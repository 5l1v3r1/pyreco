__FILENAME__ = BrowserRefresh
import os
import sys
import platform

import sublime
import sublime_plugin


# Fix windows imports
__file__ = os.path.normpath(os.path.abspath(__file__))
__path__ = os.path.dirname(__file__)

if __path__ not in sys.path:
    sys.path.insert(0, __path__)

_pywinauto = os.path.join(__path__ + os.path.sep + 'win')
if _pywinauto not in sys.path:
    sys.path.insert(0, _pywinauto)

# Cache user operating system
_os = platform.system()


class BrowserRefreshCommand(sublime_plugin.TextCommand):
    def run(self, args, activate_browser=True,
            browser_name='all', auto_save=True, delay=None):

        # Auto-save
        if auto_save and self.view and self.view.is_dirty():
            self.view.run_command('save')

        # Detect OS and import
        if _os == 'Darwin':
            from mac import MacBrowserRefresh
            from mac.utils import running_browsers
            refresher = MacBrowserRefresh(activate_browser, running_browsers())
        elif _os == 'Windows':
            from win import WinBrowserRefresh
            refresher = WinBrowserRefresh(activate_browser)
        elif _os == 'Linux':
            from linux import LinuxBrowserRefresh
            refresher = LinuxBrowserRefresh(activate_browser)
        else:
            sublime.error_message('Your operating system is not supported')

        # Delay refresh
        if delay is not None:
            import time
            time.sleep(delay)

        # Actually refresh browsers 
        if browser_name == 'Google Chrome':
            refresher.chrome()

        elif browser_name == 'Google Chrome Canary' and _os == 'Darwin':
            refresher.canary()

        elif browser_name == 'yandex' and _os == 'Darwin':
            refresher.yandex()

        elif browser_name == 'Safari':
            refresher.safari()

        elif browser_name == 'WebKit' and _os == 'Darwin':
            refresher.webkit()

        elif browser_name == 'Firefox':
            refresher.firefox()

        elif browser_name == 'Opera':
            refresher.opera()

        elif browser_name == 'IE' and _os == 'Windows':
            refresher.ie()

        elif browser_name == 'Iron' and _os == 'Windows':
            refresher.iron()
            
        elif browser_name == 'Pale Moon' and _os == 'Windows':
            refresher.palemoon()
            
        elif browser_name == 'all':
            refresher.chrome()
            refresher.safari()
            refresher.firefox()
            refresher.opera()

            if _os == 'Darwin':
                refresher.canary()
                refresher.yandex()
                refresher.webkit()

            if _os == 'Windows':
                refresher.ie()
                refresher.iron()
                refresher.palemoon()

########NEW FILE########
__FILENAME__ = utils
import subprocess
import re


def running_browsers():
    ps = check_output(['ps', 'aux'])
    running_browsers = []

    if re.search(b'Google Chrome\.app\/Contents\/MacOS\/Google Chrome', ps) is not None:
        running_browsers.append('chrome')

    if re.search(b'Google Chrome Canary\.app\/Contents\/MacOS\/Google Chrome Canary', ps) is not None:
        running_browsers.append('canary')

    if re.search(b'Yandex\.app', ps) is not None:
        running_browsers.append('yandex')

    if re.search(b'Firefox\.app', ps) is not None:
        running_browsers.append('firefox')

    if re.search(b'com\.apple\.WebKit\.WebContent\n', ps) is not None or \
        re.search(b'Safari.app\/Contents\/MacOS\/Safari\ ', ps) is not None:
            running_browsers.append('safari')

    if re.search(b'com\.apple\.WebKit\.WebContent\.Development', ps) is not None or \
        re.search(b'Safari\.app\/Contents\/MacOS\/SafariForWebKitDevelopment', ps) is not None:
            running_browsers.append('webkit')

    if re.search(b'Opera\.app', ps) is not None:
        running_browsers.append('opera')

    return running_browsers


# Got this from http://stackoverflow.com/a/2924457/124852
def check_output(*popenargs, **kwargs):
    if 'stdout' in kwargs:
        raise ValueError('stdout argument not allowed, it will be overridden.')
    process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
    output, unused_err = process.communicate()
    retcode = process.poll()
    if retcode:
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = popenargs[0]
        raise subprocess.CalledProcessError(retcode, cmd, output=output)
    return output


class CalledProcessError(Exception):
    def __init__(self, returncode, cmd, output=None):
        self.returncode = returncode
        self.cmd = cmd
        self.output = output

    def __str__(self):
        return "Command '%s' returned non-zero exit status %d" % (
            self.cmd, self.returncode)
# overwrite CalledProcessError due to `output` keyword might be not available
subprocess.CalledProcessError = CalledProcessError


if __name__ == '__main__':
    print(running_browsers())

########NEW FILE########
__FILENAME__ = application
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""The application module is the main one that users will user first.

When starting to automate and application you must initialize an instance
of the Application class. Then you must :func:`Application.Start` that
application or :func:`Application.Connect()` to a running instance of that
application.

Once you have an Application instance you can access dialogs in that
application either by using one of the methods below. ::

   dlg = app.YourDialogTitle
   dlg = app.ChildWindow(title = "your title", classname = "your class", ...)
   dlg = app['Your Dialog Title']

Similarly once you have a dialog you can get a control from that dialog
in almost exactly the same ways. ::

  ctrl = dlg.YourControlTitle
  ctrl = dlg.ChildWindow(title = "Your control", classname = "Button", ...)
  ctrl = dlg["Your control"]

.. note::

   For attribute access of controls and dialogs you do not have to
   have the title of the control exactly, it does a best match of the
   avialable dialogs or controls.

.. seealso::

  :func:`pywinauto.findwindows.find_windows` for the keyword arguments that
  can be passed to both :func:`Application.Window` and
  :func:`WindowSpecification.Window`

"""

__revision__ = "$Revision: 738 $"

import time
import os.path
##import os
import warnings
import pickle

import ctypes

from . import win32structures
from . import win32functions
from . import win32defines
from . import controls
from . import findbestmatch
from . import findwindows
from . import handleprops

from .timings import Timings, WaitUntil, TimeoutError, WaitUntilPasses


class AppStartError(Exception):
    "There was a problem starting the Application"
    pass    #pragma: no cover

class ProcessNotFoundError(Exception):
    "Could not find that process"
    pass    #pragma: no cover

class AppNotConnected(Exception):
    "Application has been connected to a process yet"
    pass    #pragma: no cover


#wait_method_deprecation = "Wait* functions are just simple wrappers around " \
#    "Wait() or WaitNot(), so they may be removed in the future!"

#=========================================================================
class WindowSpecification(object):
    """A specificiation for finding a window or control

    Windows are resolved when used.
    You can also wait for existance or non existance of a window
    """

    def __init__(self, search_criteria):
        """Initailize the class

        * **search_criteria** the criteria to match a dialog
        """

        # kwargs will contain however to find this window
        self.criteria = [search_criteria, ]


    def __call__(self, *args, **kwargs):
        "No __call__ so return a usefull error"

        if "best_match" in self.criteria[-1]:
            raise AttributeError(
                "WindowSpecification class has no '%s' method" %
                self.criteria[-1]['best_match'])

        message = (
            "You tried to execute a function call on a WindowSpecification "
            "instance. You probably have a typo for one of the methods of "
            "this class.\n"
            "The criteria leading up to this is: " + str(self.criteria))

        raise AttributeError(message)


    def WrapperObject(self):
        "Allow the calling code to get the HwndWrapper object"

        ctrls = _resolve_control(self.criteria)

        return ctrls[-1]

    def ChildWindow(self, **criteria):
        """Add criteria for a control

        When this window specification is resolved then this will be used
        to match against a control."""

        # default to non top level windows because we are usualy
        # looking for a control
        if 'top_level_only' not in criteria:
            criteria['top_level_only'] = False

        new_item = WindowSpecification(self.criteria[0])
        new_item.criteria.append(criteria)

        return new_item
        
    def Window_(self, **criteria):
        warnings.warn(
            "WindowSpecification.Window() WindowSpecification.Window_(), "
            "WindowSpecification.window() and WindowSpecification.window_() "
            "are deprecated, please switch to WindowSpecification.ChildWindow()",
            DeprecationWarning)
        return self.ChildWindow(**criteria)
    window_ = Window_
    Window = Window_

    def __getitem__(self, key):
        """Allow access to dialogs/controls through item access

        This allows::

            app.['DialogTitle']['ControlTextClass']

        to be used to access dialogs and controls.

        Both this and :func:`__getattr__` use the rules outlined in the
        HowTo document.
        """

        # if we already have 2 levels of criteria (dlg, control)
        # then resolve the control and do a getitem on it for the
        if len(self.criteria) == 2:

            ctrls = _resolve_control(self.criteria)

            # try to return a good error message if the control does not
            # have a __getitem__() method)
            if hasattr(ctrls[-1], '__getitem__'):
                return ctrls[-1][key]
            else:
                message = "The control does not have a __getitem__ method " \
                    "for item access (i.e. ctrl[key]) so maybe you have " \
                    "requested this in error?"

                raise AttributeError(message)

        # if we get here then we must have only had one criteria so far
        # so create a new :class:`WindowSpecification` for this control
        new_item = WindowSpecification(self.criteria[0])

        # add our new criteria
        new_item.criteria.append({"best_match" : key})

        return new_item


    def __getattr__(self, attr):
        """Attribute access for this class

        If we already have criteria for both dialog and control then
        resolve the control and return the requested attribute.

        If we have only criteria for the dialog but the attribute
        requested is an attribute of DialogWrapper then resolve the
        dialog and return the requested attribute.

        Otherwise delegate functionality to :func:`__getitem__` - which
        sets the appropriate criteria for the control.
        """

        # dir (and possibly other code introspection asks for 
        # members like __methods__ and __members__, these are deprecated and I 
         #am not using them so just raise an attribute error immediately
        if attr.startswith("__") or attr.endswith("__"):
            raise AttributeError(
                "Application object has no attribute '%s'"% attr)

        from pywinauto.controls.win32_controls import DialogWrapper

        # if we already have 2 levels of criteria (dlg, conrol)
        # this third must be an attribute so resolve and get the
        # attribute and return it
        if len(self.criteria) == 2:

            ctrls = _resolve_control(self.criteria)

            return getattr(ctrls[-1], attr)

        else:
            # if we have been asked for an attribute of the dialog
            # then resolve the window and return the attribute
            if len(self.criteria) == 1 and hasattr(DialogWrapper, attr):

                ctrls = _resolve_control(self.criteria)

                return getattr(ctrls[-1], attr)

        # It is a dialog/control criterion so let getitem
        # deal with it
        return self[attr]


    def Exists(self, timeout = None, retry_interval = None):
        "Check if the window exists"

        # set the current timings -couldn't set as defaults as they are
        # evaluated at import time - and timings may be changed at any time
        if timeout is None:
            timeout = Timings.exists_timeout
        if retry_interval is None:
            retry_interval = Timings.exists_retry


        # modify the criteria as Exists should look for all
        # windows - including not visible and disabled
        exists_criteria = self.criteria[:]
        for criterion in exists_criteria:
            criterion['enabled_only'] = False
            criterion['visible_only'] = False

        try:
            _resolve_control(
                exists_criteria, timeout, retry_interval)

            return True
        except (
            findwindows.WindowNotFoundError,
            findbestmatch.MatchError,
            controls.InvalidWindowHandle):
            return False


    def Wait(self,
            wait_for,
            timeout = None,
            retry_interval = None):

        """Wait for the window to be in a particular state

        * **wait_for** The state to wait for the window to be in. It can be any
          of the following states

            * 'exists' means that the window is a valid handle
            * 'visible' means that the window is not hidden
            * 'enabled' means that the window is not disabled
            * 'ready' means that the window is visible and enabled
            * 'active' means that the window is visible and enabled

        * **timeout** Raise an error if the window is not in the appropriate
          state after this number of seconds.

        * **retry_interval** How long to sleep between each retry

        An example to wait until the dialog
        exists, is ready, enabled and visible

           self.Dlg.Wait("exists enabled visible ready")

        .. seealso::

           :func:`WindowSpecification.WaitNot()`
        """

        # set the current timings -couldn't set as defaults as they are
        # evaluated at import time - and timings may be changed at any time
        if timeout is None:
            timeout = Timings.exists_timeout
        if retry_interval is None:
            retry_interval = Timings.window_find_retry

        # allow for case mixups - just to make it easier to use
        waitfor = wait_for.lower()

        # make a copy of the criteria that we can modify
        wait_criteria = self.criteria[:]

        # update the criteria based on what has been requested
        # we go from least strict to most strict in case the user
        # has specified conflicting wait conditions
        for criterion in wait_criteria:
            
            # default is that it 'exists' and for exists
            # we must not filter for enabled only or visible only (window
            # can exist even if invisible or disabled)
            criterion['enabled_only'] = False
            criterion['visible_only'] = False
            if 'exists' in waitfor:
                pass

            if 'visible' in waitfor:
                criterion['visible_only'] = True

            if 'enabled' in waitfor:
                criterion['enabled_only'] = True

            if 'ready' in waitfor:
                criterion['visible_only'] = True
                criterion['enabled_only'] = True

            if 'active' in waitfor:
                criterion['active_only'] = True

        ctrls = _resolve_control(wait_criteria, timeout, retry_interval)

        return ctrls[-1]

    def WaitNot(self,
            wait_for_not,
            timeout = None,
            retry_interval = None):

        """Wait for the window to not be in a particular state

        * **wait_for** The state to wait for the window to not be in. It can be any
          of the following states

            * 'exists' means that the window is a valid handle
            * 'visible' means that the window is not hidden
            * 'enabled' means that the window is not disabled
            * 'ready' means that the window is visible and enabled
            * 'active' means that the window is visible and enabled

        * **timeout** Raise an error if the window is sill in the
          state after this number of seconds.(Optional)
        * **wiat_interval** How long to sleep between each retry (Optional)

        e.g. self.Dlg.WaitNot("exists enabled visible ready")

        .. seealso::

           :func:`WindowSpecification.Wait()`
        """

        # set the current timings -couldn't set as defaults as they are
        # evaluated at import time - and timings may be changed at any time
        if timeout is None:
            timeout = Timings.window_find_timeout
        if retry_interval is None:
            retry_interval = Timings.window_find_retry

        ## remember the start time so we can do an accurate wait for the timeout
        #start = time.time()

        waitnot_criteria = self.criteria[:]
        for criterion in waitnot_criteria:
            criterion['enabled_only'] = False
            criterion['visible_only'] = False

        wait_for_not = wait_for_not.lower()


        def WindowIsNotXXX():
            """Local function that returns False if the window is not
            Visible, etc. Otherwise returns the best matching control"""

            # first check if the window doesn't exist, because if it doesn't
            # exist, it definitely can't be visible, active enabled or ready
            try:
                ctrls = _resolve_control(waitnot_criteria, 0, .01)
                # if we get here - then the window exists and we need to
                # do the other checks below

            except (
                findwindows.WindowNotFoundError,
                findbestmatch.MatchError,
                controls.InvalidWindowHandle):
                # Window doesn't exist
                return True

            if 'exists' in wait_for_not:
                # well if we got here then the control must have
                # existed so we are not ready to stop checking
                # because we didn't want the control to exist!
                return ctrls

            if 'ready' in wait_for_not:
                if ctrls[-1].IsVisible() and ctrls[-1].IsEnabled():
                    return ctrls

            if 'enabled' in wait_for_not:
                if ctrls[-1].IsEnabled():
                    return ctrls

            if 'visible' in wait_for_not:
                if ctrls[-1].IsVisible():
                    return ctrls

            return True

        try:
            wait_val = WaitUntil(timeout, retry_interval, WindowIsNotXXX)
        except TimeoutError as e:
            raise RuntimeError(
                "Timed out while waiting for window (%s - '%s') "
                "to not be in '%s' state"% (
                    e.function_value[-1].Class(),
                    e.function_value[-1].WindowText(),
                    "', '".join( wait_for_not.split() ) )
                )


    def _ctrl_identifiers(self):

        ctrls = _resolve_control(
            self.criteria)

        if ctrls[-1].IsDialog():
            # dialog controls are all the control on the dialog
            dialog_controls = ctrls[-1].Children()

            ctrls_to_print = dialog_controls[:]
            # filter out hidden controls
            ctrls_to_print = [
                ctrl for ctrl in ctrls_to_print if ctrl.IsVisible()]
        else:
            dialog_controls = ctrls[-1].TopLevelParent().Children()
            ctrls_to_print = [ctrls[-1]]

        # build the list of disambiguated list of control names
        name_control_map = findbestmatch.build_unique_dict(dialog_controls)

        # swap it around so that we are mapped off the controls
        control_name_map = {}
        for name, ctrl in list(name_control_map.items()):
            control_name_map.setdefault(ctrl, []).append(name)

        return control_name_map

    def PrintControlIdentifiers(self):
        """Prints the 'identifiers'

        If you pass in a control then it just prints the identifiers
        for that control

        If you pass in a dialog then it prints the identiferis for all
        controls in the dialog

        :Note: The identifiers printed by this method have not been made
               unique. So if you have 2 edit boxes, they will both have "Edit"
               listed in their identifiers. In reality though the first one
               can be refered to as "Edit", "Edit0", "Edit1" and the 2nd
               should be refered to as "Edit2".
        """

        #name_control_map = self._ctrl_identifiers()
        ctrls = _resolve_control(
            self.criteria)

        if ctrls[-1].IsDialog():
            # dialog controls are all the control on the dialog
            dialog_controls = ctrls[-1].Children()

            ctrls_to_print = dialog_controls[:]
            # filter out hidden controls
            ctrls_to_print = [
                ctrl for ctrl in ctrls_to_print if ctrl.IsVisible()]
        else:
            dialog_controls = ctrls[-1].TopLevelParent().Children()
            ctrls_to_print = [ctrls[-1]]

        # build the list of disambiguated list of control names
        name_control_map = findbestmatch.build_unique_dict(dialog_controls)

        # swap it around so that we are mapped off the controls
        control_name_map = {}
        for name, ctrl in list(name_control_map.items()):
            control_name_map.setdefault(ctrl, []).append(name)

        print("Control Identifiers:")
        for ctrl in ctrls_to_print:

            print("%s - '%s'   %s"% (
                ctrl.Class(),
                ctrl.WindowText().encode("unicode-escape"),
                str(ctrl.Rectangle())))

            print("\t", end=' ')
            names = control_name_map[ctrl]
            names.sort()
            for name in names:
                print("'%s'" % name.encode("unicode_escape"), end=' ')
            print()


#        for ctrl in ctrls_to_print:
#            print "%s - '%s'   %s"% (
#                ctrl.Class(), ctrl.WindowText(), str(ctrl.Rectangle()))
#
#            print "\t",
#            for text in findbestmatch.get_control_names(
#                ctrl, dialog_controls):
#
#                print "'%s'" % text.encode("unicode_escape"),
#            print

    print_control_identifiers = PrintControlIdentifiers


def _get_ctrl(criteria_):
    "Get the control based on the various criteria"

    # make a copy of the criteria
    criteria = [crit.copy() for crit in criteria_]

    # find the dialog
    dialog = controls.WrapHandle(
        findwindows.find_window(**criteria[0]))

    ctrl = None
    # if there is only criteria for a dialog then return it
    if len(criteria) > 1:
        # so there was criteria for a control, add the extra criteria
        # that are required for child controls
        ctrl_criteria = criteria[1]
        ctrl_criteria["top_level_only"] = False
        ctrl_criteria["parent"] = dialog.handle

        # resolve the control and return it
        ctrl = controls.WrapHandle(
            findwindows.find_window(**ctrl_criteria))

    if ctrl:
        return (dialog, ctrl)
    else:
        return (dialog, )

cur_item = 0

def _resolve_from_appdata(
    criteria_, app, timeout = None, retry_interval = None):
    "Should not be used at the moment!"

    if timeout is None:
        timeout = Timings.window_find_timeout
    if retry_interval is None:
        retry_interval = Timings.window_find_retry

    global cur_item
    # get the stored item corresponding to this request
    matched_control = app.GetMatchHistoryItem(cur_item)

    cur_item += 1
    # remove parameters from the original search  that changes each time
    criteria = [crit.copy() for crit in criteria_]

    # Remove any attributes from the current search that are
    # completely language dependent
    for unloc_attrib in ['title_re', 'title', 'best_match']:
        for c in criteria:
            if unloc_attrib in c:
                del c[unloc_attrib]


    #found_criteria = item[0]
    #for c in found_criteria:
    #    if c.has_key('process'):
    #        del c['process']
    #
    # They should match - so if they don't print it out.
    #if found_criteria != search_criteria:
    #    print "\t\t", matched[cur_index - 3][0]
    #    print "\t" ,matched[cur_index - 2][0]
    #    print search_criteria
    #    print "---"
    #    print found_criteria
    #    raise RuntimeError("Mismatch")

    # so let's use the ID from the matched control...
    #print item[1]

    # we need to try and get a good match for the dialog
    # this could be done by matching
    # - number/positoin of controls
    # - class
    # anything else?

    dialog_criterion = criteria[0]
    #print list(matched_control)
    dialog_criterion['class_name'] = matched_control[1]['Class']

    # find all the windows in the process
    process_hwnds = findwindows.find_windows(**dialog_criterion)

    dialog = None
    ctrl = None
    if len(process_hwnds) >= 1:

        similar_child_count = [h for h in process_hwnds
            if matched_control[1]['ControlCount'] -2 <=
                    len(handleprops.children(h)) and
                matched_control[1]['ControlCount'] +2 >=
                    len(handleprops.children(h))]

        if len(similar_child_count) == 0:
            #print "None Similar child count!!???"
            #print matched_control[1]['ControlCount'], \
            #    len(handleprops.children(h))
            pass
        else:
            process_hwnds = similar_child_count

        for h in process_hwnds:
            #print controls.WrapHandle(h).GetProperties()
            #print "======", h, h, h

            dialog = controls.WrapHandle(h)

            # if a control was specified also
            if len(criteria_) > 1:
                # find it in the original data
                #print item[2]

                # remove those criteria which are langauge specific
                ctrl_criterion = criteria[1]

                #def has_same_id(other_ctrl):
                #    print "==="*20
                #    print "testing", item[2]['ControlID'],
                #    print "against", other_ctrl
                #    return item[2]['ControlID'] == \
                #    handleprops.controlid(other_ctrl)

                ctrl_criterion['class_name'] = matched_control[2]['Class']
                ctrl_criterion['parent'] = dialog.handle
                ctrl_criterion['top_level_only'] = False
                #ctrl_criterion['predicate_func'] = has_same_id
                #print "CTRLCTRJL", ctrl_criterion
                ctrl_hwnds = findwindows.find_windows(**ctrl_criterion)

                if len(ctrl_hwnds) > 1:
                    same_ids = \
                        [hwnd for hwnd in ctrl_hwnds
                            if handleprops.controlid(hwnd) == \
                                matched_control[2]['ControlID']]

                    if len(same_ids) >= 1:
                        ctrl_hwnds = same_ids

                try:
                    ctrl = controls.WrapHandle(ctrl_hwnds[0])
                except IndexError:
                    print("-+-+=_" * 20)
                    print(found_criteria)
                    raise

                break



    # it is possible that the dialog will not be found - so we
    # should raise an error
    if dialog is None:
        raise findwindows.WindowNotFoundError()

    if len(criteria_) == 2 and ctrl is None:
        raise findwindows.WindowNotFoundError()

    if ctrl:
        return dialog, ctrl
    else:
        return (dialog, )

    #print process_hwnds


##
##        # if best match was specified for the dialog
##        # then we need to replace it with other values
##        # for now we will just use Class
##        for crit in ['best_match', 'title', 'title_re']:
##            if crit in criteria[0]:
##                del(criteria[0][crit])
##                criteria[0]['class_name'] = app_data[0].Class()#['Class']
##
##            if len(criteria) > 1:
##                # find the best match of the application data
##                if criteria[1].has_key('best_match'):
##                    best_match = findbestmatch.find_best_control_matches(
##                        criteria[1]['best_match'], app_data)[0]
##
##                    #visible_controls = [ctrl in app_data if ctrl.IsVisible()]
##
##                    #find the index of the best match item
##                    ctrl_index = app_data.index(best_match)
##                    #print best_match[0].WindowText()
##                    ctrl_index, best_match.WindowText()
##
##                    criteria[1]['ctrl_index'] = ctrl_index -1
##                    #criteria[1]['class_name'] = best_match.Class()
##                    #del(criteria[1]['best_match'])
##
## One idea here would be to run the new criteria on the app_data dialog and
## if it returns more then one control then you figure out which one would be
## best - so that you have that info when running on the current dialog
##
##            #for criterion in criteria[1:]:
##                # this part is weird - we now have to go off and find the
##                # index, class, text of the control in the app_data
##                # and then find the best match for this control in the
##                # current dialog
##            #    pass
##
##

#    dialog = None

    #return _resolve_control(criteria_, timeout, retry_interval)




def _resolve_control(criteria, timeout = None, retry_interval = None):
    """Find a control using criteria

    * **criteria** - a list that contains 1 or 2 dictionaries

         1st element is search criteria for the dialog

         2nd element is the search criteria for a control of the dialog

    * **timeout** -  maximum length of time to try to find the controls (default 0)
    * **retry_interval** - how long to wait between each retry (default .2)
    """

    start = time.time()

    if timeout is None:
        timeout = Timings.window_find_timeout
    if retry_interval is None:
        retry_interval = Timings.window_find_retry


    try:
        ctrl = WaitUntilPasses(
            timeout,
            retry_interval,
            _get_ctrl,
            (findwindows.WindowNotFoundError,
            findbestmatch.MatchError,
            controls.InvalidWindowHandle),
            criteria)

    except TimeoutError as e:
        raise e.original_exception

    return ctrl


#=========================================================================
class Application(object):
    "Represents an application"

    def __init__(self, datafilename = None):
        "Set the attributes"
        self.process = None
        self.xmlpath = ''

        self.match_history = []
        self.use_history = False

        # load the match history if a file was specifed
        # and it exists
        if datafilename and os.path.exists(datafilename):
            datafile = open(datafilename, "rb")
            self.match_history = pickle.load(datafile)
            datafile.close()
            self.use_history = True

    def __start(*args, **kwargs):
        "Convenience static method that calls start"
        warnings.warn(
            "Class/Static methods Application.start(), application.start() "
            "are deprecated, please switch to instance method connect_. "
            "Please note that in a future release that start_() will be "
            "renamed to Start().",
            DeprecationWarning)
        warnings.warn(
            "Class/StaticMethods Start, start deprecated, please switch "
            "to instance method Start",
            DeprecationWarning)
        return Application().start_(*args, **kwargs)
    start = staticmethod(__start)
    Start = start

    def __connect(*args, **kwargs):
        "Convenience static method that calls connect"
        warnings.warn(
            "Class/Static methods Application.Connect(), application.connect() "
            "are deprecated, please switch to instance method connect_. "
            "Please note that in a future release that connect_() will be "
            "renamed to Connect().",
            DeprecationWarning)
        return Application().connect_(*args, **kwargs)
    connect = staticmethod(__connect)
    Connect = connect

    def start_(self, cmd_line, timeout = None, retry_interval = None):
        "Starts the application giving in cmd_line"

        if timeout is None:
            timeout = Timings.app_start_timeout
        if retry_interval is None:
            retry_interval = Timings.app_start_retry

        start_info = win32structures.STARTUPINFOW()
        start_info.sb = ctypes.sizeof(start_info)

        proc_info = win32structures.PROCESS_INFORMATION()

        # we need to wrap the command line as it can be modified
        # by the function
        command_line = ctypes.c_wchar_p(str(cmd_line))

        # Actually create the process
        ret = win32functions.CreateProcess(
            0, 					# module name
            command_line,		# command line
            0, 					# Process handle not inheritable.
            0, 					# Thread handle not inheritable.
            0, 					# Set handle inheritance to FALSE.
            0, 					# No creation flags.
            0, 					# Use parent's environment block.
            0,  				# Use parent's starting directory.
            ctypes.byref(start_info),# Pointer to STARTUPINFO structure.
            ctypes.byref(proc_info)) # Pointer to PROCESS_INFORMATION structure

        # if it failed for some reason
        if not ret:
            message = ('Could not create the process "%s"\n'
                'Error returned by CreateProcess: %s')% (
                    cmd_line, ctypes.WinError())
            raise AppStartError(message)

        self.process = proc_info.dwProcessId


        def AppIdle():
            "Return true when the application is ready to start"
            result = win32functions.WaitForInputIdle(
                proc_info.hProcess, int(timeout * 1000))

            # wait completed successfully
            if result == 0:
                return True

            # the wait returned because it timed out
            if result == win32defines.WAIT_TIMEOUT:
                return False

            return bool(self.windows_())

        # Wait until the application is ready after starting it
        try:
            WaitUntil(timeout, retry_interval, AppIdle)
        except TimeoutError:
            pass

        return self

    Start_ = start_

    def connect_(self, **kwargs):
        "Connects to an already running process"

        connected = False
        if 'process' in kwargs:
            self.process = kwargs['process']
            AssertValidProcess(self.process)
            connected = True

        elif 'handle' in kwargs:

            if not handleprops.iswindow(kwargs['handle']):
                message = "Invalid handle 0x%x passed to connect_()"% (
                    kwargs['handle'])
                raise RuntimeError(message)

            self.process = handleprops.processid(kwargs['handle'])

            connected = True

        elif 'path' in kwargs:
            self.process = process_from_module(kwargs['path'])
            connected = True

        elif kwargs:
            handle = findwindows.find_window(**kwargs)
            self.process = handleprops.processid(handle)
            connected = True

        if not connected:
            raise RuntimeError(
                "You must specify one of process, handle or path")

        return self
    Connect_ = connect_

    
    def top_window_(self):
        "Return the current top window of the application"
        if not self.process:
            raise AppNotConnected("Please use start_ or connect_ before "
                "trying anything else")

        time.sleep(Timings.window_find_timeout)
        # very simple
        windows = findwindows.find_windows(process = self.process)

        if not windows:
            raise RuntimeError("No windows for that process could be found")

        criteria = {}
        criteria['handle'] = windows[0]

        return WindowSpecification(criteria)

    def active_(self):
        "Return the active window of the application"
        if not self.process:
            raise AppNotConnected("Please use start_ or connect_ before "
                "trying anything else")

        time.sleep(Timings.window_find_timeout)
        # very simple
        windows = findwindows.find_windows(
            process = self.process, active_only = True)

        if not windows:
            raise RuntimeError("No Windows of that application are active")

        criteria = {}
        criteria['handle'] = windows[0]

        return WindowSpecification(criteria)


    def windows_(self, **kwargs):
        """Return list of wrapped windows of the top level windows of
        the application
        """

        if not self.process:
            raise AppNotConnected("Please use start_ or connect_ before "
                "trying anything else")

        if 'visible_only' not in kwargs:
            kwargs['visible_only'] = False

        if 'enabled_only' not in kwargs:
            kwargs['enabled_only'] = False

        kwargs['process'] = self.process

        windows = findwindows.find_windows(**kwargs)

        return [controls.WrapHandle(win) for win in windows]

    Windows_ = windows_


    def window_(self, **kwargs):
        """Return a window of the application

        You can specify the same parameters as findwindows.find_windows.
        It will add the process parameter to ensure that the window is from
        the current process.
        """

        if not self.process:
            win_spec = WindowSpecification(kwargs)
            self.process = win_spec.WrapperObject().ProcessID()
        # add the restriction for this particular process
        else:
            kwargs['process'] = self.process

            win_spec = WindowSpecification(kwargs)

        return win_spec
    Window_ = window_

    def __getitem__(self, key):
        "Find the specified dialog of the application"

        # delegate searching functionality to self.window_()
        return self.window_(best_match = key)

    def __getattr__(self, key):
        "Find the spedified dialog of the application"

        # dir (and possibly other code introspection asks for the following
        # members, these are deprecated and I am not using them so just
        # raise an attribute error immediately
        if key.startswith("__") or key.endswith("__"):
            raise AttributeError(
                "Application object has no attribute '%s'"% key)

        # delegate all functionality to item access
        return self[key]

    def WriteAppData(self, filename):
        "Should not be used - part of application data implementation"
        f = open(filename, "wb")
        pickle.dump(self.match_history, f)
        f.close()

    def GetMatchHistoryItem(self, index):
        "Should not be used - part of application data implementation"
        return self.match_history[index]


    def Kill_(self):
        """Try and kill the application

        Dialogs may pop up asking to save data - but the application
        will be killed anyway - you will not be able to click the buttons.
        this should only be used
        """

        windows = self.windows_(visible_only = True)
        #ok_to_kill = True

        for win in windows:

            #t = threading.Thread(target = OKToClose, args = (win) )

            #t.start()

            #time.sleep(.2)
            #win.Close()

            #while t.isAlive() and not forcekill:
            #    time.sleep(.5)


            win.SendMessageTimeout(
                win32defines.WM_QUERYENDSESSION,
                timeout = .5,
                timeoutflags = (win32defines.SMTO_ABORTIFHUNG)) # |
                    #win32defines.SMTO_NOTIMEOUTIFNOTHUNG)) # |
                    #win32defines.SMTO_BLOCK)

            try:
                win.Close()
            except TimeoutError:
                pass
            #print `ok_to_kill`, win.Texts()

        #print `ok_to_kill`
#        if ok_to_kill:
#            for win in windows:
#                print "\tclosing:", win.Texts()
#                self.windows_()[0].Close()
#        elif not forcekill:
#            return False

        # window has let us know that it doesn't want to die - so we abort
        # this means that the app is not hung - but knows it doesn't want
        # to close yet - e.g. it is asking the user if they want to save
        #if not forcekill:
        #    return False

        #print "supposedly closed all windows!"

        # so we have either closed the windows - or the app is hung

        # get a handle we can wait on
        process_wait_handle = win32functions.OpenProcess(
            win32defines.SYNCHRONIZE | win32defines.PROCESS_TERMINATE ,
            False,
            self.process)

        killed = True
        if process_wait_handle:

            # wait for the window to close
            win32functions.WaitForSingleObject(
                process_wait_handle,
                Timings.after_windowclose_timeout * 1000)

            #if forcekill:
            win32functions.TerminateProcess(process_wait_handle, 0)
            #else:
            #    killed = False

        win32functions.CloseHandle(process_wait_handle)

        return killed

    kill_ = Kill_

#
#
#def OKToClose(window):
#    return_val = bool(window.SendMessageTimeout(
#        win32defines.WM_QUERYENDSESSION,
#        timeout = 1000,
#        timeoutflags = win32defines.SMTO_ABORTIFHUNG))# |
#
#    print "2343242343242"  * 100
#
#    return return_val




#=========================================================================
def AssertValidProcess(process_id):
    "Raise ProcessNotFound error if process_id is not a valid process id"
    # Set instance variable _module if not already set
    process_handle = win32functions.OpenProcess(
        0x400 | 0x010, 0, process_id) # read and query info

    if not process_handle:
        message = "Process with ID '%d' could not be opened" % process_id
        raise ProcessNotFoundError(message)

    return process_handle

#=========================================================================
def process_module(process_id):
    "Return the string module name of this process"
    process_handle = AssertValidProcess(process_id)

    # get module name from process handle
    filename = (ctypes.c_wchar * 2000)()
    win32functions.GetModuleFileNameEx(
        process_handle, 0, ctypes.byref(filename), 2000)

    # return the process value
    return filename.value

#=========================================================================
def process_from_module(module):
    "Return the running process with path module"

    # set up the variable to pass to EnumProcesses
    processes = (ctypes.c_int * 2000)()
    bytes_returned = ctypes.c_int()

    # collect all the running processes
    ctypes.windll.psapi.EnumProcesses(
        ctypes.byref(processes),
        ctypes.sizeof(processes),
        ctypes.byref(bytes_returned))

    modules = []
    # Get the process names
    for i in range(0, bytes_returned.value // ctypes.sizeof(ctypes.c_int)):
        try:
            modules.append((processes[i], process_module(processes[i])))
        except ProcessNotFoundError:
            pass

    # check for a module with a matching name in reverse order
    # as we are most likely to want to connect to the last
    # run instance
    modules.reverse()
    for process, name in modules:
        if module.lower() in name.lower():
            return process

#    # check if any of the running process has this module
#    for i in range(0, bytes_returned.value / ctypes.sizeof(ctypes.c_int)):
#        try:
#            p_module = process_module(processes[i]).lower()
#            if module.lower() in p_module:
#                return processes[i]
#

    message = "Could not find any process with a module of '%s'" % module
    raise ProcessNotFoundError(message)

#
#def WaitForDialog(dlg):
#    waited = 0
#    timeout = 10
#    app = None
#    while not app and waited <= timeout:
#        try:
#            app = Application.connect(best_match = dlg)
#        except Exception, e:
#            time.sleep(1)
#            waited += 1
#
#    if app is None:
#        raise RuntimeError("Window not found: '%s'"%dlg)
#    return app, app[dlg]

########NEW FILE########
__FILENAME__ = clipboard
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Some clipboard wrapping functions - more to be added later"

__revision__ = "$Revision: 726 $"

import ctypes

from . import win32functions
from . import win32defines

#from ctypes.wintypes import *


#====================================================================
def _get_standard_formats():
    "Get the known formats by looking in win32defines"
    formats = {}
    for define_name in list(win32defines.__dict__.keys()):
        if define_name.startswith("CF_"):
            formats[getattr(win32defines, define_name)] = define_name
    return formats

# get all the formats names keyed on the value
_standard_formats = _get_standard_formats()


#====================================================================
def GetClipboardFormats():
    "Get a list of the formats currently in the clipboard"
    if not win32functions.OpenClipboard(0):
        raise WinError()

    available_formats = []
    format = 0
    while True:
        # retrieve the next format
        format = win32functions.EnumClipboardFormats(format)

        # stop enumerating because all formats have been
        # retrieved
        if not format:
            break

        available_formats.append(format)

    win32functions.CloseClipboard()

    return available_formats


#====================================================================
def GetFormatName(format):
    "Get the string name for a format value"

    # standard formats should not be passed to GetClipboardFormatName    
    if format in _standard_formats:
        return _standard_formats[format]

    if not win32functions.OpenClipboard(0):
        raise WinError()    

    max_size = 500
    buffer_ = ctypes.create_unicode_buffer(max_size+1)

    ret = win32functions.GetClipboardFormatName(
        format, ctypes.byref(buffer_), max_size)
    
    if not ret:
        raise RuntimeError("test")
    
    win32functions.CloseClipboard()

    return buffer_.value


#====================================================================
def GetData(format = win32defines.CF_UNICODETEXT):
    "Return the data from the clipboard in the requested format"
    if format not in GetClipboardFormats():
        raise RuntimeError("That format is not available")
    
    if not win32functions.OpenClipboard(0):
        raise WinError()

    handle = win32functions.GetClipboardData(format)
    
    if not handle:
        error = ctypes.WinError()
        win32functions.CloseClipboard()
        raise error
    
    buffer_ = ctypes.c_wchar_p(win32functions.GlobalLock(handle))
    
    data = buffer_.value
    
    win32functions.GlobalUnlock(handle)

    win32functions.CloseClipboard()

    return data


#====================================================================
def EmptyClipboard():
    if not win32functions.OpenClipboard(0):
        raise RuntimeError("Couldn't open clipboard")
    win32functions.EmptyClipboard()
    win32functions.CloseClipboard()


#====================================================================
# Todo: Implement setting clipboard data
#def SetData(data, formats = [win32defines.CF_UNICODETEXT, ]):
#    pass


#====================================================================
if __name__ == "__main__":
    _unittests()
########NEW FILE########
__FILENAME__ = controlproperties
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Wrap"""

__revision__ = "$Rev: 439 $"

try:
    import pywinauto
except ImportError:
    import sys
    sys.path.append("..")

from .win32structures import RECT, LOGFONTW


#====================================================================
class func_wrapper(object):
    "Little class to allow attribute access to return a callable object"
    def __init__(self, value):
        self.value = value

    def __call__(self, *args, **kwargs):
        "Return the saved value"
        return self.value


#====================================================================
class ControlProps(dict):
    "Wrap controls read from a file to resemble hwnd controls"

    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)

        self.ref = None
        #self.MenuItems = []

    def __getattr__(self, attr):
        # if the key is not in the dictionary but the plural is
        if attr not in self and attr + "s" in self:
            # return the first element of the possible list item
            return func_wrapper(self[attr+'s'][0])

        return func_wrapper(self[attr])
    
    #def FriendlyClassName(self):
    #    print "sdafafasdfafasdfasdf",
    #    try:
    #        print "---", self['FriendlyClassName']
    #    except Exception, e:
    #        print "fffffffffffffffffffff"
    #        print `e`
    #    return self['FriendlyClassName']

    def WindowText(self):        
        return self['Texts'][0]

    def HasStyle(self, style):
        return self['Style'] & style == style

    def HasExStyle(self, exstyle):
        return self['ExStyle'] & exstyle == exstyle


#====================================================================
def GetMenuBlocks(ctrls):
    allMenuBlocks = []
    for ctrl in ctrls:
        if 'MenuItems' in ctrl:
            # we need to get all the separate menu blocks!
            menuBlocks = MenuBlockAsControls(ctrl.MenuItems())
            allMenuBlocks.extend(menuBlocks)

    return allMenuBlocks


#====================================================================
def MenuBlockAsControls(menuItems, parentage = []):

    blocks = []

    curBlock = []
    for item in menuItems:

        # do a bit of conversion first :-)
        itemAsCtrl = MenuItemAsControl(item)

        # update the FriendlyClassName to contain the 'path' to
        # this particular item
        # TODO: CHECK - as itemPath is currently unused!
        if parentage:
            itemPath = "%s->%s" % ("->".join(parentage), item['Text'])
        else:
            itemPath = item['Text']
        
        #append the item to the current menu block
        curBlock.append(itemAsCtrl)

        # If the item has a sub menu
        if 'MenuItems' in item:

            # add the current item the path
            parentage.append(item['Text'])

            # Get the block for the SubMenu, and add it to the list of
            # blocks we have found
            blocks.extend(
                MenuBlockAsControls(
                    item['MenuItems']['MenuItems'], parentage))

            # and seeing as we are dong with that sub menu remove the current
            # item from the path
            del(parentage[-1])

    # add the current block to the list of blocks
    blocks.append(curBlock)

    return blocks


#====================================================================
def MenuItemAsControl(menuItem):
    "Make a menu item look like a control for tests"

    itemAsCtrl = ControlProps()
    
    itemAsCtrl["Texts"] = [menuItem['Text'], ]
    itemAsCtrl["ControlID"] = menuItem['ID']
    itemAsCtrl["Type"] = menuItem['Type']
    itemAsCtrl["State"] = menuItem['State']

    itemAsCtrl["Class"] = "MenuItem"
    itemAsCtrl["FriendlyClassName"] = "MenuItem"

    # as most of these don't matter - just set them up with default stuff
    itemAsCtrl["Rectangle"] = RECT(0, 0, 999, 999)
    itemAsCtrl["Fonts"] = [LOGFONTW(), ]
    itemAsCtrl["ClientRects"] = [RECT(0, 0, 999, 999), ]
    itemAsCtrl["ContextHelpID"] = 0
    itemAsCtrl["UserData"]  = 0
    itemAsCtrl["Style"] = 0
    itemAsCtrl["ExStyle"] = 0
    itemAsCtrl["IsVisible"] = 1

    return itemAsCtrl
    

#====================================================================
def SetReferenceControls(controls, refControls):
    """Set the reference controls for the controls passed in
    
    This does some minor checking as following:
     * test that there are the same number of reference controls as 
       controls - fails with an exception if there are not
     * test if all the ID's are the same or not
    """

    # numbers of controls must be the same (though in future I could imagine
    # relaxing this constraint)

    if len(controls) != len(refControls):
        raise RuntimeError(
            "Numbers of controls on ref. dialog does not match Loc. dialog")

    # set the controls
    for i, ctrl in enumerate(controls):
        ctrl.ref = refControls[i]

    toRet = 1
    allIDsSameFlag = 2
    allClassesSameFlag = 4

    # find if all the control id's match
    if  [ctrl.ControlID() for ctrl in controls] == \
        [ctrl.ControlID() for ctrl in refControls]:

        toRet += allIDsSameFlag

    # check if the control classes match
    if [ctrl.Class() for ctrl in controls] == \
       [ctrl.Class() for ctrl in refControls]:

        toRet += allClassesSameFlag

    return toRet



##====================================================================
#class ControlProps(dict):
#    #----------------------------------------------------------------
#    def __init__(self, props = {}):
#        # default to having menuItems for all things
#        self.MenuItems = []
#
#        self.update(props)
#        #for x in props:
#            #self[x] = props[x]
#
#        if hasattr(props, "handle"):
#            self.__dict__['handle'] = props.handle
#        else:
#            self.__dict__['handle'] = None
#
#        self.__dict__['ref'] = None
#
#    #----------------------------------------------------------------
#    # handles attribute access for dictionary items and
#    # for plurals (e.g. if self.Fonts = [4, 2] then self.Font = 4)
#    def __getattr__(self, key):
#
#        # if the key is not in the dictionary but the plural is
#        if key not in self and key + "s" in self:
#
#            # try to get the first element of the possible list item
#            try:
#                return self[key + "s"][0]
#            except TypeError, e:
#                pass
#
#        if key in self:
#            return self[key]
#
#        return self.__dict__[key]
#
#    #----------------------------------------------------------------
#    def __setattr__(self, key, value):
#        if key in self.__dict__:
#            self.__dict__[key] = value
#        else:
#            self[key] = value
#
#    #----------------------------------------------------------------
#    def HasStyle(self, flag):
#        return self.Style & flag == flag
#
#    #----------------------------------------------------------------
#    def HasExStyle(self, flag):
#        return self.ExStyle & flag == flag
#
#

########NEW FILE########
__FILENAME__ = Accessability HwndWrapper
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Basic wrapping of Windows controls"

__revision__ = "$Revision: 681 $"

# pylint:  disable-msg=W0611

import time
import re
import ctypes

# the wrappers may be used in an environment that does not need
# the actions - as such I don't want to require sendkeys - so
# the following makes the import optional.
import SendKeysCtypes as SendKeys

# I leave this optional because PIL is a large dependency
try:
    import PIL.ImageGrab
except ImportError:
    PIL.ImageGrab = None

from pywinauto import win32defines
from pywinauto import win32functions
from pywinauto import win32structures
from pywinauto.timings import Timings

#from pywinauto import findbestmatch
from pywinauto import handleprops

# also import MenuItemNotEnabled so that it is
# accessible from HwndWrapper module
from .menuwrapper import Menu #, MenuItemNotEnabled



def FindAccessabilityMenu(handle):
    from pyia import accessibleObjectFromWindow
    ao = accessibleObjectFromWindow(handle)
    menu = None
    
    def iterate_children(parent):
        for child in parent:
            
            # get the accessability role name
            try:
                role = child.accRoleName()
            except Exception as e:
                # if it doesn't have a role name - then it is not a Menu
                # and it can be skipped
                continue
            
            # get the accessability name
            try:
                name = child.accName()
            except Exception as e:
                name = ""
                
            # get how many children there are
            try:
                child_count = child.accChildCount
            except Exception as e:
                name = ""
                
            if role == "menu bar" and name != "System" and child_count:
                menu = child
                break

            if child_cound:
                iterate_children(child)

    if menu:
        return AccessabilityMenu(handle, menus)
    
    return None

from . import menuwrapper

class AccessabilityMenuItem(menuwrapper.Menu):
    def __init__(self, ctrl, index, ao_item):
        self.ctrl = ctrl
        self.ao_item = ao_item
        self.index = index
    def Rectangle(self):
        return self.so_item.accLocation()
    def Index(self):
        return self.index
    def State(self):
        return 0
    def ID(self):
        return ""
    def Type(self):
        return ""
    def Text(self):
        return self.so_item.accName()
    def SubMenu(self):
        pass
    def IsEnabled(self):
        return True
    def IsChecked(self):
        return False
    def Click(self):
        self.ao_item.accDoDefaultAction()
    def Select(self):
        pass
    def __repr__(self):
        "Return a representation of the object as a string"
        return "<AOMenuItem %s>" % repr(self.Text())

        
class AccessabilityMenu(menuwrapper.Menu):
    def __init__(self, owner_handle, menu):
        self.handle = owner_handle
        self.ao_menu = menu
    
    def ItemCount(self):
        return self.ao_menu.accChildCount
    
    def Item(self, index):
        return AccessabilityMenuItem(self.ao_menu[index])
        
    def Items(self):
        pass
    
    def GetProperties(self):
        pass
    def GetMenuPath(self, path, path_items = None, appdata = None):
        pass
        
#====================================================================
class ControlNotEnabled(RuntimeError):
    "Raised when a control is not enabled"
    pass

#====================================================================
class ControlNotVisible(RuntimeError):
    "Raised when a control is nto visible"
    pass

#====================================================================
class InvalidWindowHandle(RuntimeError):
    "Raised when an invalid handle is passed to HwndWrapper "
    def __init__(self, hwnd):
        "Initialise the RuntimError parent with the mesage"
        RuntimeError.__init__(self,
            "Handle 0x%d is not a vaild window handle"% hwnd)




# metaclass that will know about
class _MetaWrapper(type):
    "Metaclass for Wrapper objects"
    re_wrappers = {}
    str_wrappers = {}

    def __init__(cls, name, bases, attrs):
        # register the class names, both the regular expression
        # or the classes directly

        #print "metaclass __init__", cls
        type.__init__(cls, name, bases, attrs)

        for win_class in cls.windowclasses:
            _MetaWrapper.re_wrappers[re.compile(win_class)] = cls
            _MetaWrapper.str_wrappers[win_class] = cls

    def FindWrapper(handle):
        """Find the correct wrapper for this handle"""
        class_name = handleprops.classname(handle)


        try:
            return _MetaWrapper.str_wrappers[class_name]
        except KeyError:
            wrapper_match = None

            for regex, wrapper in list(_MetaWrapper.re_wrappers.items()):
                if regex.match(class_name):
                    wrapper_match = wrapper
                    _MetaWrapper.str_wrappers[class_name] = wrapper

                    break

        # if it is a dialog then override the wrapper we found
        # and make it a DialogWrapper
        if handleprops.is_toplevel_window(handle):
            from . import win32_controls
            wrapper_match = win32_controls.DialogWrapper

        if wrapper_match is None:
            wrapper_match = HwndWrapper
        return wrapper_match


        #if handle in meta.wrappers:
        #    return meta.wrappers[handle]
    FindWrapper = staticmethod(FindWrapper)


#====================================================================
class HwndWrapper(object, metaclass=_MetaWrapper):
    """Default wrapper for controls.

    All other wrappers are derived from this.

    This class wraps a lot of functionality of underlying windows API
    features for working with windows.

    Most of the methods apply to every single window type. For example
    you can Click() on any window.

    Most of the methods of this class are simple wrappers around
    API calls and as such they try do the simplest thing possible.

    A HwndWrapper object can be passed directly to a ctypes wrapped
    C function - and it will get converted to a Long with the value of
    it's handle (see ctypes, _as_parameter_)"""

    friendlyclassname = None
    windowclasses = []
    handle = None
    can_be_label = False
    has_title = True

    #-----------------------------------------------------------
    def __new__(cls, handle):
        # only use the meta class to find the wrapper for HwndWrapper
        # so allow users to force the wrapper if they want
        # thanks to Raghav for finding this.
        if cls != HwndWrapper:
            obj = object.__new__(cls)
            obj.__init__(handle)
            return obj

        new_class = cls.FindWrapper(handle)
        #super(currentclass, cls).__new__(cls[, ...])"
        obj = object.__new__(new_class)
        obj.__init__(handle)
        return obj

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        """Initialize the control

        * **hwnd** is either a valid window handle or it can be an
          instance or subclass of HwndWrapper.

        If the handle is not valid then an InvalidWindowHandle error
        is raised.
        """

        # handle if hwnd is actually a HwndWrapper
        try:
            self.handle = hwnd.handle
        except AttributeError:
            self.handle = hwnd

        # verify that we have been passed in a valid windows handle
        if not win32functions.IsWindow(hwnd):
            raise InvalidWindowHandle(hwnd)

        # make it so that ctypes conversion happens correctly
        self._as_parameter_ = self.handle

        #win32functions.WaitGuiThreadIdle(self)

        # specify whether we need to grab an image of ourselves
        # when asked for properties
        self._NeedsImageProp = False

        # default to not having a reference control added
        self.ref = None

        self.appdata = None

        self._cache = {}

        # build the list of default properties to be written
        # Derived classes can either modify this list or override
        # GetProperties depending on how much control they need.
        self.writable_props = [
            'Class',
            'FriendlyClassName',
            'Texts',
            'Style',
            'ExStyle',
            'ControlID',
            'UserData',
            'ContextHelpID',
            'Fonts',
            'ClientRects',
            'Rectangle',
            'IsVisible',
            'IsUnicode',
            'IsEnabled',
            'MenuItems',
            'ControlCount',
            ]

    #-----------------------------------------------------------
    def FriendlyClassName(self):
        """Return the friendly class name for the control

        This differs from the class of the control in some cases.
        Class() is the actual 'Registered' window class of the control
        while FriendlyClassName() is hopefully something that will make
        more sense to the user.

        For example Checkboxes are implemented as Buttons - so the class
        of a CheckBox is "Button" - but the friendly class is "CheckBox"
        """
        if self.friendlyclassname is None:
            self.friendlyclassname = handleprops.classname(self)
        return self.friendlyclassname

    #-----------------------------------------------------------
    def Class(self):
        """Return the class name of the window"""
        if "class" not in self._cache:
            self._cache['class'] = handleprops.classname(self)
        return self._cache['class']

    #-----------------------------------------------------------
    def WindowText(self):
        """Window text of the control

        Quite  a few contorls have other text that is visible, for example
        Edit controls usually have an empty string for WindowText but still
        have text displayed in the edit window.
        """
        return handleprops.text(self)

    #-----------------------------------------------------------
    def Style(self):
        """Returns the style of window

        Return value is a long.

        Combination of WS_* and specific control specific styles.
        See HwndWrapper.HasStyle() to easily check if the window has a
        particular style.
        """
        return handleprops.style(self)

    #-----------------------------------------------------------
    def ExStyle(self):
        """Returns the Extended style of window

        Return value is a long.

        Combination of WS_* and specific control specific styles.
        See HwndWrapper.HasStyle() to easily check if the window has a
        particular style.
        """
        return handleprops.exstyle(self)

    #-----------------------------------------------------------
    def ControlID(self):
        """Return the ID of the window

        Only controls have a valid ID - dialogs usually have no ID assigned.

        The ID usually identified the control in the window - but there can
        be duplicate ID's for example lables in a dialog may have duplicate
        ID's.
        """
        return handleprops.controlid(self)

    #-----------------------------------------------------------
    def UserData(self):
        """Extra data associted with the window

        This value is a long value that has been associated with the window
        and rarely has useful data (or at least data that you know the use
        of).
        """
        return handleprops.userdata(self)

    #-----------------------------------------------------------
    def ContextHelpID(self):
        "Return the Context Help ID of the window"
        return handleprops.contexthelpid(self)

    #-----------------------------------------------------------
    def IsUnicode(self):
        """Whether the window is unicode or not

        A window is Unicode if it was registered by the Wide char version
        of RegisterClass(Ex).
        """
        return handleprops.isunicode(self)

    #-----------------------------------------------------------
    def IsVisible(self):
        """Whether the window is visible or not

        Checks that both the Top Level Parent (probably dialog) that
        owns this window and the window itself are both visible.

        If you want to wait for a control to become visible (or wait
        for it to become hidden) use ``Application.Wait('visible')`` or
        ``Application.WaitNot('visible')``.

        If you want to raise an exception immediately if a window is
        not visible then you can use the HwndWrapper.VerifyVisible().
        HwndWrapper.VerifyActionable() raises if the window is not both
        visible and enabled.
        """

        return handleprops.isvisible(self.TopLevelParent()) and \
            handleprops.isvisible(self)

    #-----------------------------------------------------------
    def IsEnabled(self):
        """Whether the window is enabled or not

        Checks that both the Top Level Parent (probably dialog) that
        owns this window and the window itself are both enabled.

        If you want to wait for a control to become enabled (or wait
        for it to become disabled) use ``Application.Wait('visible')`` or
        ``Application.WaitNot('visible')``.

        If you want to raise an exception immediately if a window is
        not enabled then you can use the HwndWrapper.VerifyEnabled().
        HwndWrapper.VerifyReady() raises if the window is not both
        visible and enabled.
        """
        return handleprops.isenabled(self.TopLevelParent()) and \
            handleprops.isenabled(self)

    #-----------------------------------------------------------
    def Rectangle(self):
        """Return the rectangle of window

        The rectangle is the rectangle of the control on the screen,
        coordinates are given from the top left of the screen.

        This method returns a RECT structure, Which has attributes - top,
        left, right, bottom. and has methods width() and height().
        See win32structures.RECT for more information.
        """
        return handleprops.rectangle(self)

    #-----------------------------------------------------------
    def ClientRect(self):
        """Returns the client rectangle of window

        The client rectangle is the window rectangle minus any borders that
        are not available to the control for drawing.

        Both top and left are always 0 for this method.

        This method returns a RECT structure, Which has attributes - top,
        left, right, bottom. and has methods width() and height().
        See win32structures.RECT for more information.
        """
        return handleprops.clientrect(self)

    #-----------------------------------------------------------
    def Font(self):
        """Return the font of the window

        The font of the window is used to draw the text of that window.
        It is a structure which has attributes for Font name, height, width
        etc.

        See win32structures.LOGFONTW for more information.
        """
        return handleprops.font(self)

    #-----------------------------------------------------------
    def ProcessID(self):
        """Return the ID of process that owns this window"""
        return handleprops.processid(self)

    #-----------------------------------------------------------
    def HasStyle(self, style):
        "Return True if the control has the specified sytle"
        return handleprops.has_style(self, style)

    #-----------------------------------------------------------
    def HasExStyle(self, exstyle):
        "Return True if the control has the specified extended sytle"
        return handleprops.has_exstyle(self, exstyle)

    #-----------------------------------------------------------
    def IsDialog(self):
        "Return true if the control is a top level window"

        if "isdialog" not in self._cache:
            self._cache['isdialog'] = handleprops.is_toplevel_window(self)

        return self._cache['isdialog']

    #-----------------------------------------------------------
    def Parent(self):
        """Return the parent of this control

        Note that the parent of a control is not necesarily a dialog or
        other main window. A group box may be the parent of some radio
        buttons for example.

        To get the main (or top level) window then use
        HwndWrapper.TopLevelParent().
        """

        if "parent" not in self._cache:

            parent_hwnd = handleprops.parent(self)

            if parent_hwnd:
                #return WrapHandle(parent_hwnd)

                self._cache["parent"] = HwndWrapper(parent_hwnd)
            else:
                self._cache["parent"] = None

        return self._cache["parent"]

    #-----------------------------------------------------------
    def TopLevelParent(self):
        """Return the top level window of this control

        The TopLevel parent is different from the parent in that the Parent
        is the window that owns this window - but it may not be a dialog/main
        window. For example most Comboboxes have an Edit. The ComboBox is the
        parent of the Edit control.

        This will always return a valid window handle (if the control has
        no top level parent then the control itself is returned - as it is
        a top level window already!)
        """

        if "top_level_parent" not in self._cache:

            parent = self.Parent()

            if self.IsDialog():
                self._cache["top_level_parent"] = self
                #return self

            elif not parent:
                self._cache["top_level_parent"] = self
                #return self

            elif not parent.IsDialog():
                self._cache["top_level_parent"] = parent.TopLevelParent()
                #return parent.TopLevelParent()
            else:
                self._cache["top_level_parent"] = parent
                #return parent

        return self._cache["top_level_parent"]

    #-----------------------------------------------------------
    def Texts(self):
        """Return the text for each item of this control"

        It is a list of strings for the control. It is frequently over-ridden
        to extract all strings from a control with multiple items.

        It is always a list with one or more strings:

          * First elemtent is the window text of the control
          * Subsequent elements contain the text of any items of the
            control (e.g. items in a listbox/combobox, tabs in a tabcontrol)
        """
        texts = [self.WindowText(), ]
        return texts

    #-----------------------------------------------------------
    def ClientRects(self):
        """Return the client rect for each item in this control

        It is a list of rectangles for the control. It is frequently over-ridden
        to extract all rectangles from a control with multiple items.

        It is always a list with one or more rectangles:

          * First elemtent is the client rectangle of the control
          * Subsequent elements contain the client rectangle of any items of
            the control (e.g. items in a listbox/combobox, tabs in a
            tabcontrol)
        """

        return [self.ClientRect(), ]

    #-----------------------------------------------------------
    def Fonts(self):
        """Return the font for each item in this control

        It is a list of fonts for the control. It is frequently over-ridden
        to extract all fonts from a control with multiple items.

        It is always a list with one or more fonts:

          * First elemtent is the control font
          * Subsequent elements contain the font of any items of
            the control (e.g. items in a listbox/combobox, tabs in a
            tabcontrol)
        """
        return [self.Font(), ]

    #-----------------------------------------------------------
    def Children(self):
        """Return the children of this control as a list

        It returns a list of HwndWrapper (or subclass) instances, it
        returns an empty list if there are no children.
        """

        child_windows = handleprops.children(self)
        return [HwndWrapper(hwnd) for hwnd in child_windows]

    #-----------------------------------------------------------
    def ControlCount(self):
        "Return the number of children of this control"

        return len(handleprops.children(self))

    #-----------------------------------------------------------
    def IsChild(self, parent):
        """Return True if this window is a child of 'parent'.

        A window is a child of another window when it is a direct of the
        other window. A window is a direct descendant of a given
        window if the parent window is the the chain of parent windows
        for the child window.
        """

        # Call the IsChild API funciton and convert the result
        # to True/False
        return win32functions.IsChild(parent, self.handle) != 0

    #-----------------------------------------------------------
    def SendMessage(self, message, wparam = 0 , lparam = 0):
        "Send a message to the control and wait for it to return"
        return win32functions.SendMessage(self, message, wparam, lparam)

        #result = ctypes.c_long()
        #ret = win32functions.SendMessageTimeout(self, message, wparam, lparam,
        #    win32defines.SMTO_NORMAL, 400, ctypes.byref(result))

        #return result.value


    #-----------------------------------------------------------
    def SendMessageTimeout(
        self,
        message,
        wparam = 0 ,
        lparam = 0,
        timeout = None,
        timeoutflags = win32defines.SMTO_NORMAL):
        """Send a message to the control and wait for it to return or to timeout

        If no timeout is given then a default timeout of .4 of a second will
        be used.
        """

        if timeout is None:
            timeout = Timings.sendmessagetimeout_timeout

        result = ctypes.c_long()
        win32functions.SendMessageTimeout(self,
            message, wparam, lparam,
            timeoutflags, int(timeout * 1000),
            ctypes.byref(result))

        return result.value


    #-----------------------------------------------------------
    def PostMessage(self, message, wparam = 0 , lparam = 0):
        "Post a message to the control message queue and return"
        return win32functions.PostMessage(self, message, wparam, lparam)

        #result = ctypes.c_long()
        #ret = win32functions.SendMessageTimeout(self, message, wparam, lparam,
        #    win32defines.SMTO_NORMAL, 400, ctypes.byref(result))

        #return result.value


#    #-----------------------------------------------------------
#    def NotifyMenuSelect(self, menu_id):
#        """Notify the dialog that one of it's menu items was selected
#
#        **This method is Deprecated**
#        """
#
#        import warnings
#        warning_msg = "HwndWrapper.NotifyMenuSelect() is deprecated - " \
#            "equivalent functionality is being moved to the MenuWrapper class."
#        warnings.warn(warning_msg, DeprecationWarning)
#
#        self.SetFocus()
#
#        msg = win32defines.WM_COMMAND
#        return self.SendMessageTimeout(
#            msg,
#            win32functions.MakeLong(0, menu_id), #wparam
#            )
#

    #-----------------------------------------------------------
    def NotifyParent(self, message, controlID = None):
        "Send the notification message to parent of this control"

        if controlID is None:
            controlID = self.ControlID()

        return self.Parent().PostMessage(
            win32defines.WM_COMMAND,
            win32functions.MakeLong(message, controlID),
            self)

    #-----------------------------------------------------------
    def GetProperties(self):
        "Return the properties of the control as a dictionary"
        props = {}

        # for each of the properties that can be written out
        for propname in self.writable_props:
            # set the item in the props dictionary keyed on the propname
            props[propname] = getattr(self, propname)()

        if self._NeedsImageProp:
            props["Image"] = self.CaptureAsImage()

        return props

    #-----------------------------------------------------------
    def CaptureAsImage(self):
        """Return a PIL image of the control

        See PIL documentation to know what you can do with the resulting
        image"""

        if not (self.Rectangle().width() and self.Rectangle().height()):
            return None

        # get the control rectangle in a way that PIL likes it
        box = (
            self.Rectangle().left,
            self.Rectangle().top,
            self.Rectangle().right,
            self.Rectangle().bottom)

        # PIL is optional so check first
        if not PIL.ImageGrab:
            print("PIL does not seem to be installed. "
                "PIL is required for CaptureAsImage")
        
        # grab the image and get raw data as a string
        return PIL.ImageGrab.grab(box)


    #-----------------------------------------------------------
    def __hash__(self):
        "Returns the hash value of the handle"
        return hash(self.handle)

    #-----------------------------------------------------------
    def __eq__(self, other):
        "Returns True if the handles of both controls are the same"
        if isinstance(other, HwndWrapper):
            return self.handle == other.handle
        else:
            return self.handle == other

    #-----------------------------------------------------------
    def VerifyActionable(self):
        """Verify that the control is both visible and enabled

        Raise either ControlNotEnalbed or ControlNotVisible if not
        enabled or visible respectively.
        """
        win32functions.WaitGuiThreadIdle(self)
        self.VerifyVisible()
        self.VerifyEnabled()


    #-----------------------------------------------------------
    def VerifyEnabled(self):
        """Verify that the control is enabled

        Check first if the control's parent is enabled (skip if no parent),
        then check if control itself is enabled.
        """

        # Check if the control and it's parent are enabled
        if not self.IsEnabled():
            raise ControlNotEnabled()

    #-----------------------------------------------------------
    def VerifyVisible(self):
        """Verify that the control is visible

        Check first if the control's parent is visible. (skip if no parent),
        then check if control itself is visible.
        """

        # check if the control and it's parent are visible
        if not self.IsVisible():
            raise ControlNotVisible()


    #-----------------------------------------------------------
    def Click(
        self, button = "left", pressed = "", coords = (0, 0), double = False):
        """Simulates a mouse click on the control

        This method sends WM_* messages to the control, to do a more
        'realistic' mouse click use ClickInput() which uses SendInput() API
        to perform the click.

        This method does not require that the control be visible on the screen
        (i.e. is can be hidden beneath another window and it will still work.)
        """

        _perform_click(self, button, pressed, coords, double)
        return self


    #-----------------------------------------------------------
    def ClickInput(
        self, button = "left", coords = (None, None), double = False, wheel_dist = 0):
        """Click at the specified coordinates

        * **button** The mouse button to click. One of 'left', 'right',
          'middle' or 'x' (Default: 'left')
        * **coords** The coordinates to click at.(Default: center of control)
        * **double** Whether to perform a double click or not (Default: False)
        * **wheel_dist** The distance to move the mouse week (default: 0)

        NOTES: 
           This is different from Click in that it requires the control to
           be visible on the screen but performs a more realistic 'click'
           simulation.

           This method is also vulnerable if the mouse if moved by the user
           as that could easily move the mouse off the control before the
           Click has finished.
        
           If the mouse buttons are swapped, this method sends the 'wrong'
           mouse click e.g. ClickInput sends a right-click and 

        """
        _perform_click_input(self, button, coords, double, wheel_dist = wheel_dist)



    #-----------------------------------------------------------
    def CloseClick(
        self, button = "left", pressed = "", coords = (0, 0), double = False):
        """Peform a click action that should make the window go away

        The only difference from Click is that there are extra delays
        before and after the click action.
        """

        time.sleep(Timings.before_closeclick_wait)

        _perform_click(self, button, pressed, coords, double)

        start = time.time()
        timeout = Timings.closeclick_dialog_close_wait
        # Keep waiting until both this control and it's parent
        # are no longer valid controls
        while (win32functions.IsWindow(self) or \
            win32functions.IsWindow(self.Parent())) and \
            time.time() - start < timeout:

            time.sleep(min(
                Timings.closeclick_retry,
                timeout - (time.time() - start) ))

        time.sleep(Timings.after_closeclick_wait)

        return self


    #-----------------------------------------------------------
    def DoubleClick(
        self, button = "left", pressed = "", coords = (0, 0)):
        "Perform a double click action"
        _perform_click(self, button, pressed, coords, double = True)
        return self

    #-----------------------------------------------------------
    def DoubleClickInput(self, button = "left", coords = (None, None)):
        "Double click at the specified coordinates"
        _perform_click_input(self, button, coords, double = True)

    #-----------------------------------------------------------
    def RightClick(
        self, pressed = "", coords = (0, 0)):
        "Perform a right click action"

        _perform_click(
            self, "right", "right " + pressed, coords, button_up = False)
        _perform_click(self, "right", pressed, coords, button_down = False)
        return self

    #-----------------------------------------------------------
    def RightClickInput(self, coords = (None, None)):
        "Right click at the specified coords"
        _perform_click_input(self, 'right', coords)


    #-----------------------------------------------------------
    def PressMouse(self, button = "left", pressed = "", coords = (0, 0)):
        "Press the mouse button"
        #flags, click_point = _calc_flags_and_coords(pressed, coords)

        _perform_click(self, button, pressed, coords, button_up = False)
        return self

    #-----------------------------------------------------------
    def PressMouseInput(self, button = "left", coords = (None, None)):
        "Press a mouse button using SendInput"
        _perform_click_input(self, button, coords, button_up = False)


    #-----------------------------------------------------------
    def ReleaseMouse(self, button = "left", pressed = "", coords = (0, 0)):
        "Release the mouse button"
        #flags, click_point = _calc_flags_and_coords(pressed, coords)
        _perform_click(self, button, pressed, coords, button_down = False)
        return self

    #-----------------------------------------------------------
    def ReleaseMouseInput(self, button = "left", coords = (None, None)):
        "Release the mouse button"
        _perform_click_input(self, button, coords, button_down = False)

    #-----------------------------------------------------------
    def MoveMouse(self, pressed = "left", coords = (0, 0)):
        "Move the mouse"

        flags, click_point = _calc_flags_and_coords(pressed, coords)
        self.SendMessageTimeout(win32defines.WM_MOUSEMOVE, flags, click_point)
        win32functions.WaitGuiThreadIdle(self)

        return self

    #-----------------------------------------------------------
    def DragMouse(self,
        button = "left",
        pressed = "",
        press_coords = (0, 0),
        release_coords = (0, 0)):
        "Drag the mouse"

        self.PressMouse(button, pressed, press_coords)
        self.MoveMouse(pressed, press_coords)
        self.ReleaseMouse(button, pressed, release_coords)

        return self


    #-----------------------------------------------------------
    def SetWindowText(self, text, append = False):
        "Set the text of the window"

        self.VerifyActionable()

        if append:
            text = self.WindowText() + text

        text = ctypes.c_wchar_p(str(text))
        self.PostMessage(win32defines.WM_SETTEXT, 0, text)
        win32functions.WaitGuiThreadIdle(self)

        return self

    #-----------------------------------------------------------
    def TypeKeys(
        self,
        keys,
        pause = None,
        with_spaces = False,
        with_tabs = False,
        with_newlines = False,
        turn_off_numlock = True):
        """Type keys to the window using SendKeys

        This uses the SendKeys python module from
        http://www.rutherfurd.net/python/sendkeys/ .This is the best place
        to find documentation on what to use for the ``keys``
        """

        self.VerifyActionable()

        if pause is None:
            pause = Timings.after_sendkeys_key_wait

        self.SetFocus()

        # attach the Python process with the process that self is in
        win32functions.AttachThreadInput(
            win32functions.GetCurrentThreadId(), self.ProcessID(), 1)

        # make sure that the control is in the foreground
        win32functions.SetForegroundWindow(self)
        #win32functions.SetActiveWindow(self)


        # Play the keys to the active window
        SendKeys.SendKeys(
            keys,
            pause, with_spaces,
            with_tabs,
            with_newlines,
            turn_off_numlock)

        # detach the python process from the window's process
        win32functions.AttachThreadInput(
            win32functions.GetCurrentThreadId(), self.ProcessID(), 0)

        win32functions.WaitGuiThreadIdle(self)
        return self

    #-----------------------------------------------------------
    def DebugMessage(self, text):
        "Write some debug text over the window"

        # don't draw if dialog is not visible

        dc = win32functions.CreateDC("DISPLAY", None, None, None )

        if not dc:
            raise ctypes.WinError()

        rect = self.Rectangle

        #ret = win32functions.TextOut(
        #    dc, rect.left, rect.top, unicode(text), len(text))
        ret = win32functions.DrawText(
            dc,
            str(text),
            len(text),
            ctypes.byref(rect),
            win32defines.DT_SINGLELINE)

        # delete the Display context that we created
        win32functions.DeleteDC(dc)

        if not ret:
            raise ctypes.WinError()

        return self


    #-----------------------------------------------------------
    def DrawOutline(
        self,
        colour = 'green',
        thickness = 2,
        fill = win32defines.BS_NULL,
        rect = None):
        """Draw an outline around the window

        * **colour** can be either an integer or one of 'red', 'green', 'blue'
          (default 'green')
        * **thickness** thickness of rectangle (default 2)
        * **fill** how to fill in the rectangle (default BS_NULL)
        * **rect** the coordinates of the rectangle to draw (defaults to
          the rectangle of the control.
        """

        # don't draw if dialog is not visible
        if not self.IsVisible():
            return

        colours = {
            "green" : 0x00ff00,
            "blue" : 0xff0000,
            "red" : 0x0000ff,
        }

        # if it's a known colour
        if colour in colours:
            colour = colours[colour]

        if not rect:
            rect = self.Rectangle()

        # create the pen(outline)
        pen_handle = win32functions.CreatePen(
            win32defines.PS_SOLID, thickness, colour)

        # create the brush (inside)
        brush = win32structures.LOGBRUSH()
        brush.lbStyle = fill
        brush.lbHatch = win32defines.HS_DIAGCROSS
        brush_handle = win32functions.CreateBrushIndirect(ctypes.byref(brush))

        # get the Device Context
        dc = win32functions.CreateDC("DISPLAY", None, None, None )

        # push our objects into it
        win32functions.SelectObject(dc, brush_handle)
        win32functions.SelectObject(dc, pen_handle)

        # draw the rectangle to the DC
        win32functions.Rectangle(
            dc, rect.left, rect.top, rect.right, rect.bottom)

        # Delete the brush and pen we created
        win32functions.DeleteObject(brush_handle)
        win32functions.DeleteObject(pen_handle)

        # delete the Display context that we created
        win32functions.DeleteDC(dc)


    #-----------------------------------------------------------
    def PopupWindow(self):
        """Return any owned Popups

        Please do not use in production code yet - not tested fully
        """
        popup = win32functions.GetWindow(self, win32defines.GW_HWNDNEXT)

        return popup


    #-----------------------------------------------------------
    def Owner(self):
        """Return the owner window for the window if it exists

        Returns None if there is no owner"""
        owner = win32functions.GetWindow(self, win32defines.GW_OWNER)
        if owner:
            return HwndWrapper(owner)
        else:
            return None

    #-----------------------------------------------------------
#    def ContextMenuSelect(self, path, x = None, y = None):
#        "TODO ContextMenuSelect Not Implemented"
#        pass
#        #raise NotImplementedError(
#        #    "HwndWrapper.ContextMenuSelect not implemented yet")

    #-----------------------------------------------------------
    def _menu_handle(self):
        "Simple Overridable method to get the menu handle"
        return win32functions.GetMenu(self)

    #-----------------------------------------------------------
    def Menu(self):
        "Return the menu of the control"
        menu_hwnd = self._menu_handle()
        if menu_hwnd: # and win32functions.IsMenu(menu_hwnd):
            return Menu(self, menu_hwnd)
        #else:
            #FindAccessabilityMenu(self.hanlde)
        return None

    #-----------------------------------------------------------
    def MenuItem(self, path):
        """Return the menu item specifed by path

        Path can be a string in the form "MenuItem->MenuItem->MenuItem..."
        where each MenuItem is the text of an item at that level of the menu.
        E.g. ::

          File->Export->ExportAsPNG

        spaces are not important so you could also have written... ::

          File -> Export -> Export As PNG

        """
        if self.appdata is not None:
            menu_appdata = self.appdata['MenuItems']
        else:
            menu_appdata = None

        menu = self.Menu()
        if menu:
            return self.Menu().GetMenuPath(path, appdata = menu_appdata)[-1]

        raise RuntimeError("There is no menu.")

    #-----------------------------------------------------------
    def MenuItems(self):
        """Return the menu items for the dialog

        If there are no menu items then return an empty list
        """
        if self.IsDialog() and self.Menu():
            #menu_handle = win32functions.GetMenu(self)
            #self.SendMessage(win32defines.WM_INITMENU, menu_handle)
            return self.Menu().GetProperties()['MenuItems']

            #self.SendMessage(win32defines.WM_INITMENU, menu_handle)
            #return _GetMenuItems(menu_handle, self)
        else:
            return []



#    #-----------------------------------------------------------
#    def MenuClick(self, path):
#        "Select the menuitem specifed in path"
#
#        self.VerifyActionable()
#
#        self.SetFocus()
#
#        menu = Menu(self, self._menu_handle())
#
#        path_items = menu.GetMenuPath(path)
#
#        for menu_item in path_items:
#            if not menu_item.IsEnabled():
#                raise MenuItemNotEnabled(
#                    "MenuItem '%s' is disabled"% menu_item.Text())
#
#            menu_item.Click()
#
#        return self


    #-----------------------------------------------------------
    def MenuSelect(self, path, ):
        "Select the menuitem specifed in path"

        self.VerifyActionable()

        self.MenuItem(path).Select()


    #-----------------------------------------------------------
    def MoveWindow(
        self,
        x = None,
        y = None,
        width = None,
        height = None,
        repaint = True):
        """Move the window to the new coordinates

        * **x** Specifies the new left position of the window.
          Defaults to the current left position of the window.
        * **y** Specifies the new top position of the window.
          Defaults to the current top position of the window.
        * **width** Specifies the new width of the window. Defaults to the
          current width of the window.
        * **height** Specifies the new height of the window. Default to the
          current height of the window.
        * **repaint** Whether the window should be repainted or not.
          Defaults to True

        """

        cur_rect = self.Rectangle()

        # if no X is specified - so use current coordinate
        if x is None:
            x = cur_rect.left
        else:
            try:
                y = x.top
                width = x.width()
                height = x.height()
                x = x.left
            except AttributeError:
                pass

        # if no Y is specified - so use current coordinate
        if y is None:
            y = cur_rect.top

        # if no width is specified - so use current width
        if width is None:
            width = cur_rect.width()

        # if no height is specified - so use current height
        if height is None:
            height = cur_rect.height()

        # ask for the window to be moved
        ret = win32functions.MoveWindow(self, x, y, width, height, repaint)

        # check that it worked correctly
        if not ret:
            raise ctypes.WinError()

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_movewindow_wait)


    #-----------------------------------------------------------
    def Close(self):
        """Close the window

        Code modified from http://msdn.microsoft.com/msdnmag/issues/02/08/CQA/

        """

        # tell the window it must close
        self.PostMessage(win32defines.WM_CLOSE)

        start = time.time()
        # Keeps trying while
        #    we have not timed out and
        #    window is still a valid handle and
        #    window is still visible
        # any one of these conditions evaluates to false means the window is
        # closed
        while (
            (time.time() - start) < Timings.after_windowclose_timeout and
            win32functions.IsWindow(self) and
            self.IsVisible()):

            time.sleep(min(
                Timings.after_windowclose_retry,
                Timings.after_windowclose_timeout - (time.time() - start) ))


#        # get a handle we can wait on
#        process_wait_handle = win32functions.OpenProcess(
#            win32defines.SYNCHRONIZE | win32defines.PROCESS_TERMINATE ,
#            False ,
#            self.ProcessID())
#
#        # wait for the window to close
#        win32functions.WaitForSingleObject(
#            process_wait_handle,
#            )


    #-----------------------------------------------------------
    def Maximize(self):
        """Maximize the window"""
        win32functions.ShowWindow(self, win32defines.SW_MAXIMIZE)

    #-----------------------------------------------------------
    def Minimize(self):
        """Minimize the window"""
        win32functions.ShowWindow(self, win32defines.SW_MINIMIZE)

    #-----------------------------------------------------------
    def Restore(self):
        """Restore the window"""

        # do it twice just in case the window was minimized from being
        # maximized - because then the window would come up maximized
        # after the first ShowWindow, and Restored after the 2nd
        win32functions.ShowWindow(self, win32defines.SW_RESTORE)
        win32functions.ShowWindow(self, win32defines.SW_RESTORE)


    #-----------------------------------------------------------
    def GetShowState(self):
        """Get the show state and Maximized/minimzed/restored state

        Returns a value that is a union of the following

        * SW_HIDE the window is hidden.
        * SW_MAXIMIZE the window is maximized
        * SW_MINIMIZE the window is minimized
        * SW_RESTORE the window is in the 'restored'
          state (neither minimized or maximized)
        * SW_SHOW The window is not hidden
        """

        wp = win32structures.WINDOWPLACEMENT()
        wp.lenght = ctypes.sizeof(wp)

        ret = win32functions.GetWindowPlacement(self, ctypes.byref(wp))

        if not ret:
            raise ctypes.WinError()

        return wp.showCmd

    #-----------------------------------------------------------
    def GetFocus(self):
        """Return the control in the process of this window that has the Focus
        """

        gui_info = win32structures.GUITHREADINFO()
        gui_info.cbSize = ctypes.sizeof(gui_info)
        ret = win32functions.GetGUIThreadInfo(
            win32functions.GetWindowThreadProcessId(self, 0),
            ctypes.byref(gui_info))

        if not ret:
            return None

        return HwndWrapper(gui_info.hwndFocus)

    #-----------------------------------------------------------
    def SetFocus(self):
        """Set the focus to this control

        Bring the window to the foreground first if necessary."""

        # find the current foreground window
        cur_foreground = win32functions.GetForegroundWindow()

        # if it is already foreground then just return
        if self.handle != cur_foreground:

            # get the thread of the window that is in the foreground
            cur_fore_thread = win32functions.GetWindowThreadProcessId(
                cur_foreground, 0)

            # get the thread of the window that we want to be in the foreground
            control_thread = win32functions.GetWindowThreadProcessId(self, 0)

            # if a different thread owns the active window
            if cur_fore_thread != control_thread:
                # Attach the two threads and set the foreground window
                win32functions.AttachThreadInput(
                    cur_fore_thread, control_thread, True)

                win32functions.SetForegroundWindow(self)

                # detach the thread again
                win32functions.AttachThreadInput(
                    cur_fore_thread, control_thread, False)

            else:   # same threads - just set the foreground window
                win32functions.SetForegroundWindow(self)

            # make sure that we are idle before returning
            win32functions.WaitGuiThreadIdle(self)

            # only sleep if we had to change something!
            time.sleep(Timings.after_setfocus_wait)

        return self



    #-----------------------------------------------------------
    def SetApplicationData(self, appdata):
        """Application data is data from a previous run of the software

        It is essential for running scripts written for one spoke language
        on a different spoken langauge
        """
        self.appdata = appdata


    _scroll_types = {"left": {
            "line" : win32defines.SB_LINELEFT,
            "page" : win32defines.SB_PAGELEFT,
            "end" :  win32defines.SB_LEFT,
            },
        "right": {
                "line" : win32defines.SB_LINERIGHT,
                "page" : win32defines.SB_PAGERIGHT,
                "end" :  win32defines.SB_RIGHT,
            },
        "up": {
                "line" : win32defines.SB_LINEUP,
                "page" : win32defines.SB_PAGEUP,
                "end" :  win32defines.SB_TOP,
            },
        "down": {
                "line" : win32defines.SB_LINEDOWN,
                "page" : win32defines.SB_PAGEDOWN,
                "end" :  win32defines.SB_BOTTOM,
            },
        }

    #-----------------------------------------------------------
    def Scroll(self, direction, amount, count = 1):
        """Ask the control to scroll itself

        direction can be any of "up", "down", "left", "right"
        amount can be one of "line", "page", "end"
        count (optional) the number of times to scroll
        """

        # check which message we want to send
        if direction.lower() in ("left", "right"):
            message = win32defines.WM_HSCROLL
        elif direction.lower() in ("up", "down"):
            message = win32defines.WM_VSCROLL

        # the constant that matches direction, and how much
        scroll_type = \
            HwndWrapper._scroll_types[direction.lower()][amount.lower()]

        # Scroll as often as we have been asked to
        while count > 0:
            self.SendMessage(message, scroll_type)
            count -= 1

        return self


#
#def MouseLeftClick():
#    pass
#def MouseRightClick():
#    pass
#def MouseDoubleClick():
#    pass
#def MouseDown():
#    pass
#def MouseUp():
#    pass
#def MoveMouse():
#    pass
#def DragMouse():
#    pass
#
#def LeftClick(x, y):
#    win32defines.MOUSEEVENTF_LEFTDOWN
#    win32defines.MOUSEEVENTF_LEFTUP
#
#    # set the cursor position
#    win32functions.SetCursorPos(x, y)
#    time.sleep(Timings.after_setcursorpos_wait)
#
#    inp_struct = win32structures.INPUT()
#    inp_struct.type = win32defines.INPUT_MOUSE
#    for event in (win32defines.MOUSEEVENTF_LEFTDOWN, win32defines.MOUSEEVENTF_LEFTUP):
#        inp_struct._.mi.dwFlags = event
#        win32functions.SendInput(
#            1,
#            ctypes.pointer(inp_struct),
#            ctypes.sizeof(inp_struct))
#
#        time.sleep(Timings.after_clickinput_wait)



#====================================================================
def _perform_click_input(
    ctrl = None,
    button = "left",
    coords = (None, None),
    double = False,
    button_down = True,
    button_up = True,
    absolute = False,
    wheel_dist = 0):
    """Peform a click action using SendInput

    All the *ClickInput() and *MouseInput() methods use this function.
    
    Thanks to a bug report from Tomas Walch (twalch) on sourceforge and code 
    seen at http://msdn.microsoft.com/en-us/magazine/cc164126.aspx this 
    function now always works the same way whether the mouse buttons are 
    swapped or not.
    
    For example if you send a right click to Notepad.Edit - it will always
    bring up a popup menu rather than 'clicking' it.
    """

    # Handle if the mouse buttons are swapped
    if win32functions.GetSystemMetrics(win32defines.SM_SWAPBUTTON):
        if button.lower() == 'left':
            button = 'right'
        else:
            button = 'left'

    events = []
    if button.lower() == 'left':
        if button_down:
            events.append(win32defines.MOUSEEVENTF_LEFTDOWN)
        if button_up:
            events.append(win32defines.MOUSEEVENTF_LEFTUP)
    elif button.lower() == 'right':
        if button_down:
            events.append(win32defines.MOUSEEVENTF_RIGHTDOWN)
        if button_up:
            events.append(win32defines.MOUSEEVENTF_RIGHTUP)
    elif button.lower() == 'middle':
        if button_down:
            events.append(win32defines.MOUSEEVENTF_MIDDLEDOWN)
        if button_up:
            events.append(win32defines.MOUSEEVENTF_MIDDLEUP)
    elif button.lower() == 'x':
        if button_down:
            events.append(win32defines.MOUSEEVENTF_XDOWN)
        if button_up:
            events.append(win32defines.MOUSEEVENTF_XUP)
    if button.lower() == 'wheel':
        events.append(win32defines.MOUSEEVENTF_WHEEL)


    # if we were asked to double click (and we are doing a full click
    # not just up or down.
    if double and button_down and button_up:
        events *= 2


    if ctrl == None:
        ctrl = HwndWrapper(win32functions.GetDesktopWindow())
    else:
        ctrl.SetFocus()

    if isinstance(coords, win32structures.RECT):
        coords = (coords.left, coords.top)

#    # allow points objects to be passed as the coords
#    if isinstance(coords, win32structures.POINT):
#        coords = [coords.x, coords.y]
#    else:
    coords = list(coords)

    # set the default coordinates
    if coords[0] is None:
        coords[0] = ctrl.Rectangle().width() // 2
    if coords[1] is None:
        coords[1] = ctrl.Rectangle().height() // 2

    if not absolute:
        coords[0] = coords[0] + ctrl.Rectangle().left
        coords[1] = coords[1] + ctrl.Rectangle().top

    # set the cursor position
    win32functions.SetCursorPos(coords[0], coords[1])
    time.sleep(Timings.after_setcursorpos_wait)

    inp_struct = win32structures.INPUT()
    inp_struct.type = win32defines.INPUT_MOUSE

    for event in events:
        inp_struct._.mi.dwFlags = event
        if button.lower() == 'wheel':
            inp_struct._.mi.mouseData = wheel_dist
        else:
            inp_struct._.mi.mouseData = 0

        win32functions.SendInput(
            1,
            ctypes.pointer(inp_struct),
            ctypes.sizeof(inp_struct))

        time.sleep(Timings.after_clickinput_wait)





#====================================================================
def _perform_click(
        ctrl,
        button = "left",
        pressed = "",
        coords = (0, 0),
        double = False,
        button_down = True,
        button_up = True):
    "Low level method for performing click operations"

    ctrl.VerifyActionable()

    if isinstance(coords, win32structures.RECT):
        coords = (coords.left, coords.top)

    # figure out the messages for click/press
    msgs  = []
    if not double:
        if button.lower() == "left":
            if button_down:
                msgs.append(win32defines.WM_LBUTTONDOWN)
            if button_up:
                msgs.append(win32defines.WM_LBUTTONUP)

        elif button.lower() == "middle":
            if button_down:
                msgs.append(win32defines.WM_MBUTTONDOWN)
            if button_up:
                msgs.append(win32defines.WM_MBUTTONUP)

        elif button.lower() == "right":
            if button_down:
                msgs.append(win32defines.WM_RBUTTONDOWN)
            if button_up:
                msgs.append(win32defines.WM_RBUTTONUP)

    # figure out the messages for double clicking
    else:
        if button.lower() == "left":
            msgs = (
                win32defines.WM_LBUTTONDOWN,
                win32defines.WM_LBUTTONUP,
                win32defines.WM_LBUTTONDBLCLK,
                win32defines.WM_LBUTTONUP)
        elif button.lower() == "middle":
            msgs = (
                win32defines.WM_MBUTTONDOWN,
                win32defines.WM_MBUTTONUP,
                win32defines.WM_MBUTTONDBLCLK,
                win32defines.WM_MBUTTONUP)
        elif button.lower() == "right":
            msgs = (
                win32defines.WM_RBUTTONDOWN,
                win32defines.WM_RBUTTONUP,
                win32defines.WM_RBUTTONDBLCLK,
                win32defines.WM_RBUTTONUP)

    # figure out the flags and pack coordinates
    flags, click_point = _calc_flags_and_coords(pressed, coords)


    # send each message
    for msg in msgs:
        ctrl.SendMessageTimeout(msg, flags, click_point)
        #ctrl.PostMessage(msg, flags, click_point)
        #flags = 0

        time.sleep(Timings.sendmessagetimeout_timeout)
        
        # wait until the thread can accept another message
        win32functions.WaitGuiThreadIdle(ctrl)

    # wait a certain(short) time after the click
    time.sleep(Timings.after_click_wait)


_mouse_flags = {
    "left": win32defines.MK_LBUTTON,
    "right": win32defines.MK_RBUTTON,
    "middle": win32defines.MK_MBUTTON,
    "shift": win32defines.MK_SHIFT,
    "control": win32defines.MK_CONTROL,
}

#====================================================================
def _calc_flags_and_coords(pressed, coords):
    "Calculate the flags to use and the coordinates for mouse actions"
    flags = 0

    for key in pressed.split():
        flags |= _mouse_flags[key.lower()]

    click_point = win32functions.MakeLong(coords[1], coords[0])

    return flags, click_point



#====================================================================
class _dummy_control(dict):
    "A subclass of dict so that we can assign attributes"
    pass

#====================================================================
def GetDialogPropsFromHandle(hwnd):
    "Get the properties of all the controls as a list of dictionaries"

    # wrap the dialog handle and start a new list for the
    # controls on the dialog
    try:
        controls = [hwnd, ]
        controls.extend(hwnd.Children())
    except AttributeError:
        controls = [HwndWrapper(hwnd), ]

        # add all the children of the dialog
        controls.extend(controls[0].Children())

    props = []

    # Add each control to the properties for this dialog
    for ctrl in controls:
        # Get properties for each control and wrap them in
        # _dummy_control so that we can assign handle
        ctrl_props = _dummy_control(ctrl.GetProperties())

        # assign the handle
        ctrl_props.handle = ctrl.handle

        # offset the rectangle from the dialog rectangle
        ctrl_props['Rectangle'] -= controls[0].Rectangle()

        props.append(ctrl_props)

    return props








########NEW FILE########
__FILENAME__ = Accessability win32_controls
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Wraps various standard windows controls"

__revision__ = "$Revision: 680 $"

import time

import ctypes

from . import HwndWrapper

from pywinauto import win32functions
from pywinauto import win32defines
from pywinauto import win32structures
#from pywinauto import findbestmatch
from pywinauto import controlproperties

from pywinauto import tests
from pywinauto.timings import Timings

#====================================================================
class ButtonWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows Button control"

    friendlyclassname = "Button"
    windowclasses = [
        "Button",
        r"WindowsForms\d*\.BUTTON\..*",
        "TButton",
        "ThunderCommandButton",
        "ThunderOptionButton",
        "ThunderCheckBox"]
    can_be_label = True

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the control"
        super(ButtonWrapper, self).__init__(hwnd)

        #self._set_if_needs_image()


    def _set_if_needs_image(self, value):
        "Does nothing see _get_if_needs_image"
        pass
    #-----------------------------------------------------------
    def _get_if_needs_image(self):
        "Set the _NeedsImageProp attribute if it is an image button"

        # optimization call Style once and work with that rather than
        # calling HasStyle a number of times
        style = self.Style()

        if self.IsVisible() and (\
            style & win32defines.BS_BITMAP == style or \
            style & win32defines.BS_ICON == style or \
            style & win32defines.BS_OWNERDRAW == style):

            #self._NeedsImageProp = True
            return True
        else:
            return False
    _NeedsImageProp = property(_get_if_needs_image, _set_if_needs_image)

    #-----------------------------------------------------------
    def FriendlyClassName(self):
        """Return the friendly class name of the button

        Windows controls with the class "Button" can look like different
        controls based on their style. They can look like the following
        controls:

          - Buttons, this method returns "Button"
          - CheckBoxes, this method returns "CheckBox"
          - RadioButtons, this method returns "RadioButton"
          - GroupBoxes, this method returns "GroupBox"

        """
        # get the least significant BIT
        style_lsb = self.Style() & 0xF

        f_class_name = 'Button'


        vb_buttons = {
            "ThunderOptionButton": "RadioButton",
            "ThunderCheckBox": "CheckBox",
            "ThunderCommandButton": "Button"
        }

        if self.Class() in vb_buttons:
            f_class_name = vb_buttons[self.Class()]

        if style_lsb == win32defines.BS_3STATE or \
            style_lsb == win32defines.BS_AUTO3STATE or \
            style_lsb == win32defines.BS_AUTOCHECKBOX or \
            style_lsb == win32defines.BS_CHECKBOX:
            f_class_name = "CheckBox"
        elif style_lsb == win32defines.BS_RADIOBUTTON or \
            style_lsb == win32defines.BS_AUTORADIOBUTTON:
            f_class_name = "RadioButton"
        elif style_lsb ==  win32defines.BS_GROUPBOX:
            f_class_name = "GroupBox"

        if self.Style() & win32defines.BS_PUSHLIKE:
            f_class_name = "Button"

        return f_class_name


    #-----------------------------------------------------------
    def GetCheckState(self):
        """Return the check state of the checkbox

        The check state is represented by an integer
        0 - unchecked
        1 - checked
        2 - indeterminate

        The following constants are defined in the win32defines module
        BST_UNCHECKED = 0
        BST_CHECKED = 1
        BST_INDETERMINATE = 2
        """
        return self.SendMessage(win32defines.BM_GETCHECK)

    #-----------------------------------------------------------
    def Check(self):
        "Check a checkbox"
        self.SendMessageTimeout(win32defines.BM_SETCHECK,
            win32defines.BST_CHECKED)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_buttoncheck_wait)

        # return this control so that actions can be chained.
        return self


    #-----------------------------------------------------------
    def UnCheck(self):
        "Uncheck a checkbox"
        self.SendMessageTimeout(win32defines.BM_SETCHECK,
            win32defines.BST_UNCHECKED)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_buttoncheck_wait)

        # return this control so that actions can be chained.
        return self

    #-----------------------------------------------------------
    def SetCheckIndeterminate(self):
        "Set the checkbox to indeterminate"
        self.SendMessageTimeout(win32defines.BM_SETCHECK,
            win32defines.BST_INDETERMINATE)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_buttoncheck_wait)

        # return this control so that actions can be chained.
        return self

    #-----------------------------------------------------------
    def IsDialog(self):
        "Buttons are never dialogs so return False"
        return False

    #-----------------------------------------------------------
    def Click(self, *args, **kwargs):
        "Click the Button control"
    #    import win32functions
    #    win32functions.WaitGuiThreadIdle(self)
    #    self.NotifyParent(win32defines.BN_CLICKED)
        HwndWrapper.HwndWrapper.Click(self, *args, **kwargs)
    #    win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_button_click_wait)


    #def IsSelected (self):
    #    (for radio buttons)



#====================================================================
def _get_multiple_text_items(wrapper, count_msg, item_len_msg, item_get_msg):
    "Helper function to get multiple text items from a control"

    texts = []

    # find out how many text items are in the combobox
    num_items = wrapper.SendMessage(count_msg)

    # get the text for each item in the combobox
    for i in range(0, num_items):
        text_len = wrapper.SendMessage (item_len_msg, i, 0)

        text = ctypes.create_unicode_buffer(text_len + 1)

        wrapper.SendMessage(item_get_msg, i, ctypes.byref(text))

        texts.append(text.value)

    return texts


#====================================================================
class ComboBoxWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows ComboBox control"

    friendlyclassname = "ComboBox"
    windowclasses = [
        "ComboBox",
        "WindowsForms\d*\.COMBOBOX\..*",
        "TComboBox"]
    has_title = False

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the control"
        super(ComboBoxWrapper, self).__init__(hwnd)

        self.writable_props.extend([
            "SelectedIndex",
            "DroppedRect",
            ])

    #-----------------------------------------------------------
    def DroppedRect(self):
        "Get the dropped rectangle of the combobox"
        dropped_rect = win32structures.RECT()

        self.SendMessage(
            win32defines.CB_GETDROPPEDCONTROLRECT,
            0,
            ctypes.byref(dropped_rect))

        # we need to offset the dropped rect from the control
        dropped_rect -= self.Rectangle()

        return dropped_rect

    #-----------------------------------------------------------
    def ItemCount(self):
        "Return the number of items in the combobox"
        return self.SendMessage(win32defines.CB_GETCOUNT)

    #-----------------------------------------------------------
    def SelectedIndex(self):
        "Return the selected index"
        return self.SendMessage(win32defines.CB_GETCURSEL)

    #-----------------------------------------------------------
    def _get_item_index(self, ident):
        "Get the index for the item with this 'ident'"
        if isinstance(ident, int):

            if ident >= self.ItemCount():
                raise IndexError(
                    "Combobox has %d items, you requested item %d (0 based)"%
                        (self.ItemCount(),
                        ident))

            # negative index
            if ident < 0:
                # convert it to a positive index
                ident = (self.ItemCount() + ident)

        elif isinstance(ident, str):
            # todo - implement fuzzy lookup for ComboBox items
            # todo - implement appdata lookup for combobox items
            ident = self.ItemTexts().index(ident)

        return ident

    #-----------------------------------------------------------
    def ItemData(self, item):
        "Returns the item data associated with the item if any"
        index = self._get_item_index(item)
        return self.SendMessage(win32defines.CB_GETITEMDATA, index)

    #-----------------------------------------------------------
    def ItemTexts(self):
        "Return the text of the items of the combobox"
        return _get_multiple_text_items(
            self,
            win32defines.CB_GETCOUNT,
            win32defines.CB_GETLBTEXTLEN,
            win32defines.CB_GETLBTEXT)

    #-----------------------------------------------------------
    def Texts(self):
        "Return the text of the items in the combobox"
        texts = [self.WindowText()]
        texts.extend(self.ItemTexts())
        return texts

    #-----------------------------------------------------------
    def GetProperties(self):
        "Return the properties of the control as a dictionary"
        props = HwndWrapper.HwndWrapper.GetProperties(self)

        #props['ItemData'] = []
        #for i in range(self.ItemCount()):
        #    props['ItemData'].append(self.ItemData(i))

        return props

    #-----------------------------------------------------------
    def Select(self, item):
        """Select the ComboBox item

        item can be either a 0 based index of the item to select
        or it can be the string that you want to select
        """
        self.VerifyActionable()

        index = self._get_item_index(item)

        # change the selected item
        self.SendMessageTimeout(win32defines.CB_SETCURSEL, index)

        # Notify the parent that we are finished selecting
        self.NotifyParent(win32defines.CBN_SELENDOK)

        # Notify the parent that we have changed
        self.NotifyParent(win32defines.CBN_SELCHANGE)

        # simple combo boxes don't have drop downs so they do not recieve
        # this notification
        if self.HasStyle(win32defines.CBS_DROPDOWN):
            # Notify the parent that the drop down has closed
            self.NotifyParent(win32defines.CBN_CLOSEUP)


        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_comboboxselect_wait)

        # return this control so that actions can be chained.
        return self

    #-----------------------------------------------------------
    #def Deselect(self, item):
    # Not implemented because it doesn't make sense for combo boxes.

    #TODO def EditControl(self): # return the edit control of the Combobox

    #TODO def ListControl(self): # return the list control of the combobox

    #TODO def ItemText(self, index):  # get the test of item XX?

    #TODO def EditText(self):  # or should this be self.EditControl.Text()?


#====================================================================
class ListBoxWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows ListBox control"

    friendlyclassname = "ListBox"
    windowclasses = [
        "ListBox",
        r"WindowsForms\d*\.LISTBOX\..*",
        "ThunderListBox",
        "ThunderFileListBox",
        "TListBox",]
    has_title = False

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the control"
        super(ListBoxWrapper, self).__init__(hwnd)

        self.writable_props.extend([
            "SelectedIndices"])

    #-----------------------------------------------------------
    def SelectedIndices(self):
        "The currently selected indices of the listbox"
        num_selected = self.SendMessage(win32defines.LB_GETSELCOUNT)

        # if we got LB_ERR then it is a single selection list box
        if num_selected == win32defines.LB_ERR:
            items = (self.SendMessage(win32defines.LB_GETCURSEL), )

        # otherwise it is a multiselection list box
        else:
            items = (ctypes.c_int * num_selected)()

            self.SendMessage(
                win32defines.LB_GETSELITEMS, num_selected, ctypes.byref(items))

            # Need to convert from Ctypes array to a python tuple
            items = tuple(items)

        return items

    #-----------------------------------------------------------
    def _get_item_index(self, ident):
        "Return the index of the item 'ident'"
        if isinstance(ident, int):

            if ident >= self.ItemCount():
                raise IndexError(
                    "ListBox has %d items, you requested item %d (0 based)"%
                        (self.ItemCount(),
                        ident))

            # negative index
            if ident < 0:
                ident = (self.ItemCount() + ident)

        elif isinstance(ident, str):
            # todo - implement fuzzy lookup for ComboBox items
            # todo - implement appdata lookup for combobox items
            ident = self.ItemTexts().index(ident) #-1

        return ident

    #-----------------------------------------------------------
    def ItemCount(self):
        "Return the number of items in the ListBox"
        return self.SendMessage(win32defines.LB_GETCOUNT)

    #-----------------------------------------------------------
    def ItemData(self, i):
        "Return the ItemData if any associted with the item"

        index = self._get_item_index(i)

        return self.SendMessage(win32defines.LB_GETITEMDATA, index)

    #-----------------------------------------------------------
    def ItemTexts(self):
        "Return the text of the items of the listbox"
        return _get_multiple_text_items(
            self,
            win32defines.LB_GETCOUNT,
            win32defines.LB_GETTEXTLEN,
            win32defines.LB_GETTEXT)

    #-----------------------------------------------------------
    def Texts(self):
        "Return the texts of the control"
        texts = [self.WindowText()]
        texts.extend(self.ItemTexts())
        return texts

#    #-----------------------------------------------------------
#    def GetProperties(self):
#        "Return the properties as a dictionary for the control"
#        props = HwndWrapper.HwndWrapper.GetProperties(self)
#
#        props['ItemData'] = []
#        for i in range(self.ItemCount()):
#            props['ItemData'].append(self.ItemData(i))
#
#        return props

    #-----------------------------------------------------------
    def Select(self, item):
        """Select the ListBox item

        item can be either a 0 based index of the item to select
        or it can be the string that you want to select
        """
        self.VerifyActionable()

        # Make sure we have an index  so if passed in a
        # string then find which item it is
        index = self._get_item_index(item)

        # change the selected item
        self.SendMessageTimeout(win32defines.LB_SETCURSEL, index)

        # Notify the parent that we have changed
        self.NotifyParent(win32defines.LBN_SELCHANGE)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_listboxselect_wait)

        return self

    #-----------------------------------------------------------
    def SetItemFocus(self, item):
        "Set the ListBox focus to the item at index"

        index = self._get_item_index(item)

        # if it is a multiple selection dialog
        if self.HasStyle(win32defines.LBS_EXTENDEDSEL) or \
            self.HasStyle(win32defines.LBS_MULTIPLESEL):
            self.SendMessageTimeout(win32defines.LB_SETCARETINDEX, index)
        else:
            self.SendMessageTimeout(win32defines.LB_SETCURSEL, index)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_listboxfocuschange_wait)

        # return this control so that actions can be chained.
        return self


    #-----------------------------------------------------------
    def GetItemFocus(self):
        "Retrun the index of current selection in a ListBox"

        # if it is a multiple selection dialog
        if self.HasStyle(win32defines.LBS_EXTENDEDSEL) or \
            self.HasStyle(win32defines.LBS_MULTIPLESEL):
            return self.SendMessage(win32defines.LB_GETCARETINDEX)
        else:
            return self.SendMessage(win32defines.LB_GETCURSEL)


#====================================================================
class EditWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows Edit control"

    friendlyclassname = "Edit"
    windowclasses = [
        "Edit",
        "TEdit",
        "TMemo",
        r"WindowsForms\d*\.EDIT\..*",
        "ThunderTextBox",
        "ThunderRT6TextBox",
        ]
    has_title = False

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the control"
        super(EditWrapper, self).__init__(hwnd)

        self.writable_props.extend([
            'SelectionIndices'])

    #-----------------------------------------------------------
    def LineCount(self):
        "Return how many lines there are in the Edit"
        return  self.SendMessage(win32defines.EM_GETLINECOUNT)-1

    #-----------------------------------------------------------
    def LineLength(self, line_index):
        "Return how many characters there are in the line"

        # need to first get a character index of that line
        char_index = self.SendMessage(win32defines.EM_LINEINDEX, line_index)

        # now get the length of text on that line
        return self.SendMessage (
            win32defines.EM_LINELENGTH, char_index, 0)


    #-----------------------------------------------------------
    def GetLine(self, line_index):
        "Return the line specified"

        text_len = self.LineLength(line_index)
        # create a buffer and set the length at the start of the buffer
        text = ctypes.create_unicode_buffer(text_len+3)
        text[0] = chr(text_len)

        # retrieve the line itself
        self.SendMessage(
            win32defines.EM_GETLINE, line_index, ctypes.byref(text))

        return text.value

    #-----------------------------------------------------------
    def Texts(self):
        "Get the text of the edit control"

        texts = [self.WindowText(), ]

        for i in range(0, self.LineCount()+1):
            texts.append(self.GetLine(i))

        return texts

    #-----------------------------------------------------------
    def TextBlock(self):
        "Get the text of the edit control"

        length = self.SendMessage(win32defines.WM_GETTEXTLENGTH)
        text = ctypes.create_unicode_buffer(length + 1)
        self.SendMessage(win32defines.WM_GETTEXT, length+1, ctypes.byref(text))

        #text = text.value.replace("\r\n", "\n")
        return text.value

    #-----------------------------------------------------------
    def SelectionIndices(self):
        "The start and end indices of the current selection"
        start = ctypes.c_int()
        end = ctypes.c_int()
        self.SendMessage(
            win32defines.EM_GETSEL, ctypes.byref(start), ctypes.byref(end))

        return (start.value, end.value)

    #-----------------------------------------------------------
    def SetWindowText(self, text, append = False):
        """Override SetWindowText for edit controls because it should not be
        used for Edit controls.

        Edit Controls should either use SetEditText() or TypeKeys() to modify
        the contents of the edit control."""
        HwndWrapper.HwndWrapper.SetWindowText(self, text, append)
        raise UserWarning(
            "SetWindowText() should probably not be called for Edit Controls")

    #-----------------------------------------------------------
    def SetEditText(self, text, pos_start = None, pos_end = None):
        "Set the text of the edit control"
        self.VerifyActionable()

        # allow one or both of pos_start and pos_end to be None
        if pos_start is not None or pos_end is not None:

            # if only one has been specified - then set the other
            # to the current selection start or end
            start, end = self.SelectionIndices()
            if pos_start is None:
                pos_start = start
            if pos_end is None:
                pos_end = end

            # set the selection if either start or end has
            # been specified
            self.Select(pos_start, pos_end)
        else:
            self.Select()

        # replace the selection with
        text = ctypes.c_wchar_p(str(text))
        self.SendMessageTimeout(win32defines.EM_REPLACESEL, True, text)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_editsetedittext_wait)


        # return this control so that actions can be chained.
        return self

    # set SetText as an alias to SetEditText
    SetText = SetEditText

    #-----------------------------------------------------------
    def Select(self, start = 0, end = None):
        "Set the edit selection of the edit control"
        self.VerifyActionable()

        # if we have been asked to select a string
        if isinstance(start, str):
            string_to_select = start
            #
            start = self.TextBlock().index(string_to_select)

            if end is None:
                end = start + len(string_to_select)

        if end is None:
            end = -1

        self.SendMessageTimeout(win32defines.EM_SETSEL, start, end)

        # give the control a chance to catch up before continuing
        win32functions.WaitGuiThreadIdle(self)

        time.sleep(Timings.after_editselect_wait)

        # return this control so that actions can be chained.
        return self


#====================================================================
class StaticWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows Static control"

    friendlyclassname = "Static"
    windowclasses = [
        "Static",
        r"WindowsForms\d*\.STATIC\..*",
        "TPanel"]
    can_be_label = True

    def __init__(self, hwnd):
        "Initialize the control"
        super(StaticWrapper, self).__init__(hwnd)

        # if the control is visible - and it shows an image
        if self.IsVisible() and (
            self.HasStyle(win32defines.SS_ICON) or \
            self.HasStyle(win32defines.SS_BITMAP) or \
            self.HasStyle(win32defines.SS_CENTERIMAGE) or \
            self.HasStyle(win32defines.SS_OWNERDRAW)):

            self._NeedsImageProp = True


#====================================================================
# the main reason for this is just to make sure that
# a Dialog is a known class - and we don't need to take
# an image of it (as an unknown control class)
class DialogWrapper(HwndWrapper.HwndWrapper):
    "Wrap a dialog"

    friendlyclassname = "Dialog"
    #windowclasses = ["#32770", ]
    can_be_label = True

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        """Initialize the DialogWrapper

        The only extra functionality here is to modify self.friendlyclassname
        to make it "Dialog" if the class is "#32770" otherwise to leave it
        the same as the window class.
        """
        HwndWrapper.HwndWrapper.__init__(self, hwnd)

        if self.Class() == "#32770":
            self.friendlyclassname = "Dialog"
        else:
            self.friendlyclassname = self.Class()

    #-----------------------------------------------------------
    def RunTests(self, tests_to_run = None, ref_controls = None):
        "Run the tests on dialog"

        # get all the controls
        controls = [self] + self.Children()
        
        # add the reference controls
        if ref_controls is not None:                        
            matched_flags = controlproperties.SetReferenceControls(
                controls, ref_controls)
            
            # todo: allow some checking of how well the controls matched
            # matched_flags says how well they matched
            # 1 = same number of controls
            # 2 = ID's matched
            # 4 = control classes matched
            # i.e. 1 + 2 + 4 = perfect match
        
        return tests.run_tests(controls, tests_to_run)

    #-----------------------------------------------------------
    def WriteToXML(self, filename):
        "Write the dialog an XML file (requires elementtree)"
        
        controls = [self] + self.Children()
        props = [ctrl.GetProperties() for ctrl in controls]

        from pywinauto import XMLHelpers
        XMLHelpers.WriteDialogToFile(filename, props)

    #-----------------------------------------------------------
    def ClientAreaRect(self):
        """Return the client area rectangle

        From MSDN
        The client area of a control is the bounds of the control, minus the
        nonclient elements such as scroll bars, borders, title bars, and 
        menus."""
        rect = win32structures.RECT(self.Rectangle())
        self.SendMessage(win32defines.WM_NCCALCSIZE, 0, ctypes.byref(rect))
        return rect

#    #-----------------------------------------------------------
#    def ReadControlsFromXML(self, filename):
#        from pywinauto import XMLHelpers
#        [controlproperties.ControlProps(ctrl) for
#            ctrl in XMLHelpers.ReadPropertiesFromFile(handle)]  


    #-----------------------------------------------------------
    def Controls(self):
        "Return all the controls in the dialog as a list"
        return 
        

#    #-----------------------------------------------------------
#    def AddReference(self, reference):
#
#        if len(self.Children() != len(reference)):
#            raise "different number of reference controls"
#
#        for i, ctrl in enumerate(reference):
#        # loop over each of the controls
#        # and set the reference
#            if isinstance(ctrl, dict):
#                ctrl = CtrlProps(ctrl)
#
#            self.
#            if ctrl.Class() != self.Children()[i+1].Class():
#                print "different classes"



#====================================================================
# the main reason for this is just to make sure that
# a Dialog is a known class - and we don't need to take
# an image of it (as an unknown control class)
class PopupMenuWrapper(HwndWrapper.HwndWrapper):
    "Wrap a Popup Menu"

    friendlyclassname = "PopupMenu"
    windowclasses = ["#32768", ]
    has_title = False

    #-----------------------------------------------------------
    def IsDialog(self):
        "Return whether it is a dialog"
        return True

    #-----------------------------------------------------------
    def _menu_handle(self):
        "Get the menu handle for the popup menu menu"
        mbi = win32structures.MENUBARINFO()
        mbi.cbSize = ctypes.sizeof(mbi)
        ret = win32functions.GetMenuBarInfo(
            self,
            win32defines.OBJID_CLIENT,
            0,
            ctypes.byref(mbi))

        if not ret:
            raise ctypes.WinError()

        return mbi.hMenu



#====================================================================
class MFCWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows Static control"

    #friendlyclassname = "MFC_"
    windowclasses = ["Afx.*", ]
    can_be_label = True

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the control"
        super(MFCWrapper, self).__init__(hwnd)

        from pyia import accessibleObjectFromWindow
        self.ao = accessibleObjectFromWindow(hwnd)

        self.aovals = {}
        
        for attrib in ("accName", "accRoleName", "accState", "accValue"):
            try:
                value = getattr(self.ao, attrib)()
                print("XXXXX", value)
            except Exception as e:
                value = None
            
            self.aovals[attrib] = value
        
    #-----------------------------------------------------------
    def FriendlyClassName(self):
        """Return the friendly class name for the control

        This differs from the class of the control in some cases.
        Class() is the actual 'Registered' window class of the control
        while FriendlyClassName() is hopefully something that will make
        more sense to the user.

        For example Checkboxes are implemented as Buttons - so the class
        of a CheckBox is "Button" - but the friendly class is "CheckBox"
        """
        if self.aovals['accRoleName']:
            return self.aovals['accRoleName']
        else:
            return friendlyclassname + self.Class()
    
    #-----------------------------------------------------------
    def WindowText(self):
        """Window text of the control

        Quite  a few contorls have other text that is visible, for example
        Edit controls usually have an empty string for WindowText but still
        have text displayed in the edit window.
        """
        if self.aovals['accName']:
            return self.aovals['accName']
        else:
            return super(MFCWrapper, self).FriendlyClassName()
        
    
        
        
        


########NEW FILE########
__FILENAME__ = common_controls
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Classes that wrap the Windows Common controls"

__revision__ = "$Revision: 716 $"

import time
import ctypes

from .. import win32functions
from .. import win32defines
from .. import win32structures
from .. import findbestmatch
from . import HwndWrapper

from ..timings import Timings

class AccessDenied(RuntimeError):
    "Raised when we cannot allocate memory in the control's process"
    pass


# Todo: I should return iterators from things like Items() and Texts()
#       to save building full lists all the time
# Todo: ListViews should be based off of GetItem, and then have actions
#       Applied to that e.g. ListView.Item(xxx).Select(), rather then
#       ListView.Select(xxx)
#       Or at least most of the functions should call GetItem to get the
#       Item they want to work with.

#====================================================================
class _RemoteMemoryBlock(object):
    "Class that enables reading and writing memory in a different process"
    #----------------------------------------------------------------
    def __init__(self, handle, size = 8192):
        "Allocatte the memory"
        self.memAddress = 0

        self._as_parameter_ = self.memAddress

        process_id = ctypes.c_long()
        win32functions.GetWindowThreadProcessId(
            handle, ctypes.byref(process_id))

        self.process = win32functions.OpenProcess(
                win32defines.PROCESS_VM_OPERATION |
                win32defines.PROCESS_VM_READ |
                win32defines.PROCESS_VM_WRITE,
            0,
            process_id)

        if not self.process:
            raise AccessDenied(
                str(ctypes.WinError()) + "process: %d",
                process_id.value)

        if win32functions.GetVersion() < 2147483648:
            self.memAddress = win32functions.VirtualAllocEx(
                self.process,	# remote process
                0,				# let Valloc decide where
                size,			# how much to allocate
                    win32defines.MEM_RESERVE |
                    win32defines.MEM_COMMIT,	# allocation type
                win32defines.PAGE_READWRITE	# protection
                )

            if not self.memAddress:
                raise ctypes.WinError()

        else:
            raise RuntimeError("Win9x allocation not supported")

        self._as_parameter_ = self.memAddress


    #----------------------------------------------------------------
    def _CloseHandle(self):
        "Close the handle to the process."
        ret = win32functions.CloseHandle(self.process)

        if not ret:
            raise ctypes.WinError()

    #----------------------------------------------------------------
    def CleanUp(self):
        "Free Memory and the process handle"
        if self.process:
            # free up the memory we allocated
            ret = win32functions.VirtualFreeEx(
                self.process, self.memAddress, 0, win32defines.MEM_RELEASE)

            if not ret:
                self._CloseHandle()
                raise ctypes.WinError()

            self._CloseHandle()


    #----------------------------------------------------------------
    def __del__(self):
        "Ensure that the memory is Freed"
        # Free the memory in the remote process's address space
        self.CleanUp()

    #----------------------------------------------------------------
    def Address(self):
        "Return the address of the memory block"
        return self.memAddress

    #----------------------------------------------------------------
    def Write(self, data):
        "Write data into the memory block"
        # write the data from this process into the memory allocated
        # from the other process
        ret = win32functions.WriteProcessMemory(
            self.process,
            self.memAddress,
            ctypes.pointer(data),
            ctypes.sizeof(data),
            0);

        if not ret:
            raise ctypes.WinError()

    #----------------------------------------------------------------
    def Read(self, data, address = None):
        "Read data from the memory block"
        if not address:
            address = self.memAddress

        ret = win32functions.ReadProcessMemory(
            self.process, address, ctypes.byref(data), ctypes.sizeof(data), 0)

        # disabled as it often returns an error - but
        # seems to work fine anyway!!
        if not ret:
            raise ctypes.WinError()

        return data




#====================================================================
class ListViewWrapper(HwndWrapper.HwndWrapper):
    """Class that wraps Windows ListView common control

    This class derives from HwndWrapper - so has all the methods o
    that class also

    **see** HwndWrapper.HwndWrapper_

    .. _HwndWrapper.HwndWrapper: class-pywinauto.controls.HwndWrapper.HwndWrapper.html

    """

    friendlyclassname = "ListView"
    windowclasses = [
        "SysListView32", 
        r"WindowsForms\d*\.SysListView32\..*", 
        "TSysListView",
        "ListView20WndClass"]

    #----------------------------------------------------------------
    def __init__(self, hwnd):
        "Initialise the instance"
        super(ListViewWrapper, self).__init__(hwnd)

        self.writable_props.extend([
            'ColumnCount',
            'ItemCount',
            'Columns',
            'Items'])
        
        if self.IsUnicode():
            self.create_buffer = ctypes.create_unicode_buffer
            self.LVCOLUMN       = win32structures.LVCOLUMNW
            self.LVITEM         = win32structures.LVITEMW
            self.LVM_GETITEM    = win32defines.LVM_GETITEMW
            self.LVM_GETCOLUMN  = win32defines.LVM_GETCOLUMNW
        else:
            self.create_buffer = ctypes.create_string_buffer
            self.LVCOLUMN       = win32structures.LVCOLUMNW
            self.LVITEM         = win32structures.LVITEMW
            self.LVM_GETCOLUMN  = win32defines.LVM_GETCOLUMNA
            self.LVM_GETITEM    = win32defines.LVM_GETITEMA            

    #-----------------------------------------------------------
    def ColumnCount(self):
        """Return the number of columns"""
        if self.GetHeaderControl() is not None:
            return self.GetHeaderControl().ItemCount()
        return 0

    #-----------------------------------------------------------
    def ItemCount(self):
        "The number of items in the ListView"
        return self.SendMessage(win32defines.LVM_GETITEMCOUNT)

    #-----------------------------------------------------------
    def GetHeaderControl(self):
        "Returns the Header control associated with the ListView"
        #from wraphandle import WrapHandle
        #from HwndWrapper import WrapHandle

        try:
            return HwndWrapper.HwndWrapper(
                self.SendMessage(win32defines.LVM_GETHEADER))
        except HwndWrapper.InvalidWindowHandle:
            return None

    #-----------------------------------------------------------
    def GetColumn(self, col_index):
        "Get the information for a column of the ListView"

        col_props = {}

        col = self.LVCOLUMN()
        col.mask = \
            win32defines.LVCF_FMT | \
            win32defines.LVCF_IMAGE | \
            win32defines.LVCF_ORDER | \
            win32defines.LVCF_SUBITEM | \
            win32defines.LVCF_TEXT | \
            win32defines.LVCF_WIDTH

        remote_mem = _RemoteMemoryBlock(self)

        col.cchTextMax = 2000
        col.pszText = remote_mem.Address() + ctypes.sizeof(col) + 1

        # put the information in the memory that the
        # other process can read/write
        remote_mem.Write(col)

        # ask the other process to update the information
        retval = self.SendMessage(
            self.LVM_GETCOLUMN,
            col_index,
            remote_mem)

        col = remote_mem.Read(col)

        # if that succeeded then there was a column
        if retval:
            col = remote_mem.Read(col)

            text = self.create_buffer(1999)
            remote_mem.Read(text, col.pszText)

            col_props['order'] = col.iOrder
            col_props['text'] = text.value
            col_props['format'] = col.fmt
            col_props['width'] = col.cx
            col_props['image'] = col.iImage
            col_props['subitem'] = col.iSubItem

        del remote_mem

        return col_props

    #-----------------------------------------------------------
    def Columns(self):
        "Get the information on the columns of the ListView"
        cols = []

        for i in range(0,  self.ColumnCount()):
            cols.append(self.GetColumn(i))

        return cols

    #-----------------------------------------------------------
    def ColumnWidths(self):
        "Return a list of all the column widths"
        return [col['width'] for col in self.Columns()]

    #-----------------------------------------------------------
    def GetItemRect(self, item_index):
        "Return the bounding rectangle of the list view item"
        # set up a memory block in the remote application
        remote_mem = _RemoteMemoryBlock(self)
        rect = win32structures.RECT()

        rect.left = win32defines.LVIR_SELECTBOUNDS

        # Write the local RECT structure to the remote memory block
        remote_mem.Write(rect)

        # Fill in the requested item
        retval = self.SendMessage(
            win32defines.LVM_GETITEMRECT,
            item_index,
            remote_mem)

        # if it succeeded
        if not retval:
        	del remote_mem
        	raise RuntimeError("Did not succeed in getting rectangle")

        rect = remote_mem.Read(rect)

        del remote_mem

        return rect

    #-----------------------------------------------------------
    def _as_item_index(self, item):
        """Ensure that item is an item index

        If a string is passed in then it will be searched for in the
        list of item titles.
        """
        index = item
        if isinstance(item, str):
            index = (self.Texts().index(item) - 1) // self.ColumnCount()

        return index

    #-----------------------------------------------------------
    def GetItem(self, item_index, subitem_index = 0):
        """Return the item of the list view"

        * **item_index** Can be either the index of the item or a string
          with the text of the item you want returned.
        * **subitem_index** The 0 based index of the item you want returned.
          Defaults to 0.
        """

        item_data = {}

        # ensure the item_index is an integer or
        # convert it to one
        item_index = self._as_item_index(item_index)

        # set up a memory block in the remote application
        remote_mem = _RemoteMemoryBlock(self)

        # set up the item structure to get the text
        item = self.LVITEM()
        item.mask = \
            win32defines.LVIF_TEXT | \
            win32defines.LVIF_IMAGE | \
            win32defines.LVIF_INDENT | \
            win32defines.LVIF_STATE

        item.iItem = item_index
        item.iSubItem = subitem_index
        item.stateMask = ctypes.c_uint(-1)

        item.cchTextMax = 2000
        item.pszText = remote_mem.Address() + \
            ctypes.sizeof(item) + 1

        # Write the local LVITEM structure to the remote memory block
        remote_mem.Write(item)

        # Fill in the requested item
        retval = self.SendMessage(
            self.LVM_GETITEM,
            item_index,
            remote_mem)

        # if it succeeded
        if retval:

            remote_mem.Read(item)

            # Read the remote text string
            char_data = self.create_buffer(2000)
            remote_mem.Read(char_data, item.pszText)

            # and add it to the titles
            item_data['text'] = char_data.value
            item_data['state'] = item.state
            item_data['image'] = item.iImage
            item_data['indent'] = item.iIndent

        else:
            raise RuntimeError(
                "We should never get to this part of ListView.GetItem()")

        del remote_mem

        return item_data

    #-----------------------------------------------------------
    def Items(self):
        "Get all the items in the list view"
        colcount = self.ColumnCount()

        if not colcount:
            colcount = 1

        items = []
        # now get the item values...
        # for each of the rows
        for item_index in range(0, self.ItemCount()):

            # and each of the columns for that row
            for subitem_index in range(0, colcount):

                # get the item
                items.append(self.GetItem(item_index, subitem_index))

        return items

    #-----------------------------------------------------------
    def Texts(self):
        "Get the texts for the ListView control"
        texts = [self.WindowText()]
        texts.extend([item['text'] for item in self.Items()])
        return texts

    #-----------------------------------------------------------
    def UnCheck(self, item):
        "Uncheck the ListView item"

        self.VerifyActionable()

        # ensure the item is an integer or
        # convert it to one
        item = self._as_item_index(item)

        lvitem = self.LVITEM()

        lvitem.mask = win32defines.LVIF_STATE
        lvitem.state = 0x1000
        lvitem.stateMask = win32defines.LVIS_STATEIMAGEMASK

        remote_mem = _RemoteMemoryBlock(self)
        remote_mem.Write(lvitem)

        self.SendMessageTimeout(
            win32defines.LVM_SETITEMSTATE, item, remote_mem)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_listviewcheck_wait)

        del remote_mem

    #-----------------------------------------------------------
    def Check(self, item):
        "Check the ListView item"

        self.VerifyActionable()

        # ensure the item is an integer or
        # convert it to one
        item = self._as_item_index(item)

        lvitem = self.LVITEM()

        lvitem.mask = win32defines.LVIF_STATE
        lvitem.state = 0x2000
        lvitem.stateMask = win32defines.LVIS_STATEIMAGEMASK

        remote_mem = _RemoteMemoryBlock(self)
        remote_mem.Write(lvitem)

        self.SendMessageTimeout(
            win32defines.LVM_SETITEMSTATE, item, remote_mem)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_listviewcheck_wait)

        del remote_mem

    #-----------------------------------------------------------
    def IsChecked(self, item):
        "Return whether the ListView item is checked or not"

        # ensure the item is an integer or
        # convert it to one
        item = self._as_item_index(item)

        state = self.SendMessage(
            win32defines.LVM_GETITEMSTATE,
            item,
            win32defines.LVIS_STATEIMAGEMASK)

        return state & 0x2000 == 0x2000

    #-----------------------------------------------------------
    def IsSelected(self, item):
        "Return True if the item is selected"

        # ensure the item is an integer or
        # convert it to one
        item = self._as_item_index(item)

        return win32defines.LVIS_SELECTED == self.SendMessage(
            win32defines.LVM_GETITEMSTATE, item, win32defines.LVIS_SELECTED)

    #-----------------------------------------------------------
    def IsFocused(self, item):
        "Return True if the item has the focus"

        # ensure the item is an integer or
        # convert it to one
        item = self._as_item_index(item)

        return win32defines.LVIS_FOCUSED == self.SendMessage(
            win32defines.LVM_GETITEMSTATE, item, win32defines.LVIS_FOCUSED)

    #-----------------------------------------------------------
    def _modify_selection(self, item, to_select):
        """Change the selection of the item

        item is the item you want to change
        to_select should be True to select the item and false
        to deselect the item
        """

        self.VerifyActionable()

        # ensure the item is an integer or
        # convert it to one
        item = self._as_item_index(item)

        if item >= self.ItemCount():
            raise IndexError("There are only %d items in the list view not %d"%
                (self.ItemCount(), item + 1))

        # first we need to change the state of the item
        lvitem = self.LVITEM()
        lvitem.mask = win32defines.LVIF_STATE

        if to_select:
            lvitem.state = win32defines.LVIS_SELECTED

        lvitem.stateMask = win32defines.LVIS_SELECTED

        remote_mem = _RemoteMemoryBlock(self)
        remote_mem.Write(lvitem)

        self.SendMessageTimeout(
            win32defines.LVM_SETITEMSTATE, item, remote_mem)

        # now we need to notify the parent that the state has chnaged
        nmlv = win32structures.NMLISTVIEW()
        nmlv.hdr.hwndFrom = self.handle
        nmlv.hdr.idFrom = self.ControlID()
        nmlv.hdr.code = win32defines.LVN_ITEMCHANGING

        nmlv.iItem = item
        #nmlv.iSubItem = 0
        nmlv.uNewState = win32defines.LVIS_SELECTED
        #nmlv.uOldState = 0
        nmlv.uChanged = win32defines.LVIS_SELECTED
        nmlv.ptAction = win32structures.POINT()

        remote_mem.Write(nmlv)

        self.Parent().SendMessageTimeout(
            win32defines.WM_NOTIFY,
            self.ControlID(),
            remote_mem)

        del remote_mem

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_listviewselect_wait)

    #-----------------------------------------------------------
    def Select(self, item):
        """Mark the item as selected

        The ListView control must be enabled and visible before an
        Item can be selected otherwise an exception is raised"""
        self._modify_selection(item, True)

    #-----------------------------------------------------------
    def Deselect(self, item):
        """Mark the item as not selected

        The ListView control must be enabled and visible before an
        Item can be selected otherwise an exception is raised"""
        self._modify_selection(item, False)

    # Naming is not clear - so create an alias.
    #UnSelect = Deselect

    #-----------------------------------------------------------
    def GetSelectedCount(self):
        "Return the number of selected items"

        return self.SendMessage(win32defines.LVM_GETSELECTEDCOUNT)



    # commented out as we can get these strings from the header
    #					col = remote_mem.Read(col)
    #
    #                   charData = ctypes.create_unicode_buffer(2000)
    #
    #					ret = remote_mem.Read(charData, col.pszText)
    #
    #					self.Titles.append(charData.value)
    #				else:
    #					break



class _treeview_element(object):
    "Wrapper around TreeView items"
    #----------------------------------------------------------------
    def __init__(self, elem, tv_handle):
        "Initialize the item"
        self.tree_ctrl = tv_handle
        self.elem = elem
        self._as_parameter_ = self.elem

    #----------------------------------------------------------------
    def Text(self):
        "Return the text of the item"
        return self._readitem()[1]

    #----------------------------------------------------------------
    def Item(self):
        "Return the item itself"
        return self._readitem()[0]

    #----------------------------------------------------------------
    def State(self):
        "Return the state of the item"
        return self.Item().state

    #----------------------------------------------------------------
    def Rectangle(self, text_area_rect = True):
        """Return the rectangle of the item

        If text_area_rect is set to False then it will return
        the rectangle for the whole item (usually left is equal to 0).
        Defaults to True - which returns just the rectangle of the
        text of the item
        """
        remote_mem = _RemoteMemoryBlock(self.tree_ctrl)

        # this is a bit weird
        # we have to write the element handle
        # but we read the Rectangle afterwards!
        remote_mem.Write(ctypes.c_long(self.elem))

        ret = self.tree_ctrl.SendMessage(
            win32defines.TVM_GETITEMRECT, text_area_rect, remote_mem)

        # the item is not visible
        if not ret:
            rect = None
        else:
            # OK - it's visible so read it
            rect = win32structures.RECT()
            remote_mem.Read(rect)

        del remote_mem
        return rect


    #----------------------------------------------------------------
    def Click(self, button = "left", double = False, where = "text"):
        """Click on the treeview item

        where can be any one of "text", "icon", "button"
        defaults to "text"
        """

        # find the text rectangle for the item,
        point_to_click = self.Rectangle().mid_point()

        if where.lower() != "text":
            remote_mem = _RemoteMemoryBlock(self.tree_ctrl)

            point_to_click.x = self.Rectangle().left

            found = False
            while not found and point_to_click.x >= 0:

                hittest = win32structures.TVHITTESTINFO()
                hittest.pt = point_to_click
                hittest.hItem = self.elem

                remote_mem.Write(hittest)

                self.tree_ctrl.SendMessage(win32defines.TVM_HITTEST, 0, remote_mem)
                remote_mem.Read(hittest)

                if where.lower() == 'button' and \
                    hittest.flags == win32defines.TVHT_ONITEMBUTTON:
                    found = True
                    break

                if where.lower() == 'icon' and \
                    hittest.flags == win32defines.TVHT_ONITEMICON:
                    found = True
                    break

                point_to_click.x -= 1

            if not found:
                raise Exception("Area ('%s') not found for this tree view item"% where)

        self.tree_ctrl.ClickInput(
            button,
            coords = (point_to_click.x, point_to_click.y),
            double = double)

        # if we use click instead of clickInput - then we need to tell the
        # treeview to update itself
        #self.tree_ctrl.

    #----------------------------------------------------------------
    # TODO: add code for this
    def Collapse(self):
        "Collapse the children of this tree view item"
        pass

    #----------------------------------------------------------------
    def Expand(self):
        "Expand the children of this tree view item"
        self.tree_ctrl.SendMessageTimeout(
            win32defines.TVM_EXPAND,
            win32defines.TVE_EXPAND,
            self)


    #----------------------------------------------------------------
    def Children(self):
        "Return the direct children of this control"
        if self.Item().cChildren not in (0, 1):
            print("##### not dealing with that TVN_GETDISPINFO stuff yet")
            pass

        ## No children
        #if self.__item.cChildren == 0:
        #    pass

        children = []
        if self.Item().cChildren == 1:

            # Get the first child of this element
            child_elem = self.tree_ctrl.SendMessage(
                win32defines.TVM_GETNEXTITEM,
                win32defines.TVGN_CHILD,
                self.elem)

            if child_elem:
                children.append(_treeview_element(child_elem, self.tree_ctrl))

                # now get all the next children
                while True:
                    next_child = children[-1].Next()

                    if next_child is not None:
                        children.append(next_child)
                    else:
                        break

            #else:
            #    raise ctypes.WinError()

        return children

    #----------------------------------------------------------------
    def Next(self):
        "Return the next item"
        # get the next element
        next_elem = self.tree_ctrl.SendMessage(
            win32defines.TVM_GETNEXTITEM,
            win32defines.TVGN_NEXT,
            self.elem)

        if next_elem:
            return _treeview_element(next_elem, self.tree_ctrl)

        return None
        # don't raise - as it just meant that there was no
        # next
        #else:
        #    raise ctypes.WinError()

    #def Click(self):
    #    print self.Rectangle()
    #    self.t

    #----------------------------------------------------------------
    def SubElements(self):
        "Return the list of Children of this control"
        sub_elems = []

        for child in self.Children():
            sub_elems.append(child)

            sub_elems.extend(child.SubElements())

        return sub_elems

    #----------------------------------------------------------------
    def GetChild(self, child_spec):
        """Return the child item of this item

        Accepts either a string or an index.
        If a string is passed then it returns the child item
        with the best match for the string."""

        #print child_spec


        if isinstance(child_spec, str):

            texts = [c.Text() for c in self.Children()]
            indices = list(range(0, len(texts)))
            index = findbestmatch.find_best_match(
                child_spec, texts, indices, limit_ratio = .6)

            #if len(matching) > 1 :
            #    raise RuntimeError(
            #        "There are multiple children that match that spec '%s'"%
            #            child_spec)

        else:
            index = child_spec

        return self.Children()[index]


    #----------------------------------------------------------------
    def _readitem(self):
        "Read the treeview item"
        remote_mem = _RemoteMemoryBlock(self.tree_ctrl)

        item = win32structures.TVITEMW()
        item.mask =  win32defines.TVIF_TEXT | \
            win32defines.TVIF_HANDLE | \
            win32defines.TVIF_CHILDREN | \
            win32defines.TVIF_STATE

        # set the address for the text
        item.pszText = remote_mem.Address() + ctypes.sizeof(item) + 1
        item.cchTextMax = 2000
        item.hItem = self.elem
        item.stateMask = -1

        # Write the local TVITEM structure to the remote memory block
        remote_mem.Write(item)

        # read the entry
        retval = win32functions.SendMessage(
            self.tree_ctrl,
            win32defines.TVM_GETITEMW,
            0,
            remote_mem)

        text = ''
        if retval:
            remote_mem.Read(item)

            #self.__item = item
            # Read the remote text string
            char_data = ctypes.create_unicode_buffer(2000)
            remote_mem.Read(char_data, item.pszText)

            text = char_data.value
        else:
            # seems that this may not always be correct
            raise ctypes.WinError()

        return item, text



#====================================================================
class TreeViewWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows TreeView common control"

    friendlyclassname = "TreeView"
    windowclasses = [
        "SysTreeView32", r"WindowsForms\d*\.SysTreeView32\..*", "TTreeView"]

    #----------------------------------------------------------------
    def __init__(self, hwnd):
        "Initialise the instance"
        super(TreeViewWrapper, self).__init__(hwnd)

    #----------------------------------------------------------------
    def ItemCount(self):
        "Return the count of the items in the treeview"
        return self.SendMessage(win32defines.TVM_GETCOUNT)

    #----------------------------------------------------------------
    def Texts(self):
        "Return all the text for the tree view"
        texts = [self.WindowText(), ]
        if self.ItemCount():
            texts.append(self.Root().Text())
            elements = self.Root().SubElements()

            texts.extend([elem.Text() for elem in elements])

        return texts

    #----------------------------------------------------------------
    def Root(self):
        "Return the root element of the tree view"
        # get the root item:
        root_elem = self.SendMessage(
            win32defines.TVM_GETNEXTITEM,
            win32defines.TVGN_ROOT)

        # Sometimes there is no root element
        if not root_elem:
            return None

        return _treeview_element(root_elem, self)

    #----------------------------------------------------------------
    def Roots(self):
        roots = []

        cur_elem = self.Root()
        while cur_elem:
            roots.append(cur_elem)

            cur_elem = cur_elem.Next()

        return roots

    #----------------------------------------------------------------
    def GetProperties(self):
        "Get the properties for the control as a dictionary"
        props = super(TreeViewWrapper, self).GetProperties()

        props['ItemCount'] = self.ItemCount()

        return props

    #----------------------------------------------------------------
    def GetItem(self, path):
        """Read the TreeView item

        * **path** the path to the item to return. This can be one of
          the following:

          * A string separated by \\ characters. The first character must
            be \\. This string is split on the \\ characters and each of
            these is used to find the specific child at each level. The
            \\ represents the root item - so you don't need to specify the
            root itself.
          * A list/tuple of strings - The first item should be the root
            element.
          * A list/tuple of integers - The first item the index which root
            to select.
        """

        # work just based on integers for now

        if not self.ItemCount():
            return None

        # Ensure the path is absolute
        if isinstance(path, str):
            if not path.startswith("\\"):
                raise RuntimeError(
                    "Only absolute paths allowed - "
                    "please start the path with \\")

            path = path.split("\\")[1:]

        current_elem = None

        # find the correct root elem
        if isinstance(path[0], int):
            current_elem = self.Roots()[path[0]]

        else:
            texts = [r.Text() for r in self.Roots()]
            indices = list(range(0, len(texts)))
            try:
                current_elem = findbestmatch.find_best_match(
                    path[0], texts, self.Roots(), limit_ratio = .6)
            except IndexError:
                raise IndexError("There is no root element '%s'"% path[0])

        # get the correct lowest level item
#        current_elem.GetChild
#        for i in range(0, path[0]):
#            current_elem = current_elem.Next()
#
#            if current_elem is None:
#                raise IndexError("Root Item '%s' does not have %d sibling(s)"%
#                    (self.Root().WindowText(), i + 1))
#
        # remove the first (empty) item and the root element as we have
        # dealt with it (string or integer)
        path = path[1:]

        # now for each of the lower levels
        # just index into it's children
        for child_spec in path:

            # ensure that the item is expanded (as this is sometimes required
            # for loading the tree view branches
            current_elem.Expand()

            try:
                current_elem = current_elem.GetChild(child_spec)
            except IndexError:
                if isinstance(child_spec, str):
                    raise IndexError("Item '%s' does not have a child '%s'"%
                        (current_elem.Text(), child_spec))
                else:
                    raise IndexError("Item '%s' does not have %d children"%
                        (current_elem.WindowText(), child_spec + 1))


            #self.SendMessageTimeout(
            #    win32defines.TVM_EXPAND,
            #    win32defines.TVE_EXPAND,
            #    current_elem)

        return  current_elem

    #----------------------------------------------------------------
    def Select(self, path):
        "Select the treeview item"
        elem = self.GetItem(path)
        self.SendMessageTimeout(
            win32defines.TVM_SELECTITEM, # message
            win32defines.TVGN_CARET,     # how to select
            elem)                 # item to select

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_treeviewselect_wait)

    #-----------------------------------------------------------
    def IsSelected(self, path):
        "Return True if the item is selected"
        return win32defines.TVIS_SELECTED  == (win32defines.TVIS_SELECTED & \
            self.GetItem(path).State())

    #----------------------------------------------------------------
    def EnsureVisible(self, path):
        "Make sure that the TreeView item is visible"
        elem = self.GetItem(path)
        self.SendMessageTimeout(
            win32defines.TVM_ENSUREVISIBLE, # message
            win32defines.TVGN_CARET,     # how to select
            elem)                 # item to select

        win32functions.WaitGuiThreadIdle(self)


#
#   #-----------------------------------------------------------
#    def UnCheck(self, path):
#        "Uncheck the ListView item"
#
#        self.VerifyActionable()
#
#        elem = self.GetItem(path)
#
##        lvitem = win32structures.LVITEMW()
##
##        lvitem.mask = win32defines.LVIF_STATE
##        lvitem.state = 0x1000
##        lvitem.stateMask = win32defines.LVIS_STATEIMAGEMASK
##
##        remote_mem = _RemoteMemoryBlock(self)
##        remote_mem.Write(lvitem)
##
##        self.SendMessage(
##            win32defines.LVM_SETITEMSTATE, item, remote_mem)
##
##        del remote_mem
#
#
#    #-----------------------------------------------------------
#    def Check(self, path):
#        "Check the ListView item"
#
#        self.VerifyActionable()
#
#        elem = self.GetItem(path)
#
#        #lvitem = win32structures.LVITEMW()
#
#        lvitem.mask = win32defines.LVIF_STATE
#        lvitem.state = 0x2000
#        lvitem.stateMask = win32defines.LVIS_STATEIMAGEMASK
#
#        remote_mem = _RemoteMemoryBlock(self)
#        remote_mem.Write(lvitem)
#
#        self.SendMessage(
#            win32defines.LVM_SETITEMSTATE, item, remote_mem)
#
#        del remote_mem
#
#    #-----------------------------------------------------------
#    def IsChecked(self, path):
#        "Return whether the ListView item is checked or not"
#
#        elem = self.GetItem(path)
#
#        elem.State
#
#        state = self.SendMessage(
#            win32defines.LVM_GETITEMSTATE,
#            item,
#            win32defines.LVIS_STATEIMAGEMASK)
#
#        return state & 0x2000
#




#====================================================================
class HeaderWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows ListView Header common control "

    friendlyclassname = "Header"
    windowclasses = ["SysHeader32", "msvb_lib_header"]

    #----------------------------------------------------------------
    def __init__(self, hwnd):
        "Initialise the instance"
        super(HeaderWrapper, self).__init__(hwnd)

    #----------------------------------------------------------------
    def ItemCount(self):
        "Return the number of columns in this header"
        # get the number of items in the header...
        return self.SendMessage(win32defines.HDM_GETITEMCOUNT)

    #----------------------------------------------------------------
    def GetColumnRectangle(self, column_index):
        "Return the rectangle for the column specified by column_index"

        remote_mem = _RemoteMemoryBlock(self)
        # get the column rect
        rect = win32structures.RECT()
        remote_mem.Write(rect)
        retval = self.SendMessage(
            win32defines.HDM_GETITEMRECT,
            column_index,
            remote_mem)

        if retval:
            rect = remote_mem.Read(rect)
        else:
            raise ctypes.WinError()

        del remote_mem

        return rect

    #----------------------------------------------------------------
    def ClientRects(self):
        "Return all the client rectangles for the header control"
        rects = [self.ClientRect(), ]

        for col_index in range(0, self.ItemCount()):

            rects.append(self.GetColumnRectangle(col_index))

        return rects


    #----------------------------------------------------------------
    def GetColumnText(self, column_index):
        "Return the text for the column specified by column_index"

        remote_mem = _RemoteMemoryBlock(self)

        item = win32structures.HDITEMW()
        item.mask = win32defines.HDI_FORMAT | \
            win32defines.HDI_WIDTH | \
            win32defines.HDI_TEXT #| HDI_ORDER
        item.cchTextMax = 2000

        # set up the pointer to the text
        # it should be at the
        item.pszText = remote_mem.Address() + ctypes.sizeof(item) + 1

        # put the information in the memory that the
        # other process can read/write
        remote_mem.Write(item)

        # ask the other process to update the information
        retval = self.SendMessage(
            win32defines.HDM_GETITEMW,
            column_index,
            remote_mem)

        if retval:
            item = remote_mem.Read(item)

            # Read the remote text string
            char_data = ctypes.create_unicode_buffer(2000)
            remote_mem.Read(char_data, item.pszText)
            return char_data.value

        return None

    #----------------------------------------------------------------
    def Texts(self):
        "Return the texts of the Header control"
        texts = [self.WindowText(), ]
        for i in range(0, self.ItemCount()):
            texts.append(self.GetColumnText(i))

        return texts

#    #----------------------------------------------------------------
#    def _fill_header_info(self):
#        "Get the information from the header control"
#        remote_mem = _RemoteMemoryBlock(self)
#
#        for col_index in range(0, self.Count()):
#
#            item = win32structures.HDITEMW()
#            item.mask = win32defines.HDI_FORMAT | \
#                win32defines.HDI_WIDTH | \
#                win32defines.HDI_TEXT #| HDI_ORDER
#            item.cchTextMax = 2000
#
#            # set up the pointer to the text
#            # it should be at the
#            item.pszText = remote_mem.Address() + ctypes.sizeof(item) + 1
#
#            # put the information in the memory that the
#            # other process can read/write
#            remote_mem.Write(item)
#
#            # ask the other process to update the information
#            retval = self.SendMessage(
#                win32defines.HDM_GETITEMW,
#                col_index,
#                remote_mem)
#
#            if retval:
#                item = remote_mem.Read(item)
#
#                # Read the remote text string
#                charData = ctypes.create_unicode_buffer(2000)
#                remote_mem.Read(charData, item.pszText)
#                self._extra_texts.append(charData.value)


#====================================================================
class StatusBarWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows Status Bar common control "

    friendlyclassname = "StatusBar"
    windowclasses = [
        "msctls_statusbar32",
        "HSStatusBar",
        r"WindowsForms\d*\.msctls_statusbar32\..*"]

    #----------------------------------------------------------------
    def __init__(self, hwnd):
        "Initialise the instance"
        super(StatusBarWrapper, self).__init__(hwnd)

        self.writable_props.extend([
            'BorderWidths',
            'PartCount',
            'PartRightEdges',

        ])

    #----------------------------------------------------------------
    def BorderWidths(self):
        """Return the border widths of the StatusBar

        A dictionary of the 3 available widths is returned:
        Horizontal - the horizontal width
        Vertical - The width above and below the status bar parts
        Inter - The width between parts of the status bar
        """
        remote_mem = _RemoteMemoryBlock(self)

        # get the borders for each of the areas there can be a border.
        borders = (ctypes.c_int*3)()
        remote_mem.Write(borders)
        self.SendMessage(
            win32defines.SB_GETBORDERS,
            0,
            remote_mem
        )
        borders = remote_mem.Read(borders)
        borders_widths = {}
        borders_widths['Horizontal'] = borders[0]
        borders_widths['Vertical'] = borders[1]
        borders_widths['Inter'] = borders[2]

        del remote_mem

        return borders_widths

    #----------------------------------------------------------------
    def PartCount(self):
        "Return the number of parts"
        # get the number of parts for this status bar
        return self.SendMessage(
            win32defines.SB_GETPARTS,
            0,
            0 )

    #----------------------------------------------------------------
    def PartRightEdges(self):
        "Return the widths of the parts"
        remote_mem = _RemoteMemoryBlock(self)

        # get the number of parts for this status bar
        parts = (ctypes.c_int * self.PartCount())()
        remote_mem.Write(parts)
        self.SendMessage(
            win32defines.SB_GETPARTS,
            self.PartCount(),
            remote_mem
        )

        parts = remote_mem.Read(parts)

        del remote_mem

        return [int(part) for part in parts]

    #----------------------------------------------------------------
    def GetPartRect(self, part_index):
        "Return the rectangle of the part specified by part_index"

        if part_index >= self.PartCount():
            raise IndexError(
                "Only %d parts available you asked for part %d (zero based)" % (
                self.PartCount(),
                part_index))


        remote_mem = _RemoteMemoryBlock(self)

        # get the rectangle for this item
        rect = win32structures.RECT()
        remote_mem.Write(rect)
        self.SendMessage(
            win32defines.SB_GETRECT,
            part_index,
            remote_mem)

        rect = remote_mem.Read(rect)
        del remote_mem
        return rect

    #----------------------------------------------------------------
    def ClientRects(self):
        "Return the client rectangles for the control"
        rects = [self.ClientRect()]

        for i in range(self.PartCount()):
            rects.append(self.GetPartRect(i))

        return rects

    #----------------------------------------------------------------
    def GetPartText(self, part_index):
        "Return the text of the part specified by part_index"

        if part_index >= self.PartCount():
            raise IndexError(
                "Only %d parts available you asked for part %d (zero based)" % (
                self.PartCount(),
                part_index))

        remote_mem = _RemoteMemoryBlock(self)

        textlen = self.SendMessage(
            win32defines.SB_GETTEXTLENGTHW,
            part_index,
            0
        )

        #draw_operation = win32functions.HiWord(textlen)
        textlen = win32functions.LoWord(textlen)

        # get the text for this item
        text = ctypes.create_unicode_buffer(textlen + 1)
        remote_mem.Write(text)
        self.SendMessage(
            win32defines.SB_GETTEXTW,
            part_index,
            remote_mem
        )

        text = remote_mem.Read(text)

        del remote_mem
        return text.value


    #----------------------------------------------------------------
    def Texts(self):
        "Return the texts for the control"
        texts = [self.WindowText()]

        for i in range(self.PartCount()):
            texts.append(self.GetPartText(i))

        return texts




#====================================================================
class TabControlWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows Tab common control "

    friendlyclassname = "TabControl"
    windowclasses = [
        "SysTabControl32",
        r"WindowsForms\d*\.SysTabControl32\..*"]

    #----------------------------------------------------------------
    def __init__(self, hwnd):
        "Initialise the instance"
        super(TabControlWrapper, self).__init__(hwnd)

        #self.writable_props.append("TabStates")

    #----------------------------------------------------------------
    def RowCount(self):
        "Return the number of rows of tabs"
        return self.SendMessage(win32defines.TCM_GETROWCOUNT)

    #----------------------------------------------------------------
    def GetSelectedTab(self):
        "Return the index of the selected tab"
        return self.SendMessage(win32defines.TCM_GETCURSEL)

    #----------------------------------------------------------------
    def TabCount(self):
        "Return the number of tabs"
        return self.SendMessage(win32defines.TCM_GETITEMCOUNT)

    #----------------------------------------------------------------
    def GetTabRect(self, tab_index):
        "Return the rectangle to the tab specified by tab_index"

        if tab_index >= self.TabCount():
            raise IndexError(
                "Only %d tabs available you asked for tab %d (zero based)" % (
                self.TabCount(),
                tab_index))

        remote_mem = _RemoteMemoryBlock(self)

        rect = win32structures.RECT()
        remote_mem.Write(rect)

        self.SendMessage(
            win32defines.TCM_GETITEMRECT, tab_index, remote_mem)

        remote_mem.Read(rect)

        del remote_mem

        return rect

#    #----------------------------------------------------------------
#    def GetTabState(self, tab_index):
#        "Return the state of the tab"
#
#        if tab_index >= self.TabCount():
#            raise IndexError(
#                "Only %d tabs available you asked for tab %d (zero based)" % (
#                self.TabCount(),
#                tab_index))
#
#        remote_mem = _RemoteMemoryBlock(self)
#
#        item = win32structures.TCITEMW()
#        item.mask = win32defines.TCIF_STATE
#        remote_mem.Write(item)
#
#        ret = self.SendMessage(
#            win32defines.TCM_GETITEMW, tab_index, remote_mem)
#
#        remote_mem.Read(item)
#        del remote_mem
#
#        if not ret:
#            raise ctypes.WinError()
#
#        return item.dwState

    #----------------------------------------------------------------
    def GetTabText(self, tab_index):
        "Return the text of the tab"

        if tab_index >= self.TabCount():
            raise IndexError(
                "Only %d tabs available you asked for tab %d (zero based)" % (
                self.TabCount(),
                tab_index))

        remote_mem = _RemoteMemoryBlock(self)

        item = win32structures.TCITEMW()
        item.mask = win32defines.TCIF_TEXT
        item.cchTextMax = 1999
        item.pszText = remote_mem.Address() + ctypes.sizeof(item)
        remote_mem.Write(item)

        self.SendMessage(
            win32defines.TCM_GETITEMW, tab_index, remote_mem)

        remote_mem.Read(item)

        # Read the text that has been written
        text = ctypes.create_unicode_buffer(2000)
        text = remote_mem.Read(text, remote_mem.Address() + \
            ctypes.sizeof(item))

        return text.value

    #----------------------------------------------------------------
    def GetProperties(self):
        "Return the properties of the TabControl as a Dictionary"
        props = super(TabControlWrapper, self).GetProperties()

        props['TabCount'] = self.TabCount()


        return props

#    #----------------------------------------------------------------
#    def TabStates(self):
#        "Return the tab state for all the tabs"
#        states = []
#        for i in range(0, self.TabCount()):
#            states.append(self.GetTabState(i))
#        return states

    #----------------------------------------------------------------
    def ClientRects(self):
        "Return the client rectangles for the Tab Control"

        rects = [self.ClientRect()]
        for tab_index in range(0, self.TabCount()):
            rects.append(self.GetTabRect(tab_index))

        return rects

    #----------------------------------------------------------------
    def Texts(self):
        "Return the texts of the Tab Control"
        texts = [self.WindowText()]

        for i in range(0, self.TabCount()):
            texts.append(self.GetTabText(i))

        return texts

    #----------------------------------------------------------------
    def Select(self, tab):
        "Select the specified tab on the tab control"

        self.VerifyActionable()

        # if it's a string then find the index of
        # the tab with that text
        if isinstance(tab, str):
            # find the string in the tab control
            best_text = findbestmatch.find_best_match(
                tab, self.Texts(), self.Texts())
            tab = self.Texts().index(best_text) - 1

        if tab >= self.TabCount():
            raise IndexError(
                "Only %d tabs available you asked for tab %d (zero based)" % (
                self.TabCount(),
                tab))

        self.SendMessageTimeout(win32defines.TCM_SETCURFOCUS, tab)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_tabselect_wait)

        return self






#====================================================================
class _toolbar_button(object):
    "Wrapper around Toolbar button (TBBUTTONINFO) items"
    #----------------------------------------------------------------
    def __init__(self, index_, tb_handle):
        "Initialize the item"
        self.toolbar_ctrl = tb_handle
        self.index = index_

        self.info = win32structures.TBBUTTONINFOW()
        self.info.cbSize = ctypes.sizeof(self.info)
        self.info.dwMask = \
            win32defines.TBIF_COMMAND | \
            win32defines.TBIF_SIZE | \
            win32defines.TBIF_STYLE | \
            win32defines.TBIF_IMAGE | \
            win32defines.TBIF_LPARAM | \
            win32defines.TBIF_STATE | \
            win32defines.TBIF_TEXT  | \
            win32defines.TBIF_BYINDEX
            #win32defines.TBIF_IMAGELABEL

        self.info.cchText = 2000

        remote_mem = _RemoteMemoryBlock(self.toolbar_ctrl)

        # set the text address to after the structures
        self.info.pszText = remote_mem.Address() + \
            ctypes.sizeof(self.info)

        # fill the info structure
        remote_mem.Write(self.info)
        ret = self.toolbar_ctrl.SendMessage(
            win32defines.TB_GETBUTTONINFOW,
            self.index,
            remote_mem)
        remote_mem.Read(self.info)

        if ret == -1:
            del remote_mem
            raise RuntimeError(
                "GetButtonInfo failed for button with index %d"% self.index)

        # read the text
        self.info.text = ctypes.create_unicode_buffer(1999)
        remote_mem.Read(self.info.text, remote_mem.Address() + \
            ctypes.sizeof(self.info))

        self.info.text = self.info.text.value

        del remote_mem



    #----------------------------------------------------------------
    def Rectangle(self):
        "Get the rectangle of a button on the toolbar"

        remote_mem = _RemoteMemoryBlock(self.toolbar_ctrl)

        rect = win32structures.RECT()

        remote_mem.Write(rect)

        self.toolbar_ctrl.SendMessage(
            win32defines.TB_GETRECT,
            self.info.idCommand,
            remote_mem)

        rect = remote_mem.Read(rect)

        del remote_mem

        return rect

#    #----------------------------------------------------------------
#    def Press(self, press = True):
#        "Find where the button is and click it"
#
#        if press:
#            press_flag = win32functions.MakeLong(0, 1)
#        else:
#            press_flag = 0
#
#        ret = self.toolbar_ctrl.SendMessageTimeout(
#            win32defines.TB_PRESSBUTTON,
#            self.info.idCommand,
#            press_flag)
#
#        # Notify the parent that we are finished selecting
#        #self.toolbar_ctrl.NotifyParent(win32defines.TBN_TOOLBARCHANGE)
#
#        win32functions.WaitGuiThreadIdle(self.toolbar_ctrl)
#        time.sleep(Timings.after_toobarpressbutton_wait)
#
#    #----------------------------------------------------------------
#    def Press(self):
#        "Find where the button is and click it"
#        self.Press(press = False)
#
#    #----------------------------------------------------------------
#    def Check(self, check = True):
#        "Find where the button is and click it"
#
#        if check:
#            check_flag = win32functions.MakeLong(0, 1)
#        else:
#            check_flag = 0
#
#        ret = self.toolbar_ctrl.SendMessageTimeout(
#            win32defines.TB_CHECKBUTTON,
#            self.info.idCommand,
#            check_flag)
#
#        # Notify the parent that we are finished selecting
#        #self.toolbar_ctrl.NotifyParent(win32defines.TBN_TOOLBARCHANGE)
#
#        win32functions.WaitGuiThreadIdle(self.toolbar_ctrl)
#        time.sleep(Timings.after_toobarpressbutton_wait)
#
#    #----------------------------------------------------------------
#    def UnCheck(self):
#        self.Check(check = False)

    #----------------------------------------------------------------
    def Style(self, AND = -1):
        "Return the style of the button"
        return self.toolbar_ctrl.SendMessageTimeout(
            win32defines.TB_GETSTYLE, self.info.idCommand)

    #----------------------------------------------------------------
    def State(self, AND = -1):
        "Return the state of the button"
        return self.toolbar_ctrl.SendMessageTimeout(
            win32defines.TB_GETSTATE, self.info.idCommand)

    #----------------------------------------------------------------
    def IsCheckable(self):
        "Return if the button can be checked"
        return self.Style() & win32defines.TBSTYLE_CHECK

    #----------------------------------------------------------------
    def IsPressable(self):
        "Return if the button can be pressed"
        return self.Style() & win32defines.TBSTYLE_BUTTON

    #----------------------------------------------------------------
    def IsChecked(self):
        "Return if the button is in the checked state"
        return self.State() & win32defines.TBSTATE_CHECKED

    #----------------------------------------------------------------
    def IsPressed(self):
        "Return if the button is in the pressed state"
        return self.State() & win32defines.TBSTATE_PRESSED

    #----------------------------------------------------------------
    def IsEnabled(self):
        "Return if the button is in the pressed state"

        # make sure it has an ID
        if not self.info.idCommand:
            return False

        return self.State() & win32defines.TBSTATE_ENABLED

    #----------------------------------------------------------------
    def Click(self):
        "Left click on the Toolbar button"
        self.toolbar_ctrl.Click(coords = self.Rectangle())
        time.sleep(Timings.after_toobarpressbutton_wait)

    #----------------------------------------------------------------
    def ClickInput(self):
        "Left click on the Toolbar button"
        self.toolbar_ctrl.ClickInput(coords = self.Rectangle())
        time.sleep(Timings.after_toobarpressbutton_wait)

#====================================================================
class ToolbarWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows Toolbar common control "

    friendlyclassname = "Toolbar"
    windowclasses = [
        "ToolbarWindow32",
        r"WindowsForms\d*\.ToolbarWindow32\..*"]

    #----------------------------------------------------------------
    def __init__(self, hwnd):
        "Initialise the instance"
        super(ToolbarWrapper, self).__init__(hwnd)

        self.writable_props.extend(['ButtonCount'])

    #----------------------------------------------------------------
    def ButtonCount(self):
        "Return the number of buttons on the ToolBar"
        return self.SendMessage(win32defines.TB_BUTTONCOUNT)

    #----------------------------------------------------------------
    def Button(self, button_index):
        "Return the button at index button_index"
        return _toolbar_button(button_index, self)

    #----------------------------------------------------------------
    def GetButton(self, button_index):
        "Return information on the Toolbar button"

#        import warnings
#        warning_msg = "HwndWrapper.NotifyMenuSelect() is deprecated - " \
#            "equivalent functionality is being moved to the MenuWrapper class."
#        warnings.warn(warning_msg, DeprecationWarning)

        if button_index >= self.ButtonCount():
            raise IndexError(
                "0 to %d are acceptiple for button_index"%
                self.ButtonCount())

        remote_mem = _RemoteMemoryBlock(self)

        button = win32structures.TBBUTTON()

        remote_mem.Write(button)

        ret = self.SendMessage(
            win32defines.TB_GETBUTTON, button_index, remote_mem)

        if not ret:
            del remote_mem
            raise RuntimeError(
                "GetButton failed for button index %d"% button_index)

        remote_mem.Read(button)

        button_info = win32structures.TBBUTTONINFOW()
        button_info.cbSize = ctypes.sizeof(button_info)
        button_info.dwMask = \
            win32defines.TBIF_COMMAND | \
            win32defines.TBIF_SIZE | \
            win32defines.TBIF_STYLE | \
            win32defines.TBIF_IMAGE | \
            win32defines.TBIF_LPARAM | \
            win32defines.TBIF_STATE | \
            win32defines.TBIF_TEXT
            #win32defines.TBIF_IMAGELABEL | \

        button_info.cchText = 2000

        # set the text address to after the structures
        button_info.pszText = remote_mem.Address() + \
            ctypes.sizeof(button_info)

        # fill the button_info structure
        remote_mem.Write(button_info)
        ret = self.SendMessage(
            win32defines.TB_GETBUTTONINFOW,
            button.idCommand,
            remote_mem)
        remote_mem.Read(button_info)

        if ret == -1:
            del remote_mem
            raise RuntimeError(
                "GetButtonInfo failed for button with command id %d"%
                    button.idCommand)

        # read the text
        button_info.text = ctypes.create_unicode_buffer(1999)
        remote_mem.Read(button_info.text, remote_mem.Address() + \
            ctypes.sizeof(button_info))

        button_info.text = button_info.text.value

        del remote_mem

        return button_info

    #----------------------------------------------------------------
    def Texts(self):
        "Return the texts of the Toolbar"
        texts = [self.WindowText()]
        for i in range(0, self.ButtonCount()):
            texts.append(self.GetButton(i).text)

        return texts

    #----------------------------------------------------------------
    def GetButtonRect(self, button_index):
        "Get the rectangle of a button on the toolbar"

#        import warnings
#        warning_msg = "HwndWrapper.NotifyMenuSelect() is deprecated - " \
#            "equivalent functionality is being moved to the MenuWrapper class."
#        warnings.warn(warning_msg, DeprecationWarning)

        button_struct = self.GetButton(button_index)

        remote_mem = _RemoteMemoryBlock(self)

        rect = win32structures.RECT()

        remote_mem.Write(rect)

        self.SendMessage(
            win32defines.TB_GETRECT,
            button_struct.idCommand,
            remote_mem)

        rect = remote_mem.Read(rect)

        del remote_mem

        return rect

    #----------------------------------------------------------------
    def GetToolTipsControl(self):
        "Return the tooltip control associated with this control"
        return ToolTipsWrapper(self.SendMessage(win32defines.TB_GETTOOLTIPS))



#    def Right_Click(self, button_index, **kwargs):
#        "Right click for Toolbar buttons"
#
#        win32functions.SetCapture(self)
#
#        button = self.GetButton(button_index)
#        #print button.text
#
#        rect = self.GetButtonRect(button_index)
#
#        x = (rect.left + rect.right) /2
#        y = (rect.top + rect.bottom) /2
#
#        #print x, y
#
#
#        self.MoveMouse(coords = (x, y))
#        self.SendMessage(
#            win32defines.WM_MOUSEACTIVATE,
#            self.Parent().Parent().Parent(),
#            win32functions.MakeLong(
#                win32defines.WM_RBUTTONDOWN,
#                win32defines.HTCLIENT)
#            )
#
#        self.PressMouse(pressed = "right", button = "right", coords = (x, y))
#
#        remote_mem = _RemoteMemoryBlock(self)
#
#        # now we need to notify the parent that the state has changed
#        nmlv = win32structures.NMMOUSE()
#        nmlv.hdr.hwndFrom = self.handle
#        nmlv.hdr.idFrom = self.ControlID()
#        nmlv.hdr.code = win32defines.NM_RCLICK
#
#
#        nmlv.dwItemSpec = button.idCommand
#        #nmlv.dwItemData
#
#        nmlv.pt = win32structures.POINT()
#
#        remote_mem.Write(nmlv)
#
#        self.SendMessage(
#            win32defines.WM_NOTIFY,
#            self.ControlID(),
#            remote_mem)
#
#        del remote_mem
#
#
#        self.ReleaseMouse(button = "right", coords = (x, y))
#
#        win32functions.ReleaseCapture()
#



    # TODO def Button(i or string).rect

    #----------------------------------------------------------------
    def PressButton(self, button_identifier):
        "Find where the button is and click it"

#        import warnings
#        warning_msg = "HwndWrapper.NotifyMenuSelect() is deprecated - " \
#            "equivalent functionality is being moved to the MenuWrapper class."
#        warnings.warn(warning_msg, DeprecationWarning)

        texts = self.Texts()
        if isinstance(button_identifier, str):

            # one of these will be returned for the matching
            # text
            indices = [i for i in range(0, len(texts[1:]))]

            # find which index best matches that text
            button_index = findbestmatch.find_best_match(
                button_identifier, texts[1:], indices)

        else:
            button_index = button_identifier

        button = self.Button(button_index)

        # transliterated from
        # http://source.winehq.org/source/dlls/comctl32/toolbar.c

        # if the button is enabled
        if button.IsEnabled():

            ret = self.NotifyParent(
                #win32defines.TB_PRESSBUTTON,
                message = win32defines.BN_CLICKED,
                controlID = button.info.idCommand)

            win32functions.WaitGuiThreadIdle(self)
            time.sleep(Timings.after_toobarpressbutton_wait)




#    #----------------------------------------------------------------
#    def _fill_toolbar_info(self):
#        "Get the information from the toolbar"
#        buttonCount = self.SendMessage(win32defines.TB_BUTTONCOUNT)
#        self._extra_props['ButtonCount'] = buttonCount
#
#        remote_mem = _RemoteMemoryBlock(self)
#
#        for i in range(0, buttonCount):
#
#            button = win32structures.TBBUTTON()
#
#            remote_mem.Write(button)
#
#            self.SendMessage(
#                win32defines.TB_GETBUTTON, i, remote_mem)
#
#            remote_mem.Read(button)
#
#            buttonInfo = win32structures.TBBUTTONINFOW()
#            buttonInfo.cbSize = ctypes.sizeof(buttonInfo)
#            buttonInfo.dwMask = win32defines.TBIF_TEXT | \
#                win32defines.TBIF_COMMAND | \
#                win32defines.TBIF_SIZE | \
#                win32defines.TBIF_COMMAND | \
#                win32defines.TBIF_STYLE | \
#                win32defines.TBIF_STATE
#
#            buttonInfo.cchText = 2000
#
#            # set the text address to after the structures
#            buttonInfo.pszText = remote_mem.Address() + \
#                ctypes.sizeof(buttonInfo)
#
#            # fill the buttonInfo structure
#            remote_mem.Write(buttonInfo)
#            self.SendMessage(
#                win32defines.TB_GETBUTTONINFOW,
#                button.idCommand,
#                remote_mem)
#            remote_mem.Read(buttonInfo)
#
#            # read the text
#            text = ctypes.create_unicode_buffer(1999)
#            remote_mem.Read(text, remote_mem.Address() + \
#                ctypes.sizeof(buttonInfo))
#
#            extendedStyle = self.SendMessage(win32defines.TB_GETEXTENDEDSTYLE)
#
#            self._extra_props.setdefault('Buttons', []).append(
#                dict(
#                    iBitMap = button.iBitmap,
#                    idCommand = button.idCommand,
#                    fsState = button.fsState,
#                    fsStyle = button.fsStyle,
#                    cx = buttonInfo.cx,
#                    ExStyle = extendedStyle
#                )
#            )
#    #		if button.fsStyle & TBSTYLE_DROPDOWN == TBSTYLE_DROPDOWN and \
#    #			(extendedStyle & TBSTYLE_EX_DRAWDDARROWS) != \
#    #                TBSTYLE_EX_DRAWDDARROWS:
#    #			props['Buttons'][-1]["DROPDOWNMENU"] = 1
#    #
#    #			self.SendMessage(WM_COMMAND, button.idCommand)
#    #
#    #			print "Pressing", text.value
#    #			handle.SendMessage(TB_PRESSBUTTON, button.idCommand, 1)
#    #			handle.SendMessage(TB_PRESSBUTTON, button.idCommand, 0)
#
#            self._extra_texts.append(text.value)
#
#
# RB_GETBANDBORDERS

class BandWrapper(win32structures.REBARBANDINFOW):
    "Simple wrapper around REBARBANDINFOW to allow setting new attributes"
    pass

#====================================================================
class ReBarWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows ReBar common control "

    friendlyclassname = "ReBar"
    windowclasses = ["ReBarWindow32", ]

    #----------------------------------------------------------------
    def __init__(self, hwnd):
        "Initialise the instance"
        super(ReBarWrapper, self).__init__(hwnd)

        self.writable_props.extend(['BandCount'])

    #----------------------------------------------------------------
    def BandCount(self):
        "Return the number of bands in the control"
        return self.SendMessage(win32defines.RB_GETBANDCOUNT)

    #----------------------------------------------------------------
    def GetBand(self, band_index):
        "Get a band of the ReBar control"

        if band_index >= self.BandCount():
            raise IndexError(
                "band_index %d greater then number of available bands: %d" %
                    (band_index, self.BandCount()))

        remote_mem = _RemoteMemoryBlock(self)

        band_info = BandWrapper()

        band_info.cbSize = ctypes.sizeof(band_info)
        band_info.fMask = \
            win32defines.RBBIM_CHILD | \
            win32defines.RBBIM_CHILDSIZE | \
            win32defines.RBBIM_COLORS | \
            win32defines.RBBIM_HEADERSIZE | \
            win32defines.RBBIM_ID | \
            win32defines.RBBIM_IDEALSIZE | \
            win32defines.RBBIM_SIZE | \
            win32defines.RBBIM_STYLE | \
            win32defines.RBBIM_TEXT

        # set the pointer for the text
        band_info.pszText = ctypes.c_long(remote_mem.Address() + \
            ctypes.sizeof(band_info))
        band_info.cchText = 2000

        # write the structure
        remote_mem.Write(band_info)

        # Fill the structure
        self.SendMessage(
            win32defines.RB_GETBANDINFOW,
            band_index,
            remote_mem)

        # read it back
        remote_mem.Read(band_info)

        # read the text
        band_info.text = ctypes.create_unicode_buffer(1999)
        remote_mem.Read(band_info.text, remote_mem.Address() + \
            ctypes.sizeof(band_info))

        band_info.text = band_info.text.value

        del remote_mem
        return band_info


    #----------------------------------------------------------------
    def GetToolTipsControl(self):
        "Return the tooltip control associated with this control"
        tips_handle = self.SendMessage(win32defines.RB_GETTOOLTIPS)

        if tips_handle:
            return ToolTipsWrapper(tips_handle)

    #----------------------------------------------------------------
    def Texts(self):
        "Return the texts of the Rebar"
        texts = [self.WindowText()]
        for i in range(0, self.BandCount()):
            band = self.GetBand(i)
            texts.append(band.text)

        return texts



class ToolTip(object):
    "Class that Wraps a single tip from a ToolTip control"
    def __init__(self, ctrl, tip_index):
        "Read the required information"
        self.ctrl = ctrl
        self.index = tip_index

        remote_mem = _RemoteMemoryBlock(self.ctrl)
        tipinfo = win32structures.TOOLINFOW()
        tipinfo.cbSize = ctypes.sizeof(tipinfo)
        tipinfo.lpszText = remote_mem.Address() + \
            ctypes.sizeof(tipinfo) +1

        remote_mem.Write(tipinfo)

        ret = self.ctrl.SendMessage(
            win32defines.TTM_ENUMTOOLSW,
            self.index,
            remote_mem)

        if not ret:
            raise ctypes.WinError()

        remote_mem.Read(tipinfo)

        self.info = tipinfo

        # now get the text
        self.info.lpszText = remote_mem.Address() + \
            ctypes.sizeof(self.info) +1

        remote_mem.Write(self.info)

        self.ctrl.SendMessage(
            win32defines.TTM_GETTEXTW, 0, remote_mem)

        text = ctypes.create_unicode_buffer(2000)

        remote_mem.Read(text, self.info.lpszText)

        self.text = text.value

        del remote_mem




#====================================================================
class ToolTipsWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows ToolTips common control (not fully implemented)"

    # mask this class as it is not ready for prime time yet!
    friendlyclassname = "ToolTips"
    windowclasses = ["tooltips_class32", ]

    #----------------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the instance"
        #HwndWrapper.HwndWrapper.__init__(self, hwnd)
        super(ToolTipsWrapper, self).__init__(hwnd)


    #----------------------------------------------------------------
    def GetTip(self, tip_index):
        "Return the particular tooltip"
        if tip_index >= self.ToolCount():
            raise IndexError(
                "tip_index %d greater then number of available tips: %d" %
                    (tip_index, self.ToolCount()))
        return ToolTip(self, tip_index)


    #----------------------------------------------------------------
    def ToolCount(self):
        "Return the number of tooltips"
        return self.SendMessage(win32defines.TTM_GETTOOLCOUNT)


    #----------------------------------------------------------------
    def GetTipText(self, tip_index):
        "Return the text of the tooltip"

        return ToolTip(self, tip_index).text

    #----------------------------------------------------------------
    def Texts(self):
        "Return the text of all the tooltips"
        texts = [self.WindowText(), ]
        for tip_index in range(0, self.ToolCount()):
            texts.append(self.GetTipText(tip_index))

        return texts


#====================================================================
class UpDownWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows UpDown common control "

    friendlyclassname = "UpDown"
    windowclasses = ["msctls_updown32", "msctls_updown", ]

    #----------------------------------------------------------------
    def __init__(self, hwnd):
        "Initialise the instance"
        #HwndWrapper.HwndWrapper.__init__(self, hwnd)
        super(UpDownWrapper, self).__init__(hwnd)

    #----------------------------------------------------------------
    def GetValue(self):
        "Get the current value of the UpDown control"
        pos = self.SendMessage(win32defines.UDM_GETPOS)
        return win32functions.LoWord(pos)

    #----------------------------------------------------------------
    def GetBase(self):
        "Get the base the UpDown control (either 10 or 16)"
        return self.SendMessage(win32defines.UDM_GETBASE)

    #----------------------------------------------------------------
    def GetRange(self):
        "Return the lower, upper range of the up down control"
        updown_range = self.SendMessage(win32defines.UDM_GETRANGE)
        updown_range = (
            win32functions.HiWord(updown_range),
            win32functions.LoWord(updown_range)
            )
        return updown_range

    #----------------------------------------------------------------
    def GetBuddyControl(self):
        "Get the buddy control of the updown control"
        #from wraphandle import WrapHandle
        #from HwndWrapper import WrapHandle
        buddy_handle = self.SendMessage(win32defines.UDM_GETBUDDY)
        return HwndWrapper.HwndWrapper(buddy_handle)

    #----------------------------------------------------------------
    def SetValue(self, new_pos):
        "Set the value of the of the UpDown control to some integer value"
        self.SendMessageTimeout(
            win32defines.UDM_SETPOS, 0, win32functions.MakeLong(0, new_pos))

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_updownchange_wait)

    #----------------------------------------------------------------
    def Increment(self):
        "Increment the number in the UpDown control by one"
        # hmmm - VM_SCROLL and UDN_DELTAPOS don't seem to be working for me :-(
        # I will fake it for now either use Click, or GetValue() + 1
        self.SetValue(self.GetValue() + 1)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_updownchange_wait)

    #----------------------------------------------------------------
    def Decrement(self):
        "Decrement the number in the UpDown control by one"
        self.SetValue(self.GetValue() - 1)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_updownchange_wait)


#====================================================================
class TrackbarWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows Trackbar common control "

    friendlyclassname = "Trackbar"
    windowclasses = ["msctls_trackbar", ]

#
#    #----------------------------------------------------------------
#	def GetNumTicks(self):
#		return self.SendMessage(win32defines.TBM_GETNUMTICS)
#
#    #----------------------------------------------------------------
#	def GetPos(self):
#		return self.SendMessage(win32defines.TBM_GETPOS)
#
#    #----------------------------------------------------------------
#	def GetRangeMax(self):
#		return self.SendMessage(win32defines.TBM_GETRANGEMAX)
#
#    #----------------------------------------------------------------
#	def GetRangeMin(self):
#		return self.SendMessage(win32defines.TBM_GETRANGEMIN)
#
#    #----------------------------------------------------------------
#    def GetToolTipsControl(self):
#        "Return the tooltip control associated with this control"
#        return ToolTipsWrapper(self.SendMessage(win32defines.TBM_GETTOOLTIPS))


#====================================================================
class AnimationWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows Animation common control "

    friendlyclassname = "Animation"
    windowclasses = ["SysAnimate32", ]


#====================================================================
class ComboBoxExWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows ComboBoxEx common control "

    friendlyclassname = "ComboBoxEx"
    windowclasses = ["ComboBoxEx32", ]
    has_title = False


#====================================================================
class DateTimePickerWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows DateTimePicker common control "

    friendlyclassname = "DateTimePicker"
    windowclasses = ["SysDateTimePick32", ]
    has_title = False


#====================================================================
class HotkeyWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows Hotkey common control "

    friendlyclassname = "Hotkey"
    windowclasses = ["msctls_hotkey32", ]
    has_title = False


#====================================================================
class IPAddressWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows IPAddress common control "

    friendlyclassname = "IPAddress"
    windowclasses = ["SysIPAddress32", ]
    has_title = False


#====================================================================
class CalendarWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows Calendar common control "

    friendlyclassname = "Calendar"
    windowclasses = ["SysMonthCal32", ]
    has_title = False


#====================================================================
class PagerWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows Pager common control "

    friendlyclassname = "Pager"
    windowclasses = ["SysPager", ]

    def GetPosition(self):
        "Return the current position of the pager"
        return self.SendMessage(win32defines.PGM_GETPOS)

    def SetPosition(self, pos):
        "Set the current position of the pager"
        return self.SendMessage(win32defines.PGM_SETPOS, pos)


#====================================================================
class ProgressWrapper(HwndWrapper.HwndWrapper):
    "Class that wraps Windows Progress common control "

    friendlyclassname = "Progress"
    windowclasses = ["msctls_progress", "msctls_progress32", ]
    has_title = False


    def GetPosition(self):
        "Return the current position of the progress bar"
        return self.SendMessage(win32defines.PBM_GETPOS)

    def SetPosition(self, pos):
        "Set the current position of the progress bar"
        return self.SendMessage(win32defines.PBM_SETPOS, pos)

    def GetState(self):
        """Get the state of the progress bar
        
        State will be one of the following constants:
         * PBST_NORMAL
         * PBST_ERROR
         * PBST_PAUSED
        """
        return self.SendMessage(win32defines.PBM_GETSTATE)

    def GetStep(self):
        "Get the step size of the progress bar"
        return self.SendMessage(win32defines.PBM_GETSTEP)

    def StepIt(self):
        "Move the progress bar one step size forward"
        return self.SendMessage(win32defines.PBM_STEPIT)

#
##
###HwndWrapper._HwndWrappers["ComboBoxEx32"] = ComboBoxEx
##




##
##
###====================================================================
##class ComboBoxEx(Controls_Standard.ComboBox):
##	#----------------------------------------------------------------
##	def __init__(self, hwndOrXML):
#		Window.__init__(self, hwndOrXML)
##
#		if isinstance(hwndOrXML, (int, long)):
##			comboCntrl = SendMessage(
##				hwndOrXML,
##				CBEM_GETCOMBOCONTROL,
##				0,
##				0)
##
##			print "--"*20, comboCntrl
##			Controls_Standard.ComboBox.__init__(self, comboCntrl)
##			print self.DroppedRect
##
##
##
##			droppedRect = win32structures.RECT()
##
##			SendMessage(
##				self,
##				CB_GETDROPPEDCONTROLRECT,
##				0,
##				ctypes.byref(droppedRect))
##
##			props['DroppedRect'] = droppedRect
#
#
#
#
#
#
#			# find out how many text items are in the combobox
#			numItems = SendMessage(
#				self,
#				CB_GETCOUNT,
#				0,
#				0)
#
#			print "*"*20, numItems
##			remote_mem = _RemoteMemoryBlock(self)
##
##
##			# get the text for each item in the combobox
##			while True:
##				item = COMBOBOXEXITEMW()
##
##				item.mask = CBEIF_TEXT
##				item.cchTextMax = 4000
##				item.pszText = remote_mem.Address() + ctypes.sizeof(item) + 1
##
##				remote_mem.Write(item)
##
##				retval = SendMessage (
##					self,
##					CBEM_GETITEMW,
##					0,
##					remote_mem
##					)
##
##				if retval:
##					item = remote_mem.Read(item)
##
##					# Read the remote text string
##                  charData = ctypes.create_unicode_buffer(4000)
##					remote_mem.Read(charData, item.pszText)
##					self.Titles.append(charData.value)
##				else:
##					break
##
#
#		else:
#
#			# get the dropped Rect form
#			droppedRect = XMLToRect(hwndOrXML.find("DROPPEDRECT"))
#			props['DroppedRect'] = droppedRect

########NEW FILE########
__FILENAME__ = HwndWrapper
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Basic wrapping of Windows controls"

__revision__ = "$Revision: 733 $"

# pylint:  disable-msg=W0611

import time
import re
import ctypes

# the wrappers may be used in an environment that does not need
# the actions - as such I don't want to require sendkeys - so
# the following makes the import optional.
from .. import SendKeysCtypes as SendKeys

# I leave this optional because PIL is a large dependency
try:
    import ImageGrab
except ImportError:
    ImageGrab = None

from .. import win32defines
from .. import win32functions
from .. import win32structures
from ..timings import Timings
from .. import timings

#from pywinauto import findbestmatch
from .. import handleprops

# also import MenuItemNotEnabled so that it is
# accessible from HwndWrapper module
from .menuwrapper import Menu #, MenuItemNotEnabled



        
#====================================================================
class ControlNotEnabled(RuntimeError):
    "Raised when a control is not enabled"
    pass

#====================================================================
class ControlNotVisible(RuntimeError):
    "Raised when a control is nto visible"
    pass

#====================================================================
class InvalidWindowHandle(RuntimeError):
    "Raised when an invalid handle is passed to HwndWrapper "
    def __init__(self, hwnd):
        "Initialise the RuntimError parent with the mesage"
        RuntimeError.__init__(self,
            "Handle 0x%d is not a vaild window handle"% hwnd)




# metaclass that will know about
class _MetaWrapper(type):
    "Metaclass for Wrapper objects"
    re_wrappers = {}
    str_wrappers = {}

    def __init__(cls, name, bases, attrs):
        # register the class names, both the regular expression
        # or the classes directly

        #print "metaclass __init__", cls
        type.__init__(cls, name, bases, attrs)

        for win_class in cls.windowclasses:
            _MetaWrapper.re_wrappers[re.compile(win_class)] = cls
            _MetaWrapper.str_wrappers[win_class] = cls

    def FindWrapper(handle):
        """Find the correct wrapper for this handle"""
        class_name = handleprops.classname(handle)


        try:
            return _MetaWrapper.str_wrappers[class_name]
        except KeyError:
            wrapper_match = None

            for regex, wrapper in list(_MetaWrapper.re_wrappers.items()):
                if regex.match(class_name):
                    wrapper_match = wrapper
                    _MetaWrapper.str_wrappers[class_name] = wrapper

                    break

        # if it is a dialog then override the wrapper we found
        # and make it a DialogWrapper
        if handleprops.is_toplevel_window(handle):
            from . import win32_controls
            wrapper_match = win32_controls.DialogWrapper

        if wrapper_match is None:
            wrapper_match = HwndWrapper
        return wrapper_match


        #if handle in meta.wrappers:
        #    return meta.wrappers[handle]
    FindWrapper = staticmethod(FindWrapper)


#====================================================================
class HwndWrapper(object, metaclass=_MetaWrapper):
    """Default wrapper for controls.

    All other wrappers are derived from this.

    This class wraps a lot of functionality of underlying windows API
    features for working with windows.

    Most of the methods apply to every single window type. For example
    you can Click() on any window.

    Most of the methods of this class are simple wrappers around
    API calls and as such they try do the simplest thing possible.

    A HwndWrapper object can be passed directly to a ctypes wrapped
    C function - and it will get converted to a Long with the value of
    it's handle (see ctypes, _as_parameter_)"""

    friendlyclassname = None
    windowclasses = []
    handle = None
    can_be_label = False
    has_title = True

    #-----------------------------------------------------------
    def __new__(cls, handle):
        # only use the meta class to find the wrapper for HwndWrapper
        # so allow users to force the wrapper if they want
        # thanks to Raghav for finding this.
        if cls != HwndWrapper:
            obj = object.__new__(cls)
            obj.__init__(handle)
            return obj

        new_class = cls.FindWrapper(handle)
        #super(currentclass, cls).__new__(cls[, ...])"
        obj = object.__new__(new_class)
        obj.__init__(handle)
        return obj

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        """Initialize the control

        * **hwnd** is either a valid window handle or it can be an
          instance or subclass of HwndWrapper.

        If the handle is not valid then an InvalidWindowHandle error
        is raised.
        """

        # handle if hwnd is actually a HwndWrapper
        try:
            self.handle = hwnd.handle
        except AttributeError:
            self.handle = hwnd

        # verify that we have been passed in a valid windows handle
        if not win32functions.IsWindow(hwnd):
            raise InvalidWindowHandle(hwnd)

        # make it so that ctypes conversion happens correctly
        self._as_parameter_ = self.handle

        #win32functions.WaitGuiThreadIdle(self)

        # specify whether we need to grab an image of ourselves
        # when asked for properties
        self._NeedsImageProp = False

        # default to not having a reference control added
        self.ref = None

        self.appdata = None

        self._cache = {}

        # build the list of default properties to be written
        # Derived classes can either modify this list or override
        # GetProperties depending on how much control they need.
        self.writable_props = [
            'Class',
            'FriendlyClassName',
            'Texts',
            'Style',
            'ExStyle',
            'ControlID',
            'UserData',
            'ContextHelpID',
            'Fonts',
            'ClientRects',
            'Rectangle',
            'IsVisible',
            'IsUnicode',
            'IsEnabled',
            'MenuItems',
            'ControlCount',
            ]

    #-----------------------------------------------------------
    def FriendlyClassName(self):
        """Return the friendly class name for the control

        This differs from the class of the control in some cases.
        Class() is the actual 'Registered' window class of the control
        while FriendlyClassName() is hopefully something that will make
        more sense to the user.

        For example Checkboxes are implemented as Buttons - so the class
        of a CheckBox is "Button" - but the friendly class is "CheckBox"
        """
        if self.friendlyclassname is None:
            self.friendlyclassname = handleprops.classname(self)
        return self.friendlyclassname

    #-----------------------------------------------------------
    def Class(self):
        """Return the class name of the window"""
        if "class" not in self._cache:
            self._cache['class'] = handleprops.classname(self)
        return self._cache['class']

    #-----------------------------------------------------------
    def WindowText(self):
        """Window text of the control

        Quite  a few contorls have other text that is visible, for example
        Edit controls usually have an empty string for WindowText but still
        have text displayed in the edit window.
        """
        return handleprops.text(self)

    #-----------------------------------------------------------
    def Style(self):
        """Returns the style of window

        Return value is a long.

        Combination of WS_* and specific control specific styles.
        See HwndWrapper.HasStyle() to easily check if the window has a
        particular style.
        """
        return handleprops.style(self)

    #-----------------------------------------------------------
    def ExStyle(self):
        """Returns the Extended style of window

        Return value is a long.

        Combination of WS_* and specific control specific styles.
        See HwndWrapper.HasStyle() to easily check if the window has a
        particular style.
        """
        return handleprops.exstyle(self)

    #-----------------------------------------------------------
    def ControlID(self):
        """Return the ID of the window

        Only controls have a valid ID - dialogs usually have no ID assigned.

        The ID usually identified the control in the window - but there can
        be duplicate ID's for example lables in a dialog may have duplicate
        ID's.
        """
        return handleprops.controlid(self)

    #-----------------------------------------------------------
    def UserData(self):
        """Extra data associted with the window

        This value is a long value that has been associated with the window
        and rarely has useful data (or at least data that you know the use
        of).
        """
        return handleprops.userdata(self)

    #-----------------------------------------------------------
    def ContextHelpID(self):
        "Return the Context Help ID of the window"
        return handleprops.contexthelpid(self)

    #-----------------------------------------------------------
    def IsUnicode(self):
        """Whether the window is unicode or not

        A window is Unicode if it was registered by the Wide char version
        of RegisterClass(Ex).
        """
        return handleprops.isunicode(self)

    #-----------------------------------------------------------
    def IsVisible(self):
        """Whether the window is visible or not

        Checks that both the Top Level Parent (probably dialog) that
        owns this window and the window itself are both visible.

        If you want to wait for a control to become visible (or wait
        for it to become hidden) use ``Application.Wait('visible')`` or
        ``Application.WaitNot('visible')``.

        If you want to raise an exception immediately if a window is
        not visible then you can use the HwndWrapper.VerifyVisible().
        HwndWrapper.VerifyActionable() raises if the window is not both
        visible and enabled.
        """

        return handleprops.isvisible(self.TopLevelParent()) and \
            handleprops.isvisible(self)

    #-----------------------------------------------------------
    def IsEnabled(self):
        """Whether the window is enabled or not

        Checks that both the Top Level Parent (probably dialog) that
        owns this window and the window itself are both enabled.

        If you want to wait for a control to become enabled (or wait
        for it to become disabled) use ``Application.Wait('visible')`` or
        ``Application.WaitNot('visible')``.

        If you want to raise an exception immediately if a window is
        not enabled then you can use the HwndWrapper.VerifyEnabled().
        HwndWrapper.VerifyReady() raises if the window is not both
        visible and enabled.
        """
        return handleprops.isenabled(self.TopLevelParent()) and \
            handleprops.isenabled(self)

    #-----------------------------------------------------------
    def Rectangle(self):
        """Return the rectangle of window

        The rectangle is the rectangle of the control on the screen,
        coordinates are given from the top left of the screen.

        This method returns a RECT structure, Which has attributes - top,
        left, right, bottom. and has methods width() and height().
        See win32structures.RECT for more information.
        """
        return handleprops.rectangle(self)

    #-----------------------------------------------------------
    def ClientRect(self):
        """Returns the client rectangle of window

        The client rectangle is the window rectangle minus any borders that
        are not available to the control for drawing.

        Both top and left are always 0 for this method.

        This method returns a RECT structure, Which has attributes - top,
        left, right, bottom. and has methods width() and height().
        See win32structures.RECT for more information.
        """
        return handleprops.clientrect(self)

    #-----------------------------------------------------------
    def Font(self):
        """Return the font of the window

        The font of the window is used to draw the text of that window.
        It is a structure which has attributes for Font name, height, width
        etc.

        See win32structures.LOGFONTW for more information.
        """
        return handleprops.font(self)

    #-----------------------------------------------------------
    def ProcessID(self):
        """Return the ID of process that owns this window"""
        return handleprops.processid(self)

    #-----------------------------------------------------------
    def HasStyle(self, style):
        "Return True if the control has the specified sytle"
        return handleprops.has_style(self, style)

    #-----------------------------------------------------------
    def HasExStyle(self, exstyle):
        "Return True if the control has the specified extended sytle"
        return handleprops.has_exstyle(self, exstyle)

    #-----------------------------------------------------------
    def IsDialog(self):
        "Return true if the control is a top level window"

        if "isdialog" not in self._cache:
            self._cache['isdialog'] = handleprops.is_toplevel_window(self)

        return self._cache['isdialog']

    #-----------------------------------------------------------
    def Parent(self):
        """Return the parent of this control

        Note that the parent of a control is not necesarily a dialog or
        other main window. A group box may be the parent of some radio
        buttons for example.

        To get the main (or top level) window then use
        HwndWrapper.TopLevelParent().
        """

        if "parent" not in self._cache:

            parent_hwnd = handleprops.parent(self)

            if parent_hwnd:
                #return WrapHandle(parent_hwnd)

                self._cache["parent"] = HwndWrapper(parent_hwnd)
            else:
                self._cache["parent"] = None

        return self._cache["parent"]

    #-----------------------------------------------------------
    def TopLevelParent(self):
        """Return the top level window of this control

        The TopLevel parent is different from the parent in that the Parent
        is the window that owns this window - but it may not be a dialog/main
        window. For example most Comboboxes have an Edit. The ComboBox is the
        parent of the Edit control.

        This will always return a valid window handle (if the control has
        no top level parent then the control itself is returned - as it is
        a top level window already!)
        """

        if "top_level_parent" not in self._cache:

            parent = self.Parent()

            if self.IsDialog():
                self._cache["top_level_parent"] = self
                #return self

            elif not parent:
                self._cache["top_level_parent"] = self
                #return self

            elif not parent.IsDialog():
                self._cache["top_level_parent"] = parent.TopLevelParent()
                #return parent.TopLevelParent()
            else:
                self._cache["top_level_parent"] = parent
                #return parent

        return self._cache["top_level_parent"]

    #-----------------------------------------------------------
    def Texts(self):
        """Return the text for each item of this control"

        It is a list of strings for the control. It is frequently over-ridden
        to extract all strings from a control with multiple items.

        It is always a list with one or more strings:

          * First elemtent is the window text of the control
          * Subsequent elements contain the text of any items of the
            control (e.g. items in a listbox/combobox, tabs in a tabcontrol)
        """
        texts = [self.WindowText(), ]
        return texts

    #-----------------------------------------------------------
    def ClientRects(self):
        """Return the client rect for each item in this control

        It is a list of rectangles for the control. It is frequently over-ridden
        to extract all rectangles from a control with multiple items.

        It is always a list with one or more rectangles:

          * First elemtent is the client rectangle of the control
          * Subsequent elements contain the client rectangle of any items of
            the control (e.g. items in a listbox/combobox, tabs in a
            tabcontrol)
        """

        return [self.ClientRect(), ]

    #-----------------------------------------------------------
    def Fonts(self):
        """Return the font for each item in this control

        It is a list of fonts for the control. It is frequently over-ridden
        to extract all fonts from a control with multiple items.

        It is always a list with one or more fonts:

          * First elemtent is the control font
          * Subsequent elements contain the font of any items of
            the control (e.g. items in a listbox/combobox, tabs in a
            tabcontrol)
        """
        return [self.Font(), ]

    #-----------------------------------------------------------
    def Children(self):
        """Return the children of this control as a list

        It returns a list of HwndWrapper (or subclass) instances, it
        returns an empty list if there are no children.
        """

        child_windows = handleprops.children(self)
        return [HwndWrapper(hwnd) for hwnd in child_windows]

    #-----------------------------------------------------------
    def ControlCount(self):
        "Return the number of children of this control"

        return len(handleprops.children(self))

    #-----------------------------------------------------------
    def IsChild(self, parent):
        """Return True if this window is a child of 'parent'.

        A window is a child of another window when it is a direct of the
        other window. A window is a direct descendant of a given
        window if the parent window is the the chain of parent windows
        for the child window.
        """

        # Call the IsChild API funciton and convert the result
        # to True/False
        return win32functions.IsChild(parent, self.handle) != 0

    #-----------------------------------------------------------
    def SendMessage(self, message, wparam = 0 , lparam = 0):
        "Send a message to the control and wait for it to return"
        return win32functions.SendMessage(self, message, wparam, lparam)

        #result = ctypes.c_long()
        #ret = win32functions.SendMessageTimeout(self, message, wparam, lparam,
        #    win32defines.SMTO_NORMAL, 400, ctypes.byref(result))

        #return result.value


    #-----------------------------------------------------------
    def SendMessageTimeout(
        self,
        message,
        wparam = 0 ,
        lparam = 0,
        timeout = None,
        timeoutflags = win32defines.SMTO_NORMAL):
        """Send a message to the control and wait for it to return or to timeout

        If no timeout is given then a default timeout of .4 of a second will
        be used.
        """

        if timeout is None:
            timeout = Timings.sendmessagetimeout_timeout

        result = ctypes.c_long()
        win32functions.SendMessageTimeout(self,
            message, wparam, lparam,
            timeoutflags, int(timeout * 1000),
            ctypes.byref(result))

        return result.value


    #-----------------------------------------------------------
    def PostMessage(self, message, wparam = 0 , lparam = 0):
        "Post a message to the control message queue and return"
        return win32functions.PostMessage(self, message, wparam, lparam)

        #result = ctypes.c_long()
        #ret = win32functions.SendMessageTimeout(self, message, wparam, lparam,
        #    win32defines.SMTO_NORMAL, 400, ctypes.byref(result))

        #return result.value


#    #-----------------------------------------------------------
#    def NotifyMenuSelect(self, menu_id):
#        """Notify the dialog that one of it's menu items was selected
#
#        **This method is Deprecated**
#        """
#
#        import warnings
#        warning_msg = "HwndWrapper.NotifyMenuSelect() is deprecated - " \
#            "equivalent functionality is being moved to the MenuWrapper class."
#        warnings.warn(warning_msg, DeprecationWarning)
#
#        self.SetFocus()
#
#        msg = win32defines.WM_COMMAND
#        return self.SendMessageTimeout(
#            msg,
#            win32functions.MakeLong(0, menu_id), #wparam
#            )
#

    #-----------------------------------------------------------
    def NotifyParent(self, message, controlID = None):
        "Send the notification message to parent of this control"

        if controlID is None:
            controlID = self.ControlID()

        return self.Parent().PostMessage(
            win32defines.WM_COMMAND,
            win32functions.MakeLong(message, controlID),
            self)

    #-----------------------------------------------------------
    def GetProperties(self):
        "Return the properties of the control as a dictionary"
        props = {}

        # for each of the properties that can be written out
        for propname in self.writable_props:
            # set the item in the props dictionary keyed on the propname
            props[propname] = getattr(self, propname)()

        if self._NeedsImageProp:
            props["Image"] = self.CaptureAsImage()

        return props

    #-----------------------------------------------------------
    def CaptureAsImage(self):
        """Return a PIL image of the control

        See PIL documentation to know what you can do with the resulting
        image"""
        
        if not (self.Rectangle().width() and self.Rectangle().height()):
            return None

        # PIL is optional so check first
        if not ImageGrab:
            print("PIL does not seem to be installed. "
                "PIL is required for CaptureAsImage")
            return None

        # get the control rectangle in a way that PIL likes it
        box = (
            self.Rectangle().left,
            self.Rectangle().top,
            self.Rectangle().right,
            self.Rectangle().bottom)

        # grab the image and get raw data as a string
        return ImageGrab.grab(box)

    #-----------------------------------------------------------
    def __hash__(self):
        "Returns the hash value of the handle"
        return hash(self.handle)

    #-----------------------------------------------------------
    def __eq__(self, other):
        "Returns True if the handles of both controls are the same"
        if isinstance(other, HwndWrapper):
            return self.handle == other.handle
        else:
            return self.handle == other

    #-----------------------------------------------------------
    def VerifyActionable(self):
        """Verify that the control is both visible and enabled

        Raise either ControlNotEnalbed or ControlNotVisible if not
        enabled or visible respectively.
        """
        win32functions.WaitGuiThreadIdle(self)
        self.VerifyVisible()
        self.VerifyEnabled()


    #-----------------------------------------------------------
    def VerifyEnabled(self):
        """Verify that the control is enabled

        Check first if the control's parent is enabled (skip if no parent),
        then check if control itself is enabled.
        """

        # Check if the control and it's parent are enabled
        if not self.IsEnabled():
            raise ControlNotEnabled()

    #-----------------------------------------------------------
    def VerifyVisible(self):
        """Verify that the control is visible

        Check first if the control's parent is visible. (skip if no parent),
        then check if control itself is visible.
        """

        # check if the control and it's parent are visible
        if not self.IsVisible():
            raise ControlNotVisible()


    #-----------------------------------------------------------
    def Click(
        self, button = "left", pressed = "", coords = (0, 0), double = False):
        """Simulates a mouse click on the control

        This method sends WM_* messages to the control, to do a more
        'realistic' mouse click use ClickInput() which uses SendInput() API
        to perform the click.

        This method does not require that the control be visible on the screen
        (i.e. is can be hidden beneath another window and it will still work.)
        """

        _perform_click(self, button, pressed, coords, double)
        return self


    #-----------------------------------------------------------
    def ClickInput(
        self, 
        button = "left", 
        coords = (None, None), 
        double = False, 
        wheel_dist = 0):
        """Click at the specified coordinates

        * **button** The mouse button to click. One of 'left', 'right',
          'middle' or 'x' (Default: 'left')
        * **coords** The coordinates to click at.(Default: center of control)
        * **double** Whether to perform a double click or not (Default: False)
        * **wheel_dist** The distance to move the mouse week (default: 0)

        NOTES: 
           This is different from Click in that it requires the control to
           be visible on the screen but performs a more realistic 'click'
           simulation.

           This method is also vulnerable if the mouse if moved by the user
           as that could easily move the mouse off the control before the
           Click has finished.        
        """
        _perform_click_input(
            self, button, coords, double, wheel_dist = wheel_dist)



    #-----------------------------------------------------------
    def CloseClick(
        self, button = "left", pressed = "", coords = (0, 0), double = False):
        """Peform a click action that should make the window go away

        The only difference from Click is that there are extra delays
        before and after the click action.
        """

        time.sleep(Timings.before_closeclick_wait)

        _perform_click(self, button, pressed, coords, double)

        def has_closed():
            return not (
                win32functions.IsWindow(self) or
                win32functions.IsWindow(self.Parent()))

        # Keep waiting until both this control and it's parent
        # are no longer valid controls
        timings.WaitUntil(
            Timings.closeclick_dialog_close_wait,
            Timings.closeclick_retry,
            has_closed
        )

        time.sleep(Timings.after_closeclick_wait)

        return self



    #-----------------------------------------------------------
    def DoubleClick(
        self, button = "left", pressed = "", coords = (0, 0)):
        "Perform a double click action"
        _perform_click(self, button, pressed, coords, double = True)
        return self

    #-----------------------------------------------------------
    def DoubleClickInput(self, button = "left", coords = (None, None)):
        "Double click at the specified coordinates"
        _perform_click_input(self, button, coords, double = True)

    #-----------------------------------------------------------
    def RightClick(
        self, pressed = "", coords = (0, 0)):
        "Perform a right click action"

        _perform_click(
            self, "right", "right " + pressed, coords, button_up = False)
        _perform_click(self, "right", pressed, coords, button_down = False)
        return self

    #-----------------------------------------------------------
    def RightClickInput(self, coords = (None, None)):
        "Right click at the specified coords"
        _perform_click_input(self, 'right', coords)


    #-----------------------------------------------------------
    def PressMouse(self, button = "left", pressed = "", coords = (0, 0)):
        "Press the mouse button"
        #flags, click_point = _calc_flags_and_coords(pressed, coords)

        _perform_click(self, button, pressed, coords, button_up = False)
        return self

    #-----------------------------------------------------------
    def PressMouseInput(self, button = "left", coords = (None, None)):
        "Press a mouse button using SendInput"
        _perform_click_input(self, button, coords, button_up = False)


    #-----------------------------------------------------------
    def ReleaseMouse(self, button = "left", pressed = "", coords = (0, 0)):
        "Release the mouse button"
        #flags, click_point = _calc_flags_and_coords(pressed, coords)
        _perform_click(self, button, pressed, coords, button_down = False)
        return self

    #-----------------------------------------------------------
    def ReleaseMouseInput(self, button = "left", coords = (None, None)):
        "Release the mouse button"
        _perform_click_input(self, button, coords, button_down = False)

    #-----------------------------------------------------------
    def MoveMouse(self, pressed = "left", coords = (0, 0)):
        "Move the mouse"

        flags, click_point = _calc_flags_and_coords(pressed, coords)
        self.SendMessageTimeout(win32defines.WM_MOUSEMOVE, flags, click_point)
        win32functions.WaitGuiThreadIdle(self)

        return self

    #-----------------------------------------------------------
    def DragMouse(self,
        button = "left",
        pressed = "",
        press_coords = (0, 0),
        release_coords = (0, 0)):
        "Drag the mouse"

        self.PressMouse(button, pressed, press_coords)
        self.MoveMouse(pressed, press_coords)
        self.ReleaseMouse(button, pressed, release_coords)

        return self


    #-----------------------------------------------------------
    def SetWindowText(self, text, append = False):
        "Set the text of the window"

        self.VerifyActionable()

        if append:
            text = self.WindowText() + text

        text = ctypes.c_wchar_p(str(text))
        self.PostMessage(win32defines.WM_SETTEXT, 0, text)
        win32functions.WaitGuiThreadIdle(self)

        return self

    #-----------------------------------------------------------
    def TypeKeys(
        self,
        keys,
        pause = None,
        with_spaces = False,
        with_tabs = False,
        with_newlines = False,
        turn_off_numlock = True):
        """Type keys to the window using SendKeys

        This uses the SendKeys python module from
        http://www.rutherfurd.net/python/sendkeys/ .This is the best place
        to find documentation on what to use for the ``keys``
        """

        self.VerifyActionable()

        if pause is None:
            pause = Timings.after_sendkeys_key_wait

        self.SetFocus()

        # attach the Python process with the process that self is in
        win32functions.AttachThreadInput(
            win32functions.GetCurrentThreadId(), self.ProcessID(), 1)

        # make sure that the control is in the foreground
        win32functions.SetForegroundWindow(self)
        #win32functions.SetActiveWindow(self)

        # Play the keys to the active window
        SendKeys.SendKeys(
            keys,
            pause, with_spaces,
            with_tabs,
            with_newlines,
            turn_off_numlock)

        # detach the python process from the window's process
        win32functions.AttachThreadInput(
            win32functions.GetCurrentThreadId(), self.ProcessID(), 0)

        win32functions.WaitGuiThreadIdle(self)
        return self

    #-----------------------------------------------------------
    def DebugMessage(self, text):
        "Write some debug text over the window"

        # don't draw if dialog is not visible

        dc = win32functions.CreateDC("DISPLAY", None, None, None )

        if not dc:
            raise ctypes.WinError()

        rect = self.Rectangle

        #ret = win32functions.TextOut(
        #    dc, rect.left, rect.top, unicode(text), len(text))
        ret = win32functions.DrawText(
            dc,
            str(text),
            len(text),
            ctypes.byref(rect),
            win32defines.DT_SINGLELINE)

        # delete the Display context that we created
        win32functions.DeleteDC(dc)

        if not ret:
            raise ctypes.WinError()

        return self


    #-----------------------------------------------------------
    def DrawOutline(
        self,
        colour = 'green',
        thickness = 2,
        fill = win32defines.BS_NULL,
        rect = None):
        """Draw an outline around the window

        * **colour** can be either an integer or one of 'red', 'green', 'blue'
          (default 'green')
        * **thickness** thickness of rectangle (default 2)
        * **fill** how to fill in the rectangle (default BS_NULL)
        * **rect** the coordinates of the rectangle to draw (defaults to
          the rectangle of the control.
        """

        # don't draw if dialog is not visible
        if not self.IsVisible():
            return

        colours = {
            "green" : 0x00ff00,
            "blue" : 0xff0000,
            "red" : 0x0000ff,
        }

        # if it's a known colour
        if colour in colours:
            colour = colours[colour]

        if not rect:
            rect = self.Rectangle()

        # create the pen(outline)
        pen_handle = win32functions.CreatePen(
            win32defines.PS_SOLID, thickness, colour)

        # create the brush (inside)
        brush = win32structures.LOGBRUSH()
        brush.lbStyle = fill
        brush.lbHatch = win32defines.HS_DIAGCROSS
        brush_handle = win32functions.CreateBrushIndirect(ctypes.byref(brush))

        # get the Device Context
        dc = win32functions.CreateDC("DISPLAY", None, None, None )

        # push our objects into it
        win32functions.SelectObject(dc, brush_handle)
        win32functions.SelectObject(dc, pen_handle)

        # draw the rectangle to the DC
        win32functions.Rectangle(
            dc, rect.left, rect.top, rect.right, rect.bottom)

        # Delete the brush and pen we created
        win32functions.DeleteObject(brush_handle)
        win32functions.DeleteObject(pen_handle)

        # delete the Display context that we created
        win32functions.DeleteDC(dc)


    #-----------------------------------------------------------
    def PopupWindow(self):
        """Return any owned Popups

        Please do not use in production code yet - not tested fully
        """
        popup = win32functions.GetWindow(self, win32defines.GW_HWNDNEXT)

        return popup


    #-----------------------------------------------------------
    def Owner(self):
        """Return the owner window for the window if it exists

        Returns None if there is no owner"""
        owner = win32functions.GetWindow(self, win32defines.GW_OWNER)
        if owner:
            return HwndWrapper(owner)
        else:
            return None

    #-----------------------------------------------------------
#    def ContextMenuSelect(self, path, x = None, y = None):
#        "TODO ContextMenuSelect Not Implemented"
#        pass
#        #raise NotImplementedError(
#        #    "HwndWrapper.ContextMenuSelect not implemented yet")

    #-----------------------------------------------------------
    def _menu_handle(self):
        "Simple Overridable method to get the menu handle"
        return win32functions.GetMenu(self)

    #-----------------------------------------------------------
    def Menu(self):
        "Return the menu of the control"
        menu_hwnd = self._menu_handle()
        if menu_hwnd: # and win32functions.IsMenu(menu_hwnd):
            return Menu(self, menu_hwnd)
        return None

    #-----------------------------------------------------------
    def MenuItem(self, path):
        """Return the menu item specifed by path

        Path can be a string in the form "MenuItem->MenuItem->MenuItem..."
        where each MenuItem is the text of an item at that level of the menu.
        E.g. ::

          File->Export->ExportAsPNG

        spaces are not important so you could also have written... ::

          File -> Export -> Export As PNG

        """
        if self.appdata is not None:
            menu_appdata = self.appdata['MenuItems']
        else:
            menu_appdata = None

        menu = self.Menu()
        if menu:
            return self.Menu().GetMenuPath(path, appdata = menu_appdata)[-1]

        raise RuntimeError("There is no menu.")

    #-----------------------------------------------------------
    def MenuItems(self):
        """Return the menu items for the dialog

        If there are no menu items then return an empty list
        """
        if self.IsDialog() and self.Menu():
            #menu_handle = win32functions.GetMenu(self)
            #self.SendMessage(win32defines.WM_INITMENU, menu_handle)
            return self.Menu().GetProperties()['MenuItems']

            #self.SendMessage(win32defines.WM_INITMENU, menu_handle)
            #return _GetMenuItems(menu_handle, self)
        else:
            return []



#    #-----------------------------------------------------------
#    def MenuClick(self, path):
#        "Select the menuitem specifed in path"
#
#        self.VerifyActionable()
#
#        self.SetFocus()
#
#        menu = Menu(self, self._menu_handle())
#
#        path_items = menu.GetMenuPath(path)
#
#        for menu_item in path_items:
#            if not menu_item.IsEnabled():
#                raise MenuItemNotEnabled(
#                    "MenuItem '%s' is disabled"% menu_item.Text())
#
#            menu_item.Click()
#
#        return self


    #-----------------------------------------------------------
    def MenuSelect(self, path, ):
        "Select the menuitem specifed in path"

        self.VerifyActionable()

        self.MenuItem(path).Select()


    #-----------------------------------------------------------
    def MoveWindow(
        self,
        x = None,
        y = None,
        width = None,
        height = None,
        repaint = True):
        """Move the window to the new coordinates

        * **x** Specifies the new left position of the window.
          Defaults to the current left position of the window.
        * **y** Specifies the new top position of the window.
          Defaults to the current top position of the window.
        * **width** Specifies the new width of the window. Defaults to the
          current width of the window.
        * **height** Specifies the new height of the window. Default to the
          current height of the window.
        * **repaint** Whether the window should be repainted or not.
          Defaults to True

        """

        cur_rect = self.Rectangle()

        # if no X is specified - so use current coordinate
        if x is None:
            x = cur_rect.left
        else:
            try:
                y = x.top
                width = x.width()
                height = x.height()
                x = x.left
            except AttributeError:
                pass

        # if no Y is specified - so use current coordinate
        if y is None:
            y = cur_rect.top

        # if no width is specified - so use current width
        if width is None:
            width = cur_rect.width()

        # if no height is specified - so use current height
        if height is None:
            height = cur_rect.height()

        # ask for the window to be moved
        ret = win32functions.MoveWindow(self, x, y, width, height, repaint)

        # check that it worked correctly
        if not ret:
            raise ctypes.WinError()

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_movewindow_wait)


    #-----------------------------------------------------------
    def Close(self):
        """Close the window

        Code modified from http://msdn.microsoft.com/msdnmag/issues/02/08/CQA/

        """

        # tell the window it must close
        self.PostMessage(win32defines.WM_CLOSE)

        start = time.time()
        # Keeps trying while
        #    we have not timed out and
        #    window is still a valid handle and
        #    window is still visible
        # any one of these conditions evaluates to false means the window is
        # closed or we have timed out
        def has_closed():
            return not (win32functions.IsWindow(self) and self.IsVisible())

        # Keep waiting until both this control and it's parent
        # are no longer valid controls
        timings.WaitUntil(
            Timings.closeclick_dialog_close_wait,
            Timings.closeclick_retry,
            has_closed
        )

    #-----------------------------------------------------------
    def Maximize(self):
        """Maximize the window"""
        win32functions.ShowWindow(self, win32defines.SW_MAXIMIZE)

    #-----------------------------------------------------------
    def Minimize(self):
        """Minimize the window"""
        win32functions.ShowWindow(self, win32defines.SW_MINIMIZE)

    #-----------------------------------------------------------
    def Restore(self):
        """Restore the window"""

        # do it twice just in case the window was minimized from being
        # maximized - because then the window would come up maximized
        # after the first ShowWindow, and Restored after the 2nd
        win32functions.ShowWindow(self, win32defines.SW_RESTORE)
        win32functions.ShowWindow(self, win32defines.SW_RESTORE)


    #-----------------------------------------------------------
    def GetShowState(self):
        """Get the show state and Maximized/minimzed/restored state

        Returns a value that is a union of the following

        * SW_HIDE the window is hidden.
        * SW_MAXIMIZE the window is maximized
        * SW_MINIMIZE the window is minimized
        * SW_RESTORE the window is in the 'restored'
          state (neither minimized or maximized)
        * SW_SHOW The window is not hidden
        """

        wp = win32structures.WINDOWPLACEMENT()
        wp.lenght = ctypes.sizeof(wp)

        ret = win32functions.GetWindowPlacement(self, ctypes.byref(wp))

        if not ret:
            raise ctypes.WinError()

        return wp.showCmd

    #-----------------------------------------------------------
    def GetFocus(self):
        """Return the control in the process of this window that has the Focus
        """

        gui_info = win32structures.GUITHREADINFO()
        gui_info.cbSize = ctypes.sizeof(gui_info)
        ret = win32functions.GetGUIThreadInfo(
            win32functions.GetWindowThreadProcessId(self, 0),
            ctypes.byref(gui_info))

        if not ret:
            return None

        return HwndWrapper(gui_info.hwndFocus)

    #-----------------------------------------------------------
    def SetFocus(self):
        """Set the focus to this control

        Bring the window to the foreground first if necessary."""

        # find the current foreground window
        cur_foreground = win32functions.GetForegroundWindow()

        # if it is already foreground then just return
        if self.handle != cur_foreground:

            # get the thread of the window that is in the foreground
            cur_fore_thread = win32functions.GetWindowThreadProcessId(
                cur_foreground, 0)

            # get the thread of the window that we want to be in the foreground
            control_thread = win32functions.GetWindowThreadProcessId(self, 0)

            # if a different thread owns the active window
            if cur_fore_thread != control_thread:
                # Attach the two threads and set the foreground window
                win32functions.AttachThreadInput(
                    cur_fore_thread, control_thread, True)

                win32functions.SetForegroundWindow(self)

                # detach the thread again
                win32functions.AttachThreadInput(
                    cur_fore_thread, control_thread, False)

            else:   # same threads - just set the foreground window
                win32functions.SetForegroundWindow(self)

            # make sure that we are idle before returning
            win32functions.WaitGuiThreadIdle(self)

            # only sleep if we had to change something!
            time.sleep(Timings.after_setfocus_wait)

        return self



    #-----------------------------------------------------------
    def SetApplicationData(self, appdata):
        """Application data is data from a previous run of the software

        It is essential for running scripts written for one spoke language
        on a different spoken langauge
        """
        self.appdata = appdata


    _scroll_types = {"left": {
            "line" : win32defines.SB_LINELEFT,
            "page" : win32defines.SB_PAGELEFT,
            "end" :  win32defines.SB_LEFT,
            },
        "right": {
                "line" : win32defines.SB_LINERIGHT,
                "page" : win32defines.SB_PAGERIGHT,
                "end" :  win32defines.SB_RIGHT,
            },
        "up": {
                "line" : win32defines.SB_LINEUP,
                "page" : win32defines.SB_PAGEUP,
                "end" :  win32defines.SB_TOP,
            },
        "down": {
                "line" : win32defines.SB_LINEDOWN,
                "page" : win32defines.SB_PAGEDOWN,
                "end" :  win32defines.SB_BOTTOM,
            },
        }

    #-----------------------------------------------------------
    def Scroll(self, direction, amount, count = 1):
        """Ask the control to scroll itself

        direction can be any of "up", "down", "left", "right"
        amount can be one of "line", "page", "end"
        count (optional) the number of times to scroll
        """

        # check which message we want to send
        if direction.lower() in ("left", "right"):
            message = win32defines.WM_HSCROLL
        elif direction.lower() in ("up", "down"):
            message = win32defines.WM_VSCROLL

        # the constant that matches direction, and how much
        scroll_type = \
            HwndWrapper._scroll_types[direction.lower()][amount.lower()]

        # Scroll as often as we have been asked to
        while count > 0:
            self.SendMessage(message, scroll_type)
            count -= 1

        return self


#
#def MouseLeftClick():
#    pass
#def MouseRightClick():
#    pass
#def MouseDoubleClick():
#    pass
#def MouseDown():
#    pass
#def MouseUp():
#    pass
#def MoveMouse():
#    pass
#def DragMouse():
#    pass
#
#def LeftClick(x, y):
#    win32defines.MOUSEEVENTF_LEFTDOWN
#    win32defines.MOUSEEVENTF_LEFTUP
#
#    # set the cursor position
#    win32functions.SetCursorPos(x, y)
#    time.sleep(Timings.after_setcursorpos_wait)
#
#    inp_struct = win32structures.INPUT()
#    inp_struct.type = win32defines.INPUT_MOUSE
#    for event in (win32defines.MOUSEEVENTF_LEFTDOWN, win32defines.MOUSEEVENTF_LEFTUP):
#        inp_struct._.mi.dwFlags = event
#        win32functions.SendInput(
#            1,
#            ctypes.pointer(inp_struct),
#            ctypes.sizeof(inp_struct))
#
#        time.sleep(Timings.after_clickinput_wait)



#====================================================================
def _perform_click_input(
    ctrl = None,
    button = "left",
    coords = (None, None),
    double = False,
    button_down = True,
    button_up = True,
    absolute = False,
    wheel_dist = 0):
    """Peform a click action using SendInput

    All the *ClickInput() and *MouseInput() methods use this function.
    
    Thanks to a bug report from Tomas Walch (twalch) on sourceforge and code 
    seen at http://msdn.microsoft.com/en-us/magazine/cc164126.aspx this 
    function now always works the same way whether the mouse buttons are 
    swapped or not.
    
    For example if you send a right click to Notepad.Edit - it will always
    bring up a popup menu rather than 'clicking' it.
    """

    # Handle if the mouse buttons are swapped
    if win32functions.GetSystemMetrics(win32defines.SM_SWAPBUTTON):
        if button.lower() == 'left':
            button = 'right'
        else:
            button = 'left'

    events = []
    if button.lower() == 'left':
        if button_down:
            events.append(win32defines.MOUSEEVENTF_LEFTDOWN)
        if button_up:
            events.append(win32defines.MOUSEEVENTF_LEFTUP)
    elif button.lower() == 'right':
        if button_down:
            events.append(win32defines.MOUSEEVENTF_RIGHTDOWN)
        if button_up:
            events.append(win32defines.MOUSEEVENTF_RIGHTUP)
    elif button.lower() == 'middle':
        if button_down:
            events.append(win32defines.MOUSEEVENTF_MIDDLEDOWN)
        if button_up:
            events.append(win32defines.MOUSEEVENTF_MIDDLEUP)
    elif button.lower() == 'x':
        if button_down:
            events.append(win32defines.MOUSEEVENTF_XDOWN)
        if button_up:
            events.append(win32defines.MOUSEEVENTF_XUP)

    if button.lower() == 'wheel':
        events.append(win32defines.MOUSEEVENTF_WHEEL)


    # if we were asked to double click (and we are doing a full click
    # not just up or down.
    if double and button_down and button_up:
        events *= 2


    if ctrl == None:
        ctrl = HwndWrapper(win32functions.GetDesktopWindow())
    else:
        ctrl.SetFocus()

    if isinstance(coords, win32structures.RECT):
        coords = (coords.left, coords.top)

#    # allow points objects to be passed as the coords
#    if isinstance(coords, win32structures.POINT):
#        coords = [coords.x, coords.y]
#    else:
    coords = list(coords)

    # set the default coordinates
    if coords[0] is None:
        coords[0] = ctrl.Rectangle().width() // 2
    if coords[1] is None:
        coords[1] = ctrl.Rectangle().height() // 2

    if not absolute:
        coords[0] = coords[0] + ctrl.Rectangle().left
        coords[1] = coords[1] + ctrl.Rectangle().top

    # set the cursor position
    win32functions.SetCursorPos(coords[0], coords[1])
    time.sleep(Timings.after_setcursorpos_wait)

    inp_struct = win32structures.INPUT()
    inp_struct.type = win32defines.INPUT_MOUSE

    for event in events:
        inp_struct._.mi.dwFlags = event
        if button.lower() == 'wheel':
            inp_struct._.mi.mouseData = wheel_dist
        else:
            inp_struct._.mi.mouseData = 0

        win32functions.SendInput(
            1,
            ctypes.pointer(inp_struct),
            ctypes.sizeof(inp_struct))

        time.sleep(Timings.after_clickinput_wait)





#====================================================================
def _perform_click(
        ctrl,
        button = "left",
        pressed = "",
        coords = (0, 0),
        double = False,
        button_down = True,
        button_up = True):
    "Low level method for performing click operations"

    ctrl.VerifyActionable()

    if isinstance(coords, win32structures.RECT):
        coords = (coords.left, coords.top)

    # figure out the messages for click/press
    msgs  = []
    if not double:
        if button.lower() == "left":
            if button_down:
                msgs.append(win32defines.WM_LBUTTONDOWN)
            if button_up:
                msgs.append(win32defines.WM_LBUTTONUP)

        elif button.lower() == "middle":
            if button_down:
                msgs.append(win32defines.WM_MBUTTONDOWN)
            if button_up:
                msgs.append(win32defines.WM_MBUTTONUP)

        elif button.lower() == "right":
            if button_down:
                msgs.append(win32defines.WM_RBUTTONDOWN)
            if button_up:
                msgs.append(win32defines.WM_RBUTTONUP)

    # figure out the messages for double clicking
    else:
        if button.lower() == "left":
            msgs = (
                win32defines.WM_LBUTTONDOWN,
                win32defines.WM_LBUTTONUP,
                win32defines.WM_LBUTTONDBLCLK,
                win32defines.WM_LBUTTONUP)
        elif button.lower() == "middle":
            msgs = (
                win32defines.WM_MBUTTONDOWN,
                win32defines.WM_MBUTTONUP,
                win32defines.WM_MBUTTONDBLCLK,
                win32defines.WM_MBUTTONUP)
        elif button.lower() == "right":
            msgs = (
                win32defines.WM_RBUTTONDOWN,
                win32defines.WM_RBUTTONUP,
                win32defines.WM_RBUTTONDBLCLK,
                win32defines.WM_RBUTTONUP)

    # figure out the flags and pack coordinates
    flags, click_point = _calc_flags_and_coords(pressed, coords)


    win32functions.AttachThreadInput(
        win32functions.GetCurrentThreadId(), ctrl.ProcessID(), 1)

    # send each message
    for msg in msgs:
        ctrl.PostMessage(msg, flags, click_point)
        #ctrl.PostMessage(msg, flags, click_point)
        #flags = 0

        time.sleep(Timings.sendmessagetimeout_timeout)
        
        # wait until the thread can accept another message
        win32functions.WaitGuiThreadIdle(ctrl)

    # dettach the Python process with the process that self is in
    win32functions.AttachThreadInput(
        win32functions.GetCurrentThreadId(), ctrl.ProcessID(), 0)

    # wait a certain(short) time after the click
    time.sleep(Timings.after_click_wait)


_mouse_flags = {
    "left": win32defines.MK_LBUTTON,
    "right": win32defines.MK_RBUTTON,
    "middle": win32defines.MK_MBUTTON,
    "shift": win32defines.MK_SHIFT,
    "control": win32defines.MK_CONTROL,
}

#====================================================================
def _calc_flags_and_coords(pressed, coords):
    "Calculate the flags to use and the coordinates for mouse actions"
    flags = 0

    for key in pressed.split():
        flags |= _mouse_flags[key.lower()]

    click_point = win32functions.MakeLong(coords[1], coords[0])

    return flags, click_point



#====================================================================
class _dummy_control(dict):
    "A subclass of dict so that we can assign attributes"
    pass

#====================================================================
def GetDialogPropsFromHandle(hwnd):
    "Get the properties of all the controls as a list of dictionaries"

    # wrap the dialog handle and start a new list for the
    # controls on the dialog
    try:
        controls = [hwnd, ]
        controls.extend(hwnd.Children())
    except AttributeError:
        controls = [HwndWrapper(hwnd), ]

        # add all the children of the dialog
        controls.extend(controls[0].Children())

    props = []

    # Add each control to the properties for this dialog
    for ctrl in controls:
        # Get properties for each control and wrap them in
        # _dummy_control so that we can assign handle
        ctrl_props = _dummy_control(ctrl.GetProperties())

        # assign the handle
        ctrl_props.handle = ctrl.handle

        # offset the rectangle from the dialog rectangle
        ctrl_props['Rectangle'] -= controls[0].Rectangle()

        props.append(ctrl_props)

    return props








########NEW FILE########
__FILENAME__ = menuwrapper
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Wrapper around Menu's and Menu items

These wrappers allow you to work easily with menu items.
You can select or click on items and check if they are
checked or unchecked.
"""

__revision__ = "$Revision: 330 $"

import ctypes
import time

from .. import win32structures
from .. import win32functions
from .. import win32defines
from .. import findbestmatch
from ..timings import Timings


class MenuItemNotEnabled(RuntimeError):
    "Raised when a menuitem is not enabled"
    pass


class MenuItem(object):
    """Wrap a menu item"""

    def __init__(self, ctrl, menu, index, on_main_menu = False):
        """Initalize the menu item

        * **ctrl**	The dialog or control that owns this menu
        * **menu**	The menu that this item is on
        * **index**	The Index of this menuitem on the menu
        * **on_main_menu**	True if the item is on the main menu

        """
        self.index = index
        self.menu = menu
        self.ctrl = ctrl
        self.on_main_menu = on_main_menu


    def _read_item(self):
        """Read the menu item info

        See http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/resources/menus/menureference/menufunctions/getmenuiteminfo.asp
        for more information."""
        menu_info  = win32structures.MENUITEMINFOW()
        menu_info.cbSize = ctypes.sizeof (menu_info)
        menu_info.fMask = \
            win32defines.MIIM_CHECKMARKS | \
            win32defines.MIIM_ID | \
            win32defines.MIIM_STATE | \
            win32defines.MIIM_SUBMENU | \
            win32defines.MIIM_TYPE #| \
            #MIIM_FTYPE #| \
            #MIIM_STRING
            #MIIM_DATA | \

        ret = win32functions.GetMenuItemInfo (
            self.menu,
            self.index,
            True,
            ctypes.byref(menu_info))

        if not ret:
            raise ctypes.WinError()

        return menu_info

    def FriendlyClassName(self):
        return "MenuItem"

    def Rectangle(self):
        "Get the rectangle of the menu item"
        rect = win32structures.RECT()

        if self.on_main_menu:
            ctrl = self.ctrl
        else:
            ctrl = 0

        win32functions.GetMenuItemRect(
            ctrl,
            self.menu,
            self.index,
            ctypes.byref(rect))

        return rect

    def Index(self):
        "Return the index of this menu item"
        return self.index

    def State(self):
        "Return the state of this menu item"
        return self._read_item().fState

    def ID(self):
        "Return the ID of this menu item"
        return self._read_item().wID

    def Type(self):
        """Return the Type of this menu item

        Main types are MF_STRING, MF_BITMAP, MF_SEPARATOR.

        See http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/resources/menus/menureference/menustructures/menuiteminfo.asp
        for further information."""
        return self._read_item().fType

    def Text(self):
        "Return the state of this menu item"

        info = self._read_item()
        # if there is text
        if info.cch:
            # allocate a buffer
            buffer_size = info.cch+1
            text = ctypes.create_unicode_buffer(buffer_size)

            # update the structure and get the text info
            info.dwTypeData = ctypes.addressof(text)
            info.cch = buffer_size

            win32functions.GetMenuItemInfo (
                self.menu,
                self.index,
                True,
                ctypes.byref(info))

            text = text.value
        else:
            text = ''

        return text

    def SubMenu(self):
        "Return the SubMenu or None if no submenu"
        submenu_handle = self._read_item().hSubMenu

        if submenu_handle:
            self.ctrl.SendMessageTimeout(
                win32defines.WM_INITMENUPOPUP,
                submenu_handle,
                self.index)

            return Menu(self.ctrl, submenu_handle, False, self)

        return None

    def IsEnabled(self):
        "Return True if the item is enabled."
        return not (
            self.State() & win32defines.MF_DISABLED or
            self.State() & win32defines.MF_GRAYED)

    def IsChecked(self):
        "Return True if the item is checked."
        return bool(self.State() & win32defines.MF_CHECKED)


    def Click(self):
        """Click on the menu item

        If the menu is open this it will click with the mouse on the item.
        If the menu is not open each of it's parent's will be opened
        until the item is visible.

        """

        self.ctrl.VerifyEnabled()

        rect = self.Rectangle()

        if not self.IsEnabled():
            raise MenuItemNotEnabled(
                "MenuItem '%s' is disabled"% self.Text())

        # if the item is not visible - work up along it's parents
        # until we find an item we CAN click on
        if rect == (0, 0, 0, 0):
            if self.menu.owner_item:
                self.menu.owner_item.Click()

        rect = self.Rectangle()

        x_pt = (rect.left + rect.right) /2
        y_pt = (rect.top + rect.bottom) /2

        from .HwndWrapper import _perform_click_input #, delay_after_menuselect

        _perform_click_input(
            None,
            coords = (x_pt, y_pt),
            absolute = True)

        win32functions.WaitGuiThreadIdle(self.ctrl)

        #import time
        #time.sleep(delay_after_menuselect)


    def Select(self):
        """Select the menu item

        This will send a message to the parent window that the
        item was picked
        """

        if not self.IsEnabled():
            raise MenuItemNotEnabled(
                "MenuItem '%s' is disabled"% self.Text())

        #from HwndWrapper import delay_after_menuselect

        #if self.State() & win32defines.MF_BYPOSITION:
        #    print self.Text(), "BYPOSITION"
        #    self.ctrl.NotifyMenuSelect(self.Index(), True)
        #else:

        # seems like SetFoucs might be messing with getting the
        # id for Popup menu items - so I calling it before SetFocus
        command_id = self.ID()

        # notify the control that a menu item was selected
        self.ctrl.SetFocus()
        self.ctrl.SendMessageTimeout(
            win32defines.WM_COMMAND,
            win32functions.MakeLong(0, command_id))

        #self.ctrl.NotifyMenuSelect(self.ID())
        win32functions.WaitGuiThreadIdle(self.ctrl)
        time.sleep(Timings.after_menu_wait)

    def GetProperties(self):
        """Return the properties for the item as a dict

        If this item opens a sub menu then call Menu.GetProperties()
        to return the list of items in the sub menu. This is avialable
        under the 'MenuItems' key
        """
        props = {}
        props['Index'] = self.Index()
        props['State'] = self.State()
        props['Type'] = self.Type()
        props['ID'] = self.ID()
        props['Text'] = self.Text()

        submenu =  self.SubMenu()
        if submenu:
            props['MenuItems'] = submenu.GetProperties()

        return props

    def __repr__(self):
        "Return a representation of the object as a string"
        return "<MenuItem %s>" % repr(self.Text())



#    def Check(self):
#        item = self._read_item()
#        item.fMask = win32defines.MIIM_STATE
#        item.fState &= win32defines.MF_CHECKED
#
##        ret = win32functions.SetMenuItemInfo(
##            self.menuhandle,
##            self.ID(),
##            0, # by position
##            ctypes.byref(item))
##
##        if not ret:
##            raise ctypes.WinError()
#
#        print win32functions.CheckMenuItem(
#            self.menuhandle,
#            self.index,
#            win32defines.MF_BYPOSITION | win32defines.MF_CHECKED)
#
#        win32functions.DrawMenuBar(self.ctrl)
#
#    def UnCheck(self):
#        item = self._read_item()
#        item.fMask = win32defines.MIIM_STATE
#        item.fState &= win32defines.MF_UNCHECKED
#
#        ret = win32functions.SetMenuItemInfo(
#            self.menuhandle,
#            self.ID(),
#            0, # by position
#            ctypes.byref(item))
#
#        if not ret:
#            raise ctypes.WinError()
#
#        win32functions.DrawMenuBar(self.ctrl)
#
#

class Menu(object):
    """A simple wrapper around a menu handle

    A menu supports methods for querying the menu
    and getting it's menu items."""
    def __init__(
        self,
        owner_ctrl,
        menuhandle,
        is_main_menu = True,
        owner_item = None):
        """Initialize the class.

        * **owner_ctrl** is the Control that owns this menu
        * **menuhandle** is the menu handle of the menu
        * **is_main_menu** we have to track whether it is the main menu
          or a popup menu
        * **owner_item** The item that contains this menu - this will be
          None for the main menu, it will be a MenuItem instance for a
          submenu.

        """
        self.ctrl = owner_ctrl
        self.handle = menuhandle
        self.is_main_menu = is_main_menu
        self.owner_item = owner_item

        self._as_parameter_ = self.handle

        if self.is_main_menu:
            self.ctrl.SendMessageTimeout(win32defines.WM_INITMENU, self.handle)

    def ItemCount(self):
        "Return the count of items in this menu"
        return win32functions.GetMenuItemCount(self.handle)

    def Item(self, index):
        """Return a specific menu item

        * **index** is the 0 based index of the menu item you want
        """
        return MenuItem(self.ctrl, self, index, self.is_main_menu)

    def Items(self):
        "Return a list of all the items in this menu"
        items = []
        for i in range(0, self.ItemCount()):
            items.append(self.Item(i))

        return items

    def GetProperties(self):
        """Return the properties for the menu as a list of dictionaries

        This method is actually recursive. It calls GetProperties() for each
        of the items. If the item has a sub menu it will call this
        GetProperties to get the sub menu items.
        """
        item_props = []

        for item in self.Items():
            item_props.append(item.GetProperties())

        return {'MenuItems': item_props}


    def GetMenuPath(self, path, path_items = None, appdata = None):
        """Walk the items in this menu to find the item specified by path
        
        The path is specified by a list of items separated by '->' each Item
        can be either a string (can include spaces) e.g. "Save As" or the zero
        based index of the item to return prefaced by # e.g. #1. 
        
        These can be mixed as necessary. For Example:
            "#0 -> Save As", 
            "Tools -> #0 -> Configure"
        
        Text matching is done using a 'best match' fuzzy algorithm, so you don't
        have to add all puntuation, elipses, etc.
        """

        if path_items is None:
            path_items = []

        # get the first part (and remainder)
        parts = path.split("->", 1)
        current_part = parts[0]

        if current_part.startswith("#"):
            index = int(current_part[1:])
            best_item = self.Item(index)
        else:
            # get the text names from the menu items
            if appdata is None:
                item_texts = [item.Text() for item in self.Items()]

            else:
                item_texts = [item['Text'] for item in appdata]

            # find the item that best matches the current part
            best_item = findbestmatch.find_best_match(
                current_part,
                item_texts,
                self.Items())

        path_items.append(best_item)


        # if there are more parts - then get the next level
        if parts[1:]:
            if appdata:
                appdata = appdata[best_item.Index()]['MenuItems']
            if best_item.SubMenu() is not None:
                best_item.SubMenu().GetMenuPath(
                    "->".join(parts[1:]),
                    path_items,
                    appdata)

        return path_items


    def __repr__(self):
        "Return a simple representation of the menu"
        return "<Menu %d>" % self.handle


#    def GetProperties(self):
#
#        for i in range(0, self.ItemCount()):
#            menu_info = self.Item(self, i)[0]
#
#            item_prop['Index'] = i
#            item_prop['State'] = menu_info.fState
#            item_prop['Type'] = menu_info.fType
#            item_prop['ID'] = menu_info.wID
#
#            else:
#                item_prop['Text'] = ""
#
#            if self.IsSubMenu(i):
#                item_prop['MenuItems'] = self.SubMenu(i).GetProperties()
#
#            return item_prop


##====================================================================
#def _GetMenuItems(menu_handle, ctrl):
#    "Get the menu items as a list of dictionaries"
#    # If it doesn't have a real menu just return
#    if not win32functions.IsMenu(menu_handle):
#        return []
#
#
#    menu = Menu(ctrl, menu_handle)
#
#    props = []
#    for item in menu.Items():
#        item_props = {}
#
#        item_prop['Index'] = item.Index()
#        item_prop['State'] = item.State()
#        item_prop['Type'] = item.Type()
#        item_prop['ID'] = item.ID()
#        item_prop['Text'] = item.Text()
#
#        props.append(item_props)
#
#
#
#
#
#
#
#    items = []
#
#
#    # for each menu item
#    for i in range(0, item_count):
#
#        item_prop = {}
#
#        # get the information on the menu Item
#        menu_info  = win32structures.MENUITEMINFOW()
#        menu_info.cbSize = ctypes.sizeof (menu_info)
#        menu_info.fMask = \
#            win32defines.MIIM_CHECKMARKS | \
#            win32defines.MIIM_ID | \
#            win32defines.MIIM_STATE | \
#            win32defines.MIIM_SUBMENU | \
#            win32defines.MIIM_TYPE #| \
#            #MIIM_FTYPE #| \
#            #MIIM_STRING
#            #MIIM_DATA | \
#
#
#        ret = win32functions.GetMenuItemInfo (
#            menu_handle, i, True, ctypes.byref(menu_info))
#        if not ret:
#            raise ctypes.WinError()
#
#        # if there is text
#        if menu_info.cch:
#            # allocate a buffer
#            buffer_size = menu_info.cch+1
#            text = ctypes.create_unicode_buffer(buffer_size)
#
#            # update the structure and get the text info
#            menu_info.dwTypeData = ctypes.addressof(text)
#            menu_info.cch = buffer_size
#            win32functions.GetMenuItemInfo (
#                menu_handle, i, True, ctypes.byref(menu_info))
#            item_prop['Text'] = text.value
#        else:
#            item_prop['Text'] = ""
#
#        # if it's a sub menu then get it's items
#        if menu_info.hSubMenu:
#            # make sure that the app updates the menu if it need to
#            ctrl.SendMessage(
#                win32defines.WM_INITMENUPOPUP, menu_info.hSubMenu, i)
#
#            #ctrl.SendMessage(
#            #    win32defines.WM_INITMENU, menu_info.hSubMenu, )
#
#            # get the sub menu items
#            sub_menu_items = _GetMenuItems(menu_info.hSubMenu, ctrl)
#
#            # append them
#            item_prop['MenuItems'] = sub_menu_items
#
#        items.append(item_prop)
#
#    return items
#



########NEW FILE########
__FILENAME__ = win32_controls
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Wraps various standard windows controls"

__revision__ = "$Revision: 699 $"

import time

import ctypes

from . import HwndWrapper

from .. import win32functions
from .. import win32defines
from .. import win32structures
#from pywinauto import findbestmatch
from .. import controlproperties

from .. import tests
from ..timings import Timings

#====================================================================
class ButtonWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows Button control"

    friendlyclassname = "Button"
    windowclasses = [
        "Button",
        r"WindowsForms\d*\.BUTTON\..*",
        "TButton",
        "ThunderCommandButton",
        "ThunderOptionButton",
        "ThunderCheckBox"]
    can_be_label = True

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the control"
        super(ButtonWrapper, self).__init__(hwnd)

        #self._set_if_needs_image()


    def _set_if_needs_image(self, value):
        "Does nothing see _get_if_needs_image"
        pass
    #-----------------------------------------------------------
    def _get_if_needs_image(self):
        "Set the _NeedsImageProp attribute if it is an image button"

        # optimization call Style once and work with that rather than
        # calling HasStyle a number of times
        style = self.Style()

        if self.IsVisible() and (\
            style & win32defines.BS_BITMAP == style or \
            style & win32defines.BS_ICON == style or \
            style & win32defines.BS_OWNERDRAW == style):

            #self._NeedsImageProp = True
            return True
        else:
            return False
    _NeedsImageProp = property(_get_if_needs_image, _set_if_needs_image)

    #-----------------------------------------------------------
    def FriendlyClassName(self):
        """Return the friendly class name of the button

        Windows controls with the class "Button" can look like different
        controls based on their style. They can look like the following
        controls:

          - Buttons, this method returns "Button"
          - CheckBoxes, this method returns "CheckBox"
          - RadioButtons, this method returns "RadioButton"
          - GroupBoxes, this method returns "GroupBox"

        """
        # get the least significant BIT
        style_lsb = self.Style() & 0xF

        f_class_name = 'Button'


        vb_buttons = {
            "ThunderOptionButton": "RadioButton",
            "ThunderCheckBox": "CheckBox",
            "ThunderCommandButton": "Button"
        }

        if self.Class() in vb_buttons:
            f_class_name = vb_buttons[self.Class()]

        if style_lsb == win32defines.BS_3STATE or \
            style_lsb == win32defines.BS_AUTO3STATE or \
            style_lsb == win32defines.BS_AUTOCHECKBOX or \
            style_lsb == win32defines.BS_CHECKBOX:
            f_class_name = "CheckBox"
        elif style_lsb == win32defines.BS_RADIOBUTTON or \
            style_lsb == win32defines.BS_AUTORADIOBUTTON:
            f_class_name = "RadioButton"
        elif style_lsb ==  win32defines.BS_GROUPBOX:
            f_class_name = "GroupBox"

        if self.Style() & win32defines.BS_PUSHLIKE:
            f_class_name = "Button"

        return f_class_name


    #-----------------------------------------------------------
    def GetCheckState(self):
        """Return the check state of the checkbox

        The check state is represented by an integer
        0 - unchecked
        1 - checked
        2 - indeterminate

        The following constants are defined in the win32defines module
        BST_UNCHECKED = 0
        BST_CHECKED = 1
        BST_INDETERMINATE = 2
        """
        return self.SendMessage(win32defines.BM_GETCHECK)

    #-----------------------------------------------------------
    def Check(self):
        "Check a checkbox"
        self.SendMessageTimeout(win32defines.BM_SETCHECK,
            win32defines.BST_CHECKED)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_buttoncheck_wait)

        # return this control so that actions can be chained.
        return self


    #-----------------------------------------------------------
    def UnCheck(self):
        "Uncheck a checkbox"
        self.SendMessageTimeout(win32defines.BM_SETCHECK,
            win32defines.BST_UNCHECKED)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_buttoncheck_wait)

        # return this control so that actions can be chained.
        return self

    #-----------------------------------------------------------
    def SetCheckIndeterminate(self):
        "Set the checkbox to indeterminate"
        self.SendMessageTimeout(win32defines.BM_SETCHECK,
            win32defines.BST_INDETERMINATE)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_buttoncheck_wait)

        # return this control so that actions can be chained.
        return self

    #-----------------------------------------------------------
    def IsDialog(self):
        "Buttons are never dialogs so return False"
        return False

    #-----------------------------------------------------------
    def Click(self, *args, **kwargs):
        "Click the Button control"
    #    import win32functions
    #    win32functions.WaitGuiThreadIdle(self)
    #    self.NotifyParent(win32defines.BN_CLICKED)
        HwndWrapper.HwndWrapper.Click(self, *args, **kwargs)
    #    win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_button_click_wait)


    #def IsSelected (self):
    #    (for radio buttons)



#====================================================================
def _get_multiple_text_items(wrapper, count_msg, item_len_msg, item_get_msg):
    "Helper function to get multiple text items from a control"

    texts = []

    # find out how many text items are in the combobox
    num_items = wrapper.SendMessage(count_msg)

    # get the text for each item in the combobox
    for i in range(0, num_items):
        text_len = wrapper.SendMessage (item_len_msg, i, 0)

        text = ctypes.create_unicode_buffer(text_len + 1)

        wrapper.SendMessage(item_get_msg, i, ctypes.byref(text))

        texts.append(text.value)

    return texts


#====================================================================
class ComboBoxWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows ComboBox control"

    friendlyclassname = "ComboBox"
    windowclasses = [
        "ComboBox",
        "WindowsForms\d*\.COMBOBOX\..*",
        "TComboBox"]
    has_title = False

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the control"
        super(ComboBoxWrapper, self).__init__(hwnd)

        self.writable_props.extend([
            "SelectedIndex",
            "DroppedRect",
            ])

    #-----------------------------------------------------------
    def DroppedRect(self):
        "Get the dropped rectangle of the combobox"
        dropped_rect = win32structures.RECT()

        self.SendMessage(
            win32defines.CB_GETDROPPEDCONTROLRECT,
            0,
            ctypes.byref(dropped_rect))

        # we need to offset the dropped rect from the control
        dropped_rect -= self.Rectangle()

        return dropped_rect

    #-----------------------------------------------------------
    def ItemCount(self):
        "Return the number of items in the combobox"
        return self.SendMessage(win32defines.CB_GETCOUNT)

    #-----------------------------------------------------------
    def SelectedIndex(self):
        "Return the selected index"
        return self.SendMessage(win32defines.CB_GETCURSEL)

    #-----------------------------------------------------------
    def _get_item_index(self, ident):
        "Get the index for the item with this 'ident'"
        if isinstance(ident, int):

            if ident >= self.ItemCount():
                raise IndexError(
                    "Combobox has %d items, you requested item %d (0 based)"%
                        (self.ItemCount(),
                        ident))

            # negative index
            if ident < 0:
                # convert it to a positive index
                ident = (self.ItemCount() + ident)

        elif isinstance(ident, str):
            # todo - implement fuzzy lookup for ComboBox items
            # todo - implement appdata lookup for combobox items
            ident = self.ItemTexts().index(ident)

        return ident

    #-----------------------------------------------------------
    def ItemData(self, item):
        "Returns the item data associated with the item if any"
        index = self._get_item_index(item)
        return self.SendMessage(win32defines.CB_GETITEMDATA, index)

    #-----------------------------------------------------------
    def ItemTexts(self):
        "Return the text of the items of the combobox"
        return _get_multiple_text_items(
            self,
            win32defines.CB_GETCOUNT,
            win32defines.CB_GETLBTEXTLEN,
            win32defines.CB_GETLBTEXT)

    #-----------------------------------------------------------
    def Texts(self):
        "Return the text of the items in the combobox"
        texts = [self.WindowText()]
        texts.extend(self.ItemTexts())
        return texts

    #-----------------------------------------------------------
    def GetProperties(self):
        "Return the properties of the control as a dictionary"
        props = HwndWrapper.HwndWrapper.GetProperties(self)

        #props['ItemData'] = []
        #for i in range(self.ItemCount()):
        #    props['ItemData'].append(self.ItemData(i))

        return props

    #-----------------------------------------------------------
    def Select(self, item):
        """Select the ComboBox item

        item can be either a 0 based index of the item to select
        or it can be the string that you want to select
        """
        self.VerifyActionable()

        index = self._get_item_index(item)

        # change the selected item
        self.SendMessageTimeout(win32defines.CB_SETCURSEL, index)

        # Notify the parent that we are finished selecting
        self.NotifyParent(win32defines.CBN_SELENDOK)

        # Notify the parent that we have changed
        self.NotifyParent(win32defines.CBN_SELCHANGE)

        # simple combo boxes don't have drop downs so they do not recieve
        # this notification
        if self.HasStyle(win32defines.CBS_DROPDOWN):
            # Notify the parent that the drop down has closed
            self.NotifyParent(win32defines.CBN_CLOSEUP)


        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_comboboxselect_wait)

        # return this control so that actions can be chained.
        return self

    #-----------------------------------------------------------
    #def Deselect(self, item):
    # Not implemented because it doesn't make sense for combo boxes.

    #TODO def EditControl(self): # return the edit control of the Combobox

    #TODO def ListControl(self): # return the list control of the combobox

    #TODO def ItemText(self, index):  # get the test of item XX?

    #TODO def EditText(self):  # or should this be self.EditControl.Text()?


#====================================================================
class ListBoxWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows ListBox control"

    friendlyclassname = "ListBox"
    windowclasses = [
        "ListBox",
        r"WindowsForms\d*\.LISTBOX\..*",
        "ThunderListBox",
        "ThunderFileListBox",
        "TListBox",]
    has_title = False

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the control"
        super(ListBoxWrapper, self).__init__(hwnd)

        self.writable_props.extend([
            "SelectedIndices"])

    #-----------------------------------------------------------
    def SelectedIndices(self):
        "The currently selected indices of the listbox"
        num_selected = self.SendMessage(win32defines.LB_GETSELCOUNT)

        # if we got LB_ERR then it is a single selection list box
        if num_selected == win32defines.LB_ERR:
            items = (self.SendMessage(win32defines.LB_GETCURSEL), )

        # otherwise it is a multiselection list box
        else:
            items = (ctypes.c_int * num_selected)()

            self.SendMessage(
                win32defines.LB_GETSELITEMS, num_selected, ctypes.byref(items))

            # Need to convert from Ctypes array to a python tuple
            items = tuple(items)

        return items

    #-----------------------------------------------------------
    def _get_item_index(self, ident):
        "Return the index of the item 'ident'"
        if isinstance(ident, int):

            if ident >= self.ItemCount():
                raise IndexError(
                    "ListBox has %d items, you requested item %d (0 based)"%
                        (self.ItemCount(),
                        ident))

            # negative index
            if ident < 0:
                ident = (self.ItemCount() + ident)

        elif isinstance(ident, str):
            # todo - implement fuzzy lookup for ComboBox items
            # todo - implement appdata lookup for combobox items
            ident = self.ItemTexts().index(ident) #-1

        return ident

    #-----------------------------------------------------------
    def ItemCount(self):
        "Return the number of items in the ListBox"
        return self.SendMessage(win32defines.LB_GETCOUNT)

    #-----------------------------------------------------------
    def ItemData(self, i):
        "Return the ItemData if any associted with the item"

        index = self._get_item_index(i)

        return self.SendMessage(win32defines.LB_GETITEMDATA, index)

    #-----------------------------------------------------------
    def ItemTexts(self):
        "Return the text of the items of the listbox"
        return _get_multiple_text_items(
            self,
            win32defines.LB_GETCOUNT,
            win32defines.LB_GETTEXTLEN,
            win32defines.LB_GETTEXT)

    #-----------------------------------------------------------
    def Texts(self):
        "Return the texts of the control"
        texts = [self.WindowText()]
        texts.extend(self.ItemTexts())
        return texts

#    #-----------------------------------------------------------
#    def GetProperties(self):
#        "Return the properties as a dictionary for the control"
#        props = HwndWrapper.HwndWrapper.GetProperties(self)
#
#        props['ItemData'] = []
#        for i in range(self.ItemCount()):
#            props['ItemData'].append(self.ItemData(i))
#
#        return props

    #-----------------------------------------------------------
    def Select(self, item):
        """Select the ListBox item

        item can be either a 0 based index of the item to select
        or it can be the string that you want to select
        """
        self.VerifyActionable()

        # Make sure we have an index  so if passed in a
        # string then find which item it is
        index = self._get_item_index(item)

        # change the selected item
        self.SendMessageTimeout(win32defines.LB_SETCURSEL, index)

        # Notify the parent that we have changed
        self.NotifyParent(win32defines.LBN_SELCHANGE)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_listboxselect_wait)

        return self

    #-----------------------------------------------------------
    def SetItemFocus(self, item):
        "Set the ListBox focus to the item at index"

        index = self._get_item_index(item)

        # if it is a multiple selection dialog
        if self.HasStyle(win32defines.LBS_EXTENDEDSEL) or \
            self.HasStyle(win32defines.LBS_MULTIPLESEL):
            self.SendMessageTimeout(win32defines.LB_SETCARETINDEX, index)
        else:
            self.SendMessageTimeout(win32defines.LB_SETCURSEL, index)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_listboxfocuschange_wait)

        # return this control so that actions can be chained.
        return self


    #-----------------------------------------------------------
    def GetItemFocus(self):
        "Retrun the index of current selection in a ListBox"

        # if it is a multiple selection dialog
        if self.HasStyle(win32defines.LBS_EXTENDEDSEL) or \
            self.HasStyle(win32defines.LBS_MULTIPLESEL):
            return self.SendMessage(win32defines.LB_GETCARETINDEX)
        else:
            return self.SendMessage(win32defines.LB_GETCURSEL)


#====================================================================
class EditWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows Edit control"

    friendlyclassname = "Edit"
    windowclasses = [
        "Edit",
        "TEdit",
        "TMemo",
        r"WindowsForms\d*\.EDIT\..*",
        "ThunderTextBox",
        "ThunderRT6TextBox",
        ]
    has_title = False

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        "Initialize the control"
        super(EditWrapper, self).__init__(hwnd)

        self.writable_props.extend([
            'SelectionIndices'])

    #-----------------------------------------------------------
    def LineCount(self):
        "Return how many lines there are in the Edit"
        return  self.SendMessage(win32defines.EM_GETLINECOUNT)-1

    #-----------------------------------------------------------
    def LineLength(self, line_index):
        "Return how many characters there are in the line"

        # need to first get a character index of that line
        char_index = self.SendMessage(win32defines.EM_LINEINDEX, line_index)

        # now get the length of text on that line
        return self.SendMessage (
            win32defines.EM_LINELENGTH, char_index, 0)


    #-----------------------------------------------------------
    def GetLine(self, line_index):
        "Return the line specified"

        text_len = self.LineLength(line_index)
        # create a buffer and set the length at the start of the buffer
        text = ctypes.create_unicode_buffer(text_len+3)
        text[0] = chr(text_len)

        # retrieve the line itself
        self.SendMessage(
            win32defines.EM_GETLINE, line_index, ctypes.byref(text))

        return text.value

    #-----------------------------------------------------------
    def Texts(self):
        "Get the text of the edit control"

        texts = [self.WindowText(), ]

        for i in range(0, self.LineCount()+1):
            texts.append(self.GetLine(i))

        return texts

    #-----------------------------------------------------------
    def TextBlock(self):
        "Get the text of the edit control"

        length = self.SendMessage(win32defines.WM_GETTEXTLENGTH)
        text = ctypes.create_unicode_buffer(length + 1)
        self.SendMessage(win32defines.WM_GETTEXT, length+1, ctypes.byref(text))

        #text = text.value.replace("\r\n", "\n")
        return text.value

    #-----------------------------------------------------------
    def SelectionIndices(self):
        "The start and end indices of the current selection"
        start = ctypes.c_int()
        end = ctypes.c_int()
        self.SendMessage(
            win32defines.EM_GETSEL, ctypes.byref(start), ctypes.byref(end))

        return (start.value, end.value)

    #-----------------------------------------------------------
    def SetWindowText(self, text, append = False):
        """Override SetWindowText for edit controls because it should not be
        used for Edit controls.

        Edit Controls should either use SetEditText() or TypeKeys() to modify
        the contents of the edit control."""
        HwndWrapper.HwndWrapper.SetWindowText(self, text, append)
        raise UserWarning(
            "SetWindowText() should probably not be called for Edit Controls")

    #-----------------------------------------------------------
    def SetEditText(self, text, pos_start = None, pos_end = None):
        "Set the text of the edit control"
        self.VerifyActionable()

        # allow one or both of pos_start and pos_end to be None
        if pos_start is not None or pos_end is not None:

            # if only one has been specified - then set the other
            # to the current selection start or end
            start, end = self.SelectionIndices()
            if pos_start is None:
                pos_start = start
            if pos_end is None:
                pos_end = end

            # set the selection if either start or end has
            # been specified
            self.Select(pos_start, pos_end)
        else:
            self.Select()

        # replace the selection with
        text = ctypes.c_wchar_p(str(text))
        self.SendMessageTimeout(win32defines.EM_REPLACESEL, True, text)

        win32functions.WaitGuiThreadIdle(self)
        time.sleep(Timings.after_editsetedittext_wait)


        # return this control so that actions can be chained.
        return self

    # set SetText as an alias to SetEditText
    SetText = SetEditText

    #-----------------------------------------------------------
    def Select(self, start = 0, end = None):
        "Set the edit selection of the edit control"
        self.VerifyActionable()

        # if we have been asked to select a string
        if isinstance(start, str):
            string_to_select = start
            #
            start = self.TextBlock().index(string_to_select)

            if end is None:
                end = start + len(string_to_select)

        if end is None:
            end = -1

        self.SendMessageTimeout(win32defines.EM_SETSEL, start, end)

        # give the control a chance to catch up before continuing
        win32functions.WaitGuiThreadIdle(self)

        time.sleep(Timings.after_editselect_wait)

        # return this control so that actions can be chained.
        return self


#====================================================================
class StaticWrapper(HwndWrapper.HwndWrapper):
    "Wrap a windows Static control"

    friendlyclassname = "Static"
    windowclasses = [
        "Static",
        r"WindowsForms\d*\.STATIC\..*",
        "TPanel"]
    can_be_label = True

    def __init__(self, hwnd):
        "Initialize the control"
        super(StaticWrapper, self).__init__(hwnd)

        # if the control is visible - and it shows an image
        if self.IsVisible() and (
            self.HasStyle(win32defines.SS_ICON) or \
            self.HasStyle(win32defines.SS_BITMAP) or \
            self.HasStyle(win32defines.SS_CENTERIMAGE) or \
            self.HasStyle(win32defines.SS_OWNERDRAW)):

            self._NeedsImageProp = True


#====================================================================
# the main reason for this is just to make sure that
# a Dialog is a known class - and we don't need to take
# an image of it (as an unknown control class)
class DialogWrapper(HwndWrapper.HwndWrapper):
    "Wrap a dialog"

    friendlyclassname = "Dialog"
    #windowclasses = ["#32770", ]
    can_be_label = True

    #-----------------------------------------------------------
    def __init__(self, hwnd):
        """Initialize the DialogWrapper

        The only extra functionality here is to modify self.friendlyclassname
        to make it "Dialog" if the class is "#32770" otherwise to leave it
        the same as the window class.
        """
        HwndWrapper.HwndWrapper.__init__(self, hwnd)

        if self.Class() == "#32770":
            self.friendlyclassname = "Dialog"
        else:
            self.friendlyclassname = self.Class()

    #-----------------------------------------------------------
    def RunTests(self, tests_to_run = None, ref_controls = None):
        "Run the tests on dialog"

        # get all the controls
        controls = [self] + self.Children()
        
        # add the reference controls
        if ref_controls is not None:                        
            matched_flags = controlproperties.SetReferenceControls(
                controls, ref_controls)
            
            # todo: allow some checking of how well the controls matched
            # matched_flags says how well they matched
            # 1 = same number of controls
            # 2 = ID's matched
            # 4 = control classes matched
            # i.e. 1 + 2 + 4 = perfect match
        
        return tests.run_tests(controls, tests_to_run)

    #-----------------------------------------------------------
    def WriteToXML(self, filename):
        "Write the dialog an XML file (requires elementtree)"
        
        controls = [self] + self.Children()
        props = [ctrl.GetProperties() for ctrl in controls]

        from pywinauto import XMLHelpers
        XMLHelpers.WriteDialogToFile(filename, props)

    #-----------------------------------------------------------
    def ClientAreaRect(self):
        """Return the client area rectangle

        From MSDN
        The client area of a control is the bounds of the control, minus the
        nonclient elements such as scroll bars, borders, title bars, and 
        menus."""
        rect = win32structures.RECT(self.Rectangle())
        self.SendMessage(win32defines.WM_NCCALCSIZE, 0, ctypes.byref(rect))
        return rect

#    #-----------------------------------------------------------
#    def ReadControlsFromXML(self, filename):
#        from pywinauto import XMLHelpers
#        [controlproperties.ControlProps(ctrl) for
#            ctrl in XMLHelpers.ReadPropertiesFromFile(handle)]  


#    #-----------------------------------------------------------
#    def AddReference(self, reference):
#
#        if len(self.Children() != len(reference)):
#            raise "different number of reference controls"
#
#        for i, ctrl in enumerate(reference):
#        # loop over each of the controls
#        # and set the reference
#            if isinstance(ctrl, dict):
#                ctrl = CtrlProps(ctrl)
#
#            self.
#            if ctrl.Class() != self.Children()[i+1].Class():
#                print "different classes"



#====================================================================
# the main reason for this is just to make sure that
# a Dialog is a known class - and we don't need to take
# an image of it (as an unknown control class)
class PopupMenuWrapper(HwndWrapper.HwndWrapper):
    "Wrap a Popup Menu"

    friendlyclassname = "PopupMenu"
    windowclasses = ["#32768", ]
    has_title = False

    #-----------------------------------------------------------
    def IsDialog(self):
        "Return whether it is a dialog"
        return True

    #-----------------------------------------------------------
    def _menu_handle(self):
        "Get the menu handle for the popup menu menu"
        mbi = win32structures.MENUBARINFO()
        mbi.cbSize = ctypes.sizeof(mbi)
        ret = win32functions.GetMenuBarInfo(
            self,
            win32defines.OBJID_CLIENT,
            0,
            ctypes.byref(mbi))

        if not ret:
            raise ctypes.WinError()

        return mbi.hMenu



########NEW FILE########
__FILENAME__ = findbestmatch
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Module to find the closest match of a string in a list"

__revision__ = "$Revision: 679 $"

import re
import difflib

from . import fuzzydict
#import ctypes
#import ldistance
#levenshtein_distance = ctypes.cdll.levenshtein.levenshtein_distance
#levenshtein_distance = ldistance.distance


# need to use sets.Set for python 2.3 compatability
# but 2.6 raises a deprecation warning about sets module
try:
    set
except NameError:
    import sets
    set = sets.Set

find_best_control_match_cutoff = .6

#====================================================================
class MatchError(IndexError):
    "A suitable match could not be found"
    def __init__(self, items = None, tofind = ''):
        "Init the parent with the message"
        self.tofind = tofind
        self.items = items
        if self.items is None:
            self.items = []

        IndexError.__init__(self,
            "Could not find '%s' in '%s'"% (tofind, self.items))


_cache = {}

# given a list of texts return the match score for each
# and the best score and text with best score
#====================================================================
def _get_match_ratios(texts, match_against):
    "Get the match ratio of how each item in texts compared to match_against"

    # now time to figre out the matching
    ratio_calc = difflib.SequenceMatcher()
    ratio_calc.set_seq1(match_against)

    ratios = {}
    best_ratio = 0
    best_text = ''

    global cache

    for text in texts:

        if 0:
            pass

        if (text, match_against) in _cache:
            ratios[text] = _cache[(text, match_against)]

        elif(match_against, text) in _cache:
            ratios[text] = _cache[(match_against, text)]

        else:
            # set up the SequenceMatcher with other text
            ratio_calc.set_seq2(text)

            # try using the levenshtein distance instead
            #lev_dist = levenshtein_distance(unicode(match_against), unicode(text))
            #ratio = 1 - lev_dist / 10.0
            #ratios[text] = ratio

            # calculate ratio and store it
            ratios[text] = ratio_calc.ratio()

            _cache[(match_against, text)] = ratios[text]

        # if this is the best so far then update best stats
        if ratios[text] > best_ratio:
            best_ratio = ratios[text]
            best_text = text

    return ratios, best_ratio, best_text




#====================================================================
def find_best_match(search_text, item_texts, items, limit_ratio = .5):
    """Return the item that best matches the search_text

    * **search_text** The text to search for
    * **item_texts** The list of texts to search through
    * **items** The list of items corresponding (1 to 1)
      to the list of texts to search through.
    * **limit_ratio** How well the text has to match the best match.
      If the best match matches lower then this then it is not
      considered a match and a MatchError is raised, (default = .5)
    """
    search_text = _cut_at_tab(search_text)

    text_item_map = UniqueDict()
    # Clean each item, make it unique and map to
    # to the item index
    for text, item in zip(item_texts, items):
        text_item_map[_cut_at_tab(text)] = item

    ratios, best_ratio, best_text = \
        _get_match_ratios(list(text_item_map.keys()), search_text)

    if best_ratio < limit_ratio:
        raise MatchError(items = list(text_item_map.keys()), tofind = search_text)

    return text_item_map[best_text]





#====================================================================
_after_tab = re.compile(r"\t.*", re.UNICODE)
_non_word_chars = re.compile(r"\W", re.UNICODE)

def _cut_at_tab(text):
    "Clean out non characters from the string and return it"

    # remove anything after the first tab
    return  _after_tab.sub("", text)

def _clean_non_chars(text):
    "Remove non word characters"
    # should this also remove everything after the first tab?

    # remove non alphanumeric characters
    return _non_word_chars.sub("", text)


def IsAboveOrToLeft(ref_control, other_ctrl):
    "Return true if the other_ctrl is above or to the left of ref_control"
    text_r = other_ctrl.Rectangle()
    ctrl_r = ref_control.Rectangle()

    # skip controls where text win is to the right of ctrl
    if text_r.left >= ctrl_r.right:
        return False

    # skip controls where text win is below ctrl
    if text_r.top >= ctrl_r.bottom:
        return False
        
    # text control top left corner is below control
    # top left corner - so not to the above or left :)
    if text_r.top >= ctrl_r.top and text_r.left >= ctrl_r.left:
        return False

    return True


#====================================================================
distance_cuttoff = 999
def GetNonTextControlName(ctrl, controls):
    """return the name for this control by finding the closest
    text control above and to its left"""

    names = []

    ctrl_index = controls.index(ctrl)

    if ctrl_index != 0:
        prev_ctrl = controls[ctrl_index-1]

        if prev_ctrl.FriendlyClassName() == "Static" and \
            prev_ctrl.IsVisible() and prev_ctrl.WindowText() and \
            IsAboveOrToLeft(ctrl, prev_ctrl):

            names.append(
                prev_ctrl.WindowText() +
                    ctrl.FriendlyClassName())

    # get the visible text controls so that we can get
    # the closest text if the control has no text
    text_ctrls = [ctrl_ for ctrl_ in controls
        if ctrl_.IsVisible() and ctrl_.WindowText() and ctrl_.can_be_label]

    best_name = ''
    closest = distance_cuttoff
    # now for each of the visible text controls
    for text_ctrl in text_ctrls:

        # get aliases to the control rectangles
        text_r = text_ctrl.Rectangle()
        ctrl_r = ctrl.Rectangle()

        # skip controls where text win is to the right of ctrl
        if text_r.left >= ctrl_r.right:
            continue

        # skip controls where text win is below ctrl
        if text_r.top >= ctrl_r.bottom:
            continue

        # calculate the distance between the controls
        # at first I just calculated the distance from the top let
        # corner of one control to the top left corner of the other control
        # but this was not best, so as a text control should either be above
        # or to the left of the control I get the distance between
        # the top left of the non text control against the
        #    Top-Right of the text control (text control to the left)
        #    Bottom-Left of the text control (text control above)
        # then I get the min of these two


        # We do not actually need to calculate the difference here as we
        # only need a comparative number. As long as we find the closest one
        # the actual distance is not all that important to us.
        # this reduced the unit tests run on my by about 1 second
        # (from 61 ->60 s)

        # (x^2 + y^2)^.5
        #distance = (
        #    (text_r.left - ctrl_r.left) ** 2 +  #  (x^2 + y^2)
        #    (text_r.bottom - ctrl_r.top) ** 2) \
        #    ** .5  # ^.5

        #distance2 = (
        #    (text_r.right - ctrl_r.left) ** 2 +  #  (x^2 + y^2)
        #    (text_r.top - ctrl_r.top) ** 2) \
        #    ** .5  # ^.5

        distance = abs(text_r.left - ctrl_r.left) + abs(text_r.bottom - ctrl_r.top)
        distance2 = abs(text_r.right - ctrl_r.left) + abs(text_r.top - ctrl_r.top)

        distance = min(distance, distance2)

        # if this distance was closer then the last one
        if distance < closest:
            closest = distance
            best_name = text_ctrl.WindowText() + ctrl.FriendlyClassName()

    names.append(best_name)

    return names


#====================================================================
def get_control_names(control, allcontrols):
    "Returns a list of names for this control"
    names = []

    # if it has a reference control - then use that
    #if hasattr(control, 'ref') and control.ref:
    #    control = control.ref

    # Add the control based on it's friendly class name
    names.append(control.FriendlyClassName())

    # if it has some character text then add it base on that
    # and based on that with friendly class name appended
    cleaned = control.WindowText()
    # Todo - I don't like the hardcoded classnames here!
    if cleaned and control.has_title:
        names.append(cleaned)
        names.append(cleaned + control.FriendlyClassName())

    # it didn't have visible text
    else:
        # so find the text of the nearest text visible control
        non_text_names = GetNonTextControlName(control, allcontrols)
        
        # and if one was found - add it
        if non_text_names:
            names.extend(non_text_names)

    # return the names - and make sure there are no duplicates
    return set(names)


#====================================================================
class UniqueDict(dict):
    "A dictionary subclass that handles making it's keys unique"
    def __setitem__(self, text, item):
        "Set an item of the dictionary"

        # this text is already in the map
        # so we need to make it unique
        if text in self:
            # find next unique text after text1
            unique_text = text
            counter = 2
            while unique_text in self:
                unique_text = text + str(counter)
                counter += 1

            # now we also need to make sure the original item
            # is under text0 and text1 also!
            if text + '0' not in self:
                dict.__setitem__(self, text+'0', self[text])
                dict.__setitem__(self, text+'1', self[text])

            # now that we don't need original 'text' anymore
            # replace it with the uniq text
            text = unique_text

        # add our current item
        dict.__setitem__(self, text, item)


    def FindBestMatches(
        self,
        search_text,
        clean = False,
        ignore_case = False):

        """Return the best matches for search_text in the items

        * **search_text** the text to look for
        * **clean** whether to clean non text characters out of the strings
        * **ignore_case** compare strings case insensitively
        """

        # now time to figure out the matching
        ratio_calc = difflib.SequenceMatcher()

        if ignore_case:
            search_text = search_text.lower()

        ratio_calc.set_seq1(search_text)

        ratios = {}
        best_ratio = 0
        best_texts = []

        ratio_offset = 1
        if clean:
            ratio_offset *= .9

        if ignore_case:
            ratio_offset *= .9

        for text_ in self:

            # make a copy of the text as we need the original later
            text = text_

            if clean:
                text = _clean_non_chars(text)

            if ignore_case:
                text = text.lower()

            # check if this item is in the cache - if yes, then retrieve it
            if (text, search_text) in _cache:
                ratios[text_] = _cache[(text, search_text)]

            elif(search_text, text) in _cache:
                ratios[text_] = _cache[(search_text, text)]

            # not in the cache - calculate it and add it to the cache
            else:
                # set up the SequenceMatcher with other text
                ratio_calc.set_seq2(text)

                # if a very quick check reveals that this is not going
                # to match then
                ratio = ratio_calc.real_quick_ratio() * ratio_offset

                if ratio  >=  find_best_control_match_cutoff:
                    ratio = ratio_calc.quick_ratio() * ratio_offset

                    if ratio >= find_best_control_match_cutoff:
                        ratio = ratio_calc.ratio() * ratio_offset

                # save the match we got and store it in the cache
                ratios[text_] = ratio
                _cache[(text, search_text)] = ratio

            # try using the levenshtein distance instead
            #lev_dist = levenshtein_distance(unicode(search_text), unicode(text))
            #ratio = 1 - lev_dist / 10.0
            #ratios[text_] = ratio
            #print "%5s" %("%0.2f"% ratio), search_text, `text`

            # if this is the best so far then update best stats
            if ratios[text_] > best_ratio and \
                ratios[text_] >= find_best_control_match_cutoff:

                best_ratio = ratios[text_]
                best_texts = [text_]

            elif ratios[text_] == best_ratio:
                best_texts.append(text_)

        #best_ratio *= ratio_offset

        return best_ratio, best_texts


#====================================================================
def build_unique_dict(controls):
    """Build the disambiguated list of controls

    Separated out to a different function so that we can get
    the control identifiers for printing.
    """
    name_control_map = UniqueDict()


    # collect all the possible names for all controls
    # and build a list of them
    for ctrl in controls:
        ctrl_names = get_control_names(ctrl, controls)

        # for each of the names
        for name in ctrl_names:
            name_control_map[name] = ctrl
    return name_control_map


#====================================================================
def find_best_control_matches(search_text, controls):
    """Returns the control that is the the best match to search_text

    This is slightly differnt from find_best_match in that it builds
    up the list of text items to search through using information
    from each control. So for example for there is an OK, Button
    then the following are all added to the search list:
    "OK", "Button", "OKButton"

    But if there is a ListView (which do not have visible 'text')
    then it will just add "ListView".
    """

    name_control_map = build_unique_dict(controls)


#    # collect all the possible names for all controls
#    # and build a list of them
#    for ctrl in controls:
#        ctrl_names = get_control_names(ctrl, controls)
#
#        # for each of the names
#        for name in ctrl_names:
#            name_control_map[name] = ctrl

    search_text = str(search_text)

    best_ratio, best_texts = name_control_map.FindBestMatches(search_text)

    best_ratio_ci, best_texts_ci = \
        name_control_map.FindBestMatches(search_text, ignore_case = True)

    best_ratio_clean, best_texts_clean = \
        name_control_map.FindBestMatches(search_text, clean = True)

    best_ratio_clean_ci, best_texts_clean_ci = \
        name_control_map.FindBestMatches(
            search_text, clean = True, ignore_case = True)


    if best_ratio_ci > best_ratio:
        best_ratio = best_ratio_ci
        best_texts = best_texts_ci

    if best_ratio_clean > best_ratio:
        best_ratio = best_ratio_clean
        best_texts = best_texts_clean

    if best_ratio_clean_ci > best_ratio:
        best_ratio = best_ratio_clean_ci
        best_texts = best_texts_clean_ci

    if best_ratio < find_best_control_match_cutoff:
        raise MatchError(items = list(name_control_map.keys()), tofind = search_text)

    return [name_control_map[best_text] for best_text in best_texts]






#
#def GetControlMatchRatio(text, ctrl):
#    # get the texts for the control
#    ctrl_names = get_control_names(ctrl)
#
#    #get the best match for these
#    matcher = UniqueDict()
#    for name in ctrl_names:
#        matcher[name] = ctrl
#
#    best_ratio, unused = matcher.FindBestMatches(text)
#
#    return best_ratio
#
#
#
#def get_controls_ratios(search_text, controls):
#    name_control_map = UniqueDict()
#
#    # collect all the possible names for all controls
#    # and build a list of them
#    for ctrl in controls:
#        ctrl_names = get_control_names(ctrl)
#
#        # for each of the names
#        for name in ctrl_names:
#            name_control_map[name] = ctrl
#
#    match_ratios, best_ratio, best_text = \
#        _get_match_ratios(name_control_map.keys(), search_text)
#
#    return match_ratios, best_ratio, best_text,

########NEW FILE########
__FILENAME__ = findwindows
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Provides functions for iterating and finding windows

"""

__revision__ = "$Revision: 689 $"

import re

import ctypes

from . import win32functions
from . import win32structures
from . import handleprops

from . import findbestmatch

from . import controls


# todo: we should filter out invalid windows before returning

#=========================================================================
class WindowNotFoundError(Exception):
    "No window could be found"
    pass

#=========================================================================
class WindowAmbiguousError(Exception):
    "There was more then one window that matched"
    pass



#=========================================================================
def find_window(**kwargs):
    """Call findwindows and ensure that only one window is returned

    Calls find_windows with exactly the same arguments as it is called with
    so please see find_windows for a description of them."""
    windows = find_windows(**kwargs)

    if not windows:
        raise WindowNotFoundError()

    if len(windows) > 1:
        #for w in windows:
        #    print "ambig", handleprops.classname(w), \
        #    handleprops.text(w), handleprops.processid(w)
        exception =  WindowAmbiguousError(
            "There are %d windows that match the criteria %s"% (
            len(windows),
            str(kwargs),
            )
        )

        exception.windows = windows
        raise exception

    return windows[0]

#=========================================================================
def find_windows(class_name = None,
                class_name_re = None,
                parent = None,
                process = None,
                title = None,
                title_re = None,
                top_level_only = True,
                visible_only = True,
                enabled_only = False,
                best_match = None,
                handle = None,
                ctrl_index = None,
                predicate_func = None,
                active_only = False,
                control_id = None,
    ):
    """Find windows based on criteria passed in

    Possible values are:

    * **class_name**  Windows with this window class
    * **class_name_re**  Windows whose class match this regular expression
    * **parent**    Windows that are children of this
    * **process**   Windows running in this process
    * **title**     Windows with this Text
    * **title_re**  Windows whose Text match this regular expression
    * **top_level_only** Top level windows only (default=True)
    * **visible_only**   Visible windows only (default=True)
    * **enabled_only**   Enabled windows only (default=True)
    * **best_match**  Windows with a title similar to this
    * **handle**      The handle of the window to return
    * **ctrl_index**  The index of the child window to return
    * **active_only**  Active windows only (default=False)
    * **control_id**  Windows with this control id
   """

    # allow a handle to be passed in
    # if it is present - just return it
    if handle is not None:
        return [handle, ]

    if top_level_only:
        # find the top level windows
        windows = enum_windows()

        # if we have been given a parent
        if parent:
            windows = [win for win in windows
                if handleprops.parent(win) == parent]

    # looking for child windows
    else:
        # if not given a parent look for all children of the desktop
        if not parent:
            parent = win32functions.GetDesktopWindow()

        # look for all children of that parent
        windows = enum_child_windows(parent)

        # if the ctrl_index has been specified then just return
        # that control
        if ctrl_index is not None:
            return [windows[ctrl_index]]

    if control_id is not None and windows:
        windows = [win for win in windows if
            handleprops.controlid(win) == control_id]
            
    if active_only:
        gui_info = win32structures.GUITHREADINFO()
        gui_info.cbSize = ctypes.sizeof(gui_info)

        # get all the active windows (not just the specified process)
        ret = win32functions.GetGUIThreadInfo(0, ctypes.byref(gui_info))

        if not ret:
            raise ctypes.WinError()

        if gui_info.hwndActive in windows:
            windows = [gui_info.hwndActive]
        else:
            windows = []

    if class_name is not None and windows:
        windows = [win for win in windows
            if class_name == handleprops.classname(win)]

    if class_name_re is not None and windows:
        class_name_regex = re.compile(class_name_re)
        windows = [win for win in windows
            if class_name_regex.match(handleprops.classname(win))]

    if process is not None and windows:
        windows = [win for win in windows
            if handleprops.processid(win) == process]

    if title is not None and windows:
        windows = [win for win in windows
            if title == handleprops.text(win)]

    elif title_re is not None and windows:
        title_regex = re.compile(title_re)
        windows = [win for win in windows
            if title_regex.match(handleprops.text(win))]

    if visible_only and windows:
        windows = [win for win in windows if handleprops.isvisible(win)]

    if enabled_only and windows:
        windows = [win for win in windows if handleprops.isenabled(win)]

    if best_match is not None and windows:
        wrapped_wins = []
        
        for win in windows:
            try:
                wrapped_wins.append(controls.WrapHandle(win))
            except controls.InvalidWindowHandle:
                # skip invalid handles - they have dissapeared 
                # since the list of windows was retrieved
                pass
        windows = findbestmatch.find_best_control_matches(
            best_match, wrapped_wins)
        
        # convert window back to handle
        windows = [win.handle for win in windows]

    if predicate_func is not None and windows:
        windows = [win for win in windows if predicate_func(win)]

    return windows

#=========================================================================
def enum_windows():
    "Return a list of handles of all the top level windows"
    windows = []

    # The callback function that will be called for each HWND
    # all we do is append the wrapped handle
    def EnumWindowProc(hwnd, lparam):
        "Called for each window - adds handles to a list"
        windows.append(hwnd)
        return True

    # define the type of the child procedure
    enum_win_proc = ctypes.WINFUNCTYPE(
        ctypes.c_int, ctypes.c_long, ctypes.c_long)

    # 'construct' the callback with our function
    proc = enum_win_proc(EnumWindowProc)

    # loop over all the children (callback called for each)
    win32functions.EnumWindows(proc, 0)

    # return the collected wrapped windows
    return windows


#=========================================================================
def enum_child_windows(handle):
    "Return a list of handles of the child windows of this handle"

    # this will be filled in the callback function
    child_windows = []

    # callback function for EnumChildWindows
    def EnumChildProc(hwnd, lparam):
        "Called for each child - adds child hwnd to list"

        # append it to our list
        child_windows.append(hwnd)

        # return true to keep going
        return True

    # define the child proc type
    enum_child_proc = ctypes.WINFUNCTYPE(
        ctypes.c_int, 			# return type
        win32structures.HWND, 	# the window handle
        win32structures.LPARAM)	# extra information

    # update the proc to the correct type
    proc = enum_child_proc(EnumChildProc)

    # loop over all the children (callback called for each)
    win32functions.EnumChildWindows(handle, proc, 0)

    return child_windows


########NEW FILE########
__FILENAME__ = fuzzydict
"""Match items in a dictionary using fuzzy matching

Implemented for pywinauto.

This class uses difflib to match strings.
This class uses a linear search to find the items as it HAS to iterate over
every item in the dictionary (otherwise it would not be possible to know which
is the 'best' match).

If the exact item is in the dictionary (no fuzzy matching needed - then it
doesn't do the linear search and speed should be similar to standard Python
dictionaries.

>>> fuzzywuzzy = FuzzyDict({"hello" : "World", "Hiya" : 2, "Here you are" : 3})
>>> fuzzywuzzy['Me again'] = [1,2,3]
>>>
>>> fuzzywuzzy['Hi']
2
>>>
>>>
>>> # next one doesn't match well enough - so a key error is raised
...
>>> fuzzywuzzy['There']
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "pywinauto\fuzzydict.py", line 125, in __getitem__
    raise KeyError(
KeyError: "'There'. closest match: 'hello' with ratio 0.400"
>>>
>>> fuzzywuzzy['you are']
3
>>> fuzzywuzzy['again']
[1, 2, 3]
>>>
"""

__revision__ = "$Rev$"

import difflib

class FuzzyDict(dict):
    "Provides a dictionary that performs fuzzy lookup"
    def __init__(self, items = None, cutoff = .6):
        """Construct a new FuzzyDict instance

        items is an dictionary to copy items from (optional)
        cutoff is the match ratio below which mathes should not be considered
        cutoff needs to be a float between 0 and 1 (where zero is no match
        and 1 is a perfect match)"""
        super(FuzzyDict, self).__init__()

        if items:
            self.update(items)
        self.cutoff =  cutoff

        # short wrapper around some super (dict) methods
        self._dict_contains = lambda key: \
            super(FuzzyDict,self).__contains__(key)

        self._dict_getitem = lambda key: \
            super(FuzzyDict,self).__getitem__(key)

    def _search(self, lookfor, stop_on_first = False):
        """Returns the value whose key best matches lookfor

        if stop_on_first is True then the method returns as soon
        as it finds the first item
        """

        # if the item is in the dictionary then just return it
        if self._dict_contains(lookfor):
            return True, lookfor, self._dict_getitem(lookfor), 1

        # set up the fuzzy matching tool
        ratio_calc = difflib.SequenceMatcher()
        ratio_calc.set_seq1(lookfor)

        # test each key in the dictionary
        best_ratio = 0
        best_match = None
        best_key = None
        for key in self:

            # if the current key is not a string
            # then we just skip it
            try:
                # set up the SequenceMatcher with other text
                ratio_calc.set_seq2(key)
            except TypeError:
                continue

            # we get an error here if the item to look for is not a
            # string - if it cannot be fuzzy matched and we are here
            # this it is defintely not in the dictionary
            try:
            # calculate the match value
                ratio = ratio_calc.ratio()
            except TypeError:
                break

            # if this is the best ratio so far - save it and the value
            if ratio > best_ratio:
                best_ratio = ratio
                best_key = key
                best_match = self._dict_getitem(key)

            if stop_on_first and ratio >= self.cutoff:
                break

        return (
            best_ratio >= self.cutoff,
            best_key,
            best_match,
            best_ratio)


    def __contains__(self, item):
        "Overides Dictionary __contains__ to use fuzzy matching"
        if self._search(item, True)[0]:
            return True
        else:
            return False

    def __getitem__(self, lookfor):
        "Overides Dictionary __getitem__ to use fuzzy matching"
        matched, key, item, ratio = self._search(lookfor)

        if not matched:
            raise KeyError(
                "'%s'. closest match: '%s' with ratio %.3f"%
                    (str(lookfor), str(key), ratio))

        return item



if __name__ == '__main__':
    import unittest

    class FuzzyTestCase(unittest.TestCase):
        "Perform some tests"
        test_dict = {
            'Hiya'  : 1,
            'hiy\xe4' : 2,
            'test3' : 3,
            1: 324}


        def testCreation_Empty(self):
            "Verify that not specifying any values creates an empty dictionary"
            fd = FuzzyDict()

            self.assertEquals(fd, {})

        def testCreation_Dict(self):
            "Test creating a fuzzy dict"
            fd = FuzzyDict(self.test_dict)
            self.assertEquals(fd, self.test_dict)
            self.assertEquals(self.test_dict['Hiya'], fd['hiya'])

            fd2 = FuzzyDict(self.test_dict, cutoff = .8)
            self.assertEquals(fd, self.test_dict)
            self.assertRaises(KeyError, fd2.__getitem__, 'hiya')


        def testContains(self):
            "Test checking if an item is in a FuzzyDict"
            fd = FuzzyDict(self.test_dict)

            self.assertEquals(True, fd.__contains__('hiya'))

            self.assertEquals(True, fd.__contains__('test3'))

            self.assertEquals(True, fd.__contains__('hiy\xe4'))

            self.assertEquals(False, fd.__contains__('FuzzyWuzzy'))

            self.assertEquals(True, fd.__contains__(1))

            self.assertEquals(False, fd.__contains__(23))


        def testGetItem(self):
            "Test getting items from a FuzzyDict"
            fd = FuzzyDict(self.test_dict)

            self.assertEquals(self.test_dict["Hiya"], fd['hiya'])
            self.assertRaises(KeyError, fd.__getitem__, 'FuzzyWuzzy')

            fd2 = FuzzyDict(self.test_dict, cutoff = .14)

            self.assertEquals(1, fd2['FuzzyWuzzy'])
            self.assertEquals(324, fd2[1])
            self.assertRaises(KeyError, fd2.__getitem__, 23)

    unittest.main()
########NEW FILE########
__FILENAME__ = handleprops
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Functions to retrieve properties from a window handle

These are implemented in a procedural way so as to to be
useful to other modules with the least conceptual overhead
"""

__revision__ = "$Revision: 727 $"

import ctypes

from . import win32functions
from . import win32defines
from . import win32structures

# from . import findwindows # for children


#=========================================================================
def text(handle):
    "Return the text of the window"
    length = win32functions.GetWindowTextLength(handle)
    buff = ctypes.create_unicode_buffer(length + 1)
    win32functions.GetWindowText(handle, buff, length + 1)
    return buff.value

#=========================================================================
def classname(handle):
    "Return the class name of the window"
    class_name = (ctypes.c_wchar * 257)()
    win32functions.GetClassName (handle, ctypes.byref(class_name), 256)
    return class_name.value


#=========================================================================
def parent(handle):
    "Return the handle of the parent of the window"
    return win32functions.GetParent(handle)

#=========================================================================
def style(handle):
    "Return the style of the window"
    return win32functions.GetWindowLong (handle, win32defines.GWL_STYLE)

#=========================================================================
def exstyle(handle):
    "Return the extended style of the window"
    return win32functions.GetWindowLong (handle, win32defines.GWL_EXSTYLE)

#=========================================================================
def controlid(handle):
    "Return the ID of the control"
    return win32functions.GetWindowLong (handle, win32defines.GWL_ID)

#=========================================================================
def userdata(handle):
    "Return the value of any userdata associated with the window"
    return win32functions.GetWindowLong (handle, win32defines.GWL_USERDATA)

#=========================================================================
def contexthelpid(handle):
    "Return the context help id of the window"
    return win32functions.GetWindowContextHelpId (handle)

#=========================================================================
def iswindow(handle):
    "Return True if the handle is a window"
    return bool(win32functions.IsWindow(handle))

#=========================================================================
def isvisible(handle):
    "Return True if the window is visible"
    return bool(win32functions.IsWindowVisible(handle))

#=========================================================================
def isunicode(handle):
    "Teturn True if the window is a unicode window"
    return bool(win32functions.IsWindowUnicode(handle))

#=========================================================================
def isenabled(handle):
    "Return True if the window is enabled"
    return bool(win32functions.IsWindowEnabled(handle))

#=========================================================================
def clientrect(handle):
    "Return the client rectangle of the control"
    client_rect = win32structures.RECT()
    win32functions.GetClientRect(handle, ctypes.byref(client_rect))
    return client_rect

#=========================================================================
def rectangle(handle):
    "Return the rectangle of the window"
    rect = win32structures.RECT()
    win32functions.GetWindowRect(handle, ctypes.byref(rect))
    return rect

#=========================================================================
def font(handle):
    "Return the font as a LOGFONTW of the window"

    # get the font handle
    font_handle = win32functions.SendMessage(
        handle, win32defines.WM_GETFONT, 0, 0)

    # if the fondUsed is 0 then the control is using the
    # system font (well probably not - even though that is what the docs say)
    # instead we switch to the default GUI font - which is more likely correct.
    if not font_handle:

        # So just get the default system font
        font_handle = win32functions.GetStockObject(win32defines.DEFAULT_GUI_FONT)

        # if we still don't have a font!
        # ----- ie, we're on an antiquated OS, like NT 3.51
        if not font_handle:

            # ----- On Asian platforms, ANSI font won't show.
            if win32functions.GetSystemMetrics(win32defines.SM_DBCSENABLED):
                # ----- was...(SYSTEM_FONT)
                font_handle = win32functions.GetStockObject(
                    win32defines.SYSTEM_FONT)
            else:
                # ----- was...(SYSTEM_FONT)
                font_handle = win32functions.GetStockObject(
                    win32defines.ANSI_VAR_FONT)

    else:
        fontval = win32structures.LOGFONTW()
        ret = win32functions.GetObject(
	    font_handle, ctypes.sizeof(fontval), ctypes.byref(fontval))

    # Get the Logfont structure of the font of the control
    fontval = win32structures.LOGFONTW()
    ret = win32functions.GetObject(
        font_handle, ctypes.sizeof(fontval), ctypes.byref(fontval))

    # The function could not get the font - this is probably
    # because the control does not have associated Font/Text
    # So we should make sure the elements of the font are zeroed.
    if not ret:
        fontval = win32structures.LOGFONTW()

    # if it is a main window
    if is_toplevel_window(handle):

        if "MS Shell Dlg" in fontval.lfFaceName or \
            fontval.lfFaceName == "System":
            # these are not usually the fonts actaully used in for
            # title bars so we need to get the default title bar font

            # get the title font based on the system metrics rather
            # than the font of the control itself
            ncms = win32structures.NONCLIENTMETRICSW()
            ncms.cbSize = ctypes.sizeof(ncms)
            win32functions.SystemParametersInfo(
                win32defines.SPI_GETNONCLIENTMETRICS,
                ctypes.sizeof(ncms),
                ctypes.byref(ncms),
                0)

            # with either of the following 2 flags set the font of the
            # dialog isthe small one (but there is normally no difference!
            if has_style(handle, win32defines.WS_EX_TOOLWINDOW) or \
               has_style(handle, win32defines.WS_EX_PALETTEWINDOW):

                fontval = ncms.lfSmCaptionFont
            else:
                fontval = ncms.lfCaptionFont

    return fontval

#=========================================================================
def processid(handle):
    "Retrun the ID of process that controls this window"
    process_id = ctypes.c_int()
    win32functions.GetWindowThreadProcessId(handle, ctypes.byref(process_id))

    return process_id.value

#=========================================================================
def children(handle):
    "Return a list of handles to the children of this window"
    return findwindows.enum_child_windows(handle)


#=========================================================================
def has_style(handle, tocheck):
    "Return True if the control has style tocheck"
    hwnd_style = style(handle)
    return tocheck & hwnd_style == tocheck

#=========================================================================
def has_exstyle(handle, tocheck):
    "Return True if the control has extended style tocheck"
    hwnd_exstyle = exstyle(handle)
    return tocheck & hwnd_exstyle == tocheck


#=========================================================================
def is_toplevel_window(handle):
    "Return whether the window is a top level window or not"

    # only request the style once - this is an optimization over calling
    # (handle, style) for each style I wan to check!
    style_ = style(handle)

    if (style_ & win32defines.WS_OVERLAPPED == win32defines.WS_OVERLAPPED or \
        style_ & win32defines.WS_CAPTION == win32defines.WS_CAPTION) and \
        not (style_ & win32defines.WS_CHILD == win32defines.WS_CHILD):
        return True
    else:
        return False


#=========================================================================
#def get_button_friendlyclassname(handle):
#    "Return the friendly class name of a button control"
#
#    # get the least significant bit
#    style_lsb = style(handle) & 0xF
#
#    # default to "Button"
#    f_classname = "Button"
#
#    if style_lsb == win32defines.BS_3STATE or \
#        style_lsb == win32defines.BS_AUTO3STATE or \
#        style_lsb == win32defines.BS_AUTOCHECKBOX or \
#        style_lsb == win32defines.BS_CHECKBOX:
#        f_classname = "CheckBox"
#
#    elif style_lsb == win32defines.BS_RADIOBUTTON or \
#        style_lsb == win32defines.BS_AUTORADIOBUTTON:
#        f_classname = "RadioButton"
#
#    elif style_lsb == win32defines.BS_GROUPBOX:
#        f_classname = "GroupBox"
#
#    if style(handle) & win32defines.BS_PUSHLIKE:
#        f_classname = "Button"
#
#    return f_classname


#def friendlyclassname(handle):
#    """Return the friendly class name of the window
#
#    The friendly class name might be subjective, but it
#    tries to be what a normal user would call a window
#    rather then the windows class name for the window.
#    """
#
#    import warnings
#    warnings.warn("handleprops.friendlyclassname() is deprecated. Please use"
#        "FriendlyClassMethod() of HwndWrapper",
#        DeprecationWarning)
#
#    # if it's a dialog then return that
#    if is_toplevel_window(handle) and classname(handle) == "#32770":
#        return "Dialog"
#
#    # otherwise ask the wrapper class for the friendly class name
#    class_name = classname(handle)
#
#    from controls import wraphandle
#    info = wraphandle._find_wrapper(class_name)
#
#    if info:
#       return info.friendlyclassname
#
#    else:
#        return class_name



#
#
#    # Check if the class name is in the known classes
#    for cls_name, f_cls_name in _class_names.items():
#
#        # OK we found it
#        if re.match(cls_name, classname(handle)):
#            # If it is a string then just return it
#            if isinstance(f_cls_name, basestring):
#                return f_cls_name
#            # otherwise it is a function so call it
#            else:
#                return f_cls_name(handle)
#
#    # unknown class - just return it's classname
#    return classname(handle)





#=========================================================================
def dumpwindow(handle):
    "Dump a window to a set of properties"
    props = {}

    for func in (
        text,
        classname,
        rectangle,
        clientrect,
        style,
        exstyle,
        contexthelpid,
        controlid,
        userdata,
        font,
        parent,
        processid,
        isenabled,
        isunicode,
        isvisible,
        children,
        ):

        props[func.__name__] = func(handle)

    return props


########NEW FILE########
__FILENAME__ = SendKeysCtypes
# -*- coding: utf-8 -*-
"""
Check that SendInput can work the way we want it to

The tips and tricks at http://www.pinvoke.net/default.aspx/user32.sendinput
is useful!

"""
import time
import ctypes

__all__ = ['KeySequenceError', 'SendKeys']

#pylint: disable-msg=R0903

DEBUG = 0

MapVirtualKey = ctypes.windll.user32.MapVirtualKeyW
SendInput = ctypes.windll.user32.SendInput
VkKeyScan = ctypes.windll.user32.VkKeyScanW
VkKeyScan.restype = ctypes.c_short
VkKeyScan.argtypes = [ctypes.c_wchar]

DWORD = ctypes.c_ulong
LONG = ctypes.c_long
WORD = ctypes.c_ushort


# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4283
class MOUSEINPUT(ctypes.Structure):
    "Needed for complete definition of INPUT structure - not used"
#    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4283
        ('dx', LONG),
        ('dy', LONG),
        ('mouseData', DWORD),
        ('dwFlags', DWORD),
        ('time', DWORD),
        ('dwExtraInfo', ctypes.POINTER(ctypes.c_ulong)),
    ]
#assert ctypes.sizeof(MOUSEINPUT) == 24, ctypes.sizeof(MOUSEINPUT)
#assert ctypes.alignment(MOUSEINPUT) == 2, ctypes.alignment(MOUSEINPUT)


# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4292
class KEYBDINPUT(ctypes.Structure):
    "A particular keyboard event"
 #   _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4292
        ('wVk', WORD),
        ('wScan', WORD),
        ('dwFlags', DWORD),
        ('time', DWORD),
        ('dwExtraInfo', ctypes.POINTER(ctypes.c_ulong)),
    ]
#assert ctypes.sizeof(KEYBDINPUT) == 16, ctypes.sizeof(KEYBDINPUT)
#assert ctypes.alignment(KEYBDINPUT) == 2, ctypes.alignment(KEYBDINPUT)


class HARDWAREINPUT(ctypes.Structure):
    "Needed for complete definition of INPUT structure - not used"
#    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4300
        ('uMsg', DWORD),
        ('wParamL', WORD),
        ('wParamH', WORD),
    ]
#assert ctypes.sizeof(HARDWAREINPUT) == 8, ctypes.sizeof(HARDWAREINPUT)
#assert ctypes.alignment(HARDWAREINPUT) == 2, ctypes.alignment(HARDWAREINPUT)


# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4314
class UNION_INPUT_STRUCTS(ctypes.Union):
    "The C Union type representing a single Event of any type"
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4314
        ('mi', MOUSEINPUT),
        ('ki', KEYBDINPUT),
        ('hi', HARDWAREINPUT),
    ]
#assert ctypes.sizeof(UNION_INPUT_STRUCTS) == 24, \
#    ctypes.sizeof(UNION_INPUT_STRUCTS)
#assert ctypes.alignment(UNION_INPUT_STRUCTS) == 2, \
#    ctypes.alignment(UNION_INPUT_STRUCTS)


# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4310
class INPUT(ctypes.Structure):
    "See: http://msdn.microsoft.com/en-us/library/ms646270%28VS.85%29.aspx"
#    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4310
        ('type', DWORD),
        # Unnamed field renamed to '_'
        ('_', UNION_INPUT_STRUCTS),
    ]
#assert ctypes.sizeof(INPUT) == 28, ctypes.sizeof(INPUT)
#assert ctypes.alignment(INPUT) == 2, ctypes.alignment(INPUT)


INPUT_KEYBOARD = 1
KEYEVENTF_EXTENDEDKEY = 1
KEYEVENTF_KEYUP       = 2
KEYEVENTF_UNICODE     = 4
KEYEVENTF_SCANCODE    = 8
VK_SHIFT        = 16
VK_CONTROL      = 17
VK_MENU         = 18

# 'codes' recognized as {CODE( repeat)?}
CODES = {
    'BACK':     8,
    'BACKSPACE':8,
    'BKSP':     8,
    'BREAK':    3,
    'BS':       8,
    'CAP':      20,
    'CAPSLOCK': 20,
    'DEL':      46,
    'DELETE':   46,
    'DOWN':     40,
    'END':      35,
    'ENTER':    13,
    'ESC':      27,
    'F1':       112,
    'F2':       113,
    'F3':       114,
    'F4':       115,
    'F5':       116,
    'F6':       117,
    'F7':       118,
    'F8':       119,
    'F9':       120,
    'F10':      121,
    'F11':      122,
    'F12':      123,
    'F13':      124,
    'F14':      125,
    'F15':      126,
    'F16':      127,
    'F17':      128,
    'F18':      129,
    'F19':      130,
    'F20':      131,
    'F21':      132,
    'F22':      133,
    'F23':      134,
    'F24':      135,
    'HELP':     47,
    'HOME':     36,
    'INS':      45,
    'INSERT':   45,
    'LEFT':     37,
    'LWIN':     91,
    'NUMLOCK':  144,
    'PGDN':     34,
    'PGUP':     33,
    'PRTSC':    44,
    'RIGHT':    39,
    'RMENU':    165,
    'RWIN':     92,
    'SCROLLLOCK':145,
    'SPACE':     32,
    'TAB':       9,
    'UP':        38,

    'VK_ACCEPT': 30,
    'VK_ADD':    107,
    'VK_APPS':    93,
    'VK_ATTN':    246,
    'VK_BACK':    8,
    'VK_CANCEL':  3,
    'VK_CAPITAL': 20,
    'VK_CLEAR':   12,
    'VK_CONTROL': 17,
    'VK_CONVERT': 28,
    'VK_CRSEL':   247,
    'VK_DECIMAL': 110,
    'VK_DELETE':  46,
    'VK_DIVIDE':  111,
    'VK_DOWN':    40,
    'VK_END':     35,
    'VK_EREOF':   249,
    'VK_ESCAPE':  27,
    'VK_EXECUTE': 43,
    'VK_EXSEL':   248,
    'VK_F1':      112,
    'VK_F2':      113,
    'VK_F3':      114,
    'VK_F4':      115,
    'VK_F5':      116,
    'VK_F6':      117,
    'VK_F7':      118,
    'VK_F8':      119,
    'VK_F9':      120,
    'VK_F10':     121,
    'VK_F11':     122,
    'VK_F12':     123,
    'VK_F13':     124,
    'VK_F14':     125,
    'VK_F15':     126,
    'VK_F16':     127,
    'VK_F17':     128,
    'VK_F18':     129,
    'VK_F19':     130,
    'VK_F20':     131,
    'VK_F21':     132,
    'VK_F22':     133,
    'VK_F23':     134,
    'VK_F24':     135,
    'VK_FINAL':   24,
    'VK_HANGEUL':  21,
    'VK_HANGUL':   21,
    'VK_HANJA':    25,
    'VK_HELP':     47,
    'VK_HOME':     36,
    'VK_INSERT':   45,
    'VK_JUNJA':    23,
    'VK_KANA':     21,
    'VK_KANJI':    25,
    'VK_LBUTTON':   1,
    'VK_LCONTROL':162,
    'VK_LEFT':     37,
    'VK_LMENU':   164,
    'VK_LSHIFT':  160,
    'VK_LWIN':     91,
    'VK_MBUTTON':    4,
    'VK_MENU':        18,
    'VK_MODECHANGE':  31,
    'VK_MULTIPLY':   106,
    'VK_NEXT':        34,
    'VK_NONAME':     252,
    'VK_NONCONVERT':  29,
    'VK_NUMLOCK':    144,
    'VK_NUMPAD0':     96,
    'VK_NUMPAD1':     97,
    'VK_NUMPAD2':     98,
    'VK_NUMPAD3':     99,
    'VK_NUMPAD4':    100,
    'VK_NUMPAD5':    101,
    'VK_NUMPAD6':    102,
    'VK_NUMPAD7':    103,
    'VK_NUMPAD8':    104,
    'VK_NUMPAD9':    105,
    'VK_OEM_CLEAR':  254,
    'VK_PA1':        253,
    'VK_PAUSE':       19,
    'VK_PLAY':       250,
    'VK_PRINT':       42,
    'VK_PRIOR':       33,
    'VK_PROCESSKEY': 229,
    'VK_RBUTTON':      2,
    'VK_RCONTROL':   163,
    'VK_RETURN':      13,
    'VK_RIGHT':       39,
    'VK_RMENU':      165,
    'VK_RSHIFT':     161,
    'VK_RWIN':        92,
    'VK_SCROLL':     145,
    'VK_SELECT':      41,
    'VK_SEPARATOR':  108,
    'VK_SHIFT':       16,
    'VK_SNAPSHOT':    44,
    'VK_SPACE':       32,
    'VK_SUBTRACT':   109,
    'VK_TAB':          9,
    'VK_UP':          38,
    'ZOOM':          251,
}
# reverse the CODES dict to make it easy to look up a particular code name
CODE_NAMES = dict((entry[1], entry[0]) for entry in list(CODES.items()))

# modifier keys
MODIFIERS = {
    '+': VK_SHIFT,
    '^': VK_CONTROL,
    '%': VK_MENU,
}


class KeySequenceError(Exception):
    """Exception raised when a key sequence string has a syntax error"""

    def __str__(self):
        return ' '.join(self.args)


class KeyAction(object):
    """Class that represents a single 'keyboard' action

    It represents either a PAUSE action (not reallly keyboard) or a keyboard
    action (press or release or both) of a particular key.
    """

    def __init__(self, key, down = True, up = True):
        self.key = key
        if isinstance(self.key, str):
            self.key = str(key)
        self.down = down
        self.up = up

    def _get_key_info(self):
        """Return virtual_key, scan_code, and flags for the action
        
        This is one of the methods that will be overridden by sub classes"""
        return 0, ord(self.key), KEYEVENTF_UNICODE

    def GetInput(self):
        "Build the INPUT structure for the action"
        actions = 1
        # if both up and down
        if self.up and self.down:
            actions = 2

        inputs = (INPUT * actions)()

        vk, scan, flags = self._get_key_info()

        for inp in inputs:
            inp.type = INPUT_KEYBOARD

            inp._.ki.wVk = vk
            inp._.ki.wScan = scan
            inp._.ki.dwFlags |= flags

        # if we are releasing - then let it up
        if self.up:
            inputs[-1]._.ki.dwFlags |= KEYEVENTF_KEYUP

        return inputs

    def Run(self):
        "Execute the action"
        inputs = self.GetInput()
        return SendInput(
            len(inputs),
            ctypes.byref(inputs),
            ctypes.sizeof(INPUT))

    def _get_down_up_string(self):
        """Return a string that will show whether the string is up or down
        
        return 'down' if the key is a press only
        return 'up' if the key is up only
        return '' if the key is up & down (as default)
        """
        down_up = ""
        if not (self.down and self.up):
            if self.down:
                down_up = "down"
            elif self.up:
                down_up = "up"
        return down_up
    
    def key_description(self):
        "Return a description of the key"
        vk, scan, flags = self._get_key_info()
        desc = ''
        if vk:
            if vk in CODE_NAMES:
                desc = CODE_NAMES[vk]
            else:
                desc = "VK %d"% vk
        else:
            desc = "%s"% self.key
        
        return desc

    def __str__(self):
        parts = []
        parts.append(self.key_description())
        up_down = self._get_down_up_string()
        if up_down:
            parts.append(up_down)

        return "<%s>"% (" ".join(parts))
    __repr__ = __str__


class VirtualKeyAction(KeyAction):
    """Represents a virtual key action e.g. F9 DOWN, etc

    Overrides necessary methods of KeyAction"""

    def _get_key_info(self):
        "Virtual keys have extended flag set"
        
        # copied more or less verbatim from 
        # http://www.pinvoke.net/default.aspx/user32.sendinput
        if (
            (self.key >= 33 and self.key <= 46) or 
            (self.key >= 91 and self.key <= 93) ):
            flags = KEYEVENTF_EXTENDEDKEY;        
        else:
            flags = 0
        # This works for %{F4} - ALT + F4
        #return self.key, 0, 0

        # this works for Tic Tac Toe i.e. +{RIGHT} SHIFT + RIGHT
        return self.key, MapVirtualKey(self.key, 0), flags


class EscapedKeyAction(KeyAction):
    """Represents an escaped key action e.g. F9 DOWN, etc

    Overrides necessary methods of KeyAction"""

    def _get_key_info(self):
        """EscapedKeyAction doesn't send it as Unicode and the vk and 
        scan code are generated differently"""
        vkey_scan = LoByte(VkKeyScan(self.key))

        return (vkey_scan, MapVirtualKey(vkey_scan, 0), 0)

    def key_description(self):
        "Return a description of the key"
        
        return "KEsc %s"% self.key


class PauseAction(KeyAction):
    "Represents a pause action"

    def __init__(self, how_long):
        self.how_long = how_long

    def Run(self):
        "Pause for the lenght of time specified"
        time.sleep(self.how_long)

    def __str__(self):
        return "<PAUSE %1.2f>"% (self.how_long)
    __repr__ = __str__

    #def GetInput(self):
    #    print `self.key`
    #    keys = KeyAction.GetInput(self)
    #
    #    shift_state = HiByte(VkKeyScan(self.key))
    #
    #    shift_down = shift_state & 0x100  # 1st bit
    #    ctrl_down =  shift_state & 0x80   # 2nd bit
    #    alt_down =  shift_state & 0x40    # 3rd bit
    #
    #    print bin(shift_state), shift_down, ctrl_down, alt_down
    #
    #    print keys
    #    keys = [k for k in keys]
    #
    #    modifiers = []
    #    if shift_down:
    #        keys[0:0] = VirtualKeyAction(VK_SHIFT, up = False).GetInput()
    #        keys.append(VirtualKeyAction(VK_SHIFT, down = False).GetInput())
    #    if ctrl_down:
    #        keys[0:0] = VirtualKeyAction(VK_CONTROL, up = False).GetInput()
    #        keys.append(VirtualKeyAction(VK_CONTROL, down = False).GetInput())
    #    if alt_down:
    #        keys[0:0] = VirtualKeyAction(VK_ALT, up = False).GetInput()
    #        keys.append(VirtualKeyAction(VK_ALT, down = False).GetInput())
    #
    #    print keys
    #    new_keys = (INPUT * len(keys)) ()
    #
    #    for i, k in enumerate(keys):
    #        if hasattr(k, 'type'):
    #            new_keys[i] = k
    #        else:
    #            for sub_key in k:
    #                new_keys[i] = sub_key
    #
    #    return new_keys
    #

def handle_code(code):
    "Handle a key or sequence of keys in braces"

    code_keys = []
    # it is a known code (e.g. {DOWN}, {ENTER}, etc)
    if code in CODES:
        code_keys.append(VirtualKeyAction(CODES[code]))

    # it is an escaped modifier e.g. {%}, {^}, {+}
    elif len(code) == 1:
        code_keys.append(KeyAction(code))

    # it is a repetition or a pause  {DOWN 5}, {PAUSE 1.3}
    elif ' ' in code:
        to_repeat, count = code.rsplit(None, 1)
        if to_repeat == "PAUSE":
            try:
                pause_time = float(count)
            except ValueError:
                raise KeySequenceError('invalid pause time %s'% count)
            code_keys.append(PauseAction(pause_time))

        else:
            try:
                count = int(count)
            except ValueError:
                raise KeySequenceError(
                    'invalid repetition count %s'% count)

            # If the value in to_repeat is a VK e.g. DOWN
            # we need to add the code repeated
            if to_repeat in CODES:
                code_keys.extend(
                    [VirtualKeyAction(CODES[to_repeat])] * count)
            # otherwise parse the keys and we get back a KeyAction
            else:
                to_repeat = parse_keys(to_repeat)
                if isinstance(to_repeat, list):
                    keys = to_repeat * count
                else:
                    keys = [to_repeat] * count
                code_keys.extend(keys)
    else:
        raise RuntimeError("Unknown code: %s"% code)

    return code_keys


def parse_keys(string,
                with_spaces = False,
                with_tabs = False,
                with_newlines = False,
                modifiers = None):
    "Return the parsed keys"

    keys = []
    if not modifiers:
        modifiers = []
    index = 0
    while index < len(string):

        c = string[index]
        index += 1
        # check if one of CTRL, SHIFT, ALT has been pressed
        if c in list(MODIFIERS.keys()):
            modifier = MODIFIERS[c]
            # remember that we are currently modified
            modifiers.append(modifier)
            # hold down the modifier key
            keys.append(VirtualKeyAction(modifier, up = False))
            if DEBUG:
                print(("MODS+", modifiers))
            continue

        # Apply modifiers over a bunch of characters (not just one!)
        elif c == "(":
            # find the end of the bracketed text
            end_pos = string.find(")", index)
            if end_pos == -1:
                raise KeySequenceError('`)` not found')
            keys.extend(
                parse_keys(string[index:end_pos], modifiers = modifiers))
            index = end_pos + 1

        # Escape or named key
        elif c == "{":
            end_pos = string.find("}", index)
            if end_pos == -1:
                raise KeySequenceError('`}` not found')

            code = string[index:end_pos]
            index = end_pos + 1
            keys.extend(handle_code(code))

        # unmatched ")"
        elif c == ')':
            raise KeySequenceError('`)` should be preceeded by `(`')

        # unmatched "}"
        elif c == '}':
            raise KeySequenceError('`}` should be preceeded by `{`')

        # so it is a normal character
        else:
            # don't output white space unless flags to output have been set
            if (c == ' ' and not with_spaces or
                c == '\t' and not with_tabs or
                c == '\n' and not with_newlines):
                continue
            
            # output nuewline
            if c in ('~', '\n'):
                keys.append(VirtualKeyAction(CODES["ENTER"]))

            # safest are the virtual keys - so if our key is a virtual key
            # use a VirtualKeyAction
            #if ord(c) in CODE_NAMES:
            #    keys.append(VirtualKeyAction(ord(c)))
                
            elif modifiers:
                keys.append(EscapedKeyAction(c))
                
            else:
                keys.append(KeyAction(c))

        # as we have handled the text - release the modifiers
        while modifiers:
            if DEBUG:
                print(("MODS-", modifiers))
            keys.append(VirtualKeyAction(modifiers.pop(), down = False))

    # just in case there were any modifiers left pressed - release them
    while modifiers:
        keys.append(VirtualKeyAction(modifiers.pop(), down = False))

    return keys

def LoByte(val):
    "Return the low byte of the value"
    return val & 0xff

def HiByte(val):
    "Return the high byte of the value"
    return (val & 0xff00) >> 8

def SendKeys(keys,
             pause=0.05,
             with_spaces=False,
             with_tabs=False,
             with_newlines=False,
             turn_off_numlock=True):
    "Parse the keys and type them"
    keys = parse_keys(keys, with_spaces, with_tabs, with_newlines)

    for k in keys:
        k.Run()
        time.sleep(pause)


def main():
    "Send some test strings"

    actions = """
        {LWIN}
        {PAUSE .25}
        r
        {PAUSE .25}
        Notepad.exe{ENTER}
        {PAUSE 1}
        Hello{SPACE}World!
        {PAUSE 1}
        %{F4}
        {PAUSE .25}
        n
        """
    SendKeys(actions, pause = .1)
    
    keys = parse_keys(actions)
    for k in keys:
        print(k)
        k.Run()
        time.sleep(.1)

    test_strings = [
        "\n"
        "(aa)some text\n",
        "(a)some{ }text\n",
        "(b)some{{}text\n",
        "(c)some{+}text\n",
        "(d)so%me{ab 4}text",
        "(e)so%me{LEFT 4}text",
        "(f)so%me{ENTER 4}text",
        "(g)so%me{^aa 4}text",
        "(h)some +(asdf)text",
        "(i)some %^+(asdf)text",
        "(j)some %^+a text+",
        "(k)some %^+a tex+{&}",
        "(l)some %^+a tex+(dsf)",
        "",
        ]

    for s in test_strings:
        print((repr(s)))
        keys = parse_keys(s, with_newlines = True)
        print(keys)

        for k in keys:
            k.Run()
            time.sleep(.1)
        print()

if __name__ == "__main__":

    main()

########NEW FILE########
__FILENAME__ = sk_test
import sendkeys
sendkeys.SendKeys("{LWIN}")
########NEW FILE########
__FILENAME__ = taskbar
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Module showing how to work with the task bar

This module will likely change significantly in the future!"""

import warnings

from pywinauto import win32defines
from pywinauto import findwindows
from pywinauto import application

warnings.warn("The taskbar module is still very experimental", FutureWarning)

def TaskBarHandle():
    "Return the first window that has a class name 'Shell_TrayWnd'"
    return findwindows.find_windows(class_name = "Shell_TrayWnd")[0]


def _get_visible_button_index(reqd_button):
    "Get the nth visible icon"
    cur_button = -1
    for i in range(0, SystemTrayIcons.ButtonCount()):
        if not SystemTrayIcons.GetButton(i).fsState & \
            win32defines.TBSTATE_HIDDEN:

            cur_button += 1

        if cur_button == reqd_button:
            return i

def ClickSystemTrayIcon(button):
    "Click on a visible tray icon given by button"
    button = _get_visible_button_index(button)
    r = SystemTrayIcons.GetButtonRect(button)
    SystemTrayIcons.ClickInput(coords = (r.left+2, r.top+2))

def RightClickSystemTrayIcon(button):
    "Right click on a visible tray icon given by button"
    button = _get_visible_button_index(button)
    r = SystemTrayIcons.GetButtonRect(button)
    SystemTrayIcons.RightClickInput(coords = (r.left+2, r.top+2))



# windows explorer owns all these windows so get that app
explorer_app = application.Application().connect_(handle = TaskBarHandle())

# Get the taskbar
TaskBar = explorer_app.window_(handle = TaskBarHandle())

# The Start button
StartButton = TaskBar.Start

# the Quick Launch toolbar
QuickLaunch = TaskBar.QuickLaunch

# the system tray - contains various windows
SystemTray = TaskBar.TrayNotifyWnd

# the clock is in the system tray
Clock = TaskBar.TrayClockWClass

# these are the icons - what people normally think of
# as the system tray
SystemTrayIcons = TaskBar.NoficationArea

# the toolbar with the running applications
RunningApplications = TaskBar.RunningApplicationsToolbar



########NEW FILE########
__FILENAME__ = allcontrols
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Get All Controls Test

**What is checked**
This test does no actual testing  it just returns each control.

**How is it checked**
A loop over all the controls in the dialog is made and each control added to
the list of bugs

**When is a bug reported**
For each control.

**Bug Extra Information**
There is no extra information associated with this bug type

**Is Reference dialog needed**
No,but if available the reference control will be returned with the localised
control.

**False positive bug reports**
Not possible

**Test Identifier**
The identifier for this test/bug is "AllControls"
"""
__revision__ = "$Revision: 189 $"


testname = "AllControls"

#-----------------------------------------------------------------------------
def AllControlsTest(windows):
    "Returns just one bug for each control"

    bugs = []
    for win in windows:
        bugs.append((
            [win,],
            {},
            testname,
            0
        ))


    return bugs


########NEW FILE########
__FILENAME__ = asianhotkey
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Asian Hotkey Format Test

**What is checked**

This test checks whether the format for shortcuts/hotkeys follows the
standards for localised Windows applications. This format is
{localised text}({uppercase hotkey})
so for example if the English control is
"&Help"
the localised control for Asian languages should be
"LocHelp(H)"

**How is it checked**

After checking whether this control displays hotkeys it examines the 1st
string of the control to make sure that the format is correct.
If the reference control is available then it also makes sure that the
hotkey character is the same as the reference.
Controls with a title of less than 4 characters are ignored. This has been
done to avoid false positive bug reports for strings like "&X:".

**When is a bug reported**

A bug is reported when a control has a hotkey and it is not in the correct
format.
Also if the reference control is available a bug will be reported if the
hotkey character is not the same as used in the reference

**Bug Extra Information**

This test produces 2 different types of bug:
BugType: "AsianHotkeyFormat"
There is no extra information associated with this bug type

**BugType: "AsianHotkeyDiffRef"**

There is no extra information associated with this bug type

**Is Reference dialog needed**

The reference dialog is not needed.
If it is unavailable then only bugs of type "AsianHotkeyFormat" will be
reported, bug of type "AsianHotkeyDiffRef" will not be found.

**False positive bug reports**

There should be very few false positive bug reports when testing Asian
software. If a string is very short (eg "&Y:") but is padded with spaces
then it will get reported.

**Test Identifier**

The identifier for this test/bug is "AsianHotkeyTests"
"""

__revision__ = "$Revision: 286 $"


testname = "AsianHotkeyFormat"


import re

from .repeatedhotkey import ImplementsHotkey, GetHotkey


#-----------------------------------------------------------------------------
def AsianHotkeyTest(windows):
    "Return the repeated hotkey errors"

    bugs = []

    for win in windows:
        # skip it if it doesn't implement hotkey functionality
        if not ImplementsHotkey(win):
            continue

        if _IsAsianHotkeyFormatIncorrect(win.WindowText()):

            bugs.append((
                [win,],
                {},
                testname,
                0)
            )

    return bugs


_asianHotkeyRE = re.compile (r"""
    \(&.\)      # the hotkey
    (
        (\t.*)|     # tab, and then anything
        #(\\t.*)|   # escaped tab, and then anything
        (\(.*\)     # anything in brackets
    )|
    \s*|            # any whitespace
    :|              # colon
    (\.\.\.)|       # elipsis
    >|              # greater than sign
    <|              # less than sign
    (\n.*)          # newline, and then anything
    \s)*$""", re.VERBOSE)

#-----------------------------------------------------------------------------
def _IsAsianHotkeyFormatIncorrect(text):
    "Check if the format of the hotkey is correct or not"
    # get the hotkey
    pos, char = GetHotkey(text)

    # if it has a hotkey then check that it is correct Asian format
    if char:
        found = _asianHotkeyRE.search(text)
        if not found:
            return True


    return False


#	if (hotkeyPos - 2  >= 0 &&	// at least 4th character ".(&..."
#        // at most 2nd last character "...(&H)"
#		hotkeyPos + 1 <= title.length()-1 &&
#		title[hotkeyPos-2] == '(' &&
#		title[hotkeyPos+1] == ')' &&
#		hotkeyPos +1 == title.find_last_not_of("\n\t :")
#	   )
#	{
#		// OK So we know now that the format "..(&X).."
#       // is correct and that it is the
#		// last non space character in the title
#		; // SO NO BUG!


AsianHotkeyTest.TestsMenus = True

########NEW FILE########
__FILENAME__ = changedtext
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA


"""Translation Test

**What is checked**
This checks for controls which appear not to be translated.

**How is it checked**
It compares the text of the localised and reference controls.

If there are more than string in the control then each item is searched for in
the US list of titles (so checking is not order dependent).
The indices for the untranslated strings are returned in a comma separated
string.
Also the untranslated strings themselves are returned (all as one string).
These strings are not escaped and are delimited as
"string1","string2",..."stringN".

**When is a bug reported**

 If the text of the localised control is identical to the reference control
 (in case, spacing i.e.  a binary compare) then it will be flagged as
 untranslated. Otherwise the control is treated as translated.

Note: This is the method to return the least number of bugs. If there are
differences in any part of the string (e.g. a path or variable name) but the
rest of the string is untranslated then a bug will not be highlighted

**Bug Extra Information**
The bug contains the following extra information
Name	Description
Strings		The list of the untranslated strings as explained above
StringIndices		The list of indices (0 based) that are untranslated.
This will usually be 0 but if there are many strings in the control
untranslated it will report ALL the strings e.g. 0,2,5,19,23

**Is Reference dialog needed**
The reference dialog is always necessary.

**False positive bug reports**
False positive bugs will be reported in the following cases.
-	The title of the control stays the same as the US because the
translation is the same as the English text(e.g. Name: in German)
-	The title of the control is not displayed (and not translated).
This can sometimes happen if the programmer displays something else on the
control after the dialog is created.

**Test Identifier**
The identifier for this test/bug is "Translation" """

__revision__ = "$Revision: 221 $"

testname = "TextChanged"

import re

#-----------------------------------------------------------------------------
def TextChangedTest(windows):
    "Returns just one bug for each control"

    bugs = []
    for win in windows:
        if not win.ref:
            continue

        # get if any items are untranslated
        changedTitles, changedIndices = _GetTranslations(win)

        if changedTitles:
            indicesAsString = ",".join([str(idx) for idx in changedIndices])

            bugs.append((
                [win,],
                {
                    "StringIndices": indicesAsString,
                    "Strings": ('"%s"' % '","'.join(changedTitles))
                },
                testname,
                0)
            )


    return bugs

def _GetChangedTexts(win):
    "Find the text items that have changed"
 
    changedTitles = []
    changedIndices = []

    # loop over each of the cleaned loc title
    for index, title in enumerate(win.Texts()):

        # if that title is in the cleaned Ref Titles
        if title not in win.ref.Texts():
            # add this as one of the bugs
            changedTitles.append(title)
            changedIndices.append(index)

    # return all the untranslated titles and thier indices
    return changedTitles, changedIndices


TextChangedTest.TestsMenus = True


########NEW FILE########
__FILENAME__ = comboboxdroppedheight
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""ComboBox dropped height Test

**What is checked**
It is ensured that the height of the list displayed when the combobox is
dropped down is not less than the height of the reference.

**How is it checked**
The value for the dropped rectangle can be retrieved from windows. The height
of this rectangle is calculated and compared against the reference height.

**When is a bug reported**
If the height of the dropped rectangle for the combobox being checked is less
than the height of the reference one then a bug is reported.

**Bug Extra Information**
There is no extra information associated with this bug type

**Is Reference dialog needed**
The reference dialog is necessary for this test.

**False positive bug reports**
No false bugs should be reported. If the font of the localised control has a
smaller height than the reference then it is possible that the dropped
rectangle could be of a different size.

**Test Identifier**
The identifier for this test/bug is "ComboBoxDroppedHeight"
"""
__revision__ = "$Revision: 276 $"

testname = "ComboBoxDroppedHeight"

def ComboBoxDroppedHeightTest(windows):
    "Check if each combobox height is the same as the reference"
    bugs = []
    for win in windows:
        if not win.ref:
            continue

        if win.Class() != "ComboBox" or win.ref.Class() != "ComboBox":
            continue

        if win.DroppedRect().height() != win.ref.DroppedRect().height():

            bugs.append((
                [win, ],
                {},
                testname,
                0,)
            )

    return bugs


########NEW FILE########
__FILENAME__ = comparetoreffont
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Compare against reference font test

**What is checked**
This test checks all the parameters of the font for the control against the
font for the reference control. If any value is different then this is reported
as a bug.
Here is a list of all the possible values that are tested:
lfFaceName	The name of the font
lfHeight	The height of the font
lfWidth		Average width of characters
lfEscapement	Angle of text
lfOrientation	Another angle for the text!
lfWeight	How bold the text is
lfItalic	If the font is italic
lfUnderline	If the font is underlined
lfStrikeOut	If the font is struck out
lfCharSet	The character set of the font
lfOutPrecision	The output precision
lfClipPrecision	The clipping precision
lfQuality	The output quality
lfPitchAndFamily	The pitch and family


**How is it checked**
Each property of the font for the control being tested is compared against the
equivalent property of the reference control font for equality.

**When is a bug reported**
For each property of the font that is not identical to the reference font a bug
is reported. So for example if the Font Face has changed and the text is bold
then (at least) 2 bugs will be reported.

**Bug Extra Information**
The bug contains the following extra information
Name	Description
ValueType	What value is incorrect (see above), String
Ref	The reference value converted to a string, String
Loc	The localised value converted to a string, String

**Is Reference dialog needed**
This test will not run if the reference controls are not available.

**False positive bug reports**
Running this test for Asian languages will result in LOTS and LOTS of false
positives, because the font HAS to change for the localised text to display
properly.

**Test Identifier**
The identifier for this test/bug is "CompareToRefFont"
"""

__revision__ = "$Revision: 614 $"

testname = "CompareToRefFont"

from .. import win32structures
_font_attribs = [field[0] for field in win32structures.LOGFONTW._fields_]

def CompareToRefFontTest(windows):
    "Compare the font to the font of the reference control"

    bugs = []
    for win in windows:
        # if no reference then skip the control
        if not win.ref:
            continue

        # find each of the bugs
        for font_attrib in _font_attribs:

            loc_value = getattr(win.Font(), font_attrib)
            # get the reference value
            ref_value = getattr(win.ref.Font(), font_attrib)

            # If they are different
            if loc_value != ref_value:

                # Add the bug information
                bugs.append((
                    [win, ],
                    {
                        "ValueType": font_attrib,
                        "Ref": str(ref_value),
                        "Loc": str(loc_value),
                    },
                    testname,
                    0,)
                )
    return bugs





########NEW FILE########
__FILENAME__ = leadtrailspaces
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Different Leading and Trailing Spaces Test

**What is checked**
Checks that the same space characters (<space>, <tab>, <enter>, <vertical tab>)
are before and after all non space characters in the title of the control when
compared to the reference control.

**How is it checked**
Find the 1st non-space character, and the characters of the title up to that
are the leading spaces.
Find the last non-space character, and the characters of the title after that
are the trailing spaces.
These are then compared to the lead and trail spaces from the reference
control and if they are not exactly the then a bug is reported.

**When is a bug reported**
When either the leading or trailing spaces of the control being tested does
not match the equivalent spaces of the reference control exactly.

**Bug Extra Information**
The bug contains the following extra information

  * **Lead-Trail**  Whether this bug report is for the leading or
    trailing spaces of the control, String

    This will be either:

      - "Leading"  bug relating to leading spaces
      - "Trailing"  bug relating to trailing spaces

  * **Ref**  The leading or trailings spaces of the reference string
    (depending on Lead-Trail value), String
  * **Loc**  The leading or trailings spaces of the local string (depending on
    Lead-Trail value), String

**Is Reference dialog needed**
This test will not run if the reference controls are not available.

**False positive bug reports**
This is usually not a very important test, so if it generates many false
positives then we should consider removing it.

**Test Identifier**
The identifier for this test/bug is "LeadTrailSpaces"
"""
__revision__ = "$Revision: 412 $"


testname = "LeadTrailSpaces"
def LeadTrailSpacesTest(windows):
    "Return the leading/trailing space bugs for the windows"
    bugs = []
    for win in windows:
        if not win.ref:
            continue

        locLeadSpaces = GetLeadSpaces(win.WindowText())
        locTrailSpaces = GetTrailSpaces(win.WindowText())

        refLeadSpaces = GetLeadSpaces(win.ref.WindowText())
        refTrailSpaces = GetTrailSpaces(win.ref.WindowText())

        diffs = []
        if locLeadSpaces != refLeadSpaces:
            diffs.append(("Leading", locLeadSpaces, locTrailSpaces))

        if locTrailSpaces != refTrailSpaces:
            diffs.append(("Trailing", locTrailSpaces, refTrailSpaces))

        for diff, loc, ref in diffs:
            bugs.append((
                [win, ],
                {
                    "Lead-Trail": diff,
                    "Ref": ref,
                    "Loc": loc,
                },
                testname,
                0,)
            )
    return bugs


def GetLeadSpaces(title):
    "Return the leading spaces of the string"
    spaces = ''

    for i in range(0, len(title)):
        if not title[i].isspace():
            break

        spaces += title[i]

    return spaces


def GetTrailSpaces(title):
    "Return the trailing spaces of the string"
    rev = "".join(reversed(title))
    spaces = GetLeadSpaces(rev)
    return "".join(reversed(spaces))


LeadTrailSpacesTest.TestsMenus = True

########NEW FILE########
__FILENAME__ = miscvalues
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Miscellaneous Control properties Test

**What is checked**
This checks various values related to a control in windows. The values tested
are
Class	The class type of the control
Style	The Style of the control (GetWindowLong)
ExStyle	The Extended Style of the control (GetWindowLong)
HelpID	The Help ID of the control (GetWindowLong)
ControlID	The Control ID of the control (GetWindowLong)
UserData	The User Data of the control (GetWindowLong)
Visibility	Whether the control is visible or not

**How is it checked**
After retrieving the information for the control we compare it to the same
information from the reference control.

**When is a bug reported**
If the information does not match then a bug is reported.

**Bug Extra Information**
The bug contains the following extra information
Name	Description
ValueType	What value is incorrect (see above), String
Ref	The reference value converted to a string, String
Loc	The localised value converted to a string, String

**Is Reference dialog needed**
This test will not run if the reference controls are not available.

**False positive bug reports**
Some values can change easily without any bug being caused, for example User
Data is actually meant for programmers to store information for the control
and this can change every time the software is run.

**Test Identifier**
The identifier for this test/bug is "MiscValues"
"""
__revision__ = "$Revision: 616 $"

testname = "MiscValues"

def MiscValuesTest(windows):
    "Return the bugs from checking miscelaneous values of a control"
    bugs = []
    for win in windows:
        if not win.ref:
            continue

        diffs = {}

        if win.Class() != win.ref.Class():
            diffs["Class"] = (win.Class(), win.ref.Class())

        if win.Style() != win.ref.Style():
            diffs["Style"] = (win.Style(), win.ref.Style())

        if win.ExStyle() != win.ref.ExStyle():
            diffs["ExStyle"] = (win.ExStyle(), win.ref.ExStyle())

        if win.ContextHelpID() != win.ref.ContextHelpID():
            diffs["HelpID"] = (win.ContextHelpID(), win.ref.ContextHelpID())

        if win.ControlID() != win.ref.ControlID():
            diffs["ControlID"] = (win.ControlID(), win.ref.ControlID())

        if win.IsVisible() != win.ref.IsVisible():
            diffs["Visibility"] = (win.IsVisible(), win.ref.IsVisible())

        if win.UserData() != win.ref.UserData():
            diffs["UserData"] = (win.UserData(), win.ref.UserData())

        for diff, vals in list(diffs.items()):
            bugs.append((
                [win, ],
                {
                    "ValueType": diff,
                    "Ref": str(vals[1]),
                    "Loc": str(vals[0]),
                },
                testname,
                0,)
            )
    return bugs


########NEW FILE########
__FILENAME__ = missalignmen2t
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Missalignment Test

**What is checked**
This test checks that if a set of controls were aligned on a particular axis
in the reference dialog  that they are all aligned on the same axis.

**How is it checked**
A list of all the reference controls that are aligned is created (ie more than
one control with the same Top, Left, Bottom or Right coordinates). These
controls are then analysed in the localised dialog to make sure that they are
all aligned on the same axis.

**When is a bug reported**
A bug is reported when any of the controls that were aligned in the reference
dialog are no longer aligned in the localised control.

**Bug Extra Information**
The bug contains the following extra information
Name	Description
AlignmentType	This is either LEFT, TOP, RIGHT or BOTTOM. It tells you how
the controls were aligned in the reference dialog. String
AlignmentRect	Gives the smallest rectangle that surrounds ALL the controls
concerned in the bug, Rectangle

**Is Reference dialog needed**
This test cannot be performed without the reference control. It is required
to see which controls should be aligned.

**False positive bug reports**
It is quite possible that this test reports false positives:
1.	Where the controls only just happen to be aligned in the reference dialog
(by coincidence)
2.	Where the control does not have a clear boundary (for example static
labels or checkboxes)  they may be miss-aligned but it is not noticeable that
they are not.


**Test Identifier**
The identifier for this test/bug is "Missalignment" """

__revision__ = "$Revision: 221 $"

testname = "Missalignment"

from pywinauto.win32structures import RECT

#====================================================================
def MissalignmentTest(windows):
    "Run the test on the windows passed in"
    refAlignments = {}

    #find the controls alligned along each axis
    for win in windows:
        if not win.ref:
            continue


        for side in ("top", "left", "right", "bottom"):
            sideValue = getattr(win.ref.Rectangle(), side)

            # make sure that the side dictionary has been created
            sideAlignments = refAlignments.setdefault(side, {})

            # make sure that the array of controls for this
            # alignment line has been created and add the current window
            sideAlignments.setdefault(sideValue, []).append(win)

    bugs = []
    for side in refAlignments:
        for alignment in refAlignments[side]:
            # get the controls that were alligned
            controls = refAlignments[side][alignment]

            # get the sides of the current controls
            sides = [getattr(ctrl.Rectangle(), side) for ctrl in controls]

            # if one or more of the controls have a differnt value for this
            # side
            if len(set(sides)) > 1:
                if side in ("top bottom"):
                    # find how far away from each other the controls are...
                    lefts = [c.ref.Rectangle().left for c in controls]
                    rights = [c.ref.Rectangle().right for c in controls]

                    nearest = []
                    for i, c1 in enumerate(controls):
                        for c2 in controls[i+1:]:
                            dist = min (
                                abs(c1.Rectangle().right - c2.Rectangle().left),
                                abs(c1.Rectangle().left - c2.Rectangle().right))

                            if dist < 40 and getattr(c1.Rectangle(), side) != getattr(c2.Rectangle(), side):
                                buggy_controls.append((c1, c2))


            else:
                if side in ("left right"):
                    # find how far away from each other the controls are...
                    lefts = [c.ref.Rectangle().left for c in controls]
                    rights = [c.ref.Rectangle().right for c in controls]

                    for left in left:
                        for right in rights:
                            if min (abs(right - left), abs(left - right)) > 40:
                                continue




            sides = set(sides)

            if len(sides) > 1:

                overAllRect = RECT()
                overAllRect.left = min(
                    [ctrl.Rectangle().left for ctrl in controls])
                overAllRect.top = min(
                    [ctrl.Rectangle().top for ctrl in controls])
                overAllRect.right = max(
                    [ctrl.Rectangle().right for ctrl in controls])
                overAllRect.bottom = max(
                    [ctrl.Rectangle().bottom for ctrl in controls])


                bugs.append((
                    controls,
                    {
                        "AlignmentType": side.upper(),
                        "AlignmentRect": overAllRect
                    },
                    testname,
                    0)
                )

    return bugs


########NEW FILE########
__FILENAME__ = missalignment
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Missalignment Test

**What is checked**
This test checks that if a set of controls were aligned on a particular axis
in the reference dialog  that they are all aligned on the same axis.

**How is it checked**
A list of all the reference controls that are aligned is created (ie more than
one control with the same Top, Left, Bottom or Right coordinates). These
controls are then analysed in the localised dialog to make sure that they are
all aligned on the same axis.

**When is a bug reported**
A bug is reported when any of the controls that were aligned in the reference
dialog are no longer aligned in the localised control.

**Bug Extra Information**
The bug contains the following extra information
Name	Description
AlignmentType	This is either LEFT, TOP, RIGHT or BOTTOM. It tells you how
the controls were aligned in the reference dialog. String
AlignmentRect	Gives the smallest rectangle that surrounds ALL the controls
concerned in the bug, Rectangle

**Is Reference dialog needed**
This test cannot be performed without the reference control. It is required
to see which controls should be aligned.

**False positive bug reports**
It is quite possible that this test reports false positives:
1.	Where the controls only just happen to be aligned in the reference dialog
(by coincidence)
2.	Where the control does not have a clear boundary (for example static
labels or checkboxes)  they may be miss-aligned but it is not noticeable that
they are not.


**Test Identifier**
The identifier for this test/bug is "Missalignment" """

__revision__ = "$Revision: 221 $"

testname = "Missalignment"

from ..win32structures import RECT

#====================================================================
def MissalignmentTest(windows):
    "Run the test on the windows passed in"
    refAlignments = {}

    #find the controls alligned along each axis
    for win in windows:
        if not win.ref:
            continue


        for side in ("top", "left", "right", "bottom"):
            sideValue = getattr(win.ref.Rectangle(), side)

            # make sure that the side dictionary has been created
            sideAlignments = refAlignments.setdefault(side, {})

            # make sure that the array of controls for this
            # alignment line has been created and add the current window
            sideAlignments.setdefault(sideValue, []).append(win)

    bugs = []
    for side in refAlignments:
        for alignment in refAlignments[side]:
            controls = refAlignments[side][alignment]
            sides = [getattr(ctrl.Rectangle(), side) for ctrl in controls]
            sides = set(sides)

            if len(sides) > 1:

                overAllRect = RECT()
                overAllRect.left = min(
                    [ctrl.Rectangle().left for ctrl in controls])
                overAllRect.top = min(
                    [ctrl.Rectangle().top for ctrl in controls])
                overAllRect.right = max(
                    [ctrl.Rectangle().right for ctrl in controls])
                overAllRect.bottom = max(
                    [ctrl.Rectangle().bottom for ctrl in controls])


                bugs.append((
                    controls,
                    {
                        "AlignmentType": side.upper(),
                        "AlignmentRect": overAllRect
                    },
                    testname,
                    0)
                )

    return bugs


########NEW FILE########
__FILENAME__ = missingextrastring
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Different number of special character sequences Test

**What is checked**
This test checks to make sure that certain special character sequences
appear the in the localised if they appear in the reference title strings.
These strings usually mean something to the user but the software internally
does not care if they exist or not. The list that is currently checked is:
">>", ">", "<<", "<", ":"(colon), "...", "&&", "&", ""

**How is it checked**
For each of the string to check for we make sure that if it appears in the
reference that it also appears in the localised title.

**When is a bug reported**
 - If the reference has one of the text strings but the localised does
   not a bug is reported.
 - If the localised has one of the text strings but the reference does
   not a bug is reported.

Bug Extra Information
The bug contains the following extra information

**MissingOrExtra**	Whether the characters are missing or extra from the
controls being check as compared to the reference, (String with
following possible values)

 - "MissingCharacters"	The characters are in the reference but not in
   the localised.
 - "ExtraCharacters"	The characters are not in the reference but are in
   the localised.

**MissingOrExtraText**	What character string is missing or added, String

**Is Reference dialog needed**
This test will not run if the reference controls are not available.

**False positive bug reports**
Currently this test is at a beta stage filtering of the results is probably
necessary at the moment.

**Test Identifier**
The identifier for this test/bug is "MissingExtraString"
"""

__revision__ = "$Revision: 622 $"



testname = "MissingExtraString"

CharsToCheck = (
    ">",
    ">>",
    "<",
    "<<",
    "&",
    "&&",
    "...",
    ":",
    "@",

)

#-----------------------------------------------------------------------------
def MissingExtraStringTest(windows):
    "Return the errors from running the test"
    bugs = []
    for win in windows:
        if not win.ref:
            continue

        for char in CharsToCheck:
            missing_extra = ''

            if win.WindowText().count(char) > win.ref.WindowText().count(char):
                missing_extra = "ExtraCharacters"
            elif win.WindowText().count(char) < win.ref.WindowText().count(char):
                missing_extra = "MissingCharacters"

            if missing_extra:
                bugs.append((
                    [win,],
                    {
                        "MissingOrExtra": missing_extra,
                        "MissingOrExtraText": char
                    },
                    testname,
                    0))

    return bugs


MissingExtraStringTest.TestsMenus = True

def _unittests():
    "Run the unit tests for this test"


    # set up some mock controls - (only requires some 'Text')
    test_strings = (
        ("Nospecial", "NietherHere", 0),

        ("Nob>ug", "Niet>herHere", 0),
        ("No>>bug", ">>NietherHere", 0),
        ("<Nobug", "NietherHere<", 0),
        ("Nobug<<", "NietherHere<<", 0),
        ("No&bu&g", "&NietherHere&", 0),
        ("No&&bug", "NietherHere&&", 0),
        ("Nobug...", "Nieth...erHere", 0),
        ("Nobug:", ":NietherHere", 0),
        ("No@bug", "Ni@etherHere", 0),
        (">Th&&>>is &str<<ing >>has ju<st about @everything :but ...no bug",
            "This s&tr...in<<g has jus<t abou&&t every>th:ing >>but no @bug",
            0),

        ("GreaterAdded >", "No Greater", 1),
        ("GreaterMissing", "Greater > here", 1),

        ("doubleGreater added >>", "No double greater", 1),
        ("doubleGreater added >>", "No double greater >", 1),
        ("doubleGreater Missing >", "No double greater >>", 1),
        )

    class Control(object):
        def Text(self):
            return self.text
        pass

    ctrls = []
    total_bug_count = 0
    for loc, ref, num_bugs in test_strings:
        ctrl = Control()
        ctrl.text = loc
        ctrl.ref = Control()
        ctrl.ref.text = ref

        total_bug_count += num_bugs
        num_found = len(MissingExtraStringTest([ctrl]))
        try:
            assert num_found == num_bugs
        except:
            #print num_found, num_bugs, loc, ref
            pass


        ctrls.append(ctrl)

    assert len(MissingExtraStringTest(ctrls)) == total_bug_count



if __name__ == "__main__":
    _unittests()
########NEW FILE########
__FILENAME__ = overlapping
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA
"""Overlapping Test

**What is checked**
The overlapping test checks for controls that occupy the same space as some
other control in the dialog.

  + If the reference controls are available check for each pair of controls:

    - If controls are exactly the same size and position in reference then
      make sure that they are also in the localised.
    - If a reference control is wholly contained in another make sure that the
      same happens for the controls being tested.

  + If the reference controls are not available only the following check can
    be done

    - If controls are overlapped in localised report a bug (if reference is
      available it is used just to say if this overlapping happens in reference
      also)


**How is it checked**
Various tests are performed on each pair of controls to see if any of the
above conditions are met. The most specific tests that can be performed are
done 1st so that the bugs reported are as specific as possible. I.e. we report
that 2 controls are not exactly overlapped when they should be rather than jut
reporting that they are overlapped which contains less information.

**When is a bug reported**
A bug is reported when:

    - controls are overlapped (but not contained wholly, and not exactly
      overlapped)
    - reference controls are exactly overlapped but they are not in tested
      dialog
    - one reference control is wholly contained in another but not in
      tested dialog


**Bug Extra Information**
This test produces 3 different types of bug:
BugType: "Overlapping"
Name    Description
OverlappedRect  <What this info is>, Rectangle

**BugType -  "NotContainedOverlap"**
There is no extra information associated with this bug type

**BugType - "NotExactOverlap"**
There is no extra information associated with this bug type

**Is Reference dialog needed**
For checking whether controls should be exactly overlapped and whether they
should be wholly contained the reference controls are necessary. If the
reference controls are not available then only simple overlapping of controls
will be checked.

**False positive bug reports**
If there are controls in the dialog that are not visible or are moved
dynamically it may cause bugs to be reported that do not need to be logged.
If necessary filter out bugs with hidden controls.

**Test Identifier**
The identifier for this test is "Overlapping"
"""

testname = "Overlapping"
__revision__ = "$Revision: 545 $"

from .. import win32structures

#====================================================================
def OverlappingTest(windows):
    "Return the repeated hotkey errors"

    bugs = []

    for i, first in enumerate(windows[:-1]):
        first_rect = first.Rectangle()

        if first.ref:
            first_ref_rect = first.ref.Rectangle()

        for second in windows[i+1:]:
            second_rect = second.Rectangle()


            # if the reference controls are available
            if first.ref and second.ref:
                second_ref_rect = second.ref.Rectangle()

                if first_ref_rect == second_ref_rect and \
                    not first_rect == second_rect:

                    bugs.append(([first, second], {}, "NotExactOverlap", 0))

                elif _ContainedInOther(first_ref_rect,second_ref_rect) and \
                    not _ContainedInOther(first_rect, second_rect):

                    bugs.append(
                        ([first, second], {}, "NotContainedOverlap", 0))


            if _Overlapped(first_rect, second_rect) and \
                not _ContainedInOther(first_rect, second_rect) and \
                not first_rect == second_rect:

                ovlRect = _OverlapRect(first_rect, second_rect)

                isInRef = -1
                if first.ref and second.ref:
                    isInRef = 0
                    if _Overlapped(first_ref_rect, second_ref_rect):
                        isInRef = 1

                bugs.append((
                    [first, second],
                    {"OverlappedRect":ovlRect},
                    testname,
                    isInRef))

    return bugs



#====================================================================
def _ContainedInOther(rect1, rect2):
    "Return true if one rectangle completely contains the other"
    # check if rect2 is inside rect1

    if rect1.left   >= rect2.left and \
        rect1.top    >= rect2.top and \
        rect1.right  <= rect2.right and \
        rect1.bottom <= rect2.bottom:
        return True

    # check if rect1 is inside rect2
    elif rect2.left  >= rect1.left and \
        rect2.top    >= rect1.top and \
        rect2.right  <= rect1.right and \
        rect2.bottom <= rect1.bottom:
        return True

    # no previous return - so must not be included
    return False


def _Overlapped(rect1, rect2):
    "Return true if the two rectangles are overlapped"
    ovlRect = _OverlapRect(rect1, rect2)

    # if it is actually a bug
    if ovlRect.left < ovlRect.right and ovlRect.top < ovlRect.bottom:
        # make sure that the rectangle is the 'right way around :-)'
        return True
    return False


# Case 1: L2 between L1 and R1 -> max(L1, L2) < min(R1, R2)
#
# L1            R1
# ---------------
#        L2          R2
#        --------------
#
# Case 2: R2 outside L1 and R1 -> NOT max(L1, L2) < min(R1, R2)
#
#               L1          R1
#               -------------
# L2        R2
# ------------
#

class OptRect(object): pass

def _OverlapRect (rect1, rect2):
    "check whether the 2 rectangles are actually overlapped"

    ovlRect = OptRect()#win32structures.RECT()

    ovlRect.left   = max(rect1.left,   rect2.left)
    ovlRect.right  = min(rect1.right,  rect2.right)
    ovlRect.top    = max(rect1.top,    rect2.top)
    ovlRect.bottom = min(rect1.bottom, rect2.bottom)

    return ovlRect


########NEW FILE########
__FILENAME__ = repeatedhotkey
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Repeated Hotkeys Test

**What is checked**
This test checks all the controls in a dialog to see if there are controls that
use the same hotkey character.

**How is it checked**
A list of all the hotkeys (converted to uppercase) used in the dialog is
created. Then this list is examined to see if any hotkeys are used more than
once. If any are used more than once a list of all the controls that use this
hotkey are compiled to be used in the bug report.

**When is a bug reported**
If more than one control has the same hotkey then a bug is reported.

**Bug Extra Information**
The bug contains the following extra information
Name	Description
RepeatedHotkey	This is the hotkey that is repeated between the 2 controls
converted to uppercase, String
CharsUsedInDialog	This is a list of all the hotkeys used in the dialog,
String
AllCharsInDialog	This is a list of all the characters in the dialog for
controls that have a hotkeys, String
AvailableInControlS	A list of the available characters for each control.
Any of the characters in this list could be used as the new hotkey without
conflicting with any existing hotkey.

**Is Reference dialog needed**
The reference dialog does not need to be available. If it is available then
for each bug discovered it is checked to see if it is a problem in the
reference dialog.
NOTE: Checking the reference dialog is not so exact here! Only when the
equivalent controls in the reference dialog all have the hotkeys will it be
reported as being in the reference also. I.e. if there are 3 controls with the
same hotkey in the Localised software  then those same controls in the
reference dialog must have the same hotkey for it to be reported as existing
in the reference also.

**False positive bug reports**
There should be very few false positives from this test. Sometimes a control
only has one or 2 characters eg "X:" and it is impossible to avoid a hotkey
clash. Also for Asian languages hotkeys should be the same as the US software
so probably this test should be run on those languages.

**Test Identifier**
The identifier for this test/bug is "RepeatedHotkey"
"""

testname = "RepeatedHotkey"
__revision__ = "$Revision: 648 $"

# need to use sets.Set for python 2.3 compatability
# but 2.6 raises a deprecation warning about sets module
try:
    set
except NameError:
    import sets
    set = sets.Set
    
from ..win32defines import SS_NOPREFIX


#-----------------------------------------------------------------------------
def RepeatedHotkeyTest(windows):
    "Return the repeated hotkey errors"

    hotkeyControls, allChars, hotkeys = _CollectDialogInfo(windows)

    # get the available characters in the dialog
    dlgAvailable = allChars.difference(hotkeys)

    # remove some characters that aren't good choices for hotkeys
    dlgAvailable.difference_update(set("-& _"))


    bugs = []
    # for each hotkey
    for char, controls in list(hotkeyControls.items()):

        # if there is more than one control associated then it is a bug
        if len(controls) > 1:

            ctrlsAvailableChars = ""

            # build up the available characters for each control
            for ctrl in controls:
                controlChars = ""
                controlChars = set(ctrl.WindowText().lower())

                controlAvailableChars = controlChars.intersection(dlgAvailable)
                controlAvailableChars = \
                    "<%s>" % _SetAsString(controlAvailableChars)

                ctrlsAvailableChars += controlAvailableChars

            refCtrls = [ctrl.ref for ctrl in controls if ctrl.ref]
            refHotkeyControls, refAllChars, refHotkeys = \
                _CollectDialogInfo(refCtrls)

            isInRef = -1
            if len(refHotkeys) > 1:
                isInRef = 1
            else:
                isInRef = 0

            bugs.append((
                controls,
                {
                    "RepeatedHotkey" : 		char,
                    "CharsUsedInDialog" :   _SetAsString(hotkeys),
                    "AllCharsInDialog" :    _SetAsString(allChars),
                    "AvailableInControls" : ctrlsAvailableChars,
                },
                testname,
                isInRef)
            )

#	# What is the algorithm to try and do all that is necessary to find
#	# if it is possible to get a fix character if none of the current
#	# characters are free
#	for bug in bugs:
#		for c, chars in bug.bugData:
#			# control has no possibilities
#			if not chars:
#				# check if there are any other hotkey controls
#				# in the dialog that could be used
#				others = set(c.Title.lower()).intersection(unUsedChars)


    return  bugs



#-----------------------------------------------------------------------------
def _CollectDialogInfo(windows):
    "Collect information on the hotkeys in the dialog"
    hotkeyControls = {}
    allChars = ''

    for win in windows:
        # skip it if it doesn't implement hotkey functionality
        if not ImplementsHotkey(win):
            continue

        # get the hotkey
        pos, char = GetHotkey(win.WindowText())

        # if no hotkey for this control
        # then continue
        if not char:
            continue

        # store hotkey with list of used hotkeys
        # map this hotkey to the list of controls that have it
        hotkeyControls.setdefault(char.lower(), []).append(win)


        # Add the title of this control to the list of available
        # characters for the dialog
        allChars += win.WindowText().lower()


    allChars = set(allChars)
    hotkeys = set(hotkeyControls.keys())

    return hotkeyControls, allChars, hotkeys


#-----------------------------------------------------------------------------
# get hokey position
def GetHotkey(text):
    "Return the position and character of the hotkey"

    # find the last & character that is not followed
    # by & or by the end of the string

    curEnd = len(text) + 1
    text = text.replace("&&", "__")
    while True:
        pos = text.rfind("&", 0, curEnd)

        # One found was at the end of the text or
        # no (more) & were found
        # so return the None value
        if pos == -1 or pos == len(text):
            return (-1, '')

        # One found but was prededed by non valid hotkey character
        # so continue, as that can't be a shortcut
        if text[pos - 1] == '&':
            curEnd = pos - 2
            continue

        # 2 ampersands in a row - so skip
        # the 1st one and continue
        return (pos, text[pos+1])



#-----------------------------------------------------------------------------
def _SetAsString(settojoin):
    "Convert the set to a ordered string"
    return "".join(sorted(settojoin))


#-----------------------------------------------------------------------------
def ImplementsHotkey(win):
    "checks whether a control interprets & character to be a hotkey"

    # buttons always implement hotkey
    if win.Class() == "Button":
        return True

    # Statics do if they don't have SS_NOPREFIX style
    elif win.Class() == "Static" and not win.HasStyle(SS_NOPREFIX):
        return True

    if win.Class() == "MenuItem" and win.State() != "2048":
        return True

    # Most controls don't - so just return false if
    # neither of the above condition hold
    return False


RepeatedHotkeyTest.TestsMenus = True


########NEW FILE########
__FILENAME__ = translation
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA


"""Translation Test

**What is checked**
This checks for controls which appear not to be translated.

**How is it checked**
It compares the text of the localised and reference controls.

If there are more than string in the control then each item is searched for in
the US list of titles (so checking is not order dependent).
The indices for the untranslated strings are returned in a comma separated
string.
Also the untranslated strings themselves are returned (all as one string).
These strings are not escaped and are delimited as
"string1","string2",..."stringN".

**When is a bug reported**

 If the text of the localised control is identical to the reference control
 (in case, spacing i.e.  a binary compare) then it will be flagged as
 untranslated. Otherwise the control is treated as translated.

Note: This is the method to return the least number of bugs. If there are
differences in any part of the string (e.g. a path or variable name) but the
rest of the string is untranslated then a bug will not be highlighted

**Bug Extra Information**
The bug contains the following extra information
Name	Description
Strings		The list of the untranslated strings as explained above
StringIndices		The list of indices (0 based) that are untranslated.
This will usually be 0 but if there are many strings in the control
untranslated it will report ALL the strings e.g. 0,2,5,19,23

**Is Reference dialog needed**
The reference dialog is always necessary.

**False positive bug reports**
False positive bugs will be reported in the following cases.
-	The title of the control stays the same as the US because the
translation is the same as the English text(e.g. Name: in German)
-	The title of the control is not displayed (and not translated).
This can sometimes happen if the programmer displays something else on the
control after the dialog is created.

**Test Identifier**
The identifier for this test/bug is "Translation" """

__revision__ = "$Revision: 221 $"

testname = "Translation"

import re

#-----------------------------------------------------------------------------
def TranslationTest(windows):
    "Returns just one bug for each control"

    bugs = []
    for win in windows:
        if not win.ref:
            continue

        # get if any items are untranslated
        untranTitles, untranIndices = _GetUntranslations(win)

        if untranTitles:
            indicesAsString = ",".join([str(idx) for idx in untranIndices])

            bugs.append((
                [win,],
                {
                    "StringIndices": indicesAsString,
                    "Strings": ('"%s"' % '","'.join(untranTitles))
                },
                testname,
                0)
            )


    return bugs

def _GetUntranslations(win):
    "Find the text items that are not translated"
    # remove ampersands and other non translatable bits from the string

    nonTransChars = re.compile(
        """(\&(?!\&)|	# ampersand not followed by an ampersand
            \.\.\.$|	# elipsis ...
            ^\s*|		# leading whitespace
            \s*$|		# trailing whitespace
            \s*:\s*$	# trailing colon (with/without whitespace)
            )*			# repeated as often as necessary
            """, re.X)


    # clean each of the loc titles for comparison
    cleanedLocTitles = []
    for title in win.Texts():
        cleanedLocTitles.append(nonTransChars.sub("", title))

    # clean each of the ref titles for comparison
    cleanedRefTitles = []
    for title in win.ref.Texts():
        cleanedRefTitles.append(nonTransChars.sub("", title))

    untranslatedTitles = []
    untranslatedIndices = []

    # loop over each of the cleaned loc title
    for index, title in enumerate(cleanedLocTitles):

        # if the title is empty just skip it
        if not title:
            continue

        # if that title is in the cleaned Ref Titles
        if title in cleanedRefTitles:
            # add this as one of the bugs
            untranslatedTitles.append(title)
            untranslatedIndices.append(index)

    # return all the untranslated titles and thier indices
    return untranslatedTitles, untranslatedIndices


TranslationTest.TestsMenus = True


########NEW FILE########
__FILENAME__ = truncation
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

# pylint: disable-msg=W0611

"""Truncation Test

**What is checked**
Checks for controls where the text does not fit in the space provided by the
control.

**How is it checked**
There is a function in windows (DrawText) that allows us to find the size that
certain text will need. We use this function with correct fonts and other
relevant information for the control to be as accurate as possible.

**When is a bug reported**
When the calculated required size for the text is greater than the size of the
space available for displaying the text.

**Bug Extra Information**
The bug contains the following extra information
Name	Description
Strings		The list of the truncated strings as explained above
StringIndices		The list of indices (0 based) that are truncated. This
will often just be 0 but if there are many strings in the control untranslated
it will report ALL the strings e.g. 0,2,5,19,23


**Is Reference dialog needed**
The reference dialog does not need to be available. If it is available then
for each bug discovered it is checked to see if it is a problem in the
reference dialog.

**False positive bug reports**
Certain controls do not display the text that is the title of the control, if
this is not handled in a standard manner by the software then DLGCheck will
report that the string is truncated.

**Test Identifier**
The identifier for this test/bug is "Truncation"
"""

__revision__ = "$Revision: 619 $"

testname = "Truncation"

import ctypes

from .. import win32defines
from .. import win32functions
from ..win32structures import RECT


#==============================================================================
def TruncationTest(windows):
    "Actually do the test"

    truncations = []

    # for each of the windows in the dialog
    for win in windows:

        truncIdxs, truncStrings = _FindTruncations(win)

        isInRef = -1

        # if there were any truncations for this control
        if truncIdxs:

            # now that we know there was at least one truncation
            # check if the reference control has truncations
            if win.ref:
                isInRef = 0
                refTruncIdxs, refTruncStrings = _FindTruncations(win.ref)

                if refTruncIdxs:
                    isInRef = 1

            truncIdxs = ",".join([str(index) for index in truncIdxs])
            truncStrings = '"%s"' % ",".join(
                [str(string) for string in truncStrings])
            truncations.append((
                [win,],
                {
                    "StringIndices": truncIdxs,
                    "Strings": truncStrings,
                },
                testname,
                isInRef)
            )

    # return all the truncations
    return truncations

#==============================================================================
def _FindTruncations(ctrl):
    "Return the index of the texts that are truncated for this control"
    truncIdxs = []
    truncStrings = []

    # for each of the titles this dialog
    for idx, (text, rect, font, flags) in enumerate(_GetTruncationInfo(ctrl)):

        # skip if there is no text
        if not text:
            continue

        # get the minimum rectangle
        minRect = _GetMinimumRect(text, font, rect, flags)

        # if the min rectangle is bigger than the rectangle of the
        # object
        if minRect.right > rect.right or \
            minRect.bottom > rect.bottom:
            
            # append the index and the rectangle to list of bug items
            truncIdxs.append(idx)
            truncStrings.append(text)
        
            #print "%s'\n\tRECT: %s\n\t MIN: %s" %(text, rect, minRect)

    return truncIdxs, truncStrings



#==============================================================================
def _GetMinimumRect(text, font, usableRect, drawFlags):
    """Return the minimum rectangle that the text will fit into

    Uses font, usableRect and drawFlags information to find how
    how to do it accurately
    """

    # try to create the font
    # create a Display DC (compatible to the screen)
    txtDC = win32functions.CreateDC("DISPLAY", None, None, None )

    hFontGUI = win32functions.CreateFontIndirect(ctypes.byref(font))
        
#    # Maybe we could not get the font or we got the system font
#    if not hFontGUI:
#
#        # So just get the default system font
#        hFontGUI = win32functions.GetStockObject(win32defines.DEFAULT_GUI_FONT)
#
#        # if we still don't have a font!
#        # ----- ie, we're on an antiquated OS, like NT 3.51
#        if not hFontGUI:
#
#            # ----- On Asian platforms, ANSI font won't show.
#            if win32functions.GetSystemMetrics(win32defines.SM_DBCSENABLED):
#                # ----- was...(SYSTEM_FONT)
#                hFontGUI = win32functions.GetStockObject(
#                    win32defines.SYSTEM_FONT)
#            else:
#                # ----- was...(SYSTEM_FONT)
#                hFontGUI = win32functions.GetStockObject(
#                    win32defines.ANSI_VAR_FONT)

    # put our font into the Device Context
    win32functions.SelectObject (txtDC, hFontGUI)

    modifiedRect = RECT(usableRect)
    # Now write the text to our DC with our font to get the
    # rectangle that the text needs to fit in
    win32functions.DrawText (txtDC, # The DC
        str(text),		# The Title of the control
        -1,			# -1 because sTitle is NULL terminated
        ctypes.byref(modifiedRect),	# The Rectangle to be calculated to
        #truncCtrlData.drawTextFormat |
        win32defines.DT_CALCRECT | drawFlags)

    #elif modifiedRect.right == usableRect.right and \
    #	modifiedRect.bottom == usableRect.bottom:
    #	print "Oh so you thought you were perfect!!!"


    # Delete the font we created
    win32functions.DeleteObject(hFontGUI)

    # delete the Display context that we created
    win32functions.DeleteDC(txtDC)

    return modifiedRect




#==============================================================================
def _GroupBoxTruncInfo(win):
    "Return truncation information specific to Button controls"
    lineFormat = win32defines.DT_SINGLELINE

    heightAdj = 4
    widthAdj = 9

    # don't check image controls for truncation!
    # we do this by specifying huge adjustments
    # maybe a better/more pythonic way of doing this would be
    # to set some special lineFormat (None or something?)
    if win.HasStyle(win32defines.BS_BITMAP) or \
        win.HasStyle(win32defines.BS_ICON):
        heightAdj = -9000
        widthAdj = -9000
        lineFormat = win32defines.DT_WORDBREAK

    newRect = win.ClientRects()[0]
    newRect.right -=  widthAdj
    newRect.bottom -=  heightAdj

    return [(win.WindowText(), newRect, win.Font(), lineFormat), ]


#==============================================================================
def _RadioButtonTruncInfo(win):
    "Return truncation information specific to Button controls"
    lineFormat = win32defines.DT_SINGLELINE

    if win.HasStyle(win32defines.BS_MULTILINE):
        lineFormat = win32defines.DT_WORDBREAK
    
    widthAdj = 19

    # don't check image controls for truncation!
    # we do this by specifying huge adjustments
    # maybe a better/more pythonic way of doing this would be
    # to set some special lineFormat (None or something?)
    if win.HasStyle(win32defines.BS_BITMAP) or \
        win.HasStyle(win32defines.BS_ICON):
        heightAdj = -9000
        widthAdj = -9000
        lineFormat = win32defines.DT_WORDBREAK

    newRect = win.ClientRects()[0]
    newRect.right -=  widthAdj

    return [(win.WindowText(), newRect, win.Font(), lineFormat), ]


#==============================================================================
def _CheckBoxTruncInfo(win):
    "Return truncation information specific to Button controls"
    lineFormat = win32defines.DT_SINGLELINE

    if win.HasStyle(win32defines.BS_MULTILINE):
        lineFormat = win32defines.DT_WORDBREAK

    widthAdj = 18
    
    # don't check image controls for truncation!
    # we do this by specifying huge adjustments
    # maybe a better/more pythonic way of doing this would be
    # to set some special lineFormat (None or something?)
    if win.HasStyle(win32defines.BS_BITMAP) or \
        win.HasStyle(win32defines.BS_ICON):
        heightAdj = -9000
        widthAdj = -9000
        lineFormat = win32defines.DT_WORDBREAK

    newRect = win.ClientRects()[0]
    newRect.right -=  widthAdj
    
    return [(win.WindowText(), newRect, win.Font(), lineFormat), ]


#==============================================================================
def _ButtonTruncInfo(win):
    "Return truncation information specific to Button controls"
    lineFormat = win32defines.DT_SINGLELINE

    if win.HasStyle(win32defines.BS_MULTILINE):
        lineFormat = win32defines.DT_WORDBREAK

    heightAdj = 4
    widthAdj = 5

    if win.HasStyle(win32defines.BS_PUSHLIKE):
        widthAdj = 3
        heightAdj = 3 # 3
        if win.HasStyle(win32defines.BS_MULTILINE):
            widthAdj = 9
            heightAdj = 2 # 3

    # don't check image controls for truncation!
    # we do this by specifying huge adjustments
    # maybe a better/more pythonic way of doing this would be
    # to set some special lineFormat (None or something?)
    if win.HasStyle(win32defines.BS_BITMAP) or \
        win.HasStyle(win32defines.BS_ICON):
        heightAdj = -9000
        widthAdj = -9000
        lineFormat = win32defines.DT_WORDBREAK

    newRect = win.ClientRects()[0]
    newRect.right -=  widthAdj
    newRect.bottom -=  heightAdj

    return [(win.WindowText(), newRect, win.Font(), lineFormat), ]

#==============================================================================
def _ComboBoxTruncInfo(win):
    "Return truncation information specific to ComboBox controls"
    # canot wrap and never had a hotkey
    lineFormat = win32defines.DT_SINGLELINE | win32defines.DT_NOPREFIX

    if win.HasStyle(win32defines.CBS_DROPDOWN) or \
        win.HasStyle(win32defines.CBS_DROPDOWNLIST):
        widthAdj = 2#5
    else:
        widthAdj = 3

    truncData = []
    for title in win.Texts():
        newRect = win.ClientRects()[0]
        newRect.right -= widthAdj
        truncData.append((title, newRect, win.Font(), lineFormat))

    return truncData

#==============================================================================
def _ComboLBoxTruncInfo(win):
    "Return truncation information specific to ComboLBox controls"
    # canot wrap and never had a hotkey
    lineFormat = win32defines.DT_SINGLELINE | win32defines.DT_NOPREFIX

    truncData = []
    for title in win.Texts():
        newRect = win.ClientRects()[0]
        newRect.right -= 5
        truncData.append((title, newRect, win.Font(), lineFormat))

    return truncData


#==============================================================================
def _ListBoxTruncInfo(win):
    "Return truncation information specific to ListBox controls"
    # canot wrap and never had a hotkey
    lineFormat = win32defines.DT_SINGLELINE | win32defines.DT_NOPREFIX

    truncData = []
    for title in win.Texts():
        newRect = win.ClientRects()[0]
        newRect.right -= 2
        newRect.bottom -= 1
        truncData.append((title, newRect, win.Font(), lineFormat))

    return truncData


#==============================================================================
def _StaticTruncInfo(win):
    "Return truncation information specific to Static controls"
    lineFormat = win32defines.DT_WORDBREAK

    if win.HasStyle(win32defines.SS_CENTERIMAGE) or \
        win.HasStyle(win32defines.SS_SIMPLE) or \
        win.HasStyle(win32defines.SS_LEFTNOWORDWRAP):

        if "WindowsForms" not in win.Class():
            lineFormat = win32defines.DT_SINGLELINE

    if win.HasStyle(win32defines.SS_NOPREFIX):
        lineFormat |= win32defines.DT_NOPREFIX

    return [(win.WindowText(), win.ClientRects()[0], win.Font(), lineFormat), ]

#==============================================================================
def _EditTruncInfo(win):
    "Return truncation information specific to Edit controls"
    lineFormat = win32defines.DT_WORDBREAK | win32defines.DT_NOPREFIX

    if not win.HasStyle(win32defines.ES_MULTILINE):
        lineFormat |= win32defines.DT_SINGLELINE

    return [(win.WindowText(), win.ClientRects()[0], win.Font(), lineFormat), ]


#==============================================================================
def _DialogTruncInfo(win):
    "Return truncation information specific to Header controls"
    # move it down more into range

    newRect = win.ClientRects()[0]

    newRect.top += 5
    newRect.left += 5
    newRect.right -= 5


    if win.HasStyle(win32defines.WS_THICKFRAME):
        newRect.top += 1
        newRect.left += 1
        newRect.right -= 1

    # if it has the system menu but is a small caption
    # then the only button it can have is the close button
    if win.HasStyle(win32defines.WS_SYSMENU) and \
        (win.HasExStyle(win32defines.WS_EX_PALETTEWINDOW) or
        win.HasExStyle(win32defines.WS_EX_TOOLWINDOW)):
        newRect.right -= 15


    # all the rest only need to be considered if there is a system menu.
    elif win.HasStyle(win32defines.WS_SYSMENU):
        buttons = []
        # account for the close button
        newRect.right -= 18
        buttons.append('close')

        # account for Icon if it is not disabled
        if not win.HasExStyle(win32defines.WS_EX_DLGMODALFRAME):
            newRect.left += 19 # icon


        # account for context sensitive help if set
        if win.HasExStyle(win32defines.WS_EX_CONTEXTHELP) and not ( \
            win.HasStyle(win32defines.WS_MAXIMIZEBOX) and \
            win.HasStyle(win32defines.WS_MINIMIZEBOX)):

            newRect.right -= 17

            # there is a bigger gap if the minimize box is there
            if win.HasStyle(win32defines.WS_MINIMIZEBOX) or \
                win.HasStyle(win32defines.WS_MAXIMIZEBOX) or \
                win.HasStyle(win32defines.WS_GROUP):
                newRect.right -= 3

            buttons.append('help')


        # account for Maximize button (but skip if WS_GROUP is set
        if win.HasStyle(win32defines.WS_MINIMIZEBOX) or \
            win.HasStyle(win32defines.WS_MAXIMIZEBOX) or \
            win.HasStyle(win32defines.WS_GROUP):

            newRect.right -= 32
            buttons.append('min')
            buttons.append('max')

        if buttons:
            # space between first button and dialog edge
            diff = 5

            # space for each button
            diff += len(buttons) * 16

            # space between close and next button
            if len(buttons) > 1:
                diff += 2

            # extra space between help and min buttons
            if 'min' in buttons and 'help' in buttons:
                diff += 4

    return [(win.WindowText(), newRect, win.Font(), win32defines.DT_SINGLELINE), ]


#==============================================================================
def _StatusBarTruncInfo(win):
    "Return truncation information specific to StatusBar controls"
    truncInfo = _WindowTruncInfo(win)
    for i, (title, rect, font, flag) in enumerate(truncInfo):

        rect.bottom -= win.VertBorderWidth
        if i == 0:
            rect.right -= win.HorizBorderWidth
        else:
            rect.right -= win.InterBorderWidth

    return truncInfo

#==============================================================================
def _HeaderTruncInfo(win):
    "Return truncation information specific to Header controls"
    truncInfo = _WindowTruncInfo(win)

    for i, (title, rect, font, flag) in enumerate(truncInfo):
        # only modify the header rectangle
        rect.right -= 12

    return truncInfo





#==============================================================================
def _WindowTruncInfo(win):
    "Return Default truncation information"
    matchedItems = []

    for i, title in enumerate(win.Texts()):

        # Use the client rects for rectangles
        if i < len(win.ClientRects()):
            rect = win.ClientRects()[i]
        else:
            # until we run out then just use the first 'main' client rectangle
            rect = win.ClientRects()[0]

        # if we have fewer fonts than titles
        if len(win.Fonts())-1 < i:
            font = win.Font()
        else:
            font = win.Fonts()[i]

        # add the item
        matchedItems.append(
            (title, rect, font, win32defines.DT_SINGLELINE))

    return matchedItems



#==============================================================================
_TruncInfo = {
    "#32770" : _DialogTruncInfo,
    "ComboBox" : _ComboBoxTruncInfo,
    "ComboLBox" : _ComboLBoxTruncInfo,
    "ListBox" : _ListBoxTruncInfo,
    "Button" : _ButtonTruncInfo,
    "CheckBox" : _CheckBoxTruncInfo,
    "GroupBox" : _GroupBoxTruncInfo,
    "RadioButton" : _RadioButtonTruncInfo,
    "Button" : _ButtonTruncInfo,
    "Edit": _EditTruncInfo,
    "Static" : _StaticTruncInfo,

#	"msctls_statusbar32" : StatusBarTruncInfo,
#	"HSStatusBar" : StatusBarTruncInfo,
#	"SysHeader32" : HeaderTruncInfo,

#	"SysListView32" :  ListViewTruncInfo,
    #"SysTreeView32" :
}

#==============================================================================
def _GetTruncationInfo(win):
    "helper function to hide non special windows"
    if win.FriendlyClassName() in _TruncInfo:
        return _TruncInfo[win.FriendlyClassName()](win)
    else:
        return _WindowTruncInfo(win)




########NEW FILE########
__FILENAME__ = _menux
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"tests a set of controls for repeated hotkey errors"

__revision__ = "$Revision: 186 $"

#
#
#from Test_AsianHotkey import AsianHotkeyFormatIncorrect
#from win32structures import RECT, LOGFONTW
#
#class DummyCtrl(dict):
#	def __getattr__(self, name):
#		if name not in self:
#			if name + "s" in self:
#				return self[name + "s"][0]
#		return self[name]
#
#
#
#
#
#
#
##-----------------------------------------------------------------------------
#def MenuRepeatedHotkeyTest(windows):
#	"Return the repeated hotkey errors"
#	bugs = []
#
#	for win in windows:
#		if win.MenuItems:
#			# we need to get all the separate menu blocks!
#			menuBlocks = GetMenuItemsAsCtrlBocks(win.MenuItems)
#
#			for menuBlock in menuBlocks:
#
#				for test in TestFuncRegistry().RegisteredClasses():
#
#					TestFunc = TestFuncRegistry().GetClass(test)
#
#					if hasattr(TestFunc, "TestsMenus") and TestFunc.TestsMenus:
#
#						testBugs = TestFunc(menuBlock)
#						bugs.extend(testBugs)
#
#
##
##				if AsianHotkeyFormatIncorrect(item['Text']):
##					bugs.append(
##					(
##						[win,],
##						{
##							"MenuItem": item['Text'],
##						},
##						"MenuAsianHotkeyFormat",
##						0)
##					)
##
##
#
#
#
##			bugs.append((
##				controls,
##				{
##					"RepeatedHotkey" : 		char,
##					"CharsUsedInDialog" :   SetAsString(hotkeys),
##					"AllCharsInDialog" :    SetAsString(allChars),
##					"AvailableInControls" : ctrlsAvailableChars,
##				},
##				"RepeatedHotkey",
##				isInRef)
#
#	return  bugs
#
#
#
#
#import tests
#tests.register("MenuRepeatedHotkey", AsiMenuRepeatedHotkeyTest)

########NEW FILE########
__FILENAME__ = tictacto_sendkeys
import os, sys, tempfile
#import SendKeys
#print SendKeys
from .SendKeysCtypes import SendKeys
import time

try:
    True
except NameError:
    True,False = 1,0

if __name__ == '__main__':

    # create file game will be saved to
    filename = tempfile.mktemp('.txt')
    print("saving tic-tac-toe game to `%s`" % filename, file=sys.stdout)
    f = open(filename,'w')
    f.write('')
    f.close()

    # open notepad
    print("openeing notepad")
    SendKeys("""{LWIN}r{PAUSE 1}Notepad.exe{SPACE}"%(filename)s"{ENTER}{PAUSE 1}"""
        % {'filename': filename.replace('~','{~}')}, 0.05, with_spaces=True,)

    time.sleep(1)
    # draw board
    SendKeys("""\
   |   |  
---+---+---
   |   |  
---+---+---
   |   |  """.replace('+','{+}'),0.05, with_spaces=True, with_newlines=True)

   # play the game
    SendKeys("""\
    ^o{PAUSE 4}
    
    ^{HOME}
    {DOWN 2}{RIGHT 5}+{RIGHT}{PAUSE 1}x
    {LEFT 4}+{LEFT}+o
    {UP 2}{RIGHT 3}+{RIGHT}x
    {DOWN 4}+{LEFT}+(o)
    {LEFT 4}+{LEFT}x
    {RIGHT 7}{UP 4}+{RIGHT}O
    {DOWN 4}+{LEFT}x
    {UP 4}{LEFT 8}+{LEFT}+O
    {RIGHT 7}{DOWN 2}+{RIGHT 1}x
    ^s
    """, 0.5)

    # read game saved from notepad
    f = open(filename)
    output = f.read()
    f.close()

    assert output == """\
 O | x | O
---+---+---
 O | x | x
---+---+---
 x | O | x"""
    print('Bad news: cat got the game')
    print("Good news: that's what we expected, so the test passed")

########NEW FILE########
__FILENAME__ = timings
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Timing settings for all of pywinauto

This module has one object that should be used for all timing adjustments
  timings.Timings

There are a couple of predefined settings

timings.Timings.Fast()
timings.Timings.Defaults()
timings.Timings.Slow()

The Following are the individual timing settings that can be adjusted:

* window_find_timeout	(default 3)
* window_find_retry (default .09)

* app_start_timeout (default 10)
* app_start_retry   (default .90)

* exists_timeout    (default .5)
* exists_retry  (default .3)

* after_click_wait  (default .09)
* after_clickinput_wait (default .01)

* after_menu_wait   (default .05)

* after_sendkeys_key_wait   (default .01)

* after_button_click_wait   (default 0)

* before_closeclick_wait    (default .1)
* closeclick_retry  (default .05)
* closeclick_dialog_close_wait  (default .05)
* after_closeclick_wait (default .2)

* after_windowclose_timeout (default 2)
* after_windowclose_retry (default .5)

* after_setfocus_wait   (default .06)

* after_setcursorpos_wait   (default .01)

* sendmessagetimeout_timeout   (default .001)

* after_tabselect_wait   (default .01)
* after_listviewselect_wait   (default .01)
* after_listviewcheck_wait  default(.001)

* after_treeviewselect_wait  default(.001)

* after_toobarpressbutton_wait  default(.01)

* after_updownchange_wait  default(.001)

* after_movewindow_wait  default(0)
* after_buttoncheck_wait  default(0)
* after_comboselect_wait  default(0)
* after_listboxselect_wait  default(0)
* after_listboxfocuschange_wait  default(0)
* after_editsetedittext_wait  default(0)
* after_editselect_wait  default(0)

"""

import time
import operator


__revision__ = "$Revision: 453 $"


#=========================================================================
class TimeConfig(object):
    "Central storage and minipulation of timing values"
    __default_timing = {
        'window_find_timeout' : 3,
        'window_find_retry' : .09,

        'app_start_timeout' : 10,
        'app_start_retry' : .90,

        'exists_timeout' : .5,
        'exists_retry' : .3,

        'after_click_wait' : .09,
        'after_clickinput_wait' : .01,

        'after_menu_wait' : .05,

        'after_sendkeys_key_wait' : .01,

        'after_button_click_wait' : 0,

        'before_closeclick_wait' : .1,
        'closeclick_retry' : .05,
        'closeclick_dialog_close_wait' : .05,
        'after_closeclick_wait' : .2,

        'after_windowclose_timeout': 2,
        'after_windowclose_retry':  .5,

        'after_setfocus_wait' : .06,

        'after_setcursorpos_wait' : .01,

        'sendmessagetimeout_timeout' : .001,

        'after_tabselect_wait': .01,

        'after_listviewselect_wait': .01,
        'after_listviewcheck_wait': .001,

        'after_treeviewselect_wait': .001,

        'after_toobarpressbutton_wait': .01,

        'after_updownchange_wait': .001,

        'after_movewindow_wait': 0,
        'after_buttoncheck_wait': 0,
        'after_comboboxselect_wait': 0,
        'after_listboxselect_wait': 0,
        'after_listboxfocuschange_wait': 0,
        'after_editsetedittext_wait': 0,
        'after_editselect_wait': 0,
    }


    _timings = __default_timing.copy()
    _cur_speed = 1

    def __getattr__(self, attr):
        "Get the value for a particular timing"
        if attr in TimeConfig.__default_timing:
            return TimeConfig._timings[attr]
        else:
            raise KeyError(
                "Unknown timing setting: %s" % attr)

    def __setattr__(self, attr, value):
        "Set a particular timing"
        if attr in TimeConfig.__default_timing:
            TimeConfig._timings[attr] = value
        else:
            raise KeyError(
                "Unknown timing setting: %s" % attr)

    def Fast(self):
        """Set fast timing values

        Currently this changes the timing in the following ways:
        timeouts = 1 second
        waits = 0 seconds
        retries = .001 seconds (minimum!)

        (if existing times are faster then keep existing times)
        """

        for setting in TimeConfig.__default_timing:
            # set timeouts to the min of the current speed or 1 second
            if "_timeout" in setting:
                TimeConfig._timings[setting] = \
                    min(1, TimeConfig._timings[setting])

            if "_wait" in setting:
                TimeConfig._timings[setting] = TimeConfig._timings[setting] // 2

            elif setting.endswith("_retry"):
                TimeConfig._timings[setting] = 0.001

            #self._timings['app_start_timeout'] = .5


    def Slow(self):
        """Set slow timing values

        Currently this changes the timing in the following ways:
        timeouts = default timeouts * 10
        waits = default waits * 3
        retries = default retries * 3

        (if existing times are slower then keep existing times)
        """
        for setting in TimeConfig.__default_timing:
            if "_timeout" in setting:
                TimeConfig._timings[setting] = max(
                    TimeConfig.__default_timing[setting] * 10,
                    TimeConfig._timings[setting])

            if "_wait" in setting:
                TimeConfig._timings[setting] = max(
                    TimeConfig.__default_timing[setting] * 3,
                    TimeConfig._timings[setting])

            elif setting.endswith("_retry"):
                TimeConfig._timings[setting] = max(
                    TimeConfig.__default_timing[setting] * 3,
                    TimeConfig._timings[setting])

            if TimeConfig._timings[setting] < .2:
                TimeConfig._timings[setting]= .2

    def Defaults(self):
        "Set all timings to the default time"
        TimeConfig._timings = TimeConfig.__default_timing.copy()


Timings = TimeConfig()


#=========================================================================
class TimeoutError(RuntimeError):
    pass


#=========================================================================
def WaitUntil(
    timeout, 
    retry_interval, 
    func, 
    value = True, 
    op = operator.eq,
    *args):
    
    """Wait until ``op(function(*args), value)`` is True or until timeout 
       expires
    
     * **timeout**  how long the function will try the function
     * **retry_interval**  how long to wait between retries
     * **func** the function that will be executed
     * **value**  the value to be compared against (defaults to True)
     * **op** the comparison function (defaults to equality)\
     * **args** optional arguments to be passed to func when called
     
     Returns the return value of the function
     If the operation times out then the return value of the the function 
     is in the 'function_value' attribute of the raised exception.
     
     e.g. ::
      
      try:
         # wait a maximum of 10.5 seconds for the 
         # the objects ItemCount() method to return 10
         # in increments of .5 of a second
         WaitUntil(10.5, .5, self.ItemCount, 10)
      except TimeoutError, e:
         print "timed out"
     
    """
    
    start = time.time()

    func_val = func(*args)
    # while the function hasn't returned what we are waiting for    
    while not op(func_val, value):
            
        # find out how much of the time is left
        time_left = timeout - ( time.time() - start)
    
        # if we have to wait some more        
        if time_left > 0:
            # wait either the retry_interval or else the amount of
            # time until the timeout expires (whichever is less)
            time.sleep(min(retry_interval, time_left))
            func_val = func(*args)
        else:
            err = TimeoutError("timed out")
            err.function_value = func_val
            raise err
            
    return func_val


#def WaitUntilNot(timeout, retry_interval, func, value = True)
#    return WaitUntil(timeout, retry_interval, func, value = True)
    

def WaitUntilPasses(
    timeout, 
    retry_interval, 
    func, 
    exceptions = (Exception),
    *args):

    """Wait until ``func(*args)`` does not raise one of the exceptions in 
       exceptions
    
     * **timeout**  how long the function will try the function
     * **retry_interval**  how long to wait between retries
     * **func** the function that will be executed
     * **exceptions**  list of exceptions to test against (default: Exception)
     * **args** optional arguments to be passed to func when called
     
     Returns the return value of the function
     If the operation times out then the original exception raised is in
     the 'original_exception' attribute of the raised exception.
     
     e.g. ::
     
      try:
         # wait a maximum of 10.5 seconds for the 
         # window to be found in increments of .5 of a second.
         # P.int a message and re-raise the original exception if never found.
         WaitUntilPasses(10.5, .5, self.Exists, (WindowNotFoundError))
      except TimeoutError, e:
         print "timed out"
         raise e.
     
    """
    
    start = time.time()
    waited = 0

    # keep trying until the timeout is passed
    while True:
        try:
            # Call the function with any arguments
            func_val = func(*args)
            
            # if this did not raise an exception -then we are finised
            break
        
        # An exception was raised - so wait and try again
        except exceptions as e:
        
            # find out how much of the time is left
            time_left = timeout - ( time.time() - start)
        
            # if we have to wait some more        
            if time_left > 0:
                # wait either the retry_interval or else the amount of
                # time until the timeout expires (whichever is less)
                time.sleep(min(retry_interval, time_left))

            else:
                # Raise a TimeoutError - and put the original exception
                # inside it
                err = TimeoutError()
                err.original_exception = e
                raise err
    
    # return the function value
    return func_val


#
#
#
#def Defaults():
#    _current_timing = __default_timing.copy()
#
#
#def Slow():
#    for setting in __default_timing:
#        if "_timeout" in setting:
#            _current_timing[setting] = _default_timing[setting] * 10
#
#        if "_wait" in setting:
#            _current_timing[setting] = _default_timing[setting] * 3
#
#        elif setting.endswith("_retry"):
#            _current_timing[setting] = _default_timing[setting] * 3
#
#
#
#def SetTiming(**kwargs):
#    ""
#
#    for setting, time in kwargs.items():
#        if setting in __default_timing:
#            _current_timing[setting] = time
#        else:
#            raise KeyError(
#                "Unknown timing setting: %s" % setting)
#
#def Get(setting):
#    if setting in __default_timing:
#        return _current_timing[setting]
#    else:
#        raise KeyError(
#            "Unknown timing setting: %s" % setting)

########NEW FILE########
__FILENAME__ = testall
import unittest

import os.path
import os
import sys
sys.path.append(".")

#from pywinauto.timings import Timings
#Timings.Fast()

excludes = ['test_sendkeys']

def run_tests():
    testfolder = os.path.abspath(os.path.split(__file__)[0])

    sys.path.append(testfolder)


    for root, dirs, files in os.walk(testfolder):
        test_modules = [
            file.replace('.py', '') for file in files if
                file.startswith('test_') and
                file.endswith('.py')]

        test_modules = [mod for mod in test_modules if mod.lower() not in excludes]
        for mod in test_modules:

            #globals().update(__import__(mod, globals(), locals()).__dict__)
            # import it
            imported_mod = __import__(mod, globals(), locals())
            #print imported_mod.__dict__
            globals().update(imported_mod.__dict__)


    #runner = unittest.TextTestRunner(verbosity = 2)
    unittest.main()#testRunner = runner)

if __name__ == '__main__':
    run_tests()
########NEW FILE########
__FILENAME__ = test_application
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

#pylint: disable-msg=C0301
#pylint: disable-msg=F0401
#pylint: disable-msg=W0142

"Tests for application.py"

__revision__ = "$Revision: 234 $"

import os
import os.path
import unittest
import time
import pprint
import pdb
import warnings

import sys
sys.path.append(".")
from pywinauto import application
from pywinauto.application import *
from pywinauto import findwindows
from pywinauto.timings import Timings

Timings.Fast()
#application.set_timing(1, .01, 1, .01, .05, 0, 0, .1, 0, .01)

# page setup dialog takes a long time to load
# so make sure that we wait for it.
Timings.window_find_timeout = 10


class ApplicationTestCases(unittest.TestCase):
    "Unit tests for the application.Application class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""
        self.prev_warn = warnings.showwarning
        def no_warnings(*args, **kwargs): pass
        warnings.showwarning = no_warnings

    def tearDown(self):
        "Close the application after tests"
        # close the application
        #self.dlg.SendMessage(win32defines.WM_CLOSE)
        warnings.showwarning = self.prev_warn


    def testNotConnected(self):
        "Verify that it raises when the app is not connected"
        #self.assertRaises (AppNotConnected, Application().__getattr__, 'Hiya')
        #self.assertRaises (AppNotConnected, Application().__getitem__, 'Hiya')
        #self.assertRaises (AppNotConnected, Application().window_, title = 'Hiya')
        #self.assertRaises (AppNotConnected, Application().top_window_,)
        pass

    def testStartProblem(self):
        "Verify start_ raises on unknown command"
        self.assertRaises (AppStartError, Application().start_, 'Hiya')


    def teststart_(self):
        "test start_() works correctly"
        app = Application()
        self.assertEqual(app.process, None)
        app.start_("notepad.exe")
        self.assertNotEqual(app.process, None)

        self.assertEqual(app.UntitledNotepad.ProcessID(), app.process)

        notepadpath = os.path.join(os.environ['systemroot'], r"system32\notepad.exe")
        self.assertEqual(str(process_module(app.process)).lower(), str(notepadpath).lower())

        app.UntitledNotepad.MenuSelect("File->Exit")

#    def test_start(self):
#        "test start() works correctly"
#        app = Application()
#        self.assertEqual(app.process, None)
#        app._start("notepad.exe")
#        self.assertNotEqual(app.process, None)
#
#        self.assertEqual(app.UntitledNotepad.ProcessID(), app.process)
#
#        notepadpath = os.path.join(os.environ['systemroot'], r"system32\notepad.exe")
#        self.assertEqual(str(process_module(app.process)).lower(), str(notepadpath).lower())
#
#        app.UntitledNotepad.MenuSelect("File->Exit")


    def testStart_bug01(self):
        "On SourceForge forum AppStartError forgot to include %s for application name"

        app = Application()
        self.assertEqual(app.process, None)
        application.app_start_timeout = 1
        app_name = r"I am not * and Application!/\.exe"
        try:
            app.start_(app_name)
        except AppStartError as e:
            self.assertEquals(app_name in str(e), True)


#    def testset_timing(self):
#        "Test that set_timing sets the timing correctly"
#        from pywinauto.controls import HwndWrapper
#        prev_timing = (
#            application.window_find_timeout,
#            application.window_retry_interval,
#            application.app_start_timeout,
#            application.exists_timeout,
#            application.exists_retry_interval,
#            HwndWrapper.delay_after_click,
#            HwndWrapper.delay_after_menuselect,
#            HwndWrapper.delay_after_sendkeys_key,
#            HwndWrapper.delay_after_button_click,
#            HwndWrapper.delay_before_after_close_click,
#        )
#        set_timing(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
#
#        self.assertEquals(
#            (
#                application.window_find_timeout,
#                application.window_retry_interval,
#                application.app_start_timeout,
#                application.exists_timeout,
#                application.exists_retry_interval,
#                HwndWrapper.delay_after_click,
#                HwndWrapper.delay_after_menuselect,
#                HwndWrapper.delay_after_sendkeys_key,
#                HwndWrapper.delay_after_button_click,
#                HwndWrapper.delay_before_after_close_click,
#            ), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) )
#
#        set_timing(*prev_timing)



    def testConnect_path(self):
        "Test that connect_() works with a path"
        app1 = Application()
        app1.start_("notepad.exe")

        app_conn = Application()
        app_conn.connect_(path = r"system32\notepad.exe")
        self.assertEqual(app1.process, app_conn.process)

        app_conn = Application()
        app_conn.connect_(path = r"c:\windows\system32\notepad.exe")
        self.assertEqual(app1.process, app_conn.process)

        app_conn.UntitledNotepad.MenuSelect('File->Exit')

#    def test_Connect(self):
#        "Test that connect_() works with a path"
#        app1 = Application()
#        app1.start_("notepad.exe")
#
#        app_conn = Application()
#        app_conn.connect_(path = r"system32\notepad.exe")
#        self.assertEqual(app1.process, app_conn.process)
#
#        app_conn = Application()
#        app_conn.connect_(path = r"c:\windows\system32\notepad.exe")
#        self.assertEqual(app1.process, app_conn.process)
#
#        app_conn.UntitledNotepad.MenuSelect('File->Exit')

    def testConnect_process(self):
        "Test that connect_() works with a process"
        app1 = Application()
        app1.start_("notepad.exe")

        app_conn = Application()
        app_conn.connect_(process = app1.process)
        self.assertEqual(app1.process, app_conn.process)

        app_conn.UntitledNotepad.MenuSelect('File->Exit')


    def testConnect_handle(self):
        "Test that connect_() works with a handle"
        app1 = Application()
        app1.start_("notepad.exe")
        handle = app1.UntitledNotepad.handle

        app_conn = Application()
        app_conn.connect_(handle = handle)
        self.assertEqual(app1.process, app_conn.process)

        app_conn.UntitledNotepad.MenuSelect('File->Exit')


    def testConnect_windowspec(self):
        "Test that connect_() works with a windowspec"
        app1 = Application()
        app1.start_("notepad.exe")
        handle = app1.UntitledNotepad.handle

        app_conn = Application()
        try:
            app_conn.connect_(title = "Untitled - Notepad")
        except findwindows.WindowAmbiguousError:
            wins = findwindows.find_windows(title = "Untitled - Notepad")
            app_conn.connect_(handle = wins[0])

        self.assertEqual(app1.process, app_conn.process)

        app_conn.UntitledNotepad.MenuSelect('File->Exit')

    def testConnect_raises(self):
        "Test that connect_() raises with invalid input"
        # try an argument that does not exist
        self.assertRaises (
            TypeError,
            Application().connect_, **{'not_arg': 23})

        self.assertRaises (
            RuntimeError,
            Application().connect_)

        # try to pass an invalid process
        self.assertRaises (
            ProcessNotFoundError,
            Application().connect_, **{'process': 0})

        # try to pass an invalid handle
        self.assertRaises(
            RuntimeError,
            Application().connect_, **{'handle' : 0})

        # try to pass an invalid path
        self.assertRaises(
            ProcessNotFoundError,
            Application().connect_, **{'path': "no app here"})


    def testTopWindow(self):
        "Test that top_window_() works correctly"
        app = Application()
        app.start_('notepad.exe')

        self.assertEqual(app.UntitledNotepad.handle, app.top_window_().handle)

        app.UntitledNotepad.MenuSelect("File->Page Setup")

        self.assertEqual(app.PageSetup.handle, app.top_window_().handle)

        app.PageSetup.Cancel.Click()
        app.UntitledNotepad.MenuSelect("File->Exit")


    def testWindows(self):
        "Test that windows_() works correctly"
        app = Application()

        self.assertRaises(AppNotConnected, app.windows_, **{'title' : 'not connected'})

        app.start_('notepad.exe')

        notepad_handle = app.UntitledNotepad.handle
        self.assertEquals(app.windows_(visible_only = True), [notepad_handle])

        app.UntitledNotepad.MenuSelect("File->Page Setup")

        pagesetup_handle = app.PageSetup.handle
        self.assertEquals(
            app.windows_(visible_only = True, enabled_only = False),
            [pagesetup_handle, notepad_handle])

        app.PageSetup.Cancel.Click()
        app.UntitledNotepad.MenuSelect("File->Exit")

    def testWindow(self):
        "Test that window_() works correctly"

        app = Application()
        app.start_('notepad.exe')

        title = app.window_(title = "Untitled - Notepad")
        title_re = app.window_(title_re = "Untitled[ -]+Notepad")
        classname = app.window_(class_name = "Notepad")
        classname_re = app.window_(class_name_re = "Not..ad")
        handle = app.window_(handle = title.handle)
        bestmatch = app.window_(best_match = "Untiotled Notepad")

        self.assertNotEqual(title.handle, None)
        self.assertNotEqual(title.handle, 0)

        self.assertEqual(title.handle, title_re.handle)
        self.assertEqual(title.handle, classname.handle)
        self.assertEqual(title.handle, classname_re.handle)
        self.assertEqual(title.handle, handle.handle)
        self.assertEqual(title.handle, bestmatch.handle)

        app.UntitledNotepad.MenuSelect("File->Exit")

    def testGetitem(self):
        "Test that __getitem__() works correctly"
        app = Application()
        app.start_('notepad.exe')

        try:
            app['blahblah']
        except:
            pass


        #prev_timeout = application.window_find_timeout
        #application.window_find_timeout = .1
        self.assertRaises(
            findbestmatch.MatchError,
            app['blahblah']['not here'].__getitem__, 'handle')

        self.assertEqual(
            app['Unt\xeftledNotepad'].handle,
            app.window_(title = "Untitled - Notepad").handle)

        app.UntitledNotepad.MenuSelect("File->Page Setup")

        self.assertEqual(
            app['PageSetup'].handle,
            app.window_(title = "Page Setup").handle)

        app.PageSetup.Cancel.Click()
        app.UntitledNotepad.MenuSelect("File->Exit")

        #application.window_find_timeout = prev_timeout

    def testGetattr(self):
        "Test that __getattr__() works correctly"
        app = Application()
        app.start_('notepad.exe')

        #prev_timeout = application.window_find_timeout
        #application.window_find_timeout = .1
        self.assertRaises(
            findbestmatch.MatchError,
            app.blahblah.__getattr__, 'handle')

        self.assertEqual(
            app.UntitledNotepad.handle,
            app.window_(title = "Untitled - Notepad").handle)

        app.UntitledNotepad.MenuSelect("File->Page Setup")

        # I think it's OK that this no longer raises a matcherror
        # just because the window is not enabled - doesn't mean you
        # should not be able to access it at all!
        #self.assertRaises(findbestmatch.MatchError,
        #    app.Notepad.__getattr__, 'handle')

        self.assertEqual(
            app.PageSetup.handle,
            app.window_(title = "Page Setup").handle)

        app.PageSetup.Cancel.Click()
        app.UntitledNotepad.MenuSelect("File->Exit")

        #application.window_find_timeout = prev_timeout


    def testkill_(self):
        "test killing the application"

        app = Application()
        app.start('notepad.exe')

        app.UntitledNotepad.Edit.TypeKeys("hello")

        app.UntitledNotepad.MenuSelect("File->Page Setup")

        app.PageSetup.Printer.Click()
        app.PageSetup.Network.Click()

        app.kill_()

        self.assertRaises(AttributeError, app.UntitledNotepad.Edit)




class WindowSpecificationTestCases(unittest.TestCase):
    "Unit tests for the application.Application class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""
        self.app = Application().start_("Notepad")
        self.dlgspec = self.app.UntitledNotepad
        self.ctrlspec = self.app.UntitledNotepad.Edit


    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.app.UntitledNotepad.MenuSelect("File->Exit")


    def test__init__(self):
        "Test creating a new spec by hand"

        wspec = WindowSpecification(
            dict(
                best_match = "UntitledNotepad",
                process = self.app.process)
            )

        self.assertEquals(
            wspec.WindowText(),
            "Untitled - Notepad")


    def test__call__(self):
        "Test that __call__() correctly raises an error"
        self.assertRaises(AttributeError, self.dlgspec)
        self.assertRaises(AttributeError, self.ctrlspec)

        # no best_match!
        wspec = WindowSpecification(
            dict(title = "blah", process = self.app.process) )

        self.assertRaises(AttributeError, wspec)



    def testWrapperObject(self):
        "Test that we can get a control "
        from pywinauto.controls import HwndWrapper
        self.assertEquals(True, isinstance(self.dlgspec, WindowSpecification))

        self.assertEquals(
            True,
            isinstance(self.dlgspec.WrapperObject(), HwndWrapper.HwndWrapper)
            )

    def testWindow(self):
        "test specifying a sub window of an existing specification"
        sub_spec = self.dlgspec.ChildWindow(class_name = "Edit")

        self.assertEquals(True, isinstance(sub_spec, WindowSpecification))
        self.assertEquals(sub_spec.Class(), "Edit")



    def test__getitem__(self):
        "test item access of a windowspec"

        self.assertEquals(
            True,
            isinstance(self.dlgspec['Edit'], WindowSpecification)
            )

        self.assertEquals(self.dlgspec['Edit'].Class(), "Edit")

        self.assertRaises(AttributeError, self.ctrlspec.__getitem__, 'edit')



    def testGetAttr(self):
        "Test getting attributes works correctly"

        self.assertEquals(
            True,
            isinstance(self.dlgspec.Edit, WindowSpecification)
            )

        self.assertEquals(self.dlgspec.Edit.Class(), "Edit")


        # check that getting a dialog attribute works correctly
        self.assertEquals(
            "Notepad",
            self.dlgspec.Class())




    def testExists(self):
        "Check that windows exist"

        self.assertEquals(True, self.dlgspec.Exists())
        self.assertEquals(True, self.dlgspec.Exists(0))
        self.assertEquals(True, self.ctrlspec.Exists())
        self.assertEquals(True, self.app.DefaultIME.Exists())

        self.assertEquals(False, self.app.BlahBlah.Exists(.1))

    def testExists_timing(self):
        "test the timing of the exists method"

        # try ones that should be found immediately
        start = time.time()
        self.assertEquals(True, self.dlgspec.Exists())
        self.assertEquals(True, time.time() - start < .1)

        start = time.time()
        self.assertEquals(True, self.ctrlspec.Exists())
        self.assertEquals(True, time.time() - start < .1)

        # try one that should not be found
        start = time.time()
        self.assertEquals(True, self.dlgspec.Exists(.5))
        timedif =  time.time() - start
        self.assertEquals(True, .49 > timedif < .6)


    def testWait(self):
        "test the functionality and timing of the wait method"

        allowable_error = .02

        start = time.time()
        self.assertEqual(self.dlgspec.WrapperObject(), self.dlgspec.Wait("enaBleD "))
        time_taken = (time.time() - start)
        if not 0 <= time_taken < (0 + allowable_error):
            self.assertEqual(.02,  time_taken)

        start = time.time()
        self.assertEqual(self.dlgspec.WrapperObject(), self.dlgspec.Wait("  ready"))
        self.assertEqual(True, 0 <= (time.time() - start) < 0 + allowable_error)

        start = time.time()
        self.assertEqual(self.dlgspec.WrapperObject(), self.dlgspec.Wait(" exiSTS"))
        self.assertEqual(True, 0 <= (time.time() - start) < 0 + allowable_error)

        start = time.time()
        self.assertEqual(self.dlgspec.WrapperObject(), self.dlgspec.Wait(" VISIBLE "))
        self.assertEqual(True, 0 <= (time.time() - start) < 0 + allowable_error)

        start = time.time()
        self.assertEqual(self.dlgspec.WrapperObject(), self.dlgspec.Wait(" ready enabled"))
        self.assertEqual(True, 0 <= (time.time() - start) < 0 + allowable_error)

        start = time.time()
        self.assertEqual(self.dlgspec.WrapperObject(), self.dlgspec.Wait("visible exists "))
        self.assertEqual(True, 0 <= (time.time() - start) < 0 + allowable_error)

        start = time.time()
        self.assertEqual(self.dlgspec.WrapperObject(), self.dlgspec.Wait("exists "))
        self.assertEqual(True, 0 <= (time.time() - start) < 0 + allowable_error)



    def testWaitNot(self):
        """Test that wait not fails for all the following

        * raises and error when criteria not met
        * timing is close to the timeout value"""
        allowable_error = .05

        start = time.time()
        self.assertRaises(RuntimeError, self.dlgspec.WaitNot, "enaBleD ", .1, .05)
        taken = time.time() - start
        if .1 < (taken)  > .1 + allowable_error:
            self.assertEqual(.12, taken)

        start = time.time()
        self.assertRaises(RuntimeError, self.dlgspec.WaitNot, "  ready", .1, .05)
        self.assertEqual(True, .1 <= (time.time() - start) < .1 + allowable_error)

        start = time.time()
        self.assertRaises(RuntimeError, self.dlgspec.WaitNot, " exiSTS", .1, .05)
        self.assertEqual(True, .1 <= (time.time() - start) < .1 + allowable_error)

        start = time.time()
        self.assertRaises(RuntimeError, self.dlgspec.WaitNot, " VISIBLE ", .1, .05)
        self.assertEqual(True, .1 <= (time.time() - start) < .1 + allowable_error)

        start = time.time()
        self.assertRaises(RuntimeError, self.dlgspec.WaitNot, " ready enabled", .1, .05)
        self.assertEqual(True, .1 <= (time.time() - start) < .1 + allowable_error)

        start = time.time()
        self.assertRaises(RuntimeError, self.dlgspec.WaitNot, "visible exists ", .1, .05)
        self.assertEqual(True, .1 <= (time.time() - start) < .1 + allowable_error)

        start = time.time()
        self.assertRaises(RuntimeError, self.dlgspec.WaitNot, "exists ", .1, .05)
        self.assertEqual(True, .1 <= (time.time() - start) < .1 + allowable_error)


#    def testWaitReady(self):
#        "Make sure the friendly class is set correctly"
#
#        allowable_error = .02
#
#        start = time.time()
#        self.assertEqual(self.dlgspec.ctrl_(), self.dlgspec.WaitReady(.1, .05))
#
#        # it it didn't finish in the allocated time then raise an error
#        # we assertEqual to something that we know is not right - to get a
#        # better error report
#        if not 0 <= (time.time() - start) < 0 + allowable_error:
#            self.assertEqual(0, time.time() - start)
#        #self.assertEqual(True, 0 <= (time.time() - start) < 0 + allowable_error)
#
#
#    def testWaitNotReady(self):
#        "Make sure the friendly class is set correctly"
#
#        allowable_error = .02
#
#        start = time.time()
#        self.assertRaises(RuntimeError, self.dlgspec.WaitNotReady, .1, .05)
#
#        if not .1 <= (time.time() - start) < .1 + allowable_error:
#            self.assertEqual(.1, time.time() - start)
#
#        #self.assertEqual(True, .1 <= (time.time() - start) < .1 + allowable_error)
#
#
#    def testWaitEnabled(self):
#        "Make sure the friendly class is set correctly"
#
#        allowable_error = .02
#
#        start = time.time()
#        self.assertEqual(self.dlgspec.ctrl_(), self.dlgspec.WaitEnabled(.1, .05))
#
#        if not 0 <= (time.time() - start) < 0 + allowable_error:
#            self.assertEqual(0, time.time() - start)
#
#        #self.assertEqual(True, 0 <= (time.time() - start) < 0 + allowable_error)
#
#
#    def testWaitNotEnabled(self):
#        "Make sure the friendly class is set correctly"
#
#        allowable_error = .02
#
#        start = time.time()
#        self.assertRaises(RuntimeError, self.dlgspec.WaitNotEnabled, .1, .05)
#        if not .1 <= (time.time() - start) < .1 + allowable_error:
#            self.assertEqual(.1, time.time() - start)
#        #self.assertEqual(True, .1 <= (time.time() - start) < .1 + allowable_error)
#
#    def testWaitVisible(self):
#        "Make sure the friendly class is set correctly"
#
#        allowable_error = .02
#
#        start = time.time()
#        self.assertEqual(self.dlgspec.ctrl_(), self.dlgspec.WaitVisible(.1, .05))
#        if not 0 <= (time.time() - start) < 0 + allowable_error:
#            self.assertEqual(0, time.time() - start)
#        #self.assertEqual(True, 0 <= (time.time() - start) < 0 + allowable_error)
#
#    def testWaitNotVisible(self):
#        "Make sure the friendly class is set correctly"
#
#        allowable_error = .02
#
#        start = time.time()
#        self.assertRaises(RuntimeError, self.dlgspec.WaitNotVisible, .1, .05)
#        # it it didn't finish in the allocated time then raise an error
#        # we assertEqual to something that we know is not right - to get a
#        # better error report
#        if not .1 <= (time.time() - start) < .1 + allowable_error:
#            self.assertEqual(.1, time.time() - start)
#
#    def testWaitExists(self):
#        "Make sure the friendly class is set correctly"
#
#        allowable_error = .02
#
#        start = time.time()
#        self.assertEqual(self.dlgspec.ctrl_(), self.dlgspec.WaitExists(.1, .05))
#
#        # it it didn't finish in the allocated time then raise an error
#        # we assertEqual to something that we know is not right - to get a
#        # better error report
#        if not 0 <= (time.time() - start) < 0 + allowable_error:
#            self.assertEqual(.1, time.time() - start)
#
#    def testWaitNotExists(self):
#        "Make sure the friendly class is set correctly"
#
#        allowable_error = .02
#
#        start = time.time()
#        self.assertRaises(RuntimeError, self.dlgspec.WaitNotExists, .1, .05)
#        if not .1 <= (time.time() - start) < .1 + allowable_error:
#            self.assertEqual(.1, time.time() - start)
#        #self.assertEqual(True, .1 <= (time.time() - start) < .1 + allowable_error)


    def testPrintControlIdentifiers(self):
        "Make sure the friendly class is set correctly"

        self.dlgspec.print_control_identifiers()
        self.ctrlspec.print_control_identifiers()


if __name__ == "__main__":
    #_unittests()

    unittest.main()



########NEW FILE########
__FILENAME__ = test_clipboard
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Tests for clipboard.py"

__revision__ = "$Revision: 234 $"

import unittest

import sys
sys.path.append(".")
from pywinauto.clipboard import *
from pywinauto.application import Application
from pywinauto.win32structures import RECT

import time

class ClipboardTestCases(unittest.TestCase):
    "Unit tests for the clipboard"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""
        self.app1 = Application.start("notepad.exe")
        self.app2 = Application.start("notepad.exe")

        self.app1.UntitledNotepad.MoveWindow(RECT(0, 0, 200, 200))
        self.app2.UntitledNotepad.MoveWindow(RECT(0, 200, 200, 400))


    def tearDown(self):
        "Close the application after tests"
        # close the application
        #self.dlg.SendMessage(win32defines.WM_CLOSE)
        self.app1.UntitledNotepad.MenuSelect('File -> Exit')
        if self.app1.Notepad.No.Exists():
            self.app1.Notepad.No.Click()

        self.app2.UntitledNotepad.MenuSelect('File -> Exit')
        if self.app2.Notepad.No.Exists():
            self.app2.Notepad.No.Click()


    def testGetClipBoardFormats(self):
        typetext(self.app1, "here we are")
        copytext(self.app1)

        self.assertEquals(GetClipboardFormats(), [13, 16, 1, 7])

    def testGetFormatName(self):

        self.assertEquals(
            [GetFormatName(f) for f in GetClipboardFormats()],
            ['CF_UNICODETEXT', 'CF_LOCALE', 'CF_SCREENFONTS', 'CF_OEMTEXT']
        )

    def testBug1452832(self):
        """Failing test for sourceforge bug 1452832

        Where GetData was not closing the clipboard. FIXED.
        """
        self.app1.UntitledNotepad.MenuSelect("Edit -> Select All")
        typetext(self.app1, "some text")
        copytext(self.app1)

        # was not closing the clipboard!
        data = GetData()
        self.assertEquals(data, "some text")


        self.assertEquals(gettext(self.app2), "")
        pastetext(self.app2)
        self.assertEquals(gettext(self.app2), "some text")



def gettext(app):
    return app.UntitledNotepad.Edit.Texts()[1]

def typetext(app, text):
    app.UntitledNotepad.Edit.SetEditText(text)


def copytext(app):
    app.UntitledNotepad.MenuSelect("Edit -> Select All")
    app.UntitledNotepad.MenuSelect("Edit -> Copy")

def pastetext(app):
    app.UntitledNotepad.MenuItem("Edit -> Paste").Click()

if __name__ == "__main__":
    #_unittests()

    unittest.main()



########NEW FILE########
__FILENAME__ = test_common_controls
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Tests for classes in controls\common_controls.py"

__revision__ = "$Revision: 234 $"

import sys
sys.path.append(".")
from pywinauto.controls import common_controls
from pywinauto.controls.common_controls import *
from pywinauto.win32structures import RECT
from pywinauto.controls import WrapHandle
#from pywinauto.controls.HwndWrapper import HwndWrapper
from pywinauto import findbestmatch

import ctypes

import unittest
import time
import pprint
import pdb

controlspy_folder = r"C:\_projects\py_pywinauto\controlspy0798\\"


class RemoteMemoryBlockTestCases(unittest.TestCase):
    def test__init__fail(self):
        self.assertRaises(AccessDenied, common_controls._RemoteMemoryBlock, 0)

    def test__init__fail(self):
        self.assertRaises(AccessDenied, common_controls._RemoteMemoryBlock, 0)





class ListViewTestCases(unittest.TestCase):
    "Unit tests for the ListViewWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        app = Application()
        app.start_(controlspy_folder + "List View.exe")

        self.texts = [
            ("Mercury", '57,910,000', '4,880', '3.30e23'),
            ("Venus",   '108,200,000', '12,103.6', '4.869e24'),
            ("Earth",   '149,600,000', '12,756.3', '5.9736e24'),
            ("Mars",    '227,940,000', '6,794', '6.4219e23'),
            ("Jupiter", '778,330,000', '142,984', '1.900e27'),
            ("Saturn",  '1,429,400,000', '120,536', '5.68e26'),
            ("Uranus",  '2,870,990,000', '51,118', '8.683e25'),
            ("Neptune", '4,504,000,000', '49,532', '1.0247e26'),
            ("Pluto",   '5,913,520,000', '2,274', '1.27e22'),
         ]

        self.app = app
        self.dlg = app.MicrosoftControlSpy #top_window_()
        self.ctrl = app.MicrosoftControlSpy.ListView.WrapperObject()

        #self.dlg.MenuSelect("Styles")

        # select show selection always!
        #app.ControlStyles.ListBox1.TypeKeys("{UP}" * 26 + "{SPACE}")

        #self.app.ControlStyles.ListBox1.Select("LVS_SHOWSELALWAYS")
        #self.app.ControlStyles.ApplyStylesSetWindowLong.Click()

        #self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.SendMessage(win32defines.WM_CLOSE)


    def testFriendlyClass(self):
        "Make sure the ListView friendly class is set correctly"
        self.assertEquals (self.ctrl.FriendlyClassName(), "ListView")

    def testColumnCount(self):
        "Test the ListView ColumnCount method"
        self.assertEquals (self.ctrl.ColumnCount(), 4)

    def testItemCount(self):
        "Test the ListView ItemCount method"
        self.assertEquals (self.ctrl.ItemCount(), 9)

    def testItemText(self):
        "Test the ListView item.Text property"
        item = self.ctrl.GetItem(1)

        self.assertEquals(item['text'], "Venus")

    def testItems(self):
        "Test the ListView Items method"

        flat_texts = []
        for row in self.texts:
            flat_texts.extend(row)

        for i, item in enumerate(self.ctrl.Items()):
            self.assertEquals(item['text'], flat_texts[i])

    def testTexts(self):
        "Test the ListView Texts method"

        flat_texts = []
        for row in self.texts:
            flat_texts.extend(row)

        self.assertEquals(flat_texts, self.ctrl.Texts()[1:])


    def testGetItem(self):
        "Test the ListView GetItem method"

        for row in range(self.ctrl.ItemCount()):
            for col in range(self.ctrl.ColumnCount()):
                self.assertEquals(
                    self.ctrl.GetItem(row, col)['text'], self.texts[row][col])

    def testGetItemText(self):
        "Test the ListView GetItem method - with text this time"

        for text in [row[0] for row in self.texts]:
            self.assertEquals(
                self.ctrl.GetItem(text)['text'], text)

        self.assertRaises(ValueError, self.ctrl.GetItem, "Item not in this list")

    def testColumn(self):
        "Test the ListView Columns method"

        cols = self.ctrl.Columns()
        self.assertEqual (len(cols), self.ctrl.ColumnCount())

        # TODO: add more checking of column values
        #for col in cols:
        #    print col


    def testGetSelectionCount(self):
        "Test the ListView GetSelectedCount method"

        self.assertEquals(self.ctrl.GetSelectedCount(), 0)

        self.ctrl.Select(1)
        self.ctrl.Select(7)

        self.assertEquals(self.ctrl.GetSelectedCount(), 2)


#    def testGetSelectionCount(self):
#        "Test the ListView GetSelectedCount method"
#
#        self.assertEquals(self.ctrl.GetSelectedCount(), 0)
#
#        self.ctrl.Select(1)
#        self.ctrl.Select(7)
#
#        self.assertEquals(self.ctrl.GetSelectedCount(), 2)


    def testIsSelected(self):
        "Test ListView IsSelected for some items"

        # ensure that the item is not selected
        self.assertEquals(self.ctrl.IsSelected(1), False)

        # select an item
        self.ctrl.Select(1)

        # now ensure that the item is selected
        self.assertEquals(self.ctrl.IsSelected(1), True)


    def _testFocused(self):
        "Test checking the focus of some ListView items"

        print("Select something quick!!")
        import time
        time.sleep(3)
        #self.ctrl.Select(1)

        print(self.ctrl.IsFocused(0))
        print(self.ctrl.IsFocused(1))
        print(self.ctrl.IsFocused(2))
        print(self.ctrl.IsFocused(3))
        print(self.ctrl.IsFocused(4))
        print(self.ctrl.IsFocused(5))
        #for col in cols:
        #    print col


    def testSelect(self):
        "Test ListView Selecting some items"
        self.ctrl.Select(1)
        self.ctrl.Select(3)
        self.ctrl.Select(4)

        self.assertRaises(IndexError, self.ctrl.Deselect, 23)

        self.assertEquals(self.ctrl.GetSelectedCount(), 3)


    def testSelectText(self):
        "Test ListView Selecting some items"
        self.ctrl.Select("Venus")
        self.ctrl.Select("Jupiter")
        self.ctrl.Select("Uranus")

        self.assertRaises(ValueError, self.ctrl.Deselect, "Item not in list")

        self.assertEquals(self.ctrl.GetSelectedCount(), 3)



    def testDeselect(self):
        "Test ListView Selecting some items"
        self.ctrl.Select(1)
        self.ctrl.Select(4)

        self.ctrl.Deselect(3)
        self.ctrl.Deselect(4)

        self.assertRaises(IndexError, self.ctrl.Deselect, 23)

        self.assertEquals(self.ctrl.GetSelectedCount(), 1)




    def testGetProperties(self):
        "Test getting the properties for the listview control"
        props  = self.ctrl.GetProperties()

        self.assertEquals(
            "ListView", props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(getattr(self.ctrl, prop_name)(), props[prop_name])

        self.assertEquals(props['ColumnCount'], 4)
        self.assertEquals(props['ItemCount'], 9)


    def testGetColumnTexts(self):
        self.dlg.MenuSelect("Styles")
        self.app.ControlStyles.StylesListBox.TypeKeys(
            "{HOME}" + "{DOWN}"* 12 + "{SPACE}")

        self.app.ControlStyles.ApplyStylesSetWindowLong.Click()
        self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

        self.assertEquals(self.ctrl.GetColumn(0)['text'], "Planet")
        self.assertEquals(self.ctrl.GetColumn(1)['text'], "Distance (km)")
        self.assertEquals(self.ctrl.GetColumn(2)['text'], "Diameter (km)")
        self.assertEquals(self.ctrl.GetColumn(3)['text'], "Mass (kg)")


#
#    def testSubItems(self):
#
#        for row in range(self.ctrl.ItemCount())
#
#        for i in self.ctrl.Items():
#
#            #self.assertEquals(item.Text, texts[i])





class TreeViewTestCases(unittest.TestCase):
    "Unit tests for the TreeViewWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        app = Application()
        app.start_(controlspy_folder + "Tree View.exe")

        self.root_text = "The Planets"
        self.texts = [
            ("Mercury", '57,910,000', '4,880', '3.30e23'),
            ("Venus",   '108,200,000', '12,103.6', '4.869e24'),
            ("Earth",   '149,600,000', '12,756.3', '5.9736e24'),
            ("Mars",    '227,940,000', '6,794', '6.4219e23'),
            ("Jupiter", '778,330,000', '142,984', '1.900e27'),
            ("Saturn",  '1,429,400,000', '120,536', '5.68e26'),
            ("Uranus",  '2,870,990,000', '51,118', '8.683e25'),
            ("Neptune", '4,504,000,000', '49,532', '1.0247e26'),
            ("Pluto",   '5,913,520,000', '2,274', '1.27e22'),
         ]

        self.app = app
        self.dlg = app.MicrosoftControlSpy #top_window_()
        self.ctrl = app.MicrosoftControlSpy.TreeView.WrapperObject()

        #self.dlg.MenuSelect("Styles")

        # select show selection always, and show checkboxes
        #app.ControlStyles.ListBox1.TypeKeys(
        #    "{HOME}{SPACE}" + "{DOWN}"* 12 + "{SPACE}")
        #self.app.ControlStyles.ApplyStylesSetWindowLong.Click()
        #self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.SendMessage(win32defines.WM_CLOSE)

    def testFriendlyClass(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals (self.ctrl.FriendlyClassName(), "TreeView")

    def testItemCount(self):
        "Test the TreeView ItemCount method"
        self.assertEquals (self.ctrl.ItemCount(), 37)


    def testGetItem(self):
        "Test the ItemCount method"

        self.assertRaises(RuntimeError, self.ctrl.GetItem, "test\here\please")

        self.assertRaises(IndexError, self.ctrl.GetItem, r"\test\here\please")

        self.assertEquals(
            self.ctrl.GetItem((0, 1, 2)).Text(), self.texts[1][3] + " kg")

        self.assertEquals(
            self.ctrl.GetItem(r"\The Planets\Venus\4.869").Text(), self.texts[1][3] + " kg")

        self.assertEquals(
            self.ctrl.GetItem(
                ["The Planets", "Venus", "4.869"]).Text(),
            self.texts[1][3] + " kg")


    def testItemText(self):
        "Test the ItemCount method"

        self.assertEquals(self.ctrl.Root().Text(), self.root_text)

        self.assertEquals(
            self.ctrl.GetItem((0, 1, 2)).Text(), self.texts[1][3] + " kg")

    def testSelect(self):
        "Test selecting an item"
        self.ctrl.Select((0, 1, 2))

        self.ctrl.GetItem((0, 1, 2)).State()

        self.assertEquals(True, self.ctrl.IsSelected((0, 1, 2)))


    def testEnsureVisible(self):
        "make sure that the item is visible"

        # note this is partially a fake test at the moment because
        # just by getting an item - we usually make it visible
        self.ctrl.EnsureVisible((0, 8, 2))

        # make sure that the item is not hidden
        self.assertNotEqual(None, self.ctrl.GetItem((0, 8, 2)).Rectangle())


    def testGetProperties(self):
        "Test getting the properties for the treeview control"
        props  = self.ctrl.GetProperties()

        self.assertEquals(
            "TreeView", props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(getattr(self.ctrl, prop_name)(), props[prop_name])


class HeaderTestCases(unittest.TestCase):
    "Unit tests for the Header class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        app = Application()
        app.start_(controlspy_folder + "Header.exe")

        self.texts = ['Distance', 'Diameter', 'Mass']
        self.item_rects = [
            RECT(0, 0, 90, 21),
            RECT(90, 0, 180, 21),
            RECT(180, 0, 260, 21)]
        self.app = app
        self.dlg = app.MicrosoftControlSpy
        self.ctrl = app.MicrosoftControlSpy.Header.WrapperObject()


    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.SendMessage(win32defines.WM_CLOSE)

    def testFriendlyClass(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals (self.ctrl.FriendlyClassName(), "Header")

    def testTexts(self):
        "Make sure the texts are set correctly"
        self.assertEquals (self.ctrl.Texts()[1:], self.texts)

    def testGetProperties(self):
        "Test getting the properties for the header control"
        props  = self.ctrl.GetProperties()

        self.assertEquals(
            self.ctrl.FriendlyClassName(), props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(getattr(self.ctrl, prop_name)(), props[prop_name])

    def testItemCount(self):
        self.assertEquals(3, self.ctrl.ItemCount())

    def testGetColumnRectangle(self):
        for i in range(0, 3):
            self.assertEquals(
                self.item_rects[i],
                self.ctrl.GetColumnRectangle(i))

    def testClientRects(self):
        test_rects = self.item_rects
        test_rects.insert(0, self.ctrl.ClientRect())

        self.assertEquals(
            test_rects,
            self.ctrl.ClientRects())

    def testGetColumnText(self):
        for i in range(0, 3):
            self.assertEquals(
                self.texts[i],
                self.ctrl.GetColumnText(i))




class StatusBarTestCases(unittest.TestCase):
    "Unit tests for the TreeViewWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        app = Application()
        app.start_(controlspy_folder + "Status bar.exe")

        self.texts = ["Long text", "", "Status Bar"]
        self.part_rects = [
            RECT(0, 2, 65, 20),
            RECT(67, 2, 90, 20),
            RECT(92, 2, 264, 20)]
        self.app = app
        self.dlg = app.MicrosoftControlSpy
        self.ctrl = app.MicrosoftControlSpy.StatusBar.WrapperObject()

        #self.dlg.MenuSelect("Styles")

        # select show selection always, and show checkboxes
        #app.ControlStyles.ListBox1.TypeKeys(
        #    "{HOME}{SPACE}" + "{DOWN}"* 12 + "{SPACE}")
        #self.app.ControlStyles.ApplyStylesSetWindowLong.Click()
        #self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.SendMessage(win32defines.WM_CLOSE)

    def testFriendlyClass(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals (self.ctrl.FriendlyClassName(), "StatusBar")

    def testTexts(self):
        "Make sure the texts are set correctly"
        self.assertEquals (self.ctrl.Texts()[1:], self.texts)

    def testGetProperties(self):
        "Test getting the properties for the status bar control"
        props  = self.ctrl.GetProperties()

        self.assertEquals(
            self.ctrl.FriendlyClassName(), props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(getattr(self.ctrl, prop_name)(), props[prop_name])


    def testBorderWidths(self):
        "Make sure the border widths are retrieved correctly"
        self.assertEquals (
            self.ctrl.BorderWidths(),
            dict(
                Horizontal = 0,
                Vertical = 2,
                Inter = 2,
                )
            )

    def testPartCount(self):
        "Make sure the number of parts is retrieved correctly"
        self.assertEquals (self.ctrl.PartCount(), 3)

    def testPartRightEdges(self):
        "Make sure the part widths are retrieved correctly"

        for i in range(0, self.ctrl.PartCount()-1):
            self.assertEquals (self.ctrl.PartRightEdges()[i], self.part_rects[i].right)

        self.assertEquals(self.ctrl.PartRightEdges()[i+1], -1)

    def testGetPartRect(self):
        "Make sure the part rectangles are retrieved correctly"

        for i in range(0, self.ctrl.PartCount()):
            self.assertEquals (self.ctrl.GetPartRect(i), self.part_rects[i])

        self.assertRaises(IndexError, self.ctrl.GetPartRect, 99)

    def testClientRects(self):
        self.assertEquals(self.ctrl.ClientRect(), self.ctrl.ClientRects()[0])
        self.assertEquals(self.part_rects, self.ctrl.ClientRects()[1:])

    def testGetPartText(self):
        self.assertRaises(IndexError, self.ctrl.GetPartText, 99)

        for i, text in enumerate(self.texts):
            self.assertEquals(text, self.ctrl.GetPartText(i))








class TabControlTestCases(unittest.TestCase):
    "Unit tests for the TreeViewWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        app = Application()
        app.start_(controlspy_folder + "Tab.exe")

        self.texts = [
            "Pluto", "Neptune", "Uranus",
            "Saturn", "Jupiter", "Mars",
            "Earth", "Venus", "Mercury", "Sun"]

        self.rects = [
            RECT(2,2,80,21),
            RECT(80,2,174,21),
            RECT(174,2,261,21),
            RECT(2,21,91,40),
            RECT(91,21,180,40),
            RECT(180,21,261,40),
            RECT(2,40,64,59),
            RECT(64,40,131,59),
            RECT(131,40,206,59),
            RECT(206,40,261,59),
        ]

        self.app = app
        self.dlg = app.MicrosoftControlSpy
        self.ctrl = app.MicrosoftControlSpy.TabControl.WrapperObject()

        #self.dlg.MenuSelect("Styles")

        # select show selection always, and show checkboxes
        #app.ControlStyles.ListBox1.TypeKeys(
        #    "{HOME}{SPACE}" + "{DOWN}"* 12 + "{SPACE}")
        #self.app.ControlStyles.ApplyStylesSetWindowLong.Click()
        #self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.SendMessage(win32defines.WM_CLOSE)

    def testFriendlyClass(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals (self.ctrl.FriendlyClassName(), "TabControl")

    def testTexts(self):
        "Make sure the texts are set correctly"
        self.assertEquals (self.ctrl.Texts()[1:], self.texts)

    def testGetProperties(self):
        "Test getting the properties for the tabcontrol"
        props  = self.ctrl.GetProperties()

        self.assertEquals(
            self.ctrl.FriendlyClassName(), props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(getattr(self.ctrl, prop_name)(), props[prop_name])

    def testRowCount(self):
        self.assertEquals(3, self.ctrl.RowCount())

    def testGetSelectedTab(self):
        self.assertEquals(6, self.ctrl.GetSelectedTab())
        self.ctrl.Select(0)
        self.assertEquals(0, self.ctrl.GetSelectedTab())
        self.ctrl.Select("Jupiter")
        self.assertEquals(4, self.ctrl.GetSelectedTab())

    def testTabCount(self):
        "Make sure the number of parts is retrieved correctly"
        self.assertEquals (self.ctrl.TabCount(), 10)

    def testGetTabRect(self):
        "Make sure the part rectangles are retrieved correctly"

        for i, rect in enumerate(self.rects):
            self.assertEquals (self.ctrl.GetTabRect(i), self.rects[i])

        self.assertRaises(IndexError, self.ctrl.GetTabRect, 99)

#    def testGetTabState(self):
#        self.assertRaises(IndexError, self.ctrl.GetTabState, 99)
#
#        self.dlg.StatementEdit.SetEditText ("MSG (TCM_HIGHLIGHTITEM,1,MAKELONG(TRUE,0))")
#
#        time.sleep(.3)
#        # use CloseClick to allow the control time to respond to the message
#        self.dlg.Send.CloseClick()
#        time.sleep(2)
#        print "==\n",self.ctrl.TabStates()
#
#        self.assertEquals (self.ctrl.GetTabState(1), 1)
#
#    def testTabStates(self):
#        print self.ctrl.TabStates()
#        raise "tabstates hiay"


    def testGetTabText(self):
        for i, text in enumerate(self.texts):
            self.assertEquals(text, self.ctrl.GetTabText(i))

        self.assertRaises(IndexError, self.ctrl.GetTabText, 99)

    def testClientRects(self):
        self.assertEquals(self.ctrl.ClientRect(), self.ctrl.ClientRects()[0])
        self.assertEquals(self.rects, self.ctrl.ClientRects()[1:])

    def testSelect(self):
        self.assertEquals(6, self.ctrl.GetSelectedTab())

        self.ctrl.Select(1)
        self.assertEquals(1, self.ctrl.GetSelectedTab())
        self.ctrl.Select("Mercury")
        self.assertEquals(8, self.ctrl.GetSelectedTab())

        self.assertRaises(IndexError, self.ctrl.Select, 99)






class ToolbarTestCases(unittest.TestCase):
    "Unit tests for the UpDownWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        app = Application()
        app.start_(controlspy_folder + "toolbar.exe")

        self.app = app
        self.dlg = app.MicrosoftControlSpy
        self.ctrl = app.MicrosoftControlSpy.Toolbar.WrapperObject()

        #self.dlg.MenuSelect("Styles")

        # select show selection always, and show checkboxes
        #app.ControlStyles.ListBox1.TypeKeys(
        #    "{HOME}{SPACE}" + "{DOWN}"* 12 + "{SPACE}")
        #self.app.ControlStyles.ApplyStylesSetWindowLong.Click()
        #self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.SendMessage(win32defines.WM_CLOSE)

    def testFriendlyClass(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals (self.ctrl.FriendlyClassName(), "Toolbar")

    def testTexts(self):
        "Make sure the texts are set correctly"
        for txt in self.ctrl.Texts():
            self.assertEquals (isinstance(txt, str), True)

    def testGetProperties(self):
        "Test getting the properties for the toolbar control"
        props  = self.ctrl.GetProperties()

        self.assertEquals(
            self.ctrl.FriendlyClassName(), props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        self.assertEquals(
            self.ctrl.ButtonCount(), props['ButtonCount'])

        for prop_name in props:
            self.assertEquals(getattr(self.ctrl, prop_name)(), props[prop_name])

    def testButtonCount(self):
        "Test the button count method of the toolbar"
        self.assertEquals(self.ctrl.ButtonCount(), 14)

    def testGetButton(self):
        self.assertRaises(IndexError, self.ctrl.GetButton, 29)

    def testGetButtonRect(self):
        self.assertEquals(self.ctrl.GetButtonRect(0), RECT(6, 0, 29, 22))

    def testGetToolTipsControls(self):
        tips = self.ctrl.GetToolTipsControl()

        self.assertEquals("Button ID 7" in tips.Texts(),True)

    def testPressButton(self):

        self.ctrl.PressButton(0)

        #print self.ctrl.Texts()
        self.assertRaises(
            findbestmatch.MatchError,
            self.ctrl.PressButton,
            "asdfdasfasdf")

        # todo more tests for pressbutton
        self.ctrl.PressButton("10")



class RebarTestCases(unittest.TestCase):
    "Unit tests for the UpDownWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        app = Application()
        app.start_(controlspy_folder + "rebar.exe")

        self.app = app
        self.dlg = app.MicrosoftControlSpy
        self.ctrl = app.MicrosoftControlSpy.Rebar.WrapperObject()

        #self.dlg.MenuSelect("Styles")

        # select show selection always, and show checkboxes
        #app.ControlStyles.ListBox1.TypeKeys(
        #    "{HOME}{SPACE}" + "{DOWN}"* 12 + "{SPACE}")
        #self.app.ControlStyles.ApplyStylesSetWindowLong.Click()
        #self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.SendMessage(win32defines.WM_CLOSE)

    def testFriendlyClass(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals (self.ctrl.FriendlyClassName(), "ReBar")

    def testTexts(self):
        "Make sure the texts are set correctly"
        for txt in self.ctrl.Texts():
            self.assertEquals (isinstance(txt, str), True)

    def testBandCount(self):
        self.assertEquals(self.ctrl.BandCount(), 2)

    def testGetBand(self):

        self.assertRaises(IndexError, self.ctrl.GetBand, 99)
        self.assertRaises(IndexError, self.ctrl.GetBand, 2)

        band = self.ctrl.GetBand(0)


        self.assertEquals(band.hwndChild, self.dlg.ToolBar.handle)

        #self.assertEquals(band.text, "blah")

    def testGetToolTipsControl(self):
        self.assertEquals(self.ctrl.GetToolTipsControl(), None)


class ToolTipsTestCases(unittest.TestCase):
    "Unit tests for the tooltips class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        self.texts = ['Tooltip Tool 0', 'Tooltip Tool 1', 'Tooltip Tool 2']

        # start the application
        from pywinauto.application import Application
        app = Application()
        app.start_(controlspy_folder + "Tooltip.exe")

        self.app = app
        self.dlg = app.MicrosoftControlSpy

        tips = app.windows_(
            visible_only = False,
            enabled_only = False,
            top_level_only = False,
            class_name = "tooltips_class32")

        self.ctrl = WrapHandle(tips[1])
        #self.ctrl = HwndWrapper(tips[1])


        #self.dlg.MenuSelect("Styles")

        # select show selection always, and show checkboxes
        #app.ControlStyles.ListBox1.TypeKeys(
        #    "{HOME}{SPACE}" + "{DOWN}"* 12 + "{SPACE}")
        #self.app.ControlStyles.ApplyStylesSetWindowLong.Click()
        #self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.SendMessage(win32defines.WM_CLOSE)

    def testFriendlyClass(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals (self.ctrl.FriendlyClassName(), "ToolTips")

    def testTexts(self):
        "Make sure the texts are set correctly"
        self.assertEquals (self.ctrl.Texts()[1:], self.texts)

    def testGetProperties(self):
        "Test getting the properties for the tooltips control"
        props  = self.ctrl.GetProperties()

        self.assertEquals(
            self.ctrl.FriendlyClassName(), props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(getattr(self.ctrl, prop_name)(), props[prop_name])

    def testGetTip(self):
        self.assertRaises(IndexError, self.ctrl.GetTip, 99)
        tip = self.ctrl.GetTip(1)
        self.assertEquals(tip.text, self.texts[1])

    def testToolCount(self):
        self.assertEquals(3, self.ctrl.ToolCount())

    def testGetTipText(self):
        self.assertEquals(self.texts[1], self.ctrl.GetTipText(1))

    def testTexts(self):
        self.assertEquals(self.ctrl.Texts()[0], '')
        self.assertEquals(self.ctrl.Texts()[1:], self.texts)



class UpDownTestCases(unittest.TestCase):
    "Unit tests for the UpDownWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        app = Application()
        app.start_(controlspy_folder + "Up-Down.exe")

        self.app = app
        self.dlg = app.MicrosoftControlSpy
        self.ctrl = app.MicrosoftControlSpy.UpDown2.WrapperObject()

        #self.dlg.MenuSelect("Styles")

        # select show selection always, and show checkboxes
        #app.ControlStyles.ListBox1.TypeKeys(
        #    "{HOME}{SPACE}" + "{DOWN}"* 12 + "{SPACE}")
        #self.app.ControlStyles.ApplyStylesSetWindowLong.Click()
        #self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.SendMessage(win32defines.WM_CLOSE)

    def testFriendlyClass(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals (self.ctrl.FriendlyClassName(), "UpDown")

    def testTexts(self):
        "Make sure the texts are set correctly"
        self.assertEquals (self.ctrl.Texts()[1:], [])

    def testGetProperties(self):
        "Test getting the properties for the updown control"
        props  = self.ctrl.GetProperties()

        self.assertEquals(
            self.ctrl.FriendlyClassName(), props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(getattr(self.ctrl, prop_name)(), props[prop_name])

    def testGetValue(self):
        "Test getting up-down position"
        self.assertEquals (self.ctrl.GetValue(), 0)

        self.ctrl.SetValue(23)
        self.assertEquals (self.ctrl.GetValue(), 23)

    def testSetValue(self):
        "Test setting up-down position"
        self.assertEquals (self.ctrl.GetValue(), 0)

        self.ctrl.SetValue(23)
        self.assertEquals (self.ctrl.GetValue(), 23)
        self.assertEquals(
            int(self.ctrl.GetBuddyControl().Texts()[1]),
            23)

    def testGetBase(self):
        "Test getting the base of the up-down control"
        self.assertEquals (self.ctrl.GetBase(), 10)
        self.dlg.StatementEdit.SetEditText ("MSG (UDM_SETBASE, 16, 0)")

        # use CloseClick to allow the control time to respond to the message
        self.dlg.Send.Click()

        self.assertEquals (self.ctrl.GetBase(), 16)

    def testGetRange(self):
        "Test getting the range of the up-down control"
        self.assertEquals((0, 9999), self.ctrl.GetRange())

    def testGetBuddy(self):
        "Test getting the buddy control"
        self.assertEquals (self.ctrl.GetBuddyControl().handle, self.dlg.Edit6.handle)


    def testIncrement(self):
        "Test incremementing up-down position"
        self.ctrl.Increment()
        self.assertEquals (self.ctrl.GetValue(), 1)

    def testDecrement(self):
        "Test decrementing up-down position"
        self.ctrl.SetValue(23)
        self.ctrl.Decrement()
        self.assertEquals (self.ctrl.GetValue(), 22)





if __name__ == "__main__":
    unittest.main()
########NEW FILE########
__FILENAME__ = test_findbestmatch
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Tests for findbestmatch.py"

__revision__ = "$Revision: 234 $"

import unittest
import os.path

test_path = os.path.split(__file__)[0]

import sys
sys.path.append(".")
from pywinauto import findbestmatch
from pywinauto import win32structures


class TestFindBestMatch(unittest.TestCase):

    def setUp(self):
        # load the test strings
        self.strings = open(os.path.join(test_path, "testtext.txt"), "rb").readlines()
        self.strings = (line.decode('utf-8')[:-1] for line in self.strings)

    def testclean_text_1(self):
        s = "nothingremovedhere"
        result =  findbestmatch._clean_non_chars(s)
        self.assertEqual(s, result)

    def testclean_text_2(self):
        s = "#$%#^$%&**"
        result =  findbestmatch._clean_non_chars(s)
        self.assertEqual('', result)

    def testclean_text_3(self):
        s = ""
        result =  findbestmatch._clean_non_chars(s)
        self.assertEqual('', result)


class DummyCtrl():
    def __init__(self, l, t, r, b):
        self.rect = win32structures.RECT(l, t, r, b)
    def Rectangle(self):
        return self.rect
        
class TestIsAboveOrToLeft(unittest.TestCase):
    def testSameRect(self):
        "both rectangles are the same so false"
        other = DummyCtrl(10, 20, 200, 40)
        this = DummyCtrl(10, 20, 200, 40)
        
        result = findbestmatch.IsAboveOrToLeft(this, other)
        self.assertEqual(result, False)

    def testToLeft(self):
        other = DummyCtrl(10, 20, 200, 40)
        this = DummyCtrl(100, 20, 200, 40)
        
        result = findbestmatch.IsAboveOrToLeft(this, other)
        self.assertEqual(result, True)

    def testAbove(self):
        other = DummyCtrl(10, 10, 200, 30)
        this = DummyCtrl(10, 20, 200, 40)
        
        result = findbestmatch.IsAboveOrToLeft(this, other)
        self.assertEqual(result, True)

    def testLeftAndTop(self):
        other = DummyCtrl(5, 10, 200, 20)
        this = DummyCtrl(10, 20, 200, 40)
        
        result = findbestmatch.IsAboveOrToLeft(this, other)
        self.assertEqual(result, True)

    def testBelow(self):
        other = DummyCtrl(10, 120, 200, 140)
        this = DummyCtrl(10, 20, 20, 40)
        
        result = findbestmatch.IsAboveOrToLeft(this, other)
        self.assertEqual(result, False)

    def testToRight(self):
        other = DummyCtrl(110, 20, 120, 40)
        this = DummyCtrl(10, 20, 20, 40)
        
        result = findbestmatch.IsAboveOrToLeft(this, other)
        self.assertEqual(result, False)


    def testTopLeftInSideControl(self):
        other = DummyCtrl(15, 25, 120, 40)
        this = DummyCtrl(10, 20, 20, 40)
        
        result = findbestmatch.IsAboveOrToLeft(this, other)
        self.assertEqual(result, False)


if __name__ == "__main__":

    unittest.main()



########NEW FILE########
__FILENAME__ = test_findwindows
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Tests for findwindows.py"

__revision__ = "$Revision: 234 $"

import unittest

import sys
sys.path.append(".")
from pywinauto.findwindows import *


#=========================================================================
def _unittests():
    "Do a quick test of finding some windows"
    windows = find_windows(
        class_name_re = "#32770",
        enabled_only = False,
        visible_only = False)

    for win in windows:
        print("==" * 20)
        print(handleprops.dumpwindow(win))

#class ApplicationTestCases(unittest.TestCase):
#    "Unit tests for the ListViewWrapper class"
#
#    def setUp(self):
#        """Start the application set some data and ensure the application
#        is in the state we want it."""
#        pass
#
#    def tearDown(self):
#        "Close the application after tests"
#        # close the application
#        #self.dlg.SendMessage(win32defines.WM_CLOSE)
#        pass
#
#    def testNotConnected(self):
#        "Make sure the friendly class is set correctly"
#        self.assertRaises (AppNotConnected, Application().__getattr__, 'Hiya')
#        self.assertRaises (AppNotConnected, Application().__getitem__, 'Hiya')
#        self.assertRaises (AppNotConnected, Application().window_, title = 'Hiya')
#        self.assertRaises (AppNotConnected, Application().top_window_,)
#
#    def testStartProplem(self):
#        "Make sure the friendly class is set correctly"
#        self.assertRaises (AppStartError, Application().start_, 'Hiya')
#
#    #def testStartProplem(self):
#    #    "Make sure the friendly class is set correctly"
#    #    self.assertRaises (AppStartError, Application().start_, 'Hiya')
#


if __name__ == "__main__":
    #_unittests()

    unittest.main()



########NEW FILE########
__FILENAME__ = test_handleprops
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Tests for handleprops.py"

__revision__ = "$Revision: 234 $"

import unittest

import sys
sys.path.append(".")
from pywinauto.handleprops import *
from pywinauto.application import Application


class handlepropsTestCases(unittest.TestCase):
    "Unit tests for the handleprops module"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""
        self.app = Application().start_("notepad")
        self.dlghandle = self.app.UntitledNotepad.handle
        self.edit_handle = self.app.UntitledNotepad.Edit.handle

    def tearDown(self):
        "Close the application after tests"
        # close the application
        #self.dlg.SendMessage(win32defines.WM_CLOSE)
        self.app.UntitledNotepad.MenuSelect("File->Exit")

    def test_text(self):
        "Make sure the text method returns correct result"
        self.assertEquals("Untitled - Notepad", text(self.dlghandle))
        self.assertEquals("", text(self.edit_handle))


    def test_classname(self):
        "Make sure the classname method returns correct result"
        self.assertEquals("Notepad", classname(self.dlghandle))
        self.assertEquals("Edit", classname(self.edit_handle))

    def test_parent(self):
        "Make sure the parent method returns correct result"
        self.assertEquals(0, parent(self.dlghandle))
        self.assertEquals(self.dlghandle, parent(self.edit_handle))

    def test_style(self):
        "Make sure the style method returns correct result"
        self.assertEquals(0x14cf0000, style(self.dlghandle))
        # will be 0x50300104 if wordwrap is on and 0x50200104 if off
        self.assertTrue(
            (0x50200104, 0x50300104).__contains__, 
            style(self.edit_handle),)

    def test_exstyle(self):
        "Make sure the exstyle method returns correct result"
        self.assertEquals(0x110, exstyle(self.dlghandle))
        self.assertEquals(0x200, exstyle(self.edit_handle))

    def test_controlid(self):
        "Make sure the controlid method returns correct result"
        #self.assertEquals(0, controlid(self.dlghandle))
        self.assertEquals(15, controlid(self.edit_handle))

    def test_userdata(self):
        "Make sure the userdata method returns correct result"
        self.assertEquals(0, userdata(self.dlghandle))
        self.assertEquals(0, userdata(self.edit_handle))

    def test_contexthelpid(self):
        "Make sure the contexthelpid method returns correct result"
        self.assertEquals(0, contexthelpid(self.dlghandle))
        self.assertEquals(0, contexthelpid(self.edit_handle))

    def test_iswindow(self):
        "Make sure the iswindow method returns correct result"
        self.assertEquals(True, iswindow(self.dlghandle))
        self.assertEquals(True, iswindow(self.edit_handle))

        self.assertEquals(False, iswindow(1))

    def test_isvisible(self):
        "Make sure the isvisible method returns correct result"
        self.assertEquals(True, isvisible(self.dlghandle))
        self.assertEquals(True, isvisible(self.edit_handle))

        # need to check something invisible
        #self.assertEquals(False, isvisible(self.edit_handle))

    def test_isunicode(self):
        "Make sure the isunicode method returns correct result"
        self.assertEquals(True, isunicode(self.dlghandle))
        self.assertEquals(True, isunicode(self.edit_handle))

        # need to check something not unicode
        #self.assertEquals(False, isunicode(self.edit_handle))


    def test_isenabled(self):
        "Make sure the isenabled method returns correct result"
        self.assertEquals(True, isenabled(self.dlghandle))
        self.assertEquals(True, isenabled(self.edit_handle))

        self.app.UntitledNotepad.MenuSelect("Format->Font")
        self.assertEquals(False, isenabled(self.dlghandle))
        self.app.Font.Cancel.CloseClick()

        self.app.UntitledNotepad.MenuSelect("Edit->Replace")
        self.assertEquals(
            False,
            isenabled(
                self.app.Replace.ChildWindow(
                    title_re = "Replace.*",
                    class_name = "Button",
                    enabled_only = False).handle))
        self.app.Replace.Cancel.Click()

    def test_clientrect(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals(0, clientrect(self.dlghandle).left)
        self.assertEquals(0, clientrect(self.edit_handle).left)

        self.assertEquals(0, clientrect(self.dlghandle).top)
        self.assertEquals(0, clientrect(self.edit_handle).top)

        self.assertEquals(True,
            rectangle(self.dlghandle).right > clientrect(self.dlghandle).right)
        self.assertEquals(True,
            rectangle(self.edit_handle).right > clientrect(self.edit_handle).right)

        self.assertEquals(True,
            rectangle(self.dlghandle).bottom > clientrect(self.dlghandle).bottom)
        self.assertEquals(True,
            rectangle(self.edit_handle).bottom > clientrect(self.edit_handle).bottom)



    def test_rectangle(self):
        "Make sure the friendly class is set correctly"
        dlgrect = rectangle(self.dlghandle)
        self.assertEquals(True, dlgrect.left < dlgrect.right)
        self.assertEquals(True, dlgrect.top < dlgrect.bottom)

        editrect = rectangle(self.edit_handle)
        self.assertEquals(True, editrect.left < editrect.right)
        self.assertEquals(True, editrect.top < editrect.bottom)

    def test_font(self):
        "Make sure the friendly class is set correctly"
        dlgfont = font(self.dlghandle)
        self.assertEquals(True, isinstance(dlgfont.lfFaceName, str))

        editfont = font(self.edit_handle)
        self.assertEquals(True, isinstance(editfont.lfFaceName, str))


    def test_processid(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals(self.app.process, processid(self.dlghandle))
        self.assertEquals(self.app.process, processid(self.edit_handle))

    def test_children(self):
        "Make sure the children method returns correct result"
        self.assertEquals(2,  len(children(self.dlghandle)))
        self.assertEquals([], children(self.edit_handle))

    def test_has_style(self):
        "Make sure the has_style method returns correct result"
        self.assertEquals(True,  has_style(self.dlghandle, 0xf0000))
        self.assertEquals(True, has_style(self.edit_handle, 0x4))

        self.assertEquals(False,  has_style(self.dlghandle, 4))
        self.assertEquals(False, has_style(self.edit_handle, 1))


    def test_has_exstyle(self):
        "Make sure the has_exstyle method returns correct result"
        self.assertEquals(True,  has_exstyle(self.dlghandle, 0x10))
        self.assertEquals(True, has_exstyle(self.edit_handle, 0x200))

        self.assertEquals(False,  has_exstyle(self.dlghandle, 4))
        self.assertEquals(False, has_exstyle(self.edit_handle, 0x10))

    def test_is_toplevel_window(self):
        "Make sure the friendly class is set correctly"

        self.assertEquals(True, is_toplevel_window(self.dlghandle))
        self.assertEquals(False, is_toplevel_window(self.edit_handle))

        self.app.UntitledNotepad.MenuSelect("Edit->Replace")
        self.assertEquals(True, is_toplevel_window(self.app.Replace.handle))
        self.assertEquals(False, is_toplevel_window(self.app.Replace.Cancel.handle))
        self.app.Replace.Cancel.Click()

#    def test_friendlyclassname(self):
#        "Make sure the friendly class is returned correctly"
#        self.assertEquals("Notepad", friendlyclassname(self.dlghandle))
#        self.assertEquals("Edit", friendlyclassname(self.edit_handle))
#
#        self.app.UntitledNotepad.MenuSelect("Edit->Replace")
#        self.assertEquals("Dialog", friendlyclassname(self.app.Replace.handle))
#        self.app.Replace.Cancel.Click()


    def test_dumpwindow(self):
        "Make sure the friendly class is set correctly"
        dlgdump = dumpwindow(self.dlghandle)

        for key, item in list(dlgdump.items()):
            self.assertEquals(item, globals()[key](self.dlghandle))

        editdump = dumpwindow(self.edit_handle)

        for key, item in list(editdump.items()):
            self.assertEquals(item, globals()[key](self.edit_handle))




if __name__ == "__main__":
    #_unittests()

    unittest.main()



########NEW FILE########
__FILENAME__ = test_HwndWrapper
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Tests for HwndWrapper"

import time
import pprint
import pdb
import warnings

import ctypes

import sys
sys.path.append(".")
from pywinauto.application import Application
from pywinauto.controls.HwndWrapper import HwndWrapper
from pywinauto import win32structures, win32defines


__revision__ = "$Revision: 234 $"

try:
    from pywinauto.controls.HwndWrapper import *
except ImportError:
    # allow it to be imported in a dev environment
    import sys

    pywinauto_imp = "\\".join(__file__.split('\\')[:-3])
    print("sdfdsf", pywinauto_imp)
    sys.path.append(pywinauto_imp)
    from pywinauto.controls.HwndWrapper import *

import unittest



class HwndWrapperTests(unittest.TestCase):
    "Unit tests for the TreeViewWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        self.app = Application()
        self.app.start_("calc.exe")

        self.dlg = self.app.Calculator
        self.ctrl = HwndWrapper(self.dlg.Backspace.handle)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.TypeKeys("%{F4}")


    def testInvalidHandle(self):
        "Test that an exception is raised with an invalid window handle"
        self.assertRaises(InvalidWindowHandle, HwndWrapper, -1)

    #def testText(self):
    #    "Test getting the window Text of the dialog"
    #    self.assertEquals(self.dlg.WindowText(), "Untitled - Notepad")

    def testFriendlyClassName(self):
        "Test getting the friendly classname of the dialog"
        self.assertEquals(self.ctrl.FriendlyClassName(), "Button")


    def testClass(self):
        "Test getting the classname of the dialog"
        self.assertEquals(self.ctrl.Class(), "Button")

    def testWindowText(self):
        "Test getting the window Text of the dialog"
        self.assertEquals(self.ctrl.WindowText(), "Backspace")

    def testStyle(self):

        self.dlg.Style()

        self.assertEquals(self.ctrl.Style(),
            win32defines.WS_CHILD |
            win32defines.WS_VISIBLE |
            win32defines.BS_PUSHBUTTON |
            win32defines.BS_TEXT)


    def testExStyle(self):
        self.assertEquals(self.ctrl.ExStyle(),
            win32defines.WS_EX_NOPARENTNOTIFY |
            win32defines.WS_EX_LEFT |
            win32defines.WS_EX_LTRREADING |
            win32defines.WS_EX_RIGHTSCROLLBAR)

        self.assertEquals(self.dlg.ExStyle(),
            win32defines.WS_EX_WINDOWEDGE |
            win32defines.WS_EX_LEFT |
            win32defines.WS_EX_LTRREADING |
            win32defines.WS_EX_RIGHTSCROLLBAR |
            win32defines.WS_EX_CONTROLPARENT |
            win32defines.WS_EX_APPWINDOW)

    def testControlID(self):
        self.assertEquals(self.ctrl.ControlID(), 83)
        self.dlg.ControlID()

    def testUserData(self):
        self.ctrl.UserData()
        self.dlg.UserData()

    def testContextHelpID(self):
        self.ctrl.ContextHelpID()
        self.dlg.ContextHelpID()

    def testIsVisible(self):
        self.assertEqual(self.ctrl.IsVisible(), True)
        self.assertEqual(self.dlg.IsVisible(), True)

    def testIsUnicode(self):
        self.assertEqual(self.ctrl.IsUnicode(), True)
        self.assertEqual(self.dlg.IsUnicode(), True)

    def testIsEnabled(self):
        self.assertEqual(self.ctrl.IsEnabled(), True)
        self.assertEqual(self.dlg.IsEnabled(), True)
        self.assertEqual(self.dlg.ChildWindow(
            title = 'Ave', enabled_only = False).IsEnabled(), False)

    def testCloseClick_bug(self):
        self.dlg.Sta.Click()
        Timings.closeclick_dialog_close_wait = .5
        try:
            self.app.StatisticsBox.CAD.CloseClick()
        except timings.TimeoutError:
            pass
            
        self.app.StatisticsBox.TypeKeys("%{F4}")

        #self.assertEquals(self.app.StatisticsBox.Exists(), False)


    def testRectangle(self):
        "Test getting the rectangle of the dialog"
        rect = self.dlg.Rectangle()
        self.assertNotEqual(rect.top, None)
        self.assertNotEqual(rect.left, None)
        self.assertNotEqual(rect.bottom, None)
        self.assertNotEqual(rect.right, None)

        self.assertEqual(rect.height(), 309)
        self.assertEqual(rect.width(), 480)

    def testClientRect(self):
        rect = self.dlg.Rectangle()
        cli = self.dlg.ClientRect()

        self.assertEqual(cli.left , 0)
        self.assertEqual(cli.top , 0)

        assert(cli.width() < rect.width())
        assert(cli.height() < rect.height())

    def testFont(self):
        self.assertNotEqual(self.dlg.Font(), self.ctrl.Font())

    def ProcessID(self):
        self.assertEqual(self.ctrl.ProcessID(), self.dlg.ProcessID)
        self.assertNotEqual(self.ctrl.ProcessID(), 0)

    def testHasStyle(self):
        self.assertEqual(self.ctrl.HasStyle(win32defines.WS_CHILD), True)
        self.assertEqual(self.dlg.HasStyle(win32defines.WS_CHILD), False)

        self.assertEqual(self.ctrl.HasStyle(win32defines.WS_SYSMENU), False)
        self.assertEqual(self.dlg.HasStyle(win32defines.WS_SYSMENU), True)

    def testHasExStyle(self):
        self.assertEqual(self.ctrl.HasExStyle(win32defines.WS_EX_NOPARENTNOTIFY), True)
        self.assertEqual(self.dlg.HasExStyle(win32defines.WS_EX_NOPARENTNOTIFY), False)

        self.assertEqual(self.ctrl.HasExStyle(win32defines.WS_EX_APPWINDOW), False)
        self.assertEqual(self.dlg.HasExStyle(win32defines.WS_EX_APPWINDOW), True)

    def testIsDialog(self):
        self.assertEqual(self.ctrl.IsDialog(), False)
        self.assertEqual(self.dlg.IsDialog(), True)

    def testMenuItems(self):
        self.assertEqual(self.ctrl.MenuItems(), [])
        self.assertEqual(self.dlg.MenuItems()[1]['Text'], '&View')


    def testParent(self):
        self.assertEqual(self.ctrl.Parent(), self.dlg.handle)


    def testTopLevelParent(self):
        self.assertEqual(self.ctrl.TopLevelParent(), self.dlg.handle)
        self.assertEqual(self.dlg.TopLevelParent(), self.dlg.handle)

    def testTexts(self):
        self.assertEqual(self.dlg.Texts(), ['Calculator'])
        self.assertEqual(self.ctrl.Texts(), ['Backspace'])
        self.assertEqual(self.dlg.Edit.Texts(), ['0. ', "0. "])

    def testClientRects(self):
        self.assertEqual(self.ctrl.ClientRects()[0], self.ctrl.ClientRect())
        self.assertEqual(self.dlg.ClientRects()[0], self.dlg.ClientRect())

    def testFonts(self):
        self.assertEqual(self.ctrl.Fonts()[0], self.ctrl.Font())
        self.assertEqual(self.dlg.Fonts()[0], self.dlg.Font())

    def testChildren(self):
        self.assertEqual(self.ctrl.Children(), [])
        self.assertNotEqual(self.dlg.Children(), [])


    def testIsChild(self):
        self.assertEqual(self.ctrl.IsChild(self.dlg.WrapperObject()), True)
        self.assertEqual(self.dlg.IsChild(self.ctrl), False)


    def testSendMessage(self):
        vk = self.dlg.SendMessage(win32defines.WM_GETDLGCODE)
        self.assertEqual(0, vk)

        code = self.dlg.Inv.SendMessage(win32defines.WM_GETDLGCODE)
        self.assertEqual(0, vk)


    def testSendMessageTimeout(self):

        vk = self.dlg.SendMessageTimeout(win32defines.WM_GETDLGCODE)
        self.assertEqual(0, vk)

        code = self.dlg.Inv.SendMessageTimeout(win32defines.WM_GETDLGCODE)
        self.assertEqual(0, vk)

    def testPostMessage(self):
        self.assertNotEquals(0, self.dlg.PostMessage(win32defines.WM_PAINT))
        self.assertNotEquals(0, self.dlg.Inv.PostMessage(win32defines.WM_PAINT))

#    def testNotifyMenuSelect(self):
#        "Call NotifyMenuSelect to ensure it does not raise"
#        self.ctrl.NotifyMenuSelect(1234)
#        self.dlg.NotifyMenuSelect(1234)

    def testNotifyParent(self):
        "Call NotifyParent to ensure it does not raise"
        self.ctrl.NotifyParent(1234)
        #self.dlg.NotifyParent(1234)

    def testGetProperties(self):
        "Test getting the properties for the HwndWrapped control"
        props  = self.dlg.GetProperties()

        self.assertEquals(
            self.dlg.FriendlyClassName(), props['FriendlyClassName'])

        self.assertEquals(
            self.dlg.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(getattr(self.dlg, prop_name)(), props[prop_name])

#    def testCaptureAsImage(self):
#        pass

    def testEquals(self):
        self.assertNotEqual(self.ctrl, self.dlg.handle)
        self.assertEqual(self.ctrl, self.ctrl.handle)
        self.assertEqual(self.ctrl, self.ctrl)


#    def testVerifyActionable(self):
#        self.assertRaises()

#    def testVerifyEnabled(self):
#        self.assertRaises()

#    def testVerifyVisible(self):
#        self.assertRaises()


    def testMoveWindow_same(self):
        "Test calling movewindow without any parameters"
        prevRect = self.dlg.Rectangle()
        self.dlg.MoveWindow()
        self.assertEquals(prevRect, self.dlg.Rectangle())

    def testMoveWindow(self):
        "Test moving the window"

        dlgClientRect = self.dlg.ClientAreaRect()

        prev_rect = self.ctrl.Rectangle() - dlgClientRect

        new_rect = win32structures.RECT(prev_rect)
        new_rect.left -= 1
        new_rect.top -= 1
        new_rect.right += 2
        new_rect.bottom += 2

        self.ctrl.MoveWindow(
            new_rect.left,
            new_rect.top,
            new_rect.width(),
            new_rect.height(),
            )

        self.assertEquals(
            self.ctrl.Rectangle(),
            new_rect + dlgClientRect)

        self.ctrl.MoveWindow(prev_rect)

        self.assertEquals(
            self.ctrl.Rectangle(),
            prev_rect + dlgClientRect)


    def testMaximize(self):
        self.dlg.Maximize()

        self.assertEquals(self.dlg.GetShowState(), win32defines.SW_SHOWMAXIMIZED)
        self.dlg.Restore()

    def testMinimize(self):
        self.dlg.Minimize()
        self.assertEquals(self.dlg.GetShowState(), win32defines.SW_SHOWMINIMIZED)
        self.dlg.Restore()

    def testRestore(self):
        self.dlg.Maximize()
        self.dlg.Restore()
        self.assertEquals(self.dlg.GetShowState(), win32defines.SW_SHOWNORMAL)

        self.dlg.Minimize()
        self.dlg.Restore()
        self.assertEquals(self.dlg.GetShowState(), win32defines.SW_SHOWNORMAL)

    def testGetFocus(self):
        self.assertNotEqual(self.dlg.GetFocus(), None)
        self.assertEqual(self.dlg.GetFocus(), self.ctrl.GetFocus())

        self.dlg.Hyp.SetFocus()
        self.assertEqual(self.dlg.GetFocus(), self.dlg.Hyp.handle)

    def testSetFocus(self):
        self.assertNotEqual(self.dlg.GetFocus(), self.dlg.Hyp.handle)
        self.dlg.Hyp.SetFocus()
        self.assertEqual(self.dlg.GetFocus(), self.dlg.Hyp.handle)

    def testMenuSelect(self):
        "Test selecting a menut item"

        if not self.dlg.MenuItem("View -> Digit grouping").IsChecked():
            self.dlg.MenuSelect("View -> Digit grouping")

        self.dlg.TypeKeys("1234567")
        self.dlg.MenuSelect("Edit->Copy")
        self.dlg.CE.Click()
        self.assertEquals(self.dlg.Edit.Texts()[1], "0. ")
        self.dlg.MenuSelect("Edit->Paste")
        self.assertEquals(self.dlg.Edit.Texts()[1], "1,234,567. ")

    def testClose(self):
        "Test the Close() method of windows"
        # open the statistics dialog
        try:
            self.dlg.Sta.CloseClick()
        except timings.TimeoutError:
            pass
        # make sure it is open and visible
        self.assertTrue(self.app.StatisticsBox.IsVisible(), True)

        # close it
        self.app.StatisticsBox.Close()

        # make sure that it is not visible
        self.assertRaises(AttributeError, self.app.StatisticsBox)

        # make sure the main calculator dialog is still open
        self.assertEquals(self.dlg.IsVisible(), True)



class HwndWrapperMouseTests(unittest.TestCase):
    "Unit tests for mouse actions of the HwndWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        self.app = Application()
        self.app.start_("notepad.exe")

        # Get the old font
        self.app.UntitledNotepad.MenuSelect("Format->Font")        

        self.old_font = self.app.Font.FontComboBox.SelectedIndex()
        self.old_font_style = self.app.Font.FontStyleCombo.SelectedIndex()
        
        # ensure we have the correct settings for this test
        self.app.Font.FontStyleCombo.Select(0)
        self.app.Font.FontComboBox.Select("Lucida Console")
        self.app.Font.OK.Click()

        self.dlg = self.app.UntitledNotepad
        self.ctrl = HwndWrapper(self.dlg.Edit.handle)
        self.dlg.edit.SetEditText("Here is some text\r\n and some more")

    def tearDown(self):
        "Close the application after tests"

        # Set the old font again
        self.app.UntitledNotepad.MenuSelect("Format->Font")        
        self.app.Font.FontComboBox.Select(self.old_font)
        self.app.Font.FontStyleCombo.Select(self.old_font_style)
        self.app.Font.OK.Click()

        # close the application
        self.dlg.TypeKeys("%{F4}")
        if self.app.Notepad.No.Exists():
            self.app.Notepad.No.Click()

    #def testText(self):
    #    "Test getting the window Text of the dialog"
    #    self.assertEquals(self.dlg.WindowText(), "Untitled - Notepad")


    def testClick(self):
        self.ctrl.Click(coords = (50, 10))
        self.assertEquals(self.dlg.Edit.SelectionIndices(), (5,5))

    def testClickInput(self):
        self.ctrl.ClickInput(coords = (50, 10))
        self.assertEquals(self.dlg.Edit.SelectionIndices(), (5,5))

    def testDoubleClick(self):
        self.ctrl.DoubleClick(coords = (60, 30))
        self.assertEquals(self.dlg.Edit.SelectionIndices(), (24,29))

    def testDoubleClickInput(self):
        self.ctrl.DoubleClickInput(coords = (60, 30))
        self.assertEquals(self.dlg.Edit.SelectionIndices(), (24,29))

    def testMenuSelectNotepad_bug(self):
        "In notepad - MenuSelect Edit->Paste did not work"

        text = 'Here are some unicode characters \xef\xfc\r\n'
        app2 = Application.start("notepad")
        app2.UntitledNotepad.Edit.SetEditText(text)

        app2.UntitledNotepad.MenuSelect("Edit->Select All")
        app2.UntitledNotepad.MenuSelect("Edit->Copy")

        self.dlg.MenuSelect("Edit->Select All")
        self.dlg.MenuSelect("Edit->Paste")
        self.dlg.MenuSelect("Edit->Paste")
        self.dlg.MenuSelect("Edit->Paste")

        app2.UntitledNotepad.MenuSelect("File->Exit")
        app2.Notepad.No.Click()

        self.assertEquals(self.dlg.Edit.TextBlock(), text*3)


#
#    def testRightClick(self):
#        pass
#
#    def testPressMouse(self):
#        pass
#
#    def testReleaseMouse(self):
#        pass
#
#    def testMoveMouse(self):
#        pass
#
#    def testDragMouse(self):
#        pass
#
#    def testSetWindowText(self):
#        pass
#
#    def testTypeKeys(self):
#        pass
#
#    def testDebugMessage(self):
#        pass
#
#    def testDrawOutline(self):
#        pass
#





class GetDialogPropsFromHandleTest(unittest.TestCase):
    "Unit tests for mouse actions of the HwndWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        self.app = Application()
        self.app.start_("notepad.exe")

        self.dlg = self.app.UntitledNotepad
        self.ctrl = HwndWrapper(self.dlg.Edit.handle)

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.TypeKeys("%{F4}")


    def test_GetDialogPropsFromHandle(self):
        "Test some small stuff regarding GetDialogPropsFromHandle"

        props_from_handle = GetDialogPropsFromHandle(self.dlg.handle)

        props_from_dialog = GetDialogPropsFromHandle(self.dlg)

        props_from_ctrl = GetDialogPropsFromHandle(self.ctrl)

        self.assertEquals(props_from_handle, props_from_dialog)




##====================================================================
#def _unittests():
#    "do some basic testing"
#    from pywinauto.findwindows import find_windows
#    import sys
#
#    if len(sys.argv) < 2:
#        handle = win32functions.GetDesktopWindow()
#    else:
#        try:
#            handle = int(eval(sys.argv[1]))
#
#        except ValueError:
#
#            handle = find_windows(
#                title_re = "^" + sys.argv[1],
#                class_name = "#32770",
#                visible_only = False)
#
#            if not handle:
#                print "dialog not found"
#                sys.exit()
#
#    props = GetDialogPropsFromHandle(handle)
#    print len(props)
#    #pprint(GetDialogPropsFromHandle(handle))


if __name__ == "__main__":
    unittest.main()


########NEW FILE########
__FILENAME__ = test_menuwrapper
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Tests for HwndWrapper"

import sys
sys.path.append(".")
from pywinauto.application import Application
from pywinauto.controls.HwndWrapper import HwndWrapper
from pywinauto import win32structures, win32defines
from pywinauto.controls import menuwrapper

import time
import pprint
import pdb
import ctypes

__revision__ = "$Revision: 234 $"

#try:
#    from pywinauto.controls.pywinauto import *
#except ImportError:
#    # allow it to be imported in a dev environment
#    import sys
#
#    pywinauto_imp = "\\".join(__file__.split('\\')[:-3])
#    print "sdfdsf", pywinauto_imp
#    sys.path.append(pywinauto_imp)
#    from pywinauto.controls.HwndWrapper import *

import unittest

class MenuWrapperTests(unittest.TestCase):
    "Unit tests for the TreeViewWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        self.app = Application()
        self.app.start_("Notepad.exe")

        self.dlg = self.app.Notepad

    def tearDown(self):
        "Close the application after tests"
        # close the application
        self.dlg.TypeKeys("%{F4}")


    def testInvalidHandle(self):
        "Test that an exception is raised with an invalid menu handle"
        #self.assertRaises(InvalidWindowHandle, HwndWrapper, -1)
        pass


    def testItemCount(self):
        self.assertEquals(5, self.dlg.Menu().ItemCount())

    def testItem(self):
        pass

    def testItems(self):
        pass
    def testGetProperties(self):
        pass
    def testGetMenuPath(self):
        pass
    def test__repr__(self):
        pass



if __name__ == "__main__":
    unittest.main()


########NEW FILE########
__FILENAME__ = test_SendKeys
# -*- coding: latin-1 -*-
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Module containing tests for XMLHelpers Module

>>> from SendKeys import *
>>> SendKeys("a\\r\\n")
>>> val = raw_input()
>>> print val
a
>>>
>>> SendKeys(u"ä\\r\\n")
>>> val = raw_input()
>>> print val
ä
>>>

"""

__revision__ = "$Revision: 236 $"


import sys
sys.path.append(".")
from pywinauto.SendKeysCtypes import *
#from SendKeys import *
import os
import unittest
from msvcrt import getch

class SendKeysTests(unittest.TestCase):
    "Unit tests for the Sendkeys module"

    def setUp(self):
        """Actualy does nothing!"""
        #sys.stdin.flush()
        pass

    def tearDown(self):
        "delete the file we have created"
        pass

    def __run_NormalCharacters_with_options(self, **args):
        "Make sure that sending any character in range "

        missed = []
        for i in range(32, 127):

            # skip characters that must be escaped
            if chr(i) in (' ', '%', '^', '+', '(', ')', '{', '}', '~'):
                continue

            SendKeys(chr(i) + "{ENTER}", pause = .001, **args)
            received = input()

            self.assertEquals(i, ord(received))

    # Space tests
    def testNormalWithSpaces(self):
        "Make sure that with spaces option works"
        self.__run_NormalCharacters_with_options(with_spaces = True)

    def testNormalWithoutSpaces(self):
        "Make sure that with spaces option works"
        self.__run_NormalCharacters_with_options(with_spaces = False)

    def testSpaceWithSpaces(self):
        "Make sure that with spaces option works"
        SendKeys(" \t \t {ENTER}", pause = .001, with_spaces = True)
        received = input()
        self.assertEquals("   ", received)

    def testSpaceWithoutSpaces(self):
        "Make sure that with spaces option works"
        SendKeys(" \t \t {ENTER}", pause = .001, with_spaces = False)
        received = input()
        self.assertEquals("", received)


    # Tab tests
    def testNormalWithTabs(self):
        "Make sure that with spaces option works"
        self.__run_NormalCharacters_with_options(with_tabs = True)

    def testNormalWithoutTabs(self):
        "Make sure that with spaces option works"
        self.__run_NormalCharacters_with_options(with_tabs = False)

    def testTabWithTabs(self):
        "Make sure that with spaces option works"
        SendKeys("\t \t \t{ENTER}", pause = .1, with_tabs = True)
        received = input()
        self.assertEquals("\t\t\t", received)

    def testTabWithoutTabs(self):
        "Make sure that with spaces option works"
        SendKeys("\t a\t b\t{ENTER}", pause = .1, with_tabs = False)
        received = input()
        self.assertEquals("ab", received)


    def testTab(self):
        "Make sure that with spaces option works"
        SendKeys("{TAB}  {TAB} {ENTER}", pause = .3)
        received = input()
        self.assertEquals("\t\t", received)



    # Newline tests
    def testNormalWithNewlines(self):
        "Make sure that with spaces option works"
        self.__run_NormalCharacters_with_options(with_newlines = True)

    def testNormalWithoutNewlines(self):
        "Make sure that with spaces option works"
        self.__run_NormalCharacters_with_options(with_newlines = False)

    def testNewlinesWithNewlines(self):
        "Make sure that with spaces option works"
        SendKeys("\t \t \t a~\tb\nc{ENTER}", pause = .1, with_newlines = True)
        received = input()
        self.assertEquals("a", received)
        
        received = input()
        self.assertEquals("b", received)

        received = input()
        self.assertEquals("c", received)

    def testNewlinesWithoutNewlines(self):
        "Make sure that with spaces option works"
        SendKeys("\t \t \t\na{ENTER}", pause = .01, with_newlines = False)
        received = input()
        self.assertEquals("a", received)


    def testANSIExtendedCharacters(self):
        "Make sure that sending any character in range "
        os.system("chcp 850")
        matched = 0
        extended_chars = "äëïöüáéíóúâêîôûàèìòùãõñýç"
        for char in extended_chars:

            SendKeys(char + "{ENTER}", pause = .01)
            received = input().decode("cp850")

            if char == received:
                matched += 1
            else:
                print("expected %s, recieved %s"% (
                    repr(char), repr(received)))

        self.assertEquals(matched, len(extended_chars))




#====================================================================
if __name__ == "__main__":
    unittest.main()

    #import doctest
    #doctest.testmod()



########NEW FILE########
__FILENAME__ = test_win32controls
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Tests various standard windows controls"

__revision__ = "$Revision: 234 $"

# pylint:  disable-msg=W0212,F0401,R0904

import sys
sys.path.append(".")
from pywinauto.controls.win32_controls import *
from pywinauto import XMLHelpers

import unittest

# following imports are not required for the tests
# but are useful for debugging
import pprint

from pywinauto.timings import Timings
Timings.Fast()
Timings.window_find_timeout = 5


class ButtonTestCases(unittest.TestCase):
    "Unit tests for the ComboBoxWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        self.app = Application()

        self.app.start_("calc.exe")
        self.calc = self.app.SciCalc
        self.calc.MenuSelect("View->Scientific")

    def tearDown(self):
        "Close the application after tests"

        self.calc.TypeKeys("%{F4}")

    def testGetProperties(self):
        "Test getting the properties for the button control"
        props = self.calc._6.GetProperties()

        self.assertEquals(
            "Button", props['FriendlyClassName'])

        self.assertEquals(
            self.calc._6.Texts(), ['6'])

        self.assertEquals(
            self.calc._6.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(
                getattr(self.calc._6, prop_name)(), props[prop_name])

    def test_set_if_needs_image(self):
        "test whether an image needs to be saved with the properties"
        self.assertEquals(self.calc._8._NeedsImageProp, False)

    def testFriendlyClass(self):
        "Test the FriendlyClassName method"
        self.assertEquals(self.calc._8.FriendlyClassName(), "Button")
        self.assertEquals(self.calc.Dec.FriendlyClassName(), "RadioButton")
        self.assertEquals(self.calc.Hyp.FriendlyClassName(), "CheckBox")

        children = self.calc.Children()
        no_text_buttons = [
            c for c in children
                if not c.WindowText() and c.Class() == "Button"]

        first_group = no_text_buttons[0]

        self.assertEquals(first_group.FriendlyClassName(), "GroupBox")

    def testCheckUncheck(self):
        "Test unchecking a control"

        self.calc.Inv.Check()
        self.assertEquals(self.calc.Inv.GetCheckState(), 1)
        self.calc.Inv.UnCheck()
        self.assertEquals(self.calc.Inv.GetCheckState(), 0)

    def testGetCheckState_unchecked(self):
        "unchecked"
        self.assertEquals(self.calc.Inv.GetCheckState(), 0)

    def testGetCheckState_checked(self):
        "checked"
        self.calc.Inv.Check()
        self.assertEquals(self.calc.Inv.GetCheckState(), 1)

#    def testGetCheckState_indeterminate(self):
#        "indeterminate"
#        self.calc.Inv.SetCheckIndeterminate()
#        self.assertEquals(self.calc.Inv.GetCheckState(), 0)

    def testClick(self):
        "Test clicking on buttons"
        self.calc._6.Click()
        self.calc._5.Click()
        self.calc['+'].Click()
        self.calc._4.Click()
        self.calc._3.Click()
        self.calc['='].Click()
        self.assertEquals(self.calc.Edit.Texts()[1], "108. ")

    def testIsSelected(self):
        "Test whether the control is selected or not"
        # Todo - I need to find an application where a button can be
        # selected - I don't see one in Calc at least :)
        self.assertEquals(self.calc.Hex.GetCheckState(), 0)

        self.calc.Hex.Click()

        self.assertEquals(self.calc.Hex.GetCheckState(), 1)


class ComboBoxTestCases(unittest.TestCase):
    "Unit tests for the ComboBoxWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        self.app = Application()

        self.app.start_("Notepad.exe")

        self.app.UntitledNotepad.MenuSelect("Format->Font")

        self.ctrl = self.app.Font.ComboBox2.WrapperObject()

    def tearDown(self):
        "Close the application after tests"

        self.app.Font.Cancel.CloseClick()

        # close the application
        self.app.UntitledNotepad.MenuSelect("File->Exit")

        if self.app.Notepad.No.Exists():
            self.app.Notepad.No.Click()

    def testGetProperties(self):
        "Test getting the properties for the combobox control"
        props = self.ctrl.GetProperties()

        self.assertEquals(
            "ComboBox", props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(
                getattr(self.ctrl, prop_name)(), props[prop_name])

    def testItemCount(self):
        "Test that ItemCount returns the correct number of items"
        self.assertEquals(self.ctrl.ItemCount(), 4)

    def testDroppedRect(self):
        "Test that the dropped rect is correct"
        rect = self.ctrl.DroppedRect()
        #import pdb;pdb.set_trace()
        self.assertEquals(rect.left, 0)
        self.assertEquals(rect.top, 0)
        self.assertEquals(rect.right, self.ctrl.ClientRect().right)
        self.assertEquals(rect.bottom, self.ctrl.Rectangle().height() - 3)

    def testSelectedIndex(self):
        "That the control returns the correct index for the selected item"
        self.ctrl.Select(2)
        self.assertEquals(self.ctrl.SelectedIndex(), 2)
        self.assertEquals(self.ctrl.Texts()[3], self.app.Font.Edit2.Texts()[1])

    def testSelect_negative(self):
        "Test that the Select method correctly handles negative indices"
        self.ctrl.Select(-1)
        self.assertEquals(self.ctrl.SelectedIndex(), 3)

    def testSelect_toohigh(self):
        "Test that the Select correctly raises if the item is too high"
        self.assertRaises(IndexError, self.ctrl.Select, 211)

    def testSelect_string(self):
        "Test that we can select based on a string"
        self.ctrl.Select(0)
        self.assertEquals(self.ctrl.SelectedIndex(), 0)
        self.ctrl.Select("Italic")
        self.assertEquals(self.ctrl.SelectedIndex(), 1)

        # now do it with a typo
        self.assertRaises(ValueError, self.ctrl.Select, "Bold Italc")

    def testSelect_simpleCombo(self):
        "Test selection for a simple combo"
        self.app.Font.ScriptComboBox.Select(0)
        self.assertEquals(self.app.Font.ScriptComboBox.SelectedIndex(), 0)
        self.app.Font.ScriptComboBox.Select(2)
        self.assertEquals(self.app.Font.ScriptComboBox.SelectedIndex(), 2)

    def testItemData(self):
        "Test that it doesn't raise"
        self.ctrl.ItemData(0)
        self.ctrl.ItemData(1)
        self.ctrl.ItemData("Italic")
        self.ctrl.ItemData(self.ctrl.ItemCount() - 1)

#
#    def testTexts(self):
#        pass
#

class ListBoxTestCases(unittest.TestCase):
    "Unit tests for the TreeViewWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        self.app = Application()

        self.app.start_(r"c:\Program Files\Windows NT\Accessories\wordpad.exe")
        self.app.DocumentWordPad.MenuSelect("Insert->Date and time...")
        #pdb.set_trace()

        self.dlg = self.app.DateAndTime
        self.ctrl = self.dlg.ListBox.WrapperObject()

    def tearDown(self):
        "Close the application after tests"

        self.dlg.Cancel.Click()

        # close the application
        self.app.DocumentWordPad.MenuSelect("File->Exit")

    def testGetProperties(self):
        "Test getting the properties for the listbox control"
        props = self.ctrl.GetProperties()

        self.assertEquals(
            "ListBox", props['FriendlyClassName'])

        self.assertEquals(
            self.ctrl.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(
                getattr(self.ctrl, prop_name)(), props[prop_name])

    def testItemCount(self):
        "test that the count of items is correct"
        self.assertEquals(self.ctrl.ItemCount(), 14)

    def testItemData(self):
        "For the moment - just test that it does not raise"
        self.ctrl.ItemData(1)
        self.ctrl.ItemData(self.ctrl.ItemCount() - 1)

    def testSelectedIndices(self):
        "test that the selected indices are correct"
        self.assertEquals(self.ctrl.SelectedIndices(), (0, ))
        self.ctrl.Select(2)
        self.assertEquals(self.ctrl.SelectedIndices(), (2, ))

        self.assertTrue(type(self.ctrl.SelectedIndices()) == tuple)

    def testSelect(self):
        "Test selecting an item"
        self.ctrl.Select(5)
        self.assertEquals(self.ctrl.SelectedIndices(), (5, ))

        # get the text of the 2nd item (3rd item in list
        # because of empty WindowText)
        item_to_select = self.ctrl.Texts()[2]

        self.ctrl.Select(item_to_select)
        self.assertEquals(self.ctrl.SelectedIndices(), (1, ))

    def testGetSetItemFocus(self):
        "Test setting and getting the focus of a particular item"
        self.ctrl.SetItemFocus(0)
        self.assertEquals(self.ctrl.GetItemFocus(), 0)

        self.ctrl.SetItemFocus(5)
        self.assertEquals(self.ctrl.GetItemFocus(), 5)


class EditTestCases(unittest.TestCase):
    "Unit tests for the TreeViewWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        app = Application()

        import os.path
        path = os.path.split(__file__)[0]

        test_file = os.path.join(path, "test.txt")

        self.test_data = open(test_file, "rb").read()
        # remove the BOM if it exists
        self.test_data = self.test_data.replace("\xef\xbb\xbf", "")
        self.test_data = self.test_data.decode('utf-8')

        app.start_("Notepad.exe " + test_file)

        self.app = app
        self.dlg = app.UntitledNotepad
        self.ctrl = self.dlg.Edit.WrapperObject()

        self.old_pos = self.dlg.Rectangle

        self.dlg.MoveWindow(10, 10, 400, 400)
        #self.dlg.MenuSelect("Styles")

        # select show selection always, and show checkboxes
        #app.ControlStyles.ListBox1.TypeKeys(
        #    "{HOME}{SPACE}" + "{DOWN}"* 12 + "{SPACE}")
        #self.app.ControlStyles.ApplyStylesSetWindowLong.Click()
        #self.app.ControlStyles.SendMessage(win32defines.WM_CLOSE)

    def tearDown(self):
        "Close the application after tests"

        # set it back to it's old position so not to annoy users :-)
        self.old_pos = self.dlg.Rectangle

        # close the application
        self.dlg.MenuSelect("File->Exit")

        if self.app.Notepad.No.Exists():
            self.app.Notepad.No.Click()

    def testSetText(self):
        "Test setting the text of the edit control"
        self.ctrl.SetEditText("Here is\r\nsome text")
        self.assertEquals(
            "\n".join(self.ctrl.Texts()[1:]), "Here is\nsome text")

    def testTypeKeys(self):
        "Test typing some text into the edit control"
        # typekeys types at the current caret position
        # (start when opening a new file)
        added_text = "Here is some more Text"
        self.ctrl.TypeKeys("%{HOME}" + added_text, with_spaces = True)
        expected_text = added_text + self.test_data

        self.assertEquals(self.ctrl.TextBlock(), expected_text)

    def testSelect(self):
        "Test selecting some text of the edit control"
        self.ctrl.Select(10, 50)

        self.assertEquals((10, 50), self.ctrl.SelectionIndices())

    def testLineCount(self):
        "Test getting the line count of the edit control"
        self.dlg.Maximize()
        for i in range(0, self.ctrl.LineCount()):
            self.assertEquals(
                self.ctrl.LineLength(i),
                len(self.test_data.split("\r\n")[i]))

    def testGetLine(self):
        "Test getting each line of the edit control"

        #for i in range(0, self.ctrl.LineCount()):
        #    print `self.ctrl.GetLine(i)`

        self.dlg.Maximize()
        for i, line in enumerate(self.test_data.split("\r\n")):
            #print `line`
            #print `self.ctrl.GetLine(i)`
            self.assertEquals(self.ctrl.GetLine(i), line)

    def testTextBlock(self):
        "Test getting the text block of the edit control"
        self.assertEquals(self.ctrl.TextBlock(), self.test_data)

    def testSelection(self):
        "Test selecting text in the edit control in various ways"

        self.ctrl.Select(0, 0)
        self.assertEquals((0, 0), self.ctrl.SelectionIndices())

        self.ctrl.Select()
        self.assertEquals(
            (0, len(self.test_data)), self.ctrl.SelectionIndices())

        self.ctrl.Select(10, 25)
        self.assertEquals((10, 25), self.ctrl.SelectionIndices())

        self.ctrl.Select(18, 7)
        self.assertEquals((7, 18), self.ctrl.SelectionIndices())

        txt = "\xc7a-va? Et"
        self.test_data.index(txt)

        self.ctrl.Select(txt)
        start = self.test_data.index(txt)
        end = start + len(txt)
        self.assertEquals((start, end), self.ctrl.SelectionIndices())


class DialogTestCases(unittest.TestCase):
    "Unit tests for the DialogWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        self.app = Application()

        self.app.start_("calc.exe")
        self.calc = self.app.SciCalc

        # write out the XML so that we can read it in later
        self.app.Calculator.WriteToXML("ref_controls.xml")

    def tearDown(self):
        "Close the application after tests"
        self.calc.TypeKeys("%{F4}")

    def testGetProperties(self):
        "Test getting the properties for the dialog box"
        props = self.calc.GetProperties()

        self.assertEquals(
            "SciCalc", props['FriendlyClassName'])

        self.assertEquals(self.calc.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(
                getattr(self.calc, prop_name)(), props[prop_name])

    def testRunTests(self):
        "Test running the UI tests on the dialog"
        bugs = self.calc.RunTests()
        from pywinauto.controls.HwndWrapper import HwndWrapper
        self.assertEquals(True, isinstance(bugs[0][0][0], HwndWrapper))

    def testRunTestsWithReference(self):
        "Add a ref control, get the bugs and validate that the hande "
        from pywinauto import controlproperties
        ref_controls = [controlproperties.ControlProps(ctrl) for
                ctrl in XMLHelpers.ReadPropertiesFromFile("ref_controls.xml")]

        bugs = self.calc.RunTests(ref_controls = ref_controls)
        from pywinauto import tests
        tests.print_bugs(bugs)
        from pywinauto.controls.HwndWrapper import HwndWrapper
        self.assertEquals(True, isinstance(bugs[0][0][0], HwndWrapper))

    def testWriteToXML(self):
        "Write the output and validate that it is the same as the test output"
        self.calc.WriteToXML("test_output.xml")

        all_props = [self.calc.GetProperties()]
        all_props.extend([c.GetProperties() for c in self.calc.Children()])

        props = XMLHelpers.ReadPropertiesFromFile("test_output.xml")
        for i, ctrl in enumerate(props):

            for key, ctrl_value in list(ctrl.items()):
                expected_value = all_props[i][key]
                
                if "Image" in expected_value.__class__.__name__:
                    expected_value = expected_value.tostring()
                    ctrl_value = ctrl_value.tostring()

                if isinstance(ctrl_value, (list, tuple)):
                    ctrl_value = list(ctrl_value)
                    expected_value = list(expected_value)

                self.assertEquals(ctrl_value, expected_value)

        import os
        os.unlink("test_output.xml")

    def testClientAreaRect(self):
        """Validate that the client area rect is the right size
        (comparing against the full rectangle)"""
        clientarea = self.calc.ClientAreaRect()
        self.assertEquals(self.calc.Rectangle().left + 3, clientarea.left)
        self.assertEquals(self.calc.Rectangle().top + 41, clientarea.top)
        self.assertEquals(self.calc.Rectangle().right - 3, clientarea.right)
        self.assertEquals(self.calc.Rectangle().bottom - 3, clientarea.bottom)


class PopupMenuTestCases(unittest.TestCase):
    "Unit tests for the DialogWrapper class"

    def setUp(self):
        """Start the application set some data and ensure the application
        is in the state we want it."""

        # start the application
        from pywinauto.application import Application
        self.app = Application()

        self.app.start_("notepad.exe")
        self.app.Notepad.Edit.RightClick()
        self.popup = self.app.PopupMenu.WrapperObject()

    def tearDown(self):
        "Close the application after tests"
        self.popup.TypeKeys("{ESC}")
        self.app.Notepad.TypeKeys("%{F4}")

    def testGetProperties(self):
        "Test getting the properties for the PopupMenu"
        props = self.popup.GetProperties()

        self.assertEquals(
            "PopupMenu", props['FriendlyClassName'])

        self.assertEquals(self.popup.Texts(), props['Texts'])

        for prop_name in props:
            self.assertEquals(
                getattr(self.popup, prop_name)(), props[prop_name])

    def testIsDialog(self):
        "Ensure that IsDialog works correctly"
        self.assertEquals(True, self.popup.IsDialog())

    def test_menu_handle(self):
        "Ensure that the menu handle is returned"
        handle = self.popup._menu_handle()
        self.assertNotEquals(0, handle)


if __name__ == "__main__":
    #_unittests()
    unittest.main()

########NEW FILE########
__FILENAME__ = test_win32functions
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Tests for win32functions.py"

__revision__ = "$Revision: 234 $"

import unittest

import sys
sys.path.append(".")
from pywinauto.win32functions import *

import struct


class Win32FunctionsTestCases(unittest.TestCase):
    "Unit tests for the win32function methods"

    def testMakeLong(self):
        data = (
            (0, (0, 0)),
            (1, (0, 1)),
            (0x10000, (1, 0)),
            (0xffff, (0, 0xffff)),
            (0xffff0000, (0xffff, 0)),
            (0xffffffff, (0xffff, 0xffff)),
            (0, (0x10000, 0x10000)),
        )

        for result, (hi, lo) in data:
            self.assertEquals(result, MakeLong(hi,lo))



    def testMakeLong_zero(self):
        "test that makelong(0,0)"
        self.assertEquals(0, MakeLong(0,0))

    def testMakeLong_lowone(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals(1, MakeLong(0,1))

    def testMakeLong_highone(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals(0x10000, MakeLong(1,0))

    def testMakeLong_highbig(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals(0xffff0000, MakeLong(0xffff,0))

    def testMakeLong_lowbig(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals(0xffff, MakeLong(0, 0xffff))

    def testMakeLong_big(self):
        "Make sure the friendly class is set correctly"
        self.assertEquals(0xffffffff, MakeLong(0xffff, 0xffff))


    def testLowWord_zero(self):
        self.assertEquals(0, LoWord(0))

    def testLowWord_one(self):
        self.assertEquals(1, LoWord(1))

    def testLowWord_big(self):
        self.assertEquals(1, LoWord(MakeLong(0xffff, 1)))

    def testLowWord_vbig(self):
        self.assertEquals(0xffff, LoWord(MakeLong(0xffff, 0xffff)))


    def testHiWord_zero(self):
        self.assertEquals(0, HiWord(0))

    def testHiWord_one(self):
        self.assertEquals(0, HiWord(1))

    def testHiWord_bigone(self):
        self.assertEquals(1, HiWord(0x10000))

    def testHiWord_big(self):
        self.assertEquals(0xffff, HiWord(MakeLong(0xffff, 1)))

    def testHiWord_vbig(self):
        self.assertEquals(0xffff, HiWord(MakeLong(0xffff, 0xffff)))

if __name__ == "__main__":
    unittest.main()



########NEW FILE########
__FILENAME__ = test_XMLHelpers
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Module containing tests for XMLHelpers Module"""

__revision__ = "$Revision: 236 $"

import sys
sys.path.append(".")

from pywinauto.XMLHelpers import *

import unittest

class XMLHelperTestCases(unittest.TestCase):
    "Unit tests for the ListViewWrapper class"

    def setUp(self):
        """Actually does nothing!"""
        pass

    def tearDown(self):
        "delete the file we have created"
        import os
        os.unlink("__unittests.xml")

    def assertReadWriteSame(self, props):
        "Make sure that roundtripping produces identical file"
        WriteDialogToFile("__unittests.xml", props)

        read_props = ReadPropertiesFromFile("__unittests.xml")
        self.assertEquals(props, read_props)

    def testOneUnicode(self):
        "Make sure the friendly class is set correctly"
        props = [dict(test = "hiya")]
        self.assertReadWriteSame(props)

    def testOneString(self):
        "Make sure the friendly class is set correctly"
        props = [dict(test = "hiya")]
        self.assertReadWriteSame(props)

    def testSomeEscapes(self):
        "Make sure the friendly class is set correctly"

        test_string = []
        for i in range(0, 50000):
            test_string.append(chr(i))

        test_string = "".join(test_string)

        props = [dict(test = test_string)]
        self.assertReadWriteSame(props)


    def testOneBool(self):
        "Test writing/reading Bool"
        props = [dict(test = True)]
        self.assertReadWriteSame(props)

    def testOneList(self):
        "Test writing/reading a list"
        props = [dict(test = [1, 2, 3, 4, 5, 6])]
        self.assertReadWriteSame(props)

    def testOneDict(self):
        "Make sure the friendly class is set correctly"
        props = [dict(test_value = dict(test = 1))]
        self.assertReadWriteSame(props)

    def testOneLong(self):
        "Test writing/reading one long is correct"
        props = [dict(test = 1)]
        self.assertReadWriteSame(props)

    def testLOGFONTW(self):
        "Test writing/reading one LOGFONTW is correct"
        font = LOGFONTW()
        font.lfWeight = 23
        font.lfFaceName = "wowow"
        props = [dict(test = font)]
        self.assertReadWriteSame(props)

    def testRECT(self):
        "Test writing/reading one RECT is correct"
        props = [dict(test = RECT(1, 2, 3, 4))]
        self.assertReadWriteSame(props)

    def testTwoLong(self):
        "Test writing/reading two longs is correct"
        props = [dict(test = 1), dict(test_blah = 2)]
        self.assertReadWriteSame(props)

    def testEmptyList(self):
        "Test writing/reading empty list"
        props = [dict(test = [])]
        self.assertReadWriteSame(props)

    def testEmptyDict(self):
        "Test writing/reading empty dict"
        props = [dict(test = {})]
        self.assertReadWriteSame(props)


#====================================================================
if __name__ == "__main__":
    unittest.main()



########NEW FILE########
__FILENAME__ = win32defines
# generated by 'xml2py'
# flags 'commctrl.xml -d -w -kde -v -o win32defines.py'

"Definition of Windows defines"

__revision__ = "$Revision: 669 $"

from ctypes import c_int


VFT_FONT = 4 # Variable c_long
WS_GROUP = 131072 # Variable c_long
REGCLS_SURROGATE = 8
VIEW_E_DRAW = -2147221184 # Variable c_long
WM_POWERBROADCAST = 536 # Variable c_int
TCM_GETITEMW = 4924 # Variable c_int
CBF_FAIL_POKES = 65536 # Variable c_int
WA_INACTIVE = 0 # Variable c_int
CTRY_IRELAND = 353 # Variable c_int
SECURITY_DESCRIPTOR_REVISION1 = 1 # Variable c_int
WM_PSD_GREEKTEXTRECT = 1028 # Variable c_int
BAUD_57600 = 262144 # Variable c_ulong
IMAGE_REL_BASED_MIPS_JMPADDR = 5 # Variable c_int
LB_SETANCHORINDEX = 412 # Variable c_int
MM_WIM_OPEN = 958 # Variable c_int
FOURCC_LIST = 1414744396 # Variable c_ulong
SCS_32BIT_BINARY = 0 # Variable c_int
VFT_DLL = 2 # Variable c_long
ARW_BOTTOMRIGHT = 1 # Variable c_long
CBEM_GETITEMW = 1037 # Variable c_int
IMPORT_OBJECT_NAME_UNDECORATE = 3
CAL_KOREA = 5 # Variable c_int
TTM_HITTESTW = 1079 # Variable c_int
SND_RESOURCE = 262148 # Variable c_long
TBM_GETCHANNELRECT = 1050 # Variable c_int
IMAGE_SYM_TYPE_VOID = 1 # Variable c_int

_SECURITY_IMPERSONATION_LEVEL = c_int # enum
SecurityAnonymous = 0
SecurityIdentification = 1
SecurityImpersonation = 2
SecurityDelegation = 3
TMPF_TRUETYPE = 4 # Variable c_int
PAN_STROKE_GRADUAL_VERT = 4 # Variable c_int
WNNC_NET_AS400 = 720896 # Variable c_int
TC_CR_ANY = 16 # Variable c_int
PAN_STROKE_GRADUAL_TRAN = 3 # Variable c_int
cmb13 = 1148 # Variable c_int
ERROR_DEVICE_DOOR_OPEN = 1166 # Variable c_long
HKEY_CLASSES_ROOT = 2147483648 # Variable POINTER(HKEY__)
OLEOBJ_S_CANNOT_DOVERB_NOW = 262529 # Variable c_long
JobObjectBasicAccountingInformation = 1
SZDDE_ITEM_ITEMLIST = 'TopicItemList' # Variable POINTER(c_wchar)
CO_E_LOOKUPACCNAMEFAILED = -2147220977 # Variable c_long
TB_BUTTONSTRUCTSIZE = 1054 # Variable c_int
META_POLYLINE = 805 # Variable c_int
FS_CYRILLIC = 4 # Variable c_long
FUNC_STATIC = 3
stc5 = 1092 # Variable c_int
S_SERDSH = -11 # Variable c_int
DMPAPER_FANFOLD_STD_GERMAN = 40 # Variable c_int
SND_ASYNC = 1 # Variable c_int
MAX_DEFAULTCHAR = 2 # Variable c_int
PROCESS_VM_OPERATION = 8 # Variable c_int
TIME_SMPTE = 8 # Variable c_int
FOREGROUND_BLUE = 1 # Variable c_int
SELECTDIB = 41 # Variable c_int
JOB_OBJECT_UILIMIT_HANDLES = 1 # Variable c_int
MM_DRVM_ERROR = 979 # Variable c_int
TVM_SETSCROLLTIME = 4385 # Variable c_int
CF_SYLK = 4 # Variable c_int
WSAECONNREFUSED = 10061 # Variable c_int
HELP_QUIT = 2 # Variable c_long
STN_DBLCLK = 1 # Variable c_int
SBM_GETPOS = 225 # Variable c_int
DOWNLOADFACE = 514 # Variable c_int
ARW_STARTMASK = 3 # Variable c_long
WM_QUERYNEWPALETTE = 783 # Variable c_int
LANG_PORTUGUESE = 22 # Variable c_int
STGFMT_ANY = 4 # Variable c_int
LVN_ITEMCHANGED = 4294967195 # Variable c_uint
WAVE_INVALIDFORMAT = 0 # Variable c_int
XST_EXECSENT = 9 # Variable c_int
COMPRESSION_ENGINE_MAXIMUM = 256 # Variable c_int
SC_MANAGER_MODIFY_BOOT_CONFIG = 32 # Variable c_int
RT_DLGINCLUDE = 23 # Variable POINTER(c_wchar)
HSHELL_ACTIVATESHELLWINDOW = 3 # Variable c_int
LOGPIXELSX = 88 # Variable c_int
TYPEFLAG_FRESTRICTED = 512
SERVICE_NO_CHANGE = 4294967295 # Variable c_uint
LVCOLUMNA_V1_SIZE = 24 # Variable c_uint
PIPE_WAIT = 0 # Variable c_int
ERROR_HOST_NODE_NOT_GROUP_OWNER = 5016 # Variable c_long
STARTF_USEHOTKEY = 512 # Variable c_int
EMR_HEADER = 1 # Variable c_int
MCI_VD_GETDEVCAPS_NORMAL_RATE = 16389 # Variable c_long
SPLREG_DEFAULT_SPOOL_DIRECTORY = 'DefaultSpoolDirectory' # Variable POINTER(c_wchar)
stc16 = 1103 # Variable c_int
LVNI_CUT = 4 # Variable c_int
LVM_SETHOTITEM = 4156 # Variable c_int
PAN_WEIGHT_BLACK = 10 # Variable c_int
CTRY_GREECE = 30 # Variable c_int
DT_DISPFILE = 6 # Variable c_int
PSINJECT_BOUNDINGBOX = 24 # Variable c_int
SB_SETMINHEIGHT = 1032 # Variable c_int
edt3 = 1154 # Variable c_int
NO_PROPAGATE_INHERIT_ACE = 4 # Variable c_int
ERROR_FLOPPY_WRONG_CYLINDER = 1123 # Variable c_long
DS_LOCALEDIT = 32 # Variable c_long
WM_FONTCHANGE = 29 # Variable c_int
TBSTYLE_TRANSPARENT = 32768 # Variable c_int
lst7 = 1126 # Variable c_int
MIXERLINE_COMPONENTTYPE_DST_VOICEIN = 8 # Variable c_long
AF_PUP = 4 # Variable c_int
IMAGE_REL_SH3_DIRECT4_LONG = 8 # Variable c_int
WM_ENDSESSION = 22 # Variable c_int
VARFLAG_FDEFAULTBIND = 32
SM_CXMINTRACK = 34 # Variable c_int
R2_NOTMERGEPEN = 2 # Variable c_int
EM_GETWORDBREAKPROC = 209 # Variable c_int
RPC_C_PROTECT_LEVEL_PKT = 4 # Variable c_int
WGL_SWAP_UNDERLAY5 = 1048576 # Variable c_int
RGN_DIFF = 4 # Variable c_int
SPLDS_PRINT_OWNER = 'printOwner' # Variable POINTER(c_wchar)
VK_F9 = 120 # Variable c_int
PAN_STROKE_INSTANT_VERT = 8 # Variable c_int
JOY_BUTTON23 = 4194304 # Variable c_long
JOB_CONTROL_RESUME = 2 # Variable c_int
LVIF_NORECOMPUTE = 2048 # Variable c_int
MNC_SELECT = 3 # Variable c_int
SM_CYMIN = 29 # Variable c_int
LR_COPYFROMRESOURCE = 16384 # Variable c_int
DDE_FACKREQ = 32768 # Variable c_int
WSB_PROP_VBKGCOLOR = 64 # Variable c_long
NORM_IGNORESYMBOLS = 4 # Variable c_int
SORT_GEORGIAN_MODERN = 1 # Variable c_int
UI_CAP_2700 = 1 # Variable c_int
VK_F18 = 129 # Variable c_int
ico4 = 1087 # Variable c_int
TOKEN_WRITE = 131296 # Variable c_long
MCI_VD_FORMAT_TRACK = 16385 # Variable c_int
C3_NOTAPPLICABLE = 0 # Variable c_int
DMPAPER_B5 = 13 # Variable c_int
FADF_RESERVED = 61448 # Variable c_int
SPLREG_EVENT_LOG = 'EventLog' # Variable POINTER(c_wchar)
OFN_NONETWORKBUTTON = 131072 # Variable c_int
DRAGDROP_E_LAST = 2147746063 # Variable c_ulong
TBN_GETINFOTIPA = 4294966578 # Variable c_uint
IDHOT_SNAPWINDOW = -1 # Variable c_int
SORT_KOREAN_KSC = 0 # Variable c_int
JOY_BUTTON25 = 16777216 # Variable c_long
URLACTION_HTML_MIN = 5632 # Variable c_int
psh2 = 1025 # Variable c_int
PGK_CONTROL = 2 # Variable c_int
PST_MODEM = 6 # Variable c_ulong
DATA_S_LAST = 262463 # Variable c_long
LF_FULLFACESIZE = 64 # Variable c_int
ERROR_SET_NOT_FOUND = 1170 # Variable c_long
MIXER_OBJECTF_HANDLE = 2147483648 # Variable c_ulong
CBR_1200 = 1200 # Variable c_int
WNNC_NET_LANTASTIC = 655360 # Variable c_int
SO_DISCOPTLEN = 28679 # Variable c_int
CTRY_KUWAIT = 965 # Variable c_int
ILLUMINANT_A = 1 # Variable c_int
IMAGE_SYM_CLASS_END_OF_FUNCTION = 255 # Variable c_ubyte
OLEUPDATE_ALWAYS = 1
MM_WIM_CLOSE = 959 # Variable c_int
WM_CHAR = 258 # Variable c_int
CONNECT_UPDATE_RECENT = 2 # Variable c_int
OF_PARSE = 256 # Variable c_int
NRC_NAMTFUL = 14 # Variable c_int
ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = 3005 # Variable c_long
ERROR_INSTALL_FAILURE = 1603 # Variable c_long
AC_DST_NO_PREMULT_ALPHA = 16 # Variable c_int
UDN_FIRST = 4294966575 # Variable c_uint
MIDICAPS_VOLUME = 1 # Variable c_int
ERROR_UNKNOWN_PRINT_MONITOR = 3000 # Variable c_long
CS_DBLCLKS = 8 # Variable c_int
RPC_C_AUTHN_DCE_PUBLIC = 2 # Variable c_int
VK_NUMPAD0 = 96 # Variable c_int
ERROR_DDE_FAIL = 1156 # Variable c_long
LANG_SPANISH = 10 # Variable c_int
ENHMETA_STOCK_OBJECT = 2147483648 # Variable c_uint
META_BITBLT = 2338 # Variable c_int
DBG_EXCEPTION_NOT_HANDLED = 2147549185 # Variable c_ulong
WM_SYNCPAINT = 136 # Variable c_int
VK_NUMPAD1 = 97 # Variable c_int
JOB_CONTROL_RESTART = 4 # Variable c_int
DROPEFFECT_MOVE = 2 # Variable c_int
IMAGE_REL_PPC_REFLO = 17 # Variable c_int
BINDSTATUS_BEGINUPLOADDATA = 17
SCREEN_FONTTYPE = 8192 # Variable c_int
MCI_OPEN = 2051 # Variable c_int
MCIERR_MULTIPLE = 280 # Variable c_int
SS_ETCHEDFRAME = 18 # Variable c_long
VK_NUMPAD2 = 98 # Variable c_int
PAN_LETT_OBLIQUE_BOXED = 11 # Variable c_int
ERROR_CLUSTERLOG_CORRUPT = 5029 # Variable c_long
ico1 = 1084 # Variable c_int
VK_NUMPAD3 = 99 # Variable c_int
MDMSPKRFLAG_ON = 4 # Variable c_int
CHANGEKIND_DELETEMEMBER = 1
BINDSTATUS_DOWNLOADINGDATA = 5
ENUMPAPERMETRICS = 34 # Variable c_int
LVS_SMALLICON = 2 # Variable c_int
CRYPT_E_NO_VERIFY_USAGE_DLL = -2146885593 # Variable c_long
ERROR_REPARSE_ATTRIBUTE_CONFLICT = 4391 # Variable c_long
LVM_GETITEMPOSITION = 4112 # Variable c_int
MDMVOLFLAG_MEDIUM = 2 # Variable c_int
MMIO_DIRTY = 268435456 # Variable c_int
PERF_DATA_REVISION = 1 # Variable c_int
TBCD_TICS = 1 # Variable c_int
ERROR_INVALID_EVENTNAME = 1211 # Variable c_long
WSAEMSGSIZE = 10040 # Variable c_int
IMAGE_REL_IA64_DIR32NB = 16 # Variable c_int
CB_GETCURSEL = 327 # Variable c_int
MM_STREAM_DONE = 982 # Variable c_int
MNC_EXECUTE = 2 # Variable c_int
C3_KASHIDA = 512 # Variable c_int
WM_PSD_PAGESETUPDLG = 1024 # Variable c_int
WS_CHILDWINDOW = 1073741824 # Variable c_long
ENUM_S_FIRST = 262576 # Variable c_long
PSH_USEHBMHEADER = 1048576 # Variable c_int
POSTSCRIPT_IDENTIFY = 4117 # Variable c_int
IMAGE_REL_IA64_SECREL22 = 12 # Variable c_int
TVN_FIRST = 4294966896 # Variable c_uint
NRC_OPENERR = 63 # Variable c_int
TTN_POP = 4294966774 # Variable c_uint
ERROR_CLASS_HAS_WINDOWS = 1412 # Variable c_long
TCM_INSERTITEMA = 4871 # Variable c_int
MIDIERR_NOTREADY = 67 # Variable c_int
GWL_HWNDPARENT = -8 # Variable c_int
CTRY_IRAN = 981 # Variable c_int
CDM_LAST = 1224 # Variable c_int
LOCALE_SABBREVMONTHNAME6 = 73 # Variable c_int
IMAGE_SYM_CLASS_ENUM_TAG = 15 # Variable c_int
PRINTER_NOTIFY_FIELD_DATATYPE = 11 # Variable c_int
EM_EMPTYUNDOBUFFER = 205 # Variable c_int
TVI_ROOT = 4294901760 # Variable POINTER(_TREEITEM)
PERF_RAW_FRACTION = 537003008 # Variable c_int
PRINTER_ENUM_ICON2 = 131072 # Variable c_int
CBEM_HASEDITCHANGED = 1034 # Variable c_int
QUERY_USES_NETWORK = 8
SE_SACL_AUTO_INHERIT_REQ = 512 # Variable c_int
HEAP_NO_SERIALIZE = 1 # Variable c_int
URLPOLICY_CREDENTIALS_SILENT_LOGON_OK = 0 # Variable c_int
PRINTER_HTML_VIEW_JOBPROPERTIES = 3 # Variable c_int
STUB_UNMARSHAL = 0
MMIO_FINDRIFF = 32 # Variable c_int
LOGON32_PROVIDER_WINNT35 = 1 # Variable c_int
MOVEFILE_REPLACE_EXISTING = 1 # Variable c_int
SECURITY_WORLD_RID = 0 # Variable c_long
TAPE_SPACE_SETMARKS = 8 # Variable c_long
CM_IN_GAMUT = 0 # Variable c_int
TBM_GETPOS = 1024 # Variable c_int
MCI_SEQ_MAPPER = 65535 # Variable c_int
WM_CHOOSEFONT_GETLOGFONT = 1025 # Variable c_int
IMAGE_REL_PPC_TOCREL14 = 9 # Variable c_int
VK_NUMLOCK = 144 # Variable c_int
IMAGE_FILE_MACHINE_ALPHA = 388 # Variable c_int
DCBA_FACEUPLEFT = 2 # Variable c_int
USERCLASSTYPE_APPNAME = 3
ISC_SHOWUICOMPOSITIONWINDOW = 2147483648 # Variable c_uint
RPC_C_AUTHN_DPA = 16 # Variable c_int
MF_MOUSESELECT = 32768 # Variable c_long
TBS_TOP = 4 # Variable c_int
MK_E_CANTOPENFILE = -2147221014 # Variable c_long
WM_SIZE = 5 # Variable c_int
WM_USER = 1024 # Variable c_int
DCOM_NONE = 0
PIDSI_DOC_SECURITY = 19 # Variable c_long
DMPAPER_A3_EXTRA = 63 # Variable c_int
PARITY_MARK = 2048 # Variable c_ushort
CF_FIXEDPITCHONLY = 16384 # Variable c_long
VARCMP_EQ = 1 # Variable c_int
stc17 = 1104 # Variable c_int
PDERR_RETDEFFAILURE = 4099 # Variable c_int
ERROR_DECRYPTION_FAILED = 6001 # Variable c_long
RT_ACCELERATOR = 9 # Variable POINTER(c_wchar)
TYSPEC_CLSID = 0
LVNI_ABOVE = 256 # Variable c_int
CCM_GETUNICODEFORMAT = 8198 # Variable c_int
LVNI_DROPHILITED = 8 # Variable c_int
ERROR_ARITHMETIC_OVERFLOW = 534 # Variable c_long
SUBLANG_GERMAN_SWISS = 2 # Variable c_int
CHANGEKIND_MAX = 7
CBEN_BEGINEDIT = 4294966492 # Variable c_uint
cmb11 = 1146 # Variable c_int
_MAX_DIR = 256 # Variable c_int
HC_ACTION = 0 # Variable c_int
MK_ALT = 32 # Variable c_int
RPC_S_PROTSEQ_NOT_SUPPORTED = 1703 # Variable c_long
PSN_WIZBACK = 4294967090 # Variable c_uint
DRAGDROP_S_CANCEL = 262401 # Variable c_long
LANG_UKRAINIAN = 34 # Variable c_int
LC_NONE = 0 # Variable c_int
CO_E_INIT_UNACCEPTED_USER_ALLOCATOR = -2147467251 # Variable c_long
STATUS_NONCONTINUABLE_EXCEPTION = 3221225509 # Variable c_ulong
RTS_CONTROL_ENABLE = 1 # Variable c_int
NMTTDISPINFOW_V1_SIZE = 184 # Variable c_uint
WM_CANCELMODE = 31 # Variable c_int
IPM_CLEARADDRESS = 1124 # Variable c_int
WGL_FONT_LINES = 0 # Variable c_int
FADF_STATIC = 2 # Variable c_int
ERROR_INVALID_CMM = 2300 # Variable c_long
JOY_BUTTON32 = 2147483648 # Variable c_ulong
TVHT_ONITEMICON = 2 # Variable c_int
DUPLICATE_SAME_ACCESS = 2 # Variable c_int
SM_CYMINIMIZED = 58 # Variable c_int
stc8 = 1095 # Variable c_int
CIP_OLDER_VERSION_EXISTS = 3
MONTHCAL_CLASSA = 'SysMonthCal32' # Variable POINTER(c_char)
META_DIBCREATEPATTERNBRUSH = 322 # Variable c_int
IMAGE_FILE_MACHINE_R3000 = 354 # Variable c_int
ICM_OFF = 1 # Variable c_int
ERROR_INVALID_FORM_NAME = 1902 # Variable c_long
cmb16 = 1151 # Variable c_int
AUXCAPS_VOLUME = 1 # Variable c_int
MCI_DEVTYPE_OTHER = 521 # Variable c_int
TlbNamePath = 2
DMPAPER_FANFOLD_LGL_GERMAN = 41 # Variable c_int
MONTHCAL_CLASSW = 'SysMonthCal32' # Variable POINTER(c_wchar)
MAXCHAR = 127 # Variable c_int
LVIF_TEXT = 1 # Variable c_int
HEBREW_CHARSET = 177 # Variable c_int
CBEIF_IMAGE = 2 # Variable c_int
ERROR_NO_TRUST_LSA_SECRET = 1786 # Variable c_long
IDLFLAG_FRETVAL = 8 # Variable c_int

IMPORT_OBJECT_TYPE = c_int # enum
IMPORT_OBJECT_CODE = 0
IMPORT_OBJECT_DATA = 1
IMPORT_OBJECT_CONST = 2
XTYPF_NOBLOCK = 2 # Variable c_int
CDS_TEST = 2 # Variable c_int
CALLTYPE_ASYNC_CALLPENDING = 5
NTM_MM_INSTANCE = 524288 # Variable c_int
CBN_EDITCHANGE = 5 # Variable c_int
PRINTER_STATUS_WAITING = 8192 # Variable c_int
DOMAIN_GROUP_RID_GUESTS = 514 # Variable c_long
RPC_E_ATTEMPTED_MULTITHREAD = -2147417854 # Variable c_long
ERROR_CONNECTED_OTHER_PASSWORD = 2108 # Variable c_long
ERROR_CONTROL_ID_NOT_FOUND = 1421 # Variable c_long
NCBLANSTALERT = 115 # Variable c_int
ERROR_IO_DEVICE = 1117 # Variable c_long

tagSTGC = c_int # enum
STGC_DEFAULT = 0
STGC_OVERWRITE = 1
STGC_ONLYIFCURRENT = 2
STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
STGC_CONSOLIDATE = 8
ACCESS_DS_SOURCE_W = 'DS' # Variable POINTER(c_wchar)
RPC_C_EP_MATCH_BY_IF = 1 # Variable c_int
R2_NOTCOPYPEN = 4 # Variable c_int
PRINTER_ENUM_CONTAINER = 32768 # Variable c_int
DISP_E_BADCALLEE = -2147352560 # Variable c_long
JobObjectBasicLimitInformation = 2
MF_POPUP = 16 # Variable c_long
META_SETBKMODE = 258 # Variable c_int
TOOLTIPS_CLASSW = 'tooltips_class32' # Variable POINTER(c_wchar)
SPI_SETDOUBLECLKHEIGHT = 30 # Variable c_int
FUNC_DISPATCH = 4
DISP_CHANGE_NOTUPDATED = -3 # Variable c_int
DLGC_BUTTON = 8192 # Variable c_int
RBBS_HIDDEN = 8 # Variable c_int
STARTF_USEPOSITION = 4 # Variable c_int
SECURITY_CREATOR_OWNER_SERVER_RID = 2 # Variable c_long
TVM_GETISEARCHSTRINGA = 4375 # Variable c_int
DEFAULT_PALETTE = 15 # Variable c_int
HELP_FINDER = 11 # Variable c_int
PAGE_GUARD = 256 # Variable c_int
EMARCH_ENC_I17_SIGN_INST_WORD_X = 3 # Variable c_int
CTRY_KENYA = 254 # Variable c_int
VFT2_DRV_DISPLAY = 4 # Variable c_long
SERVICE_DISABLED = 4 # Variable c_int
BF_DIAGONAL_ENDTOPRIGHT = 22 # Variable c_int
CERT_E_REVOKED = -2146762484 # Variable c_long
IMAGE_SYM_TYPE_UNION = 9 # Variable c_int
WM_MDICASCADE = 551 # Variable c_int
LANG_ROMANIAN = 24 # Variable c_int
FILE_TYPE_REMOTE = 32768 # Variable c_int
META_SETROP2 = 260 # Variable c_int
ERROR_LUIDS_EXHAUSTED = 1334 # Variable c_long
RPCFLG_AUTO_COMPLETE = 134217728 # Variable c_ulong
MCI_INFO_MEDIA_UPC = 1024 # Variable c_long
SOFTDIST_ADSTATE_INSTALLED = 3 # Variable c_int
HDM_SETIMAGELIST = 4616 # Variable c_int
LB_SETITEMDATA = 410 # Variable c_int
MCI_FROM = 4 # Variable c_long
CTRY_PERU = 51 # Variable c_int
BM_SETIMAGE = 247 # Variable c_int
SERVICE_CONFIG_FAILURE_ACTIONS = 2 # Variable c_int
SPLDS_PRINT_MEDIA_SUPPORTED = 'printMediaSupported' # Variable POINTER(c_wchar)
MCM_SETCOLOR = 4106 # Variable c_int
WM_QUERYDRAGICON = 55 # Variable c_int
LOGPIXELSY = 90 # Variable c_int
TYPEFLAG_FAGGREGATABLE = 1024
IMAGE_REL_SH3_DIRECT32_NB = 16 # Variable c_int
MWMO_ALERTABLE = 2 # Variable c_int
MCI_DEVTYPE_VCR = 513 # Variable c_int
S_SERDLN = -6 # Variable c_int
BSM_INSTALLABLEDRIVERS = 4 # Variable c_int
LVM_SETBKIMAGEW = 4234 # Variable c_int
FILE_FLAG_DELETE_ON_CLOSE = 67108864 # Variable c_int
META_SCALEVIEWPORTEXT = 1042 # Variable c_int
EMR_FILLRGN = 71 # Variable c_int
ACCESS_OBJECT_GUID = 0 # Variable c_int
LVS_ICON = 0 # Variable c_int
HDS_HOTTRACK = 4 # Variable c_int
MMSYSERR_NOERROR = 0 # Variable c_int

_RPC_ASYNC_EVENT = c_int # enum
RpcCallComplete = 0
RpcSendComplete = 1
RpcReceiveComplete = 2
ERROR_NO_MORE_FILES = 18 # Variable c_long
IMAGE_REL_SH3_DIRECT8 = 3 # Variable c_int
TBSTYLE_GROUP = 4 # Variable c_int
TTDT_AUTOPOP = 2 # Variable c_int
GL_ID_NOMODULE = 1 # Variable c_int
SC_MANAGER_ALL_ACCESS = 983103 # Variable c_long
SPAPI_E_KEY_DOES_NOT_EXIST = -2146500092 # Variable c_long
DT_LEFT = 0 # Variable c_int
PCF_INTTIMEOUTS = 128 # Variable c_ulong
CTRY_UNITED_STATES = 1 # Variable c_int
SND_ALIAS_SYSTEMDEFAULT = 17491 # Variable c_ulong
CF_ENABLETEMPLATEHANDLE = 32 # Variable c_long
RPC_C_PROFILE_MATCH_BY_BOTH = 4 # Variable c_int
WM_PALETTEISCHANGING = 784 # Variable c_int
URLMON_OPTION_USERAGENT_REFRESH = 268435458 # Variable c_int
ACS_CENTER = 1 # Variable c_int
SEC_NOCACHE = 268435456 # Variable c_int
DC_ACTIVE = 1 # Variable c_int
HTBORDER = 18 # Variable c_int
VARFLAG_FHIDDEN = 64
PARITY_NONE = 256 # Variable c_ushort
DMPAPER_ENV_B4 = 33 # Variable c_int
LCMAP_KATAKANA = 2097152 # Variable c_int
BACKUP_INVALID = 0 # Variable c_int
BLACKNESS = 66 # Variable c_ulong
MCI_SYSINFO_NAME = 1024 # Variable c_long
ERROR_WMI_TRY_AGAIN = 4203 # Variable c_long
JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 4 # Variable c_int
MCI_DELETE = 2134 # Variable c_int
VK_ESCAPE = 27 # Variable c_int
DT_RIGHT = 2 # Variable c_int
PROPSHEETHEADERW_V1_SIZE = 40 # Variable c_uint
MCI_REALIZE = 2112 # Variable c_int
RDW_NOINTERNALPAINT = 16 # Variable c_int
PSH_NOAPPLYNOW = 128 # Variable c_int
LR_VGACOLOR = 128 # Variable c_int
RESOURCE_CONTEXT = 5 # Variable c_int
NMPWAIT_WAIT_FOREVER = 4294967295 # Variable c_uint
ERROR_WRITE_FAULT = 29 # Variable c_long
TVS_NONEVENHEIGHT = 16384 # Variable c_int
DTM_GETMCFONT = 4106 # Variable c_int
KEY_QUERY_VALUE = 1 # Variable c_int

tagREGKIND = c_int # enum
REGKIND_DEFAULT = 0
REGKIND_REGISTER = 1
REGKIND_NONE = 2
VOS_UNKNOWN = 0 # Variable c_long
BS_INDEXED = 4 # Variable c_int
SE_TCB_NAME = 'SeTcbPrivilege' # Variable POINTER(c_wchar)
SC_DEFAULT = 61792 # Variable c_int
ST_CLIENT = 16 # Variable c_int
TKF_HOTKEYSOUND = 16 # Variable c_int
CAL_SABBREVMONTHNAME11 = 44 # Variable c_int
WM_PALETTECHANGED = 785 # Variable c_int
HKEY_LOCAL_MACHINE = 2147483650 # Variable POINTER(HKEY__)
ERROR_DS_NO_MORE_RIDS = 1930 # Variable c_long
TRANSPARENT = 1 # Variable c_int
CTRY_COSTA_RICA = 506 # Variable c_int
PSU_DEFAULT = 1
CRYPT_E_HASH_VALUE = -2146889721 # Variable c_long
DRV_MCI_LAST = 6143 # Variable c_int
SPLREG_OS_VERSION = 'OSVersion' # Variable POINTER(c_wchar)
WSASYS_STATUS_LEN = 128 # Variable c_int
DBG_CONTROL_C = 1073807365 # Variable c_ulong
PRINTER_HTML_VIEW_PRINTPROPERTIES = 1 # Variable c_int
GROUP_SECURITY_INFORMATION = 2 # Variable c_long
ERROR_SET_POWER_STATE_VETOED = 1140 # Variable c_long
MCM_GETCURSEL = 4097 # Variable c_int
OLEUPDATE_ONCALL = 3
PORT_STATUS_OFFLINE = 1 # Variable c_int
PBS_SMOOTH = 1 # Variable c_int
EM_CHARFROMPOS = 215 # Variable c_int
TVHT_NOWHERE = 1 # Variable c_int
RPC_C_IMP_LEVEL_IDENTIFY = 2 # Variable c_int
SOCK_DGRAM = 2 # Variable c_int
NM_CLICK = 4294967294 # Variable c_uint
LANG_NORWEGIAN = 20 # Variable c_int
RPC_S_ENTRY_NOT_FOUND = 1761 # Variable c_long
VIEW_SORTTYPE = 7 # Variable c_int
EMR_PAINTRGN = 74 # Variable c_int
GCS_RESULTSTR = 2048 # Variable c_int
GMEM_DISCARDABLE = 256 # Variable c_int
PRINTER_STATUS_DOOR_OPEN = 4194304 # Variable c_int
ERROR_DUPLICATE_TAG = 2304 # Variable c_long
ERROR_PRINTER_ALREADY_EXISTS = 1802 # Variable c_long
ERROR_RING2SEG_MUST_BE_MOVABLE = 200 # Variable c_long
R2_WHITE = 16 # Variable c_int
ERROR_INVALID_EVENT_COUNT = 151 # Variable c_long
SERVICES_FAILED_DATABASEA = 'ServicesFailed' # Variable POINTER(c_char)
ERROR_UNABLE_TO_CLEAN = 4311 # Variable c_long
SERVICE_CONTROL_SHUTDOWN = 5 # Variable c_int
MCI_ANIM_GETDEVCAPS_NORMAL_RATE = 16388 # Variable c_long
WM_HANDHELDLAST = 863 # Variable c_int
MK_E_INTERMEDIATEINTERFACENOTSUPPORTED = -2147221017 # Variable c_long
AD_COUNTERCLOCKWISE = 1 # Variable c_int
LANG_THAI = 30 # Variable c_int
IMAGE_SCN_ALIGN_1BYTES = 1048576 # Variable c_int
ERROR_FLOPPY_ID_MARK_NOT_FOUND = 1122 # Variable c_long
DCX_LOCKWINDOWUPDATE = 1024 # Variable c_long
CE_OVERRUN = 2 # Variable c_int
RPC_C_VERS_MAJOR_ONLY = 4 # Variable c_int
PAN_FAMILY_PICTORIAL = 5 # Variable c_int
THREAD_PRIORITY_ERROR_RETURN = 2147483647 # Variable c_int
RPC_X_PIPE_DISCIPLINE_ERROR = 1917 # Variable c_long
IMAGE_SYM_TYPE_SHORT = 3 # Variable c_int
SM_CYVTHUMB = 9 # Variable c_int
CLIP_EMBEDDED = 128 # Variable c_int
GCPCLASS_POSTBOUNDRTL = 16 # Variable c_int
JOB_NOTIFY_FIELD_PRIORITY = 14 # Variable c_int
XMLELEMTYPE_COMMENT = 2
DC_PAPERSIZE = 3 # Variable c_int
IMAGE_REL_IA64_IMM64 = 3 # Variable c_int
GENERIC_READ = 2147483648 # Variable c_ulong
MMIOERR_CANNOTCLOSE = 260 # Variable c_int
HEAP_TAG_SHIFT = 18 # Variable c_int
ERROR_NOT_LOGGED_ON = 1245 # Variable c_long
IDLFLAG_FIN = 1 # Variable c_int
CB_SETCURSEL = 334 # Variable c_int
IMAGE_SYM_CLASS_EXTERNAL_DEF = 5 # Variable c_int
VK_RETURN = 13 # Variable c_int
MK_S_HIM = 262629 # Variable c_long
TVIF_HANDLE = 16 # Variable c_int
SPAPI_E_INVALID_INF_LOGCONFIG = -2146500054 # Variable c_long
CAL_ICALINTVALUE = 1 # Variable c_int
IPPORT_LOGINSERVER = 513 # Variable c_int
TYPE_E_BUFFERTOOSMALL = -2147319786 # Variable c_long
IMAGE_ARCHIVE_END = '`\n' # Variable POINTER(c_char)
EMR_SETTEXTCOLOR = 24 # Variable c_int
SUBLANG_NORWEGIAN_BOKMAL = 1 # Variable c_int
EN_KILLFOCUS = 512 # Variable c_int
MMIOM_USER = 32768 # Variable c_int
XTYP_WILDCONNECT = 8418 # Variable c_int
ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 1808 # Variable c_long
SPI_GETANIMATION = 72 # Variable c_int
ERROR_MAX_THRDS_REACHED = 164 # Variable c_long
DDE_FDATRESERVED = -45057 # Variable c_int
lst8 = 1127 # Variable c_int
frm3 = 1078 # Variable c_int
CDERR_MEMLOCKFAILURE = 10 # Variable c_int
SCS_CAP_COMPSTR = 1 # Variable c_int
SP_PARITY = 1 # Variable c_ulong
TBN_DELETINGBUTTON = 4294966581 # Variable c_uint
MCI_RECORD_OVERWRITE = 512 # Variable c_long
LOCALE_SABBREVMONTHNAME7 = 74 # Variable c_int
LVKF_ALT = 1 # Variable c_int
FILE_ACTION_REMOVED = 2 # Variable c_int
UPDFCACHE_IFBLANK = 16 # Variable c_int
SM_CYMINTRACK = 35 # Variable c_int
SET_TAPE_MEDIA_INFORMATION = 0 # Variable c_int
UDM_GETPOS = 1128 # Variable c_int
ERROR_SHARING_BUFFER_EXCEEDED = 36 # Variable c_long
MF_POSTMSGS = 67108864 # Variable c_int
DV_E_DVTARGETDEVICE_SIZE = -2147221396 # Variable c_long
BACKUP_ALTERNATE_DATA = 4 # Variable c_int
PFD_SUPPORT_OPENGL = 32 # Variable c_int
INADDR_NONE = 4294967295 # Variable c_uint
TYSPEC_FILENAME = 6
SS_LEFT = 0 # Variable c_long
PSINJECT_COMMENTS = 2 # Variable c_int
JOB_EXECUTE = 131088 # Variable c_long
RBS_FIXEDORDER = 2048 # Variable c_int
DS_NOIDLEMSG = 256 # Variable c_long
STUB_CALL_SERVER = 1
rad4 = 1059 # Variable c_int
STM_SETICON = 368 # Variable c_int
SPI_SETSCREENSAVERRUNNING = 97 # Variable c_int
COINIT_APARTMENTTHREADED = 2
PF_COMPARE_EXCHANGE_DOUBLE = 2 # Variable c_int
MCI_FORMAT_SMPTE_24 = 4 # Variable c_int
WS_EX_RIGHT = 4096 # Variable c_long
NEWFILEOPENORD = 1547 # Variable c_int
MININT_PTR = 2147483648 # Variable c_ulong
STG_S_CANNOTCONSOLIDATE = 197126 # Variable c_long
LVCF_TEXT = 4 # Variable c_int
NI_OPENCANDIDATE = 16 # Variable c_int
PIPE_TYPE_MESSAGE = 4 # Variable c_int
FR_ENABLEHOOK = 256 # Variable c_int
SECURITY_NETWORK_RID = 2 # Variable c_long
ERROR_SEM_TIMEOUT = 121 # Variable c_long
CF_ANSIONLY = 1024 # Variable c_long
NLS_HIRAGANA = 262144 # Variable c_int
LCS_GM_GRAPHICS = 2 # Variable c_long
CBES_EX_NOEDITIMAGEINDENT = 2 # Variable c_int
DST_TEXT = 1 # Variable c_int

tagOLEWHICHMK = c_int # enum
OLEWHICHMK_CONTAINER = 1
OLEWHICHMK_OBJREL = 2
OLEWHICHMK_OBJFULL = 3
WM_IME_ENDCOMPOSITION = 270 # Variable c_int
RPC_C_PROFILE_DEFAULT_ELT = 0 # Variable c_int
SPI_GETSCREENSAVEACTIVE = 16 # Variable c_int
MCI_WHERE = 2115 # Variable c_int
DMDUP_HORIZONTAL = 3 # Variable c_int
TRUST_E_FINANCIAL_CRITERIA = -2146869218 # Variable c_long
DMPAPER_A4 = 9 # Variable c_int
IA64_JMPE_MASK = 16777215 # Variable c_int
DCOM_CALL_COMPLETE = 1
FILE_GENERIC_WRITE = 1179926 # Variable c_long
NUMPRS_LEADING_MINUS = 16 # Variable c_int
FILE_UNICODE_ON_DISK = 4 # Variable c_int
TCM_DELETEITEM = 4872 # Variable c_int
DMBIN_AUTO = 7 # Variable c_int
RPC_C_MQ_TEMPORARY = 0 # Variable c_int
MCI_STATUS_ITEM = 256 # Variable c_long
TYSPEC_FILEEXT = 1
MCI_DEVTYPE_DIGITAL_VIDEO = 520 # Variable c_int
RPC_E_NO_GOOD_SECURITY_PACKAGES = -2147417830 # Variable c_long
PAN_XHEIGHT_CONSTANT_SMALL = 2 # Variable c_int
TRUETYPE_FONTTYPE = 4 # Variable c_int
IP_TTL = 7 # Variable c_int
IPM_SETFOCUS = 1128 # Variable c_int
WS_HSCROLL = 1048576 # Variable c_long
IMAGE_SIZEOF_SYMBOL = 18 # Variable c_int
TCM_GETITEMCOUNT = 4868 # Variable c_int
ERROR_SERVICE_LOGON_FAILED = 1069 # Variable c_long
MDITILE_VERTICAL = 0 # Variable c_int
HANGUP_PENDING = 4 # Variable c_int
PROCESS_HEAP_ENTRY_BUSY = 4 # Variable c_int
TKF_HOTKEYACTIVE = 4 # Variable c_int
SEE_MASK_FLAG_NO_UI = 1024 # Variable c_int
ERROR_NO_LOGON_SERVERS = 1311 # Variable c_long
RPC_C_NOTIFY_ON_SEND_COMPLETE = 1 # Variable c_int
MCI_WAVE_SET_FORMATTAG = 65536 # Variable c_long
PSP_USECALLBACK = 128 # Variable c_int
MIXERCONTROL_CONTROLTYPE_DECIBELS = 805568512 # Variable c_long
DPD_DELETE_UNUSED_FILES = 1 # Variable c_int

XLAT_SIDE = c_int # enum
XLAT_SERVER = 1
XLAT_CLIENT = 2
GMEM_ZEROINIT = 64 # Variable c_int
MMSYSERR_READERROR = 16 # Variable c_int
JOY_BUTTON31 = 1073741824 # Variable c_long
SEE_MASK_HOTKEY = 32 # Variable c_int
ERROR_INVALID_MENU_HANDLE = 1401 # Variable c_long
CPS_CANCEL = 4 # Variable c_int

tagDVASPECT = c_int # enum
DVASPECT_CONTENT = 1
DVASPECT_THUMBNAIL = 2
DVASPECT_ICON = 4
DVASPECT_DOCPRINT = 8
JOYCAPS_POV4DIR = 32 # Variable c_int
HSHELL_LANGUAGE = 8 # Variable c_int
PS_JOIN_ROUND = 0 # Variable c_int
SE_CREATE_PAGEFILE_NAME = 'SeCreatePagefilePrivilege' # Variable POINTER(c_wchar)
C2_RIGHTTOLEFT = 2 # Variable c_int
IPPROTO_IDP = 22 # Variable c_int
DDL_DIRECTORY = 16 # Variable c_int
EMARCH_ENC_I17_IMM9D_SIZE_X = 9 # Variable c_int
WSATRY_AGAIN = 11002 # Variable c_int
ERROR_MEDIA_OFFLINE = 4304 # Variable c_long
MMIO_CREATELIST = 64 # Variable c_int
NORM_IGNORENONSPACE = 2 # Variable c_int
LB_GETSELCOUNT = 400 # Variable c_int
PS_STYLE_MASK = 15 # Variable c_int
ERROR_BAD_REM_ADAP = 60 # Variable c_long
NCBUNLINK = 112 # Variable c_int
IMAGE_SYM_CLASS_EXTERNAL = 2 # Variable c_int
PERF_INVERSE_COUNTER = 16777216 # Variable c_int
SE_TAKE_OWNERSHIP_NAME = 'SeTakeOwnershipPrivilege' # Variable POINTER(c_wchar)
LVITEMW_V1_SIZE = 36 # Variable c_uint
URLTEMPLATE_MEDIUM = 69632
WNNC_NET_LOCUS = 393216 # Variable c_int
PROPSHEETPAGEW_V1_SIZE = 40 # Variable c_uint
PAN_SERIF_FLARED = 14 # Variable c_int

_EXCEPTION_DISPOSITION = c_int # enum
ExceptionContinueExecution = 0
ExceptionContinueSearch = 1
ExceptionNestedException = 2
ExceptionCollidedUnwind = 3
CTRY_MOROCCO = 212 # Variable c_int
ERROR_NO_SUCH_PRIVILEGE = 1313 # Variable c_long
TOOLTIPS_CLASSA = 'tooltips_class32' # Variable POINTER(c_char)
ERROR_JOIN_TO_JOIN = 138 # Variable c_long
IMAGE_REL_PPC_REL24 = 6 # Variable c_int
TC_HARDERR = 1 # Variable c_int
C2_COMMONSEPARATOR = 7 # Variable c_int
VK_RIGHT = 39 # Variable c_int
GROUP_NAME = 128 # Variable c_int
HDM_SETHOTDIVIDER = 4627 # Variable c_int
SETXOFF = 1 # Variable c_int
GMEM_VALID_FLAGS = 32626 # Variable c_int
TB_ADDSTRINGA = 1052 # Variable c_int
MWT_RIGHTMULTIPLY = 3 # Variable c_int
CF_SELECTSCRIPT = 4194304 # Variable c_long
CWP_ALL = 0 # Variable c_int
PGM_GETBUTTONSIZE = 5131 # Variable c_int
WH_JOURNALRECORD = 0 # Variable c_int
DT_NOCLIP = 256 # Variable c_int

tagCALLCONV = c_int # enum
CC_FASTCALL = 0
CC_CDECL = 1
CC_MSCPASCAL = 2
CC_PASCAL = 2
CC_MACPASCAL = 3
CC_STDCALL = 4
CC_FPFASTCALL = 5
CC_SYSCALL = 6
CC_MPWCDECL = 7
CC_MPWPASCAL = 8
CC_MAX = 9
R2_MERGEPENNOT = 14 # Variable c_int
SC_CONTEXTHELP = 61824 # Variable c_int
PSP_USEREFPARENT = 64 # Variable c_int
TBS_AUTOTICKS = 1 # Variable c_int
SS_PATHELLIPSIS = 32768 # Variable c_long
MSG_PEEK = 2 # Variable c_int
EMARCH_ENC_I17_SIGN_INST_WORD_POS_X = 27 # Variable c_int
CAL_SABBREVMONTHNAME13 = 46 # Variable c_int
LANG_RUSSIAN = 25 # Variable c_int
SETRGBSTRINGA = 'commdlg_SetRGBColor' # Variable POINTER(c_char)
MHDR_ISSTRM = 8 # Variable c_int
OFN_NODEREFERENCELINKS = 1048576 # Variable c_int
TB_GETBUTTONINFOA = 1089 # Variable c_int
MCIERR_SEQ_DIV_INCOMPATIBLE = 336 # Variable c_int
HDM_HITTEST = 4614 # Variable c_int
SEE_MASK_ICON = 16 # Variable c_int
MCI_ANIM_WINDOW_DISABLE_STRETCH = 2097152 # Variable c_long
DI_CHANNEL = 1 # Variable c_int
WM_NCMBUTTONUP = 168 # Variable c_int
SIF_RANGE = 1 # Variable c_int
LANG_MALAY = 62 # Variable c_int
CALLBACK_FUNCTION = 196608 # Variable c_long
TOKEN_IMPERSONATE = 4 # Variable c_int
TVM_SETBKCOLOR = 4381 # Variable c_int
LR_SHARED = 32768 # Variable c_int
TCS_RIGHTJUSTIFY = 0 # Variable c_int
PSINJECT_ORIENTATION = 23 # Variable c_int
CAL_SABBREVDAYNAME1 = 14 # Variable c_int
IP_MULTICAST_TTL = 3 # Variable c_int
ATF_ONOFFFEEDBACK = 2 # Variable c_int
CF_ENHMETAFILE = 14 # Variable c_int
COLOR_HIGHLIGHT = 13 # Variable c_int
UDM_GETBUDDY = 1130 # Variable c_int
SEF_AVOID_PRIVILEGE_CHECK = 8 # Variable c_int
CBR_9600 = 9600 # Variable c_int
ODT_MENU = 1 # Variable c_int
TYPEFLAG_FREPLACEABLE = 2048
CTRY_SAUDI_ARABIA = 966 # Variable c_int
TBM_SETLINESIZE = 1047 # Variable c_int
PSP_USEHEADERSUBTITLE = 8192 # Variable c_int
SO_ERROR = 4103 # Variable c_int
LOCALE_SMONGROUPING = 24 # Variable c_int
PFD_DEPTH_DONTCARE = 536870912 # Variable c_int
SERVICE_CONTROL_CONTINUE = 3 # Variable c_int
NUMMARKERS = 20 # Variable c_int
JOYCAPS_HASR = 2 # Variable c_int
MMSYSERR_INVALPARAM = 11 # Variable c_int
SWP_NOOWNERZORDER = 512 # Variable c_int
TC_CP_STROKE = 4 # Variable c_int
ANYSIZE_ARRAY = 1 # Variable c_int
IMAGE_REL_ALPHA_LITUSE = 5 # Variable c_int
PSH_WIZARDCONTEXTHELP = 4096 # Variable c_int
SETLINECAP = 21 # Variable c_int
ERROR_DOMAIN_EXISTS = 1356 # Variable c_long
CF_NOVERTFONTS = 16777216 # Variable c_long
EC_LEFTMARGIN = 1 # Variable c_int
TC_SO_ABLE = 4096 # Variable c_int
edt8 = 1159 # Variable c_int
SO_SYNCHRONOUS_ALERT = 16 # Variable c_int
CP_ACP = 0 # Variable c_int
PAN_CONTRAST_NONE = 2 # Variable c_int
ERROR_UNKNOWN_PRODUCT = 1605 # Variable c_long
XTYP_MASK = 240 # Variable c_int
SYSTEM_ALARM_ACE_TYPE = 3 # Variable c_int
ERROR_PAGEFILE_QUOTA = 1454 # Variable c_long
CBEN_DRAGBEGINA = 4294966488 # Variable c_uint
TCM_SETPADDING = 4907 # Variable c_int
URLACTION_HTML_JAVA_RUN = 5637 # Variable c_int
MMIO_EXCLUSIVE = 16 # Variable c_int
DS_FIXEDSYS = 8 # Variable c_long
ERROR_USER_EXISTS = 1316 # Variable c_long
VARFLAG_FRESTRICTED = 128
INET_E_CANNOT_INSTANTIATE_OBJECT = -2146697200 # Variable c_long
STD_PRINTPRE = 9 # Variable c_int
ERROR_NETWORK_ACCESS_DENIED = 65 # Variable c_long
MCI_DEVTYPE_VIDEODISC = 514 # Variable c_int
CTRY_CZECH = 420 # Variable c_int
WGL_SWAP_UNDERLAY7 = 4194304 # Variable c_int
PS_GEOMETRIC = 65536 # Variable c_int
HTBOTTOM = 15 # Variable c_int
LANG_ARABIC = 1 # Variable c_int
CRYPT_E_STREAM_MSG_NOT_READY = -2146889712 # Variable c_long
GGO_METRICS = 0 # Variable c_int
FORMAT_MESSAGE_MAX_WIDTH_MASK = 255 # Variable c_int
FORMAT_MESSAGE_FROM_STRING = 1024 # Variable c_int
CF_INITTOLOGFONTSTRUCT = 64 # Variable c_long
WMSZ_LEFT = 1 # Variable c_int
SERKF_AVAILABLE = 2 # Variable c_int
PAN_BENT_ARMS_DOUBLE_SERIF = 11 # Variable c_int
TBN_DRAGOUT = 4294966582 # Variable c_uint
PSD_DISABLEPAPER = 512 # Variable c_int
ERROR_SERVICE_CANNOT_ACCEPT_CTRL = 1061 # Variable c_long
PAN_WEIGHT_BOOK = 5 # Variable c_int
IMAGE_REL_IA64_PCREL21B = 6 # Variable c_int
SUBLANG_ARABIC_JORDAN = 11 # Variable c_int
VK_TAB = 9 # Variable c_int
IO_REPARSE_TAG_DFS = 2147483656 # Variable c_uint
LZERROR_READ = -3 # Variable c_int
PSM_SETFINISHTEXTA = 1139 # Variable c_int
PROP_SM_CXDLG = 212 # Variable c_int
MCI_SET_ON = 8192 # Variable c_long
SM_CXSCREEN = 0 # Variable c_int
FS_LATIN1 = 1 # Variable c_long
MK_S_ME = 262628 # Variable c_long
HTSYSMENU = 3 # Variable c_int
TAPE_SPACE_FILEMARKS = 6 # Variable c_long
RESOURCE_REMEMBERED = 3 # Variable c_int
SUBLANG_ARABIC_SAUDI_ARABIA = 1 # Variable c_int
WM_NCRBUTTONUP = 165 # Variable c_int
PSU_SECURITY_URL_ONLY = 2
ACE_INHERITED_OBJECT_TYPE_PRESENT = 2 # Variable c_int
XTYP_CONNECT_CONFIRM = 32882 # Variable c_int
LVIS_FOCUSED = 1 # Variable c_int
PATINVERT = 5898313 # Variable c_ulong
CREATE_NEW = 1 # Variable c_int
MB_RETRYCANCEL = 5 # Variable c_long
PRINTER_ATTRIBUTE_ENABLE_DEVQ = 128 # Variable c_int
URLACTION_ACTIVEX_CURR_MAX = 4613 # Variable c_int
chx12 = 1051 # Variable c_int
HDN_GETDISPINFOA = 4294966987 # Variable c_uint
RGN_COPY = 5 # Variable c_int
REG_REFRESH_HIVE = 2 # Variable c_long
CFS_CANDIDATEPOS = 64 # Variable c_int
RPC_C_AUTHN_GSS_KERBEROS = 18 # Variable c_int
EMR_ABORTPATH = 68 # Variable c_int
VOS_DOS = 65536 # Variable c_long
SORT_CHINESE_BIG5 = 0 # Variable c_int
RBBS_NOGRIPPER = 256 # Variable c_int
OBJ_METADC = 4 # Variable c_int
MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT = 1895890944 # Variable c_long
STATUS_FLOAT_MULTIPLE_TRAPS = 3221226165 # Variable c_ulong
ERROR_DIFFERENT_SERVICE_ACCOUNT = 1079 # Variable c_long
SPI_GETSTICKYKEYS = 58 # Variable c_int
OLE_E_STATIC = -2147221493 # Variable c_long
RPC_C_EP_ALL_ELTS = 0 # Variable c_int
RBS_VERTICALGRIPPER = 16384 # Variable c_int
CF_RIFF = 11 # Variable c_int
DOMAIN_GROUP_RID_USERS = 513 # Variable c_long
RPC_S_INVALID_NET_ADDR = 1707 # Variable c_long
CPS_CONVERT = 2 # Variable c_int
IMAGE_ORDINAL_FLAG32 = 2147483648 # Variable c_uint
REG_WHOLE_HIVE_VOLATILE = 1 # Variable c_long
TB_SAVERESTOREA = 1050 # Variable c_int
BROADCAST_QUERY_DENY = 1112363332 # Variable c_int
IgnoreError = 0
LOGON32_LOGON_INTERACTIVE = 2 # Variable c_int
IN_CLASSA_NSHIFT = 24 # Variable c_int
KF_REPEAT = 16384 # Variable c_int
VER_PLATFORM_WIN32s = 0 # Variable c_int
scr6 = 1173 # Variable c_int
MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT = 4104 # Variable c_long
LOCALE_IMEASURE = 13 # Variable c_int

tagOLELINKBIND = c_int # enum
OLELINKBIND_EVENIFCLASSDIFF = 1
IME_HOTKEY_DSWITCH_FIRST = 256 # Variable c_int
OFS_MAXPATHNAME = 128 # Variable c_int
NormalError = 1
VIF_DIFFLANG = 8 # Variable c_long
SPLDS_PRINT_RATE_UNIT = 'printRateUnit' # Variable POINTER(c_wchar)
SERVICE_AUTO_START = 2 # Variable c_int
LVM_GETCOLUMNORDERARRAY = 4155 # Variable c_int
TRUST_E_BAD_DIGEST = -2146869232 # Variable c_long
OLEOBJ_E_FIRST = 2147746176 # Variable c_ulong
CTRY_MACAU = 853 # Variable c_int
NULL_BRUSH = 5 # Variable c_int
BINDSTATUS_BEGINDOWNLOADCOMPONENTS = 7
NCBCHAINSENDNA = 114 # Variable c_int
PBM_SETBARCOLOR = 1033 # Variable c_int
RPC_S_PROTSEQ_NOT_FOUND = 1744 # Variable c_long
IS_TEXT_UNICODE_ODD_LENGTH = 512 # Variable c_int
CBEM_SETITEMA = 1029 # Variable c_int
XST_ADVSENT = 11 # Variable c_int
CFSTR_MIME_XBM = 'image/xbm' # Variable POINTER(c_wchar)
RPC_C_VERS_UPTO = 5 # Variable c_int
VK_NEXT = 34 # Variable c_int
ico2 = 1085 # Variable c_int
LPD_TYPE_COLORINDEX = 1 # Variable c_int
C3_LEXICAL = 1024 # Variable c_int
IME_CMODE_HANJACONVERT = 64 # Variable c_int
PRINTER_ACCESS_USE = 8 # Variable c_int
SORT_KOREAN_UNICODE = 1 # Variable c_int
MCIERR_DUPLICATE_FLAGS = 295 # Variable c_int
END_PATH = 4098 # Variable c_int
GMEM_FIXED = 0 # Variable c_int
PIPE_ACCESS_DUPLEX = 3 # Variable c_int
MCIERR_FLAGS_NOT_COMPATIBLE = 284 # Variable c_int
LOCALE_IFIRSTWEEKOFYEAR = 4109 # Variable c_int
VT_UI2 = 18
ACCESS_MAX_LEVEL = 4 # Variable c_int
CTRY_LIECHTENSTEIN = 41 # Variable c_int
IMAGE_SYM_CLASS_WEAK_EXTERNAL = 105 # Variable c_int
REALTIME_PRIORITY_CLASS = 256 # Variable c_int
ERROR_INVALID_ORDINAL = 182 # Variable c_long
URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX = 4100 # Variable c_int
ERROR_PRINT_MONITOR_IN_USE = 3008 # Variable c_long
LPD_TRANSPARENT = 4096 # Variable c_int
URLACTION_SCRIPT_MAX = 5631 # Variable c_int
VARIANT_NOVALUEPROP = 1 # Variable c_int
MAXPNAMELEN = 32 # Variable c_int
SND_ALIAS_SYSTEMHAND = 18515 # Variable c_ulong
DLGC_UNDEFPUSHBUTTON = 32 # Variable c_int
TCS_VERTICAL = 128 # Variable c_int
ERROR_TOO_MANY_MODULES = 214 # Variable c_long
FOF_ALLOWUNDO = 64 # Variable c_int
LOCALE_SABBREVMONTHNAME4 = 71 # Variable c_int
RBBIM_TEXT = 4 # Variable c_int
PSN_KILLACTIVE = 4294967095 # Variable c_uint
MF_HSZ_INFO = 16777216 # Variable c_int
SE_ERR_SHARE = 26 # Variable c_int
PROXY_CALCSIZE = 0
IME_CAND_RADICAL = 4 # Variable c_int
TYPE_E_NAMECONFLICT = -2147319763 # Variable c_long
GL_ID_CANNOTSAVE = 17 # Variable c_int
QUERY_IS_INSTALLEDENTRY = 10
IMAGE_REL_IA64_LTOFF64 = 15 # Variable c_int
CDM_SETCONTROLTEXT = 1128 # Variable c_int
TYSPEC_JAVACLASS = 7
HELPINFO_WINDOW = 1 # Variable c_int
SM_CXMENUSIZE = 54 # Variable c_int
ERROR_ALREADY_ASSIGNED = 85 # Variable c_long
LBN_DBLCLK = 2 # Variable c_int
MIXERCONTROL_CT_CLASS_MASK = 4026531840 # Variable c_ulong
rad5 = 1060 # Variable c_int
SPI_SETDRAGWIDTH = 76 # Variable c_int
SHGFI_SYSICONINDEX = 16384 # Variable c_int
BAUD_7200 = 1024 # Variable c_ulong
MCI_FORMAT_SMPTE_25 = 5 # Variable c_int
IMAGE_SEPARATE_DEBUG_FLAGS_MASK = 32768 # Variable c_int
ERROR_NOT_JOINED = 136 # Variable c_long
DM_GETDEFID = 1024 # Variable c_int
LIBFLAG_FHIDDEN = 4
TBN_GETBUTTONINFOA = 4294966596 # Variable c_uint
PRINTER_NOTIFY_FIELD_DRIVER_NAME = 4 # Variable c_int
IMAGE_SCN_ALIGN_2048BYTES = 12582912 # Variable c_int
ERROR_DISCARDED = 157 # Variable c_long
DMPAPER_LETTER_PLUS = 59 # Variable c_int
IMAGE_REL_PPC_TOCREL16 = 8 # Variable c_int
BS_NULL = 1 # Variable c_int
TB_GETTOOLTIPS = 1059 # Variable c_int

tagMKREDUCE = c_int # enum
MKRREDUCE_ONE = 196608
MKRREDUCE_TOUSER = 131072
MKRREDUCE_THROUGHUSER = 65536
MKRREDUCE_ALL = 0
MCI_SEQ_DIV_SMPTE_30DROP = 1219 # Variable c_int
TVN_GETDISPINFOA = 4294966893 # Variable c_uint
THREAD_BASE_PRIORITY_MIN = -2 # Variable c_int
TTS_ALWAYSTIP = 1 # Variable c_int
TVIF_IMAGE = 2 # Variable c_int
WNFMT_CONNECTION = 32 # Variable c_int
IMAGE_REL_PPC_REL14 = 7 # Variable c_int
GCP_USEKERNING = 8 # Variable c_int
IMAGE_REL_SH3_DIRECT8_WORD = 4 # Variable c_int
IMN_SETSTATUSWINDOWPOS = 12 # Variable c_int
JOB_OBJECT_LIMIT_PRIORITY_CLASS = 32 # Variable c_int
SCS_CAP_MAKEREAD = 2 # Variable c_int
CRYPT_E_REVOCATION_OFFLINE = -2146885613 # Variable c_long
WS_EX_LTRREADING = 0 # Variable c_long
CO_E_NETACCESSAPIFAILED = -2147220984 # Variable c_long
DMBIN_LARGECAPACITY = 11 # Variable c_int
EDGE_RAISED = 5 # Variable c_int
QS_SENDMESSAGE = 64 # Variable c_int
SMEXF_SERVER = 1
IMAGE_REL_ALPHA_REFHI = 10 # Variable c_int
ERROR_GROUP_NOT_AVAILABLE = 5012 # Variable c_long
R2_NOTMASKPEN = 8 # Variable c_int
SERVER_WRITE = 131075 # Variable c_long
MCI_STATUS = 2068 # Variable c_int
TCS_FIXEDWIDTH = 1024 # Variable c_int
LOCALE_STIMEFORMAT = 4099 # Variable c_int
URLACTION_INFODELIVERY_NO_ADDING_CHANNELS = 7424 # Variable c_int
IPPORT_RESERVED = 1024 # Variable c_int
ERROR_RESOURCE_DATA_NOT_FOUND = 1812 # Variable c_long
ERROR_INVALID_DRIVE = 15 # Variable c_long
IMAGE_FILE_LINE_NUMS_STRIPPED = 4 # Variable c_int
APPCLASS_MASK = 15 # Variable c_long
COMMON_LVB_GRID_RVERTICAL = 4096 # Variable c_int
DMPAPER_B5_TRANSVERSE = 62 # Variable c_int
MMIOERR_CANNOTWRITE = 262 # Variable c_int
CSTR_EQUAL = 2 # Variable c_int
PRINTER_STATUS_OUT_OF_MEMORY = 2097152 # Variable c_int
THREAD_SET_CONTEXT = 16 # Variable c_int
EVENTLOG_END_PAIRED_EVENT = 2 # Variable c_int
RBS_BANDBORDERS = 1024 # Variable c_int
PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY = 15 # Variable c_int
BACKUP_SPARSE_BLOCK = 9 # Variable c_int
WAVE_FORMAT_2S08 = 32 # Variable c_int
RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY = 8 # Variable c_int
GCS_CURSORPOS = 128 # Variable c_int
MS_CTS_ON = 16 # Variable c_ulong
TB_INSERTMARKHITTEST = 1105 # Variable c_int
BF_TOPLEFT = 3 # Variable c_int
HTCLIENT = 1 # Variable c_int
STGM_PRIORITY = 262144 # Variable c_long
CTLCOLOR_EDIT = 1 # Variable c_int
WM_DDE_TERMINATE = 993 # Variable c_int
SUBLANG_ARABIC_MOROCCO = 6 # Variable c_int
EMR_WIDENPATH = 66 # Variable c_int
PROCESSOR_PPC_620 = 620 # Variable c_int
ERROR_MESSAGE_SYNC_ONLY = 1159 # Variable c_long
TV_FIRST = 4352 # Variable c_int
_MAX_DRIVE = 3 # Variable c_int
CTRY_RUSSIA = 7 # Variable c_int
SERVICE_ERROR_NORMAL = 1 # Variable c_int
Win32ServiceShareProcess = 32
IDC_UPARROW = 206102 # Variable POINTER(c_wchar)
DMLERR_NOTPROCESSED = 16393 # Variable c_int
WAVE_FORMAT_DIRECT_QUERY = 9 # Variable c_int
IMAGE_REL_ALPHA_GPRELLO = 22 # Variable c_int
SPAPI_E_NO_DEVICE_ICON = -2146500055 # Variable c_long
HDM_GETIMAGELIST = 4617 # Variable c_int
SWP_NOZORDER = 4 # Variable c_int
LEFT_CTRL_PRESSED = 8 # Variable c_int
WM_IME_SETCONTEXT = 641 # Variable c_int
URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY = 196608 # Variable c_int
DRV_LOAD = 1 # Variable c_int
EMR_BEGINPATH = 59 # Variable c_int
DRIVE_FIXED = 3 # Variable c_int
IMAGE_FILE_MACHINE_POWERPC = 496 # Variable c_int
ES_MULTILINE = 4 # Variable c_long
EMR_POLYLINETO = 6 # Variable c_int
C3_HIRAGANA = 32 # Variable c_int

tagCALLTYPE = c_int # enum
CALLTYPE_TOPLEVEL = 1
CALLTYPE_NESTED = 2
CALLTYPE_ASYNC = 3
CALLTYPE_TOPLEVEL_CALLPENDING = 4
DTN_CLOSEUP = 4294966543 # Variable c_uint
TAPE_LOCK = 3 # Variable c_long
Win32ServiceOwnProcess = 16
LVGIT_UNFOLDED = 1 # Variable c_int
ABM_WINDOWPOSCHANGED = 9 # Variable c_int
HCBT_KEYSKIPPED = 7 # Variable c_int
GETSETPAPERMETRICS = 35 # Variable c_int
URLTEMPLATE_HIGH = 73728
PRINTER_STATUS_PROCESSING = 16384 # Variable c_int
SO_CONNECT_TIME = 28684 # Variable c_int
IMAGE_FILE_LOCAL_SYMS_STRIPPED = 8 # Variable c_int
DOF_EXECUTABLE = 32769 # Variable c_int
ERROR_NO_MORE_USER_HANDLES = 1158 # Variable c_long
VK_F5 = 116 # Variable c_int
AUXCAPS_AUXIN = 2 # Variable c_int
NOERROR = 0 # Variable c_int
ST_BLOCKED = 8 # Variable c_int
XTYP_ADVDATA = 16400 # Variable c_int
MMSYSERR_LASTERROR = 20 # Variable c_int
CFSTR_MIME_POSTSCRIPT = 'application/postscript' # Variable POINTER(c_wchar)
ES_SYSTEM_REQUIRED = 1 # Variable c_ulong
PRINTER_STATUS_PRINTING = 1024 # Variable c_int
MMIO_DENYREAD = 48 # Variable c_int
MIXERCONTROL_CT_CLASS_SLIDER = 1073741824 # Variable c_long
CCS_RIGHT = 131 # Variable c_long
ARABIC_CHARSET = 178 # Variable c_int
ERROR_CIRCULAR_DEPENDENCY = 1059 # Variable c_long
WSAEADDRINUSE = 10048 # Variable c_int
EWX_POWEROFF = 8 # Variable c_int
VK_F6 = 117 # Variable c_int
PRINTER_NOTIFY_FIELD_BYTES_PRINTED = 25 # Variable c_int
WM_MOVE = 3 # Variable c_int
PRINTER_ENUM_ICON4 = 524288 # Variable c_int
PURGE_TXABORT = 1 # Variable c_int
NDR_VAX_FLOAT = 256 # Variable c_ulong
SECURITY_NULL_RID = 0 # Variable c_long
DSIG_FONTTYPE = 262144 # Variable c_int
HDI_ORDER = 128 # Variable c_int
META_DELETEOBJECT = 496 # Variable c_int
INET_E_DOWNLOAD_FAILURE = -2146697208 # Variable c_long
CAL_SABBREVMONTHNAME12 = 45 # Variable c_int
MCI_SEQ_STATUS_MASTER = 16392 # Variable c_long
TAPE_LOGICAL_BLOCK = 2 # Variable c_long
CDERR_DIALOGFAILURE = 65535 # Variable c_int
PSN_SETACTIVE = 4294967096 # Variable c_uint
TOKEN_READ = 131080 # Variable c_long
MCI_TO = 8 # Variable c_long
ERROR_NO_SUCH_USER = 1317 # Variable c_long
NETPROPERTY_PERSISTENT = 1 # Variable c_int
DMPAPER_A3_TRANSVERSE = 67 # Variable c_int
ERROR_NO_SUCH_PACKAGE = 1364 # Variable c_long
LCS_GM_BUSINESS = 1 # Variable c_long
KLF_NOTELLSHELL = 128 # Variable c_int
MMIO_COMPAT = 0 # Variable c_int
ERROR_RESOURCE_NAME_NOT_FOUND = 1814 # Variable c_long
RPC_C_MQ_CLEAR_ON_OPEN = 2 # Variable c_int
IMAGE_SIZEOF_SECTION_HEADER = 40 # Variable c_int
IMAGE_REL_SH3_ABSOLUTE = 0 # Variable c_int
SECTION_MAP_READ = 4 # Variable c_int
MIXERLINE_COMPONENTTYPE_DST_UNDEFINED = 0 # Variable c_long
SECURITY_RESTRICTED_CODE_RID = 12 # Variable c_long
LBS_MULTICOLUMN = 512 # Variable c_long
META_SETTEXTJUSTIFICATION = 522 # Variable c_int
FILE_GENERIC_EXECUTE = 1179808 # Variable c_long
IMN_CHANGECANDIDATE = 3 # Variable c_int
UDM_SETBUDDY = 1129 # Variable c_int
DCBA_FACEUPRIGHT = 3 # Variable c_int
VK_FINAL = 24 # Variable c_int
AF_UNSPEC = 0 # Variable c_int
USER_MARSHAL_FC_ULONG = 9 # Variable c_int
TYPEFLAG_FDISPATCHABLE = 4096
JOB_OBJECT_MSG_END_OF_JOB_TIME = 1 # Variable c_int
IMAGE_SCN_ALIGN_32BYTES = 6291456 # Variable c_int
IMAGE_FILE_LARGE_ADDRESS_AWARE = 32 # Variable c_int
ERROR_NO_VOLUME_ID = 1173 # Variable c_long
DMPAPER_FANFOLD_US = 39 # Variable c_int
ERROR_WMI_SERVER_UNAVAILABLE = 4208 # Variable c_long
DRAGDROP_S_USEDEFAULTCURSORS = 262402 # Variable c_long
NTE_BAD_KEYSET_PARAM = -2146893793 # Variable c_long
JOYCAPS_HASV = 8 # Variable c_int
MCI_STATUS_MODE = 4 # Variable c_long
WM_NCMOUSEMOVE = 160 # Variable c_int
CB_GETCOUNT = 326 # Variable c_int
MB_ICONEXCLAMATION = 48 # Variable c_long
IMAGE_REL_ARM_ADDR32NB = 2 # Variable c_int
BAUD_300 = 16 # Variable c_ulong
RPC_C_MQ_EXPRESS = 0 # Variable c_int
TCIS_BUTTONPRESSED = 1 # Variable c_int
SPI_LANGDRIVER = 12 # Variable c_int
MM_WIM_DATA = 960 # Variable c_int
PSD_ENABLEPAGESETUPHOOK = 8192 # Variable c_int
MMSYSERR_ALLOCATED = 4 # Variable c_int
DESKTOP_SWITCHDESKTOP = 256 # Variable c_long
edt9 = 1160 # Variable c_int
RB_BEGINDRAG = 1048 # Variable c_int
LOCALE_IDAYLZERO = 38 # Variable c_int
EMR_FILLPATH = 62 # Variable c_int
PAN_LETT_NORMAL_CONTACT = 2 # Variable c_int
IMAGE_SCN_ALIGN_16BYTES = 5242880 # Variable c_int
LOCALE_ICOUNTRY = 5 # Variable c_int
RPC_C_AUTHN_LEVEL_PKT_INTEGRITY = 5 # Variable c_int
EVENTLOG_SEQUENTIAL_READ = 1 # Variable c_int
CFSTR_MIME_TIFF = 'image/tiff' # Variable POINTER(c_wchar)
SB_BOTH = 3 # Variable c_int
DETACHED_PROCESS = 8 # Variable c_int
MF_MENUBREAK = 64 # Variable c_long
CCH_MAX_PROPSTG_NAME = 31 # Variable c_int
VARFLAG_FDEFAULTCOLLELEM = 256
JobObjectBasicUIRestrictions = 4
ACL_REVISION2 = 2 # Variable c_int
BINDSTRING_UA_PIXELS = 7
WNNC_NET_POWERLAN = 983040 # Variable c_int
INFINITE = 4294967295 # Variable c_uint
INFOTIPSIZE = 1024 # Variable c_int
CC_SHOWHELP = 8 # Variable c_int
LCS_DEVICE_CMYK = 2 # Variable c_long
SE_CHANGE_NOTIFY_NAME = 'SeChangeNotifyPrivilege' # Variable POINTER(c_wchar)
ERROR_IS_SUBSTED = 135 # Variable c_long
DISPATCH_METHOD = 1 # Variable c_int
PGM_SETBUTTONSIZE = 5130 # Variable c_int
BINDSTRING_PASSWORD = 6
SOFTDIST_FLAG_DELETE_SUBSCRIPTION = 8 # Variable c_int
ERROR_HANDLE_DISK_FULL = 39 # Variable c_long
ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 174 # Variable c_long
TB_ISBUTTONENABLED = 1033 # Variable c_int
CTRY_GUATEMALA = 502 # Variable c_int
TAPE_DRIVE_FILEMARKS = 2147745792 # Variable c_uint
PSM_ADDPAGE = 1127 # Variable c_int
MCI_ANIM_PLAY_FAST = 262144 # Variable c_long
RTS_CONTROL_TOGGLE = 3 # Variable c_int
BI_RLE8 = 1 # Variable c_long
ONESTOPBIT = 0 # Variable c_int
IMAGE_REL_PPC_ADDR16 = 4 # Variable c_int
ERROR_PIPE_LISTENING = 536 # Variable c_long
RPC_E_REMOTE_DISABLED = -2147417828 # Variable c_long
STM_GETIMAGE = 371 # Variable c_int
WSAENETDOWN = 10050 # Variable c_int
MOD_IGNORE_ALL_MODIFIER = 1024 # Variable c_int
CB_GETITEMHEIGHT = 340 # Variable c_int
BINDINFOF_URLENCODESTGMEDDATA = 1
ACCESS_DS_SOURCE_A = 'DS' # Variable POINTER(c_char)
LVM_SETHOVERTIME = 4167 # Variable c_int
ERROR_NO_PROC_SLOTS = 89 # Variable c_long
MIDI_MAPPER = 4294967295 # Variable c_uint
N_BTMASK = 15 # Variable c_int
CO_E_RUNAS_CREATEPROCESS_FAILURE = -2147467239 # Variable c_long
ERROR_UNEXP_NET_ERR = 59 # Variable c_long
ODS_COMBOBOXEDIT = 4096 # Variable c_int

_tagPARSEACTION = c_int # enum
PARSE_CANONICALIZE = 1
PARSE_FRIENDLY = 2
PARSE_SECURITY_URL = 3
PARSE_ROOTDOCUMENT = 4
PARSE_DOCUMENT = 5
PARSE_ANCHOR = 6
PARSE_ENCODE = 7
PARSE_DECODE = 8
PARSE_PATH_FROM_URL = 9
PARSE_URL_FROM_PATH = 10
PARSE_MIME = 11
PARSE_SERVER = 12
PARSE_SCHEMA = 13
PARSE_SITE = 14
PARSE_DOMAIN = 15
PARSE_LOCATION = 16
PARSE_SECURITY_DOMAIN = 17
IME_CONFIG_GENERAL = 1 # Variable c_int
WM_IME_KEYLAST = 271 # Variable c_int
SSWF_CUSTOM = 4 # Variable c_int
GCP_GLYPHSHAPE = 16 # Variable c_int
OFN_SHARENOWARN = 1 # Variable c_int
RPC_S_DUPLICATE_ENDPOINT = 1740 # Variable c_long
SEC_FILE = 8388608 # Variable c_int
SZDDESYS_ITEM_FORMATS = 'Formats' # Variable POINTER(c_wchar)
JOB_NOTIFY_FIELD_PAGES_PRINTED = 21 # Variable c_int
GENERIC_ALL = 268435456 # Variable c_long
STM_GETICON = 369 # Variable c_int
HTRIGHT = 11 # Variable c_int
DDL_READONLY = 1 # Variable c_int
STD_PRINT = 14 # Variable c_int
RPC_E_CANTPOST_INSENDCALL = -2147418109 # Variable c_long
RPC_S_INVALID_NETWORK_OPTIONS = 1724 # Variable c_long
WSAEHOSTDOWN = 10064 # Variable c_int
SE_GROUP_USE_FOR_DENY_ONLY = 16 # Variable c_long
ERROR_CLASS_ALREADY_EXISTS = 1410 # Variable c_long
DRIVE_RAMDISK = 6 # Variable c_int
BF_SOFT = 4096 # Variable c_int
ABN_FULLSCREENAPP = 2 # Variable c_int
MCI_STEP = 2062 # Variable c_int
URLACTION_SHELL_CURR_MAX = 6149 # Variable c_int
ERROR_INVALID_DOMAIN_ROLE = 1354 # Variable c_long
SUBLANG_CHINESE_TRADITIONAL = 1 # Variable c_int
META_SETTEXTCOLOR = 521 # Variable c_int
ERROR_EMPTY = 4306 # Variable c_long
IMAGE_REL_SH3_STARTOF_SECTION = 12 # Variable c_int
SM_CYMAXTRACK = 60 # Variable c_int
META_CREATEBRUSHINDIRECT = 764 # Variable c_int
DMDUP_SIMPLEX = 1 # Variable c_int
ERROR_RESOURCE_LANG_NOT_FOUND = 1815 # Variable c_long
PBT_APMRESUMESUSPEND = 7 # Variable c_int
TVGN_CHILD = 4 # Variable c_int
DBG_CONTINUE = 65538 # Variable c_ulong
TT_PRIM_CSPLINE = 3 # Variable c_int
DESCKIND_NONE = 0
SE_SYSTEM_ENVIRONMENT_NAME = 'SeSystemEnvironmentPrivilege' # Variable POINTER(c_wchar)
EV_PERR = 512 # Variable c_int
PC_RESERVED = 1 # Variable c_int
URLPOLICY_AUTHENTICATE_MUTUAL_ONLY = 196608 # Variable c_int
ILD_ROP = 64 # Variable c_int
IMAGE_REL_SH3_PCREL8_WORD = 9 # Variable c_int
CALLBACK_WINDOW = 65536 # Variable c_long
CB_GETTOPINDEX = 347 # Variable c_int
DTM_SETFORMATA = 4101 # Variable c_int
PERF_COUNTER_LARGE_QUEUELEN_TYPE = 4523264 # Variable c_int
SYSPAL_STATIC = 1 # Variable c_int
MM_LOENGLISH = 4 # Variable c_int
TBN_GETINFOTIPW = 4294966577 # Variable c_uint
ERROR_INVALID_STATE = 5023 # Variable c_long
STG_E_READFAULT = -2147287010 # Variable c_long
TVHT_ONITEMINDENT = 8 # Variable c_int
MS_DSR_ON = 32 # Variable c_ulong
INET_E_AUTHENTICATION_REQUIRED = -2146697207 # Variable c_long
CTRY_UAE = 971 # Variable c_int
DMLERR_MEMORY_ERROR = 16392 # Variable c_int
BINDSTATUS_INSTALLINGCOMPONENTS = 8
BACKUP_SECURITY_DATA = 3 # Variable c_int
JOY_CAL_READYONLY = 2097152 # Variable c_long
HOTKEYF_ALT = 4 # Variable c_int
OBJ_REGION = 8 # Variable c_int
META_INVERTREGION = 298 # Variable c_int
ERROR_DISK_RECALIBRATE_FAILED = 1126 # Variable c_long
MCI_STATUS_TIME_FORMAT = 6 # Variable c_long
EMR_MOVETOEX = 27 # Variable c_int
IMAGE_REL_IA64_DIR64 = 5 # Variable c_int
CF_PENDATA = 10 # Variable c_int
MIXERCONTROL_CONTROLTYPE_CUSTOM = 0 # Variable c_long
EV_EVENT1 = 2048 # Variable c_int
MMIOERR_CHUNKNOTFOUND = 265 # Variable c_int
FIONREAD = 1074030207 # Variable c_long
ERROR_INVALID_SHOWWIN_COMMAND = 1449 # Variable c_long
CONNDLG_RO_PATH = 1 # Variable c_int
AUDIT_ALLOW_NO_PRIVILEGE = 1 # Variable c_int
EMR_SETBKMODE = 18 # Variable c_int
CF_DIF = 5 # Variable c_int
MMIO_REMOVEPROC = 131072 # Variable c_int
ADVF_NODATA = 1
EMR_MODIFYWORLDTRANSFORM = 36 # Variable c_int
VT_UI4 = 19
MCI_SET_VIDEO = 4096 # Variable c_long
SERVICE_KERNEL_DRIVER = 1 # Variable c_int
LOCALE_S2359 = 41 # Variable c_int
MF_DISABLED = 2 # Variable c_long
CW_USEDEFAULT = -2147483648 # Variable c_int
SPLREG_NET_POPUP = 'NetPopup' # Variable POINTER(c_wchar)
HWND_DESKTOP = 0 # Variable POINTER(HWND__)
DFCS_SCROLLDOWN = 1 # Variable c_int
CDM_GETFOLDERPATH = 1126 # Variable c_int
DDE_FACKRESERVED = -49408 # Variable c_int
PAN_CONTRAST_LOW = 4 # Variable c_int
MM_STREAM_ERROR = 983 # Variable c_int
VK_PRIOR = 33 # Variable c_int
PROCESSOR_ARCHITECTURE_UNKNOWN = 65535 # Variable c_int
DC_BINNAMES = 12 # Variable c_int
XST_EXECACKRCVD = 10 # Variable c_int
TIME_ZONE_ID_STANDARD = 1 # Variable c_int
LOCALE_SABBREVMONTHNAME5 = 72 # Variable c_int
LVS_EX_FLATSB = 256 # Variable c_int
MCIERR_UNRECOGNIZED_KEYWORD = 259 # Variable c_int
LB_RESETCONTENT = 388 # Variable c_int
IME_CHOTKEY_SHAPE_TOGGLE = 17 # Variable c_int
CO_E_APPSINGLEUSE = -2147221002 # Variable c_long
PORT_STATUS_OUT_OF_MEMORY = 9 # Variable c_int
FACILITY_CERT = 11 # Variable c_int
JOY_BUTTON14 = 8192 # Variable c_long
SM_CXMINSPACING = 47 # Variable c_int
MF_MENUBARBREAK = 32 # Variable c_long
LANG_SINDHI = 89 # Variable c_int
META_SETBKCOLOR = 513 # Variable c_int
QUERY_IS_CACHED_OR_MAPPED = 11
TYMED_HGLOBAL = 1
FOF_SILENT = 4 # Variable c_int
TYSPEC_PACKAGENAME = 8
WNNC_NET_TWINS = 2359296 # Variable c_int
REPARSE_GUID_DATA_BUFFER_HEADER_SIZE = 24 # Variable c_long
PERF_COUNTER_TIMER_INV = 557909248 # Variable c_int
PERF_AVERAGE_BASE = 1073939458 # Variable c_int
CLOSECHANNEL = 4112 # Variable c_int
STUB_CALL_SERVER_NO_HRESULT = 3
rad6 = 1061 # Variable c_int
CTRY_PANAMA = 507 # Variable c_int
EVENTLOG_FORWARDS_READ = 4 # Variable c_int
JOB_READ = 131088 # Variable c_long
MF_INSERT = 0 # Variable c_long
LOCALE_SYSTEM_DEFAULT = 2048 # Variable c_ulong
LVN_LAST = 4294967097 # Variable c_uint
SUBLANG_FRENCH = 1 # Variable c_int
ERROR_NO_SUCH_MEMBER = 1387 # Variable c_long
OLE_E_NOSTORAGE = -2147221486 # Variable c_long
TIME_NOSECONDS = 2 # Variable c_int
BN_SETFOCUS = 6 # Variable c_int
PGN_SCROLL = 4294966395 # Variable c_uint
ERROR_OUT_OF_PAPER = 28 # Variable c_long
SPAPI_E_FILEQUEUE_LOCKED = -2146500074 # Variable c_long
CBES_EX_PATHWORDBREAKPROC = 4 # Variable c_int
RPC_X_INVALID_PIPE_OBJECT = 1830 # Variable c_long
PSINJECT_PAGETRAILER = 13 # Variable c_int
NCBASTAT = 51 # Variable c_int
DECIMAL_NEG = 128 # Variable c_ubyte
RB_SETTOOLTIPS = 1042 # Variable c_int
PAN_SERIF_OBTUSE_COVE = 3 # Variable c_int
TAPE_DRIVE_GET_ABSOLUTE_BLK = 1048576 # Variable c_int
EMR_SELECTPALETTE = 48 # Variable c_int
PSD_DISABLEORIENTATION = 256 # Variable c_int
LVIF_STATE = 8 # Variable c_int
DST_COMPLEX = 0 # Variable c_int
MEM_E_INVALID_SIZE = -2146959343 # Variable c_long
TAPE_DRIVE_SEQUENTIAL_FMKS = 2148007936 # Variable c_uint
EM_SETRECTNP = 180 # Variable c_int
SKF_TRISTATE = 128 # Variable c_int
SIZE_MAXHIDE = 4 # Variable c_int
HELP_PARTIALKEY = 261 # Variable c_long
MCM_SETDAYSTATE = 4104 # Variable c_int
MIXERCONTROL_CONTROLTYPE_STEREOENH = 536936453 # Variable c_long
TVHT_TOLEFT = 2048 # Variable c_int
PROCESSOR_ARM920 = 2336 # Variable c_int
CO_E_APPDIDNTREG = -2147220994 # Variable c_long
SMEXF_HANDLER = 2
TAPE_SPACE_RELATIVE_BLOCKS = 5 # Variable c_long
PSWIZB_FINISH = 4 # Variable c_int
PIPE_CLIENT_END = 0 # Variable c_int
SPI_SETDEFAULTINPUTLANG = 90 # Variable c_int
OBJ_PAL = 5 # Variable c_int
FOURCC_DOS = 542330692 # Variable c_ulong
NRC_INVDDID = 59 # Variable c_int
N_TMASK1 = 192 # Variable c_int
REPARSE_DATA_BUFFER_HEADER_SIZE = 8 # Variable c_long
TCS_FLATBUTTONS = 8 # Variable c_int
ILC_COLOR32 = 32 # Variable c_int
SB_LINELEFT = 0 # Variable c_int
WM_SYSDEADCHAR = 263 # Variable c_int
DISP_CHANGE_BADPARAM = -5 # Variable c_int
MIXER_OBJECTF_AUX = 1342177280 # Variable c_long
RPCFLG_NON_NDR = 2147483648 # Variable c_ulong
AF_ISO = 7 # Variable c_int
IMAGE_SUBSYSTEM_WINDOWS_CE_GUI = 9 # Variable c_int
TVIF_PARAM = 4 # Variable c_int
MCI_RECORD = 2063 # Variable c_int
EC_ENABLEALL = 0 # Variable c_int
OLECLOSE_SAVEIFDIRTY = 0
HDI_DI_SETITEM = 64 # Variable c_int
RESOURCEUSAGE_RESERVED = 2147483648 # Variable c_uint
JOY_BUTTON3 = 4 # Variable c_int
MB_ICONASTERISK = 64 # Variable c_long
VFT2_FONT_TRUETYPE = 3 # Variable c_long
TPM_VCENTERALIGN = 16 # Variable c_long
STREAM_CONTAINS_PROPERTIES = 4 # Variable c_int
SPLDS_PRINT_MIN_X_EXTENT = 'printMinXExtent' # Variable POINTER(c_wchar)
ERROR_PARTITION_FAILURE = 1105 # Variable c_long
psh8 = 1031 # Variable c_int
PC_WIDE = 16 # Variable c_int
TVM_ENSUREVISIBLE = 4372 # Variable c_int
CRYPT_E_OSS_ERROR = -2146881536 # Variable c_long
S_NORMAL = 0 # Variable c_int
AdapterType = 4
MCI_SEQ_STATUS_TEMPO = 16386 # Variable c_long
ERROR_BUFFER_OVERFLOW = 111 # Variable c_long
SUBLANG_SPANISH_VENEZUELA = 8 # Variable c_int
IOC_IN = 2147483648 # Variable c_uint
TOKEN_ADJUST_GROUPS = 64 # Variable c_int
PAN_CONTRAST_MEDIUM_LOW = 5 # Variable c_int
TVM_INSERTITEMW = 4402 # Variable c_int
SERVICE_ACTIVE = 1 # Variable c_int
ERROR_POPUP_ALREADY_ACTIVE = 1446 # Variable c_long
COMMON_LVB_SBCSDBCS = 768 # Variable c_int
WAVERR_BASE = 32 # Variable c_int
ERROR_INVALID_SERVICE_ACCOUNT = 1057 # Variable c_long
PC_INTERIORS = 128 # Variable c_int
DIALOPTION_DIALTONE = 256 # Variable c_int
URLACTION_SCRIPT_CURR_MAX = 5125 # Variable c_int
MK_E_UNAVAILABLE = -2147221021 # Variable c_long
WMSZ_RIGHT = 2 # Variable c_int

tagDISCARDCACHE = c_int # enum
DISCARDCACHE_SAVEIFDIRTY = 0
DISCARDCACHE_NOSAVE = 1
LVKF_SHIFT = 4 # Variable c_int
TAPE_LONG_FILEMARKS = 3 # Variable c_long
TIME_SAMPLES = 2 # Variable c_int
PORT_STATUS_WARMING_UP = 11 # Variable c_int
MB_TOPMOST = 262144 # Variable c_long
URLTEMPLATE_PREDEFINED_MAX = 131072
WC_COMBOBOXEXA = 'ComboBoxEx32' # Variable POINTER(c_char)
IME_SMODE_PHRASEPREDICT = 8 # Variable c_int
ACTIVEOBJECT_WEAK = 1 # Variable c_int
WSB_PROP_MASK = 4095 # Variable c_long
LB_SELITEMRANGE = 411 # Variable c_int
CTRY_HONDURAS = 504 # Variable c_int
STN_DISABLE = 3 # Variable c_int
STREAM_SPARSE_ATTRIBUTE = 8 # Variable c_int
VARCMP_NULL = 3 # Variable c_int
SS_REALSIZEIMAGE = 2048 # Variable c_long
UI_CAP_ROTANY = 4 # Variable c_int
ERROR_REGISTRY_RECOVERED = 1014 # Variable c_long
C2_SEGMENTSEPARATOR = 9 # Variable c_int
ICC_TAB_CLASSES = 8 # Variable c_int
STG_E_PATHNOTFOUND = -2147287037 # Variable c_long
IME_ESC_RESERVED_FIRST = 4 # Variable c_int
PBTF_APMRESUMEFROMFAILURE = 1 # Variable c_int
IMAGE_SYM_CLASS_BIT_FIELD = 18 # Variable c_int
DT_MODIFYSTRING = 65536 # Variable c_int
RPC_E_CANTCALLOUT_ININPUTSYNCCALL = -2147417843 # Variable c_long
RPC_E_CANTCALLOUT_INEXTERNALCALL = -2147418107 # Variable c_long
REG_DWORD_LITTLE_ENDIAN = 4 # Variable c_int
SRCAND = 8913094 # Variable c_ulong
PERF_100NSEC_MULTI_TIMER = 575735040 # Variable c_int
WH_DEBUG = 9 # Variable c_int
SPAPI_E_INVALID_COINSTALLER = -2146500057 # Variable c_long
DS_MODALFRAME = 128 # Variable c_long
PRINTER_ENUM_ICON7 = 4194304 # Variable c_int
WSB_PROP_CYVSCROLL = 1 # Variable c_long
PAN_STRAIGHT_ARMS_DOUBLE_SERIF = 6 # Variable c_int
STGFMT_DOCUMENT = 0 # Variable c_int
MS_RING_ON = 64 # Variable c_ulong
EXCEPTION_DEBUG_EVENT = 1 # Variable c_int
stc20 = 1107 # Variable c_int
EWX_LOGOFF = 0 # Variable c_int
CF_SHOWHELP = 4 # Variable c_long
MK_E_NOTBOUND = -2147221015 # Variable c_long
CO_E_BAD_PATH = -2146959356 # Variable c_long
ERROR_INVALID_CATEGORY = 117 # Variable c_long
SEE_MASK_DOENVSUBST = 512 # Variable c_int
RBHT_CAPTION = 2 # Variable c_int
MCI_VD_OFFSET = 1024 # Variable c_int
chx4 = 1043 # Variable c_int
EMR_SETMETARGN = 28 # Variable c_int
BAUD_2400 = 256 # Variable c_ulong
LANG_GEORGIAN = 55 # Variable c_int
ERROR_ALIAS_EXISTS = 1379 # Variable c_long
ERROR_LISTBOX_ID_NOT_FOUND = 1416 # Variable c_long
HANDLE_FLAG_PROTECT_FROM_CLOSE = 2 # Variable c_int
CONTEXT_SEGMENTS = 65540 # Variable c_long
MIXER_GETLINEINFOF_QUERYMASK = 15 # Variable c_long
MCIERR_MISSING_STRING_ARGUMENT = 269 # Variable c_int
PBT_APMRESUMEAUTOMATIC = 18 # Variable c_int
DOMAIN_GROUP_RID_CONTROLLERS = 516 # Variable c_long
DMPAPER_ENV_9 = 19 # Variable c_int
URLACTION_SCRIPT_SAFE_ACTIVEX = 5125 # Variable c_int
IMC_GETCOMPOSITIONWINDOW = 11 # Variable c_int
VFT2_DRV_INSTALLABLE = 8 # Variable c_long
KEY_EXECUTE = 131097 # Variable c_long
DDE_FADVRESERVED = -49153 # Variable c_int
MOD_SQSYNTH = 3 # Variable c_int
NIM_MODIFY = 1 # Variable c_int
DMPAPER_A2 = 66 # Variable c_int
IDHOT_SNAPDESKTOP = -2 # Variable c_int
WM_ACTIVATEAPP = 28 # Variable c_int
TYPEFLAG_FREVERSEBIND = 8192
SPI_GETKEYBOARDDELAY = 22 # Variable c_int
SM_DBCSENABLED = 42 # Variable c_int
DC_DRIVER = 11 # Variable c_int
STG_E_INVALIDFLAG = -2147286785 # Variable c_long
WM_SPOOLERSTATUS = 42 # Variable c_int
EVENTLOG_WARNING_TYPE = 2 # Variable c_int
VAR_TIMEVALUEONLY = 1 # Variable c_ulong
MIDIERR_UNPREPARED = 64 # Variable c_int
COLOR_INACTIVECAPTION = 3 # Variable c_int
EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X = 18 # Variable c_int
ENUM_CURRENT_SETTINGS = 4294967295 # Variable c_ulong
JOYCAPS_HASU = 4 # Variable c_int
CT_CTYPE2 = 2 # Variable c_int
LANG_CROATIAN = 26 # Variable c_int
HDN_ENDTRACKA = 4294966989 # Variable c_uint
SE_DACL_DEFAULTED = 8 # Variable c_int
SND_PURGE = 64 # Variable c_int
STD_DELETE = 5 # Variable c_int
EMARCH_ENC_I17_IMM5C_VAL_POS_X = 16 # Variable c_int
LANG_JAPANESE = 17 # Variable c_int
ERROR_SEVERITY_INFORMATIONAL = 1073741824 # Variable c_int
CTRY_INDONESIA = 62 # Variable c_int
SW_MAXIMIZE = 3 # Variable c_int

tagSF_TYPE = c_int # enum
SF_ERROR = 10
SF_I1 = 16
SF_I2 = 2
SF_I4 = 3
SF_I8 = 20
SF_BSTR = 8
SF_UNKNOWN = 13
SF_DISPATCH = 9
SF_VARIANT = 12
SF_RECORD = 36
SF_HAVEIID = 32781
CO_E_OBJNOTCONNECTED = -2147220995 # Variable c_long
MCI_DEVTYPE_SCANNER = 518 # Variable c_int
SAVE_CTM = 4101 # Variable c_int
WSAENOBUFS = 10055 # Variable c_int
WM_POWER = 72 # Variable c_int
MSGF_COMMCTRL_DRAGSELECT = 16898 # Variable c_int
JOB_OBJECT_UILIMIT_ALL = 255 # Variable c_int
PROGRESS_CLASSA = 'msctls_progress32' # Variable POINTER(c_char)
UPDFCACHE_ONLYIFBLANK = 2147483648 # Variable c_uint
ERROR_EAS_DIDNT_FIT = 275 # Variable c_long
TA_LEFT = 0 # Variable c_int
JOY_POVFORWARD = 0 # Variable c_int
LVM_GETBKIMAGEA = 4165 # Variable c_int
ERROR_BAD_COMMAND = 22 # Variable c_long
MCI_LAST = 4095 # Variable c_int
LBN_SELCHANGE = 1 # Variable c_int
LOCALE_SDAYNAME2 = 43 # Variable c_int
PAN_FAMILY_SCRIPT = 3 # Variable c_int
VARFLAG_FUIDEFAULT = 512
ERROR_NO_SUCH_LOGON_SESSION = 1312 # Variable c_long
TA_NOUPDATECP = 0 # Variable c_int
MIXERLINE_TARGETTYPE_MIDIIN = 4 # Variable c_int
LB_GETLOCALE = 422 # Variable c_int
WGL_SWAP_UNDERLAY1 = 65536 # Variable c_int
WSAEINVAL = 10022 # Variable c_int
LB_SETCOLUMNWIDTH = 405 # Variable c_int
RPC_S_NO_PROTSEQS = 1719 # Variable c_long
RPC_S_INVALID_TIMEOUT = 1709 # Variable c_long
RPC_E_VERSION_MISMATCH = -2147417840 # Variable c_long
EMARCH_ENC_I17_IMM41a_INST_WORD_X = 1 # Variable c_int
DDE_FPOKRESERVED = -8193 # Variable c_int
RPC_S_INVALID_STRING_BINDING = 1700 # Variable c_long
SYSTEM_FLAG_REMOTE_BOOT_CLIENT = 1 # Variable c_int
URLOSTRM_GETNEWESTVERSION = 3 # Variable c_int
ERROR_SHARING_VIOLATION = 32 # Variable c_long
LVM_SETTEXTCOLOR = 4132 # Variable c_int
HDI_IMAGE = 32 # Variable c_int
PRINTER_ENUM_DEFAULT = 1 # Variable c_int
DMPAPER_NOTE = 18 # Variable c_int
MM_JOY2MOVE = 929 # Variable c_int
OLEIVERB_HIDE = -3 # Variable c_long
MA_ACTIVATEANDEAT = 2 # Variable c_int
CDM_HIDECONTROL = 1129 # Variable c_int
BINDINFOF_URLENCODEDEXTRAINFO = 2
CF_NULL = 0 # Variable c_int
RAND_MAX = 32767 # Variable c_int
ERROR_CLUSTER_SHUTTING_DOWN = 5022 # Variable c_long
MMSYSERR_NOTSUPPORTED = 8 # Variable c_int
ERROR_REDIRECTOR_HAS_OPEN_HANDLES = 1794 # Variable c_long
PBT_APMSUSPEND = 4 # Variable c_int
edt4 = 1155 # Variable c_int
SPLDS_PRIORITY = 'priority' # Variable POINTER(c_wchar)
STG_E_INVALIDHEADER = -2147286789 # Variable c_long
PRINTER_CHANGE_CONFIGURE_PORT = 2097152 # Variable c_int
FILE_PERSISTENT_ACLS = 8 # Variable c_int
RPC_C_QOS_CAPABILITIES_DEFAULT = 0 # Variable c_int
PDERR_PARSEFAILURE = 4098 # Variable c_int
VIF_CANNOTDELETE = 4096 # Variable c_long
TC_SIGNAL = 3 # Variable c_int
ERROR_POSSIBLE_DEADLOCK = 1131 # Variable c_long
SERVICE_CONTROL_INTERROGATE = 4 # Variable c_int
WH_CALLWNDPROCRET = 12 # Variable c_int
ERROR_INVALID_PRINT_MONITOR = 3007 # Variable c_long
DCTT_SUBDEV = 4 # Variable c_long
chx10 = 1049 # Variable c_int
SB_GETBORDERS = 1031 # Variable c_int
MB_YESNO = 4 # Variable c_long
OF_SHARE_EXCLUSIVE = 16 # Variable c_int
SO_DONTLINGER = 4294967167 # Variable c_uint
NDR_IEEE_FLOAT = 0 # Variable c_ulong
META_EXTFLOODFILL = 1352 # Variable c_int
SHGNLI_NOUNIQUE = 4 # Variable c_int
MCIERR_HARDWARE = 262 # Variable c_int
ERROR_INVALID_BLOCK = 9 # Variable c_long
IMAGE_CURSOR = 2 # Variable c_int
ODS_DEFAULT = 32 # Variable c_int
SUBLANG_CHINESE_SINGAPORE = 4 # Variable c_int
HICF_ENTERING = 16 # Variable c_int
SPI_SETKEYBOARDPREF = 69 # Variable c_int
CF_NOSIZESEL = 2097152 # Variable c_long
EM_LINEINDEX = 187 # Variable c_int
PRINTER_NOTIFY_FIELD_SHARE_NAME = 2 # Variable c_int
HICF_LEAVING = 32 # Variable c_int
UOI_TYPE = 3 # Variable c_int
RPC_X_SS_IN_NULL_CONTEXT = 1775 # Variable c_long
NM_CHAR = 4294967278 # Variable c_uint
_HEX = 128 # Variable c_int
TAPE_DRIVE_COMPRESSION = 131072 # Variable c_int
AC_LINE_ONLINE = 1 # Variable c_int
ERROR_NON_MDICHILD_WINDOW = 1445 # Variable c_long
VK_SCROLL = 145 # Variable c_int
ERROR_EA_ACCESS_DENIED = 994 # Variable c_long
LANG_USER_DEFAULT = 1024 # Variable c_int
MMIOERR_CANNOTOPEN = 259 # Variable c_int
QUERYESCSUPPORT = 8 # Variable c_int
MAXIMUM_SUPPORTED_EXTENSION = 512 # Variable c_int
OR_INVALID_SET = 1912 # Variable c_long
RPC_C_PROTECT_LEVEL_PKT_PRIVACY = 6 # Variable c_int
HELP_FORCEFILE = 9 # Variable c_long
BS_DIBPATTERN = 5 # Variable c_int
ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = 1220 # Variable c_long
PGM_GETBUTTONSTATE = 5132 # Variable c_int
MIXERCONTROL_CT_UNITS_MASK = 16711680 # Variable c_long
PSINJECT_BEGINPAGESETUP = 10 # Variable c_int
DTM_SETSYSTEMTIME = 4098 # Variable c_int
MCI_GETDEVCAPS_CAN_SAVE = 9 # Variable c_long
PAN_CONTRAST_VERY_HIGH = 9 # Variable c_int
DFCS_BUTTONRADIO = 4 # Variable c_int
TTN_LAST = 4294966747 # Variable c_uint
BINDSTATUS_ENDDOWNLOADCOMPONENTS = 9
WM_ACTIVATE = 6 # Variable c_int
PRINTER_ENUM_ICON5 = 1048576 # Variable c_int
SZ_URLCONTEXT = 'URL Context' # Variable POINTER(c_wchar)
PSD_INHUNDREDTHSOFMILLIMETERS = 8 # Variable c_int
CCS_NOPARENTALIGN = 8 # Variable c_long
META_SETDIBTODEV = 3379 # Variable c_int
LVM_GETTOPINDEX = 4135 # Variable c_int
CD_LBSELSUB = 1 # Variable c_int
MOUSEEVENTF_MIDDLEDOWN = 32 # Variable c_int
MAP_FOLDCZONE = 16 # Variable c_int
WSASYSNOTREADY = 10091 # Variable c_int
PAN_MIDLINE_STANDARD_POINTED = 3 # Variable c_int
MDITILE_SKIPDISABLED = 2 # Variable c_int
JOY_BUTTON2 = 2 # Variable c_int
WC_TABCONTROLA = 'SysTabControl32' # Variable POINTER(c_char)
PRINTER_CHANGE_ADD_PRINT_PROCESSOR = 16777216 # Variable c_int
CBR_56000 = 56000 # Variable c_int
LOGON32_LOGON_SERVICE = 5 # Variable c_int
STG_E_INVALIDPOINTER = -2147287031 # Variable c_long
BSF_NOTIMEOUTIFNOTHUNG = 64 # Variable c_int
CBN_EDITUPDATE = 6 # Variable c_int
WM_GETTEXT = 13 # Variable c_int
MIXERCONTROL_CT_UNITS_BOOLEAN = 65536 # Variable c_long
IMC_SETCOMPOSITIONWINDOW = 12 # Variable c_int
ADVF_PRIMEFIRST = 2
ERROR_CANTWRITE = 1013 # Variable c_long
MCI_GETDEVCAPS_CAN_EJECT = 7 # Variable c_long
COMMON_LVB_GRID_LVERTICAL = 2048 # Variable c_int
MCIERR_CANNOT_USE_ALL = 279 # Variable c_int
MIDIPROP_SET = 2147483648 # Variable c_ulong
_MAX_PATH = 260 # Variable c_int
VT_EMPTY = 0
ERROR_BADKEY = 1010 # Variable c_long
GCL_WNDPROC = -24 # Variable c_int
HDS_DRAGDROP = 64 # Variable c_int
NUMLOCK_ON = 32 # Variable c_int
PROCESSOR_STRONGARM = 2577 # Variable c_int
IMAGE_DIRECTORY_ENTRY_EXPORT = 0 # Variable c_int
MCI_STRING_OFFSET = 512 # Variable c_int
SC_ACTION_NONE = 0
CF_SCALABLEONLY = 131072 # Variable c_long
MMIOM_CLOSE = 4 # Variable c_int
LVN_BEGINDRAG = 4294967187 # Variable c_uint
URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY = 4610 # Variable c_int
GCL_HBRBACKGROUND = -10 # Variable c_int
RPC_X_WRONG_PIPE_VERSION = 1832 # Variable c_long
ERROR_BAD_NETPATH = 53 # Variable c_long
IS_TEXT_UNICODE_REVERSE_SIGNATURE = 128 # Variable c_int
SO_SNDBUF = 4097 # Variable c_int
STD_REDOW = 4 # Variable c_int
SIOCSHIWAT = 2147775232 # Variable c_ulong
ABE_TOP = 1 # Variable c_int
QUERY_USES_CACHE = 12
TYMED_FILE = 2
CF_WAVE = 12 # Variable c_int
MAXDWORD = 4294967295 # Variable c_uint
LVM_GETITEMSTATE = 4140 # Variable c_int
ENUM_S_LAST = 262591 # Variable c_long
AUXCAPS_CDAUDIO = 1 # Variable c_int
ERROR_DS_CANT_ON_NON_LEAF = 1934 # Variable c_long
DM_DUPLEX = 4096 # Variable c_long
STOPBITS_10 = 1 # Variable c_ushort
FILE_ATTRIBUTE_NORMAL = 128 # Variable c_int
ERROR_NO_SITENAME = 1919 # Variable c_long
EMR_SCALEWINDOWEXTEX = 32 # Variable c_int
SIZE_MAXSHOW = 3 # Variable c_int
LVM_GETISEARCHSTRINGW = 4213 # Variable c_int
MCI_ANIM_STATUS_SPEED = 16385 # Variable c_long
OR_INVALID_OID = 1911 # Variable c_long
ERROR_SERVER_HAS_OPEN_HANDLES = 1811 # Variable c_long
LVSICF_NOSCROLL = 2 # Variable c_int
WM_PENWINFIRST = 896 # Variable c_int
STD_INPUT_HANDLE = 4294967286 # Variable c_ulong
MCIERR_BAD_CONSTANT = 290 # Variable c_int
CAL_SMONTHNAME3 = 23 # Variable c_int
MCIERR_WAVE_SETOUTPUTINUSE = 321 # Variable c_int
CONTEXT_EXTENDED_REGISTERS = 65568 # Variable c_long

tagBINDSPEED = c_int # enum
BINDSPEED_INDEFINITE = 1
BINDSPEED_MODERATE = 2
BINDSPEED_IMMEDIATE = 3
ERROR_INVALID_PRINTER_COMMAND = 1803 # Variable c_long
FADF_EMBEDDED = 4 # Variable c_int
RPC_S_INVALID_BINDING = 1702 # Variable c_long
JOB_STATUS_DELETING = 4 # Variable c_int
WM_QUEUESYNC = 35 # Variable c_int
MNC_IGNORE = 0 # Variable c_int
DMPAPER_A3 = 8 # Variable c_int
PATPAINT = 16452105 # Variable c_ulong
NRC_CMDTMO = 5 # Variable c_int
SERVICE_WIN32_OWN_PROCESS = 16 # Variable c_int
RPC_C_PROTECT_LEVEL_PKT_INTEGRITY = 5 # Variable c_int
REG_CREATED_NEW_KEY = 1 # Variable c_long
UDM_SETPOS = 1127 # Variable c_int
VAR_DATEVALUEONLY = 2 # Variable c_ulong
WC_TREEVIEWA = 'SysTreeView32' # Variable POINTER(c_char)
SP_RLSD = 64 # Variable c_ulong
MAX_NATURAL_ALIGNMENT = 4 # Variable c_uint
RPC_S_TYPE_ALREADY_REGISTERED = 1712 # Variable c_long

tagCOINIT = c_int # enum
META_SETMAPMODE = 259 # Variable c_int
HOTKEYF_SHIFT = 1 # Variable c_int
AD_CLOCKWISE = 2 # Variable c_int
TBS_BOTH = 8 # Variable c_int
URLACTION_HTML_MAX = 6143 # Variable c_int
PBT_APMRESUMESTANDBY = 8 # Variable c_int
CFERR_MAXLESSTHANMIN = 8194 # Variable c_int
CTRY_ESTONIA = 372 # Variable c_int
LVSIL_NORMAL = 0 # Variable c_int
EMR_POLYBEZIERTO = 5 # Variable c_int
LVM_INSERTITEMA = 4103 # Variable c_int
ACS_TRANSPARENT = 2 # Variable c_int
NEWFRAME = 1 # Variable c_int
ERROR_NO_QUOTAS_FOR_ACCOUNT = 1302 # Variable c_long
SUBLANG_SPANISH_HONDURAS = 18 # Variable c_int
META_OFFSETVIEWPORTORG = 529 # Variable c_int
IME_CAND_STROKE = 5 # Variable c_int
ACCESS_PROPERTY_SET_GUID = 1 # Variable c_int
TBN_ENDADJUST = 4294966592 # Variable c_uint
PAN_MIDLINE_CONSTANT_SERIFED = 10 # Variable c_int
TBSTATE_MARKED = 128 # Variable c_int
OF_DELETE = 512 # Variable c_int
PD_ALLPAGES = 0 # Variable c_int
OLECLOSE_NOSAVE = 1
PROCESS_TERMINATE = 1 # Variable c_int
CCS_NORESIZE = 4 # Variable c_long
VS_FF_PATCHED = 4 # Variable c_long
MB_DEFMASK = 3840 # Variable c_long
LVCF_SUBITEM = 8 # Variable c_int
MK_E_FIRST = 2147746272 # Variable c_ulong
DTN_FORMATQUERYW = 4294966554 # Variable c_uint
DM_MEDIATYPE = 33554432 # Variable c_long
IMAGE_REL_ALPHA_HINT = 8 # Variable c_int
EMR_SETPOLYFILLMODE = 19 # Variable c_int
TVM_GETSCROLLTIME = 4386 # Variable c_int
DSPRINT_PUBLISH = 1 # Variable c_int
RecognizerType = 8
PSCB_INITIALIZED = 1 # Variable c_int
MM_JOY1BUTTONUP = 951 # Variable c_int
TAPE_DRIVE_SET_BLOCK_SIZE = 2147483664 # Variable c_uint
MK_S_FIRST = 262624 # Variable c_long
BSF_FLUSHDISK = 4 # Variable c_int
MCI_WAVE_STATUS_CHANNELS = 16386 # Variable c_long
CB_GETLBTEXT = 328 # Variable c_int
TVM_EDITLABELA = 4366 # Variable c_int
SPAPI_E_EXPECTED_SECTION_NAME = -2146500608 # Variable c_long
IP_OPTIONS = 1 # Variable c_int
CTRY_BRAZIL = 55 # Variable c_int
LMEM_DISCARDABLE = 3840 # Variable c_int
ERROR_LOGON_NOT_GRANTED = 1380 # Variable c_long
ERROR_ENCRYPTION_FAILED = 6000 # Variable c_long
ERROR_SPL_NO_ADDJOB = 3004 # Variable c_long
STGFMT_FILE = 3 # Variable c_int
MIXERR_INVALCONTROL = 1025 # Variable c_int
URLOSTRM_USECACHEDCOPY = 2 # Variable c_int
AF_CCITT = 10 # Variable c_int
META_SETSTRETCHBLTMODE = 263 # Variable c_int
WS_MINIMIZE = 536870912 # Variable c_long
CREATE_FOR_DIR = 2 # Variable c_int
OLEIVERB_DISCARDUNDOSTATE = -6 # Variable c_long

tagURLZONE = c_int # enum
URLZONE_PREDEFINED_MIN = 0
URLZONE_LOCAL_MACHINE = 0
URLZONE_INTRANET = 1
URLZONE_TRUSTED = 2
URLZONE_INTERNET = 3
URLZONE_UNTRUSTED = 4
URLZONE_PREDEFINED_MAX = 999
URLZONE_USER_MIN = 1000
URLZONE_USER_MAX = 10000
NI_SELECTCANDIDATESTR = 18 # Variable c_int
ERROR_BAD_CONFIGURATION = 1610 # Variable c_long
XCLASS_MASK = 64512 # Variable c_int
LANG_ICELANDIC = 15 # Variable c_int
TCS_FORCEICONLEFT = 16 # Variable c_int
MCIERR_DRIVER = 278 # Variable c_int
RBN_CHILDSIZE = 4294966457 # Variable c_uint
NRC_REMTFUL = 18 # Variable c_int
CREATE_SEPARATE_WOW_VDM = 2048 # Variable c_int
EMR_ANGLEARC = 41 # Variable c_int
SE_SECURITY_NAME = 'SeSecurityPrivilege' # Variable POINTER(c_wchar)
DISP_E_MEMBERNOTFOUND = -2147352573 # Variable c_long
VIEW_E_LAST = 2147746127 # Variable c_ulong
TIMERR_BASE = 96 # Variable c_int
DD_DEFDRAGDELAY = 200 # Variable c_int
SPI_SETICONTITLELOGFONT = 34 # Variable c_int
VOS_NT_WINDOWS32 = 262148 # Variable c_long
DMMEDIA_USER = 256 # Variable c_int
TPM_TOPALIGN = 0 # Variable c_long
MDMSPKRFLAG_OFF = 1 # Variable c_int
DTN_USERSTRINGW = 4294966551 # Variable c_uint
VK_END = 35 # Variable c_int
PARAMFLAG_FHASCUSTDATA = 64 # Variable c_int
DCBA_FACEDOWNNONE = 256 # Variable c_int
stc4 = 1091 # Variable c_int
PRINTER_ENUM_ICON6 = 2097152 # Variable c_int
ERROR_SET_POWER_STATE_FAILED = 1141 # Variable c_long
RB_IDTOINDEX = 1040 # Variable c_int
TTM_SETMAXTIPWIDTH = 1048 # Variable c_int
PSD_MARGINS = 2 # Variable c_int
ODT_LISTVIEW = 102 # Variable c_int
CAL_SMONTHNAME4 = 24 # Variable c_int
ERROR_EXE_MARKED_INVALID = 192 # Variable c_long
stc21 = 1108 # Variable c_int
BIND_MAYBOTHERUSER = 1
MMIO_PARSE = 256 # Variable c_int
IDB_HIST_SMALL_COLOR = 8 # Variable c_int
URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT = 131072 # Variable c_int
IMAGE_FILE_MACHINE_SH3 = 418 # Variable c_int
MA_NOACTIVATE = 3 # Variable c_int
BS_PUSHLIKE = 4096 # Variable c_long
LANG_NEUTRAL = 0 # Variable c_int
FKF_CLICKON = 64 # Variable c_int
IMAGE_DLLCHARACTERISTICS_WDM_DRIVER = 8192 # Variable c_int
FS_VIETNAMESE = 256 # Variable c_long
MCI_VD_SPIN_UP = 65536 # Variable c_long
ST_CONNECTED = 1 # Variable c_int
ERROR_PRODUCT_UNINSTALLED = 1614 # Variable c_long
STM_MSGMAX = 372 # Variable c_int
DMPAPER_ENV_C4 = 30 # Variable c_int
PAN_MIDLINE_CONSTANT_TRIMMED = 8 # Variable c_int
SSGF_DISPLAY = 3 # Variable c_int
MINHALF_PTR = 32768 # Variable c_int
NI_IMEMENUSELECTED = 24 # Variable c_int
SERVICE_DRIVER = 11 # Variable c_int
SPI_GETACCESSTIMEOUT = 60 # Variable c_int
STREAM_NORMAL_ATTRIBUTE = 0 # Variable c_int
IMAGE_SYM_TYPE_DWORD = 15 # Variable c_int
STGM_SIMPLE = 134217728 # Variable c_long
WNNC_NET_LANMAN = 131072 # Variable c_int
HWND_TOP = 0 # Variable POINTER(HWND__)
PRINTER_ATTRIBUTE_DEFAULT = 4 # Variable c_int
FILE_NOTIFY_CHANGE_CREATION = 64 # Variable c_int
FO_DELETE = 3 # Variable c_int
MIXERCONTROL_CONTROLTYPE_SLIDER = 1073872896 # Variable c_long
WININETINFO_OPTION_LOCK_HANDLE = 65534 # Variable c_int
PST_X25 = 259 # Variable c_ulong
JOB_OBJECT_LIMIT_VALID_FLAGS = 127 # Variable c_int
NTE_PROV_DLL_NOT_FOUND = -2146893794 # Variable c_long
HDM_GETORDERARRAY = 4625 # Variable c_int
SUBLANG_LITHUANIAN_CLASSIC = 2 # Variable c_int
DATADIR_SET = 2
MOD_FMSYNTH = 4 # Variable c_int
CONNECT_TEMPORARY = 4 # Variable c_int
BN_CLICKED = 0 # Variable c_int
LANG_SLOVENIAN = 36 # Variable c_int
PGF_INVISIBLE = 0 # Variable c_int
IMAGE_SYM_TYPE_NULL = 0 # Variable c_int
GCP_ERROR = 32768 # Variable c_int
RPCFLG_MESSAGE = 16777216 # Variable c_ulong
PRINTER_ENUM_SHARED = 32 # Variable c_int
IMAGE_SIZEOF_AUX_SYMBOL = 18 # Variable c_int
PRINTER_CHANGE_JOB = 65280 # Variable c_int
MCI_SEQ_DIV_SMPTE_30 = 1220 # Variable c_int
CCS_ADJUSTABLE = 32 # Variable c_long
RESOURCE_CONNECTED = 1 # Variable c_int
MF_SYSMENU = 8192 # Variable c_long
WM_HSCROLLCLIPBOARD = 782 # Variable c_int
LVNI_TORIGHT = 2048 # Variable c_int
WGL_SWAP_OVERLAY10 = 1024 # Variable c_int
SERVICE_ERROR_CRITICAL = 3 # Variable c_int
LOCALE_SDAYNAME3 = 44 # Variable c_int
RESOURCEDISPLAYTYPE_DOMAIN = 1 # Variable c_int
EPT_S_CANT_CREATE = 1899 # Variable c_long
VARFLAG_FNONBROWSABLE = 1024
WS_DISABLED = 134217728 # Variable c_long
AC_SRC_OVER = 0 # Variable c_int
ACCESS_SYSTEM_SECURITY = 16777216 # Variable c_long
WGL_SWAP_UNDERLAY2 = 131072 # Variable c_int
JOY_POVLEFT = 27000 # Variable c_int
DS_CENTERMOUSE = 4096 # Variable c_long
ERROR_TLW_WITH_WSCHILD = 1406 # Variable c_long
PAN_XHEIGHT_CONSTANT_LARGE = 4 # Variable c_int
WSAEDESTADDRREQ = 10039 # Variable c_int
GWL_USERDATA = -21 # Variable c_int
MOD_MAPPER = 5 # Variable c_int
IMAGE_REL_ARM_ADDR32 = 1 # Variable c_int
DC_TRUETYPE = 15 # Variable c_int
TVSIL_NORMAL = 0 # Variable c_int
SET_SPREAD = 4106 # Variable c_int
SS_ELLIPSISMASK = 49152 # Variable c_long
SPLDS_PRINT_COLOR = 'printColor' # Variable POINTER(c_wchar)
DISP_E_BADVARTYPE = -2147352568 # Variable c_long
IMAGE_SCN_ALIGN_512BYTES = 10485760 # Variable c_int
RC_SCALING = 4 # Variable c_int
MHDR_PREPARED = 2 # Variable c_int
SCS_CHANGECLAUSE = 36 # Variable c_int
CONTEXT_FULL = 65543 # Variable c_long
LVIS_SELECTED = 2 # Variable c_int
HDN_GETDISPINFOW = 4294966967 # Variable c_uint
HDN_ITEMDBLCLICKA = 4294966993 # Variable c_uint
OF_READWRITE = 2 # Variable c_int
CDDS_ITEM = 65536 # Variable c_int
CFS_RECT = 1 # Variable c_int
RB_GETPALETTE = 1062 # Variable c_int
BINDSTATUS_ENDDOWNLOADDATA = 6
EMR_SETROP2 = 20 # Variable c_int
ASPECTY = 42 # Variable c_int
SB_LINERIGHT = 1 # Variable c_int
TBTS_TOP = 0 # Variable c_int
CBS_DISABLENOSCROLL = 2048 # Variable c_long
MIXER_GETLINEINFOF_COMPONENTTYPE = 3 # Variable c_long
EV_RXFLAG = 2 # Variable c_int
MIXER_OBJECTF_MIDIOUT = 805306368 # Variable c_long
LB_GETCURSEL = 392 # Variable c_int
MNC_CLOSE = 1 # Variable c_int
CLASS_E_NOTLICENSED = -2147221230 # Variable c_long
DOF_DIRECTORY = 32771 # Variable c_int
CA_NEGATIVE = 1 # Variable c_int
PAN_PROP_CONDENSED = 6 # Variable c_int
NM_NCHITTEST = 4294967282 # Variable c_uint
TB_AUTOSIZE = 1057 # Variable c_int
chx11 = 1050 # Variable c_int
WM_PSD_FULLPAGERECT = 1025 # Variable c_int
FILE_ACTION_RENAMED_NEW_NAME = 5 # Variable c_int
RPC_E_CALL_CANCELED = -2147418110 # Variable c_long
TBCDRF_NOMARK = 524288 # Variable c_int
DM_PAPERWIDTH = 8 # Variable c_long
RBN_HEIGHTCHANGE = 4294966465 # Variable c_uint
OFN_SHOWHELP = 16 # Variable c_int
VTBIT_R4 = 16 # Variable c_int
ES_LEFT = 0 # Variable c_long
SO_SYNCHRONOUS_NONALERT = 32 # Variable c_int
FILE_ATTRIBUTE_HIDDEN = 2 # Variable c_int
psh14 = 1037 # Variable c_int
MCI_MODE_RECORD = 527 # Variable c_int
SERVICE_CONTROL_NETBINDDISABLE = 10 # Variable c_int
SERVICES_ACTIVE_DATABASEA = 'ServicesActive' # Variable POINTER(c_char)
WINSTA_READATTRIBUTES = 2 # Variable c_long
IO_COMPLETION_ALL_ACCESS = 2031619 # Variable c_long
SSWF_DISPLAY = 3 # Variable c_int
SE_GROUP_OWNER = 8 # Variable c_long
NRC_ENVNOTDEF = 52 # Variable c_int
SE_ASSIGNPRIMARYTOKEN_NAME = 'SeAssignPrimaryTokenPrivilege' # Variable POINTER(c_wchar)
MCI_DEVTYPE_ANIMATION = 519 # Variable c_int
MCIERR_NO_ELEMENT_ALLOWED = 301 # Variable c_int
MCI_VD_MEDIA_CAV = 1027 # Variable c_int
ERROR_INFLOOP_IN_RELOC_CHAIN = 202 # Variable c_long
CBR_38400 = 38400 # Variable c_int
FR_WHOLEWORD = 2 # Variable c_int
GGO_GLYPH_INDEX = 128 # Variable c_int
HOVER_DEFAULT = 4294967295 # Variable c_uint
PSM_CANCELTOCLOSE = 1131 # Variable c_int
META_CREATEPATTERNBRUSH = 505 # Variable c_int
DC_PAPERNAMES = 16 # Variable c_int
EXIT_FAILURE = 1 # Variable c_int
LVM_FIRST = 4096 # Variable c_int
LVIS_OVERLAYMASK = 3840 # Variable c_int
OLECREATE_LEAVERUNNING = 1 # Variable c_int
SO_MAXPATHDG = 28682 # Variable c_int
ERROR_CANTREAD = 1012 # Variable c_long
CACHE_E_NOCACHE_UPDATED = -2147221136 # Variable c_long
BF_TOPRIGHT = 6 # Variable c_int
FS_CHINESETRAD = 1048576 # Variable c_long
RPC_S_FP_OVERFLOW = 1771 # Variable c_long
ERROR_INVALID_GROUPNAME = 1209 # Variable c_long
TCS_RAGGEDRIGHT = 2048 # Variable c_int
SB_THUMBTRACK = 5 # Variable c_int
DMPAPER_A5_TRANSVERSE = 61 # Variable c_int
BST_INDETERMINATE = 2 # Variable c_int
CHANGEKIND_SETNAMES = 2
ERROR_BAD_FORMAT = 11 # Variable c_long
BINDSTATUS_USINGCACHEDCOPY = 10
NTM_NONNEGATIVE_AC = 65536 # Variable c_int
PERF_COUNTER_RAWCOUNT_HEX = 0 # Variable c_int
CB_LIMITTEXT = 321 # Variable c_int
GETSETPAPERBINS = 29 # Variable c_int
META_TEXTOUT = 1313 # Variable c_int
MIIM_SUBMENU = 4 # Variable c_int
NUMRESERVED = 106 # Variable c_int
ASYNC_MODE_DEFAULT = 0 # Variable c_long
OPEN_ALWAYS = 4 # Variable c_int
CAL_GREGORIAN_XLIT_ENGLISH = 11 # Variable c_int
LANG_KASHMIRI = 96 # Variable c_int
PIDSI_CHARCOUNT = 16 # Variable c_long
BINDSTATUS_MIMETYPEAVAILABLE = 13
JOYERR_NOCANDO = 166 # Variable c_int
DDL_POSTMSGS = 8192 # Variable c_int
MIXER_SETCONTROLDETAILSF_VALUE = 0 # Variable c_long
PAN_PROP_VERY_CONDENSED = 8 # Variable c_int
CO_E_OBJISREG = -2147220996 # Variable c_long
IMAGE_REL_IA64_ADDEND = 31 # Variable c_int
CO_E_INCOMPATIBLESTREAMVERSION = -2147220968 # Variable c_long
IMAGE_FILE_MACHINE_ALPHA64 = 644 # Variable c_int
CF_DIB = 8 # Variable c_int
CDERR_INITIALIZATION = 2 # Variable c_int
ADVF_ONLYONCE = 4
HGDI_ERROR = 4294967295 # Variable c_void_p
MCI_ANIM_GETDEVCAPS_FAST_RATE = 16386 # Variable c_long
VT_UI8 = 21
SUBLANG_SPANISH_URUGUAY = 14 # Variable c_int
IME_CMODE_ROMAN = 16 # Variable c_int
QID_SYNC = 4294967295 # Variable c_uint
CONVERT10_E_OLESTREAM_GET = -2147221056 # Variable c_long
PRINTER_CHANGE_ADD_PRINTER = 1 # Variable c_int
SPAPI_E_DI_BAD_PATH = -2146500076 # Variable c_long
LOCALE_STIME = 30 # Variable c_int
RPC_C_SECURITY_QOS_VERSION = 1 # Variable c_long
stc22 = 1109 # Variable c_int
REG_OPTION_CREATE_LINK = 2 # Variable c_long
HC_SKIP = 2 # Variable c_int
OLE_E_INVALIDHWND = -2147221489 # Variable c_long
BINDSTATUS_CACHEFILENAMEAVAILABLE = 14
SC_ACTION_RESTART = 1
ABM_GETTASKBARPOS = 5 # Variable c_int
IME_ESC_IME_NAME = 4102 # Variable c_int
MCI_SEQ_FORMAT_SONGPTR = 16385 # Variable c_int
E_FAIL = -2147467259 # Variable c_long
MAX_PRIORITY = 99 # Variable c_int
WM_MDINEXT = 548 # Variable c_int
DMICM_ABS_COLORIMETRIC = 4 # Variable c_int
SPAPI_E_BAD_INTERFACE_INSTALLSECT = -2146500067 # Variable c_long
TVM_GETCOUNT = 4357 # Variable c_int
ERROR_VC_DISCONNECTED = 240 # Variable c_long
ERROR_RESOURCE_NOT_AVAILABLE = 5006 # Variable c_long
PRINTER_ATTRIBUTE_DIRECT = 2 # Variable c_int
WS_VSCROLL = 2097152 # Variable c_long

_tagPSUACTION = c_int # enum
TYMED_ISTREAM = 4
TVI_FIRST = 4294901761 # Variable POINTER(_TREEITEM)
PSINJECT_VMRESTORE = 18 # Variable c_int
MAXSHORT = 32767 # Variable c_int
LCID_INSTALLED = 1 # Variable c_int
PBT_APMRESUMECRITICAL = 6 # Variable c_int
IA64_JMPE_MARKER = 3473423 # Variable c_int
SP_PARITY_CHECK = 32 # Variable c_ulong
RBN_DELETINGBAND = 4294966459 # Variable c_uint
SPI_SETBORDER = 6 # Variable c_int
TB_SETINDENT = 1071 # Variable c_int
IE_DEFAULT = -5 # Variable c_int
CAL_GREGORIAN_ME_FRENCH = 9 # Variable c_int
VK_CRSEL = 247 # Variable c_int
RPC_E_TOO_LATE = -2147417831 # Variable c_long
IMAGE_SYM_CLASS_STATIC = 3 # Variable c_int
DCX_INTERSECTRGN = 128 # Variable c_long
PSINJECT_ENDDEFAULTS = 4 # Variable c_int
GGO_GRAY2_BITMAP = 4 # Variable c_int
ERROR_BUS_RESET = 1111 # Variable c_long
ERROR_DOMAIN_TRUST_INCONSISTENT = 1810 # Variable c_long
CAL_SMONTHNAME2 = 22 # Variable c_int
AF_IPX = 6 # Variable c_int
LB_CTLCODE = 0 # Variable c_long
IDH_OK = 28443 # Variable c_int
CRYPT_E_INVALID_NUMERIC_STRING = -2146885600 # Variable c_long
FILE_SUPPORTS_REPARSE_POINTS = 128 # Variable c_int
CRYPT_E_UNKNOWN_ALGO = -2146889726 # Variable c_long
NIM_ADD = 0 # Variable c_int
NONZEROLHND = 2 # Variable c_int
RESOURCEDISPLAYTYPE_SHAREADMIN = 8 # Variable c_int
OBJ_ENHMETADC = 12 # Variable c_int
MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED = 4096 # Variable c_long
OLE_S_LAST = 262399 # Variable c_long
MDM_CELLULAR = 8 # Variable c_int
SHOW_FULLSCREEN = 3 # Variable c_int
ERROR_OLD_WIN_VERSION = 1150 # Variable c_long
USER_MARSHAL_FC_SMALL = 3 # Variable c_int
LOCALE_SENGLANGUAGE = 4097 # Variable c_int
RPC_C_OPT_MQ_ACKNOWLEDGE = 4 # Variable c_int
IME_CONFIG_SELECTDICTIONARY = 3 # Variable c_int
LB_ADDFILE = 406 # Variable c_int
BF_RECT = 15 # Variable c_int
SPI_GETBEEP = 1 # Variable c_int
CF_FORCEFONTEXIST = 65536 # Variable c_long
stc1 = 1088 # Variable c_int
ERROR_CONNECTION_ACTIVE = 1230 # Variable c_long
TBM_SETPAGESIZE = 1045 # Variable c_int
DRIVE_NO_ROOT_DIR = 1 # Variable c_int
ENABLE_LINE_INPUT = 2 # Variable c_int
_OUT_TO_MSGBOX = 2 # Variable c_int
VK_CAPITAL = 20 # Variable c_int
DFCS_CHECKED = 1024 # Variable c_int
WM_HOTKEY = 786 # Variable c_int
STD_FILESAVE = 8 # Variable c_int
DMPAPER_A5_EXTRA = 64 # Variable c_int
IMAGE_SIZEOF_STD_OPTIONAL_HEADER = 28 # Variable c_int
MCI_STATUS_READY = 7 # Variable c_long
META_SETWINDOWORG = 523 # Variable c_int
COLOR_ADJ_MIN = -100 # Variable c_short
WT_EXECUTEINWAITTHREAD = 4 # Variable c_int
TTM_SETTIPBKCOLOR = 1043 # Variable c_int
CONNECT_LOCALDRIVE = 256 # Variable c_int
BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE = 22
HKCOMB_SCA = 128 # Variable c_int
SPLDS_SPOOLER_KEY = 'DsSpooler' # Variable POINTER(c_wchar)
AUXCAPS_LRVOLUME = 2 # Variable c_int
LVM_GETWORKAREAS = 4166 # Variable c_int
OLECLOSE_PROMPTSAVE = 2
RTL_CRITSECT_TYPE = 0 # Variable c_int
ERROR_CRC = 23 # Variable c_long
CBEM_GETEXTENDEDSTYLE = 1033 # Variable c_int
_PUNCT = 16 # Variable c_int
TBM_SETRANGEMIN = 1031 # Variable c_int
BINDSTATUS_CLASSINSTALLLOCATION = 23
SORT_DEFAULT = 0 # Variable c_int
LOCALE_SSHORTDATE = 31 # Variable c_int
WGL_SWAP_UNDERLAY6 = 2097152 # Variable c_int
SPI_SETTOGGLEKEYS = 53 # Variable c_int
DD_DEFSCROLLDELAY = 50 # Variable c_int
SHUTDOWN_NORETRY = 1 # Variable c_int
DEFAULT_GUI_FONT = 17 # Variable c_int
PURGE_RXABORT = 2 # Variable c_int
SPAPI_E_DEVINFO_LIST_LOCKED = -2146500078 # Variable c_long
PATCOPY = 15728673 # Variable c_ulong
WM_COPYDATA = 74 # Variable c_int
MCI_WAVE_SET_ANYINPUT = 67108864 # Variable c_long
GPTR = 64 # Variable c_int
ERROR_ILL_FORMED_PASSWORD = 1324 # Variable c_long
LOCALE_SABBREVLANGNAME = 3 # Variable c_int
MIXER_GETLINECONTROLSF_QUERYMASK = 15 # Variable c_long
MB_TYPEMASK = 15 # Variable c_long
RPC_E_ACCESS_DENIED = -2147417829 # Variable c_long
PR_JOBSTATUS = 0 # Variable c_int
ABN_WINDOWARRANGE = 3 # Variable c_int
JOY_CAL_READZONLY = 16777216 # Variable c_long
ERROR_NEGATIVE_SEEK = 131 # Variable c_long
ERROR_SERIAL_NO_DEVICE = 1118 # Variable c_long
REGDB_E_CLASSNOTREG = -2147221164 # Variable c_long
CUDR_NEGATIVECOORDS = 8 # Variable c_int
TBM_GETPAGESIZE = 1046 # Variable c_int
MCIERR_EXTENSION_NOT_FOUND = 281 # Variable c_int
FROM_LEFT_2ND_BUTTON_PRESSED = 4 # Variable c_int
EMARCH_ENC_I17_IMM7B_VAL_POS_X = 0 # Variable c_int
PRINTER_CHANGE_SET_JOB = 512 # Variable c_int
SPI_SETHIGHCONTRAST = 67 # Variable c_int
SM_CYSMCAPTION = 51 # Variable c_int
NTM_DSIG = 2097152 # Variable c_int
TCN_FIRST = 4294966746 # Variable c_uint
MMIO_SHAREMODE = 112 # Variable c_int
WM_SETCURSOR = 32 # Variable c_int
ERROR_INVALID_FILTER_PROC = 1427 # Variable c_long
PSP_DLGINDIRECT = 1 # Variable c_int
IMAGE_REL_PPC_SECREL = 11 # Variable c_int
ERROR_DEVICE_ALREADY_REMEMBERED = 1202 # Variable c_long
TBCD_THUMB = 2 # Variable c_int
WM_MDIGETACTIVE = 553 # Variable c_int
MMIOERR_INVALIDFILE = 272 # Variable c_int
LVFI_WRAP = 32 # Variable c_int
ERROR_MEMBERS_PRIMARY_GROUP = 1374 # Variable c_long
GCP_NUMERICSLATIN = 67108864 # Variable c_long
VT_DATE = 7
TTM_RELAYEVENT = 1031 # Variable c_int
MMSYSERR_NOTENABLED = 3 # Variable c_int
RPC_C_PROFILE_MATCH_BY_IF = 2 # Variable c_int
IMAGE_SCN_LNK_COMDAT = 4096 # Variable c_int
IME_ESC_PRIVATE_LAST = 4095 # Variable c_int
DEVICE_FONTTYPE = 2 # Variable c_int
SPI_SETANIMATION = 73 # Variable c_int
IMAGE_SYM_CLASS_REGISTER_PARAM = 17 # Variable c_int
STG_E_FILEALREADYEXISTS = -2147286960 # Variable c_long
PRF_ERASEBKGND = 8 # Variable c_long
MAX_SIZE_SECURITY_ID = 512 # Variable c_int
RPC_C_VERS_COMPATIBLE = 2 # Variable c_int
IMAGE_ARCHIVE_LINKER_MEMBER = '/               ' # Variable POINTER(c_char)
PAGE_WRITECOPY = 8 # Variable c_int
NRC_NORESOURCES = 56 # Variable c_int
DEREGISTERED = 5 # Variable c_int
FR_ENABLETEMPLATEHANDLE = 8192 # Variable c_int
STDOLE_MINORVERNUM = 0 # Variable c_int
BIND_JUSTTESTEXISTENCE = 2
OBJECT_INHERIT_ACE = 1 # Variable c_int
CDERR_STRUCTSIZE = 1 # Variable c_int
SPI_ICONVERTICALSPACING = 24 # Variable c_int
IMAGE_REL_SH3_DIRECT4_WORD = 7 # Variable c_int
CAL_SABBREVMONTHNAME1 = 34 # Variable c_int
ERROR_DS_OBJ_CLASS_VIOLATION = 1933 # Variable c_long
SBM_SETRANGE = 226 # Variable c_int
UNIQUE_NAME = 0 # Variable c_int
CBN_DBLCLK = 2 # Variable c_int
REBARCLASSNAMEA = 'ReBarWindow32' # Variable POINTER(c_char)
BACKUP_DATA = 1 # Variable c_int
IMAGE_COMDAT_SELECT_SAME_SIZE = 3 # Variable c_int
LB_GETITEMHEIGHT = 417 # Variable c_int
TVS_EDITLABELS = 8 # Variable c_int
TVN_SELCHANGINGW = 4294966846 # Variable c_uint
SYSTEM_FIXED_FONT = 16 # Variable c_int
MCI_BREAK_OFF = 1024 # Variable c_long
URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS = 7428 # Variable c_int
USER_MARSHAL_FC_SHORT = 6 # Variable c_int
SE_DACL_AUTO_INHERITED = 1024 # Variable c_int
BSCF_LASTDATANOTIFICATION = 4
CRYPT_E_SELF_SIGNED = -2146885625 # Variable c_long
URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS = 7429 # Variable c_int
TVIS_SELECTED = 2 # Variable c_int
ERROR_TOO_MANY_TCBS = 155 # Variable c_long
ERROR_DISK_OPERATION_FAILED = 1127 # Variable c_long
CTRY_SOUTH_AFRICA = 27 # Variable c_int
IMAGE_SCN_CNT_INITIALIZED_DATA = 64 # Variable c_int
QUERY_IS_CACHED = 9
MEM_COMMIT = 4096 # Variable c_int
MM_JOY1MOVE = 928 # Variable c_int
CBS_SIMPLE = 1 # Variable c_long
PIDSI_LASTSAVE_DTM = 13 # Variable c_long
C2_NOTAPPLICABLE = 0 # Variable c_int
TB_SETBUTTONSIZE = 1055 # Variable c_int
MCI_OVLY_WINDOW_STATE = 262144 # Variable c_long
IP_MAX_MEMBERSHIPS = 20 # Variable c_int

_RPC_NOTIFICATION_TYPES = c_int # enum
RpcNotificationTypeNone = 0
RpcNotificationTypeEvent = 1
RpcNotificationTypeApc = 2
RpcNotificationTypeIoc = 3
RpcNotificationTypeHwnd = 4
RpcNotificationTypeCallback = 5
JOY_BUTTON7 = 64 # Variable c_long
IPPROTO_TCP = 6 # Variable c_int
ERROR_NO_SPOOL_SPACE = 62 # Variable c_long
TBS_VERT = 2 # Variable c_int
MCM_SETSELRANGE = 4102 # Variable c_int
DISPID_VALUE = 0 # Variable c_int
URLACTION_NETWORK_MAX = 7167 # Variable c_int
SKF_HOTKEYSOUND = 16 # Variable c_int
RPC_S_INVALID_OBJECT = 1900 # Variable c_long
IDC_ICON = 206401 # Variable POINTER(c_wchar)
SERVICE_WIN32_SHARE_PROCESS = 32 # Variable c_int
RC_OP_DX_OUTPUT = 16384 # Variable c_int
PRINTER_HTML_VIEW_QUEUE = 0 # Variable c_int
DELETE = 65536 # Variable c_long
MDMSPKR_DIAL = 1 # Variable c_int
RPC_C_NS_DEFAULT_EXP_AGE = -1 # Variable c_int
IDNO = 7 # Variable c_int
JOY_BUTTON22 = 2097152 # Variable c_long
MK_S_ASYNCHRONOUS = 262632 # Variable c_long
HDN_ENDDRAG = 4294966985 # Variable c_uint
IMAGE_REL_BASED_IA64_IMM64 = 9 # Variable c_int
LOCALE_SDAYNAME1 = 42 # Variable c_int
LOGON32_PROVIDER_DEFAULT = 0 # Variable c_int
MCIERR_FILE_NOT_FOUND = 275 # Variable c_int
VARFLAG_FREPLACEABLE = 2048
TCIF_TEXT = 1 # Variable c_int
PBT_APMBATTERYLOW = 9 # Variable c_int
CBN_ERRSPACE = -1 # Variable c_int
BLACK_BRUSH = 4 # Variable c_int
MM_DRVM_CLOSE = 977 # Variable c_int
PAN_ARMSTYLE_INDEX = 6 # Variable c_int
LPD_SUPPORT_OPENGL = 32 # Variable c_int
OPAQUE = 2 # Variable c_int
ERROR_LOG_FILE_FULL = 1502 # Variable c_long
PID_FIRST_NAME_DEFAULT = 4095 # Variable c_int
DRV_CLOSE = 4 # Variable c_int
RPC_C_PROTECT_LEVEL_CONNECT = 2 # Variable c_int
ERROR_WAIT_NO_CHILDREN = 128 # Variable c_long
EMR_SETDIBITSTODEVICE = 80 # Variable c_int
IPN_LAST = 4294966417 # Variable c_uint
FORMAT_MESSAGE_FROM_SYSTEM = 4096 # Variable c_int
MIIM_ID = 2 # Variable c_int
LVM_SETEXTENDEDLISTVIEWSTYLE = 4150 # Variable c_int
WM_LBUTTONDOWN = 513 # Variable c_int
ILLUMINANT_D50 = 4 # Variable c_int
ERROR_INVALID_KEYBOARD_HANDLE = 1457 # Variable c_long
OF_SHARE_DENY_READ = 48 # Variable c_int
CTRY_ICELAND = 354 # Variable c_int
ERROR_NO_UNICODE_TRANSLATION = 1113 # Variable c_long

tagSTGTY = c_int # enum
STGTY_STORAGE = 1
STGTY_STREAM = 2
STGTY_LOCKBYTES = 3
STGTY_PROPERTY = 4
TCS_BOTTOM = 2 # Variable c_int
DT_RASDISPLAY = 1 # Variable c_int
WM_MDIMAXIMIZE = 549 # Variable c_int
GETDEVICEUNITS = 42 # Variable c_int
OLE_E_CANTCONVERT = -2147221487 # Variable c_long
TTF_ABSOLUTE = 128 # Variable c_int
CF_GDIOBJLAST = 1023 # Variable c_int
MCHT_TODAYLINK = 196608 # Variable c_int
MIXERCONTROL_CONTROLTYPE_MILLITIME = 1627586560 # Variable c_long
RPC_C_VERS_EXACT = 3 # Variable c_int
GL_ID_UNKNOWN = 0 # Variable c_int
ODT_TAB = 101 # Variable c_int
SBN_SIMPLEMODECHANGE = 4294966416 # Variable c_uint
CO_E_IIDSTRING = -2147221004 # Variable c_long
SE_AUDIT_NAME = 'SeAuditPrivilege' # Variable POINTER(c_wchar)
E_PENDING = -2147483638 # Variable c_long
PRINTER_CHANGE_DELETE_PRINTER_DRIVER = 1073741824 # Variable c_int
DOF_PROGMAN = 1 # Variable c_int
MKSYS_POINTERMONIKER = 5
chx16 = 1055 # Variable c_int
HCBT_CREATEWND = 3 # Variable c_int
SPI_SETHANDHELD = 78 # Variable c_int
DCX_CACHE = 2 # Variable c_long
URLACTION_HTML_CURR_MAX = 5637 # Variable c_int
GWL_HINSTANCE = -6 # Variable c_int
WM_IME_COMPOSITION = 271 # Variable c_int
SW_SHOWMINIMIZED = 2 # Variable c_int
URLACTION_JAVA_MIN = 7168 # Variable c_int
LVS_EDITLABELS = 512 # Variable c_int
LMEM_LOCKCOUNT = 255 # Variable c_int
MF_BITMAP = 4 # Variable c_long
IMAGE_FILE_MACHINE_R4000 = 358 # Variable c_int
DFCS_INACTIVE = 256 # Variable c_int
MCIERR_UNNAMED_RESOURCE = 298 # Variable c_int

__MIDL_IBindStatusCallback_0003 = c_int # enum
BINDF_ASYNCHRONOUS = 1
BINDF_ASYNCSTORAGE = 2
BINDF_NOPROGRESSIVERENDERING = 4
BINDF_OFFLINEOPERATION = 8
BINDF_GETNEWESTVERSION = 16
BINDF_NOWRITECACHE = 32
BINDF_NEEDFILE = 64
BINDF_PULLDATA = 128
BINDF_IGNORESECURITYPROBLEM = 256
BINDF_RESYNCHRONIZE = 512
BINDF_HYPERLINK = 1024
BINDF_NO_UI = 2048
BINDF_SILENTOPERATION = 4096
BINDF_PRAGMA_NO_CACHE = 8192
BINDF_FREE_THREADED = 65536
BINDF_DIRECT_READ = 131072
BINDF_FORMS_SUBMIT = 262144
BINDF_GETFROMCACHE_IF_NET_FAIL = 524288
LB_INITSTORAGE = 424 # Variable c_int
STARTF_FORCEONFEEDBACK = 64 # Variable c_int
HICF_OTHER = 0 # Variable c_int
ERROR_DEVICE_REQUIRES_CLEANING = 1165 # Variable c_long
PERF_COUNTER_RATE = 65536 # Variable c_int
WGL_SWAP_OVERLAY8 = 256 # Variable c_int
WM_GETICON = 127 # Variable c_int
ERROR_CANT_ACCESS_FILE = 1920 # Variable c_long
SPAPI_E_INVALID_CLASS = -2146500090 # Variable c_long
BAUD_19200 = 8192 # Variable c_ulong
MIXER_OBJECTF_MIXER = 0 # Variable c_long
STG_S_RETRYNOW = 197122 # Variable c_long
WM_NOTIFY = 78 # Variable c_int
psh3 = 1026 # Variable c_int
HKCOMB_CA = 64 # Variable c_int
MCI_CUE = 2096 # Variable c_int
ERROR_TAG_NOT_PRESENT = 2303 # Variable c_long
ONE5STOPBITS = 1 # Variable c_int
ERROR_TRUSTED_RELATIONSHIP_FAILURE = 1789 # Variable c_long
LVM_SETTEXTBKCOLOR = 4134 # Variable c_int
WNNC_NET_SUN_PC_NFS = 458752 # Variable c_int
PSINJECT_APPEND = 0 # Variable c_int
MM_WOM_DONE = 957 # Variable c_int
WM_MENUSELECT = 287 # Variable c_int
META_PATBLT = 1565 # Variable c_int
FILE_TYPE_CHAR = 2 # Variable c_int
MIDICAPS_STREAM = 8 # Variable c_int
REG_LINK = 6 # Variable c_int
ERROR_RXACT_INVALID_STATE = 1369 # Variable c_long
XMLELEMTYPE_DOCUMENT = 3
BINDSTATUS_SENDINGREQUEST = 11
STANDARD_RIGHTS_ALL = 2031616 # Variable c_long
EMARCH_ENC_I17_IMM41b_VAL_POS_X = 32 # Variable c_int
SM_CXHTHUMB = 10 # Variable c_int
ERROR_REQ_NOT_ACCEP = 71 # Variable c_long
ERROR_INSUFFICIENT_BUFFER = 122 # Variable c_long
PROFILE_KERNEL = 536870912 # Variable c_int
SUBLANG_NEUTRAL = 0 # Variable c_int
MEVT_NOP = 2 # Variable c_ubyte
TAPE_ERASE_LONG = 1 # Variable c_long
ERROR_INVALID_SUB_AUTHORITY = 1335 # Variable c_long
N_TMASK2 = 240 # Variable c_int
PS_ENDCAP_FLAT = 512 # Variable c_int
PSD_DISABLEMARGINS = 16 # Variable c_int
JOB_STATUS_SPOOLING = 8 # Variable c_int
WM_CTLCOLORSCROLLBAR = 311 # Variable c_int
FILE_ATTRIBUTE_OFFLINE = 4096 # Variable c_int
PRINTER_STATUS_OUTPUT_BIN_FULL = 2048 # Variable c_int
ERROR_INVALID_OWNER = 1307 # Variable c_long
PERF_SIZE_VARIABLE_LEN = 768 # Variable c_int
DM_COPY = 2 # Variable c_int
MB_USEGLYPHCHARS = 4 # Variable c_int
IMAGE_SCN_ALIGN_8192BYTES = 14680064 # Variable c_int
PFD_GENERIC_FORMAT = 64 # Variable c_int
DRAGDROP_S_LAST = 262415 # Variable c_long
VT_INT = 22
SOFTDIST_FLAG_USAGE_AUTOINSTALL = 4 # Variable c_int
MCI_SEQ_STATUS_COPYRIGHT = 16396 # Variable c_long
CDM_GETFOLDERIDLIST = 1127 # Variable c_int
NDR_CHAR_REP_MASK = 15 # Variable c_ulong
SBT_TOOLTIPS = 2048 # Variable c_int
NORM_IGNOREKANATYPE = 65536 # Variable c_int
MK_E_CONNECTMANUALLY = -2147221024 # Variable c_long
S_SERDFQ = -13 # Variable c_int
PS_ENDCAP_ROUND = 0 # Variable c_int
DMLERR_INVALIDPARAMETER = 16390 # Variable c_int
PRSPEC_INVALID = 4294967295 # Variable c_uint
SC_ACTION_REBOOT = 2
TVHT_ONITEM = 70 # Variable c_int
R2_MERGENOTPEN = 12 # Variable c_int
MIXERLINE_LINEF_SOURCE = 2147483648 # Variable c_ulong
GMDI_USEDISABLED = 1 # Variable c_long
MCI_GETDEVCAPS_HAS_AUDIO = 2 # Variable c_long
PARITY_ODD = 512 # Variable c_ushort
ERROR_INVALID_SERVER_STATE = 1352 # Variable c_long
MF_BYPOSITION = 1024 # Variable c_long
MIXERCONTROL_CONTROLTYPE_MUTE = 536936450 # Variable c_long
TB_SETBITMAPSIZE = 1056 # Variable c_int
WS_EX_MDICHILD = 64 # Variable c_long
CTRY_PAKISTAN = 92 # Variable c_int
OLE_E_NOCONNECTION = -2147221500 # Variable c_long
DCB_ENABLE = 4 # Variable c_int
UNLOAD_DLL_DEBUG_EVENT = 7 # Variable c_int
PGS_HORZ = 1 # Variable c_int
PFD_TYPE_COLORINDEX = 1 # Variable c_int
JOY_RETURNR = 8 # Variable c_long
RPC_E_INVALID_EXTENSION = -2147417838 # Variable c_long
STOPBITS_15 = 2 # Variable c_ushort
STG_E_UNIMPLEMENTEDFUNCTION = -2147286786 # Variable c_long
VIEW_S_LAST = 262479 # Variable c_long
CTRY_NETHERLANDS = 31 # Variable c_int
TIMER_QUERY_STATE = 1 # Variable c_int
UDM_GETRANGE32 = 1136 # Variable c_int
HCBT_DESTROYWND = 4 # Variable c_int
BS_MULTILINE = 8192 # Variable c_long
DSS_UNION = 16 # Variable c_int
PROPSETFLAG_NONSIMPLE = 1 # Variable c_int
VERTSIZE = 6 # Variable c_int
RC_STRETCHBLT = 2048 # Variable c_int
FILE_ATTRIBUTE_SPARSE_FILE = 512 # Variable c_int
ERROR_MEMBER_IN_ALIAS = 1378 # Variable c_long
PRINTER_NOTIFY_FIELD_PARAMETERS = 10 # Variable c_int
ERROR_INVALID_FLAGS = 1004 # Variable c_long
CTRY_CROATIA = 385 # Variable c_int
CBEM_GETEDITCONTROL = 1031 # Variable c_int

tagOLEGETMONIKER = c_int # enum
OLEGETMONIKER_ONLYIFTHERE = 1
OLEGETMONIKER_FORCEASSIGN = 2
OLEGETMONIKER_UNASSIGN = 3
OLEGETMONIKER_TEMPFORUSER = 4
META_FILLREGION = 552 # Variable c_int
OFN_FILEMUSTEXIST = 4096 # Variable c_int
META_PIE = 2074 # Variable c_int
URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY = 4609 # Variable c_int
CDERR_MEMALLOCFAILURE = 9 # Variable c_int
EVENT_ALL_ACCESS = 2031619 # Variable c_long
WM_CHOOSEFONT_SETFLAGS = 1126 # Variable c_int
WAVECAPS_LRVOLUME = 8 # Variable c_int
CERT_E_CN_NO_MATCH = -2146762481 # Variable c_long
MCIERR_DEVICE_ORD_LENGTH = 311 # Variable c_int
EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X = 4 # Variable c_int
RC_BIGFONT = 1024 # Variable c_int
WM_KEYDOWN = 256 # Variable c_int
ERROR_NO_SCROLLBARS = 1447 # Variable c_long
CFSTR_MIME_AIFF = 'audio/aiff' # Variable POINTER(c_wchar)
WM_EXITSIZEMOVE = 562 # Variable c_int
IMAGE_REL_BASED_HIGHADJ = 4 # Variable c_int
CBF_FAIL_CONNECTIONS = 8192 # Variable c_int
DFCS_SCROLLSIZEGRIPRIGHT = 16 # Variable c_int
TVN_GETINFOTIPW = 4294966882 # Variable c_uint
TVCDRF_NOIMAGES = 65536 # Variable c_int
BI_BITFIELDS = 3 # Variable c_long
CDIS_INDETERMINATE = 256 # Variable c_int
LVCFMT_IMAGE = 2048 # Variable c_int
SPI_SETSHOWSOUNDS = 57 # Variable c_int
IMAGE_REL_ALPHA_GPDISP = 6 # Variable c_int
CLIP_DEFAULT_PRECIS = 0 # Variable c_int
CCHDEVICENAME = 32 # Variable c_int
IDIGNORE = 5 # Variable c_int
TCM_GETTOOLTIPS = 4909 # Variable c_int
SBS_VERT = 1 # Variable c_long
DMPAPER_ISO_B4 = 42 # Variable c_int
STATFLAG_DEFAULT = 0
DM_DISPLAYFREQUENCY = 4194304 # Variable c_long
ERROR_INVALID_PIXEL_FORMAT = 2000 # Variable c_long
STATUS_ARRAY_BOUNDS_EXCEEDED = 3221225612 # Variable c_ulong
SECURITY_CREATOR_OWNER_RID = 0 # Variable c_long
VFF_CURNEDEST = 1 # Variable c_int
ABS_ALWAYSONTOP = 2 # Variable c_int
VS_FFI_FILEFLAGSMASK = 63 # Variable c_long
MIXERCONTROL_CT_SC_TIME_MICROSECS = 0 # Variable c_long
TB_SETIMAGELIST = 1072 # Variable c_int

tagOLEMISC = c_int # enum
OLEMISC_RECOMPOSEONRESIZE = 1
OLEMISC_ONLYICONIC = 2
OLEMISC_INSERTNOTREPLACE = 4
OLEMISC_STATIC = 8
OLEMISC_CANTLINKINSIDE = 16
OLEMISC_CANLINKBYOLE1 = 32
OLEMISC_ISLINKOBJECT = 64
OLEMISC_INSIDEOUT = 128
OLEMISC_ACTIVATEWHENVISIBLE = 256
OLEMISC_RENDERINGISDEVICEINDEPENDENT = 512
OLEMISC_INVISIBLEATRUNTIME = 1024
OLEMISC_ALWAYSRUN = 2048
OLEMISC_ACTSLIKEBUTTON = 4096
OLEMISC_ACTSLIKELABEL = 8192
OLEMISC_NOUIACTIVATE = 16384
OLEMISC_ALIGNABLE = 32768
OLEMISC_SIMPLEFRAME = 65536
OLEMISC_SETCLIENTSITEFIRST = 131072
OLEMISC_IMEMODE = 262144
OLEMISC_IGNOREACTIVATEWHENVISIBLE = 524288
OLEMISC_WANTSTOMENUMERGE = 1048576
OLEMISC_SUPPORTSMULTILEVELUNDO = 2097152
COLOR_INFOTEXT = 23 # Variable c_int
LVS_NOCOLUMNHEADER = 16384 # Variable c_int
URLACTION_INFODELIVERY_MAX = 7679 # Variable c_int
ERROR_NONE_MAPPED = 1332 # Variable c_long
NRC_CANOCCR = 36 # Variable c_int
IPPROTO_UDP = 17 # Variable c_int
BS_CENTER = 768 # Variable c_long
URLACTION_HTML_SUBMIT_FORMS_TO = 5635 # Variable c_int
OBJ_BRUSH = 2 # Variable c_int
SUCCESSFUL_ACCESS_ACE_FLAG = 64 # Variable c_int
CBES_EX_NOSIZELIMIT = 8 # Variable c_int
SO_UPDATE_ACCEPT_CONTEXT = 28683 # Variable c_int
TBCDRF_HILITEHOTTRACK = 131072 # Variable c_int
RPC_E_SYS_CALL_FAILED = -2147417856 # Variable c_long
DLL_PROCESS_ATTACH = 1 # Variable c_int
FILE_SUPPORTS_OBJECT_IDS = 65536 # Variable c_int
WIZ_CXDLG = 276 # Variable c_int
ERROR_DIR_NOT_EMPTY = 145 # Variable c_long
LBS_DISABLENOSCROLL = 4096 # Variable c_long
NCBNAMSZ = 16 # Variable c_int
ERROR_BAD_QUERY_SYNTAX = 1615 # Variable c_long
MMIO_FHOPEN = 16 # Variable c_int
ILC_COLOR24 = 24 # Variable c_int
SPLDS_PRINTER_CLASS = 'printQueue' # Variable POINTER(c_wchar)
PSH_RTLREADING = 2048 # Variable c_int
ERROR_CONNECTION_INVALID = 1229 # Variable c_long
ERROR_SERVICE_DISABLED = 1058 # Variable c_long
MCS_NOTODAYCIRCLE = 8 # Variable c_int
NO_ERROR = 0 # Variable c_long
IMAGE_FILE_MACHINE_WCEMIPSV2 = 361 # Variable c_int
SPI_SETACCESSTIMEOUT = 61 # Variable c_int
DRAGDROP_E_FIRST = 2147746048 # Variable c_ulong
WSAEPROTOTYPE = 10041 # Variable c_int
IMAGE_REL_BASED_HIGHLOW = 3 # Variable c_int
CBN_CLOSEUP = 8 # Variable c_int
_BLANK = 64 # Variable c_int
CO_E_FAILEDTOCLOSEHANDLE = -2147220971 # Variable c_long
HSHELL_REDRAW = 6 # Variable c_int
SB_GETTIPTEXTA = 1042 # Variable c_int
stc13 = 1100 # Variable c_int
CFSTR_MIME_RAWDATA = 'application/octet-stream' # Variable POINTER(c_wchar)
LVIS_CUT = 4 # Variable c_int
RBBS_FIXEDSIZE = 2 # Variable c_int
WS_EX_DLGMODALFRAME = 1 # Variable c_long
CE_RXPARITY = 4 # Variable c_int
SELECT_CAP_CONVERSION = 1 # Variable c_int
DLL_THREAD_ATTACH = 2 # Variable c_int
WHDR_DONE = 1 # Variable c_int
MDMSPKR_CALLSETUP = 3 # Variable c_int
PSPCB_CREATE = 2 # Variable c_int
LPD_SUPPORT_GDI = 16 # Variable c_int
TAPE_DRIVE_ECC = 65536 # Variable c_int
DOF_SHELLDATA = 2 # Variable c_int
KEY_WRITE = 131078 # Variable c_long
HDM_INSERTITEMA = 4609 # Variable c_int
SND_ALIAS_SYSTEMSTART = 21331 # Variable c_ulong
RPC_S_INTERNAL_ERROR = 1766 # Variable c_long
PORT_STATUS_OUTPUT_BIN_FULL = 4 # Variable c_int
MCI_SEQ_FILE = 16386 # Variable c_int
BN_HILITE = 2 # Variable c_int
CRYPT_E_CONTROL_TYPE = -2146889716 # Variable c_long
MIXERCONTROL_CT_SC_LIST_SINGLE = 0 # Variable c_long
RPC_E_INVALID_CALLDATA = -2147417844 # Variable c_long
GETVECTORPENSIZE = 26 # Variable c_int
PRINTER_ENUM_ICON8 = 8388608 # Variable c_int
CTRY_UKRAINE = 380 # Variable c_int
SCS_WOW_BINARY = 2 # Variable c_int
SP_OUTOFDISK = -4 # Variable c_int
WSAEPROTONOSUPPORT = 10043 # Variable c_int
MCI_NOTIFY_SUPERSEDED = 2 # Variable c_int
PENDINGTYPE_NESTED = 2
SO_DEBUG = 1 # Variable c_int
LANG_SWEDISH = 29 # Variable c_int
OF_VERIFY = 1024 # Variable c_int
BS_AUTO3STATE = 6 # Variable c_long
stc23 = 1110 # Variable c_int
LBS_NOSEL = 16384 # Variable c_long
BST_UNCHECKED = 0 # Variable c_int
CO_E_CLASSSTRING = -2147221005 # Variable c_long
IMAGE_REL_MIPS_REFHI = 4 # Variable c_int
EMR_POLYPOLYLINE = 7 # Variable c_int
DCB_DISABLE = 8 # Variable c_int
LCMAP_UPPERCASE = 512 # Variable c_int
WNNC_NET_BWNFS = 1048576 # Variable c_int
JOB_OBJECT_SET_ATTRIBUTES = 2 # Variable c_int
VOS_DOS_WINDOWS32 = 65540 # Variable c_long
SW_OTHERZOOM = 2 # Variable c_int
PIDSI_TEMPLATE = 7 # Variable c_long
VS_FFI_STRUCVERSION = 65536 # Variable c_long
TBN_GETBUTTONINFOW = 4294966576 # Variable c_uint
CLSCTX_ALL = 7 # Variable c_int
CTRY_SINGAPORE = 65 # Variable c_int
CAL_SABBREVMONTHNAME9 = 42 # Variable c_int
DISP_CHANGE_FAILED = -1 # Variable c_int
CF_METAFILEPICT = 3 # Variable c_int
SO_OOBINLINE = 256 # Variable c_int
ERROR_NOACCESS = 998 # Variable c_long
S_SERDVNA = -1 # Variable c_int
CS_BYTEALIGNWINDOW = 8192 # Variable c_int
SBS_SIZEGRIP = 16 # Variable c_long
TPM_RIGHTBUTTON = 2 # Variable c_long
ENABLE_WRAP_AT_EOL_OUTPUT = 2 # Variable c_int
CBS_DROPDOWNLIST = 3 # Variable c_long
CAL_SDAYNAME1 = 7 # Variable c_int
ERROR_BAD_VALIDATION_CLASS = 1348 # Variable c_long
DMORIENT_PORTRAIT = 1 # Variable c_int
ERROR_INVALID_DATA = 13 # Variable c_long
WGL_SWAP_UNDERLAY9 = 16777216 # Variable c_int
VIF_CANNOTREADSRC = 65536 # Variable c_long
MWMO_INPUTAVAILABLE = 4 # Variable c_int
EXCEPTION_MAXIMUM_PARAMETERS = 15 # Variable c_int
SPLDS_DRIVER_NAME = 'driverName' # Variable POINTER(c_wchar)
REG_BINARY = 3 # Variable c_int
MB_APPLMODAL = 0 # Variable c_long
VIEW_LIST = 2 # Variable c_int
LOCALE_SABBREVDAYNAME5 = 53 # Variable c_int
CBEMAXSTRLEN = 260 # Variable c_int
TAPE_DRIVE_REPORT_SMKS = 524288 # Variable c_int
LVNI_FOCUSED = 1 # Variable c_int
SERKF_INDICATOR = 4 # Variable c_int
PORT_STATUS_TONER_LOW = 10 # Variable c_int
ERROR_TOO_MANY_CMDS = 56 # Variable c_long
SW_ERASE = 4 # Variable c_int
SEE_MASK_CONNECTNETDRV = 128 # Variable c_int
VS_FFI_SIGNATURE = 4277077181 # Variable c_ulong
XTYPF_ACKREQ = 8 # Variable c_int
CO_E_INIT_MEMORY_ALLOCATOR = -2147467256 # Variable c_long
ODDPARITY = 1 # Variable c_int
GCPCLASS_LATINNUMERICTERMINATOR = 6 # Variable c_int
WGL_FONT_POLYGONS = 1 # Variable c_int
MCI_NOTIFY_FAILURE = 8 # Variable c_int
FS_JISJAPAN = 131072 # Variable c_long
TOKEN_ADJUST_SESSIONID = 256 # Variable c_int
TB_ISBUTTONHIGHLIGHTED = 1038 # Variable c_int
ERROR_REQUEST_REFUSED = 4320 # Variable c_long
JOB_NOTIFY_FIELD_PRINTER_NAME = 0 # Variable c_int
CO_E_LOOKUPACCSIDFAILED = -2147220979 # Variable c_long
SECURITY_CREATOR_GROUP_RID = 1 # Variable c_long
PGM_FORWARDMOUSE = 5123 # Variable c_int
VARFLAG_FIMMEDIATEBIND = 4096
DCX_WINDOW = 1 # Variable c_long
TAPE_DRIVE_SET_COMPRESSION = 2147484160 # Variable c_uint
SUBLANG_NORWEGIAN_NYNORSK = 2 # Variable c_int
OF_SHARE_DENY_WRITE = 32 # Variable c_int
MCIERR_SEQ_PORT_INUSE = 337 # Variable c_int
PM_NOYIELD = 2 # Variable c_int
PRINTER_CHANGE_PORT = 7340032 # Variable c_int
PSWIZB_NEXT = 2 # Variable c_int
RBHT_GRABBER = 4 # Variable c_int
TCP_NODELAY = 1 # Variable c_int
MK_CONTROL = 8 # Variable c_int
ARW_TOPLEFT = 2 # Variable c_long
ERROR_BAD_UNIT = 20 # Variable c_long
SERVICE_ACCEPT_PAUSE_CONTINUE = 2 # Variable c_int
IP_DEFAULT_MULTICAST_LOOP = 1 # Variable c_int
SKF_AVAILABLE = 2 # Variable c_int
ARW_LEFT = 0 # Variable c_long
LVS_SHAREIMAGELISTS = 64 # Variable c_int
SEE_MASK_HMONITOR = 2097152 # Variable c_int
STGTY_REPEAT = 256 # Variable c_long
VK_SELECT = 41 # Variable c_int
TKIND_ENUM = 0
STGM_TRANSACTED = 65536 # Variable c_long
_REPORT_ERRMODE = 3 # Variable c_int
LB_SETCURSEL = 390 # Variable c_int
SO_RCVLOWAT = 4100 # Variable c_int
RGB_GAMMA_MAX = 65000 # Variable c_ushort
IMAGE_FILE_MACHINE_IA64 = 512 # Variable c_int
ERROR_NO_IMPERSONATION_TOKEN = 1309 # Variable c_long
NI_COMPOSITIONSTR = 21 # Variable c_int
GETTRACKKERNTABLE = 259 # Variable c_int
PROCESSOR_PPC_604 = 604 # Variable c_int
BINDVERB_GET = 0
RB_SHOWBAND = 1059 # Variable c_int
RPC_S_NO_BINDINGS = 1718 # Variable c_long
BS_TEXT = 0 # Variable c_long
BSM_NETDRIVER = 2 # Variable c_int
ERROR_NO_SIGNAL_SENT = 205 # Variable c_long
LVBKIF_SOURCE_MASK = 3 # Variable c_int
MCIERR_SEQ_PORTUNSPECIFIED = 342 # Variable c_int
NM_RDBLCLK = 4294967290 # Variable c_uint
CTLCOLOR_STATIC = 6 # Variable c_int
MCI_UNFREEZE = 2117 # Variable c_int
ERROR_LM_CROSS_ENCRYPTION_REQUIRED = 1390 # Variable c_long
MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY = 4105 # Variable c_long
MKSYS_CLASSMONIKER = 7
chx14 = 1053 # Variable c_int
PSH_WIZARD = 32 # Variable c_int
CO_E_INIT_ONLY_SINGLE_THREADED = -2147467246 # Variable c_long
BS_PATTERN = 3 # Variable c_int
ODT_STATIC = 5 # Variable c_int
HDM_INSERTITEMW = 4618 # Variable c_int
IMAGE_BITMAP = 0 # Variable c_int
LANG_FINNISH = 11 # Variable c_int
GETSETSCREENPARAMS = 3072 # Variable c_int
DMPAPER_B5_EXTRA = 65 # Variable c_int
MK_E_ENUMERATION_FAILED = -2147221009 # Variable c_long
ERROR_DS_UNAVAILABLE = 1928 # Variable c_long
BITSPIXEL = 12 # Variable c_int
GL_ID_NOCONVERT = 32 # Variable c_int
PERF_DETAIL_NOVICE = 100 # Variable c_int
ERROR_SERVICE_NEVER_STARTED = 1077 # Variable c_long
PAN_MIDLINE_HIGH_POINTED = 6 # Variable c_int
DUPLICATE = 6 # Variable c_int
PBT_APMQUERYSUSPENDFAILED = 2 # Variable c_int
ERROR_IS_SUBST_PATH = 146 # Variable c_long
MSG_MAXIOVLEN = 16 # Variable c_int
WC_HEADERW = 'SysHeader32' # Variable POINTER(c_wchar)
NRC_LOCTFUL = 17 # Variable c_int
GCS_COMPREADCLAUSE = 4 # Variable c_int
MIXERCONTROL_CT_SC_LIST_MULTIPLE = 16777216 # Variable c_long
WRITE_OWNER = 524288 # Variable c_long
TBN_QUERYINSERT = 4294966590 # Variable c_uint
IMAGE_MIX_ISA_LIMIT = 2 # Variable c_int
CDN_SHAREVIOLATION = 4294966692 # Variable c_uint
CDRF_NOTIFYPOSTPAINT = 16 # Variable c_int
TB_GETBITMAPFLAGS = 1065 # Variable c_int
LB_SELITEMRANGEEX = 387 # Variable c_int
STGM_NOSNAPSHOT = 2097152 # Variable c_long
LVM_SETITEMSTATE = 4139 # Variable c_int
META_CREATEPALETTE = 247 # Variable c_int
LOCALE_SMONTHNAME5 = 60 # Variable c_int
SWP_ASYNCWINDOWPOS = 16384 # Variable c_int
VFF_BUFFTOOSMALL = 4 # Variable c_int
BAUD_14400 = 4096 # Variable c_ulong
RPC_BUFFER_NONOTIFY = 65536 # Variable c_int
URLACTION_SCRIPT_JAVA_USE = 5122 # Variable c_int
LB_GETHORIZONTALEXTENT = 403 # Variable c_int
PRINTER_CHANGE_ADD_PRINTER_DRIVER = 268435456 # Variable c_int
ERROR_HOST_UNREACHABLE = 1232 # Variable c_long
LANG_MANIPURI = 88 # Variable c_int
LVM_GETHOTCURSOR = 4159 # Variable c_int
BINDSTATUS_CLASSIDAVAILABLE = 12
C1_UPPER = 1 # Variable c_int
chx9 = 1048 # Variable c_int
GCL_HCURSOR = -12 # Variable c_int
LVS_EX_SUBITEMIMAGES = 2 # Variable c_int
DEBUG_PROCESS = 1 # Variable c_int
PST_TCPIP_TELNET = 258 # Variable c_ulong
RESOURCETYPE_DISK = 1 # Variable c_int
OFN_ENABLESIZING = 8388608 # Variable c_int
TC_SA_DOUBLE = 64 # Variable c_int
MCHT_TITLEBTNPREV = 33619971 # Variable c_int
NCBDGSEND = 32 # Variable c_int
AF_DECnet = 12 # Variable c_int
edt10 = 1161 # Variable c_int
MB_RIGHT = 524288 # Variable c_long
SSWF_TITLE = 1 # Variable c_int
RPC_C_QOS_IDENTITY_DYNAMIC = 1 # Variable c_int
GCP_REORDER = 2 # Variable c_int
ERROR_SERVICE_MARKED_FOR_DELETE = 1072 # Variable c_long
SC_RESTORE = 61728 # Variable c_int
URLACTION_SHELL_WEBVIEW_VERB = 6149 # Variable c_int
TBM_GETTIC = 1027 # Variable c_int
PIDSI_LASTAUTHOR = 8 # Variable c_long
DCX_NORESETATTRS = 4 # Variable c_long
DTN_DATETIMECHANGE = 4294966537 # Variable c_uint
CO_E_FAILEDTOGETWINDIR = -2147220975 # Variable c_long
VT_UINT = 23
MCM_GETTODAY = 4109 # Variable c_int
WM_COPY = 769 # Variable c_int
SPLDS_PRINT_NUMBER_UP = 'printNumberUp' # Variable POINTER(c_wchar)
IE_BYTESIZE = -11 # Variable c_int
ERROR_DESTINATION_ELEMENT_FULL = 1161 # Variable c_long
EVENTLOG_ERROR_TYPE = 1 # Variable c_int
IS_TEXT_UNICODE_DBCS_LEADBYTE = 1024 # Variable c_int
NUMPRS_LEADING_PLUS = 4 # Variable c_int
MB_ICONQUESTION = 32 # Variable c_long
SC_ACTION_RUN_COMMAND = 3
HDN_ITEMCLICKW = 4294966974 # Variable c_uint
MDM_SPEED_ADJUST = 128 # Variable c_int
EPT_S_NOT_REGISTERED = 1753 # Variable c_long
GMEM_MODIFY = 128 # Variable c_int
LOCALE_ITLZERO = 37 # Variable c_int
TB_LINEDOWN = 1 # Variable c_int
SECURITY_DESCRIPTOR_MIN_LENGTH = 20 # Variable c_uint
CAL_GREGORIAN = 1 # Variable c_int
TBTS_RIGHT = 3 # Variable c_int
MIXERLINE_LINEF_DISCONNECTED = 32768 # Variable c_long
OFN_ENABLEINCLUDENOTIFY = 4194304 # Variable c_int
SE_GROUP_MANDATORY = 1 # Variable c_long
MCI_INFO = 2058 # Variable c_int
ERROR_IOPL_NOT_ENABLED = 197 # Variable c_long
JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 64 # Variable c_int
NRC_BUFLEN = 1 # Variable c_int
JOY_RETURNPOV = 64 # Variable c_long
MB_YESNOCANCEL = 3 # Variable c_long
LVM_SETITEMW = 4172 # Variable c_int
TBM_SETSEL = 1034 # Variable c_int
WM_GETHOTKEY = 51 # Variable c_int
SPLDS_PRINT_MEMORY = 'printMemory' # Variable POINTER(c_wchar)

__MIDL_IBindStatusCallback_0001 = c_int # enum
BINDVERB_POST = 1
BINDVERB_PUT = 2
BINDVERB_CUSTOM = 3
CO_E_WRONGTRUSTEENAMESYNTAX = -2147220983 # Variable c_long
SUBLANG_PORTUGUESE = 2 # Variable c_int
BACKGROUND_BLUE = 16 # Variable c_int
HDN_ITEMCHANGINGA = 4294966996 # Variable c_uint
LIBFLAG_FHASDISKIMAGE = 8
SC_VSCROLL = 61552 # Variable c_int
RDW_ALLCHILDREN = 128 # Variable c_int
JOY_RETURNZ = 4 # Variable c_long
ERROR_INVALID_MEDIA = 4300 # Variable c_long
R2_NOP = 11 # Variable c_int
LANG_ARMENIAN = 43 # Variable c_int
IMAGE_DIRECTORY_ENTRY_DEBUG = 6 # Variable c_int
TBM_CLEARSEL = 1043 # Variable c_int
DOMAIN_ALIAS_RID_ADMINS = 544 # Variable c_long
PC_POLYPOLYGON = 256 # Variable c_int
ERROR_BEGINNING_OF_MEDIA = 1102 # Variable c_long
BEGIN_PATH = 4096 # Variable c_int
SidTypeDeletedAccount = 6
chx8 = 1047 # Variable c_int
MAX_MONITORS = 4 # Variable c_int
RPC_C_AUTHN_MQ = 100 # Variable c_int
CFSTR_MIME_FRACTALS = 'application/fractals' # Variable POINTER(c_wchar)
WAVE_FORMAT_2M08 = 16 # Variable c_int
PAN_LETT_OBLIQUE_FLATTENED = 12 # Variable c_int
MCI_MODE_OPEN = 530 # Variable c_int
DCOM_CALL_CANCELED = 2
IMAGE_SYM_CLASS_TYPE_DEFINITION = 13 # Variable c_int
MSGF_USER = 4096 # Variable c_int
EM_SETREADONLY = 207 # Variable c_int
NIF_MESSAGE = 1 # Variable c_int
GMEM_NOCOMPACT = 16 # Variable c_int
HELP_HELPONHELP = 4 # Variable c_long
WAVE_ALLOWSYNC = 2 # Variable c_int
ADVFCACHE_ONSAVE = 32
BN_DOUBLECLICKED = 5 # Variable c_int
ODA_FOCUS = 4 # Variable c_int
MCI_WAVE_SET_BITSPERSAMPLE = 2097152 # Variable c_long
EMR_ELLIPSE = 42 # Variable c_int
SBS_SIZEBOXTOPLEFTALIGN = 2 # Variable c_long
INET_E_UNKNOWN_PROTOCOL = -2146697203 # Variable c_long
BDR_RAISEDINNER = 4 # Variable c_int
VK_HELP = 47 # Variable c_int
EPT_S_INVALID_ENTRY = 1751 # Variable c_long
RPC_C_MQ_JOURNAL_DEADLETTER = 1 # Variable c_int
PFD_SWAP_EXCHANGE = 512 # Variable c_int
KEY_NOTIFY = 16 # Variable c_int
ERROR_INVALID_SEGMENT_NUMBER = 180 # Variable c_long
MCIERR_NO_CLOSING_QUOTE = 294 # Variable c_int
SPAPI_E_DEVINFO_DATA_LOCKED = -2146500077 # Variable c_long
VK_PA1 = 253 # Variable c_int
CBENF_DROPDOWN = 4 # Variable c_int
VOS_DOS_WINDOWS16 = 65537 # Variable c_long
FOF_NOERRORUI = 1024 # Variable c_int
FR_DOWN = 1 # Variable c_int
CFSTR_MIME_BASICAUDIO = 'audio/basic' # Variable POINTER(c_wchar)
GCS_DELTASTART = 256 # Variable c_int
LVFI_PARAM = 1 # Variable c_int
GGO_GRAY8_BITMAP = 6 # Variable c_int
EDGE_SUNKEN = 10 # Variable c_int
MMIOM_RENAME = 6 # Variable c_int
EMR_ENDPATH = 60 # Variable c_int
MF_DEFAULT = 4096 # Variable c_long
NRC_PENDING = 255 # Variable c_int
FILE_CASE_SENSITIVE_SEARCH = 1 # Variable c_int
VOS_OS232_PM32 = 196611 # Variable c_long
DMPAPER_QUARTO = 15 # Variable c_int
RB_DELETEBAND = 1026 # Variable c_int
DI_APPBANDING = 1 # Variable c_int
IPPORT_ROUTESERVER = 520 # Variable c_int
DFCS_CAPTIONRESTORE = 3 # Variable c_int
STREAM_MODIFIED_WHEN_READ = 1 # Variable c_int
TYPE_E_LIBNOTREGISTERED = -2147319779 # Variable c_long
MM_JOY2BUTTONUP = 952 # Variable c_int
EMR_SETWINDOWORGEX = 10 # Variable c_int
EM_GETMODIFY = 184 # Variable c_int
LVM_GETITEMRECT = 4110 # Variable c_int
RBN_LAYOUTCHANGED = 4294966463 # Variable c_uint
CTRY_SLOVAK = 421 # Variable c_int
IMAGE_REL_SH3_PCREL12_WORD = 11 # Variable c_int
TVM_EDITLABELW = 4417 # Variable c_int
ERROR_MAGAZINE_NOT_PRESENT = 1163 # Variable c_long
CAL_SDAYNAME5 = 11 # Variable c_int
DRV_OPEN = 3 # Variable c_int
FO_MOVE = 1 # Variable c_int
MCI_GETDEVCAPS_DEVICE_TYPE = 4 # Variable c_long
SPI_SETICONMETRICS = 46 # Variable c_int
SPLREG_SCHEDULER_THREAD_PRIORITY = 'SchedulerThreadPriority' # Variable POINTER(c_wchar)
ERROR_IRQ_BUSY = 1119 # Variable c_long
RPC_C_AUTHN_DEFAULT = 4294967295 # Variable c_ulong
DT_INTERNAL = 4096 # Variable c_int
PGF_SCROLLDOWN = 2 # Variable c_int
ERROR_HOOK_NEEDS_HMOD = 1428 # Variable c_long
SHGFI_LINKOVERLAY = 32768 # Variable c_int
DTS_SHOWNONE = 2 # Variable c_int
LVN_INSERTITEM = 4294967194 # Variable c_uint
MIXERLINE_TARGETTYPE_WAVEIN = 2 # Variable c_int
HIST_FORWARD = 1 # Variable c_int
DSS_RIGHT = 32768 # Variable c_int
STATUSCLASSNAMEW = 'msctls_statusbar32' # Variable POINTER(c_wchar)
ERROR_MOD_NOT_FOUND = 126 # Variable c_long
GCL_HICONSM = -34 # Variable c_int
QS_MOUSEMOVE = 2 # Variable c_int
CB_SETEDITSEL = 322 # Variable c_int
META_SCALEWINDOWEXT = 1040 # Variable c_int
PROCESSOR_HITACHI_SH3 = 10003 # Variable c_int
DT_TOP = 0 # Variable c_int
WSB_PROP_VSTYLE = 256 # Variable c_long
DMPAPER_A4_EXTRA = 53 # Variable c_int
EMR_ROUNDRECT = 44 # Variable c_int
ERROR_SPOOL_FILE_NOT_FOUND = 3002 # Variable c_long
ERROR_NOT_LOCKED = 158 # Variable c_long
RBBIM_IDEALSIZE = 512 # Variable c_int
TOKEN_QUERY = 8 # Variable c_int
PAN_WEIGHT_HEAVY = 9 # Variable c_int
SB_LINEDOWN = 1 # Variable c_int
TOKEN_DUPLICATE = 2 # Variable c_int
CRYPT_E_NO_PROVIDER = -2146885626 # Variable c_long
MCIERR_BASE = 256 # Variable c_int
MCIERR_SET_DRIVE = 309 # Variable c_int
OLE_S_USEREG = 262144 # Variable c_long
DCX_EXCLUDEUPDATE = 256 # Variable c_long
IMAGE_NT_OPTIONAL_HDR64_MAGIC = 523 # Variable c_int
TTF_IDISHWND = 1 # Variable c_int
IMAGE_FILE_AGGRESIVE_WS_TRIM = 16 # Variable c_int
PFD_DRAW_TO_BITMAP = 8 # Variable c_int
MIDIPATCHSIZE = 128 # Variable c_int
stc24 = 1111 # Variable c_int
WM_MDIDESTROY = 545 # Variable c_int
EM_GETPASSWORDCHAR = 210 # Variable c_int
TB_BOTTOM = 7 # Variable c_int
TB_GETBUTTONINFOW = 1087 # Variable c_int
GMEM_NODISCARD = 32 # Variable c_int
VFT2_DRV_KEYBOARD = 2 # Variable c_long
JOYERR_UNPLUGGED = 167 # Variable c_int
SECURITY_DESCRIPTOR_REVISION = 1 # Variable c_int
S_SERDTP = -8 # Variable c_int
PERF_DETAIL_ADVANCED = 200 # Variable c_int
WNNC_NET_FJ_REDIR = 2228224 # Variable c_int
PSNRET_INVALID_NOCHANGEPAGE = 2 # Variable c_int
AF_UNKNOWN1 = 20 # Variable c_int
ERROR_PROC_NOT_FOUND = 127 # Variable c_long
IPPROTO_ND = 77 # Variable c_int
CAL_SABBREVMONTHNAME8 = 41 # Variable c_int
MMIO_FINDCHUNK = 16 # Variable c_int
IMAGE_REL_SH3_DIRECT4 = 6 # Variable c_int
EMARCH_ENC_I17_IMM41b_SIZE_X = 8 # Variable c_int
TYPE_E_INVDATAREAD = -2147319784 # Variable c_long
ENABLEPAIRKERNING = 769 # Variable c_int
CF_PRINTERFONTS = 2 # Variable c_int
ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED = 1925 # Variable c_long
MM_TWIPS = 6 # Variable c_int
NRC_SNUMOUT = 8 # Variable c_int
CONVERT10_E_OLESTREAM_FMT = -2147221054 # Variable c_long
PROPSETFLAG_UNBUFFERED = 4 # Variable c_int
SE_ERR_DDETIMEOUT = 28 # Variable c_int
HIGH_PRIORITY_CLASS = 128 # Variable c_int
SPI_GETICONTITLEWRAP = 25 # Variable c_int
PSINJECT_PAGEBBOX = 26 # Variable c_int
SB_SETTIPTEXTA = 1040 # Variable c_int
SND_NODEFAULT = 2 # Variable c_int
NRC_SYSTEM = 64 # Variable c_int
WSAETIMEDOUT = 10060 # Variable c_int
RPC_E_NOT_REGISTERED = -2147417853 # Variable c_long
I_INDENTCALLBACK = -1 # Variable c_int
ERROR_UNRECOGNIZED_VOLUME = 1005 # Variable c_long
CF_TTONLY = 262144 # Variable c_long
ERROR_BROKEN_PIPE = 109 # Variable c_long
PAN_SERIF_EXAGGERATED = 9 # Variable c_int
MF_HELP = 16384 # Variable c_long
BF_DIAGONAL_ENDBOTTOMRIGHT = 28 # Variable c_int
CAL_SMONTHNAME11 = 31 # Variable c_int
MAXWORD = 65535 # Variable c_int
TB_ISBUTTONINDETERMINATE = 1037 # Variable c_int
DS_SETFONT = 64 # Variable c_long
XTYP_REQUEST = 8368 # Variable c_int
IO_REPARSE_TAG_SIS = 2147483655 # Variable c_uint
MSHCTX_DIFFERENTMACHINE = 2
FS_CHINESESIMP = 262144 # Variable c_long
MWT_IDENTITY = 1 # Variable c_int
SUBLANG_SPANISH_PUERTO_RICO = 20 # Variable c_int
PAN_WEIGHT_MEDIUM = 6 # Variable c_int
MF_ERRORS = 268435456 # Variable c_int
R2_MASKNOTPEN = 3 # Variable c_int
LOCALE_SDAYNAME7 = 48 # Variable c_int
rad2 = 1057 # Variable c_int

tagFUNCFLAGS = c_int # enum
FUNCFLAG_FRESTRICTED = 1
FUNCFLAG_FSOURCE = 2
FUNCFLAG_FBINDABLE = 4
FUNCFLAG_FREQUESTEDIT = 8
FUNCFLAG_FDISPLAYBIND = 16
FUNCFLAG_FDEFAULTBIND = 32
FUNCFLAG_FHIDDEN = 64
FUNCFLAG_FUSESGETLASTERROR = 128
FUNCFLAG_FDEFAULTCOLLELEM = 256
FUNCFLAG_FUIDEFAULT = 512
FUNCFLAG_FNONBROWSABLE = 1024
FUNCFLAG_FREPLACEABLE = 2048
FUNCFLAG_FIMMEDIATEBIND = 4096
JobObjectSecurityLimitInformation = 5
SUBLANG_ENGLISH_EIRE = 6 # Variable c_int
PAN_LETT_NORMAL_FLATTENED = 5 # Variable c_int
JOY_RETURNU = 16 # Variable c_long
LCMAP_BYTEREV = 2048 # Variable c_int
MINLONG = 2147483648 # Variable c_uint
PS_DASHDOTDOT = 4 # Variable c_int
CC_ELLIPSES = 8 # Variable c_int
WAVERR_STILLPLAYING = 33 # Variable c_int
TRUST_E_NOSIGNATURE = -2146762496 # Variable c_long
MOD_ALT = 1 # Variable c_int
DL_DRAGGING = 1158 # Variable c_int
NUMPRS_INEXACT = 131072 # Variable c_int
DESKTOP_ENUMERATE = 64 # Variable c_long
MCIERR_NO_WINDOW = 346 # Variable c_int
THREAD_ALL_ACCESS = 2032639 # Variable c_long
HDM_DELETEITEM = 4610 # Variable c_int
IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14 # Variable c_int
RPC_S_INVALID_TAG = 1733 # Variable c_long
ERROR_HOOK_NOT_INSTALLED = 1431 # Variable c_long
EMR_SCALEVIEWPORTEXTEX = 31 # Variable c_int
ILD_OVERLAYMASK = 3840 # Variable c_int
PAN_PROP_EVEN_WIDTH = 4 # Variable c_int
TKIND_RECORD = 1
WNCON_FORNETCARD = 1 # Variable c_int
MF_BYCOMMAND = 0 # Variable c_long
ILC_MASK = 1 # Variable c_int
JOB_NOTIFY_FIELD_PRINT_PROCESSOR = 6 # Variable c_int
__REQUIRED_RPCNDR_H_VERSION__ = 440 # Variable c_int
MIXER_GETLINEINFOF_DESTINATION = 0 # Variable c_long
SUBLANG_ARABIC_QATAR = 16 # Variable c_int
TBIF_STYLE = 8 # Variable c_int
JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT = 3 # Variable c_int
CDN_HELP = 4294966691 # Variable c_uint
LVN_MARQUEEBEGIN = 4294967140 # Variable c_uint
WM_NCCALCSIZE = 131 # Variable c_int
TYPE_E_OUTOFBOUNDS = -2147316575 # Variable c_long
GETSETPRINTORIENT = 30 # Variable c_int
MM_MIM_ERROR = 965 # Variable c_int
EMR_EXTSELECTCLIPRGN = 75 # Variable c_int
TCS_EX_REGISTERDROP = 2 # Variable c_int
MIXERCONTROL_CT_UNITS_SIGNED = 131072 # Variable c_long
SS_RIGHTJUST = 1024 # Variable c_long
MCI_ANIM_GETDEVCAPS_MAX_WINDOWS = 16392 # Variable c_long
PRF_OWNED = 32 # Variable c_long
SERVICE_PAUSE_CONTINUE = 64 # Variable c_int
PGM_GETBKCOLOR = 5125 # Variable c_int
CLIP_CHARACTER_PRECIS = 1 # Variable c_int
chx15 = 1054 # Variable c_int
VK_JUNJA = 23 # Variable c_int
SUBLANG_ARABIC_OMAN = 8 # Variable c_int
ICC_COOL_CLASSES = 1024 # Variable c_int
DESKTOP_CREATEMENU = 4 # Variable c_long
DM_PAPERSIZE = 2 # Variable c_long
BST_CHECKED = 1 # Variable c_int
EV_ERR = 128 # Variable c_int
TBSTYLE_AUTOSIZE = 16 # Variable c_int
FOF_NOCONFIRMMKDIR = 512 # Variable c_int
MF_MASK = 4278190080 # Variable c_uint
RPC_S_PROTOCOL_ERROR = 1728 # Variable c_long
VT_I8 = 20
WHITE_PEN = 6 # Variable c_int
NEWTRANSPARENT = 3 # Variable c_int
RPC_E_FAULT = -2147417852 # Variable c_long
META_ARC = 2071 # Variable c_int
SPECIFIC_RIGHTS_ALL = 65535 # Variable c_long
PS_COSMETIC = 0 # Variable c_int
BAUD_4800 = 512 # Variable c_ulong
DRVCNF_OK = 1 # Variable c_int
SM_SECURE = 44 # Variable c_int
SECURITY_AUTHENTICATED_USER_RID = 11 # Variable c_long
LMEM_VALID_FLAGS = 3954 # Variable c_int
PDEVICESIZE = 26 # Variable c_int
MMIO_GETTEMP = 131072 # Variable c_int
XTYP_ADVREQ = 8226 # Variable c_int
CFSTR_MIME_TEXT = 'text/plain' # Variable POINTER(c_wchar)
DC_DATATYPE_PRODUCED = 21 # Variable c_int
FILE_FLAG_POSIX_SEMANTICS = 16777216 # Variable c_int
DISP_E_UNKNOWNINTERFACE = -2147352575 # Variable c_long
ACL_REVISION = 2 # Variable c_int
GCP_DISPLAYZWG = 4194304 # Variable c_long
TVGN_NEXTVISIBLE = 6 # Variable c_int
TTTOOLINFOW_V1_SIZE = 40 # Variable c_uint
SUBLANG_NEPALI_INDIA = 2 # Variable c_int
PBM_GETPOS = 1032 # Variable c_int
GW_CHILD = 5 # Variable c_int
ODT_HEADER = 100 # Variable c_int
FILE_FLAG_SEQUENTIAL_SCAN = 134217728 # Variable c_int
HELP_CONTEXT = 1 # Variable c_long
CRYPT_E_INVALID_PRINTABLE_STRING = -2146885599 # Variable c_long
GL_ID_PRIVATE_LAST = 65535 # Variable c_int
SM_CYFULLSCREEN = 17 # Variable c_int
MCIERR_GET_CD = 307 # Variable c_int
RPC_S_FP_UNDERFLOW = 1770 # Variable c_long
IMAGE_REL_ALPHA_PAIR = 12 # Variable c_int
ACN_START = 1 # Variable c_int
SPAPI_E_REMOTE_COMM_FAILURE = -2146500063 # Variable c_long
DESKTOP_JOURNALRECORD = 16 # Variable c_long
MM_MOM_CLOSE = 968 # Variable c_int
EMARCH_ENC_I17_IMM41c_VAL_POS_X = 40 # Variable c_int
MCI_SEQ_SET_TEMPO = 65536 # Variable c_long
PGS_DRAGNDROP = 4 # Variable c_int
MIXERCONTROL_CT_CLASS_NUMBER = 805306368 # Variable c_long
MOVEFILE_COPY_ALLOWED = 2 # Variable c_int
IMAGE_SCN_ALIGN_256BYTES = 9437184 # Variable c_int
LCID_ALTERNATE_SORTS = 4 # Variable c_int
OLE_E_WRONGCOMPOBJ = -2147221490 # Variable c_long
DPD_DELETE_SPECIFIC_VERSION = 2 # Variable c_int
DV_E_NOIVIEWOBJECT = -2147221395 # Variable c_long
PROCESS_QUERY_INFORMATION = 1024 # Variable c_int
LVM_GETNUMBEROFWORKAREAS = 4169 # Variable c_int
SERVICE_CONTROL_STOP = 1 # Variable c_int
OLE_E_NOT_INPLACEACTIVE = -2147221488 # Variable c_long
MCI_MODE_PLAY = 526 # Variable c_int
RT_GROUP_CURSOR = 18 # Variable POINTER(c_wchar)
IMAGE_SYM_TYPE_INT = 4 # Variable c_int
GL_ID_TYPINGERROR = 33 # Variable c_int
ERROR_CONTINUE = 1246 # Variable c_long
WM_NCRBUTTONDBLCLK = 166 # Variable c_int
INVALID_FILE_SIZE = 4294967295 # Variable c_ulong
OLEOBJ_S_FIRST = 262528 # Variable c_long
CFSTR_MIME_X_SGI_MOVIE = 'video/x-sgi-movie' # Variable POINTER(c_wchar)
TCM_INSERTITEMW = 4926 # Variable c_int
SPLDS_PRINT_DUPLEX_SUPPORTED = 'printDuplexSupported' # Variable POINTER(c_wchar)

tagBINDSTATUS = c_int # enum
BINDSTATUS_FINDINGRESOURCE = 1
BINDSTATUS_CONNECTING = 2
BINDSTATUS_REDIRECTING = 3
BINDSTATUS_BEGINDOWNLOADDATA = 4
BINDSTATUS_BEGINSYNCOPERATION = 15
BINDSTATUS_ENDSYNCOPERATION = 16
BINDSTATUS_UPLOADINGDATA = 18
BINDSTATUS_ENDUPLOADDATA = 19
BINDSTATUS_PROTOCOLCLASSID = 20
BINDSTATUS_ENCODING = 21
BINDSTATUS_DECODING = 24
BINDSTATUS_LOADINGMIMEHANDLER = 25
ERROR_DISK_FULL = 112 # Variable c_long
DFCS_SCROLLSIZEGRIP = 8 # Variable c_int
RDW_INTERNALPAINT = 2 # Variable c_int
WS_EX_LEFTSCROLLBAR = 16384 # Variable c_long
META_SETRELABS = 261 # Variable c_int
SW_SHOWMINNOACTIVE = 7 # Variable c_int
IME_ESC_RESERVED_LAST = 2047 # Variable c_int
CDRF_NEWFONT = 2 # Variable c_int
FRAME_TSS = 2 # Variable c_int
XTYP_XACT_COMPLETE = 32896 # Variable c_int
MCI_CLOSE = 2052 # Variable c_int
SC_MOVE = 61456 # Variable c_int
THREAD_BASE_PRIORITY_MAX = 2 # Variable c_int
MIXERCONTROL_CT_UNITS_CUSTOM = 0 # Variable c_long
SECURITY_ANONYMOUS = 0 # Variable c_int
PERF_DETAIL_WIZARD = 400 # Variable c_int
HEAP_FREE_CHECKING_ENABLED = 64 # Variable c_int
SIZE_RESTORED = 0 # Variable c_int
CSTR_LESS_THAN = 1 # Variable c_int
LANG_CHINESE = 4 # Variable c_int
ACTFLG_SystemWide = 4 # Variable c_int
SS_NOPREFIX = 128 # Variable c_long
RPC_S_NOT_CANCELLED = 1826 # Variable c_long
ERROR_BAD_PROFILE = 1206 # Variable c_long
IMAGE_SUBSYSTEM_UNKNOWN = 0 # Variable c_int
MCM_GETMINREQRECT = 4105 # Variable c_int
BDR_INNER = 12 # Variable c_int
ERROR_SERVICE_START_HANG = 1070 # Variable c_long
FORMAT_MESSAGE_FROM_HMODULE = 2048 # Variable c_int
MCI_OPEN_ELEMENT = 512 # Variable c_long
PERF_COUNTER_HISTOGRAM = 393216 # Variable c_int
WNNC_NET_PATHWORKS = 851968 # Variable c_int
SW_MAX = 11 # Variable c_int
VTBIT_I2 = 4 # Variable c_int
DRAFT_QUALITY = 1 # Variable c_int
CAL_SMONTHNAME6 = 26 # Variable c_int
IMAGE_SYM_CLASS_UNDEFINED_LABEL = 7 # Variable c_int
S_SEROFM = -2 # Variable c_int
CO_E_DECODEFAILED = -2147220966 # Variable c_long
SPI_SETPENWINDOWS = 49 # Variable c_int
RPC_C_VERS_ALL = 1 # Variable c_int
HKL_PREV = 0 # Variable c_int
MCI_FORMAT_SAMPLES = 9 # Variable c_int
APPCMD_FILTERINITS = 32 # Variable c_long
STG_E_BADBASEADDRESS = -2147286768 # Variable c_long
ERROR_SHUTDOWN_CLUSTER = 5008 # Variable c_long
RPC_S_INVALID_NAF_ID = 1763 # Variable c_long
CALLBACK_TASK = 131072 # Variable c_long
ERROR_OPERATION_ABORTED = 995 # Variable c_long
RPC_S_INVALID_NAME_SYNTAX = 1736 # Variable c_long
PCF_TOTALTIMEOUTS = 64 # Variable c_ulong
MCI_VD_PLAY_FAST = 131072 # Variable c_long
scr4 = 1171 # Variable c_int
IPPORT_ECHO = 7 # Variable c_int
SSGF_NONE = 0 # Variable c_int
stc14 = 1101 # Variable c_int
DM_PELSWIDTH = 524288 # Variable c_long
PRINTER_ERROR_OUTOFPAPER = 1 # Variable c_int
TVM_GETIMAGELIST = 4360 # Variable c_int
GCP_NUMERICOVERRIDE = 16777216 # Variable c_long
CTRY_BOLIVIA = 591 # Variable c_int
IS_TEXT_UNICODE_SIGNATURE = 8 # Variable c_int
RPC_E_INVALID_OBJREF = -2147417827 # Variable c_long
RBBS_GRIPPERALWAYS = 128 # Variable c_int
PERF_COUNTER_LARGE_DELTA = 4195584 # Variable c_int
PS_DASHDOT = 3 # Variable c_int
ABORTDOC = 2 # Variable c_int
STATFLAG_NOOPEN = 2
CTRY_SPAIN = 34 # Variable c_int
DFCS_MENUARROW = 0 # Variable c_int
SND_SYNC = 0 # Variable c_int
CO_E_ERRORINDLL = -2147220999 # Variable c_long
EPSPRINTING = 33 # Variable c_int
LOCALE_SMONTHNAME11 = 66 # Variable c_int
DT_CHARSTREAM = 4 # Variable c_int
ERROR_CANT_ACCESS_DOMAIN_INFO = 1351 # Variable c_long
WC_HEADERA = 'SysHeader32' # Variable POINTER(c_char)
WM_DDE_EXECUTE = 1000 # Variable c_int
IMAGE_SUBSYSTEM_NATIVE = 1 # Variable c_int
SM_CXMENUCHECK = 71 # Variable c_int
CONSOLE_TEXTMODE_BUFFER = 1 # Variable c_int
MCIERR_SET_CD = 308 # Variable c_int
ETO_NUMERICSLOCAL = 1024 # Variable c_int
LCMAP_SORTKEY = 1024 # Variable c_int
PGS_AUTOSCROLL = 2 # Variable c_int
DF_ALLOWOTHERACCOUNTHOOK = 1 # Variable c_long
PGF_CALCHEIGHT = 2 # Variable c_int
LB_GETTEXTLEN = 394 # Variable c_int
SETDTR = 5 # Variable c_int
ILD_NORMAL = 0 # Variable c_int
CAL_SMONTHNAME9 = 29 # Variable c_int
ERROR_CANNOT_OPEN_PROFILE = 1205 # Variable c_long
BAUD_1200 = 64 # Variable c_ulong
EVENPARITY = 2 # Variable c_int
MIXER_OBJECTF_HMIXER = 2147483648 # Variable c_ulong
HEAP_GROWABLE = 2 # Variable c_int
ODS_GRAYED = 2 # Variable c_int
EMR_EXTCREATEPEN = 95 # Variable c_int
VIF_SRCOLD = 4 # Variable c_long
LOCALE_IPOSSIGNPOSN = 82 # Variable c_int
TVM_GETVISIBLECOUNT = 4368 # Variable c_int
MIDI_CACHE_BESTFIT = 2 # Variable c_int
VK_NONAME = 252 # Variable c_int
ERROR_READ_FAULT = 30 # Variable c_long
ERROR_INVALID_PARAMETER = 87 # Variable c_long
ERROR_NOT_READY = 21 # Variable c_long
RP_INIFILE = 2 # Variable c_int
QS_HOTKEY = 128 # Variable c_int
LVSCW_AUTOSIZE_USEHEADER = -2 # Variable c_int
LR_LOADFROMFILE = 16 # Variable c_int
FOF_NOCONFIRMATION = 16 # Variable c_int
CFSTR_MIME_WAV = 'audio/wav' # Variable POINTER(c_wchar)
PD_ENABLEPRINTTEMPLATE = 16384 # Variable c_int
ERROR_INVALID_DLL = 1154 # Variable c_long
LOGON32_LOGON_BATCH = 4 # Variable c_int
DTN_FORMATA = 4294966540 # Variable c_uint
DST_BITMAP = 4 # Variable c_int
FRAME_NONFPO = 3 # Variable c_int
WAVECAPS_DIRECTSOUND = 64 # Variable c_int
RPC_C_OPT_MAX_OPTIONS = 10 # Variable c_int
SERVICE_FILE_SYSTEM_DRIVER = 2 # Variable c_int
OFN_NOREADONLYRETURN = 32768 # Variable c_int
TC_RESERVED = 32768 # Variable c_int
META_RESTOREDC = 295 # Variable c_int
LPD_SHARE_ACCUM = 256 # Variable c_int
WM_INPUTLANGCHANGE = 81 # Variable c_int
LVM_SETITEMPOSITION32 = 4145 # Variable c_int
SUBLANG_ARABIC_TUNISIA = 7 # Variable c_int
STUB_MARSHAL = 2
MCI_OVLY_GETDEVCAPS_CAN_FREEZE = 16386 # Variable c_long
stc25 = 1112 # Variable c_int
EMARCH_ENC_I17_IMM7B_SIZE_X = 7 # Variable c_int
PAGE_READONLY = 2 # Variable c_int
JOY_BUTTON2CHG = 512 # Variable c_int
MF_LINKS = 536870912 # Variable c_int
BS_NOTIFY = 16384 # Variable c_long
CTRY_TUNISIA = 216 # Variable c_int
DC_ENUMRESOLUTIONS = 13 # Variable c_int
PROCESS_SET_QUOTA = 256 # Variable c_int
ERROR_PARTIAL_COPY = 299 # Variable c_long
FOF_MULTIDESTFILES = 1 # Variable c_int
VIF_ACCESSVIOLATION = 512 # Variable c_long
DMPAPER_LEDGER = 4 # Variable c_int
MOD_WIN = 8 # Variable c_int
TVE_EXPANDPARTIAL = 16384 # Variable c_int
MCI_VD_MEDIA_CLV = 1026 # Variable c_int
SPLDS_SERVER_NAME = 'serverName' # Variable POINTER(c_wchar)
PROCESSOR_ARCHITECTURE_ARM = 5 # Variable c_int
MCIERR_DRIVER_INTERNAL = 272 # Variable c_int
SPLREG_PORT_THREAD_PRIORITY = 'PortThreadPriority' # Variable POINTER(c_wchar)
PSM_APPLY = 1134 # Variable c_int
MIXERCONTROL_CONTROLTYPE_TREBLE = 1342373891 # Variable c_long
CO_E_INIT_RPC_CHANNEL = -2147467254 # Variable c_long
IMAGE_FILE_MACHINE_SH4 = 422 # Variable c_int
LVHT_TOLEFT = 64 # Variable c_int
FROM_LEFT_3RD_BUTTON_PRESSED = 8 # Variable c_int
TVM_CREATEDRAGIMAGE = 4370 # Variable c_int
WHDR_INQUEUE = 16 # Variable c_int
WM_NCLBUTTONUP = 162 # Variable c_int
SERVICE_TYPE_ALL = 319 # Variable c_int
LZERROR_WRITE = -4 # Variable c_int
KF_EXTENDED = 256 # Variable c_int
TTM_UPDATETIPTEXTW = 1081 # Variable c_int
MIXER_SETCONTROLDETAILSF_QUERYMASK = 15 # Variable c_long
BAUD_1800 = 128 # Variable c_ulong
SC_HOTKEY = 61776 # Variable c_int
MM_HIMETRIC = 3 # Variable c_int
CF_BITMAP = 2 # Variable c_int
SM_CXICON = 11 # Variable c_int
HKCOMB_C = 4 # Variable c_int
MCSC_TRAILINGTEXT = 5 # Variable c_int
INET_E_RESOURCE_NOT_FOUND = -2146697211 # Variable c_long
TVC_BYMOUSE = 1 # Variable c_int
MKF_HOTKEYACTIVE = 4 # Variable c_int
MSHCTX_INPROC = 3
JOB_OBJECT_UILIMIT_DESKTOP = 64 # Variable c_int
TVN_ITEMEXPANDEDW = 4294966841 # Variable c_uint
TVM_SETITEMA = 4365 # Variable c_int
RBBIM_HEADERSIZE = 2048 # Variable c_int
MCIERR_PARSER_INTERNAL = 271 # Variable c_int
BINDSTRING_POST_DATA_MIME = 13
PRINTER_CHANGE_SET_PRINTER_DRIVER = 536870912 # Variable c_int
MIXERCONTROL_CT_CLASS_METER = 268435456 # Variable c_long
BF_LEFT = 1 # Variable c_int
PDERR_CREATEICFAILURE = 4106 # Variable c_int
MCHT_TITLE = 65536 # Variable c_int
IMAGE_SYM_TYPE_LONG = 5 # Variable c_int
IME_SMODE_PLAURALCLAUSE = 1 # Variable c_int
SS_NOTIFY = 256 # Variable c_long
IME_CMODE_NOCONVERSION = 256 # Variable c_int
UDS_NOTHOUSANDS = 128 # Variable c_int
NTE_BAD_HASH_STATE = -2146893812 # Variable c_long
IMAGE_REL_PPC_GPREL = 21 # Variable c_int
ILLUMINANT_D55 = 5 # Variable c_int
DESKTOP_JOURNALPLAYBACK = 32 # Variable c_long
TKIND_MODULE = 2
MCI_VD_GETDEVCAPS_FAST_RATE = 16387 # Variable c_long
NUMPRS_CURRENCY = 1024 # Variable c_int
PID_ILLEGAL = 4294967295 # Variable c_uint
RB_MAXIMIZEBAND = 1055 # Variable c_int
MIXERR_LASTERROR = 1026 # Variable c_int
TBM_GETRANGEMAX = 1026 # Variable c_int
NETINFO_DLL16 = 1 # Variable c_int
ICM_DELETEPROFILE = 2 # Variable c_int
TVM_GETTEXTCOLOR = 4384 # Variable c_int
PERF_MULTI_COUNTER = 33554432 # Variable c_int
RPC_C_AUTHN_LEVEL_PKT = 4 # Variable c_int
TVHT_BELOW = 512 # Variable c_int
MCI_VD_STATUS_MEDIA_TYPE = 16388 # Variable c_long
TA_RIGHT = 2 # Variable c_int
XTYP_MONITOR = 33010 # Variable c_int
ACTFLG_UserInstall = 32 # Variable c_int
WSAEREMOTE = 10071 # Variable c_int
XCLASS_BOOL = 4096 # Variable c_int
JOB_NOTIFY_FIELD_DRIVER_NAME = 8 # Variable c_int
ERROR_SUCCESS_REBOOT_REQUIRED = 3010 # Variable c_long
SYSPAL_ERROR = 0 # Variable c_int
DMCOLLATE_FALSE = 0 # Variable c_int
IMAGE_REL_ARM_SECREL = 15 # Variable c_int
SC_MOUSEMENU = 61584 # Variable c_int
JOB_NOTIFY_FIELD_PARAMETERS = 7 # Variable c_int
VK_HANJA = 25 # Variable c_int
CONTEXT_DEBUG_REGISTERS = 65552 # Variable c_long
TAPE_DRIVE_TAPE_CAPACITY = 256 # Variable c_int
VT_HRESULT = 25
RPC_X_INVALID_ES_ACTION = 1827 # Variable c_long
PERF_COUNTER_BASE = 196608 # Variable c_int
COLOR_WINDOWTEXT = 8 # Variable c_int
HDI_BITMAP = 16 # Variable c_int
IMAGE_SYM_TYPE_DOUBLE = 7 # Variable c_int
CONVERT10_E_STG_DIB_TO_BITMAP = -2147221050 # Variable c_long
PORT_TYPE_NET_ATTACHED = 8 # Variable c_int
WM_PAINTCLIPBOARD = 777 # Variable c_int
ERROR_TRUSTED_DOMAIN_FAILURE = 1788 # Variable c_long
MOUSEEVENTF_MOVE = 1 # Variable c_int
WGL_SWAP_OVERLAY1 = 2 # Variable c_int
CBEIF_TEXT = 1 # Variable c_int
WS_EX_WINDOWEDGE = 256 # Variable c_long
INET_E_CANNOT_CONNECT = -2146697212 # Variable c_long
MMSYSERR_NODRIVER = 6 # Variable c_int
ILCF_SWAP = 1 # Variable c_int
ERROR_METAFILE_NOT_SUPPORTED = 2003 # Variable c_long
SPLDS_PRINT_SEPARATOR_FILE = 'printSeparatorFile' # Variable POINTER(c_wchar)
psh4 = 1027 # Variable c_int
BST_PUSHED = 4 # Variable c_int
TVM_SETITEMW = 4415 # Variable c_int
NORM_IGNOREWIDTH = 131072 # Variable c_int
cmb3 = 1138 # Variable c_int
ICC_BAR_CLASSES = 4 # Variable c_int
VK_EXSEL = 248 # Variable c_int
LVM_EDITLABELA = 4119 # Variable c_int
ERROR_CLASS_DOES_NOT_EXIST = 1411 # Variable c_long
VS_FF_SPECIALBUILD = 32 # Variable c_long
SW_RESTORE = 9 # Variable c_int
VFT2_UNKNOWN = 0 # Variable c_long
RPC_S_BINDING_INCOMPLETE = 1819 # Variable c_long
SUBLANG_SPANISH_COSTA_RICA = 5 # Variable c_int
MSGF_COMMCTRL_TOOLBARCUST = 16899 # Variable c_int
CRYPT_E_BAD_ENCODE = -2146885630 # Variable c_long
C1_ALPHA = 256 # Variable c_int
_CONTROL = 32 # Variable c_int
URLPOLICY_JAVA_HIGH = 65536 # Variable c_int
CBEM_SETITEMW = 1036 # Variable c_int
TBM_CLEARTICS = 1033 # Variable c_int
FILE_APPEND_DATA = 4 # Variable c_int
SECTION_QUERY = 1 # Variable c_int
FR_NOUPDOWN = 1024 # Variable c_int
SUBLANG_SPANISH_PARAGUAY = 15 # Variable c_int
ERROR_NOT_ENOUGH_SERVER_MEMORY = 1130 # Variable c_long
VK_CANCEL = 3 # Variable c_int
IMAGE_REL_PPC_BRTAKEN = 512 # Variable c_int
TBM_SETSELEND = 1036 # Variable c_int
SHERB_NOSOUND = 4 # Variable c_int
MB_DEFAULT_DESKTOP_ONLY = 131072 # Variable c_long
PRINTER_ATTRIBUTE_SHARED = 8 # Variable c_int
HHT_TORIGHT = 1024 # Variable c_int
ENABLE_PROCESSED_INPUT = 1 # Variable c_int
DSTINVERT = 5570569 # Variable c_ulong
DMLERR_POKEACKTIMEOUT = 16395 # Variable c_int
PRINTER_CHANGE_ADD_JOB = 256 # Variable c_int
SS_BLACKFRAME = 7 # Variable c_long
DFCS_MENUCHECK = 1 # Variable c_int
TB_THUMBPOSITION = 4 # Variable c_int
MCI_STATUS_POSITION = 2 # Variable c_long
FONTDLGORD = 1542 # Variable c_int
JOY_BUTTON6 = 32 # Variable c_long
WIN_CERT_REVISION_2_0 = 512 # Variable c_int
PS_DASH = 1 # Variable c_int
TRUST_E_SUBJECT_FORM_UNKNOWN = -2146762749 # Variable c_long
SBT_OWNERDRAW = 4096 # Variable c_int
SORT_GERMAN_PHONE_BOOK = 1 # Variable c_int
DMPAPER_10X11 = 45 # Variable c_int
SE_DACL_PRESENT = 4 # Variable c_int
MCI_OPEN_TYPE = 8192 # Variable c_long
BF_MONO = 32768 # Variable c_int
TVM_HITTEST = 4369 # Variable c_int
ERROR_NO_NETWORK = 1222 # Variable c_long
SHERB_NOPROGRESSUI = 2 # Variable c_int
LANG_SLOVAK = 27 # Variable c_int
FS_THAI = 65536 # Variable c_long
SRVINFO_F_COSERVERINFO = 0
MMIOERR_BASE = 256 # Variable c_int
CBF_SKIP_UNREGISTRATIONS = 1048576 # Variable c_int
cmb5 = 1140 # Variable c_int
LANG_PUNJABI = 70 # Variable c_int
SECURITY_LOGON_IDS_RID = 5 # Variable c_long
VK_PLAY = 250 # Variable c_int
ERROR_INVALID_LIBRARY = 4301 # Variable c_long
SO_DISCOPT = 28675 # Variable c_int
IMAGE_COMDAT_SELECT_LARGEST = 6 # Variable c_int
MCIERR_CANNOT_LOAD_DRIVER = 266 # Variable c_int
ERROR_BAD_PROVIDER = 1204 # Variable c_long
TBM_SETTHUMBLENGTH = 1051 # Variable c_int
SPI_SETDRAGFULLWINDOWS = 37 # Variable c_int
BS_FLAT = 32768 # Variable c_long
TBDDRET_TREATPRESSED = 2 # Variable c_int
XST_INIT1 = 3 # Variable c_int
WC_NATIVEFONTCTLA = 'NativeFontCtl' # Variable POINTER(c_char)
PROCESS_CREATE_PROCESS = 128 # Variable c_int
CFS_POINT = 2 # Variable c_int
PERSIST_E_SIZEINDEFINITE = -2146762742 # Variable c_long
RPC_S_INVALID_BOUND = 1734 # Variable c_long
URLACTION_INFODELIVERY_NO_EDITING_CHANNELS = 7425 # Variable c_int
DDE_FNOTPROCESSED = 0 # Variable c_int
RPC_C_MQ_PERMANENT = 1 # Variable c_int
LVIR_ICON = 1 # Variable c_int
EMARCH_ENC_I17_IMM7B_INST_WORD_X = 3 # Variable c_int
SPAPI_E_NO_SUCH_DEVINST = -2146500085 # Variable c_long
SE_PRIVILEGE_ENABLED_BY_DEFAULT = 1 # Variable c_long
WM_SHOWWINDOW = 24 # Variable c_int
CERT_E_PATHLENCONST = -2146762492 # Variable c_long
VOS__WINDOWS16 = 1 # Variable c_long
SND_MEMORY = 4 # Variable c_int
MCSC_TITLETEXT = 3 # Variable c_int
VFT_STATIC_LIB = 7 # Variable c_long
XTYP_UNREGISTER = 32978 # Variable c_int
SB_ENDSCROLL = 8 # Variable c_int
CDRF_NOTIFYPOSTERASE = 64 # Variable c_int
MCI_VD_SEEK_REVERSE = 65536 # Variable c_long
TAPE_DRIVE_LOCK_UNLK_IMMED = 2147483776 # Variable c_uint
TAPE_DRIVE_ABS_BLK_IMMED = 2147491840 # Variable c_uint
INPLACE_S_TRUNCATED = 262560 # Variable c_long
INADDR_LOOPBACK = 2130706433 # Variable c_int
STN_CLICKED = 0 # Variable c_int
TB_THUMBTRACK = 5 # Variable c_int
RPC_C_STATS_CALLS_IN = 0 # Variable c_int
MIXERLINE_COMPONENTTYPE_SRC_LAST = 4106 # Variable c_long
LC_MARKER = 4 # Variable c_int
DOMAIN_GROUP_RID_CERT_ADMINS = 517 # Variable c_long
DOF_DOCUMENT = 32770 # Variable c_int
TT_ENABLED = 2 # Variable c_int
CO_E_NOT_SUPPORTED = -2147467231 # Variable c_long
DFCS_SCROLLCOMBOBOX = 5 # Variable c_int
WS_EX_PALETTEWINDOW = 392 # Variable c_long
VIF_DIFFCODEPG = 16 # Variable c_long
EMR_SETCOLORSPACE = 100 # Variable c_int
IGP_SELECT = 24 # Variable c_int
IDLFLAG_NONE = 0 # Variable c_int
RPC_S_CANT_CREATE_ENDPOINT = 1720 # Variable c_long
MCI_OVLY_STATUS_STRETCH = 16386 # Variable c_long
EM_GETLIMITTEXT = 213 # Variable c_int
PP_DISPLAYERRORS = 1 # Variable c_int
ERROR_INVALID_TARGET_HANDLE = 114 # Variable c_long
FOF_FILESONLY = 128 # Variable c_int
SIZEOF_RFPO_DATA = 16 # Variable c_int
JOB_CONTROL_SENT_TO_PRINTER = 6 # Variable c_int
SPI_SETCURSORS = 87 # Variable c_int
IMAGE_SCN_MEM_NOT_PAGED = 134217728 # Variable c_int
VK_RMENU = 165 # Variable c_int
HSHELL_WINDOWACTIVATED = 4 # Variable c_int
JOB_NOTIFY_FIELD_TOTAL_BYTES = 22 # Variable c_int

tagSTDMSHLFLAGS = c_int # enum
SECTION_ALL_ACCESS = 983071 # Variable c_long
MCIERR_WAVE_OUTPUTSUNSUITABLE = 326 # Variable c_int
CTRY_ZIMBABWE = 263 # Variable c_int
ERROR_HOST_NODE_NOT_AVAILABLE = 5005 # Variable c_long
UNIVERSAL_NAME_INFO_LEVEL = 1 # Variable c_int
ERROR_DISK_CORRUPT = 1393 # Variable c_long
COLOR_3DDKSHADOW = 21 # Variable c_int
BM_GETSTATE = 242 # Variable c_int
CAL_SMONTHNAME1 = 21 # Variable c_int
DMLERR_POSTMSG_FAILED = 16396 # Variable c_int
TAPE_ERASE_SHORT = 0 # Variable c_long
ERROR_NO_MORE_DEVICES = 1248 # Variable c_long
ERROR_NOTIFY_ENUM_DIR = 1022 # Variable c_long
MK_E_INVALIDEXTENSION = -2147221018 # Variable c_long
IME_CMODE_SYMBOL = 1024 # Variable c_int
SUBLANG_SPANISH_GUATEMALA = 4 # Variable c_int

_ACL_INFORMATION_CLASS = c_int # enum
AclRevisionInformation = 1
AclSizeInformation = 2
ERROR_AUTODATASEG_EXCEEDS_64k = 199 # Variable c_long
TVM_GETBKCOLOR = 4383 # Variable c_int

tagEXTCONN = c_int # enum
EXTCONN_STRONG = 1
EXTCONN_WEAK = 2
EXTCONN_CALLABLE = 4
PRINTER_CHANGE_DELETE_PRINT_PROCESSOR = 67108864 # Variable c_int
TVN_ENDLABELEDITW = 4294966836 # Variable c_uint
PRINTER_ERROR_JAM = 2 # Variable c_int
GMEM_DISCARDED = 16384 # Variable c_int
CAPSLOCK_ON = 128 # Variable c_int
MSGF_MAX = 8 # Variable c_int
XST_ADVDATASENT = 15 # Variable c_int
STDOLE_LCID = 0 # Variable c_int
SPI_SETFASTTASKSWITCH = 36 # Variable c_int
SIZE_MINIMIZED = 1 # Variable c_int
S_LEGATO = 1 # Variable c_int
TBIF_IMAGE = 1 # Variable c_int
DTM_GETMCCOLOR = 4103 # Variable c_int
WM_ENTERSIZEMOVE = 561 # Variable c_int
COLORONCOLOR = 3 # Variable c_int
SIF_TRACKPOS = 16 # Variable c_int
MM_WOM_CLOSE = 956 # Variable c_int
WM_CLEAR = 771 # Variable c_int
EMR_ARCTO = 55 # Variable c_int
TB_CUSTOMIZE = 1051 # Variable c_int
stc3 = 1090 # Variable c_int
DRV_USER = 16384 # Variable c_int
WM_DEADCHAR = 259 # Variable c_int
WSAECONNRESET = 10054 # Variable c_int
SO_DISCDATALEN = 28678 # Variable c_int
DL_BEGINDRAG = 1157 # Variable c_int
DATA_E_FIRST = 2147746096 # Variable c_ulong
GL_ID_PRIVATE_FIRST = 32768 # Variable c_int
RC_DEVBITS = 32768 # Variable c_int
CONTEXT_FLOATING_POINT = 65544 # Variable c_long
stc26 = 1113 # Variable c_int
STG_E_INSUFFICIENTMEMORY = -2147287032 # Variable c_long
GDICOMMENT_ENDGROUP = 3 # Variable c_int
EC_QUERYWAITING = 2 # Variable c_int
SOCKET_ERROR = -1 # Variable c_int
DESKTOP_READOBJECTS = 1 # Variable c_long
ERROR_INVALID_THREAD_ID = 1444 # Variable c_long
TBN_HOTITEMCHANGE = 4294966583 # Variable c_uint
_UPPER = 1 # Variable c_int
GL_ID_CHOOSECANDIDATE = 40 # Variable c_int
OLEOBJ_E_NOVERBS = -2147221120 # Variable c_long
WM_PAINT = 15 # Variable c_int
CTRY_PARAGUAY = 595 # Variable c_int

tagSTGMOVE = c_int # enum
STGMOVE_MOVE = 0
STGMOVE_COPY = 1
STGMOVE_SHALLOWCOPY = 2
SM_CXSIZE = 30 # Variable c_int
CAL_SABBREVMONTHNAME5 = 38 # Variable c_int
IMAGE_FILE_MACHINE_I386 = 332 # Variable c_int
CF_UNICODETEXT = 13 # Variable c_int
TVE_COLLAPSE = 1 # Variable c_int
IMAGE_DEBUG_TYPE_OMAP_FROM_SRC = 8 # Variable c_int
CTRY_OMAN = 968 # Variable c_int
MIXERCONTROL_CONTROLTYPE_PAN = 1073872897 # Variable c_long
CTRY_JORDAN = 962 # Variable c_int
HHT_TOLEFT = 2048 # Variable c_int
SPI_SETDESKPATTERN = 21 # Variable c_int
CP_WINANSI = 1004 # Variable c_int
RPCFLG_ASYNCHRONOUS = 1073741824 # Variable c_ulong
EMR_DELETEOBJECT = 40 # Variable c_int
WHDR_PREPARED = 2 # Variable c_int
TB_CHANGEBITMAP = 1067 # Variable c_int
IMAGE_REL_SH3_SECTION = 14 # Variable c_int
IMAGE_REL_BASED_ABSOLUTE = 0 # Variable c_int
DTM_SETMCCOLOR = 4102 # Variable c_int
CFERR_CHOOSEFONTCODES = 8192 # Variable c_int
MCI_ANIM_WINDOW_DEFAULT = 0 # Variable c_long
SPI_SETPOWEROFFACTIVE = 86 # Variable c_int
NEXTBAND = 3 # Variable c_int
CF_SCREENFONTS = 1 # Variable c_int
EMR_EXTTEXTOUTA = 83 # Variable c_int
edt11 = 1162 # Variable c_int
TBN_DROPDOWN = 4294966586 # Variable c_uint
SM_CXVSCROLL = 2 # Variable c_int
RPC_C_PROFILE_MATCH_BY_MBR = 3 # Variable c_int
OLE_E_BLANK = -2147221497 # Variable c_long
DESKTOPVERTRES = 117 # Variable c_int
CAL_SMONTHNAME13 = 33 # Variable c_int
SND_ALIAS_SYSTEMASTERISK = 10835 # Variable c_ulong
IMAGE_SUBSYSTEM_WINDOWS_CUI = 3 # Variable c_int
INADDR_ANY = 0 # Variable c_ulong
TRANSPORT_TYPE_DG = 2 # Variable c_int

tagMSHLFLAGS = c_int # enum
MSHLFLAGS_NORMAL = 0
MSHLFLAGS_TABLESTRONG = 1
MSHLFLAGS_TABLEWEAK = 2
MSHLFLAGS_NOPING = 4
UI_CAP_ROT90 = 2 # Variable c_int
TBSTYLE_TOOLTIPS = 256 # Variable c_int
LOCALE_SDATE = 29 # Variable c_int
JOY_BUTTON26 = 33554432 # Variable c_long
LVM_GETBKIMAGEW = 4235 # Variable c_int
RPC_S_NOT_RPC_ERROR = 1823 # Variable c_long
ERROR_THREAD_1_INACTIVE = 210 # Variable c_long
GREEK_CHARSET = 161 # Variable c_int
JOY_RETURNV = 32 # Variable c_long
MCI_SEEK_TO_START = 256 # Variable c_long
HCBT_CLICKSKIPPED = 6 # Variable c_int
LVS_EX_UNDERLINEHOT = 2048 # Variable c_int
MDMVOLFLAG_HIGH = 4 # Variable c_int

_tagOIBDG_FLAGS = c_int # enum
OIBDG_APARTMENTTHREADED = 256
BACKUP_OBJECT_ID = 7 # Variable c_int
TA_BASELINE = 24 # Variable c_int
PST_FAX = 33 # Variable c_ulong
ERROR_CURRENT_DIRECTORY = 16 # Variable c_long
EM_GETLINECOUNT = 186 # Variable c_int
TVIS_OVERLAYMASK = 3840 # Variable c_int
PROGRESS_CLASSW = 'msctls_progress32' # Variable POINTER(c_wchar)
DEFAULT_PITCH = 0 # Variable c_int
ITALIC_FONTTYPE = 512 # Variable c_int
HSHELL_WINDOWDESTROYED = 2 # Variable c_int
CLRBREAK = 9 # Variable c_int
SECTION_MAP_EXECUTE = 8 # Variable c_int
DMTT_SUBDEV = 3 # Variable c_int
ELF_VERSION = 0 # Variable c_int
APPCLASS_MONITOR = 1 # Variable c_long
QDI_STRETCHDIB = 8 # Variable c_int
MCIERR_UNSUPPORTED_FUNCTION = 274 # Variable c_int
CO_E_INIT_SCM_FILE_MAPPING_EXISTS = -2147467249 # Variable c_long
PRINTER_STATUS_PENDING_DELETION = 4 # Variable c_int
MCI_WAVE_STATUS_BITSPERSAMPLE = 16390 # Variable c_long
ERROR_SUCCESS_RESTART_REQUIRED = 3011 # Variable c_long
RT_VERSION = 22 # Variable POINTER(c_wchar)
ACS_TIMER = 8 # Variable c_int
CB_SETITEMHEIGHT = 339 # Variable c_int
WS_EX_CONTROLPARENT = 65536 # Variable c_long
PERF_COUNTER_MULTI_TIMER_INV = 591463680 # Variable c_int
PGK_SHIFT = 1 # Variable c_int
TTM_NEWTOOLRECTA = 1030 # Variable c_int
RPC_C_MQ_USE_EXISTING_SECURITY = 4 # Variable c_int
SYSPAL_NOSTATIC256 = 3 # Variable c_int
SERVICE_CONFIG_DESCRIPTION = 1 # Variable c_int
MCI_OVLY_WINDOW_DEFAULT = 0 # Variable c_long
IMAGE_REL_MIPS_ABSOLUTE = 0 # Variable c_int
TOKEN_ADJUST_PRIVILEGES = 32 # Variable c_int
CTLCOLOR_MAX = 7 # Variable c_int
_DIGIT = 4 # Variable c_int
HKCOMB_S = 2 # Variable c_int
BINDSTRING_ACCEPT_ENCODINGS = 11
URLZONEREG_HKCU = 2
LANG_LITHUANIAN = 39 # Variable c_int
HC_SYSMODALON = 4 # Variable c_int
HCBT_MOVESIZE = 0 # Variable c_int
DCX_INTERSECTUPDATE = 512 # Variable c_long
URLACTION_INFODELIVERY_CURR_MAX = 7430 # Variable c_int
IMAGE_REL_I386_ABSOLUTE = 0 # Variable c_int
CONNECT_REFCOUNT = 64 # Variable c_int
LANG_ALBANIAN = 28 # Variable c_int
RB_GETTOOLTIPS = 1041 # Variable c_int
LOCALE_INEGCURR = 28 # Variable c_int
TB_GETHOTITEM = 1095 # Variable c_int
SC_MANAGER_ENUMERATE_SERVICE = 4 # Variable c_int
MCI_SEQ_DIV_SMPTE_24 = 1217 # Variable c_int
PRINTER_STATUS_WARMING_UP = 65536 # Variable c_int
RPC_C_NS_SYNTAX_DEFAULT = 0 # Variable c_int
WM_TCARD = 82 # Variable c_int
LCMAP_SIMPLIFIED_CHINESE = 33554432 # Variable c_int
WGL_SWAP_OVERLAY3 = 8 # Variable c_int
CDIS_DISABLED = 4 # Variable c_int
TRANSPORT_TYPE_CN = 1 # Variable c_int
ERROR_NO_SUCH_SITE = 1249 # Variable c_long
MCS_WEEKNUMBERS = 4 # Variable c_int
NEWOBJECTOPENORD = 1548 # Variable c_int
ICC_USEREX_CLASSES = 512 # Variable c_int
TME_LEAVE = 2 # Variable c_int
LOCALE_IDEFAULTMACCODEPAGE = 4113 # Variable c_int
SECURITY_SERVICE_RID = 6 # Variable c_long
BACKGROUND_GREEN = 32 # Variable c_int
WM_KEYLAST = 264 # Variable c_int
ERROR_DEVICE_IN_USE = 2404 # Variable c_long
RPC_S_WAITONTIMER = -2147417834 # Variable c_long
DT_WORDBREAK = 16 # Variable c_int
WH_SYSMSGFILTER = 6 # Variable c_int
RESOURCEDISPLAYTYPE_SERVER = 2 # Variable c_int
ERROR_WORKING_SET_QUOTA = 1453 # Variable c_long
HS_CROSS = 4 # Variable c_int
IPPORT_EXECSERVER = 512 # Variable c_int
HCBT_SETFOCUS = 9 # Variable c_int
CHANGEKIND_SETDOCUMENTATION = 3
VIFF_DONTDELETEOLD = 2 # Variable c_int
SPAPI_E_DEVICE_INTERFACE_ACTIVE = -2146500069 # Variable c_long
FILE_EXECUTE = 32 # Variable c_int
IMAGE_SYM_TYPE_MOE = 11 # Variable c_int
ERROR_DLL_INIT_FAILED = 1114 # Variable c_long
EMARCH_ENC_I17_IMM41a_SIZE_X = 10 # Variable c_int
ST_ADVISE = 2 # Variable c_int
CBEN_DRAGBEGINW = 4294966487 # Variable c_uint
RC_BITBLT = 1 # Variable c_int
PWR_SUSPENDREQUEST = 1 # Variable c_int
PSM_SETWIZBUTTONS = 1136 # Variable c_int
KEY_CREATE_LINK = 32 # Variable c_int
KLF_REPLACELANG = 16 # Variable c_int
HWND_TOPMOST = 4294967295 # Variable POINTER(HWND__)
FR_HIDEWHOLEWORD = 65536 # Variable c_int
MCI_SAVE_FILE = 256 # Variable c_long
ERROR = 0 # Variable c_int
RPC_E_SERVERFAULT = -2147417851 # Variable c_long
MCI_WAVE_SET_AVGBYTESPERSEC = 524288 # Variable c_long
VOS__WINDOWS32 = 4 # Variable c_long
TB_HIDEBUTTON = 1028 # Variable c_int
LANG_LATVIAN = 38 # Variable c_int
HDI_TEXT = 2 # Variable c_int
TVIS_EXPANDEDONCE = 64 # Variable c_int
VT_PTR = 26

PROXY_PHASE = c_int # enum
PROXY_GETBUFFER = 1
PROXY_MARSHAL = 2
PROXY_SENDRECEIVE = 3
PROXY_UNMARSHAL = 4
ERROR_OPLOCK_NOT_GRANTED = 300 # Variable c_long
CAL_SABBREVMONTHNAME2 = 35 # Variable c_int
IDC_WAIT = 206100 # Variable POINTER(c_wchar)
CACHE_S_SAMECACHE = 262513 # Variable c_long
ERROR_INVALID_CLEANER = 4310 # Variable c_long
RC_FLOODFILL = 4096 # Variable c_int
WSB_PROP_CXHTHUMB = 16 # Variable c_long
IME_ITHOTKEY_UISTYLE_TOGGLE = 514 # Variable c_int
ERROR_ACCOUNT_EXPIRED = 1793 # Variable c_long
IMAGE_REL_BASED_MIPS_JMPADDR16 = 9 # Variable c_int
DLGC_STATIC = 256 # Variable c_int
PAN_LETT_OBLIQUE_WEIGHTED = 10 # Variable c_int
RB_SETTEXTCOLOR = 1045 # Variable c_int
GDT_VALID = 0 # Variable c_int
ASPECTX = 40 # Variable c_int
GMEM_INVALID_HANDLE = 32768 # Variable c_int
LB_SETHORIZONTALEXTENT = 404 # Variable c_int
IP_MULTICAST_IF = 2 # Variable c_int
SPLDS_VERSION_NUMBER = 'versionNumber' # Variable POINTER(c_wchar)
METRICS_USEDEFAULT = -1 # Variable c_int
LB_SETTOPINDEX = 407 # Variable c_int
WNNC_NET_COGENT = 1114112 # Variable c_int
SUBLANG_ARABIC_SYRIA = 10 # Variable c_int
SRVINFO_F_COSERVERINFO2 = 1
SHOW_OPENNOACTIVATE = 4 # Variable c_int
PBT_APMQUERYSTANDBY = 1 # Variable c_int
WINSTA_CREATEDESKTOP = 8 # Variable c_long
VARIANT_NOUSEROVERRIDE = 4 # Variable c_int
DS_CENTER = 2048 # Variable c_long
CO_E_ACESINWRONGORDER = -2147220969 # Variable c_long
MIXERCONTROL_CT_CLASS_SWITCH = 536870912 # Variable c_long
STGM_CONVERT = 131072 # Variable c_long
RPC_S_OUT_OF_RESOURCES = 1721 # Variable c_long
OLE_E_FIRST = -2147221504 # Variable c_long
SUBLANG_ARABIC_LIBYA = 4 # Variable c_int
MOUSEEVENTF_RIGHTUP = 16 # Variable c_int
JOY_BUTTON20 = 524288 # Variable c_long
SPLDS_PRINT_STAPLING_SUPPORTED = 'printStaplingSupported' # Variable POINTER(c_wchar)
MCI_PLAY = 2054 # Variable c_int
DL_CURSORSET = 0 # Variable c_int
AF_IMPLINK = 3 # Variable c_int
ERROR_NO_MEDIA_IN_DRIVE = 1112 # Variable c_long
GCPCLASS_LATINNUMBER = 5 # Variable c_int
PAGE_NOACCESS = 1 # Variable c_int
TBNF_TEXT = 2 # Variable c_int
SEC_WINNT_AUTH_IDENTITY_ANSI = 1 # Variable c_int
IMAGE_NT_OPTIONAL_HDR32_MAGIC = 267 # Variable c_int
SOMAXCONN = 5 # Variable c_int
QDI_SETDIBITS = 1 # Variable c_int
ASPECT_FILTERING = 1 # Variable c_int
VTBIT_I1 = 65536 # Variable c_int
META_INTERSECTCLIPRECT = 1046 # Variable c_int
JOB_OBJECT_SECURITY_FILTER_TOKENS = 8 # Variable c_int
CTRY_BELGIUM = 32 # Variable c_int
LPD_SWAP_EXCHANGE = 512 # Variable c_int
WM_IME_STARTCOMPOSITION = 269 # Variable c_int
MAP_PRECOMPOSED = 32 # Variable c_int
TRUNCATE_EXISTING = 5 # Variable c_int
PSD_NOWARNING = 128 # Variable c_int
PERF_ELAPSED_TIME = 807666944 # Variable c_int
MCI_VD_GETDEVCAPS_CAN_REVERSE = 16386 # Variable c_long
MCI_VD_GETDEVCAPS_CAV = 131072 # Variable c_long
IPPORT_EFSSERVER = 520 # Variable c_int
CFSTR_MIME_HTML = 'text/html' # Variable POINTER(c_wchar)
GCS_COMPCLAUSE = 32 # Variable c_int
EMR_OFFSETCLIPRGN = 26 # Variable c_int
TB_GETRECT = 1075 # Variable c_int
META_CREATEPENINDIRECT = 762 # Variable c_int
CERT_E_PURPOSE = -2146762490 # Variable c_long
FW_SEMIBOLD = 600 # Variable c_int
TCM_SETEXTENDEDSTYLE = 4916 # Variable c_int
NRC_ACTSES = 15 # Variable c_int
LBN_KILLFOCUS = 5 # Variable c_int
stc11 = 1098 # Variable c_int
ERROR_SEEK = 25 # Variable c_long
PORT_STATUS_POWER_SAVE = 12 # Variable c_int
WS_CHILD = 1073741824 # Variable c_long
CTRY_ROMANIA = 40 # Variable c_int
MDMVOL_MEDIUM = 1 # Variable c_int
ERROR_BAD_THREADID_ADDR = 159 # Variable c_long
RBN_DELETEDBAND = 4294966458 # Variable c_uint
SE_GROUP_ENABLED = 4 # Variable c_long
BF_ADJUST = 8192 # Variable c_int
FORM_USER = 0 # Variable c_int
PSP_HIDEHEADER = 2048 # Variable c_int
LOCALE_SISO639LANGNAME = 89 # Variable c_int
PRINTER_ERROR_INFORMATION = 2147483648 # Variable c_uint
SCS_CHANGEATTR = 18 # Variable c_int
SUBLANG_CHINESE_MACAU = 5 # Variable c_int
NRC_MAXAPPS = 54 # Variable c_int
VK_DECIMAL = 110 # Variable c_int
EVENTLOG_PAIRED_EVENT_INACTIVE = 16 # Variable c_int
SPI_SETMOUSE = 4 # Variable c_int
HDF_CENTER = 2 # Variable c_int
LANG_HEBREW = 13 # Variable c_int
NFS_BUTTON = 8 # Variable c_int
WM_DDE_DATA = 997 # Variable c_int
MAXLONG = 2147483647 # Variable c_int
TAPE_DRIVE_END_OF_DATA = 2147549184 # Variable c_uint
DLGC_WANTCHARS = 128 # Variable c_int
GMEM_LOCKCOUNT = 255 # Variable c_int
NTM_MULTIPLEMASTER = 262144 # Variable c_int
SELECT_CAP_SENTENCE = 2 # Variable c_int
SM_CXBORDER = 5 # Variable c_int
DRV_REMOVE = 10 # Variable c_int
IPPORT_SUPDUP = 95 # Variable c_int
ERROR_QUORUMLOG_OPEN_FAILED = 5028 # Variable c_long
CONNECT_PROMPT = 16 # Variable c_int
WS_VISIBLE = 268435456 # Variable c_long
EMR_SETMAPPERFLAGS = 16 # Variable c_int
MMIOM_OPEN = 3 # Variable c_int
BM_CLICK = 245 # Variable c_int
rad7 = 1062 # Variable c_int
ERROR_DYNLINK_FROM_INVALID_RING = 196 # Variable c_long
LVM_GETSTRINGWIDTHW = 4183 # Variable c_int
TAPE_DRIVE_SPACE_IMMEDIATE = 2155872256 # Variable c_uint
MIXERCONTROL_CONTROLTYPE_QSOUNDPAN = 1073872898 # Variable c_long
WNNC_NET_DCE = 1638400 # Variable c_int
LOCALE_SNATIVELANGNAME = 4 # Variable c_int
HDI_WIDTH = 1 # Variable c_int
TVHT_ONITEMLABEL = 4 # Variable c_int
GMR_VISIBLE = 0 # Variable c_int
DC_MAXEXTENT = 5 # Variable c_int
CF_NOFACESEL = 524288 # Variable c_long
OFN_HIDEREADONLY = 4 # Variable c_int
PC_PATHS = 512 # Variable c_int
PAN_MIDLINE_STANDARD_TRIMMED = 2 # Variable c_int
LOCALE_IPOSSEPBYSPACE = 85 # Variable c_int
MCI_SPIN = 2060 # Variable c_int
PANOSE_COUNT = 10 # Variable c_int
SERVICE_ACCEPT_SHUTDOWN = 4 # Variable c_int
MCI_OVLY_WHERE_DESTINATION = 262144 # Variable c_long
MEM_RESERVE = 8192 # Variable c_int
ODS_CHECKED = 8 # Variable c_int
ERROR_EVENTLOG_FILE_CHANGED = 1503 # Variable c_long
JOYCAPS_POVCTS = 64 # Variable c_int
TVM_GETTOOLTIPS = 4377 # Variable c_int
TIME_NOMINUTESORSECONDS = 1 # Variable c_int
LVM_FINDITEMW = 4179 # Variable c_int
PERF_NO_INSTANCES = -1 # Variable c_int
RDW_INVALIDATE = 1 # Variable c_int
TTF_CENTERTIP = 2 # Variable c_int
IME_KHOTKEY_ENGLISH = 82 # Variable c_int
MB_OK = 0 # Variable c_long
NI_CLOSECANDIDATE = 17 # Variable c_int
DMICM_SATURATE = 1 # Variable c_int
HDN_TRACKA = 4294966988 # Variable c_uint
JOB_NOTIFY_FIELD_PORT_NAME = 2 # Variable c_int
EMARCH_ENC_I17_IC_SIZE_X = 1 # Variable c_int
COLOR_INACTIVECAPTIONTEXT = 19 # Variable c_int
FADF_HAVEVARTYPE = 128 # Variable c_int
LBS_OWNERDRAWVARIABLE = 32 # Variable c_long
LVM_SETIMAGELIST = 4099 # Variable c_int
HHT_ONHEADER = 2 # Variable c_int
ERROR_EXTENDED_ERROR = 1208 # Variable c_long
ERROR_SERVICE_EXISTS = 1073 # Variable c_long
EM_SCROLL = 181 # Variable c_int
LVBKIF_STYLE_TILE = 16 # Variable c_int
TME_HOVER = 1 # Variable c_int
STATUS_FLOAT_DENORMAL_OPERAND = 3221225613 # Variable c_ulong
MCS_MULTISELECT = 2 # Variable c_int
CBM_INIT = 4 # Variable c_long
ICM_QUERYPROFILE = 3 # Variable c_int
IME_SMODE_AUTOMATIC = 4 # Variable c_int
FILE_READ_ATTRIBUTES = 128 # Variable c_int
stc27 = 1114 # Variable c_int
ILC_COLOR4 = 4 # Variable c_int
UPDFCACHE_NODATACACHE = 1 # Variable c_int
ABM_NEW = 0 # Variable c_int
NCBADDNAME = 48 # Variable c_int
LOCALE_IPOSSYMPRECEDES = 84 # Variable c_int

tagPENDINGMSG = c_int # enum
PENDINGMSG_CANCELCALL = 0
PENDINGMSG_WAITNOPROCESS = 1
PENDINGMSG_WAITDEFPROCESS = 2
RPC_S_CALL_FAILED = 1726 # Variable c_long
RPC_X_BYTE_COUNT_TOO_SMALL = 1782 # Variable c_long
PSH_WATERMARK = 32768 # Variable c_int
IMAGE_REL_MIPS_REFHALF = 1 # Variable c_int
CTRL_LOGOFF_EVENT = 5 # Variable c_int
UDM_SETRANGE32 = 1135 # Variable c_int
WNNC_NET_CLEARCASE = 1441792 # Variable c_int
PAN_MIDLINE_INDEX = 8 # Variable c_int
CAL_SABBREVMONTHNAME4 = 37 # Variable c_int
WHDR_ENDLOOP = 8 # Variable c_int
NO_PRIORITY = 0 # Variable c_int
PAN_WEIGHT_VERY_LIGHT = 2 # Variable c_int
LVSIL_SMALL = 1 # Variable c_int
AF_BAN = 21 # Variable c_int
TTTOOLINFOA_V1_SIZE = 40 # Variable c_uint
MF_HILITE = 128 # Variable c_long
OLEOBJ_S_INVALIDVERB = 262528 # Variable c_long
LVM_DELETEALLITEMS = 4105 # Variable c_int
DTR_CONTROL_HANDSHAKE = 2 # Variable c_int
GCPCLASS_NEUTRAL = 3 # Variable c_int
SND_ALIAS = 65536 # Variable c_long
RPC_C_STATS_CALLS_OUT = 1 # Variable c_int
NUMCOLORS = 24 # Variable c_int
PERF_COUNTER_QUEUELEN_TYPE = 4523008 # Variable c_int
IMAGE_SYM_CLASS_AUTOMATIC = 1 # Variable c_int
TAPE_DRIVE_WRITE_MARK_IMMED = 2415919104 # Variable c_uint
RPC_S_GROUP_MEMBER_NOT_FOUND = 1898 # Variable c_long
ERROR_BAD_ENVIRONMENT = 10 # Variable c_long
ERROR_INVALID_EA_NAME = 254 # Variable c_long
PROCESSOR_SHx_SH4 = 104 # Variable c_int
MOUSEEVENTF_LEFTDOWN = 2 # Variable c_int
EM_GETRECT = 178 # Variable c_int
FACILITY_STORAGE = 3 # Variable c_int
EN_VSCROLL = 1538 # Variable c_int
ERROR_ENVVAR_NOT_FOUND = 203 # Variable c_long
psh9 = 1032 # Variable c_int
TYPE_E_CANTCREATETMPFILE = -2147316573 # Variable c_long
CAL_SMONTHNAME12 = 32 # Variable c_int
PRINTER_FONTTYPE = 16384 # Variable c_int
LVM_SETICONSPACING = 4149 # Variable c_int
MIXERLINE_COMPONENTTYPE_DST_HEADPHONES = 5 # Variable c_long
ERROR_DIRECTORY = 267 # Variable c_long
TVI_SORT = 4294901763 # Variable POINTER(_TREEITEM)
DDD_REMOVE_DEFINITION = 2 # Variable c_int
HCBT_QS = 2 # Variable c_int
SHGNLI_PIDL = 1 # Variable c_int
COMPRESSION_FORMAT_NONE = 0 # Variable c_int
NM_RELEASEDCAPTURE = 4294967280 # Variable c_uint
MOUSEEVENTF_WHEEL = 2048 # Variable c_int
rad3 = 1058 # Variable c_int
IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 1024 # Variable c_int
S_WHITEVOICE = 7 # Variable c_int
CDN_TYPECHANGE = 4294966689 # Variable c_uint
TOKEN_ASSIGN_PRIMARY = 1 # Variable c_int
TCM_SETITEMA = 4870 # Variable c_int
PSM_SETCURSEL = 1125 # Variable c_int
CLASSFACTORY_S_FIRST = 262416 # Variable c_long
TB_SETBUTTONWIDTH = 1083 # Variable c_int
FF_MODERN = 48 # Variable c_int
SP_OUTOFMEMORY = -5 # Variable c_int
TBSTYLE_WRAPABLE = 512 # Variable c_int
SHGFI_USEFILEATTRIBUTES = 16 # Variable c_int
STG_E_CANTSAVE = -2147286781 # Variable c_long
WNCON_NOTROUTED = 2 # Variable c_int
ERROR_CLIPBOARD_NOT_OPEN = 1418 # Variable c_long
MMSYSERR_NODRIVERCB = 20 # Variable c_int
LVIS_ACTIVATING = 32 # Variable c_int
LVHT_TORIGHT = 32 # Variable c_int
RPC_E_THREAD_NOT_INIT = -2147417841 # Variable c_long
SB_ISSIMPLE = 1038 # Variable c_int
TKIND_DISPATCH = 4
RUSSIAN_CHARSET = 204 # Variable c_int
NRC_CMDCAN = 11 # Variable c_int
DRVCNF_CANCEL = 0 # Variable c_int
PERF_RAW_BASE = 1073939459 # Variable c_int
SC_TASKLIST = 61744 # Variable c_int
CP_REGION = 2 # Variable c_int
VTBIT_UI2 = 262144 # Variable c_int
psh1 = 1024 # Variable c_int
PSM_REBOOTSYSTEM = 1130 # Variable c_int
ERROR_SEM_USER_LIMIT = 106 # Variable c_long
EMR_RECTANGLE = 43 # Variable c_int
COLOR_BACKGROUND = 1 # Variable c_int
TTM_SETTOOLINFOA = 1033 # Variable c_int
ST_ISSELF = 256 # Variable c_int
NLS_IME_CONVERSION = 8388608 # Variable c_int
GCP_DBCS = 1 # Variable c_int
SND_APPLICATION = 128 # Variable c_int
RBN_GETOBJECT = 4294966464 # Variable c_uint
DWL_DLGPROC = 4 # Variable c_int
STGM_CREATE = 4096 # Variable c_long
RC_GDI20_STATE = 32 # Variable c_int
PST_LAT = 257 # Variable c_ulong
CS_HREDRAW = 2 # Variable c_int
WSAEOPNOTSUPP = 10045 # Variable c_int
WSANO_RECOVERY = 11003 # Variable c_int
MCI_OPEN_SHAREABLE = 256 # Variable c_long
SM_CYVSCROLL = 20 # Variable c_int
RESOURCEDISPLAYTYPE_NETWORK = 6 # Variable c_int
RPC_C_MGMT_IS_SERVER_LISTEN = 3 # Variable c_int
INET_E_OBJECT_NOT_FOUND = -2146697210 # Variable c_long
HELP_SETINDEX = 5 # Variable c_long
LOCALE_SINTLSYMBOL = 21 # Variable c_int
TAPE_DRIVE_LOG_BLK_IMMED = 2147516416 # Variable c_uint
WNNC_NET_VINES = 262144 # Variable c_int
PFD_NEED_SYSTEM_PALETTE = 256 # Variable c_int
CBEIF_DI_SETITEM = 268435456 # Variable c_int
DISP_E_DIVBYZERO = -2147352558 # Variable c_long
IMAGE_REL_SH3_SECREL = 15 # Variable c_int
PARAMFLAG_FOPT = 16 # Variable c_int
ctlLast = 1279 # Variable c_int
SPI_SETMOUSETRAILS = 93 # Variable c_int
CTRY_NORWAY = 47 # Variable c_int
PSBTN_FINISH = 2 # Variable c_int
FW_HEAVY = 900 # Variable c_int
TRUST_E_TIME_STAMP = -2146869243 # Variable c_long
CFSTR_MIME_X_WAV = 'audio/x-wav' # Variable POINTER(c_wchar)
LVN_ODCACHEHINT = 4294967183 # Variable c_uint
MKF_MODIFIERS = 64 # Variable c_int
STGM_SHARE_DENY_NONE = 64 # Variable c_long
LPD_SHARE_STENCIL = 128 # Variable c_int
IMAGE_REL_ALPHA_REFLO = 11 # Variable c_int
DLGC_WANTALLKEYS = 4 # Variable c_int
CLIP_TO_PATH = 4097 # Variable c_int
MCIERR_NEW_REQUIRES_ALIAS = 299 # Variable c_int
DFCS_MENUARROWRIGHT = 4 # Variable c_int
ICC_TREEVIEW_CLASSES = 2 # Variable c_int
URLACTION_JAVA_CURR_MAX = 7168 # Variable c_int
PBM_SETPOS = 1026 # Variable c_int
SPI_SETFONTSMOOTHING = 75 # Variable c_int
DRV_FREE = 6 # Variable c_int
IS_TEXT_UNICODE_NOT_UNICODE_MASK = 3840 # Variable c_int
PRINTER_STATUS_PAGE_PUNT = 524288 # Variable c_int
CP_SYMBOL = 42 # Variable c_int
STG_E_MEDIUMFULL = -2147286928 # Variable c_long
SERVICE_RUNNING = 4 # Variable c_int
CAL_HEBREW = 8 # Variable c_int
PROCESSOR_ARM820 = 2080 # Variable c_int
SECURITY_NT_NON_UNIQUE = 21 # Variable c_long
LZERROR_GLOBLOCK = -6 # Variable c_int
PSH_PROPTITLE = 1 # Variable c_int
NCBADDGRNAME = 54 # Variable c_int
TAPE_DRIVE_PADDING = 262144 # Variable c_int
MCI_VD_STATUS_DISC_SIZE = 16390 # Variable c_long
IPPORT_DAYTIME = 13 # Variable c_int
XMLELEMTYPE_DTD = 4
WSB_PROP_PALETTE = 2048 # Variable c_long
IPPROTO_ICMP = 1 # Variable c_int
TEXTCAPS = 34 # Variable c_int
PRINTACTION_NETINSTALLLINK = 3 # Variable c_int
IMAGE_REL_PPC_ADDR64 = 1 # Variable c_int
ERROR_INVALID_SIGNAL_NUMBER = 209 # Variable c_long
MCI_ESCAPE = 2053 # Variable c_int
LVBKIF_SOURCE_HBITMAP = 1 # Variable c_int
HTBOTTOMRIGHT = 17 # Variable c_int
ERROR_PASSWORD_MUST_CHANGE = 1907 # Variable c_long
PRINTER_ERROR_SEVERE = 536870912 # Variable c_int
TRANSFORM_CTM = 4107 # Variable c_int
edt14 = 1165 # Variable c_int
ERROR_INVALID_TIME = 1901 # Variable c_long
stc18 = 1105 # Variable c_int
PASSTHROUGH = 19 # Variable c_int
PGF_CALCWIDTH = 1 # Variable c_int
ICC_WIN95_CLASSES = 255 # Variable c_int
C3_DIACRITIC = 2 # Variable c_int
NRC_NAMERR = 23 # Variable c_int
RB_GETBANDBORDERS = 1058 # Variable c_int
PID_DICTIONARY = 0 # Variable c_int
HELP_MULTIKEY = 513 # Variable c_long
LOCALE_RETURN_NUMBER = 536870912 # Variable c_int
LVCF_WIDTH = 2 # Variable c_int
WNFMT_INENUM = 16 # Variable c_int
S_OK = 0 # Variable c_long
VT_SAFEARRAY = 27
BAUD_150 = 8 # Variable c_ulong
CB_ADDSTRING = 323 # Variable c_int
CS_E_LAST = 2147746152 # Variable c_ulong
ERROR_ALREADY_EXISTS = 183 # Variable c_long
NUMPRS_TRAILING_WHITE = 2 # Variable c_int
SE_GROUP_ENABLED_BY_DEFAULT = 2 # Variable c_long
MMSYSERR_INVALHANDLE = 5 # Variable c_int
TVM_INSERTITEMA = 4352 # Variable c_int
SE_SHUTDOWN_NAME = 'SeShutdownPrivilege' # Variable POINTER(c_wchar)
WM_QUERYENDSESSION = 17 # Variable c_int
CF_OEMTEXT = 7 # Variable c_int
SUBLANG_SWEDISH = 1 # Variable c_int
SE_REMOTE_SHUTDOWN_NAME = 'SeRemoteShutdownPrivilege' # Variable POINTER(c_wchar)
JOB_CONTROL_LAST_PAGE_EJECTED = 7 # Variable c_int
PWR_OK = 1 # Variable c_int
MH_KEEP = 2 # Variable c_int
EMR_REALIZEPALETTE = 52 # Variable c_int
IMAGE_REL_MIPS_SECTION = 10 # Variable c_int
CCS_NOMOVEX = 130 # Variable c_long
ERROR_ILLEGAL_ELEMENT_ADDRESS = 1162 # Variable c_long
STOCK_LAST = 17 # Variable c_int
MOUSEEVENTF_MIDDLEUP = 64 # Variable c_int
PIDSI_APPNAME = 18 # Variable c_long
EM_SCROLLCARET = 183 # Variable c_int
DPD_DELETE_ALL_FILES = 4 # Variable c_int
PCF_SETXCHAR = 32 # Variable c_ulong
PAN_CONTRAST_MEDIUM = 6 # Variable c_int
CERT_E_UNTRUSTEDTESTROOT = -2146762483 # Variable c_long
LB_ERRSPACE = -2 # Variable c_int
PSINJECT_PAGES = 21 # Variable c_int
VFT2_FONT_RASTER = 1 # Variable c_long
ERROR_WMI_INVALID_MOF = 4210 # Variable c_long
IN_CLASSC_NSHIFT = 8 # Variable c_int
DST_ICON = 3 # Variable c_int
CO_E_FAILEDTOGETSECCTX = -2147220991 # Variable c_long
R2_XORPEN = 7 # Variable c_int
MCI_WAVE_STATUS_SAMPLESPERSEC = 16387 # Variable c_long
CP_INSTALLED = 1 # Variable c_int
CDERR_REGISTERMSGFAIL = 12 # Variable c_int
ERROR_PORT_UNREACHABLE = 1234 # Variable c_long
RDH_RECTANGLES = 1 # Variable c_int
PID_LOCALE = 2147483648 # Variable c_uint
LVCFMT_CENTER = 2 # Variable c_int
SET_BOUNDS = 4109 # Variable c_int
CDDS_POSTPAINT = 2 # Variable c_int
ODS_SELECTED = 1 # Variable c_int
HKCOMB_A = 8 # Variable c_int
MDITILE_HORIZONTAL = 1 # Variable c_int
DMLERR_ADVACKTIMEOUT = 16384 # Variable c_int
WM_SYSKEYUP = 261 # Variable c_int
LMEM_NODISCARD = 32 # Variable c_int
MCI_FORMAT_FRAMES = 3 # Variable c_int
BLTALIGNMENT = 119 # Variable c_int
SERVICE_ERROR_SEVERE = 2 # Variable c_int
PSP_RTLREADING = 16 # Variable c_int
WM_CUT = 768 # Variable c_int
ERROR_FILE_OFFLINE = 4350 # Variable c_long
RPC_S_UNKNOWN_AUTHN_TYPE = 1741 # Variable c_long
PERF_DISPLAY_NOSHOW = 1073741824 # Variable c_int
WNNC_NET_DECORB = 2097152 # Variable c_int
KL_NAMELENGTH = 9 # Variable c_int
SWP_NOSENDCHANGING = 1024 # Variable c_int
STG_E_NOMOREFILES = -2147287022 # Variable c_long
WC_TREEVIEWW = 'SysTreeView32' # Variable POINTER(c_wchar)
MIXERCONTROL_CONTROLTYPE_PEAKMETER = 268566529 # Variable c_long
S_PERIODVOICE = 3 # Variable c_int
VFT_VXD = 5 # Variable c_long
PGF_NORMAL = 1 # Variable c_int
VT_STREAMED_OBJECT = 68
RC_DI_BITMAP = 128 # Variable c_int
VALID_INHERIT_FLAGS = 31 # Variable c_int
EC_USEFONTINFO = 65535 # Variable c_int
DFCS_MENUBULLET = 2 # Variable c_int
RT_MESSAGETABLE = 17 # Variable POINTER(c_wchar)
ILC_COLOR8 = 8 # Variable c_int
CB_DIR = 325 # Variable c_int
TCIS_HIGHLIGHTED = 2 # Variable c_int
WSAHOST_NOT_FOUND = 11001 # Variable c_int
VFT2_DRV_SOUND = 9 # Variable c_long
CBR_128000 = 128000 # Variable c_int
PF_PPC_MOVEMEM_64BIT_OK = 4 # Variable c_int
DMBIN_ONLYONE = 1 # Variable c_int
ERROR_SERVICE_DEPENDENCY_FAIL = 1068 # Variable c_long
VK_NUMPAD9 = 105 # Variable c_int
MCN_FIRST = 4294966546 # Variable c_uint
RESOURCEDISPLAYTYPE_GENERIC = 0 # Variable c_int
PSIDENT_PSCENTRIC = 1 # Variable c_int
BS_LEFTTEXT = 32 # Variable c_long
TCI_SRCCODEPAGE = 2 # Variable c_int
CO_E_NOMATCHINGSIDFOUND = -2147220980 # Variable c_long
ERROR_FILE_ENCRYPTED = 6002 # Variable c_long
GETTECHNOLOGY = 20 # Variable c_int
MIXERCONTROL_CONTROLTYPE_BASS = 1342373890 # Variable c_long
ABSOLUTE = 1 # Variable c_int
URLPOLICY_NOTIFY_ON_ALLOW = 16 # Variable c_int

__MIDL_IBindStatusCallback_0002 = c_int # enum
NTE_BAD_KEY = -2146893821 # Variable c_long
WM_DDE_LAST = 1000 # Variable c_int
XTYPF_NODATA = 4 # Variable c_int
WM_NCCREATE = 129 # Variable c_int
HELP_SETWINPOS = 515 # Variable c_long
BSF_POSTMESSAGE = 16 # Variable c_int
LVM_GETTEXTBKCOLOR = 4133 # Variable c_int
SIOCGLOWAT = 1074033411 # Variable c_long
IMN_CLOSECANDIDATE = 4 # Variable c_int
OF_SHARE_COMPAT = 0 # Variable c_int
HANGEUL_CHARSET = 129 # Variable c_int
SECTION_MAP_WRITE = 2 # Variable c_int
EM_GETFIRSTVISIBLELINE = 206 # Variable c_int
HELP_CONTEXTPOPUP = 8 # Variable c_long
stc32 = 1119 # Variable c_int
LANG_VIETNAMESE = 42 # Variable c_int
WSB_PROP_WINSTYLE = 1024 # Variable c_long
ERROR_TOO_MANY_SECRETS = 1381 # Variable c_long
SPLREG_BEEP_ENABLED = 'BeepEnabled' # Variable POINTER(c_wchar)
LB_GETTOPINDEX = 398 # Variable c_int
XST_NULL = 0 # Variable c_int
SPI_GETSERIALKEYS = 62 # Variable c_int
GW_OWNER = 4 # Variable c_int
MCI_OVLY_WINDOW_HWND = 65536 # Variable c_long
WMSZ_BOTTOMRIGHT = 8 # Variable c_int
CS_INSERTCHAR = 8192 # Variable c_int
NM_KEYDOWN = 4294967281 # Variable c_uint
IMAGE_FILE_MACHINE_SH3E = 420 # Variable c_int
LVN_DELETEITEM = 4294967193 # Variable c_uint
TBSTYLE_EX_DRAWDDARROWS = 1 # Variable c_int
RBBS_FIXEDBMP = 32 # Variable c_int
CLIPBRD_E_CANT_OPEN = -2147221040 # Variable c_long
PSM_CHANGED = 1128 # Variable c_int
CF_GDIOBJFIRST = 768 # Variable c_int
IMAGE_REL_ALPHA_ABSOLUTE = 0 # Variable c_int
WM_NCDESTROY = 130 # Variable c_int
CAL_SSHORTDATE = 5 # Variable c_int
SE_ERR_ASSOCINCOMPLETE = 27 # Variable c_int
ABM_SETAUTOHIDEBAR = 8 # Variable c_int
SBARS_SIZEGRIP = 256 # Variable c_int
RPC_C_AUTHN_MSN = 17 # Variable c_int
TVS_TRACKSELECT = 512 # Variable c_int
PSM_RESTARTWINDOWS = 1129 # Variable c_int
PAN_FAMILY_TEXT_DISPLAY = 2 # Variable c_int
CP_UTF8 = 65001 # Variable c_int
TC_SA_INTEGER = 128 # Variable c_int
AF_DATAKIT = 9 # Variable c_int
WSAEDQUOT = 10069 # Variable c_int
RPC_E_CHANGED_MODE = -2147417850 # Variable c_long
PSINJECT_DOCNEEDEDRES = 19 # Variable c_int
STARTF_RUNFULLSCREEN = 32 # Variable c_int
PAN_BENT_ARMS_HORZ = 7 # Variable c_int
SZDDESYS_ITEM_SYSITEMS = 'SysItems' # Variable POINTER(c_wchar)
KLF_SETFORPROCESS = 256 # Variable c_int
LVM_SETCOLUMNW = 4192 # Variable c_int
IMAGE_REL_PPC_NEG = 256 # Variable c_int
CBN_SELENDCANCEL = 10 # Variable c_int
ERROR_INVALID_PRINTER_STATE = 1906 # Variable c_long
WM_PSD_YAFULLPAGERECT = 1030 # Variable c_int
MIXERCONTROL_CONTROLTYPE_SINGLESELECT = 1879113728 # Variable c_long
ERROR_SETMARK_DETECTED = 1103 # Variable c_long
WM_IME_NOTIFY = 642 # Variable c_int
DEVICE_DEFAULT_FONT = 14 # Variable c_int

tagSERVERCALL = c_int # enum
SERVERCALL_ISHANDLED = 0
SERVERCALL_REJECTED = 1
SERVERCALL_RETRYLATER = 2
PGM_GETBORDER = 5127 # Variable c_int
DT_RASCAMERA = 3 # Variable c_int
SETCHARSET = 772 # Variable c_int
stc28 = 1115 # Variable c_int
DFCS_ADJUSTRECT = 8192 # Variable c_int
CDIS_GRAYED = 2 # Variable c_int
SUBLANG_SPANISH_PERU = 10 # Variable c_int
PAN_XHEIGHT_DUCKING_LARGE = 7 # Variable c_int
JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 8 # Variable c_int
OF_WRITE = 1 # Variable c_int
SB_CTL = 2 # Variable c_int
MCI_SET_DOOR_OPEN = 256 # Variable c_long
TB_GETBITMAP = 1068 # Variable c_int

_TOKEN_INFORMATION_CLASS = c_int # enum
TokenUser = 1
TokenGroups = 2
TokenPrivileges = 3
TokenOwner = 4
TokenPrimaryGroup = 5
TokenDefaultDacl = 6
TokenSource = 7
TokenType = 8
TokenImpersonationLevel = 9
TokenStatistics = 10
TokenRestrictedSids = 11
TokenSessionId = 12
REBARCLASSNAMEW = 'ReBarWindow32' # Variable POINTER(c_wchar)
ERROR_BUSY_DRIVE = 142 # Variable c_long
SOFTDIST_FLAG_USAGE_EMAIL = 1 # Variable c_int
SERVICE_CHANGE_CONFIG = 2 # Variable c_int
SE_DEBUG_NAME = 'SeDebugPrivilege' # Variable POINTER(c_wchar)
META_DIBSTRETCHBLT = 2881 # Variable c_int
PRINTER_ENUM_ICON1 = 65536 # Variable c_int
EMR_SETWORLDTRANSFORM = 35 # Variable c_int
LVN_BEGINRDRAG = 4294967185 # Variable c_uint
CAL_SABBREVMONTHNAME7 = 40 # Variable c_int
OLEIVERB_PRIMARY = 0 # Variable c_long
MIXER_GETLINEINFOF_SOURCE = 1 # Variable c_long
EMR_STRETCHDIBITS = 81 # Variable c_int
BM_GETCHECK = 240 # Variable c_int
SO_TYPE = 4104 # Variable c_int
MCI_GETDEVCAPS_CAN_RECORD = 1 # Variable c_long
PRINTER_ALL_ACCESS = 983052 # Variable c_long
DATE_USE_ALT_CALENDAR = 4 # Variable c_int
CTRY_BELIZE = 501 # Variable c_int
IMAGE_FILE_MACHINE_MIPSFPU = 870 # Variable c_int
MK_E_SYNTAX = -2147221020 # Variable c_long
HDS_HORZ = 0 # Variable c_int
OFN_ENABLETEMPLATEHANDLE = 128 # Variable c_int
LB_ERR = -1 # Variable c_int
JOY_CAL_READXONLY = 1048576 # Variable c_long
FILEOPENORD = 1536 # Variable c_int
TA_TOP = 0 # Variable c_int
IMAGE_REL_MIPS_PAIR = 37 # Variable c_int
TTM_TRACKACTIVATE = 1041 # Variable c_int
CF_PALETTE = 9 # Variable c_int
IMAGE_ROM_OPTIONAL_HDR_MAGIC = 263 # Variable c_int
ACCESS_DENIED_OBJECT_ACE_TYPE = 6 # Variable c_int
SE_OWNER_DEFAULTED = 1 # Variable c_int
TTM_GETDELAYTIME = 1045 # Variable c_int
STANDARD_RIGHTS_WRITE = 131072 # Variable c_long
RB_INSERTBANDA = 1025 # Variable c_int
TB_SAVERESTOREW = 1100 # Variable c_int
WM_INITDIALOG = 272 # Variable c_int
E_OUTOFMEMORY = -2147024882 # Variable c_long
GM_ADVANCED = 2 # Variable c_int
WM_CREATE = 1 # Variable c_int
TTDT_AUTOMATIC = 0 # Variable c_int
CO_E_INIT_SCM_MUTEX_EXISTS = -2147467250 # Variable c_long
URLPOLICY_ALLOW = 0 # Variable c_int
LC_INTERIORS = 128 # Variable c_int
TCS_BUTTONS = 256 # Variable c_int
SPI_GETSOUNDSENTRY = 64 # Variable c_int
STG_E_TOOMANYOPENFILES = -2147287036 # Variable c_long
RPC_C_MQ_RECOVERABLE = 1 # Variable c_int
RPC_C_MQ_JOURNAL_ALWAYS = 2 # Variable c_int
ENUMPAPERBINS = 31 # Variable c_int
CRYPT_E_INVALID_MSG_TYPE = -2146889724 # Variable c_long
cmb14 = 1149 # Variable c_int
SPIF_SENDWININICHANGE = 2 # Variable c_int
DUPLICATE_CLOSE_SOURCE = 1 # Variable c_int
MMSYSERR_ERROR = 1 # Variable c_int
DTN_WMKEYDOWNA = 4294966539 # Variable c_uint
IMAGE_REL_ARM_BRANCH24 = 3 # Variable c_int
CAL_SMONTHNAME10 = 30 # Variable c_int
SPLDS_PRINT_NOTIFY = 'printNotify' # Variable POINTER(c_wchar)
JOB_NOTIFY_FIELD_USER_NAME = 3 # Variable c_int
CREATE_NEW_CONSOLE = 16 # Variable c_int
CTRY_SWITZERLAND = 41 # Variable c_int
MF_GRAYED = 1 # Variable c_long
WM_NEXTDLGCTL = 40 # Variable c_int
CTRY_BELARUS = 375 # Variable c_int
MCI_ANIM_OPEN_WS = 65536 # Variable c_long
URLPOLICY_JAVA_PROHIBIT = 0 # Variable c_int
TOOLBARCLASSNAMEW = 'ToolbarWindow32' # Variable POINTER(c_wchar)
PSM_GETCURRENTPAGEHWND = 1142 # Variable c_int
IMAGE_FILE_BYTES_REVERSED_LO = 128 # Variable c_int
RPC_C_USE_INTERNET_PORT = 1 # Variable c_int

__MIDL_ICodeInstall_0001 = c_int # enum
CIP_DISK_FULL = 0
CIP_ACCESS_DENIED = 1
CIP_NEWER_VERSION_EXISTS = 2
CIP_NAME_CONFLICT = 4
CIP_TRUST_VERIFICATION_COMPONENT_MISSING = 5
CIP_EXE_SELF_REGISTERATION_TIMEOUT = 6
CIP_UNSAFE_TO_ABORT = 7
CIP_NEED_REBOOT = 8
OLE_E_NOTRUNNING = -2147221499 # Variable c_long
TKIND_COCLASS = 5
PT_MOVETO = 6 # Variable c_int
CDERR_LOCKRESFAILURE = 8 # Variable c_int
EMBDHLP_INPROC_HANDLER = 0 # Variable c_long
STATUS_INTEGER_DIVIDE_BY_ZERO = 3221225620 # Variable c_ulong
MAXGETHOSTSTRUCT = 1024 # Variable c_int
LANG_CZECH = 5 # Variable c_int
CC_PREVENTFULLOPEN = 4 # Variable c_int
IMAGE_ARCHIVE_PAD = '\n' # Variable POINTER(c_char)
SE_ERR_NOASSOC = 31 # Variable c_int
EMR_SETICMMODE = 98 # Variable c_int
IME_KHOTKEY_HANJACONVERT = 81 # Variable c_int
IMAGE_DEBUG_TYPE_OMAP_TO_SRC = 7 # Variable c_int
WC_SEPCHARS = 32 # Variable c_int
GDICOMMENT_IDENTIFIER = 1128875079 # Variable c_int
NTE_NO_MEMORY = -2146893810 # Variable c_long
DMPAPER_USER = 256 # Variable c_int
E_INVALIDARG = -2147024809 # Variable c_long
FD_OOB = 4 # Variable c_int
STG_S_CONVERTED = 197120 # Variable c_long
CRYPT_E_NO_KEY_PROPERTY = -2146885621 # Variable c_long
R2_NOTXORPEN = 10 # Variable c_int
BINDSTRING_HEADERS = 1
SE_GROUP_LOGON_ID = 3221225472 # Variable c_ulong
RPC_S_CALL_FAILED_DNE = 1727 # Variable c_long
TVN_ITEMEXPANDEDA = 4294966890 # Variable c_uint
PRINTER_NOTIFY_FIELD_LOCATION = 6 # Variable c_int
PAGE_READWRITE = 4 # Variable c_int
LVS_LIST = 3 # Variable c_int
CAL_SDAYNAME4 = 10 # Variable c_int
PD_PRINTTOFILE = 32 # Variable c_int
MAXLOGICALLOGNAMESIZE = 256 # Variable c_int
LVS_SORTASCENDING = 16 # Variable c_int
CFSTR_MIME_X_PNG = 'image/x-png' # Variable POINTER(c_wchar)
HCBT_SYSCOMMAND = 8 # Variable c_int
CDDS_ITEMPOSTPAINT = 65538 # Variable c_int
LVS_EX_TWOCLICKACTIVATE = 128 # Variable c_int
PGS_VERT = 0 # Variable c_int
KF_UP = 32768 # Variable c_int
CAL_SDAYNAME7 = 13 # Variable c_int
DATABITS_8 = 8 # Variable c_ushort
MB_HELP = 16384 # Variable c_long
IMAGE_SCN_MEM_FARDATA = 32768 # Variable c_int
NUMPRS_PARENS = 128 # Variable c_int
LVA_SNAPTOGRID = 5 # Variable c_int
EMBDHLP_DELAYCREATE = 65536 # Variable c_long
FW_BOLD = 700 # Variable c_int
WGL_SWAP_OVERLAY5 = 32 # Variable c_int
CAL_SDAYNAME6 = 12 # Variable c_int
DMPAPER_LETTER_EXTRA_TRANSVERSE = 56 # Variable c_int
TB_ENABLEBUTTON = 1025 # Variable c_int
MCI_OVLY_WHERE_SOURCE = 131072 # Variable c_long
MCI_BREAK_KEY = 256 # Variable c_long
MF_CONV = 1073741824 # Variable c_int
ERROR_NOT_AUTHENTICATED = 1244 # Variable c_long
BS_PUSHBUTTON = 0 # Variable c_long
TOKEN_EXECUTE = 131072 # Variable c_long
VIF_FILEINUSE = 128 # Variable c_long
TCN_KEYDOWN = 4294966746 # Variable c_uint
STG_E_EXTANTMARSHALLINGS = -2147286776 # Variable c_long
ERROR_DHCP_ADDRESS_CONFLICT = 4100 # Variable c_long
ICC_PROGRESS_CLASS = 32 # Variable c_int
FILE_ADD_SUBDIRECTORY = 4 # Variable c_int
SUBLANG_SPANISH_BOLIVIA = 16 # Variable c_int
RPC_S_MAX_CALLS_TOO_SMALL = 1742 # Variable c_long
SND_ALIAS_SYSTEMEXCLAMATION = 8531 # Variable c_ulong
PBM_SETRANGE = 1025 # Variable c_int
IME_REGWORD_STYLE_EUDC = 1 # Variable c_int
IMAGE_RESOURCE_DATA_IS_DIRECTORY = 2147483648 # Variable c_uint
FW_THIN = 100 # Variable c_int
TME_QUERY = 1073741824 # Variable c_int
MCIERR_UNRECOGNIZED_COMMAND = 261 # Variable c_int
EMARCH_ENC_I17_IMM9D_INST_WORD_X = 3 # Variable c_int
SB_SETTIPTEXTW = 1041 # Variable c_int
EMR_SETPALETTEENTRIES = 50 # Variable c_int
LANG_MARATHI = 78 # Variable c_int
ILC_COLOR = 0 # Variable c_int
BLACKONWHITE = 1 # Variable c_int
ERROR_CAN_NOT_COMPLETE = 1003 # Variable c_long
STG_E_DOCFILECORRUPT = -2147286775 # Variable c_long
MAXERRORLENGTH = 256 # Variable c_int
CAT_E_LAST = 2147746145 # Variable c_ulong
WC_PAGESCROLLERW = 'SysPager' # Variable POINTER(c_wchar)
edt15 = 1166 # Variable c_int
BACKUP_LINK = 5 # Variable c_int
AC_LINE_UNKNOWN = 255 # Variable c_int
PORT_STATUS_TYPE_INFO = 3 # Variable c_int
TTF_SUBCLASS = 16 # Variable c_int
COMMON_LVB_TRAILING_BYTE = 512 # Variable c_int
DDE_FREQUESTED = 4096 # Variable c_int
ERROR_INVALID_OPLOCK_PROTOCOL = 301 # Variable c_long
UDM_SETACCEL = 1131 # Variable c_int
EM_REPLACESEL = 194 # Variable c_int
TB_LOADIMAGES = 1074 # Variable c_int
DFC_MENU = 2 # Variable c_int
TVINSERTSTRUCTA_V1_SIZE = 48 # Variable c_uint
VT_CARRAY = 28
ACCESS_ALLOWED_COMPOUND_ACE_TYPE = 4 # Variable c_int
DT_EDITCONTROL = 8192 # Variable c_int
CBENF_ESCAPE = 3 # Variable c_int
INPLACE_E_LAST = 2147746223 # Variable c_ulong
JOB_OBJECT_SECURITY_NO_ADMIN = 1 # Variable c_int
MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE = 4099 # Variable c_long
TCM_SETIMAGELIST = 4867 # Variable c_int
GCPGLYPH_LINKAFTER = 16384 # Variable c_int
NOTSRCERASE = 1114278 # Variable c_ulong
IMAGE_SCN_ALIGN_4BYTES = 3145728 # Variable c_int
ESB_DISABLE_UP = 1 # Variable c_int
CERTSRV_E_BAD_REQUESTSUBJECT = -2146877439 # Variable c_long
FW_LIGHT = 300 # Variable c_int
TB_TOP = 6 # Variable c_int
EV_DSR = 16 # Variable c_int
EPT_S_CANT_PERFORM_OP = 1752 # Variable c_long
PRINTER_CHANGE_SET_PRINTER = 2 # Variable c_int
COLOR_SCROLLBAR = 0 # Variable c_int
ERROR_LOGON_SESSION_EXISTS = 1363 # Variable c_long
CCS_NOMOVEY = 2 # Variable c_long
ERROR_NO_USER_KEYS = 6006 # Variable c_long
TB_ISBUTTONHIDDEN = 1036 # Variable c_int
CTRY_TRINIDAD_Y_TOBAGO = 1 # Variable c_int
HS_DIAGCROSS = 5 # Variable c_int
RBBIM_ID = 256 # Variable c_int
STD_COPY = 1 # Variable c_int
ERROR_EXE_MACHINE_TYPE_MISMATCH = 216 # Variable c_long
PAN_LETT_NORMAL_OFF_CENTER = 7 # Variable c_int
WM_NCPAINT = 133 # Variable c_int
QS_PAINT = 32 # Variable c_int
OUT_DEFAULT_PRECIS = 0 # Variable c_int
TB_SETTOOLTIPS = 1060 # Variable c_int
MB_ABORTRETRYIGNORE = 2 # Variable c_long
JOY_BUTTON9 = 256 # Variable c_long
GDTR_MIN = 1 # Variable c_int
GL_ID_REVERSECONVERSION = 41 # Variable c_int
MH_DELETE = 3 # Variable c_int
LVS_ALIGNTOP = 0 # Variable c_int
SM_CMOUSEBUTTONS = 43 # Variable c_int
DESKTOPHORZRES = 118 # Variable c_int
ERROR_LOCAL_USER_SESSION_KEY = 1303 # Variable c_long
VFT_UNKNOWN = 0 # Variable c_long
LVHT_ONITEMSTATEICON = 8 # Variable c_int
C2_LEFTTORIGHT = 1 # Variable c_int
NI_FINALIZECONVERSIONRESULT = 20 # Variable c_int
JOB_ACCESS_ADMINISTER = 16 # Variable c_int
CRYPT_E_NOT_DECRYPTED = -2146889718 # Variable c_long
CFSEPCHAR = '+' # Variable c_char
FOF_CONFIRMMOUSE = 2 # Variable c_int
LVM_SCROLL = 4116 # Variable c_int
CDDS_PREPAINT = 1 # Variable c_int
JOB_NOTIFY_FIELD_TIME = 19 # Variable c_int
IMAGE_REL_ALPHA_GPRELHI = 23 # Variable c_int
CONVERT10_S_LAST = 262607 # Variable c_long
ERROR_INVALID_SCROLLBAR_RANGE = 1448 # Variable c_long
THREAD_BASE_PRIORITY_IDLE = -15 # Variable c_int
ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS = 1926 # Variable c_long
TB_SETHOTIMAGELIST = 1076 # Variable c_int
FACILITY_INTERNET = 12 # Variable c_int
PROCESS_DUP_HANDLE = 64 # Variable c_int
CRYPT_E_VERIFY_USAGE_OFFLINE = -2146885591 # Variable c_long
TIME_ZONE_ID_INVALID = 4294967295 # Variable c_ulong
URLPOLICY_CHANNEL_SOFTDIST_PRECACHE = 131072 # Variable c_int
VT_BSTR_BLOB = 4095
MCI_ANIM_PLAY_SPEED = 65536 # Variable c_long
GCPCLASS_PREBOUNDLTR = 128 # Variable c_int
MSGF_COMMCTRL_SIZEHEADER = 16897 # Variable c_int
MCN_SELECT = 4294966550 # Variable c_uint
CRYPT_E_STREAM_INSUFFICIENT_DATA = -2146889711 # Variable c_long
TB_INSERTBUTTONA = 1045 # Variable c_int
PGF_DEPRESSED = 4 # Variable c_int
NCBTRACE = 121 # Variable c_int
WAIT_ABANDONED_0 = 128 # Variable c_ulong
VAR_CALENDAR_HIJRI = 8 # Variable c_ulong
DMPAPER_RESERVED_48 = 48 # Variable c_int
OF_PROMPT = 8192 # Variable c_int
MCIERR_SEQ_PORT_MAPNODEVICE = 339 # Variable c_int
CRYPT_E_FILERESIZED = -2146885595 # Variable c_long
RDW_NOERASE = 32 # Variable c_int
MIXERCONTROL_CT_UNITS_PERCENT = 327680 # Variable c_long
TB_GETHOTIMAGELIST = 1077 # Variable c_int
SPAPI_E_BAD_SERVICE_INSTALLSECT = -2146500073 # Variable c_long
RPC_S_UNKNOWN_MGR_TYPE = 1716 # Variable c_long
TAPE_UNLOAD = 1 # Variable c_long
ERROR_INVALID_EDIT_HEIGHT = 1424 # Variable c_long
TCM_SETITEMEXTRA = 4878 # Variable c_int
IME_HOTKEY_DSWITCH_LAST = 287 # Variable c_int
MFS_GRAYED = 3 # Variable c_long
CONNECT_NEED_DRIVE = 32 # Variable c_int
CAL_SCALNAME = 2 # Variable c_int
ERROR_UNKNOWN_COMPONENT = 1607 # Variable c_long
PIDSI_REVNUMBER = 9 # Variable c_long
EM_GETMARGINS = 212 # Variable c_int
MF_RIGHTJUSTIFY = 16384 # Variable c_long
NUMPRS_EXPONENT = 2048 # Variable c_int
SB_GETTEXTW = 1037 # Variable c_int
SERVICE_QUERY_CONFIG = 1 # Variable c_int
psh5 = 1028 # Variable c_int
DRV_POWER = 15 # Variable c_int
ERROR_EA_LIST_INCONSISTENT = 255 # Variable c_long
INET_E_USE_DEFAULT_SETTING = -2146697198 # Variable c_long
TB_GETBUTTONSIZE = 1082 # Variable c_int
ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = 1809 # Variable c_long
ExeNamePath = 0
MCI_OVLY_PUT_DESTINATION = 262144 # Variable c_long
GCL_CBCLSEXTRA = -20 # Variable c_int
RPC_C_OPT_MQ_AUTHN_LEVEL = 6 # Variable c_int
TAPE_DRIVE_LOGICAL_BLK = 2147500032 # Variable c_uint
PBT_APMQUERYSUSPEND = 0 # Variable c_int
SP_ERROR = -1 # Variable c_int
PRINTER_CHANGE_ALL = 2004353023 # Variable c_int
SM_SHOWSOUNDS = 70 # Variable c_int
ERROR_INSTALL_USEREXIT = 1602 # Variable c_long
PRINTER_CONTROL_SET_STATUS = 4 # Variable c_int
TCIF_PARAM = 8 # Variable c_int
SPAPI_E_INVALID_HWPROFILE = -2146500080 # Variable c_long
ERROR_REVISION_MISMATCH = 1306 # Variable c_long
ERROR_OBJECT_ALREADY_EXISTS = 5010 # Variable c_long
MMSYSERR_BADDB = 14 # Variable c_int
STATUS_WAIT_0 = 0 # Variable c_ulong
SPLREG_SCHEDULER_THREAD_PRIORITY_DEFAULT = 'SchedulerThreadPriorityDefault' # Variable POINTER(c_wchar)
TBN_CUSTHELP = 4294966587 # Variable c_uint
SM_CYCURSOR = 14 # Variable c_int
RT_RCDATA = 16 # Variable POINTER(c_wchar)
MM_MIM_LONGDATA = 964 # Variable c_int
TBS_FIXEDLENGTH = 64 # Variable c_int
E_POINTER = -2147467261 # Variable c_long
WMSZ_TOPRIGHT = 5 # Variable c_int
ERROR_INVALID_MONITOR_HANDLE = 1461 # Variable c_long
JOY_BUTTON4 = 8 # Variable c_int
RPC_C_AUTHZ_NAME = 1 # Variable c_int
PS_JOIN_MITER = 8192 # Variable c_int
HEAP_DISABLE_COALESCE_ON_FREE = 128 # Variable c_int
TBN_GETDISPINFOW = 4294966579 # Variable c_uint
TYPE_E_IOERROR = -2147316574 # Variable c_long
FINDMSGSTRINGW = 'commdlg_FindReplace' # Variable POINTER(c_wchar)
DMPAPER_ENV_11 = 21 # Variable c_int
MCI_ANIM_GETDEVCAPS_CAN_STRETCH = 16391 # Variable c_long
OLE_E_ADVF = -2147221503 # Variable c_long
JOB_OBJECT_UILIMIT_READCLIPBOARD = 2 # Variable c_int
PD_ENABLEPRINTTEMPLATEHANDLE = 65536 # Variable c_int
VARFLAG_FBINDABLE = 4
SERVICE_CONTROL_NETBINDADD = 7 # Variable c_int
CTRY_GERMANY = 49 # Variable c_int
LANG_BULGARIAN = 2 # Variable c_int
XST_INIT2 = 4 # Variable c_int
SM_CYICONSPACING = 39 # Variable c_int
OF_SHARE_DENY_NONE = 64 # Variable c_int
ERROR_LOGIN_TIME_RESTRICTION = 1239 # Variable c_long
BACKGROUND_RED = 64 # Variable c_int
ERROR_INVALID_PRIMARY_GROUP = 1308 # Variable c_long
SUBLANG_GERMAN_LIECHTENSTEIN = 5 # Variable c_int
URLACTION_AUTHENTICATE_CLIENT = 6657 # Variable c_int
IMAGE_SYM_TYPE_ENUM = 10 # Variable c_int
MCI_WAVE_PCM = 1152 # Variable c_int
ERROR_WMI_GUID_NOT_FOUND = 4200 # Variable c_long
TVM_SETINDENT = 4359 # Variable c_int
LOCALE_SGROUPING = 16 # Variable c_int
SCS_POSIX_BINARY = 4 # Variable c_int
CB_SETITEMDATA = 337 # Variable c_int
CAL_SMONTHNAME5 = 25 # Variable c_int
REG_NOTIFY_CHANGE_NAME = 1 # Variable c_long
META_SELECTCLIPREGION = 300 # Variable c_int
CERT_E_ROLE = -2146762493 # Variable c_long
stc29 = 1116 # Variable c_int
RESOURCEUSAGE_SIBLING = 8 # Variable c_int
chx6 = 1045 # Variable c_int
ERROR_IO_PENDING = 997 # Variable c_long
TTM_ENUMTOOLSW = 1082 # Variable c_int
DESKTOP_WRITEOBJECTS = 128 # Variable c_long
MCI_INFO_COPYRIGHT = 8192 # Variable c_long
PSINJECT_EOF = 15 # Variable c_int
PROCESSOR_INTEL_386 = 386 # Variable c_int
TLS_MINIMUM_AVAILABLE = 64 # Variable c_int
JOY_RETURNBUTTONS = 128 # Variable c_long
LVS_ALIGNMASK = 3072 # Variable c_int
IMAGE_REL_SH3_DIRECT32 = 2 # Variable c_int
WM_GETFONT = 49 # Variable c_int
CO_E_SETSERLHNDLFAILED = -2147220976 # Variable c_long
SE_SELF_RELATIVE = 32768 # Variable c_int
PERF_DISPLAY_SECONDS = 805306368 # Variable c_int
FO_RENAME = 4 # Variable c_int
CAL_SABBREVMONTHNAME6 = 39 # Variable c_int
JOB_NOTIFY_FIELD_STATUS_STRING = 11 # Variable c_int
META_OFFSETCLIPRGN = 544 # Variable c_int
ERROR_NO_RECOVERY_PROGRAM = 1082 # Variable c_long
EV_CTS = 8 # Variable c_int
CBF_FAIL_REQUESTS = 131072 # Variable c_int
SPAPI_E_DI_DONT_INSTALL = -2146500053 # Variable c_long
BINDSTRING_LANGUAGE = 4
MIXERCONTROL_CT_SC_METER_POLLED = 0 # Variable c_long
MCHT_NOWHERE = 0 # Variable c_int
TCM_SETMINTABWIDTH = 4913 # Variable c_int
CFSTR_MIME_X_BITMAP = 'image/x-xbitmap' # Variable POINTER(c_wchar)
VAR_PERINSTANCE = 0
PO_PORTCHANGE = 32 # Variable c_int
HDM_GETITEMRECT = 4615 # Variable c_int
IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR = 60 # Variable c_int
REG_OPTION_OPEN_LINK = 8 # Variable c_long
ERROR_INVALID_MESSAGENAME = 1217 # Variable c_long
WM_COMMNOTIFY = 68 # Variable c_int
PERF_DETAIL_EXPERT = 300 # Variable c_int
REBARBANDINFOW_V3_SIZE = 56 # Variable c_uint
PARITY_SPACE = 4096 # Variable c_ushort
TTM_SETTIPTEXTCOLOR = 1044 # Variable c_int
SO_MAXDG = 28681 # Variable c_int
PROCESSOR_SHx_SH3 = 103 # Variable c_int
LVM_GETVIEWRECT = 4130 # Variable c_int
WC_DEFAULTCHAR = 64 # Variable c_int
MMSYSERR_BADDEVICEID = 2 # Variable c_int
ERROR_CANTOPEN = 1011 # Variable c_long
CO_E_NOMATCHINGNAMEFOUND = -2147220978 # Variable c_long
PRINTER_CHANGE_DELETE_FORM = 262144 # Variable c_int
PSINJECT_DOCSUPPLIEDRES = 20 # Variable c_int
ERROR_LICENSE_QUOTA_EXCEEDED = 1395 # Variable c_long
NAME_FLAGS_MASK = 135 # Variable c_int
SPI_GETDEFAULTINPUTLANG = 89 # Variable c_int
SPI_SETKEYBOARDDELAY = 23 # Variable c_int
HEAP_REALLOC_IN_PLACE_ONLY = 16 # Variable c_int
JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0 # Variable c_int
PAN_PROPORTION_INDEX = 3 # Variable c_int
PCF_RTSCTS = 2 # Variable c_ulong
CBEN_FIRST = 4294966496 # Variable c_uint
SUBLANG_FRENCH_SWISS = 4 # Variable c_int
LB_SETCOUNT = 423 # Variable c_int
TBSTYLE_CHECK = 2 # Variable c_int
DMCOLOR_MONOCHROME = 1 # Variable c_int
ERROR_REDIR_PAUSED = 72 # Variable c_long
BST_FOCUS = 8 # Variable c_int
WC_DIALOG = 206704 # Variable POINTER(c_wchar)
IME_ITHOTKEY_RESEND_RESULTSTR = 512 # Variable c_int
JobObjectEndOfJobTimeInformation = 6
MSGF_MENU = 2 # Variable c_int
ATTR_INPUT_ERROR = 4 # Variable c_int
MCI_OVLY_WHERE_FRAME = 524288 # Variable c_long
DM_FORMNAME = 65536 # Variable c_long
RPC_E_SERVER_CANTMARSHAL_DATA = -2147418099 # Variable c_long
WS_EX_RIGHTSCROLLBAR = 0 # Variable c_long
MMIO_FINDPROC = 262144 # Variable c_int
WINDOW_BUFFER_SIZE_EVENT = 4 # Variable c_int
FR_SHOWHELP = 128 # Variable c_int
LCS_sRGB = 1934772034 # Variable c_int
MCI_TRACK = 16 # Variable c_long
HTNOWHERE = 0 # Variable c_int
BINDSTRING_UA_COLOR = 8
CB_SETHORIZONTALEXTENT = 350 # Variable c_int
SECURITY_DYNAMIC_TRACKING = 1 # Variable c_int
DIGSIG_E_CRYPTO = -2146762744 # Variable c_long
ES_NOHIDESEL = 256 # Variable c_long
GCP_KASHIDA = 1024 # Variable c_int
GETCOLORTABLE = 5 # Variable c_int
WS_CLIPSIBLINGS = 67108864 # Variable c_long
SPI_SETLANGTOGGLE = 91 # Variable c_int
R2_COPYPEN = 13 # Variable c_int
DISPLAY_DEVICE_PRIMARY_DEVICE = 4 # Variable c_int
WS_TABSTOP = 65536 # Variable c_long
TKIND_ALIAS = 6
IDABORT = 3 # Variable c_int
GDICOMMENT_WINDOWS_METAFILE = 2147483649 # Variable c_uint
WHITENESS = 16711778 # Variable c_ulong
PROCESSOR_ARCHITECTURE_IA64 = 6 # Variable c_int
SBS_HORZ = 0 # Variable c_long
GDICOMMENT_MULTIFORMATS = 1073741828 # Variable c_int
IME_THOTKEY_IME_NONIME_TOGGLE = 112 # Variable c_int
DS_3DLOOK = 4 # Variable c_long
DCBA_FACEDOWNCENTER = 257 # Variable c_int
SZDDESYS_ITEM_HELP = 'Help' # Variable POINTER(c_wchar)
ACTFLG_Assigned = 16 # Variable c_int
IMC_GETCANDIDATEPOS = 7 # Variable c_int
IMAGE_REL_ALPHA_SECTION = 14 # Variable c_int
ENUM_ALL_CALENDARS = 4294967295 # Variable c_uint
RPC_E_OUT_OF_RESOURCES = -2147417855 # Variable c_long
TTM_ACTIVATE = 1025 # Variable c_int
PORT_STATUS_PAPER_OUT = 3 # Variable c_int
TRUST_E_ACTION_UNKNOWN = -2146762750 # Variable c_long
SERVICE_ERROR_IGNORE = 0 # Variable c_int
EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X = 13 # Variable c_int
PCF_PARITY_CHECK = 8 # Variable c_ulong
DOMAIN_ALIAS_RID_GUESTS = 546 # Variable c_long
TBS_LEFT = 4 # Variable c_int
MCIERR_BAD_INTEGER = 270 # Variable c_int
PIPE_READMODE_MESSAGE = 2 # Variable c_int
URLPOLICY_MASK_PERMISSIONS = 15 # Variable c_int
LVIF_DI_SETITEM = 4096 # Variable c_int
DACL_SECURITY_INFORMATION = 4 # Variable c_long
RBBIM_COLORS = 2 # Variable c_int
DS_NOFAILCREATE = 16 # Variable c_long
PD_RETURNDEFAULT = 1024 # Variable c_int
ERROR_UNKNOWN_PORT = 1796 # Variable c_long
OFN_ALLOWMULTISELECT = 512 # Variable c_int
PRINTER_CHANGE_TIMEOUT = 2147483648 # Variable c_uint
STOPBITS_20 = 4 # Variable c_ushort
BS_DIBPATTERNPT = 6 # Variable c_int
CE_MODE = 32768 # Variable c_int
PRINTER_NOTIFY_FIELD_PAGES_PRINTED = 23 # Variable c_int
RBBS_CHILDEDGE = 4 # Variable c_int
ERROR_BAD_DEV_TYPE = 66 # Variable c_long
SM_RESERVED1 = 24 # Variable c_int
SERVICE_INTERACTIVE_PROCESS = 256 # Variable c_int
FACILITY_RPC = 1 # Variable c_int
KEY_CREATE_SUB_KEY = 4 # Variable c_int
TVGN_LASTVISIBLE = 10 # Variable c_int
SPLDS_DRIVER_KEY = 'DsDriver' # Variable POINTER(c_wchar)
GENERIC_EXECUTE = 536870912 # Variable c_long
TBM_GETTHUMBRECT = 1049 # Variable c_int
WM_NCRBUTTONDOWN = 164 # Variable c_int
ODA_SELECT = 2 # Variable c_int
PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 131072 # Variable c_int
ERROR_NO_SUCH_DOMAIN = 1355 # Variable c_long
IDH_CANCEL = 28444 # Variable c_int
GETEXTENTTABLE = 257 # Variable c_int
MCM_SETRANGE = 4114 # Variable c_int
VK_UP = 38 # Variable c_int
RPC_S_STRING_TOO_LONG = 1743 # Variable c_long
TT_PRIM_LINE = 1 # Variable c_int
MCI_FORMAT_HMS = 1 # Variable c_int
CALLBACK_EVENT = 327680 # Variable c_long
ERROR_SEM_IS_SET = 102 # Variable c_long
LCMAP_LINGUISTIC_CASING = 16777216 # Variable c_int
AF_LAT = 14 # Variable c_int
IMPLTYPEFLAG_FDEFAULT = 1 # Variable c_int
NRC_NAMCONF = 25 # Variable c_int
IMC_SETCOMPOSITIONFONT = 10 # Variable c_int
ERROR_CANNOT_FIND_WND_CLASS = 1407 # Variable c_long
CS_E_NOT_DELETABLE = -2147221147 # Variable c_long
IN_CLASSB_HOST = 65535 # Variable c_int
TCS_HOTTRACK = 64 # Variable c_int
MCIERR_WAVE_SETOUTPUTUNSUITABLE = 327 # Variable c_int
ERROR_ACTIVE_CONNECTIONS = 2402 # Variable c_long
CREATE_UNICODE_ENVIRONMENT = 1024 # Variable c_int
TCN_GETOBJECT = 4294966743 # Variable c_uint
BS_BITMAP = 128 # Variable c_long
REGDB_S_LAST = 262495 # Variable c_long
LBS_USETABSTOPS = 128 # Variable c_long
NTE_SYS_ERR = -2146893791 # Variable c_long
CF_NOVECTORFONTS = 2048 # Variable c_long
MCS_NOTODAY = 16 # Variable c_int
N_TSHIFT = 2 # Variable c_int
TRUST_E_SYSTEM_ERROR = -2146869247 # Variable c_long
AC_SRC_NO_ALPHA = 2 # Variable c_int
HELP_CONTEXTMENU = 10 # Variable c_int
VK_NUMPAD4 = 100 # Variable c_int
edt16 = 1167 # Variable c_int
RPC_E_CLIENT_CANTMARSHAL_DATA = -2147418101 # Variable c_long
DRV_INSTALL = 9 # Variable c_int
IMAGE_FILE_32BIT_MACHINE = 256 # Variable c_int
MSGF_DDEMGR = 32769 # Variable c_int
IMAGE_SYM_DTYPE_ARRAY = 3 # Variable c_int
MCI_OVLY_WHERE_VIDEO = 1048576 # Variable c_long
TAPE_DRIVE_WRITE_PROTECT = 4096 # Variable c_int
PORT_STATUS_DOOR_OPEN = 7 # Variable c_int
FOREGROUND_GREEN = 2 # Variable c_int
ERROR_RETRY = 1237 # Variable c_long
CRYPT_E_NO_REVOCATION_DLL = -2146885615 # Variable c_long
ACCESS_MAX_MS_ACE_TYPE = 8 # Variable c_int
VT_USERDEFINED = 29
SKF_HOTKEYACTIVE = 4 # Variable c_int
MIXERCONTROL_CONTROLF_MULTIPLE = 2 # Variable c_long
DMPAPER_ENV_B5 = 34 # Variable c_int
MSG_PARTIAL = 32768 # Variable c_int
CO_E_FAILEDTOQUERYCLIENTBLANKET = -2147220987 # Variable c_long
STGFMT_DOCFILE = 5 # Variable c_int
INPLACE_E_FIRST = 2147746208 # Variable c_ulong
GCS_RESULTREADCLAUSE = 1024 # Variable c_int
TAPE_SPACE_SEQUENTIAL_FMKS = 7 # Variable c_long
TVM_SORTCHILDREN = 4371 # Variable c_int
TYPE_E_CIRCULARTYPE = -2147312508 # Variable c_long
WM_CHILDACTIVATE = 34 # Variable c_int
RB_GETTEXTCOLOR = 1046 # Variable c_int
HDN_ITEMCLICKA = 4294966994 # Variable c_uint
MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE = 4102 # Variable c_long
TBNF_DI_SETITEM = 268435456 # Variable c_int
SEC_RESERVE = 67108864 # Variable c_int
DMBIN_SMALLFMT = 9 # Variable c_int
URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT = 65536 # Variable c_int
WM_MDITILE = 550 # Variable c_int
psh6 = 1029 # Variable c_int
CTRY_SERBIA = 381 # Variable c_int
JOY_BUTTON16 = 32768 # Variable c_long
OEM_FIXED_FONT = 10 # Variable c_int
CPS_REVERT = 3 # Variable c_int
PGN_FIRST = 4294966396 # Variable c_uint
DT_TABSTOP = 128 # Variable c_int
ERROR_EOM_OVERFLOW = 1129 # Variable c_long
MINCHAR = 128 # Variable c_int
CCERR_CHOOSECOLORCODES = 20480 # Variable c_int
JOB_OBJECT_LIMIT_JOB_TIME = 4 # Variable c_int
ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063 # Variable c_long
TVS_SHOWSELALWAYS = 32 # Variable c_int
FS_BALTIC = 128 # Variable c_long
DCX_EXCLUDERGN = 64 # Variable c_long
SUBLANG_ITALIAN = 1 # Variable c_int
CAL_GREGORIAN_ARABIC = 10 # Variable c_int
DRIVE_REMOVABLE = 2 # Variable c_int
HKEY_CURRENT_USER = 2147483649 # Variable POINTER(HKEY__)
SSWF_WINDOW = 2 # Variable c_int
MCI_ANIM_OPEN_PARENT = 131072 # Variable c_long
PIPE_READMODE_BYTE = 0 # Variable c_int
IDC_SIZEWE = 206404 # Variable POINTER(c_wchar)
IMAGE_REL_PPC_ADDR32 = 2 # Variable c_int
XTYP_CONNECT = 4194 # Variable c_int
IE_NOPEN = -3 # Variable c_int
PF_AMD3D_INSTRUCTIONS_AVAILABLE = 7 # Variable c_int
TAPE_SPACE_SEQUENTIAL_SMKS = 9 # Variable c_long
LVM_GETITEMTEXTA = 4141 # Variable c_int
CTRY_PORTUGAL = 351 # Variable c_int
META_OFFSETWINDOWORG = 527 # Variable c_int
SERVICE_STOP_PENDING = 3 # Variable c_int
SB_GETTIPTEXTW = 1043 # Variable c_int
SUBLANG_ARABIC_EGYPT = 3 # Variable c_int
TRUST_E_CERT_SIGNATURE = -2146869244 # Variable c_long
DMPAPER_ENV_DL = 27 # Variable c_int
RPC_C_AUTHN_LEVEL_CONNECT = 2 # Variable c_int
EM_SETMODIFY = 185 # Variable c_int
CB_SHOWDROPDOWN = 335 # Variable c_int
SRCCOPY = 13369376 # Variable c_ulong
SERVICE_CONTROL_NETBINDENABLE = 9 # Variable c_int
STATUS_FLOAT_MULTIPLE_FAULTS = 3221226164 # Variable c_ulong
CAL_SABBREVMONTHNAME10 = 43 # Variable c_int
LVN_SETDISPINFOA = 4294967145 # Variable c_uint
WSADESCRIPTION_LEN = 256 # Variable c_int
DTN_FIRST = 4294966536 # Variable c_uint
ENABLE_WINDOW_INPUT = 8 # Variable c_int
WSAENOPROTOOPT = 10042 # Variable c_int
MK_S_US = 262630 # Variable c_long
HCF_HOTKEYAVAILABLE = 64 # Variable c_int
TCS_SINGLELINE = 0 # Variable c_int
TAPE_DRIVE_HIGH_FEATURES = 2147483648 # Variable c_uint
HDN_ITEMCHANGINGW = 4294966976 # Variable c_uint
IMAGE_REL_SH3_PCREL8_LONG = 10 # Variable c_int
DM_PRINTQUALITY = 1024 # Variable c_long
MOUSEEVENTF_RIGHTDOWN = 8 # Variable c_int
DFCS_SCROLLUP = 0 # Variable c_int
ERROR_NOT_QUORUM_CAPABLE = 5021 # Variable c_long
MCIERR_FILENAME_REQUIRED = 304 # Variable c_int
IDLFLAG_FOUT = 2 # Variable c_int
S_SERMACT = -3 # Variable c_int
SUBLANG_SERBIAN_LATIN = 2 # Variable c_int
SO_OPENTYPE = 28680 # Variable c_int
RPC_BUFFER_ASYNC = 32768 # Variable c_int
ICM_REGISTERICMATCHER = 5 # Variable c_int
SO_CONNDATALEN = 28676 # Variable c_int
MIXER_GETCONTROLDETAILSF_LISTTEXT = 1 # Variable c_long
UPDOWN_CLASSW = 'msctls_updown32' # Variable POINTER(c_wchar)
DIGSIG_E_EXTENSIBILITY = -2146762745 # Variable c_long
CS_DELETE_TRANSFORM = 3 # Variable c_long
CC_WIDE = 16 # Variable c_int
MIDIERR_BADOPENMODE = 70 # Variable c_int
IMAGE_SYM_UNDEFINED = 0 # Variable c_short
PFD_NEED_PALETTE = 128 # Variable c_int
TIME_CALLBACK_EVENT_SET = 16 # Variable c_int
LANG_HINDI = 57 # Variable c_int
LOCALE_SMONTHNAME12 = 67 # Variable c_int
DOMAIN_GROUP_RID_COMPUTERS = 515 # Variable c_long
ERROR_FILE_NOT_ENCRYPTED = 6007 # Variable c_long
HDF_BITMAP = 8192 # Variable c_int
IMAGE_SCN_MEM_DISCARDABLE = 33554432 # Variable c_int
TTM_ADDTOOLA = 1028 # Variable c_int
CO_E_FAILEDTOIMPERSONATE = -2147220992 # Variable c_long
ACCESS_MAX_MS_V2_ACE_TYPE = 3 # Variable c_int
MCI_ANIM_WINDOW_HWND = 65536 # Variable c_long
NULL = 0 # Variable c_int
BS_GROUPBOX = 7 # Variable c_long
DMLERR_DLL_USAGE = 16388 # Variable c_int
TVN_SELCHANGEDW = 4294966845 # Variable c_uint
PGM_GETPOS = 5129 # Variable c_int
EMR_MAX = 104 # Variable c_int
RPC_S_UNSUPPORTED_AUTHN_LEVEL = 1821 # Variable c_long
DllNamePath = 1
TT_AVAILABLE = 1 # Variable c_int
EWX_REBOOT = 2 # Variable c_int
SM_ARRANGE = 56 # Variable c_int
ERROR_NO_USER_SESSION_KEY = 1394 # Variable c_long
PAN_NO_FIT = 1 # Variable c_int
DM_SCALE = 16 # Variable c_long
SPI_ICONHORIZONTALSPACING = 13 # Variable c_int
DM_PANNINGWIDTH = 134217728 # Variable c_long
EM_LINEFROMCHAR = 201 # Variable c_int
WDT_REMOTE_CALL = 1383359575 # Variable c_int
SE_PRIVILEGE_USED_FOR_ACCESS = 2147483648 # Variable c_ulong
RBNM_LPARAM = 4 # Variable c_int
STG_E_NOTCURRENT = -2147286783 # Variable c_long
SUBLANG_DEFAULT = 1 # Variable c_int
NTE_PROV_TYPE_NOT_DEF = -2146893801 # Variable c_long
LC_POLYMARKER = 8 # Variable c_int
SE_INCREASE_QUOTA_NAME = 'SeIncreaseQuotaPrivilege' # Variable POINTER(c_wchar)
GENERIC_WRITE = 1073741824 # Variable c_long
FOF_NOCOPYSECURITYATTRIBS = 2048 # Variable c_int
PRINTER_WRITE = 131080 # Variable c_long
BAUD_134_5 = 4 # Variable c_ulong
ERROR_UNKNOWN_PRINTPROCESSOR = 1798 # Variable c_long
CTLCOLOR_DLG = 4 # Variable c_int
GCP_NEUTRALOVERRIDE = 33554432 # Variable c_long
MDM_COMPRESSION = 1 # Variable c_int
NUMPRS_DECIMAL = 256 # Variable c_int
chx2 = 1041 # Variable c_int
MIXERCONTROL_CONTROLTYPE_BUTTON = 553713664 # Variable c_long
CLRDTR = 6 # Variable c_int

_AUDIT_EVENT_TYPE = c_int # enum
AuditEventObjectAccess = 0
AuditEventDirectoryServiceAccess = 1
DMRES_DRAFT = -1 # Variable c_int
CO_S_NOTALLINTERFACES = 524306 # Variable c_long
MCI_SEQ_DIV_SMPTE_25 = 1218 # Variable c_int
IMAGE_REL_BASED_LOW = 2 # Variable c_int
WC_DISCARDNS = 16 # Variable c_int
WM_PRINTCLIENT = 792 # Variable c_int
LVSIL_STATE = 2 # Variable c_int
CF_PRIVATEFIRST = 512 # Variable c_int
STG_E_WRITEFAULT = -2147287011 # Variable c_long
ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = 1435 # Variable c_long
MIXERCONTROL_CONTROLTYPE_MONO = 536936451 # Variable c_long
ICC_LISTVIEW_CLASSES = 1 # Variable c_int
ERROR_TOO_MANY_SEM_REQUESTS = 103 # Variable c_long
IMAGE_FILE_MACHINE_THUMB = 450 # Variable c_int
FALSE = 0 # Variable c_int
PAN_CONTRAST_MEDIUM_HIGH = 7 # Variable c_int
S_SERDSR = -15 # Variable c_int
HHT_ONDIVIDER = 4 # Variable c_int
PRINTER_CONTROL_RESUME = 2 # Variable c_int
PROCESS_ALL_ACCESS = 2035711 # Variable c_long
VK_HOME = 36 # Variable c_int
ICC_ANIMATE_CLASS = 128 # Variable c_int
EMARCH_ENC_I17_IMM41a_VAL_POS_X = 22 # Variable c_int
AF_NETBIOS = 17 # Variable c_int
STATUS_INVALID_DISPOSITION = 3221225510 # Variable c_ulong
ERROR_PROCESS_ABORTED = 1067 # Variable c_long
TBM_SETRANGEMAX = 1032 # Variable c_int
SSTF_CHARS = 1 # Variable c_int
WM_PAINTICON = 38 # Variable c_int
MCI_INFO_PRODUCT = 256 # Variable c_long
CLSCTX_SERVER = 5 # Variable c_int
LOCALE_NOUSEROVERRIDE = 2147483648 # Variable c_uint
URLACTION_DOWNLOAD_SIGNED_ACTIVEX = 4097 # Variable c_int
S_SERDPT = -12 # Variable c_int
DTS_APPCANPARSE = 16 # Variable c_int
CDERR_NOHOOK = 11 # Variable c_int
PARAMFLAG_FHASDEFAULT = 32 # Variable c_int
DISPLAY_DEVICE_MIRRORING_DRIVER = 8 # Variable c_int
JOB_NOTIFY_FIELD_POSITION = 15 # Variable c_int
STD_ERROR_HANDLE = 4294967284 # Variable c_ulong
DMPAPER_9X11 = 44 # Variable c_int
CLIPCAPS = 36 # Variable c_int
CRYPT_E_RECIPIENT_NOT_FOUND = -2146889717 # Variable c_long
MM_JOY1ZMOVE = 930 # Variable c_int
FNERR_FILENAMECODES = 12288 # Variable c_int
NLS_DBCSCHAR = 65536 # Variable c_int
TBSTATE_CHECKED = 1 # Variable c_int
PC_NONE = 0 # Variable c_int
WSANOTINITIALISED = 10093 # Variable c_int
FORMAT_MESSAGE_ALLOCATE_BUFFER = 256 # Variable c_int
TVINSERTSTRUCTW_V1_SIZE = 48 # Variable c_uint
SPI_GETMENUDROPALIGNMENT = 27 # Variable c_int
SUBLANG_AZERI_LATIN = 1 # Variable c_int
PRINTER_ENUM_CONNECTIONS = 4 # Variable c_int
VAR_STATIC = 1
PRINTER_NOTIFY_FIELD_TOTAL_BYTES = 24 # Variable c_int
TVE_COLLAPSERESET = 32768 # Variable c_int
META_CREATEREGION = 1791 # Variable c_int
LOCALE_SMONTHNAME8 = 63 # Variable c_int
MIXER_GETLINECONTROLSF_ONEBYID = 1 # Variable c_long
HTLEFT = 10 # Variable c_int
MCM_HITTEST = 4110 # Variable c_int
EVENTLOG_BACKWARDS_READ = 8 # Variable c_int
RBS_VARHEIGHT = 512 # Variable c_int
TTM_GETTOOLINFOW = 1077 # Variable c_int
MMIOERR_NETWORKERROR = 270 # Variable c_int
TOKEN_ALL_ACCESS = 983551 # Variable c_long
LOCALE_SABBREVDAYNAME7 = 55 # Variable c_int
ERROR_NO_TRACKING_SERVICE = 1172 # Variable c_long
TB_LINEUP = 0 # Variable c_int
BAUD_38400 = 16384 # Variable c_ulong
VFF_FILEINUSE = 2 # Variable c_int
UPDFCACHE_IFBLANKORONSAVECACHE = 18 # Variable c_int
LVM_GETTOOLTIPS = 4174 # Variable c_int
ERROR_LOCKED = 212 # Variable c_long
IMAGE_REL_IA64_IMM22 = 2 # Variable c_int
IMAGE_SCN_LNK_INFO = 512 # Variable c_int
DTN_USERSTRINGA = 4294966538 # Variable c_uint
DV_E_CLIPFORMAT = -2147221398 # Variable c_long
SHERB_NOCONFIRMATION = 1 # Variable c_int
SERVICE_DEMAND_START = 3 # Variable c_int
ERROR_RESOURCE_NOT_FOUND = 5007 # Variable c_long
SYSTEM_ALARM_OBJECT_ACE_TYPE = 8 # Variable c_int
LOCALE_IDEFAULTCODEPAGE = 11 # Variable c_int
PHYSICALWIDTH = 110 # Variable c_int
DMPAPER_ENV_C5 = 28 # Variable c_int
RPC_E_SERVERCALL_RETRYLATER = -2147417846 # Variable c_long
SM_CXCURSOR = 13 # Variable c_int
CDERR_NOTEMPLATE = 3 # Variable c_int
COLOR_BTNFACE = 15 # Variable c_int
VFT_DRV = 3 # Variable c_long
VK_SPACE = 32 # Variable c_int
PERF_TYPE_NUMBER = 0 # Variable c_int
ERROR_EA_TABLE_FULL = 277 # Variable c_long
LANG_MALAYALAM = 76 # Variable c_int
WM_MOUSEFIRST = 512 # Variable c_int
RB_SETBARINFO = 1028 # Variable c_int
RPC_S_INCOMPLETE_NAME = 1755 # Variable c_long
IMC_SETCANDIDATEPOS = 8 # Variable c_int
STATUS_INTEGER_OVERFLOW = 3221225621 # Variable c_ulong
STG_E_FILENOTFOUND = -2147287038 # Variable c_long
HDM_ORDERTOINDEX = 4623 # Variable c_int
GL_ID_READINGCONFLICT = 35 # Variable c_int
JOB_NOTIFY_TYPE = 1 # Variable c_int
MCIERR_DUPLICATE_ALIAS = 289 # Variable c_int
PGM_SETPOS = 5128 # Variable c_int
EMR_EXTFLOODFILL = 53 # Variable c_int

tagSTREAM_SEEK = c_int # enum
STREAM_SEEK_SET = 0
STREAM_SEEK_CUR = 1
STREAM_SEEK_END = 2
RPC_S_ALREADY_REGISTERED = 1711 # Variable c_long
MCI_VD_ESCAPE_STRING = 256 # Variable c_long
ENDDOC = 11 # Variable c_int
VTBIT_UI1 = 131072 # Variable c_int
SEC_WINNT_AUTH_IDENTITY_UNICODE = 2 # Variable c_int
TVM_ENDEDITLABELNOW = 4374 # Variable c_int
WM_RBUTTONUP = 517 # Variable c_int
SC_SCREENSAVE = 61760 # Variable c_int
E_HANDLE = -2147024890 # Variable c_long
TB_SETBUTTONINFOA = 1090 # Variable c_int
WM_SETTEXT = 12 # Variable c_int
RPC_S_CALLPENDING = -2147417835 # Variable c_long
INET_E_SECURITY_PROBLEM = -2146697202 # Variable c_long
ERROR_REGISTRY_IO_FAILED = 1016 # Variable c_long
TYPE_E_QUALIFIEDNAMEDISALLOWED = -2147319768 # Variable c_long
ERROR_ICM_NOT_ENABLED = 2308 # Variable c_long
SUBLANG_FRENCH_MONACO = 6 # Variable c_int
MMSYSERR_NOMEM = 7 # Variable c_int
IMAGE_REL_MIPS_REFWORD = 2 # Variable c_int
CO_E_TRUSTEEDOESNTMATCHCLIENT = -2147220988 # Variable c_long
LANG_SYSTEM_DEFAULT = 2048 # Variable c_int
DI_DEFAULTSIZE = 8 # Variable c_int
CS_E_INVALID_VERSION = -2147221145 # Variable c_long
SELECTPAPERSOURCE = 18 # Variable c_int
DMPAPER_ENV_C3 = 29 # Variable c_int
PSP_USEHICON = 2 # Variable c_int
TAPE_DRIVE_EJECT_MEDIA = 16777216 # Variable c_int
WSAEALREADY = 10037 # Variable c_int
JOB_STATUS_ERROR = 2 # Variable c_int
TCM_HIGHLIGHTITEM = 4915 # Variable c_int
WM_MOVING = 534 # Variable c_int
CO_E_INIT_TLS_CHANNEL_CONTROL = -2147467252 # Variable c_long
SBN_LAST = 4294966397 # Variable c_uint
ERROR_INTERNAL_DB_CORRUPTION = 1358 # Variable c_long
PSBTN_MAX = 6 # Variable c_int
IMAGE_REL_PPC_TYPEMASK = 255 # Variable c_int
VK_DELETE = 46 # Variable c_int
SM_RESERVED4 = 27 # Variable c_int
CBEN_ENDEDITW = 4294966490 # Variable c_uint
SW_SHOWNORMAL = 1 # Variable c_int
DRAGDROP_E_ALREADYREGISTERED = -2147221247 # Variable c_long
PAN_MIDLINE_CONSTANT_POINTED = 9 # Variable c_int
IS_TEXT_UNICODE_UNICODE_MASK = 15 # Variable c_int
SM_CYMAXIMIZED = 62 # Variable c_int
SW_INVALIDATE = 2 # Variable c_int
IME_ESC_SYNC_HOTKEY = 4103 # Variable c_int
LANG_GUJARATI = 71 # Variable c_int
WGL_SWAP_OVERLAY7 = 128 # Variable c_int
REG_LEGAL_OPTION = 15 # Variable c_long
POSTSCRIPT_DATA = 37 # Variable c_int
ERROR_TRUST_FAILURE = 1790 # Variable c_long
SECURITY_BUILTIN_DOMAIN_RID = 32 # Variable c_long
SPAPI_E_NO_SUCH_INTERFACE_CLASS = -2146500066 # Variable c_long
MK_E_NOSTORAGE = -2147221011 # Variable c_long
REG_NOTIFY_CHANGE_LAST_SET = 4 # Variable c_long
INHERIT_ONLY_ACE = 8 # Variable c_int
PAN_SERIF_PERP_SANS = 13 # Variable c_int
DRIVE_UNKNOWN = 0 # Variable c_int
RPC_X_SS_CHAR_TRANS_OPEN_FAIL = 1773 # Variable c_long
IME_ESC_SET_EUDC_DICTIONARY = 4100 # Variable c_int
RPC_S_BINDING_HAS_NO_AUTH = 1746 # Variable c_long
PERF_QUERY_OBJECTS = -2147483648 # Variable c_long
IS_TEXT_UNICODE_ASCII16 = 1 # Variable c_int
IME_JHOTKEY_CLOSE_OPEN = 48 # Variable c_int
WSAVERNOTSUPPORTED = 10092 # Variable c_int
JOY_BUTTON17 = 65536 # Variable c_long
ACCESS_MIN_MS_OBJECT_ACE_TYPE = 5 # Variable c_int
NTE_BAD_KEY_STATE = -2146893813 # Variable c_long
MCM_SETMONTHDELTA = 4116 # Variable c_int

_SC_ACTION_TYPE = c_int # enum
TIME_CALLBACK_EVENT_PULSE = 32 # Variable c_int
VIEW_E_FIRST = 2147746112 # Variable c_ulong
ERROR_INVALID_DATATYPE = 1804 # Variable c_long
PAN_BENT_ARMS_SINGLE_SERIF = 10 # Variable c_int
EMR_SAVEDC = 33 # Variable c_int
ATTR_TARGET_NOTCONVERTED = 3 # Variable c_int
PBM_DELTAPOS = 1027 # Variable c_int
RPC_E_CONNECTION_TERMINATED = -2147418106 # Variable c_long
MCIERR_SEQ_PORT_MISCERROR = 340 # Variable c_int
BS_HATCHED = 2 # Variable c_int
CTRY_NEW_ZEALAND = 64 # Variable c_int
SM_PENWINDOWS = 41 # Variable c_int
PAN_STRAIGHT_ARMS_SINGLE_SERIF = 5 # Variable c_int
VK_NUMPAD5 = 101 # Variable c_int
RPC_S_OBJECT_NOT_FOUND = 1710 # Variable c_long
QS_TIMER = 16 # Variable c_int
TVIS_USERMASK = 61440 # Variable c_int
TVGN_DROPHILITE = 8 # Variable c_int
FROM_LEFT_1ST_BUTTON_PRESSED = 1 # Variable c_int
TBM_GETRANGEMIN = 1025 # Variable c_int
ABM_SETPOS = 3 # Variable c_int
CRYPT_E_NO_REVOCATION_CHECK = -2146885614 # Variable c_long
R2_MASKPEN = 9 # Variable c_int
VS_FF_PRERELEASE = 2 # Variable c_long
TCIF_STATE = 16 # Variable c_int
NUMPRS_STD = 8191 # Variable c_int
CBN_SETFOCUS = 3 # Variable c_int
DT_END_ELLIPSIS = 32768 # Variable c_int

tagOLECONTF = c_int # enum
OLECONTF_EMBEDDINGS = 1
OLECONTF_LINKS = 2
OLECONTF_OTHERS = 4
OLECONTF_ONLYUSER = 8
OLECONTF_ONLYIFRUNNING = 16
VT_LPSTR = 30
RPC_C_LISTEN_MAX_CALLS_DEFAULT = 1234 # Variable c_int
META_POLYPOLYGON = 1336 # Variable c_int
OFN_ENABLEHOOK = 32 # Variable c_int
STANDARD_RIGHTS_READ = 131072 # Variable c_long
MIXERCONTROL_CT_UNITS_DECIBELS = 262144 # Variable c_long
EMR_CHORD = 46 # Variable c_int
IMAGE_SIZEOF_SHORT_NAME = 8 # Variable c_int
TBIF_STATE = 4 # Variable c_int
TAPE_DRIVE_ERASE_IMMEDIATE = 128 # Variable c_int
ERROR_RESOURCE_PROPERTIES_STORED = 5024 # Variable c_long
DM_TTOPTION = 16384 # Variable c_long
STATUS_FLOAT_STACK_CHECK = 3221225618 # Variable c_ulong
ERROR_LOCK_FAILED = 167 # Variable c_long
EMR_SETBKCOLOR = 25 # Variable c_int
SETABORTPROC = 9 # Variable c_int
SPAPI_E_NO_DRIVER_SELECTED = -2146500093 # Variable c_long
CS_VREDRAW = 1 # Variable c_int
ACTFLG_RunLocally = 1 # Variable c_int
WC_IPADDRESSA = 'SysIPAddress32' # Variable POINTER(c_char)
KF_ALTDOWN = 8192 # Variable c_int
STATUS_BREAKPOINT = 2147483651 # Variable c_ulong
ico3 = 1086 # Variable c_int
SPI_SETPOWEROFFTIMEOUT = 82 # Variable c_int
_ALPHA = 259 # Variable c_int
PROCESSOR_ARM720 = 1824 # Variable c_int
ERROR_SPECIAL_USER = 1373 # Variable c_long
IME_ESC_HANJA_MODE = 4104 # Variable c_int
MCI_CDA_TRACK_AUDIO = 1088 # Variable c_int
GMR_DAYSTATE = 1 # Variable c_int
ERROR_WMI_DP_FAILED = 4209 # Variable c_long
ERROR_BAD_TOKEN_TYPE = 1349 # Variable c_long
DT_PLOTTER = 0 # Variable c_int
FILE_CURRENT = 1 # Variable c_int
NIF_ICON = 2 # Variable c_int
NRC_DUPNAME = 13 # Variable c_int
FACILITY_CONTROL = 10 # Variable c_int
IMPLTYPEFLAG_FRESTRICTED = 4 # Variable c_int
EMR_CREATEPALETTE = 49 # Variable c_int
MMSYSERR_DELETEERROR = 18 # Variable c_int
PAN_SERIF_OBTUSE_SQUARE_COVE = 5 # Variable c_int
DFCS_BUTTONRADIOMASK = 2 # Variable c_int
BS_OWNERDRAW = 11 # Variable c_long
SHAREVISTRINGW = 'commdlg_ShareViolation' # Variable POINTER(c_wchar)
TYPE_E_SIZETOOBIG = -2147317563 # Variable c_long
RPC_X_SS_HANDLES_MISMATCH = 1778 # Variable c_long
BLACK_PEN = 7 # Variable c_int
BS_RIGHT = 512 # Variable c_long
WAVE_FORMAT_1S16 = 8 # Variable c_int
PGN_LAST = 4294966346 # Variable c_uint
EC_RIGHTMARGIN = 2 # Variable c_int
IMAGE_REL_BASED_SECTION = 6 # Variable c_int
MCI_VD_STATUS_FORWARD = 16387 # Variable c_long
IPPORT_WHOSERVER = 513 # Variable c_int
ERROR_CANNOT_MAKE = 82 # Variable c_long
LVNI_TOLEFT = 1024 # Variable c_int
EMR_EOF = 14 # Variable c_int
TVIS_BOLD = 16 # Variable c_int
WIN_CERT_TYPE_PKCS_SIGNED_DATA = 2 # Variable c_int
NTE_BAD_KEYSET = -2146893802 # Variable c_long
TVHT_ONITEMBUTTON = 16 # Variable c_int
ERROR_NONPAGED_SYSTEM_RESOURCES = 1451 # Variable c_long
MIXERLINE_COMPONENTTYPE_SRC_ANALOG = 4106 # Variable c_long
ZAFLAGS_NO_UI = 32
SETCOPYCOUNT = 17 # Variable c_int
DMDITHER_LINEART = 4 # Variable c_int
LB_GETCOUNT = 395 # Variable c_int
LCS_GM_ABS_COLORIMETRIC = 8 # Variable c_long
ERROR_CLIPPING_NOT_SUPPORTED = 2005 # Variable c_long
PSINJECT_MAX = 27 # Variable c_int
MCIERR_FILE_WRITE = 349 # Variable c_int
TBCDRF_NOEDGES = 65536 # Variable c_int
CAL_THAI = 7 # Variable c_int
HELP_CONTENTS = 3 # Variable c_long
FILE_SUPPORTS_REMOTE_STORAGE = 256 # Variable c_int
MIIM_DATA = 32 # Variable c_int
PCF_XONXOFF = 16 # Variable c_ulong
PSM_PRESSBUTTON = 1137 # Variable c_int
BS_CHECKBOX = 2 # Variable c_long
IMC_GETSTATUSWINDOWPOS = 15 # Variable c_int
ERROR_CANNOT_DETECT_DRIVER_FAILURE = 1080 # Variable c_long
MEM_RESET = 524288 # Variable c_int
ERROR_DOMAIN_CONTROLLER_EXISTS = 1250 # Variable c_long
SUBLANG_SPANISH_COLOMBIA = 9 # Variable c_int
EV_RXCHAR = 1 # Variable c_int
PSM_REMOVEPAGE = 1126 # Variable c_int
URLZONEREG_DEFAULT = 0
TB_GETANCHORHIGHLIGHT = 1098 # Variable c_int
SUBLANG_ENGLISH_AUS = 3 # Variable c_int
LPD_SWAP_COPY = 1024 # Variable c_int
NTE_BAD_TYPE = -2146893814 # Variable c_long
LANG_KOREAN = 18 # Variable c_int
DATADIR_GET = 1
PRINTER_ATTRIBUTE_NETWORK = 16 # Variable c_int
CRYPT_E_PENDING_CLOSE = -2146885617 # Variable c_long
MIXERR_INVALVALUE = 1026 # Variable c_int
ICM_DONE_OUTSIDEDC = 4 # Variable c_int
BS_LEFT = 256 # Variable c_long
FKF_HOTKEYACTIVE = 4 # Variable c_int
psh7 = 1030 # Variable c_int
HOTKEY_CLASSW = 'msctls_hotkey32' # Variable POINTER(c_wchar)
WM_LBUTTONUP = 514 # Variable c_int
PC_NOCOLLAPSE = 4 # Variable c_int
NT351_INTERFACE_SIZE = 64 # Variable c_int
STARTF_USECOUNTCHARS = 8 # Variable c_int
IPPORT_TIMESERVER = 37 # Variable c_int
ETO_IGNORELANGUAGE = 4096 # Variable c_int
BS_ICON = 64 # Variable c_long
SC_ARRANGE = 61712 # Variable c_int
TCM_GETIMAGELIST = 4866 # Variable c_int
LBN_ERRSPACE = -2 # Variable c_int
RP_LOGON = 1 # Variable c_int
ACCESS_PROPERTY_GUID = 2 # Variable c_int
CLIPBRD_S_LAST = 262623 # Variable c_long
TBIMHT_AFTER = 1 # Variable c_int
REG_RESOURCE_REQUIREMENTS_LIST = 10 # Variable c_int
SEE_MASK_INVOKEIDLIST = 12 # Variable c_int
CAL_SDAYNAME2 = 8 # Variable c_int
DOMAIN_USER_RID_KRBTGT = 502 # Variable c_long
BAUD_56K = 32768 # Variable c_ulong
TTM_GETTEXTA = 1035 # Variable c_int
SM_RESERVED3 = 26 # Variable c_int
LVM_SETWORKAREAS = 4161 # Variable c_int
CB_FINDSTRING = 332 # Variable c_int
UPDFCACHE_ONSTOPCACHE = 4 # Variable c_int
COMPRESSION_FORMAT_LZNT1 = 2 # Variable c_int
MCI_DEVTYPE_CD_AUDIO = 516 # Variable c_int
TVGN_NEXT = 1 # Variable c_int
DMMEDIA_GLOSSY = 3 # Variable c_int
DIB_PAL_COLORS = 1 # Variable c_int
LB_FINDSTRING = 399 # Variable c_int
FLOODFILLBORDER = 0 # Variable c_int
chx3 = 1042 # Variable c_int
SE_SACL_DEFAULTED = 32 # Variable c_int
BSF_QUERY = 1 # Variable c_int
TIMEOUT_ASYNC = 4294967295 # Variable c_uint
MCI_OVLY_GETDEVCAPS_CAN_STRETCH = 16385 # Variable c_long
LB_MSGMAX = 432 # Variable c_int
EMR_GLSRECORD = 102 # Variable c_int
TAPE_DRIVE_INITIATOR = 4 # Variable c_int
ERROR_INVALID_ICON_HANDLE = 1414 # Variable c_long
PFD_SUPPORT_DIRECTDRAW = 8192 # Variable c_int
IDB_VIEW_LARGE_COLOR = 5 # Variable c_int
ERROR_BAD_INHERITANCE_ACL = 1340 # Variable c_long

_CM_ERROR_CONTROL_TYPE = c_int # enum
SevereError = 2
CriticalError = 3
IMAGE_REL_BASED_DIR64 = 10 # Variable c_int
DTN_FORMATW = 4294966553 # Variable c_uint
OLE_E_PROMPTSAVECANCELLED = -2147221492 # Variable c_long
NMPWAIT_NOWAIT = 1 # Variable c_int
RBN_LAST = 4294966437 # Variable c_uint
CF_TIFF = 6 # Variable c_int
DCBA_FACEUPNONE = 0 # Variable c_int
WVR_ALIGNLEFT = 32 # Variable c_int
LVM_GETSELECTEDCOUNT = 4146 # Variable c_int
PROPSETFLAG_ANSI = 2 # Variable c_int
PD_FORCE_SWITCH = 65536
IME_CMODE_EUDC = 512 # Variable c_int
ERROR_REMOTE_STORAGE_NOT_ACTIVE = 4351 # Variable c_long
SM_CYKANJIWINDOW = 18 # Variable c_int
IMAGE_FILE_MACHINE_ARM = 448 # Variable c_int
JOB_OBJECT_LIMIT_PROCESS_TIME = 2 # Variable c_int
PD_RETURNIC = 512 # Variable c_int
DISP_E_BADPARAMCOUNT = -2147352562 # Variable c_long
STG_E_OLDFORMAT = -2147286780 # Variable c_long
TC_SA_CONTIN = 256 # Variable c_int
PI_PARSE_URL = 1
FILE_ATTRIBUTE_COMPRESSED = 2048 # Variable c_int
GWL_WNDPROC = -4 # Variable c_int
IMAGE_FILE_NET_RUN_FROM_SWAP = 2048 # Variable c_int
PERF_COUNTER_TEXT = 2816 # Variable c_int
NTE_PROV_TYPE_NO_MATCH = -2146893797 # Variable c_long
PD_USEDEVMODECOPIES = 262144 # Variable c_int
MCN_GETDAYSTATE = 4294966549 # Variable c_uint
CB_GETHORIZONTALEXTENT = 349 # Variable c_int
TVE_TOGGLE = 3 # Variable c_int
PSWIZB_BACK = 1 # Variable c_int
UDS_ALIGNRIGHT = 4 # Variable c_int
MCIERR_FILE_READ = 348 # Variable c_int
TBS_NOTHUMB = 128 # Variable c_int
LVM_GETEXTENDEDLISTVIEWSTYLE = 4151 # Variable c_int
SZ_ASYNC_CALLEE = 'AsyncCallee' # Variable POINTER(c_wchar)
WAVE_FORMAT_4S16 = 2048 # Variable c_int
CC_WIDESTYLED = 64 # Variable c_int
NULLREGION = 1 # Variable c_int
STRETCHBLT = 2048 # Variable c_int
IMAGE_SCN_ALIGN_1024BYTES = 11534336 # Variable c_int
WM_SYSKEYDOWN = 260 # Variable c_int
DC_COLLATE = 22 # Variable c_int
TBCDRF_NOOFFSET = 262144 # Variable c_int
FR_NOWHOLEWORD = 4096 # Variable c_int
JOB_NOTIFY_FIELD_BYTES_PRINTED = 23 # Variable c_int
LANG_UZBEK = 67 # Variable c_int
C1_DIGIT = 4 # Variable c_int
MIXERCONTROL_CONTROLF_DISABLED = 2147483648 # Variable c_ulong
VK_EREOF = 249 # Variable c_int
FLOODFILLSURFACE = 1 # Variable c_int
MMIO_INSTALLPROC = 65536 # Variable c_int
IME_CAND_MEANING = 3 # Variable c_int
VAR_CONST = 2
TYPE_E_DUPLICATEID = -2147317562 # Variable c_long
WSAEACCES = 10013 # Variable c_int
HCF_CONFIRMHOTKEY = 8 # Variable c_int
COLOR_HIGHLIGHTTEXT = 14 # Variable c_int
IMAGE_SIZEOF_NT_OPTIONAL64_HEADER = 240 # Variable c_int
MMIO_CREATE = 4096 # Variable c_int
ABM_ACTIVATE = 6 # Variable c_int
CACHE_S_FIRST = 262512 # Variable c_long
DC_COPIES = 18 # Variable c_int
FADF_BSTR = 256 # Variable c_int
IDC_SIZENESW = 206403 # Variable POINTER(c_wchar)

tagBIND_FLAGS = c_int # enum
TTM_UPDATETIPTEXTA = 1036 # Variable c_int
TAPE_DRIVE_REVERSE_POSITION = 2151677952 # Variable c_uint
MCI_GETDEVCAPS_HAS_VIDEO = 3 # Variable c_long
TCIF_RTLREADING = 4 # Variable c_int
UPDFCACHE_NORMALCACHE = 8 # Variable c_int
COLOR_INFOBK = 24 # Variable c_int
DISP_E_NONAMEDARGS = -2147352569 # Variable c_long
SERVICE_PAUSE_PENDING = 6 # Variable c_int
CDN_FOLDERCHANGE = 4294966693 # Variable c_uint
IPPROTO_IGMP = 2 # Variable c_int
ERROR_WMI_ALREADY_ENABLED = 4206 # Variable c_long
SPLDS_PRINT_MEDIA_READY = 'printMediaReady' # Variable POINTER(c_wchar)
ERROR_STATIC_INIT = 4002 # Variable c_long
META_MOVETO = 532 # Variable c_int
SB_THUMBPOSITION = 4 # Variable c_int
PSN_HELP = 4294967091 # Variable c_uint
PSH_DEFAULT = 0 # Variable c_int
COLOR_APPWORKSPACE = 12 # Variable c_int
IDC_NO = 206408 # Variable POINTER(c_wchar)
WNNC_NET_SYMFONET = 1376256 # Variable c_int
FW_EXTRABOLD = 800 # Variable c_int
XTYP_POKE = 16528 # Variable c_int
PRINTER_ENUM_FAVORITE = 4 # Variable c_int
KLF_REORDER = 8 # Variable c_int
HDITEMW_V1_SIZE = 28 # Variable c_uint
DMPAPER_ENV_C6 = 31 # Variable c_int
PAN_MIDLINE_HIGH_TRIMMED = 5 # Variable c_int
WM_KEYUP = 257 # Variable c_int
IMAGE_REL_I386_REL32 = 20 # Variable c_int
WM_EXITMENULOOP = 530 # Variable c_int
CD_LBSELCHANGE = 0 # Variable c_int
PBM_GETRANGE = 1031 # Variable c_int
ERROR_FILE_EXISTS = 80 # Variable c_long
STARTF_USESHOWWINDOW = 1 # Variable c_int
ERROR_SPECIAL_ACCOUNT = 1371 # Variable c_long
ERROR_QUORUM_RESOURCE = 5020 # Variable c_long
HORZSIZE = 4 # Variable c_int
MCHT_NEXT = 16777216 # Variable c_int
CF_ENABLEHOOK = 8 # Variable c_long
TB_MARKBUTTON = 1030 # Variable c_int
MCI_WAVE_STATUS_FORMATTAG = 16385 # Variable c_long
STGM_SHARE_DENY_READ = 48 # Variable c_long
MK_S_MONIKERALREADYREGISTERED = 262631 # Variable c_long
ERROR_DLL_NOT_FOUND = 1157 # Variable c_long
SM_CXFRAME = 32 # Variable c_int
MCIERR_NO_IDENTITY = 350 # Variable c_int
TKIND_MAX = 8
WM_NOTIFYFORMAT = 85 # Variable c_int
SZDDESYS_ITEM_TOPICS = 'Topics' # Variable POINTER(c_wchar)
CLIPBRD_E_BAD_DATA = -2147221037 # Variable c_long
PRINTER_NOTIFY_FIELD_CJOBS = 20 # Variable c_int
ERROR_TOO_MANY_SIDS = 1389 # Variable c_long
CO_E_REMOTE_COMMUNICATION_FAILURE = -2147467235 # Variable c_long
MM_MIM_LONGERROR = 966 # Variable c_int
MCI_WAVE_SET_BLOCKALIGN = 1048576 # Variable c_long
EM_LINESCROLL = 182 # Variable c_int
BKMODE_LAST = 2 # Variable c_int
MMIOERR_OUTOFMEMORY = 258 # Variable c_int
FS_TURKISH = 16 # Variable c_long
ERROR_TOO_MANY_MUXWAITERS = 152 # Variable c_long
FR_NOMATCHCASE = 2048 # Variable c_int
SKF_TWOKEYSOFF = 256 # Variable c_int
CTRY_JAPAN = 81 # Variable c_int
TRUST_E_NO_SIGNER_CERT = -2146869246 # Variable c_long
STGFMT_NATIVE = 1 # Variable c_int
SPLDS_PRINT_SHARE_NAME = 'printShareName' # Variable POINTER(c_wchar)
MIXERLINE_COMPONENTTYPE_SRC_FIRST = 4096 # Variable c_long
WAVERR_UNPREPARED = 34 # Variable c_int
ALL_TRANSPORTS = 'M\x00\x00\x00' # Variable POINTER(c_char)
RESOURCEUSAGE_CONTAINER = 2 # Variable c_int
WNNC_NET_APPLETALK = 1245184 # Variable c_int
WB_RIGHT = 1 # Variable c_int
LCMAP_HIRAGANA = 1048576 # Variable c_int
MOD_SHIFT = 4 # Variable c_int
ES_PASSWORD = 32 # Variable c_long
SSF_AVAILABLE = 2 # Variable c_int
HCF_INDICATOR = 32 # Variable c_int
S_QUEUEEMPTY = 0 # Variable c_int
RPC_C_OPT_BINDING_NONCAUSAL = 9 # Variable c_int
HDF_RIGHT = 1 # Variable c_int
BF_DIAGONAL_ENDBOTTOMLEFT = 25 # Variable c_int
PSNRET_INVALID = 1 # Variable c_int
GETPENWIDTH = 16 # Variable c_int
PRF_CHILDREN = 16 # Variable c_long
DSPRINT_UNPUBLISH = 3 # Variable c_int
DRIVE_CDROM = 5 # Variable c_int
WT_EXECUTEINLONGTHREAD = 16 # Variable c_int
TTM_ENUMTOOLSA = 1038 # Variable c_int
WM_CHANGECBCHAIN = 781 # Variable c_int
TAPE_DRIVE_SET_CMP_BOP_ONLY = 67108864 # Variable c_int
NTE_BAD_DATA = -2146893819 # Variable c_long
NRC_IFBUSY = 33 # Variable c_int
FILE_VOLUME_QUOTAS = 32 # Variable c_int
DISP_E_EXCEPTION = -2147352567 # Variable c_long
DFC_CAPTION = 1 # Variable c_int
DCBA_FACEUPCENTER = 1 # Variable c_int
WM_MBUTTONDBLCLK = 521 # Variable c_int
NTE_BAD_PROVIDER = -2146893805 # Variable c_long
META_LINETO = 531 # Variable c_int
PENDINGTYPE_TOPLEVEL = 1
ERROR_SOURCE_ELEMENT_EMPTY = 1160 # Variable c_long
VK_RBUTTON = 2 # Variable c_int
TBSTYLE_LIST = 4096 # Variable c_int
STG_E_ABNORMALAPIEXIT = -2147286790 # Variable c_long
SPI_SETDOUBLECLKWIDTH = 29 # Variable c_int
DRAGLISTMSGSTRING = 'commctrl_DragListMsg' # Variable POINTER(c_wchar)
ERROR_IS_JOIN_PATH = 147 # Variable c_long
SWP_NOMOVE = 2 # Variable c_int
TTM_DELTOOLW = 1075 # Variable c_int
AC_DST_NO_ALPHA = 32 # Variable c_int
LOCALE_SDAYNAME4 = 45 # Variable c_int
VK_ACCEPT = 30 # Variable c_int
CACHE_E_LAST = 2147746175 # Variable c_ulong
TC_OP_STROKE = 2 # Variable c_int
FRAME_TRAP = 1 # Variable c_int
SM_CXHSCROLL = 21 # Variable c_int
EMR_CREATEMONOBRUSH = 93 # Variable c_int
THREAD_IMPERSONATE = 256 # Variable c_int
FILE_ACTION_MODIFIED = 3 # Variable c_int
IMAGE_SIZEOF_BASE_RELOCATION = 8 # Variable c_int
TBSTATE_HIDDEN = 8 # Variable c_int
CHANGEKIND_GENERAL = 4
LOCALE_SDAYNAME5 = 46 # Variable c_int
MMIO_EMPTYBUF = 16 # Variable c_int
HC_NOREMOVE = 3 # Variable c_int
META_SETPIXEL = 1055 # Variable c_int
PIDSI_EDITTIME = 10 # Variable c_long
IMAGE_SCN_TYPE_NO_PAD = 8 # Variable c_int
PFD_SWAP_LAYER_BUFFERS = 2048 # Variable c_int
MIXERCONTROL_CONTROLTYPE_SIGNED = 805437440 # Variable c_long
PD_PRINTSETUP = 64 # Variable c_int
SO_SNDTIMEO = 4101 # Variable c_int
CLIP_TT_ALWAYS = 32 # Variable c_int
DMPAPER_LETTER_TRANSVERSE = 54 # Variable c_int
LVM_SETHOTCURSOR = 4158 # Variable c_int
VK_NUMPAD6 = 102 # Variable c_int
DT_CENTER = 1 # Variable c_int
COLORRES = 108 # Variable c_int
CWP_SKIPTRANSPARENT = 4 # Variable c_int
SECURITY_PRINCIPAL_SELF_RID = 10 # Variable c_long
CFSTR_MIME_X_AIFF = 'audio/x-aiff' # Variable POINTER(c_wchar)
BANDINFO = 24 # Variable c_int
JOB_STATUS_PRINTING = 16 # Variable c_int
HTTOPLEFT = 13 # Variable c_int
VIF_TEMPFILE = 1 # Variable c_long
DFC_SCROLL = 3 # Variable c_int
PROCESS_HEAP_ENTRY_MOVEABLE = 16 # Variable c_int
GCPCLASS_HEBREW = 2 # Variable c_int
MAXHALF_PTR = 32767 # Variable c_int
MIXER_GETCONTROLDETAILSF_VALUE = 0 # Variable c_long
FROM_LEFT_4TH_BUTTON_PRESSED = 16 # Variable c_int
VT_LPWSTR = 31
SEE_MASK_CLASSKEY = 3 # Variable c_int
PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR = 9 # Variable c_int
CF_BOTH = 3 # Variable c_int
NM_RETURN = 4294967292 # Variable c_uint
PID_FIRST_USABLE = 2 # Variable c_int
WAVERR_SYNC = 35 # Variable c_int
META_SELECTOBJECT = 301 # Variable c_int
CO_E_RUNAS_LOGON_FAILURE = -2147467238 # Variable c_long
PSP_USETITLE = 8 # Variable c_int
HTTRANSPARENT = -1 # Variable c_int
VARIANT_LOCALBOOL = 16 # Variable c_int
DST_PREFIXTEXT = 2 # Variable c_int
LVS_EX_GRIDLINES = 1 # Variable c_int
FILE_SHARE_WRITE = 2 # Variable c_int
DROPEFFECT_SCROLL = 2147483648 # Variable c_uint
WIZ_BODYX = 92 # Variable c_int
CO_E_ALREADYINITIALIZED = -2147221007 # Variable c_long
SP_DATABITS = 4 # Variable c_ulong
MIXERLINE_COMPONENTTYPE_DST_MONITOR = 3 # Variable c_long
LMEM_ZEROINIT = 64 # Variable c_int
CBR_600 = 600 # Variable c_int
PERF_QUERY_COSTLY = -2147483646 # Variable c_long
URLACTION_SHELL_MAX = 6655 # Variable c_int
WSABASEERR = 10000 # Variable c_int
CO_E_INIT_SCM_EXEC_FAILURE = -2147467247 # Variable c_long
QDI_GETDIBITS = 2 # Variable c_int
ERROR_INVALID_TRANSFORM = 2310 # Variable c_long
PS_TYPE_MASK = 983040 # Variable c_int
MCSC_TITLEBK = 2 # Variable c_int
URLPOLICY_LOG_ON_DISALLOW = 128 # Variable c_int
COMMPROP_INITIALIZED = 3879531822 # Variable c_ulong
SZDDESYS_ITEM_RTNMSG = 'ReturnMessage' # Variable POINTER(c_wchar)
JOY_BUTTON21 = 1048576 # Variable c_long
TYPE_E_TYPEMISMATCH = -2147316576 # Variable c_long
FILE_CREATE_PIPE_INSTANCE = 4 # Variable c_int
LOAD_DLL_DEBUG_EVENT = 6 # Variable c_int
PAN_SERIF_THIN = 7 # Variable c_int
GET_TAPE_MEDIA_INFORMATION = 0 # Variable c_int
CO_E_INIT_CLASS_CACHE = -2147467255 # Variable c_long
PSBTN_CANCEL = 5 # Variable c_int
PERF_COUNTER_COUNTER = 272696320 # Variable c_int
GGL_PRIVATE = 4 # Variable c_int
PDERR_LOADDRVFAILURE = 4100 # Variable c_int
SW_PARENTOPENING = 3 # Variable c_int
PERF_NO_UNIQUE_ID = -1 # Variable c_int
WM_NULL = 0 # Variable c_int
VK_LSHIFT = 160 # Variable c_int
LOCALE_IDEFAULTANSICODEPAGE = 4100 # Variable c_int
SB_PAGEUP = 2 # Variable c_int
ERROR_INVALID_PRIORITY = 1800 # Variable c_long
MIDI_CACHE_ALL = 1 # Variable c_int
CONNECT_INTERACTIVE = 8 # Variable c_int
MIXER_LONG_NAME_CHARS = 64 # Variable c_int
WNNC_NET_DISTINCT = 2293760 # Variable c_int
WSAECONNABORTED = 10053 # Variable c_int
RPC_E_SERVER_DIED = -2147418105 # Variable c_long
PSM_QUERYSIBLINGS = 1132 # Variable c_int
TKF_TOGGLEKEYSON = 1 # Variable c_int
MCN_LAST = 4294966537 # Variable c_uint
EM_SETMARGINS = 211 # Variable c_int
STD_OUTPUT_HANDLE = 4294967285 # Variable c_ulong
CFSTR_MIME_QUICKTIME = 'video/quicktime' # Variable POINTER(c_wchar)
RB_SETBANDINFOW = 1035 # Variable c_int
NFR_UNICODE = 2 # Variable c_int
PIPE_NOWAIT = 1 # Variable c_int
DESCKIND_TYPECOMP = 3
ERROR_NOT_OWNER = 288 # Variable c_long
TBN_GETDISPINFOA = 4294966580 # Variable c_uint
TTDT_INITIAL = 3 # Variable c_int
OUT_TT_PRECIS = 4 # Variable c_int
TB_GETSTYLE = 1081 # Variable c_int
EMR_CLOSEFIGURE = 61 # Variable c_int
FADF_VARIANT = 2048 # Variable c_int
CO_E_RELOAD_DLL = -2147467230 # Variable c_long
ICC_DATE_CLASSES = 256 # Variable c_int
RBBS_VARIABLEHEIGHT = 64 # Variable c_int
CREATE_ALWAYS = 2 # Variable c_int
NCBDGRECVBC = 35 # Variable c_int
OF_EXIST = 16384 # Variable c_int
CF_WYSIWYG = 32768 # Variable c_long
META_ROUNDRECT = 1564 # Variable c_int
CTRY_EGYPT = 20 # Variable c_int
DCTT_DOWNLOAD_OUTLINE = 8 # Variable c_long
ICM_QUERY = 3 # Variable c_int
DIGSIG_E_DECODE = -2146762746 # Variable c_long
EMR_STROKEPATH = 64 # Variable c_int
RC_PALETTE = 256 # Variable c_int
CAL_TAIWAN = 4 # Variable c_int
URLZONEREG_HKLM = 1
LBS_NOTIFY = 1 # Variable c_long
JOB_OBJECT_POST_AT_END_OF_JOB = 1 # Variable c_int
WS_OVERLAPPED = 0 # Variable c_long
SZM_CREATE = 0
SPAPI_E_NO_SUCH_DEVICE_INTERFACE = -2146500059 # Variable c_long
BATTERY_FLAG_HIGH = 1 # Variable c_int
RPC_X_PIPE_CLOSED = 1916 # Variable c_long
PIDSI_LASTPRINTED = 11 # Variable c_long
SUBLANG_SPANISH_ECUADOR = 12 # Variable c_int
IMAGE_FILE_UP_SYSTEM_ONLY = 16384 # Variable c_int
TVM_EXPAND = 4354 # Variable c_int
ERROR_INVALID_CURSOR_HANDLE = 1402 # Variable c_long
WVR_REDRAW = 768 # Variable c_int
ERROR_LOGON_SESSION_COLLISION = 1366 # Variable c_long
CDS_GLOBAL = 8 # Variable c_int
ERROR_MEDIA_UNAVAILABLE = 4308 # Variable c_long
ERROR_ADDRESS_NOT_ASSOCIATED = 1228 # Variable c_long
WM_CHOOSEFONT_SETLOGFONT = 1125 # Variable c_int
CFSTR_MIME_JPEG = 'image/jpeg' # Variable POINTER(c_wchar)
DT_PATH_ELLIPSIS = 16384 # Variable c_int
CabFilePath = 3
ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = 1795 # Variable c_long
MEM_FREE = 65536 # Variable c_int
DL_DROPPED = 1159 # Variable c_int
AF_MAX = 22 # Variable c_int
VIF_MISMATCH = 2 # Variable c_long
JOB_STATUS_PRINTED = 128 # Variable c_int
MCIERR_WAVE_OUTPUTSINUSE = 320 # Variable c_int
FILE_VOLUME_IS_COMPRESSED = 32768 # Variable c_int
SBT_RTLREADING = 1024 # Variable c_int
MAILSLOT_WAIT_FOREVER = 4294967295 # Variable c_ulong
CLIPBRD_E_CANT_SET = -2147221038 # Variable c_long
RPC_E_INVALID_DATA = -2147418097 # Variable c_long
CBS_UPPERCASE = 8192 # Variable c_long
JOY_CAL_READXYONLY = 131072 # Variable c_long
CO_E_CANTDETERMINECLASS = -2147221006 # Variable c_long
LVN_ODFINDITEMA = 4294967144 # Variable c_uint
SPAPI_E_DEVINST_ALREADY_EXISTS = -2146500089 # Variable c_long

_URLZONEREG = c_int # enum
ROT_COMPARE_MAX = 2048 # Variable c_int
EMR_ARC = 45 # Variable c_int
PRINTACTION_SERVERPROPERTIES = 7 # Variable c_int
TIME_MIDI = 16 # Variable c_int
GMEM_DDESHARE = 8192 # Variable c_int
IPPORT_TFTP = 69 # Variable c_int
CAL_SDAYNAME3 = 9 # Variable c_int

tagDATADIR = c_int # enum
PBM_SETRANGE32 = 1030 # Variable c_int
PAN_WEIGHT_DEMI = 7 # Variable c_int
TARGET_IS_NT50_OR_LATER = 0 # Variable c_int

tagADVF = c_int # enum
ADVF_DATAONSTOP = 64
ADVFCACHE_NOHANDLER = 8
ADVFCACHE_FORCEBUILTIN = 16
PERF_AVERAGE_BULK = 1073874176 # Variable c_int
NM_RCLICK = 4294967291 # Variable c_uint
ERROR_CHILD_WINDOW_MENU = 1436 # Variable c_long
NTE_BAD_PUBLIC_KEY = -2146893803 # Variable c_long
BDR_OUTER = 3 # Variable c_int
SPLDS_PRINTER_LOCATIONS = 'printerLocations' # Variable POINTER(c_wchar)
DUPLICATE_DEREG = 7 # Variable c_int
DLGC_WANTTAB = 2 # Variable c_int
VTBIT_UI4 = 524288 # Variable c_int
CFS_FORCE_POSITION = 32 # Variable c_int
WINSTA_ENUMERATE = 256 # Variable c_long
LANG_ORIYA = 72 # Variable c_int
INET_E_INVALID_REQUEST = -2146697204 # Variable c_long
SERVICE_INTERROGATE = 128 # Variable c_int
MCI_SYSINFO_QUANTITY = 256 # Variable c_long
SYSPAL_NOSTATIC = 2 # Variable c_int
IMAGE_REL_PPC_REFHI = 16 # Variable c_int
SPLDS_BYTES_PER_MINUTE = 'bytesPerMinute' # Variable POINTER(c_wchar)
TVS_NOTOOLTIPS = 128 # Variable c_int
ERROR_NOT_LOGON_PROCESS = 1362 # Variable c_long
LCS_CALIBRATED_RGB = 0 # Variable c_long
DMICMMETHOD_DRIVER = 3 # Variable c_int
FILE_NOTIFY_CHANGE_ATTRIBUTES = 4 # Variable c_int
STG_S_BLOCK = 197121 # Variable c_long
PIDSI_SUBJECT = 3 # Variable c_long
WS_EX_TOOLWINDOW = 128 # Variable c_long
PI_FILTER_MODE = 2
MCI_SEQ_OFFSET = 1216 # Variable c_int
HC_GETNEXT = 1 # Variable c_int
FILE_ATTRIBUTE_ENCRYPTED = 64 # Variable c_int
stc10 = 1097 # Variable c_int
DWL_MSGRESULT = 0 # Variable c_int
RB_GETBARHEIGHT = 1051 # Variable c_int
LOAD_LIBRARY_AS_DATAFILE = 2 # Variable c_int
IMAGE_SYM_CLASS_MEMBER_OF_STRUCT = 8 # Variable c_int
SP_SERIALCOMM = 1 # Variable c_ulong
IPPORT_BIFFUDP = 512 # Variable c_int
CS_SAVEBITS = 2048 # Variable c_int
SETBREAK = 8 # Variable c_int
IMAGE_DEBUG_TYPE_BORLAND = 9 # Variable c_int
RPC_S_CALL_CANCELLED = 1818 # Variable c_long
CE_IOE = 1024 # Variable c_int
MCS_DAYSTATE = 1 # Variable c_int
MIXERCONTROL_CT_SC_SWITCH_BUTTON = 16777216 # Variable c_long
TPM_LEFTALIGN = 0 # Variable c_long
GCS_COMPATTR = 16 # Variable c_int
CAL_SABBREVMONTHNAME3 = 36 # Variable c_int
AF_ECMA = 8 # Variable c_int
MIXERCONTROL_CT_SC_SWITCH_BOOLEAN = 0 # Variable c_long
LANG_BASQUE = 45 # Variable c_int
SPI_GETKEYBOARDSPEED = 10 # Variable c_int
CCM_GETCOLORSCHEME = 8195 # Variable c_int
CBEN_GETDISPINFOW = 4294966489 # Variable c_uint
OF_CREATE = 4096 # Variable c_int
SM_CXDOUBLECLK = 36 # Variable c_int
WM_DEVICECHANGE = 537 # Variable c_int
VAR_DISPATCH = 3
TA_CENTER = 6 # Variable c_int
chx13 = 1052 # Variable c_int
ERROR_GROUP_NOT_FOUND = 5013 # Variable c_long
TVN_BEGINLABELEDITA = 4294966886 # Variable c_uint
LOCALE_SMONTHNAME4 = 59 # Variable c_int
RPC_S_UUID_LOCAL_ONLY = 1824 # Variable c_long
MOUSE_MOVED = 1 # Variable c_int
HORZRES = 8 # Variable c_int
PSINJECT_BEGINDEFAULTS = 3 # Variable c_int
EMR_POLYBEZIER16 = 85 # Variable c_int
LOCALE_SPOSITIVESIGN = 80 # Variable c_int
PBT_APMSTANDBY = 5 # Variable c_int
C1_PUNCT = 16 # Variable c_int

tagOLEVERBATTRIB = c_int # enum
OLEVERBATTRIB_NEVERDIRTIES = 1
OLEVERBATTRIB_ONCONTAINERMENU = 2
WM_MOUSEMOVE = 512 # Variable c_int
DMPAPER_LEGAL_EXTRA = 51 # Variable c_int
MCI_ANIM_GETDEVCAPS_PALETTES = 16390 # Variable c_long
STATFLAG_NONAME = 1
WM_DELETEITEM = 45 # Variable c_int
PRINTER_STATUS_PAPER_JAM = 8 # Variable c_int
MCI_STATUS_START = 512 # Variable c_long
NF_REQUERY = 4 # Variable c_int
MEM_E_INVALID_LINK = -2146959344 # Variable c_long
DATETIMEPICK_CLASSA = 'SysDateTimePick32' # Variable POINTER(c_char)
SM_MOUSEPRESENT = 19 # Variable c_int
SHGFI_PIDL = 8 # Variable c_int
PSD_DEFAULTMINMARGINS = 0 # Variable c_int

tagCLSCTX = c_int # enum
CLSCTX_INPROC_SERVER = 1
CLSCTX_INPROC_HANDLER = 2
CLSCTX_LOCAL_SERVER = 4
CLSCTX_INPROC_SERVER16 = 8
CLSCTX_REMOTE_SERVER = 16
CLSCTX_INPROC_HANDLER16 = 32
CLSCTX_INPROC_SERVERX86 = 64
CLSCTX_INPROC_HANDLERX86 = 128
CLSCTX_ESERVER_HANDLER = 256
ERROR_INVALID_GROUP_ATTRIBUTES = 1345 # Variable c_long
ERROR_SWAPERROR = 999 # Variable c_long
LVN_HOTTRACK = 4294967175 # Variable c_uint
TRUST_E_FAIL = -2146762485 # Variable c_long
TA_BOTTOM = 8 # Variable c_int
DMLERR_SERVER_DIED = 16398 # Variable c_int
SB_RIGHT = 7 # Variable c_int
LZERROR_BADVALUE = -7 # Variable c_int
WS_EX_CONTEXTHELP = 1024 # Variable c_long
MKSYS_ANTIMONIKER = 3
IME_HOTKEY_PRIVATE_LAST = 543 # Variable c_int
IME_CAND_CODE = 2 # Variable c_int
ERROR_NO_LOG_SPACE = 1019 # Variable c_long
JOY_RETURNX = 1 # Variable c_long
PID_CODEPAGE = 1 # Variable c_int
FD_READ = 1 # Variable c_int
SM_CYMENUSIZE = 55 # Variable c_int
CF_ENABLETEMPLATE = 16 # Variable c_long
MCIERR_SEQ_TIMER = 341 # Variable c_int
WM_INPUTLANGCHANGEREQUEST = 80 # Variable c_int
POSTSCRIPT_IGNORE = 38 # Variable c_int
TCHT_ONITEM = 6 # Variable c_int
LOCALE_SABBREVDAYNAME4 = 52 # Variable c_int
CB_SETTOPINDEX = 348 # Variable c_int
LVM_GETCOUNTPERPAGE = 4136 # Variable c_int
CCS_TOP = 1 # Variable c_long
DT_BOTTOM = 8 # Variable c_int
OFN_SHAREAWARE = 16384 # Variable c_int
RDW_NOCHILDREN = 64 # Variable c_int
HHT_ONDIVOPEN = 8 # Variable c_int
TRUST_E_SUBJECT_NOT_TRUSTED = -2146762748 # Variable c_long
REG_NOTIFY_CHANGE_SECURITY = 8 # Variable c_long
GCP_CLASSIN = 524288 # Variable c_long
DDE_FACK = 32768 # Variable c_int
FKF_INDICATOR = 32 # Variable c_int
MCIERR_MUST_USE_SHAREABLE = 291 # Variable c_int
BATTERY_FLAG_CRITICAL = 4 # Variable c_int
IMAGE_REL_I386_DIR32 = 6 # Variable c_int
STDOLE_MAJORVERNUM = 1 # Variable c_int
DISPATCH_PROPERTYPUT = 4 # Variable c_int
MCI_FORMAT_BYTES = 8 # Variable c_int
PRINTER_ATTRIBUTE_RAW_ONLY = 4096 # Variable c_int
TAPE_DRIVE_WRITE_FILEMARKS = 2181038080 # Variable c_uint
JOY_POVBACKWARD = 18000 # Variable c_int
MMSYSERR_WRITEERROR = 17 # Variable c_int
LR_COLOR = 2 # Variable c_int
DMPAPER_10X14 = 16 # Variable c_int
LCMAP_LOWERCASE = 256 # Variable c_int
AF_APPLETALK = 16 # Variable c_int
WAVECAPS_SYNC = 16 # Variable c_int
URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING = 7430 # Variable c_int
LB_DELETESTRING = 386 # Variable c_int
WH_GETMESSAGE = 3 # Variable c_int
SORT_JAPANESE_UNICODE = 1 # Variable c_int
IME_ESC_QUERY_SUPPORT = 3 # Variable c_int
EXT_DEVICE_CAPS = 4099 # Variable c_int
MCIERR_NOTIFY_ON_AUTO_OPEN = 300 # Variable c_int
MK_E_MUSTBOTHERUSER = -2147221013 # Variable c_long
ERROR_BAD_IMPERSONATION_LEVEL = 1346 # Variable c_long
IMAGE_REL_IA64_ABSOLUTE = 0 # Variable c_int
HDM_SETITEMA = 4612 # Variable c_int
DMLERR_BUSY = 16385 # Variable c_int
HDF_RTLREADING = 4 # Variable c_int
CERTSRV_E_BAD_REQUESTSTATUS = -2146877437 # Variable c_long
BootLoad = 0
SPAPI_E_INVALID_DEVINST_NAME = -2146500091 # Variable c_long
DMPAPER_A3_EXTRA_TRANSVERSE = 68 # Variable c_int
MCI_STATUS_LENGTH = 1 # Variable c_long
PSD_ENABLEPAGESETUPTEMPLATE = 32768 # Variable c_int
TAPE_DRIVE_FIXED = 1 # Variable c_int
WM_CTLCOLOREDIT = 307 # Variable c_int
SPI_GETICONTITLELOGFONT = 31 # Variable c_int
SUBLANG_ENGLISH_NZ = 5 # Variable c_int
LVHT_ONITEMICON = 2 # Variable c_int
SP_APPABORT = -2 # Variable c_int
MCI_SEQ_STATUS_OFFSET = 16393 # Variable c_long
WS_SYSMENU = 524288 # Variable c_long
DM_COLOR = 2048 # Variable c_long
TIMERR_NOERROR = 0 # Variable c_int
LOCKFILE_EXCLUSIVE_LOCK = 2 # Variable c_int
TYPE_E_UNKNOWNLCID = -2147319762 # Variable c_long
XCLASS_FLAGS = 16384 # Variable c_int
WS_EX_TOPMOST = 8 # Variable c_long
WM_MOUSEHOVER = 673 # Variable c_int
RGN_XOR = 3 # Variable c_int
IMAGE_SCN_ALIGN_4096BYTES = 13631488 # Variable c_int
RPC_E_CANTCALLOUT_INASYNCCALL = -2147418108 # Variable c_long
RPC_S_NO_INTERFACES = 1817 # Variable c_long
PRINTER_NOTIFY_TYPE = 0 # Variable c_int
LVS_TYPEMASK = 3 # Variable c_int
SEE_MASK_ASYNCOK = 1048576 # Variable c_int
PRINTER_STATUS_BUSY = 512 # Variable c_int
LVM_GETSELECTIONMARK = 4162 # Variable c_int
LVA_ALIGNLEFT = 1 # Variable c_int
CTRY_COLOMBIA = 57 # Variable c_int
PDERR_DEFAULTDIFFERENT = 4108 # Variable c_int
MMSYSERR_KEYNOTFOUND = 15 # Variable c_int
TAPE_DRIVE_SET_ECC = 2147483904 # Variable c_uint
MIXERCONTROL_CONTROLTYPE_BOOLEAN = 536936448 # Variable c_long
RPC_S_INVALID_ASYNC_CALL = 1915 # Variable c_long
MIDIERR_STILLPLAYING = 65 # Variable c_int
LR_CREATEDIBSECTION = 8192 # Variable c_int
PROCESSOR_ARCHITECTURE_SHX = 4 # Variable c_int
MCI_SET_AUDIO_RIGHT = 2 # Variable c_long
ERROR_INVALID_GW_COMMAND = 1443 # Variable c_long
XST_UNADVSENT = 12 # Variable c_int
ISC_SHOWUICANDIDATEWINDOW = 1 # Variable c_int
SPI_GETFONTSMOOTHING = 74 # Variable c_int
LVS_OWNERDRAWFIXED = 1024 # Variable c_int
XMLELEMTYPE_PI = 5
CTRY_ISRAEL = 972 # Variable c_int
SUBLANG_SPANISH_MEXICAN = 2 # Variable c_int
PROPSETHDR_OSVERSION_UNKNOWN = 4294967295 # Variable c_uint
DMLERR_FIRST = 16384 # Variable c_int
WAVE_FORMAT_4M16 = 1024 # Variable c_int
PSINJECT_ENDSETUP = 8 # Variable c_int
MIDIPROP_TEMPO = 2 # Variable c_long
TB_SETCMDID = 1066 # Variable c_int
CSTR_GREATER_THAN = 3 # Variable c_int
VK_NUMPAD7 = 103 # Variable c_int
IMAGE_FILE_MACHINE_R10000 = 360 # Variable c_int
CB_GETITEMDATA = 336 # Variable c_int
SID_RECOMMENDED_SUB_AUTHORITIES = 1 # Variable c_int
TAPE_DRIVE_RELATIVE_BLKS = 2147614720 # Variable c_uint
ERROR_PAGED_SYSTEM_RESOURCES = 1452 # Variable c_long
TRUST_E_PROVIDER_UNKNOWN = -2146762751 # Variable c_long
ERROR_INVALID_SPI_VALUE = 1439 # Variable c_long
SHGFI_ATTR_SPECIFIED = 131072 # Variable c_int
DISPLAY_DEVICE_MULTI_DRIVER = 2 # Variable c_int
TAPE_LOGICAL_POSITION = 1 # Variable c_long
DOMAIN_ALIAS_RID_ACCOUNT_OPS = 548 # Variable c_long
ERROR_INVALID_ACCEL_HANDLE = 1403 # Variable c_long
PRINTER_ERROR_OUTOFTONER = 4 # Variable c_int
VFT2_FONT_VECTOR = 2 # Variable c_long
WM_CTLCOLORLISTBOX = 308 # Variable c_int
VT_RECORD = 36
JOB_POSITION_UNSPECIFIED = 0 # Variable c_int
URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL = 196608 # Variable c_int
CE_FRAME = 8 # Variable c_int
LBSELCHSTRINGW = 'commdlg_LBSelChangedNotify' # Variable POINTER(c_wchar)
rct1 = 1080 # Variable c_int
PARAMFLAG_FOUT = 2 # Variable c_int
INET_E_REDIRECT_TO_DIR = -2146697195 # Variable c_long
IMAGE_REL_ALPHA_GPREL32 = 3 # Variable c_int
COLOR_BTNSHADOW = 16 # Variable c_int
VTBIT_I4 = 8 # Variable c_int
FILE_READ_DATA = 1 # Variable c_int

tagDESCKIND = c_int # enum
DESCKIND_FUNCDESC = 1
DESCKIND_VARDESC = 2
DESCKIND_IMPLICITAPPOBJ = 4
DESCKIND_MAX = 5
PF_FLOATING_POINT_EMULATED = 1 # Variable c_int
MCI_ANIM_GETDEVCAPS_SLOW_RATE = 16387 # Variable c_long
SSF_INDICATOR = 4 # Variable c_int
SECURITY_LOGON_IDS_RID_COUNT = 3 # Variable c_long
SUBLANG_CHINESE_SIMPLIFIED = 2 # Variable c_int
CP_THREAD_ACP = 3 # Variable c_int
CC_SOLIDCOLOR = 128 # Variable c_int
VK_HANGUL = 21 # Variable c_int
GMDI_GOINTOPOPUPS = 2 # Variable c_long
CO_E_START_SERVICE_FAILURE = -2147467236 # Variable c_long
SO_DISCDATA = 28674 # Variable c_int
TF_REUSE_SOCKET = 2 # Variable c_int
STATUS_ACCESS_VIOLATION = 3221225477 # Variable c_ulong
TVIS_STATEIMAGEMASK = 61440 # Variable c_int
CLR_DEFAULT = 4278190080 # Variable c_ulong
JOB_OBJECT_UILIMIT_GLOBALATOMS = 32 # Variable c_int
NTM_ITALIC = 1 # Variable c_long
MCI_CDA_TRACK_OTHER = 1089 # Variable c_int
SPI_GETGRIDGRANULARITY = 18 # Variable c_int
RPC_S_INVALID_ENDPOINT_FORMAT = 1706 # Variable c_long
NDR_LITTLE_ENDIAN = 16 # Variable c_ulong
RESOURCETYPE_RESERVED = 8 # Variable c_int
NUMPRS_TRAILING_PLUS = 8 # Variable c_int
MCIERR_INTERNAL = 277 # Variable c_int
HELP_TCARD_OTHER_CALLER = 17 # Variable c_int
TB_GETITEMRECT = 1053 # Variable c_int
CTRY_SOUTH_KOREA = 82 # Variable c_int
NM_SETFOCUS = 4294967289 # Variable c_uint
RDW_ERASENOW = 512 # Variable c_int
FS_HEBREW = 32 # Variable c_long
BSM_APPLICATIONS = 8 # Variable c_int
PF_XMMI_INSTRUCTIONS_AVAILABLE = 6 # Variable c_int
CBEN_GETDISPINFOA = 4294966496 # Variable c_uint
HDN_BEGINDRAG = 4294966986 # Variable c_uint
DNS_FILTEROFF = 8 # Variable c_int
VIF_CANNOTRENAME = 8192 # Variable c_long
PAN_STROKE_GRADUAL_DIAG = 2 # Variable c_int
MCHT_CALENDARBK = 131072 # Variable c_int
MCIERR_WAVE_SETINPUTINUSE = 323 # Variable c_int
WC_COMPOSITECHECK = 512 # Variable c_int
RPC_C_MGMT_STOP_SERVER_LISTEN = 4 # Variable c_int
TVM_SETINSERTMARK = 4378 # Variable c_int
NTE_BAD_HASH = -2146893822 # Variable c_long
CT_CTYPE1 = 1 # Variable c_int
BALTIC_CHARSET = 186 # Variable c_int
HC_SYSMODALOFF = 5 # Variable c_int
TME_CANCEL = 2147483648 # Variable c_uint
SHGFI_EXETYPE = 8192 # Variable c_int
CERTSRV_E_NO_REQUEST = -2146877438 # Variable c_long
LVM_DELETEITEM = 4104 # Variable c_int
LVHITTESTINFO_V1_SIZE = 16 # Variable c_uint
HDN_ITEMDBLCLICKW = 4294966973 # Variable c_uint
ERROR_SERVICE_DOES_NOT_EXIST = 1060 # Variable c_long
PBT_APMQUERYSTANDBYFAILED = 3 # Variable c_int
VK_F22 = 133 # Variable c_int
ACM_OPENA = 1124 # Variable c_int
MMIO_ALLOCBUF = 65536 # Variable c_int
ERROR_INVALID_MEDIA_POOL = 4302 # Variable c_long
WAVE_FORMAT_PCM = 1 # Variable c_int
HWND_BROADCAST = 65535 # Variable POINTER(HWND__)
PROCESSOR_ARCHITECTURE_ALPHA64 = 7 # Variable c_int
NCBDGSENDBC = 34 # Variable c_int

tagLIBFLAGS = c_int # enum
LIBFLAG_FRESTRICTED = 1
LIBFLAG_FCONTROL = 2
HTERROR = -2 # Variable c_int
RBBIM_BACKGROUND = 128 # Variable c_int
MF_OWNERDRAW = 256 # Variable c_long
RASTERCAPS = 38 # Variable c_int
TBM_GETNUMTICS = 1040 # Variable c_int
FS_SYMBOL = 2147483648 # Variable c_ulong
MCIERR_WAVE_SETINPUTUNSUITABLE = 329 # Variable c_int
FACILITY_WIN32 = 7 # Variable c_int
STATUS_PRIVILEGED_INSTRUCTION = 3221225622 # Variable c_ulong
IME_ESC_GET_EUDC_DICTIONARY = 4099 # Variable c_int
TBNF_IMAGE = 1 # Variable c_int
WSAENAMETOOLONG = 10063 # Variable c_int
TB_BUTTONCOUNT = 1048 # Variable c_int
FR_DIALOGTERM = 64 # Variable c_int
SPAPI_E_NO_CLASS_DRIVER_LIST = -2146500072 # Variable c_long
SIZE_OF_80387_REGISTERS = 80 # Variable c_int
IDANI_CAPTION = 3 # Variable c_int
IME_CMODE_CHARCODE = 32 # Variable c_int
SZM_DELETE = 1
LVM_GETITEMCOUNT = 4100 # Variable c_int
MCI_MODE_PAUSE = 529 # Variable c_int
VREFRESH = 116 # Variable c_int
MCM_SETCURSEL = 4098 # Variable c_int
PST_UNSPECIFIED = 0 # Variable c_ulong
CB_GETDROPPEDSTATE = 343 # Variable c_int
SPLDS_PRINT_ORIENTATIONS_SUPPORTED = 'printOrientationsSupported' # Variable POINTER(c_wchar)
SECURITY_VALID_SQOS_FLAGS = 2031616 # Variable c_int
EMR_INTERSECTCLIPRECT = 30 # Variable c_int
WT_EXECUTEINUITHREAD = 2 # Variable c_int
SWP_NOSIZE = 1 # Variable c_int
BS_VCENTER = 3072 # Variable c_long
MMIO_CREATERIFF = 32 # Variable c_int
PSH_USEHICON = 2 # Variable c_int
WM_VSCROLLCLIPBOARD = 778 # Variable c_int
SORT_GEORGIAN_TRADITIONAL = 0 # Variable c_int
InfFilePath = 4
WSAELOOP = 10062 # Variable c_int
LANG_TAMIL = 73 # Variable c_int
ERROR_DS_CANT_ON_RDN = 1935 # Variable c_long
ERROR_NOT_SUBSTED = 137 # Variable c_long
MM_MOM_DONE = 969 # Variable c_int
ERROR_INVALID_STACKSEG = 189 # Variable c_long
MSGF_COMMCTRL_BEGINDRAG = 16896 # Variable c_int
MCI_OVLY_GETDEVCAPS_MAX_WINDOWS = 16387 # Variable c_long
CDIS_HOT = 64 # Variable c_int
SM_SLOWMACHINE = 73 # Variable c_int
JOYSTICKID2 = 1 # Variable c_int
DV_E_STGMEDIUM = -2147221402 # Variable c_long
CO_E_SERVER_STOPPING = -2146959352 # Variable c_long
WM_SETFOCUS = 7 # Variable c_int
CRYPT_E_INVALID_X500_STRING = -2146885597 # Variable c_long
CLIPBRD_E_LAST = 2147746271 # Variable c_ulong
SPAPI_E_BAD_SECTION_NAME_LINE = -2146500607 # Variable c_long
SERVICE_RECOGNIZER_DRIVER = 8 # Variable c_int
WDT_INPROC_CALL = 1215587415 # Variable c_int
LVHT_NOWHERE = 1 # Variable c_int
SYSTEM_FLAG_DISKLESS_CLIENT = 2 # Variable c_int
SPI_SETMINIMIZEDMETRICS = 44 # Variable c_int
RB_SETPARENT = 1031 # Variable c_int
ERROR_NETNAME_DELETED = 64 # Variable c_long
MF_DELETE = 512 # Variable c_long
chx1 = 1040 # Variable c_int
PRINTER_NOTIFY_FIELD_PORT_NAME = 3 # Variable c_int
WH_CALLWNDPROC = 4 # Variable c_int
CAL_GREGORIAN_XLIT_FRENCH = 12 # Variable c_int
XST_UNADVACKRCVD = 14 # Variable c_int
FILE_GENERIC_READ = 1179785 # Variable c_long
SHIFT_PRESSED = 16 # Variable c_int
IMAGE_REL_PPC_IFGLUE = 13 # Variable c_int
LOCALE_SLONGDATE = 32 # Variable c_int
MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC = 4101 # Variable c_long
CFSTR_MIME_X_REALAUDIO = 'audio/x-pn-realaudio' # Variable POINTER(c_wchar)
EMR_SETVIEWPORTORGEX = 12 # Variable c_int
PD_SHOWHELP = 2048 # Variable c_int
ERROR_NOT_SUPPORTED = 50 # Variable c_long
FILE_CASE_PRESERVED_NAMES = 2 # Variable c_int
JOB_OBJECT_UILIMIT_EXITWINDOWS = 128 # Variable c_int
LOCALE_IOPTIONALCALENDAR = 4107 # Variable c_int
chx7 = 1046 # Variable c_int
TRACKBAR_CLASSA = 'msctls_trackbar32' # Variable POINTER(c_char)
IE_OPEN = -2 # Variable c_int
CBEN_DELETEITEM = 4294966494 # Variable c_uint
WMSZ_BOTTOMLEFT = 7 # Variable c_int
WAVERR_LASTERROR = 35 # Variable c_int
SCALINGFACTORY = 115 # Variable c_int
DMPAPER_ENV_ITALY = 36 # Variable c_int
PRINTER_EXECUTE = 131080 # Variable c_long
PI_FORCE_ASYNC = 4
MIIM_TYPE = 16 # Variable c_int
WH_MAX = 12 # Variable c_int
MCI_FORMAT_SMPTE_30DROP = 7 # Variable c_int
REMOTE_NAME_INFO_LEVEL = 2 # Variable c_int
XST_POKEACKRCVD = 8 # Variable c_int
ERROR_BAD_DRIVER_LEVEL = 119 # Variable c_long
E_NOTIMPL = -2147467263 # Variable c_long
QS_ALLINPUT = 255 # Variable c_int
IPPORT_FINGER = 79 # Variable c_int
WM_USERCHANGED = 84 # Variable c_int
TYPE_E_CANTLOADLIBRARY = -2147312566 # Variable c_long
CDERR_NOHINSTANCE = 4 # Variable c_int
REFERENCE_WHITE_MAX = 10000 # Variable c_ushort
TVS_LINESATROOT = 4 # Variable c_int
INHERITED_ACE = 16 # Variable c_int
MIXERLINE_TARGETTYPE_AUX = 5 # Variable c_int
TYSPEC_TYPELIB = 5
IMAGE_SYM_TYPE_CHAR = 2 # Variable c_int
VIEW_PARENTFOLDER = 8 # Variable c_int
SRCPAINT = 15597702 # Variable c_ulong
TCS_MULTISELECT = 4 # Variable c_int
NM_KILLFOCUS = 4294967288 # Variable c_uint
IPPORT_NAMESERVER = 42 # Variable c_int
RBHT_CLIENT = 3 # Variable c_int
IGNORE = 0 # Variable c_int
ERROR_SEEK_ON_DEVICE = 132 # Variable c_long
TBIF_SIZE = 64 # Variable c_int
PSBTN_APPLYNOW = 4 # Variable c_int
TC_IA_ABLE = 1024 # Variable c_int
RPC_S_SERVER_UNAVAILABLE = 1722 # Variable c_long
WM_DDE_INITIATE = 992 # Variable c_int
ERROR_CANT_RESOLVE_FILENAME = 1921 # Variable c_long
MIDIERR_DONT_CONTINUE = 71 # Variable c_int
RPCFLG_LOCAL_CALL = 268435456 # Variable c_ulong
META_FLOODFILL = 1049 # Variable c_int
ERROR_ACCOUNT_LOCKED_OUT = 1909 # Variable c_long
CLASS_E_CLASSNOTAVAILABLE = -2147221231 # Variable c_long
BM_SETSTYLE = 244 # Variable c_int
WS_OVERLAPPEDWINDOW = 13565952 # Variable c_long
JOB_NOTIFY_FIELD_START_TIME = 17 # Variable c_int

__MIDL_IInternetZoneManager_0002 = c_int # enum
ZAFLAGS_CUSTOM_EDIT = 1
ZAFLAGS_ADD_SITES = 2
ZAFLAGS_REQUIRE_VERIFICATION = 4
ZAFLAGS_INCLUDE_PROXY_OVERRIDE = 8
ZAFLAGS_INCLUDE_INTRANET_SITES = 16
ZAFLAGS_SUPPORTS_VERIFICATION = 64
ZAFLAGS_UNC_AS_INTRANET = 128
IPPORT_DISCARD = 9 # Variable c_int
ERROR_CANNOT_COPY = 266 # Variable c_long
REGDB_E_LAST = 2147746143 # Variable c_ulong
SUBLANG_ENGLISH_US = 1 # Variable c_int
PST_PARALLELPORT = 2 # Variable c_ulong
CBEM_SETEXSTYLE = 1032 # Variable c_int
PFD_DRAW_TO_WINDOW = 4 # Variable c_int
BN_UNHILITE = 3 # Variable c_int
MEM_E_INVALID_ROOT = -2146959351 # Variable c_long
RPC_S_ADDRESS_ERROR = 1768 # Variable c_long
PAGE_EXECUTE = 16 # Variable c_int
HELPINFO_MENUITEM = 2 # Variable c_int
MCI_NOTIFY_SUCCESSFUL = 1 # Variable c_int
WM_IME_SELECT = 645 # Variable c_int
MH_CREATE = 1 # Variable c_int
MAXINT_PTR = 2147483647 # Variable c_long
WM_MDISETMENU = 560 # Variable c_int

VARENUM = c_int # enum
VT_NULL = 1
VT_I2 = 2
VT_I4 = 3
VT_R4 = 4
VT_R8 = 5
VT_CY = 6
VT_BSTR = 8
VT_DISPATCH = 9
VT_ERROR = 10
VT_BOOL = 11
VT_VARIANT = 12
VT_UNKNOWN = 13
VT_DECIMAL = 14
VT_I1 = 16
VT_UI1 = 17
VT_VOID = 24
VT_FILETIME = 64
VT_BLOB = 65
VT_STREAM = 66
VT_STORAGE = 67
VT_STORED_OBJECT = 69
VT_BLOB_OBJECT = 70
VT_CF = 71
VT_CLSID = 72
VT_VECTOR = 4096
VT_ARRAY = 8192
VT_BYREF = 16384
VT_RESERVED = 32768
VT_ILLEGAL = 65535
VT_ILLEGALMASKED = 4095
VT_TYPEMASK = 4095
ERROR_DEVICE_NOT_AVAILABLE = 4319 # Variable c_long
XST_ADVACKRCVD = 13 # Variable c_int
SPI_SETKEYBOARDSPEED = 11 # Variable c_int
DMPAPER_A4_TRANSVERSE = 55 # Variable c_int
PRINTER_STATUS_ERROR = 2 # Variable c_int
HIDE_WINDOW = 0 # Variable c_int
CC_ENABLEHOOK = 16 # Variable c_int
CONVERT10_E_FIRST = 2147746240 # Variable c_ulong
ERROR_USER_MAPPED_FILE = 1224 # Variable c_long
lst14 = 1133 # Variable c_int
LVN_FIRST = 4294967196 # Variable c_uint
IGP_PROPERTY = 4 # Variable c_int
SECURITY_LOCAL_SYSTEM_RID = 18 # Variable c_long
FF_DONTCARE = 0 # Variable c_int
RB_GETBANDCOUNT = 1036 # Variable c_int
LOCALE_INEGSEPBYSPACE = 87 # Variable c_int
IDI_ASTERISK = 206102 # Variable POINTER(c_wchar)
NONANTIALIASED_QUALITY = 3 # Variable c_int
TVM_GETITEMRECT = 4356 # Variable c_int
CTRL_CLOSE_EVENT = 2 # Variable c_int
PGK_MENU = 4 # Variable c_int
WHITEONBLACK = 2 # Variable c_int
PAN_BENT_ARMS_VERT = 9 # Variable c_int
RESETDEV = 7 # Variable c_int
FOF_SIMPLEPROGRESS = 256 # Variable c_int
OF_READ = 0 # Variable c_int
IDH_HELP = 28445 # Variable c_int
MM_WOM_OPEN = 955 # Variable c_int
SERVICE_STATE_ALL = 3 # Variable c_int
CO_E_MSI_ERROR = -2147467229 # Variable c_long
EASTEUROPE_CHARSET = 238 # Variable c_int
SBM_GETRANGE = 227 # Variable c_int
ERROR_BUSY = 170 # Variable c_long
STG_LAYOUT_INTERLEAVED = 1 # Variable c_long
TCS_FOCUSONBUTTONDOWN = 4096 # Variable c_int
TBN_QUERYDELETE = 4294966589 # Variable c_uint
VOS_OS232 = 196608 # Variable c_long
CLIPBRD_E_FIRST = 2147746256 # Variable c_ulong
ACTFLG_RunOnce = 2 # Variable c_int
DMLERR_LOW_MEMORY = 16391 # Variable c_int
EMR_POLYBEZIERTO16 = 88 # Variable c_int
CTRY_INDIA = 91 # Variable c_int
IO_COMPLETION_MODIFY_STATE = 2 # Variable c_int
CONNDLG_CONN_POINT = 2 # Variable c_int
SB_SIMPLE = 1033 # Variable c_int
MIXERLINE_COMPONENTTYPE_DST_TELEPHONE = 6 # Variable c_long
WM_NCLBUTTONDOWN = 161 # Variable c_int
VAR_LOCALBOOL = 16 # Variable c_ulong
IMAGE_SCN_MEM_WRITE = 2147483648 # Variable c_uint
FILE_WRITE_ATTRIBUTES = 256 # Variable c_int
CERT_E_EXPIRED = -2146762495 # Variable c_long
GCS_RESULTREADSTR = 512 # Variable c_int
PAN_XHEIGHT_INDEX = 9 # Variable c_int
RPC_S_NOT_ALL_OBJS_UNEXPORTED = 1758 # Variable c_long
LVM_SETITEMPOSITION = 4111 # Variable c_int
CUDR_NOCLOSEGAPS = 4 # Variable c_int
TB_ADDSTRINGW = 1101 # Variable c_int
ERROR_SIGNAL_PENDING = 162 # Variable c_long
SPLDS_UNC_NAME = 'uNCName' # Variable POINTER(c_wchar)
IMAGE_SYM_CLASS_UNION_TAG = 12 # Variable c_int
PGN_CALCSIZE = 4294966394 # Variable c_uint
TCIF_IMAGE = 2 # Variable c_int
WM_CAPTURECHANGED = 533 # Variable c_int
DFCS_SCROLLLEFT = 2 # Variable c_int
PSIDENT_GDICENTRIC = 0 # Variable c_int
JOYERR_BASE = 160 # Variable c_int
MDM_CCITT_OVERRIDE = 64 # Variable c_int
PRINTER_ENUM_NETWORK = 64 # Variable c_int
NRC_SABORT = 24 # Variable c_int
MF_APPEND = 256 # Variable c_long
SS_ICON = 3 # Variable c_long
MIXERLINE_COMPONENTTYPE_SRC_LINE = 4098 # Variable c_long
PRINTER_STATUS_POWER_SAVE = 16777216 # Variable c_int
MEM_DECOMMIT = 16384 # Variable c_int
WC_LISTVIEWA = 'SysListView32' # Variable POINTER(c_char)
SC_GROUP_IDENTIFIERW = '+' # Variable c_wchar
ODS_FOCUS = 16 # Variable c_int
ERROR_INVALID_FIELD = 1616 # Variable c_long
WM_DISPLAYCHANGE = 126 # Variable c_int
FNOINVERT = 2 # Variable c_int
RPC_C_STATS_PKTS_OUT = 3 # Variable c_int
IN_CLASSB_NET = 4294901760 # Variable c_uint
LANG_SANSKRIT = 79 # Variable c_int
PSD_DISABLEPAGEPAINTING = 524288 # Variable c_int
SUBLANG_SPANISH_EL_SALVADOR = 17 # Variable c_int
SPAPI_E_INVALID_CLASS_INSTALLER = -2146500083 # Variable c_long
MCI_ANIM_RECT = 65536 # Variable c_long
CBR_14400 = 14400 # Variable c_int
ERROR_NOT_REGISTRY_FILE = 1017 # Variable c_long
ERROR_INVALID_PASSWORD = 86 # Variable c_long
ERROR_INSTALL_SERVICE = 1601 # Variable c_long
ERROR_INSTALL_SOURCE_ABSENT = 1612 # Variable c_long
BATTERY_FLAG_UNKNOWN = 255 # Variable c_int
S_SERDVL = -9 # Variable c_int
DISPID_PROPERTYPUT = -3 # Variable c_int
TB_SETSTATE = 1041 # Variable c_int
RESOURCETYPE_PRINT = 2 # Variable c_int
DMPAPER_JAPANESE_POSTCARD = 43 # Variable c_int
IMAGE_COMDAT_SELECT_ASSOCIATIVE = 5 # Variable c_int
LB_GETCARETINDEX = 415 # Variable c_int
ICC_HOTKEY_CLASS = 64 # Variable c_int
CC_PIE = 2 # Variable c_int
TBSTYLE_NOPREFIX = 32 # Variable c_int
MCIERR_DEVICE_LOCKED = 288 # Variable c_int
IMAGE_COMDAT_SELECT_EXACT_MATCH = 4 # Variable c_int
MEM_PRIVATE = 131072 # Variable c_int
CAL_HIJRI = 6 # Variable c_int
SE_DACL_PROTECTED = 4096 # Variable c_int
IMAGE_REL_I386_SECREL = 11 # Variable c_int
PBM_STEPIT = 1029 # Variable c_int
CDM_SETDEFEXT = 1130 # Variable c_int
SB_PAGERIGHT = 3 # Variable c_int
WEOF = '\uffff' # Variable c_wchar
MOD_CONTROL = 2 # Variable c_int
CREATE_NEW_PROCESS_GROUP = 512 # Variable c_int
STG_E_LOCKVIOLATION = -2147287007 # Variable c_long
IOC_INOUT = 3221225472 # Variable c_uint
TAPE_DRIVE_TENSION_IMMED = 2147483712 # Variable c_uint
QDI_DIBTOSCREEN = 4 # Variable c_int
MCI_SAVE = 2067 # Variable c_int
CURVECAPS = 28 # Variable c_int
IMN_PRIVATE = 14 # Variable c_int
NCBSENDNA = 113 # Variable c_int
VFT_APP = 1 # Variable c_long
ERROR_BAD_DEVICE = 1200 # Variable c_long
COLOR_MENUTEXT = 7 # Variable c_int
TA_RTLREADING = 256 # Variable c_int
CERTSRV_E_PROPERTY_EMPTY = -2146877436 # Variable c_long
ETO_GLYPH_INDEX = 16 # Variable c_int

tagSYSKIND = c_int # enum
SYS_WIN16 = 0
SYS_WIN32 = 1
SYS_MAC = 2
STATUS_ABANDONED_WAIT_0 = 128 # Variable c_ulong
RPC_E_CLIENT_DIED = -2147418104 # Variable c_long
NLS_ALPHANUMERIC = 0 # Variable c_int
PERF_OBJECT_TIMER = 2097152 # Variable c_int
CTRL_C_EVENT = 0 # Variable c_int
WS_MAXIMIZE = 16777216 # Variable c_long
cmb15 = 1150 # Variable c_int
LOGON32_LOGON_NETWORK = 3 # Variable c_int
JOY_BUTTON19 = 262144 # Variable c_long
STDOLE2_LCID = 0 # Variable c_int
VAR_VALIDDATE = 4 # Variable c_ulong
HKEY_DYN_DATA = 2147483654 # Variable POINTER(HKEY__)
CO_E_INIT_SCM_MAP_VIEW_OF_FILE = -2147467248 # Variable c_long
PD_DISABLEPRINTTOFILE = 524288 # Variable c_int
JOY_POVCENTERED = 65535 # Variable c_ushort
OBJ_EXTPEN = 11 # Variable c_int
COLOR_WINDOW = 5 # Variable c_int
SPAPI_E_DUPLICATE_FOUND = -2146500094 # Variable c_long
GHND = 66 # Variable c_int
STATUS_INVALID_HANDLE = 3221225480 # Variable c_ulong
SM_CXMAXIMIZED = 61 # Variable c_int
LB_GETITEMRECT = 408 # Variable c_int
CONNECT_RESERVED = 4278190080 # Variable c_uint
VER_PLATFORM_WIN32_NT = 2 # Variable c_int
PRINTER_STATUS_INITIALIZING = 32768 # Variable c_int
SM_SWAPBUTTON = 23 # Variable c_int
CERT_E_VALIDITYPERIODNESTING = -2146762494 # Variable c_long
FSB_REGULAR_MODE = 0 # Variable c_int
ANSI_FIXED_FONT = 11 # Variable c_int
MCI_WAVE_SET_SAMPLESPERSEC = 262144 # Variable c_long
THREAD_PRIORITY_NORMAL = 0 # Variable c_int
WINSTA_ACCESSGLOBALATOMS = 32 # Variable c_long
MCI_DEVTYPE_DAT = 517 # Variable c_int
PRINTER_STATUS_NOT_AVAILABLE = 4096 # Variable c_int
ERROR_SUCCESS = 0 # Variable c_long
MK_E_NOINVERSE = -2147221012 # Variable c_long
PD_HIDEPRINTTOFILE = 1048576 # Variable c_int
RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE = 7 # Variable c_int
UNICODE = 1 # Variable c_int
GDI_ERROR = 4294967295 # Variable c_ulong
LVS_EX_ONECLICKACTIVATE = 64 # Variable c_int
SS_RIGHT = 2 # Variable c_long
CCHFORMNAME = 32 # Variable c_int

__MIDL_IInternetSecurityManager_0001 = c_int # enum
PUAF_DEFAULT = 0
PUAF_NOUI = 1
PUAF_ISFILE = 2
PUAF_WARN_IF_DENIED = 4
PUAF_FORCEUI_FOREGROUND = 8
PUAF_CHECK_TIFS = 16
ERROR_DEPENDENT_SERVICES_RUNNING = 1051 # Variable c_long
STATUS_ILLEGAL_INSTRUCTION = 3221225501 # Variable c_ulong
ERROR_UNKNOWN_PRINTER_DRIVER = 1797 # Variable c_long
PAN_STROKE_RAPID_VERT = 6 # Variable c_int
LMEM_FIXED = 0 # Variable c_int
WM_CHARTOITEM = 47 # Variable c_int
TCM_REMOVEIMAGE = 4906 # Variable c_int
PM_REMOVE = 1 # Variable c_int
FONTMAPPER_MAX = 10 # Variable c_int
RIGHT_ALT_PRESSED = 1 # Variable c_int
DrwFilePath = 5
RPC_E_INVALIDMETHOD = -2147417849 # Variable c_long
ATTR_TARGET_CONVERTED = 1 # Variable c_int
UPDFCACHE_ONSAVECACHE = 2 # Variable c_int
SORT_HUNGARIAN_DEFAULT = 0 # Variable c_int
FIONBIO = 2147772030 # Variable c_ulong
TRUST_E_BASIC_CONSTRAINTS = -2146869223 # Variable c_long
stc19 = 1106 # Variable c_int
PAN_SERIF_TRIANGLE = 10 # Variable c_int
RB_ENDDRAG = 1049 # Variable c_int
ERROR_PASSWORD_EXPIRED = 1330 # Variable c_long
EV_TXEMPTY = 4 # Variable c_int
MENU_EVENT = 8 # Variable c_int
PROCESS_CREATE_THREAD = 2 # Variable c_int
ERROR_SHARING_PAUSED = 70 # Variable c_long
SE_UNSOLICITED_INPUT_NAME = 'SeUnsolicitedInputPrivilege' # Variable POINTER(c_wchar)
TBSTYLE_FLAT = 2048 # Variable c_int

__MIDL_IInternetSecurityManager_0002 = c_int # enum
JOB_NOTIFY_FIELD_UNTIL_TIME = 18 # Variable c_int
E_ABORT = -2147467260 # Variable c_long
TB_MOVEBUTTON = 1106 # Variable c_int
SM_CYICON = 12 # Variable c_int
LVM_FINDITEMA = 4109 # Variable c_int
FINDMSGSTRINGA = 'commdlg_FindReplace' # Variable POINTER(c_char)
DMICM_USER = 256 # Variable c_int
FileSystemType = 2
PSH_USEHPLWATERMARK = 131072 # Variable c_int
ERROR_SECRET_TOO_LONG = 1382 # Variable c_long
REFERENCE_BLACK_MAX = 4000 # Variable c_ushort
SERVICE_CONTROL_PARAMCHANGE = 6 # Variable c_int
TAPE_DRIVE_ERASE_SHORT = 16 # Variable c_int
EMR_EXTTEXTOUTW = 84 # Variable c_int
LOCALE_SNATIVEDIGITS = 19 # Variable c_int
ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE = 5033 # Variable c_long
TVIF_CHILDREN = 64 # Variable c_int
DMBIN_CASSETTE = 14 # Variable c_int
VS_VERSION_INFO = 1 # Variable c_int
RPC_S_NO_ENTRY_NAME = 1735 # Variable c_long
CDDS_ITEMPREERASE = 65539 # Variable c_int
IDH_MISSING_CONTEXT = 28441 # Variable c_int
INET_E_REDIRECTING = -2146697196 # Variable c_long
IO_REPARSE_TAG_VALID_VALUES = 3758161919 # Variable c_uint
LPD_SHARE_DEPTH = 64 # Variable c_int
SCALINGFACTORX = 114 # Variable c_int
PSBTN_HELP = 6 # Variable c_int
DMDISPLAYFLAGS_TEXTMODE = 4 # Variable c_int
RGN_AND = 1 # Variable c_int
PI_USE_WORKERTHREAD = 8
WS_MINIMIZEBOX = 131072 # Variable c_long
CREATE_NO_WINDOW = 134217728 # Variable c_int
CTRY_UNITED_KINGDOM = 44 # Variable c_int
IMAGE_SYM_ABSOLUTE = -1 # Variable c_short
SWP_NOACTIVATE = 16 # Variable c_int
BF_BOTTOM = 8 # Variable c_int
VK_LMENU = 164 # Variable c_int
NRC_INVADDRESS = 57 # Variable c_int
SC_PREVWINDOW = 61520 # Variable c_int
DMPAPER_A4SMALL = 10 # Variable c_int
LBS_MULTIPLESEL = 8 # Variable c_long
SOFTDIST_ADSTATE_NONE = 0 # Variable c_int
LTGRAY_BRUSH = 1 # Variable c_int
DMPAPER_B4 = 12 # Variable c_int
ENDSESSION_LOGOFF = 2147483648 # Variable c_uint
COMPRESSION_FORMAT_DEFAULT = 1 # Variable c_int
VK_F21 = 132 # Variable c_int
WM_DDE_ADVISE = 994 # Variable c_int
PSBTN_BACK = 0 # Variable c_int
ERROR_TOO_MANY_SESS = 69 # Variable c_long
IDC_ARROW = 206098 # Variable POINTER(c_wchar)
IMAGE_REL_PPC_ADDR32NB = 10 # Variable c_int
IME_CMODE_ALPHANUMERIC = 0 # Variable c_int
LOCALE_SMONTHNAME6 = 61 # Variable c_int
CAL_SMONTHNAME7 = 27 # Variable c_int
ERROR_REC_NON_EXISTENT = 4005 # Variable c_long
EMR_CREATECOLORSPACE = 99 # Variable c_int
PRINTER_ATTRIBUTE_ENABLE_BIDI = 2048 # Variable c_int
VOS__PM16 = 2 # Variable c_long
RPC_C_CANCEL_INFINITE_TIMEOUT = -1 # Variable c_int
RDW_NOFRAME = 2048 # Variable c_int
STG_E_TERMINATED = -2147286526 # Variable c_long
RBN_FIRST = 4294966465 # Variable c_uint
NTE_EXISTS = -2146893809 # Variable c_long
RB_SIZETORECT = 1047 # Variable c_int
ERROR_NOT_ENOUGH_QUOTA = 1816 # Variable c_long
DTM_GETMONTHCAL = 4104 # Variable c_int
STD_FILENEW = 6 # Variable c_int
FO_COPY = 2 # Variable c_int
MK_E_LAST = 2147746287 # Variable c_ulong
VK_MENU = 18 # Variable c_int
HDS_FULLDRAG = 128 # Variable c_int
MMSYSERR_VALNOTFOUND = 19 # Variable c_int
GGO_BITMAP = 1 # Variable c_int
ABE_RIGHT = 2 # Variable c_int
PAN_WEIGHT_LIGHT = 3 # Variable c_int
CB_DELETESTRING = 324 # Variable c_int

LATENCY_TIME = c_int # enum
LT_DONT_CARE = 0
LT_LOWEST_LATENCY = 1
TBN_TOOLBARCHANGE = 4294966588 # Variable c_uint
CTRY_AUSTRIA = 43 # Variable c_int
LOCALE_SMONDECIMALSEP = 22 # Variable c_int
CREATE_SHARED_WOW_VDM = 4096 # Variable c_int
IMAGE_SYM_TYPE_FLOAT = 6 # Variable c_int
IMAGE_OS2_SIGNATURE_LE = 17740 # Variable c_int
COLOR_ACTIVEBORDER = 10 # Variable c_int
R2_NOT = 6 # Variable c_int
MFCOMMENT = 15 # Variable c_int
CTRY_BRUNEI_DARUSSALAM = 673 # Variable c_int
WNNC_NET_MSNET = 65536 # Variable c_int
ERROR_NO_MATCH = 1169 # Variable c_long
IMAGE_RESOURCE_NAME_IS_STRING = 2147483648 # Variable c_uint
TTM_SETTOOLINFOW = 1078 # Variable c_int
SBM_ENABLE_ARROWS = 228 # Variable c_int
SM_CMETRICS = 76 # Variable c_int
EMR_LINETO = 54 # Variable c_int
EN_UPDATE = 1024 # Variable c_int
EM_LIMITTEXT = 197 # Variable c_int
MCI_VD_STEP_REVERSE = 131072 # Variable c_long
WM_RENDERFORMAT = 773 # Variable c_int
PSH_WIZARD97 = 8192 # Variable c_int
JOY_BUTTON4CHG = 2048 # Variable c_int
PFD_STEREO = 2 # Variable c_int
PO_REN_PORT = 52 # Variable c_int
TBSTYLE_DROPDOWN = 8 # Variable c_int
FLI_GLYPHS = 262144 # Variable c_long
ERROR_RPL_NOT_ALLOWED = 4006 # Variable c_long
PRINTER_NOTIFY_FIELD_STATUS = 18 # Variable c_int
WM_DDE_REQUEST = 998 # Variable c_int
LV_MAX_WORKAREAS = 16 # Variable c_int
PAN_LETT_OBLIQUE_ROUNDED = 13 # Variable c_int
TTM_NEWTOOLRECTW = 1076 # Variable c_int
SM_CXSMICON = 49 # Variable c_int
CBENF_KILLFOCUS = 1 # Variable c_int
LB_SETITEMHEIGHT = 416 # Variable c_int
NTE_BAD_ALGID = -2146893816 # Variable c_long
UDS_ARROWKEYS = 32 # Variable c_int
PROCESSOR_ALPHA_21064 = 21064 # Variable c_int
MSGF_MESSAGEBOX = 1 # Variable c_int
CRYPT_E_ATTRIBUTES_MISSING = -2146889713 # Variable c_long
LBS_EXTENDEDSEL = 2048 # Variable c_long
DRAFTMODE = 7 # Variable c_int
RPC_IF_AUTOLISTEN = 1 # Variable c_int
CTRY_ARGENTINA = 54 # Variable c_int
NRC_INUSE = 22 # Variable c_int
ERROR_SPL_NO_STARTDOC = 3003 # Variable c_long
CCS_BOTTOM = 3 # Variable c_long
SUBLANG_SPANISH_ARGENTINA = 11 # Variable c_int
RBBIM_LPARAM = 1024 # Variable c_int
ST_BLOCKNEXT = 128 # Variable c_int
PSINJECT_PSADOBE = 1 # Variable c_int
ERROR_GEN_FAILURE = 31 # Variable c_long
DC_MODEL = 24 # Variable c_int
LMEM_NOCOMPACT = 16 # Variable c_int
HALFTONE = 4 # Variable c_int
TIMER_MODIFY_STATE = 2 # Variable c_int
SS_ENDELLIPSIS = 16384 # Variable c_long
STG_E_SEEKERROR = -2147287015 # Variable c_long
ANSI_CHARSET = 0 # Variable c_int
PRINTER_ATTRIBUTE_QUEUED = 1 # Variable c_int
STG_E_INVALIDFUNCTION = -2147287039 # Variable c_long
SPI_SETLOWPOWERACTIVE = 85 # Variable c_int
TKF_AVAILABLE = 2 # Variable c_int
LR_DEFAULTCOLOR = 0 # Variable c_int
RB_MINIMIZEBAND = 1054 # Variable c_int
PGF_GRAYED = 2 # Variable c_int
MMIO_DEFAULTBUFFER = 8192 # Variable c_int
PIPE_ACCESS_INBOUND = 1 # Variable c_int
LVN_ENDLABELEDITW = 4294967120 # Variable c_uint
DOMAIN_GROUP_RID_ADMINS = 512 # Variable c_long
ERROR_NESTING_NOT_ALLOWED = 215 # Variable c_long
RTS_CONTROL_HANDSHAKE = 2 # Variable c_int
ACCESS_MIN_MS_ACE_TYPE = 0 # Variable c_int
BINDSTRING_ACCEPT_MIMES = 2
LVS_OWNERDATA = 4096 # Variable c_int
URLACTION_SHELL_FILE_DOWNLOAD = 6147 # Variable c_int
COLOR_WINDOWFRAME = 6 # Variable c_int
APPCMD_MASK = 4080 # Variable c_long
LZERROR_UNKNOWNALG = -8 # Variable c_int
FOURCC_MEM = 541934925 # Variable c_ulong
CERT_E_ISSUERCHAINING = -2146762489 # Variable c_long
OFN_EXPLORER = 524288 # Variable c_int
TBSTYLE_CUSTOMERASE = 8192 # Variable c_int
IE_HARDWARE = -10 # Variable c_int
MDMSPKRFLAG_DIAL = 2 # Variable c_int
WM_WINDOWPOSCHANGING = 70 # Variable c_int
GCP_MAXEXTENT = 1048576 # Variable c_long
VIF_SHARINGVIOLATION = 1024 # Variable c_long
PAN_SERIF_COVE = 2 # Variable c_int
VIEW_SORTDATE = 6 # Variable c_int
LOCALE_SLANGUAGE = 2 # Variable c_int
WM_NEXTMENU = 531 # Variable c_int
WIN_CERT_REVISION_1_0 = 256 # Variable c_int
URLACTION_SCRIPT_MIN = 5120 # Variable c_int
LVHT_BELOW = 16 # Variable c_int
CO_E_OLE1DDE_DISABLED = -2147467242 # Variable c_long
LVM_GETTEXTCOLOR = 4131 # Variable c_int
IME_ESC_SEQUENCE_TO_INTERNAL = 4097 # Variable c_int
LANG_ITALIAN = 16 # Variable c_int
IDB_STD_SMALL_COLOR = 0 # Variable c_int
IMAGE_COMDAT_SELECT_NODUPLICATES = 1 # Variable c_int
C3_HALFWIDTH = 64 # Variable c_int
LVM_SETCALLBACKMASK = 4107 # Variable c_int
DRV_EXITSESSION = 11 # Variable c_int
TTM_GETTIPTEXTCOLOR = 1047 # Variable c_int
HDN_ITEMCHANGEDW = 4294966975 # Variable c_uint
NRC_NOCALL = 20 # Variable c_int
WC_NATIVEFONTCTLW = 'NativeFontCtl' # Variable POINTER(c_wchar)
TCN_SELCHANGE = 4294966745 # Variable c_uint
ERROR_WRONG_PASSWORD = 1323 # Variable c_long
NCBDELNAME = 49 # Variable c_int
QS_INPUT = 7 # Variable c_int
RBN_AUTOSIZE = 4294966462 # Variable c_uint
SM_MIDEASTENABLED = 74 # Variable c_int
PERF_DELTA_BASE = 8388608 # Variable c_int
S_PERIOD2048 = 2 # Variable c_int
ARW_STARTRIGHT = 1 # Variable c_long
RPC_C_PROTSEQ_MAX_REQS_DEFAULT = 10 # Variable c_int
WS_EX_APPWINDOW = 262144 # Variable c_long
SCS_SETRECONVERTSTRING = 65536 # Variable c_int
MIDI_UNCACHE = 4 # Variable c_int
JOY_BUTTON11 = 1024 # Variable c_long
ERROR_IS_JOIN_TARGET = 133 # Variable c_long
WH_MIN = -1 # Variable c_int
ACCESS_MAX_MS_V4_ACE_TYPE = 8 # Variable c_int
TCHT_ONITEMLABEL = 4 # Variable c_int
LR_LOADMAP3DCOLORS = 4096 # Variable c_int
PROP_MED_CXDLG = 227 # Variable c_int
GDICOMMENT_BEGINGROUP = 2 # Variable c_int
IDH_GENERIC_HELP_BUTTON = 28442 # Variable c_int
NRC_INCOMP = 6 # Variable c_int
ERROR_NOT_CONTAINER = 1207 # Variable c_long
SIMULATED_FONTTYPE = 32768 # Variable c_int
DLGC_HASSETSEL = 8 # Variable c_int
JOY_CAL_READRONLY = 33554432 # Variable c_long
SPLDS_DRIVER_VERSION = 'driverVersion' # Variable POINTER(c_wchar)
CP_NONE = 0 # Variable c_int
MCI_LOAD_FILE = 256 # Variable c_long
PSINJECT_SHOWPAGE = 12 # Variable c_int
TAPE_INITIATOR_PARTITIONS = 2 # Variable c_long
HKM_SETHOTKEY = 1025 # Variable c_int
EMR_POLYDRAW16 = 92 # Variable c_int
PS_ENDCAP_SQUARE = 256 # Variable c_int
XTYP_REGISTER = 32930 # Variable c_int
LOCALE_ITIMEMARKPOSN = 4101 # Variable c_int
META_SETTEXTALIGN = 302 # Variable c_int
GCL_REVERSECONVERSION = 2 # Variable c_int
_OUT_TO_DEFAULT = 0 # Variable c_int
SW_HIDE = 0 # Variable c_int
CTRY_LEBANON = 961 # Variable c_int
PAN_PROP_OLD_STYLE = 2 # Variable c_int
PAN_STROKEVARIATION_INDEX = 5 # Variable c_int
LPD_DOUBLEBUFFER = 1 # Variable c_int
SPI_GETWORKAREA = 48 # Variable c_int
WSB_PROP_CYHSCROLL = 4 # Variable c_long
RPC_S_NO_PRINC_NAME = 1822 # Variable c_long
SERVER_READ = 131074 # Variable c_long
SB_GETTEXTLENGTHA = 1027 # Variable c_int
PFD_DOUBLEBUFFER_DONTCARE = 1073741824 # Variable c_int
LPTx = 128 # Variable c_int
ERROR_NETLOGON_NOT_STARTED = 1792 # Variable c_long
CCS_VERT = 128 # Variable c_long
SPI_GETFILTERKEYS = 50 # Variable c_int
VK_MODECHANGE = 31 # Variable c_int
WGL_SWAP_UNDERLAY10 = 33554432 # Variable c_int

tagDCOM_CALL_STATE = c_int # enum
CTRY_VENEZUELA = 58 # Variable c_int
ERROR_RESOURCE_NOT_PRESENT = 4316 # Variable c_long
PSN_QUERYCANCEL = 4294967087 # Variable c_uint
IMAGE_SCN_ALIGN_8BYTES = 4194304 # Variable c_int
IMAGE_COMDAT_SELECT_ANY = 2 # Variable c_int
CREATE_FOR_IMPORT = 1 # Variable c_int
ERROR_PATH_NOT_FOUND = 3 # Variable c_long
PORT_STATUS_NO_TONER = 6 # Variable c_int
ERROR_MR_MID_NOT_FOUND = 317 # Variable c_long
UPDOWN_CLASSA = 'msctls_updown32' # Variable POINTER(c_char)
PFD_GENERIC_ACCELERATED = 4096 # Variable c_int
IS_TEXT_UNICODE_ILLEGAL_CHARS = 256 # Variable c_int
IMAGE_FILE_SYSTEM = 4096 # Variable c_int
MIXER_SHORT_NAME_CHARS = 16 # Variable c_int
CO_E_CANT_REMOTE = -2147467245 # Variable c_long
BF_BOTTOMRIGHT = 12 # Variable c_int
RBS_AUTOSIZE = 8192 # Variable c_int
CTRY_HUNGARY = 36 # Variable c_int
GGL_STRING = 3 # Variable c_int
DNS_FILTERON = 4 # Variable c_int
IMAGE_REL_IA64_SECREL64I = 13 # Variable c_int
ERROR_UNKNOWN_FEATURE = 1606 # Variable c_long
LCID_SUPPORTED = 2 # Variable c_int
TIME_NOTIMEMARKER = 4 # Variable c_int
DISPLAY_DEVICE_VGA_COMPATIBLE = 16 # Variable c_int
WGL_SWAP_UNDERLAY3 = 262144 # Variable c_int
PAN_XHEIGHT_DUCKING_SMALL = 5 # Variable c_int
VOS_OS216_PM16 = 131074 # Variable c_long
MCI_FORMAT_SMPTE_30 = 6 # Variable c_int
EMR_PIXELFORMAT = 104 # Variable c_int
TVC_UNKNOWN = 0 # Variable c_int
SBS_LEFTALIGN = 2 # Variable c_long
SetupNamePath = 6
MEM_RELEASE = 32768 # Variable c_int
WAIT_OBJECT_0 = 0 # Variable c_ulong
IOC_VOID = 536870912 # Variable c_int
PARAMFLAG_FIN = 1 # Variable c_int
MCI_ANIM_WINDOW_TEXT = 524288 # Variable c_long
STG_TOEND = 4294967295 # Variable c_ulong
SW_MINIMIZE = 6 # Variable c_int
CACHE_E_FIRST = 2147746160 # Variable c_ulong
IMAGE_REL_ARM_SECTION = 14 # Variable c_int
CE_TXFULL = 256 # Variable c_int
FILE_ATTRIBUTE_REPARSE_POINT = 1024 # Variable c_int
MOUSE_EVENT = 2 # Variable c_int
_WIN32_IE = 1024 # Variable c_int
CBS_OWNERDRAWFIXED = 16 # Variable c_long
LVSICF_NOINVALIDATEALL = 1 # Variable c_int
ERROR_ALREADY_WAITING = 1904 # Variable c_long
APPLICATION_ERROR_MASK = 536870912 # Variable c_int
CO_E_RELEASED = -2147220993 # Variable c_long
GCL_HMODULE = -16 # Variable c_int
SS_BLACKRECT = 4 # Variable c_long
SE_SACL_PRESENT = 16 # Variable c_int
TCS_FOCUSNEVER = 32768 # Variable c_int
DISPID_CONSTRUCTOR = -6 # Variable c_int
SPI_GETLOWPOWERTIMEOUT = 79 # Variable c_int
MIXER_OBJECTF_HMIDIOUT = 2952790016 # Variable c_ulong
LVS_EX_HEADERDRAGDROP = 16 # Variable c_int
ERROR_INVALID_HANDLE = 6 # Variable c_long
PERF_COUNTER_LARGE_RAWCOUNT = 65792 # Variable c_int
RPC_C_IMP_LEVEL_IMPERSONATE = 3 # Variable c_int
NCBRECVANY = 22 # Variable c_int
RPC_C_MQ_AUTHN_LEVEL_NONE = 0 # Variable c_int
HDN_ITEMCHANGEDA = 4294966995 # Variable c_uint
ERROR_INVALID_VERIFY_SWITCH = 118 # Variable c_long
RPC_E_SERVER_DIED_DNE = -2147418094 # Variable c_long
cbNDRContext = 20 # Variable c_int
ACCESS_MAX_MS_V3_ACE_TYPE = 4 # Variable c_int
PURGE_TXCLEAR = 4 # Variable c_int
WS_MAXIMIZEBOX = 65536 # Variable c_long
TAPE_DRIVE_EOT_WZ_SIZE = 8192 # Variable c_int
PWR_FAIL = -1 # Variable c_int
WC_TABCONTROLW = 'SysTabControl32' # Variable POINTER(c_wchar)
NTE_BAD_SIGNATURE = -2146893818 # Variable c_long
LPTR = 64 # Variable c_int
HCBT_MINMAX = 1 # Variable c_int
ESB_DISABLE_RIGHT = 2 # Variable c_int
VIF_BUFFTOOSMALL = 262144 # Variable c_long
CFSTR_MIME_PDF = 'application/pdf' # Variable POINTER(c_wchar)
NTM_BOLD = 32 # Variable c_long
PI_MIMEVERIFICATION = 16
MCHT_PREV = 33554432 # Variable c_int
PAN_LETT_OBLIQUE_CONTACT = 9 # Variable c_int
LOCK_WRITE = 1
RBBIM_SIZE = 64 # Variable c_int
EMR_CREATEBRUSHINDIRECT = 39 # Variable c_int
PFD_SUPPORT_GDI = 16 # Variable c_int
MDM_FORCED_EC = 4 # Variable c_int
RDW_UPDATENOW = 256 # Variable c_int
LR_COPYRETURNORG = 4 # Variable c_int
GMEM_SHARE = 8192 # Variable c_int
RPC_S_INVALID_RPC_PROTSEQ = 1704 # Variable c_long
MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 16384 # Variable c_int
MCI_SEEK = 2055 # Variable c_int
PID_MODIFY_TIME = 2147483649 # Variable c_uint
PROCESSOR_ARCHITECTURE_ALPHA = 2 # Variable c_int
LVM_SETSELECTIONMARK = 4163 # Variable c_int
MIXER_SETCONTROLDETAILSF_CUSTOM = 1 # Variable c_long
EMARCH_ENC_I17_IC_INST_WORD_POS_X = 12 # Variable c_int
SB_SETPARTS = 1028 # Variable c_int
CBN_SELCHANGE = 1 # Variable c_int
OLEOBJ_E_INVALIDVERB = -2147221119 # Variable c_long
CFSTR_MIME_AVI = 'video/avi' # Variable POINTER(c_wchar)
URLACTION_ACTIVEX_MAX = 5119 # Variable c_int
PD_ENABLESETUPHOOK = 8192 # Variable c_int
CBN_KILLFOCUS = 4 # Variable c_int

tagINVOKEKIND = c_int # enum
INVOKE_FUNC = 1
INVOKE_PROPERTYGET = 2
INVOKE_PROPERTYPUT = 4
INVOKE_PROPERTYPUTREF = 8
FILE_FLAG_RANDOM_ACCESS = 268435456 # Variable c_int
WM_IME_CONTROL = 643 # Variable c_int
XST_REQSENT = 5 # Variable c_int
LOCALE_SMONTHNAME7 = 62 # Variable c_int
VK_LCONTROL = 162 # Variable c_int
MKSYS_URLMONIKER = 6 # Variable c_int
TBSTYLE_REGISTERDROP = 16384 # Variable c_int
MCI_BREAK = 2065 # Variable c_int
MMIOERR_UNBUFFERED = 266 # Variable c_int
ERROR_SERVICE_NOT_FOUND = 1243 # Variable c_long
TB_PAGEDOWN = 3 # Variable c_int
ERROR_SERVER_DISABLED = 1341 # Variable c_long
rad13 = 1068 # Variable c_int
RBNM_STYLE = 2 # Variable c_int
DFCS_BUTTONRADIOIMAGE = 1 # Variable c_int
IMAGE_REL_IA64_PCREL21M = 7 # Variable c_int
NM_HOVER = 4294967283 # Variable c_uint
SPI_SETLOWPOWERTIMEOUT = 81 # Variable c_int
LANG_SERBIAN = 26 # Variable c_int
BATTERY_PERCENTAGE_UNKNOWN = 255 # Variable c_int
QS_MOUSE = 6 # Variable c_int
CRYPT_E_UNEXPECTED_ENCODING = -2146889723 # Variable c_long
ERROR_WINS_INTERNAL = 4000 # Variable c_long
MCHT_CALENDARDATENEXT = 16908289 # Variable c_int
INPLACE_S_FIRST = 262560 # Variable c_long
DL_COPYCURSOR = 2 # Variable c_int
MDM_FLOWCONTROL_HARD = 16 # Variable c_int
SND_LOOP = 8 # Variable c_int
SE_ERR_DLLNOTFOUND = 32 # Variable c_int
LVFI_PARTIAL = 8 # Variable c_int
DISP_E_PARAMNOTOPTIONAL = -2147352561 # Variable c_long
CDRF_SKIPDEFAULT = 4 # Variable c_int
GCS_COMPSTR = 8 # Variable c_int
CB_ERR = -1 # Variable c_int
IMAGE_DEBUG_TYPE_UNKNOWN = 0 # Variable c_int
HCBT_ACTIVATE = 5 # Variable c_int
IPPORT_TELNET = 23 # Variable c_int
SPAPI_E_NO_ASSOCIATED_CLASS = -2146500096 # Variable c_long
LB_SETSEL = 389 # Variable c_int
ERROR_WINDOW_OF_OTHER_THREAD = 1408 # Variable c_long
PSD_DISABLEPRINTER = 32 # Variable c_int
TB_COMMANDTOINDEX = 1049 # Variable c_int
PROCESS_SET_INFORMATION = 512 # Variable c_int
TYPE_E_INVALIDID = -2147317553 # Variable c_long
WM_CONTEXTMENU = 123 # Variable c_int
MMIOERR_TOOMANYOPENFILES = 271 # Variable c_int
IMAGE_SYM_DTYPE_NULL = 0 # Variable c_int
VK_RWIN = 92 # Variable c_int
META_POLYGON = 804 # Variable c_int
LC_STYLED = 32 # Variable c_int
NRC_NOSAPS = 55 # Variable c_int
IGP_CONVERSION = 8 # Variable c_int
JOY_CAL_READ5 = 4194304 # Variable c_long
SM_CYSIZE = 31 # Variable c_int
WM_CTLCOLORDLG = 310 # Variable c_int
PRINTER_CHANGE_PRINTER_DRIVER = 1879048192 # Variable c_int
VK_DOWN = 40 # Variable c_int
E_ACCESSDENIED = -2147024891 # Variable c_long
SPLDS_PRINT_BIN_NAMES = 'printBinNames' # Variable POINTER(c_wchar)
CONNECT_DEFERRED = 1024 # Variable c_int
CRYPT_E_NO_TRUSTED_SIGNER = -2146885589 # Variable c_long
IMAGE_REL_BASED_HIGH3ADJ = 11 # Variable c_int
DTM_SETMCFONT = 4105 # Variable c_int
IS_TEXT_UNICODE_NOT_ASCII_MASK = 61440 # Variable c_int
MKF_CONFIRMHOTKEY = 8 # Variable c_int
WS_EX_CLIENTEDGE = 512 # Variable c_long
LANG_SWAHILI = 65 # Variable c_int
FNERR_INVALIDFILENAME = 12290 # Variable c_int
MM_MIXM_LINE_CHANGE = 976 # Variable c_int
WM_DDE_UNADVISE = 995 # Variable c_int
RPC_C_OPT_MQ_DELIVERY = 1 # Variable c_int
EV_RING = 256 # Variable c_int
STATUS_DATATYPE_MISALIGNMENT = 2147483650 # Variable c_ulong
VK_LBUTTON = 1 # Variable c_int
CO_E_EXCEEDSYSACLLIMIT = -2147220970 # Variable c_long
BACKUP_PROPERTY_DATA = 6 # Variable c_int
LVM_GETITEMSPACING = 4147 # Variable c_int
TTN_GETDISPINFOA = 4294966776 # Variable c_uint
SND_ALIAS_SYSTEMWELCOME = 22355 # Variable c_ulong
EMR_SETMAPMODE = 17 # Variable c_int
LANG_ENGLISH = 9 # Variable c_int
WGL_SWAP_OVERLAY12 = 4096 # Variable c_int
OFN_CREATEPROMPT = 8192 # Variable c_int
PAN_ANY = 0 # Variable c_int
HICF_MOUSE = 1 # Variable c_int
ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 201 # Variable c_long
TAPE_LOAD = 0 # Variable c_long
MIXERR_INVALLINE = 1024 # Variable c_int
MCI_SEQ_SET_SLAVE = 262144 # Variable c_long
WSAEPFNOSUPPORT = 10046 # Variable c_int
PGM_RECALCSIZE = 5122 # Variable c_int
VK_APPS = 93 # Variable c_int
WM_KEYFIRST = 256 # Variable c_int
URLOSTRM_USECACHEDCOPY_ONLY = 1 # Variable c_int
REG_OPTION_BACKUP_RESTORE = 4 # Variable c_long
MCI_SEQ_SET_PORT = 131072 # Variable c_long
MIXERCONTROL_CT_CLASS_CUSTOM = 0 # Variable c_long
frm4 = 1079 # Variable c_int
HANGUP_COMPLETE = 5 # Variable c_int
RB_HITTEST = 1032 # Variable c_int
_LEADBYTE = 32768 # Variable c_int
CTRY_CHILE = 56 # Variable c_int
RC_BITMAP64 = 8 # Variable c_int
TBM_GETTHUMBLENGTH = 1052 # Variable c_int
CDDS_PREERASE = 3 # Variable c_int
IMAGE_REL_IA64_PCREL21F = 8 # Variable c_int
CF_NOSCRIPTSEL = 8388608 # Variable c_long
PRINTER_CHANGE_DELETE_JOB = 1024 # Variable c_int
TBN_LAST = 4294966576 # Variable c_uint
IDC_SIZENS = 206405 # Variable POINTER(c_wchar)
LB_ITEMFROMPOINT = 425 # Variable c_int
SET_TAPE_DRIVE_INFORMATION = 1 # Variable c_int
CBN_SELENDOK = 9 # Variable c_int
RPC_C_AUTHN_DEC_PUBLIC = 4 # Variable c_int
CFSTR_MIME_X_EMF = 'image/x-emf' # Variable POINTER(c_wchar)
MARSHALINTERFACE_MIN = 500 # Variable c_int
IMAGE_SYM_CLASS_FAR_EXTERNAL = 68 # Variable c_int
WM_VSCROLL = 277 # Variable c_int
EVENTLOG_END_ALL_PAIRED_EVENTS = 4 # Variable c_int
RESOURCEDISPLAYTYPE_GROUP = 5 # Variable c_int
IMAGE_SYM_TYPE_WORD = 13 # Variable c_int
PAN_SERIF_BONE = 8 # Variable c_int
LVM_GETISEARCHSTRINGA = 4148 # Variable c_int
TVN_KEYDOWN = 4294966884 # Variable c_uint
TCI_SRCCHARSET = 1 # Variable c_int
MCHT_CALENDARDAY = 131074 # Variable c_int
PAGE_WRITECOMBINE = 1024 # Variable c_int
WH_CBT = 5 # Variable c_int
ERROR_RESOURCE_ONLINE = 5019 # Variable c_long
SPI_GETNONCLIENTMETRICS = 41 # Variable c_int
USER_MARSHAL_FC_BYTE = 1 # Variable c_int
WM_STYLECHANGING = 124 # Variable c_int
SUBLANG_LITHUANIAN = 1 # Variable c_int
DCBA_FACEDOWNLEFT = 258 # Variable c_int
TB_ISBUTTONCHECKED = 1034 # Variable c_int
MCI_DEVTYPE_OVERLAY = 515 # Variable c_int
DS_CONTROL = 1024 # Variable c_long
MM_TEXT = 1 # Variable c_int
CACHE_S_LAST = 262527 # Variable c_long
CTRY_PRCHINA = 86 # Variable c_int
SCS_CAP_SETRECONVERTSTRING = 4 # Variable c_int
DRV_ENABLE = 2 # Variable c_int
OPEN_EXISTING = 3 # Variable c_int
SW_SCROLLCHILDREN = 1 # Variable c_int
ERROR_LIBRARY_OFFLINE = 4305 # Variable c_long
IMAGE_REL_IA64_LTOFF22 = 10 # Variable c_int
PRINTER_CHANGE_DELETE_PRINTER = 4 # Variable c_int
ARW_DOWN = 4 # Variable c_long
DRAGDROP_E_NOTREGISTERED = -2147221248 # Variable c_long
NRC_BADDR = 7 # Variable c_int
CONTEXT_INTEGER = 65538 # Variable c_long
EM_POSFROMCHAR = 214 # Variable c_int
PF_ALPHA_BYTE_INSTRUCTIONS = 5 # Variable c_int
MCM_FIRST = 4096 # Variable c_int
TB_SETINSERTMARKCOLOR = 1112 # Variable c_int
ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 1807 # Variable c_long
ERROR_CHILD_NOT_COMPLETE = 129 # Variable c_long
WM_DESTROY = 2 # Variable c_int
RBBIM_CHILD = 16 # Variable c_int
grp1 = 1072 # Variable c_int
WM_ENTERIDLE = 289 # Variable c_int
VK_PROCESSKEY = 229 # Variable c_int
FILE_BEGIN = 0 # Variable c_int
LVM_ENSUREVISIBLE = 4115 # Variable c_int
CS_NOMOVECARET = 16384 # Variable c_int
WM_NCLBUTTONDBLCLK = 163 # Variable c_int
NTM_OPENTYPE = 131072 # Variable c_int
rad14 = 1069 # Variable c_int
WM_UNDO = 772 # Variable c_int
QS_KEY = 1 # Variable c_int
SUBLANG_MALAY_BRUNEI_DARUSSALAM = 2 # Variable c_int
IMN_CLOSESTATUSWINDOW = 1 # Variable c_int
DFCS_CAPTIONMAX = 2 # Variable c_int
SPAPI_E_SECTION_NAME_TOO_LONG = -2146500606 # Variable c_long
MIDICAPS_LRVOLUME = 2 # Variable c_int
DDL_READWRITE = 0 # Variable c_int
LVN_KEYDOWN = 4294967141 # Variable c_uint
TB_MAPACCELERATORW = 1114 # Variable c_int
C3_NONSPACING = 1 # Variable c_int
PD_COLLATE = 16 # Variable c_int
TPM_LEFTBUTTON = 0 # Variable c_long
URLPOLICY_LOG_ON_ALLOW = 64 # Variable c_int
MCI_WAIT = 2 # Variable c_long
IME_CMODE_NATIVE = 1 # Variable c_int
SIOCATMARK = 1074033415 # Variable c_long
RT_ANIICON = 34 # Variable POINTER(c_wchar)
TCS_FORCELABELLEFT = 32 # Variable c_int
SEE_MASK_CLASSNAME = 1 # Variable c_int
CO_E_INIT_SHARED_ALLOCATOR = -2147467257 # Variable c_long
WM_PSD_ENVSTAMPRECT = 1029 # Variable c_int
DMPAPER_LETTER = 1 # Variable c_int
CC_ROUNDRECT = 256 # Variable c_int
ES_CENTER = 1 # Variable c_long
DMBIN_UPPER = 1 # Variable c_int
S_PERIOD1024 = 1 # Variable c_int
VK_F8 = 119 # Variable c_int
LVN_ITEMACTIVATE = 4294967182 # Variable c_uint
VK_F15 = 126 # Variable c_int
LANG_AZERI = 44 # Variable c_int
I_IMAGECALLBACK = -1 # Variable c_int
DNS_REGISTER = 1 # Variable c_int
EWX_SHUTDOWN = 1 # Variable c_int
EMR_POLYGON16 = 86 # Variable c_int
IMAGE_SIZEOF_ROM_OPTIONAL_HEADER = 56 # Variable c_int
PARAMFLAG_FLCID = 4 # Variable c_int
PERF_100NSEC_MULTI_TIMER_INV = 592512256 # Variable c_int
TBIF_LPARAM = 16 # Variable c_int
SPLDS_PRINT_MAX_RESOLUTION_SUPPORTED = 'printMaxResolutionSupported' # Variable POINTER(c_wchar)
RPC_X_WRONG_PIPE_ORDER = 1831 # Variable c_long
ERROR_DATABASE_FULL = 4314 # Variable c_long
MMIO_EXIST = 16384 # Variable c_int
DDL_ARCHIVE = 32 # Variable c_int
FSB_ENCARTA_MODE = 1 # Variable c_int
TBIF_COMMAND = 32 # Variable c_int
GL_ID_INPUTSYMBOL = 39 # Variable c_int
SWP_NOCOPYBITS = 256 # Variable c_int
CTRY_NICARAGUA = 505 # Variable c_int
SE_MACHINE_ACCOUNT_NAME = 'SeMachineAccountPrivilege' # Variable POINTER(c_wchar)
ERROR_TOO_MANY_LUIDS_REQUESTED = 1333 # Variable c_long
CCM_SETBKCOLOR = 8193 # Variable c_int
ERROR_NOT_ENOUGH_MEMORY = 8 # Variable c_long
IME_KHOTKEY_SHAPE_TOGGLE = 80 # Variable c_int
FAILED_ACCESS_ACE_FLAG = 128 # Variable c_int
MCN_SELCHANGE = 4294966547 # Variable c_uint
RPC_E_DISCONNECTED = -2147417848 # Variable c_long
PRSPEC_PROPID = 1 # Variable c_int
SERVICE_ACCEPT_STOP = 1 # Variable c_int
TVN_SETDISPINFOA = 4294966892 # Variable c_uint
TTM_GETMAXTIPWIDTH = 1049 # Variable c_int
KF_MENUMODE = 4096 # Variable c_int
IP_DONTFRAGMENT = 9 # Variable c_int
MIDIERR_NODEVICE = 68 # Variable c_int
SERVICE_PAUSED = 7 # Variable c_int
CB_GETLBTEXTLEN = 329 # Variable c_int
TTDT_RESHOW = 1 # Variable c_int
CO_E_OBJNOTREG = -2147220997 # Variable c_long
DISPID_COLLECT = -8 # Variable c_int

tagAPPINFOTYPE = c_int # enum
APPINFO_PUBLISHED = 1
APPINFO_SHELLNEW = 2
APPINFO_INSERTABLE = 3
ACE_OBJECT_TYPE_PRESENT = 1 # Variable c_int
DFC_BUTTON = 4 # Variable c_int
COMMON_LVB_LEADING_BYTE = 256 # Variable c_int
WAVECAPS_VOLUME = 4 # Variable c_int

tagCHANGEKIND = c_int # enum
CHANGEKIND_ADDMEMBER = 0
CHANGEKIND_INVALIDATE = 5
CHANGEKIND_CHANGEFAILED = 6
IMAGE_SUBSYSTEM_NATIVE_WINDOWS = 8 # Variable c_int
DRV_QUERYCONFIGURE = 8 # Variable c_int
WS_EX_TRANSPARENT = 32 # Variable c_long
PSP_DEFAULT = 0 # Variable c_int
CRYPT_E_FILE_ERROR = -2146885629 # Variable c_long
DD_DEFSCROLLINTERVAL = 50 # Variable c_int
ERROR_DS_INCORRECT_ROLE_OWNER = 1931 # Variable c_long
HKL_NEXT = 1 # Variable c_int
LANG_KANNADA = 75 # Variable c_int
RESOURCEDISPLAYTYPE_NDSCONTAINER = 11 # Variable c_int
RB_MOVEBAND = 1063 # Variable c_int
ERROR_DATABASE_DOES_NOT_EXIST = 1065 # Variable c_long
CBR_19200 = 19200 # Variable c_int
NRC_NOWILD = 21 # Variable c_int
SHGFI_SELECTED = 65536 # Variable c_int
OPENTYPE_FONTTYPE = 65536 # Variable c_int
JOB_OBJECT_TERMINATE = 8 # Variable c_int
PORT_STATUS_TYPE_WARNING = 2 # Variable c_int
CONNECT_REDIRECT = 128 # Variable c_int
EM_SETSEL = 177 # Variable c_int
PERF_TIMER_100NS = 1048576 # Variable c_int
DMPAPER_CSHEET = 24 # Variable c_int
VIEW_SORTSIZE = 5 # Variable c_int
IMAGE_SCN_MEM_NOT_CACHED = 67108864 # Variable c_int
MIDI_IO_STATUS = 32 # Variable c_long
LOCALE_SDECIMAL = 14 # Variable c_int
ERROR_DATABASE_FAILURE = 4313 # Variable c_long
VK_ATTN = 246 # Variable c_int
WIN_CERT_TYPE_RESERVED_1 = 3 # Variable c_int
ERROR_OPEN_FAILED = 110 # Variable c_long
TVI_LAST = 4294901762 # Variable POINTER(_TREEITEM)
ERROR_INVALID_BLOCK_LENGTH = 1106 # Variable c_long
KLF_UNLOADPREVIOUS = 4 # Variable c_int
WM_CTLCOLORSTATIC = 312 # Variable c_int
HICF_ACCELERATOR = 4 # Variable c_int
RC_GDI20_OUTPUT = 16 # Variable c_int
SPAPI_E_NO_INF = -2146500086 # Variable c_long
STG_E_INUSE = -2147286784 # Variable c_long
ERROR_INVALID_LB_MESSAGE = 1432 # Variable c_long
MCI_OVLY_RECT = 65536 # Variable c_long
HCF_HOTKEYSOUND = 16 # Variable c_int
ERROR_SINGLE_INSTANCE_APP = 1152 # Variable c_long
DLGC_WANTARROWS = 1 # Variable c_int
PAN_SERIF_ROUNDED = 15 # Variable c_int
LVA_DEFAULT = 0 # Variable c_int
XMLELEMTYPE_OTHER = 6
DC_FILEDEPENDENCIES = 14 # Variable c_int
DMDITHER_NONE = 1 # Variable c_int
SPAPI_E_ERROR_NOT_INSTALLED = -2146496512 # Variable c_long
ICM_ADDPROFILE = 1 # Variable c_int
CF_NOSTYLESEL = 1048576 # Variable c_long
STATUS_SEGMENT_NOTIFICATION = 1073741829 # Variable c_ulong
LVM_CREATEDRAGIMAGE = 4129 # Variable c_int
PERF_SIZE_DWORD = 0 # Variable c_int
PERF_100NSEC_TIMER = 542180608 # Variable c_int
SLE_WARNING = 3 # Variable c_int
LOCK_EXCLUSIVE = 2
HTCLOSE = 20 # Variable c_int
IMAGE_SEPARATE_DEBUG_MISMATCH = 32768 # Variable c_int
IMAGE_REL_SH3_DIRECT16 = 1 # Variable c_int
DM_REPOSITION = 1026 # Variable c_int
PD_ENABLESETUPTEMPLATEHANDLE = 131072 # Variable c_int
IMAGE_WEAK_EXTERN_SEARCH_LIBRARY = 2 # Variable c_int
CLASSFACTORY_E_FIRST = 2147746064 # Variable c_ulong
CONVERT10_E_OLESTREAM_BITMAP_TO_DIB = -2147221053 # Variable c_long
PSINJECT_BEGINPROLOG = 5 # Variable c_int
TCS_EX_FLATSEPARATORS = 1 # Variable c_int
SE_PRIVILEGE_ENABLED = 2 # Variable c_long
ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227 # Variable c_long
SKF_INDICATOR = 32 # Variable c_int
ERROR_CALL_NOT_IMPLEMENTED = 120 # Variable c_long
SS_ENHMETAFILE = 15 # Variable c_long
MAILSLOT_NO_MESSAGE = 4294967295 # Variable c_ulong
CBF_SKIP_REGISTRATIONS = 524288 # Variable c_int
SIZE_MAXIMIZED = 2 # Variable c_int
TC_GP_TRAP = 2 # Variable c_int
CBF_SKIP_CONNECT_CONFIRMS = 262144 # Variable c_int
MM_MIM_DATA = 963 # Variable c_int
IA64_STUB_NOT_AVAILABLE = 4294967295 # Variable c_void_p
NM_CUSTOMDRAW = 4294967284 # Variable c_uint
SS_LEFTNOWORDWRAP = 12 # Variable c_long
CTRY_DENMARK = 45 # Variable c_int
SPI_GETDRAGFULLWINDOWS = 38 # Variable c_int
NULL_PEN = 8 # Variable c_int
NLS_VALID_LOCALE_MASK = 1048575 # Variable c_int
DOMAIN_ALIAS_RID_SYSTEM_OPS = 549 # Variable c_long
DMPAPER_A5 = 11 # Variable c_int
ACL_REVISION_DS = 4 # Variable c_int
DFCS_FLAT = 16384 # Variable c_int
RPC_E_TIMEOUT = -2147417825 # Variable c_long
JOYSTICKID1 = 0 # Variable c_int
MCI_SET = 2061 # Variable c_int
CWP_SKIPDISABLED = 2 # Variable c_int
GCPCLASS_NUMERICSEPARATOR = 8 # Variable c_int
SHGFI_ATTRIBUTES = 2048 # Variable c_int
LVM_SETBKCOLOR = 4097 # Variable c_int
TPM_NONOTIFY = 128 # Variable c_long
TB_GETBUTTONTEXTA = 1069 # Variable c_int
COMMON_LVB_REVERSE_VIDEO = 16384 # Variable c_int
ERROR_LOGON_FAILURE = 1326 # Variable c_long
PAN_STROKE_GRADUAL_HORZ = 5 # Variable c_int
TC_SCROLLBLT = 65536 # Variable c_int
JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 16 # Variable c_int
WM_PRINT = 791 # Variable c_int
SB_GETPARTS = 1030 # Variable c_int
MCI_COPY = 2130 # Variable c_int
PAN_MIDLINE_HIGH_SERIFED = 7 # Variable c_int
TVS_CHECKBOXES = 256 # Variable c_int
DMLERR_DLL_NOT_INITIALIZED = 16387 # Variable c_int
PSINJECT_ENDPAGECOMMENTS = 9 # Variable c_int
LCS_WINDOWS_COLOR_SPACE = 1466527264 # Variable c_int
NRC_TOOMANY = 34 # Variable c_int
CB_GETDROPPEDCONTROLRECT = 338 # Variable c_int
TVGN_PREVIOUS = 2 # Variable c_int
PGM_SETBORDER = 5126 # Variable c_int
SP_HANDSHAKING = 16 # Variable c_ulong
WIZ_CXBMP = 80 # Variable c_int
SPLDS_PRINT_START_TIME = 'printStartTime' # Variable POINTER(c_wchar)
DT_VCENTER = 4 # Variable c_int
MCI_MODE_NOT_READY = 524 # Variable c_int
FILE_WRITE_DATA = 2 # Variable c_int
PSINJECT_VMSAVE = 17 # Variable c_int
MCIERR_MISSING_COMMAND_STRING = 267 # Variable c_int
IMAGE_SCN_ALIGN_64BYTES = 7340032 # Variable c_int
SE_GROUP_DEFAULTED = 2 # Variable c_int
STG_S_MONITORING = 197123 # Variable c_long
ACCESS_DENIED_ACE_TYPE = 1 # Variable c_int
ERROR_SERVICE_NO_THREAD = 1054 # Variable c_long
MCIERR_WAVE_INPUTUNSPECIFIED = 325 # Variable c_int
DM_SETDEFID = 1025 # Variable c_int
IGP_SETCOMPSTR = 20 # Variable c_int
CBEM_INSERTITEMW = 1035 # Variable c_int
TTM_GETTIPBKCOLOR = 1046 # Variable c_int
ERROR_MEDIA_INCOMPATIBLE = 4315 # Variable c_long
STG_E_DISKISWRITEPROTECTED = -2147287021 # Variable c_long
JOY_CAL_READ6 = 8388608 # Variable c_long
CB_OKAY = 0 # Variable c_int
ERROR_HOTKEY_ALREADY_REGISTERED = 1409 # Variable c_long
PSN_RESET = 4294967093 # Variable c_uint
REGDB_E_READREGDB = -2147221168 # Variable c_long
HTBOTTOMLEFT = 16 # Variable c_int
SB_GETICON = 1044 # Variable c_int
psh12 = 1035 # Variable c_int
DOWNLOADHEADER = 4111 # Variable c_int
MCIERR_ILLEGAL_FOR_AUTO_OPEN = 303 # Variable c_int
IMAGE_SIZEOF_LINENUMBER = 6 # Variable c_int
WMSZ_TOP = 3 # Variable c_int
DMPAPER_TABLOID_EXTRA = 52 # Variable c_int
FD_WRITE = 2 # Variable c_int
CDN_SELCHANGE = 4294966694 # Variable c_uint
MCI_GETDEVCAPS = 2059 # Variable c_int
TB_PRESSBUTTON = 1027 # Variable c_int
PROCESSOR_HITACHI_SH3E = 10004 # Variable c_int
PRINTACTION_OPENNETPRN = 5 # Variable c_int
PORT_STATUS_PAPER_PROBLEM = 5 # Variable c_int
REPLACEDLGORD = 1541 # Variable c_int
JOB_NOTIFY_FIELD_TOTAL_PAGES = 20 # Variable c_int
MCI_VD_SPIN_DOWN = 131072 # Variable c_long
CO_E_DLLNOTFOUND = -2147221000 # Variable c_long
REG_EXPAND_SZ = 2 # Variable c_int
MIXERCONTROL_CONTROLF_UNIFORM = 1 # Variable c_long
WM_HANDHELDFIRST = 856 # Variable c_int
PS_JOIN_BEVEL = 4096 # Variable c_int
MCI_DEVTYPE_WAVEFORM_AUDIO = 522 # Variable c_int
IPPORT_TTYLINK = 87 # Variable c_int
TIME_ZONE_ID_DAYLIGHT = 2 # Variable c_int
WGL_SWAP_UNDERLAY13 = 268435456 # Variable c_int
VK_INSERT = 45 # Variable c_int
VFT2_DRV_NETWORK = 6 # Variable c_long
CTRY_AUSTRALIA = 61 # Variable c_int
MCI_FORMAT_MILLISECONDS = 0 # Variable c_int
TOOLBARCLASSNAMEA = 'ToolbarWindow32' # Variable POINTER(c_char)
EMR_SELECTOBJECT = 37 # Variable c_int
LVBKIF_STYLE_NORMAL = 0 # Variable c_int
GWL_STYLE = -16 # Variable c_int
PERF_SAMPLE_BASE = 1073939457 # Variable c_int
POLYFILL_LAST = 2 # Variable c_int
TVS_DISABLEDRAGDROP = 16 # Variable c_int
BAUD_600 = 32 # Variable c_ulong
SE_RESTORE_NAME = 'SeRestorePrivilege' # Variable POINTER(c_wchar)
PORT_STATUS_USER_INTERVENTION = 8 # Variable c_int
MEVT_TEMPO = 1 # Variable c_ubyte
FR_REPLACE = 16 # Variable c_int
ERROR_PRINTQ_FULL = 61 # Variable c_long
rad15 = 1070 # Variable c_int
HINSTANCE_ERROR = 32 # Variable c_int
FKF_HOTKEYSOUND = 16 # Variable c_int
TB_CHECKBUTTON = 1026 # Variable c_int
LC_WIDESTYLED = 64 # Variable c_int
HTTOPRIGHT = 14 # Variable c_int
KEYEVENTF_KEYUP = 2 # Variable c_int
SERVICE_ACCEPT_PARAMCHANGE = 8 # Variable c_int
WH_JOURNALPLAYBACK = 1 # Variable c_int
PRINTER_NOTIFY_FIELD_OBJECT_GUID = 26 # Variable c_int
PAN_STRAIGHT_ARMS_HORZ = 2 # Variable c_int
TB_SETMAXTEXTROWS = 1084 # Variable c_int
RB_GETROWCOUNT = 1037 # Variable c_int
SW_SHOW = 5 # Variable c_int
MIXERCONTROL_CONTROLTYPE_VOLUME = 1342373889 # Variable c_long
MONO_FONT = 8 # Variable c_int
WB_LEFT = 0 # Variable c_int
MIDIERR_BASE = 64 # Variable c_int
LOCALE_USER_DEFAULT = 1024 # Variable c_ulong
SM_CYCAPTION = 4 # Variable c_int
DATE_SHORTDATE = 1 # Variable c_int
ES_NUMBER = 8192 # Variable c_long
TECHNOLOGY = 2 # Variable c_int
PERF_SAMPLE_COUNTER = 4260864 # Variable c_int
CBEN_ENDEDITA = 4294966491 # Variable c_uint
PRINTER_ACCESS_ADMINISTER = 4 # Variable c_int
ABN_STATECHANGE = 0 # Variable c_int
RC_DIBTODEV = 512 # Variable c_int
ERROR_PIPE_NOT_CONNECTED = 233 # Variable c_long
ERROR_INVALID_SERVICE_CONTROL = 1052 # Variable c_long
SM_CXDRAG = 68 # Variable c_int
DM_ICMMETHOD = 8388608 # Variable c_long
HKCOMB_NONE = 1 # Variable c_int
RBBIM_IMAGE = 8 # Variable c_int
VFT2_DRV_COMM = 10 # Variable c_long
PROVIDER_KEEPS_VALUE_LENGTH = 1 # Variable c_int
PRINTACTION_TESTPAGE = 4 # Variable c_int
CRYPT_E_UNEXPECTED_MSG_TYPE = -2146885622 # Variable c_long
EMR_SETMITERLIMIT = 58 # Variable c_int
BI_RGB = 0 # Variable c_long
LVM_SETBKIMAGEA = 4164 # Variable c_int
LOCALE_IFIRSTDAYOFWEEK = 4108 # Variable c_int
NFR_ANSI = 1 # Variable c_int
OFN_NOVALIDATE = 256 # Variable c_int
PORT_STATUS_PAPER_JAM = 2 # Variable c_int
WSB_PROP_CXVSCROLL = 8 # Variable c_long
TVM_SELECTITEM = 4363 # Variable c_int
HICF_DUPACCEL = 8 # Variable c_int
TVS_HASBUTTONS = 1 # Variable c_int
EMR_POLYGON = 3 # Variable c_int
ARW_STARTTOP = 2 # Variable c_long
HTOBJECT = 19 # Variable c_int
_MAX_FNAME = 256 # Variable c_int
GCPCLASS_LATIN = 1 # Variable c_int
MOD_ON_KEYUP = 2048 # Variable c_int
SHGFI_SMALLICON = 1 # Variable c_int
TYPE_E_DLLFUNCTIONNOTFOUND = -2147319761 # Variable c_long
chx5 = 1044 # Variable c_int
SERVICE_CONTROL_PAUSE = 2 # Variable c_int
URLACTION_SHELL_VERB = 6148 # Variable c_int
TA_MASK = 287 # Variable c_int
OLE_E_INVALIDRECT = -2147221491 # Variable c_long
SE_ERR_DDEBUSY = 30 # Variable c_int
WA_ACTIVE = 1 # Variable c_int
JOYERR_NOERROR = 0 # Variable c_int
WC_IPADDRESSW = 'SysIPAddress32' # Variable POINTER(c_wchar)
LVA_ALIGNTOP = 2 # Variable c_int
CDM_GETSPEC = 1124 # Variable c_int
MCI_ANIM_REALIZE_NORM = 65536 # Variable c_long
RPC_S_NO_CALL_ACTIVE = 1725 # Variable c_long
MF_SEPARATOR = 2048 # Variable c_long
RPC_S_ZERO_DIVIDE = 1767 # Variable c_long
IME_REGWORD_STYLE_USER_LAST = 4294967295 # Variable c_uint
RPC_C_PROTECT_LEVEL_DEFAULT = 0 # Variable c_int
IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13 # Variable c_int
HIST_ADDTOFAVORITES = 3 # Variable c_int
MAX_LEADBYTES = 12 # Variable c_int
CONTEXT_i486 = 65536 # Variable c_int
PRINTER_CHANGE_DELETE_PORT = 4194304 # Variable c_int
MIDIERR_LASTERROR = 71 # Variable c_int
CDIS_FOCUS = 16 # Variable c_int
BS_RADIOBUTTON = 4 # Variable c_long
EDGE_ETCHED = 6 # Variable c_int
TTN_GETDISPINFOW = 4294966766 # Variable c_uint
SHGFI_OPENICON = 2 # Variable c_int
MCI_ANIM_STATUS_HPAL = 16388 # Variable c_long
KF_DLGMODE = 2048 # Variable c_int
LVM_SUBITEMHITTEST = 4153 # Variable c_int
ERROR_SUBST_TO_JOIN = 141 # Variable c_long
SHAREVISTRINGA = 'commdlg_ShareViolation' # Variable POINTER(c_char)
FACILITY_DISPATCH = 2 # Variable c_int
IMAGE_REL_PPC_SECRELLO = 19 # Variable c_int
WM_MDIICONARRANGE = 552 # Variable c_int
ERROR_FULLSCREEN_MODE = 1007 # Variable c_long
SS_WHITERECT = 6 # Variable c_long
SECURITY_EFFECTIVE_ONLY = 524288 # Variable c_int
CS_ENABLE = 1 # Variable c_long
MCI_VD_PLAY_REVERSE = 65536 # Variable c_long
CB_ERRSPACE = -2 # Variable c_int
IE_MEMORY = -4 # Variable c_int
rad8 = 1063 # Variable c_int
CERT_E_CRITICAL = -2146762491 # Variable c_long
WH_MOUSE = 7 # Variable c_int
HCF_AVAILABLE = 2 # Variable c_int
IO_REPARSE_TAG_HSM = 3221225476 # Variable c_uint
XST_ADVDATAACKRCVD = 16 # Variable c_int
ERROR_INVALID_ACL = 1336 # Variable c_long
ERROR_INVALID_COLORSPACE = 2307 # Variable c_long
ERROR_FILE_NOT_FOUND = 2 # Variable c_long
CBEIF_LPARAM = 32 # Variable c_int
LVN_SETDISPINFOW = 4294967118 # Variable c_uint
ERROR_SERVICE_SPECIFIC_ERROR = 1066 # Variable c_long
NORMAL_PRIORITY_CLASS = 32 # Variable c_int
grp4 = 1075 # Variable c_int
CO_E_FAILEDTOOPENTHREADTOKEN = -2147220990 # Variable c_long
MK_E_NOOBJECT = -2147221019 # Variable c_long
HTMAXBUTTON = 9 # Variable c_int
LANG_FAEROESE = 56 # Variable c_int
ERROR_INVALID_ID_AUTHORITY = 1343 # Variable c_long
SEMAPHORE_MODIFY_STATE = 2 # Variable c_int
LVHT_ONITEM = 14 # Variable c_int
IMAGE_REL_ALPHA_SECRELLO = 17 # Variable c_int
URLACTION_INFODELIVERY_MIN = 7424 # Variable c_int
ERROR_NO_MORE_SEARCH_HANDLES = 113 # Variable c_long
SMTO_NORMAL = 0 # Variable c_int
MCI_STATUS_CURRENT_TRACK = 8 # Variable c_long
IMAGE_REL_PPC_ADDR24 = 3 # Variable c_int
REG_OPTION_VOLATILE = 1 # Variable c_long
ENUM_REGISTRY_SETTINGS = 4294967294 # Variable c_ulong
MAXIMUM_ALLOWED = 33554432 # Variable c_long
JOB_OBJECT_LIMIT_WORKINGSET = 1 # Variable c_int
HS_VERTICAL = 1 # Variable c_int
CONVERT10_E_LAST = 2147746255 # Variable c_ulong
TIME_TICKS = 32 # Variable c_int
ERROR_ITERATED_DATA_EXCEEDS_64k = 194 # Variable c_long
VARCMP_LT = 0 # Variable c_int
DC_MANUFACTURER = 23 # Variable c_int
STD_FIND = 12 # Variable c_int
WC_LISTVIEWW = 'SysListView32' # Variable POINTER(c_wchar)
IDC_CROSS = 206101 # Variable POINTER(c_wchar)
LANG_ESTONIAN = 37 # Variable c_int
SEM_NOOPENFILEERRORBOX = 32768 # Variable c_int
C3_SYMBOL = 8 # Variable c_int
BAUD_115200 = 131072 # Variable c_ulong
ACCESS_DS_OBJECT_TYPE_NAME_W = 'Directory Service Object' # Variable POINTER(c_wchar)
DMRES_MEDIUM = -3 # Variable c_int
ERROR_WRONG_DISK = 34 # Variable c_long
NUMPRS_THOUSANDS = 512 # Variable c_int
FACILITY_MEDIASERVER = 13 # Variable c_int
ctlFirst = 1024 # Variable c_int
TVN_SETDISPINFOW = 4294966843 # Variable c_uint
ERROR_TOO_MANY_LINKS = 1142 # Variable c_long
MMIO_DENYNONE = 64 # Variable c_int
ANIMATE_CLASSW = 'SysAnimate32' # Variable POINTER(c_wchar)
VK_F24 = 135 # Variable c_int
LANG_GERMAN = 7 # Variable c_int
MINSHORT = 32768 # Variable c_int
PC_SCANLINE = 8 # Variable c_int
PDERR_INITFAILURE = 4102 # Variable c_int
CO_E_LAUNCH_PERMSSION_DENIED = -2147467237 # Variable c_long
SEC_VLM = 33554432 # Variable c_int
PAN_PROP_EXPANDED = 5 # Variable c_int
PIPE_UNLIMITED_INSTANCES = 255 # Variable c_int
DNS_UNREGISTER = 2 # Variable c_int
DATABITS_5 = 1 # Variable c_ushort
LVS_NOSCROLL = 8192 # Variable c_int
rct2 = 1081 # Variable c_int
SM_RESERVED2 = 25 # Variable c_int
WM_KILLFOCUS = 8 # Variable c_int
IMPLINK_HIGHEXPER = 158 # Variable c_int
SCS_PIF_BINARY = 3 # Variable c_int
IDI_HAND = 206099 # Variable POINTER(c_wchar)
STD_REPLACE = 13 # Variable c_int
SIF_POS = 4 # Variable c_int
WM_MOUSELAST = 521 # Variable c_int
DMBIN_MANUAL = 4 # Variable c_int
CF_TEXT = 1 # Variable c_int
WM_ERASEBKGND = 20 # Variable c_int
VK_SNAPSHOT = 44 # Variable c_int
IMAGE_REL_BASED_REL32 = 7 # Variable c_int
NDR_BIG_ENDIAN = 0 # Variable c_ulong
ERROR_SERVICE_NOT_ACTIVE = 1062 # Variable c_long
VIF_OUTOFSPACE = 256 # Variable c_long
FILE_FLAG_OVERLAPPED = 1073741824 # Variable c_int
IME_CMODE_LANGUAGE = 3 # Variable c_int
MCI_OVLY_INFO_TEXT = 65536 # Variable c_long
META_CHORD = 2096 # Variable c_int
DFCS_CAPTIONHELP = 4 # Variable c_int
IMAGE_SCN_NO_DEFER_SPEC_EXC = 16384 # Variable c_int
LB_SELECTSTRING = 396 # Variable c_int
VK_LWIN = 91 # Variable c_int
CTRY_MACEDONIA = 389 # Variable c_int
CWP_SKIPINVISIBLE = 1 # Variable c_int
MIXER_OBJECTF_MIDIIN = 1073741824 # Variable c_long
PERF_SAMPLE_FRACTION = 549585920 # Variable c_int
LVN_COLUMNCLICK = 4294967188 # Variable c_uint
SIOCGHIWAT = 1074033409 # Variable c_long
RPC_S_NO_CONTEXT_AVAILABLE = 1765 # Variable c_long
LVFI_NEARESTXY = 64 # Variable c_int

_CLASSPATHTYPE = c_int # enum
TBTS_BOTTOM = 2 # Variable c_int
PAN_PROP_MODERN = 3 # Variable c_int
REG_LEGAL_CHANGE_FILTER = 15 # Variable c_long
VER_PLATFORM_WIN32_WINDOWS = 1 # Variable c_int
ERROR_NO_TOKEN = 1008 # Variable c_long
DIGSIG_E_ENCODE = -2146762747 # Variable c_long
SO_CONNOPTLEN = 28677 # Variable c_int
TAPE_DRIVE_SELECT = 2 # Variable c_int
OLE_S_FIRST = 262144 # Variable c_long
SE_SYSTEM_PROFILE_NAME = 'SeSystemProfilePrivilege' # Variable POINTER(c_wchar)
WA_CLICKACTIVE = 2 # Variable c_int
TRUE = 1 # Variable c_int
LVS_AUTOARRANGE = 256 # Variable c_int
MOUSETRAILS = 39 # Variable c_int
SPLDS_PRINT_KEEP_PRINTED_JOBS = 'printKeepPrintedJobs' # Variable POINTER(c_wchar)
PSP_USEHEADERTITLE = 4096 # Variable c_int
ERROR_GENERIC_NOT_MAPPED = 1360 # Variable c_long
FILE_FLAG_WRITE_THROUGH = 2147483648 # Variable c_uint
DO_PRINTFILE = 1414419024 # Variable c_long
PI_DATAPROGRESS = 64
MCHT_CALENDARDATEPREV = 33685505 # Variable c_int
SS_SIMPLE = 11 # Variable c_long
FOF_RENAMEONCOLLISION = 8 # Variable c_int
UD_MINVAL = -32767 # Variable c_int
OFN_PATHMUSTEXIST = 2048 # Variable c_int
RPC_IF_OLE = 2 # Variable c_int
DDE_FBUSY = 16384 # Variable c_int
CE_BREAK = 16 # Variable c_int
ERROR_INVALID_DOMAINNAME = 1212 # Variable c_long
MIDIERR_INVALIDSETUP = 69 # Variable c_int
DFCS_CAPTIONCLOSE = 0 # Variable c_int
SPAPI_E_INVALID_FILTER_DRIVER = -2146500052 # Variable c_long
IMPORT_OBJECT_HDR_SIG2 = 65535 # Variable c_int
HDN_DIVIDERDBLCLICKW = 4294966971 # Variable c_uint
CLR_NONE = 4294967295 # Variable c_ulong
TKF_CONFIRMHOTKEY = 8 # Variable c_int
FILE_END = 2 # Variable c_int
JOY_USEDEADZONE = 2048 # Variable c_long
CBS_HASSTRINGS = 512 # Variable c_long
ERROR_NOT_DOS_DISK = 26 # Variable c_long
CONVERT10_E_STG_NO_STD_STREAM = -2147221051 # Variable c_long
VK_F23 = 134 # Variable c_int
ERROR_END_OF_MEDIA = 1100 # Variable c_long
MSG_OOB = 1 # Variable c_int
IMAGE_SCN_ALIGN_128BYTES = 8388608 # Variable c_int
IMAGE_REL_MIPS_SECRELLO = 12 # Variable c_int
URLACTION_JAVA_MAX = 7423 # Variable c_int
S_WHITE2048 = 6 # Variable c_int
SS_CENTERIMAGE = 512 # Variable c_long
CDIS_MARKED = 128 # Variable c_int
LOCALE_SMONTHNAME1 = 56 # Variable c_int
ENHMETA_SIGNATURE = 1179469088 # Variable c_int
XTYP_SHIFT = 4 # Variable c_int
LVSCW_AUTOSIZE = -1 # Variable c_int
TBS_NOTICKS = 16 # Variable c_int
OFN_EXTENSIONDIFFERENT = 1024 # Variable c_int
ERROR_MEDIA_NOT_AVAILABLE = 4318 # Variable c_long
IMAGE_OS2_SIGNATURE = 17742 # Variable c_int
TYPE_E_AMBIGUOUSNAME = -2147319764 # Variable c_long
MCHT_TITLEBTNNEXT = 16842755 # Variable c_int
LB_SETLOCALE = 421 # Variable c_int
MCI_ANIM_UPDATE_HDC = 131072 # Variable c_long
ILLUMINANT_D75 = 7 # Variable c_int
SET_POLY_MODE = 4104 # Variable c_int
DV_E_STATDATA = -2147221401 # Variable c_long
MCIERR_INVALID_DEVICE_NAME = 263 # Variable c_int
SE_LOCK_MEMORY_NAME = 'SeLockMemoryPrivilege' # Variable POINTER(c_wchar)
VK_LEFT = 37 # Variable c_int
GCP_SYMSWAPOFF = 8388608 # Variable c_long
CO_E_FAILEDTOOPENPROCESSTOKEN = -2147220967 # Variable c_long
NTE_NOT_FOUND = -2146893807 # Variable c_long
ERROR_NETWORK_UNREACHABLE = 1231 # Variable c_long
RPC_C_PARM_BUFFER_LENGTH = 2 # Variable c_int
FS_GREEK = 8 # Variable c_long
FACILITY_MSMQ = 14 # Variable c_int
ASYNCH = 128 # Variable c_int
PBT_APMOEMEVENT = 11 # Variable c_int
REG_NOTIFY_CHANGE_ATTRIBUTES = 2 # Variable c_long
WGL_SWAP_OVERLAY15 = 32768 # Variable c_int
USER_MARSHAL_FC_CHAR = 2 # Variable c_int
INVALID_SOCKET = 4294967295 # Variable c_uint
SEF_SACL_AUTO_INHERIT = 2 # Variable c_int
PST_RS423 = 4 # Variable c_ulong
CTRL_SHUTDOWN_EVENT = 6 # Variable c_int
CDS_RESET = 1073741824 # Variable c_int
PORT_TYPE_REDIRECTED = 4 # Variable c_int
LVN_ODFINDITEMW = 4294967117 # Variable c_uint
TVN_DELETEITEMA = 4294966887 # Variable c_uint
CO_E_CREATEPROCESS_FAILURE = -2147467240 # Variable c_long
CE_DNS = 2048 # Variable c_int
TAPE_DRIVE_LOAD_UNLOAD = 2147483649 # Variable c_uint
MB_NOFOCUS = 32768 # Variable c_long
DRIVE_REMOTE = 4 # Variable c_int
S_ALLTHRESHOLD = 2 # Variable c_int
MEM_MAPPED = 262144 # Variable c_int
VIEW_LARGEICONS = 0 # Variable c_int
HELPMSGSTRINGA = 'commdlg_help' # Variable POINTER(c_char)
RPC_S_COMM_FAILURE = 1820 # Variable c_long
ERROR_TAG_NOT_FOUND = 2302 # Variable c_long
WM_MOUSELEAVE = 675 # Variable c_int
IMN_SETCONVERSIONMODE = 6 # Variable c_int
CLIP_STROKE_PRECIS = 2 # Variable c_int
GGO_BEZIER = 3 # Variable c_int
EMBDHLP_CREATENOW = 0 # Variable c_long
TMPF_FIXED_PITCH = 1 # Variable c_int
STATUS_PENDING = 259 # Variable c_ulong
DMTT_DOWNLOAD_OUTLINE = 4 # Variable c_int
ICON_BIG = 1 # Variable c_int
SHOW_ICONWINDOW = 2 # Variable c_int
BACKGROUND_INTENSITY = 128 # Variable c_int
THREAD_PRIORITY_ABOVE_NORMAL = 1 # Variable c_int

tagBINDSTRING = c_int # enum
BINDSTRING_EXTRA_URL = 3
BINDSTRING_USERNAME = 5
BINDSTRING_OS = 9
BINDSTRING_USER_AGENT = 10
BINDSTRING_POST_COOKIE = 12
BINDSTRING_URL = 14
CFSTR_MIME_RICHTEXT = 'text/richtext' # Variable POINTER(c_wchar)
ERROR_DRIVE_MEDIA_MISMATCH = 4303 # Variable c_long
DBG_CONTROL_BREAK = 1073807368 # Variable c_ulong
SPI_SETSOUNDSENTRY = 65 # Variable c_int
PAN_CULTURE_LATIN = 0 # Variable c_int
CO_E_FAILEDTOSETDACL = -2147220986 # Variable c_long
LOCALE_SABBREVMONTHNAME10 = 77 # Variable c_int
REGDB_E_WRITEREGDB = -2147221167 # Variable c_long
PROCESSOR_ARCHITECTURE_MIPS = 1 # Variable c_int
RGB_GAMMA_MIN = 1344 # Variable c_ushort
BN_PAINT = 1 # Variable c_int
ERROR_MAPPED_ALIGNMENT = 1132 # Variable c_long
IDRETRY = 4 # Variable c_int
LB_DIR = 397 # Variable c_int
LVM_GETBKCOLOR = 4096 # Variable c_int
CB_GETLOCALE = 346 # Variable c_int
VARCMP_GT = 2 # Variable c_int
ICC_UPDOWN_CLASS = 16 # Variable c_int
PRINTER_CHANGE_WRITE_JOB = 2048 # Variable c_int
OUT_CHARACTER_PRECIS = 2 # Variable c_int
WVR_HREDRAW = 256 # Variable c_int
STDOLE2_MAJORVERNUM = 2 # Variable c_int
EM_UNDO = 199 # Variable c_int
CTRY_BAHRAIN = 973 # Variable c_int
TAPE_DRIVE_TENSION = 2147483650 # Variable c_uint
BAUD_110 = 2 # Variable c_ulong
CF_DSPENHMETAFILE = 142 # Variable c_int
ERROR_FAIL_I24 = 83 # Variable c_long
RPC_C_AUTHN_LEVEL_CALL = 3 # Variable c_int
CBEM_GETEXSTYLE = 1033 # Variable c_int
INPLACE_E_NOTOOLSPACE = -2147221087 # Variable c_long
PGM_FIRST = 5120 # Variable c_int
MCHT_TITLEBK = 65536 # Variable c_int
USER_MARSHAL_FC_FLOAT = 10 # Variable c_int
frm1 = 1076 # Variable c_int
CFERR_NOFONTS = 8193 # Variable c_int
VOS__PM32 = 3 # Variable c_long
SW_SHOWDEFAULT = 10 # Variable c_int
rad16 = 1071 # Variable c_int
CDN_FIRST = 4294966695 # Variable c_uint
EMR_DELETECOLORSPACE = 101 # Variable c_int
PSINJECT_PAGENUMBER = 25 # Variable c_int
CE_OOP = 4096 # Variable c_int
RPC_C_OPT_MQ_AUTHN_SERVICE = 5 # Variable c_int
MCI_GETDEVCAPS_CAN_PLAY = 8 # Variable c_long
VIF_OUTOFMEMORY = 32768 # Variable c_long
SUBLANG_KOREAN = 1 # Variable c_int
DMLERR_NO_ERROR = 0 # Variable c_int
MKF_REPLACENUMBERS = 128 # Variable c_int
MUTANT_QUERY_STATE = 1 # Variable c_int
DMPAPER_RESERVED_49 = 49 # Variable c_int
TTM_TRACKPOSITION = 1042 # Variable c_int
SETDIBSCALING = 32 # Variable c_int
GCP_NUMERICSLOCAL = 134217728 # Variable c_long
PDERR_PRINTERCODES = 4096 # Variable c_int
WM_SETICON = 128 # Variable c_int
WM_MBUTTONUP = 520 # Variable c_int

__MIDL_IBindStatusCallback_0004 = c_int # enum
BSCF_FIRSTDATANOTIFICATION = 1
BSCF_INTERMEDIATEDATANOTIFICATION = 2
BSCF_DATAFULLYAVAILABLE = 8
BSCF_AVAILABLEDATASIZEUNKNOWN = 16
TCHT_NOWHERE = 1 # Variable c_int
MCM_GETMONTHDELTA = 4115 # Variable c_int
STANDARD_RIGHTS_REQUIRED = 983040 # Variable c_long
TB_SETDRAWTEXTFLAGS = 1094 # Variable c_int
THREAD_QUERY_INFORMATION = 64 # Variable c_int
BM_SETCHECK = 241 # Variable c_int
CO_E_INVALIDSID = -2147220982 # Variable c_long
CBF_FAIL_SELFCONNECTIONS = 4096 # Variable c_int
CTRY_MALAYSIA = 60 # Variable c_int
ERROR_QUORUM_RESOURCE_ONLINE_FAILED = 5027 # Variable c_long
LVCF_IMAGE = 16 # Variable c_int
PROP_LG_CYDLG = 218 # Variable c_int
ERROR_SESSION_CREDENTIAL_CONFLICT = 1219 # Variable c_long
ARW_HIDE = 8 # Variable c_long
KEY_ALL_ACCESS = 983103 # Variable c_long
STATUS_FLOAT_OVERFLOW = 3221225617 # Variable c_ulong
REGISTERED = 4 # Variable c_int
PSP_PREMATURE = 1024 # Variable c_int
EXIT_THREAD_DEBUG_EVENT = 4 # Variable c_int
RPC_X_NO_MORE_ENTRIES = 1772 # Variable c_long
TAPE_UNLOCK = 4 # Variable c_long
LOCALE_IDIGITS = 17 # Variable c_int
IMAGE_SYM_DTYPE_FUNCTION = 2 # Variable c_int
CO_E_FAILEDTOGENUUID = -2147220973 # Variable c_long
IMEVER_0310 = 196618 # Variable c_int
FILE_SUPPORTS_ENCRYPTION = 131072 # Variable c_int
SUBLANG_FRENCH_BELGIAN = 2 # Variable c_int
CFSTR_MIME_X_ART = 'image/x-jg' # Variable POINTER(c_wchar)
SUBLANG_ENGLISH_BELIZE = 10 # Variable c_int
ICM_QUERYMATCH = 7 # Variable c_int
IMAGE_REL_MIPS_REFWORDNB = 34 # Variable c_int
BS_MONOPATTERN = 9 # Variable c_int
ERROR_MEMBER_IN_GROUP = 1320 # Variable c_long
EN_HSCROLL = 1537 # Variable c_int
SPI_SETBEEP = 2 # Variable c_int
ERROR_FULL_BACKUP = 4004 # Variable c_long
PD_SELECTION = 1 # Variable c_int
LVN_ODSTATECHANGED = 4294967181 # Variable c_uint
FS_WANSUNG = 524288 # Variable c_long
AUX_MAPPER = 4294967295 # Variable c_uint
IMAGE_SYM_CLASS_FILE = 103 # Variable c_int
PROCESS_HEAP_REGION = 1 # Variable c_int
FD_SETSIZE = 64 # Variable c_int
RESOURCEDISPLAYTYPE_DIRECTORY = 9 # Variable c_int
PRINTER_CONTROL_PURGE = 3 # Variable c_int
STN_ENABLE = 2 # Variable c_int
PSH_PROPSHEETPAGE = 8 # Variable c_int
IMAGE_SYM_CLASS_STRUCT_TAG = 10 # Variable c_int
S_FALSE = 1 # Variable c_long
LANG_NEPALI = 97 # Variable c_int
FSHIFT = 4 # Variable c_int
TTM_SETMARGIN = 1050 # Variable c_int
EMR_SETARCDIRECTION = 57 # Variable c_int
SB_PAGEDOWN = 3 # Variable c_int
MIXERLINE_COMPONENTTYPE_DST_DIGITAL = 1 # Variable c_long
CB_GETDROPPEDWIDTH = 351 # Variable c_int
TBM_SETTICFREQ = 1044 # Variable c_int
MCIERR_FILE_NOT_SAVED = 286 # Variable c_int
PSINJECT_TRAILER = 14 # Variable c_int
FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192 # Variable c_int
EMR_PIE = 47 # Variable c_int
PROPSHEETPAGEA_V1_SIZE = 40 # Variable c_uint
DCX_PARENTCLIP = 32 # Variable c_long
CAL_SABBREVDAYNAME2 = 15 # Variable c_int
SS_SUNKEN = 4096 # Variable c_long
SEM_NOALIGNMENTFAULTEXCEPT = 4 # Variable c_int
SSF_SOUNDSENTRYON = 1 # Variable c_int
AF_NS = 6 # Variable c_int
SBS_SIZEBOX = 8 # Variable c_long
BF_MIDDLE = 2048 # Variable c_int
WNCON_DYNAMIC = 8 # Variable c_int
WM_AFXFIRST = 864 # Variable c_int
WGL_SWAP_OVERLAY9 = 512 # Variable c_int
ERROR_ALREADY_RUNNING_LKG = 1074 # Variable c_long
TAPE_TENSION = 2 # Variable c_long
LANG_TELUGU = 74 # Variable c_int
DIALOPTION_QUIET = 128 # Variable c_int
KLF_ACTIVATE = 1 # Variable c_int
MCI_SET_AUDIO = 2048 # Variable c_long
TVM_GETITEMHEIGHT = 4380 # Variable c_int

_SID_NAME_USE = c_int # enum
SidTypeUser = 1
SidTypeGroup = 2
SidTypeDomain = 3
SidTypeAlias = 4
SidTypeWellKnownGroup = 5
SidTypeInvalid = 7
SidTypeUnknown = 8
SidTypeComputer = 9
FADF_HAVEIID = 64 # Variable c_int
ERROR_TOO_MANY_CONTEXT_IDS = 1384 # Variable c_long
DT_SINGLELINE = 32 # Variable c_int
TBM_SETTOOLTIPS = 1053 # Variable c_int
MIN_PRIORITY = 1 # Variable c_int
EWX_FORCE = 4 # Variable c_int
MCI_MODE_SEEK = 528 # Variable c_int
IMAGE_REL_BASED_HIGH = 1 # Variable c_int
SPLDS_URL = 'url' # Variable POINTER(c_wchar)
MB_MISCMASK = 49152 # Variable c_long
STG_E_NOTFILEBASEDSTORAGE = -2147286777 # Variable c_long
STD_CUT = 0 # Variable c_int
DMPAPER_ENV_MONARCH = 37 # Variable c_int
XST_DATARCVD = 6 # Variable c_int
LOCKFILE_FAIL_IMMEDIATELY = 1 # Variable c_int
MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER = 4100 # Variable c_long
EMR_SETVIEWPORTEXTEX = 11 # Variable c_int
ERROR_SERVICE_DEPENDENCY_DELETED = 1075 # Variable c_long
DISC_UPDATE_PROFILE = 1 # Variable c_int
CO_E_SCM_ERROR = -2146959358 # Variable c_long
LVS_NOSORTHEADER = 32768 # Variable c_int
WAVE_FORMAT_4M08 = 256 # Variable c_int
ERROR_PRINTER_HAS_JOBS_QUEUED = 3009 # Variable c_long
PRINTER_NOTIFY_FIELD_TOTAL_PAGES = 22 # Variable c_int
RESOURCEDISPLAYTYPE_TREE = 10 # Variable c_int
EMR_STROKEANDFILLPATH = 63 # Variable c_int
LANG_HUNGARIAN = 14 # Variable c_int
PD_PAGENUMS = 2 # Variable c_int
SE_ERR_OOM = 8 # Variable c_int
ERROR_COMMITMENT_LIMIT = 1455 # Variable c_long
VK_SHIFT = 16 # Variable c_int
IPPORT_CMDSERVER = 514 # Variable c_int
SM_CXSMSIZE = 52 # Variable c_int
CTRY_VIET_NAM = 84 # Variable c_int
NCBLISTEN = 17 # Variable c_int
SOCK_RAW = 3 # Variable c_int
FW_DONTCARE = 0 # Variable c_int
SUBLANG_ENGLISH_ZIMBABWE = 12 # Variable c_int
IMAGE_REL_ALPHA_REFLONG = 1 # Variable c_int
ERROR_EA_FILE_CORRUPT = 276 # Variable c_long
NTE_BAD_PROV_TYPE = -2146893804 # Variable c_long
GCP_DIACRITIC = 256 # Variable c_int
SUBLANG_ARABIC_ALGERIA = 5 # Variable c_int
VIEW_VIEWMENU = 12 # Variable c_int
VK_OEM_CLEAR = 254 # Variable c_int
WINSTA_ACCESSCLIPBOARD = 4 # Variable c_long
FR_REPLACEALL = 32 # Variable c_int
ICM_UNREGISTERICMATCHER = 6 # Variable c_int
SEMAPHORE_ALL_ACCESS = 2031619 # Variable c_long
ERROR_MORE_WRITES = 1120 # Variable c_long
DOMAIN_ALIAS_RID_REPLICATOR = 552 # Variable c_long
XST_POKESENT = 7 # Variable c_int
VIF_CANNOTCREATE = 2048 # Variable c_long
LVBKIF_STYLE_MASK = 16 # Variable c_int
STD_PASTE = 2 # Variable c_int
MIXERCONTROL_CT_SUBCLASS_MASK = 251658240 # Variable c_long
SEEK_SET = 0 # Variable c_int
FR_HIDEUPDOWN = 16384 # Variable c_int
PST_RS449 = 5 # Variable c_ulong
MCI_SET_AUDIO_LEFT = 1 # Variable c_long
IGP_GETIMEVERSION = 4294967292 # Variable c_ulong
PARAMFLAG_NONE = 0 # Variable c_int
RPC_BUFFER_EXTRA = 16384 # Variable c_int
RPC_E_INVALID_DATAPACKET = -2147418103 # Variable c_long
CDN_INCLUDEITEM = 4294966688 # Variable c_uint
IMAGE_FILE_DEBUG_STRIPPED = 512 # Variable c_int
SM_CXDLGFRAME = 7 # Variable c_int
TKIND_INTERFACE = 3
LANG_CATALAN = 3 # Variable c_int
IMAGE_REL_SH3_DIRECT8_LONG = 5 # Variable c_int
SPLDS_PRINTER_NAME = 'printerName' # Variable POINTER(c_wchar)
FILEOKSTRINGW = 'commdlg_FileNameOK' # Variable POINTER(c_wchar)
PRINTER_CHANGE_FORM = 458752 # Variable c_int
URLACTION_SHELL_MOVE_OR_COPY = 6146 # Variable c_int
DCX_CLIPSIBLINGS = 16 # Variable c_long
TTM_GETTOOLINFOA = 1032 # Variable c_int
SBM_GETSCROLLINFO = 234 # Variable c_int
CHINESEBIG5_CHARSET = 136 # Variable c_int
IMAGE_REL_MIPS_JMPADDR = 3 # Variable c_int
MIIM_CHECKMARKS = 8 # Variable c_int
IMAGE_DEBUG_TYPE_CODEVIEW = 2 # Variable c_int
PSH_USEPSTARTPAGE = 64 # Variable c_int
MEM_4MB_PAGES = 2147483648 # Variable c_uint
GCL_REVERSE_LENGTH = 3 # Variable c_int
FR_HIDEMATCHCASE = 32768 # Variable c_int
WC_COMBOBOXEXW = 'ComboBoxEx32' # Variable POINTER(c_wchar)
PERF_DISPLAY_NO_SUFFIX = 0 # Variable c_int
SPLDS_PRINT_END_TIME = 'printEndTime' # Variable POINTER(c_wchar)
MCI_WAVE_SET_ANYOUTPUT = 134217728 # Variable c_long
MCI_ANIM_GETDEVCAPS_CAN_REVERSE = 16385 # Variable c_long
MCI_SET_TIME_FORMAT = 1024 # Variable c_long
SOCK_SEQPACKET = 5 # Variable c_int
ERROR_BAD_ARGUMENTS = 160 # Variable c_long
SW_PARENTCLOSING = 1 # Variable c_int
MS_RLSD_ON = 128 # Variable c_ulong
WNNC_NET_INTERGRAPH = 1310720 # Variable c_int
WNNC_NET_LANSTEP = 524288 # Variable c_int
ERROR_BAD_DESCRIPTOR_FORMAT = 1361 # Variable c_long
CAL_SABBREVDAYNAME3 = 16 # Variable c_int
HFILE_ERROR = -1 # Variable c_int
PI_SYNCHRONOUS = 128
ABM_GETSTATE = 4 # Variable c_int
WSF_VISIBLE = 1 # Variable c_long
OLERENDER_NONE = 0
HHT_NOWHERE = 1 # Variable c_int
JOY_BUTTON5 = 16 # Variable c_long
MCIERR_OUTOFRANGE = 282 # Variable c_int
MAP_FOLDDIGITS = 128 # Variable c_int
DM_UPDATE = 1 # Variable c_int
SHGFI_SHELLICONSIZE = 4 # Variable c_int
SP_NOTREPORTED = 16384 # Variable c_int
IO_REPARSE_TAG_NSSRECOVER = 2147483654 # Variable c_uint
MCIERR_DEVICE_TYPE_REQUIRED = 287 # Variable c_int
THREAD_DIRECT_IMPERSONATION = 512 # Variable c_int
IS_TEXT_UNICODE_CONTROLS = 4 # Variable c_int
CRYPT_E_SIGNER_NOT_FOUND = -2146889714 # Variable c_long
NDR_EBCDIC_CHAR = 1 # Variable c_ulong
CO_E_ERRORINAPP = -2147221001 # Variable c_long
NTE_OP_OK = 0 # Variable c_int
DATE_LONGDATE = 2 # Variable c_int
LVN_GETINFOTIPA = 4294967139 # Variable c_uint
META_SETVIEWPORTORG = 525 # Variable c_int
XMLELEMTYPE_TEXT = 1
MAX_PATH = 260 # Variable c_int
OFN_READONLY = 1 # Variable c_int
DMRES_HIGH = -4 # Variable c_int
TVM_SETTOOLTIPS = 4376 # Variable c_int
ERROR_SIGNAL_REFUSED = 156 # Variable c_long
CTRY_ALGERIA = 213 # Variable c_int
IMPLTYPEFLAG_FSOURCE = 2 # Variable c_int
IME_SMODE_NONE = 0 # Variable c_int
MIXERLINE_COMPONENTTYPE_DST_SPEAKERS = 4 # Variable c_long
LVM_SETTOOLTIPS = 4170 # Variable c_int
LOCALE_SMONTHNAME2 = 57 # Variable c_int
TVM_GETNEXTITEM = 4362 # Variable c_int
MK_E_NEEDGENERIC = -2147221022 # Variable c_long
DT_EXPANDTABS = 64 # Variable c_int
scr8 = 1175 # Variable c_int
SM_CYDRAG = 69 # Variable c_int
SBN_FIRST = 4294966416 # Variable c_uint
WM_COMPACTING = 65 # Variable c_int
ERROR_SECTOR_NOT_FOUND = 27 # Variable c_long
PERF_DISPLAY_PERCENT = 536870912 # Variable c_int
TCP_BSDURGENT = 28672 # Variable c_int
VK_SUBTRACT = 109 # Variable c_int
CO_E_SERVER_EXEC_FAILURE = -2146959355 # Variable c_long
LVM_SETCOLUMNORDERARRAY = 4154 # Variable c_int
RPC_C_PROTECT_LEVEL_CALL = 3 # Variable c_int
TWOSTOPBITS = 2 # Variable c_int
TTS_NOPREFIX = 2 # Variable c_int
_NLSCMPERROR = 2147483647 # Variable c_int
SRCERASE = 4457256 # Variable c_ulong
IMAGE_REL_IA64_DIR32 = 4 # Variable c_int
WS_EX_STATICEDGE = 131072 # Variable c_long
MUTANT_ALL_ACCESS = 2031617 # Variable c_long
IMAGE_REL_ALPHA_SECREL = 15 # Variable c_int
SPI_GETLOWPOWERACTIVE = 83 # Variable c_int
SPLDS_ASSET_NUMBER = 'assetNumber' # Variable POINTER(c_wchar)
META_ANIMATEPALETTE = 1078 # Variable c_int
ILC_COLOR16 = 16 # Variable c_int
ERROR_DUPLICATE_SERVICE_NAME = 1078 # Variable c_long
URLACTION_CHANNEL_SOFTDIST_PERMISSIONS = 7685 # Variable c_int
DV_E_TYMED = -2147221399 # Variable c_long
CS_E_PACKAGE_NOTFOUND = -2147221148 # Variable c_long
WGL_SWAP_OVERLAY14 = 16384 # Variable c_int
SPI_SETDESKWALLPAPER = 20 # Variable c_int
LBS_SORT = 2 # Variable c_long
META_RECTANGLE = 1051 # Variable c_int
UPDFCACHE_ALLBUTNODATACACHE = 2147483646 # Variable c_ulong
R2_LAST = 16 # Variable c_int
PST_RS422 = 3 # Variable c_ulong
PFD_TYPE_RGBA = 0 # Variable c_int
PSD_RETURNDEFAULT = 1024 # Variable c_int
HTMINBUTTON = 8 # Variable c_int
LBS_NOINTEGRALHEIGHT = 256 # Variable c_long
ERROR_INVALID_SECURITY_DESCR = 1338 # Variable c_long
HHT_BELOW = 512 # Variable c_int
CUDR_NOPRIMARY = 16 # Variable c_int
ERROR_SHUTDOWN_IN_PROGRESS = 1115 # Variable c_long
TVM_GETINDENT = 4358 # Variable c_int
SECURITY_INTERACTIVE_RID = 4 # Variable c_long
ERROR_BAD_DRIVER = 2001 # Variable c_long
DRV_DISABLE = 5 # Variable c_int
ERROR_TOO_MANY_POSTS = 298 # Variable c_long
IMAGE_ARCHIVE_START_SIZE = 8 # Variable c_int
INET_E_CANNOT_LOAD_DATA = -2146697201 # Variable c_long
FLI_MASK = 4155 # Variable c_int
DISC_NO_FORCE = 64 # Variable c_int
GL_LEVEL_WARNING = 3 # Variable c_int
PRINTACTION_OPEN = 0 # Variable c_int
TC_CR_90 = 8 # Variable c_int
WS_EX_RTLREADING = 8192 # Variable c_long
FS_ARABIC = 64 # Variable c_long
ATTR_CONVERTED = 2 # Variable c_int
BAUD_USER = 268435456 # Variable c_ulong
S_THRESHOLD = 1 # Variable c_int
ERROR_INVALID_ENVIRONMENT = 1805 # Variable c_long
ERROR_INVALID_EA_HANDLE = 278 # Variable c_long
RPC_NCA_FLAGS_IDEMPOTENT = 1 # Variable c_int
WS_CLIPCHILDREN = 33554432 # Variable c_long
TIME_FORCE24HOURFORMAT = 8 # Variable c_int
MCM_GETCOLOR = 4107 # Variable c_int
PAN_SERIF_SQUARE_COVE = 4 # Variable c_int
TIME_BYTES = 4 # Variable c_int
IME_HOTKEY_PRIVATE_FIRST = 512 # Variable c_int
ILC_PALETTE = 2048 # Variable c_int
BS_3STATE = 5 # Variable c_long
PROCESSOR_PPC_603 = 603 # Variable c_int
VK_PAUSE = 19 # Variable c_int
UDS_HORZ = 64 # Variable c_int
SERVICE_START = 16 # Variable c_int
BSF_NOHANG = 8 # Variable c_int
ERROR_DEPENDENCY_NOT_FOUND = 5002 # Variable c_long
PSH_WIZARDHASFINISH = 16 # Variable c_int
MAP_COMPOSITE = 64 # Variable c_int
URLPOLICY_DISALLOW = 3 # Variable c_int
IMAGE_SYM_CLASS_NULL = 0 # Variable c_int
DC_DUPLEX = 7 # Variable c_int
ERROR_INVALID_OPERATION = 4317 # Variable c_long
DC_ORIENTATION = 17 # Variable c_int
CBR_115200 = 115200 # Variable c_int
ERROR_JOIN_TO_SUBST = 140 # Variable c_long
RPC_E_CLIENT_CANTUNMARSHAL_DATA = -2147418100 # Variable c_long
LANG_KONKANI = 87 # Variable c_int
SM_CYMENUCHECK = 72 # Variable c_int
DISPID_DESTRUCTOR = -7 # Variable c_int
URLACTION_JAVA_PERMISSIONS = 7168 # Variable c_int
TYPEFLAG_FHIDDEN = 16
NTE_DOUBLE_ENCRYPT = -2146893806 # Variable c_long
EXCEPTION_CONTINUE_EXECUTION = -1 # Variable c_int
PGM_SETCHILD = 5121 # Variable c_int
ERROR_BAD_LENGTH = 24 # Variable c_long
RPC_S_NO_PROTSEQS_REGISTERED = 1714 # Variable c_long
CLRRTS = 4 # Variable c_int
CRYPT_E_AUTH_ATTR_MISSING = -2146889722 # Variable c_long
IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY = 1 # Variable c_int
JOY_BUTTON8 = 128 # Variable c_long
CTRY_SLOVENIA = 386 # Variable c_int
LVIS_STATEIMAGEMASK = 61440 # Variable c_int
SE_CREATE_PERMANENT_NAME = 'SeCreatePermanentPrivilege' # Variable POINTER(c_wchar)
THREAD_TERMINATE = 1 # Variable c_int
TB_INSERTBUTTONW = 1091 # Variable c_int
ERROR_OPEN_FILES = 2401 # Variable c_long
CDIS_CHECKED = 8 # Variable c_int
ERROR_INVALID_SERVICENAME = 1213 # Variable c_long
SPI_GETMOUSETRAILS = 94 # Variable c_int
SPI_GETTOGGLEKEYS = 52 # Variable c_int
RPC_C_STATS_PKTS_IN = 2 # Variable c_int
ATTR_INPUT = 0 # Variable c_int
CBEN_LAST = 4294966466 # Variable c_uint
VK_NONCONVERT = 29 # Variable c_int
TB_SETBUTTONINFOW = 1088 # Variable c_int
LVIR_BOUNDS = 0 # Variable c_int
RT_CURSOR = 1 # Variable POINTER(c_wchar)
MCIERR_INVALID_FILE = 296 # Variable c_int
CF_OWNERDISPLAY = 128 # Variable c_int
EMARCH_ENC_I17_IC_INST_WORD_X = 3 # Variable c_int
RBN_BEGINDRAG = 4294966461 # Variable c_uint
SS_USERITEM = 10 # Variable c_long
SUBLANG_SPANISH_DOMINICAN_REPUBLIC = 7 # Variable c_int
NI_CHANGECANDIDATELIST = 19 # Variable c_int
HS_FDIAGONAL = 2 # Variable c_int
EVENTLOG_PAIRED_EVENT_ACTIVE = 8 # Variable c_int
IMC_GETCOMPOSITIONFONT = 9 # Variable c_int
IMAGE_DEBUG_TYPE_RESERVED10 = 10 # Variable c_int
TB_GETOBJECT = 1086 # Variable c_int
VAR_FOURDIGITYEARS = 64 # Variable c_ulong
ERROR_GROUP_EXISTS = 1318 # Variable c_long
FF_SWISS = 32 # Variable c_int
TIME_MS = 1 # Variable c_int
MCI_USER_MESSAGES = 3072 # Variable c_int
PERSIST_E_NOTSELFSIZING = -2146762741 # Variable c_long
TBS_TOOLTIPS = 256 # Variable c_int
SKF_STICKYKEYSON = 1 # Variable c_int
UOI_USER_SID = 4 # Variable c_int
MCIERR_DEVICE_NOT_READY = 276 # Variable c_int
MIXER_OBJECTF_HMIDIIN = 3221225472 # Variable c_ulong
ERROR_DS_GC_NOT_AVAILABLE = 1938 # Variable c_long
stc30 = 1117 # Variable c_int
WAVE_FORMAT_1M16 = 4 # Variable c_int
STATUS_TIMEOUT = 258 # Variable c_ulong
LVCFMT_BITMAP_ON_RIGHT = 4096 # Variable c_int
DMBIN_LARGEFMT = 10 # Variable c_int
ERROR_SAME_DRIVE = 143 # Variable c_long
PRIVILEGE_SET_ALL_NECESSARY = 1 # Variable c_int
WGL_SWAP_OVERLAY6 = 64 # Variable c_int
LOCALE_INEGNUMBER = 4112 # Variable c_int
ERROR_NO_NET_OR_BAD_PATH = 1203 # Variable c_long
PRINTER_ENUM_LOCAL = 2 # Variable c_int
LVITEMA_V1_SIZE = 36 # Variable c_uint
PAN_SERIF_NORMAL_SANS = 11 # Variable c_int
LOCALE_STHOUSAND = 15 # Variable c_int
WINSTA_EXITWINDOWS = 64 # Variable c_long
VIF_WRITEPROT = 64 # Variable c_long
AF_UNIX = 1 # Variable c_int
DI_MASK = 1 # Variable c_int
MCI_VD_PLAY_SLOW = 1048576 # Variable c_long
EV_RLSD = 32 # Variable c_int
LB_GETTEXT = 393 # Variable c_int
EMR_POLYTEXTOUTA = 96 # Variable c_int
MS_NBF = 'MNBF' # Variable POINTER(c_char)
TVS_HASLINES = 2 # Variable c_int
REG_DWORD_BIG_ENDIAN = 5 # Variable c_int
MARKPARITY = 3 # Variable c_int
TIME_ONESHOT = 0 # Variable c_int
IMAGE_DEBUG_MISC_EXENAME = 1 # Variable c_int
IMAGE_REL_I386_REL16 = 2 # Variable c_int
PBS_VERTICAL = 4 # Variable c_int
DOF_MULTIPLE = 32772 # Variable c_int
LOCALE_ICALENDARTYPE = 4105 # Variable c_int
ERROR_LAST_ADMIN = 1322 # Variable c_long
CF_EFFECTS = 256 # Variable c_long
PSH_HEADER = 524288 # Variable c_int
SPLDS_PRINT_COLLATE = 'printCollate' # Variable POINTER(c_wchar)
CM_OUT_OF_GAMUT = 255 # Variable c_int
EDGE_BUMP = 9 # Variable c_int
SUBLANG_GERMAN = 1 # Variable c_int
INET_E_NO_VALID_MEDIA = -2146697206 # Variable c_long
NFS_EDIT = 1 # Variable c_int
CPS_COMPLETE = 1 # Variable c_int
QS_MOUSEBUTTON = 4 # Variable c_int
ETO_OPAQUE = 2 # Variable c_int
MCIERR_NO_INTEGER = 312 # Variable c_int
ERROR_DEPENDENCY_ALREADY_EXISTS = 5003 # Variable c_long
SETCOLORTABLE = 4 # Variable c_int
MIXERLINE_LINEF_ACTIVE = 1 # Variable c_long
DC_ICON = 4 # Variable c_int
ILC_COLORDDB = 254 # Variable c_int
IMAGE_SCN_LNK_REMOVE = 2048 # Variable c_int
HTCAPTION = 2 # Variable c_int
PRINTER_NOTIFY_FIELD_DEVMODE = 7 # Variable c_int
PROCESS_VM_WRITE = 32 # Variable c_int
FOREGROUND_RED = 4 # Variable c_int
MDIS_ALLCHILDSTYLES = 1 # Variable c_int
scr7 = 1174 # Variable c_int
IME_PROP_SPECIAL_UI = 131072 # Variable c_int
HDM_GETITEMCOUNT = 4608 # Variable c_int
RBNM_ID = 1 # Variable c_int
R2_BLACK = 1 # Variable c_int
MH_CLEANUP = 4 # Variable c_int
BSM_ALLDESKTOPS = 16 # Variable c_int
INET_E_REDIRECT_FAILED = -2146697196 # Variable c_long
RPC_X_PIPE_EMPTY = 1918 # Variable c_long
HKM_SETRULES = 1027 # Variable c_int
RB_SETBANDINFOA = 1030 # Variable c_int
TBTS_LEFT = 1 # Variable c_int
SPI_GETMOUSEKEYS = 54 # Variable c_int
MMIOERR_PATHNOTFOUND = 267 # Variable c_int
ERROR_DOMAIN_CONTROLLER_NOT_FOUND = 1908 # Variable c_long
CBF_FAIL_ADVISES = 16384 # Variable c_int
GETTECHNOLGY = 20 # Variable c_int
LVNI_BELOW = 512 # Variable c_int
SPI_SETWORKAREA = 47 # Variable c_int
LVM_GETCOLUMNW = 4191 # Variable c_int
DIFFERENCE = 11 # Variable c_int
TVN_SELCHANGEDA = 4294966894 # Variable c_uint
RPC_E_WRONG_THREAD = -2147417842 # Variable c_long
CTLCOLOR_LISTBOX = 2 # Variable c_int
ERROR_DS_CANT_MOD_OBJ_CLASS = 1936 # Variable c_long
NCBFINDNAME = 120 # Variable c_int
ERROR_EVENTLOG_CANT_START = 1501 # Variable c_long
MAC_CHARSET = 77 # Variable c_int
WM_MDIACTIVATE = 546 # Variable c_int
MMIOERR_CANNOTEXPAND = 264 # Variable c_int
RPC_E_INVALID_OBJECT = -2147417836 # Variable c_long
SWP_FRAMECHANGED = 32 # Variable c_int
SEE_MASK_IDLIST = 4 # Variable c_int
ERROR_WMI_ITEMID_NOT_FOUND = 4202 # Variable c_long
SORT_CHINESE_UNICODE = 1 # Variable c_int
CERT_E_UNTRUSTEDROOT = -2146762487 # Variable c_long
ERROR_NO_SUCH_GROUP = 1319 # Variable c_long
JOB_STATUS_PAPEROUT = 64 # Variable c_int
PSINJECT_ENDPROLOG = 6 # Variable c_int
DTM_SETFORMATW = 4146 # Variable c_int
MCI_DEVTYPE_FIRST_USER = 4096 # Variable c_int
LOCALE_SMONTHNAME10 = 65 # Variable c_int
ERROR_FILE_CORRUPT = 1392 # Variable c_long
DMPAPER_EXECUTIVE = 7 # Variable c_int
RPC_E_CALL_REJECTED = -2147418111 # Variable c_long
CAL_SMONTHNAME8 = 28 # Variable c_int
HDS_BUTTONS = 2 # Variable c_int
ERROR_INVALID_STARTING_CODESEG = 188 # Variable c_long
DM_YRESOLUTION = 8192 # Variable c_long
ERROR_NO_SYSTEM_RESOURCES = 1450 # Variable c_long
CT_CTYPE3 = 4 # Variable c_int
IP_ADD_MEMBERSHIP = 5 # Variable c_int
DATABITS_7 = 4 # Variable c_ushort
SPLDS_LOCATION = 'location' # Variable POINTER(c_wchar)
WGL_SWAP_UNDERLAY12 = 134217728 # Variable c_int
PIDSI_AUTHOR = 4 # Variable c_long
ERROR_INVALID_NETNAME = 1214 # Variable c_long
IPM_ISBLANK = 1129 # Variable c_int
MB_ERR_INVALID_CHARS = 8 # Variable c_int
IO_REPARSE_TAG_RESERVED_ZERO = 0 # Variable c_int
CDIS_DEFAULT = 32 # Variable c_int
EMR_EXTCREATEFONTINDIRECTW = 82 # Variable c_int
RPC_S_UNSUPPORTED_TRANS_SYN = 1730 # Variable c_long
TVS_NOSCROLL = 8192 # Variable c_int
SS_OWNERDRAW = 13 # Variable c_long
SETMITERLIMIT = 23 # Variable c_int
ILLUMINANT_DEVICE_DEFAULT = 0 # Variable c_int
SUBLANG_SPANISH_NICARAGUA = 19 # Variable c_int
DS_SYSMODAL = 2 # Variable c_long
SPLDS_PRINT_MAC_ADDRESS = 'printMACAddress' # Variable POINTER(c_wchar)
SB_TOP = 6 # Variable c_int
ISC_SHOWUIALL = 3221225487 # Variable c_uint
RDW_ERASE = 4 # Variable c_int
WGL_SWAP_UNDERLAY11 = 67108864 # Variable c_int
ERROR_NOT_ALL_ASSIGNED = 1300 # Variable c_long
QS_ALLPOSTMESSAGE = 256 # Variable c_int
RPC_X_WRONG_STUB_VERSION = 1829 # Variable c_long
NCBCALL = 16 # Variable c_int
RPC_S_SEND_INCOMPLETE = 1913 # Variable c_long
TAPE_DRIVE_SET_EOT_WZ_SIZE = 4194304 # Variable c_int
OLE_E_ADVISENOTSUPPORTED = -2147221501 # Variable c_long
SECURITY_IDENTIFICATION = 65536 # Variable c_int
FD_CLOSE = 32 # Variable c_int
LBN_SETFOCUS = 4 # Variable c_int
SM_CYMINSPACING = 48 # Variable c_int
TTM_SETDELAYTIME = 1027 # Variable c_int
MDMSPKR_ON = 2 # Variable c_int
cmb1 = 1136 # Variable c_int
MKF_INDICATOR = 32 # Variable c_int
ERROR_INVALID_MINALLOCSIZE = 195 # Variable c_long
S_SERBDNT = -5 # Variable c_int
TAPE_ABSOLUTE_BLOCK = 1 # Variable c_long
META_RESIZEPALETTE = 313 # Variable c_int
TVIF_SELECTEDIMAGE = 32 # Variable c_int

tagVARKIND = c_int # enum
TIMERR_NOCANDO = 97 # Variable c_int
EMR_GLSBOUNDEDRECORD = 103 # Variable c_int
SC_MANAGER_CONNECT = 1 # Variable c_int
EVENTLOG_SUCCESS = 0 # Variable c_int
XTYP_DISCONNECT = 32962 # Variable c_int
DFCS_BUTTON3STATE = 8 # Variable c_int
IMAGE_SCN_CNT_UNINITIALIZED_DATA = 128 # Variable c_int
PI_APARTMENTTHREADED = 256
JOYERR_PARMS = 165 # Variable c_int
DATA_S_SAMEFORMATETC = 262448 # Variable c_long
OLERENDER_DRAW = 1
KEY_EVENT = 1 # Variable c_int
LVS_TYPESTYLEMASK = 64512 # Variable c_int
MB_ICONHAND = 16 # Variable c_long
LINECAPS = 30 # Variable c_int
CBEIF_INDENT = 16 # Variable c_int
DSS_NORMAL = 0 # Variable c_int
SBS_SIZEBOXBOTTOMRIGHTALIGN = 4 # Variable c_long
SOCK_RDM = 4 # Variable c_int
ROTFLAGS_REGISTRATIONKEEPSALIVE = 1 # Variable c_int
GMEM_MOVEABLE = 2 # Variable c_int
SWP_NOREDRAW = 8 # Variable c_int
PORT_TYPE_READ = 2 # Variable c_int
WINDING = 2 # Variable c_int
WNCON_SLOWLINK = 4 # Variable c_int
MCI_STATUS_MEDIA_PRESENT = 5 # Variable c_long
HDM_FIRST = 4608 # Variable c_int
MCI_FORMAT_TMSF = 10 # Variable c_int
IPPROTO_RAW = 255 # Variable c_int
DMDITHER_FINE = 3 # Variable c_int
SPI_GETMOUSE = 3 # Variable c_int
EN_SETFOCUS = 256 # Variable c_int
WNNC_NET_RDR2SAMPLE = 2424832 # Variable c_int
DC_HASDEFID = 21323 # Variable c_int
TVM_DELETEITEM = 4353 # Variable c_int
_SPACE = 8 # Variable c_int
STGM_SHARE_EXCLUSIVE = 16 # Variable c_long
DM_DEFAULTSOURCE = 512 # Variable c_long
LOCALE_SMONTHNAME3 = 58 # Variable c_int
SUBLANG_SPANISH_MODERN = 3 # Variable c_int
CRYPT_E_BAD_MSG = -2146885619 # Variable c_long
URLMON_OPTION_USERAGENT = 268435457 # Variable c_int
ERROR_BAD_PATHNAME = 161 # Variable c_long
IME_PROP_AT_CARET = 65536 # Variable c_int
SOFTDIST_ADSTATE_AVAILABLE = 1 # Variable c_int
IMN_SETOPENSTATUS = 8 # Variable c_int
CC_ANYCOLOR = 256 # Variable c_int
STARTF_USEFILLATTRIBUTE = 16 # Variable c_int
HS_HORIZONTAL = 0 # Variable c_int
HKCOMB_SC = 16 # Variable c_int
EM_CANUNDO = 198 # Variable c_int
RELATIVE = 2 # Variable c_int
RB_INSERTBANDW = 1034 # Variable c_int
ENABLE_MOUSE_INPUT = 16 # Variable c_int
SPI_SETMENUDROPALIGNMENT = 28 # Variable c_int
LVM_GETEDITCONTROL = 4120 # Variable c_int
DCX_VALIDATE = 2097152 # Variable c_long
CA_LOG_FILTER = 2 # Variable c_int
ACM_OPENW = 1127 # Variable c_int
CREATE_DEFAULT_ERROR_MODE = 67108864 # Variable c_int
ERROR_INVALID_COMBOBOX_MESSAGE = 1422 # Variable c_long
CTRY_SWEDEN = 46 # Variable c_int
QUERYROPSUPPORT = 40 # Variable c_int
TVN_ITEMEXPANDINGW = 4294966842 # Variable c_uint
CS_E_FIRST = 2147746148 # Variable c_ulong
ERROR_INVALID_SID = 1337 # Variable c_long
NMPWAIT_USE_DEFAULT_WAIT = 0 # Variable c_int
WM_RBUTTONDBLCLK = 518 # Variable c_int
cmb12 = 1147 # Variable c_int
WGL_SWAP_OVERLAY13 = 8192 # Variable c_int
VARIANT_FALSE = 0 # Variable c_short
DC_TEXT = 8 # Variable c_int
TYPE_E_WRONGTYPEKIND = -2147319766 # Variable c_long

tagTYPEFLAGS = c_int # enum
TYPEFLAG_FAPPOBJECT = 1
TYPEFLAG_FCANCREATE = 2
TYPEFLAG_FLICENSED = 4
TYPEFLAG_FPREDECLID = 8
TYPEFLAG_FCONTROL = 32
TYPEFLAG_FDUAL = 64
TYPEFLAG_FNONEXTENSIBLE = 128
TYPEFLAG_FOLEAUTOMATION = 256
MaxJobObjectInfoClass = 8
CBS_OEMCONVERT = 128 # Variable c_long
WSAEINTR = 10004 # Variable c_int
IE_BAUDRATE = -12 # Variable c_int
TOKEN_SOURCE_LENGTH = 8 # Variable c_int
BM_SETSTATE = 243 # Variable c_int
RPC_S_NAME_SERVICE_UNAVAILABLE = 1762 # Variable c_long
PROP_LG_CXDLG = 252 # Variable c_int
DMLERR_UNADVACKTIMEOUT = 16400 # Variable c_int
TB_INDETERMINATE = 1029 # Variable c_int

IMPORT_OBJECT_NAME_TYPE = c_int # enum
IMPORT_OBJECT_ORDINAL = 0
IMPORT_OBJECT_NAME = 1
IMPORT_OBJECT_NAME_NO_PREFIX = 2
WM_PSD_MARGINRECT = 1027 # Variable c_int
IMAGE_REL_ALPHA_BRADDR = 7 # Variable c_int
IMAGE_SCN_CNT_CODE = 32 # Variable c_int
CCS_NODIVIDER = 64 # Variable c_long
JOB_NOTIFY_FIELD_DEVMODE = 9 # Variable c_int
ES_UPPERCASE = 8 # Variable c_long
VFT2_DRV_SYSTEM = 7 # Variable c_long
MCI_OVLY_PUT_FRAME = 524288 # Variable c_long
DISP_CHANGE_BADMODE = -2 # Variable c_int
NUMPRS_NEG = 65536 # Variable c_int
SORT_CHINESE_BOPOMOFO = 3 # Variable c_int
SPI_SETDOUBLECLICKTIME = 32 # Variable c_int
OLEOBJ_S_INVALIDHWND = 262530 # Variable c_long
LVIR_LABEL = 2 # Variable c_int
UDS_HOTTRACK = 256 # Variable c_int
TBCD_CHANNEL = 3 # Variable c_int
RIP_EVENT = 9 # Variable c_int
ERROR_NOT_CONNECTED = 2250 # Variable c_long
NRC_OSRESNOTAV = 53 # Variable c_int
SECURITY_IMPERSONATION = 131072 # Variable c_int
MDMVOL_HIGH = 2 # Variable c_int
WNNC_NET_10NET = 327680 # Variable c_int
DMLERR_NO_CONV_ESTABLISHED = 16394 # Variable c_int
GW_HWNDFIRST = 0 # Variable c_int
ERROR_FLOPPY_UNKNOWN_ERROR = 1124 # Variable c_long
WSAENOTEMPTY = 10066 # Variable c_int
CD_LBSELNOITEMS = -1 # Variable c_int
LOCALE_SABBREVMONTHNAME11 = 78 # Variable c_int
WM_TIMECHANGE = 30 # Variable c_int
TCS_TABS = 0 # Variable c_int
ERROR_UNKNOWN_PROPERTY = 1608 # Variable c_long
IME_ESC_PRIVATE_FIRST = 2048 # Variable c_int
NTE_PERM = -2146893808 # Variable c_long
SIOCSLOWAT = 2147775234 # Variable c_ulong
DMLERR_UNFOUND_QUEUE_ID = 16401 # Variable c_int
SPLDS_PRINT_RATE = 'printRate' # Variable POINTER(c_wchar)
CS_OWNDC = 32 # Variable c_int
JOB_NOTIFY_FIELD_NOTIFY_NAME = 4 # Variable c_int
TAPE_FORMAT = 5 # Variable c_long
AC_LINE_OFFLINE = 0 # Variable c_int
SND_NOSTOP = 16 # Variable c_int
TBN_RESET = 4294966591 # Variable c_uint
LOCK_ONLYONCE = 4
STRICT = 1 # Variable c_int
TLS_OUT_OF_INDEXES = 4294967295 # Variable c_ulong
RPC_S_UNSUPPORTED_TYPE = 1732 # Variable c_long
MCM_GETMONTHRANGE = 4103 # Variable c_int
CONNDLG_HIDE_BOX = 8 # Variable c_int
ERROR_DC_NOT_FOUND = 1425 # Variable c_long
WNFMT_ABBREVIATED = 2 # Variable c_int
IME_SMODE_SINGLECONVERT = 2 # Variable c_int
TYPE1_FONTTYPE = 131072 # Variable c_int
PROCESSOR_HITACHI_SH4 = 10005 # Variable c_int
ERROR_NULL_LM_PASSWORD = 1304 # Variable c_long
DMBIN_MIDDLE = 3 # Variable c_int
IMAGE_REL_ALPHA_INLINE_REFLONG = 9 # Variable c_int
SPI_GETSHOWSOUNDS = 56 # Variable c_int
SS_GRAYRECT = 5 # Variable c_long
REG_OPENED_EXISTING_KEY = 2 # Variable c_long
ERROR_IS_SUBST_TARGET = 149 # Variable c_long
DM_COPIES = 256 # Variable c_long
SM_CXMIN = 28 # Variable c_int
MCHT_CALENDARDATE = 131073 # Variable c_int
rad10 = 1065 # Variable c_int
RESOURCEUSAGE_ALL = 19 # Variable c_int
SCS_OS216_BINARY = 5 # Variable c_int
HELP_COMMAND = 258 # Variable c_long
DMPAPER_DSHEET = 25 # Variable c_int
LVCFMT_COL_HAS_IMAGES = 32768 # Variable c_int
TAPE_SPACE_END_OF_DATA = 4 # Variable c_long
COMPRESSION_ENGINE_STANDARD = 0 # Variable c_int
MIXERLINE_COMPONENTTYPE_DST_FIRST = 0 # Variable c_long
WT_EXECUTEINIOTHREAD = 1 # Variable c_int
LVN_ITEMCHANGING = 4294967196 # Variable c_uint
ACCESS_ALLOWED_ACE_TYPE = 0 # Variable c_int
RPC_E_NO_SYNC = -2147417824 # Variable c_long
TCM_GETCURFOCUS = 4911 # Variable c_int
CBEN_INSERTITEM = 4294966495 # Variable c_uint
PAN_SERIF_SQUARE = 6 # Variable c_int
JOY_BUTTON24 = 8388608 # Variable c_long
RPC_S_NO_ENDPOINT_FOUND = 1708 # Variable c_long
IN_CLASSC_HOST = 255 # Variable c_int
GL_ID_NODICTIONARY = 16 # Variable c_int
PROFILE_USER = 268435456 # Variable c_int
EN_CHANGE = 768 # Variable c_int
LVCOLUMNW_V1_SIZE = 24 # Variable c_uint
VK_NUMPAD8 = 104 # Variable c_int
FILE_READ_EA = 8 # Variable c_int
C3_FULLWIDTH = 128 # Variable c_int
BATTERY_FLAG_CHARGING = 8 # Variable c_int
TTN_FIRST = 4294966776 # Variable c_uint
ESB_DISABLE_LEFT = 1 # Variable c_int
MDM_TONE_DIAL = 256 # Variable c_int
VIEW_NEWFOLDER = 11 # Variable c_int
EMARCH_ENC_I17_IC_VAL_POS_X = 21 # Variable c_int
LOCALE_NEUTRAL = 0 # Variable c_ulong
MMIO_READ = 0 # Variable c_int
SPLDS_PRINT_MIN_Y_EXTENT = 'printMinYExtent' # Variable POINTER(c_wchar)
ERROR_IS_JOINED = 134 # Variable c_long
TC_VA_ABLE = 16384 # Variable c_int
DOMAIN_ALIAS_RID_POWER_USERS = 547 # Variable c_long
MK_SHIFT = 4 # Variable c_int
OLE_E_NOCACHE = -2147221498 # Variable c_long
IME_ITHOTKEY_RECONVERTSTRING = 515 # Variable c_int
MMIO_DENYWRITE = 32 # Variable c_int
DTM_GETSYSTEMTIME = 4097 # Variable c_int
ERROR_GROUP_NOT_ONLINE = 5014 # Variable c_long
IMAGE_SYM_CLASS_SECTION = 104 # Variable c_int
SPAPI_E_NO_CONFIGMGR_SERVICES = -2146500061 # Variable c_long
EVENTLOG_START_PAIRED_EVENT = 1 # Variable c_int
SPAPI_E_NO_COMPAT_DRIVERS = -2146500056 # Variable c_long
PD_NOPAGENUMS = 8 # Variable c_int
SM_CYMENU = 15 # Variable c_int
RPC_S_INTERFACE_NOT_FOUND = 1759 # Variable c_long
SECURITY_ANONYMOUS_LOGON_RID = 7 # Variable c_long
SOFTDIST_FLAG_USAGE_PRECACHE = 2 # Variable c_int
RPC_NCA_FLAGS_BROADCAST = 2 # Variable c_int
VK_HANGEUL = 21 # Variable c_int
PAGE_EXECUTE_WRITECOPY = 128 # Variable c_int
PWR_SUSPENDRESUME = 2 # Variable c_int
DTR_CONTROL_ENABLE = 1 # Variable c_int
JOY_BUTTON10 = 512 # Variable c_long
DT_METAFILE = 5 # Variable c_int
BF_DIAGONAL_ENDTOPLEFT = 19 # Variable c_int
GCP_LIGATE = 32 # Variable c_int
FILE_ATTRIBUTE_READONLY = 1 # Variable c_int
IMAGE_REL_ALPHA_REFQUAD = 2 # Variable c_int
IMAGE_SIZEOF_NT_OPTIONAL32_HEADER = 224 # Variable c_int
HDF_BITMAP_ON_RIGHT = 4096 # Variable c_int
GDT_NONE = 1 # Variable c_int
MEM_TOP_DOWN = 1048576 # Variable c_int
CB_SETLOCALE = 345 # Variable c_int
ARW_UP = 4 # Variable c_long
ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE = 5030 # Variable c_long
NI_SETCANDIDATE_PAGESTART = 22 # Variable c_int
URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS = 7426 # Variable c_int
CREATE_SUSPENDED = 4 # Variable c_int
LPSTR_TEXTCALLBACKW = 4294967295 # Variable POINTER(c_wchar)
LVS_REPORT = 1 # Variable c_int
TB_MAPACCELERATORA = 1102 # Variable c_int
SB_SETTEXTW = 1035 # Variable c_int
WAVE_FORMAT_4S08 = 512 # Variable c_int
EMARCH_ENC_I17_IMM41c_SIZE_X = 23 # Variable c_int
MIXER_OBJECTF_HWAVEIN = 2684354560 # Variable c_ulong
SO_RCVBUF = 4098 # Variable c_int
LVM_GETITEMTEXTW = 4211 # Variable c_int
IMAGE_SCN_MEM_READ = 1073741824 # Variable c_int
WM_INITMENUPOPUP = 279 # Variable c_int
HELP_SETCONTENTS = 5 # Variable c_long
IMPLTYPEFLAG_FDEFAULTVTABLE = 8 # Variable c_int
SC_CLOSE = 61536 # Variable c_int
RPC_C_IMP_LEVEL_ANONYMOUS = 1 # Variable c_int
SB_HORZ = 0 # Variable c_int
SUBLANG_SERBIAN_CYRILLIC = 3 # Variable c_int
LVS_EX_REGIONAL = 512 # Variable c_int
RC_STRETCHDIB = 8192 # Variable c_int
ERROR_LABEL_TOO_LONG = 154 # Variable c_long
RT_PLUGPLAY = 25 # Variable POINTER(c_wchar)
TCS_TOOLTIPS = 16384 # Variable c_int
META_STRETCHBLT = 2851 # Variable c_int
ERROR_MEMBER_NOT_IN_ALIAS = 1377 # Variable c_long
STGM_WRITE = 1 # Variable c_long
RTS_CONTROL_DISABLE = 0 # Variable c_int
COLOR_ACTIVECAPTION = 2 # Variable c_int
RPC_S_INVALID_VERS_OPTION = 1756 # Variable c_long
VOS_OS216 = 131072 # Variable c_long
SCS_SETSTR = 9 # Variable c_int
EMARCH_ENC_I17_SIGN_VAL_POS_X = 63 # Variable c_int
LZERROR_BADINHANDLE = -1 # Variable c_int
NLS_IME_DISABLE = 536870912 # Variable c_int
OFN_NOTESTFILECREATE = 65536 # Variable c_int
MIXER_GETLINECONTROLSF_ONEBYTYPE = 2 # Variable c_long
CC_ENABLETEMPLATEHANDLE = 64 # Variable c_int
PCF_RLSD = 4 # Variable c_ulong
STG_E_PROPSETMISMATCHED = -2147286800 # Variable c_long
VIFF_FORCEINSTALL = 1 # Variable c_int
MIXERCONTROL_CT_CLASS_FADER = 1342177280 # Variable c_long
JOB_CONTROL_CANCEL = 3 # Variable c_int
CO_E_INIT_TLS_SET_CHANNEL_CONTROL = -2147467253 # Variable c_long
ERROR_INVALID_LIST_FORMAT = 153 # Variable c_long

tagVARFLAGS = c_int # enum
VARFLAG_FREADONLY = 1
VARFLAG_FSOURCE = 2
VARFLAG_FREQUESTEDIT = 8
VARFLAG_FDISPLAYBIND = 16
GRADIENT_FILL_OP_FLAG = 255 # Variable c_int
DD_DEFSCROLLINSET = 11 # Variable c_int
MCI_OPEN_ALIAS = 1024 # Variable c_long
rct3 = 1082 # Variable c_int
SM_CXFULLSCREEN = 16 # Variable c_int
MM_MOM_POSITIONCB = 970 # Variable c_int
IOCPARM_MASK = 127 # Variable c_int
WM_CTLCOLORMSGBOX = 306 # Variable c_int
URLACTION_CHANNEL_SOFTDIST_MAX = 7935 # Variable c_int
CF_DSPMETAFILEPICT = 131 # Variable c_int
PI_CLSIDLOOKUP = 32
DFCS_CAPTIONMIN = 1 # Variable c_int
PFD_STEREO_DONTCARE = 2147483648 # Variable c_uint
NTE_BAD_FLAGS = -2146893815 # Variable c_long
DC_BINADJUST = 19 # Variable c_int
DBG_TERMINATE_PROCESS = 1073807364 # Variable c_ulong
SPLDS_PRINT_MAX_Y_EXTENT = 'printMaxYExtent' # Variable POINTER(c_wchar)
HIST_VIEWTREE = 4 # Variable c_int
IGP_SENTENCE = 12 # Variable c_int
SM_CXICONSPACING = 38 # Variable c_int
WM_SYSCOLORCHANGE = 21 # Variable c_int
APD_STRICT_UPGRADE = 1 # Variable c_int
MIXERCONTROL_CONTROLTYPE_SIGNEDMETER = 268566528 # Variable c_long
TYPE_E_ELEMENTNOTFOUND = -2147319765 # Variable c_long
TBM_GETLINESIZE = 1048 # Variable c_int
READ_CONTROL = 131072 # Variable c_long
STYLE_DESCRIPTION_SIZE = 32 # Variable c_int
PSWIZB_DISABLEDFINISH = 8 # Variable c_int
PRINTER_NOTIFY_FIELD_STATUS_STRING = 19 # Variable c_int
ERROR_DS_NO_ATTRIBUTE_OR_VALUE = 1923 # Variable c_long
MCI_SYSINFO_INSTALLNAME = 2048 # Variable c_long
ERROR_INVALID_WINDOW_HANDLE = 1400 # Variable c_long
MM_MIXM_CONTROL_CHANGE = 977 # Variable c_int
ACN_STOP = 2 # Variable c_int
PSINJECT_ENDSTREAM = 16 # Variable c_int
RBS_REGISTERDROP = 4096 # Variable c_int
CDRF_NOTIFYSUBITEMDRAW = 32 # Variable c_int
TPM_RETURNCMD = 256 # Variable c_long
MCI_RESUME = 2133 # Variable c_int
EMR_SETBRUSHORGEX = 13 # Variable c_int
LANG_DUTCH = 19 # Variable c_int
RPC_C_AUTHN_WINNT = 10 # Variable c_int
WVR_ALIGNBOTTOM = 64 # Variable c_int
DTN_WMKEYDOWNW = 4294966552 # Variable c_uint
TVN_BEGINRDRAGA = 4294966888 # Variable c_uint
WHDR_BEGINLOOP = 4 # Variable c_int
PSM_GETTABCONTROL = 1140 # Variable c_int
RPC_E_CANTCALLOUT_AGAIN = -2147418095 # Variable c_long
IDC_SIZE = 206400 # Variable POINTER(c_wchar)
WSAEADDRNOTAVAIL = 10049 # Variable c_int
ACCESS_DS_OBJECT_TYPE_NAME_A = 'Directory Service Object' # Variable POINTER(c_char)
ST_ISLOCAL = 4 # Variable c_int
PSD_ENABLEPAGEPAINTHOOK = 262144 # Variable c_int
UDS_ALIGNLEFT = 8 # Variable c_int
TAPE_PSEUDO_LOGICAL_BLOCK = 3 # Variable c_long
DROPEFFECT_LINK = 4 # Variable c_int
PF_FLOATING_POINT_PRECISION_ERRATA = 0 # Variable c_int
SBM_SETRANGEREDRAW = 230 # Variable c_int
VK_CONVERT = 28 # Variable c_int
MIXER_GETCONTROLDETAILSF_QUERYMASK = 15 # Variable c_long
PBT_APMPOWERSTATUSCHANGE = 10 # Variable c_int
MCI_INFO_MEDIA_IDENTITY = 2048 # Variable c_long
CO_E_WRONG_SERVER_IDENTITY = -2147467243 # Variable c_long
PGM_SETBKCOLOR = 5124 # Variable c_int
TCM_GETITEMA = 4869 # Variable c_int
SEE_MASK_NO_CONSOLE = 32768 # Variable c_int
PARAMFLAG_FRETVAL = 8 # Variable c_int
PRINTER_STATUS_PAPER_OUT = 16 # Variable c_int
HTHELP = 21 # Variable c_int
DISP_E_NOTACOLLECTION = -2147352559 # Variable c_long
LOCALE_SNATIVECTRYNAME = 8 # Variable c_int
LC_POLYLINE = 2 # Variable c_int
GGO_NATIVE = 2 # Variable c_int
RPC_INTERFACE_HAS_PIPES = 1 # Variable c_int
STG_E_ACCESSDENIED = -2147287035 # Variable c_long
JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO = 4 # Variable c_int
SETLINEJOIN = 22 # Variable c_int
WM_PARENTNOTIFY = 528 # Variable c_int
CS_GLOBALCLASS = 16384 # Variable c_int
LBS_HASSTRINGS = 64 # Variable c_long
SS_GRAYFRAME = 8 # Variable c_long
PI_CLASSINSTALL = 512
DM_ICMINTENT = 16777216 # Variable c_long
PRINTER_NOTIFY_INFO_DISCARDED = 1 # Variable c_int
OLERENDER_FORMAT = 2
JOY_RETURNY = 2 # Variable c_long
JOB_STATUS_PAUSED = 1 # Variable c_int
VARIABLE_PITCH = 2 # Variable c_int
ERROR_NO_VOLUME_LABEL = 125 # Variable c_long
DTM_SETRANGE = 4100 # Variable c_int
MB_SETFOREGROUND = 65536 # Variable c_long
DTS_LONGDATEFORMAT = 4 # Variable c_int
HKM_GETHOTKEY = 1026 # Variable c_int
THREAD_GET_CONTEXT = 8 # Variable c_int
LOCALE_ILZERO = 18 # Variable c_int
CTLCOLOR_SCROLLBAR = 5 # Variable c_int
SECURITY_ENTERPRISE_CONTROLLERS_RID = 9 # Variable c_long
DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 1 # Variable c_int
GCW_ATOM = -32 # Variable c_int
VIF_CANNOTREADDST = 131072 # Variable c_long
SM_CLEANBOOT = 67 # Variable c_int
WM_TIMER = 275 # Variable c_int
IMN_SETSENTENCEMODE = 7 # Variable c_int
DM_ORIENTATION = 1 # Variable c_long
BDR_SUNKENINNER = 8 # Variable c_int
IMAGE_REL_PPC_SECTION = 12 # Variable c_int
INET_E_DATA_NOT_AVAILABLE = -2146697209 # Variable c_long
GGL_INDEX = 2 # Variable c_int
CBS_DROPDOWN = 2 # Variable c_long
RDW_FRAME = 1024 # Variable c_int
stc7 = 1094 # Variable c_int
AF_HYLINK = 15 # Variable c_int
INET_E_ERROR_FIRST = -2146697214 # Variable c_long
BF_RIGHT = 4 # Variable c_int
SEVERITY_SUCCESS = 0 # Variable c_int
PS_SOLID = 0 # Variable c_int
CB_GETEXTENDEDUI = 342 # Variable c_int
WSANO_DATA = 11004 # Variable c_int
PERF_TEXT_ASCII = 65536 # Variable c_int
MCI_ANIM_INFO_TEXT = 65536 # Variable c_long
RPC_C_IMP_LEVEL_DELEGATE = 4 # Variable c_int
MB_DEFBUTTON4 = 768 # Variable c_long
CRYPT_E_REVOKED = -2146885616 # Variable c_long
MOD_RIGHT = 16384 # Variable c_int
HANDLE_FLAG_INHERIT = 1 # Variable c_int
IMAGE_REL_I386_SECTION = 10 # Variable c_int
PRINTACTION_DOCUMENTDEFAULTS = 6 # Variable c_int
MIXERLINE_COMPONENTTYPE_SRC_DIGITAL = 4097 # Variable c_long
ES_AUTOHSCROLL = 128 # Variable c_long
SM_CYFRAME = 33 # Variable c_int
CBS_LOWERCASE = 16384 # Variable c_long
HTMENU = 5 # Variable c_int
MEVT_SHORTMSG = 0 # Variable c_ubyte
TBSTYLE_BUTTON = 0 # Variable c_int
RPC_S_WRONG_KIND_OF_BINDING = 1701 # Variable c_long
PROCESSOR_MOTOROLA_821 = 821 # Variable c_int
MCI_NOTIFY_ABORTED = 4 # Variable c_int
JOY_BUTTON27 = 67108864 # Variable c_long
HDF_LEFT = 0 # Variable c_int
SC_SIZE = 61440 # Variable c_int
EV_BREAK = 64 # Variable c_int
SO_LINGER = 128 # Variable c_int
DC_SMALLCAP = 2 # Variable c_int
IMAGE_REL_ALPHA_REFLONGNB = 16 # Variable c_int
DMPAPER_ENV_PERSONAL = 38 # Variable c_int
DMDUP_VERTICAL = 2 # Variable c_int
IMEVER_0400 = 262144 # Variable c_int
MCIERR_WAVE_INPUTSINUSE = 322 # Variable c_int
MCI_VD_GETDEVCAPS_CLV = 65536 # Variable c_long
SPI_GETWINDOWSEXTENSION = 92 # Variable c_int
HICF_ARROWKEYS = 2 # Variable c_int
CDERR_GENERALCODES = 0 # Variable c_int
DM_MODIFY = 8 # Variable c_int
SPAPI_E_INVALID_PROPPAGE_PROVIDER = -2146500060 # Variable c_long
CFS_EXCLUDE = 128 # Variable c_int
IME_ESC_GETHELPFILENAME = 4107 # Variable c_int
MCI_SEQ_STATUS_SLAVE = 16391 # Variable c_long
EXTTEXTOUT = 512 # Variable c_int
ERROR_INVALID_COMPUTERNAME = 1210 # Variable c_long
lst9 = 1128 # Variable c_int
SUBLANG_SPANISH_CHILE = 13 # Variable c_int
GWL_ID = -12 # Variable c_int
PGF_SCROLLUP = 1 # Variable c_int
WM_QUIT = 18 # Variable c_int
rct4 = 1083 # Variable c_int
MCSC_TEXT = 1 # Variable c_int
NUMPRS_USE_ALL = 4096 # Variable c_int
EM_SETPASSWORDCHAR = 204 # Variable c_int
URLACTION_ACTIVEX_MIN = 4608 # Variable c_int
SPAPI_E_DEVINFO_NOT_REGISTERED = -2146500088 # Variable c_long
MMSYSERR_INVALIDALIAS = 13 # Variable c_int
N_BTSHFT = 4 # Variable c_int
XTYP_ERROR = 32770 # Variable c_int
ES_CONTINUOUS = 2147483648 # Variable c_ulong
SND_ALIAS_START = 0 # Variable c_int
IMAGE_SUBSYSTEM_WINDOWS_GUI = 2 # Variable c_int
HTVSCROLL = 7 # Variable c_int
NM_DBLCLK = 4294967293 # Variable c_uint
GETPAIRKERNTABLE = 258 # Variable c_int
JOB_OBJECT_ALL_ACCESS = 2031647 # Variable c_long
BAUD_128K = 65536 # Variable c_ulong
LVM_GETITEMW = 4171 # Variable c_int
SW_SHOWNOACTIVATE = 4 # Variable c_int
JOB_ALL_ACCESS = 983056 # Variable c_long
TAPE_DRIVE_GET_LOGICAL_BLK = 2097152 # Variable c_int
PAN_LETT_OBLIQUE_OFF_CENTER = 14 # Variable c_int
QUERY_CAN_NAVIGATE = 7
JOY_BUTTON12 = 2048 # Variable c_long
RPC_C_MGMT_INQ_STATS = 2 # Variable c_int
ACCESS_MAX_MS_OBJECT_ACE_TYPE = 8 # Variable c_int
PROP_MED_CYDLG = 215 # Variable c_int
PRINTER_ATTRIBUTE_PUBLISHED = 8192 # Variable c_int
DATA_S_FIRST = 262448 # Variable c_long
TBSTATE_WRAP = 32 # Variable c_int
PROCESSOR_PPC_601 = 601 # Variable c_int
OLEIVERB_INPLACEACTIVATE = -5 # Variable c_long
JOYCAPS_HASPOV = 16 # Variable c_int
THREAD_BASE_PRIORITY_LOWRT = 15 # Variable c_int
GET_TAPE_DRIVE_INFORMATION = 1 # Variable c_int
DMBIN_ENVELOPE = 5 # Variable c_int
PERF_AVERAGE_TIMER = 805438464 # Variable c_int
WSAEISCONN = 10056 # Variable c_int
ERROR_INVALID_FORM_SIZE = 1903 # Variable c_long
JOB_NOTIFY_FIELD_STATUS = 10 # Variable c_int
IMAGE_VXD_SIGNATURE = 17740 # Variable c_int
FILE_SHARE_DELETE = 4 # Variable c_int
TVGN_FIRSTVISIBLE = 5 # Variable c_int
SUBLANG_KASHMIRI_INDIA = 2 # Variable c_int
ERROR_WMI_INVALID_REGINFO = 4211 # Variable c_long
META_ESCAPE = 1574 # Variable c_int
JOY_CAL_READ4 = 524288 # Variable c_long
TCM_SETITEMW = 4925 # Variable c_int
WPF_RESTORETOMAXIMIZED = 2 # Variable c_int
ERROR_RESMON_ONLINE_FAILED = 5018 # Variable c_long
GCPCLASS_PREBOUNDRTL = 64 # Variable c_int
NIF_TIP = 4 # Variable c_int
IMAGE_REL_SH3_SIZEOF_SECTION = 13 # Variable c_int
TAPE_DRIVE_WRITE_SHORT_FMKS = 2214592512 # Variable c_uint
DMPAPER_A4_PLUS = 60 # Variable c_int
MCM_SETFIRSTDAYOFWEEK = 4111 # Variable c_int
LANG_TURKISH = 31 # Variable c_int
PAN_MIDLINE_LOW_TRIMMED = 11 # Variable c_int
ERROR_CONNECTION_ABORTED = 1236 # Variable c_long
PERF_TEXT_UNICODE = 0 # Variable c_int
ERROR_MEDIA_CHANGED = 1110 # Variable c_long
LCMAP_FULLWIDTH = 8388608 # Variable c_int
CO_E_NOTINITIALIZED = -2147221008 # Variable c_long
PRINTER_HTML_VIEW_INSTALL = 2 # Variable c_int
rad11 = 1066 # Variable c_int
COMMON_LVB_GRID_HORIZONTAL = 1024 # Variable c_int
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192 # Variable c_int
CC_CIRCLES = 1 # Variable c_int
WGL_SWAP_UNDERLAY15 = 1073741824 # Variable c_int
RPC_X_BAD_STUB_DATA = 1783 # Variable c_long
STDOLE2_MINORVERNUM = 0 # Variable c_int
SPI_SETFILTERKEYS = 51 # Variable c_int
TB_GETPADDING = 1110 # Variable c_int
MCI_FORMAT_MSF = 2 # Variable c_int
SPI_SETICONTITLEWRAP = 26 # Variable c_int
SC_NEXTWINDOW = 61504 # Variable c_int
JOY_POVRIGHT = 9000 # Variable c_int
CBS_OWNERDRAWVARIABLE = 32 # Variable c_long
MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER = 268632064 # Variable c_long
MCI_PUT = 2114 # Variable c_int
LVN_ENDLABELEDITA = 4294967190 # Variable c_uint
CAL_JAPAN = 3 # Variable c_int
MCIERR_PARAM_OVERFLOW = 268 # Variable c_int
LCS_DEVICE_RGB = 1 # Variable c_long
GRADIENT_FILL_TRIANGLE = 2 # Variable c_int
HDN_BEGINTRACKW = 4294966970 # Variable c_uint
ERROR_NO_BROWSER_SERVERS_FOUND = 6118 # Variable c_long
LVCF_ORDER = 32 # Variable c_int
PSH_USEICONID = 4 # Variable c_int
IMAGE_SCN_LNK_OTHER = 256 # Variable c_int
TB_GETIMAGELIST = 1073 # Variable c_int
PRINTER_CHANGE_ADD_FORM = 65536 # Variable c_int
LVS_SHOWSELALWAYS = 8 # Variable c_int
UDN_DELTAPOS = 4294966574 # Variable c_uint
IMAGE_SUBSYSTEM_OS2_CUI = 5 # Variable c_int
FNERR_BUFFERTOOSMALL = 12291 # Variable c_int
OEM_CHARSET = 255 # Variable c_int
FILE_FILE_COMPRESSION = 16 # Variable c_int
PRINTER_CHANGE_PRINT_PROCESSOR = 117440512 # Variable c_int
JOY_CAL_READ3 = 262144 # Variable c_long
FILE_NOTIFY_CHANGE_DIR_NAME = 2 # Variable c_int
TIME_ZONE_ID_UNKNOWN = 0 # Variable c_int
PSM_UNCHANGED = 1133 # Variable c_int
TBSTYLE_CHECKGROUP = 6 # Variable c_int
E_NOINTERFACE = -2147467262 # Variable c_long
DLL_PROCESS_DETACH = 0 # Variable c_int
RESTORE_CTM = 4100 # Variable c_int
IN_CLASSB_MAX = 65536 # Variable c_int
TB_SETEXTENDEDSTYLE = 1108 # Variable c_int
RPC_E_SERVER_CANTUNMARSHAL_DATA = -2147418098 # Variable c_long
TIMERR_STRUCT = 129 # Variable c_int
CTRY_HONG_KONG = 852 # Variable c_int
MMIO_FINDLIST = 64 # Variable c_int
ST_INLIST = 64 # Variable c_int
ERROR_NO_TRUST_SAM_ACCOUNT = 1787 # Variable c_long
IME_CMODE_FIXED = 2048 # Variable c_int
MCI_ALL_DEVICE_ID = 4294967295 # Variable c_uint
WSAESTALE = 10070 # Variable c_int
DROPEFFECT_COPY = 1 # Variable c_int
CDS_UPDATEREGISTRY = 1 # Variable c_int
PSH_HASHELP = 512 # Variable c_int
WM_PENWINLAST = 911 # Variable c_int
ERROR_CORE_RESOURCE = 5026 # Variable c_long
SM_CYHSCROLL = 3 # Variable c_int
DS_CONTEXTHELP = 8192 # Variable c_long
CDN_INITDONE = 4294966695 # Variable c_uint
MMIO_DELETE = 512 # Variable c_int
ERROR_NO_WILDCARD_CHARACTERS = 1417 # Variable c_long
PRINTER_READ = 131080 # Variable c_long
MK_MBUTTON = 16 # Variable c_int
GWL_EXSTYLE = -20 # Variable c_int
VTBIT_DECIMAL = 16384 # Variable c_int
DV_E_LINDEX = -2147221400 # Variable c_long
TBN_BEGINADJUST = 4294966593 # Variable c_uint
LVM_GETORIGIN = 4137 # Variable c_int
C3_IDEOGRAPH = 256 # Variable c_int
MCI_INFO_FILE = 512 # Variable c_long
OFN_LONGNAMES = 2097152 # Variable c_int
PAN_SERIFSTYLE_INDEX = 1 # Variable c_int
PERF_COUNTER_TIMER = 541132032 # Variable c_int
SND_ALIAS_SYSTEMQUESTION = 16211 # Variable c_ulong
UNICODE_NULL = '\x00' # Variable c_wchar
EM_GETHANDLE = 189 # Variable c_int
IPPORT_NETSTAT = 15 # Variable c_int
EMR_BITBLT = 76 # Variable c_int
MEVT_LONGMSG = 128 # Variable c_ubyte
URLACTION_HTML_SUBMIT_FORMS_FROM = 5634 # Variable c_int
RPC_S_CALL_IN_PROGRESS = 1791 # Variable c_long
CBF_SKIP_ALLNOTIFICATIONS = 3932160 # Variable c_int
PERF_DATA_VERSION = 1 # Variable c_int
TC_OP_CHARACTER = 1 # Variable c_int
DN_DEFAULTPRN = 1 # Variable c_int
PRINTACTION_PROPERTIES = 1 # Variable c_int
SPLDS_PRINT_MAX_X_EXTENT = 'printMaxXExtent' # Variable POINTER(c_wchar)
THREAD_SUSPEND_RESUME = 2 # Variable c_int
ACL_REVISION3 = 3 # Variable c_int
SPAPI_E_INVALID_REG_PROPERTY = -2146500087 # Variable c_long
scr5 = 1172 # Variable c_int
PRINTER_CONTROL_PAUSE = 1 # Variable c_int
ERROR_INVALID_HOOK_FILTER = 1426 # Variable c_long
LANG_FARSI = 41 # Variable c_int
CF_LOCALE = 16 # Variable c_int
MOD_MIDIPORT = 1 # Variable c_int
ABN_POSCHANGED = 1 # Variable c_int
IDI_APPLICATION = 206098 # Variable POINTER(c_wchar)
TAPE_DRIVE_ERASE_BOP_ONLY = 64 # Variable c_int
JOY_BUTTON28 = 134217728 # Variable c_long
SUBLANG_ARABIC_KUWAIT = 13 # Variable c_int
CB_SELECTSTRING = 333 # Variable c_int
S_WHITE512 = 4 # Variable c_int
IMAGE_REL_IA64_SECREL32 = 14 # Variable c_int
GL_ID_TOOMANYSTROKE = 34 # Variable c_int
SPLDS_PRINTER_NAME_ALIASES = 'printerNameAliases' # Variable POINTER(c_wchar)
SHGFI_LARGEICON = 0 # Variable c_int
TCN_SELCHANGING = 4294966744 # Variable c_uint
HICF_RESELECT = 64 # Variable c_int
PSD_MINMARGINS = 1 # Variable c_int
PAN_LETT_NORMAL_WEIGHTED = 3 # Variable c_int
WIZ_BODYCX = 184 # Variable c_int
CLIPBRD_E_CANT_CLOSE = -2147221036 # Variable c_long
TCM_GETCURSEL = 4875 # Variable c_int
DL_CANCELDRAG = 1160 # Variable c_int
WH_HARDWARE = 8 # Variable c_int
LVN_GETDISPINFOA = 4294967146 # Variable c_uint
WB_ISDELIMITER = 2 # Variable c_int
VTBIT_R8 = 32 # Variable c_int
IMAGE_REL_ALPHA_MATCH = 13 # Variable c_int
CC_FULLOPEN = 2 # Variable c_int
TMPF_VECTOR = 2 # Variable c_int
TAPE_DRIVE_SET_REPORT_SMKS = 2147485696 # Variable c_uint
NM_OUTOFMEMORY = 4294967295 # Variable c_uint
ANIMATE_CLASSA = 'SysAnimate32' # Variable POINTER(c_char)
WM_ENABLE = 10 # Variable c_int
MIDIPROP_TIMEDIV = 1 # Variable c_long
SERKF_SERIALKEYSON = 1 # Variable c_int
stc15 = 1102 # Variable c_int
IMAGE_NT_SIGNATURE = 17744 # Variable c_int
IMAGE_REL_ALPHA_SECRELHI = 18 # Variable c_int

tagTYSPEC = c_int # enum
TYSPEC_MIMETYPE = 2
TYSPEC_PROGID = 3
TYSPEC_IID = 4
EMARCH_ENC_I17_IMM41c_INST_WORD_X = 2 # Variable c_int
_LOWER = 2 # Variable c_int
LOCALE_SABBREVMONTHNAME12 = 79 # Variable c_int
MKSYS_GENERICCOMPOSITE = 1
REGULAR_FONTTYPE = 1024 # Variable c_int
GCP_JUSTIFY = 65536 # Variable c_long
MCI_UPDATE = 2132 # Variable c_int
ES_WANTRETURN = 4096 # Variable c_long
LVS_SINGLESEL = 4 # Variable c_int
TKF_INDICATOR = 32 # Variable c_int
CTRY_SYRIA = 963 # Variable c_int
ISC_SHOWUIGUIDELINE = 1073741824 # Variable c_int
WM_IME_COMPOSITIONFULL = 644 # Variable c_int
TTM_GETTEXTW = 1080 # Variable c_int
SEEK_END = 2 # Variable c_int
TVM_GETEDITCONTROL = 4367 # Variable c_int
SM_CYDOUBLECLK = 37 # Variable c_int
FILE_TRAVERSE = 32 # Variable c_int
CBEM_GETITEMA = 1028 # Variable c_int
TRUST_E_COUNTER_SIGNER = -2146869245 # Variable c_long
SET_MIRROR_MODE = 4110 # Variable c_int
FACILITY_ITF = 4 # Variable c_int
ES_READONLY = 2048 # Variable c_long
WH_FOREGROUNDIDLE = 11 # Variable c_int
MAXINTATOM = 49152 # Variable c_int
DISP_E_BADINDEX = -2147352565 # Variable c_long
STATUS_FLOAT_INVALID_OPERATION = 3221225616 # Variable c_ulong
TC_EA_DOUBLE = 512 # Variable c_int
SYSTEM_AUDIT_OBJECT_ACE_TYPE = 7 # Variable c_int
DMTT_DOWNLOAD = 2 # Variable c_int
SUBLANG_DUTCH_BELGIAN = 2 # Variable c_int
WM_ICONERASEBKGND = 39 # Variable c_int
TBDDRET_DEFAULT = 0 # Variable c_int
PROCESSOR_INTEL_PENTIUM = 586 # Variable c_int
AF_DLI = 13 # Variable c_int
MM_JOY2ZMOVE = 931 # Variable c_int
LVFI_STRING = 2 # Variable c_int
SPAPI_E_INVALID_MACHINENAME = -2146500064 # Variable c_long
TB_SETDISABLEDIMAGELIST = 1078 # Variable c_int
CF_DSPBITMAP = 130 # Variable c_int

_CM_SERVICE_LOAD_TYPE = c_int # enum
SystemLoad = 1
AutoLoad = 2
DemandLoad = 3
DisableLoad = 4
MIXERCONTROL_CONTROLTYPE_EQUALIZER = 1342373892 # Variable c_long
SKF_CONFIRMHOTKEY = 8 # Variable c_int
cmb2 = 1137 # Variable c_int
ERROR_ALLOTTED_SPACE_EXCEEDED = 1344 # Variable c_long
LOCALE_ICURRDIGITS = 25 # Variable c_int
EMR_RESIZEPALETTE = 51 # Variable c_int
OLE_S_STATIC = 262145 # Variable c_long
MSGF_NEXTWINDOW = 6 # Variable c_int
LPD_STEREO = 2 # Variable c_int
CONVERT10_S_FIRST = 262592 # Variable c_long
RBBS_BREAK = 1 # Variable c_int
PRINTER_ENUM_NAME = 8 # Variable c_int
CUDR_NORMAL = 0 # Variable c_int
ERROR_SEVERITY_SUCCESS = 0 # Variable c_int
TVN_BEGINRDRAGW = 4294966839 # Variable c_uint
TVHT_ABOVE = 256 # Variable c_int
PSN_FIRST = 4294967096 # Variable c_uint
GCPCLASS_ARABIC = 2 # Variable c_int
PROOF_QUALITY = 2 # Variable c_int
OLERENDER_ASIS = 3
CS_BYTEALIGNCLIENT = 4096 # Variable c_int
ERROR_NOT_FOUND = 1168 # Variable c_long
REGISTERING = 0 # Variable c_int
MCI_RECORD_INSERT = 256 # Variable c_long
TC_RA_ABLE = 8192 # Variable c_int
TOKEN_QUERY_SOURCE = 16 # Variable c_int
RPC_C_PROFILE_ALL_ELT = 1 # Variable c_int
IMAGE_REL_MIPS_GPREL = 6 # Variable c_int
TPM_BOTTOMALIGN = 32 # Variable c_long
LANG_POLISH = 21 # Variable c_int
PARITY_EVEN = 1024 # Variable c_ushort
CB_MSGMAX = 354 # Variable c_int
DMPAPER_ENV_12 = 22 # Variable c_int
ERROR_WMI_GUID_DISCONNECTED = 4207 # Variable c_long
IME_THOTKEY_SHAPE_TOGGLE = 113 # Variable c_int
ERROR_EVENTLOG_FILE_CORRUPT = 1500 # Variable c_long
LR_LOADTRANSPARENT = 32 # Variable c_int
PERF_NUMBER_HEX = 0 # Variable c_int
DMDITHER_USER = 256 # Variable c_int
HOTKEY_CLASSA = 'msctls_hotkey32' # Variable POINTER(c_char)
TVGN_PREVIOUSVISIBLE = 7 # Variable c_int
MA_NOACTIVATEANDEAT = 4 # Variable c_int
SERVICE_START_PENDING = 2 # Variable c_int
SS_BITMAP = 14 # Variable c_long
LVM_UPDATE = 4138 # Variable c_int
WS_THICKFRAME = 262144 # Variable c_long
JOY_RETURNCENTERED = 1024 # Variable c_long
WM_MDIREFRESHMENU = 564 # Variable c_int
IMAGE_DIRECTORY_ENTRY_IMPORT = 1 # Variable c_int
EM_SETRECT = 179 # Variable c_int
TBM_SETSELSTART = 1035 # Variable c_int
KEY_SET_VALUE = 2 # Variable c_int
URLPOLICY_JAVA_LOW = 196608 # Variable c_int
SPI_SETMOUSEKEYS = 55 # Variable c_int
STATUS_ILLEGAL_VLM_REFERENCE = 3221226176 # Variable c_ulong
WIZ_CYDLG = 140 # Variable c_int
S_WHITE1024 = 5 # Variable c_int
MB_DEFBUTTON1 = 0 # Variable c_long
XCLASS_NOTIFICATION = 32768 # Variable c_int
ERROR_HOST_NODE_NOT_RESOURCE_OWNER = 5015 # Variable c_long
SUBLANG_ARABIC_BAHRAIN = 15 # Variable c_int
SUBLANG_SYS_DEFAULT = 2 # Variable c_int
TAPE_DRIVE_FORMAT = 2684354560 # Variable c_uint
WSAEWOULDBLOCK = 10035 # Variable c_int
HDM_LAYOUT = 4613 # Variable c_int
FS_JOHAB = 2097152 # Variable c_long
MMIO_READWRITE = 2 # Variable c_int
WM_PASTE = 770 # Variable c_int
DISP_E_PARAMNOTFOUND = -2147352572 # Variable c_long
URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE = 65536 # Variable c_int
ERROR_WINDOW_NOT_COMBOBOX = 1423 # Variable c_long
lst11 = 1130 # Variable c_int
SUBLANG_CHINESE_HONGKONG = 3 # Variable c_int
LANG_ASSAMESE = 77 # Variable c_int
IN_CLASSB_NSHIFT = 16 # Variable c_int
MIIM_STATE = 1 # Variable c_int
CALLBACK_THREAD = 131072 # Variable c_long
cmb10 = 1145 # Variable c_int
WGL_SWAP_OVERLAY11 = 2048 # Variable c_int
DT_CALCRECT = 1024 # Variable c_int
SUBLANG_ENGLISH_TRINIDAD = 11 # Variable c_int
PSCB_PRECREATE = 2 # Variable c_int
RT_FONTDIR = 7 # Variable POINTER(c_wchar)
MIXER_OBJECTF_WAVEIN = 536870912 # Variable c_long
CBS_SORT = 256 # Variable c_long
MM_STREAM_OPEN = 980 # Variable c_int
ILLUMINANT_D65 = 6 # Variable c_int
IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11 # Variable c_int
VK_CONTROL = 17 # Variable c_int
PC_POLYGON = 1 # Variable c_int
ERROR_SERVER_NOT_DISABLED = 1342 # Variable c_long
ERROR_BAD_PIPE = 230 # Variable c_long
TAPE_DRIVE_WRITE_LONG_FMKS = 2281701376 # Variable c_uint
LPSTR_TEXTCALLBACKA = 4294967295 # Variable POINTER(c_char)
MCI_WAVE_MAPPER = 1153 # Variable c_int
TAPE_FIXED_PARTITIONS = 0 # Variable c_long
SWP_DEFERERASE = 8192 # Variable c_int
MAX_JOYSTICKOEMVXDNAME = 260 # Variable c_int
SIF_DISABLENOSCROLL = 8 # Variable c_int
LVCFMT_JUSTIFYMASK = 3 # Variable c_int
MMIOERR_SHARINGVIOLATION = 269 # Variable c_int
PERF_COUNTER_DELTA = 4195328 # Variable c_int

xmlelemTYPE = c_int # enum
XMLELEMTYPE_ELEMENT = 0
PAN_WEIGHT_NORD = 11 # Variable c_int
RPC_C_MGMT_INQ_PRINC_NAME = 1 # Variable c_int
PORT_STATUS_TYPE_ERROR = 1 # Variable c_int
HDN_FIRST = 4294966996 # Variable c_uint
C2_EUROPETERMINATOR = 5 # Variable c_int
CBEM_INSERTITEMA = 1025 # Variable c_int
SPLREG_ARCHITECTURE = 'Architecture' # Variable POINTER(c_wchar)
TB_GETINSERTMARK = 1103 # Variable c_int
WNNC_NET_FTP_NFS = 786432 # Variable c_int
HEAP_TAIL_CHECKING_ENABLED = 32 # Variable c_int
ERROR_NO_SHUTDOWN_IN_PROGRESS = 1116 # Variable c_long
IDOK = 1 # Variable c_int

tagMKSYS = c_int # enum
MKSYS_NONE = 0
MKSYS_FILEMONIKER = 2
MKSYS_ITEMMONIKER = 4
LVM_SORTITEMS = 4144 # Variable c_int
IME_ESC_AUTOMATA = 4105 # Variable c_int
IDANI_OPEN = 1 # Variable c_int
HKCOMB_SA = 32 # Variable c_int
PSD_SHOWHELP = 2048 # Variable c_int
PRINTER_ERROR_WARNING = 1073741824 # Variable c_int
ERROR_INVALID_SERVICE_LOCK = 1071 # Variable c_long
RT_ICON = 3 # Variable POINTER(c_wchar)
VK_F4 = 115 # Variable c_int
LVM_GETHOTITEM = 4157 # Variable c_int
PSH_USEPAGELANG = 2097152 # Variable c_int
ERROR_FILENAME_EXCED_RANGE = 206 # Variable c_long
MAXIMUM_WAIT_OBJECTS = 64 # Variable c_int
FILE_ACTION_RENAMED_OLD_NAME = 4 # Variable c_int
LOCALE_SABBREVDAYNAME3 = 51 # Variable c_int
DC_EMF_COMPLIANT = 20 # Variable c_int
PIDSI_WORDCOUNT = 15 # Variable c_long
TURKISH_CHARSET = 162 # Variable c_int
FRERR_FINDREPLACECODES = 16384 # Variable c_int
OLE_E_ENUM_NOMORE = -2147221502 # Variable c_long
EMBDHLP_INPROC_SERVER = 1 # Variable c_long
LOCALE_SDAYNAME6 = 47 # Variable c_int
VK_F14 = 125 # Variable c_int
SUBLANG_SPANISH = 1 # Variable c_int
POSTSCRIPT_INJECTION = 4118 # Variable c_int
NTE_PROVIDER_DLL_FAIL = -2146893795 # Variable c_long
SPI_SETSCREENSAVETIMEOUT = 15 # Variable c_int
BOLD_FONTTYPE = 256 # Variable c_int
MCI_VD_STEP_FRAMES = 65536 # Variable c_long
MF_END = 128 # Variable c_long
LVS_EX_INFOTIP = 1024 # Variable c_int
PC_RECTANGLE = 2 # Variable c_int
PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS = 256 # Variable c_int
IDC_HELP = 206417 # Variable POINTER(c_wchar)
TBIMHT_BACKGROUND = 2 # Variable c_int
LOCALE_IINTLCURRDIGITS = 26 # Variable c_int
GCPCLASS_POSTBOUNDLTR = 32 # Variable c_int
ERROR_WRONG_EFS = 6005 # Variable c_long
DDL_EXCLUSIVE = 32768 # Variable c_int
SPI_GETPOWEROFFTIMEOUT = 80 # Variable c_int
LR_COPYDELETEORG = 8 # Variable c_int
VK_MULTIPLY = 106 # Variable c_int
MB_ICONMASK = 240 # Variable c_long
MULTIFILEOPENORD = 1537 # Variable c_int
rad12 = 1067 # Variable c_int
SECURITY_SQOS_PRESENT = 1048576 # Variable c_int
GETVECTORBRUSHSIZE = 27 # Variable c_int
DMPAPER_B_PLUS = 58 # Variable c_int
LBS_NOREDRAW = 4 # Variable c_long
SS_CENTER = 1 # Variable c_long
ASYNC_MODE_COMPATIBILITY = 1 # Variable c_long
SW_SHOWMAXIMIZED = 3 # Variable c_int
ERROR_DEV_NOT_EXIST = 55 # Variable c_long
UOI_FLAGS = 1 # Variable c_int
TVN_BEGINLABELEDITW = 4294966837 # Variable c_uint
ERROR_INVALID_MESSAGE = 1002 # Variable c_long
CALLBACK_NULL = 0 # Variable c_long
LVHT_ABOVE = 8 # Variable c_int
FW_MEDIUM = 500 # Variable c_int
CTRY_FRANCE = 33 # Variable c_int
SPLDS_PRINT_ATTRIBUTES = 'printAttributes' # Variable POINTER(c_wchar)
ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = 1459 # Variable c_long
C2_EUROPESEPARATOR = 4 # Variable c_int
STG_E_INVALIDNAME = -2147286788 # Variable c_long
DMDITHER_RESERVED9 = 9 # Variable c_int
ERROR_DS_CROSS_DOM_MOVE_ERROR = 1937 # Variable c_long
SO_CONNDATA = 28672 # Variable c_int
PAN_LETTERFORM_INDEX = 7 # Variable c_int
S_PERIOD512 = 0 # Variable c_int
PSN_WIZNEXT = 4294967089 # Variable c_uint
DM_PELSHEIGHT = 1048576 # Variable c_long
RPC_S_ALREADY_LISTENING = 1713 # Variable c_long
IMAGE_SYM_CLASS_FUNCTION = 101 # Variable c_int
SPI_SETGRIDGRANULARITY = 19 # Variable c_int
TTM_GETTOOLCOUNT = 1037 # Variable c_int
MCI_DEVTYPE_SEQUENCER = 523 # Variable c_int
DC_FIELDS = 1 # Variable c_int
UDS_WRAP = 1 # Variable c_int
SYMBOL_CHARSET = 2 # Variable c_int
ERROR_NO_DATA_DETECTED = 1104 # Variable c_long
DV_E_DVTARGETDEVICE = -2147221403 # Variable c_long
ERROR_DS_INVALID_ATTRIBUTE_SYNTAX = 1924 # Variable c_long
EM_GETLINE = 196 # Variable c_int
SECURITY_BATCH_RID = 3 # Variable c_long
JOY_RETURNPOVCTS = 512 # Variable c_long
ERROR_HOTKEY_NOT_REGISTERED = 1419 # Variable c_long
CCM_SETCOLORSCHEME = 8194 # Variable c_int
IP_MULTICAST_LOOP = 4 # Variable c_int
MCIERR_DEVICE_NOT_INSTALLED = 306 # Variable c_int
NDR_INT_REP_MASK = 240 # Variable c_ulong
IMAGE_REL_IA64_GPREL22 = 9 # Variable c_int
C1_SPACE = 8 # Variable c_int
ERROR_OUT_OF_STRUCTURES = 84 # Variable c_long
NTM_TYPE1 = 1048576 # Variable c_int
IME_CMODE_KATAKANA = 2 # Variable c_int
MCI_SEQ_STATUS_PORT = 16387 # Variable c_long
URLACTION_ACTIVEX_TREATASUNTRUSTED = 4613 # Variable c_int
TBS_RIGHT = 0 # Variable c_int
TB_GETROWS = 1064 # Variable c_int
GCS_RESULTCLAUSE = 4096 # Variable c_int
OBJ_BITMAP = 7 # Variable c_int
DOMAIN_ALIAS_RID_PRINT_OPS = 550 # Variable c_long
GCL_CONVERSION = 1 # Variable c_int
LOCALE_USE_CP_ACP = 1073741824 # Variable c_int
VIEW_SMALLICONS = 1 # Variable c_int
SUBLANG_AZERI_CYRILLIC = 2 # Variable c_int
CRYPT_E_SECURITY_SETTINGS = -2146885594 # Variable c_long
STG_E_INVALIDHANDLE = -2147287034 # Variable c_long
USER_MARSHAL_FC_DOUBLE = 12 # Variable c_int
C1_CNTRL = 32 # Variable c_int
GW_HWNDNEXT = 2 # Variable c_int
THAI_CHARSET = 222 # Variable c_int
THREAD_SET_THREAD_TOKEN = 128 # Variable c_int
MCI_ANIM_PUT_DESTINATION = 262144 # Variable c_long
ESB_ENABLE_BOTH = 0 # Variable c_int
PRINTER_STATUS_PAPER_PROBLEM = 64 # Variable c_int
DRV_CONFIGURE = 7 # Variable c_int
PFD_OVERLAY_PLANE = 1 # Variable c_int
SECTION_EXTEND_SIZE = 16 # Variable c_int
CUDR_NORESOLVEPOSITIONS = 2 # Variable c_int
EMR_SETWINDOWEXTEX = 9 # Variable c_int
BAUD_075 = 1 # Variable c_ulong
RESOURCE_GLOBALNET = 2 # Variable c_int
RB_GETRECT = 1033 # Variable c_int
IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7 # Variable c_int
MCIERR_SEQ_NOMIDIPRESENT = 343 # Variable c_int
MCI_SEQ_SET_OFFSET = 16777216 # Variable c_long
ELF_CULTURE_LATIN = 0 # Variable c_int
TTM_ADDTOOLW = 1074 # Variable c_int
PSP_HASHELP = 32 # Variable c_int
MM_JOY2BUTTONDOWN = 950 # Variable c_int
TF_WRITE_BEHIND = 4 # Variable c_int
ERROR_SPECIAL_GROUP = 1372 # Variable c_long
stc2 = 1089 # Variable c_int
DDL_DRIVES = 16384 # Variable c_int
PERF_TYPE_TEXT = 2048 # Variable c_int
GCL_CBWNDEXTRA = -18 # Variable c_int
IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8 # Variable c_int
SSTF_NONE = 0 # Variable c_int
IMAGE_SYM_CLASS_ARGUMENT = 9 # Variable c_int
IDLE_PRIORITY_CLASS = 64 # Variable c_int
stc12 = 1099 # Variable c_int
WM_MEASUREITEM = 44 # Variable c_int
ERROR_BAD_USERNAME = 2202 # Variable c_long
DISP_CHANGE_SUCCESSFUL = 0 # Variable c_int
IMAGE_REL_ALPHA_REFQ1 = 21 # Variable c_int
LVM_GETCOLUMNWIDTH = 4125 # Variable c_int
ANTIALIASED_QUALITY = 4 # Variable c_int
FILE_FLAG_BACKUP_SEMANTICS = 33554432 # Variable c_int
WAVE_FORMAT_QUERY = 1 # Variable c_int
EMR_POLYPOLYLINE16 = 90 # Variable c_int
ERROR_INVALID_SHARENAME = 1215 # Variable c_long
ESB_DISABLE_BOTH = 3 # Variable c_int
OFN_SHAREFALLTHROUGH = 2 # Variable c_int
PERF_COUNTER_RAWCOUNT = 65536 # Variable c_int
CP_SUPPORTED = 2 # Variable c_int
TBM_GETBUDDY = 1057 # Variable c_int
RB_GETROWHEIGHT = 1038 # Variable c_int
META_CREATEFONTINDIRECT = 763 # Variable c_int
LVM_SETCOLUMNA = 4122 # Variable c_int
MIXERCONTROL_CONTROLTYPE_MICROTIME = 1610809344 # Variable c_long
TBM_GETTOOLTIPS = 1054 # Variable c_int
MOVEFILE_WRITE_THROUGH = 8 # Variable c_int
ERROR_ACCOUNT_RESTRICTION = 1327 # Variable c_long
OUT_STRING_PRECIS = 1 # Variable c_int
SERVICE_CONTINUE_PENDING = 5 # Variable c_int
ERROR_INCORRECT_ADDRESS = 1241 # Variable c_long
ACL_REVISION4 = 4 # Variable c_int
SUBLANG_MALAY_MALAYSIA = 1 # Variable c_int
PORT_TYPE_WRITE = 1 # Variable c_int
PT_LINETO = 2 # Variable c_int
URLACTION_SHELL_MIN = 6144 # Variable c_int
GETSCALINGFACTOR = 14 # Variable c_int
DMBIN_TRACTOR = 8 # Variable c_int
MF_CHANGE = 128 # Variable c_long
IS_TEXT_UNICODE_NULL_BYTES = 4096 # Variable c_int
C2_ARABICNUMBER = 6 # Variable c_int
SW_SHOWNA = 8 # Variable c_int
PROCESSOR_ARCHITECTURE_PPC = 3 # Variable c_int
TVN_BEGINDRAGA = 4294966889 # Variable c_uint
LOCALE_SABBREVMONTHNAME13 = 4111 # Variable c_int
USER_MARSHAL_FC_LONG = 8 # Variable c_int
PS_NULL = 5 # Variable c_int
GW_HWNDPREV = 3 # Variable c_int
TCM_GETITEMRECT = 4874 # Variable c_int
MAXBYTE = 255 # Variable c_int
TVIS_EXPANDPARTIAL = 128 # Variable c_int
SUBLANG_ARABIC_YEMEN = 9 # Variable c_int
LANG_DANISH = 6 # Variable c_int
IMAGE_SYM_CLASS_MEMBER_OF_ENUM = 16 # Variable c_int
TB_SETINSERTMARK = 1104 # Variable c_int
LOCALE_SNEGATIVESIGN = 81 # Variable c_int
ERROR_DEVICE_NOT_CONNECTED = 1167 # Variable c_long
MHDR_DONE = 1 # Variable c_int
MCM_GETMAXTODAYWIDTH = 4117 # Variable c_int
STG_E_UNKNOWN = -2147286787 # Variable c_long
CFSTR_MIME_X_MSVIDEO = 'video/x-msvideo' # Variable POINTER(c_wchar)
MCI_ANIM_STEP_REVERSE = 65536 # Variable c_long
ERROR_TOKEN_ALREADY_IN_USE = 1375 # Variable c_long
WM_DDE_FIRST = 992 # Variable c_int
NFS_ALL = 16 # Variable c_int
WSB_PROP_CXHSCROLL = 2 # Variable c_long
IDC_SIZENWSE = 206402 # Variable POINTER(c_wchar)
SPLREG_PORT_THREAD_PRIORITY_DEFAULT = 'PortThreadPriorityDefault' # Variable POINTER(c_wchar)
GRADIENT_FILL_RECT_V = 1 # Variable c_int
WM_SYSCOMMAND = 274 # Variable c_int
PROTOCOLFLAG_NO_PICS_CHECK = 1 # Variable c_int
HHT_ABOVE = 256 # Variable c_int
LB_SETTABSTOPS = 402 # Variable c_int
RPC_E_INVALID_HEADER = -2147417839 # Variable c_long
IME_CHOTKEY_SYMBOL_TOGGLE = 18 # Variable c_int
PAN_FAMILY_DECORATIVE = 4 # Variable c_int
SUBLANG_URDU_PAKISTAN = 1 # Variable c_int
SM_CXMAXTRACK = 59 # Variable c_int
ERROR_INVALID_MEMBER = 1388 # Variable c_long
SKF_AUDIBLEFEEDBACK = 64 # Variable c_int
MDM_V23_OVERRIDE = 1024 # Variable c_int
FILE_WRITE_EA = 16 # Variable c_int
WM_ASKCBFORMATNAME = 780 # Variable c_int
TB_REPLACEBITMAP = 1070 # Variable c_int
CTRY_ITALY = 39 # Variable c_int
STATUS_FLOAT_UNDERFLOW = 3221225619 # Variable c_ulong
ERROR_NO_EFS = 6004 # Variable c_long

tagOLECLOSE = c_int # enum
PRINTER_NOTIFY_FIELD_SEPFILE = 8 # Variable c_int
GB2312_CHARSET = 134 # Variable c_int
IMN_SETCOMPOSITIONFONT = 10 # Variable c_int
EVENTLOG_INFORMATION_TYPE = 4 # Variable c_int
DMPAPER_ENV_10 = 20 # Variable c_int
WM_MDICREATE = 544 # Variable c_int
CREATE_FORCEDOS = 8192 # Variable c_int
ERROR_NO_SUCH_ALIAS = 1376 # Variable c_long
WS_DLGFRAME = 4194304 # Variable c_long
FRERR_BUFFERLENGTHZERO = 16385 # Variable c_int
RPC_BUFFER_COMPLETE = 4096 # Variable c_int
MIXERCONTROL_CONTROLTYPE_UNSIGNED = 805502976 # Variable c_long
MARSHAL_S_LAST = 262447 # Variable c_long
VFT2_DRV_INPUTMETHOD = 11 # Variable c_long
USER_MARSHAL_FC_USHORT = 7 # Variable c_int
URLTEMPLATE_PREDEFINED_MIN = 65536
PRINTER_ATTRIBUTE_HIDDEN = 32 # Variable c_int
FILE_NOTIFY_CHANGE_SIZE = 8 # Variable c_int
NM_LAST = 4294967197 # Variable c_uint
BN_DISABLE = 4 # Variable c_int
CC_CHORD = 4 # Variable c_int

tagPENDINGTYPE = c_int # enum
TBM_SETPOS = 1029 # Variable c_int
BS_USERBUTTON = 8 # Variable c_long
ID_PSREBOOTSYSTEM = 3 # Variable c_int
MCIERR_MISSING_PARAMETER = 273 # Variable c_int
MB_DEFBUTTON3 = 512 # Variable c_long
WS_EX_LEFT = 0 # Variable c_long
URLTEMPLATE_LOW = 65536
DTM_GETRANGE = 4099 # Variable c_int
EFS_USE_RECOVERY_KEYS = 1 # Variable c_int
DISP_E_UNKNOWNNAME = -2147352570 # Variable c_long
SIF_PAGE = 2 # Variable c_int
GM_COMPATIBLE = 1 # Variable c_int
COLOR_BTNTEXT = 18 # Variable c_int
SC_MANAGER_LOCK = 8 # Variable c_int
TBSTATE_INDETERMINATE = 16 # Variable c_int
DMLERR_SYS_ERROR = 16399 # Variable c_int
PRINTER_NOTIFY_FIELD_ATTRIBUTES = 13 # Variable c_int
IMAGE_COMDAT_SELECT_NEWEST = 7 # Variable c_int
ERROR_IO_INCOMPLETE = 996 # Variable c_long
LVS_EX_CHECKBOXES = 4 # Variable c_int
TAPE_SETMARKS = 0 # Variable c_long
ERROR_LOGIN_WKSTA_RESTRICTION = 1240 # Variable c_long
MIXERCONTROL_CT_SC_TIME_MILLISECS = 16777216 # Variable c_long
WM_COMMAND = 273 # Variable c_int
RPC_S_UNKNOWN_AUTHN_SERVICE = 1747 # Variable c_long
PGF_SCROLLLEFT = 4 # Variable c_int
TB_GETBUTTONTEXTW = 1099 # Variable c_int
ERROR_NO_RECOVERY_POLICY = 6003 # Variable c_long
ERROR_INVALID_LOGON_HOURS = 1328 # Variable c_long
IMAGE_FILE_EXECUTABLE_IMAGE = 2 # Variable c_int
WM_WININICHANGE = 26 # Variable c_int
CF_USESTYLE = 128 # Variable c_long
lst1 = 1120 # Variable c_int
HEAP_ZERO_MEMORY = 8 # Variable c_int
SND_ALIAS_ID = 1114112 # Variable c_long
PRINTER_NOTIFY_FIELD_COMMENT = 5 # Variable c_int
CRYPT_E_OID_FORMAT = -2146889725 # Variable c_long
COLOR_ADJ_MAX = 100 # Variable c_short
PRSPEC_LPWSTR = 0 # Variable c_int
PDERR_SETUPFAILURE = 4097 # Variable c_int
DCBA_FACEDOWNRIGHT = 259 # Variable c_int
TB_ENDTRACK = 8 # Variable c_int
IS_TEXT_UNICODE_REVERSE_ASCII16 = 16 # Variable c_int
ETO_RTLREADING = 128 # Variable c_int
MCI_ANIM_WINDOW_STATE = 262144 # Variable c_long
SERVICE_WIN32 = 48 # Variable c_int
RPC_C_AUTHN_DCE_PRIVATE = 1 # Variable c_int
RPC_S_INVALID_ASYNC_HANDLE = 1914 # Variable c_long
EMR_POLYBEZIER = 2 # Variable c_int
FS_LATIN2 = 2 # Variable c_long
DTN_LAST = 4294966497 # Variable c_uint
ERROR_FILE_INVALID = 1006 # Variable c_long
CREATE_PROCESS_DEBUG_EVENT = 3 # Variable c_int
LVN_GETDISPINFOW = 4294967119 # Variable c_uint
MDM_FLOWCONTROL_SOFT = 32 # Variable c_int
VIEW_S_ALREADY_FROZEN = 262464 # Variable c_long
C1_LOWER = 2 # Variable c_int
CTRY_ECUADOR = 593 # Variable c_int
IMAGE_REL_IA64_RESERVED_12 = 18 # Variable c_int
SECURITY_CREATOR_GROUP_SERVER_RID = 3 # Variable c_long
TAPE_DRIVE_ABSOLUTE_BLK = 2147487744 # Variable c_uint
DMPAPER_LETTERSMALL = 2 # Variable c_int
CLIP_MASK = 15 # Variable c_int
REFERENCE_BLACK_MIN = 0 # Variable c_ushort
CO_S_LAST = 262655 # Variable c_long
MF_UNCHECKED = 0 # Variable c_long
URLACTION_HTML_FONT_DOWNLOAD = 5636 # Variable c_int
APPCMD_CLIENTONLY = 16 # Variable c_long

tagOLERENDER = c_int # enum
VARIANT_ALPHABOOL = 2 # Variable c_int
MCIERR_NONAPPLICABLE_FUNCTION = 302 # Variable c_int
SND_FILENAME = 131072 # Variable c_long
SPI_SETSCREENREADER = 71 # Variable c_int
DISP_E_UNKNOWNLCID = -2147352564 # Variable c_long
CONVERT10_S_NO_PRESENTATION = 262592 # Variable c_long
DISPATCH_PROPERTYGET = 2 # Variable c_int
EM_GETSEL = 176 # Variable c_int
ERROR_PIPE_BUSY = 231 # Variable c_long
LVM_INSERTCOLUMNA = 4123 # Variable c_int
CDS_NORESET = 268435456 # Variable c_int
JOB_NOTIFY_FIELD_DATATYPE = 5 # Variable c_int
DTS_TIMEFORMAT = 9 # Variable c_int

_JOBOBJECTINFOCLASS = c_int # enum
JobObjectBasicProcessIdList = 3
JobObjectAssociateCompletionPortInformation = 7
ERROR_ARENA_TRASHED = 7 # Variable c_long
CBR_2400 = 2400 # Variable c_int
JOY_BUTTON1CHG = 256 # Variable c_int
WM_LBUTTONDBLCLK = 515 # Variable c_int
DDD_EXACT_MATCH_ON_REMOVE = 4 # Variable c_int
CDS_SETRECT = 536870912 # Variable c_int
LVS_EX_TRACKSELECT = 8 # Variable c_int
SSTF_BORDER = 2 # Variable c_int
IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16 # Variable c_int
CRYPT_E_MSG_ERROR = -2146889727 # Variable c_long
CRYPT_E_NOT_IN_CTL = -2146885590 # Variable c_long
JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 16 # Variable c_int
LANG_KAZAK = 63 # Variable c_int
SETALLJUSTVALUES = 771 # Variable c_int
SUBLANG_URDU_INDIA = 2 # Variable c_int
CRYPT_E_BAD_LEN = -2146885631 # Variable c_long
JOY_RETURNRAWDATA = 256 # Variable c_long
WM_CTLCOLORBTN = 309 # Variable c_int
EMR_INVERTRGN = 73 # Variable c_int
TB_ISBUTTONPRESSED = 1035 # Variable c_int
SPAPI_E_DEVICE_INTERFACE_REMOVED = -2146500068 # Variable c_long
DV_E_DVASPECT = -2147221397 # Variable c_long
VIEW_S_FIRST = 262464 # Variable c_long
COLOR_BTNHIGHLIGHT = 20 # Variable c_int
E_UNEXPECTED = -2147418113 # Variable c_long
PRINTER_NOTIFY_FIELD_PRINTER_NAME = 1 # Variable c_int
LCS_GM_IMAGES = 4 # Variable c_long
EMR_POLYPOLYGON16 = 91 # Variable c_int
PSM_SETTITLEA = 1135 # Variable c_int
RPC_C_AUTHZ_NONE = 0 # Variable c_int
DMPAPER_15X11 = 46 # Variable c_int
ERROR_INVALID_PASSWORDNAME = 1216 # Variable c_long
DMDITHER_RESERVED8 = 8 # Variable c_int
LOCALE_ITIME = 35 # Variable c_int
CB_FINDSTRINGEXACT = 344 # Variable c_int
ERROR_GLOBAL_ONLY_HOOK = 1429 # Variable c_long
ERROR_BADDB = 1009 # Variable c_long
WM_DESTROYCLIPBOARD = 775 # Variable c_int
MOUSEEVENTF_ABSOLUTE = 32768 # Variable c_int
MIXERLINE_COMPONENTTYPE_DST_LINE = 2 # Variable c_long
ERROR_DS_NOT_INSTALLED = 1251 # Variable c_long
REG_RESOURCE_LIST = 8 # Variable c_int
WM_GETTEXTLENGTH = 14 # Variable c_int
HDS_HIDDEN = 8 # Variable c_int
_OUT_TO_STDERR = 1 # Variable c_int
TB_PAGEUP = 2 # Variable c_int
RESOURCE_RECENT = 4 # Variable c_int
SCROLLLOCK_ON = 64 # Variable c_int
MCHT_TITLEYEAR = 65538 # Variable c_int
ERROR_WMI_DP_NOT_FOUND = 4204 # Variable c_long
HCF_HOTKEYACTIVE = 4 # Variable c_int
ES_AUTOVSCROLL = 64 # Variable c_long
OLE_E_LAST = -2147221249 # Variable c_long
MCI_WAVE_STATUS_AVGBYTESPERSEC = 16388 # Variable c_long
SPI_SETSTICKYKEYS = 59 # Variable c_int
ERROR_SERVICE_ALREADY_RUNNING = 1056 # Variable c_long
TVM_SETTEXTCOLOR = 4382 # Variable c_int
SW_FORCEMINIMIZE = 11 # Variable c_int
RPC_NCA_FLAGS_DEFAULT = 0 # Variable c_int
MCI_SET_DOOR_CLOSED = 512 # Variable c_long
WM_MDIRESTORE = 547 # Variable c_int
DI_IMAGE = 2 # Variable c_int
AF_SNA = 11 # Variable c_int
MCI_SET_AUDIO_ALL = 0 # Variable c_long
SOFTDIST_ADSTATE_DOWNLOADED = 2 # Variable c_int
LVM_REDRAWITEMS = 4117 # Variable c_int
TAPE_DRIVE_SET_PADDING = 2147484672 # Variable c_uint
IDI_EXCLAMATION = 206101 # Variable POINTER(c_wchar)
CP_WINUNICODE = 1200 # Variable c_int
CONTEXT_i386 = 65536 # Variable c_int
VS_USER_DEFINED = 100 # Variable c_int
SIZEPALETTE = 104 # Variable c_int
PROPSETFLAG_DEFAULT = 0 # Variable c_int
OWNER_SECURITY_INFORMATION = 1 # Variable c_long
DMORIENT_LANDSCAPE = 2 # Variable c_int
REFERENCE_WHITE_MIN = 6000 # Variable c_ushort
MCI_OVLY_PUT_VIDEO = 1048576 # Variable c_long
ERROR_INVALID_MESSAGEDEST = 1218 # Variable c_long
CDDS_ITEMPREPAINT = 65537 # Variable c_int
LOCALE_IDEFAULTLANGUAGE = 9 # Variable c_int
CONVERT10_E_OLESTREAM_PUT = -2147221055 # Variable c_long
GCS_COMPREADSTR = 1 # Variable c_int
FOF_WANTMAPPINGHANDLE = 32 # Variable c_int
LZERROR_BADOUTHANDLE = -2 # Variable c_int
PRINTER_NOTIFY_FIELD_PRIORITY = 14 # Variable c_int
MCI_SEQ_STATUS_NAME = 16395 # Variable c_long
CO_S_FIRST = 262640 # Variable c_long
LVNI_ALL = 0 # Variable c_int
C3_VOWELMARK = 4 # Variable c_int
STARTF_USESTDHANDLES = 256 # Variable c_int
INPLACE_E_NOTUNDOABLE = -2147221088 # Variable c_long
SET_CLIP_BOX = 4108 # Variable c_int
WNNC_NET_9TILES = 589824 # Variable c_int
CONTAINER_INHERIT_ACE = 2 # Variable c_int
HDI_LPARAM = 8 # Variable c_int
MIXERCONTROL_CONTROLTYPE_MUX = 1879113729 # Variable c_long
SM_CYDLGFRAME = 8 # Variable c_int
scr3 = 1170 # Variable c_int
GM_LAST = 2 # Variable c_int
ERROR_INVALID_DOMAIN_STATE = 1353 # Variable c_long
LMEM_MOVEABLE = 2 # Variable c_int
TB_SETANCHORHIGHLIGHT = 1097 # Variable c_int
MCI_VD_MEDIA_OTHER = 1028 # Variable c_int
CTRY_PUERTO_RICO = 1 # Variable c_int
CS_CLASSDC = 64 # Variable c_int
MCI_ANIM_WHERE_DESTINATION = 262144 # Variable c_long
OFN_OVERWRITEPROMPT = 2 # Variable c_int
TTM_UPDATE = 1053 # Variable c_int
MCIERR_WAVE_INPUTSUNSUITABLE = 328 # Variable c_int
HEAP_MAXIMUM_TAG = 4095 # Variable c_int
TVM_SETITEMHEIGHT = 4379 # Variable c_int
IMAGE_REL_ALPHA_REFQ3 = 19 # Variable c_int
TVM_GETINSERTMARKCOLOR = 4390 # Variable c_int
JOB_STATUS_USER_INTERVENTION = 1024 # Variable c_int
ERROR_ALREADY_INITIALIZED = 1247 # Variable c_long
CTRY_TURKEY = 90 # Variable c_int
LCS_SIGNATURE = 1347637059 # Variable c_int
MCI_SEQ_NONE = 65533 # Variable c_int
LB_GETSEL = 391 # Variable c_int
SE_ERR_ACCESSDENIED = 5 # Variable c_int
IN_CLASSC_NET = 4294967040 # Variable c_uint
RPC_S_UUID_NO_ADDRESS = 1739 # Variable c_long
DLGC_DEFPUSHBUTTON = 16 # Variable c_int
IMAGE_FILE_RELOCS_STRIPPED = 1 # Variable c_int
SPAPI_E_CLASS_MISMATCH = -2146500095 # Variable c_long
WM_DROPFILES = 563 # Variable c_int
MF_CHECKED = 8 # Variable c_long
DC_VERSION = 10 # Variable c_int
LMEM_DISCARDED = 16384 # Variable c_int
TCM_FIRST = 4864 # Variable c_int
PIPE_ACCESS_OUTBOUND = 2 # Variable c_int
RESOURCEDISPLAYTYPE_SHARE = 3 # Variable c_int
WNFMT_MULTILINE = 1 # Variable c_int
WM_MOUSEACTIVATE = 33 # Variable c_int
ERROR_NO_INHERITANCE = 1391 # Variable c_long
STATUS_USER_APC = 192 # Variable c_ulong
PERF_COUNTER_FRACTION = 131072 # Variable c_int
URLACTION_ACTIVEX_RUN = 4608 # Variable c_int
SPI_GETPOWEROFFACTIVE = 84 # Variable c_int
ERROR_APP_WRONG_OS = 1151 # Variable c_long
LVM_GETIMAGELIST = 4098 # Variable c_int
SO_KEEPALIVE = 8 # Variable c_int
CDM_FIRST = 1124 # Variable c_int
MMSYSERR_INVALFLAG = 10 # Variable c_int
MB_OKCANCEL = 1 # Variable c_long
PSH_STRETCHWATERMARK = 262144 # Variable c_int
IMAGE_REL_IA64_SECTION = 11 # Variable c_int
WS_BORDER = 8388608 # Variable c_long
ERROR_INVALID_ACCESS = 12 # Variable c_long
CTRY_YEMEN = 967 # Variable c_int
TVM_GETISEARCHSTRINGW = 4416 # Variable c_int
DBG_TERMINATE_THREAD = 1073807363 # Variable c_ulong
FILE_DELETE_CHILD = 64 # Variable c_int
MIDICAPS_CACHE = 4 # Variable c_int
IMAGE_SYM_TYPE_BYTE = 12 # Variable c_int
UDS_AUTOBUDDY = 16 # Variable c_int
SB_LEFT = 6 # Variable c_int
SEE_MASK_UNICODE = 16384 # Variable c_int
WMSZ_TOPLEFT = 4 # Variable c_int
HINST_COMMCTRL = 4294967295 # Variable POINTER(HINSTANCE__)
SE_PROF_SINGLE_PROCESS_NAME = 'SeProfileSingleProcessPrivilege' # Variable POINTER(c_wchar)
HEAP_CREATE_ENABLE_TRACING = 131072 # Variable c_int
GRADIENT_FILL_RECT_H = 0 # Variable c_int
PO_DELETE = 19 # Variable c_int
MERGEPAINT = 12255782 # Variable c_ulong
DS_ABSALIGN = 1 # Variable c_long
SPAPI_E_LINE_NOT_FOUND = -2146500350 # Variable c_long
MCI_INFO_NAME = 4096 # Variable c_long
cmb4 = 1139 # Variable c_int
HIST_FAVORITES = 2 # Variable c_int
TC_SF_X_YINDEP = 32 # Variable c_int
WM_GETDLGCODE = 135 # Variable c_int
JOB_NOTIFY_FIELD_MACHINE_NAME = 1 # Variable c_int
RBN_ENDDRAG = 4294966460 # Variable c_uint
SOFTKEYBOARD_TYPE_T1 = 1 # Variable c_int
MCI_LOAD = 2128 # Variable c_int
TBN_BEGINDRAG = 4294966595 # Variable c_uint
WINSTA_ENUMDESKTOPS = 1 # Variable c_long
JOB_STATUS_OFFLINE = 32 # Variable c_int
PAN_LETT_NORMAL_ROUNDED = 6 # Variable c_int
IMAGE_REL_PPC_PAIR = 18 # Variable c_int
SPI_SETSERIALKEYS = 63 # Variable c_int
SUBLANG_FRENCH_CANADIAN = 3 # Variable c_int
TYPE_E_INCONSISTENTPROPFUNCS = -2147312509 # Variable c_long
ERROR_TOO_MANY_OPEN_FILES = 4 # Variable c_long
COMPLEXREGION = 3 # Variable c_int
DISP_E_TYPEMISMATCH = -2147352571 # Variable c_long
MESSAGE_RESOURCE_UNICODE = 1 # Variable c_int
STARTF_FORCEOFFFEEDBACK = 128 # Variable c_int
URLACTION_CHANNEL_SOFTDIST_MIN = 7680 # Variable c_int
ABM_REMOVE = 1 # Variable c_int
MB_USERICON = 128 # Variable c_long
BF_TOP = 2 # Variable c_int
PERSIST_E_SIZEDEFINITE = -2146762743 # Variable c_long
HDM_CREATEDRAGIMAGE = 4624 # Variable c_int
WM_AFXLAST = 895 # Variable c_int
VFT2_DRV_PRINTER = 1 # Variable c_long
BS_AUTOCHECKBOX = 3 # Variable c_long
ODT_LISTBOX = 2 # Variable c_int
ERROR_RESOURCE_NOT_ONLINE = 5004 # Variable c_long
SEC_COMMIT = 134217728 # Variable c_int
PRINTER_ENUM_ICONMASK = 16711680 # Variable c_int
SB_BOTTOM = 7 # Variable c_int
RPC_S_NO_MORE_BINDINGS = 1806 # Variable c_long
NCBACTION = 119 # Variable c_int
SERVICE_ALL_ACCESS = 983551 # Variable c_long
MM_MCINOTIFY = 953 # Variable c_int
PSM_SETCURSELID = 1138 # Variable c_int

_tagPI_FLAGS = c_int # enum
CAT_E_NODESCRIPTION = -2147221151 # Variable c_long
MB_DEFBUTTON2 = 256 # Variable c_long
IMAGE_SCN_LNK_NRELOC_OVFL = 16777216 # Variable c_int
MF_CALLBACKS = 134217728 # Variable c_int
MFT_RIGHTORDER = 8192 # Variable c_long
CWCSTORAGENAME = 32 # Variable c_int
ERROR_NO_MORE_ITEMS = 259 # Variable c_long
TTM_DELTOOLA = 1029 # Variable c_int
ERROR_MORE_DATA = 234 # Variable c_long
JOB_OBJECT_QUERY = 4 # Variable c_int
IMN_OPENCANDIDATE = 5 # Variable c_int
MHDR_INQUEUE = 4 # Variable c_int
psh13 = 1036 # Variable c_int
MARSHAL_E_FIRST = 2147746080 # Variable c_ulong
TVN_ITEMEXPANDINGA = 4294966891 # Variable c_uint

tagMEMCTX = c_int # enum
MEMCTX_TASK = 1
MEMCTX_SHARED = 2
MEMCTX_MACSYSTEM = 3
MEMCTX_UNKNOWN = -1
MEMCTX_SAME = -2
LVM_APPROXIMATEVIEWRECT = 4160 # Variable c_int
UDS_SETBUDDYINT = 2 # Variable c_int
IME_CMODE_SOFTKBD = 128 # Variable c_int
ERROR_SEM_OWNER_DIED = 105 # Variable c_long
LBS_STANDARD = 10485763 # Variable c_long
TPM_HORIZONTAL = 0 # Variable c_long
LVM_GETHOVERTIME = 4168 # Variable c_int
DROPEFFECT_NONE = 0 # Variable c_int
HDN_TRACKW = 4294966968 # Variable c_uint
FADF_RECORD = 32 # Variable c_int
IMAGE_FILE_MACHINE_UNKNOWN = 0 # Variable c_int
MMIO_RWMODE = 3 # Variable c_int
PCF_DTRDSR = 1 # Variable c_ulong
EMR_POLYLINETO16 = 89 # Variable c_int
EV_EVENT2 = 4096 # Variable c_int
lst2 = 1121 # Variable c_int
MCI_WAVE_GETDEVCAPS_INPUTS = 16385 # Variable c_long
WHITE_BRUSH = 0 # Variable c_int
ESB_DISABLE_DOWN = 2 # Variable c_int
ERROR_SERVICE_REQUEST_TIMEOUT = 1053 # Variable c_long
INPLACE_S_LAST = 262575 # Variable c_long
CO_E_FAILEDTOCREATEFILE = -2147220972 # Variable c_long
PROP_SM_CYDLG = 188 # Variable c_int
SBM_SETSCROLLINFO = 233 # Variable c_int
GL_ID_INPUTCODE = 38 # Variable c_int
CO_E_IIDREG_INCONSISTENT = -2147467232 # Variable c_long
SLE_MINORERROR = 2 # Variable c_int
PC_STYLED = 32 # Variable c_int
STG_E_REVERTED = -2147286782 # Variable c_long
DDD_RAW_TARGET_PATH = 1 # Variable c_int
ERROR_CONNECTION_UNAVAIL = 1201 # Variable c_long
CAL_IYEAROFFSETRANGE = 3 # Variable c_int
OLEIVERB_SHOW = -1 # Variable c_long
NM_SETCURSOR = 4294967279 # Variable c_uint
R2_MASKPENNOT = 5 # Variable c_int
TYPE_E_UNSUPFORMAT = -2147319783 # Variable c_long
SC_MINIMIZE = 61472 # Variable c_int
PRINTER_STATUS_SERVER_UNKNOWN = 8388608 # Variable c_int
MCIERR_MISSING_DEVICE_NAME = 292 # Variable c_int
IMAGE_REL_IA64_RESERVED_13 = 19 # Variable c_int
RESOURCETYPE_UNKNOWN = 4294967295 # Variable c_uint
EMR_POLYPOLYGON = 8 # Variable c_int
MDM_BLIND_DIAL = 512 # Variable c_int
URLACTION_HTML_SUBMIT_FORMS = 5633 # Variable c_int
LB_GETANCHORINDEX = 413 # Variable c_int
ODS_DISABLED = 4 # Variable c_int
PRF_NONCLIENT = 2 # Variable c_long
edt12 = 1163 # Variable c_int
TYMED_ISTORAGE = 8
VK_F16 = 127 # Variable c_int
SND_NOWAIT = 8192 # Variable c_long
TYPE_E_REGISTRYACCESS = -2147319780 # Variable c_long

tagTYPEKIND = c_int # enum
TKIND_UNION = 7
PAN_WEIGHT_INDEX = 2 # Variable c_int
MCI_CD_OFFSET = 1088 # Variable c_int
EMR_SETPIXELV = 15 # Variable c_int
MCIERR_DEVICE_LENGTH = 310 # Variable c_int
DEF_PRIORITY = 1 # Variable c_int
WGL_SWAP_MAIN_PLANE = 1 # Variable c_int
LZERROR_GLOBALLOC = -5 # Variable c_int
DATABITS_6 = 2 # Variable c_ushort
LVM_SETITEMTEXTA = 4142 # Variable c_int
NTE_NO_KEY = -2146893811 # Variable c_long
MCM_GETRANGE = 4113 # Variable c_int
MF_REMOVE = 4096 # Variable c_long
WM_MBUTTONDOWN = 519 # Variable c_int
TVHT_TORIGHT = 1024 # Variable c_int
ELF_VENDOR_SIZE = 4 # Variable c_int
MIDIPROP_GET = 1073741824 # Variable c_long
ERROR_REMOTE_STORAGE_MEDIA_ERROR = 4352 # Variable c_long
EMARCH_ENC_I17_IMM5C_SIZE_X = 5 # Variable c_int
MCI_SEQ_SMPTE = 16388 # Variable c_int
JOY_BUTTON1 = 1 # Variable c_int
TBM_GETPTICS = 1038 # Variable c_int
PAN_LETT_NORMAL_SQUARE = 8 # Variable c_int
DISP_CHANGE_BADFLAGS = -4 # Variable c_int
MSG_DONTROUTE = 4 # Variable c_int
SUBLANG_DUTCH = 1 # Variable c_int
HOTKEYF_CONTROL = 2 # Variable c_int
FILE_SHARE_READ = 1 # Variable c_int
LOCALE_IDEFAULTCOUNTRY = 10 # Variable c_int
SEM_FAILCRITICALERRORS = 1 # Variable c_int
VOS_NT = 262144 # Variable c_long
PAGE_NOCACHE = 512 # Variable c_int
SPLREG_MAJOR_VERSION = 'MajorVersion' # Variable POINTER(c_wchar)
STGFMT_STORAGE = 0 # Variable c_int
LB_GETSELITEMS = 401 # Variable c_int
LVM_INSERTCOLUMNW = 4193 # Variable c_int
EMR_POLYLINE = 4 # Variable c_int
TAPE_DRIVE_FORMAT_IMMEDIATE = 3221225472 # Variable c_uint
CONNDLG_USE_MRU = 4 # Variable c_int
IMAGE_SYM_CLASS_REGISTER = 4 # Variable c_int
NTE_KEYSET_NOT_DEF = -2146893799 # Variable c_long
DIALOPTION_BILLING = 64 # Variable c_int
ERROR_INVALID_INDEX = 1413 # Variable c_long
SPAPI_E_CANT_LOAD_CLASS_ICON = -2146500084 # Variable c_long
DOMAIN_USER_RID_ADMIN = 500 # Variable c_long
DSS_DISABLED = 32 # Variable c_int
FORMATDLGORD31 = 1543 # Variable c_int
SPACEPARITY = 4 # Variable c_int
NUMFONTS = 22 # Variable c_int
PIPE_SERVER_END = 1 # Variable c_int
edt13 = 1164 # Variable c_int
JOHAB_CHARSET = 130 # Variable c_int
ERROR_KEY_HAS_CHILDREN = 1020 # Variable c_long
MCI_OVLY_WINDOW_ENABLE_STRETCH = 1048576 # Variable c_long
ABM_QUERYPOS = 2 # Variable c_int
MCI_SEQ_SET_MASTER = 524288 # Variable c_long
DMPAPER_FOLIO = 14 # Variable c_int
IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3 # Variable c_int
lst15 = 1134 # Variable c_int
REGDB_E_FIRST = 2147746128 # Variable c_ulong
RT_ANICURSOR = 33 # Variable POINTER(c_wchar)
SBT_NOBORDERS = 256 # Variable c_int
ERROR_INTERNAL_DB_ERROR = 1383 # Variable c_long
FACILITY_WINDOWS = 8 # Variable c_int
JOY_BUTTON3CHG = 1024 # Variable c_int
LVBKIF_SOURCE_NONE = 0 # Variable c_int
S_STACCATO = 2 # Variable c_int
CLASSFACTORY_E_LAST = 2147746079 # Variable c_ulong
IP_TOS = 8 # Variable c_int
RB_GETDROPTARGET = 8196 # Variable c_int
CDN_FILEOK = 4294966690 # Variable c_uint
HTHSCROLL = 6 # Variable c_int
WM_GETMINMAXINFO = 36 # Variable c_int
OLEOBJ_S_LAST = 262543 # Variable c_long
TB_DELETEBUTTON = 1046 # Variable c_int
PERF_COUNTER_BULK_COUNT = 272696576 # Variable c_int
HELP_KEY = 257 # Variable c_long
SERVER_EXECUTE = 131074 # Variable c_long
LVM_SETITEMA = 4102 # Variable c_int
NUMBRUSHES = 16 # Variable c_int
ERROR_INVALID_HOOK_HANDLE = 1404 # Variable c_long
DFCS_BUTTONCHECK = 0 # Variable c_int
JOY_BUTTON18 = 131072 # Variable c_long
CBF_SKIP_DISCONNECTS = 2097152 # Variable c_int
TVHT_ONITEMSTATEICON = 64 # Variable c_int
MEVT_COMMENT = 130 # Variable c_ubyte
TVS_SINGLEEXPAND = 1024 # Variable c_int
WAIT_ABANDONED = 128 # Variable c_ulong
ARW_RIGHT = 0 # Variable c_long
SPAPI_E_NO_ASSOCIATED_SERVICE = -2146500071 # Variable c_long
PRINTER_STATUS_MANUAL_FEED = 32 # Variable c_int
OBJ_ENHMETAFILE = 13 # Variable c_int
IPM_SETADDRESS = 1125 # Variable c_int
IMAGE_DIRECTORY_ENTRY_SECURITY = 4 # Variable c_int
DTS_RIGHTALIGN = 32 # Variable c_int
scr2 = 1169 # Variable c_int
SPAPI_E_WRONG_INF_STYLE = -2146500352 # Variable c_long
QUERY_EXPIRATION_DATE = 1
IME_CONFIG_REGISTERWORD = 2 # Variable c_int
PIDSI_KEYWORDS = 5 # Variable c_long
MCI_GETDEVCAPS_COMPOUND_DEVICE = 6 # Variable c_long
XST_INCOMPLETE = 1 # Variable c_int
EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X = 0 # Variable c_int
MOD_LEFT = 32768 # Variable c_int
MM_DRVM_OPEN = 976 # Variable c_int
PSM_SETTITLEW = 1144 # Variable c_int
TVIF_STATE = 8 # Variable c_int
CLIP_LH_ANGLES = 16 # Variable c_int
SB_GETTEXTLENGTHW = 1036 # Variable c_int
TB_ADDBITMAP = 1043 # Variable c_int
LOCALE_SENGCOUNTRY = 4098 # Variable c_int
IMAGE_REL_ALPHA_REFQ2 = 20 # Variable c_int
DM_DISPLAYFLAGS = 2097152 # Variable c_long
MF_STRING = 0 # Variable c_long
GCS_COMPREADATTR = 2 # Variable c_int
RASTER_FONTTYPE = 1 # Variable c_int
MCI_ANIM_PUT_SOURCE = 131072 # Variable c_long
PAGESETUPDLGORD = 1546 # Variable c_int
DCTT_BITMAP = 1 # Variable c_long
PSN_APPLY = 4294967094 # Variable c_uint
WVR_VREDRAW = 512 # Variable c_int
ICON_SMALL = 0 # Variable c_int
LVM_GETNEXTITEM = 4108 # Variable c_int

tagMSHCTX = c_int # enum
MSHCTX_LOCAL = 0
MSHCTX_NOSHAREDMEM = 1
URLPOLICY_CREDENTIALS_MUST_PROMPT_USER = 65536 # Variable c_int
REG_DWORD = 4 # Variable c_int
NCBRESET = 50 # Variable c_int
SM_CYSCREEN = 1 # Variable c_int
EMR_POLYLINE16 = 87 # Variable c_int
DTN_DROPDOWN = 4294966542 # Variable c_uint
CERTDB_E_JET_ERROR = -2146873344 # Variable c_long
SE_ERR_PNF = 3 # Variable c_int
EMR_CREATEDIBPATTERNBRUSHPT = 94 # Variable c_int
TTN_SHOW = 4294966775 # Variable c_uint
VS_FF_INFOINFERRED = 16 # Variable c_long
DWL_USER = 8 # Variable c_int
CONNDLG_NOT_PERSIST = 32 # Variable c_int
PAN_BENT_ARMS_WEDGE = 8 # Variable c_int
WSAETOOMANYREFS = 10059 # Variable c_int
IMAGE_SCN_SCALE_INDEX = 1 # Variable c_int
PSM_SETFINISHTEXTW = 1145 # Variable c_int
DISPATCH_PROPERTYPUTREF = 8 # Variable c_int
DATABITS_16X = 32 # Variable c_ushort
CBEM_SETIMAGELIST = 1026 # Variable c_int
LVN_BEGINLABELEDITW = 4294967121 # Variable c_uint
STATUS_SINGLE_STEP = 2147483652 # Variable c_ulong
ERROR_RESOURCE_DISABLED = 4309 # Variable c_long
KEY_ENUMERATE_SUB_KEYS = 8 # Variable c_int
WSAESOCKTNOSUPPORT = 10044 # Variable c_int
CF_HDROP = 15 # Variable c_int
WM_IME_KEYUP = 657 # Variable c_int
IPPORT_RJE = 77 # Variable c_int
RPC_C_MGMT_INQ_IF_IDS = 0 # Variable c_int
SUBLANG_UZBEK_LATIN = 1 # Variable c_int
MOUSEEVENTF_LEFTUP = 4 # Variable c_int
TAPE_DRIVE_TAPE_REMAINING = 512 # Variable c_int
SHOW_OPENWINDOW = 1 # Variable c_int
IMAGE_REL_IA64_IMM14 = 1 # Variable c_int
GMEM_NOT_BANKED = 4096 # Variable c_int
SC_MANAGER_CREATE_SERVICE = 2 # Variable c_int
TTM_GETCURRENTTOOLA = 1039 # Variable c_int
ERROR_TIMEOUT = 1460 # Variable c_long
N_TMASK = 48 # Variable c_int
CFSTR_MIME_X_WMF = 'image/x-wmf' # Variable POINTER(c_wchar)
MCI_SYSINFO_OPEN = 512 # Variable c_long
VIF_CANNOTDELETECUR = 16384 # Variable c_long
DTS_UPDOWN = 1 # Variable c_int
CTRY_EL_SALVADOR = 503 # Variable c_int
VK_RSHIFT = 161 # Variable c_int
HEAP_CREATE_ALIGN_16 = 65536 # Variable c_int
MIXERCONTROL_CONTROLTYPE_BOOLEANMETER = 268500992 # Variable c_long
ERROR_LOGON_TYPE_NOT_GRANTED = 1385 # Variable c_long
ERROR_DEVICE_NOT_PARTITIONED = 1107 # Variable c_long
FILEOKSTRINGA = 'commdlg_FileNameOK' # Variable POINTER(c_char)
ERROR_JOURNAL_HOOK_SET = 1430 # Variable c_long
TCM_GETEXTENDEDSTYLE = 4917 # Variable c_int
SS_WHITEFRAME = 9 # Variable c_long
VK_ADD = 107 # Variable c_int
HELPMSGSTRINGW = 'commdlg_help' # Variable POINTER(c_wchar)
EVENTLOG_SEEK_READ = 2 # Variable c_int
HDM_SETITEMW = 4620 # Variable c_int
SSWF_NONE = 0 # Variable c_int
HDM_GETITEMA = 4611 # Variable c_int
RT_HTML = 35 # Variable POINTER(c_wchar)
MAXUHALF_PTR = 65535 # Variable c_int
cmb7 = 1142 # Variable c_int
WINVER = 1024 # Variable c_int
ABM_GETAUTOHIDEBAR = 7 # Variable c_int
WM_INITMENU = 278 # Variable c_int
TTM_HITTESTA = 1034 # Variable c_int
IMAGE_DIRECTORY_ENTRY_IAT = 12 # Variable c_int
MCI_SEQ_STATUS_DIVTYPE = 16394 # Variable c_long
IDHELP = 9 # Variable c_int
CB_SETDROPPEDWIDTH = 352 # Variable c_int
IMAGE_REL_I386_DIR16 = 1 # Variable c_int
LVCFMT_LEFT = 0 # Variable c_int
TCS_RIGHT = 2 # Variable c_int
SPIF_UPDATEINIFILE = 1 # Variable c_int
ERROR_INVALID_EXE_SIGNATURE = 191 # Variable c_long
RT_VXD = 32 # Variable POINTER(c_wchar)
MK_RBUTTON = 2 # Variable c_int
DOMAIN_USER_RID_GUEST = 501 # Variable c_long
ENABLEDUPLEX = 28 # Variable c_int
GL_ID_INPUTRADICAL = 37 # Variable c_int
IO_REPARSE_TAG_RESERVED_ONE = 1 # Variable c_int
CTRY_JAMAICA = 1 # Variable c_int

__MIDL_IInternetZoneManager_0001 = c_int # enum
MAX_ZONE_PATH = 260
MAX_ZONE_DESCRIPTION = 200
WSAEMFILE = 10024 # Variable c_int
SPI_GETFASTTASKSWITCH = 35 # Variable c_int
IMAGE_REL_PPC_BRNTAKEN = 1024 # Variable c_int
ODT_COMBOBOX = 3 # Variable c_int
TBM_GETSELSTART = 1041 # Variable c_int

_TOKEN_TYPE = c_int # enum
TokenPrimary = 1
TokenImpersonation = 2
ERROR_INVALID_WORKSTATION = 1329 # Variable c_long
MCM_GETMAXSELCOUNT = 4099 # Variable c_int
FACILITY_SETUPAPI = 15 # Variable c_int
MIXERLINE_TARGETTYPE_UNDEFINED = 0 # Variable c_int
ERROR_PROTOCOL_UNREACHABLE = 1233 # Variable c_long
psh15 = 1038 # Variable c_int
TVN_ENDLABELEDITA = 4294966885 # Variable c_uint
RTL_RESOURCE_TYPE = 1 # Variable c_int
TCM_HITTEST = 4877 # Variable c_int

tagREGCLS = c_int # enum
REGCLS_SINGLEUSE = 0
REGCLS_MULTIPLEUSE = 1
REGCLS_MULTI_SEPARATE = 2
REGCLS_SUSPENDED = 4
LOCALE_SABBREVDAYNAME1 = 49 # Variable c_int
INET_E_CONNECTION_TIMEOUT = -2146697205 # Variable c_long
ABE_BOTTOM = 3 # Variable c_int
REG_SZ = 1 # Variable c_int
WAIT_FAILED = 4294967295 # Variable c_ulong
TBSTATE_ELLIPSES = 64 # Variable c_int

_tagQUERYOPTION = c_int # enum
QUERY_TIME_OF_LAST_CHANGE = 2
QUERY_CONTENT_ENCODING = 3
QUERY_CONTENT_TYPE = 4
QUERY_REFRESH = 5
QUERY_RECOMBINE = 6
RPC_S_PROCNUM_OUT_OF_RANGE = 1745 # Variable c_long
BF_DIAGONAL = 16 # Variable c_int
NCBENUM = 55 # Variable c_int
FILE_ATTRIBUTE_DIRECTORY = 16 # Variable c_int
STATUSCLASSNAMEA = 'msctls_statusbar32' # Variable POINTER(c_char)
DMICM_CONTRAST = 2 # Variable c_int
DIB_RGB_COLORS = 0 # Variable c_int
FKF_FILTERKEYSON = 1 # Variable c_int
META_FRAMEREGION = 1065 # Variable c_int
BATTERY_LIFE_UNKNOWN = 4294967295 # Variable c_uint
NRC_CANCEL = 38 # Variable c_int
HDN_DIVIDERDBLCLICKA = 4294966991 # Variable c_uint
CTRY_DOMINICAN_REPUBLIC = 1 # Variable c_int
FD_CONNECT = 16 # Variable c_int
MCI_OVLY_WINDOW_TEXT = 524288 # Variable c_long
SOFTKEYBOARD_TYPE_C1 = 2 # Variable c_int
IMAGE_ICON = 1 # Variable c_int
FKF_CONFIRMHOTKEY = 8 # Variable c_int
IMAGE_SYM_TYPE_PCODE = 32768 # Variable c_int
MM_MOM_OPEN = 967 # Variable c_int
PIDSI_COMMENTS = 6 # Variable c_long
GGO_GRAY4_BITMAP = 5 # Variable c_int
LVKF_CONTROL = 2 # Variable c_int
URLPOLICY_NOTIFY_ON_DISALLOW = 32 # Variable c_int
CO_E_CONVERSIONFAILED = -2147220981 # Variable c_long
FILE_FLAG_OPEN_REPARSE_POINT = 2097152 # Variable c_int
SE_SYSTEMTIME_NAME = 'SeSystemtimePrivilege' # Variable POINTER(c_wchar)
RPC_C_AUTHN_LEVEL_DEFAULT = 0 # Variable c_int
WM_IME_KEYDOWN = 656 # Variable c_int
PFD_UNDERLAY_PLANE = -1 # Variable c_int
HELP_TCARD = 32768 # Variable c_int
SPI_SETICONS = 88 # Variable c_int
SECURITY_CONTEXT_TRACKING = 262144 # Variable c_int
TVIS_CUT = 4 # Variable c_int
PRINTER_STATUS_NO_TONER = 262144 # Variable c_int
EMR_MASKBLT = 78 # Variable c_int
PIDSI_THUMBNAIL = 17 # Variable c_long
grp3 = 1074 # Variable c_int
TIME_PERIODIC = 1 # Variable c_int
HKEY_USERS = 2147483651 # Variable POINTER(HKEY__)
NTE_KEYSET_ENTRY_BAD = -2146893798 # Variable c_long
DL_STOPCURSOR = 1 # Variable c_int
IPPROTO_IP = 0 # Variable c_int
MK_S_REDUCED_TO_SELF = 262626 # Variable c_long
JOB_STATUS_BLOCKED_DEVQ = 512 # Variable c_int
RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH = 1 # Variable c_int
OLEOBJ_E_LAST = 2147746191 # Variable c_ulong
PRINTER_ENUM_REMOTE = 16 # Variable c_int
RPC_E_CALL_COMPLETE = -2147417833 # Variable c_long
IDC_SIZEALL = 206406 # Variable POINTER(c_wchar)
RPC_E_UNSECURE_CALL = -2147417832 # Variable c_long
SPI_SETMOUSEBUTTONSWAP = 33 # Variable c_int
MCI_OVLY_PUT_SOURCE = 131072 # Variable c_long
ES_USER_PRESENT = 4 # Variable c_ulong
IN_CLASSA_HOST = 16777215 # Variable c_int

tagSTATFLAG = c_int # enum
MM_JOY1BUTTONDOWN = 949 # Variable c_int
LVIF_INDENT = 16 # Variable c_int
RPC_E_NO_CONTEXT = -2147417826 # Variable c_long
TAPE_DRIVE_RESERVED_BIT = 2147483648 # Variable c_uint
CLASSFACTORY_S_LAST = 262431 # Variable c_long
TAPE_PSEUDO_LOGICAL_POSITION = 2 # Variable c_long
BS_TOP = 1024 # Variable c_long
MK_E_NO_NORMALIZED = -2146959353 # Variable c_long
PROCESS_HEAP_UNCOMMITTED_RANGE = 2 # Variable c_int
PSP_USEICONID = 4 # Variable c_int
RPC_C_AUTHZ_DCE = 2 # Variable c_int
LOCALE_SCOUNTRY = 6 # Variable c_int
MCSC_MONTHBK = 4 # Variable c_int
WSB_PROP_HSTYLE = 512 # Variable c_long
PERF_COUNTER_HISTOGRAM_TYPE = 2147483648 # Variable c_uint
INET_E_QUERYOPTION_UNKNOWN = -2146697197 # Variable c_long
VK_F7 = 118 # Variable c_int
CS_DISABLE = 2 # Variable c_long
PGF_HOT = 8 # Variable c_int
ERROR_DS_NO_RIDS_ALLOCATED = 1929 # Variable c_long
ERROR_DS_RIDMGR_INIT_ERROR = 1932 # Variable c_long
SORT_STRINGSORT = 4096 # Variable c_int
IMAGE_SIZEOF_RELOCATION = 10 # Variable c_int
MEVT_F_SHORT = 0 # Variable c_long
WM_NCHITTEST = 132 # Variable c_int
TVN_DELETEITEMW = 4294966838 # Variable c_uint
OF_CANCEL = 2048 # Variable c_int
VK_F17 = 128 # Variable c_int
URLACTION_SCRIPT_RUN = 5120 # Variable c_int
STGM_DIRECT = 0 # Variable c_long
IMAGE_SYM_TYPE_STRUCT = 8 # Variable c_int
RPC_S_ENTRY_ALREADY_EXISTS = 1760 # Variable c_long
FIOASYNC = 2147772029 # Variable c_ulong
ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE = 2305 # Variable c_long
MMIO_UNICODEPROC = 16777216 # Variable c_int
ERROR_DRIVE_LOCKED = 108 # Variable c_long
DISP_E_ARRAYISLOCKED = -2147352563 # Variable c_long
WM_SETHOTKEY = 50 # Variable c_int
PRINTER_CHANGE_SET_FORM = 131072 # Variable c_int
LANG_GREEK = 8 # Variable c_int
SEE_MASK_FLAG_DDEWAIT = 256 # Variable c_int
RPC_NCA_FLAGS_MAYBE = 4 # Variable c_int
UOI_NAME = 2 # Variable c_int
PROCESSOR_ARM_7TDMI = 70001 # Variable c_int
CCM_GETDROPTARGET = 8196 # Variable c_int
RGN_OR = 2 # Variable c_int
PS_USERSTYLE = 7 # Variable c_int
PSBTN_OK = 3 # Variable c_int
CLR_INVALID = 4294967295 # Variable c_uint
NRC_LOCKFAIL = 60 # Variable c_int
COLOR_GRAYTEXT = 17 # Variable c_int
S_SERDST = -16 # Variable c_int
CFSTR_MIME_GIF = 'image/gif' # Variable POINTER(c_wchar)
IME_ITHOTKEY_PREVIOUS_COMPOSITION = 513 # Variable c_int
IPPROTO_GGP = 3 # Variable c_int
SE_ERR_FNF = 2 # Variable c_int
GDT_ERROR = -1 # Variable c_int
PROCESS_HEAP_ENTRY_DDESHARE = 32 # Variable c_int
ERROR_SUBST_TO_SUBST = 139 # Variable c_long
DMRES_LOW = -2 # Variable c_int
CTLCOLOR_BTN = 3 # Variable c_int
PERF_QUERY_GLOBAL = -2147483647 # Variable c_long
PLANES = 14 # Variable c_int
HANGUL_CHARSET = 129 # Variable c_int
GL_LEVEL_FATAL = 1 # Variable c_int
WS_EX_NOPARENTNOTIFY = 4 # Variable c_long
LVCFMT_RIGHT = 1 # Variable c_int
IP_DEFAULT_MULTICAST_TTL = 1 # Variable c_int
MDMSPKR_OFF = 0 # Variable c_int
ABE_LEFT = 0 # Variable c_int
NMTTDISPINFOA_V1_SIZE = 104 # Variable c_uint
SPLREG_MINOR_VERSION = 'MinorVersion' # Variable POINTER(c_wchar)
ERROR_NT_CROSS_ENCRYPTION_REQUIRED = 1386 # Variable c_long
MCI_SEQ_DIV_PPQN = 1216 # Variable c_int
EXIT_SUCCESS = 0 # Variable c_int
TBN_GETOBJECT = 4294966584 # Variable c_uint
ERROR_TRANSFORM_NOT_SUPPORTED = 2004 # Variable c_long
NTM_REGULAR = 64 # Variable c_long
RPC_S_CANNOT_SUPPORT = 1764 # Variable c_long
SPAPI_E_MACHINE_UNAVAILABLE = -2146500062 # Variable c_long
CO_E_FIRST = 2147746288 # Variable c_ulong
VIEW_NETDISCONNECT = 10 # Variable c_int
MIXER_GETLINEINFOF_LINEID = 2 # Variable c_long
MM_MIM_OPEN = 961 # Variable c_int
FORMATDLGORD30 = 1544 # Variable c_int
MM_HIENGLISH = 5 # Variable c_int
WSAEUSERS = 10068 # Variable c_int
SERVICE_CONTROL_NETBINDREMOVE = 8 # Variable c_int
RT_DIALOG = 5 # Variable POINTER(c_wchar)
LOCALE_ICURRENCY = 27 # Variable c_int
IMAGE_REL_MIPS_REFLO = 5 # Variable c_int
IMAGE_FILE_MACHINE_MIPSFPU16 = 1126 # Variable c_int
EMR_POLYDRAW = 56 # Variable c_int
INET_E_USE_DEFAULT_PROTOCOLHANDLER = -2146697199 # Variable c_long
ERROR_INVALID_MODULETYPE = 190 # Variable c_long
NLS_ROMAN = 4194304 # Variable c_int
MCI_VD_PLAY_SCAN = 524288 # Variable c_long
STD_HELP = 11 # Variable c_int
lst16 = 1135 # Variable c_int
VK_CLEAR = 12 # Variable c_int
PIDSI_TITLE = 2 # Variable c_long
IMAGE_DOS_SIGNATURE = 23117 # Variable c_int
CERT_E_MALFORMED = -2146762488 # Variable c_long
WAVE_FORMAT_1M08 = 1 # Variable c_int
FR_MATCHCASE = 4 # Variable c_int
EMR_POLYTEXTOUTW = 97 # Variable c_int
WAVE_FORMAT_1S08 = 2 # Variable c_int
ERROR_CANT_OPEN_ANONYMOUS = 1347 # Variable c_long
NUMPRS_HEX_OCT = 64 # Variable c_int
TAPE_DRIVE_SETMARKS = 2148532224 # Variable c_uint
UDM_SETBASE = 1133 # Variable c_int
COLOR_CAPTIONTEXT = 9 # Variable c_int
FILE_SUPPORTS_SPARSE_FILES = 64 # Variable c_int
JOY_BUTTON13 = 4096 # Variable c_long
DMPAPER_ESHEET = 26 # Variable c_int
SM_CYEDGE = 46 # Variable c_int
CBES_EX_CASESENSITIVE = 16 # Variable c_int
EMR_STRETCHBLT = 77 # Variable c_int
IMAGE_REL_PPC_IMGLUE = 14 # Variable c_int
PAN_STRAIGHT_ARMS_WEDGE = 3 # Variable c_int
RB_DRAGMOVE = 1050 # Variable c_int
PGB_TOPORLEFT = 0 # Variable c_int
WINSTA_READSCREEN = 512 # Variable c_long
HELP_TCARD_DATA = 16 # Variable c_int
OR_INVALID_OXID = 1910 # Variable c_long
VK_ZOOM = 251 # Variable c_int
IMAGE_REL_I386_SEG12 = 9 # Variable c_int
VK_KANA = 21 # Variable c_int
TB_GETINSERTMARKCOLOR = 1113 # Variable c_int
FILE_ATTRIBUTE_TEMPORARY = 256 # Variable c_int
MERGECOPY = 12583114 # Variable c_ulong
FCONTROL = 8 # Variable c_int
TVM_GETITEMW = 4414 # Variable c_int
JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR = 12 # Variable c_int
WGL_SWAP_OVERLAY2 = 4 # Variable c_int
STM_SETIMAGE = 370 # Variable c_int
LOCALE_SABBREVMONTHNAME8 = 75 # Variable c_int
TVS_INFOTIP = 2048 # Variable c_int
SPLDS_PRINT_STATUS = 'printStatus' # Variable POINTER(c_wchar)
MIXERLINE_COMPONENTTYPE_DST_LAST = 8 # Variable c_long
IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10 # Variable c_int
ERROR_OBJECT_IN_LIST = 5011 # Variable c_long
scr1 = 1168 # Variable c_int
TVN_BEGINDRAGW = 4294966840 # Variable c_uint
CDDS_ITEMPOSTERASE = 65540 # Variable c_int
MCM_SETMAXSELCOUNT = 4100 # Variable c_int
PC_WIDESTYLED = 64 # Variable c_int
SOCK_STREAM = 1 # Variable c_int
DI_NORMAL = 3 # Variable c_int
TVIS_DROPHILITED = 8 # Variable c_int
MCI_BREAK_HWND = 512 # Variable c_long
CB_SETEXTENDEDUI = 341 # Variable c_int
EM_SETTABSTOPS = 203 # Variable c_int
DOUBLE_CLICK = 2 # Variable c_int
IMN_SETCOMPOSITIONWINDOW = 11 # Variable c_int
IMAGE_SEPARATE_DEBUG_SIGNATURE = 18756 # Variable c_int
URLACTION_NETWORK_CURR_MAX = 6657 # Variable c_int
VK_PRINT = 42 # Variable c_int
PRINTER_NOTIFY_FIELD_SERVER_NAME = 0 # Variable c_int
IMAGE_SCN_MEM_PRELOAD = 524288 # Variable c_int
ES_OEMCONVERT = 1024 # Variable c_long
RC_BANDING = 2 # Variable c_int
FADF_DISPATCH = 1024 # Variable c_int
FILE_TYPE_DISK = 1 # Variable c_int
CE_PTO = 512 # Variable c_int
MMIO_WRITE = 1 # Variable c_int
CTRY_CARIBBEAN = 1 # Variable c_int
CP_UTF7 = 65000 # Variable c_int
EVENTLOG_AUDIT_FAILURE = 16 # Variable c_int
EM_FMTLINES = 200 # Variable c_int
DC_SIZE = 8 # Variable c_int
SEF_DACL_AUTO_INHERIT = 1 # Variable c_int
RES_ICON = 1 # Variable c_int
MAX_LANA = 254 # Variable c_int
TCI_SRCFONTSIG = 3 # Variable c_int
GL_LEVEL_NOGUIDELINE = 0 # Variable c_int
IMAGE_SUBSYSTEM_POSIX_CUI = 7 # Variable c_int
LBSELCHSTRINGA = 'commdlg_LBSelChangedNotify' # Variable POINTER(c_char)
MCIERR_EXTRA_CHARACTERS = 305 # Variable c_int
DMLERR_DATAACKTIMEOUT = 16386 # Variable c_int
EXCEPTION_EXECUTE_HANDLER = 1 # Variable c_int
MIXERCONTROL_CONTROLTYPE_ONOFF = 536936449 # Variable c_long
CO_E_CLASS_CREATE_FAILED = -2146959359 # Variable c_long
IMN_OPENSTATUSWINDOW = 2 # Variable c_int
PSPCB_RELEASE = 1 # Variable c_int
EMR_SELECTCLIPPATH = 67 # Variable c_int
EMR_PLGBLT = 79 # Variable c_int
ILD_TRANSPARENT = 1 # Variable c_int
NTE_SIGNATURE_FILE_BAD = -2146893796 # Variable c_long
STGM_FAILIFTHERE = 0 # Variable c_long
MAXPROPPAGES = 100 # Variable c_int
VK_DIVIDE = 111 # Variable c_int
VFT2_DRV_MOUSE = 5 # Variable c_long
NUMPENS = 18 # Variable c_int
LISTEN_OUTSTANDING = 1 # Variable c_int
LANG_BELARUSIAN = 35 # Variable c_int
TAPE_DRIVE_LOCK_UNLOCK = 2147483652 # Variable c_uint
LVIR_SELECTBOUNDS = 3 # Variable c_int
DTS_SHORTDATEFORMAT = 0 # Variable c_int
CTRY_POLAND = 48 # Variable c_int
MFT_RADIOCHECK = 512 # Variable c_long
DSPRINT_UPDATE = 2 # Variable c_int
PDERR_NODEVICES = 4103 # Variable c_int
RBHT_NOWHERE = 1 # Variable c_int
BS_DIBPATTERN8X8 = 8 # Variable c_int
IPM_GETADDRESS = 1126 # Variable c_int
ERROR_CHILD_MUST_BE_VOLATILE = 1021 # Variable c_long
RPC_C_BINDING_DEFAULT_TIMEOUT = 5 # Variable c_int
IMAGE_REL_ARM_ABSOLUTE = 0 # Variable c_int
LCMAP_HALFWIDTH = 4194304 # Variable c_int
DMMEDIA_TRANSPARENCY = 2 # Variable c_int
ERROR_INVALID_HANDLE_STATE = 1609 # Variable c_long
PCF_SPECIALCHARS = 256 # Variable c_ulong
SUBLANG_ITALIAN_SWISS = 2 # Variable c_int
ARW_TOPRIGHT = 3 # Variable c_long
WSAEBADF = 10009 # Variable c_int
VS_FF_DEBUG = 1 # Variable c_long
WM_SETFONT = 48 # Variable c_int
SERVER_ACCESS_ADMINISTER = 1 # Variable c_int
MF_USECHECKBITMAPS = 512 # Variable c_long
WM_DDE_ACK = 996 # Variable c_int
EXCEPTION_CONTINUE_SEARCH = 0 # Variable c_int
MAXSTRETCHBLTMODE = 4 # Variable c_int
NRC_DUPENV = 48 # Variable c_int
MCIERR_OUT_OF_MEMORY = 264 # Variable c_int
DMDITHER_COARSE = 2 # Variable c_int
HDF_JUSTIFYMASK = 3 # Variable c_int
ERROR_SCREEN_ALREADY_LOCKED = 1440 # Variable c_long
cmb6 = 1141 # Variable c_int
NORM_IGNORECASE = 1 # Variable c_int
LVN_BEGINLABELEDITA = 4294967191 # Variable c_uint
MM_MCISIGNAL = 971 # Variable c_int
OF_REOPEN = 32768 # Variable c_int
VERTRES = 10 # Variable c_int
PFD_SWAP_COPY = 1024 # Variable c_int
DONT_RESOLVE_DLL_REFERENCES = 1 # Variable c_int
PRINTACTION_NETINSTALL = 2 # Variable c_int
PSD_INWININIINTLMEASURE = 0 # Variable c_int
CS_E_NO_CLASSSTORE = -2147221144 # Variable c_long
NCBCANCEL = 53 # Variable c_int
UD_MAXVAL = 32767 # Variable c_int
CTRY_MEXICO = 52 # Variable c_int
RPC_X_SS_CHAR_TRANS_SHORT_FILE = 1774 # Variable c_long
TBDDRET_NODEFAULT = 1 # Variable c_int
SIF_ALL = 23 # Variable c_int
S_SERDDR = -14 # Variable c_int
SHGFI_DISPLAYNAME = 512 # Variable c_int
DMLERR_REENTRANCY = 16397 # Variable c_int
IMPLINK_IP = 155 # Variable c_int
TRANSPORT_TYPE_WMSG = 8 # Variable c_int
QS_ALLEVENTS = 191 # Variable c_int
OFN_ENABLETEMPLATE = 64 # Variable c_int
NM_FIRST = 0 # Variable c_uint
TAPE_DRIVE_VARIABLE_BLOCK = 2048 # Variable c_int
MCI_STOP = 2056 # Variable c_int
CDERR_FINDRESFAILURE = 6 # Variable c_int
PSH_MODELESS = 1024 # Variable c_int
TBCDRF_NOETCHEDEFFECT = 1048576 # Variable c_int
MOVEFILE_DELAY_UNTIL_REBOOT = 4 # Variable c_int
HDM_SETORDERARRAY = 4626 # Variable c_int
PAN_MIDLINE_STANDARD_SERIFED = 4 # Variable c_int
PRINTER_ATTRIBUTE_WORK_OFFLINE = 1024 # Variable c_int
psh16 = 1039 # Variable c_int
SHGFI_ICONLOCATION = 4096 # Variable c_int
SUBLANG_UZBEK_CYRILLIC = 2 # Variable c_int
RPC_C_MQ_JOURNAL_NONE = 0 # Variable c_int
NETINFO_PRINTERRED = 8 # Variable c_int
PRINTDLGORD = 1538 # Variable c_int
SO_REUSEADDR = 4 # Variable c_int
HKEY_PERFORMANCE_DATA = 2147483652 # Variable POINTER(HKEY__)
MCI_OVLY_OPEN_PARENT = 131072 # Variable c_long
MCI_GETDEVCAPS_USES_FILES = 5 # Variable c_long
STG_E_OLDDLL = -2147286779 # Variable c_long

tagFUNCKIND = c_int # enum
FUNC_VIRTUAL = 0
FUNC_PUREVIRTUAL = 1
FUNC_NONVIRTUAL = 2
stc6 = 1093 # Variable c_int
DS_SETFOREGROUND = 512 # Variable c_long
SERVICE_SYSTEM_START = 1 # Variable c_int
EN_MAXTEXT = 1281 # Variable c_int
MCIERR_DEVICE_OPEN = 265 # Variable c_int
S_SERDCC = -7 # Variable c_int
NLS_KATAKANA = 131072 # Variable c_int
COLOR_MENU = 4 # Variable c_int
TPM_CENTERALIGN = 4 # Variable c_long
NDR_LOCAL_DATA_REPRESENTATION = 16 # Variable c_ulong
FORM_PRINTER = 2 # Variable c_int
SM_CYSMSIZE = 53 # Variable c_int
PS_DOT = 2 # Variable c_int
CLSCTX_INPROC = 3 # Variable c_int
DFCS_MONO = 32768 # Variable c_int
OUT_STROKE_PRECIS = 3 # Variable c_int
TVC_BYKEYBOARD = 2 # Variable c_int
CDS_FULLSCREEN = 4 # Variable c_int
FD_ACCEPT = 8 # Variable c_int
IMAGE_REL_MIPS_JMPADDR16 = 16 # Variable c_int
SBT_POPOUT = 512 # Variable c_int
PSINJECT_REPLACE = 1 # Variable c_int
MIXER_OBJECTF_HWAVEOUT = 2415919104 # Variable c_ulong
SP_STOPBITS = 8 # Variable c_ulong

_GET_FILEEX_INFO_LEVELS = c_int # enum
GetFileExInfoStandard = 0
GetFileExMaxInfoLevel = 1
BN_KILLFOCUS = 7 # Variable c_int
SPI_SETNONCLIENTMETRICS = 42 # Variable c_int
CACHE_S_SOMECACHES_NOTUPDATED = 262514 # Variable c_long
PSD_NONETWORKBUTTON = 2097152 # Variable c_int
SUBLANG_PORTUGUESE_BRAZILIAN = 1 # Variable c_int
ERROR_CONNECTION_COUNT_LIMIT = 1238 # Variable c_long
CB_INSERTSTRING = 330 # Variable c_int
ORD_LANGDRIVER = 1 # Variable c_int
LOCALE_ILANGUAGE = 1 # Variable c_int
MIDIMAPPER = 4294967295 # Variable c_uint
SB_GETRECT = 1034 # Variable c_int
PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST = 512 # Variable c_int
IPM_SETRANGE = 1127 # Variable c_int
MCIERR_INVALID_DEVICE_ID = 257 # Variable c_int
VFT2_DRV_LANGUAGE = 3 # Variable c_long
CBS_AUTOHSCROLL = 64 # Variable c_long
USER_MARSHAL_FC_USMALL = 4 # Variable c_int
TB_HITTEST = 1093 # Variable c_int
CAL_SLONGDATE = 6 # Variable c_int
NCBDGRECV = 33 # Variable c_int
TBSTATE_PRESSED = 2 # Variable c_int
RPC_C_OPT_MQ_JOURNAL = 3 # Variable c_int
INET_E_CANNOT_LOCK_REQUEST = -2146697194 # Variable c_long
HDN_ENDTRACKW = 4294966969 # Variable c_uint
RPC_S_SERVER_TOO_BUSY = 1723 # Variable c_long
IMAGE_SYM_CLASS_BLOCK = 100 # Variable c_int
AC_SRC_NO_PREMULT_ALPHA = 1 # Variable c_int
TVM_GETITEMA = 4364 # Variable c_int
SET_ARC_DIRECTION = 4102 # Variable c_int
TPM_VERTICAL = 64 # Variable c_long
CADV_LATEACK = 65535 # Variable c_int
SC_SEPARATOR = 61455 # Variable c_int
edt5 = 1156 # Variable c_int
FOREGROUND_INTENSITY = 8 # Variable c_int
MCI_MODE_STOP = 525 # Variable c_int
CTLCOLOR_MSGBOX = 0 # Variable c_int
ERROR_WMI_INSTANCE_NOT_FOUND = 4201 # Variable c_long
TVIF_INTEGRAL = 128 # Variable c_int
PRINTER_STATUS_PAUSED = 1 # Variable c_int
NRC_NORES = 9 # Variable c_int
LVNI_SELECTED = 2 # Variable c_int
SERVICE_ENUMERATE_DEPENDENTS = 8 # Variable c_int
PO_RENAME = 20 # Variable c_int
WH_KEYBOARD = 2 # Variable c_int
STATUS_FLOAT_DIVIDE_BY_ZERO = 3221225614 # Variable c_ulong
IMAGE_REL_IA64_RESERVED_11 = 17 # Variable c_int
NF_QUERY = 3 # Variable c_int
FACILITY_NULL = 0 # Variable c_int
CC_ENABLETEMPLATE = 32 # Variable c_int
IMAGE_SCN_ALIGN_2BYTES = 2097152 # Variable c_int
VK_F1 = 112 # Variable c_int
FOURCC_RIFF = 1179011410 # Variable c_ulong
RUNDLGORD = 1545 # Variable c_int
FW_NORMAL = 400 # Variable c_int
URLACTION_DOWNLOAD_CURR_MAX = 4100 # Variable c_int
SPAPI_E_DI_POSTPROCESSING_REQUIRED = -2146500058 # Variable c_long
IO_REPARSE_TAG_MOUNT_POINT = 2684354563 # Variable c_uint
PSNRET_NOERROR = 0 # Variable c_int
CAT_E_FIRST = 2147746144 # Variable c_ulong
REG_OPTION_RESERVED = 0 # Variable c_long
FLUSHOUTPUT = 6 # Variable c_int
DRAGDROP_S_DROP = 262400 # Variable c_long
VK_F10 = 121 # Variable c_int
PERF_100NSEC_TIMER_INV = 558957824 # Variable c_int
DLGC_WANTMESSAGE = 4 # Variable c_int
SE_LOAD_DRIVER_NAME = 'SeLoadDriverPrivilege' # Variable POINTER(c_wchar)
STD_PROPERTIES = 10 # Variable c_int
TTM_WINDOWFROMPOINT = 1040 # Variable c_int
RPC_E_CANTTRANSMIT_CALL = -2147418102 # Variable c_long
IDLFLAG_FLCID = 4 # Variable c_int
MEVT_F_CALLBACK = 1073741824 # Variable c_long
SUBLANG_FRENCH_LUXEMBOURG = 5 # Variable c_int
RESOURCEUSAGE_ATTACHED = 16 # Variable c_int
IDB_VIEW_SMALL_COLOR = 4 # Variable c_int
STARTF_USESIZE = 2 # Variable c_int
NCBSEND = 20 # Variable c_int
CDIS_SELECTED = 1 # Variable c_int
ERROR_NO_DATA = 232 # Variable c_long
DC_MINEXTENT = 4 # Variable c_int
FADF_UNKNOWN = 512 # Variable c_int
MCI_VD_GETDEVCAPS_SLOW_RATE = 16388 # Variable c_long
NTE_BAD_UID = -2146893823 # Variable c_long
STATUS_CONTROL_C_EXIT = 3221225786 # Variable c_ulong
WT_EXECUTEDELETEWAIT = 8 # Variable c_int
ERROR_ALREADY_REGISTERED = 1242 # Variable c_long
CP_RECTANGLE = 1 # Variable c_int
ERROR_BAD_DATABASE_VERSION = 1613 # Variable c_long
STANDARD_RIGHTS_EXECUTE = 131072 # Variable c_long
MCI_ANIM_OPEN_NOSTATIC = 262144 # Variable c_long
EMR_SETCOLORADJUSTMENT = 23 # Variable c_int
WSAEINPROGRESS = 10036 # Variable c_int
WM_COMPAREITEM = 57 # Variable c_int
ERROR_DISK_CHANGE = 107 # Variable c_long
VK_KANJI = 25 # Variable c_int
RPC_C_BIND_TO_ALL_NICS = 1 # Variable c_int
LB_INSERTSTRING = 385 # Variable c_int
WAVERR_BADFORMAT = 32 # Variable c_int
HDF_OWNERDRAW = 32768 # Variable c_int
WNNC_NET_PROTSTOR = 2162688 # Variable c_int
CTRL_BREAK_EVENT = 1 # Variable c_int
EMARCH_ENC_I17_IMM9D_VAL_POS_X = 7 # Variable c_int
PRNSETUPDLGORD = 1539 # Variable c_int
HDN_BEGINTRACKA = 4294966990 # Variable c_uint
STD_FILEOPEN = 7 # Variable c_int
CBENF_RETURN = 2 # Variable c_int
SERVICES_ACTIVE_DATABASEW = 'ServicesActive' # Variable POINTER(c_wchar)
DMTT_BITMAP = 1 # Variable c_int
SC_KEYMENU = 61696 # Variable c_int
PRINTER_CHANGE_PRINTER = 255 # Variable c_int
MCIERR_WAVE_OUTPUTUNSPECIFIED = 324 # Variable c_int
ANSI_NULL = 0 # Variable c_char
CP_OEMCP = 1 # Variable c_int
IMAGE_DIRECTORY_ENTRY_TLS = 9 # Variable c_int
DMICMMETHOD_DEVICE = 4 # Variable c_int
PSINJECT_PAGEORDER = 22 # Variable c_int
LBN_SELCANCEL = 3 # Variable c_int
URLPOLICY_AUTHENTICATE_CLEARTEXT_OK = 0 # Variable c_int
CC_STYLED = 32 # Variable c_int
SW_OTHERUNZOOM = 4 # Variable c_int
WAVECAPS_PLAYBACKRATE = 2 # Variable c_int
WNNC_NET_NETWARE = 196608 # Variable c_int
NTE_PROV_TYPE_ENTRY_BAD = -2146893800 # Variable c_long
IMAGE_SCN_GPREL = 32768 # Variable c_int
ERROR_DELETING_ICM_XFORM = 2309 # Variable c_long
SID_MAX_SUB_AUTHORITIES = 15 # Variable c_int
TT_POLYGON_TYPE = 24 # Variable c_int
SEC_IMAGE = 16777216 # Variable c_int
EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X = 24 # Variable c_int
MK_E_EXCEEDEDDEADLINE = -2147221023 # Variable c_long
LVM_ARRANGE = 4118 # Variable c_int
LVBKIF_SOURCE_URL = 2 # Variable c_int
TBS_BOTTOM = 0 # Variable c_int
RIGHT_CTRL_PRESSED = 4 # Variable c_int
NUMPRS_LEADING_WHITE = 1 # Variable c_int
OBJ_FONT = 6 # Variable c_int
RPC_S_UNKNOWN_AUTHN_LEVEL = 1748 # Variable c_long
GCL_STYLE = -26 # Variable c_int
RB_GETBANDINFOW = 1052 # Variable c_int
LOCALE_IMONLZERO = 39 # Variable c_int
MB_RTLREADING = 1048576 # Variable c_long
IMAGE_DEBUG_TYPE_FIXUP = 6 # Variable c_int
WM_HELP = 83 # Variable c_int
PAN_XHEIGHT_CONSTANT_STD = 3 # Variable c_int
CAL_GREGORIAN_US = 2 # Variable c_int
IMAGE_ARCHIVE_START = '!<arch>\n' # Variable POINTER(c_char)
RPCFLG_INPUT_SYNCHRONOUS = 536870912 # Variable c_ulong
COLOR_3DLIGHT = 22 # Variable c_int
CAT_E_CATIDNOEXIST = -2147221152 # Variable c_long
ERROR_RMODE_APP = 1153 # Variable c_long
TC_NORMAL = 0 # Variable c_int
DMICMMETHOD_SYSTEM = 2 # Variable c_int
TIMER_ALL_ACCESS = 2031619 # Variable c_long
MB_MODEMASK = 12288 # Variable c_long
CLIPBRD_S_FIRST = 262608 # Variable c_long
IMPLINK_LOWEXPER = 156 # Variable c_int
JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 8 # Variable c_int
RPC_C_AUTHN_LEVEL_NONE = 1 # Variable c_int
HOTKEYF_EXT = 8 # Variable c_int

tagTYMED = c_int # enum
TYMED_GDI = 16
TYMED_MFPICT = 32
TYMED_ENHMF = 64
TYMED_NULL = 0
EMR_MIN = 1 # Variable c_int
OFN_NOLONGNAMES = 262144 # Variable c_int
TTM_GETMARGIN = 1051 # Variable c_int
EVENT_MODIFY_STATE = 2 # Variable c_int
SUBLANG_SWEDISH_FINLAND = 2 # Variable c_int
APD_COPY_NEW_FILES = 8 # Variable c_int
PAN_CONTRAST_INDEX = 4 # Variable c_int
RPC_S_NOTHING_TO_EXPORT = 1754 # Variable c_long
WM_SIZECLIPBOARD = 779 # Variable c_int
DESKTOP_HOOKCONTROL = 8 # Variable c_long
WSAEAFNOSUPPORT = 10047 # Variable c_int
HELP_INDEX = 3 # Variable c_long
ICM_SETDEFAULTPROFILE = 4 # Variable c_int
ERROR_BAD_NET_NAME = 67 # Variable c_long
LOCALE_SABBREVMONTHNAME9 = 76 # Variable c_int
STG_E_SHAREVIOLATION = -2147287008 # Variable c_long
OLE_E_CANT_GETMONIKER = -2147221495 # Variable c_long
SB_VERT = 1 # Variable c_int
ACL_REVISION1 = 1 # Variable c_int
DMPAPER_ENV_C65 = 32 # Variable c_int
stc9 = 1096 # Variable c_int
ERROR_OBJECT_NOT_FOUND = 4312 # Variable c_long
APD_STRICT_DOWNGRADE = 2 # Variable c_int
SUBLANG_GERMAN_LUXEMBOURG = 4 # Variable c_int
SPAPI_E_DI_NOFILECOPY = -2146500081 # Variable c_long
MIXERLINE_TARGETTYPE_WAVEOUT = 1 # Variable c_int
WVR_VALIDRECTS = 1024 # Variable c_int
RPC_S_NO_MORE_MEMBERS = 1757 # Variable c_long
JOY_BUTTON29 = 268435456 # Variable c_long
rad9 = 1064 # Variable c_int
NMTVCUSTOMDRAW_V3_SIZE = 56 # Variable c_uint
MCI_OVLY_WINDOW_DISABLE_STRETCH = 2097152 # Variable c_long
COMMON_LVB_UNDERSCORE = 32768 # Variable c_int
RBS_TOOLTIPS = 256 # Variable c_int
ID_DEFAULTINST = -2 # Variable c_int
LVM_GETCOLUMNA = 4121 # Variable c_int
CTRY_FINLAND = 358 # Variable c_int
SPI_GETKEYBOARDPREF = 68 # Variable c_int
CDN_LAST = 4294966597 # Variable c_uint
DO_DROPFILE = 1162627398 # Variable c_long
TB_ADDBUTTONSA = 1044 # Variable c_int
EVENTLOG_AUDIT_SUCCESS = 8 # Variable c_int
SUBLANG_GERMAN_AUSTRIAN = 3 # Variable c_int
CTRY_PHILIPPINES = 63 # Variable c_int
TBM_SETBUDDY = 1056 # Variable c_int
CBES_EX_NOEDITIMAGE = 1 # Variable c_int
META_SETVIEWPORTEXT = 526 # Variable c_int
IDI_QUESTION = 206100 # Variable POINTER(c_wchar)
VIEW_SORTNAME = 4 # Variable c_int
VK_F13 = 124 # Variable c_int
TAPE_SELECT_PARTITIONS = 1 # Variable c_long
LOCALE_ILDATE = 34 # Variable c_int
DC_EXTRA = 9 # Variable c_int
URLACTION_CREDENTIALS_USE = 6656 # Variable c_int
TB_SETROWS = 1063 # Variable c_int
COLOR_INACTIVEBORDER = 11 # Variable c_int
FRAME_FPO = 0 # Variable c_int
JOB_WRITE = 131088 # Variable c_long
STGM_READWRITE = 2 # Variable c_long
TVM_SETINSERTMARKCOLOR = 4389 # Variable c_int
LBS_OWNERDRAWFIXED = 16 # Variable c_long
TTF_RTLREADING = 4 # Variable c_int
TCS_MULTILINE = 512 # Variable c_int
SBS_BOTTOMALIGN = 4 # Variable c_long
PSD_INTHOUSANDTHSOFINCHES = 4 # Variable c_int
META_SETPOLYFILLMODE = 262 # Variable c_int
SERVICE_STOP = 32 # Variable c_int
MIXERCONTROL_CT_UNITS_UNSIGNED = 196608 # Variable c_long
AC_LINE_BACKUP_POWER = 2 # Variable c_int
MCI_SET_OFF = 16384 # Variable c_long
ERROR_INTERNAL_ERROR = 1359 # Variable c_long
ERROR_INVALID_NAME = 123 # Variable c_long
ENUM_E_LAST = 2147746239 # Variable c_ulong
WNNC_NET_FRONTIER = 1507328 # Variable c_int
STGM_SHARE_DENY_WRITE = 32 # Variable c_long
URLACTION_NETWORK_MIN = 6656 # Variable c_int
TTM_GETCURRENTTOOLW = 1083 # Variable c_int
LOCALE_SLIST = 12 # Variable c_int
PERF_COUNTER_MULTI_TIMER = 574686464 # Variable c_int
FILE_TYPE_UNKNOWN = 0 # Variable c_int
ERROR_INVALID_FUNCTION = 1 # Variable c_long
IMAGE_SYM_CLASS_LABEL = 6 # Variable c_int
ERROR_ACCESS_DENIED = 5 # Variable c_long
DMPAPER_STATEMENT = 6 # Variable c_int
DT_NOPREFIX = 2048 # Variable c_int
EMR_FLATTENPATH = 65 # Variable c_int
HDF_STRING = 16384 # Variable c_int
URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY = 4612 # Variable c_int
PSN_WIZFINISH = 4294967088 # Variable c_uint
CTRY_FAEROE_ISLANDS = 298 # Variable c_int
VOS__BASE = 0 # Variable c_long
IDCANCEL = 2 # Variable c_int
ES_RIGHT = 2 # Variable c_long
CDDS_POSTERASE = 4 # Variable c_int
DFCS_BUTTONPUSH = 16 # Variable c_int
LB_GETITEMDATA = 409 # Variable c_int
CALL_PENDING = 2 # Variable c_int
OUTPUT_DEBUG_STRING_EVENT = 8 # Variable c_int
CO_E_OBJSRV_RPC_FAILURE = -2146959354 # Variable c_long
EMARCH_ENC_I17_IMM41b_INST_WORD_X = 1 # Variable c_int
GL_ID_INPUTREADING = 36 # Variable c_int
cmb9 = 1144 # Variable c_int
STATUS_IN_PAGE_ERROR = 3221225478 # Variable c_ulong
QS_POSTMESSAGE = 8 # Variable c_int
DM_COLLATE = 32768 # Variable c_long
FILE_ATTRIBUTE_ARCHIVE = 32 # Variable c_int
IMAGE_SYM_DEBUG = -2 # Variable c_short
ERROR_PRIVATE_DIALOG_INDEX = 1415 # Variable c_long
NCBSSTAT = 52 # Variable c_int
JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 2 # Variable c_int
IMAGE_REL_MIPS_SECRELHI = 13 # Variable c_int
FACILITY_SSPI = 9 # Variable c_int
OUT_TT_ONLY_PRECIS = 7 # Variable c_int
RBS_DBLCLKTOGGLE = 32768 # Variable c_int
OUT_SCREEN_OUTLINE_PRECIS = 9 # Variable c_int
REG_OPTION_NON_VOLATILE = 0 # Variable c_long
EXCEPTION_NONCONTINUABLE = 1 # Variable c_int
RPC_X_ENUM_VALUE_OUT_OF_RANGE = 1781 # Variable c_long
SECURITY_DIALUP_RID = 1 # Variable c_long
URLACTION_SCRIPT_OVERRIDE_SAFETY = 5121 # Variable c_int
ERROR_INVALID_ADDRESS = 487 # Variable c_long
WM_QUERYOPEN = 19 # Variable c_int
WSAENOTSOCK = 10038 # Variable c_int
DTM_FIRST = 4096 # Variable c_int
MMIO_GLOBALPROC = 268435456 # Variable c_int
CBF_FAIL_EXECUTES = 32768 # Variable c_int
DI_READ_SPOOL_JOB = 3 # Variable c_int
BF_BOTTOMLEFT = 9 # Variable c_int
MCI_WINDOW = 2113 # Variable c_int
WSAEHOSTUNREACH = 10065 # Variable c_int
SS_ETCHEDVERT = 17 # Variable c_long
ICC_INTERNET_CLASSES = 2048 # Variable c_int
LOCALE_INEGSYMPRECEDES = 86 # Variable c_int
LVN_GETINFOTIPW = 4294967138 # Variable c_uint
JOY_CAL_READALWAYS = 65536 # Variable c_long
MCI_OPEN_TYPE_ID = 4096 # Variable c_long
EMR_CREATEPEN = 38 # Variable c_int
ERROR_PRINTER_DRIVER_IN_USE = 3001 # Variable c_long
PGB_BOTTOMORRIGHT = 1 # Variable c_int
ERROR_DEVICE_REINITIALIZATION_NEEDED = 1164 # Variable c_long
EMR_SETTEXTALIGN = 22 # Variable c_int
IP_DROP_MEMBERSHIP = 6 # Variable c_int
TYPE_E_INVALIDSTATE = -2147319767 # Variable c_long
NI_SETCANDIDATE_PAGESIZE = 23 # Variable c_int
DLGWINDOWEXTRA = 30 # Variable c_int
CCM_FIRST = 8192 # Variable c_int
GCL_MENUNAME = -8 # Variable c_int
CBS_NOINTEGRALHEIGHT = 1024 # Variable c_long
HDF_IMAGE = 2048 # Variable c_int
TVHT_ONITEMRIGHT = 32 # Variable c_int
PD_NOWARNING = 128 # Variable c_int
MCIERR_CUSTOM_DRIVER_BASE = 512 # Variable c_int
MMIO_TOUPPER = 16 # Variable c_int
ERROR_WINDOW_NOT_DIALOG = 1420 # Variable c_long
TBSTYLE_ALTDRAG = 1024 # Variable c_int
META_EXCLUDECLIPRECT = 1045 # Variable c_int
CTRY_DEFAULT = 0 # Variable c_int
NFS_LISTCOMBO = 4 # Variable c_int
MM_MIM_CLOSE = 962 # Variable c_int
DCE_C_ERROR_STRING_LEN = 256 # Variable c_int
CTRY_LATVIA = 371 # Variable c_int
ERROR_WRITE_PROTECT = 19 # Variable c_long
CD_LBSELADD = 2 # Variable c_int
TOKEN_ADJUST_DEFAULT = 128 # Variable c_int
STG_S_CONSOLIDATIONFAILED = 197125 # Variable c_long
CRYPT_E_ISSUER_SERIALNUMBER = -2146889715 # Variable c_long
LBS_NODATA = 8192 # Variable c_long
TVN_SELCHANGINGA = 4294966895 # Variable c_uint
TAPE_DRIVE_ERASE_LONG = 32 # Variable c_int
EMARCH_ENC_I17_IMM5C_INST_WORD_X = 3 # Variable c_int
TBM_GETSELEND = 1042 # Variable c_int
PRINTER_STATUS_IO_ACTIVE = 256 # Variable c_int
CAL_SABBREVDAYNAME7 = 20 # Variable c_int
TB_GETEXTENDEDSTYLE = 1109 # Variable c_int
TB_GETTEXTROWS = 1085 # Variable c_int
ATTR_FIXEDCONVERTED = 5 # Variable c_int
URLPOLICY_JAVA_MEDIUM = 131072 # Variable c_int
TAPE_DRIVE_SEQUENTIAL_SMKS = 2149580800 # Variable c_uint
SM_CYSMICON = 50 # Variable c_int
WM_SIZING = 532 # Variable c_int
CACHE_S_FORMATETC_NOTSUPPORTED = 262512 # Variable c_long
CTRY_QATAR = 974 # Variable c_int
ERROR_CANNOT_DETECT_PROCESS_ABORT = 1081 # Variable c_long
INVALID_ATOM = 0 # Variable c_ushort
CRYPT_E_NO_SIGNER = -2146885618 # Variable c_long
STGM_DELETEONRELEASE = 67108864 # Variable c_long
XCLASS_DATA = 8192 # Variable c_int
HSHELL_GETMINRECT = 5 # Variable c_int
LVN_DELETEALLITEMS = 4294967192 # Variable c_uint
SUBLANG_ARABIC_IRAQ = 2 # Variable c_int
URLACTION_MIN = 4096 # Variable c_int
CB_GETEDITSEL = 320 # Variable c_int
PDERR_PRINTERNOTFOUND = 4107 # Variable c_int
SM_DEBUG = 22 # Variable c_int
ERROR_PATH_BUSY = 148 # Variable c_long
SS_TYPEMASK = 31 # Variable c_long
IMAGE_REL_I386_DIR32NB = 7 # Variable c_int
RDW_VALIDATE = 8 # Variable c_int
SHGFI_TYPENAME = 1024 # Variable c_int
C1_BLANK = 64 # Variable c_int
edt6 = 1157 # Variable c_int
RESOURCEUSAGE_CONNECTABLE = 1 # Variable c_int
DM_PAPERLENGTH = 4 # Variable c_long
OUT_RASTER_PRECIS = 6 # Variable c_int
R2_MERGEPEN = 15 # Variable c_int
MMIOM_WRITEFLUSH = 5 # Variable c_int
PAN_LETT_NORMAL_BOXED = 4 # Variable c_int
LB_OKAY = 0 # Variable c_int
lst3 = 1122 # Variable c_int
META_DIBBITBLT = 2368 # Variable c_int
BSM_ALLCOMPONENTS = 0 # Variable c_int
MCI_PASTE = 2131 # Variable c_int
VK_SEPARATOR = 108 # Variable c_int
FADF_AUTO = 1 # Variable c_int
ERROR_DIRECT_ACCESS_HANDLE = 130 # Variable c_long
SERVICE_INACTIVE = 2 # Variable c_int
IMAGE_REL_IA64_RESERVED_16 = 22 # Variable c_int
WGL_SWAP_UNDERLAY8 = 8388608 # Variable c_int
JOY_RETURNALL = 255 # Variable c_long
IPPORT_SMTP = 25 # Variable c_int
VK_F2 = 113 # Variable c_int
SO_SNDLOWAT = 4099 # Variable c_int
SETKERNTRACK = 770 # Variable c_int
IPPORT_SYSTAT = 11 # Variable c_int
LOCALE_INEGSIGNPOSN = 83 # Variable c_int
CO_E_BAD_SERVER_NAME = -2147467244 # Variable c_long
WSAENETRESET = 10052 # Variable c_int
RB_GETBARINFO = 1027 # Variable c_int
GW_HWNDLAST = 1 # Variable c_int
LVIF_IMAGE = 2 # Variable c_int
VK_F11 = 122 # Variable c_int
SO_BROADCAST = 32 # Variable c_int
DMCOLLATE_TRUE = 1 # Variable c_int
ILLUMINANT_F2 = 8 # Variable c_int
SERVICE_QUERY_STATUS = 4 # Variable c_int
CC_NONE = 0 # Variable c_int
DT_WORD_ELLIPSIS = 262144 # Variable c_int
FORM_BUILTIN = 1 # Variable c_int
MCHT_TITLEMONTH = 65537 # Variable c_int
DMBIN_LOWER = 2 # Variable c_int
SBS_TOPALIGN = 2 # Variable c_long
ERROR_TOO_MANY_NAMES = 68 # Variable c_long
ERROR_CANCELLED = 1223 # Variable c_long
ERROR_KEY_DELETED = 1018 # Variable c_long
LPD_TYPE_RGBA = 0 # Variable c_int
META_SELECTPALETTE = 564 # Variable c_int
SERVICE_ACCEPT_NETBINDCHANGE = 16 # Variable c_int
MCI_VD_STATUS_SPEED = 16386 # Variable c_long
COLOROKSTRINGA = 'commdlg_ColorOK' # Variable POINTER(c_char)
RPC_E_UNEXPECTED = -2147352577 # Variable c_long
WSAEFAULT = 10014 # Variable c_int
C1_XDIGIT = 128 # Variable c_int
IPN_FIRST = 4294966436 # Variable c_uint
EM_SETHANDLE = 188 # Variable c_int
MIDISTRM_ERROR = -2 # Variable c_int
DMICMMETHOD_USER = 256 # Variable c_int
IS_TEXT_UNICODE_REVERSE_CONTROLS = 64 # Variable c_int
PSH_USEHBMWATERMARK = 65536 # Variable c_int
REGDB_E_KEYMISSING = -2147221166 # Variable c_long
RPC_C_EP_MATCH_BY_OBJ = 2 # Variable c_int
IPPROTO_PUP = 12 # Variable c_int
INADDR_BROADCAST = 4294967295 # Variable c_ulong
STG_LAYOUT_SEQUENTIAL = 0 # Variable c_long
SID_REVISION = 1 # Variable c_int
SHGFI_ICON = 256 # Variable c_int
CS_NOCLOSE = 512 # Variable c_int
IN_CLASSA_NET = 4278190080 # Variable c_uint
NRC_SCLOSED = 10 # Variable c_int
FSB_FLAT_MODE = 2 # Variable c_int
IMAGE_SCN_MEM_SHARED = 268435456 # Variable c_int
TYPE_E_BADMODULEKIND = -2147317571 # Variable c_long
ERROR_NOT_EXPORT_FORMAT = 6008 # Variable c_long
CLIPBRD_E_CANT_EMPTY = -2147221039 # Variable c_long
TAPE_SHORT_FILEMARKS = 2 # Variable c_long
SM_CXMINIMIZED = 57 # Variable c_int
CO_E_INIT_TLS = -2147467258 # Variable c_long
IMAGE_REL_MIPS_LITERAL = 7 # Variable c_int
ODT_BUTTON = 4 # Variable c_int
ABS_AUTOHIDE = 1 # Variable c_int
SERVER_ALL_ACCESS = 983043 # Variable c_long
OBJ_METAFILE = 9 # Variable c_int
DMPAPER_LETTER_EXTRA = 50 # Variable c_int
TTF_TRANSPARENT = 256 # Variable c_int
SERVICES_FAILED_DATABASEW = 'ServicesFailed' # Variable POINTER(c_wchar)
WM_STYLECHANGED = 125 # Variable c_int
RBBS_NOVERT = 16 # Variable c_int
PERF_TYPE_COUNTER = 1024 # Variable c_int
DM_LOGPIXELS = 131072 # Variable c_long
ENHANCED_KEY = 256 # Variable c_int
LVS_ALIGNLEFT = 2048 # Variable c_int
LOCALE_FONTSIGNATURE = 88 # Variable c_int
EV_RX80FULL = 1024 # Variable c_int
HKEY_CURRENT_CONFIG = 2147483653 # Variable POINTER(HKEY__)
TBSTYLE_SEP = 1 # Variable c_int
URLPOLICY_QUERY = 1 # Variable c_int
WAVE_FORMAT_DIRECT = 8 # Variable c_int
WM_RENDERALLFORMATS = 774 # Variable c_int
MOD_SYNTH = 2 # Variable c_int
RPC_S_FP_DIV_ZERO = 1769 # Variable c_long
PIDSI_CREATE_DTM = 12 # Variable c_long
IME_SMODE_CONVERSATION = 16 # Variable c_int
CBR_57600 = 57600 # Variable c_int
PRINTER_NOTIFY_FIELD_AVERAGE_PPM = 21 # Variable c_int
FR_ENABLETEMPLATE = 512 # Variable c_int
EPS_SIGNATURE = 1179865157 # Variable c_int
OLE_E_CLASSDIFF = -2147221496 # Variable c_long
PD_RETURNDC = 256 # Variable c_int
LMEM_MODIFY = 128 # Variable c_int
JOB_OBJECT_UI_VALID_FLAGS = 255 # Variable c_int
ACM_PLAY = 1125 # Variable c_int
ERROR_INVALID_DWP_HANDLE = 1405 # Variable c_long
DCB_SET = 3 # Variable c_int
FILE_FLAG_NO_BUFFERING = 536870912 # Variable c_int
ILCF_MOVE = 0 # Variable c_int
SB_SETICON = 1039 # Variable c_int
I_CHILDRENCALLBACK = -1 # Variable c_int
HDATA_APPOWNED = 1 # Variable c_int
SPLREG_DS_PRESENT = 'DsPresent' # Variable POINTER(c_wchar)
IMAGE_REL_ARM_BRANCH11 = 4 # Variable c_int
MCI_WAVE_STATUS_LEVEL = 16391 # Variable c_long
FILE_ADD_FILE = 2 # Variable c_int
DMPAPER_ENV_INVITE = 47 # Variable c_int
CRYPT_E_INVALID_IA5_STRING = -2146885598 # Variable c_long
ENABLE_PROCESSED_OUTPUT = 1 # Variable c_int
DRAGDROP_E_INVALIDHWND = -2147221246 # Variable c_long
IMAGE_FILE_BYTES_REVERSED_HI = 32768 # Variable c_int
RB_GETBANDINFOA = 1053 # Variable c_int
AF_CHAOS = 5 # Variable c_int
ACTIVEOBJECT_STRONG = 0 # Variable c_int
TF_DISCONNECT = 1 # Variable c_int
OLE_E_CANT_BINDTOSOURCE = -2147221494 # Variable c_long
HS_BDIAGONAL = 3 # Variable c_int
TT_PRIM_QSPLINE = 2 # Variable c_int
JOB_CONTROL_DELETE = 5 # Variable c_int
WIN_CERT_TYPE_X509 = 1 # Variable c_int
DM_DITHERTYPE = 67108864 # Variable c_long
MIDI_CACHE_QUERY = 3 # Variable c_int
ERROR_INVALID_MSGBOX_STYLE = 1438 # Variable c_long
ILD_MASK = 16 # Variable c_int
RT_FONT = 8 # Variable POINTER(c_wchar)
IMAGE_DEBUG_TYPE_EXCEPTION = 5 # Variable c_int
LVM_SETITEMCOUNT = 4143 # Variable c_int
IME_PROP_UNICODE = 524288 # Variable c_int
EN_ERRSPACE = 1280 # Variable c_int
SB_SETTEXTA = 1025 # Variable c_int
MDMVOLFLAG_LOW = 1 # Variable c_int
CTRY_LITHUANIA = 370 # Variable c_int
IMAGE_SCN_MEM_16BIT = 131072 # Variable c_int
EMR_SETSTRETCHBLTMODE = 21 # Variable c_int
CB_RESETCONTENT = 331 # Variable c_int
SLE_ERROR = 1 # Variable c_int
OLE_S_MAC_CLIPFORMAT = 262146 # Variable c_long
MCIERR_BAD_TIME_FORMAT = 293 # Variable c_int
MIDIERR_NOMAP = 66 # Variable c_int
MIXERCONTROL_CONTROLTYPE_PERCENT = 805634048 # Variable c_long
SPAPI_E_SECTION_NOT_FOUND = -2146500351 # Variable c_long
CRYPT_E_NO_VERIFY_USAGE_CHECK = -2146885592 # Variable c_long
ERROR_NO_SYSTEM_MENU = 1437 # Variable c_long
KEY_READ = 131097 # Variable c_long
PRINTER_ENUM_ICON3 = 262144 # Variable c_int
NIM_DELETE = 2 # Variable c_int
PAN_SERIF_OBTUSE_SANS = 12 # Variable c_int
MOUSE_WHEELED = 4 # Variable c_int
FILE_NOTIFY_CHANGE_LAST_ACCESS = 32 # Variable c_int
WS_EX_ACCEPTFILES = 16 # Variable c_long
ANSI_VAR_FONT = 12 # Variable c_int
MCI_CDA_STATUS_TYPE_TRACK = 16385 # Variable c_long
FADF_FIXEDSIZE = 16 # Variable c_int
INVALID_HANDLE_VALUE = 4294967295 # Variable c_void_p
VK_RCONTROL = 163 # Variable c_int
PST_NETWORK_BRIDGE = 256 # Variable c_ulong
NRC_BRIDGE = 35 # Variable c_int
TAPE_FILEMARKS = 1 # Variable c_long
TVIS_EXPANDED = 32 # Variable c_int
MCM_GETSELRANGE = 4101 # Variable c_int
MCI_NOTIFY = 1 # Variable c_long
DMMEDIA_STANDARD = 1 # Variable c_int
FNERR_SUBCLASSFAILURE = 12289 # Variable c_int
STATUS_GUARD_PAGE_VIOLATION = 2147483649 # Variable c_ulong
SEE_MASK_NOCLOSEPROCESS = 64 # Variable c_int
GCPGLYPH_LINKBEFORE = 32768 # Variable c_int
URLPOLICY_JAVA_CUSTOM = 8388608 # Variable c_int
RPC_C_NS_SYNTAX_DCE = 3 # Variable c_int
PRINTER_NOTIFY_FIELD_START_TIME = 16 # Variable c_int
ERROR_NO_ASSOCIATION = 1155 # Variable c_long
UDM_GETACCEL = 1132 # Variable c_int
PHYSICALOFFSETX = 112 # Variable c_int
FINDDLGORD = 1540 # Variable c_int
VTBIT_CY = 64 # Variable c_int
TPM_RIGHTALIGN = 8 # Variable c_long
IMAGE_SYM_CLASS_UNDEFINED_STATIC = 14 # Variable c_int

tagUSERCLASSTYPE = c_int # enum
USERCLASSTYPE_FULL = 1
USERCLASSTYPE_SHORT = 2
MCI_ANIM_STATUS_HWND = 16387 # Variable c_long
MF_UNHILITE = 0 # Variable c_long
WM_CANCELJOURNAL = 75 # Variable c_int
SBS_RIGHTALIGN = 4 # Variable c_long
CAL_SERASTRING = 4 # Variable c_int
RES_CURSOR = 2 # Variable c_int
DC_INBUTTON = 16 # Variable c_int
OUT_DEVICE_PRECIS = 5 # Variable c_int
SPI_GETHIGHCONTRAST = 66 # Variable c_int
LMEM_INVALID_HANDLE = 32768 # Variable c_int
WS_POPUPWINDOW = 2156396544 # Variable c_ulong
BF_FLAT = 16384 # Variable c_int
PT_BEZIERTO = 4 # Variable c_int
NDR_FLOAT_REP_MASK = 65280 # Variable c_ulong
WAVE_MAPPED = 4 # Variable c_int
VS_FF_PRIVATEBUILD = 8 # Variable c_long
NUMPRS_TRAILING_MINUS = 32 # Variable c_int
BS_DEFPUSHBUTTON = 1 # Variable c_long
KLF_SUBSTITUTE_OK = 2 # Variable c_int
ACTFLG_Published = 8 # Variable c_int
LR_MONOCHROME = 1 # Variable c_int
ERROR_MENU_ITEM_NOT_FOUND = 1456 # Variable c_long
DLGC_RADIOBUTTON = 64 # Variable c_int
SP_BAUD = 2 # Variable c_ulong
SPI_GETSCREENSAVETIMEOUT = 14 # Variable c_int
ENABLE_ECHO_INPUT = 4 # Variable c_int
STATUS_NO_MEMORY = 3221225495 # Variable c_ulong
ISC_SHOWUIALLCANDIDATEWINDOW = 15 # Variable c_int
SC_HSCROLL = 61568 # Variable c_int
RPC_C_BINDING_INFINITE_TIMEOUT = 10 # Variable c_int
ERROR_RESOURCE_TYPE_NOT_FOUND = 1813 # Variable c_long
LVCF_FMT = 1 # Variable c_int
CONVERT10_E_STG_FMT = -2147221052 # Variable c_long
OBJ_MEMDC = 10 # Variable c_int
CONTEXT_CONTROL = 65537 # Variable c_long
DI_ROPS_READ_DESTINATION = 2 # Variable c_int
EMARCH_ENC_I17_SIGN_SIZE_X = 1 # Variable c_int
MIXERLINE_COMPONENTTYPE_DST_WAVEIN = 7 # Variable c_long
PD_ENABLEPRINTHOOK = 4096 # Variable c_int
LOCALE_IDATE = 33 # Variable c_int
MCI_ANIM_REALIZE_BKGD = 131072 # Variable c_long
IS_TEXT_UNICODE_REVERSE_MASK = 240 # Variable c_int
JOB_OBJECT_LIMIT_AFFINITY = 16 # Variable c_int
ERROR_RESMON_CREATE_FAILED = 5017 # Variable c_long
CBR_BLOCK = 4294967295 # Variable POINTER(HDDEDATA__)
MWMO_WAITALL = 1 # Variable c_int
CTRY_LUXEMBOURG = 352 # Variable c_int
GL_LEVEL_ERROR = 2 # Variable c_int
CRYPT_E_NO_MATCH = -2146885623 # Variable c_long
HDITEMA_V1_SIZE = 28 # Variable c_uint
WM_DDE_POKE = 999 # Variable c_int
VK_EXECUTE = 43 # Variable c_int
PRINTER_ATTRIBUTE_LOCAL = 64 # Variable c_int
cmb8 = 1143 # Variable c_int
PD_NONETWORKBUTTON = 2097152 # Variable c_int
OFN_SHAREWARN = 0 # Variable c_int
NETINFO_DISKRED = 4 # Variable c_int
TBN_ENDDRAG = 4294966594 # Variable c_uint
ERROR_DUP_NAME = 52 # Variable c_long
PWR_CRITICALRESUME = 3 # Variable c_int
SUBLANG_ENGLISH_PHILIPPINES = 13 # Variable c_int
ERROR_HWNDS_HAVE_DIFF_PARENT = 1441 # Variable c_long
SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE = -2146500070 # Variable c_long
DISP_CHANGE_RESTART = 1 # Variable c_int
WNNC_NET_FARALLON = 1179648 # Variable c_int
GETEXTENDEDTEXTMETRICS = 256 # Variable c_int
EM_LINELENGTH = 193 # Variable c_int
MEVT_F_LONG = 2147483648 # Variable c_ulong
VARIANT_CALENDAR_HIJRI = 8 # Variable c_int
REGDB_S_FIRST = 262480 # Variable c_long
IDCLOSE = 8 # Variable c_int
DMICMMETHOD_NONE = 1 # Variable c_int
ERROR_MEMBER_NOT_IN_GROUP = 1321 # Variable c_long
UDN_LAST = 4294966556 # Variable c_uint
URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY = 4611 # Variable c_int
XTYP_ADVSTART = 4144 # Variable c_int
SMTO_BLOCK = 1 # Variable c_int

_SRVINFO = c_int # enum
RESOURCETYPE_ANY = 0 # Variable c_int
LVIF_PARAM = 4 # Variable c_int
psh10 = 1033 # Variable c_int
CRYPT_E_EXISTS = -2146885627 # Variable c_long
TBM_SETTIPSIDE = 1055 # Variable c_int
TB_GETDISABLEDIMAGELIST = 1079 # Variable c_int
WM_NCMBUTTONDBLCLK = 169 # Variable c_int
JOB_NOTIFY_FIELD_SUBMITTED = 16 # Variable c_int
PERF_COUNTER_VALUE = 0 # Variable c_int
SERVICE_USER_DEFINED_CONTROL = 256 # Variable c_int
JOB_STATUS_DELETED = 256 # Variable c_int
IME_REGWORD_STYLE_USER_FIRST = 2147483648 # Variable c_uint
MKF_MOUSEKEYSON = 1 # Variable c_int
GGL_LEVEL = 1 # Variable c_int
ERROR_BAD_EXE_FORMAT = 193 # Variable c_long
SUBLANG_ENGLISH_UK = 2 # Variable c_int
BSM_VXDS = 1 # Variable c_int
NCBCHAINSEND = 23 # Variable c_int
LVS_EX_FULLROWSELECT = 32 # Variable c_int
PST_RS232 = 1 # Variable c_ulong
WVR_ALIGNTOP = 16 # Variable c_int
PAN_STRAIGHT_ARMS_VERT = 4 # Variable c_int
LANG_TATAR = 68 # Variable c_int
ERROR_LB_WITHOUT_TABSTOPS = 1434 # Variable c_long

tagLOCKTYPE = c_int # enum
PERF_COUNTER_ELAPSED = 262144 # Variable c_int
CBEM_SETEXTENDEDSTYLE = 1038 # Variable c_int
PSN_GETOBJECT = 4294967086 # Variable c_uint
MCI_VD_PLAY_SPEED = 262144 # Variable c_long
SZDDESYS_ITEM_STATUS = 'Status' # Variable POINTER(c_wchar)
EMR_GDICOMMENT = 70 # Variable c_int
FR_FINDNEXT = 8 # Variable c_int
CERT_E_REVOCATION_FAILURE = -2146762482 # Variable c_long
IMAGE_REL_PPC_TOCDEFN = 2048 # Variable c_int
ERROR_INVALID_PROFILE = 2301 # Variable c_long
ERROR_REQUEST_ABORTED = 1235 # Variable c_long
OUT_OUTLINE_PRECIS = 8 # Variable c_int
ERROR_UNRECOGNIZED_MEDIA = 1785 # Variable c_long
PERF_COUNTER_QUEUELEN = 327680 # Variable c_int
APPCLASS_STANDARD = 0 # Variable c_long
PCF_16BITMODE = 512 # Variable c_ulong
ERROR_UNKNOWN_REVISION = 1305 # Variable c_long
TYPE_E_UNDEFINEDTYPE = -2147319769 # Variable c_long
META_EXTTEXTOUT = 2610 # Variable c_int
CAL_SABBREVDAYNAME6 = 19 # Variable c_int
ERROR_INVALID_PRINTER_NAME = 1801 # Variable c_long
SEM_NOGPFAULTERRORBOX = 2 # Variable c_int
RPC_S_UNKNOWN_IF = 1717 # Variable c_long
THREAD_SET_INFORMATION = 32 # Variable c_int
DL_MOVECURSOR = 3 # Variable c_int
SE_SACL_AUTO_INHERITED = 2048 # Variable c_int
ACM_STOP = 1126 # Variable c_int
MM_DRVM_DATA = 978 # Variable c_int
CDERR_LOADRESFAILURE = 7 # Variable c_int
HEAP_GENERATE_EXCEPTIONS = 4 # Variable c_int
LOCALE_S1159 = 40 # Variable c_int
ERROR_NOT_EMPTY = 4307 # Variable c_long
CO_E_ACNOTINITIALIZED = -2147220965 # Variable c_long
DMLERR_EXECACKTIMEOUT = 16389 # Variable c_int
CBEIF_SELECTEDIMAGE = 4 # Variable c_int
FILE_NOTIFY_CHANGE_SECURITY = 256 # Variable c_int
JOB_OBJECT_ASSIGN_PROCESS = 1 # Variable c_int
MB_PRECOMPOSED = 1 # Variable c_int
LANG_MACEDONIAN = 47 # Variable c_int
ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY = 1922 # Variable c_long
SO_CONNOPT = 28673 # Variable c_int
PM_NOREMOVE = 0 # Variable c_int
S_SERDMD = -10 # Variable c_int
PD_ENABLESETUPTEMPLATE = 32768 # Variable c_int
IPPROTO_MAX = 256 # Variable c_int
SUBLANG_SPANISH_PANAMA = 6 # Variable c_int
TAPE_REWIND = 0 # Variable c_long
AF_INET = 2 # Variable c_int
LVM_GETHEADER = 4127 # Variable c_int
OLEIVERB_UIACTIVATE = -4 # Variable c_long
MCM_GETFIRSTDAYOFWEEK = 4112 # Variable c_int
edt7 = 1158 # Variable c_int
LVS_SORTDESCENDING = 32 # Variable c_int
MK_LBUTTON = 1 # Variable c_int
RPC_S_INVALID_STRING_UUID = 1705 # Variable c_long
BACKUP_EA_DATA = 2 # Variable c_int
DCB_ACCUMULATE = 2 # Variable c_int
ERROR_INVALID_FLAG_NUMBER = 186 # Variable c_long
lst4 = 1123 # Variable c_int
WM_WINDOWPOSCHANGED = 71 # Variable c_int
MM_STREAM_CLOSE = 981 # Variable c_int
RT_MENU = 4 # Variable POINTER(c_wchar)
WM_DRAWITEM = 43 # Variable c_int
RPC_X_SS_CONTEXT_DAMAGED = 1777 # Variable c_long
MCM_SETTODAY = 4108 # Variable c_int
IMAGE_REL_IA64_RESERVED_14 = 20 # Variable c_int
LOCALE_SMONTHNAME9 = 64 # Variable c_int
MCHT_CALENDARWEEKNUM = 131075 # Variable c_int
VK_F3 = 114 # Variable c_int
CRYPT_E_NOT_FOUND = -2146885628 # Variable c_long
BSF_IGNORECURRENTTASK = 2 # Variable c_int
IMN_SETCANDIDATEPOS = 9 # Variable c_int
IPPORT_FTP = 21 # Variable c_int
SPLDS_PRINT_LANGUAGE = 'printLanguage' # Variable POINTER(c_wchar)
SCS_DOS_BINARY = 1 # Variable c_int
HDN_LAST = 4294966897 # Variable c_uint
PSINJECT_BEGINSETUP = 7 # Variable c_int
TIME_CALLBACK_FUNCTION = 0 # Variable c_int
LOCALE_SMONTHNAME13 = 4110 # Variable c_int
SPI_GETICONMETRICS = 45 # Variable c_int
OLEIVERB_OPEN = -2 # Variable c_long
TMPF_DEVICE = 8 # Variable c_int
VK_F12 = 123 # Variable c_int
DDL_SYSTEM = 4 # Variable c_int
DMPAPER_TABLOID = 3 # Variable c_int
CFSTR_MIME_RAWDATASTRM = 'application/octet-stream' # Variable POINTER(c_wchar)
CTRY_URUGUAY = 598 # Variable c_int
USER_CALL_IS_ASYNC = 256 # Variable c_int
TARGET_IS_NT351_OR_WIN95_OR_LATER = 1 # Variable c_int
ERROR_CANT_EVICT_ACTIVE_NODE = 5009 # Variable c_long
INET_E_INVALID_URL = -2146697214 # Variable c_long
FF_SCRIPT = 64 # Variable c_int
JOB_OBJECT_SECURITY_VALID_FLAGS = 15 # Variable c_int
BS_BOTTOM = 2048 # Variable c_long
STGM_READ = 0 # Variable c_long
RT_GROUP_ICON = 20 # Variable POINTER(c_wchar)
SM_CYBORDER = 6 # Variable c_int
WM_MENUCHAR = 288 # Variable c_int
CO_E_RUNAS_SYNTAX = -2147467241 # Variable c_long
SWP_HIDEWINDOW = 128 # Variable c_int
VK_F19 = 130 # Variable c_int
OFN_NOCHANGEDIR = 8 # Variable c_int
VIETNAMESE_CHARSET = 163 # Variable c_int
RPC_C_BINDING_MAX_TIMEOUT = 9 # Variable c_int
SACL_SECURITY_INFORMATION = 8 # Variable c_long
TVM_SORTCHILDRENCB = 4373 # Variable c_int
CBN_DROPDOWN = 7 # Variable c_int
ILD_IMAGE = 32 # Variable c_int
ICC_NATIVEFNTCTL_CLASS = 8192 # Variable c_int
ERROR_INVALID_USER_BUFFER = 1784 # Variable c_long
BATTERY_FLAG_LOW = 2 # Variable c_int
MIXERCONTROL_CONTROLTYPE_FADER = 1342373888 # Variable c_long

tagOLEUPDATE = c_int # enum
WM_ENTERMENULOOP = 529 # Variable c_int
REGDB_E_INVALIDVALUE = -2147221165 # Variable c_long
TVIF_TEXT = 1 # Variable c_int
LR_DEFAULTSIZE = 64 # Variable c_int
IE_BADID = -1 # Variable c_int
ERROR_LOCK_VIOLATION = 33 # Variable c_long
RPC_BUFFER_PARTIAL = 8192 # Variable c_int
MCI_WAVE_OUTPUT = 8388608 # Variable c_long
ERROR_SEVERITY_WARNING = 2147483648 # Variable c_uint
ERROR_BAD_LOGON_SESSION_STATE = 1365 # Variable c_long
SECURITY_DELEGATION = 196608 # Variable c_int
FW_EXTRALIGHT = 200 # Variable c_int
TCM_SETCURFOCUS = 4912 # Variable c_int
SB_LINEUP = 0 # Variable c_int
SCS_QUERYRECONVERTSTRING = 131072 # Variable c_int
HCF_HIGHCONTRASTON = 1 # Variable c_int
ETO_NUMERICSLATIN = 2048 # Variable c_int
ERROR_CANCEL_VIOLATION = 173 # Variable c_long
DMDITHER_RESERVED7 = 7 # Variable c_int
LVM_DELETECOLUMN = 4124 # Variable c_int
MCI_WAVE_INPUT = 4194304 # Variable c_long
IMAGE_ARCHIVE_LONGNAMES_MEMBER = '//              ' # Variable POINTER(c_char)
C2_OTHERNEUTRAL = 11 # Variable c_int
DCTT_DOWNLOAD = 2 # Variable c_long
CC_INTERIORS = 128 # Variable c_int
IMAGE_SIZEOF_FILE_HEADER = 20 # Variable c_int
AF_FIREFOX = 19 # Variable c_int
LVM_HITTEST = 4114 # Variable c_int
CONNECT_CURRENT_MEDIA = 512 # Variable c_int
CF_PRIVATELAST = 767 # Variable c_int
SETRGBSTRINGW = 'commdlg_SetRGBColor' # Variable POINTER(c_wchar)
ERROR_FILEMARK_DETECTED = 1101 # Variable c_long
SM_MENUDROPALIGNMENT = 40 # Variable c_int
LVM_GETCALLBACKMASK = 4106 # Variable c_int
MKF_HOTKEYSOUND = 16 # Variable c_int
CO_E_FAILEDTOGETTOKENINFO = -2147220989 # Variable c_long
CF_LIMITSIZE = 8192 # Variable c_long
QUERYDIBSUPPORT = 3073 # Variable c_int
IGP_UI = 16 # Variable c_int
DM_PROMPT = 4 # Variable c_int
TAPE_ABSOLUTE_POSITION = 0 # Variable c_long
MM_ANISOTROPIC = 8 # Variable c_int
MB_COMPOSITE = 2 # Variable c_int
PERF_SIZE_ZERO = 512 # Variable c_int
XTYP_EXECUTE = 16464 # Variable c_int
PD_NOSELECTION = 4 # Variable c_int
lst12 = 1131 # Variable c_int
MMSYSERR_BASE = 0 # Variable c_int
ERROR_SOME_NOT_MAPPED = 1301 # Variable c_long
GRAY_BRUSH = 2 # Variable c_int
WSAEPROCLIM = 10067 # Variable c_int
HSHELL_WINDOWCREATED = 1 # Variable c_int
EXIT_PROCESS_DEBUG_EVENT = 5 # Variable c_int
CBEIF_OVERLAY = 8 # Variable c_int
TCHT_ONITEMICON = 2 # Variable c_int
MCI_FREEZE = 2116 # Variable c_int
CTRY_ALBANIA = 355 # Variable c_int
REG_FULL_RESOURCE_DESCRIPTOR = 9 # Variable c_int
SPI_GETBORDER = 5 # Variable c_int
TB_SETSTYLE = 1080 # Variable c_int
WM_IME_CHAR = 646 # Variable c_int
ERROR_SEVERITY_ERROR = 3221225472 # Variable c_uint
SE_BACKUP_NAME = 'SeBackupPrivilege' # Variable POINTER(c_wchar)
SWP_SHOWWINDOW = 64 # Variable c_int
SMTO_ABORTIFHUNG = 2 # Variable c_int
SMTO_NOTIMEOUTIFNOTHUNG  = 0x0008
POLYGONALCAPS = 32 # Variable c_int
TCN_LAST = 4294966716 # Variable c_uint
MCI_SYSINFO = 2064 # Variable c_int
IDC_APPSTARTING = 206416 # Variable POINTER(c_wchar)
SEVERITY_ERROR = 1 # Variable c_int
MIXER_OBJECTF_WAVEOUT = 268435456 # Variable c_long
MCHT_CALENDAR = 131072 # Variable c_int
FKF_AVAILABLE = 2 # Variable c_int
TBS_HORZ = 0 # Variable c_int
ILD_BLEND50 = 4 # Variable c_int
PBM_SETSTEP = 1028 # Variable c_int
CBEM_GETIMAGELIST = 1027 # Variable c_int
WNNC_NET_LIFENET = 917504 # Variable c_int
HIST_BACK = 0 # Variable c_int
FILE_NOTIFY_CHANGE_FILE_NAME = 1 # Variable c_int
CBR_256000 = 256000 # Variable c_int
IPPORT_MTP = 57 # Variable c_int
REGDB_E_IIDNOTREG = -2147221163 # Variable c_long
CLIENTSITE_S_FIRST = 262544 # Variable c_long
SPAPI_E_INVALID_REFERENCE_STRING = -2146500065 # Variable c_long
XTYP_ADVSTOP = 32832 # Variable c_int
IMAGE_SCN_MEM_EXECUTE = 536870912 # Variable c_int
LVS_EX_UNDERLINECOLD = 4096 # Variable c_int
MDMVOL_LOW = 0 # Variable c_int
CDS_SET_PRIMARY = 16 # Variable c_int
LOCALE_SABBREVMONTHNAME2 = 69 # Variable c_int
MK_E_NOTBINDABLE = -2147221016 # Variable c_long
JOB_OBJECT_SECURITY_ONLY_TOKEN = 4 # Variable c_int
ERROR_GRACEFUL_DISCONNECT = 1226 # Variable c_long
STREAM_CONTAINS_SECURITY = 2 # Variable c_int
ERROR_SERVICE_DATABASE_LOCKED = 1055 # Variable c_long
STG_E_INVALIDPARAMETER = -2147286953 # Variable c_long
CBF_FAIL_ALLSVRXACTIONS = 258048 # Variable c_int
ERROR_META_EXPANSION_TOO_LONG = 208 # Variable c_long
CO_E_APPNOTFOUND = -2147221003 # Variable c_long
FILE_ALL_ACCESS = 2032639 # Variable c_long
WPF_SETMINPOSITION = 1 # Variable c_int
DMDITHER_ERRORDIFFUSION = 5 # Variable c_int
CF_DSPTEXT = 129 # Variable c_int
RPC_C_EP_MATCH_BY_BOTH = 3 # Variable c_int
LOCALE_SMONTHOUSANDSEP = 23 # Variable c_int
OPENCHANNEL = 4110 # Variable c_int
ERROR_INSTALL_SUSPEND = 1604 # Variable c_long
LOAD_WITH_ALTERED_SEARCH_PATH = 8 # Variable c_int
FACILITY_NT_BIT = 268435456 # Variable c_int
LF_FACESIZE = 32 # Variable c_int
ERROR_PRIVILEGE_NOT_HELD = 1314 # Variable c_long
LVM_GETSTRINGWIDTHA = 4113 # Variable c_int
ST_TERMINATED = 32 # Variable c_int
LB_FINDSTRINGEXACT = 418 # Variable c_int
SM_CXEDGE = 45 # Variable c_int
WSB_PROP_HBKGCOLOR = 128 # Variable c_long
ERROR_ACCOUNT_DISABLED = 1331 # Variable c_long
SUBLANG_ENGLISH_CARIBBEAN = 9 # Variable c_int
TAPE_DRIVE_FIXED_BLOCK = 1024 # Variable c_int
SPLDS_PRINTER_MODEL = 'printerModel' # Variable POINTER(c_wchar)
CONNECT_UPDATE_PROFILE = 1 # Variable c_int
FILE_ATTRIBUTE_SYSTEM = 4 # Variable c_int
PAN_CONTRAST_VERY_LOW = 3 # Variable c_int
SECURITY_PROXY_RID = 8 # Variable c_long
SERVICE_STOPPED = 1 # Variable c_int
IMAGE_ENHMETAFILE = 3 # Variable c_int
IN_CLASSA_MAX = 128 # Variable c_int
TVN_GETDISPINFOW = 4294966844 # Variable c_uint
DLL_THREAD_DETACH = 3 # Variable c_int
IS_TEXT_UNICODE_STATISTICS = 2 # Variable c_int
ID_PSRESTARTWINDOWS = 2 # Variable c_int
TB_ADDBUTTONSW = 1092 # Variable c_int
GCPCLASS_LOCALNUMBER = 4 # Variable c_int
SPAPI_E_GENERAL_SYNTAX = -2146500605 # Variable c_long
MB_SYSTEMMODAL = 4096 # Variable c_long
SERVER_ACCESS_ENUMERATE = 2 # Variable c_int
ACCESS_ALLOWED_OBJECT_ACE_TYPE = 5 # Variable c_int
CF_APPLY = 512 # Variable c_long
PAN_STROKE_RAPID_HORZ = 7 # Variable c_int
FIXED_PITCH = 1 # Variable c_int
CRYPT_E_NOT_CHAR_STRING = -2146885596 # Variable c_long
DMBIN_USER = 256 # Variable c_int
GCPCLASS_LATINNUMERICSEPARATOR = 7 # Variable c_int
IMAGE_SCN_MEM_PURGEABLE = 131072 # Variable c_int
MM_MIM_MOREDATA = 972 # Variable c_int
WM_HSCROLL = 276 # Variable c_int
PD_USEDEVMODECOPIESANDCOLLATE = 262144 # Variable c_int
PROCESS_VM_READ = 16 # Variable c_int
ERROR_INVALID_AT_INTERRUPT_TIME = 104 # Variable c_long
TCM_DESELECTALL = 4914 # Variable c_int
MCI_ANIM_WINDOW_ENABLE_STRETCH = 1048576 # Variable c_long
SPLDS_USER_KEY = 'DsUser' # Variable POINTER(c_wchar)
STGM_NOSCRATCH = 1048576 # Variable c_long
DISPID_EVALUATE = -5 # Variable c_int
LVM_INSERTITEMW = 4173 # Variable c_int
MCI_OVLY_OPEN_WS = 65536 # Variable c_long
SPLDS_DESCRIPTION = 'description' # Variable POINTER(c_wchar)
ERROR_SEM_NOT_FOUND = 187 # Variable c_long
SECURITY_STATIC_TRACKING = 0 # Variable c_int
CDDS_SUBITEM = 131072 # Variable c_int
ERROR_DOMAIN_LIMIT_EXCEEDED = 1357 # Variable c_long
TBM_GETTICPOS = 1039 # Variable c_int
RESOURCEDISPLAYTYPE_ROOT = 7 # Variable c_int
WSAENOTCONN = 10057 # Variable c_int
MCI_WAVE_OFFSET = 1152 # Variable c_int
CBEM_GETCOMBOCONTROL = 1030 # Variable c_int
MIXER_GETLINECONTROLSF_ALL = 0 # Variable c_long
MDMSPKRFLAG_CALLSETUP = 8 # Variable c_int
ODA_DRAWENTIRE = 1 # Variable c_int
WSB_PROP_CYVTHUMB = 32 # Variable c_long
RPC_E_SERVERCALL_REJECTED = -2147417845 # Variable c_long
MCIERR_SEQ_PORT_NONEXISTENT = 338 # Variable c_int
SC_GROUP_IDENTIFIERA = '+' # Variable c_char
NTE_BAD_VER = -2146893817 # Variable c_long
PAN_CONTRAST_HIGH = 8 # Variable c_int
WM_APP = 32768 # Variable c_int
DEVICEDATA = 19 # Variable c_int
ERROR_NETWORK_BUSY = 54 # Variable c_long
DTN_FORMATQUERYA = 4294966541 # Variable c_uint
MAXUINT_PTR = 4294967295 # Variable c_ulong
IPPORT_WHOIS = 43 # Variable c_int
IMAGE_REL_PPC_SECRELHI = 20 # Variable c_int
ERROR_INVALID_SEGDPL = 198 # Variable c_long
ERROR_FLOPPY_BAD_REGISTERS = 1125 # Variable c_long

_CM_SERVICE_NODE_TYPE = c_int # enum
DriverType = 1
CF_MAX = 17 # Variable c_int
TBN_FIRST = 4294966596 # Variable c_uint
MCI_OPEN_ELEMENT_ID = 2048 # Variable c_long
GDTR_MAX = 2 # Variable c_int
IME_CHOTKEY_IME_NONIME_TOGGLE = 16 # Variable c_int
SW_NORMAL = 1 # Variable c_int
HWND_BOTTOM = 1 # Variable POINTER(HWND__)
JOB_NOTIFY_FIELD_DOCUMENT = 13 # Variable c_int
TCM_ADJUSTRECT = 4904 # Variable c_int
STARTDOC = 10 # Variable c_int
RPC_E_RETRY = -2147417847 # Variable c_long
JOB_CONTROL_PAUSE = 1 # Variable c_int
LVS_NOLABELWRAP = 128 # Variable c_int
CDRF_NOTIFYITEMDRAW = 32 # Variable c_int
PRF_CHECKVISIBLE = 1 # Variable c_long
PRINTER_NOTIFY_OPTIONS_REFRESH = 1 # Variable c_int
RPC_C_AUTHN_NONE = 0 # Variable c_int
WS_CAPTION = 12582912 # Variable c_long
PAN_PROP_MONOSPACED = 9 # Variable c_int
LANG_URDU = 32 # Variable c_int
UDM_GETBASE = 1134 # Variable c_int

tagURLTEMPLATE = c_int # enum
URLTEMPLATE_CUSTOM = 0
LOCALE_SISO3166CTRYNAME = 90 # Variable c_int
IDB_STD_LARGE_COLOR = 1 # Variable c_int
MMIOERR_CANNOTSEEK = 263 # Variable c_int
RB_SETBKCOLOR = 1043 # Variable c_int
ERROR_PASSWORD_RESTRICTION = 1325 # Variable c_long
IPN_FIELDCHANGED = 4294966436 # Variable c_uint
META_STRETCHDIB = 3907 # Variable c_int
ERROR_HANDLE_EOF = 38 # Variable c_long
SET_SCREEN_ANGLE = 4105 # Variable c_int
NRC_ILLNN = 19 # Variable c_int
CE_RXOVER = 1 # Variable c_int
psh11 = 1034 # Variable c_int
TAPE_DRIVE_WRITE_SETMARKS = 2164260864 # Variable c_uint
GW_MAX = 5 # Variable c_int
WM_DRAWCLIPBOARD = 776 # Variable c_int
SETICMPROFILE_EMBEDED = 1 # Variable c_int
GCL_HICON = -14 # Variable c_int
CMB_MASKED = 2 # Variable c_int
ERROR_NOT_A_REPARSE_POINT = 4390 # Variable c_long
RBBIM_CHILDSIZE = 32 # Variable c_int
MEVT_VERSION = 132 # Variable c_ubyte
ERROR_NET_WRITE_FAULT = 88 # Variable c_long
OBJ_PEN = 1 # Variable c_int
IDB_HIST_LARGE_COLOR = 9 # Variable c_int
PS_ENDCAP_MASK = 3840 # Variable c_int
META_SAVEDC = 30 # Variable c_int
DD_DEFDRAGMINDIST = 2 # Variable c_int
PAN_WEIGHT_THIN = 4 # Variable c_int
SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT = 4 # Variable c_int
ERROR_CAN_NOT_DEL_LOCAL_WINS = 4001 # Variable c_long
SPLDS_PORT_NAME = 'portName' # Variable POINTER(c_wchar)
DATABITS_16 = 16 # Variable c_ushort
SPAPI_E_NO_DEVICE_SELECTED = -2146500079 # Variable c_long
ERROR_OUTOFMEMORY = 14 # Variable c_long
WSAENETUNREACH = 10051 # Variable c_int
MAX_COMPUTERNAME_LENGTH = 15 # Variable c_int
SRCINVERT = 6684742 # Variable c_ulong
FILE_TYPE_PIPE = 3 # Variable c_int
IMAGE_REL_MIPS_SECREL = 11 # Variable c_int
LOCALE_SABBREVDAYNAME6 = 54 # Variable c_int
MCI_ANIM_PLAY_REVERSE = 131072 # Variable c_long
PSBTN_NEXT = 1 # Variable c_int
SB_PAGELEFT = 2 # Variable c_int
IME_CAND_UNKNOWN = 0 # Variable c_int
PERF_COUNTER_LARGE_RAWCOUNT_HEX = 256 # Variable c_int
SORT_CHINESE_PRCP = 0 # Variable c_int
CBR_300 = 300 # Variable c_int
SYNCHRONIZE = 1048576 # Variable c_long
ERROR_EXCL_SEM_ALREADY_OWNED = 101 # Variable c_long
AF_VOICEVIEW = 18 # Variable c_int
PC_WINDPOLYGON = 4 # Variable c_int
MSGF_SCROLLBAR = 5 # Variable c_int
URLACTION_SHELL_INSTALL_DTITEMS = 6144 # Variable c_int
DM_BITSPERPEL = 262144 # Variable c_long
CAL_SABBREVDAYNAME5 = 18 # Variable c_int
PAN_MIDLINE_LOW_SERIFED = 13 # Variable c_int
WM_CLOSE = 16 # Variable c_int
CO_E_LAST = 2147746303 # Variable c_ulong
WM_RBUTTONDOWN = 516 # Variable c_int
NTE_BAD_LEN = -2146893820 # Variable c_long
IMM_ERROR_GENERAL = -2 # Variable c_int
ERROR_INVALID_WINDOW_STYLE = 2002 # Variable c_long
MMIOERR_ACCESSDENIED = 268 # Variable c_int
FORMAT_MESSAGE_IGNORE_INSERTS = 512 # Variable c_int
MAX_PERF_OBJECTS_IN_QUERY_FUNCTION = 8 # Variable c_long
REG_MULTI_SZ = 7 # Variable c_int
HDI_FORMAT = 4 # Variable c_int
STG_E_SHAREREQUIRED = -2147286778 # Variable c_long
MK_S_LAST = 262639 # Variable c_long
DISPID_UNKNOWN = -1 # Variable c_int
GETPHYSPAGESIZE = 12 # Variable c_int
TBM_SETTIC = 1028 # Variable c_int
SS_ETCHEDHORZ = 16 # Variable c_long
ERROR_STACK_OVERFLOW = 1001 # Variable c_long
JOY_CAL_READVONLY = 134217728 # Variable c_long
SC_MONITORPOWER = 61808 # Variable c_int
CO_E_SCM_RPC_FAILURE = -2146959357 # Variable c_long
TVGN_CARET = 9 # Variable c_int
WSAEDISCON = 10101 # Variable c_int
lst10 = 1129 # Variable c_int
ASPECTXY = 44 # Variable c_int
WM_PSD_MINMARGINRECT = 1026 # Variable c_int
PT_CLOSEFIGURE = 1 # Variable c_int
TVM_SETIMAGELIST = 4361 # Variable c_int
NFS_STATIC = 2 # Variable c_int
RIGHTMOST_BUTTON_PRESSED = 2 # Variable c_int
edt1 = 1152 # Variable c_int
UDM_SETRANGE = 1125 # Variable c_int
JOB_OBJECT_MSG_END_OF_PROCESS_TIME = 2 # Variable c_int
USER_MARSHAL_FC_WCHAR = 5 # Variable c_int
DMPAPER_LEGAL = 5 # Variable c_int
MCI_ANIM_STATUS_STRETCH = 16389 # Variable c_long
TCM_SETTOOLTIPS = 4910 # Variable c_int
lst5 = 1124 # Variable c_int
LANG_INDONESIAN = 33 # Variable c_int
MIXERCONTROL_CT_CLASS_LIST = 1879048192 # Variable c_long
IDANI_CLOSE = 2 # Variable c_int
ERROR_PRINT_CANCELLED = 63 # Variable c_long
MMIOM_SEEK = 2 # Variable c_int
IMAGE_REL_IA64_RESERVED_15 = 21 # Variable c_int
SORT_CHINESE_PRC = 2 # Variable c_int
APD_COPY_ALL_FILES = 4 # Variable c_int
ERROR_INVALID_LEVEL = 124 # Variable c_long
_MAX_EXT = 256 # Variable c_int
TBBF_LARGE = 1 # Variable c_int
LANG_BENGALI = 69 # Variable c_int
NCBHANGUP = 18 # Variable c_int
JOY_CAL_READUONLY = 67108864 # Variable c_long
ERROR_UNABLE_TO_LOCK_MEDIA = 1108 # Variable c_long
IDC_IBEAM = 206099 # Variable POINTER(c_wchar)
VK_MBUTTON = 4 # Variable c_int
SESSION_ESTABLISHED = 3 # Variable c_int
CFSTR_MIME_BMP = 'image/bmp' # Variable POINTER(c_wchar)
IMAGE_FILE_DLL = 8192 # Variable c_int
ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND = 5032 # Variable c_long
CBR_110 = 110 # Variable c_int
DDE_FDEFERUPD = 16384 # Variable c_int
CFS_DEFAULT = 0 # Variable c_int
FILE_ACTION_ADDED = 1 # Variable c_int
EM_SETWORDBREAKPROC = 208 # Variable c_int
CDERR_LOADSTRFAILURE = 5 # Variable c_int
WINSTA_WRITEATTRIBUTES = 16 # Variable c_long
grp2 = 1073 # Variable c_int
RPC_E_INVALID_PARAMETER = -2147418096 # Variable c_long
LVM_SETITEMTEXTW = 4212 # Variable c_int
ERROR_DISK_RESET_FAILED = 1128 # Variable c_long
DFCS_SCROLLRIGHT = 3 # Variable c_int
DMPAPER_11X17 = 17 # Variable c_int
CUDR_NOSNAPTOGRID = 1 # Variable c_int
MIXERCONTROL_CT_CLASS_TIME = 1610612736 # Variable c_long
MCI_GETDEVCAPS_ITEM = 256 # Variable c_long
SPI_GETSCREENREADER = 70 # Variable c_int
TVGN_PARENT = 3 # Variable c_int
IMAGE_DIRECTORY_ENTRY_BASERELOC = 5 # Variable c_int
SHIFTJIS_CHARSET = 128 # Variable c_int
MIXERCONTROL_CONTROLTYPE_LOUDNESS = 536936452 # Variable c_long
FILE_LIST_DIRECTORY = 1 # Variable c_int
URLACTION_DOWNLOAD_MIN = 4096 # Variable c_int
PAN_XHEIGHT_DUCKING_STD = 6 # Variable c_int
SUBLANG_ENGLISH_JAMAICA = 8 # Variable c_int
ERROR_BOOT_ALREADY_ACCEPTED = 1076 # Variable c_long
ILLUMINANT_C = 3 # Variable c_int
DMPAPER_ENV_14 = 23 # Variable c_int
DRIVERVERSION = 0 # Variable c_int
SE_CREATE_TOKEN_NAME = 'SeCreateTokenPrivilege' # Variable POINTER(c_wchar)
MF_SENDMSGS = 33554432 # Variable c_int
CLASS_E_NOAGGREGATION = -2147221232 # Variable c_long
IMAGE_REL_PPC_ADDR14 = 5 # Variable c_int
WM_DEVMODECHANGE = 27 # Variable c_int
MCIERR_NULL_PARAMETER_BLOCK = 297 # Variable c_int
RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY = 16 # Variable c_int
NOPARITY = 0 # Variable c_int
CO_E_ACCESSCHECKFAILED = -2147220985 # Variable c_long
TB_GETSTATE = 1042 # Variable c_int
BM_GETIMAGE = 246 # Variable c_int
SE_INC_BASE_PRIORITY_NAME = 'SeIncreaseBasePriorityPrivilege' # Variable POINTER(c_wchar)
XST_CONNECTED = 2 # Variable c_int
TTF_DI_SETITEM = 32768 # Variable c_int
TBS_ENABLESELRANGE = 32 # Variable c_int
PAN_WEIGHT_BOLD = 8 # Variable c_int
STATUS_FLOAT_INEXACT_RESULT = 3221225615 # Variable c_ulong
DMDITHER_RESERVED6 = 6 # Variable c_int
MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER = 4103 # Variable c_long
SC_MAXIMIZE = 61488 # Variable c_int
TB_GETBUTTON = 1047 # Variable c_int
PST_SCANNER = 34 # Variable c_ulong
MAXIMUM_PROCESSORS = 32 # Variable c_int
RPC_S_SEC_PKG_ERROR = 1825 # Variable c_long
MK_E_NOPREFIX = -2147221010 # Variable c_long
DEBUG_ONLY_THIS_PROCESS = 2 # Variable c_int
ATF_TIMEOUTON = 1 # Variable c_int
WH_MSGFILTER = -1 # Variable c_int
IME_THOTKEY_SYMBOL_TOGGLE = 114 # Variable c_int
DOMAIN_GROUP_RID_SCHEMA_ADMINS = 518 # Variable c_long
DI_COMPAT = 4 # Variable c_int
WT_EXECUTEDEFAULT = 0 # Variable c_int
IME_ESC_PRIVATE_HOTKEY = 4106 # Variable c_int
SPLDS_PRINT_SPOOLING = 'printSpooling' # Variable POINTER(c_wchar)
IMAGE_DEBUG_TYPE_COFF = 1 # Variable c_int
LOCALE_SABBREVCTRYNAME = 7 # Variable c_int
IOC_OUT = 1073741824 # Variable c_int
SIMPLEREGION = 2 # Variable c_int
PURGE_RXCLEAR = 8 # Variable c_int
SORT_HUNGARIAN_TECHNICAL = 1 # Variable c_int
OBJ_DC = 3 # Variable c_int
PSH_USECALLBACK = 256 # Variable c_int
WVR_ALIGNRIGHT = 128 # Variable c_int
MMSYSERR_BADERRNUM = 9 # Variable c_int
HTGROWBOX = 4 # Variable c_int
DC_PAPERS = 2 # Variable c_int
MIXER_GETLINEINFOF_TARGETTYPE = 4 # Variable c_long
lst13 = 1132 # Variable c_int
PS_ALTERNATE = 8 # Variable c_int
CTRY_TAIWAN = 886 # Variable c_int
DEFAULT_QUALITY = 0 # Variable c_int
RT_BITMAP = 2 # Variable POINTER(c_wchar)
EMR_FRAMERGN = 72 # Variable c_int
SO_ACCEPTCONN = 2 # Variable c_int
IDI_WINLOGO = 206103 # Variable POINTER(c_wchar)
DMBIN_FORMSOURCE = 15 # Variable c_int
MCI_PAUSE = 2057 # Variable c_int
IMAGE_FILE_MACHINE_MIPS16 = 614 # Variable c_int
PC_TRAPEZOID = 4 # Variable c_int
LANG_AFRIKAANS = 54 # Variable c_int
IME_CMODE_FULLSHAPE = 8 # Variable c_int
REBARBANDINFOA_V3_SIZE = 56 # Variable c_uint
CTRY_MONACO = 33 # Variable c_int
LEFT_ALT_PRESSED = 2 # Variable c_int
DDD_NO_BROADCAST_SYSTEM = 8 # Variable c_int
SZDDESYS_TOPIC = 'System' # Variable POINTER(c_wchar)
STG_E_INCOMPLETE = -2147286527 # Variable c_long
FILE_FLAG_OPEN_NO_RECALL = 1048576 # Variable c_int
POSTSCRIPT_PASSTHROUGH = 4115 # Variable c_int
FOCUS_EVENT = 16 # Variable c_int
TARGET_IS_NT40_OR_LATER = 0 # Variable c_int
BATTERY_FLAG_NO_BATTERY = 128 # Variable c_int
SO_DONTROUTE = 16 # Variable c_int
TCS_OWNERDRAWFIXED = 8192 # Variable c_int
RPC_S_INVALID_AUTH_IDENTITY = 1749 # Variable c_long
SBM_SETPOS = 224 # Variable c_int
MCI_ANIM_PLAY_SCAN = 1048576 # Variable c_long
MF_ENABLED = 0 # Variable c_long
WAVE_FORMAT_2S16 = 128 # Variable c_int
frm2 = 1077 # Variable c_int
IDH_NO_HELP = 28440 # Variable c_int
IMAGE_SYM_DTYPE_POINTER = 1 # Variable c_int
WM_NCMBUTTONDOWN = 167 # Variable c_int
WM_NCACTIVATE = 134 # Variable c_int
ALTERNATE = 1 # Variable c_int
CTRY_IRAQ = 964 # Variable c_int
TC_UA_ABLE = 2048 # Variable c_int
LOCALE_SABBREVMONTHNAME3 = 70 # Variable c_int
NOTSRCCOPY = 3342344 # Variable c_ulong
IME_CAND_READ = 1 # Variable c_int
TBSTATE_ENABLED = 4 # Variable c_int
C2_EUROPENUMBER = 3 # Variable c_int
JOY_BUTTON15 = 16384 # Variable c_long
WAVECAPS_SAMPLEACCURATE = 32 # Variable c_int
GL_LEVEL_INFORMATION = 4 # Variable c_int
MA_ACTIVATE = 1 # Variable c_int
META_PAINTREGION = 299 # Variable c_int
BACKUP_REPARSE_DATA = 8 # Variable c_int
LC_WIDE = 16 # Variable c_int
ERROR_NOT_QUORUM_CLASS = 5025 # Variable c_long
PS_INSIDEFRAME = 6 # Variable c_int
META_REALIZEPALETTE = 53 # Variable c_int
HSHELL_TASKMAN = 7 # Variable c_int
SPAPI_E_NO_CLASSINSTALL_PARAMS = -2146500075 # Variable c_long
MCI_WAVE_OPEN_BUFFER = 65536 # Variable c_long
IMAGE_DEBUG_TYPE_MISC = 4 # Variable c_int
MCIERR_CREATEWINDOW = 347 # Variable c_int
rad1 = 1056 # Variable c_int
SP_USERABORT = -3 # Variable c_int
DEFAULT_CHARSET = 1 # Variable c_int
MCI_WAVE_STATUS_BLOCKALIGN = 16389 # Variable c_long
LVM_GETSUBITEMRECT = 4152 # Variable c_int
RPC_C_PROTECT_LEVEL_NONE = 1 # Variable c_int
MCSC_BACKGROUND = 0 # Variable c_int
PROCESSOR_MIPS_R4000 = 4000 # Variable c_int
BS_AUTORADIOBUTTON = 9 # Variable c_long
CRYPT_E_INVALID_INDEX = -2146889720 # Variable c_long
TVSIL_STATE = 2 # Variable c_int
RPC_C_OPT_MQ_PRIORITY = 2 # Variable c_int
LVHT_ONITEMLABEL = 4 # Variable c_int
VIF_DIFFTYPE = 32 # Variable c_long
ERROR_DUP_DOMAINNAME = 1221 # Variable c_long
TB_SETPADDING = 1111 # Variable c_int
CF_NOSIMULATIONS = 4096 # Variable c_long
CLIENTSITE_E_LAST = 2147746207 # Variable c_ulong
SE_ERR_DDEFAIL = 29 # Variable c_int
MCI_ANIM_STEP_FRAMES = 131072 # Variable c_long
DM_SPECVERSION = 1024 # Variable c_int
CERT_E_CHAINING = -2146762486 # Variable c_long
SO_USELOOPBACK = 64 # Variable c_int
LVIS_DROPHILITED = 8 # Variable c_int
ERROR_PROFILE_NOT_FOUND = 2306 # Variable c_long
GMEM_NOTIFY = 16384 # Variable c_int
VIEW_NETCONNECT = 9 # Variable c_int
IO_REPARSE_TAG_NSS = 2147483653 # Variable c_uint
CRYPT_E_DELETED_PREV = -2146885624 # Variable c_long
RPC_C_AUTHN_LEVEL_PKT_PRIVACY = 6 # Variable c_int
DTR_CONTROL_DISABLE = 0 # Variable c_int
SPI_GETMINIMIZEDMETRICS = 43 # Variable c_int
SOL_SOCKET = 65535 # Variable c_int
NCBRECV = 21 # Variable c_int
MCI_VD_STATUS_SIDE = 16389 # Variable c_long
SPAPI_E_DI_DO_DEFAULT = -2146500082 # Variable c_long
ES_DISPLAY_REQUIRED = 2 # Variable c_ulong
EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X = 14 # Variable c_int
MM_ISOTROPIC = 7 # Variable c_int
MCI_ANIM_WHERE_SOURCE = 131072 # Variable c_long
C2_BLOCKSEPARATOR = 8 # Variable c_int
CRYPT_E_NO_DECRYPT_CERT = -2146885620 # Variable c_long
CFSTR_MIME_MPEG = 'video/mpeg' # Variable POINTER(c_wchar)
SSTF_DISPLAY = 3 # Variable c_int
MMIOERR_FILENOTFOUND = 257 # Variable c_int
ERROR_RING2_STACK_IN_USE = 207 # Variable c_long
TRACKBAR_CLASSW = 'msctls_trackbar32' # Variable POINTER(c_wchar)
OLE_E_OLEVERB = -2147221504 # Variable c_long
ERROR_EXCEPTION_IN_SERVICE = 1064 # Variable c_long
ERROR_UNABLE_TO_UNLOAD_MEDIA = 1109 # Variable c_long
PERF_COUNTER_NODATA = 1073742336 # Variable c_int
RESOURCEUSAGE_NOLOCALDEVICE = 4 # Variable c_int
TB_GETMAXSIZE = 1107 # Variable c_int
LVM_EDITLABELW = 4214 # Variable c_int
GCP_JUSTIFYIN = 2097152 # Variable c_long
PROCESS_SET_SESSIONID = 4 # Variable c_int
DATA_E_LAST = 2147746111 # Variable c_ulong
BS_SOLID = 0 # Variable c_int
RPC_E_INVALID_IPID = -2147417837 # Variable c_long
NONZEROLPTR = 0 # Variable c_int
C3_KATAKANA = 16 # Variable c_int
MCI_OVLY_STATUS_HWND = 16385 # Variable c_long
ERROR_NOT_CHILD_WINDOW = 1442 # Variable c_long
PAN_PROP_VERY_EXPANDED = 7 # Variable c_int
MCI_WAVE_GETDEVCAPS_OUTPUTS = 16386 # Variable c_long
CP_MACCP = 2 # Variable c_int
MDM_ERROR_CONTROL = 2 # Variable c_int
MM_LOMETRIC = 2 # Variable c_int
RBBIM_STYLE = 1 # Variable c_int
VK_BACK = 8 # Variable c_int
PS_JOIN_MASK = 61440 # Variable c_int
BAUD_9600 = 2048 # Variable c_ulong
IDYES = 6 # Variable c_int
TVN_LAST = 4294966797 # Variable c_uint
IME_ESC_MAX_KEY = 4101 # Variable c_int
EMR_RESTOREDC = 34 # Variable c_int
ERROR_INDEX_ABSENT = 1611 # Variable c_long
TVS_FULLROWSELECT = 4096 # Variable c_int
TRANSPORT_TYPE_LPC = 4 # Variable c_int
CLIENTSITE_S_LAST = 262559 # Variable c_long
PFD_DOUBLEBUFFER = 1 # Variable c_int
NTE_FAIL = -2146893792 # Variable c_long
PIPE_TYPE_BYTE = 0 # Variable c_int
DOMAIN_ALIAS_RID_BACKUP_OPS = 551 # Variable c_long
CERT_E_WRONG_USAGE = -2146762480 # Variable c_long
SM_NETWORK = 63 # Variable c_int
SB_GETTEXTA = 1026 # Variable c_int
TVN_GETINFOTIPA = 4294966883 # Variable c_uint
JOY_BUTTON30 = 536870912 # Variable c_long
DMBIN_ENVMANUAL = 6 # Variable c_int
PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR = 12 # Variable c_int
DT_RASPRINTER = 2 # Variable c_int
RPC_C_BINDING_MIN_TIMEOUT = 0 # Variable c_int
SETRTS = 3 # Variable c_int
SET_BACKGROUND_COLOR = 4103 # Variable c_int
ARW_BOTTOMLEFT = 0 # Variable c_long
FF_ROMAN = 16 # Variable c_int
STATUS_STACK_OVERFLOW = 3221225725 # Variable c_ulong
URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS = 7427 # Variable c_int
CS_PARENTDC = 128 # Variable c_int
NRC_ILLCMD = 3 # Variable c_int
LBS_WANTKEYBOARDINPUT = 1024 # Variable c_long
MCI_SEEK_TO_END = 512 # Variable c_long
stc31 = 1118 # Variable c_int
SYSTEM_FONT = 13 # Variable c_int
LVS_EX_MULTIWORKAREAS = 8192 # Variable c_int
JOB_OBJECT_UILIMIT_NONE = 0 # Variable c_int
FILE_NOTIFY_CHANGE_LAST_WRITE = 16 # Variable c_int
HELP_WM_HELP = 12 # Variable c_int
TA_UPDATECP = 1 # Variable c_int
DOMAIN_ALIAS_RID_USERS = 545 # Variable c_long
PERF_DISPLAY_PER_SEC = 268435456 # Variable c_int
LOCALE_SABBREVDAYNAME2 = 50 # Variable c_int
IMAGE_DEBUG_TYPE_FPO = 3 # Variable c_int
IMM_ERROR_NODATA = -1 # Variable c_int
LHND = 66 # Variable c_int
PERF_COUNTER_MULTI_BASE = 1107494144 # Variable c_int
TAPE_DRIVE_CLEAN_REQUESTS = 33554432 # Variable c_int
CC_RGBINIT = 1 # Variable c_int
DATETIMEPICK_CLASSW = 'SysDateTimePick32' # Variable POINTER(c_wchar)
ILD_BLEND25 = 2 # Variable c_int
REG_NONE = 0 # Variable c_int
DRVCNF_RESTART = 2 # Variable c_int
MWT_LEFTMULTIPLY = 2 # Variable c_int
ERROR_CONNECTION_REFUSED = 1225 # Variable c_long
PDERR_NODEFAULTPRN = 4104 # Variable c_int
RESOURCEDISPLAYTYPE_FILE = 4 # Variable c_int
TCM_GETROWCOUNT = 4908 # Variable c_int
ERROR_NO_SECURITY_ON_OBJECT = 1350 # Variable c_long
ERROR_INVALID_SEPARATOR_FILE = 1799 # Variable c_long
EMR_EXCLUDECLIPRECT = 29 # Variable c_int
CLIENTSITE_E_FIRST = 2147746192 # Variable c_ulong
MB_TASKMODAL = 8192 # Variable c_long
RPC_C_QOS_IDENTITY_STATIC = 0 # Variable c_int
UPDFCACHE_ALL = 2147483647 # Variable c_ulong
JOB_STATUS_RESTART = 2048 # Variable c_int
CS_E_CLASS_NOTFOUND = -2147221146 # Variable c_long
CRYPT_E_ALREADY_DECRYPTED = -2146889719 # Variable c_long
DRAGDROP_S_FIRST = 262400 # Variable c_long
ERROR_RXACT_COMMIT_FAILURE = 1370 # Variable c_long
WNNC_NET_BMC = 1572864 # Variable c_int
CDM_GETFILEPATH = 1125 # Variable c_int
PRF_CLIENT = 4 # Variable c_long
C2_WHITESPACE = 10 # Variable c_int
S_SERQFUL = -4 # Variable c_int
CAL_SABBREVDAYNAME4 = 17 # Variable c_int
PROFILE_SERVER = 1073741824 # Variable c_int
FALT = 16 # Variable c_int
MSGF_DIALOGBOX = 0 # Variable c_int
IMC_OPENSTATUSWINDOW = 34 # Variable c_int
SECURITY_LOCAL_RID = 0 # Variable c_long
ERROR_NOT_SAME_DEVICE = 17 # Variable c_long
WM_SYSCHAR = 262 # Variable c_int
RB_SETPALETTE = 1061 # Variable c_int
TCM_SETCURSEL = 4876 # Variable c_int
STG_S_MULTIPLEOPENS = 197124 # Variable c_long
PID_SECURITY = 2147483650 # Variable c_uint
HELP_SETPOPUP_POS = 13 # Variable c_int
RT_STRING = 6 # Variable POINTER(c_wchar)
TBIF_TEXT = 2 # Variable c_int
TTF_TRACK = 32 # Variable c_int
ERROR_DEPENDENT_RESOURCE_EXISTS = 5001 # Variable c_long
RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED = 8 # Variable c_int
CDRF_DODEFAULT = 0 # Variable c_int
JOYCAPS_HASZ = 1 # Variable c_int
CB_INITSTORAGE = 353 # Variable c_int
TVGN_ROOT = 0 # Variable c_int
WH_SHELL = 10 # Variable c_int
PRINTER_STATUS_TONER_LOW = 131072 # Variable c_int
SORT_JAPANESE_XJIS = 0 # Variable c_int
IMC_CLOSESTATUSWINDOW = 33 # Variable c_int
CBR_4800 = 4800 # Variable c_int
HWND_NOTOPMOST = 4294967294 # Variable POINTER(HWND__)
REG_NO_LAZY_FLUSH = 4 # Variable c_long
PFD_MAIN_PLANE = 0 # Variable c_int
ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE = 5031 # Variable c_long
LB_SETCARETINDEX = 414 # Variable c_int
RPC_X_NULL_REF_POINTER = 1780 # Variable c_long
edt2 = 1153 # Variable c_int
ES_LOWERCASE = 16 # Variable c_long
PHYSICALHEIGHT = 111 # Variable c_int
MCI_ANIM_PLAY_SLOW = 524288 # Variable c_long
PSM_ISDIALOGMESSAGE = 1141 # Variable c_int
FF_DECORATIVE = 80 # Variable c_int
CFSTR_MIME_PJPEG = 'image/pjpeg' # Variable POINTER(c_wchar)
lst6 = 1125 # Variable c_int
ROTFLAGS_ALLOWANYCLIENT = 2 # Variable c_int
LVM_GETITEMA = 4101 # Variable c_int
PERF_NUMBER_DECIMAL = 65536 # Variable c_int
VAR_FORMAT_NOSUBSTITUTE = 32 # Variable c_ulong
PERF_NUMBER_DEC_1000 = 131072 # Variable c_int
DRV_RESERVED = 2048 # Variable c_int
DMPAPER_ENV_B6 = 35 # Variable c_int
CO_E_WRONGOSFORAPP = -2147220998 # Variable c_long
SPI_SETSCREENSAVEACTIVE = 17 # Variable c_int
WGL_SWAP_UNDERLAY4 = 524288 # Variable c_int
DT_EXTERNALLEADING = 512 # Variable c_int
RPC_X_SS_CANNOT_GET_CALL_HANDLE = 1779 # Variable c_long
TAPE_DRIVE_REWIND_IMMEDIATE = 2147483656 # Variable c_uint
IMN_GUIDELINE = 13 # Variable c_int
URLACTION_DOWNLOAD_MAX = 4607 # Variable c_int
DSS_MONO = 128 # Variable c_int
RPC_S_NOT_LISTENING = 1715 # Variable c_long
NDR_ASCII_CHAR = 0 # Variable c_ulong
BS_PATTERN8X8 = 7 # Variable c_int
ERROR_PRINT_MONITOR_ALREADY_INSTALLED = 3006 # Variable c_long
PSINJECT_ENDPAGESETUP = 11 # Variable c_int
WGL_SWAP_OVERLAY4 = 16 # Variable c_int
TVS_RTLREADING = 64 # Variable c_int
LB_ADDSTRING = 384 # Variable c_int
IMC_SETSTATUSWINDOWPOS = 16 # Variable c_int
BI_RLE4 = 2 # Variable c_long
ICC_PAGESCROLLER_CLASS = 4096 # Variable c_int
PERF_DELTA_COUNTER = 4194304 # Variable c_int
DV_E_FORMATETC = -2147221404 # Variable c_long
TCM_DELETEALLITEMS = 4873 # Variable c_int
IMAGE_REL_PPC_SECREL16 = 15 # Variable c_int
SHGNLI_PREFIXNAME = 2 # Variable c_int
PDERR_DNDMMISMATCH = 4105 # Variable c_int
SE_SACL_PROTECTED = 8192 # Variable c_int
RPC_FLAGS_VALID_BIT = 32768 # Variable c_int
ENABLERELATIVEWIDTHS = 768 # Variable c_int
HEAP_PSEUDO_TAG_FLAG = 32768 # Variable c_int
PC_EXPLICIT = 2 # Variable c_int
PAN_MIDLINE_LOW_POINTED = 12 # Variable c_int
IMAGE_WEAK_EXTERN_SEARCH_ALIAS = 3 # Variable c_int
LOCALE_ICENTURY = 36 # Variable c_int
TBM_SETRANGE = 1030 # Variable c_int
PHYSICALOFFSETY = 113 # Variable c_int
VFFF_ISSHAREDFILE = 1 # Variable c_int
ENCAPSULATED_POSTSCRIPT = 4116 # Variable c_int
CS_IME = 65536 # Variable c_int
DMPAPER_A_PLUS = 57 # Variable c_int
DC_BINS = 6 # Variable c_int
RPC_S_UNKNOWN_AUTHZ_SERVICE = 1750 # Variable c_long
ILLUMINANT_B = 2 # Variable c_int
CTRY_LIBYA = 218 # Variable c_int
EM_GETTHUMB = 190 # Variable c_int
CO_E_CLSREG_INCONSISTENT = -2147467233 # Variable c_long
WAVE_FORMAT_2M16 = 64 # Variable c_int
CTRY_BULGARIA = 359 # Variable c_int
MARSHAL_S_FIRST = 262432 # Variable c_long
PROCESSOR_INTEL_486 = 486 # Variable c_int
ERROR_INVALID_LOGON_TYPE = 1367 # Variable c_long
TAPE_DRIVE_LOAD_UNLD_IMMED = 2147483680 # Variable c_uint
SND_ALIAS_SYSTEMEXIT = 17747 # Variable c_ulong
META_ELLIPSE = 1048 # Variable c_int
C3_ALPHA = 32768 # Variable c_int
KEYEVENTF_EXTENDEDKEY = 1 # Variable c_int
ERROR_PRINTER_DELETED = 1905 # Variable c_long
NRC_GOODRET = 0 # Variable c_int
TB_SETHOTITEM = 1096 # Variable c_int
ERROR_CANT_DISABLE_MANDATORY = 1310 # Variable c_long
MCI_VD_MODE_PARK = 1025 # Variable c_int
IMAGE_DIRECTORY_ENTRY_RESOURCE = 2 # Variable c_int
DDL_HIDDEN = 2 # Variable c_int
ERROR_INC_BACKUP = 4003 # Variable c_long
TVE_EXPAND = 2 # Variable c_int
DCB_RESET = 1 # Variable c_int
ERROR_REM_NOT_LIST = 51 # Variable c_long
PIDSI_PAGECOUNT = 14 # Variable c_long
LVM_SETCOLUMNWIDTH = 4126 # Variable c_int
SUBLANG_ARABIC_LEBANON = 12 # Variable c_int
PAGE_EXECUTE_READ = 32 # Variable c_int
RPC_C_USE_INTRANET_PORT = 2 # Variable c_int
MCI_CUT = 2129 # Variable c_int
WGL_SWAP_UNDERLAY14 = 536870912 # Variable c_int
ERROR_POINT_NOT_FOUND = 1171 # Variable c_long
ERROR_COUNTER_TIMEOUT = 1121 # Variable c_long
TTM_POP = 1052 # Variable c_int
PF_MMX_INSTRUCTIONS_AVAILABLE = 3 # Variable c_int
THREAD_PRIORITY_BELOW_NORMAL = -1 # Variable c_int
GETPRINTINGOFFSET = 13 # Variable c_int
META_SETTEXTCHAREXTRA = 264 # Variable c_int
PAN_LETT_OBLIQUE_SQUARE = 15 # Variable c_int
SS_WORDELLIPSIS = 49152 # Variable c_long
IMAGE_SYM_TYPE_UINT = 14 # Variable c_int
SEEK_CUR = 1 # Variable c_int
HTTOP = 12 # Variable c_int
ICM_ON = 2 # Variable c_int
WAVECAPS_PITCH = 1 # Variable c_int
PRINTER_CHANGE_ADD_PORT = 1048576 # Variable c_int
TB_SETPARENT = 1061 # Variable c_int
PERF_TYPE_ZERO = 3072 # Variable c_int
MIXERR_BASE = 1024 # Variable c_int
ERROR_SYSTEM_TRACE = 150 # Variable c_long
PRINTER_CHANGE_FAILED_CONNECTION_PRINTER = 8 # Variable c_int
IS_TEXT_UNICODE_REVERSE_STATISTICS = 32 # Variable c_int
DCX_CLIPCHILDREN = 8 # Variable c_long
SPI_SETDRAGHEIGHT = 77 # Variable c_int
MCI_ANIM_STATUS_FORWARD = 16386 # Variable c_long
PRINTER_NOTIFY_FIELD_UNTIL_TIME = 17 # Variable c_int
CO_E_SERVER_START_TIMEOUT = -2147467234 # Variable c_long
SPLDS_PRINT_NETWORK_ADDRESS = 'printNetworkAddress' # Variable POINTER(c_wchar)
WSAESHUTDOWN = 10058 # Variable c_int
IMAGE_SYM_CLASS_MEMBER_OF_UNION = 11 # Variable c_int
ERROR_EAS_NOT_SUPPORTED = 282 # Variable c_long
SETXON = 2 # Variable c_int
CRYPT_E_NOT_IN_REVOCATION_DATABASE = -2146885612 # Variable c_long
RPC_X_WRONG_ES_VERSION = 1828 # Variable c_long
SYSTEM_AUDIT_ACE_TYPE = 2 # Variable c_int
RPC_ASYNC_VERSION_1_0 = 68 # Variable c_uint
DT_RTLREADING = 131072 # Variable c_int
WM_VKEYTOITEM = 46 # Variable c_int
TVN_SINGLEEXPAND = 4294966881 # Variable c_uint
ERROR_TOO_MANY_SEMAPHORES = 100 # Variable c_long
META_SETMAPPERFLAGS = 561 # Variable c_int
RC_SAVEBITMAP = 64 # Variable c_int
TYPE_E_FIELDNOTFOUND = -2147319785 # Variable c_long
ERROR_ADAP_HDW_ERR = 57 # Variable c_long
ERROR_BAD_NET_RESP = 58 # Variable c_long
SC_MANAGER_QUERY_LOCK_STATUS = 16 # Variable c_int
MCI_STATUS_NUMBER_OF_TRACKS = 3 # Variable c_long
IMAGE_SCN_MEM_LOCKED = 262144 # Variable c_int
MIXERCONTROL_CONTROLTYPE_MIXER = 1895890945 # Variable c_long
ENUM_E_FIRST = 2147746224 # Variable c_ulong
PDERR_GETDEVMODEFAIL = 4101 # Variable c_int
SO_RCVTIMEO = 4102 # Variable c_int
SERVICE_BOOT_START = 0 # Variable c_int
COLOROKSTRINGW = 'commdlg_ColorOK' # Variable POINTER(c_wchar)
WRITE_DAC = 262144 # Variable c_long
MKF_AVAILABLE = 2 # Variable c_int
LOCALE_SABBREVMONTHNAME1 = 68 # Variable c_int
ERROR_HOOK_TYPE_NOT_ALLOWED = 1458 # Variable c_long
ERROR_SETCOUNT_ON_BAD_LB = 1433 # Variable c_long
WS_EX_OVERLAPPEDWINDOW = 768 # Variable c_long
BDR_RAISEDOUTER = 1 # Variable c_int
VK_F20 = 131 # Variable c_int
PAN_FAMILYTYPE_INDEX = 0 # Variable c_int
ETO_CLIPPED = 4 # Variable c_int
PERF_TIMER_TICK = 0 # Variable c_int
DFCS_PUSHED = 512 # Variable c_int
CO_E_PATHTOOLONG = -2147220974 # Variable c_long
RPC_S_UNSUPPORTED_NAME_SYNTAX = 1737 # Variable c_long
SERVICE_ADAPTER = 4 # Variable c_int
ERROR_WMI_UNRESOLVED_INSTANCE_REF = 4205 # Variable c_long
PROCESSOR_ARCHITECTURE_INTEL = 0 # Variable c_int
CREATE_THREAD_DEBUG_EVENT = 2 # Variable c_int
ERROR_DIR_NOT_ROOT = 144 # Variable c_long
CCM_SETUNICODEFORMAT = 8197 # Variable c_int
STD_UNDO = 3 # Variable c_int

STUB_PHASE = c_int # enum
ERROR_PIPE_CONNECTED = 535 # Variable c_long
LANG_FRENCH = 12 # Variable c_int
DDE_FAPPSTATUS = 255 # Variable c_int
UDM_GETRANGE = 1126 # Variable c_int
TCM_SETITEMSIZE = 4905 # Variable c_int
__RPCNDR_H_VERSION__ = 450 # Variable c_int
PGF_SCROLLRIGHT = 8 # Variable c_int
CCS_LEFT = 129 # Variable c_long
MIXERLINE_TARGETTYPE_MIDIOUT = 3 # Variable c_int
RB_GETBKCOLOR = 1044 # Variable c_int
CTRY_THAILAND = 66 # Variable c_int
LCMAP_TRADITIONAL_CHINESE = 67108864 # Variable c_int
PRINTER_STATUS_USER_INTERVENTION = 1048576 # Variable c_int
CONNDLG_PERSIST = 16 # Variable c_int
ERROR_INVALID_ACCOUNT_NAME = 1315 # Variable c_long
ERROR_CANNOT_IMPERSONATE = 1368 # Variable c_long
BDR_SUNKENOUTER = 2 # Variable c_int
ERROR_DS_BUSY = 1927 # Variable c_long
INET_E_NO_SESSION = -2146697213 # Variable c_long
SUBLANG_ENGLISH_CAN = 4 # Variable c_int
IME_PROP_COMPLETE_ON_UNSELECT = 1048576 # Variable c_int
TVIF_DI_SETITEM = 4096 # Variable c_int
TCS_SCROLLOPPOSITE = 1 # Variable c_int
DMDITHER_GRAYSCALE = 10 # Variable c_int
IMAGE_SYM_CLASS_END_OF_STRUCT = 102 # Variable c_int
DDE_FRELEASE = 8192 # Variable c_int
DMICM_COLORIMETRIC = 3 # Variable c_int
BSF_FORCEIFHUNG = 32 # Variable c_int
PSN_LAST = 4294966997 # Variable c_uint
LOCALE_SCURRENCY = 20 # Variable c_int
MCI_SEQ_MIDI = 16387 # Variable c_int
WS_POPUP = 2147483648 # Variable c_ulong
META_SETPALENTRIES = 55 # Variable c_int
WAVE_MAPPER = 4294967295 # Variable c_uint
PRINTER_ENUM_EXPAND = 16384 # Variable c_int
MCI_WAVE_SET_CHANNELS = 131072 # Variable c_long
VIEW_DETAILS = 3 # Variable c_int
SESSION_ABORTED = 6 # Variable c_int
WC_PAGESCROLLERA = 'SysPager' # Variable POINTER(c_char)
DRAWPATTERNRECT = 25 # Variable c_int
DKGRAY_BRUSH = 3 # Variable c_int
PERF_SIZE_LARGE = 256 # Variable c_int
IMAGE_REL_PPC_ABSOLUTE = 0 # Variable c_int
RBIM_IMAGELIST = 1 # Variable c_int
IMAGE_REL_ALPHA_LITERAL = 4 # Variable c_int
META_SETWINDOWEXT = 524 # Variable c_int
DMLERR_LAST = 16401 # Variable c_int
GETFACENAME = 513 # Variable c_int
ACS_AUTOPLAY = 4 # Variable c_int
CTRY_CANADA = 2 # Variable c_int
PRINTER_STATUS_OFFLINE = 128 # Variable c_int
USER_MARSHAL_FC_HYPER = 11 # Variable c_int
WMSZ_BOTTOM = 6 # Variable c_int
VARIANT_TRUE = -1 # Variable c_short
DMCOLOR_COLOR = 2 # Variable c_int
CALLBACK_TYPEMASK = 458752 # Variable c_long
DM_PANNINGHEIGHT = 268435456 # Variable c_long
SE_DACL_AUTO_INHERIT_REQ = 256 # Variable c_int
MMIOERR_CANNOTREAD = 261 # Variable c_int
DISPID_NEWENUM = -4 # Variable c_int
PAGE_EXECUTE_READWRITE = 64 # Variable c_int
ERROR_REGISTRY_CORRUPT = 1015 # Variable c_long
MMSYSERR_HANDLEBUSY = 12 # Variable c_int
IME_PROP_CANDLIST_START_FROM_1 = 262144 # Variable c_int
MARSHAL_E_LAST = 2147746095 # Variable c_ulong
PSINJECT_BEGINSTREAM = 0 # Variable c_int
DISP_E_OVERFLOW = -2147352566 # Variable c_long
RPC_C_PARM_MAX_PACKET_LENGTH = 1 # Variable c_int
DESKTOP_CREATEWINDOW = 2 # Variable c_long
SUBLANG_ENGLISH_SOUTH_AFRICA = 7 # Variable c_int
WM_SETREDRAW = 11 # Variable c_int
SUBLANG_ARABIC_UAE = 14 # Variable c_int
HDM_GETITEMW = 4619 # Variable c_int

TTN_NEEDTEXTW = TTN_GETDISPINFOW

MIIM_STATE      = 0x00000001
MIIM_ID         = 0x00000002
MIIM_SUBMENU    = 0x00000004
MIIM_CHECKMARKS = 0x00000008
MIIM_TYPE       = 0x00000010
MIIM_DATA       = 0x00000020
MIIM_STRING     = 0x00000040
MIIM_BITMAP     = 0x00000080
MIIM_FTYPE      = 0x00000100

INPUT_MOUSE     = 0
INPUT_KEYBOARD  = 1
INPUT_HARDWARE  = 2

OBJID_CLIENT  = 0xFFFFFFFC
KEYEVENTF_UNICODE    = 0x0004
KEYEVENTF_SCANCODE   = 0x0008


MNS_NOCHECK        = 0x80000000
MNS_MODELESS       = 0x40000000
MNS_DRAGDROP       = 0x20000000
MNS_AUTODISMISS    = 0x10000000
MNS_NOTIFYBYPOS    = 0x08000000
MNS_CHECKORBMP     = 0x04000000

MIM_MAXHEIGHT             =  0x00000001
MIM_BACKGROUND            =  0x00000002
MIM_HELPID                =  0x00000004
MIM_MENUDATA              =  0x00000008
MIM_STYLE                 =  0x00000010
MIM_APPLYTOSUBMENUS       =  0x80000000

SPIF_UPDATEINIFILE    = 0x0001
SPIF_SENDWININICHANGE = 0x0002
SPIF_SENDCHANGE       = SPIF_SENDWININICHANGE


SPI_GETMOUSEHOVERWIDTH   =  98
SPI_SETMOUSEHOVERWIDTH   =  99
SPI_GETMOUSEHOVERHEIGHT  = 100
SPI_SETMOUSEHOVERHEIGHT  = 101
SPI_GETMOUSEHOVERTIME    = 102
SPI_SETMOUSEHOVERTIME    = 103
SPI_GETWHEELSCROLLLINES  = 104
SPI_SETWHEELSCROLLLINES  = 105

SPI_GETSHOWIMEUI         = 110
SPI_SETSHOWIMEUI         = 111


SPI_GETMOUSESPEED        = 112
SPI_SETMOUSESPEED        = 113
SPI_GETSCREENSAVERRUNNING= 114

SPI_GETACTIVEWINDOWTRACKING        = 0x1000
SPI_SETACTIVEWINDOWTRACKING        = 0x1001
SPI_GETMENUANIMATION               = 0x1002
SPI_SETMENUANIMATION               = 0x1003
SPI_GETCOMBOBOXANIMATION           = 0x1004
SPI_SETCOMBOBOXANIMATION           = 0x1005
SPI_GETLISTBOXSMOOTHSCROLLING      = 0x1006
SPI_SETLISTBOXSMOOTHSCROLLING      = 0x1007
SPI_GETGRADIENTCAPTIONS            = 0x1008
SPI_SETGRADIENTCAPTIONS            = 0x1009
SPI_GETMENUUNDERLINES              = 0x100A
SPI_SETMENUUNDERLINES              = 0x100B
SPI_GETACTIVEWNDTRKZORDER          = 0x100C
SPI_SETACTIVEWNDTRKZORDER          = 0x100D
SPI_GETHOTTRACKING                 = 0x100E
SPI_SETHOTTRACKING                 = 0x100F
SPI_GETFOREGROUNDLOCKTIMEOUT       = 0x2000
SPI_SETFOREGROUNDLOCKTIMEOUT       = 0x2001
SPI_GETACTIVEWNDTRKTIMEOUT         = 0x2002
SPI_SETACTIVEWNDTRKTIMEOUT         = 0x2003
SPI_GETFOREGROUNDFLASHCOUNT        = 0x2004
SPI_SETFOREGROUNDFLASHCOUNT        = 0x2005

TBIF_BYINDEX           = 0x80000000
NM_LDOWN               = (NM_FIRST-20)

PBM_GETBARCOLOR = 0x040F
PBM_GETBKCOLOR = 0x040E
PBM_GETSTATE = 0x0411
PBM_GETSTEP = 0x040D    # Windows Vista ~
PBM_SETBKCOLOR = 0x2001
PBM_SETMARQUEE = 0x040A # Windows XP ~
PBM_SETPOS = 0x0402
PBM_SETRANGE = 0x0401
PBM_SETRANGE32 = 0x0406 # Internet Explorer 3.0 ~
PBM_SETSTATE = 0x0410

PBS_MARQUEE = 0x08    # Windows XP ~
PBS_SMOOTHREVERSE = 0x10  # Windows Vista ~

PBST_NORMAL = 0x0001  # Windows Vista ~
PBST_ERROR = 0x0002
PBST_PAUSED = 0x0003

WAIT_TIMEOUT = 258    # dderror

########NEW FILE########
__FILENAME__ = win32functions
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA
"Defines Windows(tm) functions"

__revision__ = "$Revision: 726 $"

import ctypes
from ctypes import *

import sys
if sys.platform == "cygwin":
    windll = cdll
    HRESULT = c_long



UINT = c_uint
SHORT = c_short


CreateBrushIndirect	=	ctypes.windll.gdi32.CreateBrushIndirect
CreateDC			=	ctypes.windll.gdi32.CreateDCW
CreateFontIndirect	=	ctypes.windll.gdi32.CreateFontIndirectW
CreatePen			=	ctypes.windll.gdi32.CreatePen
DeleteDC 			=	ctypes.windll.gdi32.DeleteDC
GetObject           =   ctypes.windll.gdi32.GetObjectW
DeleteObject		=	ctypes.windll.gdi32.DeleteObject
DrawText			=	ctypes.windll.user32.DrawTextW
TextOut 			=	ctypes.windll.gdi32.TextOutW
Rectangle           =   ctypes.windll.gdi32.Rectangle
SelectObject        =   ctypes.windll.gdi32.SelectObject
GetStockObject      =   ctypes.windll.gdi32.GetStockObject
GetSystemMetrics    =   ctypes.windll.user32.GetSystemMetrics
GetTextMetrics      =   ctypes.windll.gdi32.GetTextMetricsW


EnumChildWindows	=	ctypes.windll.user32.EnumChildWindows
EnumDesktopWindows	=	ctypes.windll.user32.EnumDesktopWindows
EnumWindows			=	ctypes.windll.user32.EnumWindows
GetDC				=	ctypes.windll.user32.GetDC
GetDesktopWindow	=	ctypes.windll.user32.GetDesktopWindow


SendInput           =   ctypes.windll.user32.SendInput
SetCursorPos        =   ctypes.windll.user32.SetCursorPos
GetCursorPos        =   ctypes.windll.user32.GetCursorPos
GetCaretPos         =   ctypes.windll.user32.GetCaretPos

# menu functions
DrawMenuBar			=	ctypes.windll.user32.DrawMenuBar
GetMenu             =   ctypes.windll.user32.GetMenu
GetMenuBarInfo		=	ctypes.windll.user32.GetMenuBarInfo
GetMenuInfo         =   ctypes.windll.user32.GetMenuInfo
GetMenuItemCount	=	ctypes.windll.user32.GetMenuItemCount
GetMenuItemInfo		=	ctypes.windll.user32.GetMenuItemInfoW
SetMenuItemInfo     =   ctypes.windll.user32.SetMenuItemInfoW
GetMenuItemRect     =   ctypes.windll.user32.GetMenuItemRect
CheckMenuItem		=	ctypes.windll.user32.CheckMenuItem
GetMenuState		=	ctypes.windll.user32.GetMenuState
GetSubMenu	        =	ctypes.windll.user32.GetSubMenu
GetSystemMenu		=	ctypes.windll.user32.GetSystemMenu
HiliteMenuItem		=	ctypes.windll.user32.HiliteMenuItem
IsMenu				=	ctypes.windll.user32.IsMenu
MenuItemFromPoint	=	ctypes.windll.user32.MenuItemFromPoint

BringWindowToTop    =   ctypes.windll.user32.BringWindowToTop

GetVersion          =   ctypes.windll.kernel32.GetVersion

GetParent			=	ctypes.windll.user32.GetParent
GetWindow			=	ctypes.windll.user32.GetWindow
ShowWindow			= 	ctypes.windll.user32.ShowWindow
GetWindowContextHelpId =	ctypes.windll.user32.GetWindowContextHelpId
GetWindowLong		=	ctypes.windll.user32.GetWindowLongW
GetWindowPlacement  =   ctypes.windll.user32.GetWindowPlacement
GetWindowRect		=	ctypes.windll.user32.GetWindowRect
GetWindowText		=	ctypes.windll.user32.GetWindowTextW
GetWindowTextLength	=	ctypes.windll.user32.GetWindowTextLengthW
GetClassName        =   ctypes.windll.user32.GetClassNameW
GetClientRect       =   ctypes.windll.user32.GetClientRect
IsChild				=	ctypes.windll.user32.IsChild
IsWindow 			=	ctypes.windll.user32.IsWindow
IsWindowUnicode		=	ctypes.windll.user32.IsWindowUnicode
IsWindowVisible		=	ctypes.windll.user32.IsWindowVisible
IsWindowEnabled		=	ctypes.windll.user32.IsWindowEnabled

GetCurrentThreadId  =   ctypes.windll.Kernel32.GetCurrentThreadId
GetWindowThreadProcessId =  ctypes.windll.user32.GetWindowThreadProcessId
GetGUIThreadInfo    =   ctypes.windll.user32.GetGUIThreadInfo
AttachThreadInput   =   ctypes.windll.user32.AttachThreadInput
GetWindowThreadProcessId    =   ctypes.windll.user32.GetWindowThreadProcessId

OpenProcess			=	ctypes.windll.kernel32.OpenProcess
CloseHandle         =   ctypes.windll.kernel32.CloseHandle
CreateProcess       = ctypes.windll.kernel32.CreateProcessW
TerminateProcess    = ctypes.windll.kernel32.TerminateProcess
ExitProcess         = ctypes.windll.kernel32.ExitProcess

ReadProcessMemory   =   ctypes.windll.kernel32.ReadProcessMemory
GlobalAlloc = ctypes.windll.kernel32.GlobalAlloc
GlobalLock = ctypes.windll.kernel32.GlobalLock
GlobalUnlock = ctypes.windll.kernel32.GlobalUnlock

SendMessage			=	ctypes.windll.user32.SendMessageW
SendMessageTimeout  =   ctypes.windll.user32.SendMessageTimeoutW
SendMessageA		=	ctypes.windll.user32.SendMessageA
PostMessage			=	ctypes.windll.user32.PostMessageW
GetMessage          =   ctypes.windll.user32.GetMessageW

MoveWindow          =   ctypes.windll.user32.MoveWindow
EnableWindow        =   ctypes.windll.user32.EnableWindow
SetActiveWindow		=	ctypes.windll.user32.SetActiveWindow
GetFocus			=	ctypes.windll.user32.GetFocus
SetFocus			=	ctypes.windll.user32.SetFocus
SetForegroundWindow	=	ctypes.windll.user32.SetForegroundWindow
GetForegroundWindow	=	ctypes.windll.user32.GetForegroundWindow
SetWindowLong		=	ctypes.windll.user32.SetWindowLongW
SystemParametersInfo =	ctypes.windll.user32.SystemParametersInfoW
VirtualAllocEx		=	ctypes.windll.kernel32.VirtualAllocEx
VirtualFreeEx		=	ctypes.windll.kernel32.VirtualFreeEx
WriteProcessMemory	=	ctypes.windll.kernel32.WriteProcessMemory
GetActiveWindow		=	ctypes.windll.user32.GetActiveWindow
GetLastActivePopup 	=	ctypes.windll.user32.GetLastActivePopup
FindWindow			=	ctypes.windll.user32.FindWindowW
GetTopWindow		=	ctypes.windll.user32.GetTopWindow

SetCapture			=	ctypes.windll.user32.SetCapture
ReleaseCapture		=	ctypes.windll.user32.ReleaseCapture

ShowOwnedPopups		=	ctypes.windll.user32.ShowOwnedPopups
WindowFromPoint 	=	ctypes.windll.user32.WindowFromPoint

WideCharToMultiByte	=	ctypes.windll.kernel32.WideCharToMultiByte
GetACP				=	ctypes.windll.kernel32.GetACP

WaitForSingleObject = ctypes.windll.kernel32.WaitForSingleObject
WaitForInputIdle	= ctypes.windll.user32.WaitForInputIdle

OpenProcess				=	ctypes.windll.kernel32.OpenProcess
GetModuleFileNameEx		=	ctypes.windll.psapi.GetModuleFileNameExW

GetClipboardData = ctypes.windll.user32.GetClipboardData
OpenClipboard    = ctypes.windll.user32.OpenClipboard
EmptyClipboard   = ctypes.windll.user32.EmptyClipboard
CloseClipboard   = ctypes.windll.user32.CloseClipboard
CountClipboardFormats  = ctypes.windll.user32.CountClipboardFormats
EnumClipboardFormats   = ctypes.windll.user32.EnumClipboardFormats
GetClipboardFormatName = ctypes.windll.user32.GetClipboardFormatNameW

GetQueueStatus = ctypes.windll.user32.GetQueueStatus

LoadString = ctypes.windll.user32.LoadStringW


#def VkKeyScanW(p1):
#    # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4225
#    return VkKeyScanW._api_(p1)
#VkKeyScan = stdcall(SHORT, 'user32', [c_wchar]) (VkKeyScanW)
#
#def MapVirtualKeyExW(p1, p2, p3):
#    # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4376
#    return MapVirtualKeyExW._api_(p1, p2, p3)
#MapVirtualKeyEx = stdcall(
#    UINT, 'user32', [c_uint, c_uint, c_long]) (MapVirtualKeyExW)
#
#def MapVirtualKeyW(p1, p2):
#    # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4355
#    return MapVirtualKeyW._api_(p1, p2)
#MapVirtualKey = stdcall(UINT, 'user32', [c_uint, c_uint]) (MapVirtualKeyW)


#====================================================================
def MakeLong(high, low):
    "Pack high into the high word of a long and low into the low word"

    # we need to AND each value with 0xFFFF to account for numbers
    # greater then normal WORD (short) size
    return ((high & 0xFFFF) << 16) | (low & 0xFFFF)

#====================================================================
def HiWord(value):
    "Return the high word from a long"
    #return (value & (~ 0xFFFF)) / 0xFFFF
    return (value >> 16) & 0xffff

#====================================================================
def LoWord(value):
    "Return the low word from a long"
    return value & 0xFFFF

#====================================================================
def WaitGuiThreadIdle(handle, timeout = 1):
    "Wait until the thread of the specified handle is ready"
    from . import win32defines

    process_id = ctypes.c_int()
    GetWindowThreadProcessId(handle, ctypes.byref(process_id))

    # ask the control if it has finished processing the message
    hprocess = OpenProcess(
        win32defines.PROCESS_QUERY_INFORMATION,
        0,
        process_id.value)

    # wait timout number of seconds
    ret = WaitForInputIdle(hprocess, timeout * 1000)

    CloseHandle(hprocess)

    return ret

########NEW FILE########
__FILENAME__ = win32structures
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"Definition of Windows structures"

__revision__ = "$Revision: 560 $"

from .win32defines import LF_FACESIZE, NMTTDISPINFOW_V1_SIZE, HDITEMW_V1_SIZE

import ctypes
from ctypes import \
    c_int, c_uint, c_long, c_ulong, c_void_p, c_wchar, c_char, \
    c_ubyte, c_ushort, c_wchar_p, \
    POINTER, sizeof, alignment, Union


class Structure(ctypes.Structure):
    "Override the Structure class from ctypes to add printing and comparison"
    #----------------------------------------------------------------
    def __str__(self):
        """Print out the fields of the ctypes Structure

        fields in exceptList will not be printed"""

        lines = []
        for f in self._fields_:
            name = f[0]
            lines.append("%20s\t%s"% (name, getattr(self, name)))

        return "\n".join(lines)

    #----------------------------------------------------------------
    def __eq__(self, other_struct):
        "return true if the two structures have the same coordinates"

        if isinstance(other_struct, ctypes.Structure):

            try:
                # pretend they are two structures - check that they both
                # have the same value for all fields
                are_equal = True
                for field in self._fields_:
                    name = field[0]
                    if getattr(self, name) != getattr(other_struct, name):
                        are_equal = False
                        break

                return are_equal

            except AttributeError:
                return False

        if isinstance(other_struct, (list, tuple)):
            # Now try to see if we have been passed in a list or tuple
            try:
                are_equal = True
                for i, field in enumerate(self._fields_):
                    name = field[0]
                    if getattr(self, name) != other_struct[i]:
                        are_equal = False
                        break
                return are_equal

            except:
                return False

        return False

##====================================================================
#def PrintCtypesStruct(struct, exceptList = []):
#    """Print out the fields of the ctypes Structure
#
#    fields in exceptList will not be printed"""
#    for f in struct._fields_:
#        name = f[0]
#        if name in exceptList:
#            continue
#        print "%20s "% name, getattr(struct, name)


# allow ctypes structures to be pickled
# set struct.__reduce__ = _reduce
# e.g. RECT.__reduce__ = _reduce
def _construct(typ, buf):
    #print "construct", (typ, buf)
    obj = typ.__new__(typ)
    ctypes.memmove(ctypes.addressof(obj), buf, len(buf))
    return obj

def _reduce(self):
    return (_construct, (self.__class__, str(buffer(self))))


#LPTTTOOLINFOW = POINTER(tagTOOLINFOW)
#PTOOLINFOW = POINTER(tagTOOLINFOW)
BOOL = c_int
BYTE = c_ubyte
CHAR = c_char
DWORD = c_ulong
HANDLE = c_void_p
HBITMAP = c_long
LONG = c_long
LPARAM = LONG
LPVOID = c_void_p
PVOID = c_void_p
UINT = c_uint
WCHAR = c_wchar
WORD = c_ushort
WPARAM = UINT


COLORREF = DWORD
HBITMAP = LONG
HINSTANCE = LONG
HMENU = LONG
HBRUSH = LONG
HTREEITEM = LONG
HWND = LONG
LPARAM = LONG
LPBYTE = POINTER(BYTE)
LPWSTR = c_long# POINTER(WCHAR)



class POINT(Structure):
    _fields_ = [
        # C:/PROGRA~1/MIAF9D~1/VC98/Include/windef.h 307
        ('x', LONG),
        ('y', LONG),
    ]
#assert sizeof(POINT) == 8, sizeof(POINT)
#assert alignment(POINT) == 4, alignment(POINT)


#====================================================================
class RECT(Structure):
    "Wrap the RECT structure and add extra functionality"
    _fields_ = [
        # C:/PROGRA~1/MIAF9D~1/VC98/Include/windef.h 287
        ('left', LONG),
        ('top', LONG),
        ('right', LONG),
        ('bottom', LONG),
    ]

    #----------------------------------------------------------------
    def __init__(self, otherRect_or_left = 0, top = 0, right = 0, bottom = 0):
        """Provide a constructor for RECT structures

        A RECT can be constructed by:
        - Another RECT (each value will be copied)
        - Values for left, top, right and bottom

        e.g. my_rect = RECT(otherRect)
        or   my_rect = RECT(10, 20, 34, 100)
        """
        if isinstance(otherRect_or_left, RECT):
            self.left = otherRect_or_left.left
            self.right = otherRect_or_left.right
            self.top = otherRect_or_left.top
            self.bottom = otherRect_or_left.bottom
        else:
            #if not isinstance(otherRect_or_left, (int, long)):
            #    print type(self), type(otherRect_or_left), otherRect_or_left
            self.left = int(otherRect_or_left)
            self.right = int(right)
            self.top = int(top)
            self.bottom = int(bottom)


#    #----------------------------------------------------------------
#    def __eq__(self, otherRect):
#        "return true if the two rectangles have the same coordinates"
#
#        try:
#            return \
#                self.left == otherRect.left and \
#                self.top == otherRect.top and \
#                self.right == otherRect.right and \
#                self.bottom == otherRect.bottom
#        except AttributeError:
#            return False

    #----------------------------------------------------------------
    def __str__(self):
        "Return a string representation of the RECT"
        return "(L%d, T%d, R%d, B%d)" % (
            self.left, self.top, self.right, self.bottom)

    #----------------------------------------------------------------
    def __repr__(self):
        "Return some representation of the RECT"
        return "<RECT L%d, T%d, R%d, B%d>" % (
            self.left, self.top, self.right, self.bottom)

    #----------------------------------------------------------------
    def __sub__(self, other):
        "Return a new rectangle which is offset from the one passed in"
        newRect = RECT()

        newRect.left = self.left - other.left
        newRect.right = self.right - other.left

        newRect.top = self.top - other.top
        newRect.bottom = self.bottom - other.top

        return newRect

    #----------------------------------------------------------------
    def __add__(self, other):
        "Allow two rects to be added using +"
        newRect = RECT()

        newRect.left = self.left + other.left
        newRect.right = self.right + other.left

        newRect.top = self.top + other.top
        newRect.bottom = self.bottom + other.top

        return newRect

    #----------------------------------------------------------------
    def width(self):
        "Return the width of the  rect"
        return self.right - self.left

    #----------------------------------------------------------------
    def height(self):
        "Return the height of the rect"
        return self.bottom - self.top

    #----------------------------------------------------------------
    def mid_point(self):
        "Return a POINT structure representing the mid point"
        pt = POINT()
        pt.x = int(self.left + self.width()//2)
        pt.y = int(self.top + self.height()//2)
        return pt

    #def __hash__(self):
    #	return hash (self.left, self.top, self.right, self.bottom)

RECT.__reduce__ = _reduce

#assert sizeof(RECT) == 16, sizeof(RECT)
#assert alignment(RECT) == 4, alignment(RECT)


class LVCOLUMNW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 2982
        ('mask', UINT),
        ('fmt', c_int),
        ('cx', c_int),
        ('pszText', c_long), #LPWSTR),
        ('cchTextMax', c_int),
        ('iSubItem', c_int),
        ('iImage', c_int),
        ('iOrder', c_int),
    ]


class LVITEMW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 2679
        ('mask', UINT),
        ('iItem', c_int),
        ('iSubItem', c_int),
        ('state', UINT),
        ('stateMask', UINT),
        ('pszText', c_long), #LPWSTR),
        ('cchTextMax', c_int),
        ('iImage', c_int),
        ('lParam', LPARAM),
        ('iIndent', c_int),
    ]
#assert sizeof(LVITEMW) == 40, sizeof(LVITEMW)
#assert alignment(LVITEMW) == 1, alignment(LVITEMW)


class TVITEMW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 3755
        ('mask', UINT),
        ('hItem', HTREEITEM),
        ('state', UINT),
        ('stateMask', UINT),
        ('pszText', c_long), #LPWSTR),
        ('cchTextMax', c_int),
        ('iImage', c_int),
        ('iSelectedImage', c_int),
        ('cChildren', c_int),
        ('lParam', LPARAM),
    ]
#assert sizeof(TVITEMW) == 40, sizeof(TVITEMW)
#assert alignment(TVITEMW) == 1, alignment(TVITEMW)


# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 2225
class NMHDR(Structure):
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 2225
        ('hwndFrom', HWND),
        ('idFrom', UINT),
        ('code', UINT),
    ]
#assert sizeof(NMHDR) == 12, sizeof(NMHDR)
#assert alignment(NMHDR) == 4, alignment(NMHDR)


# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 4275
class NMTVDISPINFOW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 4275
        ('hdr', NMHDR),
        ('item', TVITEMW),
    ]
#assert sizeof(NMTVDISPINFOW) == 52, sizeof(NMTVDISPINFOW)
#assert alignment(NMTVDISPINFOW) == 1, alignment(NMTVDISPINFOW)


class LOGFONTW(Structure):
    _fields_ = [
        # C:/PROGRA~1/MIAF9D~1/VC98/Include/wingdi.h 1090
        ('lfHeight', LONG),
        ('lfWidth', LONG),
        ('lfEscapement', LONG),
        ('lfOrientation', LONG),
        ('lfWeight', LONG),
        ('lfItalic', BYTE),
        ('lfUnderline', BYTE),
        ('lfStrikeOut', BYTE),
        ('lfCharSet', BYTE),
        ('lfOutPrecision', BYTE),
        ('lfClipPrecision', BYTE),
        ('lfQuality', BYTE),
        ('lfPitchAndFamily', BYTE),
        ('lfFaceName', WCHAR * LF_FACESIZE),
    ]

    #----------------------------------------------------------------
    def __str__(self):
        return  "('%s' %d)" % (self.lfFaceName, self.lfHeight)

    #----------------------------------------------------------------
    def __repr__(self):
        return "<LOGFONTW '%s' %d>" % (self.lfFaceName, self.lfHeight)

LOGFONTW.__reduce__ = _reduce

#assert sizeof(LOGFONTW) == 92, sizeof(LOGFONTW)
#assert alignment(LOGFONTW) == 4, alignment(LOGFONTW)


class TEXTMETRICW(Structure):
    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MIAF9D~1/VC98/Include/wingdi.h 878
        ('tmHeight', LONG),
        ('tmAscent', LONG),
        ('tmDescent', LONG),
        ('tmInternalLeading', LONG),
        ('tmExternalLeading', LONG),
        ('tmAveCharWidth', LONG),
        ('tmMaxCharWidth', LONG),
        ('tmWeight', LONG),
        ('tmOverhang', LONG),
        ('tmDigitizedAspectX', LONG),
        ('tmDigitizedAspectY', LONG),
        ('tmFirstChar', WCHAR),
        ('tmLastChar', WCHAR),
        ('tmDefaultChar', WCHAR),
        ('tmBreakChar', WCHAR),
        ('tmItalic', BYTE),
        ('tmUnderlined', BYTE),
        ('tmStruckOut', BYTE),
        ('tmPitchAndFamily', BYTE),
        ('tmCharSet', BYTE),
    ]
#assert sizeof(TEXTMETRICW) == 58, sizeof(TEXTMETRICW)
#assert alignment(TEXTMETRICW) == 2, alignment(TEXTMETRICW)


class NONCLIENTMETRICSW(Structure):
    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MIAF9D~1/VC98/Include/winuser.h 8767
        ('cbSize', UINT),
        ('iBorderWidth', c_int),
        ('iScrollWidth', c_int),
        ('iScrollHeight', c_int),
        ('iCaptionWidth', c_int),
        ('iCaptionHeight', c_int),
        ('lfCaptionFont', LOGFONTW),
        ('iSmCaptionWidth', c_int),
        ('iSmCaptionHeight', c_int),
        ('lfSmCaptionFont', LOGFONTW),
        ('iMenuWidth', c_int),
        ('iMenuHeight', c_int),
        ('lfMenuFont', LOGFONTW),
        ('lfStatusFont', LOGFONTW),
        ('lfMessageFont', LOGFONTW),
    ]

#assert sizeof(NONCLIENTMETRICSW) == 500, sizeof(NONCLIENTMETRICSW)
#assert alignment(NONCLIENTMETRICSW) == 2, alignment(NONCLIENTMETRICSW)


# C:/PROGRA~1/MIAF9D~1/VC98/Include/wingdi.h 1025
class LOGBRUSH(Structure):
    _fields_ = [
        # C:/PROGRA~1/MIAF9D~1/VC98/Include/wingdi.h 1025
        ('lbStyle', UINT),
        ('lbColor', COLORREF),
        ('lbHatch', LONG),
    ]
#assert sizeof(LOGBRUSH) == 12, sizeof(LOGBRUSH)
#assert alignment(LOGBRUSH) == 4, alignment(LOGBRUSH)

# C:/PROGRA~1/MIAF9D~1/VC98/Include/winuser.h 5147
class MENUITEMINFOW(Structure):
    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MIAF9D~1/VC98/Include/winuser.h 5147
        ('cbSize', UINT),
        ('fMask', UINT),
        ('fType', UINT),
        ('fState', UINT),
        ('wID', UINT),
        ('hSubMenu', HMENU),
        ('hbmpChecked', HBITMAP),
        ('hbmpUnchecked', HBITMAP),
        ('dwItemData', DWORD),
        ('dwTypeData', c_wchar_p), #LPWSTR),
        ('cch', UINT),
    ]
#assert sizeof(MENUITEMINFOW) == 44, sizeof(MENUITEMINFOW)
#assert alignment(MENUITEMINFOW) == 2, alignment(MENUITEMINFOW)

class MENUBARINFO(Structure):
    _fields_ = [
        ('cbSize',  DWORD),
        ('rcBar',  RECT),          # rect of bar, popup, item
        ('hMenu',  HMENU),          # real menu handle of bar, popup
        ('hwndMenu',  HWND),       # hwnd of item submenu if one
        ('fBarFocused',  BOOL, 1),  # bar, popup has the focus
        ('fFocused',  BOOL, 1),     # item has the focus
    ]


class MSG(Structure):
    _fields_ = [
        # C:/PROGRA~1/MIAF9D~1/VC98/Include/winuser.h 1226
        ('hwnd', HWND),
        ('message', UINT),
        ('wParam', WPARAM),
        ('lParam', LPARAM),
        ('time', DWORD),
        ('pt', POINT),
]

#assert sizeof(MSG) == 28, sizeof(MSG)
#assert alignment(MSG) == 4, alignment(MSG)


# C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 1865
class TOOLINFOW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 1865
        ('cbSize', UINT),
        ('uFlags', UINT),
        ('hwnd', HWND),
        ('uId', UINT),
        ('rect', RECT),
        ('hinst', HINSTANCE),
        ('lpszText', c_long),#LPWSTR),
        ('lParam', LPARAM),
    ]
#assert sizeof(TOOLINFOW) == 44, sizeof(TOOLINFOW)
#assert alignment(TOOLINFOW) == 1, alignment(TOOLINFOW)


# C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 2068
class NMTTDISPINFOW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 2068
        ('hdr', NMHDR),
        ('lpszText', LPWSTR),
        ('szText', WCHAR * 80),
        ('hinst', HINSTANCE),
        ('uFlags', UINT),
        ('lParam', LPARAM),
    ]

#assert sizeof(NMTTDISPINFOW) == 188, sizeof(NMTTDISPINFOW)
#assert alignment(NMTTDISPINFOW) == 1, alignment(NMTTDISPINFOW)


class HDITEMW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 617
        ('mask', UINT),
        ('cxy', c_int),
        ('pszText', c_long),#LPWSTR),
        ('hbm', HBITMAP),
        ('cchTextMax', c_int),
        ('fmt', c_int),
        ('lParam', LPARAM),
        ('iImage', c_int),
        ('iOrder', c_int),
    ]
#assert sizeof(HDITEMW) == 36, sizeof(HDITEMW)
#assert alignment(HDITEMW) == 1, alignment(HDITEMW)


# C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 4456
class COMBOBOXEXITEMW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/_tools/Python24/Lib/site-packages/ctypes/wrap/test/commctrl.h 4456
        ('mask', UINT),
        ('iItem', c_int),
        ('pszText', c_long),#LPWSTR),
        ('cchTextMax', c_int),
        ('iImage', c_int),
        ('iSelectedImage', c_int),
        ('iOverlay', c_int),
        ('iIndent', c_int),
        ('lParam', LPARAM),
]
#assert sizeof(COMBOBOXEXITEMW) == 36, sizeof(COMBOBOXEXITEMW)
#assert alignment(COMBOBOXEXITEMW) == 1, alignment(COMBOBOXEXITEMW)


# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 4757
class TCITEMHEADERW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 4757
        ('mask', UINT),
        ('lpReserved1', UINT),
        ('lpReserved2', UINT),
        ('pszText', LPWSTR),
        ('cchTextMax', c_int),
        ('iImage', c_int),
    ]

#assert sizeof(TCITEMHEADERW) == 24, sizeof(TCITEMHEADERW)
#assert alignment(TCITEMHEADERW) == 1, alignment(TCITEMHEADERW)

# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 4804
class TCITEMW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 4804
        ('mask', UINT),
        ('dwState', DWORD),
        ('dwStateMask', DWORD),
        ('pszText', c_long), #LPWSTR),
        ('cchTextMax', c_int),
        ('iImage', c_int),
        ('lParam', LPARAM),
    ]
#assert sizeof(TCITEMW) == 28, sizeof(TCITEMW)
#assert alignment(TCITEMW) == 1, alignment(TCITEMW)



# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 1308
class TBBUTTONINFOW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 1308
        ('cbSize', UINT),
        ('dwMask', DWORD),
        ('idCommand', c_int),
        ('iImage', c_int),
        ('fsState', BYTE),
        ('fsStyle', BYTE),
        ('cx', WORD),
        ('lParam', DWORD),
        ('pszText', LPWSTR),
        ('cchText', c_int),
    ]
#assert sizeof(TBBUTTONINFOW) == 32, sizeof(TBBUTTONINFOW)
#assert alignment(TBBUTTONINFOW) == 1, alignment(TBBUTTONINFOW)

# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 953
class TBBUTTON(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 953
        ('iBitmap', c_int),
        ('idCommand', c_int),
        ('fsState', BYTE),
        ('fsStyle', BYTE),
        ('bReserved', BYTE * 2),
        ('dwData', DWORD),
        ('iString', c_int),
    ]
#assert sizeof(TBBUTTON) == 20, sizeof(TBBUTTON)
#assert alignment(TBBUTTON) == 1, alignment(TBBUTTON)



class REBARBANDINFOW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 1636
        ('cbSize', UINT),
        ('fMask', UINT),
        ('fStyle', UINT),
        ('clrFore', COLORREF),
        ('clrBack', COLORREF),
        ('lpText', LPWSTR),
        ('cch', UINT),
        ('iImage', c_int),
        ('hwndChild', HWND),
        ('cxMinChild', UINT),
        ('cyMinChild', UINT),
        ('cx', UINT),
        ('hbmBack', HBITMAP),
        ('wID', UINT),
        ('cyChild', UINT),
        ('cyMaxChild', UINT),
        ('cyIntegral', UINT),
        ('cxIdeal', UINT),
        ('lParam', LPARAM),
        ('cxHeader', UINT),
    ]
#assert sizeof(REBARBANDINFOW) == 80, sizeof(REBARBANDINFOW)
#assert alignment(REBARBANDINFOW) == 1, alignment(REBARBANDINFOW)


# C:/PROGRA~1/MICROS~4/VC98/Include/winbase.h 223
class SECURITY_ATTRIBUTES(Structure):
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winbase.h 223
        ('nLength', DWORD),
        ('lpSecurityDescriptor', LPVOID),
        ('bInheritHandle', BOOL),
    ]
#assert sizeof(SECURITY_ATTRIBUTES) == 12, sizeof(SECURITY_ATTRIBUTES)
#assert alignment(SECURITY_ATTRIBUTES) == 4, alignment(SECURITY_ATTRIBUTES)

# C:/PROGRA~1/MICROS~4/VC98/Include/winbase.h 3794
class STARTUPINFOW(Structure):
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winbase.h 3794
        ('cb', DWORD),
        ('lpReserved', LPWSTR),
        ('lpDesktop', LPWSTR),
        ('lpTitle', LPWSTR),
        ('dwX', DWORD),
        ('dwY', DWORD),
        ('dwXSize', DWORD),
        ('dwYSize', DWORD),
        ('dwXCountChars', DWORD),
        ('dwYCountChars', DWORD),
        ('dwFillAttribute', DWORD),
        ('dwFlags', DWORD),
        ('wShowWindow', WORD),
        ('cbReserved2', WORD),
        ('lpReserved2', LPBYTE),
        ('hStdInput', HANDLE),
        ('hStdOutput', HANDLE),
        ('hStdError', HANDLE),
    ]
#assert sizeof(STARTUPINFOW) == 68, sizeof(STARTUPINFOW)
#assert alignment(STARTUPINFOW) == 4, alignment(STARTUPINFOW)

# C:/PROGRA~1/MICROS~4/VC98/Include/winbase.h 229
class PROCESS_INFORMATION(Structure):
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winbase.h 229
        ('hProcess', HANDLE),
        ('hThread', HANDLE),
        ('dwProcessId', DWORD),
        ('dwThreadId', DWORD),
    ]
#assert sizeof(PROCESS_INFORMATION) == 16, sizeof(PROCESS_INFORMATION)
#assert alignment(PROCESS_INFORMATION) == 4, alignment(PROCESS_INFORMATION)


# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 3417
class NMLISTVIEW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 3417
        ('hdr', NMHDR),
        ('iItem', c_int),
        ('iSubItem', c_int),
        ('uNewState', UINT),
        ('uOldState', UINT),
        ('uChanged', UINT),
        ('ptAction', POINT),
        ('lParam', LPARAM),
    ]
#assert sizeof(NMLISTVIEW) == 44, sizeof(NMLISTVIEW)
#assert alignment(NMLISTVIEW) == 1, alignment(NMLISTVIEW)


# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 235
class NMMOUSE(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 235
        ('hdr', NMHDR),
        ('dwItemSpec', DWORD),
        ('dwItemData', DWORD),
        ('pt', POINT),
        ('dwHitInfo', DWORD),
    ]
#assert sizeof(NMMOUSE) == 32, sizeof(NMMOUSE)
#assert alignment(NMMOUSE) == 1, alignment(NMMOUSE)


# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4283
class MOUSEINPUT(Structure):
    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4283
        ('dx', LONG),
        ('dy', LONG),
        ('mouseData', DWORD),
        ('dwFlags', DWORD),
        ('time', DWORD),
        ('dwExtraInfo', DWORD),
    ]
#assert sizeof(MOUSEINPUT) == 24, sizeof(MOUSEINPUT)
#assert alignment(MOUSEINPUT) == 2, alignment(MOUSEINPUT)

# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4292
class KEYBDINPUT(Structure):
    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4292
        ('wVk', WORD),
        ('wScan', WORD),
        ('dwFlags', DWORD),
        ('time', DWORD),
        ('dwExtraInfo', DWORD),
    ]
#assert sizeof(KEYBDINPUT) == 16, sizeof(KEYBDINPUT)
#assert alignment(KEYBDINPUT) == 2, alignment(KEYBDINPUT)


class HARDWAREINPUT(Structure):
    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4300
        ('uMsg', DWORD),
        ('wParamL', WORD),
        ('wParamH', WORD),
    ]
#assert sizeof(HARDWAREINPUT) == 8, sizeof(HARDWAREINPUT)
#assert alignment(HARDWAREINPUT) == 2, alignment(HARDWAREINPUT)


# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4314
class UNION_INPUT_STRUCTS(Union):
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4314
        ('mi', MOUSEINPUT),
        ('ki', KEYBDINPUT),
        ('hi', HARDWAREINPUT),
    ]
#assert sizeof(UNION_INPUT_STRUCTS) == 24, sizeof(UNION_INPUT_STRUCTS)
#assert alignment(UNION_INPUT_STRUCTS) == 2, alignment(UNION_INPUT_STRUCTS)

# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4310
class INPUT(Structure):
    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 4310
        ('type', DWORD),
        # Unnamed field renamed to '_'
        ('_', UNION_INPUT_STRUCTS),
    ]
#assert sizeof(INPUT) == 28, sizeof(INPUT)
#assert alignment(INPUT) == 2, alignment(INPUT)



# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 2415
class NMUPDOWN(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 2415
        ('hdr', NMHDR),
        ('iPos', c_int),
        ('iDelta', c_int),
    ]
#assert sizeof(NMUPDOWN) == 20, sizeof(NMUPDOWN)
#assert alignment(NMUPDOWN) == 1, alignment(NMUPDOWN)



# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 9821
class GUITHREADINFO(Structure):
    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 9821
        ('cbSize', DWORD),
        ('flags', DWORD),
        ('hwndActive', HWND),
        ('hwndFocus', HWND),
        ('hwndCapture', HWND),
        ('hwndMenuOwner', HWND),
        ('hwndMoveSize', HWND),
        ('hwndCaret', HWND),
        ('rcCaret', RECT),
    ]
#assert sizeof(GUITHREADINFO) == 48, sizeof(GUITHREADINFO)
#assert alignment(GUITHREADINFO) == 2, alignment(GUITHREADINFO)



# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 5043
class MENUINFO(Structure):
    _pack_ = 2
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 5043
        ('cbSize', DWORD),
        ('fMask', DWORD),
        ('dwStyle', DWORD),
        ('cyMax', UINT),
        ('hbrBack', HBRUSH),
        ('dwContextHelpID', DWORD),
        ('dwMenuData', DWORD),
    ]
#assert sizeof(MENUINFO) == 28, sizeof(MENUINFO)
#assert alignment(MENUINFO) == 2, alignment(MENUINFO)



NMTTDISPINFOW_V1_SIZE = 184 # Variable c_uint

# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 2066
class NMTTDISPINFOW(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 2066
        ('hdr', NMHDR),
        ('lpszText', LPWSTR),
        ('szText', WCHAR * 80),
        ('hinst', HINSTANCE),
        ('uFlags', UINT),
        ('lParam', LPARAM),
    ]
#assert sizeof(NMTTDISPINFOW) == 188, sizeof(NMTTDISPINFOW)
#assert alignment(NMTTDISPINFOW) == 1, alignment(NMTTDISPINFOW)


# C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 2208
class WINDOWPLACEMENT(Structure):
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/winuser.h 2208
        ('length', UINT),
        ('flags', UINT),
        ('showCmd', UINT),
        ('ptMinPosition', POINT),
        ('ptMaxPosition', POINT),
        ('rcNormalPosition', RECT),
    ]
#assert sizeof(WINDOWPLACEMENT) == 44, sizeof(WINDOWPLACEMENT)
#assert alignment(WINDOWPLACEMENT) == 4, alignment(WINDOWPLACEMENT)


# C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 4052
class TVHITTESTINFO(Structure):
    _pack_ = 1
    _fields_ = [
        # C:/PROGRA~1/MICROS~4/VC98/Include/commctrl.h 4052
        ('pt', POINT),
        ('flags', UINT),
        ('hItem', HTREEITEM),
    ]
#assert sizeof(TVHITTESTINFO) == 16, sizeof(TVHITTESTINFO)
#assert alignment(TVHITTESTINFO) == 1, alignment(TVHITTESTINFO)



########NEW FILE########
__FILENAME__ = XMLHelpers
# GUI Application automation and testing library
# Copyright (C) 2006 Mark Mc Mahon
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 2.1
# of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
#    Free Software Foundation, Inc.,
#    59 Temple Place,
#    Suite 330,
#    Boston, MA 02111-1307 USA

"""Module containing operations for reading and writing dialogs as XML
"""

__revision__ = "$Revision: 736 $"


# how should we read in the XML file
# NOT USING MS Components (requirement on machine)
# maybe using built in XML
# maybe using elementtree
# others?

#import elementtree
try:
    # Python 2.5 (thanks to Daisuke Yamashita)
    from xml.etree.ElementTree import Element, SubElement, ElementTree
    from xml.etree.cElementTree import Element, SubElement, ElementTree 
except ImportError:
    from elementtree.ElementTree import Element, SubElement, ElementTree
    from cElementTree import Element, SubElement, ElementTree

import ctypes
import re
import PIL.Image
from . import controls

# reported that they are not used - but in fact they are
# through a search of globals()
from .win32structures import LOGFONTW, RECT

class XMLParsingError(RuntimeError):
    "Wrap parsing Exceptions"
    pass



#DONE: Make the dialog reading function not actually know about the
# types of each element (so that we can read the control properties
# without having to know each and every element type)
# probably need to store info on what type things are.
#
# - if it is a ctypes struct then there is a __type__ field
#   which says what kind of stuct it is
# - If it is an image then a "_IMG" is appeded to the the element tag
# - if it is a long then _LONG is appended to attribute name
# everything else is considered a string!


#-----------------------------------------------------------------------------
def _SetNodeProps(element, name, value):
    "Set the properties of the node based on the type of object"

    # if it is a ctypes structure
    if isinstance(value, ctypes.Structure):

        # create an element for the structure
        struct_elem = SubElement(element, name)
        #clsModule = value.__class__.__module__
        cls_name = value.__class__.__name__
        struct_elem.set("__type__", "%s" % cls_name)

        # iterate over the fields in the structure
        for prop_name in value._fields_:
            prop_name = prop_name[0]
            item_val = getattr(value, prop_name)

            if isinstance(item_val, int):
                prop_name += "_LONG"
                item_val = str(item_val)

            struct_elem.set(prop_name, _EscapeSpecials(item_val))

    elif hasattr(value, 'tostring') and hasattr(value, 'size'):
        try:
            # if the image is too big then don't try to
            # write it out - it would probably product a MemoryError
            # anyway
            if value.size[0] * value.size[1] > (5000*5000):
                raise MemoryError

            image_data = value.tostring().encode("bz2").encode("base64")
            _SetNodeProps(
                element,
                name + "_IMG",
                {
                    "mode": value.mode,
                    "size_x":value.size[0],
                    "size_y":value.size[1],
                    "data":image_data
                })

        # a system error is raised from time to time when we try to grab
        # the image of a control that has 0 height or width
        except (SystemError, MemoryError):
            pass


    elif isinstance(value, (list, tuple)):
        # add the element to hold the values
        # we do this to be able to support empty lists
        listelem = SubElement(element, name + "_LIST")

        for i, attrval in enumerate(value):
            _SetNodeProps(listelem, "%s_%05d"%(name, i), attrval)

    elif isinstance(value, dict):
        dict_elem = SubElement(element, name)

        for item_name, val in list(value.items()):
            _SetNodeProps(dict_elem, item_name, val)

    else:
        if isinstance(value, bool):
            value = int(value)

        if isinstance(value, int):
            name += "_LONG"

        element.set(name, _EscapeSpecials(value))


#-----------------------------------------------------------------------------
def WriteDialogToFile(filename, props):
    """Write the props to the file

    props can be either a dialog of a dictionary
    """
    # if we are passed in a wrapped handle then
    # get the properties
    try:
        list(props[0].keys())
    except (TypeError, AttributeError):
        props = controls.GetDialogPropsFromHandle(props)

    # build a tree structure
    root = Element("DIALOG")
    root.set("_version_", "2.0")
    for ctrl in props:
        ctrlelem = SubElement(root, "CONTROL")
        for name, value in sorted(ctrl.items()):
            _SetNodeProps(ctrlelem, name, value)

    # wrap it in an ElementTree instance, and save as XML
    tree = ElementTree(root)
    tree.write(filename, encoding="utf-8")



#-----------------------------------------------------------------------------
def _EscapeSpecials(string):
    "Ensure that some characters are escaped before writing to XML"

    # ensure it is unicode
    string = str(string)

    # escape backslashs
    string = string.replace('\\', r'\\')

    # escape non printable characters (chars below 30)
    for i in range(0, 32):
        string = string.replace(chr(i), "\\%02d"%i)

    return string


#-----------------------------------------------------------------------------
def _UnEscapeSpecials(string):
    "Replace escaped characters with real character"

    # Unescape all the escape characters
    for i in range(0, 32):
        string = string.replace("\\%02d"%i, chr(i))

    # convert doubled backslashes to a single backslash
    string = string.replace(r'\\', '\\')

    return str(string)



#-----------------------------------------------------------------------------
def _XMLToStruct(element, struct_type = None):
    """Convert an ElementTree to a ctypes Struct

    If struct_type is not specified then element['__type__']
    will be used for the ctypes struct type"""


    # handle if we are passed in an element or a dictionary
    try:
        attribs = element.attrib
    except AttributeError:
        attribs = element

    # if the type has not been passed in
    if not struct_type:
        # get the type and create an instance of the type
        struct = globals()[attribs["__type__"]]()
    else:
        # create an instance of the type
        struct = globals()[struct_type]()

    # get the attribute and set them upper case
    struct_attribs = dict([(at.upper(), at) for at in dir(struct)])

    # for each of the attributes in the element
    for prop_name in attribs:

        # get the value
        val = attribs[prop_name]

        # if the value ends with "_long"
        if prop_name.endswith("_LONG"):
            # get an long attribute out of the value
            val = int(val)
            prop_name = prop_name[:-5]

        # if the value is a string
        elif isinstance(val, str):
            # make sure it if Unicode
            val = str(val)

        # now we can have all upper case attribute name
        # but structure name will not be upper case
        if prop_name.upper() in struct_attribs:
            prop_name = struct_attribs[prop_name.upper()]

            # set the appropriate attribute of the Struct
            setattr(struct, prop_name, val)

    # reutrn the struct
    return struct



#====================================================================
def _OLD_XMLToTitles(element):
    "For OLD XML files convert the titles as a list"
    # get all the attribute names
    title_names = list(element.keys())

    # sort them to make sure we get them in the right order
    title_names.sort()

    # build up the array
    titles = []
    for name in title_names:
        val = element[name]
        val = val.replace('\\n', '\n')
        val = val.replace('\\x12', '\x12')
        val = val.replace('\\\\', '\\')

        titles.append(str(val))

    return titles


#====================================================================
# TODO: this function should be broken up into smaller functions
#       for each type of processing e.g.
#       ElementTo
def _ExtractProperties(properties, prop_name, prop_value):
    """Hmmm - confusing - can't remember exactly how
    all these similar functions call each other"""

    # get the base property name and number if it in the form
    #  "PROPNAME_00001" = ('PROPNAME', 1)
    prop_name, reqd_index = _SplitNumber(prop_name)

    # if there is no required index, and the property
    # was not already set - then just set it

    # if this is an indexed member of a list
    if reqd_index == None:
        # Have we hit a property with this name already
        if prop_name in properties:
            # try to append current value to the property
            try:
                properties[prop_name].append(prop_value)

            # if that fails then we need to make sure that
            # the curruen property is a list and then
            # append it
            except AttributeError:
                new_val = [properties[prop_name], prop_value]
                properties[prop_name] = new_val
        # No index, no previous property with that name
        #  - just set the property
        else:
            properties[prop_name] = prop_value

    # OK - so it HAS an index
    else:

        # make sure that the property is a list
        properties.setdefault(prop_name, [])

        # make sure that the list has enough elements
        while 1:
            if len(properties[prop_name]) <= reqd_index:
                properties[prop_name].append('')
            else:
                break

        # put our value in at the right index
        properties[prop_name][reqd_index] = prop_value


#====================================================================
def _GetAttributes(element):
    "Get the attributes from an element"

    properties = {}

    # get all the attributes
    for attrib_name, val in list(element.attrib.items()):

        # if it is 'Long' element convert it to an long
        if attrib_name.endswith("_LONG"):
            val = int(val)
            attrib_name = attrib_name[:-5]

        else:
            # otherwise it is a string - make sure we get it as a unicode string
            val = _UnEscapeSpecials(val)

        _ExtractProperties(properties, attrib_name, val)

    return properties


#====================================================================
number = re.compile(r"^(.*)_(\d{5})$")
def _SplitNumber(prop_name):
    """Return (string, number) for a prop_name in the format string_number

    The number part has to be 5 digits long
    None is returned if there is no _number part

    e.g.
    >>> _SplitNumber("NoNumber")
    ('NoNumber', None)
    >>> _SplitNumber("Anumber_00003")
    ('Anumber', 3)
    >>> _SplitNumber("notEnoughDigits_0003")
    ('notEnoughDigits_0003', None)
    """
    found = number.search(prop_name)

    if not found:
        return prop_name, None

    return found.group(1), int(found.group(2))



#====================================================================
def _ReadXMLStructure(control_element):
    """Convert an element into nested Python objects

    The values will be returned in a dictionary as following:

     - the attributes will be items of the dictionary
       for each subelement

       + if it has a __type__ attribute then it is converted to a
         ctypes structure
       + if the element tag ends with _IMG then it is converted to
         a PIL image

     - If there are elements with the same name or attributes with
       ordering e.g. texts_00001, texts_00002 they will be put into a
       list (in the correct order)
    """

    # get the attributes for the current element
    properties = _GetAttributes(control_element)

    for elem in control_element:
        # if it is a ctypes structure
        if "__type__" in elem.attrib:
            # create a new instance of the correct type

            # grab the data
            propval = _XMLToStruct(elem)

        elif elem.tag.endswith("_IMG"):
            elem.tag = elem.tag[:-4]

            # get image Attribs
            img = _GetAttributes(elem)
            data = img['data'].decode('base64').decode('bz2')

            propval = PIL.Image.fromstring(
                img['mode'],
                (img['size_x'], img['size_y']),
                data)

        elif elem.tag.endswith("_LIST"):
            # All this is just to handle the edge case of
            # an empty list
            elem.tag = elem.tag[:-5]

            # read the structure
            propval = _ReadXMLStructure(elem)

            # if it was empty then convert the returned dict
            # to a list
            if propval == {}:
                propval = list()

            # otherwise extract the list out of the returned dict
            else:
                propval = propval[elem.tag]

        else:
            propval = _ReadXMLStructure(elem)

        _ExtractProperties(properties, elem.tag, propval)

    return properties




#====================================================================
def ReadPropertiesFromFile(filename):
    """Return an list of controls from XML file filename"""

    # parse the file
    parsed = ElementTree().parse(filename)

    # Return the list that has been stored under 'CONTROL'
    props =  _ReadXMLStructure(parsed)['CONTROL']
    if not isinstance(props, list):
        props = [props]


    # it is an old XML so let's fix it up a little
    if "_version_" not in parsed.attrib:

        # find each of the control elements
        for ctrl_prop in props:

            ctrl_prop['Fonts'] = [_XMLToStruct(ctrl_prop['FONT'], "LOGFONTW"), ]

            ctrl_prop['Rectangle'] = \
                _XMLToStruct(ctrl_prop["RECTANGLE"], "RECT")

            ctrl_prop['ClientRects'] = [
                _XMLToStruct(ctrl_prop["CLIENTRECT"], "RECT"),]

            ctrl_prop['Texts'] = _OLD_XMLToTitles(ctrl_prop["TITLES"])

            ctrl_prop['Class'] = ctrl_prop['CLASS']
            ctrl_prop['ContextHelpID'] = ctrl_prop['HELPID']
            ctrl_prop['ControlID'] = ctrl_prop['CTRLID']
            ctrl_prop['ExStyle'] = ctrl_prop['EXSTYLE']
            ctrl_prop['FriendlyClassName'] = ctrl_prop['FRIENDLYCLASS']
            ctrl_prop['IsUnicode'] = ctrl_prop['ISUNICODE']
            ctrl_prop['IsVisible'] = ctrl_prop['ISVISIBLE']
            ctrl_prop['Style'] = ctrl_prop['STYLE']
            ctrl_prop['UserData'] = ctrl_prop['USERDATA']

            for prop_name in [
                'CLASS',
                'CLIENTRECT',
                'CTRLID',
                'EXSTYLE',
                'FONT',
                'FRIENDLYCLASS',
                'HELPID',
                'ISUNICODE',
                'ISVISIBLE',
                'RECTANGLE',
                'STYLE',
                'TITLES',
                'USERDATA',
                ]:
                del(ctrl_prop[prop_name])

    return props



########NEW FILE########
