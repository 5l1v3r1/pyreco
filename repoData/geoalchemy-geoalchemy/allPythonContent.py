__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# GeoAlchemy documentation build configuration file, created by
# sphinx-quickstart on Tue Aug  4 21:27:34 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.jsmath']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'GeoAlchemy'
copyright = u'2009, Sanjiv Singh'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.7.3'
# The full version, including alpha/beta/rc tags.
release = '0.7.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'GeoAlchemydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'GeoAlchemy.tex', u'GeoAlchemy Documentation',
   u'Sanjiv Singh', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

jsmath_path = '_static/jsMath/jsMath.js'
script_files = '_static/remove.js'


########NEW FILE########
__FILENAME__ = mysql
from unittest import TestCase
from binascii import b2a_hex
from sqlalchemy import (create_engine, MetaData, Column, Integer, String,
        Unicode, Numeric, func, literal, select)
from sqlalchemy.orm import sessionmaker, column_property
from sqlalchemy.ext.declarative import declarative_base

from geoalchemy import (Geometry, Point, LineString, Polygon,
		GeometryColumn, GeometryDDL, WKTSpatialElement)

engine = create_engine('mysql://gis:gis@localhost/gis', echo=True)
metadata = MetaData(engine)
session = sessionmaker(bind=engine)()
Base = declarative_base(metadata=metadata)

class Road(Base):
    __tablename__ = 'roads'

    road_id = Column(Integer, autoincrement=True, primary_key=True)
    road_name = Column(Unicode(40))
    road_geom = GeometryColumn(LineString(2), nullable=False)

class Lake(Base):
    __tablename__ = 'lakes'

    lake_id = Column(Integer, autoincrement=True, primary_key=True)
    lake_name = Column(Unicode(40))
    lake_geom = GeometryColumn(Polygon(2), nullable=False)

class Spot(Base):
    __tablename__ = 'spots'

    spot_id = Column(Integer, autoincrement=True, primary_key=True)
    spot_height = Column(Numeric)
    spot_location = GeometryColumn(Point(2), nullable=False)

# enable the DDL extension, which allows CREATE/DROP operations
# to work correctly.  This is not needed if working with externally
# defined tables.    
GeometryDDL(Road.__table__)
GeometryDDL(Lake.__table__)
GeometryDDL(Spot.__table__)

metadata.drop_all()
metadata.create_all()

# Add objects.  We can use strings...
session.add_all([
            Road(road_name='Jeff Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Peter Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Geordie Rd', road_geom='LINESTRING(-89.2232485796178 42.6420382611465,-89.2449842484076 42.9179140573248,-89.2316084522293 43.106847178344,-89.0710987261147 43.243949044586,-89.092834566879 43.2957802993631,-89.092834566879 43.2957802993631,-89.0309715095541 43.3175159681529)'),
            Road(road_name='Paul St', road_geom='LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147)'),
            Road(road_name='Graeme Ave', road_geom='LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)'),
            Road(road_name='Phil Tce', road_geom='LINESTRING(-88.9356689617834 42.9363057770701,-88.9824842484076 43.0366242484076,-88.9222931656051 43.1085191528662,-88.8487262866242 43.0449841210191)'),
            Lake(lake_name='My Lake', lake_geom='POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))'),
            Lake(lake_name='Lake White', lake_geom='POLYGON((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542))'),
            Lake(lake_name='Lake Blue', lake_geom='POLYGON((-89.0694267515924 43.1335987261147,-89.1078821656051 43.1135350318471,-89.1329617834395 43.0884554140127,-89.1312898089172 43.0466560509554,-89.112898089172 43.0132165605096,-89.0694267515924 42.9898089171975,-89.0343152866242 42.953025477707,-89.0209394904459 42.9179140127389,-89.0042197452229 42.8961783439491,-88.9774681528663 42.8644108280255,-88.9440286624204 42.8292993630573,-88.9072452229299 42.8142515923567,-88.8687898089172 42.815923566879,-88.8687898089172 42.815923566879,-88.8102707006369 42.8343152866242,-88.7734872611465 42.8710987261147,-88.7517515923567 42.9145700636943,-88.7433917197452 42.9730891719745,-88.7517515923567 43.0299363057325,-88.7734872611465 43.0867834394905,-88.7885352038217 43.158678388535,-88.8738057324841 43.1620222929936,-88.947372611465 43.1937898089172,-89.0042197452229 43.2138535031847,-89.0410031847134 43.2389331210191,-89.0710987261147 43.243949044586,-89.0660828025478 43.2238853503185,-89.0543789808917 43.203821656051,-89.0376592356688 43.175398089172,-89.0292993630573 43.1519904458599,-89.0376592356688 43.1369426751592,-89.0393312101911 43.1386146496815,-89.0393312101911 43.1386146496815,-89.0510350318471 43.1335987261147,-89.0694267515924 43.1335987261147))'),
            Lake(lake_name='Lake Deep', lake_geom='POLYGON((-88.9122611464968 43.038296178344,-88.9222929936306 43.0399681528663,-88.9323248407643 43.0282643312102,-88.9206210191083 43.0182324840764,-88.9105891719745 43.0165605095542,-88.9005573248408 43.0232484076433,-88.9072452229299 43.0282643312102,-88.9122611464968 43.038296178344))'),
            Spot(spot_height=420.40, spot_location='POINT(-88.5945861592357 42.9480095987261)'),
            Spot(spot_height=102.34, spot_location='POINT(-88.9055734203822 43.0048567324841)'),
            Spot(spot_height=388.62, spot_location='POINT(-89.201512910828 43.1051752038217)'),
            Spot(spot_height=454.66, spot_location='POINT(-88.3304141847134 42.6269904904459)'),
])

# or use an explicit WKTSpatialElement (similar to saying func.GeomFromText())
r = Road(road_name='Dave Cres', road_geom=WKTSpatialElement('LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)', 4326))
session.add(r)
session.commit()


########NEW FILE########
__FILENAME__ = postgis-non-declarative
from sqlalchemy import *
from sqlalchemy.orm import *

from geoalchemy import *
from geoalchemy.postgis import PGComparator

engine = create_engine('postgresql://gis:gis@localhost/gis', echo=True)
metadata = MetaData(engine)
session = sessionmaker(bind=engine)()

# define table
spots_table = Table('spots', metadata,
                    Column('spot_id', Integer, primary_key=True),
                    Column('spot_height', Numeric),
                    GeometryExtensionColumn('spot_location', Geometry(2)))

# define class
class Spot(object):
    def __init__(self, spot_id=None, spot_height=None, spot_location=None):
        self.spot_id = spot_id
        self.spot_height = spot_height
        self.spot_location = spot_location

# set up the mapping between table and class       
mapper(Spot, spots_table, properties={
            'spot_location': GeometryColumn(spots_table.c.spot_location, 
                                            comparator=PGComparator)}) 

# enable the DDL extension, which allows CREATE/DROP operations
# to work correctly.  This is not needed if working with externally
# defined tables.    
GeometryDDL(spots_table)


metadata.drop_all()
metadata.create_all()

# Add objects.  We can use strings...
session.add_all([
            Spot(spot_height=420.40, spot_location='POINT(-88.5945861592357 42.9480095987261)'),
            Spot(spot_height=102.34, spot_location='POINT(-88.9055734203822 43.0048567324841)'),
            Spot(spot_height=388.62, spot_location='POINT(-89.201512910828 43.1051752038217)'),
            Spot(spot_height=454.66, spot_location='POINT(-88.3304141847134 42.6269904904459)'),
])

session.commit()

s = session.query(Spot).get(1)
print session.scalar(s.spot_location.wkt)

s = session.query(Spot).filter(Spot.spot_location == 'POINT(-88.5945861592357 42.9480095987261)').first()
print session.scalar(s.spot_location.wkt)
print session.scalar(functions.geometry_type(s.spot_location))
########NEW FILE########
__FILENAME__ = postgis
from sqlalchemy import create_engine, MetaData, Column, Integer, String, Numeric
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

from geoalchemy import GeometryColumn, LineString, Polygon, Point, \
        GeometryCollection, GeometryDDL, WKTSpatialElement
from geoalchemy.functions import functions
from geoalchemy.postgis import pg_functions

engine = create_engine('postgresql://gis:gis@localhost/gis', echo=True)
metadata = MetaData(engine)
session = sessionmaker(bind=engine)()
Base = declarative_base(metadata=metadata)

class Road(Base):
    __tablename__ = 'roads'

    road_id = Column(Integer, primary_key=True)
    road_name = Column(String)
    road_geom = GeometryColumn(LineString(2))

class Lake(Base):
    __tablename__ = 'lakes'

    lake_id = Column(Integer, primary_key=True)
    lake_name = Column(String)
    lake_geom = GeometryColumn(Polygon(2))

class Spot(Base):
    __tablename__ = 'spots'

    spot_id = Column(Integer, primary_key=True)
    spot_height = Column(Numeric)
    spot_location = GeometryColumn(Point(2))

class Shape(Base):
    __tablename__ = 'shapes'

    shape_id = Column(Integer, primary_key=True)
    shape_name = Column(String)
    shape_geom = GeometryColumn(GeometryCollection(2))

class Overlap(Base):
    __tablename__ = 'overlap'

    id = Column(Integer, primary_key=True)
    geom = GeometryColumn(Polygon(2))

# enable the DDL extension, which allows CREATE/DROP operations
# to work correctly.  This is not needed if working with externally
# defined tables.    
GeometryDDL(Road.__table__)
GeometryDDL(Lake.__table__)
GeometryDDL(Spot.__table__)
GeometryDDL(Shape.__table__)
GeometryDDL(Overlap.__table__)

metadata.drop_all()
metadata.create_all()

# Add objects.  We can use strings...
session.add_all([
            Road(road_name='Jeff Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Peter Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Geordie Rd', road_geom='LINESTRING(-89.2232485796178 42.6420382611465,-89.2449842484076 42.9179140573248,-89.2316084522293 43.106847178344,-89.0710987261147 43.243949044586,-89.092834566879 43.2957802993631,-89.092834566879 43.2957802993631,-89.0309715095541 43.3175159681529)'),
            Road(road_name='Paul St', road_geom='LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147)'),
            Road(road_name='Graeme Ave', road_geom='LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)'),
            Road(road_name='Phil Tce', road_geom='LINESTRING(-88.9356689617834 42.9363057770701,-88.9824842484076 43.0366242484076,-88.9222931656051 43.1085191528662,-88.8487262866242 43.0449841210191)'),
            Lake(lake_name='My Lake', lake_geom='POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))'),
            Lake(lake_name='Lake White', lake_geom='POLYGON((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542))'),
            Lake(lake_name='Lake Blue', lake_geom='POLYGON((-89.0694267515924 43.1335987261147,-89.1078821656051 43.1135350318471,-89.1329617834395 43.0884554140127,-89.1312898089172 43.0466560509554,-89.112898089172 43.0132165605096,-89.0694267515924 42.9898089171975,-89.0343152866242 42.953025477707,-89.0209394904459 42.9179140127389,-89.0042197452229 42.8961783439491,-88.9774681528663 42.8644108280255,-88.9440286624204 42.8292993630573,-88.9072452229299 42.8142515923567,-88.8687898089172 42.815923566879,-88.8687898089172 42.815923566879,-88.8102707006369 42.8343152866242,-88.7734872611465 42.8710987261147,-88.7517515923567 42.9145700636943,-88.7433917197452 42.9730891719745,-88.7517515923567 43.0299363057325,-88.7734872611465 43.0867834394905,-88.7885352038217 43.158678388535,-88.8738057324841 43.1620222929936,-88.947372611465 43.1937898089172,-89.0042197452229 43.2138535031847,-89.0410031847134 43.2389331210191,-89.0710987261147 43.243949044586,-89.0660828025478 43.2238853503185,-89.0543789808917 43.203821656051,-89.0376592356688 43.175398089172,-89.0292993630573 43.1519904458599,-89.0376592356688 43.1369426751592,-89.0393312101911 43.1386146496815,-89.0393312101911 43.1386146496815,-89.0510350318471 43.1335987261147,-89.0694267515924 43.1335987261147))'),
            Lake(lake_name='Lake Deep', lake_geom='POLYGON((-88.9122611464968 43.038296178344,-88.9222929936306 43.0399681528663,-88.9323248407643 43.0282643312102,-88.9206210191083 43.0182324840764,-88.9105891719745 43.0165605095542,-88.9005573248408 43.0232484076433,-88.9072452229299 43.0282643312102,-88.9122611464968 43.038296178344))'),
            Spot(spot_height=420.40, spot_location='POINT(-88.5945861592357 42.9480095987261)'),
            Spot(spot_height=102.34, spot_location='POINT(-88.9055734203822 43.0048567324841)'),
            Spot(spot_height=388.62, spot_location='POINT(-89.201512910828 43.1051752038217)'),
            Spot(spot_height=454.66, spot_location='POINT(-88.3304141847134 42.6269904904459)'),
            Shape(shape_name='My Shapes', shape_geom='GEOMETRYCOLLECTION(POINT(-88.3304141847134 42.6269904904459),LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147),POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936)))'),
            Shape(shape_name='Jogging Track', shape_geom='GEOMETRYCOLLECTION(LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147))'),
            Shape(shape_name='Play Ground', shape_geom='GEOMETRYCOLLECTION(POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936)))'),
            Overlap(geom='POLYGON((0 0,0 50,50 50,50 0,0 0))'),
            Overlap(geom='POLYGON((20 20,20 80,80 80,80 20,20 20))'),
])

# or use an explicit WKTSpatialElement (similar to saying func.GeomFromText())
r = Road(road_name='Dave Cres', road_geom=WKTSpatialElement('LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)', 4326))
session.add(r)
session.commit()


print session.query(functions.extent(Overlap.geom)).filter(Overlap.geom != None).one() 
print session.query(pg_functions.wkt(functions.union(Overlap.geom))).filter(Overlap.geom != None).one()
print session.query(pg_functions.wkt(functions.collect(Overlap.geom))).filter(Overlap.geom != None).one()

########NEW FILE########
__FILENAME__ = reflection
from sqlalchemy import *
from sqlalchemy.orm import *
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime
from geoalchemy import *

# Setup the database engine and session
engine = create_engine('postgresql://gis:gis@localhost/gis', echo=True)
session = sessionmaker(bind=engine)()

# Setup the metadata and declarative extension
metadata = MetaData(engine)
Base = declarative_base(metadata=metadata)


# Define the model classes
class Spot(Base):
    __tablename__ = 'spots'
    __table_args__ = {'autoload': True}
    geom = GeometryColumn(Point(2))

class Road(Base):
    __tablename__ = 'roads'
    __table_args__ = {'autoload': True}
    geom = GeometryColumn(LineString(2))

class Lake(Base):
    __tablename__ = 'lakes'
    __table_args__ = {'autoload': True}
    geom = GeometryColumn(Polygon(2))



########NEW FILE########
__FILENAME__ = spatialite
from unittest import TestCase
from binascii import b2a_hex
from sqlalchemy import (create_engine, MetaData, Column, Integer, String,
        Numeric, func, literal, select)
from sqlalchemy.orm import sessionmaker, column_property
from sqlalchemy.ext.declarative import declarative_base

from pysqlite2 import dbapi2 as sqlite
from geoalchemy import (Geometry, GeometryColumn, GeometryDDL,
	WKTSpatialElement)


engine = create_engine('sqlite:////tmp/devdata.db', module=sqlite, echo=True)
connection = engine.raw_connection().connection
connection.enable_load_extension(True)
metadata = MetaData(engine)
session = sessionmaker(bind=engine)()
session.execute("select load_extension('/usr/local/lib/libspatialite.so')")
session.execute("SELECT InitSpatialMetaData();")
session.execute("INSERT INTO spatial_ref_sys (srid, auth_name, auth_srid, ref_sys_name, proj4text) VALUES (4326, 'epsg', 4326, 'WGS 84', '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs');")
Base = declarative_base(metadata=metadata)

class Road(Base):
    __tablename__ = 'roads'

    road_id = Column(Integer, primary_key=True)
    road_name = Column(String)
    road_geom = GeometryColumn(Geometry(2))

class Lake(Base):
    __tablename__ = 'lakes'

    lake_id = Column(Integer, primary_key=True)
    lake_name = Column(String)
    lake_geom = GeometryColumn(Geometry(2))

class Spot(Base):
    __tablename__ = 'spots'

    spot_id = Column(Integer, primary_key=True)
    spot_height = Column(Numeric)
    spot_location = GeometryColumn(Geometry(2))

# enable the DDL extension, which allows CREATE/DROP operations
# to work correctly.  This is not needed if working with externally
# defined tables.    
GeometryDDL(Road.__table__)
GeometryDDL(Lake.__table__)
GeometryDDL(Spot.__table__)

metadata.drop_all()
metadata.create_all()

# Add objects.  We can use strings...
session.add_all([
            Road(road_name='Jeff Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Peter Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Geordie Rd', road_geom='LINESTRING(-89.2232485796178 42.6420382611465,-89.2449842484076 42.9179140573248,-89.2316084522293 43.106847178344,-89.0710987261147 43.243949044586,-89.092834566879 43.2957802993631,-89.092834566879 43.2957802993631,-89.0309715095541 43.3175159681529)'),
            Road(road_name='Paul St', road_geom='LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147)'),
            Road(road_name='Graeme Ave', road_geom='LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)'),
            Road(road_name='Phil Tce', road_geom='LINESTRING(-88.9356689617834 42.9363057770701,-88.9824842484076 43.0366242484076,-88.9222931656051 43.1085191528662,-88.8487262866242 43.0449841210191)'),
            Lake(lake_name='My Lake', lake_geom='POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))'),
            Lake(lake_name='Lake White', lake_geom='POLYGON((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542))'),
            Lake(lake_name='Lake Blue', lake_geom='POLYGON((-89.0694267515924 43.1335987261147,-89.1078821656051 43.1135350318471,-89.1329617834395 43.0884554140127,-89.1312898089172 43.0466560509554,-89.112898089172 43.0132165605096,-89.0694267515924 42.9898089171975,-89.0343152866242 42.953025477707,-89.0209394904459 42.9179140127389,-89.0042197452229 42.8961783439491,-88.9774681528663 42.8644108280255,-88.9440286624204 42.8292993630573,-88.9072452229299 42.8142515923567,-88.8687898089172 42.815923566879,-88.8687898089172 42.815923566879,-88.8102707006369 42.8343152866242,-88.7734872611465 42.8710987261147,-88.7517515923567 42.9145700636943,-88.7433917197452 42.9730891719745,-88.7517515923567 43.0299363057325,-88.7734872611465 43.0867834394905,-88.7885352038217 43.158678388535,-88.8738057324841 43.1620222929936,-88.947372611465 43.1937898089172,-89.0042197452229 43.2138535031847,-89.0410031847134 43.2389331210191,-89.0710987261147 43.243949044586,-89.0660828025478 43.2238853503185,-89.0543789808917 43.203821656051,-89.0376592356688 43.175398089172,-89.0292993630573 43.1519904458599,-89.0376592356688 43.1369426751592,-89.0393312101911 43.1386146496815,-89.0393312101911 43.1386146496815,-89.0510350318471 43.1335987261147,-89.0694267515924 43.1335987261147))'),
            Lake(lake_name='Lake Deep', lake_geom='POLYGON((-88.9122611464968 43.038296178344,-88.9222929936306 43.0399681528663,-88.9323248407643 43.0282643312102,-88.9206210191083 43.0182324840764,-88.9105891719745 43.0165605095542,-88.9005573248408 43.0232484076433,-88.9072452229299 43.0282643312102,-88.9122611464968 43.038296178344))'),
            Spot(spot_height=420.40, spot_location='POINT(-88.5945861592357 42.9480095987261)'),
            Spot(spot_height=102.34, spot_location='POINT(-88.9055734203822 43.0048567324841)'),
            Spot(spot_height=388.62, spot_location='POINT(-89.201512910828 43.1051752038217)'),
            Spot(spot_height=454.66, spot_location='POINT(-88.3304141847134 42.6269904904459)'),
])

# or use an explicit WKTSpatialElement (similar to saying func.GeomFromText())
r = Road(road_name='Dave Cres', road_geom=WKTSpatialElement('LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)', 4326))
session.add(r)
session.commit()


########NEW FILE########
__FILENAME__ = tutorial
from sqlalchemy import *
from sqlalchemy.orm import *
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime
from geoalchemy import *
from geoalchemy.postgis import PGComparator


# Setup the database engine and session
engine = create_engine('postgresql://gis:gis@localhost/gis', echo=True)
session = sessionmaker(bind=engine)()

# Setup the metadata and declarative extension
metadata = MetaData(engine)
Base = declarative_base(metadata=metadata)


# Define the model classes
class Spot(Base):
    __tablename__ = 'spots'
    id = Column(Integer, primary_key=True)
    name = Column(Unicode, nullable=False)
    height = Column(Integer)
    created = Column(DateTime, default=datetime.now())
    geom = GeometryColumn(Point(2), comparator=PGComparator)

class Road(Base):
    __tablename__ = 'roads'
    id = Column(Integer, primary_key=True)
    name = Column(Unicode, nullable=False)
    width = Column(Integer)
    created = Column(DateTime, default=datetime.now())
    geom = GeometryColumn(LineString(2), comparator=PGComparator)

class Lake(Base):
    __tablename__ = 'lakes'
    id = Column(Integer, primary_key=True)
    name = Column(Unicode, nullable=False)
    depth = Column(Integer)
    created = Column(DateTime, default=datetime.now())
    geom = GeometryColumn(Polygon(2), comparator=PGComparator)

# DDL Extensions for geometry specific DDL
GeometryDDL(Spot.__table__)
GeometryDDL(Road.__table__)
GeometryDDL(Lake.__table__)

# Drop and create database objects
metadata.drop_all()
metadata.create_all()

# Create a few gis objects in the database
wkt_spot1 = "POINT(-81.40 38.08)"
spot1 = Spot(name="Gas Station", height=240.8, geom=WKTSpatialElement(wkt_spot1))
wkt_spot2 = "POINT(-81.42 37.65)"
spot2 = Spot(name="Restaurant", height=233.6, geom=WKTSpatialElement(wkt_spot2))

wkt_road1 = "LINESTRING(-80.3 38.2, -81.03 38.04, -81.2 37.89)"
road1 = Road(name="Peter St", width=6.0, geom=WKTSpatialElement(wkt_road1))
wkt_road2 = "LINESTRING(-79.8 38.5, -80.03 38.2, -80.2 37.89)"
road2 = Road(name="George Ave", width=8.0, geom=WKTSpatialElement(wkt_road2))

wkt_lake1 = "POLYGON((-81.3 37.2, -80.63 38.04, -80.02 37.49, -81.3 37.2))"
lake1 = Lake(name="Lake Juliet", depth=36.0, geom=WKTSpatialElement(wkt_lake1))
wkt_lake2 = "POLYGON((-79.8 38.5, -80.03 38.2, -80.02 37.89, -79.92 37.75, -79.8 38.5))"
lake2 = Lake(name="Lake Blue", depth=58.0, geom=WKTSpatialElement(wkt_lake2))

session.add_all([spot1, spot2, road1, road2, lake1, lake2])
session.commit()

# Insert a geometry with a different SRID
geom_spot3 = WKTSpatialElement('POINT(30250865 -610981)', 2249)
spot3 = Spot(name="Park", height=53.2, geom=geom_spot3)
session.add(spot3)
session.commit()

########NEW FILE########
__FILENAME__ = base
from sqlalchemy.orm.properties import ColumnProperty
from sqlalchemy.sql import expression, not_
from sqlalchemy.sql.expression import ColumnClause, literal
from sqlalchemy.types import UserDefinedType
from sqlalchemy.ext.compiler import compiles

from utils import from_wkt
from functions import functions, _get_function, BaseFunction

# Base classes for geoalchemy

class SpatialElement(object):
    """Represents a geometry value."""

    def __str__(self):
        if isinstance(self.desc, SpatialElement):
            return self.desc.desc
        return self.desc

    def __repr__(self):
        return "<%s at 0x%x; %r>" % (self.__class__.__name__, id(self), self.desc)
    
    def __getattr__(self, name):
        return getattr(functions, name)(self)
#
    def __get_wkt(self, session):
        """This method converts the object into a WKT geometry. It takes into
        account that WKTSpatialElement does not have to make a new query
        to retrieve the WKT geometry.
        
        """
        if isinstance(self, WKTSpatialElement):
            # for WKTSpatialElement we don't need to make a new query
            return self.desc 
        elif isinstance(self.desc, WKTSpatialElement):
            return self.desc.desc
        else:
            return session.scalar(self.wkt)       

    def geom_type(self, session):
        wkt = self.__get_wkt(session)
        return from_wkt(wkt)["type"]

    def coords(self, session):
        wkt = self.__get_wkt(session)
        return from_wkt(wkt)["coordinates"]

class WKTSpatialElement(SpatialElement, expression.Function):
    """Represents a Geometry value expressed within application code; i.e. in
    the OGC Well Known Text (WKT) format.
    
    Extends expression.Function so that in a SQL expression context the value 
    is interpreted as 'GeomFromText(value)' or as the equivalent function in the 
    currently used database.
    
    """
    
    def __init__(self, desc, srid=4326, geometry_type='GEOMETRY'):
        assert isinstance(desc, basestring)
        self.desc = desc
        self.srid = srid
        self.geometry_type = geometry_type
        
        expression.Function.__init__(self, "")

    @property
    def geom_wkt(self):
        # directly return WKT value
        return self.desc

@compiles(WKTSpatialElement)
def __compile_wktspatialelement(element, compiler, **kw):
    function = _get_function(element, compiler, (element.desc, element.srid), kw.get('within_columns_clause', False))
    
    return compiler.process(function)

class WKBSpatialElement(SpatialElement, expression.Function):
    """Represents a Geometry value as expressed in the OGC Well
    Known Binary (WKB) format.
    
    Extends expression.Function so that in a SQL expression context the value 
    is interpreted as 'GeomFromWKB(value)' or as the equivalent function in the 
    currently used database .
    
    """
    
    def __init__(self, desc, srid=4326, geometry_type='GEOMETRY'):
        assert isinstance(desc, (basestring, buffer))
        self.desc = desc
        self.srid = srid
        self.geometry_type = geometry_type
        
        expression.Function.__init__(self, "")

@compiles(WKBSpatialElement)
def __compile_wkbspatialelement(element, compiler, **kw):
    from geoalchemy.dialect import DialectManager 
    database_dialect = DialectManager.get_spatial_dialect(compiler.dialect)
    
    function = _get_function(element, compiler, (database_dialect.bind_wkb_value(element), 
                                                 element.srid),
                                                 kw.get('within_columns_clause', False))
    
    return compiler.process(function)


class DBSpatialElement(SpatialElement, expression.Function):
    """This class can be used to wrap a geometry returned by a 
    spatial database operation.
    
    For example:: 
    
        element = DBSpatialElement(session.scalar(r.geom.buffer(10.0)))
        session.scalar(element.wkt)
    
    """
    
    def __init__(self, desc):
        self.desc = desc
        expression.Function.__init__(self, "", desc)

@compiles(DBSpatialElement)
def __compile_dbspatialelement(element, compiler, **kw):
    function = _get_function(element, compiler, [literal(element.desc)], 
                                        kw.get('within_columns_clause', False))
    
    return compiler.process(function)

class PersistentSpatialElement(SpatialElement):
    """Represents a Geometry value loaded from the database."""
    
    def __init__(self, desc):
        self.desc = desc
    
    @property    
    def geom_wkb(self):
        if self.desc is not None and isinstance(self.desc, WKBSpatialElement):
            return self.desc.desc
        else:
            return None
    
    @property    
    def geom_wkt(self):
        if self.desc is not None and isinstance(self.desc, WKTSpatialElement):
            return self.desc.desc
        else:
            return None

class GeometryBase(UserDefinedType):
    """Base Geometry column type for all spatial databases.
    """

    name = 'GEOMETRY'

    def __init__(self, dimension=2, srid=4326, spatial_index=True,
                 wkt_internal=False, **kwargs):
        self.dimension = dimension
        self.srid = srid
        self.spatial_index = spatial_index
        self.wkt_internal = wkt_internal
        self.kwargs = kwargs
        super(GeometryBase, self).__init__()

    def get_col_spec(self):
        return self.name
    
    def bind_processor(self, dialect):
        def process(value):
            if value is not None:
                if isinstance(value, SpatialElement):
                    if isinstance(value.desc, SpatialElement):
                        return value.desc.desc
                    return value.desc
                else:
                    return value
            else:
                return value
        return process
        
    def result_processor(self, dialect, coltype=None):
        def process(value):
            if value is not None:
                return PersistentSpatialElement(value)
            else:
                return value
        return process

    def adapt(self, cls, **kwargs):
        return cls(dimension=self.dimension, srid=self.srid,
                   spatial_index=self.spatial_index,
                   wkt_internal=self.wkt_internal, **self.kwargs)

# ORM integration

def _to_gis(value, srid_db):
    """Interpret a value as a GIS-compatible construct."""

    if hasattr(value, '__clause_element__'):
        return value.__clause_element__()
    elif isinstance(value, SpatialElement):
        if isinstance(value.desc, (WKBSpatialElement, WKTSpatialElement)):
            return _check_srid(value.desc, srid_db)
        return _check_srid(value, srid_db)
    elif isinstance(value, basestring):
        return _check_srid(WKTSpatialElement(value), srid_db)
    elif isinstance(value, expression.ClauseElement):
        return value
    elif value is None:
        return None
    else:
        raise Exception("Invalid type")
    
def _check_srid(spatial_element, srid_db):
    """Check if the SRID of the spatial element which we are about to insert
    into the database equals the SRID used for the geometry column.
    If not, a transformation is added.
    """
    if srid_db is None or not hasattr(spatial_element, 'srid') or \
            isinstance(spatial_element.srid, BaseFunction):
        return spatial_element
    
    if spatial_element.srid == srid_db:
        return spatial_element
    else:
        return functions.transform(spatial_element, srid_db)

class RawColumn(ColumnClause):
    """This class is used to wrap a geometry column, so that
    no conversion to WKB is added, see SpatialComparator.RAW
    """
    def __init__(self, column):
        self.column = column
        ColumnClause.__init__(self, column.name, column.table)
        
    def _make_proxy(self, selectable, name=None):
        return self.column._make_proxy(selectable, name)
        
@compiles(RawColumn)
def __compile_rawcolumn(rawcolumn, compiler, **kw):
    return compiler.visit_column(rawcolumn.column)

class SpatialComparator(ColumnProperty.ColumnComparator):
    """Intercepts standard Column operators on mapped class attributes
        and overrides their behavior.
        
        A comparator class makes sure that queries like 
        "session.query(Lake).filter(Lake.lake_geom.gcontains(..)).all()" can be executed.
    """
    
    @property
    def RAW(self):
        """For queries like 'select extent(spots.spot_location) from spots' the 
        geometry column should not be surrounded by 'AsBinary(..)'. If 'RAW' is
        called on a geometry column, this column wont't be converted to WKB::
        
            session.query(func.extent(Spot.spot_location.RAW)).first() 
        
        """
        return RawColumn(self.__clause_element__())
    
    def __getattr__(self, name):
        return getattr(functions, name)(self)
        
    # override the __eq__() operator (allows to use '==' on geometries)
    def __eq__(self, other): 
        if other is None:
            return self.op("IS")(None)
        return functions.equals(self, other)
    
    def __ne__(self, other):
        if other is None:
            return self.op("IS NOT")(None)
        return not_(functions.equals(self, other))

########NEW FILE########
__FILENAME__ = dialect
from sqlalchemy.dialects.postgresql.base import PGDialect
from sqlalchemy.dialects.sqlite.base import SQLiteDialect
from sqlalchemy.dialects.mysql.base import MySQLDialect
from sqlalchemy.dialects.oracle.base import OracleDialect
from sqlalchemy.dialects.mssql.base import MSDialect
from sqlalchemy import func
from geoalchemy.functions import functions
from geoalchemy.base import WKTSpatialElement, WKBSpatialElement,\
    DBSpatialElement

class SpatialDialect(object):
    """This class bundles all required classes and methods to support 
    a database dialect. It is supposed to be subclassed.
    The child classes must be added to DialectManager.__initialize_dialects(),
    so that they can be used.
    
    """
    
    __functions = {
                   functions.wkt: 'AsText',
                   WKTSpatialElement : 'GeomFromText',
                   functions.wkb: 'AsBinary',
                   WKBSpatialElement : 'GeomFromWKB',
                   DBSpatialElement : '',
                   functions.dimension : 'Dimension',
                   functions.srid : 'SRID',
                   functions.geometry_type : 'GeometryType',
                   functions.is_valid : 'IsValid',
                   functions.is_empty : 'IsEmpty',
                   functions.is_simple : 'IsSimple',
                   functions.is_closed : 'IsClosed',
                   functions.is_ring : 'IsRing',
                   functions.num_points : 'NumPoints',
                   functions.point_n : 'PointN',
                   functions.length : 'Length',
                   functions.area : 'Area',
                   functions.x : 'X',
                   functions.y : 'Y',
                   functions.centroid : 'Centroid',
                   functions.boundary : 'Boundary',
                   functions.buffer : 'Buffer',
                   functions.convex_hull : 'ConvexHull',
                   functions.envelope : 'Envelope',
                   functions.start_point : 'StartPoint',
                   functions.end_point : 'EndPoint',
                   functions.transform : 'Transform',
                   functions.equals : 'Equals',
                   functions.distance : 'Distance',
                   functions.within_distance : 'DWithin',
                   functions.disjoint : 'Disjoint',
                   functions.intersects : 'Intersects',
                   functions.touches : 'Touches',
                   functions.crosses : 'Crosses',
                   functions.within : 'Within',
                   functions.overlaps : 'Overlaps',
                   functions.gcontains : 'Contains',
                   functions.covers : 'Covers',
                   functions.covered_by : 'CoveredBy',
                   functions.intersection : 'Intersections',
                   functions.union : None,
                   functions.collect : None,
                   functions.extent : None,
                   functions._within_distance: lambda compiler, geom1, geom2, dist:
                                                   func.DWithin(geom1, geom2, dist)
                  }
    
    def get_function(self, function_class):
        """This method is called to translate a generic function into a database
        dialect specific function.
        
        It either returns a string, a list or a method that returns a Function object.
        
            - String: A function name, e.g.::
                    
                    functions.wkb: 'SDO_UTIL.TO_WKBGEOMETRY'
            
            - List: A list of function names that are called cascaded, e.g.::
            
                    functions.wkt: ['TO_CHAR', 'SDO_UTIL.TO_WKTGEOMETRY'] is compiled as:
                    TO_CHAR(SDO_UTIL.TO_WKTGEOMETRY(..))
                    
            - Method: A method that accepts a list/set of arguments and returns a Function object, e.g.::
            
                    functions.equals : lambda params, within_column_clause : (func.SDO_EQUAL(*params) == 'TRUE')
    
        """
        if self._get_function_mapping() is not None:
            if function_class in self._get_function_mapping():
                if self._get_function_mapping()[function_class] is None:
                    raise NotImplementedError("Operation '%s' is not supported for '%s'" 
                                                % (function_class.__name__, self.__class__.__name__)) 
                else:
                    return self._get_function_mapping()[function_class]
        
        return SpatialDialect.__functions[function_class]
    
    def is_member_function(self, function_class):   
        """Returns True if the passed-in function should be called as member 
        function. E.g. ``Point.the_geom.dims`` is compiled as
        ``points.the_geom.Get_Dims()``.

        """
        return False
    
    def is_property(self, function_class):   
        """Returns True if the passed-in function should be called as property, 
        E.g. ``Point.the_geom.x`` is compiled as (for MS Server)
        ``points.the_geom.x``.

        """
        return False
    
    def _get_function_mapping(self):
        """This method can be overridden in subclasses, to set a database specific name
        for a function, or to add new functions, that are only supported by the database.
        
        """
        return None
    
    def process_result(self, value, type):
        """This method is called when a geometry value from the database is
        transformed into a SpatialElement object. It receives an WKB binary sequence, either as Buffer (for PostGIS
        and Spatialite), a String (for MySQL) or a cx_Oracle.LOB (for Oracle), and is supposed to return a 
        subclass of SpatialElement, e.g. PGSpatialElement or MySQLSpatialElement.
        
        """
        raise NotImplementedError("Method SpatialDialect.process_result must be implemented in subclasses.")
    
    def process_wkb(self, value):
        """This method is called from functions._WKBType.process_result_value() to convert
        the result of functions.wkb() into a usable format. 
        
        """
        return value
    
    def bind_wkb_value(self, wkb_element):
        """This method is called from base.__compile_wkbspatialelement() to insert
        the value of base.WKBSpatialElement into a query.
        
        """
        return None if wkb_element is None else wkb_element.desc
    
    def handle_ddl_after_create(self, bind, table, column):
        """This method is called after the mapped table was created in the database
        by SQLAlchemy. It is used to create a geometry column for the created table.
        
        """
        pass
    
    def handle_ddl_before_drop(self, bind, table, column):
        """This method is called after the mapped table was deleted from the database
        by SQLAlchemy. It can be used to delete the geometry column.
        
        """
        pass


class DialectManager(object):
    """This class is responsible for finding a spatial dialect (e.g. PGSpatialDialect or MySQLSpatialDialect)
    for a SQLAlchemy database dialect.
    
    It can be used by calling "DialectManager.get_spatial_dialect(dialect)", which returns the
    corresponding spatial dialect.
    The spatial dialect has to be listed in __initialize_dialects().
    
    """
    
    # all available spatial dialects {(SQLAlchemy dialect class: spatial dialect class)}    
    __dialects_mapping = None
    
    # all instantiated dialects {(spatial dialect class: spatial dialect instance)}    
    __spatial_dialect_instances = {}     
    
    @staticmethod
    def __initialize_dialects():
        #further spatial dialects can be added here
        from geoalchemy.postgis import PGSpatialDialect
        from geoalchemy.mysql import MySQLSpatialDialect
        from geoalchemy.spatialite import SQLiteSpatialDialect
        from geoalchemy.oracle import OracleSpatialDialect
        from geoalchemy.mssql import MSSpatialDialect
            
        DialectManager.__dialects_mapping = {
                PGDialect: PGSpatialDialect,
                SQLiteDialect: SQLiteSpatialDialect,
                MySQLDialect: MySQLSpatialDialect,
                OracleDialect: OracleSpatialDialect,
                MSDialect: MSSpatialDialect
                }

    @staticmethod
    def __dialects():
        if DialectManager.__dialects_mapping is None:
            DialectManager.__initialize_dialects()
            
        return DialectManager.__dialects_mapping
    
    @staticmethod
    def get_spatial_dialect(dialect):
        """This method returns a spatial dialect instance for a given SQLAlchemy dialect.
        The instances are cached, so that for every spatial dialect exists only one instance.
        
        """
        possible_spatial_dialects = [spatial_dialect for (dialect_sqlalchemy, spatial_dialect) 
                                     in DialectManager.__dialects().iteritems() 
                                     if isinstance(dialect, dialect_sqlalchemy)]
        
        if possible_spatial_dialects:
            # take the first possible spatial dialect
            spatial_dialect = possible_spatial_dialects[0]
            if spatial_dialect not in DialectManager.__spatial_dialect_instances:
                # if there is no instance for the given dialect yet, create one
                spatial_dialect_instance = spatial_dialect()
                DialectManager.__spatial_dialect_instances[spatial_dialect] = spatial_dialect_instance
                
            return DialectManager.__spatial_dialect_instances[spatial_dialect]
        else:
            raise NotImplementedError('Dialect "%s" is not supported by GeoAlchemy' % (dialect.name))
        

########NEW FILE########
__FILENAME__ = functions
from sqlalchemy.sql.expression import Function, ClauseElement
from sqlalchemy.ext.compiler import compiles
from sqlalchemy import literal
from sqlalchemy.types import NullType, TypeDecorator
import types
import re

WKT_REGEX = re.compile('.*\\(.*\\).*')

def parse_clause(clause, compiler):
    """This method is used to translate a clause element (geometries, functions, ..).
    According to the type of the clause, a conversion to the database geometry type is added or
    the column clause (column name) or the cascaded clause element is returned.
        
    """
    from geoalchemy.base import SpatialElement, WKTSpatialElement, WKBSpatialElement, DBSpatialElement, GeometryBase
    
    if hasattr(clause, '__clause_element__'):
        # for example a column name
        return clause.__clause_element__()
    elif isinstance(clause, ClauseElement):
        # for cascaded clause elements, like other functions
        return clause
    elif isinstance(clause, SpatialElement):
        if isinstance(clause, (WKTSpatialElement, WKBSpatialElement)):
            return clause
        if isinstance(clause, DBSpatialElement):
            return literal(clause.desc, GeometryBase)    
        return clause.desc
    elif isinstance(clause, basestring) and WKT_REGEX.match(clause):
        return WKTSpatialElement(clause)
    
    # for raw parameters    
    return literal(clause)


def _get_function(element, compiler, params, within_column_clause):
    """For elements of type BaseFunction, the database specific function data 
    is looked up and a executable sqlalchemy.sql.expression.Function object 
    is returned.
    """
    from geoalchemy.dialect import DialectManager 
    database_dialect = DialectManager.get_spatial_dialect(compiler.dialect)
    for kls in element.__class__.__mro__:
        try:
            function_data = database_dialect.get_function(kls)
        except KeyError:
            continue
    if function_data is None:
        raise Exception("Unsupported function for this dialect")
    
    if isinstance(function_data, list):
        """if we have a list of function names, create cascaded Function objects
        for all function names in the list::
        
            ['TO_CHAR', 'SDO_UTIL.TO_WKTGEOMETRY'] --> TO_CHAR(SDO_UTIL.TO_WKTGEOMETRY(..))
        """
        function = None
        for name in reversed(function_data):
            packages = name.split('.')
            
            if function is None:
                """for the innermost function use the passed-in parameters as argument,
                otherwise use the prior created function
                """
                args = params
            else:
                args = [function]
                
            function = Function(packages.pop(-1), 
                        packagenames=packages,
                        *args
                        )
        
        return function
    
    elif isinstance(function_data, types.FunctionType):
        """if we have a function, call this function with the parameters and return the
        created Function object
        """
        if hasattr(element, 'flags'):
            # when element is a BaseFunction
            flags = element.flags
        else:
            flags = {}
            
        return function_data(params, within_column_clause, **flags)
    
    else:
        packages = function_data.split('.')
        
        return Function(packages.pop(-1), 
                        packagenames=packages, 
                        *params
                        )

    
class BaseFunction(Function):
    """Represents a database function.
    
    When the function is used on a geometry column (r.geom.point_n(2) or Road.geom.point_n(2)),
    additional arguments are set using __call__. The column or geometry the function is called on 
    is stored inside the constructor (see base.SpatialComparator.__getattr__()).
    When the function is called directly (functions.point_n(..., 2)),
    all arguments are set using the constructor.
    """
    
    def __init__(self, *arguments, **kwargs):
        self.arguments = arguments
        self.flags = kwargs.copy()
        
        Function.__init__(self, self.__class__.__name__, **kwargs)
        
    def __call__(self, *arguments, **kwargs):
        if len(arguments) > 0:
            self.arguments =  self.arguments + arguments
        
        if len(kwargs) > 0:
            self.flags.update(kwargs)
        
        return self

class ReturnsGeometryFunction(BaseFunction):
    """Represents a database function which returns a new geometry.
    
    This class adds support for "function chaining", so that a new function
    can called on a function that returns a geometry, for example::
    
        session.scalar(r.road_geom.point_n(5).wkt)
        
    Note that only database generic functions (in package 'functions') can be
    called, but no database specific functions, like::
    
         session.scalar(r.road_geom.point_n(5).sdo_geom_sdo_centroid)
    """
    
    def __getattr__(self, name):
        return getattr(functions, name)(self)
    
    # override the __eq__() operator (allows to use '==' on geometries)
    def __eq__(self, other): 
        return functions.equals(self, other)

@compiles(BaseFunction)
def __compile_base_function(element, compiler, **kw):
    
    params = [parse_clause(argument, compiler) for argument in element.arguments]
    
    from geoalchemy.dialect import DialectManager 
    database_dialect = DialectManager.get_spatial_dialect(compiler.dialect)
    
    if database_dialect.is_member_function(element.__class__):
        geometry = params.pop(0)
        function_name = database_dialect.get_function(element.__class__)
        
        if isinstance(function_name, str):
            """If the function is defined as String (e.g. "oracle_functions.dims : 'Get_Dims'"), 
            we construct the function call in the query ourselves. This is because SQLAlchemy, 
            at this point of the compile process, does not add parenthesis for functions 
            without arguments when using Oracle.
            Otherwise let SQLAlchemy build the query. Note that this won't work for Oracle with
            functions without parameters."""
            
            return "%s.%s(%s)" % (
                        compiler.process(geometry),
                        function_name,
                        ", ".join([compiler.process(e) for e in params]) 
                        )
        else:
            function = _get_function(element, compiler, params, kw.get('within_columns_clause', False))
            
            return "%s.%s" % (
                        compiler.process(geometry),
                        compiler.process(function)      
                        )
            
    elif database_dialect.is_property(element.__class__):
        geometry = params.pop(0)
        function_name = database_dialect.get_function(element.__class__)
        
        return "%s.%s" % (
                        compiler.process(geometry),
                        function_name 
                        )
        
    else:
        function = _get_function(element, compiler, params, kw.get('within_columns_clause', False))
        return compiler.process(function)

def BooleanFunction(function, compare_value = 'TRUE'):
    """Wrapper for database function that return 'Boolean-like' values, for example
    SDO_EQUAL returns the string 'TRUE'.
    
    This function adds the necessary comparison to ensure
    that in the WHERE clause the function is compared to `compare_value`
    while in the SELECT clause the function result is returned.
    
    :param function: The function that needs boolean wrapping
    :param compare_value: The value that the function should be compare to
    """
    def function_handler(params, within_column_clause):
        return check_comparison(function(*params), within_column_clause, True, compare_value)
    
    return function_handler
  
def check_comparison(function, within_column_clause, returns_boolean, compare_value):
    """Because Oracle and MS SQL do not want to know Boolean and functions return 0/1 or the string 'TRUE',
    we manually have to add a comparison, but only if the function is called inside the where-clause, 
    not in the select clause.
    
    For example:
    select .. from .. where SDO_EQUAL(.., ..) = 'TRUE'
    select SDO_EQUAL(.., ..) from ..
    
    """
    if returns_boolean and not within_column_clause:
        return (function == compare_value)
    else: 
        return function

class functions:
    """Functions that implement OGC SFS or SQL/MM and that are supported by most databases
    """
    
    class wkt(BaseFunction):
        """AsText(g)"""
        pass

    class wkb(BaseFunction):
        """AsBinary(g)"""
        def __init__(self, *arguments):
            BaseFunction.__init__(self, type_=_WKBType, *arguments)
        
    class dimension(BaseFunction):
        """Dimension(g)"""
        pass
    
    class srid(BaseFunction):
        """SRID(g)"""
        pass
    
    class geometry_type(BaseFunction):
        """GeometryType(g)"""
        pass
    
    class is_valid(BaseFunction):
        """IsValid(g)"""
        pass
    
    class is_empty(BaseFunction):
        """IsEmpty(g)"""
        pass
    
    class is_simple(BaseFunction):
        """IsSimple(g)"""
        pass
    
    class is_closed(BaseFunction):
        """IsClosed(g)"""
        pass
    
    class is_ring(BaseFunction):
        """IsRing(g)"""
        pass
    
    class num_points(BaseFunction):
        """NumPoints(g)"""
        pass
    
    class point_n(ReturnsGeometryFunction):
        """PointN(g, n)"""
        pass
    
    class length(BaseFunction):
        """Length(g)"""
        pass
    
    class area(BaseFunction):
        """Area(g)"""
        pass
    
    class x(BaseFunction):
        """X(g)"""
        pass
    
    class y(BaseFunction):
        """Y(g)"""
        pass
    
    class centroid(ReturnsGeometryFunction):
        """Centroid(g)"""
        pass
    
    class boundary(ReturnsGeometryFunction):
        """Boundary"""
        pass
    
    class buffer(ReturnsGeometryFunction):
        """Buffer(g, n)"""
        pass
    
    class convex_hull(ReturnsGeometryFunction):
        """ConvexHull(g)"""
        pass
    
    class envelope(ReturnsGeometryFunction):
        """Envelope(g)"""
        pass
    
    class start_point(ReturnsGeometryFunction):
        """StartPoint(g)"""
        pass
    
    class end_point(ReturnsGeometryFunction):
        """EndPoint(g)"""
        pass
    
    class transform(ReturnsGeometryFunction):
        """Transform(g, srid)"""
        pass

    class equals(BaseFunction):
        """Equals(g1, g2)"""
        pass
    
    class distance(BaseFunction):
        """Distance(g1, g2)"""
        pass
    
    class within_distance(BaseFunction):
        """DWithin(g1, g2, d)"""
        pass
    
    class disjoint(BaseFunction):
        """Disjoint(g1, g2)"""
        pass
    
    class intersects(BaseFunction):
        """Intersects(g1, g2)"""
        pass
    
    class touches(BaseFunction):
        """Touches(g1, g2)"""
        pass
    
    class crosses(BaseFunction):
        """Crosses(g1, g2)"""
        pass
    
    class within(BaseFunction):
        """Within(g1, g2)"""
        pass
    
    class overlaps(BaseFunction):
        """Overlaps(g1, g2)"""
        pass
    
    class gcontains(BaseFunction):
        """Contains(g1, g2)"""
        pass
    
    class covers(BaseFunction):
        """Covers(g1, g2)"""
        pass
    
    class covered_by(BaseFunction):
        """CoveredBy(g1, g2)"""
        pass
    
    class intersection(ReturnsGeometryFunction):
        """Intersection(g1, g2)"""
        pass

    class _within_distance(BaseFunction):
        """A specific DWithin(g1, g2, d) implementation, for dialects
           that either don't support DWithin (MySQL, Spatialite), or
           don't support it correctly (PostGIS 1.3), or provide multiple
           implementations (Oracle)."""
        pass
    
    class union(ReturnsGeometryFunction):
        """Union(geometry set)

        Union is an aggregte function. It is typically used
        in ``SELECT`` clauses.

        *Only supported in PostgreSQL/PostGIS currently.*
        """
        pass
            
    class collect(ReturnsGeometryFunction):
        """Collect(geometry set)
        
        Collect is an aggregate function. It is typically used
        in ``SELECT`` clauses.

        *Only supported in PostgreSQL/PostGIS currently.*
        """
        pass
    
    class extent(BaseFunction):
        """Extent(geometry set)
        
        Extent is an aggregate function. It is typically used
        in ``SELECT`` clauses.

        *Only supported in PostgreSQL/PostGIS currently.*
        """
        pass
    
@compiles(functions._within_distance)
def __compile__within_distance(element, compiler, **kw):
    from geoalchemy.dialect import DialectManager 
    database_dialect = DialectManager.get_spatial_dialect(compiler.dialect)
    for kls in element.__class__.__mro__:
        try:
            function = database_dialect.get_function(kls)
        except KeyError:
            continue
    if function is None:
        raise Exception("Unsupported function for this dialect")
    arguments = list(element.arguments)
    return compiler.process(
        function(compiler,
                 parse_clause(arguments.pop(0), compiler),
                 parse_clause(arguments.pop(0), compiler),
                 arguments.pop(0), *arguments))

class _WKBType(TypeDecorator):
    """A helper type which makes sure that the WKB sequence returned from queries like 
    'session.scalar(r.road_geom.wkb)', has the same type as the attribute 'geom_wkb' which
    is filled when querying an object of a mapped class, for example with 'r = session.query(Road).get(1)'::
    
        eq_(session.scalar(self.r.road_geom.wkb), self.r.road_geom.geom_wkb)
    
    This type had to be introduced, because for Oracle 'SDO_UTIL.TO_WKBGEOMETRY(..)' returned the type 
    cx_Oracle.LOB and not a buffer.
    
    To modify the behavior of 'process_result_value' for a specific database dialect, overwrite the 
    method 'process_wkb' in that dialect.
    
    This class is used inside :class:`functions.wkb`.
    
    """

    impl = NullType

    def process_result_value(self, value, dialect):
        if value is not None:
            from geoalchemy.dialect import DialectManager 
            database_dialect = DialectManager.get_spatial_dialect(dialect)
            
            return database_dialect.process_wkb(value)
        else:
            return value

    def copy(self):
        return _WKBType()
    

########NEW FILE########
__FILENAME__ = geometry
import warnings

from sqlalchemy import Column, Table, exc
from sqlalchemy.orm import column_property
from sqlalchemy.orm.interfaces import AttributeExtension
from sqlalchemy.sql.expression import Alias
from sqlalchemy.sql import expression
from sqlalchemy.ext.compiler import compiles
from sqlalchemy.dialects.postgresql.base import PGDialect

from geoalchemy.base import GeometryBase, _to_gis, SpatialComparator
from geoalchemy.dialect import DialectManager
from geoalchemy.functions import functions

class Geometry(GeometryBase):
    """Geometry column type. This is the base class for all other
    geometry types like Point, LineString, Polygon, etc.
    
    Converts bind/result values to/from a dialect specific persistent
    geometry value.
    
    """
    
    def result_processor(self, dialect, coltype=None):
        def process(value):
            if value is not None:
                return DialectManager.get_spatial_dialect(dialect).process_result(value, self)
            else:
                return value
        return process

# other datatypes can be added as needed, which 
# currently only affect DDL statements.

class Point(Geometry):
    name = 'POINT'
    
class Curve(Geometry):
    name = 'CURVE'
    
class LineString(Curve):
    name = 'LINESTRING'

class Polygon(Geometry):
    name = 'POLYGON'

class MultiPoint(Geometry):
    name = 'MULTIPOINT'

class MultiLineString(Geometry):
    name = 'MULTILINESTRING'

class MultiPolygon(Geometry):
    name = 'MULTIPOLYGON'

class GeometryCollection(Geometry):
    name = 'GEOMETRYCOLLECTION'

class GeometryDDL(object):
    """A DDL extension which integrates SQLAlchemy table create/drop 
    methods with AddGeometryColumn/DropGeometryColumn functions of
    spatial databases.
    
    Usage::
    
        sometable = Table('sometable', metadata, ...)
        
        GeometryDDL(sometable)

        sometable.create()
    
    """

    try:
        from sqlalchemy import event as _event
    except ImportError:
        # SQLAlchemy 0.6
        use_event = False
        columns_attribute = '_columns'
    else:
        # SQLALchemy 0.7
        use_event = True
        columns_attribute = 'columns'
    
    def __init__(self, table):
        if self.use_event:
            self._event.listen(table, 'before_create', self.before_create)
            self._event.listen(table, 'before_drop', self.before_drop)
            self._event.listen(table, 'after_create', self.after_create)
            self._event.listen(table, 'after_drop', self.after_drop)
        else:
            for e in ('before-create', 'after-create',
                      'before-drop', 'after-drop'):
                table.ddl_listeners[e].append(self)
        self._stack = []
        
    def __call__(self, event, table, bind):
        spatial_dialect = DialectManager.get_spatial_dialect(bind.dialect)
        if event in ('before-create', 'before-drop'):
            """Remove geometry column from column list (table._columns), so that it 
            does not show up in the create statement ("create table tab (..)"). 
            Afterwards (on event 'after-create') restore the column list from self._stack.
            """
            regular_cols = [c for c in table.c if not isinstance(c.type, Geometry)]
            gis_cols = set(table.c).difference(regular_cols)
            self._stack.append(table.c)
            setattr(table, self.columns_attribute,
                    expression.ColumnCollection(*regular_cols))
            
            if event == 'before-drop':
                for c in gis_cols:
                    spatial_dialect.handle_ddl_before_drop(bind, table, c)
                
        elif event == 'after-create':
            setattr(table, self.columns_attribute, self._stack.pop())
            
            for c in table.c:
                if isinstance(c.type, Geometry):
                    spatial_dialect.handle_ddl_after_create(bind, table, c)

        elif event == 'after-drop':
            setattr(table, self.columns_attribute, self._stack.pop())

    def before_create(self, target, connection, **kw):
        self('before-create', target, connection)

    def before_drop(self, target, connection, **kw):
        self('before-drop', target, connection)

    def after_create(self, target, connection, **kw):
        self('after-create', target, connection)

    def after_drop(self, target, connection, **kw):
        self('after-drop', target, connection)


class SpatialAttribute(AttributeExtension):
    """Intercepts 'set' events on a mapped instance attribute and 
    converts the incoming value to a GIS expression.
    
    """
    
    def set(self, state, value, oldvalue, initiator):
        return _to_gis(value, self.__get_srid(initiator))
 
    def __get_srid(self, initiator):
        """Returns the SRID used for the geometry column that is connected
        to this SpatialAttribute instance."""
        try:
            return initiator.parent_token.columns[0].type.srid
        except Exception:
            return None
 
class GeometryExtensionColumn(Column):
    pass
        
@compiles(GeometryExtensionColumn)
def compile_column(element, compiler, **kw):
    if isinstance(element.table, (Table, Alias)):
        if kw.has_key("within_columns_clause") and kw["within_columns_clause"] == True:
            if element.type.wkt_internal:
                if isinstance(compiler.dialect, PGDialect):
                    return compiler.process(functions.wkt(element))
                warnings.warn("WKT Internal GeometryColumn type not "
                    "compatible with %s dialect. Defaulting back to WKB"
                    % compiler.dialect.name, exc.SAWarning)
            return compiler.process(functions.wkb(element))
        
    return compiler.visit_column(element, **kw)
     
            
def GeometryColumn(*args, **kw):
    """Define a declarative column property with GIS behavior.
    
    This just produces orm.column_property() with the appropriate
    extension and comparator_factory arguments.  The given arguments
    are passed through to Column.  The declarative module extracts
    the Column for inclusion in the mapped table.
    
    This method can also be used for non-declarative mappings to 
    set the properties for a geometry column when defining the mapping.
    
    """
    if kw.has_key("comparator"):
        comparator = kw.pop("comparator")
    else:
        comparator = SpatialComparator
    
    if isinstance(args[0], GeometryExtensionColumn):
        # if used for non-declarative, use the column of the table definition
        column = args[0]
        args = args[1:]
    else:
        # if used for declarative, create a new column
        column = GeometryExtensionColumn(*args, **kw) 
    
    return column_property(
        column, 
        extension=SpatialAttribute(), 
        comparator_factory=comparator
    )


########NEW FILE########
__FILENAME__ = mssql
# -*- coding: utf-8 -*-

import warnings
from sqlalchemy import func, cast, exc
from sqlalchemy.types import VARBINARY
from sqlalchemy.sql.expression import text
from sqlalchemy.ext.compiler import compiles
from geoalchemy.base import WKBSpatialElement, WKTSpatialElement, PersistentSpatialElement, DBSpatialElement, SpatialComparator
from geoalchemy.dialect import SpatialDialect
from geoalchemy.functions import functions, BaseFunction, BooleanFunction
from geoalchemy.geometry import Geometry

u"""
:mod:`geoalchemy.mssql` -- MS SQL Server 2008 Spatial Dialect
=============================================================

This module provides the :class:`~geoalchemy.dialect.SpatialDialect` for
connecting to MS SQL Server 2008 databases that contain spatial data.

Most OGC functionality is fully supported, but there are a few exceptions.
See :class:`geoalchemy.mssql.MSSpatialDialect` for details.

There are also a number of MS SQL Server 2008 specific functions that are
available. See :class:`geoalchemy.mssql.ms_functions` for details.

To include a spatial index the bounding box for the data must be defined in the
column definition. If no bounding box is specified then no spatial index will
be created.

>>> class Road(Base):
>>>    __tablename__ = 'ROADS'
>>>
>>>    road_id = Column(Integer, primary_key=True)
>>>    road_name = Column(String(255))
>>>    road_geom = GeometryColumn(Geometry(2, bounding_box='(xmin=-180, ymin=-90, xmax=180, ymax=90)'), nullable=False)

There is also currently no support for inserting `None` geometries. You must
use :data:`geoalchemy.mssql.MS_SPATIAL_NULL` to explicitly insert NULL
geometries.

It is not possible to restrict the geometry columns to a specific geometry
type.

.. moduleauthor:: Mark Hall <Mark.Hall@nationalarchives.gov.uk>
"""

MS_SPATIAL_NULL = text('null')
"""There is a bug causing errors when trying to insert None values into
nullable columns. Use this constant instead."""

class MSComparator(SpatialComparator):
    """Comparator class used for MS SQL Server 2008
    """
    def __getattr__(self, name):
        try:
            return SpatialComparator.__getattr__(self, name)
        except AttributeError:
            return getattr(ms_functions, name)(self)

class MSPersistentSpatialElement(PersistentSpatialElement):
    """Represents a Geometry as loaded from an MS SQL Server 2008 database.
    """
    def __init__(self, desc):
        self.desc = desc
    
    def __getattr__(self, name):
        try:
            return PersistentSpatialElement.__getattr__(self, name)
        except AttributeError:
            return getattr(ms_functions, name)(self)

@compiles(VARBINARY, 'mssql')
def compile_varbinary(element, compiler, **kw):
    """Compiler function to handle VARBINARY(max).
    
    Should be removed when SQLAlchemy supports this natively.
    """
    if str(element.length).lower() == 'max':
        return "VARBINARY(max)"
    else:
        return compiler.visit_VARBINARY(element, **kw)

def CastDBSpatialElementFunction():
    """Wrapper required for handling the :class:`geoalchemy.base.DBSpatialElement`.
    
    This adds the necessary casts so that a :class:`geoalchemy.base.DBSpatialElement`
    is recognised as a spatial element by the SQL Server. The reason for this
    is that in SQL Server the geometry data is a subclass of VARBINARY and the
    sub-classing information gets lost between queries. The cast provided by
    this function guarantees that SQL Server knows the data is a geometry.
    """
    def function_handler(params, within_column_clause):
        return cast(cast(params[0], VARBINARY('max')), Geometry)
    
    return function_handler

class ms_functions(functions):
    """MS SQL Server specific geometry functions.
    """
    class gml(BaseFunction):
        """g.AsGML()
        
        GML representation of the geometry. Does not include the SRS.
        """
        pass
    
    class text_zm(BaseFunction):
        """p.AsTextZM()
        
        The :class:`~geoalchemy.geometry.Point` WKT representation augmented
        with Z and M values. Only valid for :class:`~geoalchemy.geometry.Point`
        geometries.
        """
        pass
    
    class buffer_with_tolerance(BaseFunction):
        """g.BufferWithTolerance(distance, tolerance, relative)
        
        Creates a buffer with the given tolerance values.
        """
        pass
    
    class filter(BaseFunction):
        """g1.Filter(g2)
        
        An index-only intersection query. Can return false positives. If no
        index is defined then behaves like g1.intersection(g2).
        """
        pass
    
    class instance_of(BaseFunction):
        """g.InstanceOf(geometry_type_name)
        
        Tests whether the geometry is of the given geometry type.
        """
        pass
    
    class m(BaseFunction):
        """p.M
        
        Returns the M value for the given :class:`~geoalchemy.geometry.Point`.
        Only valid for :class:`~geoalchemy.geometry.Point` geometries.
        """
        pass
    
    class make_valid(BaseFunction):
        """g.MakeValid()
        
        Converts an invalid :class:`~geoalchemy.geometry.Geometry` into a
        valid one. This can return a different type of
        :class:`~geoalchemy.geometry.Geometry`.
        """
        pass
    
    class reduce(BaseFunction):
        """g.Reduce(tolerance)
        
        Returns an approximation of the :class:`~geoalchemy.geometry.Geometry`
        using the Douglas-Peucker algorithm.
        """
        pass
    
    class to_string(BaseFunction):
        """g.ToString()
        
        Equivalent to :class:`~geoalchemy.mssql.ms_functions.text_zm` except
        that for NULL geometries it will return the string 'NULL'.
        """
        pass
    
    class z(BaseFunction):
        """p.Z
        
        Returns the M value for the given :class:`~geoalchemy.geometry.Point`.
        Only valid for :class:`~geoalchemy.geometry.Point` geometries.
        """
        pass

class MSSpatialDialect(SpatialDialect):
    """The :class:`~geoalchemy.dialect.SpatialDialect` for accessing MS
    SQL Server 2008 spatial data.
    
    For the standard OGC functions there are a few differences in the SQL
    Server 2008 implementation that need to be taken into account:
    
    * g.centroid -- Only returns results for :class:`~geoalchemy.geometry.Polygon`
      and :class:`~geoalchemy.geometry.MultiPolygon`. Returns 'NULL' for all
      other :class:`~geoalchemy.geometry.Geometry`
    * g.envelope -- Will always return a :class:`~geoalchemy.geometry.Polygon`
      regardless of the type of :class:`~geoalchemy.geometry.Geometry` it
      was called on
    * g.buffer -- Only supports the buffer distance as a parameter
    
    Some standard functions are not available:
    
    * g.transform
    * g.within_distance
    * g.covers
    * g.covers_by
    * g.intersection
    
    For SQL Server 2008 specific functions see :class:`~geoalchemy.mssql.ms_functions`.
    """
    __functions = {
                   functions.wkt: 'STAsText',
                   WKTSpatialElement: 'geometry::STGeomFromText',
                   functions.wkb: 'STAsBinary',
                   WKBSpatialElement : 'geometry::STGeomFromWKB',
                   DBSpatialElement : CastDBSpatialElementFunction(),
                   functions.dimension : 'STDimension',
                   functions.srid : 'STSrid',
                   functions.geometry_type : 'STGeometryType',
                   functions.is_empty : 'STIsEmpty',
                   functions.is_simple : 'STIsSimple',
                   functions.is_closed : 'STIsClosed',
                   functions.is_ring : 'STIsRing',
                   functions.num_points : 'STNumPoints',
                   functions.point_n : 'STPointN',
                   functions.length : 'STLength',
                   functions.area : 'STArea',
                   functions.x : 'STX',
                   functions.y : 'STY',
                   functions.centroid : 'STCentroid',
                   functions.boundary : 'STBoundary',
                   functions.buffer : 'STBuffer',
                   functions.convex_hull : 'STConvexHull',
                   functions.envelope : 'STEnvelope',
                   functions.start_point : 'STStartPoint',
                   functions.end_point : 'STEndPoint',
                   functions.transform : None,
                   functions.equals : BooleanFunction(func.STEquals, 1),
                   functions.distance : 'STDistance',
                   functions.within_distance : None,
                   functions.disjoint : BooleanFunction(func.STDisjoint, 1),
                   functions.intersects : BooleanFunction(func.STIntersects, 1),
                   functions.touches : BooleanFunction(func.STTouches, 1),
                   functions.crosses : BooleanFunction(func.STCrosses, 1),
                   functions.within : BooleanFunction(func.STWithin, 1),
                   functions.overlaps : BooleanFunction(func.STOverlaps, 1),
                   functions.gcontains : BooleanFunction(func.STContains, 1),
                   functions.covers : None,
                   functions.covered_by : None,
                   functions.intersection : None,
                   functions.is_valid : BooleanFunction(func.STIsValid, 1),
                   # Not tested
                   # functions.aggregate_union : 'STUnion', 
                   ms_functions.gml : 'AsGml',
                   ms_functions.text_zm : 'AsTextZM',
                   ms_functions.buffer_with_tolerance : 'BufferWithTolerance',
                   ms_functions.filter : BooleanFunction(func.Filter, 1),
                   ms_functions.instance_of : BooleanFunction(func.InstanceOf, 1),
                   ms_functions.m : 'M',
                   ms_functions.make_valid : 'MakeValid',
                   ms_functions.reduce : 'Reduce',
                   ms_functions.to_string : 'ToString',
                   ms_functions.z : 'Z'
                  }
    
    __member_functions = (
                          functions.wkt,
                          functions.wkb,
                          functions.dimension,
                          functions.geometry_type,
                          functions.is_empty,
                          functions.is_simple,
                          functions.is_closed,
                          functions.is_ring,
                          functions.num_points,
                          functions.point_n,
                          functions.length,
                          functions.area,
                          functions.centroid,
                          functions.boundary,
                          functions.buffer,
                          functions.convex_hull,
                          functions.envelope,
                          functions.start_point,
                          functions.end_point,
                          functions.equals,
                          functions.distance,
                          functions.disjoint,
                          functions.intersects,
                          functions.touches,
                          functions.crosses,
                          functions.within,
                          functions.overlaps,
                          functions.gcontains,
                          functions.is_valid,
                          ms_functions.gml,
                          ms_functions.text_zm,
                          ms_functions.buffer_with_tolerance,
                          ms_functions.filter,
                          ms_functions.instance_of,
                          ms_functions.make_valid,
                          ms_functions.reduce,
                          ms_functions.to_string
                         )
    
    __properties = (
                    functions.srid,
                    functions.x,
                    functions.y,
                    ms_functions.m,
                    ms_functions.z
                   )
    
    def _get_function_mapping(self):
        return MSSpatialDialect.__functions
    
    def process_result(self, value, type):
        return MSPersistentSpatialElement(WKBSpatialElement(value, type.srid))
    
    def handle_ddl_after_create(self, bind, table, column):
        nullable = "NOT NULL"
        if column.nullable:
            nullable = "NULL"
            
        bind.execute("ALTER TABLE [%s].[%s] ADD [%s] %s %s" %
                     (table.schema or 'dbo', table.name, column.name, 'GEOMETRY', nullable))
        
        if column.type.spatial_index:
            if "bounding_box" in column.type.kwargs:
                bind.execute("CREATE SPATIAL INDEX [%s_%s] ON [%s].[%s]([%s]) WITH (BOUNDING_BOX = %s)" %
                             (table.name, column.name, table.schema or 'dbo', table.name, column.name, column.type.kwargs["bounding_box"]))
            else:
                warnings.warn("No bounding_box given for '[%s].[%s].[%s]' no spatial index will be created." %
                              (table.schema or 'dbo', table.name, column.name), 
                              exc.SAWarning, stacklevel=3)
            
    def is_member_function(self, function_class):
        return function_class in self.__member_functions
    
    def is_property(self, function_class):
        return function_class in self.__properties
    

########NEW FILE########
__FILENAME__ = mysql
from sqlalchemy import func
from geoalchemy.base import SpatialComparator, PersistentSpatialElement,\
    WKBSpatialElement
from geoalchemy.dialect import SpatialDialect 
from geoalchemy.functions import functions, BaseFunction


class MySQLComparator(SpatialComparator):
    """Comparator class used for MySQL
    """
    def __getattr__(self, name):
        try:
            return SpatialComparator.__getattr__(self, name)
        except AttributeError:
            return getattr(mysql_functions, name)(self)


class MySQLPersistentSpatialElement(PersistentSpatialElement):
    """Represents a Geometry value as loaded from the database."""
    
    def __init__(self, desc):
        self.desc = desc
        
    def __getattr__(self, name):
        try:
            return PersistentSpatialElement.__getattr__(self, name)
        except AttributeError:
            return getattr(mysql_functions, name)(self)


class mysql_functions(functions):
    """Functions only supported by MySQL
    """
    
    class mbr_equal(BaseFunction):
        """MBREqual(g1, g2)"""
        pass
    
    class mbr_disjoint(BaseFunction):
        """MBRDisjoint(g1, g2)"""
        pass
    
    class mbr_intersects(BaseFunction):
        """MBRIntersects(g1, g2)"""
        pass
    
    class mbr_touches(BaseFunction):
        """MBRTouches(g1, g2)"""
        pass
    
    class mbr_within(BaseFunction):
        """MBRWithin(g1, g2)"""
        pass
    
    class mbr_overlaps(BaseFunction):
        """MBROverlaps(g1, g2)"""
        pass
    
    class mbr_contains(BaseFunction):
        """MBRContains(g1, g2)"""
        pass

    @staticmethod
    def _within_distance(compiler, geom1, geom2, distance, *args):
        """MySQL does not support the function distance, so we are doing
        a kind of "mbr_within_distance". The MBR of 'geom2' is expanded with
        the amount of 'distance' by manually changing the coordinates.
        Then we test if 'geom1' intersects this expanded MBR.
        """
        mbr = func.ExteriorRing(func.Envelope(geom2))

        lower_left = func.StartPoint(mbr)
        upper_right = func.PointN(mbr, 3)

        xmin = func.X(lower_left)
        ymin = func.Y(lower_left)
        xmax = func.X(upper_right)
        ymax = func.Y(upper_right)

        return func.Intersects(
                geom1,
                func.GeomFromText(
                    func.Concat('Polygon((',
                           xmin - distance, ' ', ymin - distance, ',',
                           xmax + distance, ' ', ymin - distance, ',',
                           xmax + distance, ' ', ymax + distance, ',',
                           xmin - distance, ' ', ymax + distance, ',',
                           xmin - distance, ' ', ymin - distance, '))'),
                    func.srid(geom2)))

class MySQLSpatialDialect(SpatialDialect):
    """Implementation of SpatialDialect for MySQL."""
    
    __functions = {
                   functions.length : 'GLength',
                   functions.is_valid : None,
                   functions.is_simple : None,
                   functions.boundary : None,
                   functions.is_ring : None,
                   functions.centroid : None, 
                   functions.distance : None, # see also: http://bugs.mysql.com/bug.php?id=13600
                   functions.touches : None,
                   functions.crosses : None,
                   functions.transform : None,
                   functions.buffer : None,
                   functions.convex_hull : None,
                   functions.intersection : None,
                   functions.within_distance : None,
                   mysql_functions.mbr_equal : 'MBREqual',
                   mysql_functions.mbr_disjoint : 'MBRDisjoint',
                   mysql_functions.mbr_intersects : 'MBRIntersects',
                   mysql_functions.mbr_touches : 'MBRTouches',
                   mysql_functions.mbr_within : 'MBRWithin',
                   mysql_functions.mbr_overlaps : 'MBROverlaps',
                   mysql_functions.mbr_contains : 'MBRContains',
                   functions._within_distance : mysql_functions._within_distance
                   }

    def _get_function_mapping(self):
        return MySQLSpatialDialect.__functions
    
    def process_result(self, value, type):
        return MySQLPersistentSpatialElement(WKBSpatialElement(value, type.srid))
    
    def handle_ddl_after_create(self, bind, table, column):
        if column.type.spatial_index or not column.nullable:
            # MySQL requires NOT NULL for spatial indexed columns
            bind.execute("ALTER TABLE %s ADD %s %s NOT NULL" % 
                            (table.name, column.name, column.type.name))
        else:
            bind.execute("ALTER TABLE %s ADD %s %s" % 
                            (table.name, column.name, column.type.name))
        
        if column.type.spatial_index:
            bind.execute("CREATE SPATIAL INDEX idx_%s_%s ON %s(%s)" % 
                            (table.name, column.name, table.name, column.name))
            

########NEW FILE########
__FILENAME__ = oracle
# -*- coding: utf-8 -*-
from sqlalchemy import select, func, exc
from geoalchemy.base import SpatialComparator, PersistentSpatialElement,\
    GeometryBase
from geoalchemy.dialect import SpatialDialect 
from geoalchemy.functions import functions, BaseFunction, check_comparison, BooleanFunction
from geoalchemy.geometry import LineString, MultiLineString, GeometryCollection,\
    Geometry
from geoalchemy.base import WKTSpatialElement, WKBSpatialElement
    
import warnings
from sqlalchemy.schema import Column
from sqlalchemy.sql.expression import table, column, and_, text
from sqlalchemy.orm.attributes import InstrumentedAttribute

"""Currently cx_Oracle does not support the insertion of NULL values into geometry columns 
as bind parameter, see http://sourceforge.net/mailarchive/forum.php?thread_name=AANLkTikNG4brmQJiua2FQS8zUwk8rNgLHoe6SZ32f1gQ%40mail.gmail.com&forum_name=cx-oracle-users

For still being able to insert NULL, this variable can be used::
    
    spot_null = Spot(spot_height=None, spot_location=ORACLE_NULL_GEOMETRY)
    
"""
ORACLE_NULL_GEOMETRY = text('NULL')

class OracleComparator(SpatialComparator):
    """Comparator class used for Oracle
    """
    def __getattr__(self, name):
        try:
            return SpatialComparator.__getattr__(self, name)
        except AttributeError:
            return getattr(oracle_functions, name)(self)


class OraclePersistentSpatialElement(PersistentSpatialElement):
    """Represents a Geometry value as loaded from the database."""

    def __init__(self, desc):
        self.desc = desc
        
    def __getattr__(self, name):
        try:
            return PersistentSpatialElement.__getattr__(self, name)
        except AttributeError:
            return getattr(oracle_functions, name)(self)

def ST_GeometryFunction(function, returns_geometry = False, relation_function = False, 
                          returns_boolean = False, compare_value = 1, default_cast = False):
    """Functions inside MDSYS.OGC_* (OGC SF) and MDSYS.ST_GEOMETRY.ST_* (SQL MM) expect ST_GEOMETRY 
    instead of SDO_GEOMETRY, this method adds a cast.
    
    Some functions like OGC_X or OGC_IsClosed only work if the geometry (the first parameter) is casted 
    to a ST_GEOMETRY subtype, for example: 'OGC_X(ST_POINT(SDO_GEOMETRY(..)))'. 
    This method tries to get the geometry type from WKTSpatialElement, WKBSpatialElement and columns and 
    adds a corresponding cast (if possible).
    If the geometry type can not be identified, no cast is added and the user manually has to add 
    a cast, for example: 'session.scalar(functions.x(func.ST_POINT(spot.spot_location.transform(2249)))'
    
    Functions like OGC_IsEmpty do not require a cast to a subtype. In this case (``default_cast = True``),
    a cast to 'ST_GEOMETRY' is always added.
    
    If ``relation_function`` is set to ``True``, a cast is also added for the second parameter. 

    If the database function returns a new geometry (`returns_geometry = True``) a back-cast to
    SDO_GEOMETRY ('ST_GEOMETRY.GET_SDO_GEOM(..)') is added.  
    """
    assert(not (returns_geometry and returns_boolean)) # both can not be true
     
    def get_function(function, geom_cast, params, returns_geometry, relation_function):
        if relation_function:
            # cast 2nd geometry
            geom2_cast = cast_param(params)
            
            if geom2_cast is not None:
                function = function(geom_cast, geom2_cast, *params)
            else:
                function = function(geom_cast, *params)
        else:
            function = function(geom_cast, *params)
            
        if returns_geometry:
            # add cast to SDO_GEOMETRY
            return func.ST_GEOMETRY.GET_SDO_GEOM(function)
        else:
            return function
    
    def cast_param(params):
        if len(params) > 0:
            geom = params[0]
            
            if default_cast:
                params.pop(0)
                return func.ST_GEOMETRY(geom)
            
            elif isinstance(geom, (WKBSpatialElement, WKTSpatialElement)) and geom.geometry_type <> Geometry.name:
                params.pop(0)
                return getattr(func, 'ST_%s' % (geom.geometry_type))(geom)

            elif isinstance(geom, Column) and isinstance(geom.type, GeometryBase):
                params.pop(0)
                return getattr(func, 'ST_%s' % (geom.type.name))(geom)
        
        return None
    
    
    def function_handler(params, within_column_clause):
        if len(params) > 0:
            geom_cast = cast_param(params)
            if geom_cast is not None:
                return check_comparison(get_function(function, geom_cast, params, returns_geometry, relation_function),
                                          within_column_clause, returns_boolean, compare_value)
            
        return check_comparison(function(*params), within_column_clause, returns_boolean, compare_value)
    
    return function_handler

def DimInfoFunction(function, returns_boolean = False, compare_value = 'TRUE'):
    """Some Oracle functions expect a 'dimension info array' (DIMINFO) for each geometry. This method
    tries to append a corresponding DIMINFO for every geometry in the parameter list.
    
    For geometry columns a subselect is added which queries the DIMINFO from 'ALL_SDO_GEOM_METADATA'.
    For WKTSpatialElement/WKBSpatialElement objects, that were queried from the database, the DIMINFO 
    will be added as text representation (if possible).
    
    Most functions that require DIMINFO also accept a tolerance value instead of the DIMINFO. If you want to 
    use a tolerance value for geometry columns or WKBSpatialElement objects that come from the database, 
    the flag 'auto_diminfo' has to be set to 'False' when calling the function::
        
        l = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        session.scalar(l.lake_geom.area) # DIMINFO is added automatically
        session.scalar(l.lake_geom.area(tolerance, auto_diminfo=False)) # DIMINFO is not added
    
    see also: http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_objrelschema.htm#sthref300
    """
    
    def function_handler(params, within_column_clause, **flags):
        if flags.get('auto_diminfo', True):
            # insert diminfo for all geometries in params
            params = list(params)
            
            i = 0
            length = len(params)
            while i < length:
                diminfo = None
                if isinstance(params[i], (WKBSpatialElement, WKTSpatialElement)) and hasattr(params[i], 'DIMINFO'):
                    # the attribute DIMINFO is set in OracleSpatialDialect.process_result()
                    diminfo = params[i].DIMINFO
                    
                elif isinstance(params[i], Column) and isinstance(params[i].type, GeometryBase):
                    diminfo = OracleSpatialDialect.get_diminfo_select(params[i])
                    
                if diminfo is not None:
                    i += 1
                    # insert DIMINFO after the geometry
                    params.insert(i, diminfo)
                    length += 1
                    
                i += 1

        return check_comparison(function(*params), within_column_clause, returns_boolean, compare_value)
    
    return function_handler

class oracle_functions(functions):
    """Functions only supported by Oracle
    """
    
    class gtype(BaseFunction):
        """g.Get_GType()"""
        pass
        
    class dims(BaseFunction):
        """g.Get_Dims()"""
        pass
    
    class kml(BaseFunction):
        """TO_CHAR(SDO_UTIL.TO_KMLGEOMETRY(g))"""
        pass

    class gml(BaseFunction):
        """TO_CHAR(SDO_UTIL.TO_GMLGEOMETRY(g))"""
        pass

    class gml311(BaseFunction):
        """TO_CHAR(SDO_UTIL.TO_GML311GEOMETRY(g))"""
        pass
    
    # Spatial Operators
    # http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_operat.htm#insertedID0
    
    class sdo_filter(BaseFunction):
        """SDO_FILTER(g1, g2, param)"""
        pass
    
    class sdo_nn(BaseFunction):
        """SDO_NN(g1, g2, param [, number])"""
        pass
    
    class sdo_nn_distance(BaseFunction):
        """SDO_NN_DISTANCE(number)"""
        pass
    
    class sdo_relate(BaseFunction):
        """SDO_RELATE(g1, g2, param)"""
        pass
    
    class sdo_within_distance(BaseFunction):
        """SDO_WITHIN_DISTANCE(g1, g2, param)"""
        pass
    
    class sdo_anyinteract(BaseFunction):
        """SDO_ANYINTERACT(g1, g2)"""
        pass
    
    class sdo_contains(BaseFunction):
        """SDO_CONTAINS(g1, g2)"""
        pass
    
    class sdo_coveredby(BaseFunction):
        """SDO_COVEREDBY(g1, g2)"""
        pass
    
    class sdo_covers(BaseFunction):
        """SDO_COVERS(g1, g2)"""
        pass
    
    class sdo_equal(BaseFunction):
        """SDO_EQUAL(g1, g2)"""
        pass
    
    class sdo_inside(BaseFunction):
        """SDO_INSIDE(g1, g2)"""
        pass
    
    class sdo_on(BaseFunction):
        """SDO_ON(g1, g2)"""
        pass
    
    class sdo_overlapbdydisjoint(BaseFunction):
        """SDO_OVERLAPBDYDISJOINT(g1, g2)"""
        pass
    
    class sdo_overlapbdyintersect(BaseFunction):
        """SDO_OVERLAPBDYINTERSECT(g1, g2)"""
        pass
    
    class sdo_overlaps(BaseFunction):
        """SDO_OVERLAPS(g1, g2)"""
        pass
    
    class sdo_touch(BaseFunction):
        """SDO_TOUCH(g1, g2)"""
        pass
    
    # Selection of functions of the SDO_GEOM package
    # http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_objgeom.htm#insertedID0
    
    class sdo_geom_sdo_area(BaseFunction):
        """SDO_GEOM.SDO_AREA()"""
        pass
    
    class sdo_geom_sdo_buffer(BaseFunction):
        """SDO_GEOM.SDO_BUFFER()"""
        pass
    
    class sdo_geom_sdo_centroid(BaseFunction):
        """SDO_GEOM.SDO_CENTROID()"""
        pass
    
    class sdo_geom_sdo_concavehull(BaseFunction):
        """SDO_GEOM.SDO_CONCAVEHULL()"""
        pass
    
    class sdo_geom_sdo_concavehull_boundary(BaseFunction):
        """SDO_GEOM.SDO_CONCAVEHULL_BOUNDARY()"""
        pass
    
    class sdo_geom_sdo_convexhull(BaseFunction):
        """SDO_GEOM.SDO_CONVEXHULL()"""
        pass
    
    class sdo_geom_sdo_difference(BaseFunction):
        """SDO_GEOM.SDO_DIFFERENCE()"""
        pass
    
    class sdo_geom_sdo_distance(BaseFunction):
        """SDO_GEOM.SDO_DISTANCE()"""
        pass
    
    class sdo_geom_sdo_intersection(BaseFunction):
        """SDO_GEOM.SDO_INTERSECTION()"""
        pass
    
    class sdo_geom_sdo_length(BaseFunction):
        """SDO_GEOM.SDO_LENGTH()"""
        pass
    
    class sdo_geom_sdo_mbr(BaseFunction):
        """SDO_GEOM.SDO_MBR()"""
        pass
    
    class sdo_geom_sdo_pointonsurface(BaseFunction):
        """SDO_GEOM.SDO_POINTONSURFACE()"""
        pass
    
    class sdo_geom_sdo_union(BaseFunction):
        """SDO_GEOM.SDO_UNION()"""
        pass
    
    class sdo_geom_sdo_xor(BaseFunction):
        """SDO_GEOM.SDO_XOR()"""
        pass
    
    class sdo_geom_sdo_within_distance(BaseFunction):
        """SDO_GEOM.WITHIN_DISTANCE()"""
        pass
 
    @staticmethod
    def _within_distance(compiler, geom1, geom2, distance, additional_params={}):
        """If the first parameter is a geometry column, then the Oracle operator
        SDO_WITHIN_DISTANCE is called and Oracle makes use of the spatial index of
        this column.

        If the first parameter is not a geometry column but a function, which is
        the case when a coordinate transformation had to be added by the spatial
        filter, then the function SDO_GEOM.WITHIN_DISTANCE is called.
        SDO_GEOM.WITHIN_DISTANCE does not make use of a spatial index and requires
        additional parameters: either a tolerance value or a dimension information
        array (DIMINFO) for both geometries. These parameters can be specified when
        defining the spatial filter, e.g.::

            additional_params={'tol': '0.005'}

            or

            from sqlalchemy.sql.expression import text
            diminfo = text("MDSYS.SDO_DIM_ARRAY("\
                "MDSYS.SDO_DIM_ELEMENT('LONGITUDE', -180, 180, 0.000000005),"\
                "MDSYS.SDO_DIM_ELEMENT('LATITUDE', -90, 90, 0.000000005)"\
                ")")
            additional_params={'dim1': diminfo, 'dim2': diminfo}

            filter = create_default_filter(request, Spot, additional_params=additional_params)
            proto.count(request, filter=filter)

        For its distance calculation Oracle by default uses meter as unit for
        geodetic data (like EPSG:4326) and otherwise the 'unit of measurement
        associated with the data'. The unit used for the 'distance' value can be
        changed by adding an entry to 'additional_params'. Valid units are defined
        in the view 'sdo_dist_units'::

            additional_params={'params': 'unit=km'}

        SDO_WITHIN_DISTANCE accepts further parameters, which can also be set using
        the name 'params' together with the unit::

            additional_params={'params': 'unit=km max_resolution=10'}


        Valid options for 'additional_params' are:

            params
                A String containing additional parameters, for example the unit.

            tol
                The tolerance value used for the SDO_GEOM.WITHIN_DISTANCE function call.

            dim1 and dim2
                If the parameter 'tol' is not set, these two parameters have to be
                set. 'dim1' is the DIMINFO for the first geometry (the reprojected
                geometry column) and 'dim2' is the DIMINFO for the second geometry
                (the input geometry from the request). Values for 'dim1' and 'dim2'
                have to be SQLAlchemy expressions, either literal text (text(..))
                or a select query.

        Note that 'tol' or 'dim1'/'dim2' only have to be set when the input
        geometry from the request uses a different CRS than the geometry column!


        SDO_WITHIN_DISTANCE:
        http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_operat.htm#i77653

        SDO_GEOM.WITHIN_DISTANCE:
        http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_objgeom.htm#i856373

        DIMINFO:
        http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_objrelschema.htm#i1010905

        TOLERANCE:
        http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_intro.htm#i884589
        """

        params = additional_params.get('params', '')
        if isinstance(geom1, Column):
            return (func.SDO_WITHIN_DISTANCE(
                        geom1, geom2,
                        'distance=%s %s' % (distance, params)) == 'TRUE')
        else:
            dim1 = additional_params.get('dim1', None)
            dim2 = additional_params.get('dim2', None)
            if dim1 is not None and dim2 is not None:
                return (func.SDO_GEOM.WITHIN_DISTANCE(geom1, dim1,
                                                 distance,
                                                 geom2, dim2,
                                                 params) == 'TRUE')
            else:
                tol = additional_params.get('tol', None)
                if tol is not None:
                    return (func.SDO_GEOM.WITHIN_DISTANCE(geom1,
                                                 distance,
                                                 geom2,
                                                 tol,
                                                 params) == 'TRUE')
                else:
                    raise Exception('No dimension information ("dim1" and "dim2") or '\
                                    'tolerance value ("tol") specified for calling '\
                                    'SDO_GEOM.WITHIN_DISTANCE on Oracle, which is '\
                                    'required when reprojecting.')

class OracleSpatialDialect(SpatialDialect):
    """Implementation of SpatialDialect for Oracle."""
    
    __functions = {
                   functions.wkt: ['TO_CHAR', 'SDO_UTIL.TO_WKTGEOMETRY'],
                   WKTSpatialElement : 'MDSYS.SDO_GEOMETRY',
                   functions.wkb: 'SDO_UTIL.TO_WKBGEOMETRY',
                   WKBSpatialElement : 'MDSYS.SDO_GEOMETRY',
                   functions.dimension : ['MDSYS.ST_GEOMETRY.ST_DIMENSION', 'MDSYS.ST_GEOMETRY'],
                   functions.srid : ['MDSYS.OGC_SRID', 'MDSYS.ST_GEOMETRY'],
                   functions.geometry_type : ['MDSYS.OGC_GeometryType', 'MDSYS.ST_GEOMETRY'],
                   functions.is_valid : None,
                   functions.is_empty : ST_GeometryFunction(func.MDSYS.OGC_IsEmpty, returns_boolean=True, default_cast=True),
                   functions.is_simple : ST_GeometryFunction(func.MDSYS.OGC_IsSimple, returns_boolean=True, default_cast=True),
                   functions.is_closed : ST_GeometryFunction(func.MDSYS.OGC_IsClosed, returns_boolean=True),
                   functions.is_ring : ST_GeometryFunction(func.MDSYS.OGC_IsRing, returns_boolean=True),
                   functions.num_points : ST_GeometryFunction(func.MDSYS.OGC_NumPoints),
                   functions.point_n : ST_GeometryFunction(func.MDSYS.OGC_PointN, True),
                   functions.length : DimInfoFunction(func.SDO_GEOM.SDO_Length),
                   functions.area : DimInfoFunction(func.SDO_GEOM.SDO_Area),
                   functions.x : ST_GeometryFunction(func.MDSYS.OGC_X),
                   functions.y : ST_GeometryFunction(func.MDSYS.OGC_Y),
                   functions.centroid : DimInfoFunction(func.SDO_GEOM.SDO_CENTROID),
                   functions.boundary : ST_GeometryFunction(func.MDSYS.ST_GEOMETRY.ST_Boundary, True),
                   functions.buffer : DimInfoFunction(func.SDO_GEOM.SDO_Buffer),
                   functions.convex_hull : DimInfoFunction(func.SDO_GEOM.SDO_ConvexHull),
                   functions.envelope : ST_GeometryFunction(func.MDSYS.ST_GEOMETRY.ST_Envelope, True),
                   functions.start_point : ST_GeometryFunction(func.MDSYS.OGC_StartPoint, True),
                   functions.end_point : ST_GeometryFunction(func.MDSYS.OGC_EndPoint, True),
                   functions.transform : 'SDO_CS.TRANSFORM',
                   # note: we are not using SDO_Equal because it always requires a spatial index
                   functions.equals : ST_GeometryFunction(func.MDSYS.OGC_EQUALS, returns_boolean=True, relation_function=True, default_cast=True), 
                   functions.distance : DimInfoFunction(func.SDO_GEOM.SDO_Distance),
                   functions.within_distance : DimInfoFunction(func.SDO_GEOM.Within_Distance, returns_boolean=True),
                   functions.disjoint : ST_GeometryFunction(func.MDSYS.OGC_Disjoint, relation_function=True, returns_boolean=True, default_cast=True),                   
                   functions.intersects : ST_GeometryFunction(func.MDSYS.OGC_Intersects, relation_function=True, returns_boolean=True, default_cast=True),
                   functions.touches : ST_GeometryFunction(func.MDSYS.OGC_Touch, relation_function=True, returns_boolean=True, default_cast=True),
                   functions.crosses : ST_GeometryFunction(func.MDSYS.OGC_Cross, relation_function=True, returns_boolean=True, default_cast=True),                   
                   functions.within : ST_GeometryFunction(func.MDSYS.OGC_Within, relation_function=True, returns_boolean=True, default_cast=True),                   
                   functions.overlaps : ST_GeometryFunction(func.MDSYS.OGC_Overlap, relation_function=True, returns_boolean=True, default_cast=True),                   
                   functions.gcontains : ST_GeometryFunction(func.MDSYS.OGC_Contains, relation_function=True, returns_boolean=True, default_cast=True),
                   functions.covers : None, # use oracle_functions.sdo_covers 
                   functions.covered_by : None, # use oracle_functions.sdo_coveredby
                   functions.intersection : DimInfoFunction(func.SDO_GEOM.SDO_INTERSECTION),
                   # aggregate_union => SDO_AGGR_UNION ?
                   
                   oracle_functions.gtype : 'Get_GType',
                   oracle_functions.dims : 'Get_Dims',
                   oracle_functions.kml : ['TO_CHAR', 'SDO_UTIL.TO_KMLGEOMETRY'],
                   oracle_functions.gml : ['TO_CHAR', 'SDO_UTIL.TO_GMLGEOMETRY'],
                   oracle_functions.gml311 : ['TO_CHAR', 'SDO_UTIL.TO_GML311GEOMETRY'],
                   
                   oracle_functions.sdo_filter : BooleanFunction(func.SDO_FILTER),
                   oracle_functions.sdo_nn : BooleanFunction(func.SDO_NN),
                   oracle_functions.sdo_nn_distance : 'SDO_NN_DISTANCE',
                   oracle_functions.sdo_relate : BooleanFunction(func.SDO_RELATE),
                   oracle_functions.sdo_within_distance : BooleanFunction(func.SDO_WITHIN_DISTANCE),
                   oracle_functions.sdo_anyinteract : BooleanFunction(func.SDO_ANYINTERACT),
                   oracle_functions.sdo_contains : BooleanFunction(func.SDO_CONTAINS),
                   oracle_functions.sdo_coveredby : BooleanFunction(func.SDO_COVEREDBY),
                   oracle_functions.sdo_covers : BooleanFunction(func.SDO_COVERS),
                   oracle_functions.sdo_equal : BooleanFunction(func.SDO_EQUAL),
                   oracle_functions.sdo_inside : BooleanFunction(func.SDO_INSIDE),
                   oracle_functions.sdo_on : BooleanFunction(func.SDO_ON),
                   oracle_functions.sdo_overlapbdydisjoint : BooleanFunction(func.SDO_OVERLAPBDYDISJOINT),
                   oracle_functions.sdo_overlapbdyintersect : BooleanFunction(func.SDO_OVERLAPBDYINTERSECT),
                   oracle_functions.sdo_overlaps : BooleanFunction(func.SDO_OVERLAPS),
                   oracle_functions.sdo_touch : BooleanFunction(func.SDO_TOUCH),
                   
                   # same as functions.area
                   oracle_functions.sdo_geom_sdo_area : DimInfoFunction(func.SDO_GEOM.SDO_Area), 
                   # same as functions.buffer
                   oracle_functions.sdo_geom_sdo_buffer : DimInfoFunction(func.SDO_GEOM.SDO_Buffer), 
                   # same as functions.centroid
                   oracle_functions.sdo_geom_sdo_centroid : DimInfoFunction(func.SDO_GEOM.SDO_CENTROID), 
                   oracle_functions.sdo_geom_sdo_concavehull : 'SDO_GEOM.SDO_CONCAVEHULL', 
                   oracle_functions.sdo_geom_sdo_concavehull_boundary : 'SDO_GEOM.SDO_CONCAVEHULL_BOUNDARY',
                   # same as functions.convexhull
                   oracle_functions.sdo_geom_sdo_convexhull : DimInfoFunction(func.SDO_GEOM.SDO_CONVEXHULL), 
                   # same as functions.distance
                   oracle_functions.sdo_geom_sdo_difference : DimInfoFunction(func.SDO_GEOM.SDO_DIFFERENCE), 
                   # same as functions.intersection
                   oracle_functions.sdo_geom_sdo_difference : DimInfoFunction(func.SDO_GEOM.SDO_INTERSECTION), 
                   # same as functions.length
                   oracle_functions.sdo_geom_sdo_length : DimInfoFunction(func.SDO_GEOM.SDO_LENGTH), 
                   oracle_functions.sdo_geom_sdo_mbr : DimInfoFunction(func.SDO_GEOM.SDO_MBR), 
                   oracle_functions.sdo_geom_sdo_pointonsurface : DimInfoFunction(func.SDO_GEOM.SDO_POINTONSURFACE), 
                   oracle_functions.sdo_geom_sdo_union : DimInfoFunction(func.SDO_GEOM.SDO_UNION), 
                   oracle_functions.sdo_geom_sdo_xor : DimInfoFunction(func.SDO_GEOM.SDO_XOR), 
                   # same as functions.within_distance
                   oracle_functions.sdo_geom_sdo_within_distance : DimInfoFunction(func.SDO_GEOM.Within_Distance, returns_boolean=True),

                   functions._within_distance : oracle_functions._within_distance
                  }
    
    __member_functions = (
                          oracle_functions.dims,
                          oracle_functions.gtype
                    )
    
    METADATA_TABLE = table('ALL_SDO_GEOM_METADATA', column('diminfo'), column('table_name'), column('column_name'))
    
    def _get_function_mapping(self):
        return OracleSpatialDialect.__functions
    
    def is_member_function(self, function_class):
        return function_class in self.__member_functions
    
    def process_result(self, value, type):
        value = self.process_wkb(value)
        wkb_element = WKBSpatialElement(value, type.srid, type.name)    
        
        if type.kwargs.has_key("diminfo"):
            # also set the DIMINFO data so that in can be used in function calls, see DimInfoFunction()
            if not type.kwargs.has_key("diminfo_sql"):
                # cache the SQLAlchemy text literal
                type.kwargs["diminfo_sql"] = text(type.kwargs["diminfo"])
            wkb_element.DIMINFO = type.kwargs["diminfo_sql"]
        
        return OraclePersistentSpatialElement(wkb_element)

    def process_wkb(self, value):
        """SDO_UTIL.TO_WKBGEOMETRY(..) returns an object of cx_Oracle.LOB, which we 
        will transform into a buffer.
        """
        if value is not None:
            return buffer(value.read())
        else:
            return value
    
    def bind_wkb_value(self, wkb_element):
        """Append a transformation to BLOB using the Oracle function 'TO_BLOB'.
        """
        if wkb_element is not None and wkb_element.desc is not None:
            return func.TO_BLOB(wkb_element.desc)
        
        return None

    @staticmethod
    def get_diminfo_select(column):
        """Returns a select which queries the DIMINFO array from 'ALL_SDO_GEOM_METADATA'
        for the passed in column.
        
        see: http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_objrelschema.htm#sthref300
        """
        if isinstance(column, InstrumentedAttribute):
            column = column.property.columns[0]
        
        return select([OracleSpatialDialect.METADATA_TABLE.c.diminfo]).where(
                                                and_(OracleSpatialDialect.METADATA_TABLE.c.table_name == column.table.name.upper(),
                                                     OracleSpatialDialect.METADATA_TABLE.c.column_name == column.name.upper()))

    def handle_ddl_before_drop(self, bind, table, column):
        bind.execute("DELETE FROM USER_SDO_GEOM_METADATA WHERE table_name = '%s' AND column_name = '%s'" %
                            (table.name.upper(), column.name.upper()))
        
        if column.type.spatial_index and column.type.kwargs.has_key("diminfo"):
            bind.execute("DROP INDEX %s_%s_sidx" % (table.name, column.name))
          
    def handle_ddl_after_create(self, bind, table, column):    
        bind.execute("ALTER TABLE %s ADD %s %s" % 
                            (table.name, column.name, 'SDO_GEOMETRY'))
        
        if not column.nullable:
            bind.execute("ALTER TABLE %s MODIFY %s NOT NULL" % (table.name, column.name))
        

        if not column.type.kwargs.has_key("diminfo"):
            warnings.warn("No DIMINFO given for '%s.%s', no entry in USER_SDO_GEOM_METADATA will be made "\
                    "and no spatial index will be created." % (table.name, column.name), 
                    exc.SAWarning, stacklevel=3)
        else:
            diminfo = column.type.kwargs["diminfo"]
        
            bind.execute("INSERT INTO USER_SDO_GEOM_METADATA (table_name, column_name, diminfo, srid) " +
                            "VALUES ('%s', '%s', %s, %s)" % 
                            (table.name, column.name, diminfo, column.type.srid))
            
            if column.type.spatial_index:
                bind.execute("CREATE INDEX %s_%s_sidx ON %s(%s) "\
                             "INDEXTYPE IS MDSYS.SPATIAL_INDEX%s" % 
                             (table.name, column.name, table.name, column.name, 
                              self.__get_index_parameters(column.type)))
    
    def __get_index_parameters(self, type):
        type_name = self.__get_oracle_gtype(type)
        
        if type_name == None:
            return ""
        else:
            return " PARAMETERS ('LAYER_GTYPE=%s')" % type_name
    
    def __get_oracle_gtype(self, type):
        """Maps the GeoAlchemy types to SDO_GTYPE values:
        http://download.oracle.com/docs/cd/B19306_01/appdev.102/b14255/sdo_objrelschema.htm#g1013735
        """
        if isinstance(type, LineString):
            return "LINE"
        elif isinstance(type, MultiLineString):
            return "MULTILINE"
        elif isinstance(type, GeometryCollection):
            return "COLLECTION"
        else:
            if type.name == Geometry.name:
                return None
            else:
                return type.name

########NEW FILE########
__FILENAME__ = postgis
# -*- coding: utf-8 -*-
from sqlalchemy import select, func, and_
from geoalchemy.base import SpatialComparator, PersistentSpatialElement, \
    WKBSpatialElement, WKTSpatialElement
from geoalchemy.dialect import SpatialDialect 
from geoalchemy.functions import functions, BaseFunction

class PGComparator(SpatialComparator):
    """Comparator class used for PostGIS
    """
    def __getattr__(self, name):
        try:
            return SpatialComparator.__getattr__(self, name)
        except AttributeError:
            return getattr(pg_functions, name)(self)


class PGPersistentSpatialElement(PersistentSpatialElement):
    """Represents a Geometry value as loaded from the database."""

    def __init__(self, desc):
        self.desc = desc
        
    def __getattr__(self, name):
        try:
            return PersistentSpatialElement.__getattr__(self, name)
        except AttributeError:
            return getattr(pg_functions, name)(self)


class pg_functions(functions):
    """Functions only supported by PostGIS
    """
    
    class svg(BaseFunction):
        """AsSVG(g)"""
        pass
    
    class kml(BaseFunction):
        """AsKML(g)"""
        pass

    class gml(BaseFunction):
        """AsGML(g)"""
        pass
    
    class geojson(BaseFunction):
        """AsGeoJSON(g): available since PostGIS version 1.3.4"""
        pass
    
    class expand(BaseFunction):
        """Expand(g)"""
        pass

    @staticmethod
    def _within_distance(compiler, geom1, geom2, distance, *args):
        """ST_DWithin in early versions of PostGIS 1.3 does not work when
        distance = 0. So we are directly using the (correct) internal
        definition. Note that the definition changed in version 1.3.4, see also:
        http://postgis.refractions.net/docs/ST_DWithin.html
        """
        return and_(func.ST_Expand(geom2, distance).op('&&')(geom1),
                    func.ST_Expand(geom1, distance).op('&&')(geom2),
                    func.ST_Distance(geom1, geom2) <= distance)

class PGSpatialDialect(SpatialDialect):
    """Implementation of SpatialDialect for PostGIS."""
    
    __functions = {
                   WKTSpatialElement: 'ST_GeomFromText',
                   WKBSpatialElement: 'ST_GeomFromWKB',
                   functions.wkt: 'ST_AsText',
                   functions.wkb: 'ST_AsBinary',
                   functions.dimension : 'ST_Dimension',
                   functions.srid : 'ST_SRID',
                   functions.geometry_type : 'ST_GeometryType',
                   functions.is_valid : 'ST_IsValid',
                   functions.is_empty : 'ST_IsEmpty',
                   functions.is_simple : 'ST_IsSimple',
                   functions.is_closed : 'ST_IsClosed',
                   functions.is_ring : 'ST_IsRing',
                   functions.num_points : 'ST_NumPoints',
                   functions.point_n : 'ST_PointN',
                   functions.length : 'ST_Length',
                   functions.area : 'ST_Area',
                   functions.x : 'ST_X',
                   functions.y : 'ST_Y',
                   functions.centroid : 'ST_Centroid',
                   functions.boundary : 'ST_Boundary',
                   functions.buffer : 'ST_Buffer',
                   functions.convex_hull : 'ST_ConvexHull',
                   functions.envelope : 'ST_Envelope',
                   functions.start_point : 'ST_StartPoint',
                   functions.end_point : 'ST_EndPoint',
                   functions.transform : 'ST_Transform',
                   functions.equals : 'ST_Equals',
                   functions.distance : 'ST_Distance',
                   functions.within_distance : 'ST_DWithin',
                   functions.disjoint : 'ST_Disjoint',
                   functions.intersects : 'ST_Intersects',
                   functions.touches : 'ST_Touches',
                   functions.crosses : 'ST_Crosses',
                   functions.within : 'ST_Within',
                   functions.overlaps : 'ST_Overlaps',
                   functions.gcontains : 'ST_Contains',
                   functions.covers : 'ST_Covers',
                   functions.covered_by : 'ST_CoveredBy',
                   functions.intersection : 'ST_Intersection',
                   functions.union : 'ST_Union',
                   functions.collect : 'ST_Collect',
                   functions.extent : 'ST_Extent',
                   pg_functions.svg : 'ST_AsSVG',
                   pg_functions.kml : 'ST_AsKML',
                   pg_functions.gml : 'ST_AsGML',
                   pg_functions.geojson : 'ST_AsGeoJSON',
                   pg_functions.expand : 'ST_Expand',
                   functions._within_distance : pg_functions._within_distance
                  }
    
    def _get_function_mapping(self):
        return PGSpatialDialect.__functions
    
    def process_result(self, value, type):
        if type.wkt_internal:
            return PGPersistentSpatialElement(WKTSpatialElement(value, type.srid))
        return PGPersistentSpatialElement(WKBSpatialElement(value, type.srid))
    
    def handle_ddl_before_drop(self, bind, table, column):
        bind.execute(select([func.DropGeometryColumn((table.schema or 'public'), table.name, column.name)]).execution_options(autocommit=True))
    
    def handle_ddl_after_create(self, bind, table, column):    
        bind.execute(select([func.AddGeometryColumn((table.schema or 'public'), 
                                                    table.name, 
                                                    column.name, 
                                                    column.type.srid, 
                                                    column.type.name, 
                                                    column.type.dimension)]).execution_options(autocommit=True))
        if column.type.spatial_index:
            bind.execute("CREATE INDEX \"idx_%s_%s\" ON \"%s\".\"%s\" USING GIST (%s)" % 
                            (table.name, column.name, (table.schema or 'public'), table.name, column.name))
            
        if not column.nullable:
            bind.execute("ALTER TABLE \"%s\".\"%s\" ALTER COLUMN \"%s\" SET not null" % 
                            ((table.schema or 'public'), table.name, column.name))
            

########NEW FILE########
__FILENAME__ = spatialite
from sqlalchemy import select, func
from sqlalchemy.sql import and_, text, column, table

from geoalchemy.base import SpatialComparator, PersistentSpatialElement,\
    WKBSpatialElement
from geoalchemy.dialect import SpatialDialect 
from geoalchemy.functions import functions, BaseFunction
from geoalchemy.mysql import mysql_functions
from geoalchemy.geometry import GeometryExtensionColumn


class SQLiteComparator(SpatialComparator):
    """Comparator class used for Spatialite
    """
    def __getattr__(self, name):
        try:
            return SpatialComparator.__getattr__(self, name)
        except AttributeError:
            return getattr(sqlite_functions, name)(self)


class SQLitePersistentSpatialElement(PersistentSpatialElement):
    """Represents a Geometry value as loaded from the database."""
    
    def __init__(self, desc):
        self.desc = desc
        
    def __getattr__(self, name):
        try:
            return PersistentSpatialElement.__getattr__(self, name)
        except AttributeError:
            return getattr(sqlite_functions, name)(self)


class sqlite_functions(mysql_functions):
    """Functions only supported by SQLite
    """
    
    class svg(BaseFunction):
        """AsSVG(g)"""
        pass
    
    class fgf(BaseFunction):
        """AsFGF(g)"""
        pass

    @staticmethod
    def _within_distance(compiler, geom1, geom2, distance, *args):
        if isinstance(geom1, GeometryExtensionColumn) and \
           geom1.type.spatial_index and \
           SQLiteSpatialDialect.supports_rtree(compiler.dialect):
            """If querying on a geometry column that also has a spatial index,
            then make use of this index.

            see: http://www.gaia-gis.it/spatialite/spatialite-tutorial-2.3.1.html#t8 and
            http://groups.google.com/group/spatialite-users/browse_thread/thread/34609c7a711ac92d/7688ced3f909039c?lnk=gst&q=index#f6dbc235471574db
            """
            return and_(
                func.Distance(geom1, geom2) <= distance,
                table(geom1.table.fullname, column("rowid")).c.rowid.in_(
                    select([table("idx_%s_%s" % (geom1.table.fullname, geom1.key), column("pkid")).c.pkid]).where(
                        and_(text('xmin') >= func.MbrMinX(geom2) - distance,
                        and_(text('xmax') <= func.MbrMaxX(geom2) + distance,
                        and_(text('ymin') >= func.MbrMinY(geom2) - distance,
                             text('ymax') <= func.MbrMaxY(geom2) + distance))))))
        else:
            return func.Distance(geom1, geom2) <= distance


class SQLiteSpatialDialect(SpatialDialect):
    """Implementation of SpatialDialect for SQLite."""
    
    __functions = { 
                   functions.within_distance : None,
                   functions.length : 'GLength',
                   # not tested
                   #functions.aggregate_union : 'GUnion',
                   sqlite_functions.svg : 'AsSVG',
                   sqlite_functions.fgf : 'AsFGF',
                   mysql_functions.mbr_equal : 'MBREqual',
                   mysql_functions.mbr_disjoint : 'MBRDisjoint',
                   mysql_functions.mbr_intersects : 'MBRIntersects',
                   mysql_functions.mbr_touches : 'MBRTouches',
                   mysql_functions.mbr_within : 'MBRWithin',
                   mysql_functions.mbr_overlaps : 'MBROverlaps',
                   mysql_functions.mbr_contains : 'MBRContains',
                   functions._within_distance : sqlite_functions._within_distance
                   }

    def _get_function_mapping(self):
        return SQLiteSpatialDialect.__functions
    
    def process_result(self, value, type):
        return SQLitePersistentSpatialElement(WKBSpatialElement(value, type.srid))
    
    def handle_ddl_before_drop(self, bind, table, column):
        if column.type.spatial_index and SQLiteSpatialDialect.supports_rtree(bind.dialect):
            bind.execute(select([func.DisableSpatialIndex(table.name, column.name)]).execution_options(autocommit=True))
            bind.execute("DROP TABLE idx_%s_%s" % (table.name, column.name));
        
        bind.execute(select([func.DiscardGeometryColumn(table.name, column.name)]).execution_options(autocommit=True))
    
    def handle_ddl_after_create(self, bind, table, column):
        bind.execute(select([func.AddGeometryColumn(table.name, 
                                                    column.name, 
                                                    column.type.srid, 
                                                    column.type.name, 
                                                    column.type.dimension,
                                                    0 if column.nullable else 1)]).execution_options(autocommit=True))
        if column.type.spatial_index and SQLiteSpatialDialect.supports_rtree(bind.dialect):
            bind.execute("SELECT CreateSpatialIndex('%s', '%s')" % (table.name, column.name))
            bind.execute("VACUUM %s" % table.name)
    
    @staticmethod  
    def supports_rtree(dialect):
        # R-Tree index is only supported since SQLite version 3.6.0
        return dialect.server_version_info[0] > 3 or (dialect.server_version_info[0] == 3 and 
                                                      dialect.server_version_info[1] >= 6)

########NEW FILE########
__FILENAME__ = test_dialect
from unittest import TestCase
from nose.tools import ok_, raises

from sqlalchemy.dialects.sqlite.base import SQLiteDialect
from sqlalchemy.dialects.mysql.base import MySQLDialect
from sqlalchemy.dialects.oracle.base import OracleDialect
from sqlalchemy.dialects.mssql.base import MSDialect
from sqlalchemy.dialects.firebird.base import FBDialect
from sqlalchemy.dialects.postgresql.psycopg2 import PGDialect_psycopg2

from geoalchemy.dialect import DialectManager
from geoalchemy.postgis import PGSpatialDialect
from geoalchemy.mysql import MySQLSpatialDialect
from geoalchemy.spatialite import SQLiteSpatialDialect
from geoalchemy.oracle import OracleSpatialDialect
from geoalchemy.functions import parse_clause
from geoalchemy.base import WKTSpatialElement
from geoalchemy.mssql import MSSpatialDialect


class TestDialectManager(TestCase):

    def test_get_spatial_dialect(self):
        spatial_dialect = DialectManager.get_spatial_dialect(PGDialect_psycopg2())
        ok_(isinstance(spatial_dialect, PGSpatialDialect))
        ok_(isinstance(DialectManager.get_spatial_dialect(MySQLDialect()), MySQLSpatialDialect))
        ok_(isinstance(DialectManager.get_spatial_dialect(SQLiteDialect()), SQLiteSpatialDialect))
        ok_(isinstance(DialectManager.get_spatial_dialect(OracleDialect()), OracleSpatialDialect))
        ok_(isinstance(DialectManager.get_spatial_dialect(MSDialect()), MSSpatialDialect))
        spatial_dialect2 = DialectManager.get_spatial_dialect(PGDialect_psycopg2())
        ok_(spatial_dialect is spatial_dialect2, "only one instance per dialect should be created")

    @raises(NotImplementedError)
    def test_get_spatial_dialect_unknown_dialect(self):
        DialectManager.get_spatial_dialect(FBDialect())

    def test_parse_clause(self):
        ok_(isinstance(parse_clause('POINT(0 0)', None), WKTSpatialElement))
        ok_(isinstance(parse_clause('POINT (0 0)', None), WKTSpatialElement))
        ok_(isinstance(parse_clause('GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))', None), WKTSpatialElement))
        ok_(isinstance(parse_clause('GEOMETRYCOLLECTION (POINT(4 6),LINESTRING(4 6,7 10))', None), WKTSpatialElement))
        ok_(not isinstance(parse_clause('unit=km arc_tolerance=0.05)', None), WKTSpatialElement))


if __name__ == '__main__':
    import sys
    import nose

    sys.argv.append(__name__)
    result = nose.run()
    sys.exit(int(not result))

########NEW FILE########
__FILENAME__ = test_mssql
# -*- coding: utf-8 -*-

from sqlalchemy import (create_engine, MetaData, Column, Integer, String,
        Numeric, func, Table, and_)
from sqlalchemy.orm import sessionmaker, mapper
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.exc import IntegrityError
from geoalchemy import GeometryColumn, Geometry, LineString, Polygon, GeometryDDL, GeometryExtensionColumn, GeometryCollection, DBSpatialElement, WKTSpatialElement, WKBSpatialElement
from geoalchemy.functions import functions
from geoalchemy.mssql import MS_SPATIAL_NULL, ms_functions, MSComparator
from unittest import TestCase
from nose.tools import eq_, ok_, raises, assert_almost_equal

u"""
.. moduleauthor:: Mark Hall <Mark.Hall@nationalarchives.gov.uk>
"""

engine = create_engine('mssql+pyodbc://gis:gis@localhost:4331/gis', echo=True)
metadata = MetaData(engine)
session = sessionmaker(bind=engine)()
Base = declarative_base(metadata=metadata)

class Road(Base):
    __tablename__ = 'ROADS'

    road_id = Column(Integer, primary_key=True)
    road_name = Column(String(255))
    road_geom = GeometryColumn(LineString(2, bounding_box='(xmin=-180, ymin=-90, xmax=180, ymax=90)'), comparator=MSComparator, nullable=False)

class Lake(Base):
    __tablename__ = 'lakes'

    lake_id = Column(Integer, primary_key=True)
    lake_name = Column(String(255))
    lake_geom = GeometryColumn(Polygon(2), comparator=MSComparator)

spots_table = Table('spots', metadata,
                    Column('spot_id', Integer, primary_key=True),
                    Column('spot_height', Numeric(6, 2)),
                    GeometryExtensionColumn('spot_location', Geometry(2)))

class Spot(object):
    def __init__(self, spot_id=None, spot_height=None, spot_location=None):
        self.spot_id = spot_id
        self.spot_height = spot_height
        self.spot_location = spot_location


mapper(Spot, spots_table, properties={
            'spot_location': GeometryColumn(spots_table.c.spot_location, comparator=MSComparator)})

class Shape(Base):
    __tablename__ = 'shapes'

    shape_id = Column(Integer, primary_key=True)
    shape_name = Column(String(255))
    shape_geom = GeometryColumn(GeometryCollection(2))

# enable the DDL extension, which allows CREATE/DROP operations
# to work correctly.  This is not needed if working with externally
# defined tables.
GeometryDDL(Road.__table__)
GeometryDDL(Lake.__table__)
GeometryDDL(spots_table)
GeometryDDL(Shape.__table__)


class TestGeometry(TestCase):

    def setUp(self):
        metadata.drop_all()
        metadata.create_all()

        session.add_all([
            Road(road_name='Jeff Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Peter Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Geordie Rd', road_geom='LINESTRING(-89.2232485796178 42.6420382611465,-89.2449842484076 42.9179140573248,-89.2316084522293 43.106847178344,-89.0710987261147 43.243949044586,-89.092834566879 43.2957802993631,-89.092834566879 43.2957802993631,-89.0309715095541 43.3175159681529)'),
            Road(road_name='Paul St', road_geom='LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147)'),
            Road(road_name='Graeme Ave', road_geom='LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)'),
            Road(road_name='Phil Tce', road_geom='LINESTRING(-88.9356689617834 42.9363057770701,-88.9824842484076 43.0366242484076,-88.9222931656051 43.1085191528662,-88.8487262866242 43.0449841210191)'),
            Lake(lake_name='My Lake', lake_geom='POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))'),
            Lake(lake_name='Lake White', lake_geom='POLYGON((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542))'),
            Lake(lake_name='Lake Blue', lake_geom='POLYGON((-89.0694267515924 43.1335987261147,-89.1078821656051 43.1135350318471,-89.1329617834395 43.0884554140127,-89.1312898089172 43.0466560509554,-89.112898089172 43.0132165605096,-89.0694267515924 42.9898089171975,-89.0343152866242 42.953025477707,-89.0209394904459 42.9179140127389,-89.0042197452229 42.8961783439491,-88.9774681528663 42.8644108280255,-88.9440286624204 42.8292993630573,-88.9072452229299 42.8142515923567,-88.8687898089172 42.815923566879,-88.8687898089172 42.815923566879,-88.8102707006369 42.8343152866242,-88.7734872611465 42.8710987261147,-88.7517515923567 42.9145700636943,-88.7433917197452 42.9730891719745,-88.7517515923567 43.0299363057325,-88.7734872611465 43.0867834394905,-88.7885352038217 43.158678388535,-88.8738057324841 43.1620222929936,-88.947372611465 43.1937898089172,-89.0042197452229 43.2138535031847,-89.0410031847134 43.2389331210191,-89.0710987261147 43.243949044586,-89.0660828025478 43.2238853503185,-89.0543789808917 43.203821656051,-89.0376592356688 43.175398089172,-89.0292993630573 43.1519904458599,-89.0376592356688 43.1369426751592,-89.0393312101911 43.1386146496815,-89.0393312101911 43.1386146496815,-89.0510350318471 43.1335987261147,-89.0694267515924 43.1335987261147))'),
            Lake(lake_name='Lake Deep', lake_geom='POLYGON((-88.9122611464968 43.038296178344,-88.9222929936306 43.0399681528663,-88.9323248407643 43.0282643312102,-88.9206210191083 43.0182324840764,-88.9105891719745 43.0165605095542,-88.9005573248408 43.0232484076433,-88.9072452229299 43.0282643312102,-88.9122611464968 43.038296178344))'),
            Spot(spot_height=420.40, spot_location='POINT(-88.5945861592357 42.9480095987261)'),
            Spot(spot_height=102.34, spot_location='POINT(-88.9055734203822 43.0048567324841)'),
            Spot(spot_height=388.62, spot_location='POINT(-89.201512910828 43.1051752038217)'),
            Spot(spot_height=454.66, spot_location='POINT(-88.3304141847134 42.6269904904459)'),
            Shape(shape_name='Bus Stop', shape_geom='GEOMETRYCOLLECTION(POINT(-88.3304141847134 42.6269904904459))'),
            Shape(shape_name='Jogging Track', shape_geom='GEOMETRYCOLLECTION(LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147))'),
            Shape(shape_name='Play Ground', shape_geom='GEOMETRYCOLLECTION(POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936)))'),
            ])
        self.r = Road(road_name='Dave Cres', road_geom=WKTSpatialElement('LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)', 4326))
        session.add(self.r)
        session.commit()

    def tearDown(self):
        session.rollback()
        metadata.drop_all()

    def test_geometry_type(self):
        r = session.query(Road).get(1)
        l = session.query(Lake).get(1)
        s = session.query(Spot).get(1)
        eq_(session.scalar(r.road_geom.geometry_type), 'LineString')
        eq_(session.scalar(l.lake_geom.geometry_type), 'Polygon')
        eq_(session.scalar(s.spot_location.geometry_type), 'Point')
        eq_(session.scalar(functions.geometry_type(r.road_geom)), 'LineString')
        ok_(session.query(Road).filter(Road.road_geom.geometry_type == 'LineString').first())

    def test_wkt(self):
        l = session.query(Lake).get(1)
        assert session.scalar(self.r.road_geom.wkt) == 'LINESTRING (-88.6748409363057 43.1035032292994, -88.6464173694267 42.9981688343949, -88.607961955414 42.9680732929936, -88.5160033566879 42.9363057770701, -88.4390925286624 43.0031847579618)'
        eq_(session.scalar(l.lake_geom.wkt),'POLYGON ((-88.7968950764331 43.2305732929936, -88.7935511273885 43.1553344394904, -88.716640299363 43.1570064140127, -88.7250001719745 43.2339172420382, -88.7968950764331 43.2305732929936))')
        ok_(not session.query(Spot).filter(Spot.spot_location.wkt == 'POINT (0,0)').first())
        ok_(session.query(Spot).get(1) is
            session.query(Spot).filter(Spot.spot_location == 'POINT (-88.5945861592357 42.9480095987261)').first())
        r = session.query(Road).get(1)
        p = DBSpatialElement(session.scalar(r.road_geom.point_n(5)))
        eq_(session.scalar(p.wkt), u'POINT (-88.3655256496815 43.1402866687898)')
        eq_(session.scalar(WKTSpatialElement('POINT (-88.5769371859941 42.9915634871979)').wkt), u'POINT (-88.5769371859941 42.9915634871979)')
        eq_(session.query(Spot.spot_location.wkt).filter(Spot.spot_id == 1).first(), (u'POINT (-88.5945861592357 42.9480095987261)',))

    def test_coords(self):
        eq_(self.r.road_geom.coords(session), [[-88.6748409363057,43.1035032292994],[-88.6464173694267,42.9981688343949],[-88.607961955414,42.9680732929936],[-88.5160033566879,42.9363057770701],[-88.4390925286624,43.0031847579618]])
        l = session.query(Lake).filter(Lake.lake_name=="Lake Deep").one()
        eq_(l.lake_geom.coords(session), [[[-88.9122611464968,43.038296178344],[-88.9222929936306,43.0399681528663],[-88.9323248407643,43.0282643312102],[-88.9206210191083,43.0182324840764],[-88.9105891719745,43.0165605095542],[-88.9005573248408,43.0232484076433],[-88.9072452229299,43.0282643312102],[-88.9122611464968,43.038296178344]]])
        s = session.query(Spot).filter(Spot.spot_height==102.34).one()
        eq_(s.spot_location.coords(session), [-88.905573420382197, 43.0048567324841])

    def test_wkb(self):
        eq_(session.scalar(WKBSpatialElement(session.scalar(self.r.road_geom.wkb)).wkt),
            u'LINESTRING (-88.6748409363057 43.1035032292994, -88.6464173694267 42.9981688343949, -88.607961955414 42.9680732929936, -88.5160033566879 42.9363057770701, -88.4390925286624 43.0031847579618)')
        eq_(session.scalar(self.r.road_geom.wkb), self.r.road_geom.geom_wkb)
        ok_(not session.query(Spot).filter(Spot.spot_location.wkb == '101').first())
        centroid_geom = DBSpatialElement(session.scalar(session.query(Lake).first().lake_geom.centroid))
        eq_(session.scalar(WKBSpatialElement(session.scalar(centroid_geom.wkb)).wkt), u'POINT (-88.757840057564835 43.193797540630335)')

    @raises(AttributeError)
    def test_svg(self):
        eq_(session.scalar(self.r.road_geom.svg), 'M -88.674840936305699 -43.103503229299399 -88.6464173694267 -42.998168834394903 -88.607961955413998 -42.968073292993601 -88.516003356687904 -42.936305777070103 -88.4390925286624 -43.003184757961797')
        ok_(self.r is session.query(Road).filter(Road.road_geom.svg == 'M -88.674840936305699 -43.103503229299399 -88.6464173694267 -42.998168834394903 -88.607961955413998 -42.968073292993601 -88.516003356687904 -42.936305777070103 -88.4390925286624 -43.003184757961797').first())
        eq_(session.scalar(func.svg('POINT(-88.9055734203822 43.0048567324841)')), u'cx="-88.905573420382197" cy="-43.0048567324841"')
        ok_(session.query(Spot).filter(Spot.spot_location.svg == 'cx="-88.905573420382197" cy="-43.0048567324841"').first())

    def test_gml(self):
        eq_(session.scalar(self.r.road_geom.gml), '<LineString xmlns="http://www.opengis.net/gml"><posList>-88.6748409363057 43.1035032292994 -88.6464173694267 42.9981688343949 -88.607961955414 42.9680732929936 -88.5160033566879 42.9363057770701 -88.4390925286624 43.0031847579618</posList></LineString>')

    @raises(AttributeError)
    def test_kml(self):
        s = session.query(Spot).filter(Spot.spot_height==420.40).one()
        eq_(session.scalar(s.spot_location.kml), u'<Point><coordinates>-88.5945861592357,42.9480095987261</coordinates></Point>')

    @raises(AttributeError)
    def test_geojson(self):
        s = session.query(Spot).filter(Spot.spot_height==420.40).one()
        session.scalar(s.spot_location.geojson)

    def test_dimension(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        eq_(session.scalar(r.road_geom.dimension), 1)
        eq_(session.scalar(l.lake_geom.dimension), 2)
        ok_(session.query(Spot).filter(Spot.spot_location.dimension == 0).first() is not None)
        eq_(session.scalar(functions.dimension('POINT(-88.5945861592357 42.9480095987261)')), 0)

    def test_srid(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(r.road_geom.srid), 4326)
        ok_(session.query(Spot).filter(Spot.spot_location.srid == 4326).first() is not None)
        eq_(session.scalar(functions.srid('POINT(-88.5945861592357 42.9480095987261)')), 4326)

    def test_is_empty(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        assert not session.scalar(r.road_geom.is_empty)
        assert not session.scalar(l.lake_geom.is_empty)
        ok_(session.query(Spot).filter(Spot.spot_location.is_empty == False).first() is not None)
        eq_(session.scalar(functions.is_empty('POINT(-88.5945861592357 42.9480095987261)')), False)

    def test_is_simple(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        assert session.scalar(r.road_geom.is_simple)
        assert session.scalar(l.lake_geom.is_simple)
        ok_(session.query(Spot).filter(Spot.spot_location.is_simple == True).first() is not None)
        eq_(session.scalar(functions.is_simple('LINESTRING(1 1,2 2,2 3.5,1 3,1 2,2 1)')), False)

    def test_is_closed(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        assert not session.scalar(r.road_geom.is_closed)
        assert session.scalar(l.lake_geom.is_closed)
        ok_(session.query(Lake).filter(Lake.lake_geom.is_closed == True).first() is not None)
        eq_(session.scalar(functions.is_closed('LINESTRING(0 0, 1 1)')), False)

    def test_is_ring(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert not session.scalar(r.road_geom.is_ring)
        ok_(session.query(Road).filter(Road.road_geom.is_ring == True).first() is None)
        eq_(session.scalar(functions.is_ring('LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)')), False)

    def test_num_points(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(session.scalar(l.lake_geom.num_points))
        eq_(session.scalar(r.road_geom.num_points), 5)
        ok_(session.scalar(s.spot_location.num_points))
        ok_(session.query(Road).filter(Road.road_geom.num_points == 5).first() is not None)
        eq_(session.scalar(functions.num_points('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)')), 4)

    def test_point_n(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        ok_(session.scalar(l.lake_geom.point_n(1)))
        ok_(session.query(Road).filter(Road.road_geom.point_n(5) == WKTSpatialElement('POINT(-88.3655256496815 43.1402866687898)')).first() is not None)
        eq_(session.scalar(functions.wkt(r.road_geom.point_n(5))), u'POINT (-88.3655256496815 43.1402866687898)')
        eq_(session.scalar(functions.wkt(functions.point_n('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)', 1)))
                           , u'POINT (77.29 29.07)')

    def test_persistent(self):
        eq_(session.scalar(self.r.road_geom.wkt),
            u'LINESTRING (-88.6748409363057 43.1035032292994, -88.6464173694267 42.9981688343949, -88.607961955414 42.9680732929936, -88.5160033566879 42.9363057770701, -88.4390925286624 43.0031847579618)')

    def test_eq(self):
        r1 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r2 = session.query(Road).filter(Road.road_geom == 'LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)').one()
        r3 = session.query(Road).filter(Road.road_geom == r1.road_geom).one()
        ok_(r1 is r2 is r3)

    def test_length(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert_almost_equal(session.scalar(r.road_geom.length), 0.496071476676014)
        ok_(session.query(Road).filter(Road.road_geom.length > 0).first() is not None)
        assert_almost_equal(session.scalar(functions.length('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)')), 0.62916306324869398)

    def test_area(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        assert_almost_equal(session.scalar(l.lake_geom.area), 0.10475991566721)
        ok_(session.query(Lake).filter(Lake.lake_geom.area > 0).first() is not None)
        assert_almost_equal(session.scalar(functions.area(WKTSpatialElement('POLYGON((743238 2967416,743238 2967450,743265 2967450,743265.625 2967416,743238 2967416))',2249))),
                            928.625)

    def test_x(self):
        s = session.query(Spot).filter(Spot.spot_height==420.40).one()
        eq_(session.scalar(s.spot_location.x), -88.5945861592357)
        s = session.query(Spot).filter(and_(Spot.spot_location.x < 0, Spot.spot_location.y > 42)).all()
        ok_(s is not None)
        eq_(session.scalar(functions.x('POINT(-88.3655256496815 43.1402866687898)')), -88.3655256496815)

    def test_y(self):
        s = session.query(Spot).filter(Spot.spot_height==420.40).one()
        eq_(session.scalar(s.spot_location.y), 42.9480095987261)
        s = session.query(Spot).filter(and_(Spot.spot_location.y < 0, Spot.spot_location.y > 42)).all()
        ok_(s is not None)
        eq_(session.scalar(functions.y('POINT(-88.3655256496815 43.1402866687898)')), 43.1402866687898)

    def test_centroid(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        ok_(not session.scalar(functions.wkt(r.road_geom.centroid)))
        eq_(session.scalar(functions.wkt(l.lake_geom.centroid)), u'POINT (-88.921453826951719 43.019149768468026)')
        ok_(session.query(Spot).filter(Spot.spot_location.centroid == WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)')).first() is None)
        ok_(session.scalar(functions.wkt(functions.centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, 0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'))) is None)

    def test_boundary(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.boundary)), u'MULTIPOINT ((-88.5912422100082 43.187101952731609), (-88.547770872712135 42.698885396122932))')
        ok_(session.query(Road).filter(Road.road_geom.boundary == WKTSpatialElement('MULTIPOINT ((-88.5912422100082 43.187101952731609), (-88.547770872712135 42.698885396122932))')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.boundary('POLYGON((1 1,0 0, -1 1, 1 1))'))),
            u'LINESTRING (0 0, 1 1, -1 1, 0 0)')

    def test_buffer(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert_almost_equal(session.scalar(functions.area(r.road_geom.buffer(10.0))), 323.99187776147323)
        ok_(session.query(Spot).filter(functions.within('POINT(-88.5945861592357 42.9480095987261)', Spot.spot_location.buffer(10))).first() is not None)
        assert_almost_equal(session.scalar(functions.area(functions.buffer('POINT(-88.5945861592357 42.9480095987261)', 10))), 314.12087152405275)

    def test_convex_hull(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.convex_hull)),
            u'POLYGON ((-88.547770872712135 42.698885396122932, -88.5912422100082 43.187101952731609, -88.602946031838655 43.088455460965633, -88.609633930027485 42.969745270907879, -88.547770872712135 42.698885396122932))')
        ok_(session.query(Spot).filter(Spot.spot_location.convex_hull == WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.convex_hull('POINT(-88.5945861592357 42.9480095987261)'))),
            u'POINT (-88.594586159235689 42.948009598726117)')

    def test_envelope(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.envelope)),
            u'POLYGON ((-88.6096339299363 42.6988853949045, -88.5477708726115 42.6988853949045, -88.5477708726115 43.187101955414, -88.6096339299363 43.187101955414, -88.6096339299363 42.6988853949045))')
        eq_(session.scalar(functions.geometry_type(self.r.road_geom.envelope)), 'Polygon')
        ok_(session.query(Spot).filter(Spot.spot_location.envelope == WKTSpatialElement('POLYGON ((-88.9055744203822 43.0048557324841, -88.9055724203822 43.0048557324841, -88.9055724203822 43.0048577324841, -88.9055744203822 43.0048577324841, -88.9055744203822 43.0048557324841))')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.envelope('POINT(-88.5945861592357 42.9480095987261)'))),
            u'POLYGON ((-88.5945871592357 42.948008598726105, -88.5945851592357 42.948008598726105, -88.5945851592357 42.9480105987261, -88.5945871592357 42.9480105987261, -88.5945871592357 42.948008598726105))')

    def test_start_point(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.start_point)),
            u'POINT (-88.5477708726115 42.6988853949045)')
        ok_(session.query(Road).filter(Road.road_geom.start_point == WKTSpatialElement('POINT(-88.9139332929936 42.5082802993631)')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.start_point('LINESTRING(0 1, 0 2)'))),
            u'POINT (0 1)')

    def test_end_point(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.end_point)),
            u'POINT (-88.5912422101911 43.187101955414)')
        ok_(session.query(Road).filter(Road.road_geom.end_point == WKTSpatialElement('POINT(-88.3655256496815 43.1402866687898)')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.end_point('LINESTRING(0 1, 0 2)'))),
            u'POINT (0 2)')

    @raises(NotImplementedError)
    def test_transform(self):
        spot = session.query(Spot).get(1)
        # compare the coordinates using a tolerance, because they may vary on different systems
        assert_almost_equal(session.scalar(functions.x(spot.spot_location.transform(2249))), -3890517.6109559298)
        assert_almost_equal(session.scalar(functions.y(spot.spot_location.transform(2249))), 3627658.6746507999)
        ok_(session.query(Spot).filter(Spot.spot_location.transform(2249) == WKTSpatialElement('POINT(-3890517.61095593 3627658.6746508)', 2249)).first() is not None)
        eq_(session.scalar(functions.wkt(functions.transform(WKTSpatialElement('POLYGON((743238 2967416,743238 2967450,743265 2967450,743265.625 2967416,743238 2967416))', 2249), 4326))),
            u'POLYGON((-71.1776848522251 42.3902896512902,-71.1776843766326 42.3903829478009,-71.1775844305465 42.3903826677917,-71.1775825927231 42.3902893647987,-71.1776848522251 42.3902896512902))')

    # Test Geometry Relationships

    def test_equals(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Peter Rd').one()
        r3 = session.query(Road).filter(Road.road_name=='Paul St').one()
        equal_roads = session.query(Road).filter(Road.road_geom.equals(r1.road_geom)).all()
        ok_(r1 in equal_roads)
        ok_(r2 in equal_roads)
        ok_(r3 not in equal_roads)
        ok_(session.query(Spot).filter(Spot.spot_location.equals(WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)'))).first() is not None)
        eq_(session.scalar(functions.equals('POINT(-88.5945861592357 42.9480095987261)', 'POINT(-88.5945861592357 42.9480095987261)')), True)

    def test_distance(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        r3 = session.query(Road).filter(Road.road_name=='Peter Rd').one()
        assert_almost_equal(session.scalar(r1.road_geom.distance(r2.road_geom)), 0.336997238682841)
        eq_(session.scalar(r1.road_geom.distance(r3.road_geom)), 0.0)
        ok_(session.query(Spot).filter(Spot.spot_location.distance(WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)')) < 10).first() is not None)
        assert_almost_equal(session.scalar(functions.distance('POINT(-88.5945861592357 42.9480095987261)', 'POINT(-88.5945861592357 42.9480095987261)')), 0)

    @raises(NotImplementedError)
    def test_within_distance(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        roads_within_distance = session.query(Road).filter(
            Road.road_geom.within_distance(r1.road_geom, 0.20)).all()
        ok_(r2 in roads_within_distance)
        ok_(r3 not in roads_within_distance)
        eq_(session.scalar(functions.within_distance('POINT(-88.9139332929936 42.5082802993631)', 'POINT(-88.9139332929936 35.5082802993631)', 10)), True)

    def test_disjoint(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        disjoint_roads = session.query(Road).filter(Road.road_geom.disjoint(r1.road_geom)).all()
        ok_(r2 not in disjoint_roads)
        ok_(r3 in disjoint_roads)
        eq_(session.scalar(functions.disjoint('POINT(0 0)', 'LINESTRING ( 2 0, 0 2 )')), True)


    def test_intersects(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        intersecting_roads = session.query(Road).filter(Road.road_geom.intersects(r1.road_geom)).all()
        ok_(r2 in intersecting_roads)
        ok_(r3 not in intersecting_roads)
        eq_(session.scalar(functions.intersects('POINT(0 0)', 'LINESTRING ( 2 0, 0 2 )')), False)

    def test_touches(self):
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        r = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        touching_lakes = session.query(Lake).filter(Lake.lake_geom.touches(r.road_geom)).all()
        ok_(not session.scalar(l1.lake_geom.touches(r.road_geom)))
        ok_(session.scalar(l2.lake_geom.touches(r.road_geom)))
        ok_(l1 not in touching_lakes)
        ok_(l2 in touching_lakes)
        eq_(session.scalar(functions.touches('POINT(1 1)', 'LINESTRING (0 0, 1 1, 0 2)')), False)

    def test_crosses(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Paul St').one()
        l = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        crossing_roads = session.query(Road).filter(Road.road_geom.crosses(l.lake_geom)).all()
        ok_(not session.scalar(r1.road_geom.crosses(l.lake_geom)))
        ok_(session.scalar(r2.road_geom.crosses(l.lake_geom)))
        ok_(r1 not in crossing_roads)
        ok_(r2 in crossing_roads)
        eq_(session.scalar(functions.crosses('LINESTRING(0 1, 2 1)', 'LINESTRING (0 0, 1 2, 0 2)')), True)

    def test_within(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        spots_within = session.query(Spot).filter(Spot.spot_location.within(l.lake_geom)).all()
        ok_(session.scalar(p1.spot_location.within(l.lake_geom)))
        ok_(not session.scalar(p2.spot_location.within(l.lake_geom)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)
        eq_(session.scalar(functions.within('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), True)
        buffer_geom = DBSpatialElement(session.scalar(l.lake_geom.buffer(10.0)))
        spots_within = session.query(Spot).filter(l.lake_geom.within(buffer_geom)).all()
        ok_(p1 in spots_within)
        ok_(p2 in spots_within)

    def test_overlaps(self):
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l3 = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        overlapping_lakes = session.query(Lake).filter(Lake.lake_geom.overlaps(l3.lake_geom)).all()
        ok_(not session.scalar(l1.lake_geom.overlaps(l3.lake_geom)))
        ok_(session.scalar(l2.lake_geom.overlaps(l3.lake_geom)))
        ok_(l1 not in overlapping_lakes)
        ok_(l2 in overlapping_lakes)
        eq_(session.scalar(functions.overlaps('POLYGON((2 1, 4 1, 4 3, 2 3, 2 1))', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), True)

    def test_contains(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains(p1.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        ok_(session.scalar(l.lake_geom.gcontains(WKTSpatialElement('POINT(-88.9055734203822 43.0048567324841)'))))
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains('POINT(-88.9055734203822 43.0048567324841)')).all()
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        spots_within = session.query(Spot).filter(l.lake_geom.gcontains(Spot.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)
        eq_(session.scalar(functions.gcontains('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), False)

    @raises(NotImplementedError)
    def test_covers(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        covering_lakes = session.query(Lake).filter(Lake.lake_geom.covers(p1.spot_location)).all()
        ok_(session.scalar(l.lake_geom.covers(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.covers(p2.spot_location)))
        ok_(l in covering_lakes)
        ok_(l1 not in covering_lakes)
        eq_(session.scalar(functions.gcontains('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), False)

    @raises(NotImplementedError)
    def test_covered_by(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        covered_spots = session.query(Spot).filter(Spot.spot_location.covered_by(l.lake_geom)).all()
        ok_(session.scalar(p1.spot_location.covered_by(l.lake_geom)))
        ok_(not session.scalar(p2.spot_location.covered_by(l.lake_geom)))
        ok_(p1 in covered_spots)
        ok_(p2 not in covered_spots)
        eq_(session.scalar(functions.covered_by('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), True)

    @raises(NotImplementedError)
    def test_intersection(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        r = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        s = session.query(Spot).filter(Spot.spot_height==454.66).one()
        eq_(session.scalar(func.STAsText(l.lake_geom.intersection(s.spot_location))), 'GEOMETRYCOLLECTION EMPTY')
        eq_(session.scalar(func.STAsText(session.scalar(l.lake_geom.intersection(r.road_geom)))), 'POINT(-89.0710987261147 43.243949044586)')
        l = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        r = session.query(Road).filter(Road.road_name=='Paul St').one()
        eq_(session.scalar(func.STAsText(session.scalar(l.lake_geom.intersection(r.road_geom)))), 'LINESTRING(-88.1430673666454 42.6255500261493,-88.1140839697546 42.6230657349872)')
        ok_(session.query(Lake).filter(Lake.lake_geom.intersection(r.road_geom) == WKTSpatialElement('LINESTRING(-88.1430673666454 42.6255500261493,-88.1140839697546 42.6230657349872)')).first() is not None)

    @raises(IntegrityError)
    def test_constraint_nullable(self):
        spot_null = Spot(spot_height=420.40, spot_location=MS_SPATIAL_NULL)
        session.add(spot_null)
        session.commit();
        ok_(True)
        road_null = Road(road_name='Jeff Rd', road_geom=MS_SPATIAL_NULL)
        session.add(road_null)
        session.commit();

    # Test SQL Server specific functions

    def test_text_zm(self):
        engine.execute('INSERT INTO [spots] VALUES(%f, geometry::STGeomFromText(%s, %i))' % (130.23, "'POINT (-88.5945861592357 42.9480095987261 130.23 1)'", 4326))
        eq_(session.query(Spot.spot_location.text_zm.label('text_zm')).filter(Spot.spot_height==130.23).first().text_zm, u'POINT (-88.5945861592357 42.9480095987261 130.23 1)')
        eq_(session.query(Spot.spot_location.text_zm.label('text_zm')).filter(Spot.spot_height==420.40).first().text_zm, u'POINT (-88.5945861592357 42.9480095987261)')


    def test_buffer_with_tolerance(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert_almost_equal(session.scalar(functions.area(r.road_geom.buffer_with_tolerance(10.0, 20, 1))), 214.63894668789601)
        assert_almost_equal(session.scalar(functions.area(r.road_geom.buffer_with_tolerance(10.0, 20, 0))), 214.63894668789601)
        ok_(session.query(Spot).filter(functions.within('POINT(-88.5945861592357 42.9480095987261)', Spot.spot_location.buffer(10))).first() is not None)
        assert_almost_equal(session.scalar(functions.area(ms_functions.buffer_with_tolerance('POINT(-88.5945861592357 42.9480095987261)', 10, 2, 0))), 306.21843345678644)

    def test_filter(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        intersecting_roads = session.query(Road).filter(Road.road_geom.filter(r1.road_geom)).all()
        ok_(r2 in intersecting_roads)
        ok_(r3 not in intersecting_roads)
        eq_(session.scalar(ms_functions.filter('POINT(0 0)', 'LINESTRING ( 2 0, 0 2 )')), False)

    def test_instance_of(self):
        ok_(session.query(Road).filter(Road.road_geom.instance_of('LINESTRING')).first() is not None)
        ok_(session.query(Lake).filter(Lake.lake_geom.instance_of('POLYGON')).first() is not None)
        ok_(session.query(Spot).filter(Spot.spot_location.instance_of('POINT')).first() is not None)

    def test_extended_coords(self):
        engine.execute('INSERT INTO [spots] VALUES(%f, geometry::STGeomFromText(%s, %i))' % (130.23, "'POINT (-88.5945861592357 42.9480095987261 130.23 1)'", 4326))
        p = session.query(Spot.spot_location.z.label('z'), Spot.spot_location.m.label('m')).filter(Spot.spot_height==130.23).first()
        eq_(p.z, 130.23)
        eq_(p.m, 1)
        p = session.query(Spot.spot_location.z.label('z'), Spot.spot_location.m.label('m')).filter(Spot.spot_height==420.40).first()
        ok_(p.z is None)
        ok_(p.m is None)

    def test_make_valid(self):
        session.add(Shape(shape_name=u'Invalid Shape', shape_geom=WKTSpatialElement(u'LINESTRING(0 2, 1 1, 1 0, 1 1, 2 2)')))
        invalid_line = session.query(Shape).filter(Shape.shape_name==u'Invalid Shape').first()
        eq_(session.scalar(invalid_line.shape_geom.is_valid), 0)
        invalid_line.shape_geom = DBSpatialElement(session.scalar(invalid_line.shape_geom.make_valid))
        valid_line = session.query(Shape).filter(Shape.shape_name==u'Invalid Shape').first()
        eq_(session.scalar(valid_line.shape_geom.is_valid), 1)


    def test_reduce(self):
        r = session.query(Road).first()
        eq_(session.scalar(DBSpatialElement(session.scalar(r.road_geom.reduce(0.5))).wkt),
            u'LINESTRING (-88.9139332929936 42.5082802993631, -88.3655256496815 43.1402866687898)')
        eq_(session.scalar(DBSpatialElement(session.scalar(r.road_geom.reduce(0.05))).wkt),
            u'LINESTRING (-88.9139332929936 42.5082802993631, -88.6113059044586 42.9680732929936, -88.3655256496815 43.1402866687898)')
        eq_(session.scalar(DBSpatialElement(session.scalar(r.road_geom.reduce(0.0000000000001))).wkt),
            session.scalar(r.road_geom.wkt))


    def test_to_string(self):
        engine.execute('INSERT INTO [spots] VALUES(%f, geometry::STGeomFromText(%s, %i))' % (130.23, "'POINT (-88.5945861592357 42.9480095987261 130.23 1)'", 4326))
        session.add(Lake(lake_name=u'Vanished lake', lake_geom=MS_SPATIAL_NULL))
        eq_(session.query(Spot.spot_location.text_zm.label('to_string')).filter(Spot.spot_height==130.23).first().to_string, u'POINT (-88.5945861592357 42.9480095987261 130.23 1)')
        eq_(session.query(Spot.spot_location.text_zm.label('to_string')).filter(Spot.spot_height==420.40).first().to_string, u'POINT (-88.5945861592357 42.9480095987261)')
        ok_(session.query(Lake.lake_geom.to_string.label('to_string')).filter(Lake.lake_name==u'Vanished lake').first().to_string is None)


if __name__ == '__main__':
    import sys
    import nose

    sys.argv.append(__name__)
    result = nose.run()
    sys.exit(int(not result))

########NEW FILE########
__FILENAME__ = test_mysql
from unittest import TestCase
from binascii import b2a_hex
from sqlalchemy import (create_engine, MetaData, Column, Integer,
        Unicode, Numeric, func, Table)
from sqlalchemy.orm import sessionmaker, mapper
from sqlalchemy.ext.declarative import declarative_base

from geoalchemy import (GeometryColumn, Point, Polygon, LineString,
        GeometryDDL, WKTSpatialElement, DBSpatialElement, GeometryExtensionColumn,
        WKBSpatialElement)
from geoalchemy.functions import functions
from nose.tools import ok_, eq_, raises, assert_almost_equal
from sqlalchemy import and_
from sqlalchemy.exc import OperationalError

from geoalchemy.mysql import MySQLComparator, mysql_functions

engine = create_engine('mysql://gis:gis@localhost/gis', echo=True)
metadata = MetaData(engine)
session = sessionmaker(bind=engine)()
Base = declarative_base(metadata=metadata)

class Road(Base):
    __tablename__ = 'roads'

    road_id = Column(Integer, primary_key=True)
    road_name = Column(Unicode(40))
    road_geom = GeometryColumn(LineString(2, srid=4326, spatial_index=False), comparator=MySQLComparator, nullable=False)

class Lake(Base):
    __tablename__ = 'lakes'

    lake_id = Column(Integer, primary_key=True)
    lake_name = Column(Unicode(40))
    lake_geom = GeometryColumn(Polygon(2, srid=4326), comparator=MySQLComparator)

spots_table = Table('spots', metadata,
                    Column('spot_id', Integer, primary_key=True),
                    Column('spot_height', Numeric(precision=10, scale=2)),
                    GeometryExtensionColumn('spot_location', Point(2, srid=4326)))

class Spot(object):
    def __init__(self, spot_id=None, spot_height=None, spot_location=None):
        self.spot_id = spot_id
        self.spot_height = spot_height
        self.spot_location = spot_location


mapper(Spot, spots_table, properties={
            'spot_location': GeometryColumn(spots_table.c.spot_location,
                                            comparator=MySQLComparator)})

# enable the DDL extension, which allows CREATE/DROP operations
# to work correctly.  This is not needed if working with externally
# defined tables.
GeometryDDL(Road.__table__)
GeometryDDL(Lake.__table__)
GeometryDDL(spots_table)

class TestGeometry(TestCase):

    def setUp(self):

        metadata.drop_all()
        metadata.create_all()

        # Add objects.  We can use strings...
        session.add_all([
            Road(road_name=u'Jeff Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name=u'Peter Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name=u'Geordie Rd', road_geom='LINESTRING(-89.2232485796178 42.6420382611465,-89.2449842484076 42.9179140573248,-89.2316084522293 43.106847178344,-89.0710987261147 43.243949044586,-89.092834566879 43.2957802993631,-89.092834566879 43.2957802993631,-89.0309715095541 43.3175159681529)'),
            Road(road_name=u'Paul St', road_geom='LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147)'),
            Road(road_name=u'Graeme Ave', road_geom='LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)'),
            Road(road_name=u'Phil Tce', road_geom='LINESTRING(-88.9356689617834 42.9363057770701,-88.9824842484076 43.0366242484076,-88.9222931656051 43.1085191528662,-88.8487262866242 43.0449841210191)'),
            Lake(lake_name=u'My Lake', lake_geom='POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))'),
            Lake(lake_name=u'Lake White', lake_geom='POLYGON((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542))'),
            Lake(lake_name=u'Lake Blue', lake_geom='POLYGON((-89.0694267515924 43.1335987261147,-89.1078821656051 43.1135350318471,-89.1329617834395 43.0884554140127,-89.1312898089172 43.0466560509554,-89.112898089172 43.0132165605096,-89.0694267515924 42.9898089171975,-89.0343152866242 42.953025477707,-89.0209394904459 42.9179140127389,-89.0042197452229 42.8961783439491,-88.9774681528663 42.8644108280255,-88.9440286624204 42.8292993630573,-88.9072452229299 42.8142515923567,-88.8687898089172 42.815923566879,-88.8687898089172 42.815923566879,-88.8102707006369 42.8343152866242,-88.7734872611465 42.8710987261147,-88.7517515923567 42.9145700636943,-88.7433917197452 42.9730891719745,-88.7517515923567 43.0299363057325,-88.7734872611465 43.0867834394905,-88.7885352038217 43.158678388535,-88.8738057324841 43.1620222929936,-88.947372611465 43.1937898089172,-89.0042197452229 43.2138535031847,-89.0410031847134 43.2389331210191,-89.0710987261147 43.243949044586,-89.0660828025478 43.2238853503185,-89.0543789808917 43.203821656051,-89.0376592356688 43.175398089172,-89.0292993630573 43.1519904458599,-89.0376592356688 43.1369426751592,-89.0393312101911 43.1386146496815,-89.0393312101911 43.1386146496815,-89.0510350318471 43.1335987261147,-89.0694267515924 43.1335987261147))'),
            Lake(lake_name=u'Lake Deep', lake_geom='POLYGON((-88.9122611464968 43.038296178344,-88.9222929936306 43.0399681528663,-88.9323248407643 43.0282643312102,-88.9206210191083 43.0182324840764,-88.9105891719745 43.0165605095542,-88.9005573248408 43.0232484076433,-88.9072452229299 43.0282643312102,-88.9122611464968 43.038296178344))'),
            Spot(spot_height=420.40, spot_location='POINT(-88.5945861592357 42.9480095987261)'),
            Spot(spot_height=102.34, spot_location='POINT(-88.9055734203822 43.0048567324841)'),
            Spot(spot_height=388.62, spot_location='POINT(-89.201512910828 43.1051752038217)'),
            Spot(spot_height=454.66, spot_location='POINT(-88.3304141847134 42.6269904904459)'),
        ])

        # or use an explicit WKTSpatialElement (similar to saying func.GeomFromText())
        self.r = Road(road_name=u'Dave Cres', road_geom=WKTSpatialElement('LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)', 4326))
        session.add(self.r)
        session.commit()

    def tearDown(self):
        session.rollback()
        metadata.drop_all()

    # Test Geometry Functions

    def test_wkt(self):
        l = session.query(Lake).get(1)
        eq_(session.scalar(self.r.road_geom.wkt), 'LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)')
        eq_(session.scalar(l.lake_geom.wkt),'POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))')
        ok_(not session.query(Spot).filter(Spot.spot_location.wkt == 'POINT(0,0)').first())
        ok_(session.query(Spot).get(1) is
            session.query(Spot).filter(Spot.spot_location == 'POINT(-88.5945861592357 42.9480095987261)').first())
        envelope_geom = DBSpatialElement(session.scalar(self.r.road_geom.envelope))
        eq_(session.scalar(envelope_geom.wkt), 'POLYGON((-88.6748409363057 42.9363057770701,-88.4390925286624 42.9363057770701,-88.4390925286624 43.1035032292994,-88.6748409363057 43.1035032292994,-88.6748409363057 42.9363057770701))')
        eq_(session.scalar(WKTSpatialElement('POINT(-88.5769371859941 42.9915634871979)').wkt), 'POINT(-88.5769371859941 42.9915634871979)')

    def test_wkb(self):
        eq_(b2a_hex(session.scalar(self.r.road_geom.wkb)).upper(), '010200000005000000D7DB0998302B56C0876F04983F8D45404250F5E65E2956C068CE11FFC37F4540C8ED42D9E82656C0EFC45ED3E97B45407366F132062156C036C921DED877454078A18C171A1C56C053A5AF5B68804540')
        eq_(session.scalar(self.r.road_geom.wkb), self.r.road_geom.geom_wkb)
        envelope_geom = DBSpatialElement(session.scalar(self.r.road_geom.envelope))
        eq_(b2a_hex(session.scalar(envelope_geom.wkb)).upper(), '01030000000100000005000000D7DB0998302B56C036C921DED877454078A18C171A1C56C036C921DED877454078A18C171A1C56C0876F04983F8D4540D7DB0998302B56C0876F04983F8D4540D7DB0998302B56C036C921DED8774540')

    def test_coords(self):
        eq_(self.r.road_geom.coords(session), [[-88.674840936305699, 43.103503229299399], [-88.6464173694267, 42.998168834394903], [-88.607961955413998, 42.968073292993601], [-88.516003356687904, 42.936305777070103], [-88.4390925286624, 43.003184757961797]])
        s = session.query(Spot).filter(Spot.spot_height==102.34).one()
        eq_(s.spot_location.coords(session), [-88.905573420382197, 43.0048567324841])
        l = session.query(Lake).filter(Lake.lake_name==u"Lake Deep").one()
        eq_(l.lake_geom.coords(session), [[[-88.912261146496803, 43.038296178343998], [-88.922292993630606, 43.039968152866301], [-88.932324840764295, 43.028264331210202], [-88.920621019108296, 43.0182324840764], [-88.910589171974493, 43.016560509554203], [-88.900557324840804, 43.023248407643301], [-88.907245222929902, 43.028264331210202], [-88.912261146496803, 43.038296178343998]]])

    def test_persistent(self):
        eq_(b2a_hex(session.scalar(self.r.road_geom.wkb)).upper(), '010200000005000000D7DB0998302B56C0876F04983F8D45404250F5E65E2956C068CE11FFC37F4540C8ED42D9E82656C0EFC45ED3E97B45407366F132062156C036C921DED877454078A18C171A1C56C053A5AF5B68804540')

    def test_dimension(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        eq_(session.scalar(l.lake_geom.dimension), 2)
        eq_(session.scalar(r.road_geom.dimension), 1)
        eq_(session.scalar(s.spot_location.dimension), 0)
        ok_(session.query(Spot).filter(Spot.spot_location.dimension == 0).first() is not None)
        eq_(session.scalar(functions.dimension('POINT(-88.5945861592357 42.9480095987261)')), 0)

    def test_srid(self):
        eq_(session.scalar(self.r.road_geom.srid), 4326)
        ok_(session.query(Spot).filter(Spot.spot_location.srid == 4326).first() is not None)
        eq_(session.scalar(functions.srid('POINT(-88.5945861592357 42.9480095987261)')), 4326)

    def test_geometry_type(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        eq_(session.scalar(l.lake_geom.geometry_type), 'POLYGON')
        eq_(session.scalar(r.road_geom.geometry_type), 'LINESTRING')
        eq_(session.scalar(s.spot_location.geometry_type), 'POINT')
        eq_(session.scalar(functions.geometry_type(r.road_geom)), 'LINESTRING')
        ok_(session.query(Road).filter(Road.road_geom.geometry_type == 'LINESTRING').first())

    @raises(NotImplementedError)
    def test_is_valid(self):
        session.scalar(self.r.road_geom.is_valid)

    def test_is_empty(self):
        ok_(not session.scalar(self.r.road_geom.is_empty))
        ok_(session.query(Spot).filter(Spot.spot_location.is_empty == False).first() is not None)
        eq_(session.scalar(functions.is_empty('POINT(-88.5945861592357 42.9480095987261)')), False)

    @raises(NotImplementedError)
    def test_is_simple(self):
        session.scalar(self.r.road_geom.is_simple)

    @raises(NotImplementedError)
    def test_boundary(self):
        b2a_hex(session.scalar(self.r.road_geom.boundary))

    def test_envelope(self):
        eq_(b2a_hex(session.scalar(self.r.road_geom.envelope)), 'e610000001030000000100000005000000d7db0998302b56c036c921ded877454078a18c171a1c56c036c921ded877454078a18c171a1c56c0876f04983f8d4540d7db0998302b56c0876f04983f8d4540d7db0998302b56c036c921ded8774540')
        env =  WKBSpatialElement(session.scalar(func.AsBinary(self.r.road_geom.envelope)))
        eq_(env.geom_type(session), 'Polygon')
        eq_(session.scalar(functions.wkt(functions.envelope('POINT(-88.5945861592357 42.9480095987261)'))),
            'POLYGON((-88.5945861592357 42.9480095987261,-88.5945861592357 42.9480095987261,-88.5945861592357 42.9480095987261,-88.5945861592357 42.9480095987261,-88.5945861592357 42.9480095987261))')

    def test_x(self):
        import math
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_( not session.scalar(l.lake_geom.x))
        ok_( not session.scalar(r.road_geom.x))
        print session.scalar(s.spot_location.x)
        eq_(math.ceil(session.scalar(s.spot_location.x)), -88.0)
        s = session.query(Spot).filter(and_(Spot.spot_location.x < 0, Spot.spot_location.y > 42)).all()
        ok_(s is not None)
        eq_(math.ceil(session.scalar(functions.x('POINT(-88.3655256496815 43.1402866687898)'))), -88.0)

    def test_y(self):
        import math
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.y))
        ok_(not session.scalar(r.road_geom.y))
        eq_(math.floor(session.scalar(s.spot_location.y)), 42.0)
        s = session.query(Spot).filter(and_(Spot.spot_location.y < 0, Spot.spot_location.y > 42)).all()
        ok_(s is not None)
        eq_(math.floor(session.scalar(functions.y('POINT(-88.3655256496815 43.1402866687898)'))), 43.0)

    def test_start_point(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.start_point))
        eq_(b2a_hex(session.scalar(r.road_geom.start_point)), 'e61000000101000000850811e27d3a56c0997b2f540f414540')
        ok_(not session.scalar(s.spot_location.start_point))

    def test_end_point(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.end_point))
        eq_(b2a_hex(session.scalar(r.road_geom.end_point)), 'e61000000101000000ccceb1c5641756c02c42dfe9f4914540')
        ok_(not session.scalar(s.spot_location.end_point))

    @raises(NotImplementedError)
    def test_transform(self):
        spot = session.query(Spot).get(1)
        session.scalar(spot.spot_location.transform(2249))

    def test_length(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        assert_almost_equal(session.scalar(r.road_geom.length), 0.85516941641479005)
        ok_(not session.scalar(l.lake_geom.length))
        ok_(not session.scalar(s.spot_location.length))

    def test_is_closed(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.is_closed))
        ok_(not session.scalar(r.road_geom.is_closed))
        ok_(not session.scalar(s.spot_location.is_closed))

    @raises(NotImplementedError)
    def test_is_ring(self):
        l = session.query(Lake).get(1)
        session.scalar(l.lake_geom.is_ring)

    def test_num_points(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.num_points))
        eq_(session.scalar(r.road_geom.num_points), 5)
        ok_(not session.scalar(s.spot_location.num_points))

    def test_point_n(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.point_n(1)))
        eq_(b2a_hex(session.scalar(r.road_geom.point_n(5))), 'e61000000101000000ccceb1c5641756c02c42dfe9f4914540')
        ok_(not session.scalar(s.spot_location.point_n(1)))

    @raises(NotImplementedError)
    def test_centroid(self):
        l = session.query(Lake).get(1)
        session.scalar(l.lake_geom.centroid)

    def test_area(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        assert_almost_equal(session.scalar(l.lake_geom.area), 0.0056748625704923002)
        ok_(not session.scalar(r.road_geom.area))
        ok_(not session.scalar(s.spot_location.area))

    # Test Geometry Relations for Spatial Elements

    def test_equals(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Peter Rd').one()
        r3 = session.query(Road).filter(Road.road_name==u'Paul St').one()
        equal_roads = session.query(Road).filter(Road.road_geom.equals(r1.road_geom)).all()
        ok_(r1 in equal_roads)
        ok_(r2 in equal_roads)
        ok_(r3 not in equal_roads)

    @raises(NotImplementedError)
    def test_distance(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        value1 = session.scalar(r1.road_geom.distance(r2.road_geom))
        value2 = session.scalar(r2.road_geom.distance(r1.road_geom))
        eq_(value1, value2)

    def test_disjoint(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        disjoint_roads = session.query(Road).filter(Road.road_geom.disjoint(r1.road_geom)).all()
        ok_(r2 not in disjoint_roads)
        ok_(r3 in disjoint_roads)

    def test_intersects(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        intersecting_roads = session.query(Road).filter(Road.road_geom.intersects(r1.road_geom)).all()
        ok_(r2 in intersecting_roads)
        ok_(r3 not in intersecting_roads)

    @raises(NotImplementedError)
    def test_touches(self):
        r = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        session.query(Lake).filter(Lake.lake_geom.touches(r.road_geom)).all()

    @raises(NotImplementedError)
    def test_crosses(self):
        l = session.query(Lake).filter(Lake.lake_name==u'Lake White').one()
        session.query(Road).filter(Road.road_geom.crosses(l.lake_geom)).all()

    def test_within(self):
        l = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        spots_within = session.query(Spot).filter(Spot.spot_location.within(l.lake_geom)).all()
        ok_(session.scalar(p1.spot_location.within(l.lake_geom)))
        ok_(not session.scalar(p2.spot_location.within(l.lake_geom)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)
        envelope_geom = DBSpatialElement(session.scalar(l.lake_geom.envelope))
        spots_within = session.query(Spot).filter(l.lake_geom.within(envelope_geom)).all()
        ok_(p1 in spots_within)
        ok_(p2 in spots_within)

    def test_overlaps(self):
        l1 = session.query(Lake).filter(Lake.lake_name==u'Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        l3 = session.query(Lake).filter(Lake.lake_name==u'My Lake').one()
        overlapping_lakes = session.query(Lake).filter(Lake.lake_geom.overlaps(l3.lake_geom)).all()
        ok_(not session.scalar(l1.lake_geom.overlaps(l3.lake_geom)))
        ok_(session.scalar(l2.lake_geom.overlaps(l3.lake_geom)))
        ok_(l1 not in overlapping_lakes)
        ok_(l2 in overlapping_lakes)

    def test_contains(self):
        l = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        l1 = session.query(Lake).filter(Lake.lake_name==u'Lake White').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains(p1.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        ok_(session.scalar(l.lake_geom.gcontains(WKTSpatialElement('POINT(-88.9055734203822 43.0048567324841)'))))
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains('POINT(-88.9055734203822 43.0048567324841)')).all()
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        spots_within = session.query(Spot).filter(l.lake_geom.gcontains(Spot.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)

    # Test Geometry Relations for Minimum Bounding Rectangles (MBRs)

    def test_mbr_equal(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Peter Rd').one()
        r3 = session.query(Road).filter(Road.road_name==u'Paul St').one()
        equal_roads = session.query(Road).filter(Road.road_geom.mbr_equal(r1.road_geom)).all()
        ok_(r1 in equal_roads)
        ok_(r2 in equal_roads)
        ok_(r3 not in equal_roads)
        ok_(session.scalar(r2.road_geom.mbr_equal(r1.road_geom)))
        eq_(session.scalar(mysql_functions.mbr_equal('POINT(-88.5945861592357 42.9480095987261)', 'POINT(-88.5945861592357 42.9480095987261)')), True)


    def test_mbr_disjoint(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        disjoint_roads = session.query(Road).filter(Road.road_geom.mbr_disjoint(r1.road_geom)).all()
        ok_(r2 not in disjoint_roads)
        ok_(r3 in disjoint_roads)

    def test_mbr_intersects(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        intersecting_roads = session.query(Road).filter(Road.road_geom.mbr_intersects(r1.road_geom)).all()
        ok_(r2 in intersecting_roads)
        ok_(r3 not in intersecting_roads)

    def test_mbr_touches(self):
        l1 = session.query(Lake).filter(Lake.lake_name==u'Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        r = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        touching_lakes = session.query(Lake).filter(Lake.lake_geom.mbr_touches(r.road_geom)).all()
        ok_(l1 not in touching_lakes)
        ok_(l2 not in touching_lakes)
        eq_(session.scalar(l1.lake_geom.mbr_touches(r.road_geom)), 0L)
        eq_(session.scalar(l2.lake_geom.mbr_touches(r.road_geom)), 0L)

    def test_mbr_within(self):
        l = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        spots_within = session.query(Spot).filter(Spot.spot_location.mbr_within(l.lake_geom)).all()
        ok_(session.scalar(p1.spot_location.mbr_within(l.lake_geom)))
        ok_(not session.scalar(p2.spot_location.mbr_within(l.lake_geom)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)

    def test_mbr_overlaps(self):
        l1 = session.query(Lake).filter(Lake.lake_name==u'Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        l3 = session.query(Lake).filter(Lake.lake_name==u'My Lake').one()
        overlapping_lakes = session.query(Lake).filter(Lake.lake_geom.mbr_overlaps(l3.lake_geom)).all()
        ok_(not session.scalar(l1.lake_geom.mbr_overlaps(l3.lake_geom)))
        ok_(session.scalar(l2.lake_geom.mbr_overlaps(l3.lake_geom)))
        ok_(l1 not in overlapping_lakes)
        ok_(l2 in overlapping_lakes)

    def test_mbr_contains(self):
        l = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        l1 = session.query(Lake).filter(Lake.lake_name==u'Lake White').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.mbr_contains(p1.spot_location)).all()
        ok_(session.scalar(l.lake_geom.mbr_contains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.mbr_contains(p2.spot_location)))
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)

    def test_within_distance(self):
        ok_(session.scalar(functions._within_distance('POINT(-88.9139332929936 42.5082802993631)',
                                                      'POINT(-88.9139332929936 35.5082802993631)', 10)))
        ok_(session.scalar(functions._within_distance('Point(0 0)', 'Point(0 0)', 0)))
        ok_(session.scalar(functions._within_distance('Point(0 0)',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)))
        ok_(session.scalar(functions._within_distance('Point(5 5)',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)))
        ok_(session.scalar(functions._within_distance('Point(6 5)',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 1)))
        ok_(session.scalar(functions._within_distance('Polygon((0 0, 1 0, 1 8, 0 8, 0 0))',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)))

    @raises(OperationalError)
    def test_constraint_nullable(self):
        road_null = Road(road_name=u'Jeff Rd', road_geom=None)
        session.add(road_null)
        session.commit();


if __name__ == '__main__':
    import sys
    import nose

    sys.argv.append(__name__)
    result = nose.run()
    sys.exit(int(not result))

########NEW FILE########
__FILENAME__ = test_oracle
from unittest import TestCase
from sqlalchemy import (create_engine, MetaData, Column, Integer, String,
        Numeric, func, Table, and_, not_)
from sqlalchemy.orm import sessionmaker, mapper, aliased
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.exc import IntegrityError
from geoalchemy.geometry import LineString, Point, Polygon
from sqlalchemy.schema import Sequence
from sqlalchemy.sql.expression import text, select

from geoalchemy import (GeometryCollection, GeometryColumn,
        GeometryDDL, WKTSpatialElement, DBSpatialElement, GeometryExtensionColumn)
from geoalchemy.functions import functions
from geoalchemy.oracle import OracleComparator, oracle_functions, ORACLE_NULL_GEOMETRY,\
    OracleSpatialDialect

from nose.tools import eq_, ok_, raises, assert_almost_equal

import os
os.environ['ORACLE_HOME'] = '/usr/lib/oracle/xe/app/oracle/product/10.2.0/server'
os.environ['LD_LIBRARY'] = '/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib'


import cx_Oracle

#engine = create_engine('oracle://gis:gis@localhost:1521/gis', echo=True)
engine = create_engine('oracle://system:system@172.16.53.129:1521/gis', echo=False)

metadata = MetaData(engine)
session = sessionmaker(bind=engine)()
Base = declarative_base(metadata=metadata)

diminfo = "MDSYS.SDO_DIM_ARRAY("\
            "MDSYS.SDO_DIM_ELEMENT('LONGITUDE', -180, 180, 0.000000005),"\
            "MDSYS.SDO_DIM_ELEMENT('LATITUDE', -90, 90, 0.000000005)"\
            ")"
diminfo_ = text(diminfo)
tolerance = 0.000000005

class Road(Base):
    __tablename__ = 'roads'

    road_id = Column(Integer, Sequence('roads_id_seq'), primary_key=True)
    road_name = Column(String(40))
    road_geom = GeometryColumn(LineString(2, diminfo=diminfo), comparator=OracleComparator, nullable=False)

road_alias = aliased(Road)

class Lake(Base):
    __tablename__ = 'lakes'

    lake_id = Column(Integer, Sequence('lakes_id_seq'), primary_key=True)
    lake_name = Column(String(40))
    lake_geom = GeometryColumn(Polygon(2, diminfo=diminfo), comparator=OracleComparator)

lake_alias = aliased(Lake)

spots_table = Table('spots', metadata,
                    Column('spot_id', Integer, Sequence('spots_id_seq'), primary_key=True),
                    Column('spot_height', Numeric),
                    GeometryExtensionColumn('spot_location', Point(2, diminfo=diminfo)))

class Spot(object):
    def __init__(self, spot_id=None, spot_height=None, spot_location=None):
        self.spot_id = spot_id
        self.spot_height = spot_height
        self.spot_location = spot_location

mapper(Spot, spots_table, properties={
            'spot_location': GeometryColumn(spots_table.c.spot_location,
                                            comparator=OracleComparator)})
spot_alias = aliased(Spot)

class Shape(Base):
    __tablename__ = 'shapes'

    shape_id = Column(Integer, Sequence('shapes_id_seq'), primary_key=True)
    shape_name = Column(String(40))
    shape_geom = GeometryColumn(GeometryCollection(2, diminfo=diminfo))

# enable the DDL extension, which allows CREATE/DROP operations
# to work correctly.  This is not needed if working with externally
# defined tables.
GeometryDDL(Road.__table__)
GeometryDDL(Lake.__table__)
GeometryDDL(spots_table)
GeometryDDL(Shape.__table__)


class TestGeometry(TestCase):
    """Tests for Oracle
    """

    SLOW_SYSTEM = True
    database_is_set_up = False

    def __init__(self, methodName):
        TestCase.__init__(self, methodName)

    def setUp(self):
        if not session.is_active:
            session.rollback()

        if not TestGeometry.SLOW_SYSTEM or not TestGeometry.database_is_set_up:

            metadata.drop_all()
            metadata.create_all()

            # Add objects.  We can use strings...
            session.add_all([
                Road(road_name='Jeff Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
                Road(road_name='Peter Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
                Road(road_name='Geordie Rd', road_geom='LINESTRING(-89.2232485796178 42.6420382611465,-89.2449842484076 42.9179140573248,-89.2316084522293 43.106847178344,-89.0710987261147 43.243949044586,-89.092834566879 43.2957802993631,-89.0309715095541 43.3175159681529)'),
                Road(road_name='Paul St', road_geom='LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147)'),
                Road(road_name='Graeme Ave', road_geom='LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)'),
                Road(road_name='Phil Tce', road_geom='LINESTRING(-88.9356689617834 42.9363057770701,-88.9824842484076 43.0366242484076,-88.9222931656051 43.1085191528662,-88.8487262866242 43.0449841210191)'),
                Lake(lake_name='My Lake', lake_geom='POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))'),
                Lake(lake_name='Lake White', lake_geom='POLYGON((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542))'),
                Lake(lake_name='Lake Blue', lake_geom='POLYGON((-89.0694267515924 43.1335987261147,-89.1078821656051 43.1135350318471,-89.1329617834395 43.0884554140127,-89.1312898089172 43.0466560509554,-89.112898089172 43.0132165605096,-89.0694267515924 42.9898089171975,-89.0343152866242 42.953025477707,-89.0209394904459 42.9179140127389,-89.0042197452229 42.8961783439491,-88.9774681528663 42.8644108280255,-88.9440286624204 42.8292993630573,-88.9072452229299 42.8142515923567,-88.8687898089172 42.815923566879,-88.8687898089172 42.815923566879,-88.8102707006369 42.8343152866242,-88.7734872611465 42.8710987261147,-88.7517515923567 42.9145700636943,-88.7433917197452 42.9730891719745,-88.7517515923567 43.0299363057325,-88.7734872611465 43.0867834394905,-88.7885352038217 43.158678388535,-88.8738057324841 43.1620222929936,-88.947372611465 43.1937898089172,-89.0042197452229 43.2138535031847,-89.0410031847134 43.2389331210191,-89.0710987261147 43.243949044586,-89.0660828025478 43.2238853503185,-89.0543789808917 43.203821656051,-89.0376592356688 43.175398089172,-89.0292993630573 43.1519904458599,-89.0376592356688 43.1369426751592,-89.0393312101911 43.1386146496815,-89.0393312101911 43.1386146496815,-89.0510350318471 43.1335987261147,-89.0694267515924 43.1335987261147))'),
                Lake(lake_name='Lake Deep', lake_geom='POLYGON((-88.9122611464968 43.038296178344,-88.9222929936306 43.0399681528663,-88.9323248407643 43.0282643312102,-88.9206210191083 43.0182324840764,-88.9105891719745 43.0165605095542,-88.9005573248408 43.0232484076433,-88.9072452229299 43.0282643312102,-88.9122611464968 43.038296178344))'),

                Spot(spot_height=420.40, spot_location='POINT(-88.5945861592357 42.9480095987261)'),
                Spot(spot_height=102.34, spot_location='POINT(-88.9055734203822 43.0048567324841)'),
                Spot(spot_height=388.62, spot_location='POINT(-89.201512910828 43.1051752038217)'),
                Spot(spot_height=454.66, spot_location='POINT(-88.3304141847134 42.6269904904459)'),
                # the following spots are for test_within_distance
                Spot(spot_height=420.40, spot_location='POINT(0 0)'),
                Spot(spot_height=102.34, spot_location='POINT(10 10)'),
                Spot(spot_height=388.62, spot_location='POINT(10 11)'),
                Spot(spot_height=1454.66, spot_location='POINT(40 34)'),
                Spot(spot_height=54.66, spot_location='POINT(5 5)'),
                Spot(spot_height=333.12, spot_location='POINT(2 3)'),
                Spot(spot_height=783.55, spot_location='POINT(38 34)'),
                Spot(spot_height=3454.67, spot_location='POINT(-134 45)'),

                Shape(shape_name='Bus Stop', shape_geom='GEOMETRYCOLLECTION(POINT(-88.3304141847134 42.6269904904459))'),
                Shape(shape_name='Jogging Track', shape_geom='GEOMETRYCOLLECTION(LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147))'),
                Shape(shape_name='Play Ground', shape_geom='GEOMETRYCOLLECTION(POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936)))'),
            ])

            # or use an explicit WKTSpatialElement (similar to saying func.GeomFromText())
            self.r = Road(road_name='Dave Cres', road_geom=WKTSpatialElement('LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)', 4326))
            session.add(self.r)
            session.commit()

            TestGeometry.database_is_set_up = True

        self.r = session.query(Road).filter(Road.road_name=='Dave Cres').one()

    def tearDown(self):
        if not TestGeometry.SLOW_SYSTEM:
            session.rollback()
            metadata.drop_all()

    def test_WKBSpatialElement(self):
        s = session.query(Spot).get(1)
        ok_(isinstance(s.spot_location.geom_wkb, buffer))
        ok_(session.scalar(func.SDO_UTIL.VALIDATE_WKBGEOMETRY(s.spot_location.geom_wkb)))
        ok_(session.scalar(func.SDO_GEOM.SDO_MBR(s.spot_location.desc)))

    # Test Geometry Functions

    def test_geometry_type(self):
        r = session.query(Road).get(1)
        l = session.query(Lake).get(1)
        s = session.query(Spot).get(1)

        eq_(session.scalar(r.road_geom.geometry_type), u'ST_LINESTRING')
        eq_(session.scalar(l.lake_geom.geometry_type), u'ST_POLYGON')
        eq_(session.scalar(s.spot_location.geometry_type), u'ST_POINT')
        eq_(session.scalar(functions.geometry_type(r.road_geom)), u'ST_LINESTRING')
        ok_(session.query(Road).filter(Road.road_geom.geometry_type == u'ST_LINESTRING').first())

    def test_gtype(self):
        r = session.query(Road).get(1)
        l = session.query(Lake).get(1)
        s = session.query(Spot).get(1)

        # see 'Valid SDO_GTYPE Values': http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_objrelschema.htm#g1013735
        eq_(session.scalar(r.road_geom.gtype), 2)
        eq_(session.scalar(l.lake_geom.gtype), 3)
        eq_(session.scalar(s.spot_location.gtype), 1)
        eq_(session.scalar(oracle_functions.gtype(r.road_geom)), 2)

        # note we are using a table alias!
        road = session.query(road_alias).filter(road_alias.road_geom.gtype == 2).first()
        ok_(road)

    def test_wkt(self):
        l = session.query(Lake).get(1)
        eq_(session.scalar(self.r.road_geom.wkt), 'LINESTRING (-88.6748409363057 43.1035032292994, -88.6464173694267 42.9981688343949, -88.607961955414 42.9680732929936, -88.5160033566879 42.9363057770701, -88.4390925286624 43.0031847579618)')
        eq_(session.scalar(l.lake_geom.wkt), 'POLYGON ((-88.7968950764331 43.2305732929936, -88.7935511273885 43.1553344394904, -88.716640299363 43.1570064140127, -88.7250001719745 43.2339172420382, -88.7968950764331 43.2305732929936))')
        ok_(session.query(Spot).filter(Spot.spot_location.wkt == 'POINT (-88.5945861592357 42.9480095987261)').first())

        ok_(session.query(Spot).get(1) is
            session.query(Spot).filter(Spot.spot_location == 'POINT(-88.5945861592357 42.9480095987261)').first())

        """At the moment, cx_Oracle does not support cx_Oracle.Object as parameter, so DBSpatialElement
        can not be used for Oracle, see also:
        http://sourceforge.net/mailarchive/message.php?msg_name=AANLkTilkBwWsIy0yEFQpPOvQiF-k9RxvlYlKf2KyaOfw%40mail.gmail.com
        """
#        centroid_geom = DBSpatialElement(session.scalar(l.lake_geom.centroid(0.000000005)))
#        eq_(session.scalar(centroid_geom.wkt), u'POINT(-88.5769371859941 42.9915634871979)')

        eq_(session.scalar(WKTSpatialElement('POINT(-88.5769371859941 42.9915634871979)').wkt), 'POINT (-88.5769371859941 42.9915634871979)')

    def test_coords(self):
        eq_(self.r.road_geom.coords(session), [[-88.6748409363057,43.1035032292994],[-88.6464173694267,42.9981688343949],[-88.607961955414,42.9680732929936],[-88.5160033566879,42.9363057770701],[-88.4390925286624,43.0031847579618]])
        l = session.query(Lake).filter(Lake.lake_name=="Lake Deep").one()
        eq_(l.lake_geom.coords(session), [[[-88.9122611464968,43.038296178344],[-88.9222929936306,43.0399681528663],[-88.9323248407643,43.0282643312102],[-88.9206210191083,43.0182324840764],[-88.9105891719745,43.0165605095542],[-88.9005573248408,43.0232484076433],[-88.9072452229299,43.0282643312102],[-88.9122611464968,43.038296178344]]])
        s = session.query(Spot).get(2)
        eq_(s.spot_location.coords(session), [-88.905573420382197, 43.0048567324841])

    def test_wkb(self):
        eq_(session.scalar(functions.wkt(func.SDO_GEOMETRY(self.r.road_geom.wkb, 4326))),
            u'LINESTRING (-88.6748409363057 43.1035032292994, -88.6464173694267 42.9981688343949, -88.607961955414 42.9680732929936, -88.5160033566879 42.9363057770701, -88.4390925286624 43.0031847579618)')
        eq_(session.scalar(self.r.road_geom.wkb), self.r.road_geom.geom_wkb)
        ok_(not session.query(Spot).filter(func.DBMS_LOB.Compare(Spot.spot_location.wkb, func.to_blob('101')) == 0).first())
#        centroid_geom = DBSpatialElement(session.scalar(self.r.road_geom.centroid))
#        eq_(session.scalar(functions.wkt(func.GeomFromWKB(centroid_geom.wkb, 4326))), u'POINT(-88.5769371859941 42.9915634871979)')


    def test_gml(self):
        eq_(session.scalar(self.r.road_geom.gml), u'<gml:LineString srsName="SDO:4326" xmlns:gml="http://www.opengis.net/gml"><gml:coordinates decimal="." cs="," ts=" ">-88.6748409363057,43.1035032292994 -88.6464173694267,42.9981688343949 -88.607961955414,42.9680732929936 -88.5160033566879,42.9363057770701 -88.4390925286624,43.0031847579618 </gml:coordinates></gml:LineString>')

    def test_gml311(self):
        eq_(session.scalar(self.r.road_geom.gml311), u'<gml:Curve srsName="SDO:4326" xmlns:gml="http://www.opengis.net/gml"><gml:segments><gml:LineStringSegment><gml:posList srsDimension="2">-88.6748409363057 43.1035032292994 -88.6464173694267 42.9981688343949 -88.607961955414 42.9680732929936 -88.5160033566879 42.9363057770701 -88.4390925286624 43.0031847579618 </gml:posList></gml:LineStringSegment></gml:segments></gml:Curve>')

    def test_kml(self):
        s = session.query(Spot).get(1)
        eq_(session.scalar(s.spot_location.kml),  u'<Point><extrude>0</extrude><tessellate>0</tessellate><altitudeMode>relativeToGround</altitudeMode><coordinates>-88.5945861592357,42.9480095987261 </coordinates></Point>')

    def test_dims(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        eq_(session.scalar(r.road_geom.dims), 2)
        eq_(session.scalar(l.lake_geom.dims), 2)
        ok_(session.query(spot_alias).filter(spot_alias.spot_location.dims == 2).first() is not None)
        eq_(session.scalar(oracle_functions.dims('POINT(-88.5945861592357 42.9480095987261)')), 2)

    def test_dimension(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        eq_(session.scalar(r.road_geom.dimension), 1)
        eq_(session.scalar(l.lake_geom.dimension), 2)
        ok_(session.query(Spot).filter(Spot.spot_location.dimension == 0).first() is not None)
        eq_(session.scalar(functions.dimension('POINT(-88.5945861592357 42.9480095987261)')), 0)

    def test_srid(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(r.road_geom.srid), 4326)
        ok_(session.query(Spot).filter(Spot.spot_location.srid == 4326).first() is not None)
        eq_(session.scalar(functions.srid('POINT(-88.5945861592357 42.9480095987261)')), 4326)

    @raises(NotImplementedError)
    def test_is_valid(self):
        session.scalar(self.r.road_geom.is_valid)

    def test_is_empty(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        assert not session.scalar(r.road_geom.is_empty)
        assert not session.scalar(l.lake_geom.is_empty)
        ok_(session.query(Spot).filter(not_(Spot.spot_location.is_empty)).first() is not None)
        eq_(session.scalar(functions.is_empty('POINT(-88.5945861592357 42.9480095987261)')), False)

    def test_is_simple(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        assert session.scalar(r.road_geom.is_simple)
        assert session.scalar(l.lake_geom.is_simple)
        ok_(session.query(Spot).filter(Spot.spot_location.is_simple).first() is not None)
        eq_(session.scalar(functions.is_simple('LINESTRING(1 1,2 2,2 3.5,1 3,1 2,2 1)')), False)

    def test_is_closed(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        assert not session.scalar(r.road_geom.is_closed)
        # note Oracle always returns FALSE for polygons
        assert not session.scalar(l.lake_geom.is_closed)
        ok_(session.query(Lake).filter(Lake.lake_geom.is_closed).first() is None)
        # note that we manually have to set a geometry type for WKTSpatialElement
        eq_(session.scalar(functions.is_closed(WKTSpatialElement('LINESTRING(0 0, 1 1)', geometry_type=LineString.name))), False)

    def test_is_ring(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert not session.scalar(r.road_geom.is_ring)
        ok_(session.query(Road).filter(Road.road_geom.is_ring).first() is None)
        eq_(session.scalar(functions.is_ring(WKTSpatialElement('LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)', geometry_type=LineString.name))), False)

    def test_num_points(self):
        r = session.query(Road).get(1)
        eq_(session.scalar(r.road_geom.num_points), 5)
        ok_(session.query(Road).filter(Road.road_geom.num_points == 5).first() is not None)
        eq_(session.scalar(functions.num_points(WKTSpatialElement('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)', geometry_type=LineString.name))),
            4)

    def test_point_n(self):
        r = session.query(Road).get(1)
        ok_(session.query(Road).filter(and_(Road.road_geom.point_n(5) <> None,
                                            functions.wkt(Road.road_geom.point_n(5)) == 'POINT (-88.3655256496815 43.1402866687898)')).first()
                                            is not None)
        eq_(session.scalar(r.road_geom.point_n(5).wkt), u'POINT (-88.3655256496815 43.1402866687898)')
        eq_(session.scalar(functions.wkt(functions.point_n(
                                                WKTSpatialElement('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)', geometry_type=LineString.name), 1))),
            u'POINT (77.29 29.07)')

    def test_persistent(self):
        eq_(session.scalar(functions.wkt(func.SDO_GEOMETRY(self.r.road_geom.wkb, 4326))),
            u'LINESTRING (-88.6748409363057 43.1035032292994, -88.6464173694267 42.9981688343949, -88.607961955414 42.9680732929936, -88.5160033566879 42.9363057770701, -88.4390925286624 43.0031847579618)')

        geom = WKTSpatialElement('POINT(30250865.9714116 -610981.481754275)', 2249)
        spot = Spot(spot_height=102.34, spot_location=geom)
        session.add(spot)
        session.commit();
        assert_almost_equal(float(session.scalar(spot.spot_location.x)), 0)
        assert_almost_equal(float(session.scalar(spot.spot_location.y)), 0)
        session.delete(spot)
        session.commit()

    def test_eq(self):
        r1 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r2 = session.query(Road).filter(Road.road_geom == 'LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)').one()
        r3 = session.query(Road).filter(Road.road_geom == r1.road_geom).one()
        ok_(r1 is r2 is r3)

    def test_length(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert_almost_equal(float(session.scalar(r.road_geom.length)), 54711.459044609008)
        ok_(session.query(Road).filter(Road.road_geom.length > 0).first() is not None)
        assert_almost_equal(float(session.scalar(functions.length('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)', diminfo_))),
                            66830.9630972249)

    def test_area(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        assert_almost_equal(float(session.scalar(l.lake_geom.area(tolerance, auto_diminfo=False))), 104854567.261647)
        assert_almost_equal(float(session.scalar(l.lake_geom.area(
                                                 OracleSpatialDialect.get_diminfo_select(Lake.lake_geom),
                                                 auto_diminfo=False))), 104854567.261647)
        assert_almost_equal(float(session.scalar(l.lake_geom.area(
                                                 OracleSpatialDialect.get_diminfo_select(Lake.__table__.c.lake_geom),
                                                 auto_diminfo=False))), 104854567.261647)
        ok_(session.query(Lake).filter(Lake.lake_geom.area > 0).first() is not None)
        assert_almost_equal(float(session.scalar(functions.area(WKTSpatialElement('POLYGON((743238 2967416,743238 2967450,743265 2967450,743265.625 2967416,743238 2967416))',2249), diminfo_))),
                            86.272430609366495)

    def test_x(self):
        s = session.query(Spot).get(1)
        assert_almost_equal(float(session.scalar(s.spot_location.x)), -88.594586159235689)
        s = session.query(Spot).filter(and_(Spot.spot_location.x < 0, Spot.spot_location.y > 42)).all()
        ok_(s is not None)
        assert_almost_equal(float(session.scalar(functions.x(WKTSpatialElement('POINT(-88.3655256496815 43.1402866687898)', geometry_type=Point.name)))),
                            -88.3655256496815)

    def test_y(self):
        s = session.query(Spot).get(1)
        assert_almost_equal(float(session.scalar(s.spot_location.y)), 42.9480095987261)
        s = session.query(Spot).filter(and_(Spot.spot_location.y < 0, Spot.spot_location.y > 42)).all()
        ok_(s is not None)
        assert_almost_equal(float(session.scalar(functions.y(WKTSpatialElement('POINT(-88.3655256496815 43.1402866687898)', geometry_type=Point.name)))),
                            43.1402866687898)

    def test_centroid(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        # Oracle does not support centroid for LineString
        eq_(session.scalar(functions.wkt(r.road_geom.centroid)), None)
        eq_(session.scalar(functions.wkt(l.lake_geom.centroid)), u'POINT (-88.9213649409212 43.0190392609092)')
        ok_(session.query(Spot).filter(functions.wkt(Spot.spot_location.centroid) == 'POINT (-88.5945861592357 42.9480095987261)').first() is not None)
        eq_(session.scalar(functions.wkt(functions.centroid('MULTIPOINT((-1 0), (-1 2), (-1 3), (-1 4), (-1 7), (0 1), (0 3), (1 1), (2 0), (6 0), (7 8), (9 8), (10 6) )', diminfo_))),
            u'POINT (2.30460703912783 3.31788085910597)')

    def test_boundary(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(r.road_geom.boundary.wkt), u'MULTIPOINT ((-88.5477708726115 42.6988853949045), (-88.5912422101911 43.187101955414))')
        ok_(session.query(Road).filter(Road.road_geom.boundary.wkt == 'MULTIPOINT ((-88.9139332929936 42.5082802993631), (-88.3655256496815 43.1402866687898))').first() is not None)
        eq_(session.scalar(functions.wkt(functions.boundary(WKTSpatialElement('POLYGON((1 1,0 0, -1 1, 1 1))', geometry_type=Polygon.name)))),
            u'LINESTRING (1.0 1.0, 0.0 0.0, -1.0 1.0, 1.0 1.0)')

    def test_buffer(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert_almost_equal(float(session.scalar(functions.area(r.road_geom.buffer(10.0), diminfo_))), 1094509.76889366)
        ok_(session.query(Spot).filter(functions.within(
                                                'POINT(-88.5945861592357 42.9480095987261)',
                                                Spot.spot_location.buffer(10))).first() is not None)
        assert_almost_equal(float(session.scalar(functions.area(functions.buffer(
                                        'POINT(-88.5945861592357 42.9480095987261)', diminfo_, 10,
                                        'unit=km arc_tolerance=0.05'), diminfo_))),
                            312144711.50297302)

    def test_convex_hull(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.convex_hull)),
            u'POLYGON ((-88.5477708728477 42.6988853969538, -88.5912422100661 43.1871019533972, -88.6029460317718 43.0884554581896, -88.6096339299412 42.9697452675198, -88.5477708728477 42.6988853969538))')
        # Oracle does not support ConvexHull for points
        ok_(session.query(Spot).filter(functions.equals(Spot.spot_location.convex_hull,
                                                        WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)'))).first() is None)
        eq_(session.scalar(functions.wkt(functions.convex_hull('LINESTRING(0 0, 1 1, 1 0)', diminfo_))),
            u'POLYGON ((0.999999915732742 8.48487373222706E-8, 0.999999915755202 0.999999915201249, 8.4273559349594E-8 8.48422467917753E-8, 0.999999915732742 8.48487373222706E-8))')

    def test_envelope(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.envelope)),
            u'POLYGON ((-88.6096339299363 42.6988853949045, -88.5477708726115 42.6988853949045, -88.5477708726115 43.187101955414, -88.6096339299363 43.187101955414, -88.6096339299363 42.6988853949045))')
        eq_(session.scalar(functions.geometry_type(self.r.road_geom.envelope)), u'ST_POLYGON')
        ok_(session.query(Spot).filter(functions.wkt(Spot.spot_location.envelope) == 'POINT (-88.5945861592357 42.9480095987261)').first() is not None)
        eq_(session.scalar(functions.wkt(functions.envelope(WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)', geometry_type=Point.name)))),
            u'POINT (-88.5945861592357 42.9480095987261)')

    def test_start_point(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.start_point)),
            u'POINT (-88.5477708726115 42.6988853949045)')
        ok_(session.query(Road).filter(functions.wkt(Road.road_geom.start_point) ==
                                                        'POINT (-88.9139332929936 42.5082802993631)').first() is not None)
        eq_(session.scalar(functions.wkt(functions.start_point(WKTSpatialElement('LINESTRING(0 1, 0 2)', geometry_type=LineString.name)))),
            u'POINT (0.0 1.0)')

    def test_end_point(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.end_point)),
            u'POINT (-88.5912422101911 43.187101955414)')
        ok_(session.query(Road).filter(functions.wkt(Road.road_geom.end_point) ==
                                                    'POINT (-88.3655256496815 43.1402866687898)').first() is not None)
        eq_(session.scalar(functions.wkt(functions.end_point(WKTSpatialElement('LINESTRING(0 1, 0 2)', geometry_type=LineString.name)))),
            u'POINT (0.0 2.0)')

    def test_transform(self):
        spot = session.query(Spot).get(1)
        # note that we have to cast to 'ST_POINT', because 'functions.x' only works for Points in Oracle
        assert_almost_equal(float(session.scalar(functions.x(func.ST_POINT(spot.spot_location.transform(2249))))), -3890517.61088792)
        assert_almost_equal(float(session.scalar(functions.y(func.ST_POINT(spot.spot_location.transform(2249))))), 3627658.6749871401)
        ok_(session.query(Spot).filter(functions.wkt(Spot.spot_location.transform(2249)) == 'POINT (-3890517.61088792 3627658.67498714)').first() is not None)
        eq_(session.scalar(functions.wkt(functions.transform(WKTSpatialElement('POLYGON((743238 2967416,743238 2967450,743265 2967450,743265.625 2967416,743238 2967416))', 2249), 4326))),
            u'POLYGON ((-71.1776848522252 42.3902896503503, -71.1776843766327 42.390382946861, -71.1775844305466 42.3903826668518, -71.1775825927231 42.3902893638588, -71.1776848522252 42.3902896503503))')

    # Test Geometry Relationships

    def test_equals(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Peter Rd').one()
        r3 = session.query(Road).filter(Road.road_name=='Paul St').one()
        equal_roads = session.query(Road).filter(Road.road_geom.equals(r1.road_geom)).all()
        ok_(r1 in equal_roads)
        ok_(r2 in equal_roads)
        ok_(r3 not in equal_roads)
        ok_(session.query(Spot).filter(Spot.spot_location.equals(WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)'))).first() is not None)
        eq_(session.scalar(functions.equals('POINT(-88.5945861592357 42.9480095987261)', 'POINT(-88.5945861592357 42.9480095987261)')), True)

    def test_distance(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        r3 = session.query(Road).filter(Road.road_name=='Peter Rd').one()
        assert_almost_equal(float(session.scalar(r1.road_geom.distance(r2.road_geom))), 29371.776054049602)
        eq_(session.scalar(r1.road_geom.distance(r3.road_geom)), 0.0)
        ok_(session.query(Spot).filter(Spot.spot_location.distance(
                                                            WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)'),
                                                            tolerance, auto_diminfo=False) < 10).first() is not None)
        eq_(session.scalar(functions.distance('POINT(-88.5945861592357 42.9480095987261)', 'POINT(-88.5945861592357 42.9480095987261)', tolerance)),
            0)

    def test_within_distance(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        roads_within_distance = session.query(Road).filter(
            Road.road_geom.within_distance(0.20, r1.road_geom)).all()
        ok_(r2 in roads_within_distance)
        ok_(r3 not in roads_within_distance)

    def test_disjoint(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        disjoint_roads = session.query(Road).filter(Road.road_geom.disjoint(r1.road_geom)).all()
        ok_(r2 not in disjoint_roads)
        ok_(r3 in disjoint_roads)
        eq_(session.scalar(functions.disjoint(
                                WKTSpatialElement('POINT(0 0)'),
                                WKTSpatialElement('LINESTRING ( 2 0, 0 2 )'))), True)

    def test_intersects(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        intersecting_roads = session.query(Road).filter(Road.road_geom.intersects(r1.road_geom)).all()
        ok_(r2 in intersecting_roads)
        ok_(r3 not in intersecting_roads)
        eq_(session.scalar(functions.intersects(
                                WKTSpatialElement('POINT(0 0)'),
                                WKTSpatialElement('LINESTRING ( 2 0, 0 2 )'))), False)

    def test_touches(self):
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        r = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        touching_lakes = session.query(Lake).filter(Lake.lake_geom.touches(r.road_geom)).all()
        ok_(session.scalar(l2.lake_geom.touches(r.road_geom)))
        ok_(l1 not in touching_lakes)
        ok_(l2 in touching_lakes)
        eq_(session.scalar(functions.touches(
                                WKTSpatialElement('POINT(0 0)'),
                                WKTSpatialElement('LINESTRING ( 2 0, 0 2 )'))), False)

    def test_crosses(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Paul St').one()
        l = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        crossing_roads = session.query(Road).filter(Road.road_geom.crosses(l.lake_geom)).all()
        ok_(not session.scalar(r1.road_geom.crosses(l.lake_geom)))
        ok_(session.scalar(r2.road_geom.crosses(l.lake_geom)))
        ok_(r1 not in crossing_roads)
        ok_(r2 in crossing_roads)
        # note that Oracle returns False instead of True (like the other databases do..)
        eq_(session.scalar(functions.crosses('LINESTRING(0 1, 2 1)', 'LINESTRING (0 0, 1 2, 0 2)')), False)

    def test_within(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        p1 = session.query(Spot).get(2)
        p2 = session.query(Spot).get(3)
        spots_within = session.query(Spot).filter(Spot.spot_location.within(l.lake_geom)).all()
        ok_(session.scalar(p1.spot_location.within(l.lake_geom)))
        ok_(not session.scalar(p2.spot_location.within(l.lake_geom)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)
        eq_(session.scalar(functions.within('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), True)

    def test_overlaps(self):
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l3 = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        overlapping_lakes = session.query(Lake).filter(Lake.lake_geom.overlaps(l3.lake_geom)).all()
        ok_(not session.scalar(l1.lake_geom.overlaps(l3.lake_geom)))
        ok_(session.scalar(l2.lake_geom.overlaps(l3.lake_geom)))
        ok_(l1 not in overlapping_lakes)
        ok_(l2 in overlapping_lakes)
        eq_(session.scalar(functions.overlaps('POLYGON((2 1, 4 1, 4 3, 2 3, 2 1))', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), True)

    def test_contains(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        p1 = session.query(Spot).get(2)
        p2 = session.query(Spot).get(3)
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains(p1.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        ok_(session.scalar(l.lake_geom.gcontains(WKTSpatialElement('POINT(-88.9055734203822 43.0048567324841)'))))
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains('POINT(-88.9055734203822 43.0048567324841)')).all()
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        spots_within = session.query(Spot).filter(l.lake_geom.gcontains(Spot.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)
        eq_(session.scalar(functions.gcontains('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), False)

    def test_sdo_filter(self):
        ok_(session.query(Spot).filter(Spot.spot_location.sdo_filter('POINT(-88.9055734203822 43.0048567324841)')).all())

    def test_sdo_nn(self):
        ok_(session.query(Spot).filter(Spot.spot_location.sdo_nn('POINT(-88.9055734203822 43.0048567324841)'
                                                                     'distance=2')).first())

    def test_sdo_nn_distance(self):
        ok_(session.query(Spot, oracle_functions.sdo_nn_distance(text('42'))).
                        filter(Spot.spot_location.sdo_nn('POINT(-88.9055734203822 43.0048567324841)'
                                                                     'distance=2', text('42'))).first())

    def test_sdo_relate(self):
        ok_(session.query(Spot).
                        filter(Spot.spot_location.sdo_relate('POINT(-88.9055734203822 43.0048567324841)',
                                                                     'mask=equal')).first())

    def test_sdo_within_distance(self):
        ok_(session.query(Spot).
                        filter(Spot.spot_location.sdo_within_distance('POINT(-88.9055734203822 43.0048567324841)',
                                                                     'distance=2')).first())

    def test_sdo_anyinteract(self):
        ok_(session.query(Spot).filter(
                Spot.spot_location.sdo_anyinteract('POINT(-88.9055734203822 43.0048567324841)')).first())

    def test_sdo_contains(self):
        ok_(session.query(Lake).filter(
                Lake.lake_geom.sdo_contains('POINT(-88.9055734203822 43.0048567324841)')).first())

    def test_sdo_coveredby(self):
        test_lake = Lake(lake_name='Test Lake', lake_geom=WKTSpatialElement('POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))', 4326))
        session.add(test_lake)
        session.commit()

        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        covering_lakes = session.query(Lake).filter(Lake.lake_geom.sdo_coveredby('POLYGON((0 0, 20 0, 20 20, 0 20, 0 0))')).all()
        ok_(test_lake in covering_lakes)
        ok_(l1 not in covering_lakes)

    def test_sdo_covers(self):
        # see http://download.oracle.com/docs/cd/E11882_01/appdev.112/e11830/sdo_intro.htm#i880253
        # Covers/CoveredBy work different in Oracle
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        covering_lakes = session.query(Lake).filter(Lake.lake_geom.sdo_covers('LINESTRING(-88.7968950764331 43.2305732929936, -88.7935511273885 43.1553344394904)')).all()
        ok_(l in covering_lakes)
        ok_(l1 not in covering_lakes)

    def test_sdo_equal(self):
        ok_(session.query(Spot).filter(
                        Spot.spot_location.sdo_equal('POINT(-88.9055734203822 43.0048567324841)')).first())

    def test_sdo_inside(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        ok_(session.query(Spot).filter(
                        Spot.spot_location.sdo_inside(l.lake_geom)).first())

    def test_sdo_on(self):
        test_road = Road(road_name='Test Road', road_geom=WKTSpatialElement('LINESTRING(0 0, 10 0)', 4326))
        session.add(test_road)
        session.commit()

        ok_(session.query(Road).filter(
                        Road.road_geom.sdo_on('POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))')).first())

    def test_sdo_overlapbydisjoint(self):
        r2 = session.query(Road).filter(Road.road_name=='Paul St').one()
        ok_(session.query(Lake).filter(
                        Lake.lake_geom.sdo_overlapbdydisjoint(r2.road_geom)).first())

    def test_sdo_overlapbyintersect(self):
        test_lake = Lake(lake_name='Test Lake Overlap', lake_geom=WKTSpatialElement('POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))', 4326))
        session.add(test_lake)
        session.commit()
        ok_(session.query(Lake).filter(Lake.lake_geom.sdo_overlapbdyintersect(
                    'POLYGON((-10 1, 5 1, 5 8, -10 8, -10 1))')).first())

    def test_sdo_overlaps(self):
        r2 = session.query(Road).filter(Road.road_name=='Paul St').one()
        ok_(session.query(Lake).filter(
                        Lake.lake_geom.sdo_overlaps(r2.road_geom)).first())

    def test_sdo_touch(self):
        test_lake = Lake(lake_name='Test Lake Touch', lake_geom=WKTSpatialElement('POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))', 4326))
        session.add(test_lake)
        session.commit()
        ok_(session.query(Lake).filter(Lake.lake_geom.sdo_touch(
                    'POLYGON((-10 1, 0 1, 0 8, -10 8, -10 1))')).first())


    def test_intersection(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        s = session.query(Spot).get(4)
        eq_(session.scalar(functions.wkt(l.lake_geom.intersection(s.spot_location, tolerance, auto_diminfo=False))), None)
        l = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        r = session.query(Road).filter(Road.road_name=='Paul St').one()
        eq_(session.scalar(functions.wkt(l.lake_geom.intersection(r.road_geom))), u'LINESTRING (-88.1430664921296 42.6255530821991, -88.114084510211 42.6230683849207)')
        ok_(session.query(Lake).filter(functions.equals(Lake.lake_geom.intersection(r.road_geom), WKTSpatialElement('LINESTRING(-88.1430664921296 42.6255530821991, -88.114084510211 42.6230683849207)'))).first() is not None)

    def test_sdo_geom_sdo_area(self):
        ok_(self.test_area, 'same as functions.area')

    def test_sdo_geom_sdo_buffer(self):
        ok_(self.test_buffer, 'same as functions.buffer')

    def test_sdo_geom_sdo_centroid(self):
        ok_(self.test_centroid, 'same as functions.centroid')

    def test_sdo_geom_sdo_concavehull(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.sdo_geom_sdo_concavehull(tolerance))),
            u'POLYGON ((-88.5477708728477 42.6988853969538, -88.5912422100661 43.1871019533972, -88.6029460317718 43.0884554581896, -88.6096339299412 42.9697452675198, -88.5477708728477 42.6988853969538))')

    def test_sdo_geom_sdo_concavehull_boundary(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.sdo_geom_sdo_concavehull_boundary(tolerance))),
            u'POLYGON ((-88.5477708728477 42.6988853969538, -88.5912422100661 43.1871019533972, -88.6029460317718 43.0884554581896, -88.6096339299412 42.9697452675198, -88.5477708728477 42.6988853969538))')

    def test_sdo_geom_sdo_convexhull(self):
        ok_(self.test_convex_hull, 'same as functions.convex_hull')

    def test_sdo_geom_sdo_difference(self):
        eq_(session.scalar(functions.wkt(oracle_functions.sdo_geom_sdo_difference(
                                    'POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))',
                                    'POLYGON((-10 1, 5 1, 5 8, -10 8, -10 1))',
                                    tolerance))),
            u'POLYGON ((5.0 1.0, 5.0 8.0, 0.0 8.06054845190832, 0.0 1.00766739404158, 5.0 1.0))')


    def test_sdo_geom_sdo_distance(self):
        ok_(self.test_distance, 'same as functions.distance')

    def test_sdo_geom_sdo_intersection(self):
        ok_(self.test_intersection, 'same as functions.intersection')

    def test_sdo_geom_sdo_length(self):
        ok_(self.test_length, 'same as functions.length')

    def test_sdo_geom_sdo_mbr(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.sdo_geom_sdo_mbr)),
            u'POLYGON ((-88.6096339299363 42.6988853949045, -88.5477708726115 42.6988853949045, -88.5477708726115 43.187101955414, -88.6096339299363 43.187101955414, -88.6096339299363 42.6988853949045))')

    def test_sdo_geom_sdo_pointonsurface(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        eq_(session.scalar(functions.wkt(l.lake_geom.sdo_geom_sdo_pointonsurface)), u'POINT (-89.0694267515924 43.1335987261147)')

    def test_sdo_geom_sdo_union(self):
        eq_(session.scalar(functions.wkt(oracle_functions.sdo_geom_sdo_union(
                                    'POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))',
                                    'POLYGON((-10 1, 5 1, 5 8, -10 8, -10 1))',
                                    tolerance))),
            u'POLYGON ((0.0 8.06054845190832, -10.0 8.0, -10.0 1.0, 0.0 1.00766739404158, 0.0 0.0, 10.0 0.0, 10.0 10.0, 0.0 10.0, 0.0 8.06054845190832))')

    def test_sdo_geom_sdo_xor(self):
        eq_(session.scalar(functions.wkt(oracle_functions.sdo_geom_sdo_xor(
                                    'POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))',
                                    'POLYGON((-10 1, 5 1, 5 8, -10 8, -10 1))',
                                    tolerance))),
            u'MULTIPOLYGON (((-10.0 8.0, -10.0 1.0, 0.0 1.00766739404158, 0.0 8.06054845190832, -10.0 8.0)), ((10.0 0.0, 10.0 10.0, 0.0 10.0, 0.0 8.06054845190832, 5.0 8.0, 5.0 1.0, 0.0 1.00766739404158, 0.0 0.0, 10.0 0.0)))')

    def test_sdo_geom_sdo_within_distance(self):
        ok_(self.test_within_distance, 'same as functions.within_distance')

    def test_within_distance(self):
        """
        Because SDO_WITHIN_DISTANCE requires a spatial index for the geometry used
        as first parameter, we have to insert out test geometries into tables,
        unlike to the other databases.

        Note that Oracle uses meter as unit for the tolerance value for geodetic coordinate
        systems (like 4326)!
        """
        # test if SDO_functions._within_distance is called correctly
        eq_(session.query(Spot).filter(functions._within_distance(Spot.spot_location, 'POINT(0 0)', 0)).count(), 1)
        eq_(session.query(Spot).filter(functions._within_distance(Spot.spot_location, 'POINT(0 0)', 0.1)).count(), 1)
        eq_(session.query(Spot).filter(functions._within_distance(Spot.spot_location, 'POINT(9 9)', 100000)).count(), 0)

        eq_(session.query(Spot).filter(functions._within_distance(Spot.spot_location,
                                                       'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)).count(), 3)

        eq_(session.query(Spot).filter(functions._within_distance(Spot.spot_location,
                                                       'Polygon((-10 -10, 10 -10, 10 10, -10 10, -10 -10))', 0)).count(), 4)

        eq_(session.query(Spot).filter(functions._within_distance(Spot.spot_location,
                                                       'Polygon((-10 -10, 10 -10, 10 10, -10 10, -10 -10))', 200000)).count(), 5)

        # test if SDO_GEOM.functions._within_distance is called correctly
        eq_(session.scalar(select([text('1')], from_obj=['dual']).where(
                                                    functions._within_distance('POINT(0 0)', 'POINT(0 0)', 0,
                                                                    {'tol' : 0.00000005}))), 1)
        eq_(session.scalar(select([text('1')], from_obj=['dual']).where(
                                                    functions._within_distance('POINT(0 0)', 'POINT(0 0)', 0,
                                                                    {'dim1' : text(diminfo),
                                                                     'dim2' : text(diminfo)}))), 1)

#todo: insert None
    @raises(IntegrityError)
    def test_constraint_nullable(self):
        spot_null = Spot(spot_height=None, spot_location=ORACLE_NULL_GEOMETRY)
#        spot_null = Spot(spot_height=None, spot_location=None)
        session.add(spot_null)
        session.commit();
        session.delete(spot_null)
        session.commit();
        ok_(True)
        road_null = Road(road_name='Jeff Rd', road_geom=ORACLE_NULL_GEOMETRY)
#        road_null = Road(road_name='Jeff Rd', road_geom=None)
        session.add(road_null)
        session.commit();


if __name__ == '__main__':
    import sys
    import nose

    sys.argv.append(__name__)
    result = nose.run()
    sys.exit(int(not result))

########NEW FILE########
__FILENAME__ = test_postgis
from unittest import TestCase
from sqlalchemy import (create_engine, MetaData, Column, Integer, String,
        Numeric, func, Table)
from sqlalchemy.orm import sessionmaker, mapper, relationship
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import and_, ForeignKey
from sqlalchemy.exc import IntegrityError

from geoalchemy import (Geometry, GeometryCollection, GeometryColumn,
        GeometryDDL, WKTSpatialElement, DBSpatialElement, GeometryExtensionColumn)
from geoalchemy.functions import functions
from geoalchemy.postgis import PGComparator, pg_functions

from nose.tools import eq_, ok_, raises, assert_almost_equal



engine = create_engine('postgresql://gis:gis@localhost/gis')
metadata = MetaData(engine)
session = sessionmaker(bind=engine)()
Base = declarative_base(metadata=metadata)

class Road(Base):
    __tablename__ = 'ROADS'

    road_id = Column(Integer, primary_key=True)
    road_name = Column(String)
    road_geom = GeometryColumn(Geometry(2), comparator=PGComparator, nullable=False)

    lakes = relationship('Lake', backref="road")

class Lake(Base):
    __tablename__ = 'lakes'

    lake_id = Column(Integer, primary_key=True)
    lake_name = Column(String)
    lake_geom = GeometryColumn(Geometry(2, wkt_internal=True), comparator=PGComparator)
    road_id = Column(Integer, ForeignKey('ROADS.road_id'))

spots_table = Table('spots', metadata,
                    Column('spot_id', Integer, primary_key=True),
                    Column('spot_height', Numeric),
                    GeometryExtensionColumn('spot_location', Geometry(2)))

class Spot(object):
    def __init__(self, spot_id=None, spot_height=None, spot_location=None):
        self.spot_id = spot_id
        self.spot_height = spot_height
        self.spot_location = spot_location


mapper(Spot, spots_table, properties={
            'spot_location': GeometryColumn(spots_table.c.spot_location,
                                            comparator=PGComparator)})

class Shape(Base):
    __tablename__ = 'shapes'

    shape_id = Column(Integer, primary_key=True)
    shape_name = Column(String)
    shape_geom = GeometryColumn(GeometryCollection(2))

# enable the DDL extension, which allows CREATE/DROP operations
# to work correctly.  This is not needed if working with externally
# defined tables.
GeometryDDL(Road.__table__)
GeometryDDL(Lake.__table__)
GeometryDDL(spots_table)
GeometryDDL(Shape.__table__)

class TestGeometry(TestCase):
    """Tests for PostGIS

    Note that WKT is used for comparisons, because PostGIS returns
    differing WKB values on different systems.
    """

    def setUp(self):

        metadata.drop_all()
        metadata.create_all()

        # Add objects.  We can use strings...
        session.add_all([
            Road(road_name='Jeff Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Peter Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Geordie Rd', road_geom='LINESTRING(-89.2232485796178 42.6420382611465,-89.2449842484076 42.9179140573248,-89.2316084522293 43.106847178344,-89.0710987261147 43.243949044586,-89.092834566879 43.2957802993631,-89.092834566879 43.2957802993631,-89.0309715095541 43.3175159681529)'),
            Road(road_name='Paul St', road_geom='LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147)'),
            Road(road_name='Graeme Ave', road_geom='LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)'),
            Road(road_name='Phil Tce', road_geom='LINESTRING(-88.9356689617834 42.9363057770701,-88.9824842484076 43.0366242484076,-88.9222931656051 43.1085191528662,-88.8487262866242 43.0449841210191)'),
            Lake(lake_name='My Lake', lake_geom='POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))'),
            Lake(lake_name='Lake White', lake_geom='POLYGON((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542))'),
            Lake(lake_name='Lake Blue', lake_geom='POLYGON((-89.0694267515924 43.1335987261147,-89.1078821656051 43.1135350318471,-89.1329617834395 43.0884554140127,-89.1312898089172 43.0466560509554,-89.112898089172 43.0132165605096,-89.0694267515924 42.9898089171975,-89.0343152866242 42.953025477707,-89.0209394904459 42.9179140127389,-89.0042197452229 42.8961783439491,-88.9774681528663 42.8644108280255,-88.9440286624204 42.8292993630573,-88.9072452229299 42.8142515923567,-88.8687898089172 42.815923566879,-88.8687898089172 42.815923566879,-88.8102707006369 42.8343152866242,-88.7734872611465 42.8710987261147,-88.7517515923567 42.9145700636943,-88.7433917197452 42.9730891719745,-88.7517515923567 43.0299363057325,-88.7734872611465 43.0867834394905,-88.7885352038217 43.158678388535,-88.8738057324841 43.1620222929936,-88.947372611465 43.1937898089172,-89.0042197452229 43.2138535031847,-89.0410031847134 43.2389331210191,-89.0710987261147 43.243949044586,-89.0660828025478 43.2238853503185,-89.0543789808917 43.203821656051,-89.0376592356688 43.175398089172,-89.0292993630573 43.1519904458599,-89.0376592356688 43.1369426751592,-89.0393312101911 43.1386146496815,-89.0393312101911 43.1386146496815,-89.0510350318471 43.1335987261147,-89.0694267515924 43.1335987261147))'),
            Lake(lake_name='Lake Deep', lake_geom='POLYGON((-88.9122611464968 43.038296178344,-88.9222929936306 43.0399681528663,-88.9323248407643 43.0282643312102,-88.9206210191083 43.0182324840764,-88.9105891719745 43.0165605095542,-88.9005573248408 43.0232484076433,-88.9072452229299 43.0282643312102,-88.9122611464968 43.038296178344))'),
            Spot(spot_height=420.40, spot_location='POINT(-88.5945861592357 42.9480095987261)'),
            Spot(spot_height=102.34, spot_location='POINT(-88.9055734203822 43.0048567324841)'),
            Spot(spot_height=388.62, spot_location='POINT(-89.201512910828 43.1051752038217)'),
            Spot(spot_height=454.66, spot_location='POINT(-88.3304141847134 42.6269904904459)'),
            Shape(shape_name='Bus Stop', shape_geom='GEOMETRYCOLLECTION(POINT(-88.3304141847134 42.6269904904459))'),
            Shape(shape_name='Jogging Track', shape_geom='GEOMETRYCOLLECTION(LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147))'),
            Shape(shape_name='Play Ground', shape_geom='GEOMETRYCOLLECTION(POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936)))'),
        ])

        # or use an explicit WKTSpatialElement (similar to saying func.GeomFromText())
        self.r = Road(road_name='Dave Cres', road_geom=WKTSpatialElement('LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)', 4326))
        session.add(self.r)
        session.commit()

    def tearDown(self):
        session.rollback()
        metadata.drop_all()

    # Test Geometry Functions

    def test_geometry_type(self):
        r = session.query(Road).get(1)
        l = session.query(Lake).get(1)
        s = session.query(Spot).get(1)
        eq_(session.scalar(r.road_geom.geometry_type), 'ST_LineString')
        eq_(session.scalar(l.lake_geom.geometry_type), 'ST_Polygon')
        eq_(session.scalar(s.spot_location.geometry_type), 'ST_Point')
        eq_(session.scalar(functions.geometry_type(r.road_geom)), 'ST_LineString')
        ok_(session.query(Road).filter(Road.road_geom.geometry_type == 'ST_LineString').first())

    def test_geom_type(self):
        r = session.query(Road).get(1)
        l = session.query(Lake).get(1)
        s = session.query(Spot).get(1)
        eq_(r.road_geom.geom_type(session), 'LineString')
        eq_(l.lake_geom.geom_type(session), 'Polygon')
        eq_(s.spot_location.geom_type(session), 'Point')

    def test_wkt(self):
        l = session.query(Lake).get(1)
        assert session.scalar(self.r.road_geom.wkt) == 'LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)'
        eq_(session.scalar(l.lake_geom.wkt),'POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))')
        eq_(session.scalar(l.lake_geom.wkt), l.lake_geom.geom_wkt)
        ok_(not session.query(Spot).filter(Spot.spot_location.wkt == 'POINT(0,0)').first())
        ok_(session.query(Spot).get(1) is
            session.query(Spot).filter(Spot.spot_location == 'POINT(-88.5945861592357 42.9480095987261)').first())
        centroid_geom = DBSpatialElement(session.scalar(self.r.road_geom.centroid))
        eq_(session.scalar(centroid_geom.wkt), u'POINT(-88.5769371859941 42.9915634871979)')
        eq_(session.scalar(WKTSpatialElement('POINT(-88.5769371859941 42.9915634871979)').wkt), u'POINT(-88.5769371859941 42.9915634871979)')
        eq_(session.query(Spot.spot_location.wkt).filter(Spot.spot_id == 1).first(), (u'POINT(-88.5945861592357 42.9480095987261)',))

    def test_coords(self):
        eq_(self.r.road_geom.coords(session), [[-88.6748409363057,43.1035032292994],[-88.6464173694267,42.9981688343949],[-88.607961955414,42.9680732929936],[-88.5160033566879,42.9363057770701],[-88.4390925286624,43.0031847579618]])
        l = session.query(Lake).filter(Lake.lake_name=="Lake Deep").one()
        eq_(l.lake_geom.coords(session), [[[-88.9122611464968,43.038296178344],[-88.9222929936306,43.0399681528663],[-88.9323248407643,43.0282643312102],[-88.9206210191083,43.0182324840764],[-88.9105891719745,43.0165605095542],[-88.9005573248408,43.0232484076433],[-88.9072452229299,43.0282643312102],[-88.9122611464968,43.038296178344]]])
        s = session.query(Spot).filter(Spot.spot_height==102.34).one()
        eq_(s.spot_location.coords(session), [-88.905573420382197, 43.0048567324841])

    def test_wkb(self):
        eq_(session.scalar(functions.wkt(func.ST_GeomFromWKB(self.r.road_geom.wkb, 4326))),
            u'LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)')
        eq_(session.scalar(self.r.road_geom.wkb), self.r.road_geom.geom_wkb)
        ok_(not session.query(Spot).filter(Spot.spot_location.wkb == '101').first())
        centroid_geom = DBSpatialElement(session.scalar(self.r.road_geom.centroid))
        eq_(session.scalar(functions.wkt(func.ST_GeomFromWKB(centroid_geom.wkb, 4326))), u'POINT(-88.5769371859941 42.9915634871979)')

    def test_svg(self):
        eq_(session.scalar(self.r.road_geom.svg), u'M -88.674840936305699 -43.103503229299399 L -88.6464173694267 -42.998168834394903 -88.607961955413998 -42.968073292993601 -88.516003356687904 -42.936305777070103 -88.4390925286624 -43.003184757961797')
        ok_(self.r is session.query(Road).filter(Road.road_geom.svg == u'M -88.674840936305699 -43.103503229299399 L -88.6464173694267 -42.998168834394903 -88.607961955413998 -42.968073292993601 -88.516003356687904 -42.936305777070103 -88.4390925286624 -43.003184757961797').first())
        eq_(session.scalar(pg_functions.svg('POINT(-88.9055734203822 43.0048567324841)')), u'cx="-88.905573420382197" cy="-43.0048567324841"')
        ok_(session.query(Spot).filter(Spot.spot_location.svg == 'cx="-88.905573420382197" cy="-43.0048567324841"').first())

    def test_gml(self):
        eq_(session.scalar(self.r.road_geom.gml), '<gml:LineString srsName="EPSG:4326"><gml:coordinates>-88.674840936305699,43.103503229299399 -88.6464173694267,42.998168834394903 -88.607961955413998,42.968073292993601 -88.516003356687904,42.936305777070103 -88.4390925286624,43.003184757961797</gml:coordinates></gml:LineString>')

    def test_kml(self):
        s = session.query(Spot).filter(Spot.spot_height==420.40).one()
        eq_(session.scalar(s.spot_location.kml), u'<Point><coordinates>-88.594586159235703,42.948009598726102</coordinates></Point>')

    def test_geojson(self):
        s = session.query(Spot).filter(Spot.spot_height==420.40).one()
        ok_(True) # todo: test with version 1.3.4

    def test_dimension(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        eq_(session.scalar(r.road_geom.dimension), 1)
        eq_(session.scalar(l.lake_geom.dimension), 2)
        ok_(session.query(Spot).filter(Spot.spot_location.dimension == 0).first() is not None)
        eq_(session.scalar(functions.dimension('POINT(-88.5945861592357 42.9480095987261)')), 0)

    def test_srid(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(r.road_geom.srid), 4326)
        ok_(session.query(Spot).filter(Spot.spot_location.srid == 4326).first() is not None)
        eq_(session.scalar(functions.srid('POINT(-88.5945861592357 42.9480095987261)')), 4326)

    def test_is_valid(self):
        ok_(session.query(Spot).filter(Spot.spot_location.is_valid == True).first() is not None)
        eq_(session.scalar(functions.is_valid('POINT(-88.5945861592357 42.9480095987261)')), True)

    def test_is_empty(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        assert not session.scalar(r.road_geom.is_empty)
        assert not session.scalar(l.lake_geom.is_empty)
        ok_(session.query(Spot).filter(Spot.spot_location.is_empty == False).first() is not None)
        eq_(session.scalar(functions.is_empty('POINT(-88.5945861592357 42.9480095987261)')), False)

    def test_is_simple(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        assert session.scalar(r.road_geom.is_simple)
        assert session.scalar(l.lake_geom.is_simple)
        ok_(session.query(Spot).filter(Spot.spot_location.is_simple == True).first() is not None)
        eq_(session.scalar(functions.is_simple('LINESTRING(1 1,2 2,2 3.5,1 3,1 2,2 1)')), False)

    def test_is_closed(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        assert not session.scalar(r.road_geom.is_closed)
        assert session.scalar(l.lake_geom.is_closed)
        ok_(session.query(Lake).filter(Lake.lake_geom.is_closed == True).first() is not None)
        eq_(session.scalar(functions.is_closed('LINESTRING(0 0, 1 1)')), False)

    def test_is_ring(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert not session.scalar(r.road_geom.is_ring)
        ok_(session.query(Road).filter(Road.road_geom.is_ring == True).first() is None)
        eq_(session.scalar(functions.is_ring('LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)')), False)

    def test_num_points(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.num_points))
        eq_(session.scalar(r.road_geom.num_points), 5)
        ok_(not session.scalar(s.spot_location.num_points))
        ok_(session.query(Road).filter(Road.road_geom.num_points == 5).first() is not None)
        eq_(session.scalar(functions.num_points('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)')), 4)

    def test_point_n(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        ok_(not session.scalar(l.lake_geom.point_n(1)))
        ok_(session.query(Road).filter(Road.road_geom.point_n(5) == WKTSpatialElement('POINT(-88.3655256496815 43.1402866687898)')).first() is not None)
        eq_(session.scalar(r.road_geom.point_n(5).wkt), u'POINT(-88.3655256496815 43.1402866687898)')
        eq_(session.scalar(functions.wkt(functions.point_n('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)', 1)))
                           , u'POINT(77.29 29.07)')

    def test_persistent(self):
        eq_(session.scalar(functions.wkt(func.ST_GeomFromWKB(self.r.road_geom.wkb, 4326))),
            u'LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)')

        geom = WKTSpatialElement('POINT(30250865.9714116 -610981.481754275)', 2249)
        spot = Spot(spot_height=102.34, spot_location=geom)
        session.add(spot)
        session.commit();
        assert_almost_equal(session.scalar(spot.spot_location.x), 0)
        assert_almost_equal(session.scalar(spot.spot_location.y), 0)

    def test_eq(self):
        r1 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r2 = session.query(Road).filter(Road.road_geom == 'LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)').one()
        r3 = session.query(Road).filter(Road.road_geom == r1.road_geom).one()
        ok_(r1 is r2 is r3)

    def test_ne(self):
        r1 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r2 = session.query(Road).filter(Road.road_geom == 'LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)').one()
        ok_(r2 not in session.query(Road).filter(Road.road_geom != r2.road_geom).all())

    def test_length(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert_almost_equal(session.scalar(r.road_geom.length), 0.496071476676014)
        ok_(session.query(Road).filter(Road.road_geom.length > 0).first() is not None)
        assert_almost_equal(session.scalar(functions.length('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)')), 0.62916306324869398)

    def test_area(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        assert_almost_equal(session.scalar(l.lake_geom.area), 0.10475991566721)
        ok_(session.query(Lake).filter(Lake.lake_geom.area > 0).first() is not None)
        assert_almost_equal(session.scalar(functions.area(WKTSpatialElement('POLYGON((743238 2967416,743238 2967450,743265 2967450,743265.625 2967416,743238 2967416))',2249))),
                            928.625)

    def test_x(self):
        s = session.query(Spot).filter(Spot.spot_height==420.40).one()
        eq_(session.scalar(s.spot_location.x), -88.5945861592357)
        s = session.query(Spot).filter(and_(Spot.spot_location.x < 0, Spot.spot_location.y > 42)).all()
        ok_(s is not None)
        eq_(session.scalar(functions.x('POINT(-88.3655256496815 43.1402866687898)')), -88.3655256496815)

    def test_y(self):
        s = session.query(Spot).filter(Spot.spot_height==420.40).one()
        eq_(session.scalar(s.spot_location.y), 42.9480095987261)
        s = session.query(Spot).filter(and_(Spot.spot_location.y < 0, Spot.spot_location.y > 42)).all()
        ok_(s is not None)
        eq_(session.scalar(functions.y('POINT(-88.3655256496815 43.1402866687898)')), 43.1402866687898)

    def test_centroid(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        eq_(session.scalar(functions.wkt(r.road_geom.centroid)), u'POINT(-88.5889975373709 42.941769988935)')
        eq_(session.scalar(functions.wkt(l.lake_geom.centroid)), u'POINT(-88.9214538261088 43.0191497691548)')
        ok_(session.query(Spot).filter(Spot.spot_location.centroid == WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, 0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'))),
            u'POINT(2.30769230769231 3.30769230769231)')

    def test_boundary(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.boundary)), u'MULTIPOINT(-88.5477708726115 42.6988853949045,-88.5912422101911 43.187101955414)')
        ok_(session.query(Road).filter(Road.road_geom.boundary == WKTSpatialElement('MULTIPOINT(-88.9139332929936 42.5082802993631,-88.3655256496815 43.1402866687898)')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.boundary('POLYGON((1 1,0 0, -1 1, 1 1))'))),
            u'LINESTRING(1 1,0 0,-1 1,1 1)')

    def test_buffer(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        assert_almost_equal(session.scalar(functions.area(r.road_geom.buffer(10.0, 8))), 321.93380659099699)
        ok_(session.query(Spot).filter(functions.within('POINT(-88.5945861592357 42.9480095987261)', Spot.spot_location.buffer(10))).first() is not None)
        assert_almost_equal(session.scalar(functions.area(functions.buffer('POINT(-88.5945861592357 42.9480095987261)', 10, 2))), 282.84271247461902)

    def test_convex_hull(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.convex_hull)),
            u'POLYGON((-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414,-88.5477708726115 42.6988853949045))')
        ok_(session.query(Spot).filter(Spot.spot_location.convex_hull == WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.convex_hull('POINT(-88.5945861592357 42.9480095987261)'))),
            u'POINT(-88.5945861592357 42.9480095987261)')

    def test_envelope(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.envelope)),
            u'POLYGON((-88.6096339299363 42.6988853949045,-88.6096339299363 43.187101955414,-88.5477708726115 43.187101955414,-88.5477708726115 42.6988853949045,-88.6096339299363 42.6988853949045))')
        eq_(session.scalar(functions.geometry_type(self.r.road_geom.envelope)), 'ST_Polygon')
        ok_(session.query(Spot).filter(Spot.spot_location.envelope == WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.envelope('POINT(-88.5945861592357 42.9480095987261)'))),
            u'POINT(-88.5945861592357 42.9480095987261)')

    def test_start_point(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.start_point)),
            u'POINT(-88.5477708726115 42.6988853949045)')
        ok_(session.query(Road).filter(Road.road_geom.start_point == WKTSpatialElement('POINT(-88.9139332929936 42.5082802993631)')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.start_point('LINESTRING(0 1, 0 2)'))),
            u'POINT(0 1)')

    def test_end_point(self):
        r = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        eq_(session.scalar(functions.wkt(r.road_geom.end_point)),
            u'POINT(-88.5912422101911 43.187101955414)')
        ok_(session.query(Road).filter(Road.road_geom.end_point == WKTSpatialElement('POINT(-88.3655256496815 43.1402866687898)')).first() is not None)
        eq_(session.scalar(functions.wkt(functions.end_point('LINESTRING(0 1, 0 2)'))),
            u'POINT(0 2)')

    def test_transform(self):
        spot = session.query(Spot).get(1)
        # compare the coordinates using a tolerance, because they may vary on different systems
        assert_almost_equal(session.scalar(functions.x(spot.spot_location.transform(2249))), -3890517.6109559298)
        assert_almost_equal(session.scalar(functions.y(spot.spot_location.transform(2249))), 3627658.6746507999)
        ok_(session.query(Spot).filter(Spot.spot_location.transform(2249).wkt == 'POINT(-3890517.61095593 3627658.6746508)').first() is not None)
        eq_(session.scalar(functions.wkt(functions.transform(WKTSpatialElement('POLYGON((743238 2967416,743238 2967450,743265 2967450,743265.625 2967416,743238 2967416))', 2249), 4326))),
            u'POLYGON((-71.1776848522251 42.3902896512902,-71.1776843766326 42.3903829478009,-71.1775844305465 42.3903826677917,-71.1775825927231 42.3902893647987,-71.1776848522251 42.3902896512902))')

    # Test Geometry Relationships

    def test_equals(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Peter Rd').one()
        r3 = session.query(Road).filter(Road.road_name=='Paul St').one()
        equal_roads = session.query(Road).filter(Road.road_geom.equals(r1.road_geom)).all()
        ok_(r1 in equal_roads)
        ok_(r2 in equal_roads)
        ok_(r3 not in equal_roads)
        ok_(session.query(Spot).filter(Spot.spot_location.equals(WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)'))).first() is not None)
        eq_(session.scalar(functions.equals('POINT(-88.5945861592357 42.9480095987261)', 'POINT(-88.5945861592357 42.9480095987261)')), True)

    def test_distance(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        r3 = session.query(Road).filter(Road.road_name=='Peter Rd').one()
        assert_almost_equal(session.scalar(r1.road_geom.distance(r2.road_geom)), 0.336997238682841)
        eq_(session.scalar(r1.road_geom.distance(r3.road_geom)), 0.0)
        ok_(session.query(Spot).filter(Spot.spot_location.distance(WKTSpatialElement('POINT(-88.5945861592357 42.9480095987261)')) < 10).first() is not None)
        assert_almost_equal(session.scalar(functions.distance('POINT(-88.5945861592357 42.9480095987261)', 'POINT(-88.5945861592357 42.9480095987261)')), 0)

    def test_within_distance(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        roads_within_distance = session.query(Road).filter(
            Road.road_geom.within_distance(r1.road_geom, 0.20)).all()
        ok_(r2 in roads_within_distance)
        ok_(r3 not in roads_within_distance)
        eq_(session.scalar(functions.within_distance('POINT(-88.9139332929936 42.5082802993631)', 'POINT(-88.9139332929936 35.5082802993631)', 10)), True)

    def test_disjoint(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        disjoint_roads = session.query(Road).filter(Road.road_geom.disjoint(r1.road_geom)).all()
        ok_(r2 not in disjoint_roads)
        ok_(r3 in disjoint_roads)
        eq_(session.scalar(functions.disjoint('POINT(0 0)', 'LINESTRING ( 2 0, 0 2 )')), True)


    def test_intersects(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        intersecting_roads = session.query(Road).filter(Road.road_geom.intersects(r1.road_geom)).all()
        ok_(r2 in intersecting_roads)
        ok_(r3 not in intersecting_roads)
        eq_(session.scalar(functions.intersects('POINT(0 0)', 'LINESTRING ( 2 0, 0 2 )')), False)

    def test_touches(self):
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        r = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        touching_lakes = session.query(Lake).filter(Lake.lake_geom.touches(r.road_geom)).all()
        ok_(not session.scalar(l1.lake_geom.touches(r.road_geom)))
        ok_(session.scalar(l2.lake_geom.touches(r.road_geom)))
        ok_(l1 not in touching_lakes)
        ok_(l2 in touching_lakes)
        eq_(session.scalar(functions.touches('POINT(1 1)', 'LINESTRING (0 0, 1 1, 0 2)')), False)

    def test_crosses(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Paul St').one()
        l = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        crossing_roads = session.query(Road).filter(Road.road_geom.crosses(l.lake_geom)).all()
        ok_(not session.scalar(r1.road_geom.crosses(l.lake_geom)))
        ok_(session.scalar(r2.road_geom.crosses(l.lake_geom)))
        ok_(r1 not in crossing_roads)
        ok_(r2 in crossing_roads)
        eq_(session.scalar(functions.crosses('LINESTRING(0 1, 2 1)', 'LINESTRING (0 0, 1 2, 0 2)')), True)

    def test_within(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        spots_within = session.query(Spot).filter(Spot.spot_location.within(l.lake_geom)).all()
        ok_(session.scalar(p1.spot_location.within(l.lake_geom)))
        ok_(not session.scalar(p2.spot_location.within(l.lake_geom)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)
        eq_(session.scalar(functions.within('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), True)
        buffer_geom = DBSpatialElement(session.scalar(l.lake_geom.buffer(10.0)))
        spots_within = session.query(Spot).filter(l.lake_geom.within(buffer_geom)).all()
        ok_(p1 in spots_within)
        ok_(p2 in spots_within)

    def test_overlaps(self):
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l3 = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        overlapping_lakes = session.query(Lake).filter(Lake.lake_geom.overlaps(l3.lake_geom)).all()
        ok_(not session.scalar(l1.lake_geom.overlaps(l3.lake_geom)))
        ok_(session.scalar(l2.lake_geom.overlaps(l3.lake_geom)))
        ok_(l1 not in overlapping_lakes)
        ok_(l2 in overlapping_lakes)
        eq_(session.scalar(functions.overlaps('POLYGON((2 1, 4 1, 4 3, 2 3, 2 1))', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), True)

    def test_contains(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains(p1.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        ok_(session.scalar(l.lake_geom.gcontains(WKTSpatialElement('POINT(-88.9055734203822 43.0048567324841)'))))
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains('POINT(-88.9055734203822 43.0048567324841)')).all()
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        spots_within = session.query(Spot).filter(l.lake_geom.gcontains(Spot.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)
        eq_(session.scalar(functions.gcontains('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), False)

    def test_covers(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        covering_lakes = session.query(Lake).filter(Lake.lake_geom.covers(p1.spot_location)).all()
        ok_(session.scalar(l.lake_geom.covers(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.covers(p2.spot_location)))
        ok_(l in covering_lakes)
        ok_(l1 not in covering_lakes)
        eq_(session.scalar(functions.gcontains('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), False)

    def test_covered_by(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        covered_spots = session.query(Spot).filter(Spot.spot_location.covered_by(l.lake_geom)).all()
        ok_(session.scalar(p1.spot_location.covered_by(l.lake_geom)))
        ok_(not session.scalar(p2.spot_location.covered_by(l.lake_geom)))
        ok_(p1 in covered_spots)
        ok_(p2 not in covered_spots)
        eq_(session.scalar(functions.covered_by('LINESTRING(0 1, 2 1)', 'POLYGON((-1 -1, 3 -1, 3 2, -1 2, -1 -1))')), True)

    def test_intersection(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        r = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        s = session.query(Spot).filter(Spot.spot_height==454.66).one()
        eq_(session.scalar(func.ST_AsText(l.lake_geom.intersection(s.spot_location))), 'GEOMETRYCOLLECTION EMPTY')
        eq_(session.scalar(func.ST_AsText(session.scalar(l.lake_geom.intersection(r.road_geom)))), 'POINT(-89.0710987261147 43.243949044586)')
        l = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        r = session.query(Road).filter(Road.road_name=='Paul St').one()
        eq_(session.scalar(func.ST_AsText(session.scalar(l.lake_geom.intersection(r.road_geom)))), 'LINESTRING(-88.1430673666454 42.6255500261493,-88.1140839697546 42.6230657349872)')
        ok_(session.query(Lake).filter(Lake.lake_geom.intersection(r.road_geom).wkt == 'LINESTRING(-88.1430673666454 42.6255500261493,-88.1140839697546 42.6230657349872)').first() is not None)

    def test_extent(self):
        l = session.query(functions.extent(Lake.lake_geom)). \
                filter(Lake.lake_geom != None).scalar()
        r = session.query(functions.extent(Road.road_geom)). \
                filter(Road.road_geom != None).scalar()
        s = session.query(functions.extent(Spot.spot_location)). \
                filter(Spot.spot_location != None).scalar()
        sh = session.query(functions.extent(Shape.shape_geom)). \
                filter(Shape.shape_geom != None).scalar()

        eq_(l, "BOX(-89.1329617834395 42.565127388535,-88.0846337579618 43.243949044586)")
        eq_(r, "BOX(-89.2449842484076 42.5082802993631,-88.0110670509554 43.3175159681529)")
        eq_(s, "BOX(-89.201512910828 42.6269904904459,-88.3304141847134 43.1051752038217)")
        eq_(sh, "BOX(-88.7968950764331 42.5584395350319,-88.0110670509554 43.2339172420382)")

    def test_union(self):
        l = session.query(functions.geometry_type(functions.union(Lake.lake_geom))). \
                filter(Lake.lake_geom != None).scalar()
        r = session.query(functions.geometry_type(functions.union(Road.road_geom))). \
                filter(Road.road_geom != None).scalar()
        s = session.query(functions.geometry_type(functions.union(Spot.spot_location))). \
                filter(Spot.spot_location != None).scalar()
        sh = session.query(functions.geometry_type(functions.union(Shape.shape_geom))). \
                filter(Shape.shape_geom != None).scalar()
        la = session.query(functions.union(Lake.lake_geom).wkt). \
                filter(Lake.lake_geom != None).scalar()

        eq_(l, "ST_MultiPolygon")
        eq_(r, "ST_MultiLineString")
        eq_(s, "ST_MultiPoint")
        eq_(sh, "ST_GeometryCollection")
        eq_(la, 'MULTIPOLYGON(((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542)),((-88.7878611897291 43.1554581337873,-88.7734872611465 43.0867834394905,-88.7517515923567 43.0299363057325,-88.7433917197452 42.9730891719745,-88.7517515923567 42.9145700636943,-88.7734872611465 42.8710987261147,-88.8102707006369 42.8343152866242,-88.8687898089172 42.815923566879,-88.9072452229299 42.8142515923567,-88.9440286624204 42.8292993630573,-88.9774681528663 42.8644108280255,-89.0042197452229 42.8961783439491,-89.0209394904459 42.9179140127389,-89.0343152866242 42.953025477707,-89.0694267515924 42.9898089171975,-89.112898089172 43.0132165605096,-89.1312898089172 43.0466560509554,-89.1329617834395 43.0884554140127,-89.1078821656051 43.1135350318471,-89.0694267515924 43.1335987261147,-89.0510350318471 43.1335987261147,-89.0393312101911 43.1386146496815,-89.0376592356688 43.1369426751592,-89.0292993630573 43.1519904458599,-89.0376592356688 43.175398089172,-89.0543789808917 43.203821656051,-89.0660828025478 43.2238853503185,-89.0710987261147 43.243949044586,-89.0410031847134 43.2389331210191,-89.0042197452229 43.2138535031847,-88.947372611465 43.1937898089172,-88.8738057324841 43.1620222929936,-88.7937087643429 43.1588812709654,-88.7968950764331 43.2305732929936,-88.7250001719745 43.2339172420382,-88.716640299363 43.1570064140127,-88.7878611897291 43.1554581337873)))')

    def test_collect(self):
        l = session.query(functions.geometry_type(functions.collect(Lake.lake_geom))). \
                filter(Lake.lake_geom != None).scalar()
        r = session.query(functions.geometry_type(functions.collect(Road.road_geom))). \
                filter(Road.road_geom != None).scalar()
        s = session.query(functions.geometry_type(functions.collect(Spot.spot_location))). \
                filter(Spot.spot_location != None).scalar()
        sh = session.query(functions.geometry_type(functions.collect(Shape.shape_geom))). \
                filter(Shape.shape_geom != None).scalar()
        la = session.query(functions.collect(Lake.lake_geom).wkt). \
                filter(Lake.lake_geom != None).scalar()

        eq_(l, "ST_MultiPolygon")
        eq_(r, "ST_MultiLineString")
        eq_(s, "ST_MultiPoint")
        eq_(sh, "ST_GeometryCollection")
        eq_(la, "MULTIPOLYGON(((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936)),((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542)),((-89.0694267515924 43.1335987261147,-89.1078821656051 43.1135350318471,-89.1329617834395 43.0884554140127,-89.1312898089172 43.0466560509554,-89.112898089172 43.0132165605096,-89.0694267515924 42.9898089171975,-89.0343152866242 42.953025477707,-89.0209394904459 42.9179140127389,-89.0042197452229 42.8961783439491,-88.9774681528663 42.8644108280255,-88.9440286624204 42.8292993630573,-88.9072452229299 42.8142515923567,-88.8687898089172 42.815923566879,-88.8687898089172 42.815923566879,-88.8102707006369 42.8343152866242,-88.7734872611465 42.8710987261147,-88.7517515923567 42.9145700636943,-88.7433917197452 42.9730891719745,-88.7517515923567 43.0299363057325,-88.7734872611465 43.0867834394905,-88.7885352038217 43.158678388535,-88.8738057324841 43.1620222929936,-88.947372611465 43.1937898089172,-89.0042197452229 43.2138535031847,-89.0410031847134 43.2389331210191,-89.0710987261147 43.243949044586,-89.0660828025478 43.2238853503185,-89.0543789808917 43.203821656051,-89.0376592356688 43.175398089172,-89.0292993630573 43.1519904458599,-89.0376592356688 43.1369426751592,-89.0393312101911 43.1386146496815,-89.0393312101911 43.1386146496815,-89.0510350318471 43.1335987261147,-89.0694267515924 43.1335987261147)),((-88.9122611464968 43.038296178344,-88.9222929936306 43.0399681528663,-88.9323248407643 43.0282643312102,-88.9206210191083 43.0182324840764,-88.9105891719745 43.0165605095542,-88.9005573248408 43.0232484076433,-88.9072452229299 43.0282643312102,-88.9122611464968 43.038296178344)))")

    def test_within_distance(self):
        ok_(session.scalar(functions._within_distance('POINT(-88.9139332929936 42.5082802993631)', 'POINT(-88.9139332929936 35.5082802993631)', 10)))
        ok_(session.scalar(functions._within_distance('Point(0 0)', 'Point(0 0)', 0)))
        ok_(session.scalar(functions._within_distance('Point(0 0)',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)))
        ok_(session.scalar(functions._within_distance('Point(5 5)',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)))
        ok_(session.scalar(functions._within_distance('Point(6 5)',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 1)))
        ok_(session.scalar(functions._within_distance('Polygon((0 0, 1 0, 1 8, 0 8, 0 0))',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)))

    @raises(IntegrityError)
    def test_constraint_nullable(self):
        spot_null = Spot(spot_height=420.40, spot_location=None)
        session.add(spot_null)
        session.commit();
        ok_(True)
        road_null = Road(road_name='Jeff Rd', road_geom=None)
        session.add(road_null)
        session.commit();

    def test_null(self):
        spot_null = Spot(spot_height=420.40, spot_location=None)
        session.add(spot_null)
        session.commit();
        spot_null = session.query(Spot).filter(Spot.spot_location == None).one()
        eq_(spot_null.spot_location, None)
        ok_(session.query(Spot).filter(Spot.spot_location != None).first() is not None)

    def test_issue17(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        lakes_within_distance = session.query(Lake).filter(
            Lake.road.has(functions._within_distance(Road.road_geom,r1.road_geom, 0.20))).all()
        lakes_within_distance = session.query(Lake).filter(
            Lake.road.has(functions.within_distance(Road.road_geom,r1.road_geom, 0.20))).all()


if __name__ == '__main__':
    import sys
    import nose

    sys.argv.append(__name__)
    result = nose.run()
    sys.exit(int(not result))

########NEW FILE########
__FILENAME__ = test_spatialite
from unittest import TestCase
from binascii import b2a_hex
from sqlalchemy import (create_engine, MetaData, Column, Integer, String,
        Numeric, func, Table)
from sqlalchemy.orm import sessionmaker, mapper
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.exc import IntegrityError
from sqlalchemy.sql.expression import Select, select

from pysqlite2 import dbapi2 as sqlite
from geoalchemy import (GeometryColumn, Point, Polygon,
		LineString, GeometryDDL, WKTSpatialElement, WKBSpatialElement,
        DBSpatialElement, GeometryExtensionColumn)
from geoalchemy.functions import functions
from nose.tools import ok_, eq_, assert_almost_equal, raises

from geoalchemy.spatialite import SQLiteComparator, sqlite_functions
from geoalchemy.base import PersistentSpatialElement
from sqlalchemy.orm.query import aliased

engine = create_engine('sqlite://', module=sqlite, echo=True)
connection = engine.raw_connection().connection
connection.enable_load_extension(True)
metadata = MetaData(engine)
session = sessionmaker(bind=engine)()
session.execute("select load_extension('/usr/lib/libspatialite.so')")
session.execute("SELECT InitSpatialMetaData()")
connection.enable_load_extension(False)
session.commit()
Base = declarative_base(metadata=metadata)

class Road(Base):
    __tablename__ = 'roads'

    road_id = Column(Integer, primary_key=True)
    road_name = Column(String)
    road_geom = GeometryColumn(LineString(2, srid=4326), comparator = SQLiteComparator, nullable=False)

class Lake(Base):
    __tablename__ = 'lakes'

    lake_id = Column(Integer, primary_key=True)
    lake_name = Column(String)
    lake_geom = GeometryColumn(Polygon(2, srid=4326, spatial_index=False), comparator = SQLiteComparator)

spots_table = Table('spots', metadata,
                    Column('spot_id', Integer, primary_key=True),
                    Column('spot_height', Numeric()),
                    GeometryExtensionColumn('spot_location', Point(2, srid=4326)))

class Spot(object):
    def __init__(self, spot_id=None, spot_height=None, spot_location=None):
        self.spot_id = spot_id
        self.spot_height = spot_height
        self.spot_location = spot_location


mapper(Spot, spots_table, properties={
            'spot_location': GeometryColumn(spots_table.c.spot_location,
                                            comparator=SQLiteComparator)})

# enable the DDL extension, which allows CREATE/DROP operations
# to work correctly.  This is not needed if working with externally
# defined tables.
GeometryDDL(Road.__table__)
GeometryDDL(Lake.__table__)
GeometryDDL(spots_table)

class TestGeometry(TestCase):
    """Tests for Spatialite

    Note that WKT is used for comparisons, because Spatialite may return
    differing WKB values on different systems.
    """

    def setUp(self):
        metadata.drop_all()
        session.execute("DROP VIEW geom_cols_ref_sys")
        session.execute("DROP TABLE geometry_columns")
        session.execute("DROP TABLE spatial_ref_sys")
        session.commit()
        session.execute("SELECT InitSpatialMetaData()")
        session.execute("INSERT INTO spatial_ref_sys (srid, auth_name, auth_srid, ref_sys_name, proj4text) VALUES (4326, 'epsg', 4326, 'WGS 84', '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')")
        session.execute("INSERT INTO spatial_ref_sys (srid, auth_name, auth_srid, ref_sys_name, proj4text) VALUES (2249, 'epsg', 2249, 'NAD83 / Massachusetts Mainland (ftUS)', '+proj=lcc +lat_1=42.68333333333333 +lat_2=41.71666666666667 +lat_0=41 +lon_0=-71.5 +x_0=200000.0001016002 +y_0=750000 +ellps=GRS80 +datum=NAD83 +to_meter=0.3048006096012192 +no_defs')")
        metadata.create_all()

        # Add objects.  We can use strings...
        session.add_all([
            Road(road_name='Jeff Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Peter Rd', road_geom='LINESTRING(-88.9139332929936 42.5082802993631,-88.8203027197452 42.5985669235669,-88.7383759681529 42.7239650127389,-88.6113059044586 42.9680732929936,-88.3655256496815 43.1402866687898)'),
            Road(road_name='Geordie Rd', road_geom='LINESTRING(-89.2232485796178 42.6420382611465,-89.2449842484076 42.9179140573248,-89.2316084522293 43.106847178344,-89.0710987261147 43.243949044586,-89.092834566879 43.2957802993631,-89.092834566879 43.2957802993631,-89.0309715095541 43.3175159681529)'),
            Road(road_name='Paul St', road_geom='LINESTRING(-88.2652071783439 42.5584395350319,-88.1598727834395 42.6269904904459,-88.1013536751592 42.621974566879,-88.0244428471338 42.6437102356688,-88.0110670509554 42.6771497261147)'),
            Road(road_name='Graeme Ave', road_geom='LINESTRING(-88.5477708726115 42.6988853949045,-88.6096339299363 42.9697452675159,-88.6029460318471 43.0884554585987,-88.5912422101911 43.187101955414)'),
            Road(road_name='Phil Tce', road_geom='LINESTRING(-88.9356689617834 42.9363057770701,-88.9824842484076 43.0366242484076,-88.9222931656051 43.1085191528662,-88.8487262866242 43.0449841210191)'),
            Lake(lake_name='My Lake', lake_geom='POLYGON((-88.7968950764331 43.2305732929936,-88.7935511273885 43.1553344394904,-88.716640299363 43.1570064140127,-88.7250001719745 43.2339172420382,-88.7968950764331 43.2305732929936))'),
            Lake(lake_name='Lake White', lake_geom='POLYGON((-88.1147292993631 42.7540605095542,-88.1548566878981 42.7824840764331,-88.1799363057325 42.7707802547771,-88.188296178344 42.7323248407643,-88.1832802547771 42.6955414012739,-88.1565286624204 42.6771496815287,-88.1448248407643 42.6336783439491,-88.131449044586 42.5718152866242,-88.1013535031847 42.565127388535,-88.1080414012739 42.5868630573248,-88.1164012738854 42.6119426751592,-88.1080414012739 42.6520700636943,-88.0980095541401 42.6838375796178,-88.0846337579618 42.7139331210191,-88.1013535031847 42.7423566878981,-88.1147292993631 42.7540605095542))'),
            Lake(lake_name='Lake Blue', lake_geom='POLYGON((-89.0694267515924 43.1335987261147,-89.1078821656051 43.1135350318471,-89.1329617834395 43.0884554140127,-89.1312898089172 43.0466560509554,-89.112898089172 43.0132165605096,-89.0694267515924 42.9898089171975,-89.0343152866242 42.953025477707,-89.0209394904459 42.9179140127389,-89.0042197452229 42.8961783439491,-88.9774681528663 42.8644108280255,-88.9440286624204 42.8292993630573,-88.9072452229299 42.8142515923567,-88.8687898089172 42.815923566879,-88.8687898089172 42.815923566879,-88.8102707006369 42.8343152866242,-88.7734872611465 42.8710987261147,-88.7517515923567 42.9145700636943,-88.7433917197452 42.9730891719745,-88.7517515923567 43.0299363057325,-88.7734872611465 43.0867834394905,-88.7885352038217 43.158678388535,-88.8738057324841 43.1620222929936,-88.947372611465 43.1937898089172,-89.0042197452229 43.2138535031847,-89.0410031847134 43.2389331210191,-89.0710987261147 43.243949044586,-89.0660828025478 43.2238853503185,-89.0543789808917 43.203821656051,-89.0376592356688 43.175398089172,-89.0292993630573 43.1519904458599,-89.0376592356688 43.1369426751592,-89.0393312101911 43.1386146496815,-89.0393312101911 43.1386146496815,-89.0510350318471 43.1335987261147,-89.0694267515924 43.1335987261147))'),
            Lake(lake_name='Lake Deep', lake_geom='POLYGON((-88.9122611464968 43.038296178344,-88.9222929936306 43.0399681528663,-88.9323248407643 43.0282643312102,-88.9206210191083 43.0182324840764,-88.9105891719745 43.0165605095542,-88.9005573248408 43.0232484076433,-88.9072452229299 43.0282643312102,-88.9122611464968 43.038296178344))'),
            Spot(spot_height=420.40, spot_location='POINT(-88.5945861592357 42.9480095987261)'),
            Spot(spot_height=102.34, spot_location='POINT(-88.9055734203822 43.0048567324841)'),
            Spot(spot_height=388.62, spot_location='POINT(-89.201512910828 43.1051752038217)'),
            Spot(spot_height=454.66, spot_location='POINT(-88.3304141847134 42.6269904904459)'),
        ])

        # or use an explicit WKTSpatialElement (similar to saying func.GeomFromText())
        self.r = Road(road_name='Dave Cres', road_geom=WKTSpatialElement('LINESTRING(-88.6748409363057 43.1035032292994,-88.6464173694267 42.9981688343949,-88.607961955414 42.9680732929936,-88.5160033566879 42.9363057770701,-88.4390925286624 43.0031847579618)', 4326))
        session.add(self.r)
        session.commit()

    def tearDown(self):
        session.rollback()
        metadata.drop_all()

    # Test Geometry Functions

    def test_wkt(self):
        eq_(session.scalar(self.r.road_geom.wkt), 'LINESTRING(-88.674841 43.103503, -88.646417 42.998169, -88.607962 42.968073, -88.516003 42.936306, -88.439093 43.003185)')
        centroid_geom = DBSpatialElement(session.scalar(self.r.road_geom.centroid))
        eq_(session.scalar(centroid_geom.wkt), u'POINT(-88.576937 42.991563)')
        ok_(not session.query(Spot).filter(Spot.spot_location.wkt == 'POINT(0,0)').first())
        ok_(session.query(Spot).get(1) is
            session.query(Spot).filter(Spot.spot_location == 'POINT(-88.5945861592357 42.9480095987261)').first())
        eq_(session.scalar(WKTSpatialElement('POINT(-88.5769371859941 42.9915634871979)').wkt), u'POINT(-88.576937 42.991563)')

    def test_wkb(self):
        eq_(session.scalar(functions.wkt(func.GeomFromWKB(self.r.road_geom.wkb, 4326))),
            u'LINESTRING(-88.674841 43.103503, -88.646417 42.998169, -88.607962 42.968073, -88.516003 42.936306, -88.439093 43.003185)')
        eq_(session.scalar(self.r.road_geom.wkb), self.r.road_geom.geom_wkb)
        centroid_geom = DBSpatialElement(session.scalar(self.r.road_geom.centroid))
        eq_(session.scalar(functions.wkt(func.GeomFromWKB(centroid_geom.wkb, 4326))),
            u'POINT(-88.576937 42.991563)')

    def test_persistent(self):
        eq_(session.scalar(functions.wkt(func.GeomFromWKB(self.r.road_geom.wkb, 4326))),
            u'LINESTRING(-88.674841 43.103503, -88.646417 42.998169, -88.607962 42.968073, -88.516003 42.936306, -88.439093 43.003185)')

        geom = WKTSpatialElement('POINT(30250865.9714116 -610981.481754275)', 2249)
        spot = Spot(spot_height=102.34, spot_location=geom)
        session.add(spot)
        session.commit();
        assert_almost_equal(session.scalar(spot.spot_location.x), 0)
        assert_almost_equal(session.scalar(spot.spot_location.y), 0)

        spot.spot_location = PersistentSpatialElement(None)
        ok_(isinstance(spot.spot_location, PersistentSpatialElement))

    def test_svg(self):
        eq_(session.scalar(self.r.road_geom.svg), 'M -88.674841 -43.103503 L -88.646417 -42.998169 -88.607962 -42.968073 -88.516003 -42.936306 -88.439093 -43.003185 ')

    def test_fgf(self):
        eq_(b2a_hex(session.scalar(self.r.road_geom.fgf(1))), '020000000100000005000000d7db0998302b56c0876f04983f8d454000000000000000004250f5e65e2956c068ce11ffc37f45400000000000000000c8ed42d9e82656c0efc45ed3e97b454000000000000000007366f132062156c036c921ded8774540000000000000000078a18c171a1c56c053a5af5b688045400000000000000000')

    def test_dimension(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        eq_(session.scalar(l.lake_geom.dimension), 2)
        eq_(session.scalar(r.road_geom.dimension), 1)
        eq_(session.scalar(s.spot_location.dimension), 0)

    def test_srid(self):
        eq_(session.scalar(self.r.road_geom.srid), 4326)
        ok_(session.query(Spot).filter(Spot.spot_location.srid == 4326).first() is not None)
        eq_(session.scalar(functions.srid('POINT(-88.5945861592357 42.9480095987261)')), 4326)

    def test_geometry_type(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        eq_(session.scalar(l.lake_geom.geometry_type), 'POLYGON')
        eq_(session.scalar(r.road_geom.geometry_type), 'LINESTRING')
        eq_(session.scalar(s.spot_location.geometry_type), 'POINT')

    def test_is_valid(self):
        ok_(not session.scalar(self.r.road_geom.is_valid))

    def test_is_empty(self):
        ok_(not session.scalar(self.r.road_geom.is_empty))

    def test_is_simple(self):
        ok_(session.scalar(self.r.road_geom.is_simple))

    def test_is_valid(self):
        assert session.scalar(self.r.road_geom.is_valid)

    def test_boundary(self):
        eq_(session.scalar(functions.wkt(self.r.road_geom.boundary)), u'MULTIPOINT(-88.674841 43.103503, -88.439093 43.003185)')

    def test_envelope(self):
        eq_(session.scalar(functions.wkt(self.r.road_geom.envelope)),
            u'POLYGON((-88.674841 42.936306, -88.439093 42.936306, -88.439093 43.103503, -88.674841 43.103503, -88.674841 42.936306))')
        env =  WKBSpatialElement(session.scalar(func.AsBinary(self.r.road_geom.envelope)))
        eq_(env.geom_type(session), 'Polygon')

    def test_x(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_( not session.scalar(l.lake_geom.x))
        ok_( not session.scalar(r.road_geom.x))
        eq_(session.scalar(s.spot_location.x), -88.594586159235703)

    def test_y(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.y))
        ok_(not session.scalar(r.road_geom.y))
        eq_(session.scalar(s.spot_location.y), 42.948009598726102)

    def test_start_point(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.start_point))
        assert_almost_equal(session.scalar(func.X(r.road_geom.start_point)), -88.9139332929936)
        assert_almost_equal(session.scalar(func.Y(r.road_geom.start_point)), 42.5082802993631)
        #eq_(b2a_hex(session.scalar(r.road_geom.start_point)), '0001ffffffff850811e27d3a56c0997b2f540f414540850811e27d3a56c0997b2f540f4145407c01000000850811e27d3a56c0997b2f540f414540fe')
        ok_(not session.scalar(s.spot_location.start_point))

    def test_end_point(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.end_point))
        assert_almost_equal(session.scalar(func.X(r.road_geom.end_point)), -88.3655256496815)
        assert_almost_equal(session.scalar(func.Y(r.road_geom.end_point)), 43.1402866687898)
        #eq_(b2a_hex(session.scalar(r.road_geom.end_point)), '0001ffffffffccceb1c5641756c02c42dfe9f4914540ccceb1c5641756c02c42dfe9f49145407c01000000ccceb1c5641756c02c42dfe9f4914540fe')
        ok_(not session.scalar(s.spot_location.end_point))

    def test_transform(self):
        spot = session.query(Spot).get(1)
        eq_(session.scalar(functions.wkt(spot.spot_location.transform(2249))),
            u'POINT(-3890517.610956 3627658.674651)')
        ok_(session.query(Spot).filter(sqlite_functions.mbr_contains(
                                                functions.buffer(Spot.spot_location.transform(2249), 10),
                                                WKTSpatialElement('POINT(-3890517.610956 3627658.674651)', 2249))).first() is not None)
        eq_(session.scalar(functions.wkt(functions.transform(WKTSpatialElement('POLYGON((743238 2967416,743238 2967450,743265 2967450,743265.625 2967416,743238 2967416))', 2249), 4326))),
            u'POLYGON((-71.177685 42.39029, -71.177684 42.390383, -71.177584 42.390383, -71.177583 42.390289, -71.177685 42.39029))')

    def test_length(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        assert_almost_equal(session.scalar(l.lake_geom.length), 0.30157858985653774)
        assert_almost_equal(session.scalar(r.road_geom.length), 0.8551694164147895)
        ok_(not session.scalar(s.spot_location.length))

    def test_is_closed(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.is_closed))
        ok_(not session.scalar(r.road_geom.is_closed))
        ok_(not session.scalar(s.spot_location.is_closed))

    def test_is_ring(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(session.scalar(l.lake_geom.is_ring))
        ok_(not session.scalar(r.road_geom.is_ring))
        ok_(session.scalar(s.spot_location.is_ring))

    def test_num_points(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.num_points))
        eq_(session.scalar(r.road_geom.num_points), 5)
        ok_(not session.scalar(s.spot_location.num_points))

    def test_point_n(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        ok_(not session.scalar(l.lake_geom.point_n(1)))
        assert_almost_equal(session.scalar(r.road_geom.point_n(5).x), -88.3655256496815)
        assert_almost_equal(session.scalar(r.road_geom.point_n(5).y), 43.1402866687898)
        #eq_(b2a_hex(session.scalar(r.road_geom.point_n(5))), '0001ffffffffccceb1c5641756c02c42dfe9f4914540ccceb1c5641756c02c42dfe9f49145407c01000000ccceb1c5641756c02c42dfe9f4914540fe')
        ok_(not session.scalar(s.spot_location.point_n(1)))

    def test_centroid(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        assert_almost_equal(session.scalar(func.X(l.lake_geom.centroid)), -88.7578400578)
        assert_almost_equal(session.scalar(func.Y(l.lake_geom.centroid)), 43.1937975407)
        #eq_(b2a_hex(session.scalar(l.lake_geom.centroid)), '0001ffffffff81ec9573803056c04bc4995bce98454081ec9573803056c04bc4995bce9845407c0100000081ec9573803056c04bc4995bce984540fe')
        assert_almost_equal(session.scalar(func.X(r.road_geom.centroid)), -88.6569666079)
        assert_almost_equal(session.scalar(func.Y(r.road_geom.centroid)), 42.8422057576)
        #eq_(b2a_hex(session.scalar(r.road_geom.centroid)), '0001ffffffff1cecabbd0b2a56c022b0f465cd6b45401cecabbd0b2a56c022b0f465cd6b45407c010000001cecabbd0b2a56c022b0f465cd6b4540fe')
        assert_almost_equal(session.scalar(func.X(s.spot_location.centroid)), -88.5945861592)
        assert_almost_equal(session.scalar(func.Y(s.spot_location.centroid)), 42.9480095987)
        #ok_(b2a_hex(session.scalar(s.spot_location.centroid)), '0001ffffffff95241bb30d2656c04e69e7605879454095241bb30d2656c04e69e760587945407c0100000095241bb30d2656c04e69e76058794540fe')

    def test_area(self):
        l = session.query(Lake).get(1)
        r = session.query(Road).get(1)
        s = session.query(Spot).get(1)
        assert_almost_equal(session.scalar(l.lake_geom.area), 0.0056748625704927669)
        assert_almost_equal(session.scalar(r.road_geom.area), 0.0)
        assert_almost_equal(session.scalar(s.spot_location.area), 0.0)

    def test_equals(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Peter Rd').one()
        r3 = session.query(Road).filter(Road.road_name=='Paul St').one()
        equal_roads = session.query(Road).filter(Road.road_geom.equals(r1.road_geom)).all()
        ok_(r1 in equal_roads)
        ok_(r2 in equal_roads)
        ok_(r3 not in equal_roads)

    def test_distance(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        r3 = session.query(Road).filter(Road.road_name=='Peter Rd').one()
        assert_almost_equal(session.scalar(r1.road_geom.distance(r2.road_geom)), 0.3369972386828412)
        assert_almost_equal(session.scalar(r1.road_geom.distance(r3.road_geom)), 0.0)

    def test_disjoint(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        disjoint_roads = session.query(Road).filter(Road.road_geom.disjoint(r1.road_geom)).all()
        ok_(r2 not in disjoint_roads)
        ok_(r3 in disjoint_roads)

    def test_intersects(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        intersecting_roads = session.query(Road).filter(Road.road_geom.intersects(r1.road_geom)).all()
        ok_(r2 in intersecting_roads)
        ok_(r3 not in intersecting_roads)

    def test_touches(self):
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        r = session.query(Road).filter(Road.road_name=='Geordie Rd').one()
        touching_lakes = session.query(Lake).filter(Lake.lake_geom.touches(r.road_geom)).all()
        ok_(not session.scalar(l1.lake_geom.touches(r.road_geom)))
        ok_(session.scalar(l2.lake_geom.touches(r.road_geom)))
        ok_(l1 not in touching_lakes)
        ok_(l2 in touching_lakes)

    def test_crosses(self):
        r1 = session.query(Road).filter(Road.road_name=='Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name=='Paul St').one()
        l = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        crossing_roads = session.query(Road).filter(Road.road_geom.crosses(l.lake_geom)).all()
        ok_(not session.scalar(r1.road_geom.crosses(l.lake_geom)))
        ok_(session.scalar(r2.road_geom.crosses(l.lake_geom)))
        ok_(r1 not in crossing_roads)
        ok_(r2 in crossing_roads)

    def test_within(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        spots_within = session.query(Spot).filter(Spot.spot_location.within(l.lake_geom)).all()
        ok_(session.scalar(p1.spot_location.within(l.lake_geom)))
        ok_(not session.scalar(p2.spot_location.within(l.lake_geom)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)
        envelope_geom = DBSpatialElement(session.scalar(l.lake_geom.envelope))
        spots_within = session.query(Spot).filter(l.lake_geom.within(envelope_geom)).all()
        ok_(p1 in spots_within)
        ok_(p2 in spots_within)

    def test_overlaps(self):
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l3 = session.query(Lake).filter(Lake.lake_name=='My Lake').one()
        overlapping_lakes = session.query(Lake).filter(Lake.lake_geom.overlaps(l3.lake_geom)).all()
        ok_(not session.scalar(l1.lake_geom.overlaps(l3.lake_geom)))
        ok_(session.scalar(l2.lake_geom.overlaps(l3.lake_geom)))
        ok_(l1 not in overlapping_lakes)
        ok_(l2 in overlapping_lakes)

    def test_contains(self):
        l = session.query(Lake).filter(Lake.lake_name=='Lake Blue').one()
        l1 = session.query(Lake).filter(Lake.lake_name=='Lake White').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains(p1.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        ok_(session.scalar(l.lake_geom.gcontains(WKTSpatialElement('POINT(-88.9055734203822 43.0048567324841)'))))
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.gcontains('POINT(-88.9055734203822 43.0048567324841)')).all()
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)
        spots_within = session.query(Spot).filter(l.lake_geom.gcontains(Spot.spot_location)).all()
        ok_(session.scalar(l.lake_geom.gcontains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.gcontains(p2.spot_location)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)

    # Test Geometry Relations for Minimum Bounding Rectangles (MBRs)

    def test_mbr_equal(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Peter Rd').one()
        r3 = session.query(Road).filter(Road.road_name==u'Paul St').one()
        equal_roads = session.query(Road).filter(Road.road_geom.mbr_equal(r1.road_geom)).all()
        ok_(r1 in equal_roads)
        ok_(r2 in equal_roads)
        ok_(r3 not in equal_roads)
        ok_(session.scalar(r2.road_geom.mbr_equal(r1.road_geom)))
        eq_(session.scalar(sqlite_functions.mbr_equal('POINT(-88.5945861592357 42.9480095987261)', 'POINT(-88.5945861592357 42.9480095987261)')), True)

    def test_mbr_disjoint(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        disjoint_roads = session.query(Road).filter(Road.road_geom.mbr_disjoint(r1.road_geom)).all()
        ok_(r2 not in disjoint_roads)
        ok_(r3 in disjoint_roads)

    def test_mbr_intersects(self):
        r1 = session.query(Road).filter(Road.road_name==u'Jeff Rd').one()
        r2 = session.query(Road).filter(Road.road_name==u'Graeme Ave').one()
        r3 = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        intersecting_roads = session.query(Road).filter(Road.road_geom.mbr_intersects(r1.road_geom)).all()
        ok_(r2 in intersecting_roads)
        ok_(r3 not in intersecting_roads)

    def test_mbr_touches(self):
        l1 = session.query(Lake).filter(Lake.lake_name==u'Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        r = session.query(Road).filter(Road.road_name==u'Geordie Rd').one()
        touching_lakes = session.query(Lake).filter(Lake.lake_geom.mbr_touches(r.road_geom)).all()
        ok_(not session.scalar(l1.lake_geom.mbr_touches(r.road_geom)))
        ok_(not session.scalar(l2.lake_geom.mbr_touches(r.road_geom)))
        ok_(l1 not in touching_lakes)
        ok_(l2 not in touching_lakes)

    def test_mbr_within(self):
        l = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        spots_within = session.query(Spot).filter(Spot.spot_location.mbr_within(l.lake_geom)).all()
        ok_(session.scalar(p1.spot_location.mbr_within(l.lake_geom)))
        ok_(not session.scalar(p2.spot_location.mbr_within(l.lake_geom)))
        ok_(p1 in spots_within)
        ok_(p2 not in spots_within)

    def test_mbr_overlaps(self):
        l1 = session.query(Lake).filter(Lake.lake_name==u'Lake White').one()
        l2 = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        l3 = session.query(Lake).filter(Lake.lake_name==u'My Lake').one()
        overlapping_lakes = session.query(Lake).filter(Lake.lake_geom.mbr_overlaps(l3.lake_geom)).all()
        ok_(not session.scalar(l1.lake_geom.mbr_overlaps(l3.lake_geom)))
        ok_(session.scalar(l2.lake_geom.mbr_overlaps(l3.lake_geom)))
        ok_(l1 not in overlapping_lakes)
        ok_(l2 in overlapping_lakes)

    def test_mbr_contains(self):
        l = session.query(Lake).filter(Lake.lake_name==u'Lake Blue').one()
        l1 = session.query(Lake).filter(Lake.lake_name==u'Lake White').one()
        p1 = session.query(Spot).filter(Spot.spot_height==102.34).one()
        p2 = session.query(Spot).filter(Spot.spot_height==388.62).one()
        containing_lakes = session.query(Lake).filter(Lake.lake_geom.mbr_contains(p1.spot_location)).all()
        ok_(session.scalar(l.lake_geom.mbr_contains(p1.spot_location)))
        ok_(not session.scalar(l.lake_geom.mbr_contains(p2.spot_location)))
        ok_(l in containing_lakes)
        ok_(l1 not in containing_lakes)

    def test_within_distance(self):
        ok_(session.scalar(functions._within_distance('POINT(-88.9139332929936 42.5082802993631)',
                                                      'POINT(-88.9139332929936 35.5082802993631)', 10)))
        ok_(session.scalar(functions._within_distance('Point(0 0)', 'Point(0 0)', 0)))
        ok_(session.scalar(functions._within_distance('Point(0 0)',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)))
        ok_(session.scalar(functions._within_distance('Point(5 5)',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)))
        ok_(session.scalar(functions._within_distance('Point(6 5)',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 1)))
        ok_(session.scalar(functions._within_distance('Polygon((0 0, 1 0, 1 8, 0 8, 0 0))',
                                                      'Polygon((-5 -5, 5 -5, 5 5, -5 5, -5 -5))', 0)))

    @raises(IntegrityError)
    def test_constraint_nullable(self):
        spot_null = Spot(spot_height=420.40, spot_location=None)
        session.add(spot_null)
        session.commit();
        ok_(True)
        road_null = Road(road_name='Jeff Rd', road_geom=None)
        session.add(road_null)
        session.commit();

    def test_query_column_name(self):
        # test for bug: http://groups.google.com/group/geoalchemy/browse_thread/thread/6b731dd1673784f9
        from sqlalchemy.orm.query import Query
        query = Query(Road.road_geom).filter(Road.road_geom == '..').__str__()
        ok_('AsBinary(roads.road_geom)' in query, 'table name is part of the column expression (select clause)')
        ok_('WHERE Equals(roads.road_geom' in query, 'table name is part of the column expression (where clause)')

        query_wkb = Select([Road.road_geom]).where(Road.road_geom == 'POINT(0 0)').__str__()
        ok_('SELECT AsBinary(roads.road_geom)' in query_wkb, 'AsBinary is added')
        ok_('WHERE Equals(roads.road_geom' in query_wkb, 'AsBinary is not added in where clause')

        # test for RAW attribute
        query_wkb = Select([Road.road_geom.RAW]).__str__()
        ok_('SELECT roads.road_geom' in query_wkb, 'AsBinary is not added')

        ok_(session.query(Road.road_geom.RAW).first())

        query_srid = Query(func.SRID(Road.road_geom.RAW))
        ok_('SRID(roads.road_geom)' in query_srid.__str__(), 'AsBinary is not added')
        ok_(session.scalar(query_srid))

        eq_(session.scalar(Select([func.SRID(Spot.spot_location)]).where(Spot.spot_id == 1)),
                None,
                'AsBinary is added and the SRID is not returned')
        eq_(str(session.scalar(Select([func.SRID(Spot.spot_location.RAW)]).where(Spot.spot_id == 1))),
                '4326',
                'AsBinary is not added and the SRID is returned')

        spot_alias = aliased(Spot)
        query_wkt = Select([func.wkt(spot_alias.spot_location.RAW)]).__str__()
        ok_('SELECT wkt(spots_1.spot_location' in query_wkt, 'Table alias is used in select clause')
        ok_('FROM spots AS spots_1' in query_wkt, 'Table alias is used in from clause')


if __name__ == '__main__':
    import sys
    import nose

    sys.argv.append(__name__)
    result = nose.run()
    sys.exit(int(not result))

########NEW FILE########
__FILENAME__ = test_type
from unittest import TestCase
from nose.tools import ok_, eq_

class TestType(TestCase):

    def test_cast_geometry(self):
        from sqlalchemy import cast
        from geoalchemy.geometry import Geometry
        c = cast('', Geometry)
        eq_(str(c), 'CAST(:param_1 AS GEOMETRY)')

    def test_cast_point(self):
        from sqlalchemy import cast
        from geoalchemy.geometry import Point
        c = cast('', Point)
        eq_(str(c), 'CAST(:param_1 AS POINT)')

    def test_cast_curve(self):
        from sqlalchemy import cast
        from geoalchemy.geometry import Curve
        c = cast('', Curve)
        eq_(str(c), 'CAST(:param_1 AS CURVE)')

    def test_cast_linestring(self):
        from sqlalchemy import cast
        from geoalchemy.geometry import LineString
        c = cast('', LineString)
        eq_(str(c), 'CAST(:param_1 AS LINESTRING)')

    def test_cast_polygon(self):
        from sqlalchemy import cast
        from geoalchemy.geometry import Polygon
        c = cast('', Polygon)
        eq_(str(c), 'CAST(:param_1 AS POLYGON)')

    def test_cast_multipoint(self):
        from sqlalchemy import cast
        from geoalchemy.geometry import MultiPoint
        c = cast('', MultiPoint)
        eq_(str(c), 'CAST(:param_1 AS MULTIPOINT)')

    def test_cast_multilinestring(self):
        from sqlalchemy import cast
        from geoalchemy.geometry import MultiLineString
        c = cast('', MultiLineString)
        eq_(str(c), 'CAST(:param_1 AS MULTILINESTRING)')

    def test_cast_multipolygon(self):
        from sqlalchemy import cast
        from geoalchemy.geometry import MultiPolygon
        c = cast('', MultiPolygon)
        eq_(str(c), 'CAST(:param_1 AS MULTIPOLYGON)')

    def test_cast_geometrycollection(self):
        from sqlalchemy import cast
        from geoalchemy.geometry import GeometryCollection
        c = cast('', GeometryCollection)
        eq_(str(c), 'CAST(:param_1 AS GEOMETRYCOLLECTION)')


if __name__ == '__main__':
    import sys
    import nose

    sys.argv.append(__name__)
    result = nose.run()
    sys.exit(int(not result))

########NEW FILE########
__FILENAME__ = utils
# These functions are shamelessly stolen from FeatureServer
import re

def from_wkt (geom):
    """wkt helper: converts from WKT to a GeoJSON-like geometry."""
    wkt_linestring_match = re.compile(r'\(([^()]+)\)')
    re_space             = re.compile(r"\s+")

    coords = []
    for line in wkt_linestring_match.findall(geom):
        rings = [[]]
        for pair in line.split(","):

            if not pair.strip():
                rings.append([])
                continue
            rings[-1].append(map(float, re.split(re_space, pair.strip())))

        coords.append(rings[0])

    if geom.startswith("MULTIPOINT"):
        geomtype = "MultiPoint"
        coords = coords[0]
    elif geom.startswith("POINT"):
        geomtype = "Point"
        coords = coords[0][0]

    elif geom.startswith("MULTILINESTRING"):
        geomtype = "MultiLineString"
    elif geom.startswith("LINESTRING"):
        geomtype = "LineString"
        coords = coords[0]

    elif geom.startswith("MULTIPOLYGON"):
        geomtype = "MultiPolygon"
    elif geom.startswith("POLYGON"):
        geomtype = "Polygon"
    else:
        geomtype = geom[:geom.index("(")]
        raise Exception("Unsupported geometry type %s" % geomtype)

    return {"type": geomtype, "coordinates": coords}



def to_wkt (geom):
    """Converts a GeoJSON-like geometry to WKT.""" 

    def coords_to_wkt (coords):
        format_str = " ".join(("%f",) * len(coords[0]))
        return ",".join([format_str % tuple(c) for c in coords])

    coords = geom["coordinates"]
    if geom["type"] == "Point":
        return "POINT(%s)" % coords_to_wkt((coords,))
    elif geom["type"] == "LineString":
        return "LINESTRING (%s)" % coords_to_wkt(coords)
    elif geom["type"] == "Polygon":
        rings = ["(" + coords_to_wkt(ring) + ")" for ring in coords]
        rings = ",".join(rings)
        return "POLYGON(%s)" % rings

    elif geom["type"] == "MultiPoint":
        pts = ",".join(coords_to_wkt((ring,)) for ring in coords)
        return "MULTIPOINT(%s)" % str(pts)

    elif geom["type"] == "MultiLineString":
        pts = ",".join( "(" +  coords_to_wkt(ring) + ")" for ring in coords  )
        return "MultiLineString(%s)" % str(pts)

    elif geom["type"] == "MultiPolygon":
        poly_str = []
        for coord_list in coords:
            poly_str.append( "((" + ",".join( coords_to_wkt((ring,))  for ring in coord_list) + "))" )
        return "MultiPolygon(%s)" % ", ".join(poly_str)


    else:
        raise Exception("Couldn't create WKT from geometry of type %s (%s). Only Point, Line, Polygon are supported." % (geom['type'], geom))


########NEW FILE########
