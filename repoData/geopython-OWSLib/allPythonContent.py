__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# OWSLib documentation build configuration file, created by
# sphinx-quickstart on Fri Oct 15 08:43:28 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'OWSLib'
copyright = u'2010, Tom Kralidis'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = open('../VERSION.txt').read().strip()
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%Y-%m-%d'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
show_authors = True

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = 'OWSLib %s documentation' % release

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%Y-%m-%dT%H:%M:%SZ'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {'indexsidebar.html'}

#html_sidebars = {'**':['indexsidebar.html']}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'OWSLibdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'OWSLib.tex', u'OWSLib Documentation',
   u'Tom Kralidis', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = csw-client
#!/usr/bin/python
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2009 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

import sys
import getopt

from owslib.csw import CatalogueServiceWeb

def usage():
    print """
    %s [options]

Required Parameters
-------------------

    --url=[URL] the URL of the CSW
    --request=[REQUEST] the request (GetCapabilities, DescribeRecord, GetDomain, GetRecords, GetRecordById)

Optional Parameters
-------------------

    --lang=[LANG] the language of the CSW
    --version=[VERSION] the CSW server version
    --print-request print the request
    --validate perform XML validation against the request

Request Specific Parameters
---------------------------

DescribeRecord
    --typename=[TypeName] the typename to describe 

GetDomain
    --dname=[NAME] the domain to query
    --dtype=[property|parameter] the type of domain query

GetRecords
    --sortby=[dc:title|dct:abstract|ows:BoundingBox] sort by property
    --keyword=[KEYWORD] the keyword(s) to query
    --bbox=[BBOX] the bounding box to spatially query in the form of "minx miny maxx maxy"
    --esn=[brief|full|summary] verbosity of results
    --qtype=[dataset|service] query for data or services
    --schema=[iso] the outputSchema (default is csw)

GetRecordById
    --id=[ID] the ID of the record

""" % sys.argv[0]

# check args
if len(sys.argv) == 1:
    usage()
    sys.exit(1)

try:
    opts, args = getopt.getopt(sys.argv[1:], '', ['typename=', 'request=', 'lang=', 'version', 'keyword=', 'bbox=', 'schema=', 'qtype=', 'esn=', 'url=', 'print-request', 'sortby=', 'id=', 'dtype=', 'dname=', 'validate'])
except getopt.GetoptError, err:
    print str(err)
    usage()
    sys.exit(2)

request = None
keyword = None
bbox = None
schema = None
qtype = None
esn = 'full'
url = None
print_request = False
validate = False
sortby = None
id = None
version = '2.0.2'
lang = 'en-US'
dname = None
dtype = None
typename = None

# set args
for o, a in opts:
    if o in '--request':
        request = a
    elif o in '--keyword':
        keyword = a
    elif o in '--bbox':
        bbox = a.split()
    elif o in '--typename':
        typename = a
    elif o in '--schema':
        schema = a
    elif o in '--qtype':
        qtype = a
    elif o in '--esn':
        esn = a
    elif o in '--url':
        url = a
    elif o in '--sortby':
        sortby = a
    elif o in '--id':
        id = a
    elif o in '--dname':
        dname = a
    elif o in '--dtype':
        dtype= a
    elif o in '--version':
        version = a
    elif o in '--lang':
        lang = a
    elif o in '--print-request':
        print_request = True
    elif o in '--validate':
        validate = True
    else:
        assert False, 'unhandled option'

if request is None or url is None:
    usage()
    sys.exit(3)

if schema == 'iso':
  outputschema = 'http://www.isotc211.org/2005/gmd'

# init
c = CatalogueServiceWeb(url, lang, version)

if request == 'GetCapabilities':
    pass
elif request == 'DescribeRecord':
    c.describerecord(typename)
elif request == 'GetRecordById':
    c.getrecordbyid([id])
elif request == 'GetDomain':
    c.getdomain(dname, dtype)
elif request == 'GetRecords':
    c.getrecords(qtype, [keyword], bbox, esn, sortby, schema)

if print_request is True: # print the request
    print c.request

if validate is True: # do XML validation
    print 'Validating request XML'
    if util.xmlvalid(c.request, csw.schema_location.split()[1]) is True:
        print 'request is valid XML'
    else:
        print 'request is NOT valid XML'

# print response
print c.response


########NEW FILE########
__FILENAME__ = csw-harvest
#!/usr/bin/python
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2010 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

# simple process to harvest CSW catalogues via Harvest operations

import sys
from owslib.csw import CatalogueServiceWeb

stop = 0
flag = 0
maxrecords = 10

if len(sys.argv) < 3:
    print 'Usage: %s <source_catalogue_url> <destination_catalogue_url> [maxrecords]' \
        % sys.argv[0]
    sys.exit(1)

src = CatalogueServiceWeb(sys.argv[1])
dest = CatalogueServiceWeb(sys.argv[2])

if len(sys.argv) == 4:
    maxrecords = sys.argv[3]

while stop == 0:
    if flag == 0:  # first run, start from 0
        startposition = 0
    else:  # subsequent run, startposition is now paged
        startposition = src.results['nextrecord']

    src.getrecords(esn='brief', startposition=startposition, maxrecords=maxrecords)

    print src.results

    if src.results['nextrecord'] == 0 \
        or src.results['returned'] == 0 \
        or src.results['nextrecord'] > src.results['matches']:  # end the loop, exhausted all records
        stop = 1
        break

    # harvest each record to destination CSW
    for i in list(src.records):
        source = '%s?service=CSW&version=2.0.2&request=GetRecordById&id=%s' % \
            (sys.argv[1], i)
        dest.harvest(source=source, \
            resourcetype='http://www.isotc211.org/2005/gmd')
        #print dest.request
        #print dest.response

    flag = 1

########NEW FILE########
__FILENAME__ = iso-getcodelist
#!/usr/bin/python
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2010 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

# get a list of entries for a given code list dictionary

import sys
import urllib2

from owslib.etree import etree
from owslib.iso import CodelistCatalogue

if len(sys.argv) < 3:
    print 'Usage: %s <path/to/gmxCodelists.xml> <CodeListDictionary>' % sys.argv[0]
    sys.exit(1)

e=etree.parse(sys.argv[1])
c=CodelistCatalogue(e)

clds = c.getcodelistdictionaries()

def valid_clds():
    return  '''
Valid code list dictionaries are:

%s
''' % '\n'.join(clds)


if len(sys.argv) < 2:
    print '''
Usage: %s <codelistdictionary>
%s
''' % (sys.argv[0], valid_clds())
    sys.exit(1)

cld = c.getcodedefinitionidentifiers(sys.argv[2])

if cld is None:
    print '''
Invalid code list dictionary: %s
%s
''' % (sys.argv[2],valid_clds())
    sys.exit(2)

print '''

CodeListDictionary: %s

codeEntry's:

 %s

''' % (sys.argv[2],'\n '.join(cld))

########NEW FILE########
__FILENAME__ = wcs-thredds-prism
# Very simple script demonstrating how to interact with a THREDDS based WCS.
# ---
#
# The GetCapabilities and DescribeCoverage requests for this dataset are: 
# http://cida.usgs.gov/thredds/wcs/prism?service=WCS&version=1.0.0&request=GetCapabilities
# http://cida.usgs.gov/thredds/wcs/prism?service=WCS&version=1.0.0&request=DescribeCoverage
#
# The equivalent GetCoverage request that is equivalent ot hte example is:
# http://cida.usgs.gov/thredds/wcs/prism?request=GetCoverage&version=1.0.0&service=WCS&format=GeoTIFF&coverage=tmx&time=1895-01-01T00:00:00Z&bbox=-90,40,-89,41
# ---
# 
# Example to find the equivalent information using OWSLib:
# 
from owslib.wcs import WebCoverageService
wcs=WebCoverageService('http://cida.usgs.gov/thredds/wcs/prism',version='1.0.0')
# Take a look at the contents (coverages) of the wcs.
print wcs.contents
tmax=wcs['tmx']
# Take a look at the attributes of the coverage
dir(tmax)
print tmax.boundingBoxWGS84
print tmax.timepositions
print tmax.supportedFormats
# mock up a simple GetCoverage request.
output=wcs.getCoverage(identifier='tmx',time=['1895-01-01T00:00:00Z'],bbox=(-90,40,-89,41),format='GeoTIFF')
# Write the file out to disk.
f=open('foo.tif','wb')
f.write(output.read())
f.close()
########NEW FILE########
__FILENAME__ = wps-ceda-script
# Example script that performs a set of (small) live requests versus the live CEDA WPS service

from owslib.wps import WebProcessingService, WPSExecution, WFSFeatureCollection, WFSQuery, GMLMultiPolygonFeatureCollection, monitorExecution, ComplexData, printInputOutput
from owslib.util import dump

verbose = True
wps = WebProcessingService('http://ceda-wps2.badc.rl.ac.uk/wps', verbose=verbose)

# 1) GetCapabilities
# GET request: http://ceda-wps2.badc.rl.ac.uk/wps?Service=WPS&Request=GetCapabilities&Format=text/xml
wps.getcapabilities()

print 'WPS Identification type: %s' % wps.identification.type
print 'WPS Identification title: %s' % wps.identification.title
print 'WPS Identification abstract: %s' % wps.identification.abstract
for operation in wps.operations:
    print 'WPS Operation: %s' % operation.name
for process in wps.processes:
    print 'WPS Process: identifier=%s title=%s' % (process.identifier, process.title)
    
# 2) DescribeProcess
# GET request: http://ceda-wps2.badc.rl.ac.uk/wps?identifier=DoubleIt&version=1.0.0&request=DescribeProcess&service=WPS
process = wps.describeprocess('DoubleIt')
print 'WPS Process: identifier=%s' % process.identifier
print 'WPS Process: title=%s' % process.title
print 'WPS Process: abstract=%s' % process.abstract
for input in process.dataInputs:
    print 'Process input:'
    printInputOutput(input, indent='\t')
for output in process.processOutputs:
    print 'Process output:'
    printInputOutput(output, indent='\t')

# 3) Execute
# POST request:
# Note: not working, requires openid login ?
#processid = "DoubleIt"
#inputs = [ ("NumberToDouble","1") ]
#output = "OutputXML"
#execution = wps.execute(processid, inputs, output)

#monitorExecution(execution)

########NEW FILE########
__FILENAME__ = wps-client
#!/usr/bin/python
# -*- coding: ISO-8859-15 -*-
# =============================================================================
#
# Authors : Luca Cinquini
#
# =============================================================================

import sys
import getopt
import os
from owslib.wps import WebProcessingService, monitorExecution

def usage():
    print  """
    
Usage: %s [parameters]

Common Parameters for all request types
-------------------

    -u, --url=[URL] the base URL of the WPS - required
    -r, --request=[REQUEST] the request type (GetCapabilities, DescribeProcess, Execute) - required 
    -v, --verbose set flag for verbose output - optional (defaults to False)    

Request Specific Parameters
---------------------------

    DescribeProcess
        -i, --identifier=[ID] process identifier - required
    Execute
        -x, --xml XML file containing pre-made request to be submitted - required

Examples
--------
python wps-client.py -u http://cida.usgs.gov/climate/gdp/process/WebProcessingService -r GetCapabilities
python wps-client.py --verbose --url=http://cida.usgs.gov/climate/gdp/process/WebProcessingService --request=GetCapabilities
python wps-client.py -u http://ceda-wps2.badc.rl.ac.uk/wps -r GetCapabilities
python wps-client.py -u http://rsg.pml.ac.uk/wps/generic.cgi -r GetCapabilities
python wps-client.py -u http://rsg.pml.ac.uk/wps/vector.cgi -r GetCapabilities

python wps-client.py -u http://cida.usgs.gov/climate/gdp/process/WebProcessingService -r DescribeProcess -i gov.usgs.cida.gdp.wps.algorithm.FeatureWeightedGridStatisticsAlgorithm
python wps-client.py --verbose --url http://cida.usgs.gov/climate/gdp/process/WebProcessingService --request DescribeProcess --identifier gov.usgs.cida.gdp.wps.algorithm.FeatureWeightedGridStatisticsAlgorithm
python wps-client.py -u http://ceda-wps2.badc.rl.ac.uk/wps -r DescribeProcess -i DoubleIt
python wps-client.py -u http://rsg.pml.ac.uk/wps/generic.cgi -r DescribeProcess -i reprojectCoords
python wps-client.py -u http://rsg.pml.ac.uk/wps/vector.cgi -r DescribeProcess -i v.mkgrid

python wps-client.py -u http://cida.usgs.gov/climate/gdp/process/WebProcessingService -r Execute -x ../tests/wps_USGSExecuteRequest1.xml
python wps-client.py --verbose --url http://cida.usgs.gov/climate/gdp/process/WebProcessingService --request Execute --xml ../tests/wps_USGSExecuteRequest1.xml
python wps-client.py -u http://rsg.pml.ac.uk/wps/generic.cgi -r Execute -x ../tests/wps_PMLExecuteRequest4.xml 
python wps-client.py -u http://rsg.pml.ac.uk/wps/generic.cgi -r Execute -x ../tests/wps_PMLExecuteRequest5.xml 
python wps-client.py -u http://rsg.pml.ac.uk/wps/vector.cgi -r Execute -x ../tests/wps_PMLExecuteRequest6.xml 

""" % sys.argv[0]
    
# check args
if len(sys.argv) == 1:
    usage()
    sys.exit(1)
    
print 'ARGV      :', sys.argv[1:]
    
try:
    options, remainder = getopt.getopt(sys.argv[1:], 'u:r:x:i:v', ['url=', 'request=', 'xml=', 'identifier=', 'verbose'])
except getopt.GetoptError, err:
    print str(err)
    usage()
    sys.exit(2)
    
print 'OPTIONS   :', options

url = None
request = None
identifier = None
xml = None
verbose = False

for opt, arg in options:
    if opt in ('-u', '--url'):
        url = arg
    elif opt in ('-r', '--request'):
        request = arg
    elif opt in ('-x', '--xml'):
        xml = open(arg, 'r').read()
    elif opt in ('-i', '--identifier'):
        identifier = arg
    elif opt in ('-v', '--verbose'):
        verbose = True
    else:
        assert False, 'Unhandled option'
   
# required arguments for all requests     
if request is None or url is None:
    usage()
    sys.exit(3)
        
# instantiate client
wps = WebProcessingService(url, verbose=verbose, skip_caps=True)

if request == 'GetCapabilities':
    wps.getcapabilities()
    print 'WPS Identification type: %s' % wps.identification.type
    print 'WPS Identification title: %s' % wps.identification.title
    print 'WPS Identification abstract: %s' % wps.identification.abstract
    for operation in wps.operations:
        print 'WPS Operation: %s' % operation.name
    for process in wps.processes:
        print 'WPS Process: identifier=%s title=%s' % (process.identifier, process.title)
    
elif request == 'DescribeProcess':
    if identifier is None:
        print '\nERROR: missing mandatory "-i (or --identifier)" argument'
        usage()
        sys.exit(4)
    process = wps.describeprocess(identifier)
    print 'WPS Process: identifier=%s' % process.identifier
    print 'WPS Process: title=%s' % process.title
    print 'WPS Process: abstract=%s' % process.abstract
    for input in process.dataInputs:
        print 'Process input: identifier=%s, data type=%s, minOccurs=%d, maxOccurs=%d' % (input.identifier, input.dataType, input.minOccurs, input.maxOccurs)
    for output in process.processOutputs:
        print 'Process output: identifier=%s, data type=%s' % (output.identifier, output.dataType)
        
elif request == 'Execute':
    if xml is None:
        print '\nERROR: missing mandatory "-x (or --xml)" argument'
        usage()
        sys.exit(5)
    execution = wps.execute(None, [], request=xml)
    monitorExecution(execution)
    
else:
    print '\nERROR: Unknown request type'
    usage()
    sys.exit(6)

########NEW FILE########
__FILENAME__ = wps-climdaps
from owslib.wps import WebProcessingService, monitorExecution

verbose = True

# get multiple outputs
wps = WebProcessingService('http://rsg.pml.ac.uk/wps/generic.cgi', verbose=verbose)

processid = 'dummyprocess'
inputs = [("input1", '1'), ("input2", '2')]
# list of tuple (output identifier, asReference attribute)
outputs = [("output1",True), ("output2",False)]

execution = wps.execute(processid, inputs, output=outputs)
print execution.status
# show status
print 'percent complete', execution.percentCompleted
print 'status message', execution.statusMessage

monitorExecution(execution)

for output in execution.processOutputs:
        print 'identifier=%s, dataType=%s, data=%s, reference=%s' % (output.identifier, output.dataType, output.data, output.reference) 

# get errors
inputs = [("input1", '1'), ("input2", '3')]
execution = wps.execute(processid, inputs, output=outputs)
monitorExecution(execution)
print execution.status
for error in execution.errors:
        print error.code, error.locator, error.text





########NEW FILE########
__FILENAME__ = wps-pml-script-1
# Example script that performs a set of (small) live requests versus the live PML WPS service

from owslib.wps import WebProcessingService, monitorExecution

# instantiate WPS client
verbose = False
wps = WebProcessingService('http://rsg.pml.ac.uk/wps/generic.cgi', verbose=verbose, skip_caps=True)

# 1) GetCapabilities
wps.getcapabilities()
print 'WPS Identification type: %s' % wps.identification.type
print 'WPS Identification title: %s' % wps.identification.title
print 'WPS Identification abstract: %s' % wps.identification.abstract
for operation in wps.operations:
    print 'WPS Operation: %s' % operation.name
for process in wps.processes:
    print 'WPS Process: identifier=%s title=%s' % (process.identifier, process.title)
    
# 2) DescribeProcess
process = wps.describeprocess('reprojectImage')
print 'WPS Process: identifier=%s' % process.identifier
print 'WPS Process: title=%s' % process.title
print 'WPS Process: abstract=%s' % process.abstract
for input in process.dataInputs:
    print 'Process input: identifier=%s, data type=%s, minOccurs=%d, maxOccurs=%d' % (input.identifier, input.dataType, input.minOccurs, input.maxOccurs)
for output in process.processOutputs:
    print 'Process output: identifier=%s, data type=%s' % (output.identifier, output.dataType)
    
# 3a) Execute
# GET request: http://rsg.pml.ac.uk/wps/generic.cgi?request=Execute&service=wps&version=1.0.0&identifier=reprojectImage&datainputs=[inputImage=http://rsg.pml.ac.uk/wps/testdata/elev_srtm_30m.img;outputSRS=EPSG:4326]&responsedocument=outputImage=@asreference=true
processid = "reprojectImage"
inputs = [ ("inputImage","http://rsg.pml.ac.uk/wps/testdata/elev_srtm_30m.img"),
           ("outputSRS", "EPSG:4326") ]
output = "outputImage"
execution = wps.execute(processid, inputs, output)

monitorExecution(execution)
        
# 3b) Execute
# GET request: http://rsg.pml.ac.uk/wps/generic.cgi?request=Execute&service=WPS&version=1.0.0&identifier=reprojectCoords&datainputs=[coords=http://rsg.pml.ac.uk/wps/testdata/coords.txt;outputSRS=EPSG:32630;inputSRS=EPSG:4326]
processid = "reprojectCoords"
inputs = [ ("coords","http://rsg.pml.ac.uk/wps/testdata/coords.txt"),
           ("outputSRS", "EPSG:32630"),
           ("inputSRS","EPSG:4326") ]
execution = wps.execute(processid, inputs)

monitorExecution(execution)
########NEW FILE########
__FILENAME__ = wps-pml-script-2
# Example script that performs a set of (small) live requests versus the live PML WPS service

from owslib.wps import WebProcessingService, monitorExecution

# instantiate WPS client
verbose = False
wps = WebProcessingService('http://rsg.pml.ac.uk/wps/vector.cgi', verbose=verbose, skip_caps=True)

# 1) GetCapabilities
wps.getcapabilities()
print 'WPS Identification type: %s' % wps.identification.type
print 'WPS Identification title: %s' % wps.identification.title
print 'WPS Identification abstract: %s' % wps.identification.abstract
for operation in wps.operations:
    print 'WPS Operation: %s' % operation.name
for process in wps.processes:
    print 'WPS Process: identifier=%s title=%s' % (process.identifier, process.title)
    
# 2) DescribeProcess
process = wps.describeprocess('v.net.path')
# alternatively, read process description from XML file (no live request to WPS server)
#xml = open('../tests/USGSDescribeProcess.xml', 'r').read()
#process = wps.describeprocess('gov.usgs.cida.gdp.wps.algorithm.FeatureWeightedGridStatisticsAlgorithm', xml=xml)
print 'WPS Process: identifier=%s' % process.identifier
print 'WPS Process: title=%s' % process.title
print 'WPS Process: abstract=%s' % process.abstract
for input in process.dataInputs:
    print 'Process input: identifier=%s, data type=%s, minOccurs=%d, maxOccurs=%d' % (input.identifier, input.dataType, input.minOccurs, input.maxOccurs)
for output in process.processOutputs:
    print 'Process output: identifier=%s, data type=%s' % (output.identifier, output.dataType)
    
# 3) Execute
# GET request: http://rsg.pml.ac.uk/wps/vector.cgi?request=execute&service=WPS&version=1.0.0&identifier=v.net.path&datainputs=[input=http://rsg.pml.ac.uk/wps/example/graph.gml;file=1%20-960123.1421801624%204665723.56559387%20-101288.65106088226%205108200.011823481]
processid = "v.net.path"
inputs = [ ("input","http://rsg.pml.ac.uk/wps/example/graph.gml"),
           ("file","1 -960123.1421801624 4665723.56559387 -101288.65106088226 5108200.011823481")]
execution = wps.execute(processid, inputs)
monitorExecution(execution)
########NEW FILE########
__FILENAME__ = wps-usgs-script
# Example script that performs a set of (small) live requests versus the live USGS WPS service

from owslib.wps import WebProcessingService, WPSExecution, WFSFeatureCollection, WFSQuery, GMLMultiPolygonFeatureCollection, monitorExecution, printInputOutput
from owslib.util import dump

# instantiate WPS client
# setting verbose=True will print out all HTTP request and responses to standard output
verbose = False
wps = WebProcessingService('http://cida.usgs.gov/climate/gdp/process/WebProcessingService', verbose=verbose, skip_caps=True)

# 1) GetCapabilities
# Submits an HTTP GET "GetCapabilities" request to the WPS service and parses the HTTP response.

wps.getcapabilities()
# alternatively, read capabilities from XML file (no live request to WPS server)
#xml = open('../tests/USGSCapabilities.xml', 'r').read() 
#wps.getcapabilities(xml=xml)
print 'WPS Identification type: %s' % wps.identification.type
print 'WPS Identification title: %s' % wps.identification.title
print 'WPS Identification abstract: %s' % wps.identification.abstract
for operation in wps.operations:
    print 'WPS Operation: %s' % operation.name
for process in wps.processes:
    print 'WPS Process: identifier=%s title=%s' % (process.identifier, process.title)

# 2) DescribeProcess
# Submits an HTTP GET "DescribeProcess" request to the WPS service and parses the HTTP response

process = wps.describeprocess('gov.usgs.cida.gdp.wps.algorithm.FeatureWeightedGridStatisticsAlgorithm')
# alternatively, read process description from XML file (no live request to WPS server)
#xml = open('../tests/USGSDescribeProcess.xml', 'r').read()
#process = wps.describeprocess('gov.usgs.cida.gdp.wps.algorithm.FeatureWeightedGridStatisticsAlgorithm', xml=xml)
print 'WPS Process: identifier=%s' % process.identifier
print 'WPS Process: title=%s' % process.title
print 'WPS Process: abstract=%s' % process.abstract
for input in process.dataInputs:
    print 'Process input:'
    printInputOutput(input, indent='\t')
for output in process.processOutputs:
    print 'Process output:'
    printInputOutput(output, indent='\t')

# 3a) Execute
# Submits an HTTP POST "Execute" process request to the WPS service, keeps checking the status of the request,
# and retrieves the output once the request terminates successfully (displaying any errors if found).
# This request uses a FEATURE_COLLECTION input obtained from a live WFS service.
#wfsUrl = "http://cida.usgs.gov/climate/gdp/proxy/http://igsarm-cida-gdp2.er.usgs.gov:8082/geoserver/wfs"
#query = WFSQuery("sample:CONUS_States", propertyNames=['the_geom',"STATE"], filters=["CONUS_States.508","CONUS_States.469"])
#featureCollection = WFSFeatureCollection(wfsUrl, query)
polygon = [(-102.8184, 39.5273), (-102.8184, 37.418), (-101.2363, 37.418), (-101.2363, 39.5273), (-102.8184, 39.5273)]
featureCollection = GMLMultiPolygonFeatureCollection( [polygon] )
processid = 'gov.usgs.cida.gdp.wps.algorithm.FeatureWeightedGridStatisticsAlgorithm'
inputs = [ ("FEATURE_ATTRIBUTE_NAME","the_geom"),
           ("DATASET_URI", "dods://cida.usgs.gov/qa/thredds/dodsC/derivatives/derivative-days_above_threshold.pr.ncml"),
           ("DATASET_ID", "ensemble_b1_pr-days_above_threshold"),
           ("TIME_START","2010-01-01T00:00:00.000Z"),
           ("TIME_END","2011-01-01T00:00:00.000Z"),
           ("REQUIRE_FULL_COVERAGE","false"),
           ("DELIMITER","COMMA"),
           ("STATISTICS","MEAN"),
           ("GROUP_BY","STATISTIC"),
           ("SUMMARIZE_TIMESTEP","false"),
           ("SUMMARIZE_FEATURE_ATTRIBUTE","false"),
           ("FEATURE_COLLECTION", featureCollection)
          ]
output = "OUTPUT"
execution = wps.execute(processid, inputs, output = "OUTPUT")
# alternatively, submit a pre-made request specified in an XML file
#request = open('../tests/wps_USGSExecuteRequest1.xml','r').read()
#execution = wps.execute(None, [], request=request)

# The monitorExecution() function can be conveniently used to wait for the process termination
# It will eventually write the process output to the specified file, or to the file specified by the server.
monitorExecution(execution)    
'''    
# 3b) Execute
# Submits an HTTP POST "Execute" process request to the WPS service, keeps checking the status of the request,
# and retrieves the output once the request terminates successfully (displaying any errors if found).
# This request uses a FEATURE_COLLECTION input defined as a GML (lat, lon) polygon.

polygon = [(-102.8184, 39.5273), (-102.8184, 37.418), (-101.2363, 37.418), (-101.2363, 39.5273), (-102.8184, 39.5273)]
featureCollection = GMLMultiPolygonFeatureCollection( [polygon] )
processid = 'gov.usgs.cida.gdp.wps.algorithm.FeatureWeightedGridStatisticsAlgorithm'
inputs =  [ ("FEATURE_ATTRIBUTE_NAME","the_geom"),
            ("DATASET_URI", "dods://igsarm-cida-thredds1.er.usgs.gov:8080/thredds/dodsC/dcp/conus_grid.w_meta.ncml"),
            ("DATASET_ID", "ccsm3_a1b_tmax"),
            ("TIME_START","1960-01-01T00:00:00.000Z"),
            ("TIME_END","1960-12-31T00:00:00.000Z"),
            ("REQUIRE_FULL_COVERAGE","true"),
            ("DELIMITER","COMMA"),
            ("STATISTICS","MEAN"),
            ("STATISTICS","MINIMUM"),
            ("STATISTICS","MAXIMUM"),
            ("STATISTICS","WEIGHT_SUM"),
            ("STATISTICS","VARIANCE"),
            ("STATISTICS","STD_DEV"),
            ("STATISTICS","COUNT"),
            ("GROUP_BY","STATISTIC"),
            ("SUMMARIZE_TIMESTEP","false"),
            ("SUMMARIZE_FEATURE_ATTRIBUTE","false"),
            ("FEATURE_COLLECTION", featureCollection)
           ]
output = "OUTPUT"
execution = wps.execute(processid, inputs, output = "OUTPUT")
# alternatively, submit a pre-made request specified in an XML file
#request = open('../tests/wps_USGSExecuteRequest3.xml','r').read()
#execution = wps.execute(None, [], request=request)
monitorExecution(execution)    
'''
########NEW FILE########
__FILENAME__ = wcs100
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2004, 2006 Sean C. Gillies
# Copyright (c) 2007 STFC <http://www.stfc.ac.uk>
#
# Authors : 
#          Dominic Lowe <d.lowe@rl.ac.uk>
#
# Contact email: d.lowe@rl.ac.uk
# =============================================================================

from owslib.coverage.wcsBase import WCSBase, WCSCapabilitiesReader, ServiceException
from urllib import urlencode
from owslib.util import openURL, testXMLValue
from owslib.etree import etree
from owslib.crs import Crs
import os, errno

import logging
from owslib.util import log

#  function to save writing out WCS namespace in full each time
def ns(tag):
    return '{http://www.opengis.net/wcs}'+tag

class WebCoverageService_1_0_0(WCSBase):
    """Abstraction for OGC Web Coverage Service (WCS), version 1.0.0
    Implements IWebCoverageService.
    """
    def __getitem__(self,name):
        ''' check contents dictionary to allow dict like access to service layers'''
        if name in self.__getattribute__('contents').keys():
            return self.__getattribute__('contents')[name]
        else:
            raise KeyError, "No content named %s" % name
    
    def __init__(self,url,xml, cookies):
        self.version='1.0.0'
        self.url = url   
        self.cookies=cookies
        # initialize from saved capability document or access the server
        reader = WCSCapabilitiesReader(self.version, self.cookies)
        if xml:
            self._capabilities = reader.readString(xml)
        else:
            self._capabilities = reader.read(self.url)

        # check for exceptions
        se = self._capabilities.find('ServiceException')

        if se is not None:
            err_message = str(se.text).strip()  
            raise ServiceException(err_message, xml) 

        #serviceIdentification metadata
        subelem=self._capabilities.find(ns('Service'))
        self.identification=ServiceIdentification(subelem)                               
                   
        #serviceProvider metadata
        subelem=self._capabilities.find(ns('Service/')+ns('responsibleParty'))
        self.provider=ServiceProvider(subelem)   
        
        #serviceOperations metadata
        self.operations=[]
        for elem in self._capabilities.find(ns('Capability/')+ns('Request'))[:]:
            self.operations.append(OperationMetadata(elem))
          
        #serviceContents metadata
        self.contents={}
        for elem in self._capabilities.findall(ns('ContentMetadata/')+ns('CoverageOfferingBrief')): 
            cm=ContentMetadata(elem, self)
            self.contents[cm.id]=cm
        
        #Some WCS servers (wrongly) advertise 'Content' OfferingBrief instead.
        if self.contents=={}:
            for elem in self._capabilities.findall(ns('ContentMetadata/')+ns('ContentOfferingBrief')): 
                cm=ContentMetadata(elem, self)
                self.contents[cm.id]=cm
        
        #exceptions
        self.exceptions = [f.text for f \
                in self._capabilities.findall('Capability/Exception/Format')]
    
    
    def items(self):
        '''supports dict-like items() access'''
        items=[]
        for item in self.contents:
            items.append((item,self.contents[item]))
        return items
    
    def __makeString(self,value):
        #using repr unconditionally breaks things in some circumstances if a value is already a string
        if type(value) is not str:
            sval=repr(value)
        else:
            sval = value
        return sval
  
    def getCoverage(self, identifier=None, bbox=None, time=None, format = None,  crs=None, width=None, height=None, resx=None, resy=None, resz=None,parameter=None,method='Get',**kwargs):
        """Request and return a coverage from the WCS as a file-like object
        note: additional **kwargs helps with multi-version implementation
        core keyword arguments should be supported cross version
        example:
        cvg=wcs.getCoverage(identifier=['TuMYrRQ4'], timeSequence=['2792-06-01T00:00:00.0'], bbox=(-112,36,-106,41),format='cf-netcdf')

        is equivalent to:
        http://myhost/mywcs?SERVICE=WCS&REQUEST=GetCoverage&IDENTIFIER=TuMYrRQ4&VERSION=1.1.0&BOUNDINGBOX=-180,-90,180,90&TIME=2792-06-01T00:00:00.0&FORMAT=cf-netcdf
           
        """
        if log.isEnabledFor(logging.DEBUG):
            log.debug('WCS 1.0.0 DEBUG: Parameters passed to GetCoverage: identifier=%s, bbox=%s, time=%s, format=%s, crs=%s, width=%s, height=%s, resx=%s, resy=%s, resz=%s, parameter=%s, method=%s, other_arguments=%s'%(identifier, bbox, time, format, crs, width, height, resx, resy, resz, parameter, method, str(kwargs)))
                
        try:
            base_url = next((m.get('url') for m in self.getOperationByName('GetCoverage').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url
        
        if log.isEnabledFor(logging.DEBUG):
            log.debug('WCS 1.0.0 DEBUG: base url of server: %s'%base_url)
        
        #process kwargs
        request = {'version': self.version, 'request': 'GetCoverage', 'service':'WCS'}
        assert len(identifier) > 0
        request['Coverage']=identifier
        #request['identifier'] = ','.join(identifier)
        if bbox:
            request['BBox']=','.join([self.__makeString(x) for x in bbox])
        else:
            request['BBox']=None
        if time:
            request['time']=','.join(time)
        if crs:
            request['crs']=crs
        request['format']=format
        if width:
            request['width']=width
        if height:
            request['height']=height
        if resx:
            request['resx']=resx
        if resy:
            request['resy']=resy
        if resz:
            request['resz']=resz
        
        #anything else e.g. vendor specific parameters must go through kwargs
        if kwargs:
            for kw in kwargs:
                request[kw]=kwargs[kw]
        
        #encode and request
        data = urlencode(request)
        if log.isEnabledFor(logging.DEBUG):
            log.debug('WCS 1.0.0 DEBUG: Second part of URL: %s'%data)
        
        
        u=openURL(base_url, data, method, self.cookies)

        return u
    

               
    def getOperationByName(self, name):
        """Return a named operation item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError, "No operation named %s" % name


class OperationMetadata(object):
    """Abstraction for WCS metadata.   
    Implements IMetadata.
    """
    def __init__(self, elem):
        """."""
        self.name = elem.tag.split('}')[1]          
        
        #self.formatOptions = [f.text for f in elem.findall('{http://www.opengis.net/wcs/1.1/ows}Parameter/{http://www.opengis.net/wcs/1.1/ows}AllowedValues/{http://www.opengis.net/wcs/1.1/ows}Value')]
        self.methods = []
        for resource in elem.findall(ns('DCPType/')+ns('HTTP/')+ns('Get/')+ns('OnlineResource')):
            url = resource.attrib['{http://www.w3.org/1999/xlink}href']
            self.methods.append({'type': 'Get', 'url': url})
        for resource in elem.findall(ns('DCPType/')+ns('HTTP/')+ns('Post/')+ns('OnlineResource')):
            url = resource.attrib['{http://www.w3.org/1999/xlink}href']
            self.methods.append({'type': 'Post', 'url': url})


class ServiceIdentification(object):
    """ Abstraction for ServiceIdentification metadata """
    def __init__(self,elem):
        # properties              
        self.type='OGC:WCS'
        self.version='1.0.0'
        self.service = testXMLValue(elem.find(ns('name')))
        self.abstract = testXMLValue(elem.find(ns('description')))
        self.title = testXMLValue(elem.find(ns('label')))     
        self.keywords = [f.text for f in elem.findall(ns('keywords')+'/'+ns('keyword'))]
        #note: differs from 'rights' in interface
        self.fees=elem.find(ns('fees')).text
        self.accessConstraints=elem.find(ns('accessConstraints')).text
       
class ServiceProvider(object):
    """ Abstraction for WCS ResponsibleParty 
    Implements IServiceProvider"""
    def __init__(self,elem):
        #it's not uncommon for the service provider info to be missing
        #so handle case where None is passed in
        if elem is None:
            self.name=None
            self.url=None
            self.contact = None
        else:
            self.name=testXMLValue(elem.find(ns('organisationName')))
            self.url=self.name #there is no definitive place for url  WCS, repeat organisationName
            self.contact=ContactMetadata(elem)

class ContactMetadata(object):
    ''' implements IContactMetadata'''
    def __init__(self, elem):
        try:
            self.name = elem.find(ns('individualName')).text
        except AttributeError:
            self.name = None
        try:
            self.organization=elem.find(ns('organisationName')).text 
        except AttributeError:
            self.organization = None
        try:
            self.address = elem.find(ns('contactInfo')+'/'+ns('address')+'/'+ns('deliveryPoint')).text
        except AttributeError:
            self.address = None
        try:
            self.city= elem.find(ns('contactInfo')+'/'+ns('address')+'/'+ns('city')).text
        except AttributeError:
            self.city = None
        try:
            self.region=elem.find(ns('contactInfo')+'/'+ns('address')+'/'+ns('administrativeArea')).text
        except AttributeError:
            self.region = None
        try:
            self.postcode=elem.find(ns('contactInfo')+'/'+ns('address')+'/'+ns('postalCode')).text
        except AttributeError:
            self.postcode=None
        try:
            self.country=elem.find(ns('contactInfo')+'/'+ns('address')+'/'+ns('country')).text
        except AttributeError:
            self.country = None
        try:
            self.email=elem.find(ns('contactInfo')+'/'+ns('address')+'/'+ns('electronicMailAddress')).text
        except AttributeError:
            self.email = None

class ContentMetadata(object):
    """
    Implements IContentMetadata
    """
    def __init__(self, elem, service):
        """Initialize. service is required so that describeCoverage requests may be made"""
        #TODO - examine the parent for bounding box info.
        
        #self._parent=parent
        self._elem=elem
        self._service=service
        self.id=elem.find(ns('name')).text
        self.title = testXMLValue(elem.find(ns('label')))
        self.abstract= testXMLValue(elem.find(ns('description')))
        self.keywords = [f.text for f in elem.findall(ns('keywords')+'/'+ns('keyword'))]        
        self.boundingBox=None #needed for iContentMetadata harmonisation
        self.boundingBoxWGS84 = None        
        b = elem.find(ns('lonLatEnvelope')) 
        if b is not None:
            gmlpositions=b.findall('{http://www.opengis.net/gml}pos')
            lc=gmlpositions[0].text
            uc=gmlpositions[1].text
            self.boundingBoxWGS84 = (
                    float(lc.split()[0]),float(lc.split()[1]),
                    float(uc.split()[0]), float(uc.split()[1]),
                    )
        #others not used but needed for iContentMetadata harmonisation
        self.styles=None
        self.crsOptions=None
        self.defaulttimeposition=None

    #grid is either a gml:Grid or a gml:RectifiedGrid if supplied as part of the DescribeCoverage response.
    def _getGrid(self):
        if not hasattr(self, 'descCov'):
                self.descCov=self._service.getDescribeCoverage(self.id)
        gridelem= self.descCov.find(ns('CoverageOffering/')+ns('domainSet/')+ns('spatialDomain/')+'{http://www.opengis.net/gml}RectifiedGrid')
        if gridelem is not None:
            grid=RectifiedGrid(gridelem)
        else:
            gridelem=self.descCov.find(ns('CoverageOffering/')+ns('domainSet/')+ns('spatialDomain/')+'{http://www.opengis.net/gml}Grid')
            grid=Grid(gridelem)
        return grid
    grid=property(_getGrid, None)
        
     #timelimits are the start/end times, timepositions are all timepoints. WCS servers can declare one or both or neither of these.
    def _getTimeLimits(self):
        timepoints, timelimits=[],[]
        b=self._elem.find(ns('lonLatEnvelope'))
        if b is not None:
            timepoints=b.findall('{http://www.opengis.net/gml}timePosition')
        else:
            #have to make a describeCoverage request...
            if not hasattr(self, 'descCov'):
                self.descCov=self._service.getDescribeCoverage(self.id)
            for pos in self.descCov.findall(ns('CoverageOffering/')+ns('domainSet/')+ns('temporalDomain/')+'{http://www.opengis.net/gml}timePosition'):
                timepoints.append(pos)
        if timepoints:
                timelimits=[timepoints[0].text,timepoints[1].text]
        return timelimits
    timelimits=property(_getTimeLimits, None)   
    
    def _getTimePositions(self):
        timepositions=[]
        if not hasattr(self, 'descCov'):
            self.descCov=self._service.getDescribeCoverage(self.id)
        for pos in self.descCov.findall(ns('CoverageOffering/')+ns('domainSet/')+ns('temporalDomain/')+'{http://www.opengis.net/gml}timePosition'):
                timepositions.append(pos.text)
        return timepositions
    timepositions=property(_getTimePositions, None)
           
            
    def _getOtherBoundingBoxes(self):
        ''' incomplete, should return other bounding boxes not in WGS84
            #TODO: find any other bounding boxes. Need to check for gml:EnvelopeWithTimePeriod.'''

        bboxes=[]

        if not hasattr(self, 'descCov'):
            self.descCov=self._service.getDescribeCoverage(self.id)

        for envelope in self.descCov.findall(ns('CoverageOffering/')+ns('domainSet/')+ns('spatialDomain/')+'{http://www.opengis.net/gml}Envelope'):
            bbox = {}
            bbox['nativeSrs'] = envelope.attrib['srsName']
            gmlpositions = envelope.findall('{http://www.opengis.net/gml}pos')
            lc=gmlpositions[0].text.split()
            uc=gmlpositions[1].text.split()
            bbox['bbox'] = (
                float(lc[0]),float(lc[1]),
                float(uc[0]), float(uc[1])
            )
            bboxes.append(bbox)

        return bboxes        
    boundingboxes=property(_getOtherBoundingBoxes,None)
    
    def _getSupportedCRSProperty(self):
        # gets supported crs info
        crss=[]
        for elem in self._service.getDescribeCoverage(self.id).findall(ns('CoverageOffering/')+ns('supportedCRSs/')+ns('responseCRSs')):
            for crs in elem.text.split(' '):
                crss.append(Crs(crs))
        for elem in self._service.getDescribeCoverage(self.id).findall(ns('CoverageOffering/')+ns('supportedCRSs/')+ns('requestResponseCRSs')):
            for crs in elem.text.split(' '):
                crss.append(Crs(crs))
        for elem in self._service.getDescribeCoverage(self.id).findall(ns('CoverageOffering/')+ns('supportedCRSs/')+ns('nativeCRSs')):
            for crs in elem.text.split(' '):
                crss.append(Crs(crs))
        return crss
    supportedCRS=property(_getSupportedCRSProperty, None)
       
       
    def _getSupportedFormatsProperty(self):
        # gets supported formats info
        frmts =[]
        for elem in self._service.getDescribeCoverage(self.id).findall(ns('CoverageOffering/')+ns('supportedFormats/')+ns('formats')):
            frmts.append(elem.text)
        return frmts
    supportedFormats=property(_getSupportedFormatsProperty, None)
    
    def _getAxisDescriptionsProperty(self):
        #gets any axis descriptions contained in the rangeset (requires a DescribeCoverage call to server).
        axisDescs =[]
        for elem in self._service.getDescribeCoverage(self.id).findall(ns('CoverageOffering/')+ns('rangeSet/')+ns('RangeSet/')+ns('axisDescription/')+ns('AxisDescription')):
            axisDescs.append(AxisDescription(elem)) #create a 'AxisDescription' object.
        return axisDescs
    axisDescriptions=property(_getAxisDescriptionsProperty, None)
        
        
          
#Adding classes to represent gml:grid and gml:rectifiedgrid. One of these is used for the cvg.grid property
#(where cvg is a member of the contents dictionary)     
#There is no simple way to convert the offset values in a rectifiedgrid grid to real values without CRS understanding, therefore this is beyond the current scope of owslib, so the representation here is purely to provide access to the information in the GML.
   
class Grid(object):
    ''' Simple grid class to provide axis and value information for a gml grid '''
    def __init__(self, grid):
        self.axislabels = []
        self.dimension=None
        self.lowlimits=[]
        self.highlimits=[]
        if grid is not None:
            self.dimension=int(grid.get('dimension'))
            self.lowlimits= grid.find('{http://www.opengis.net/gml}limits/{http://www.opengis.net/gml}GridEnvelope/{http://www.opengis.net/gml}low').text.split(' ')
            self.highlimits = grid.find('{http://www.opengis.net/gml}limits/{http://www.opengis.net/gml}GridEnvelope/{http://www.opengis.net/gml}high').text.split(' ')
            for axis in grid.findall('{http://www.opengis.net/gml}axisName'):
                self.axislabels.append(axis.text)
      

class RectifiedGrid(Grid):
    ''' RectifiedGrid class, extends Grid with additional offset vector information '''
    def __init__(self, rectifiedgrid):
        super(RectifiedGrid,self).__init__(rectifiedgrid)
        self.origin=rectifiedgrid.find('{http://www.opengis.net/gml}origin/{http://www.opengis.net/gml}pos').text.split()
        self.offsetvectors=[]
        for offset in rectifiedgrid.findall('{http://www.opengis.net/gml}offsetVector'):
            self.offsetvectors.append(offset.text.split())
        
class AxisDescription(object):
    ''' Class to represent the AxisDescription element optionally found as part of the RangeSet and used to 
    define ordinates of additional dimensions such as wavelength bands or pressure levels'''
    def __init__(self, axisdescElem):
        self.name=self.label=None
        self.values=[]
        for elem in axisdescElem.getchildren():
            if elem.tag == ns('name'):
                self.name = elem.text
            elif elem.tag == ns('label'):
                self.label = elem.text
            elif elem.tag == ns('values'):
                for child in elem.getchildren():
                    self.values.append(child.text)     

########NEW FILE########
__FILENAME__ = wcs110
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2004, 2006 Sean C. Gillies
# Copyright (c) 2007 STFC <http://www.stfc.ac.uk>
#
# Authors : 
#          Dominic Lowe <d.lowe@rl.ac.uk>
#
# Contact email: d.lowe@rl.ac.uk
# =============================================================================

##########NOTE: Does not conform to new interfaces yet #################

from wcsBase import WCSBase, WCSCapabilitiesReader, ServiceException
from owslib.util import openURL, testXMLValue
from urllib import urlencode
from urllib2 import urlopen
from owslib.etree import etree
import os, errno
from owslib.coverage import wcsdecoder
from owslib.crs import Crs

import logging
from owslib.util import log

def ns(tag):
    return '{http://www.opengis.net/wcs/1.1}'+tag

class WebCoverageService_1_1_0(WCSBase):
    """Abstraction for OGC Web Coverage Service (WCS), version 1.1.0
    Implements IWebCoverageService.
    """
    
    def __getitem__(self, name):
        ''' check contents dictionary to allow dict like access to service layers'''
        if name in self.__getattribute__('contents').keys():
            return self.__getattribute__('contents')[name]
        else:
            raise KeyError, "No content named %s" % name
    
    def __init__(self,url,xml, cookies):
        self.version='1.1.0'
        self.url = url   
        self.cookies=cookies
        # initialize from saved capability document or access the server
        reader = WCSCapabilitiesReader(self.version)
        if xml:
            self._capabilities = reader.readString(xml)
        else:
            self._capabilities = reader.read(self.url)

        # check for exceptions
        se = self._capabilities.find('{http://www.opengis.net/ows/1.1}Exception')

        if se is not None:
            err_message = str(se.text).strip()
            raise ServiceException(err_message, xml)

        #build metadata objects:
        
        #serviceIdentification metadata
        elem=self._capabilities.find('{http://www.opengis.net/wcs/1.1/ows}ServiceIdentification')
        if elem is None:
            elem=self._capabilities.find('{http://www.opengis.net/ows/1.1}ServiceIdentification')
        self.identification=ServiceIdentification(elem)
        
        #serviceProvider
        elem=self._capabilities.find('{http://www.opengis.net/ows/1.1}ServiceProvider')
        self.provider=ServiceProvider(elem)
                
        #serviceOperations
        self.operations = []
        for elem in self._capabilities.findall('{http://www.opengis.net/wcs/1.1/ows}OperationsMetadata/{http://www.opengis.net/wcs/1.1/ows}Operation/'):
            self.operations.append(Operation(elem))
        
        # exceptions - ***********TO DO *************
            self.exceptions = [f.text for f \
                in self._capabilities.findall('Capability/Exception/Format')]
              
        # serviceContents: our assumption is that services use a top-level layer
        # as a metadata organizer, nothing more.
        self.contents = {}
        top = self._capabilities.find('{http://www.opengis.net/wcs/1.1}Contents/{http://www.opengis.net/wcs/1.1}CoverageSummary')
        for elem in self._capabilities.findall('{http://www.opengis.net/wcs/1.1}Contents/{http://www.opengis.net/wcs/1.1}CoverageSummary/{http://www.opengis.net/wcs/1.1}CoverageSummary'):                    
            cm=ContentMetadata(elem, top, self)
            self.contents[cm.id]=cm
            
        if self.contents=={}:
            #non-hierarchical.
            top=None
            for elem in self._capabilities.findall('{http://www.opengis.net/wcs/1.1}Contents/{http://www.opengis.net/wcs/1.1}CoverageSummary'):     
                cm=ContentMetadata(elem, top, self)
                #make the describeCoverage requests to populate the supported formats/crs attributes
                self.contents[cm.id]=cm

    def items(self):
        '''supports dict-like items() access'''
        items=[]
        for item in self.contents:
            items.append((item,self.contents[item]))
        return items
          
    #TO DECIDE: Offer repackaging of coverageXML/Multipart MIME output?
    #def getData(self, directory='outputdir', outputfile='coverage.nc',  **kwargs):
        #u=self.getCoverageRequest(**kwargs)
        ##create the directory if it doesn't exist:
        #try:
            #os.mkdir(directory)
        #except OSError, e:
            ## Ignore directory exists error
            #if e.errno <> errno.EEXIST:
                #raise          
        ##elif wcs.version=='1.1.0':
        ##Could be multipart mime or XML Coverages document, need to use the decoder...
        #decoder=wcsdecoder.WCSDecoder(u)
        #x=decoder.getCoverages()
        #if type(x) is wcsdecoder.MpartMime:
            #filenames=x.unpackToDir(directory)
            ##print 'Files from 1.1.0 service written to %s directory'%(directory)
        #else:
            #filenames=x
        #return filenames
    
    #TO DO: Handle rest of the  WCS 1.1.0 keyword parameters e.g. GridCRS etc. 
    def getCoverage(self, identifier=None, bbox=None, time=None, format = None, store=False, rangesubset=None, gridbaseCRS=None, gridtype=None, gridCS=None, gridorigin=None, gridoffsets=None, method='Get',**kwargs):
        """Request and return a coverage from the WCS as a file-like object
        note: additional **kwargs helps with multi-version implementation
        core keyword arguments should be supported cross version
        example:
        cvg=wcs.getCoverageRequest(identifier=['TuMYrRQ4'], time=['2792-06-01T00:00:00.0'], bbox=(-112,36,-106,41),format='application/netcdf', store='true')

        is equivalent to:
        http://myhost/mywcs?SERVICE=WCS&REQUEST=GetCoverage&IDENTIFIER=TuMYrRQ4&VERSION=1.1.0&BOUNDINGBOX=-180,-90,180,90&TIMESEQUENCE=2792-06-01T00:00:00.0&FORMAT=application/netcdf
        
        if store = true, returns a coverages XML file
        if store = false, returns a multipart mime
        """
        if log.isEnabledFor(logging.DEBUG):
            log.debug('WCS 1.1.0 DEBUG: Parameters passed to GetCoverage: identifier=%s, bbox=%s, time=%s, format=%s, rangesubset=%s, gridbaseCRS=%s, gridtype=%s, gridCS=%s, gridorigin=%s, gridoffsets=%s, method=%s, other_arguments=%s'%(identifier, bbox, time, format, rangesubset, gridbaseCRS, gridtype, gridCS, gridorigin, gridoffsets, method, str(kwargs)))
        
        if method == 'Get':
            method='{http://www.opengis.net/wcs/1.1/ows}Get'
        try:
            base_url = next((m.get('url') for m in self.getOperationByName('GetCoverage').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url


        #process kwargs
        request = {'version': self.version, 'request': 'GetCoverage', 'service':'WCS'}
        assert len(identifier) > 0
        request['identifier']=identifier
        #request['identifier'] = ','.join(identifier)
        if bbox:
            request['boundingbox']=','.join([repr(x) for x in bbox])
        if time:
            request['timesequence']=','.join(time)
        request['format']=format
        request['store']=store
        
        #rangesubset: untested - require a server implementation
        if rangesubset:
            request['RangeSubset']=rangesubset
        
        #GridCRS structure: untested - require a server implementation
        if gridbaseCRS:
            request['gridbaseCRS']=gridbaseCRS
        if gridtype:
            request['gridtype']=gridtype
        if gridCS:
            request['gridCS']=gridCS
        if gridorigin:
            request['gridorigin']=gridorigin
        if gridoffsets:
            request['gridoffsets']=gridoffsets
       
       #anything else e.g. vendor specific parameters must go through kwargs
        if kwargs:
            for kw in kwargs:
                request[kw]=kwargs[kw]
        
        #encode and request
        data = urlencode(request)
        
        u=openURL(base_url, data, method, self.cookies)
        return u
        
        
    def getOperationByName(self, name):
        """Return a named operation item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError, "No operation named %s" % name
        
class Operation(object):
    """Abstraction for operation metadata    
    Implements IOperationMetadata.
    """
    def __init__(self, elem):
        self.name = elem.get('name')       
        self.formatOptions = [f.text for f in elem.findall('{http://www.opengis.net/wcs/1.1/ows}Parameter/{http://www.opengis.net/wcs/1.1/ows}AllowedValues/{http://www.opengis.net/wcs/1.1/ows}Value')]
        methods = []
        for verb in elem.findall('{http://www.opengis.net/wcs/1.1/ows}DCP/{http://www.opengis.net/wcs/1.1/ows}HTTP/*'):
            url = verb.attrib['{http://www.w3.org/1999/xlink}href']
            methods.append((verb.tag, {'url': url}))
        self.methods = dict(methods)

class ServiceIdentification(object):
    """ Abstraction for ServiceIdentification Metadata 
    implements IServiceIdentificationMetadata"""
    def __init__(self,elem):        
        self.service="WCS"
        self.version="1.1.0"
        self.title=testXMLValue(elem.find('{http://www.opengis.net/ows}Title'))
        if self.title is None:  #may have used the wcs ows namespace:
            self.title=testXMLValue(elem.find('{http://www.opengis.net/wcs/1.1/ows}Title'))
        
        self.abstract=testXMLValue(elem.find('{http://www.opengis.net/ows}Abstract'))
        if self.abstract is None:#may have used the wcs ows namespace:
            self.abstract=testXMLValue(elem.find('{http://www.opengis.net/wcs/1.1/ows}Abstract'))
        if elem.find('{http://www.opengis.net/ows}Abstract') is not None:
            self.abstract=elem.find('{http://www.opengis.net/ows}Abstract').text
        else:
            self.abstract = None
        self.keywords = [f.text for f in elem.findall('{http://www.opengis.net/ows}Keywords/{http://www.opengis.net/ows}Keyword')]
        #self.link = elem.find('{http://www.opengis.net/wcs/1.1}Service/{http://www.opengis.net/wcs/1.1}OnlineResource').attrib.get('{http://www.w3.org/1999/xlink}href', '')
               
        if elem.find('{http://www.opengis.net/wcs/1.1/ows}Fees') is not None:            
            self.fees=elem.find('{http://www.opengis.net/wcs/1.1/ows}Fees').text
        else:
            self.fees=None
        
        if  elem.find('{http://www.opengis.net/wcs/1.1/ows}AccessConstraints') is not None:
            self.accessConstraints=elem.find('{http://www.opengis.net/wcs/1.1/ows}AccessConstraints').text
        else:
            self.accessConstraints=None
       
       
class ServiceProvider(object):
    """ Abstraction for ServiceProvider metadata 
    implements IServiceProviderMetadata """
    def __init__(self,elem):
        name=elem.find('{http://www.opengis.net/ows}ProviderName')
        if name is not None:
            self.name=name.text
        else:
            self.name=None
        #self.contact=ServiceContact(elem.find('{http://www.opengis.net/ows}ServiceContact'))
        self.contact =ContactMetadata(elem)
        self.url=self.name # no obvious definitive place for url in wcs, repeat provider name?

class ContactMetadata(object):
    ''' implements IContactMetadata'''
    def __init__(self, elem):
        try:
            self.name = elem.find('{http://www.opengis.net/ows}ServiceContact/{http://www.opengis.net/ows}IndividualName').text
        except AttributeError:
            self.name = None
        
        try:
            self.organization=elem.find('{http://www.opengis.net/ows}ProviderName').text 
        except AttributeError:
            self.organization = None
        
        try:
            self.address = elem.find('{http://www.opengis.net/ows}ServiceContact/{http://www.opengis.net/ows}ContactInfo/{http://www.opengis.net/ows}Address/{http://www.opengis.net/ows}DeliveryPoint').text
        except AttributeError:
            self.address = None
        try:
            self.city=  elem.find('{http://www.opengis.net/ows}ServiceContact/{http://www.opengis.net/ows}ContactInfo/{http://www.opengis.net/ows}Address/{http://www.opengis.net/ows}City').text
        except AttributeError:
            self.city = None
        
        try:
            self.region= elem.find('{http://www.opengis.net/ows}ServiceContact/{http://www.opengis.net/ows}ContactInfo/{http://www.opengis.net/ows}Address/{http://www.opengis.net/ows}AdministrativeArea').text
        except AttributeError:
            self.region = None
        
        try:
            self.postcode= elem.find('{http://www.opengis.net/ows}ServiceContact/{http://www.opengis.net/ows}ContactInfo/{http://www.opengis.net/ows}Address/{http://www.opengis.net/ows}PostalCode').text
        except AttributeError:
            self.postcode = None
        
        try:
            self.country= elem.find('{http://www.opengis.net/ows}ServiceContact/{http://www.opengis.net/ows}ContactInfo/{http://www.opengis.net/ows}Address/{http://www.opengis.net/ows}Country').text
        except AttributeError:
            self.country = None
        
        try:
            self.email =            elem.find('{http://www.opengis.net/ows}ServiceContact/{http://www.opengis.net/ows}ContactInfo/{http://www.opengis.net/ows}Address/{http://www.opengis.net/ows}ElectronicMailAddress').text
        except AttributeError:
            self.email = None

class ContentMetadata(object):
    """Abstraction for WCS ContentMetadata
    Implements IContentMetadata
    """
    def __init__(self, elem, parent, service):
        """Initialize."""
        #TODO - examine the parent for bounding box info.
        
        self._service=service
        self._elem=elem
        self._parent=parent
        self.id=self._checkChildAndParent('{http://www.opengis.net/wcs/1.1}Identifier')
        self.description =self._checkChildAndParent('{http://www.opengis.net/wcs/1.1}Description')           
        self.title =self._checkChildAndParent('{http://www.opengis.net/ows}Title')
        self.abstract =self._checkChildAndParent('{http://www.opengis.net/ows}Abstract')
        
        #keywords.
        self.keywords=[]
        for kw in elem.findall('{http://www.opengis.net/ows}Keywords/{http://www.opengis.net/ows}Keyword'):
            if kw is not None:
                self.keywords.append(kw.text)
        
        #also inherit any keywords from parent coverage summary (if there is one)
        if parent is not None:
            for kw in parent.findall('{http://www.opengis.net/ows}Keywords/{http://www.opengis.net/ows}Keyword'):
                if kw is not None:
                    self.keywords.append(kw.text)
            
        self.boundingBox=None #needed for iContentMetadata harmonisation
        self.boundingBoxWGS84 = None
        b = elem.find('{http://www.opengis.net/ows}WGS84BoundingBox')
        if b is not None:
            lc=b.find('{http://www.opengis.net/ows}LowerCorner').text
            uc=b.find('{http://www.opengis.net/ows}UpperCorner').text
            self.boundingBoxWGS84 = (
                    float(lc.split()[0]),float(lc.split()[1]),
                    float(uc.split()[0]), float(uc.split()[1]),
                    )
                
        # bboxes - other CRS 
        self.boundingboxes = []
        for bbox in elem.findall('{http://www.opengis.net/ows}BoundingBox'):
            if bbox is not None:
                try:
                    lc=b.find('{http://www.opengis.net/ows}LowerCorner').text
                    uc=b.find('{http://www.opengis.net/ows}UpperCorner').text
                    boundingBox =  (
                            float(lc.split()[0]),float(lc.split()[1]),
                            float(uc.split()[0]), float(uc.split()[1]),
                            b.attrib['crs'])
                    self.boundingboxes.append(boundingBox)
                except:
                     pass

        #others not used but needed for iContentMetadata harmonisation
        self.styles=None
        self.crsOptions=None
                
        #SupportedCRS
        self.supportedCRS=[]
        for crs in elem.findall('{http://www.opengis.net/wcs/1.1}SupportedCRS'):
            self.supportedCRS.append(Crs(crs.text))
            
            
        #SupportedFormats         
        self.supportedFormats=[]
        for format in elem.findall('{http://www.opengis.net/wcs/1.1}SupportedFormat'):
            self.supportedFormats.append(format.text)
            
    #grid is either a gml:Grid or a gml:RectifiedGrid if supplied as part of the DescribeCoverage response.
    def _getGrid(self):
        grid=None
        #TODO- convert this to 1.1 from 1.0
        #if not hasattr(self, 'descCov'):
                #self.descCov=self._service.getDescribeCoverage(self.id)
        #gridelem= self.descCov.find(ns('CoverageOffering/')+ns('domainSet/')+ns('spatialDomain/')+'{http://www.opengis.net/gml}RectifiedGrid')
        #if gridelem is not None:
            #grid=RectifiedGrid(gridelem)
        #else:
            #gridelem=self.descCov.find(ns('CoverageOffering/')+ns('domainSet/')+ns('spatialDomain/')+'{http://www.opengis.net/gml}Grid')
            #grid=Grid(gridelem)
        return grid
    grid=property(_getGrid, None)
        
        
        
    #time limits/postions require a describeCoverage request therefore only resolve when requested
    def _getTimeLimits(self):
         timelimits=[]
         for elem in self._service.getDescribeCoverage(self.id).findall(ns('CoverageDescription/')+ns('Domain/')+ns('TemporalDomain/')+ns('TimePeriod/')):
             subelems=elem.getchildren()
             timelimits=[subelems[0].text,subelems[1].text]
         return timelimits
    timelimits=property(_getTimeLimits, None)
    
    #TODO timepositions property
    def _getTimePositions(self):
        return []
    timepositions=property(_getTimePositions, None)
    
    def _checkChildAndParent(self, path):
        ''' checks child coverage  summary, and if item not found checks higher level coverage summary'''
        try:
            value = self._elem.find(path).text
        except:
            try:
                value = self._parent.find(path).text
            except:
                value = None
        return value  

########NEW FILE########
__FILENAME__ = wcsBase
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2004, 2006 Sean C. Gillies
# Copyright (c) 2007 STFC <http://www.stfc.ac.uk>
#
# Authors : 
#          Dominic Lowe <d.lowe@rl.ac.uk>
#
# Contact email: d.lowe@rl.ac.uk
# =============================================================================

from urllib import urlencode
from urllib2 import urlopen, Request
from owslib.etree import etree
import cgi
from StringIO import StringIO


class ServiceException(Exception):
    """WCS ServiceException

    Attributes:
        message -- short error message
        xml  -- full xml error message from server
    """

    def __init__(self, message, xml):
        self.message = message
        self.xml = xml

    def __str__(self):
        return repr(self.message)

class WCSBase(object):
    """Base class to be subclassed by version dependent WCS classes. Provides 'high-level' version independent methods"""
    def __new__(self,url, xml, cookies):
        """ overridden __new__ method 
        
        @type url: string
        @param url: url of WCS capabilities document
        @type xml: string
        @param xml: elementtree object
        @return: inititalised WCSBase object
        """
        obj=object.__new__(self)
        obj.__init__(url, xml, cookies)
        self.cookies=cookies
        self._describeCoverage = {} #cache for DescribeCoverage responses
        return obj
    
    def __init__(self):
        pass    

    def getDescribeCoverage(self, identifier):
        ''' returns a describe coverage document - checks the internal cache to see if it has been fetched before '''
        if identifier not in self._describeCoverage.keys():
            reader = DescribeCoverageReader(self.version, identifier, self.cookies)
            self._describeCoverage[identifier] = reader.read(self.url)
        return self._describeCoverage[identifier]
        
        
class WCSCapabilitiesReader(object):
    """Read and parses WCS capabilities document into a lxml.etree infoset
    """

    def __init__(self, version=None, cookies = None):
        """Initialize
        @type version: string
        @param version: WCS Version parameter e.g '1.0.0'
        """
        self.version = version
        self._infoset = None
        self.cookies = cookies

    def capabilities_url(self, service_url):
        """Return a capabilities url
        @type service_url: string
        @param service_url: base url of WCS service
        @rtype: string
        @return: getCapabilities URL
        """
        qs = []
        if service_url.find('?') != -1:
            qs = cgi.parse_qsl(service_url.split('?')[1])

        params = [x[0] for x in qs]

        if 'service' not in params:
            qs.append(('service', 'WCS'))
        if 'request' not in params:
            qs.append(('request', 'GetCapabilities'))
        if ('version' not in params) and (self.version is not None):
            qs.append(('version', self.version))

        urlqs = urlencode(tuple(qs))
        return service_url.split('?')[0] + '?' + urlqs

    def read(self, service_url, timeout=30):
        """Get and parse a WCS capabilities document, returning an
        elementtree tree

        @type service_url: string
        @param service_url: The base url, to which is appended the service,
        version, and request parameters
        @rtype: elementtree tree
        @return: An elementtree tree representation of the capabilities document
        """
        request = self.capabilities_url(service_url)
        req = Request(request)
        if self.cookies is not None:
            req.add_header('Cookie', self.cookies)   
        u = urlopen(req, timeout=timeout)
        return etree.fromstring(u.read())
    
    def readString(self, st):
        """Parse a WCS capabilities document, returning an
        instance of WCSCapabilitiesInfoset
        string should be an XML capabilities document
        """
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        return etree.fromstring(st)

class DescribeCoverageReader(object):
    """Read and parses WCS DescribeCoverage document into a lxml.etree infoset
    """

    def __init__(self, version, identifier, cookies):
        """Initialize
        @type version: string
        @param version: WCS Version parameter e.g '1.0.0'
        """
        self.version = version
        self._infoset = None
        self.identifier=identifier
        self.cookies = cookies

    def descCov_url(self, service_url):
        """Return a describe coverage url
        @type service_url: string
        @param service_url: base url of WCS service
        @rtype: string
        @return: getCapabilities URL
        """
        qs = []
        if service_url.find('?') != -1:
            qs = cgi.parse_qsl(service_url.split('?')[1])

        params = [x[0] for x in qs]

        if 'service' not in params:
            qs.append(('service', 'WCS'))
        if 'request' not in params:
            qs.append(('request', 'DescribeCoverage'))
        if 'version' not in params:
            qs.append(('version', self.version))
        if self.version == '1.0.0':
            if 'coverage' not in params:
                qs.append(('coverage', self.identifier))
        elif self.version == '1.1.0':
            #NOTE: WCS 1.1.0 is ambigous about whether it should be identifier
            #or identifiers (see tables 9, 10 of specification)  
            if 'identifiers' not in params:
                qs.append(('identifiers', self.identifier))
            if 'identifier' not in params:
                qs.append(('identifier', self.identifier))
                qs.append(('format', 'text/xml'))
        urlqs = urlencode(tuple(qs))
        return service_url.split('?')[0] + '?' + urlqs

    def read(self, service_url, timeout=30):
        """Get and parse a Describe Coverage document, returning an
        elementtree tree

        @type service_url: string
        @param service_url: The base url, to which is appended the service,
        version, and request parameters
        @rtype: elementtree tree
        @return: An elementtree tree representation of the capabilities document
        """
        request = self.descCov_url(service_url)
        req = Request(request)
        if self.cookies is not None:
            req.add_header('Cookie', self.cookies)   
        u = urlopen(req, timeout=timeout)
        return etree.fromstring(u.read())
    
       

########NEW FILE########
__FILENAME__ = wcsdecoder
#WCS response decoder.
#Decodes response from a WCS (either a Coverages XML document or a Multipart MIME) and extracts the urls of the coverage data.
#Copyright (c) 2007 STFC <http://www.stfc.ac.uk>
#Author: Dominic Lowe, STFC
#contact email: d.lowe@rl.ac.uk
#
# Multipart MIME decoding based on http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/86676

#example: used in conjunction with ows lib wcs:

#from owslib import wcsdecoder
#u=wcs.getcoverage(identifier=['TuMYrRQ4'], timeSequence=['2792-06-01T00:00:00.0'], bbox=(-112,36,-106,41),format='application/netcdf', store='true')
#decoder=wcsdecoder.WCSDecoder(u)
#decoder.getCoverages()

import os
from owslib.etree import etree
import email
import errno

class WCSDecoder(object):
    def __init__(self, u):
        ''' initiate with a urllib  url object.'''
        self.u=u
        self._getType()

    def _getType(self):
        ''' determine whether it is a Multipart Mime or a Coverages XML file'''
        
        #what's the best way to test this? 
        #for now read start of file
        tempu=self.u
        if tempu.readline()[:14] == '<?xml version=':              
            self.urlType='XML'       
        else:
            self.urlType='Multipart'
        
      
    def getCoverages(self, unpackdir='./unpacked'):
        if self.urlType=='XML': 
            paths=[]              
            u_xml = self.u.read()
            u_tree = etree.fromstring(u_xml)
            for ref in u_tree.findall('{http://www.opengis.net/wcs/1.1}Coverage/{http://www.opengis.net/wcs/1.1}Reference'):
                path = ref.attrib['{http://www.w3.org/1999/xlink}href']
                paths.append(path)         
            for ref in u_tree.findall('{http://www.opengis.net/wcs/1.1.0/owcs}Coverage/{{http://www.opengis.net/wcs/1.1.0/owcs}Reference'):
                path = ref.attrib['{http://www.w3.org/1999/xlink}href']
                paths.append(path)         
        elif self.urlType=='Multipart':
            #Decode multipart mime and return fileobjects
            u_mpart=self.u.read()
            mpart =MpartMime(u_mpart)
            paths= mpart.unpackToDir(unpackdir)
        return paths

class MpartMime(object):
    def __init__ (self,mpartmime):
        """ mpartmime is a multipart mime file  that has already been read in."""
        self.mpartmime=mpartmime
        
    def unpackToDir(self, unpackdir):
        """ unpacks contents of Multipart mime to a given directory"""
        
        names=[]
        #create the directory if it doesn't exist:
        try:
            os.mkdir(unpackdir)
        except OSError, e:
            # Ignore directory exists error
            if e.errno <> errno.EEXIST:
                raise
               
        #now walk through the multipart mime and write out files
        msg = email.message_from_string(self.mpartmime)
        counter =1
        for part in msg.walk():
            # multipart/* are just containers, ignore
            if part.get_content_maintype() == 'multipart':
                continue            
            # Applications should really check the given filename so that an
            # email message can't be used to overwrite important files
            filename = part.get_filename()
            if not filename:
                try:
                    ext = mimetypes.guess_extension(part.get_type())
                except:
                    ext=None
                if not ext:
                    # Use a generic extension
                    ext = '.bin'
                filename = 'part-%03d%s' % (counter, ext)                
            fullpath=os.path.join(unpackdir, filename)
            names.append(fullpath)
            fp = open(fullpath, 'wb')
            fp.write(part.get_payload(decode=True))
            fp.close()
        return names

########NEW FILE########
__FILENAME__ = crs
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2011 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

""" API for OGC CRS constructs. """

# list of URN codes for EPSG in which axis order
# of coordinates are y,x (e.g. lat, long)
axisorder_yx = frozenset([
    4326,
    4258,
    31466,
    31467,
    31468,
    31469,
    2166,
    2167,
    2168,
    2036,
    2044,
    2045,
    2065,
    2081,
    2082,
    2083,
    2085,
    2086,
    2091,
    2092,
    2093,
    2096,
    2097,
    2098,
    2105,
    2106,
    2107,
    2108,
    2109,
    2110,
    2111,
    2112,
    2113,
    2114,
    2115,
    2116,
    2117,
    2118,
    2119,
    2120,
    2121,
    2122,
    2123,
    2124,
    2125,
    2126,
    2127,
    2128,
    2129,
    2130,
    2131,
    2132,
    2169,
    2170,
    2171,
    2172,
    2173,
    2174,
    2175,
    2176,
    2177,
    2178,
    2179,
    2180,
    2193,
    2199,
    2200,
    2206,
    2207,
    2208,
    2209,
    2210,
    2211,
    2212,
    2319,
    2320,
    2321,
    2322,
    2323,
    2324,
    2325,
    2326,
    2327,
    2328,
    2329,
    2330,
    2331,
    2332,
    2333,
    2334,
    2335,
    2336,
    2337,
    2338,
    2339,
    2340,
    2341,
    2342,
    2343,
    2344,
    2345,
    2346,
    2347,
    2348,
    2349,
    2350,
    2351,
    2352,
    2353,
    2354,
    2355,
    2356,
    2357,
    2358,
    2359,
    2360,
    2361,
    2362,
    2363,
    2364,
    2365,
    2366,
    2367,
    2368,
    2369,
    2370,
    2371,
    2372,
    2373,
    2374,
    2375,
    2376,
    2377,
    2378,
    2379,
    2380,
    2381,
    2382,
    2383,
    2384,
    2385,
    2386,
    2387,
    2388,
    2389,
    2390,
    2391,
    2392,
    2393,
    2394,
    2395,
    2396,
    2397,
    2398,
    2399,
    2400,
    2401,
    2402,
    2403,
    2404,
    2405,
    2406,
    2407,
    2408,
    2409,
    2410,
    2411,
    2412,
    2413,
    2414,
    2415,
    2416,
    2417,
    2418,
    2419,
    2420,
    2421,
    2422,
    2423,
    2424,
    2425,
    2426,
    2427,
    2428,
    2429,
    2430,
    2431,
    2432,
    2433,
    2434,
    2435,
    2436,
    2437,
    2438,
    2439,
    2440,
    2441,
    2442,
    2443,
    2444,
    2445,
    2446,
    2447,
    2448,
    2449,
    2450,
    2451,
    2452,
    2453,
    2454,
    2455,
    2456,
    2457,
    2458,
    2459,
    2460,
    2461,
    2462,
    2463,
    2464,
    2465,
    2466,
    2467,
    2468,
    2469,
    2470,
    2471,
    2472,
    2473,
    2474,
    2475,
    2476,
    2477,
    2478,
    2479,
    2480,
    2481,
    2482,
    2483,
    2484,
    2485,
    2486,
    2487,
    2488,
    2489,
    2490,
    2491,
    2492,
    2493,
    2494,
    2495,
    2496,
    2497,
    2498,
    2499,
    2500,
    2501,
    2502,
    2503,
    2504,
    2505,
    2506,
    2507,
    2508,
    2509,
    2510,
    2511,
    2512,
    2513,
    2514,
    2515,
    2516,
    2517,
    2518,
    2519,
    2520,
    2521,
    2522,
    2523,
    2524,
    2525,
    2526,
    2527,
    2528,
    2529,
    2530,
    2531,
    2532,
    2533,
    2534,
    2535,
    2536,
    2537,
    2538,
    2539,
    2540,
    2541,
    2542,
    2543,
    2544,
    2545,
    2546,
    2547,
    2548,
    2549,
    2551,
    2552,
    2553,
    2554,
    2555,
    2556,
    2557,
    2558,
    2559,
    2560,
    2561,
    2562,
    2563,
    2564,
    2565,
    2566,
    2567,
    2568,
    2569,
    2570,
    2571,
    2572,
    2573,
    2574,
    2575,
    2576,
    2577,
    2578,
    2579,
    2580,
    2581,
    2582,
    2583,
    2584,
    2585,
    2586,
    2587,
    2588,
    2589,
    2590,
    2591,
    2592,
    2593,
    2594,
    2595,
    2596,
    2597,
    2598,
    2599,
    2600,
    2601,
    2602,
    2603,
    2604,
    2605,
    2606,
    2607,
    2608,
    2609,
    2610,
    2611,
    2612,
    2613,
    2614,
    2615,
    2616,
    2617,
    2618,
    2619,
    2620,
    2621,
    2622,
    2623,
    2624,
    2625,
    2626,
    2627,
    2628,
    2629,
    2630,
    2631,
    2632,
    2633,
    2634,
    2635,
    2636,
    2637,
    2638,
    2639,
    2640,
    2641,
    2642,
    2643,
    2644,
    2645,
    2646,
    2647,
    2648,
    2649,
    2650,
    2651,
    2652,
    2653,
    2654,
    2655,
    2656,
    2657,
    2658,
    2659,
    2660,
    2661,
    2662,
    2663,
    2664,
    2665,
    2666,
    2667,
    2668,
    2669,
    2670,
    2671,
    2672,
    2673,
    2674,
    2675,
    2676,
    2677,
    2678,
    2679,
    2680,
    2681,
    2682,
    2683,
    2684,
    2685,
    2686,
    2687,
    2688,
    2689,
    2690,
    2691,
    2692,
    2693,
    2694,
    2695,
    2696,
    2697,
    2698,
    2699,
    2700,
    2701,
    2702,
    2703,
    2704,
    2705,
    2706,
    2707,
    2708,
    2709,
    2710,
    2711,
    2712,
    2713,
    2714,
    2715,
    2716,
    2717,
    2718,
    2719,
    2720,
    2721,
    2722,
    2723,
    2724,
    2725,
    2726,
    2727,
    2728,
    2729,
    2730,
    2731,
    2732,
    2733,
    2734,
    2735,
    2738,
    2739,
    2740,
    2741,
    2742,
    2743,
    2744,
    2745,
    2746,
    2747,
    2748,
    2749,
    2750,
    2751,
    2752,
    2753,
    2754,
    2755,
    2756,
    2757,
    2758,
    2935,
    2936,
    2937,
    2938,
    2939,
    2940,
    2941,
    2953,
    2963,
    3006,
    3007,
    3008,
    3009,
    3010,
    3011,
    3012,
    3013,
    3014,
    3015,
    3016,
    3017,
    3018,
    3019,
    3020,
    3021,
    3022,
    3023,
    3024,
    3025,
    3026,
    3027,
    3028,
    3029,
    3030,
    3034,
    3035,
    3038,
    3039,
    3040,
    3041,
    3042,
    3043,
    3044,
    3045,
    3046,
    3047,
    3048,
    3049,
    3050,
    3051,
    3058,
    3059,
    3068,
    3114,
    3115,
    3116,
    3117,
    3118,
    3120,
    3126,
    3127,
    3128,
    3129,
    3130,
    3131,
    3132,
    3133,
    3134,
    3135,
    3136,
    3137,
    3138,
    3139,
    3140,
    3146,
    3147,
    3150,
    3151,
    3152,
    3300,
    3301,
    3328,
    3329,
    3330,
    3331,
    3332,
    3333,
    3334,
    3335,
    3346,
    3350,
    3351,
    3352,
    3366,
    3386,
    3387,
    3388,
    3389,
    3390,
    3396,
    3397,
    3398,
    3399,
    3407,
    3414,
    3416,
    3764,
    3788,
    3789,
    3790,
    3791,
    3793,
    3795,
    3796,
    3819,
    3821,
    3823,
    3824,
    3833,
    3834,
    3835,
    3836,
    3837,
    3838,
    3839,
    3840,
    3841,
    3842,
    3843,
    3844,
    3845,
    3846,
    3847,
    3848,
    3849,
    3850,
    3851,
    3852,
    3854,
    3873,
    3874,
    3875,
    3876,
    3877,
    3878,
    3879,
    3880,
    3881,
    3882,
    3883,
    3884,
    3885,
    3888,
    3889,
    3906,
    3907,
    3908,
    3909,
    3910,
    3911,
    4001,
    4002,
    4003,
    4004,
    4005,
    4006,
    4007,
    4008,
    4009,
    4010,
    4011,
    4012,
    4013,
    4014,
    4015,
    4016,
    4017,
    4018,
    4019,
    4020,
    4021,
    4022,
    4023,
    4024,
    4025,
    4026,
    4027,
    4028,
    4029,
    4030,
    4031,
    4032,
    4033,
    4034,
    4035,
    4036,
    4037,
    4038,
    4040,
    4041,
    4042,
    4043,
    4044,
    4045,
    4046,
    4047,
    4052,
    4053,
    4054,
    4055,
    4074,
    4075,
    4080,
    4081,
    4120,
    4121,
    4122,
    4123,
    4124,
    4125,
    4126,
    4127,
    4128,
    4129,
    4130,
    4131,
    4132,
    4133,
    4134,
    4135,
    4136,
    4137,
    4138,
    4139,
    4140,
    4141,
    4142,
    4143,
    4144,
    4145,
    4146,
    4147,
    4148,
    4149,
    4150,
    4151,
    4152,
    4153,
    4154,
    4155,
    4156,
    4157,
    4158,
    4159,
    4160,
    4161,
    4162,
    4163,
    4164,
    4165,
    4166,
    4167,
    4168,
    4169,
    4170,
    4171,
    4172,
    4173,
    4174,
    4175,
    4176,
    4178,
    4179,
    4180,
    4181,
    4182,
    4183,
    4184,
    4185,
    4188,
    4189,
    4190,
    4191,
    4192,
    4193,
    4194,
    4195,
    4196,
    4197,
    4198,
    4199,
    4200,
    4201,
    4202,
    4203,
    4204,
    4205,
    4206,
    4207,
    4208,
    4209,
    4210,
    4211,
    4212,
    4213,
    4214,
    4215,
    4216,
    4218,
    4219,
    4220,
    4221,
    4222,
    4223,
    4224,
    4225,
    4226,
    4227,
    4228,
    4229,
    4230,
    4231,
    4232,
    4233,
    4234,
    4235,
    4236,
    4237,
    4238,
    4239,
    4240,
    4241,
    4242,
    4243,
    4244,
    4245,
    4246,
    4247,
    4248,
    4249,
    4250,
    4251,
    4252,
    4253,
    4254,
    4255,
    4256,
    4257,
    4259,
    4260,
    4261,
    4262,
    4263,
    4264,
    4265,
    4266,
    4267,
    4268,
    4269,
    4270,
    4271,
    4272,
    4273,
    4274,
    4275,
    4276,
    4277,
    4278,
    4279,
    4280,
    4281,
    4282,
    4283,
    4284,
    4285,
    4286,
    4287,
    4288,
    4289,
    4291,
    4292,
    4293,
    4294,
    4295,
    4296,
    4297,
    4298,
    4299,
    4300,
    4301,
    4302,
    4303,
    4304,
    4306,
    4307,
    4308,
    4309,
    4310,
    4311,
    4312,
    4313,
    4314,
    4315,
    4316,
    4317,
    4318,
    4319,
    4322,
    4324,
    4327,
    4329,
    4339,
    4341,
    4343,
    4345,
    4347,
    4349,
    4351,
    4353,
    4355,
    4357,
    4359,
    4361,
    4363,
    4365,
    4367,
    4369,
    4371,
    4373,
    4375,
    4377,
    4379,
    4381,
    4383,
    4386,
    4388,
    4417,
    4434,
    4463,
    4466,
    4469,
    4470,
    4472,
    4475,
    4480,
    4482,
    4483,
    4490,
    4491,
    4492,
    4493,
    4494,
    4495,
    4496,
    4497,
    4498,
    4499,
    4500,
    4501,
    4502,
    4503,
    4504,
    4505,
    4506,
    4507,
    4508,
    4509,
    4510,
    4511,
    4512,
    4513,
    4514,
    4515,
    4516,
    4517,
    4518,
    4519,
    4520,
    4521,
    4522,
    4523,
    4524,
    4525,
    4526,
    4527,
    4528,
    4529,
    4530,
    4531,
    4532,
    4533,
    4534,
    4535,
    4536,
    4537,
    4538,
    4539,
    4540,
    4541,
    4542,
    4543,
    4544,
    4545,
    4546,
    4547,
    4548,
    4549,
    4550,
    4551,
    4552,
    4553,
    4554,
    4555,
    4557,
    4558,
    4568,
    4569,
    4570,
    4571,
    4572,
    4573,
    4574,
    4575,
    4576,
    4577,
    4578,
    4579,
    4580,
    4581,
    4582,
    4583,
    4584,
    4585,
    4586,
    4587,
    4588,
    4589,
    4600,
    4601,
    4602,
    4603,
    4604,
    4605,
    4606,
    4607,
    4608,
    4609,
    4610,
    4611,
    4612,
    4613,
    4614,
    4615,
    4616,
    4617,
    4618,
    4619,
    4620,
    4621,
    4622,
    4623,
    4624,
    4625,
    4626,
    4627,
    4628,
    4629,
    4630,
    4631,
    4632,
    4633,
    4634,
    4635,
    4636,
    4637,
    4638,
    4639,
    4640,
    4641,
    4642,
    4643,
    4644,
    4645,
    4646,
    4652,
    4653,
    4654,
    4655,
    4656,
    4657,
    4658,
    4659,
    4660,
    4661,
    4662,
    4663,
    4664,
    4665,
    4666,
    4667,
    4668,
    4669,
    4670,
    4671,
    4672,
    4673,
    4674,
    4675,
    4676,
    4677,
    4678,
    4679,
    4680,
    4681,
    4682,
    4683,
    4684,
    4685,
    4686,
    4687,
    4688,
    4689,
    4690,
    4691,
    4692,
    4693,
    4694,
    4695,
    4696,
    4697,
    4698,
    4699,
    4700,
    4701,
    4702,
    4703,
    4704,
    4705,
    4706,
    4707,
    4708,
    4709,
    4710,
    4711,
    4712,
    4713,
    4714,
    4715,
    4716,
    4717,
    4718,
    4719,
    4720,
    4721,
    4722,
    4723,
    4724,
    4725,
    4726,
    4727,
    4728,
    4729,
    4730,
    4731,
    4732,
    4733,
    4734,
    4735,
    4736,
    4737,
    4738,
    4739,
    4740,
    4741,
    4742,
    4743,
    4744,
    4745,
    4746,
    4747,
    4748,
    4749,
    4750,
    4751,
    4752,
    4753,
    4754,
    4755,
    4756,
    4757,
    4758,
    4759,
    4760,
    4761,
    4762,
    4763,
    4764,
    4765,
    4766,
    4767,
    4768,
    4769,
    4770,
    4771,
    4772,
    4773,
    4774,
    4775,
    4776,
    4777,
    4778,
    4779,
    4780,
    4781,
    4782,
    4783,
    4784,
    4785,
    4786,
    4787,
    4788,
    4789,
    4790,
    4791,
    4792,
    4793,
    4794,
    4795,
    4796,
    4797,
    4798,
    4799,
    4800,
    4801,
    4802,
    4803,
    4804,
    4805,
    4806,
    4807,
    4808,
    4809,
    4810,
    4811,
    4812,
    4813,
    4814,
    4815,
    4816,
    4817,
    4818,
    4819,
    4820,
    4821,
    4822,
    4823,
    4824,
    4839,
    4855,
    4856,
    4857,
    4858,
    4859,
    4860,
    4861,
    4862,
    4863,
    4864,
    4865,
    4866,
    4867,
    4868,
    4869,
    4870,
    4871,
    4872,
    4873,
    4874,
    4875,
    4876,
    4877,
    4878,
    4879,
    4880,
    4883,
    4885,
    4887,
    4889,
    4891,
    4893,
    4895,
    4898,
    4900,
    4901,
    4902,
    4903,
    4904,
    4907,
    4909,
    4921,
    4923,
    4925,
    4927,
    4929,
    4931,
    4933,
    4935,
    4937,
    4939,
    4941,
    4943,
    4945,
    4947,
    4949,
    4951,
    4953,
    4955,
    4957,
    4959,
    4961,
    4963,
    4965,
    4967,
    4969,
    4971,
    4973,
    4975,
    4977,
    4979,
    4981,
    4983,
    4985,
    4987,
    4989,
    4991,
    4993,
    4995,
    4997,
    4999,
    5012,
    5013,
    5017,
    5048,
    5105,
    5106,
    5107,
    5108,
    5109,
    5110,
    5111,
    5112,
    5113,
    5114,
    5115,
    5116,
    5117,
    5118,
    5119,
    5120,
    5121,
    5122,
    5123,
    5124,
    5125,
    5126,
    5127,
    5128,
    5129,
    5130,
    5132,
    5167,
    5168,
    5169,
    5170,
    5171,
    5172,
    5173,
    5174,
    5175,
    5176,
    5177,
    5178,
    5179,
    5180,
    5181,
    5182,
    5183,
    5184,
    5185,
    5186,
    5187,
    5188,
    5224,
    5228,
    5229,
    5233,
    5245,
    5246,
    5251,
    5252,
    5253,
    5254,
    5255,
    5256,
    5257,
    5258,
    5259,
    5263,
    5264,
    5269,
    5270,
    5271,
    5272,
    5273,
    5274,
    5275,
    5801,
    5802,
    5803,
    5804,
    5808,
    5809,
    5810,
    5811,
    5812,
    5813,
    5814,
    5815,
    5816,
    20004,
    20005,
    20006,
    20007,
    20008,
    20009,
    20010,
    20011,
    20012,
    20013,
    20014,
    20015,
    20016,
    20017,
    20018,
    20019,
    20020,
    20021,
    20022,
    20023,
    20024,
    20025,
    20026,
    20027,
    20028,
    20029,
    20030,
    20031,
    20032,
    20064,
    20065,
    20066,
    20067,
    20068,
    20069,
    20070,
    20071,
    20072,
    20073,
    20074,
    20075,
    20076,
    20077,
    20078,
    20079,
    20080,
    20081,
    20082,
    20083,
    20084,
    20085,
    20086,
    20087,
    20088,
    20089,
    20090,
    20091,
    20092,
    21413,
    21414,
    21415,
    21416,
    21417,
    21418,
    21419,
    21420,
    21421,
    21422,
    21423,
    21453,
    21454,
    21455,
    21456,
    21457,
    21458,
    21459,
    21460,
    21461,
    21462,
    21463,
    21473,
    21474,
    21475,
    21476,
    21477,
    21478,
    21479,
    21480,
    21481,
    21482,
    21483,
    21896,
    21897,
    21898,
    21899,
    22171,
    22172,
    22173,
    22174,
    22175,
    22176,
    22177,
    22181,
    22182,
    22183,
    22184,
    22185,
    22186,
    22187,
    22191,
    22192,
    22193,
    22194,
    22195,
    22196,
    22197,
    25884,
    27205,
    27206,
    27207,
    27208,
    27209,
    27210,
    27211,
    27212,
    27213,
    27214,
    27215,
    27216,
    27217,
    27218,
    27219,
    27220,
    27221,
    27222,
    27223,
    27224,
    27225,
    27226,
    27227,
    27228,
    27229,
    27230,
    27231,
    27232,
    27391,
    27392,
    27393,
    27394,
    27395,
    27396,
    27397,
    27398,
    27492,
    28402,
    28403,
    28404,
    28405,
    28406,
    28407,
    28408,
    28409,
    28410,
    28411,
    28412,
    28413,
    28414,
    28415,
    28416,
    28417,
    28418,
    28419,
    28420,
    28421,
    28422,
    28423,
    28424,
    28425,
    28426,
    28427,
    28428,
    28429,
    28430,
    28431,
    28432,
    28462,
    28463,
    28464,
    28465,
    28466,
    28467,
    28468,
    28469,
    28470,
    28471,
    28472,
    28473,
    28474,
    28475,
    28476,
    28477,
    28478,
    28479,
    28480,
    28481,
    28482,
    28483,
    28484,
    28485,
    28486,
    28487,
    28488,
    28489,
    28490,
    28491,
    28492,
    29701,
    29702,
    30161,
    30162,
    30163,
    30164,
    30165,
    30166,
    30167,
    30168,
    30169,
    30170,
    30171,
    30172,
    30173,
    30174,
    30175,
    30176,
    30177,
    30178,
    30179,
    30800,
    31251,
    31252,
    31253,
    31254,
    31255,
    31256,
    31257,
    31258,
    31259,
    31275,
    31276,
    31277,
    31278,
    31279,
    31281,
    31282,
    31283,
    31284,
    31285,
    31286,
    31287,
    31288,
    31289,
    31290,
    31700
])

class Crs(object):
    """Initialize a CRS construct

        :param string crs: the Coordinate reference system. Examples:
          * EPSG:<EPSG code>
          * http://www.opengis.net/def/crs/EPSG/0/<EPSG code> (URI Style 1)
          * http://www.opengis.net/gml/srs/epsg.xml#<EPSG code> (URI Style 2)
          * urn:EPSG:geographicCRS:<epsg code>
          * urn:ogc:def:crs:EPSG::4326
          * urn:ogc:def:crs:EPSG:4326
        :param string axisorder: Force / override axisorder ('xy' or 'yx')
    """
    def __init__(self, crs, axisorder=None):
        self.id = crs
        self.naming_authority = None
        self.category = None
        self.type = None
        self.authority = None
        self.version = None
        self.code = -1
        self.axisorder = 'xy'
        self.encoding = "code"

        if axisorder is not None:  # forced axisorder
            self.axisorder = axisorder

        values = self.id.split(':')

        if self.id.find('/def/crs/') != -1: # URI Style 1
            self.encoding = "uri"
            vals = self.id.split('/')
            self.authority = vals[5].upper()
            self.code = int(vals[-1])
        elif self.id.find('#') != -1:  # URI Style 2
            self.encoding = "uri"
            vals = self.id.split('#')
            self.authority = vals[0].split('/')[-1].split('.')[0].upper()
            self.code = int(vals[-1])
        elif len(values) > 2:  # it's a URN style
            self.naming_authority = values[1]
            self.encoding = "urn"

            if len(values) == 3:  # bogus
                pass
            elif len(values) == 4:
                self.type = values[2]
            else:
                self.category = values[2]
                self.type = values[3]
                self.authority = values[4].upper()

            if len(values) == 7:  # version, even if empty, is included
                if values[5]:
                    self.version = values[5]

            # code is always the last value
            try:
                self.code = int(values[-1])
            except:
                self.code = values[-1]

        elif len(values) == 2:  # it's an authority:code code
            self.encoding = "code"
            self.authority = values[0].upper()
            self.code = int(values[1])

        # if the user has not forced the axisorder,
        # scan the list of codes that have an axis ordering of
        # yx and set axis order accordingly
        if axisorder is None:
            if self.code in axisorder_yx:
                self.axisorder = 'yx'


    def getcode(self):
        """Create for example "EPSG:4326" string and return back

        :returns: String code formated in "authority:code"
        """

        if self.authority is not None and self.code is not None:
            return '%s:%s' % (self.authority, self.code)
        return None

    def getcodeurn(self):
        """Create for example "urn:ogc:def:crs:EPSG::4326" string and return back

        :returns: String code formated in "urn:ogc:def:authority:code"
        """

        return 'urn:%s:def:crs:%s:%s:%s' % (
                    (self.naming_authority and self.naming_authority or "ogc"),
                                    (self.authority or ""),
                                    (self.version or ""),
                                    (self.code or ""))

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.getcodeurn() == other.getcodeurn()
        else:
            return False

    def __repr__(self):
        return self.getcodeurn()

########NEW FILE########
__FILENAME__ = csw
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2009 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

""" CSW request and response processor """

import warnings
import StringIO
import random
from urllib import urlencode
from urllib2 import urlopen

from owslib.util import OrderedDict

from owslib.etree import etree
from owslib import fes
from owslib import util
from owslib import ows
from owslib.iso import MD_Metadata
from owslib.fgdc import Metadata
from owslib.dif import DIF
from owslib.namespaces import Namespaces
from owslib.util import cleanup_namespaces, bind_url, add_namespaces

# default variables
outputformat = 'application/xml'

def get_namespaces():
    n = Namespaces()
    return n.get_namespaces()
namespaces = get_namespaces()
schema = 'http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd'
schema_location = '%s %s' % (namespaces['csw'], schema)

class CatalogueServiceWeb:
    """ csw request class """
    def __init__(self, url, lang='en-US', version='2.0.2', timeout=10, skip_caps=False):
        """

        Construct and process a GetCapabilities request

        Parameters
        ----------

        - url: the URL of the CSW
        - lang: the language (default is 'en-US')
        - version: version (default is '2.0.2')
        - timeout: timeout in seconds
        - skip_caps: whether to skip GetCapabilities processing on init (default is False)

        """

        self.url = url
        self.lang = lang
        self.version = version
        self.timeout = timeout
        self.service = 'CSW'
        self.exceptionreport = None
        self.owscommon = ows.OwsCommon('1.0.0')

        if not skip_caps:  # process GetCapabilities
            # construct request

            data = {'service': self.service, 'version': self.version, 'request': 'GetCapabilities'}

            self.request = '%s%s' % (bind_url(self.url), urlencode(data))
    
            self._invoke()
    
            if self.exceptionreport is None:
                # ServiceIdentification
                val = self._exml.find(util.nspath_eval('ows:ServiceIdentification', namespaces))
                self.identification=ows.ServiceIdentification(val,self.owscommon.namespace)
                # ServiceProvider
                val = self._exml.find(util.nspath_eval('ows:ServiceProvider', namespaces))
                self.provider=ows.ServiceProvider(val,self.owscommon.namespace)
                # ServiceOperations metadata 
                self.operations=[]
                for elem in self._exml.findall(util.nspath_eval('ows:OperationsMetadata/ows:Operation', namespaces)):
                    self.operations.append(ows.OperationsMetadata(elem, self.owscommon.namespace))
        
                # FilterCapabilities
                val = self._exml.find(util.nspath_eval('ogc:Filter_Capabilities', namespaces))
                self.filters=fes.FilterCapabilities(val)
 
    def describerecord(self, typename='csw:Record', format=outputformat):
        """

        Construct and process DescribeRecord request

        Parameters
        ----------

        - typename: the typename to describe (default is 'csw:Record')
        - format: the outputFormat (default is 'application/xml')
 
        """

        # construct request
        node0 = self._setrootelement('csw:DescribeRecord')
        node0.set('service', self.service)
        node0.set('version', self.version)
        node0.set('outputFormat', format)
        node0.set('schemaLanguage', namespaces['xs2'])
        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)
        etree.SubElement(node0, util.nspath_eval('csw:TypeName', namespaces)).text = typename

        self.request = node0

        self._invoke()

        # parse result
        # TODO: process the XML Schema (you're on your own for now with self.response)

    def getdomain(self, dname, dtype='parameter'):
        """

        Construct and process a GetDomain request

        Parameters
        ----------

        - dname: the value of the Parameter or Property to query
        - dtype: whether to query a parameter (parameter) or property (property)

        """

        # construct request
        dtypename = 'ParameterName'
        node0 = self._setrootelement('csw:GetDomain')
        node0.set('service', self.service)
        node0.set('version', self.version)
        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)
        if dtype == 'property':
            dtypename = 'PropertyName'
        etree.SubElement(node0, util.nspath_eval('csw:%s' % dtypename, namespaces)).text = dname

        self.request = node0

        self._invoke()

        if self.exceptionreport is None:
            self.results = {}

            val = self._exml.find(util.nspath_eval('csw:DomainValues', namespaces)).attrib.get('type')
            self.results['type'] = util.testXMLValue(val, True)

            val = self._exml.find(util.nspath_eval('csw:DomainValues/csw:%s' % dtypename, namespaces))
            self.results[dtype] = util.testXMLValue(val)

            # get the list of values associated with the Domain
            self.results['values'] = []

            for f in self._exml.findall(util.nspath_eval('csw:DomainValues/csw:ListOfValues/csw:Value', namespaces)):
                self.results['values'].append(util.testXMLValue(f))

    def getrecords(self, qtype=None, keywords=[], typenames='csw:Record', propertyname='csw:AnyText', bbox=None, esn='summary', sortby=None, outputschema=namespaces['csw'], format=outputformat, startposition=0, maxrecords=10, cql=None, xml=None, resulttype='results'):
        """

        Construct and process a  GetRecords request

        Parameters
        ----------

        - qtype: type of resource to query (i.e. service, dataset)
        - keywords: list of keywords
        - typenames: the typeNames to query against (default is csw:Record)
        - propertyname: the PropertyName to Filter against 
        - bbox: the bounding box of the spatial query in the form [minx,miny,maxx,maxy]
        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'summary')
        - sortby: property to sort results on
        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')
        - format: the outputFormat (default is 'application/xml')
        - startposition: requests a slice of the result set, starting at this position (default is 0)
        - maxrecords: the maximum number of records to return. No records are returned if 0 (default is 10)
        - cql: common query language text.  Note this overrides bbox, qtype, keywords
        - xml: raw XML request.  Note this overrides all other options
        - resulttype: the resultType 'hits', 'results', 'validate' (default is 'results')

        """

        warnings.warn("""Please use the updated 'getrecords2' method instead of 'getrecords'.  
        The 'getrecords' method will be upgraded to use the 'getrecords2' parameters
        in a future version of OWSLib.""")

        if xml is not None:
            self.request = etree.fromstring(xml)
            val = self.request.find(util.nspath_eval('csw:Query/csw:ElementSetName', namespaces))
            if val is not None:
                esn = util.testXMLValue(val)
        else:
            # construct request
            node0 = self._setrootelement('csw:GetRecords')
            if etree.__name__ != 'lxml.etree':  # apply nsmap manually
                node0.set('xmlns:ows', namespaces['ows'])
                node0.set('xmlns:gmd', namespaces['gmd'])
                node0.set('xmlns:dif', namespaces['dif'])
                node0.set('xmlns:fgdc', namespaces['fgdc'])
            node0.set('outputSchema', outputschema)
            node0.set('outputFormat', format)
            node0.set('version', self.version)
            node0.set('resultType', resulttype)
            node0.set('service', self.service)
            if startposition > 0:
                node0.set('startPosition', str(startposition))
            node0.set('maxRecords', str(maxrecords))
            node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)
    
            node1 = etree.SubElement(node0, util.nspath_eval('csw:Query', namespaces))
            node1.set('typeNames', typenames)
        
            etree.SubElement(node1, util.nspath_eval('csw:ElementSetName', namespaces)).text = esn
    
            self._setconstraint(node1, qtype, propertyname, keywords, bbox, cql, None)
    
            if sortby is not None:
                fes.setsortby(node1, sortby)
    
            self.request = node0

        self._invoke()
 
        if self.exceptionreport is None:
            self.results = {}
    
            # process search results attributes
            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsMatched')
            self.results['matches'] = int(util.testXMLValue(val, True))
            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsReturned')
            self.results['returned'] = int(util.testXMLValue(val, True))
            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('nextRecord')
            self.results['nextrecord'] = int(util.testXMLValue(val, True))
    
            # process list of matching records
            self.records = OrderedDict()

            self._parserecords(outputschema, esn)

    def getrecordbyid(self, id=[], esn='full', outputschema=namespaces['csw'], format=outputformat):
        """

        Construct and process a GetRecordById request

        Parameters
        ----------

        - id: the list of Ids
        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'full')
        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')
        - format: the outputFormat (default is 'application/xml')

        """

        # construct request
        data = {
            'service': self.service,
            'version': self.version,
            'request': 'GetRecordById',
            'outputFormat': format,
            'outputSchema': outputschema,
            'elementsetname': esn,
            'id': ','.join(id),
        }

        self.request = '%s%s' % (bind_url(self.url), urlencode(data))

        self._invoke()

        if self.exceptionreport is None:
            self.results = {}
            self.records = OrderedDict()
            self._parserecords(outputschema, esn)

    def getrecords2(self, constraints=[], sortby=None, typenames='csw:Record', esn='summary', outputschema=namespaces['csw'], format=outputformat, startposition=0, maxrecords=10, cql=None, xml=None, resulttype='results'):
        """

        Construct and process a  GetRecords request

        Parameters
        ----------

        - constraints: the list of constraints (OgcExpression from owslib.fes module)
        - sortby: an OGC SortBy object (SortBy from owslib.fes module)
        - typenames: the typeNames to query against (default is csw:Record)
        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'summary')        
        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')
        - format: the outputFormat (default is 'application/xml')
        - startposition: requests a slice of the result set, starting at this position (default is 0)
        - maxrecords: the maximum number of records to return. No records are returned if 0 (default is 10)
        - cql: common query language text.  Note this overrides bbox, qtype, keywords
        - xml: raw XML request.  Note this overrides all other options
        - resulttype: the resultType 'hits', 'results', 'validate' (default is 'results')

        """

        if xml is not None:
            self.request = etree.fromstring(xml)
            val = self.request.find(util.nspath_eval('csw:Query/csw:ElementSetName', namespaces))
            if val is not None:
                esn = util.testXMLValue(val)
        else:
            # construct request
            node0 = self._setrootelement('csw:GetRecords')
            if etree.__name__ != 'lxml.etree':  # apply nsmap manually
                node0.set('xmlns:ows', namespaces['ows'])
                node0.set('xmlns:gmd', namespaces['gmd'])
                node0.set('xmlns:dif', namespaces['dif'])
                node0.set('xmlns:fgdc', namespaces['fgdc'])
            node0.set('outputSchema', outputschema)
            node0.set('outputFormat', format)
            node0.set('version', self.version)
            node0.set('service', self.service)
            node0.set('resultType', resulttype)
            if startposition > 0:
                node0.set('startPosition', str(startposition))
            node0.set('maxRecords', str(maxrecords))        
            node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)

            node1 = etree.SubElement(node0, util.nspath_eval('csw:Query', namespaces))
            node1.set('typeNames', typenames)
        
            etree.SubElement(node1, util.nspath_eval('csw:ElementSetName', namespaces)).text = esn

            if any([len(constraints) > 0, cql is not None]): 
                node2 = etree.SubElement(node1, util.nspath_eval('csw:Constraint', namespaces))
                node2.set('version', '1.1.0')
                flt = fes.FilterRequest()
                if len(constraints) > 0:
                    node2.append(flt.setConstraintList(constraints))
                # Now add a CQL filter if passed in
                elif cql is not None:
                    etree.SubElement(node2, util.nspath_eval('csw:CqlText', namespaces)).text = cql
                
            if sortby is not None and isinstance(sortby, fes.SortBy):
                node1.append(sortby.toXML())

            self.request = node0

        self._invoke()
 
        if self.exceptionreport is None:
            self.results = {}
    
            # process search results attributes
            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsMatched')
            self.results['matches'] = int(util.testXMLValue(val, True))
            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsReturned')
            self.results['returned'] = int(util.testXMLValue(val, True))
            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('nextRecord')
            if val is not None:
                 self.results['nextrecord'] = int(util.testXMLValue(val, True))
            else:
                warnings.warn("""CSW Server did not supply a nextRecord value (it is optional), so the client
                should page through the results in another way.""")
                # For more info, see:
                # https://github.com/geopython/OWSLib/issues/100
                self.results['nextrecord'] = None

            # process list of matching records
            self.records = OrderedDict()

            self._parserecords(outputschema, esn)

    def transaction(self, ttype=None, typename='csw:Record', record=None, propertyname=None, propertyvalue=None, bbox=None, keywords=[], cql=None, identifier=None):
        """

        Construct and process a Transaction request

        Parameters
        ----------

        - ttype: the type of transaction 'insert, 'update', 'delete'
        - typename: the typename to describe (default is 'csw:Record')
        - record: the XML record to insert
        - propertyname: the RecordProperty/PropertyName to Filter against
        - propertyvalue: the RecordProperty Value to Filter against (for updates)
        - bbox: the bounding box of the spatial query in the form [minx,miny,maxx,maxy]
        - keywords: list of keywords
        - cql: common query language text.  Note this overrides bbox, qtype, keywords
        - identifier: record identifier.  Note this overrides bbox, qtype, keywords, cql

        """

        # construct request
        node0 = self._setrootelement('csw:Transaction')
        node0.set('version', self.version)
        node0.set('service', self.service)
        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)

        validtransactions = ['insert', 'update', 'delete']

        if ttype not in validtransactions:  # invalid transaction
            raise RuntimeError, 'Invalid transaction \'%s\'.' % ttype

        node1 = etree.SubElement(node0, util.nspath_eval('csw:%s' % ttype.capitalize(), namespaces))

        if ttype != 'update':  
            node1.set('typeName', typename)

        if ttype == 'insert':
            if record is None:
                raise RuntimeError, 'Nothing to insert.'
            node1.append(etree.fromstring(record))
 
        if ttype == 'update':
            if record is not None:
                node1.append(etree.fromstring(record))
            else:
                if propertyname is not None and propertyvalue is not None:
                    node2 = etree.SubElement(node1, util.nspath_eval('csw:RecordProperty', namespaces))
                    etree.SubElement(node2, util.nspath_eval('csw:Name', namespaces)).text = propertyname
                    etree.SubElement(node2, util.nspath_eval('csw:Value', namespaces)).text = propertyvalue
                    self._setconstraint(node1, qtype, propertyname, keywords, bbox, cql, identifier)

        if ttype == 'delete':
            self._setconstraint(node1, None, propertyname, keywords, bbox, cql, identifier)

        self.request = node0

        self._invoke()
        self.results = {}

        if self.exceptionreport is None:
            self._parsetransactionsummary()
            self._parseinsertresult()

    def harvest(self, source, resourcetype, resourceformat=None, harvestinterval=None, responsehandler=None):
        """

        Construct and process a Harvest request

        Parameters
        ----------

        - source: a URI to harvest
        - resourcetype: namespace identifying the type of resource
        - resourceformat: MIME type of the resource
        - harvestinterval: frequency of harvesting, in ISO8601
        - responsehandler: endpoint that CSW should responsd to with response

        """

        # construct request
        node0 = self._setrootelement('csw:Harvest')
        node0.set('version', self.version)
        node0.set('service', self.service)
        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)
        etree.SubElement(node0, util.nspath_eval('csw:Source', namespaces)).text = source
        etree.SubElement(node0, util.nspath_eval('csw:ResourceType', namespaces)).text = resourcetype
        if resourceformat is not None:
            etree.SubElement(node0, util.nspath_eval('csw:ResourceFormat', namespaces)).text = resourceformat
        if harvestinterval is not None:
            etree.SubElement(node0, util.nspath_eval('csw:HarvestInterval', namespaces)).text = harvestinterval
        if responsehandler is not None:
            etree.SubElement(node0, util.nspath_eval('csw:ResponseHandler', namespaces)).text = responsehandler
       
        self.request = node0

        self._invoke()
        self.results = {}

        if self.exceptionreport is None:
            val = self._exml.find(util.nspath_eval('csw:Acknowledgement', namespaces))
            if util.testXMLValue(val) is not None:
                ts = val.attrib.get('timeStamp')
                self.timestamp = util.testXMLValue(ts, True)
                id = val.find(util.nspath_eval('csw:RequestId', namespaces))
                self.id = util.testXMLValue(id) 
            else:
                self._parsetransactionsummary()
                self._parseinsertresult()

    def get_operation_by_name(self, name):
        """Return a named operation"""
        for item in self.operations:
            if item.name.lower() == name.lower():
                return item
        raise KeyError, "No operation named %s" % name

    def getService_urls(self, service_string=None):
        """

        Return easily identifiable URLs for all service types

        Parameters
        ----------

        - service_string: a URI to lookup

        """
        
        urls=[]
        for key,rec in self.records.iteritems():
            #create a generator object, and iterate through it until the match is found
            #if not found, gets the default value (here "none")
            url = next((d['url'] for d in rec.references if d['scheme'] == service_string), None)
            if url is not None:
                urls.append(url)
        return urls

    def _parseinsertresult(self):
        self.results['insertresults'] = []
        for i in self._exml.findall(util.nspath_eval('csw:InsertResult', namespaces)):
            for j in i.findall(util.nspath_eval('csw:BriefRecord/dc:identifier', namespaces)):
                self.results['insertresults'].append(util.testXMLValue(j))

    def _parserecords(self, outputschema, esn):
        if outputschema == namespaces['gmd']: # iso 19139
            for i in self._exml.findall('.//'+util.nspath_eval('gmd:MD_Metadata', namespaces)):
                val = i.find(util.nspath_eval('gmd:fileIdentifier/gco:CharacterString', namespaces))
                identifier = self._setidentifierkey(util.testXMLValue(val))
                self.records[identifier] = MD_Metadata(i)
        elif outputschema == namespaces['fgdc']: # fgdc csdgm
            for i in self._exml.findall('.//metadata'):
                val = i.find('idinfo/datasetid')
                identifier = self._setidentifierkey(util.testXMLValue(val))
                self.records[identifier] = Metadata(i)
        elif outputschema == namespaces['dif']: # nasa dif
            for i in self._exml.findall('.//'+util.nspath_eval('dif:DIF', namespaces)):
                val = i.find(util.nspath_eval('dif:Entry_ID', namespaces))
                identifier = self._setidentifierkey(util.testXMLValue(val))
                self.records[identifier] = DIF(i)
        else: # process default
            for i in self._exml.findall('.//'+util.nspath_eval('csw:%s' % self._setesnel(esn), namespaces)):
                val = i.find(util.nspath_eval('dc:identifier', namespaces))
                identifier = self._setidentifierkey(util.testXMLValue(val))
                self.records[identifier] = CswRecord(i)

    def _parsetransactionsummary(self):
        val = self._exml.find(util.nspath_eval('csw:TransactionSummary', namespaces))
        if val is not None:
            rid = val.attrib.get('requestId')
            self.results['requestid'] = util.testXMLValue(rid, True)
            ts = val.find(util.nspath_eval('csw:totalInserted', namespaces))
            self.results['inserted'] = int(util.testXMLValue(ts))
            ts = val.find(util.nspath_eval('csw:totalUpdated', namespaces))
            self.results['updated'] = int(util.testXMLValue(ts))
            ts = val.find(util.nspath_eval('csw:totalDeleted', namespaces))
            self.results['deleted'] = int(util.testXMLValue(ts))

    def _setesnel(self, esn):
        """ Set the element name to parse depending on the ElementSetName requested """
        el = 'Record'
        if esn == 'brief':
            el = 'BriefRecord'
        if esn == 'summary':
            el = 'SummaryRecord'
        return el

    def _setidentifierkey(self, el):
        if el is None: 
            return 'owslib_random_%i' % random.randint(1,65536)
        else:
            return el

    def _setrootelement(self, el):
        if etree.__name__ == 'lxml.etree':  # apply nsmap
            return etree.Element(util.nspath_eval(el, namespaces), nsmap=namespaces)
        else:
            return etree.Element(util.nspath_eval(el, namespaces))

    def _setconstraint(self, parent, qtype=None, propertyname='csw:AnyText', keywords=[], bbox=None, cql=None, identifier=None):
        if keywords or bbox is not None or qtype is not None or cql is not None or identifier is not None:
            node0 = etree.SubElement(parent, util.nspath_eval('csw:Constraint', namespaces))
            node0.set('version', '1.1.0')

            if identifier is not None:  # set identifier filter, overrides all other parameters
                flt = fes.FilterRequest()
                node0.append(flt.set(identifier=identifier))
            elif cql is not None:  # send raw CQL query
                # CQL passed, overrides all other parameters
                node1 = etree.SubElement(node0, util.nspath_eval('csw:CqlText', namespaces))
                node1.text = cql
            else:  # construct a Filter request
                flt = fes.FilterRequest()
                node0.append(flt.set(qtype=qtype, keywords=keywords, propertyname=propertyname,bbox=bbox))
    
    def _invoke(self):
        # do HTTP request

        if isinstance(self.request, basestring):  # GET KVP
            self.response = urlopen(self.request, timeout=self.timeout).read()
        else:
            xml_post_url = self.url
            # Get correct POST URL based on Operation list.
            for op in self.operations:
                post_verbs = filter(lambda x: x.get('type').lower() == 'post', op.methods)
                if len(post_verbs) > 1:
                    # Filter by constraints.  We must match a PostEncoding of "XML"
                    try:
                        xml_post_url = next(x for x in filter(list, ([pv.get('url') for const in pv.get('constraints') if const.name.lower() == "postencoding" and 'xml' in map(lambda x: x.lower(), const.values)] for pv in post_verbs)))[0]
                    except StopIteration:
                        # Well, just use the first one.
                        xml_post_url = post_verbs[0].get('url')
                elif len(post_verbs) == 1:
                    xml_post_url = post_verbs[0].get('url')

            self.request = cleanup_namespaces(self.request)
            # Add any namespaces used in the "typeNames" attribute of the
            # csw:Query element to the query's xml namespaces.
            for query in self.request.findall(util.nspath_eval('csw:Query', namespaces)):
                ns = query.get("typeNames", None)
                if ns is not None:
                    # Pull out "gmd" from something like "gmd:MD_Metadata" from the list
                    # of typenames
                    ns_keys = [x.split(':')[0] for x in ns.split(' ')]
                    self.request = add_namespaces(self.request, ns_keys)

            self.request = util.element_to_string(self.request, encoding='utf-8')

            self.response = util.http_post(xml_post_url, self.request, self.lang, self.timeout)

        # parse result see if it's XML
        self._exml = etree.parse(StringIO.StringIO(self.response))

        # it's XML.  Attempt to decipher whether the XML response is CSW-ish """
        valid_xpaths = [
            util.nspath_eval('ows:ExceptionReport', namespaces),
            util.nspath_eval('csw:Capabilities', namespaces),
            util.nspath_eval('csw:DescribeRecordResponse', namespaces),
            util.nspath_eval('csw:GetDomainResponse', namespaces),
            util.nspath_eval('csw:GetRecordsResponse', namespaces),
            util.nspath_eval('csw:GetRecordByIdResponse', namespaces),
            util.nspath_eval('csw:HarvestResponse', namespaces),
            util.nspath_eval('csw:TransactionResponse', namespaces)
        ]

        if self._exml.getroot().tag not in valid_xpaths:
            raise RuntimeError, 'Document is XML, but not CSW-ish'

        # check if it's an OGC Exception
        val = self._exml.find(util.nspath_eval('ows:Exception', namespaces))
        if val is not None:
            raise ows.ExceptionReport(self._exml, self.owscommon.namespace)
        else:
            self.exceptionreport = None

class CswRecord(object):
    """ Process csw:Record, csw:BriefRecord, csw:SummaryRecord """
    def __init__(self, record):

        if hasattr(record, 'getroot'):  # standalone document
            self.xml = etree.tostring(record.getroot())
        else:  # part of a larger document
            self.xml = etree.tostring(record)

        # check to see if Dublin Core record comes from
        # rdf:RDF/rdf:Description container
        # (child content model is identical)
        self.rdf = False
        rdf = record.find(util.nspath_eval('rdf:Description', namespaces))
        if rdf is not None:
            self.rdf = True
            record = rdf

        # some CSWs return records with multiple identifiers based on 
        # different schemes.  Use the first dc:identifier value to set
        # self.identifier, and set self.identifiers as a list of dicts
        val = record.find(util.nspath_eval('dc:identifier', namespaces))
        self.identifier = util.testXMLValue(val)

        self.identifiers = []
        for i in record.findall(util.nspath_eval('dc:identifier', namespaces)):
            d = {}
            d['scheme'] = i.attrib.get('scheme')
            d['identifier'] = i.text
            self.identifiers.append(d)

        val = record.find(util.nspath_eval('dc:type', namespaces))
        self.type = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:title', namespaces))
        self.title = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dct:alternative', namespaces))
        self.alternative = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dct:isPartOf', namespaces))
        self.ispartof = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dct:abstract', namespaces))
        self.abstract = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:date', namespaces))
        self.date = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dct:created', namespaces))
        self.created = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dct:issued', namespaces))
        self.issued = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:relation', namespaces))
        self.relation = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dct:temporal', namespaces))
        self.temporal = util.testXMLValue(val)

        self.uris = []  # list of dicts
        for i in record.findall(util.nspath_eval('dc:URI', namespaces)):
            uri = {}
            uri['protocol'] = util.testXMLValue(i.attrib.get('protocol'), True)
            uri['name'] = util.testXMLValue(i.attrib.get('name'), True)
            uri['description'] = util.testXMLValue(i.attrib.get('description'), True)
            uri['url'] = util.testXMLValue(i)

            self.uris.append(uri)

        self.references = []  # list of dicts
        for i in record.findall(util.nspath_eval('dct:references', namespaces)):
            ref = {}
            ref['scheme'] = util.testXMLValue(i.attrib.get('scheme'), True)
            ref['url'] = util.testXMLValue(i)

            self.references.append(ref)

        val = record.find(util.nspath_eval('dct:modified', namespaces))
        self.modified = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:creator', namespaces))
        self.creator = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:publisher', namespaces))
        self.publisher = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:coverage', namespaces))
        self.coverage = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:contributor', namespaces))
        self.contributor = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:language', namespaces))
        self.language = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:source', namespaces))
        self.source = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dct:rightsHolder', namespaces))
        self.rightsholder = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dct:accessRights', namespaces))
        self.accessrights = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dct:license', namespaces))
        self.license = util.testXMLValue(val)

        val = record.find(util.nspath_eval('dc:format', namespaces))
        self.format = util.testXMLValue(val)

        self.subjects = []
        for i in record.findall(util.nspath_eval('dc:subject', namespaces)):
            self.subjects.append(util.testXMLValue(i))

        self.rights = []
        for i in record.findall(util.nspath_eval('dc:rights', namespaces)):
            self.rights.append(util.testXMLValue(i))

        val = record.find(util.nspath_eval('dct:spatial', namespaces))
        self.spatial = util.testXMLValue(val)

        val = record.find(util.nspath_eval('ows:BoundingBox', namespaces))
        if val is not None:
            self.bbox = ows.BoundingBox(val, namespaces['ows'])
        else:
            self.bbox = None

        val = record.find(util.nspath_eval('ows:WGS84BoundingBox', namespaces))
        if val is not None:
            self.bbox_wgs84 = ows.WGS84BoundingBox(val, namespaces['ows'])
        else:
            self.bbox_wgs84 = None

########NEW FILE########
__FILENAME__ = dif
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2009 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

""" DIF metadata parser """

from owslib.etree import etree
from owslib import util
from owslib.namespaces import Namespaces

# default variables
def get_namespaces():
    n = Namespaces()
    ns = n.get_namespaces("dif")
    ns[None] = n.get_namespace("dif")
    return ns
namespaces = get_namespaces()

class DIF(object):
    """ Process DIF """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Entry_ID', namespaces))
        self.identifier = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Entry_Title', namespaces))
        self.title = util.testXMLValue(val)

        self.citation = []
        for el in md.findall(util.nspath_eval('dif:Data_Set_Citation', namespaces)):
            self.citation.append(Citation(el))

        self.personnel = []
        for el in md.findall(util.nspath_eval('dif:Personnel', namespaces)):
            self.personnel.append(util.testXMLValue(el))

        self.discipline = []
        for el in md.findall(util.nspath_eval('dif:Discipline', namespaces)):
            self.discipline.append(util.testXMLValue(el))

        self.parameters= []
        for el in md.findall(util.nspath_eval('dif:Parameters', namespaces)):
            self.parameters.append(util.testXMLValue(el))

        self.iso_topic_category  = []
        for el in md.findall(util.nspath_eval('dif:ISO_Topic_Category', namespaces)):
            self.iso_topic_category.append(util.testXMLValue(el))

        self.keyword = []
        for el in md.findall(util.nspath_eval('dif:Keyword', namespaces)):
            self.keyword.append(util.testXMLValue(el))

        self.sensor_name = []
        for el in md.findall(util.nspath_eval('dif:Sensor_Name', namespaces)):
            self.sensor_name.append(Name(el))

        self.source_name = []
        for el in md.findall(util.nspath_eval('dif:Source_Name', namespaces)):
            self.source_name.append(Name(el))

        self.temporal_coverage = []
        for el in md.findall(util.nspath_eval('dif:Temporal_Coverage', namespaces)):
            self.temporal_coverage.append(Temporal_Coverage(el))

        self.paleo_temporal_coverage = []
        for el in md.findall(util.nspath_eval('dif:Paleo_Temporal_Coverage', namespaces)):
            self.paleo_temporal_coverage.append(Paleo_Temporal_Coverage(el))

        self.data_set_progress = []
        for el in md.findall(util.nspath_eval('dif:Data_Set_Progress', namespaces)):
            self.data_set_progress.append(util.testXMLValue(el))

        self.spatial_coverage = []
        for el in md.findall(util.nspath_eval('dif:Spatial_Coverage', namespaces)):
            self.spatial_coverage.append(Spatial_Coverage(el))

        self.location = []
        for el in md.findall(util.nspath_eval('dif:location', namespaces)):
            self.location.append(util.testXMLValue(el))

        self.data_resolution = []
        for el in md.findall(util.nspath_eval('dif:Data_Resolution', namespaces)):
            self.data_resolution.append(Data_Resolution(el))

        self.project = []
        for el in md.findall(util.nspath_eval('dif:Project', namespaces)):
            self.project.append(Name(el))

        val = md.find(util.nspath_eval('dif:Quality', namespaces))
        self.quality = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Access_Constraints', namespaces))
        self.access_constraints = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Use_Constraints', namespaces))
        self.use_constraints = util.testXMLValue(val)

        self.language = []
        for el in md.findall(util.nspath_eval('dif:Data_Set_Language', namespaces)):
            self.language.append(util.testXMLValue(el))

        self.originating_center = []
        for el in md.findall(util.nspath_eval('dif:Originating_Center', namespaces)):
            self.originating_center.append(util.testXMLValue(el))

        self.data_center = []
        for el in md.findall(util.nspath_eval('dif:Data_Center', namespaces)):         
            self.data_center.append(Data_Center(el))

        self.distribution = []
        for el in md.findall(util.nspath_eval('dif:Distribution', namespaces)):     
            self.distribution.append(Distribution(el))

        self.multimedia_sample = []
        for el in md.findall(util.nspath_eval('dif:Multimedia_Sample', namespaces)):     
            self.multimedia_sample.append(Multimedia_Sample(el))

        val = md.find(util.nspath_eval('dif:Reference', namespaces))
        self.reference = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Summary', namespaces))
        self.summary = util.testXMLValue(val)

        self.related_url = []
        for el in md.findall(util.nspath_eval('dif:Related_URL', namespaces)):
            self.related_url.append(Related_URL(el))

        self.parent_dif = []
        for el in md.findall(util.nspath_eval('dif:Parent_DIF', namespaces)):
            self.parent_dif.append(util.testXMLValue(el))

        self.idn_node = []
        for el in md.findall(util.nspath_eval('dif:IDN_Node', namespaces)):
            self.idn_node.append(Name(el))

        val = md.find(util.nspath_eval('dif:Originating_Metadata_Node', namespaces))
        self.originating_metadata_node = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Metadata_Name', namespaces))
        self.metadata_name = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Metadata_Version', namespaces))
        self.metadata_version = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:DIF_Creation_Date', namespaces))
        self.dif_creation_date = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Last_DIF_Revision_Date', namespaces))
        self.last_dif_revision_date = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Future_DIF_Review_Date', namespaces))
        self.future_dif_review_date = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Private', namespaces))
        self.private = util.testXMLValue(val)

class Citation(object):
    """ Parse Data_Set_Citation """
    def __init__(self, el):
        val = el.find(util.nspath_eval('dif:Dataset_Creator', namespaces))
        self.creator = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Dataset_Title', namespaces))
        self.title = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Dataset_Series_Name', namespaces))
        self.series_name = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Dataset_Release_Date', namespaces))
        self.release_date = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Dataset_Release_Place', namespaces))
        self.release_place = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Dataset_Publisher', namespaces))
        self.publisher = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Version', namespaces))
        self.version = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Issue_Identification', namespaces))
        self.issue_identification = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Data_Presentation_Form', namespaces))
        self.presentation_form = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Other_Citation_Details', namespaces))
        self.details = util.testXMLValue(val)

        val = el.find(util.nspath_eval('dif:Online_Resource', namespaces))
        self.onlineresource = util.testXMLValue(val)

class Personnel(object):
    """ Process Personnel """
    def __init__(self, md):
        self.role = []
        for el in md.findall(util.nspath_eval('dif:Role', namespaces)):
            self.role.append(util.testXMLValue(el))

        val = md.find(util.nspath_eval('dif:First_Name', namespaces))
        self.first_name = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Middle_Name', namespaces))
        self.middle_name = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Last_Name', namespaces))
        self.last_name = util.testXMLValue(val)

        self.email = []
        for el in md.findall(util.nspath_eval('dif:Email', namespaces)):
            self.email.append(util.testXMLValue(el))

        self.phone = []
        for el in md.findall(util.nspath_eval('dif:Phone', namespaces)):
            self.phone.append(util.testXMLValue(el))

        self.fax = []
        for el in md.findall(util.nspath_eval('dif:Fax', namespaces)):
            self.fax.append(util.testXMLValue(el))

        val = md.find(util.nspath_eval('dif:Contact_Address', namespaces))
        self.contact_address = Contact_Address(val)

class Contact_Address(object):
    """ Process Contact_Address """
    def __init__(self, md):
        self.address = []
        for el in md.findall(util.nspath_eval('dif:Address', namespaces)):
            self.address.append(util.testXMLValue(el))

        val = md.find(util.nspath_eval('dif:City', namespaces))
        self.city = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Province_or_State', namespaces))
        self.province_or_state = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Postal_Code', namespaces))
        self.postal_code = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Country', namespaces))
        self.country = util.testXMLValue(val)

class Discipline(object):
    """ Process Discipline """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Discipline_Name', namespaces))
        self.name = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Subdiscipline', namespaces))
        self.subdiscipline = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Detailed_Subdiscipline', namespaces))
        self.detailed_subdiscipline = util.testXMLValue(val)

class Parameters(object):
    """ Process Parameters """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Category', namespaces))
        self.category = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Topic', namespaces))
        self.topic = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Term', namespaces))
        self.term = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Variable_Level_1', namespaces))
        self.variable_l1 = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Variable_Level_2', namespaces))
        self.variable_l2 = util.testXMLValue(val)
    
        val = md.find(util.nspath_eval('dif:Variable_Level_3', namespaces))
        self.variable_l3 = util.testXMLValue(val)
 
        val = md.find(util.nspath_eval('dif:Detailed_Variable', namespaces))
        self.detailed_variable = util.testXMLValue(val)

class Name(object):
    """ Process Sensor_Name, Source_Name, Project, IDN_Node """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Short_Name', namespaces))
        self.short_name = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Long_Name', namespaces))
        self.long_name = util.testXMLValue(val)

class Temporal_Coverage(object):
    """ Process Temporal_Coverage """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Start_Date', namespaces))
        self.start_date = util.testXMLValue(val)
        
        val = md.find(util.nspath_eval('dif:End_Date', namespaces))
        self.end_date = util.testXMLValue(val)

class Paleo_Temporal_Coverage(object):
    """ Process Paleo_Temporal_Coverage """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Paleo_Start_Date', namespaces))
        self.paleo_start_date = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Paleo_End_Date', namespaces))
        self.paleo_end_date = util.testXMLValue(val)

        self.chronostratigraphic_unit = []
        for el in md.findall(util.nspath_eval('dif:Chronostratigraphic_Unit', namespaces)):
            self.chronostratigraphic_unit.append(Chronostratigraphic_Unit(el))

class Chronostratigraphic_Unit(object):
    """ Process Chronostratigraphic_Unit """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Eon', namespaces))
        self.eon = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Era', namespaces))
        self.era = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Period', namespaces))
        self.period = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Epoch', namespaces))
        self.epoch = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Stage', namespaces))
        self.stage = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Detailed_Classification', namespaces))
        self.detailed_classification = util.testXMLValue(val)

class Spatial_Coverage(object):
    """ Process Spatial_Coverage """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Southernmost_Latitude', namespaces))
        self.miny = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Northernmost_Latitude', namespaces))
        self.maxy = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Westernmost_Latitude', namespaces))
        self.minx = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Easternmost_Latitude', namespaces))
        self.maxx = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Minimum_Altitude', namespaces))
        self.minz = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Maximum_Altitude', namespaces))
        self.maxz = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Minimum_Depth', namespaces))
        self.mindepth = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Maximum_Depth', namespaces))
        self.maxdepth = util.testXMLValue(val)

class Location(object):
    """ Process Location """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Location_Category', namespaces))
        self.category = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Location_Category', namespaces))
        self.type = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Location_Subregion1', namespaces))
        self.subregion1 = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Location_Subregion2', namespaces))
        self.subregion2 = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Location_Subregion3', namespaces))
        self.subregion3 = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Detailed_Location', namespaces))
        self.detailed_location = util.testXMLValue(val)

class Data_Resolution(object):
    """ Process Data_Resolution"""
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Latitude_Resolution', namespaces))
        self.y = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Longitude_Resolution', namespaces))
        self.x = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Horizontal_Resolution_Range', namespaces))
        self.horizontal_res_range = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Vertical_Resolution', namespaces))
        self.vertical_res = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Vertical_Resolution_Range', namespaces))
        self.vertical_res_range = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Temporal_Resolution', namespaces))
        self.temporal_res = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Temporal_Resolution_Range', namespaces))
        self.temporal_res_range = util.testXMLValue(val)

class Data_Center(object):
    """ Process Data_Center """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Data_Center_Name', namespaces))
        self.name = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Data_Center_URL', namespaces))
        self.url = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Data_Set_ID', namespaces))
        self.data_set_id = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Personnel', namespaces))
        self.personnel = util.testXMLValue(val)

class Distribution(object):
    """ Process Distribution """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Distribution_Media', namespaces))
        self.media = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Distribution_Size', namespaces))
        self.size = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Distribution_Format', namespaces))
        self.format = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Fees', namespaces))
        self.fees = util.testXMLValue(val)

class Multimedia_Sample(object):
    """ Process Multimedia_Sample """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:File', namespaces))
        self.file = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:URL', namespaces))
        self.url = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Format', namespaces))
        self.format = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Caption', namespaces))
        self.caption = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Description', namespaces))
        self.description = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Visualization_URL', namespaces))
        self.vis_url = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Visualization_Type', namespaces))
        self.vis_type = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Visualization_Subtype', namespaces))
        self.vis_subtype = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Visualization_Duration', namespaces))
        self.vis_duration = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Visualization_File_Size', namespaces))
        self.file_size = util.testXMLValue(val)

class Related_URL(object):
    """ Process Related_URL """
    def __init__(self, md):
        self.content_type = []
        for el in md.findall(util.nspath_eval('dif:URL_Content_Type', namespaces)):
            self.content_type.append(URL_Content_Type(el))

        val = md.find(util.nspath_eval('dif:URL', namespaces))
        self.url = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:Description', namespaces))
        self.description = util.testXMLValue(val)

class URL_Content_Type(object):
    """ Process URL_Content_Type """
    def __init__(self, md):
        val = md.find(util.nspath_eval('dif:Type', namespaces))
        self.type = util.testXMLValue(val)

        val = md.find(util.nspath_eval('dif:SubType', namespaces))
        self.subtype = util.testXMLValue(val)












########NEW FILE########
__FILENAME__ = etree
# =============================================================================
# OWSLib. Copyright (C) 2005 Sean C. Gillies
#
# Contact email: sgillies@frii.com
# =============================================================================


def patch_well_known_namespaces(etree_module):

    import warnings
    from owslib.namespaces import Namespaces
    ns = Namespaces()

    """Monkey patches the etree module to add some well-known namespaces."""

    try:
        register_namespace = etree_module.register_namespace
    except AttributeError:
        try:
            etree_module._namespace_map

            def register_namespace(prefix, uri):
                etree_module._namespace_map[uri] = prefix
        except AttributeError:
            def register_namespace(prefix, uri):
                pass
            warnings.warn("Only 'lxml.etree' >= 2.3 and 'xml.etree.ElementTree' >= 1.3 are fully supported!")

    for k, v in ns.get_namespaces().iteritems():
        register_namespace(k, v)

# try to find lxml or elementtree
try:
    from lxml import etree
except ImportError:
    try:
        # Python 2.5 with ElementTree included
        import xml.etree.ElementTree as etree
    except ImportError:
        try:
            # Python < 2.5 with ElementTree installed
            import elementtree.ElementTree as etree
        except ImportError:
            raise RuntimeError('You need either lxml or ElementTree to use OWSLib!')

patch_well_known_namespaces(etree)

########NEW FILE########
__FILENAME__ = wfs100
# =============================================================================
# OWSLib. Copyright (C) 2005 Sean C. Gillies
#
# Contact email: sgillies@frii.com
#
# $Id: wfs.py 503 2006-02-01 17:09:12Z dokai $
# =============================================================================

import cgi
from cStringIO import StringIO
from urllib import urlencode
from urllib2 import urlopen
from owslib.util import openURL, testXMLValue, extract_xml_list, ServiceException, xmltag_split
from owslib.etree import etree
from owslib.fgdc import Metadata
from owslib.iso import MD_Metadata
from owslib.crs import Crs
from owslib.namespaces import Namespaces
from owslib.util import log

n = Namespaces()
WFS_NAMESPACE = n.get_namespace("wfs")
OGC_NAMESPACE = n.get_namespace("ogc")


#TODO: use nspath in util.py
def nspath(path, ns=WFS_NAMESPACE):
    """
    Prefix the given path with the given namespace identifier.
    
    Parameters
    ----------
    path : string
        ElementTree API Compatible path expression

    ns : string
        The XML namespace. Defaults to WFS namespace.
    """
    components = []
    for component in path.split("/"):
        if component != '*':
            component = "{%s}%s" % (ns, component)
        components.append(component)
    return "/".join(components)


class WebFeatureService_1_0_0(object):
    """Abstraction for OGC Web Feature Service (WFS).

    Implements IWebFeatureService.
    """
    def __new__(self,url, version, xml, parse_remote_metadata=False):
        """ overridden __new__ method 
        
        @type url: string
        @param url: url of WFS capabilities document
        @type xml: string
        @param xml: elementtree object
        @type parse_remote_metadata: boolean
        @param parse_remote_metadata: whether to fully process MetadataURL elements
        @return: initialized WebFeatureService_1_0_0 object
        """
        obj=object.__new__(self)
        obj.__init__(url, version, xml, parse_remote_metadata)
        return obj
    
    def __getitem__(self,name):
        ''' check contents dictionary to allow dict like access to service layers'''
        if name in self.__getattribute__('contents').keys():
            return self.__getattribute__('contents')[name]
        else:
            raise KeyError, "No content named %s" % name
    
    
    def __init__(self, url, version, xml=None, parse_remote_metadata=False):
        """Initialize."""
        self.url = url
        self.version = version
        self._capabilities = None
        reader = WFSCapabilitiesReader(self.version)
        if xml:
            self._capabilities = reader.readString(xml)
        else:
            self._capabilities = reader.read(self.url)
        self._buildMetadata(parse_remote_metadata)
    
    def _buildMetadata(self, parse_remote_metadata=False):
        '''set up capabilities metadata objects: '''
        
        #serviceIdentification metadata
        serviceelem=self._capabilities.find(nspath('Service'))
        self.identification=ServiceIdentification(serviceelem, self.version)  
    
        #serviceProvider metadata
        self.provider=ServiceProvider(serviceelem)   
        
        #serviceOperations metadata 
        self.operations=[]
        for elem in self._capabilities.find(nspath('Capability/Request'))[:]:
            self.operations.append(OperationMetadata(elem))
                   
        #serviceContents metadata: our assumption is that services use a top-level 
        #layer as a metadata organizer, nothing more. 
        
        self.contents={} 
        featuretypelist=self._capabilities.find(nspath('FeatureTypeList'))
        features = self._capabilities.findall(nspath('FeatureTypeList/FeatureType'))
        for feature in features:
            cm=ContentMetadata(feature, featuretypelist, parse_remote_metadata)
            self.contents[cm.id]=cm       
        
        #exceptions
        self.exceptions = [f.text for f \
                in self._capabilities.findall('Capability/Exception/Format')]
      
    def getcapabilities(self, timeout=30):
        """Request and return capabilities document from the WFS as a 
        file-like object.
        NOTE: this is effectively redundant now"""
        reader = WFSCapabilitiesReader(self.version)
        return urlopen(reader.capabilities_url(self.url), timeout=timeout)
    
    def items(self):
        '''supports dict-like items() access'''
        items=[]
        for item in self.contents:
            items.append((item,self.contents[item]))
        return items
    
    def getfeature(self, typename=None, filter=None, bbox=None, featureid=None,
                   featureversion=None, propertyname=['*'], maxfeatures=None,
                   srsname=None, outputFormat=None, method='{http://www.opengis.net/wfs}Get'):
        """Request and return feature data as a file-like object.
        
        Parameters
        ----------
        typename : list
            List of typenames (string)
        filter : string 
            XML-encoded OGC filter expression.
        bbox : tuple
            (left, bottom, right, top) in the feature type's coordinates.
        featureid : list
            List of unique feature ids (string)
        featureversion : string
            Default is most recent feature version.
        propertyname : list
            List of feature property names. '*' matches all.
        maxfeatures : int
            Maximum number of features to be returned.
        method : string
            Qualified name of the HTTP DCP method to use.
        srsname: string
            EPSG code to request the data in
        outputFormat: string (optional)
            Requested response format of the request.

            
        There are 3 different modes of use

        1) typename and bbox (simple spatial query)
        2) typename and filter (more expressive)
        3) featureid (direct access to known features)
        """
        try:
            base_url = next((m.get('url') for m in self.getOperationByName('GetFeature').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url
        request = {'service': 'WFS', 'version': self.version, 'request': 'GetFeature'}

        # check featureid
        if featureid:
            request['featureid'] = ','.join(featureid)
        elif bbox and typename:
            request['bbox'] = ','.join([repr(x) for x in bbox])
        elif filter and typename:
            request['filter'] = str(filter)
        
        if srsname:
            request['srsname'] = str(srsname)
            
        assert len(typename) > 0
        request['typename'] = ','.join(typename)
        
        if propertyname:
            request['propertyname'] = ','.join(propertyname)
        if featureversion: request['featureversion'] = str(featureversion)
        if maxfeatures: request['maxfeatures'] = str(maxfeatures)

        if outputFormat is not None:
            request["outputFormat"] = outputFormat

        data = urlencode(request)
        log.debug("Making request: %s?%s" % (base_url, data))
        u = openURL(base_url, data, method)
        
        
        # check for service exceptions, rewrap, and return
        # We're going to assume that anything with a content-length > 32k
        # is data. We'll check anything smaller.

        try:
            length = int(u.info()['Content-Length'])
            have_read = False
        except (KeyError, AttributeError):
            data = u.read()
            have_read = True
            length = len(data)
     
        if length < 32000:
            if not have_read:
                data = u.read()

            try:
                tree = etree.fromstring(data)
            except BaseException:
                # Not XML
                return StringIO(data)
            else:
                if tree.tag == "{%s}ServiceExceptionReport" % OGC_NAMESPACE:
                    se = tree.find(nspath('ServiceException', OGC_NAMESPACE))
                    raise ServiceException(str(se.text).strip())
                else:
                    return StringIO(data)
        else:
            if have_read:
                return StringIO(data)
            return u

    def getOperationByName(self, name):
        """Return a named content item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError, "No operation named %s" % name

class ServiceIdentification(object):
    ''' Implements IServiceIdentificationMetadata '''
    
    def __init__(self, infoset, version):
        self._root=infoset
        self.type = testXMLValue(self._root.find(nspath('Name')))
        self.version = version
        self.title = testXMLValue(self._root.find(nspath('Title')))
        self.abstract = testXMLValue(self._root.find(nspath('Abstract')))
        self.keywords = [f.text for f in self._root.findall(nspath('Keywords'))]
        self.fees = testXMLValue(self._root.find(nspath('Fees')))
        self.accessconstraints = testXMLValue(self._root.find(nspath('AccessConstraints')))

class ServiceProvider(object):
    ''' Implements IServiceProviderMetatdata '''
    def __init__(self, infoset):
        self._root = infoset
        self.name = testXMLValue(self._root.find(nspath('Name')))
        self.url = testXMLValue(self._root.find(nspath('OnlineResource')))
        self.keywords = extract_xml_list(self._root.find(nspath('Keywords')))

class ContentMetadata:
    """Abstraction for WFS metadata.
    
    Implements IMetadata.
    """

    def __init__(self, elem, parent, parse_remote_metadata=False, timeout=30):
        """."""
        self.id = testXMLValue(elem.find(nspath('Name')))
        self.title = testXMLValue(elem.find(nspath('Title')))
        self.abstract = testXMLValue(elem.find(nspath('Abstract')))
        self.keywords = [f.text for f in elem.findall(nspath('Keywords'))]

        # bboxes
        self.boundingBox = None
        b = elem.find(nspath('BoundingBox'))
        if b is not None:
            self.boundingBox = (float(b.attrib['minx']),float(b.attrib['miny']),
                    float(b.attrib['maxx']), float(b.attrib['maxy']),
                    b.attrib['SRS'])
        self.boundingBoxWGS84 = None
        b = elem.find(nspath('LatLongBoundingBox'))
        if b is not None:
            self.boundingBoxWGS84 = (
                    float(b.attrib['minx']),float(b.attrib['miny']),
                    float(b.attrib['maxx']), float(b.attrib['maxy']),
                    )
        # crs options
        self.crsOptions = [Crs(srs.text) for srs in elem.findall(nspath('SRS'))]

        # verbs
        self.verbOptions = [op.tag for op \
            in parent.findall(nspath('Operations/*'))]
        self.verbOptions + [op.tag for op \
            in elem.findall(nspath('Operations/*')) \
            if op.tag not in self.verbOptions]
        
        #others not used but needed for iContentMetadata harmonisation
        self.styles=None
        self.timepositions=None
        self.defaulttimeposition=None

        # MetadataURLs
        self.metadataUrls = []
        for m in elem.findall(nspath('MetadataURL')):
            metadataUrl = {
                'type': testXMLValue(m.attrib['type'], attrib=True),
                'format': testXMLValue(m.find('Format')),
                'url': testXMLValue(m)
            }

            if metadataUrl['url'] is not None and parse_remote_metadata:  # download URL
                try:
                    content = urlopen(metadataUrl['url'], timeout=timeout)
                    doc = etree.parse(content)
                    if metadataUrl['type'] is not None:
                        if metadataUrl['type'] == 'FGDC':
                            metadataUrl['metadata'] = Metadata(doc)
                        if metadataUrl['type'] == 'TC211':
                            metadataUrl['metadata'] = MD_Metadata(doc)
                except Exception, err:
                    metadataUrl['metadata'] = None

            self.metadataUrls.append(metadataUrl)


class OperationMetadata:
    """Abstraction for WFS metadata.
    
    Implements IMetadata.
    """
    def __init__(self, elem):
        """."""
        self.name = xmltag_split(elem.tag)
        # formatOptions
        self.formatOptions = [f.tag for f in elem.findall(nspath('ResultFormat/*'))]
        self.methods = []
        for verb in elem.findall(nspath('DCPType/HTTP/*')):
            url = verb.attrib['onlineResource']
            self.methods.append({'type' : xmltag_split(verb.tag), 'url': url})


class WFSCapabilitiesReader(object):
    """Read and parse capabilities document into a lxml.etree infoset
    """

    def __init__(self, version='1.0'):
        """Initialize"""
        self.version = version
        self._infoset = None

    def capabilities_url(self, service_url):
        """Return a capabilities url
        """
        qs = []
        if service_url.find('?') != -1:
            qs = cgi.parse_qsl(service_url.split('?')[1])

        params = [x[0] for x in qs]

        if 'service' not in params:
            qs.append(('service', 'WFS'))
        if 'request' not in params:
            qs.append(('request', 'GetCapabilities'))
        if 'version' not in params:
            qs.append(('version', self.version))

        urlqs = urlencode(tuple(qs))
        return service_url.split('?')[0] + '?' + urlqs

    def read(self, url, timeout=30):
        """Get and parse a WFS capabilities document, returning an
        instance of WFSCapabilitiesInfoset

        Parameters
        ----------
        url : string
            The URL to the WFS capabilities document.
        timeout : number
            A timeout value (in seconds) for the request.
        """
        request = self.capabilities_url(url)
        u = urlopen(request, timeout=timeout)
        return etree.fromstring(u.read())

    def readString(self, st):
        """Parse a WFS capabilities document, returning an
        instance of WFSCapabilitiesInfoset

        string should be an XML capabilities document
        """
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        return etree.fromstring(st)
    

########NEW FILE########
__FILENAME__ = wfs110
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2011 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

import cgi
from cStringIO import StringIO
from urllib import urlencode
from urllib2 import urlopen
from owslib.util import openURL, testXMLValue, nspath_eval, ServiceException
from owslib.etree import etree
from owslib.fgdc import Metadata
from owslib.iso import MD_Metadata
from owslib.ows import *
from owslib.fes import *
from owslib.crs import Crs
from owslib.feature import WebFeatureService_
from owslib.namespaces import Namespaces
from owslib.util import log

def get_namespaces():
    n = Namespaces()
    return n.get_namespaces(["gml","ogc","ows","wfs"])
namespaces = get_namespaces()

class WebFeatureService_1_1_0(WebFeatureService_):
    """Abstraction for OGC Web Feature Service (WFS).

    Implements IWebFeatureService.
    """
    def __new__(self,url, version, xml, parse_remote_metadata=False):
        """ overridden __new__ method

        @type url: string
        @param url: url of WFS capabilities document
        @type xml: string
        @param xml: elementtree object
        @type parse_remote_metadata: boolean
        @param parse_remote_metadata: whether to fully process MetadataURL elements
        @return: initialized WebFeatureService_1_1_0 object
        """
        obj=object.__new__(self)
        obj.__init__(url, version, xml, parse_remote_metadata)
        return obj

    def __getitem__(self,name):
        ''' check contents dictionary to allow dict like access to service layers'''
        if name in self.__getattribute__('contents').keys():
            return self.__getattribute__('contents')[name]
        else:
            raise KeyError, "No content named %s" % name


    def __init__(self, url, version, xml=None, parse_remote_metadata=False):
        """Initialize."""
        self.url = url
        self.version = version
        self._capabilities = None
        self.owscommon = OwsCommon('1.0.0')
        reader = WFSCapabilitiesReader(self.version)
        if xml:
            self._capabilities = reader.readString(xml)
        else:
            self._capabilities = reader.read(self.url)
        self._buildMetadata(parse_remote_metadata)

    def _buildMetadata(self, parse_remote_metadata=False):
        '''set up capabilities metadata objects: '''

        # ServiceIdentification
        val = self._capabilities.find(util.nspath_eval('ows:ServiceIdentification', namespaces))
        self.identification=ServiceIdentification(val,self.owscommon.namespace)
        # ServiceProvider
        val = self._capabilities.find(util.nspath_eval('ows:ServiceProvider', namespaces))
        self.provider=ServiceProvider(val,self.owscommon.namespace)
        # ServiceOperations metadata
        self.operations=[]
        for elem in self._capabilities.findall(util.nspath_eval('ows:OperationsMetadata/ows:Operation', namespaces)):
            self.operations.append(OperationsMetadata(elem, self.owscommon.namespace))

        # FilterCapabilities
        val = self._capabilities.find(util.nspath_eval('ogc:Filter_Capabilities', namespaces))
        self.filters=FilterCapabilities(val)

        #serviceContents metadata: our assumption is that services use a top-level
        #layer as a metadata organizer, nothing more.

        self.contents={}
        features = self._capabilities.findall(nspath_eval('wfs:FeatureTypeList/wfs:FeatureType', namespaces))
        for feature in features:
            cm=ContentMetadata(feature, parse_remote_metadata)
            self.contents[cm.id]=cm

        #exceptions
        self.exceptions = [f.text for f \
                in self._capabilities.findall('Capability/Exception/Format')]

    def getcapabilities(self, timeout=30):
        """Request and return capabilities document from the WFS as a
        file-like object.
        NOTE: this is effectively redundant now"""
        reader = WFSCapabilitiesReader(self.version)
        return urlopen(reader.capabilities_url(self.url), timeout=timeout)

    def items(self):
        '''supports dict-like items() access'''
        items=[]
        for item in self.contents:
            items.append((item,self.contents[item]))
        return items

    def getfeature(self, typename=None, filter=None, bbox=None, featureid=None,
                   featureversion=None, propertyname=['*'], maxfeatures=None,
                   srsname=None, outputFormat=None, method='Get'):
        """Request and return feature data as a file-like object.

        Parameters
        ----------
        typename : list
            List of typenames (string)
        filter : string
            XML-encoded OGC filter expression.
        bbox : tuple
            (left, bottom, right, top) in the feature type's coordinates.
        featureid : list
            List of unique feature ids (string)
        featureversion : string
            Default is most recent feature version.
        propertyname : list
            List of feature property names. '*' matches all.
        maxfeatures : int
            Maximum number of features to be returned.
        method : string
            Qualified name of the HTTP DCP method to use.
        srsname: string
            EPSG code to request the data in
        outputFormat: string (optional)
            Requested response format of the request.

        There are 3 different modes of use

        1) typename and bbox (simple spatial query). It is assumed, that
            bbox coordinates are given *always* in the east,north order
        2) typename and filter (more expressive)
        3) featureid (direct access to known features)
        """
        try:
            base_url = next((m.get('url') for m in self.getOperationByName('GetFeature').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url
        request = {'service': 'WFS', 'version': self.version, 'request': 'GetFeature'}

        if not isinstance(typename, list):
            typename = [typename]

        if srsname is not None:
            # check, if desired SRS is supported by the service for this typename
            if typename is not None:
                # convert srsname string to Crs object found in GetCaps
                srsnameobj = self.getSRS(srsname, typename[0])
                if srsnameobj is not None:
                    request['srsname'] = srsnameobj.id
                else:
                    options = ", ".join(map(lambda x: x.id, self.contents[typename[0]].crsOptions))
                    raise ServiceException("SRSNAME %s not supported.  Options: %s" % (srsname, options))
            else:
                request['srsname'] = str(srsname)

        # check featureid
        if featureid:
            request['featureid'] = ','.join(featureid)

        # bbox
        elif bbox and typename:
            request["bbox"] = self.getBBOXKVP(bbox, typename)

        # or filter
        elif filter and typename:
            request['filter'] = str(filter)

        assert len(typename) > 0
        request['typename'] = ','.join(typename)

        if propertyname is not None:
            if not isinstance(propertyname, list):
                propertyname = [propertyname]
            request['propertyname'] = ','.join(propertyname)

        if featureversion is not None:
            request['featureversion'] = str(featureversion)
        if maxfeatures is not None:
            request['maxfeatures'] = str(maxfeatures)
        if outputFormat is not None:
            request["outputFormat"] = outputFormat

        data = urlencode(request)
        log.debug("Making request: %s?%s" % (base_url, data))
        u = openURL(base_url, data, method)

        # check for service exceptions, rewrap, and return
        # We're going to assume that anything with a content-length > 32k
        # is data. We'll check anything smaller.
        try:
            length = int(u.info()['Content-Length'])
            have_read = False
        except (KeyError, AttributeError):
            data = u.read()
            have_read = True
            length = len(data)

        if length < 32000:
            if not have_read:
                data = u.read()

            try:
                tree = etree.fromstring(data)
            except BaseException:
                # Not XML
                return StringIO(data)
            else:
                if tree.tag == "{%s}ServiceExceptionReport" % namespaces["ogc"]:
                    se = tree.find(nspath_eval('ServiceException', namespaces["ogc"]))
                    raise ServiceException(str(se.text).strip())
                else:
                    return StringIO(data)
        else:
            if have_read:
                return StringIO(data)
            return u

    def getOperationByName(self, name):
        """Return a named content item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError, "No operation named %s" % name



class ContentMetadata:
    """Abstraction for WFS metadata.

    Implements IMetadata.
    """

    def __init__(self, elem, parse_remote_metadata=False, timeout=30):
        """."""
        self.id = testXMLValue(elem.find(nspath_eval('wfs:Name', namespaces)))
        self.title = testXMLValue(elem.find(nspath_eval('wfs:Title', namespaces)))
        self.abstract = testXMLValue(elem.find(nspath_eval('wfs:Abstract', namespaces)))
        self.keywords = [f.text for f in elem.findall(nspath_eval('ows:Keywords/ows:Keyword', namespaces))]

        # bbox
        self.boundingBoxWGS84 = None
        b = BoundingBox(elem.find(nspath_eval('ows:WGS84BoundingBox', namespaces)), namespaces['ows'])
        if b is not None:
            self.boundingBoxWGS84 = (
                    float(b.minx), float(b.miny),
                    float(b.maxx), float(b.maxy),
                    )
        # crs options
        self.crsOptions = [Crs(srs.text) for srs in elem.findall(nspath_eval('wfs:OtherSRS', namespaces))]
        dsrs = testXMLValue(elem.find(nspath_eval('wfs:DefaultSRS', namespaces)))
        if dsrs is not None:  # first element is default srs
            self.crsOptions.insert(0, Crs(dsrs))

        # verbs
        self.verbOptions = [op.text for op in elem.findall(nspath_eval('wfs:Operations/wfs:Operation', namespaces))]

        # output formats
        self.outputFormats = [op.text for op in elem.findall(nspath_eval('wfs:OutputFormats/wfs:Format', namespaces))]

        # MetadataURLs
        self.metadataUrls = []
        for m in elem.findall(nspath_eval('wfs:MetadataURL', namespaces)):
            metadataUrl = {
                'type': testXMLValue(m.attrib['type'], attrib=True),
                'format': testXMLValue(m.find('Format')),
                'url': testXMLValue(m)
            }

            if metadataUrl['url'] is not None and parse_remote_metadata:  # download URL
                try:
                    content = urlopen(metadataUrl['url'], timeout=timeout)
                    doc = etree.parse(content)
                    if metadataUrl['type'] is not None:
                        if metadataUrl['type'] == 'FGDC':
                            metadataUrl['metadata'] = Metadata(doc)
                        if metadataUrl['type'] in ['TC211', '19115', '19139']:
                            metadataUrl['metadata'] = MD_Metadata(doc)
                except Exception, err:
                    metadataUrl['metadata'] = None

            self.metadataUrls.append(metadataUrl)

        #others not used but needed for iContentMetadata harmonisation
        self.styles=None
        self.timepositions=None
        self.defaulttimeposition=None

class WFSCapabilitiesReader(object):
    """Read and parse capabilities document into a lxml.etree infoset
    """

    def __init__(self, version='1.0'):
        """Initialize"""
        self.version = version
        self._infoset = None

    def capabilities_url(self, service_url):
        """Return a capabilities url
        """
        qs = []
        if service_url.find('?') != -1:
            qs = cgi.parse_qsl(service_url.split('?')[1])

        params = [x[0] for x in qs]

        if 'service' not in params:
            qs.append(('service', 'WFS'))
        if 'request' not in params:
            qs.append(('request', 'GetCapabilities'))
        if 'version' not in params:
            qs.append(('version', self.version))

        urlqs = urlencode(tuple(qs))
        return service_url.split('?')[0] + '?' + urlqs

    def read(self, url, timeout=30):
        """Get and parse a WFS capabilities document, returning an
        instance of WFSCapabilitiesInfoset

        Parameters
        ----------
        url : string
            The URL to the WFS capabilities document.
        timeout : number
            A timeout value (in seconds) for the request.
        """
        request = self.capabilities_url(url)
        u = urlopen(request, timeout=timeout)
        return etree.fromstring(u.read())

    def readString(self, st):
        """Parse a WFS capabilities document, returning an
        instance of WFSCapabilitiesInfoset

        string should be an XML capabilities document
        """
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        return etree.fromstring(st)


########NEW FILE########
__FILENAME__ = wfs200
# =============================================================================
# OWSLib. Copyright (C) 2005 Sean C. Gillies
#
# Contact email: sgillies@frii.com
#
# $Id: wfs.py 503 2006-02-01 17:09:12Z dokai $
# =============================================================================

#owslib imports:
from owslib.ows import ServiceIdentification, ServiceProvider, OperationsMetadata
from owslib.etree import etree
from owslib.util import nspath, testXMLValue
from owslib.crs import Crs
from owslib.feature import WebFeatureService_
from owslib.namespaces import Namespaces

#other imports
import cgi
from cStringIO import StringIO
from urllib import urlencode
from urllib2 import urlopen

import logging
from owslib.util import log

n = Namespaces()
WFS_NAMESPACE = n.get_namespace("wfs20")
OWS_NAMESPACE = n.get_namespace("ows110")
OGC_NAMESPACE = n.get_namespace("ogc")
GML_NAMESPACE = n.get_namespace("gml")
FES_NAMESPACE = n.get_namespace("fes")


class ServiceException(Exception):
    pass


class WebFeatureService_2_0_0(WebFeatureService_):
    """Abstraction for OGC Web Feature Service (WFS).

    Implements IWebFeatureService.
    """
    def __new__(self,url, version, xml, parse_remote_metadata=False):
        """ overridden __new__ method 
        
        @type url: string
        @param url: url of WFS capabilities document
        @type xml: string
        @param xml: elementtree object
        @type parse_remote_metadata: boolean
        @param parse_remote_metadata: whether to fully process MetadataURL elements
        @return: initialized WebFeatureService_2_0_0 object
        """
        obj=object.__new__(self)
        obj.__init__(url, version, xml, parse_remote_metadata)
        return obj
    
    def __getitem__(self,name):
        ''' check contents dictionary to allow dict like access to service layers'''
        if name in self.__getattribute__('contents').keys():
            return self.__getattribute__('contents')[name]
        else:
            raise KeyError, "No content named %s" % name
    
    
    def __init__(self, url,  version, xml=None, parse_remote_metadata=False):
        """Initialize."""
        if log.isEnabledFor(logging.DEBUG):
            log.debug('building WFS %s'%url)
        self.url = url
        self.version = version
        self._capabilities = None
        reader = WFSCapabilitiesReader(self.version)
        if xml:
            self._capabilities = reader.readString(xml)
        else:
            self._capabilities = reader.read(self.url)
        self._buildMetadata(parse_remote_metadata)
    
    def _buildMetadata(self, parse_remote_metadata=False):
        '''set up capabilities metadata objects: '''
        
        #serviceIdentification metadata
        serviceidentelem=self._capabilities.find(nspath('ServiceIdentification'))
        self.identification=ServiceIdentification(serviceidentelem)  
        #need to add to keywords list from featuretypelist information:
        featuretypelistelem=self._capabilities.find(nspath('FeatureTypeList', ns=WFS_NAMESPACE))
        featuretypeelems=featuretypelistelem.findall(nspath('FeatureType', ns=WFS_NAMESPACE))
        for f in featuretypeelems:  
            kwds=f.findall(nspath('Keywords/Keyword',ns=OWS_NAMESPACE))
            if kwds is not None:
                for kwd in kwds[:]:
                    if kwd.text not in self.identification.keywords:
                        self.identification.keywords.append(kwd.text)
	
   
        #TODO: update serviceProvider metadata, miss it out for now
        serviceproviderelem=self._capabilities.find(nspath('ServiceProvider'))
        self.provider=ServiceProvider(serviceproviderelem)   
        
        #serviceOperations metadata 
        self.operations=[]
        
        for elem in self._capabilities.find(nspath('OperationsMetadata'))[:]:
            if elem.tag !=nspath('ExtendedCapabilities'):
                self.operations.append(OperationsMetadata(elem))
                   
        #serviceContents metadata: our assumption is that services use a top-level 
        #layer as a metadata organizer, nothing more. 
        
        self.contents={} 
        featuretypelist=self._capabilities.find(nspath('FeatureTypeList',ns=WFS_NAMESPACE))
        features = self._capabilities.findall(nspath('FeatureTypeList/FeatureType', ns=WFS_NAMESPACE))
        for feature in features:
            cm=ContentMetadata(feature, featuretypelist, parse_remote_metadata)
            self.contents[cm.id]=cm       
        
        #exceptions
        self.exceptions = [f.text for f \
                in self._capabilities.findall('Capability/Exception/Format')]
      
    def getcapabilities(self, timeout=30):
        """Request and return capabilities document from the WFS as a 
        file-like object.
        NOTE: this is effectively redundant now"""
        reader = WFSCapabilitiesReader(self.version)
        return urlopen(reader.capabilities_url(self.url), timeout=timeout)
    
    def items(self):
        '''supports dict-like items() access'''
        items=[]
        for item in self.contents:
            items.append((item,self.contents[item]))
        return items
    
    def getfeature(self, typename=None, filter=None, bbox=None, featureid=None,
                   featureversion=None, propertyname=None, maxfeatures=None,storedQueryID=None, storedQueryParams={},
                   method='Get', timeout=30, outputFormat=None):
        """Request and return feature data as a file-like object.
        #TODO: NOTE: have changed property name from ['*'] to None - check the use of this in WFS 2.0
        Parameters
        ----------
        typename : list
            List of typenames (string)
        filter : string 
            XML-encoded OGC filter expression.
        bbox : tuple
            (left, bottom, right, top) in the feature type's coordinates == (minx, miny, maxx, maxy)
        featureid : list
            List of unique feature ids (string)
        featureversion : string
            Default is most recent feature version.
        propertyname : list
            List of feature property names. '*' matches all.
        maxfeatures : int
            Maximum number of features to be returned.
        method : string
            Qualified name of the HTTP DCP method to use.
        timeout : number
            A timeout value (in seconds) for the request.
        outputFormat: string (optional)
            Requested response format of the request.

        There are 3 different modes of use

        1) typename and bbox (simple spatial query)
        2) typename and filter (==query) (more expressive)
        3) featureid (direct access to known features)
        """

        url = data = None
        if typename and type(typename) == type(""):
            typename = [typename]
        if method.upper() == "GET":
            (url) = self.getGETGetFeatureRequest(typename, filter, bbox, featureid,
                                                 featureversion, propertyname,
                                                 maxfeatures, storedQueryID,
                                                 storedQueryParams, outputFormat)
            if log.isEnabledFor(logging.DEBUG):
                log.debug('GetFeature WFS GET url %s'% url)
        else:
            (url,data) = self.getPOSTGetFeatureRequest()


        # If method is 'Post', data will be None here
        u = urlopen(url, data, timeout)
        
        # check for service exceptions, rewrap, and return
        # We're going to assume that anything with a content-length > 32k
        # is data. We'll check anything smaller.
        try:
            length = int(u.info()['Content-Length'])
            have_read = False
        except KeyError:
            data = u.read()
            have_read = True
            length = len(data)
     
        if length < 32000:
            if not have_read:
                data = u.read()

            try:
                tree = etree.fromstring(data)
            except BaseException:
                # Not XML
                return StringIO(data)
            else:
                if tree.tag == "{%s}ServiceExceptionReport" % OGC_NAMESPACE:
                    se = tree.find(nspath('ServiceException', OGC_NAMESPACE))
                    raise ServiceException(str(se.text).strip())
                else:
                    return StringIO(data)
        else:
            if have_read:
                return StringIO(data)
            return u


    def getpropertyvalue(self, query=None, storedquery_id=None, valuereference=None, typename=None, method=nspath('Get'),**kwargs):
        ''' the WFS GetPropertyValue method'''
        try:
            base_url = next((m.get('url') for m in self.getOperationByName('GetPropertyValue').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url
        request = {'service': 'WFS', 'version': self.version, 'request': 'GetPropertyValue'}
        if query:
            request['query'] = str(query)
        if valuereference: 
            request['valueReference'] = str(valuereference)
        if storedquery_id: 
            request['storedQuery_id'] = str(storedquery_id)
        if typename:
            request['typename']=str(typename)
        if kwargs:
            for kw in kwargs.keys():
                request[kw]=str(kwargs[kw])
        encoded_request=urlencode(request)
        u = urlopen(base_url + encoded_request)
        return u.read()
        
        
    def _getStoredQueries(self, timeout=30):
        ''' gets descriptions of the stored queries available on the server '''
        sqs=[]
        #This method makes two calls to the WFS - one ListStoredQueries, and one DescribeStoredQueries. The information is then
        #aggregated in 'StoredQuery' objects
        method=nspath('Get')
        
        #first make the ListStoredQueries response and save the results in a dictionary if form {storedqueryid:(title, returnfeaturetype)}
        try:
            base_url = next((m.get('url') for m in self.getOperationByName('ListStoredQueries').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url

        request = {'service': 'WFS', 'version': self.version, 'request': 'ListStoredQueries'}
        encoded_request = urlencode(request)
        u = urlopen(base_url + encoded_request, timeout=timeout)
        tree=etree.fromstring(u.read())
        tempdict={}       
        for sqelem in tree[:]:
            title=rft=id=None
            id=sqelem.get('id')
            for elem in sqelem[:]:
                if elem.tag==nspath('Title', WFS_NAMESPACE):
                    title=elem.text
                elif elem.tag==nspath('ReturnFeatureType', WFS_NAMESPACE):
                    rft=elem.text
            tempdict[id]=(title,rft)        #store in temporary dictionary
        
        #then make the DescribeStoredQueries request and get the rest of the information about the stored queries 
        try:
            base_url = next((m.get('url') for m in self.getOperationByName('DescribeStoredQueries').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url
        request = {'service': 'WFS', 'version': self.version, 'request': 'DescribeStoredQueries'}
        encoded_request = urlencode(request)
        u = urlopen(base_url + encoded_request, timeout=timeout)
        tree=etree.fromstring(u.read())
        tempdict2={} 
        for sqelem in tree[:]:
            params=[] #list to store parameters for the stored query description
            id =sqelem.get('id')
            for elem in sqelem[:]:
                if elem.tag==nspath('Abstract', WFS_NAMESPACE):
                    abstract=elem.text
                elif elem.tag==nspath('Parameter', WFS_NAMESPACE):
                    newparam=Parameter(elem.get('name'), elem.get('type'))
                    params.append(newparam)
            tempdict2[id]=(abstract, params) #store in another temporary dictionary
        
        #now group the results into StoredQuery objects:
        for key in tempdict.keys(): 
            abstract='blah'
            parameters=[]
            sqs.append(StoredQuery(key, tempdict[key][0], tempdict[key][1], tempdict2[key][0], tempdict2[key][1]))
        return sqs
    storedqueries = property(_getStoredQueries, None)

    def getOperationByName(self, name):
        """Return a named content item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError, "No operation named %s" % name

class StoredQuery(object):
    '''' Class to describe a storedquery '''
    def __init__(self, id, title, returntype, abstract, parameters):
        self.id=id
        self.title=title
        self.returnfeaturetype=returntype
        self.abstract=abstract
        self.parameters=parameters
        
class Parameter(object):
    def __init__(self, name, type):
        self.name=name
        self.type=type
        
    
class ContentMetadata:
    """Abstraction for WFS metadata.
    
    Implements IMetadata.
    """

    def __init__(self, elem, parent, parse_remote_metadata=False, timeout=30):
        """."""
        self.id = elem.find(nspath('Name',ns=WFS_NAMESPACE)).text
        self.title = elem.find(nspath('Title',ns=WFS_NAMESPACE)).text
        abstract = elem.find(nspath('Abstract',ns=WFS_NAMESPACE))
        if abstract is not None:
            self.abstract = abstract.text
        else:
            self.abstract = None
        self.keywords = [f.text for f in elem.findall(nspath('Keywords',ns=WFS_NAMESPACE))]

        # bboxes
        self.boundingBoxWGS84 = None
        b = elem.find(nspath('WGS84BoundingBox',ns=OWS_NAMESPACE))
        if b is not None:
            lc = b.find(nspath("LowerCorner",ns=OWS_NAMESPACE))
            uc = b.find(nspath("UpperCorner",ns=OWS_NAMESPACE))
            ll = [float(s) for s in lc.text.split()]
            ur = [float(s) for s in uc.text.split()]
            self.boundingBoxWGS84 = (ll[0],ll[1],ur[0],ur[1])

        # there is no such think as bounding box
        # make copy of the WGS84BoundingBox
        self.boundingBox = (self.boundingBoxWGS84[0],
                            self.boundingBoxWGS84[1],
                            self.boundingBoxWGS84[2],
                            self.boundingBoxWGS84[3],
                            Crs("epsg:4326"))
        # crs options
        self.crsOptions = [Crs(srs.text) for srs in elem.findall(nspath('OtherCRS',ns=WFS_NAMESPACE))]
        defaultCrs =  elem.findall(nspath('DefaultCRS',ns=WFS_NAMESPACE))
        if len(defaultCrs) > 0:
            self.crsOptions.insert(0,Crs(defaultCrs[0].text))


        # verbs
        self.verbOptions = [op.tag for op \
            in parent.findall(nspath('Operations/*',ns=WFS_NAMESPACE))]
        self.verbOptions + [op.tag for op \
            in elem.findall(nspath('Operations/*',ns=WFS_NAMESPACE)) \
            if op.tag not in self.verbOptions]
        
        #others not used but needed for iContentMetadata harmonisation
        self.styles=None
        self.timepositions=None
        self.defaulttimeposition=None

        # MetadataURLs
        self.metadataUrls = []
        for m in elem.findall('MetadataURL'):
            metadataUrl = {
                'type': testXMLValue(m.attrib['type'], attrib=True),
                'format': m.find('Format').text.strip(),
                'url': testXMLValue(m.find('OnlineResource').attrib['{http://www.w3.org/1999/xlink}href'], attrib=True)
            }

            if metadataUrl['url'] is not None and parse_remote_metadata:  # download URL
                try:
                    content = urllib2.urlopen(metadataUrl['url'], timeout=timeout)
                    doc = etree.parse(content)
                    try:  # FGDC
                        metadataUrl['metadata'] = Metadata(doc)
                    except:  # ISO
                        metadataUrl['metadata'] = MD_Metadata(doc)
                except Exception, err:
                    metadataUrl['metadata'] = None

            self.metadataUrls.append(metadataUrl)


class WFSCapabilitiesReader(object):
    """Read and parse capabilities document into a lxml.etree infoset
    """

    def __init__(self, version='2.0.0'):
        """Initialize"""
        self.version = version
        self._infoset = None

    def capabilities_url(self, service_url):
        """Return a capabilities url
        """
        qs = []
        if service_url.find('?') != -1:
            qs = cgi.parse_qsl(service_url.split('?')[1])

        params = [x[0] for x in qs]

        if 'service' not in params:
            qs.append(('service', 'WFS'))
        if 'request' not in params:
            qs.append(('request', 'GetCapabilities'))
        if 'version' not in params:
            qs.append(('version', self.version))

        urlqs = urlencode(tuple(qs))
        return service_url.split('?')[0] + '?' + urlqs

    def read(self, url, timeout=30):
        """Get and parse a WFS capabilities document, returning an
        instance of WFSCapabilitiesInfoset

        Parameters
        ----------
        url : string
            The URL to the WFS capabilities document.
        timeout : number
            A timeout value (in seconds) for the request.
        """
        request = self.capabilities_url(url)
        u = urlopen(request, timeout=timeout)
        return etree.fromstring(u.read())

    def readString(self, st):
        """Parse a WFS capabilities document, returning an
        instance of WFSCapabilitiesInfoset

        string should be an XML capabilities document
        """
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        return etree.fromstring(st)

########NEW FILE########
__FILENAME__ = fes
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2009 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

"""
API for OGC Filter Encoding (FE) constructs and metadata.

Filter Encoding: http://www.opengeospatial.org/standards/filter

Currently supports version 1.1.0 (04-095).
"""

from owslib.etree import etree
from owslib import util
from owslib.namespaces import Namespaces

# default variables
def get_namespaces():
    n = Namespaces()
    ns = n.get_namespaces(["dif","fes","gml","ogc","xs","xsi"])
    ns[None] = n.get_namespace("ogc")
    return ns
namespaces = get_namespaces()
schema = 'http://schemas.opengis.net/filter/1.1.0/filter.xsd'
schema_location = '%s %s' % (namespaces['ogc'], schema)

class FilterRequest(object):
    """ filter class """
    def __init__(self, parent=None, version='1.1.0'):
        """

        filter Constructor

        Parameters 
        ----------

        - parent: parent etree.Element object (default is None)
        - version: version (default is '1.1.0')

        """

        self.version = version
        self._root = etree.Element(util.nspath_eval('ogc:Filter', namespaces))
        if parent is not None:
            self._root.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)

    def set(self, parent=False, qtype=None, keywords=[], typenames='csw:Record', propertyname='csw:AnyText', bbox=None, identifier=None):
        """

        Construct and process a  GetRecords request
    
        Parameters
        ----------

        - parent: the parent Element object.  If this is not, then generate a standalone request
        - qtype: type of resource to query (i.e. service, dataset)
        - keywords: list of keywords
        - propertyname: the PropertyName to Filter against 
        - bbox: the bounding box of the spatial query in the form [minx,miny,maxx,maxy]
        - identifier: the dc:identifier to query against with a PropertyIsEqualTo.  Ignores all other inputs.

        """

        # Set the identifier if passed.  Ignore other parameters
        dc_identifier_equals_filter = None
        if identifier is not None:
            dc_identifier_equals_filter = PropertyIsEqualTo('dc:identifier', identifier)
            self._root.append(dc_identifier_equals_filter.toXML())
            return self._root
   
        # Set the query type if passed
        dc_type_equals_filter = None
        if qtype is not None:
            dc_type_equals_filter = PropertyIsEqualTo('dc:type', qtype)

        # Set a bbox query if passed
        bbox_filter = None
        if bbox is not None:
            bbox_filter = BBox(bbox)
    
        # Set a keyword query if passed
        keyword_filter = None
        if len(keywords) > 0:
            if len(keywords) > 1: # loop multiple keywords into an Or
                ks = []    
                for i in keywords:
                    ks.append(PropertyIsLike(propertyname, "*%s*" % i, wildCard="*"))
                keyword_filter = Or(operations=ks)
            elif len(keywords) == 1: # one keyword
                keyword_filter = PropertyIsLike(propertyname, "*%s*" % keywords[0], wildCard="*")
    

        # And together filters if more than one exists
        filters = filter(None,[keyword_filter, bbox_filter, dc_type_equals_filter])
        if len(filters) == 1:
            self._root.append(filters[0].toXML())
        elif len(filters) > 1:
            self._root.append(And(operations=filters).toXML())

        return self._root
       
    def setConstraint(self, constraint):
        """
        Construct and process a  GetRecords request
    
        Parameters
        ----------

        - constraint: An OgcExpression object

        """
        self._root.append(constraint.toXML())
        return self._root

    def setConstraintList(self, constraints):
        """
        Construct and process a  GetRecords request
    
        Parameters
        ----------

        - constraints: A list of OgcExpression objects
                       The list is interpretted like so:

                       [a,b,c]
                       a || b || c

                       [[a,b,c]]
                       a && b && c

                       [[a,b],[c],[d],[e]] or [[a,b],c,d,e]
                       (a && b) || c || d || e

        """
        ors = []
        if len(constraints) == 1:
            if isinstance(constraints[0], OgcExpression):
                return self.setConstraint(constraints[0])
            else:
                self._root.append(And(operations=constraints[0]).toXML())
                return self._root

        for c in constraints:
            if isinstance(c, OgcExpression):
                ors.append(c)
            elif isinstance(c, list) or isinstance(c, tuple):
                if len(c) == 1:
                    ors.append(c[0])
                elif len(c) >= 2:
                    ands = []
                    for sub in c:
                        if isinstance(sub, OgcExpression):
                            ands.append(sub)
                    ors.append(And(operations=ands))

        self._root.append(Or(operations=ors).toXML())
        return self._root


class FilterCapabilities(object):
    """ Abstraction for Filter_Capabilities """
    def __init__(self, elem):
        # Spatial_Capabilities
        self.spatial_operands = [f.text for f in elem.findall(util.nspath_eval('ogc:Spatial_Capabilities/ogc:GeometryOperands/ogc:GeometryOperand', namespaces))]
        self.spatial_operators = []
        for f in elem.findall(util.nspath_eval('ogc:Spatial_Capabilities/ogc:SpatialOperators/ogc:SpatialOperator', namespaces)):
            self.spatial_operators.append(f.attrib['name'])

        # Temporal_Capabilities
        self.temporal_operands = [f.text for f in elem.findall(util.nspath_eval('ogc:Temporal_Capabilities/ogc:TemporalOperands/ogc:TemporalOperand', namespaces))]
        self.temporal_operators = []
        for f in elem.findall(util.nspath_eval('ogc:Temporal_Capabilities/ogc:TemporalOperators/ogc:TemporalOperator', namespaces)):
            self.temporal_operators.append(f.attrib['name'])

        # Scalar_Capabilities
        self.scalar_comparison_operators = [f.text for f in elem.findall(util.nspath_eval('ogc:Scalar_Capabilities/ogc:ComparisonOperators/ogc:ComparisonOperator', namespaces))]

class FilterCapabilities200(object):
    """Abstraction for Filter_Capabilities 2.0"""
    def __init__(self, elem):
        # Spatial_Capabilities
        self.spatial_operands = [f.attrib.get('name') for f in elem.findall(util.nspath_eval('fes:Spatial_Capabilities/fes:GeometryOperands/fes:GeometryOperand', namespaces))]
        self.spatial_operators = []
        for f in elem.findall(util.nspath_eval('fes:Spatial_Capabilities/fes:SpatialOperators/fes:SpatialOperator', namespaces)):
            self.spatial_operators.append(f.attrib['name'])

        # Temporal_Capabilities
        self.temporal_operands = [f.attrib.get('name') for f in elem.findall(util.nspath_eval('fes:Temporal_Capabilities/fes:TemporalOperands/fes:TemporalOperand', namespaces))]
        self.temporal_operators = []
        for f in elem.findall(util.nspath_eval('fes:Temporal_Capabilities/fes:TemporalOperators/fes:TemporalOperator', namespaces)):
            self.temporal_operators.append(f.attrib['name'])

        # Scalar_Capabilities
        self.scalar_comparison_operators = [f.text for f in elem.findall(util.nspath_eval('fes:Scalar_Capabilities/fes:ComparisonOperators/fes:ComparisonOperator', namespaces))]

        # Conformance
        self.conformance = []
        for f in elem.findall(util.nspath_eval('fes:Conformance/fes:Constraint', namespaces)):
           self.conformance[f.attrib.get('name')] = f.find(util.nspath_eval('fes:DefaultValue', namespaces)).text



def setsortby(parent, propertyname, order='ASC'):
    """

    constructs a SortBy element

    Parameters
    ----------

    - parent: parent etree.Element object
    - propertyname: the PropertyName
    - order: the SortOrder (default is 'ASC')

    """

    tmp = etree.SubElement(parent, util.nspath_eval('ogc:SortBy', namespaces))
    tmp2 = etree.SubElement(tmp, util.nspath_eval('ogc:SortProperty', namespaces))
    etree.SubElement(tmp2, util.nspath_eval('ogc:PropertyName', namespaces)).text = propertyname
    etree.SubElement(tmp2, util.nspath_eval('ogc:SortOrder', namespaces)).text = order
    
class SortProperty(object):
    def __init__(self, propertyname, order='ASC'):
        self.propertyname   = propertyname
        self.order          = order.upper()
        if self.order not in ['DESC','ASC']:
            raise ValueError("SortOrder can only be 'ASC' or 'DESC'")
    def toXML(self):
        node0 = etree.Element(util.nspath_eval("ogc:SortProperty", namespaces))
        etree.SubElement(node0, util.nspath_eval('ogc:PropertyName', namespaces)).text = self.propertyname
        etree.SubElement(node0, util.nspath_eval('ogc:SortOrder', namespaces)).text = self.order
        return node0

class SortBy(object):
    def __init__(self, properties):
        self.properties = properties
    def toXML(self):
        node0 = etree.Element(util.nspath_eval("ogc:SortBy", namespaces))
        for prop in self.properties:
            node0.append(prop.toXML())
        return node0

class OgcExpression(object):
    def __init__(self):
        pass

class BinaryComparisonOpType(OgcExpression):
    """ Super class of all the property operation classes"""
    def __init__(self, propertyoperator, propertyname, literal, matchcase=True):
        self.propertyoperator = propertyoperator
        self.propertyname = propertyname
        self.literal = literal
        self.matchcase = matchcase
    def toXML(self):
        node0 = etree.Element(util.nspath_eval(self.propertyoperator, namespaces))
        if not self.matchcase:
            node0.set('matchCase', 'false')
        etree.SubElement(node0, util.nspath_eval('ogc:PropertyName', namespaces)).text = self.propertyname
        etree.SubElement(node0, util.nspath_eval('ogc:Literal', namespaces)).text = self.literal
        return node0
    
class PropertyIsEqualTo(BinaryComparisonOpType):
    """ PropertyIsEqualTo class"""
    def __init__(self, propertyname, literal, matchcase=True):
        BinaryComparisonOpType.__init__(self, 'ogc:PropertyIsEqualTo',  propertyname, literal, matchcase)

class PropertyIsNotEqualTo(BinaryComparisonOpType):
    """ PropertyIsNotEqualTo class """
    def __init__(self, propertyname, literal, matchcase=True):
        BinaryComparisonOpType.__init__(self, 'ogc:PropertyIsNotEqualTo',  propertyname, literal, matchcase)
        
class PropertyIsLessThan(BinaryComparisonOpType):
    """PropertyIsLessThan class"""
    def __init__(self, propertyname, literal, matchcase=True):
        BinaryComparisonOpType.__init__(self, 'ogc:PropertyIsLessThan',  propertyname, literal, matchcase)

class PropertyIsGreaterThan(BinaryComparisonOpType):
    """PropertyIsGreaterThan class"""
    def __init__(self, propertyname, literal, matchcase=True):
        BinaryComparisonOpType.__init__(self, 'ogc:PropertyIsGreaterThan',  propertyname, literal, matchcase)

class PropertyIsLessThanOrEqualTo(BinaryComparisonOpType):
    """PropertyIsLessThanOrEqualTo class"""
    def __init__(self, propertyname, literal, matchcase=True):
        BinaryComparisonOpType.__init__(self, 'ogc:PropertyIsLessThanOrEqualTo',  propertyname, literal, matchcase)

class PropertyIsGreaterThanOrEqualTo(BinaryComparisonOpType):
    """PropertyIsGreaterThanOrEqualTo class"""
    def __init__(self, propertyname, literal, matchcase=True):
        BinaryComparisonOpType.__init__(self, 'ogc:PropertyIsGreaterThanOrEqualTo',  propertyname, literal, matchcase)

class PropertyIsLike(OgcExpression):
    """PropertyIsLike class"""
    def __init__(self, propertyname, literal, escapeChar='\\', singleChar='_', wildCard='%', matchCase=True):
        self.propertyname = propertyname
        self.literal = literal
        self.escapeChar = escapeChar
        self.singleChar = singleChar
        self.wildCard = wildCard
        self.matchCase = matchCase
    def toXML(self):
        node0 = etree.Element(util.nspath_eval('ogc:PropertyIsLike', namespaces))
        node0.set('wildCard', self.wildCard)
        node0.set('singleChar', self.singleChar)
        node0.set('escapeChar', self.escapeChar)
        if not self.matchCase:
            node0.set('matchCase', 'false')
        etree.SubElement(node0, util.nspath_eval('ogc:PropertyName', namespaces)).text = self.propertyname
        etree.SubElement(node0, util.nspath_eval('ogc:Literal', namespaces)).text = self.literal
        return node0

class PropertyIsNull(OgcExpression):
    """PropertyIsNull class"""
    def __init__(self, propertyname):
        self.propertyname = propertyname
    def toXML(self):
        node0 = etree.Element(util.nspath_eval('ogc:PropertyIsNull', namespaces))
        etree.SubElement(node0, util.nspath_eval('ogc:PropertyName', namespaces)).text = self.propertyname
        return node0
        
class PropertyIsBetween(OgcExpression):
    """PropertyIsBetween class"""
    def __init__(self, propertyname, lower, upper):
        self.propertyname = propertyname
        self.lower = lower
        self.upper = upper
    def toXML(self):
        node0 = etree.Element(util.nspath_eval('ogc:PropertyIsBetween', namespaces))
        etree.SubElement(node0, util.nspath_eval('ogc:PropertyName', namespaces)).text = self.propertyname
        node1 = etree.SubElement(node0, util.nspath_eval('ogc:LowerBoundary', namespaces))
        etree.SubElement(node1, util.nspath_eval('ogc:Literal', namespaces)).text = '%s' % self.lower
        node2 = etree.SubElement(node0, util.nspath_eval('ogc:UpperBoundary', namespaces))
        etree.SubElement(node2, util.nspath_eval('ogc:Literal', namespaces)).text = '%s' % self.upper
        return node0
        
class BBox(OgcExpression):
    """Construct a BBox, two pairs of coordinates (west-south and east-north)"""
    def __init__(self, bbox):
        self.bbox = bbox
    def toXML(self):
        tmp = etree.Element(util.nspath_eval('ogc:BBOX', namespaces))
        etree.SubElement(tmp, util.nspath_eval('ogc:PropertyName', namespaces)).text = 'ows:BoundingBox'
        tmp2 = etree.SubElement(tmp, util.nspath_eval('gml:Envelope', namespaces))
        etree.SubElement(tmp2, util.nspath_eval('gml:lowerCorner', namespaces)).text = '%s %s' % (self.bbox[0], self.bbox[1])
        etree.SubElement(tmp2, util.nspath_eval('gml:upperCorner', namespaces)).text = '%s %s' % (self.bbox[2], self.bbox[3])
        return tmp

# BINARY
class BinaryLogicOpType(OgcExpression):
    """ Binary Operators: And / Or """
    def __init__(self, binary_operator, operations):
        self.binary_operator = binary_operator
        try:
            assert len(operations) >= 2
            self.operations = operations
        except:
            raise ValueError("Binary operations (And / Or) require a minimum of two operations to operate against")
    def toXML(self):
        node0 = etree.Element(util.nspath_eval(self.binary_operator, namespaces))
        for op in self.operations:
            node0.append(op.toXML())
        return node0

class And(BinaryLogicOpType):
    def __init__(self, operations):
        super(And,self).__init__('ogc:And', operations)

class Or(BinaryLogicOpType):
    def __init__(self, operations):
        super(Or,self).__init__('ogc:Or', operations)

# UNARY
class UnaryLogicOpType(OgcExpression):
    """ Unary Operator: Not """
    def __init__(self, urary_operator, operations):
        self.urary_operator = urary_operator
        self.operations = operations
    def toXML(self):
        node0 = etree.Element(util.nspath_eval(self.urary_operator, namespaces))
        for op in self.operations:
            node0.append(op.toXML())
        return node0

class Not(UnaryLogicOpType):
    def __init__(self, operations):
        super(Not,self).__init__('ogc:Not', operations)


########NEW FILE########
__FILENAME__ = fgdc
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2010 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

""" FGDC metadata parser """

from owslib.etree import etree
from owslib import util

class Metadata(object):
    """ Process metadata """
    def __init__(self, md):
        if hasattr(md, 'getroot'):  # standalone document
            self.xml = etree.tostring(md.getroot())
        else:  # part of a larger document
            self.xml = etree.tostring(md)

        self.idinfo = Idinfo(md)
        self.eainfo = Eainfo(md)
        self.distinfo = Distinfo(md)
        self.metainfo = Metainfo(md)

        if self.idinfo.datasetid:
            self.identifier = self.idinfo.datasetid

class Idinfo(object):
    """ Process idinfo """
    def __init__(self, md):
        val = md.find('idinfo/datasetid')
        self.datasetid = util.testXMLValue(val)

        val = md.find('idinfo/citation')
        self.citation = Citation(val)

        val = md.find('idinfo/descript')
        if val is not None:
            self.descript = Descript(val)

        val = md.find('idinfo/timeperd')
        self.timeperd = Timeperd(val)

        val = md.find('idinfo/status')
        if val is not None:
            self.status = Status(val)

        val = md.find('idinfo/spdom')
        if val is not None:
            self.spdom = Spdom(val)

        val = md.find('idinfo/keywords')
        if val is not None:
            self.keywords = Keywords(val)

        val = md.find('idinfo/accconst')
        self.accconst = util.testXMLValue(val)

        val = md.find('idinfo/useconst')
        self.useconst = util.testXMLValue(val)

        val = md.find('idinfo/ptcontac')
        if val is not None:
            self.ptcontac = Ptcontac(val)

        val = md.find('idinfo/datacred')
        self.datacred = util.testXMLValue(val)

        val = md.find('idinfo/crossref')
        self.crossref = Citation(val)

class Citation(object):
    """ Process citation """
    def __init__(self, md):
        if md is not None:
            self.citeinfo = {}
    
            val = md.find('citeinfo/origin')
            self.citeinfo['origin'] = util.testXMLValue(val)
    
            val = md.find('citeinfo/pubdate')
            self.citeinfo['pubdate'] = util.testXMLValue(val)
    
            val = md.find('citeinfo/title')
            self.citeinfo['title'] = util.testXMLValue(val)
    
            val = md.find('citeinfo/geoform')
            self.citeinfo['geoform'] = util.testXMLValue(val)
    
            val = md.find('citeinfo/pubinfo/pubplace')
            self.citeinfo['pubplace'] = util.testXMLValue(val)
    
            val = md.find('citeinfo/pubinfo/publish')
            self.citeinfo['publish'] = util.testXMLValue(val)

            self.citeinfo['onlink'] = []
            for link in md.findall('citeinfo/onlink'):
                self.citeinfo['onlink'].append(util.testXMLValue(link))

class Descript(object):
    """ Process descript """
    def __init__(self, md):
        val = md.find('abstract')
        self.abstract = util.testXMLValue(val)
        
        val = md.find('purpose')
        self.purpose = util.testXMLValue(val)

        val = md.find('supplinf')
        self.supplinf = util.testXMLValue(val)

class Timeperd(object):
    """ Process timeperd """
    def __init__(self, md):
        if md is not None:
            val = md.find('current')
            self.current = util.testXMLValue(val)

            val = md.find('timeinfo')
            if val is not None:
                self.timeinfo = Timeinfo(val)

class Timeinfo(object):
    """ Process timeinfo """
    def __init__(self, md):
        val = md.find('sngdate')
        if val is not None:
            self.sngdate = Sngdate(val)

        val = md.find('rngdates')
        if val is not None:
            self.rngdates = Rngdates(val)

class Sngdate(object):
    """ Process sngdate """
    def __init__(self, md):
        val = md.find('caldate')
        self.caldate = util.testXMLValue(val)
        val = md.find('time')
        self.time = util.testXMLValue(val)

class Rngdates(object):
    """ Process rngdates """
    def __init__(self, md):
        val = md.find('begdate')
        self.begdate = util.testXMLValue(val)
        val = md.find('begtime')
        self.begtime = util.testXMLValue(val)
        val = md.find('enddate')
        self.enddate = util.testXMLValue(val)
        val = md.find('endtime')
        self.endtime = util.testXMLValue(val)

class Status(object):
    """ Process status """
    def __init__(self, md):
        val = md.find('progress')
        self.progress = util.testXMLValue(val)

        val = md.find('update')
        self.update = util.testXMLValue(val)

class Spdom(object):
    """ Process spdom """
    def __init__(self, md):
        val = md.find('bounding/westbc')
        self.westbc = util.testXMLValue(val)

        val = md.find('bounding/eastbc')
        self.eastbc = util.testXMLValue(val)
       
        val = md.find('bounding/northbc')
        self.northbc = util.testXMLValue(val)

        val = md.find('bounding/southbc')
        self.southbc = util.testXMLValue(val)

        if (self.southbc is not None and self.northbc is not None and
        self.eastbc is not None and self.westbc is not None):
            self.bbox = Bbox(self)

class Bbox(object):
    """ Generate bbox for spdom (convenience function) """
    def __init__(self, spdom):
        self.minx = spdom.westbc
        self.miny = spdom.southbc
        self.maxx = spdom.eastbc
        self.maxy = spdom.northbc

class Keywords(object):
    """ Process keywords """
    def __init__(self, md):
        self.theme = []
        self.place = []
        self.temporal = []

        for i in md.findall('theme'):
            theme = {}
            val = i.find('themekt')
            theme['themekt'] = util.testXMLValue(val)
            theme['themekey'] = []
            for j in i.findall('themekey'):
                themekey = util.testXMLValue(j)
                if themekey is not None:
                    theme['themekey'].append(themekey)
            self.theme.append(theme)

        for i in md.findall('place'):
            theme = {}
            place = {}
            val = i.find('placekt')
            theme['placekt'] = util.testXMLValue(val)
            theme['placekey'] = []
            for j in i.findall('placekey'):
                theme['placekey'].append(util.testXMLValue(j))
            self.place.append(place)

        for i in md.findall('temporal'):
            theme = {}
            temporal = {}
            val = i.find('tempkt')
            theme['tempkt'] = util.testXMLValue(val)
            theme['tempkey'] = []
            for j in i.findall('tempkey'):
                theme['tempkey'].append(util.testXMLValue(j))
            self.temporal.append(temporal)

class Ptcontac(object):
    """ Process ptcontac """
    def __init__(self, md):
        val = md.find('cntinfo/cntorgp/cntorg')
        self.cntorg = util.testXMLValue(val)    

        val = md.find('cntinfo/cntorgp/cntper')
        self.cntper = util.testXMLValue(val)    

        val = md.find('cntinfo/cntpos')
        self.cntpos = util.testXMLValue(val)    

        val = md.find('cntinfo/cntaddr/addrtype')
        self.addrtype = util.testXMLValue(val)

        val = md.find('cntinfo/cntaddr/address')
        self.address = util.testXMLValue(val)

        val = md.find('cntinfo/cntaddr/city')
        self.city = util.testXMLValue(val)

        val = md.find('cntinfo/cntaddr/state')
        self.state = util.testXMLValue(val)

        val = md.find('cntinfo/cntaddr/postal')
        self.postal = util.testXMLValue(val)

        val = md.find('cntinfo/cntaddr/country')
        self.country = util.testXMLValue(val)

        val = md.find('cntinfo/cntvoice')
        self.voice = util.testXMLValue(val)

        val = md.find('cntinfo/cntemail')
        self.email = util.testXMLValue(val)

class Eainfo(object):
    """ Process eainfo """
    def __init__(self, md):
        val = md.find('eainfo/detailed/enttyp/enttypl')
        self.enttypl = util.testXMLValue(val)

        val = md.find('eainfo/detailed/enttyp/enttypd')
        self.enttypd = util.testXMLValue(val)

        val = md.find('eainfo/detailed/enttyp/enttypds')
        self.enttypds = util.testXMLValue(val)

        self.attr = []
        for i in md.findall('eainfo/detailed/attr'):
            attr = {}
            val = i.find('attrlabl')
            attr['attrlabl'] = util.testXMLValue(val)

            val = i.find('attrdef')
            attr['attrdef'] = util.testXMLValue(val)

            val = i.find('attrdefs')
            attr['attrdefs'] = util.testXMLValue(val)

            val = i.find('attrdomv/udom')
            attr['udom'] = util.testXMLValue(val)

            self.attr.append(attr)

class Distinfo(object):
    """ Process distinfo """
    def __init__(self, md):
        val = md.find('distinfo')
        if val is not None:
            val2 = val.find('stdorder')
            if val2 is not None:
                self.stdorder = {'digform': []}
                for link in val2.findall('digform'):
                    digform = {}
                    digform['name'] = util.testXMLValue(link.find('digtinfo/formname'))
                    digform['url'] = util.testXMLValue(link.find('digtopt/onlinopt/computer/networka/networkr/'))
                    self.stdorder['digform'].append(digform)

class Metainfo(object):
    """ Process metainfo """
    def __init__(self, md):
        val = md.find('metainfo/metd')
        self.metd = util.testXMLValue(val)

        val = md.find('metainfo/metrd')
        self.metrd = util.testXMLValue(val)

        val = md.find('metainfo/metc')        
        if val is not None:
            self.metc = Ptcontac(val)

        val = md.find('metainfo/metstdn')
        self.metstdn = util.testXMLValue(val)

        val = md.find('metainfo/metstdv')
        self.metstdv = util.testXMLValue(val)

        val = md.find('metainfo/metac')
        self.metac = util.testXMLValue(val)

        val = md.find('metainfo/metuc')
        self.metuc = util.testXMLValue(val)

########NEW FILE########
__FILENAME__ = interfaces

# Follows the 4 aspects of service metadata

class IServiceIdentificationMetadata:
    """OO-interface to service identification metadata.
    """

    type = property("""Service name (string): "WMS", "WFS", "WCS", or "SOS".""")
    version = property("""Version of service protocol (string).""")
    title = property("""Human-targeted title of service (string).""")
    abstract = property("""Text describing the service (string).""")
    keywords = property("""Keyword list (list).""")
    accessconstraints = property("""Explanation of access constraints associated with service (string).""")
    fees = property("""Explanation of fees associated with service (string).""")
    

class IServiceProviderMetadata:
    """OO-interface to service provider metadata.
    """

    name = property("""Provider's name (string).""")
    url = property("""URL for provider's web site (string).""")
    contact = property("""How to contact the service provider (string).""")


class IServiceOperations:
    """OO-interface to service operations metadata.
    """

    operations = property("""List of operation descriptors (list). These must implement IOperationMetadata (below).""")
    exceptions = property("""List of exception formats (list).""")


class IServiceContents:
    """OO-interface to service contents metadata.
    """

    contents = property("""List of content descriptors (list). These must implement IServiceContent (below).""")


# IServiceMetadata aggregates the 4 aspects above

class IServiceMetadata(IServiceOperations, IServiceContents):
    """OWS Metadata.

    operations and contents properties are inherited.
    """

    identification = property("""Object that implements IServiceIdentificationMetadata.""")
    provider = property("""Object that implements IServiceProviderMetadata.""")


# A Service has an online resource URL as well as metadata collections

class IService(IServiceMetadata):
    """The OGC Web Service interface.
    """

    url = property("""Online resource URL (string)""")


# 3 specific service types are described below: WMS, WFS, and WCS

class IWebMapService(IService):
    """Abstraction for an OGC Web Map Service (WMS).
    """

    def getcapabilities():
        """Make a request to the WMS, returns an XML document wrapped in a 
        Python file object."""

    def getmap(**kw):
        """Make a request to the WMS, returns an image wrapped in a Python
        file object."""

    def getfeatureinfo(**kw):
        """Make a request to the WMS, returns data."""


class IWebFeatureService(IService):
    """Abstraction for an OGC Web Feature Service (WFS).
    """

    def getcapabilities():
        """Make a request to the WFS, returns an XML document wrapped in a 
        Python file object."""

    def getfeature(**kw):
        """Make a request to the WFS, returns an XML document wrapped in a
        Python file object."""

    def describefeaturetype(**kw):
        """Make a request to the WFS, returns data."""


class IWebCoverageService(IService):
    # TODO
    pass

class ISensorObservationService(IService):
    """Abstraction for an OGC Sensor Observation Service (SOS).
    """

    def getcapabilities():
        """Make a request to the SOS, returns an XML document wrapped in a 
        Python file object."""

    def describesensor():
        """Make a request to the SOS, returns an XML document wrapped in a 
        Python file object."""

    def getobservation():
        """Make a request to the SOS, returns an XML document wrapped in a 
        Python file object."""

# Second level metadata interfaces

class IOperationMetadata:
    """OO-interface to operation metadata.
    """

    name = property("""Operation name (string): GetCapabilities", for example.""")
    formatOptions = property("""List of content types (list).""")
    methods = property("""Mapping of method descriptors, keyed to HTTP verbs. Items must implement IMethodMetadata (below).""")


class IMethodMetadata:
    """OO-interface to method metadata.
    """

    url = property("""Method endpoint URL (string).""")
    # TODO: constraint

class IContentMetadata:
    """OO-interface to content metadata.
    """

    id = property("""Unique identifier (string).""")
    title = property("""Human-targeted title (string).""")
    boundingBox = property("""Four bounding values and a coordinate reference system identifier (tuple).""")
    boundingBoxWGS84 = property("""Four bounding values in WGS coordinates.""")
    crsOptions = property("""List of available coordinate/spatial reference systems (list).""")
    styles = property("""List of style dicts (list).""")
    timepositions=property("""List of times for which data is available""")
    defaulttimeposition=property("""Default time position""")

class iSensorObservationServiceContentMetadata(IContentMetadata):
    """Extension class for SOS specifics"""
    pass

# XXX: needed?

class IContactMetadata:
    """OO-interface to OWS metadata.

    Properties
    ----------
    name : string
    organization : string
    address : string
    city : string
    region : string
    postcode : string
    country : string
    email : string
    hoursofservice: string
    role: string
    """

########NEW FILE########
__FILENAME__ = iso
# -*- coding: ISO-8859-15 -*- 
# ============================================================================= 
# Copyright (c) 2009 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#           Angelos Tzotsos <tzotsos@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

""" ISO metadata parser """

from owslib.etree import etree
from owslib import util
from owslib.namespaces import Namespaces

# default variables
def get_namespaces():
    n = Namespaces()
    ns = n.get_namespaces(["gco","gmd","gml","gml32","gmx","gts","srv","xlink"])
    ns[None] = n.get_namespace("gmd")
    return ns
namespaces = get_namespaces()


class MD_Metadata(object):
    """ Process gmd:MD_Metadata """
    def __init__(self, md=None):

        if md is None:
            self.xml = None
            self.identifier = None
            self.parentidentifier = None
            self.language = None
            self.dataseturi = None
            self.languagecode = None
            self.datestamp = None
            self.charset = None
            self.hierarchy = None
            self.contact = []
            self.datetimestamp = None
            self.stdname = None
            self.stdver = None
            self.referencesystem = None
            self.identification = None
            self.serviceidentification = None
            self.identificationinfo = []
            self.distribution = None
            self.dataquality = None
        else:
            if hasattr(md, 'getroot'):  # standalone document
                self.xml = etree.tostring(md.getroot())
            else:  # part of a larger document
                self.xml = etree.tostring(md)

            val = md.find(util.nspath_eval('gmd:fileIdentifier/gco:CharacterString', namespaces))
            self.identifier = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:parentIdentifier/gco:CharacterString', namespaces))
            self.parentidentifier = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:language/gco:CharacterString', namespaces))
            self.language = util.testXMLValue(val)
            
            val = md.find(util.nspath_eval('gmd:dataSetURI/gco:CharacterString', namespaces))
            self.dataseturi = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:language/gmd:LanguageCode', namespaces))
            self.languagecode = util.testXMLValue(val)
            
            val = md.find(util.nspath_eval('gmd:dateStamp/gco:Date', namespaces))
            self.datestamp = util.testXMLValue(val)

            if not self.datestamp:
                val = md.find(util.nspath_eval('gmd:dateStamp/gco:DateTime', namespaces))
                self.datestamp = util.testXMLValue(val)

            self.charset = _testCodeListValue(md.find(util.nspath_eval('gmd:characterSet/gmd:MD_CharacterSetCode', namespaces)))
      
            self.hierarchy = _testCodeListValue(md.find(util.nspath_eval('gmd:hierarchyLevel/gmd:MD_ScopeCode', namespaces)))

            self.contact = []
            for i in md.findall(util.nspath_eval('gmd:contact/gmd:CI_ResponsibleParty', namespaces)):
                o = CI_ResponsibleParty(i)
                self.contact.append(o)
            
            val = md.find(util.nspath_eval('gmd:dateStamp/gco:DateTime', namespaces))
            self.datetimestamp = util.testXMLValue(val)
            
            val = md.find(util.nspath_eval('gmd:metadataStandardName/gco:CharacterString', namespaces))
            self.stdname = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:metadataStandardVersion/gco:CharacterString', namespaces))
            self.stdver = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:referenceSystemInfo/gmd:MD_ReferenceSystem', namespaces))
            if val is not None:
                self.referencesystem = MD_ReferenceSystem(val)
            else:
                self.referencesystem = None

            # TODO: merge .identificationinfo into .identification
            #warnings.warn(
            #    'the .identification and .serviceidentification properties will merge into '
            #    '.identification being a list of properties.  This is currently implemented '
            #    'in .identificationinfo.  '
            #    'Please see https://github.com/geopython/OWSLib/issues/38 for more information',
            #    FutureWarning)

            val = md.find(util.nspath_eval('gmd:identificationInfo/gmd:MD_DataIdentification', namespaces))
            val2 = md.find(util.nspath_eval('gmd:identificationInfo/srv:SV_ServiceIdentification', namespaces))

            if val is not None:
                self.identification = MD_DataIdentification(val, 'dataset')
                self.serviceidentification = None
            elif val2 is not None:
                self.identification = MD_DataIdentification(val2, 'service')
                self.serviceidentification = SV_ServiceIdentification(val2)
            else:
                self.identification = None
                self.serviceidentification = None

            self.identificationinfo = []
            for idinfo in md.findall(util.nspath_eval('gmd:identificationInfo', namespaces)):
                val = list(idinfo)[0]
                tagval = util.xmltag_split(val.tag)
                if tagval == 'MD_DataIdentification': 
                    self.identificationinfo.append(MD_DataIdentification(val, 'dataset'))
                elif tagval == 'MD_ServiceIdentification': 
                    self.identificationinfo.append(MD_DataIdentification(val, 'service'))
                elif tagval == 'SV_ServiceIdentification': 
                    self.identificationinfo.append(SV_ServiceIdentification(val))

            val = md.find(util.nspath_eval('gmd:distributionInfo/gmd:MD_Distribution', namespaces))

            if val is not None:
                self.distribution = MD_Distribution(val)
            else:
                self.distribution = None
            
            val = md.find(util.nspath_eval('gmd:dataQualityInfo/gmd:DQ_DataQuality', namespaces))
            if val is not None:
                self.dataquality = DQ_DataQuality(val)
            else:
                self.dataquality = None

class CI_Date(object):
    """ process CI_Date """
    def __init__(self, md=None):
        if md is None:
            self.date = None
            self.type = None
        else:
            val = md.find(util.nspath_eval('gmd:date/gco:Date', namespaces))
            if val is not None:
                self.date = util.testXMLValue(val)
            else:
                val = md.find(util.nspath_eval('gmd:date/gco:DateTime', namespaces))
                if val is not None:
                    self.date = util.testXMLValue(val)
                else:
                    self.date = None

            val = md.find(util.nspath_eval('gmd:dateType/gmd:CI_DateTypeCode', namespaces))
            self.type = _testCodeListValue(val)

class CI_ResponsibleParty(object):
    """ process CI_ResponsibleParty """
    def __init__(self, md=None):

        if md is None:
            self.name = None
            self.organization = None
            self.position = None
            self.phone = None
            self.fax = None
            self.address = None
            self.city = None
            self.region = None
            self.postcode = None
            self.country = None
            self.email = None
            self.onlineresource = None
            self.role = None
        else:
            val = md.find(util.nspath_eval('gmd:individualName/gco:CharacterString', namespaces))
            self.name = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:organisationName/gco:CharacterString', namespaces))
            self.organization = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:positionName/gco:CharacterString', namespaces))
            self.position = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:contactInfo/gmd:CI_Contact/gmd:phone/gmd:CI_Telephone/gmd:voice/gco:CharacterString', namespaces))

            self.phone = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:contactInfo/gmd:CI_Contact/gmd:phone/gmd:CI_Telephone/gmd:facsimile/gco:CharacterString', namespaces))
            self.fax = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:contactInfo/gmd:CI_Contact/gmd:address/gmd:CI_Address/gmd:deliveryPoint/gco:CharacterString', namespaces))
            self.address = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:contactInfo/gmd:CI_Contact/gmd:address/gmd:CI_Address/gmd:city/gco:CharacterString', namespaces))
            self.city = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:contactInfo/gmd:CI_Contact/gmd:address/gmd:CI_Address/gmd:administrativeArea/gco:CharacterString', namespaces))
            self.region = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:contactInfo/gmd:CI_Contact/gmd:address/gmd:CI_Address/gmd:postalCode/gco:CharacterString', namespaces))
            self.postcode = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:contactInfo/gmd:CI_Contact/gmd:address/gmd:CI_Address/gmd:country/gco:CharacterString', namespaces))
            self.country = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:contactInfo/gmd:CI_Contact/gmd:address/gmd:CI_Address/gmd:electronicMailAddress/gco:CharacterString', namespaces))
            self.email = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:contactInfo/gmd:CI_Contact/gmd:onlineResource/gmd:CI_OnlineResource', namespaces))
            if val is not None:
              self.onlineresource = CI_OnlineResource(val)
            else:
              self.onlineresource = None
          
            self.role = _testCodeListValue(md.find(util.nspath_eval('gmd:role/gmd:CI_RoleCode', namespaces)))

class MD_DataIdentification(object):
    """ process MD_DataIdentification """
    def __init__(self, md=None, identtype=None):
        if md is None:
            self.identtype = None
            self.title = None
            self.alternatetitle = None
            self.aggregationinfo = None
            self.uricode = []
            self.uricodespace = []
            self.date = []
            self.datetype = []
            self.uselimitation = []
            self.accessconstraints = []
            self.classification = []
            self.otherconstraints = []
            self.securityconstraints = []
            self.useconstraints = []
            self.denominators = []
            self.distance = []
            self.uom = []
            self.resourcelanguage = []
            self.creator = None
            self.publisher = None
            self.originator = None
            self.edition = None
            self.abstract = None
            self.purpose = None
            self.status = None
            self.contact = []
            self.keywords = []
            self.topiccategory = []
            self.supplementalinformation = None
            self.extent = None
            self.bbox = None
            self.temporalextent_start = None
            self.temporalextent_end = None
        else:
            self.identtype = identtype
            val = md.find(util.nspath_eval('gmd:citation/gmd:CI_Citation/gmd:title/gco:CharacterString', namespaces))
            self.title = util.testXMLValue(val)
            
            val = md.find(util.nspath_eval('gmd:citation/gmd:CI_Citation/gmd:alternateTitle/gco:CharacterString', namespaces))
            self.alternatetitle = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:aggregationInfo', namespaces))
            self.aggregationinfo = util.testXMLValue(val)

            self.uricode = []
            for i in md.findall(util.nspath_eval('gmd:citation/gmd:CI_Citation/gmd:identifier/gmd:RS_Identifier/gmd:code/gco:CharacterString', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.uricode.append(val)

            self.uricodespace = []
            for i in md.findall(util.nspath_eval('gmd:citation/gmd:CI_Citation/gmd:identifier/gmd:RS_Identifier/gmd:codeSpace/gco:CharacterString', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.uricodespace.append(val)

            self.date = []
            self.datetype = []
            
            for i in md.findall(util.nspath_eval('gmd:citation/gmd:CI_Citation/gmd:date/gmd:CI_Date', namespaces)):
                self.date.append(CI_Date(i))
            
            self.uselimitation = []
            for i in md.findall(util.nspath_eval('gmd:resourceConstraints/gmd:MD_Constraints/gmd:useLimitation/gco:CharacterString', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.uselimitation.append(val)
            
            self.accessconstraints = []
            for i in md.findall(util.nspath_eval('gmd:resourceConstraints/gmd:MD_LegalConstraints/gmd:accessConstraints/gmd:MD_RestrictionCode', namespaces)):
                val = _testCodeListValue(i)
                if val is not None:
                    self.accessconstraints.append(val)
            
            self.classification = []
            for i in md.findall(util.nspath_eval('gmd:resourceConstraints/gmd:MD_LegalConstraints/gmd:accessConstraints/gmd:MD_ClassificationCode', namespaces)):
                val = _testCodeListValue(i)
                if val is not None:
                    self.classification.append(val)
            
            self.otherconstraints = []
            for i in md.findall(util.nspath_eval('gmd:resourceConstraints/gmd:MD_LegalConstraints/gmd:otherConstraints/gco:CharacterString', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.otherconstraints.append(val)

            self.securityconstraints = []
            for i in md.findall(util.nspath_eval('gmd:resourceConstraints/gmd:MD_SecurityConstraints/gmd:useLimitation', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.securityconstraints.append(val)

            self.useconstraints = []
            for i in md.findall(util.nspath_eval('gmd:resourceConstraints/gmd:MD_LegalConstraints/gmd:useConstraints/gmd:MD_RestrictionCode', namespaces)):
                val = _testCodeListValue(i)
                if val is not None:
                    self.useconstraints.append(val)
            
            self.denominators = []
            for i in md.findall(util.nspath_eval('gmd:spatialResolution/gmd:MD_Resolution/gmd:equivalentScale/gmd:MD_RepresentativeFraction/gmd:denominator/gco:Integer', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.denominators.append(val)
            
            self.distance = []
            self.uom = []
            for i in md.findall(util.nspath_eval('gmd:spatialResolution/gmd:MD_Resolution/gmd:distance/gco:Distance', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.distance.append(val)
                self.uom.append(i.get("uom"))
            
            self.resourcelanguage = []
            for i in md.findall(util.nspath_eval('gmd:language/gmd:LanguageCode', namespaces)):
                val = _testCodeListValue(i)
                if val is not None:
                    self.resourcelanguage.append(val)

            val = md.find(util.nspath_eval('gmd:pointOfContact/gmd:CI_ResponsibleParty/gmd:organisationName', namespaces))
            if val is not None:
                val2 = val.find(util.nspath_eval('gmd:role/gmd:CI_RoleCode', namespaces)) 
                if val2 is not None:
                    clv = _testCodeListValue(val)
                    if clv == 'originator':
                        self.creator = util.testXMLValue(val)
                    elif clv == 'publisher':
                        self.publisher = util.testXMLValue(val)
                    elif clv == 'contributor':
                        self.originator = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:edition/gco:CharacterString', namespaces))
            self.edition = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:abstract/gco:CharacterString', namespaces))
            self.abstract = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:purpose/gco:CharacterString', namespaces))
            self.purpose = util.testXMLValue(val)

            self.status = _testCodeListValue(md.find(util.nspath_eval('gmd:status/gmd:MD_ProgressCode', namespaces)))

            self.contact = []
            for i in md.findall(util.nspath_eval('gmd:pointOfContact/gmd:CI_ResponsibleParty', namespaces)):
                o = CI_ResponsibleParty(i)
                self.contact.append(o)
            
            self.keywords = []

            for i in md.findall(util.nspath_eval('gmd:descriptiveKeywords', namespaces)):
                mdkw = {}
                mdkw['type'] = _testCodeListValue(i.find(util.nspath_eval('gmd:MD_Keywords/gmd:type/gmd:MD_KeywordTypeCode', namespaces)))

                mdkw['thesaurus'] = {}

                val = i.find(util.nspath_eval('gmd:MD_Keywords/gmd:thesaurusName/gmd:CI_Citation/gmd:title/gco:CharacterString', namespaces))
                mdkw['thesaurus']['title'] = util.testXMLValue(val)

                val = i.find(util.nspath_eval('gmd:MD_Keywords/gmd:thesaurusName/gmd:CI_Citation/gmd:date/gmd:CI_Date/gmd:date/gco:Date', namespaces))
                mdkw['thesaurus']['date'] = util.testXMLValue(val)

                val = i.find(util.nspath_eval('gmd:MD_Keywords/gmd:thesaurusName/gmd:CI_Citation/gmd:date/gmd:CI_Date/gmd:dateType/gmd:CI_DateTypeCode', namespaces))
                mdkw['thesaurus']['datetype'] = util.testXMLValue(val)

                mdkw['keywords'] = []

                for k in i.findall(util.nspath_eval('gmd:MD_Keywords/gmd:keyword', namespaces)):
                    val = k.find(util.nspath_eval('gco:CharacterString', namespaces))
                    if val is not None:
                        val2 = util.testXMLValue(val) 
                        if val2 is not None:
                            mdkw['keywords'].append(val2)

                self.keywords.append(mdkw)

            self.topiccategory = []
            for i in md.findall(util.nspath_eval('gmd:topicCategory/gmd:MD_TopicCategoryCode', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.topiccategory.append(val)
            
            val = md.find(util.nspath_eval('gmd:supplementalInformation/gco:CharacterString', namespaces))
            self.supplementalinformation = util.testXMLValue(val)
            
            # There may be multiple geographicElement, create an extent
            # from the one containing either an EX_GeographicBoundingBox or EX_BoundingPolygon.
            # The schema also specifies an EX_GeographicDescription. This is not implemented yet.
            val = None
            val2 = None
            val3 = None
            extents = md.findall(util.nspath_eval('gmd:extent', namespaces))
            extents.extend(md.findall(util.nspath_eval('srv:extent', namespaces)))
            for extent in extents:
                if val is None:
                    for e in extent.findall(util.nspath_eval('gmd:EX_Extent/gmd:geographicElement', namespaces)):
                        if e.find(util.nspath_eval('gmd:EX_GeographicBoundingBox', namespaces)) is not None or e.find(util.nspath_eval('gmd:EX_BoundingPolygon', namespaces)) is not None:
                            val = e
                            break
                    self.extent = EX_Extent(val)
                    self.bbox = self.extent.boundingBox  # for backwards compatibility

                if val2 is None:
                    val2 = extent.find(util.nspath_eval('gmd:EX_Extent/gmd:temporalElement/gmd:EX_TemporalExtent/gmd:extent/gml:TimePeriod/gml:beginPosition', namespaces))
                    if val2 is None:
                        val2 = extent.find(util.nspath_eval('gmd:EX_Extent/gmd:temporalElement/gmd:EX_TemporalExtent/gmd:extent/gml32:TimePeriod/gml32:beginPosition', namespaces))
                    self.temporalextent_start = util.testXMLValue(val2)

                if val3 is None:
                    val3 = extent.find(util.nspath_eval('gmd:EX_Extent/gmd:temporalElement/gmd:EX_TemporalExtent/gmd:extent/gml:TimePeriod/gml:endPosition', namespaces))
                    if val3 is None:
                        val3 = extent.find(util.nspath_eval('gmd:EX_Extent/gmd:temporalElement/gmd:EX_TemporalExtent/gmd:extent/gml32:TimePeriod/gml32:endPosition', namespaces))
                    self.temporalextent_end = util.testXMLValue(val3)

class MD_Distributor(object):        
    """ process MD_Distributor """
    def __init__(self, md=None):
        if md is None:
            self.contact = None
            self.online = []
        else:
            self.contact = None
            val = md.find(util.nspath_eval('gmd:MD_Distributor/gmd:distributorContact/gmd:CI_ResponsibleParty', namespaces))
            if val is not None:
                self.contact = CI_ResponsibleParty(val)

            self.online = []

            for ol in md.findall(util.nspath_eval('gmd:MD_Distributor/gmd:distributorTransferOptions/gmd:MD_DigitalTransferOptions/gmd:onLine/gmd:CI_OnlineResource', namespaces)):
                self.online.append(CI_OnlineResource(ol))

class MD_Distribution(object):
    """ process MD_Distribution """
    def __init__(self, md=None):
        if md is None:
            self.format = None
            self.version = None
            self.distributor = []
            self.online = []
            pass
        else:
            val = md.find(util.nspath_eval('gmd:distributionFormat/gmd:MD_Format/gmd:name/gco:CharacterString', namespaces))
            self.format = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:distributionFormat/gmd:MD_Format/gmd:version/gco:CharacterString', namespaces))
            self.version = util.testXMLValue(val)

            self.distributor = []
            for dist in md.findall(util.nspath_eval('gmd:distributor', namespaces)):
                self.distributor.append(MD_Distributor(dist))

            self.online = []

            for ol in md.findall(util.nspath_eval('gmd:transferOptions/gmd:MD_DigitalTransferOptions/gmd:onLine/gmd:CI_OnlineResource', namespaces)):
                self.online.append(CI_OnlineResource(ol))

        
class DQ_DataQuality(object):
    ''' process DQ_DataQuality'''
    def __init__(self, md=None):
        if md is None:
            self.conformancetitle = []
            self.conformancedate = []
            self.conformancedatetype = []
            self.conformancedegree = []
            self.lineage = None
            self.specificationtitle = None
            self.specificationdate = []
        else:
            self.conformancetitle = []
            for i in md.findall(util.nspath_eval('gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:specification/gmd:CI_Citation/gmd:title/gco:CharacterString', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.conformancetitle.append(val)
            
            self.conformancedate = []
            for i in md.findall(util.nspath_eval('gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:specification/gmd:CI_Citation/gmd:date/gmd:CI_Date/gmd:date/gco:Date', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.conformancedate.append(val)
            
            self.conformancedatetype = []
            for i in md.findall(util.nspath_eval('gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:specification/gmd:CI_Citation/gmd:date/gmd:CI_Date/gmd:dateType/gmd:CI_DateTypeCode', namespaces)):
                val = _testCodeListValue(i)
                if val is not None:
                    self.conformancedatetype.append(val)
            
            self.conformancedegree = []
            for i in md.findall(util.nspath_eval('gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:pass/gco:Boolean', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.conformancedegree.append(val)
            
            val = md.find(util.nspath_eval('gmd:lineage/gmd:LI_Lineage/gmd:statement/gco:CharacterString', namespaces))
            self.lineage = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:specification/gmd:CI_Citation/gmd:title/gco:CharacterString', namespaces))
            self.specificationtitle = util.testXMLValue(val)

            self.specificationdate = []
            for i in md.findall(util.nspath_eval('gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:specification/gmd:CI_Citation/gmd:date/gmd:CI_Date', namespaces)):
                val = util.testXMLValue(i)
                if val is not None:
                    self.specificationdate.append(val)

class SV_ServiceIdentification(object):
    """ process SV_ServiceIdentification """
    def __init__(self, md=None):
        if md is None:
            self.identtype = 'service'
            self.type = None
            self.version = None
            self.fees = None
            self.bbox = None
            self.couplingtype
            self.operations = []
            self.operateson = []
        else:
            self.identtype = 'service'
            val = md.find(util.nspath_eval('srv:serviceType/gco:LocalName', namespaces))
            self.type = util.testXMLValue(val)
          
            val = md.find(util.nspath_eval('srv:serviceTypeVersion/gco:CharacterString', namespaces))
            self.version = util.testXMLValue(val)

            val = md.find(util.nspath_eval('srv:accessProperties/gmd:MD_StandardOrderProcess/gmd:fees/gco:CharacterString', namespaces))
            self.fees = util.testXMLValue(val)

            val = md.find(util.nspath_eval('srv:extent/gmd:EX_Extent', namespaces))

            if val is not None:
                self.bbox = EX_Extent(val)
            else:
                self.bbox = None

            self.couplingtype = _testCodeListValue(md.find(util.nspath_eval('gmd:couplingType/gmd:SV_CouplingType', namespaces)))

            self.operations = []

            for i in md.findall(util.nspath_eval('srv:containsOperations', namespaces)):
                tmp = {}
                val = i.find(util.nspath_eval('srv:SV_OperationMetadata/srv:operationName/gco:CharacterString', namespaces))
                tmp['name'] = util.testXMLValue(val)
                tmp['dcplist'] = []
                for d in i.findall(util.nspath_eval('srv:SV_OperationMetadata/srv:DCP', namespaces)):
                    tmp2 = _testCodeListValue(d.find(util.nspath_eval('srv:DCPList', namespaces)))
                    tmp['dcplist'].append(tmp2)
             
                tmp['connectpoint'] = []
     
                for d in i.findall(util.nspath_eval('srv:SV_OperationMetadata/srv:connectPoint', namespaces)):
                    tmp3 = d.find(util.nspath_eval('gmd:CI_OnlineResource', namespaces))
                    tmp['connectpoint'].append(CI_OnlineResource(tmp3))
                self.operations.append(tmp)

            self.operateson = []
             
            for i in md.findall(util.nspath_eval('srv:operatesOn', namespaces)):
                tmp = {}
                tmp['uuidref'] = i.attrib.get('uuidref')
                tmp['href'] = i.attrib.get(util.nspath_eval('xlink:href', namespaces))
                tmp['title'] = i.attrib.get(util.nspath_eval('xlink:title', namespaces))
                self.operateson.append(tmp)

class CI_OnlineResource(object):
    """ process CI_OnlineResource """
    def __init__(self,md=None):
        if md is None:
            self.url = None
            self.protocol = None
            self.name = None
            self.description = None
            self.function = None
        else:
            val = md.find(util.nspath_eval('gmd:linkage/gmd:URL', namespaces))
            self.url = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:protocol/gco:CharacterString', namespaces))
            self.protocol = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:name/gco:CharacterString', namespaces))
            self.name = util.testXMLValue(val)

            val = md.find(util.nspath_eval('gmd:description/gco:CharacterString', namespaces))
            self.description = util.testXMLValue(val)

            self.function = _testCodeListValue(md.find(util.nspath_eval('gmd:function/gmd:CI_OnLineFunctionCode', namespaces)))


class EX_GeographicBoundingBox(object):
    def __init__(self, md=None):
        if md is None:
            self.minx = None
            self.maxx = None
            self.miny = None
            self.maxy = None
        else:
            val = md.find(util.nspath_eval('gmd:westBoundLongitude/gco:Decimal', namespaces))
            self.minx = util.testXMLValue(val)
            val = md.find(util.nspath_eval('gmd:eastBoundLongitude/gco:Decimal', namespaces))
            self.maxx = util.testXMLValue(val)
            val = md.find(util.nspath_eval('gmd:southBoundLatitude/gco:Decimal', namespaces))
            self.miny = util.testXMLValue(val)
            val = md.find(util.nspath_eval('gmd:northBoundLatitude/gco:Decimal', namespaces))
            self.maxy = util.testXMLValue(val)
    
class EX_Polygon(object):
    def __init__(self, md=None):
        if md is None:
            self.exterior_ring = None
            self.interior_rings = []
        else:
            linear_ring = md.find(util.nspath_eval('gml32:Polygon/gml32:exterior/gml32:LinearRing', namespaces))
            if linear_ring is not None:
                self.exterior_ring = self._coordinates_for_ring(linear_ring)
                        
            interior_ring_elements = md.findall(util.nspath_eval('gml32:Polygon/gml32:interior', namespaces))
            self.interior_rings = []
            for iring_element in interior_ring_elements:
                linear_ring = iring_element.find(util.nspath_eval('gml32:LinearRing', namespaces))
                self.interior_rings.append(self._coordinates_for_ring(linear_ring))
            
    def _coordinates_for_ring(self, linear_ring):
        coordinates = []
        positions = linear_ring.findall(util.nspath_eval('gml32:pos', namespaces))
        for pos in positions:
            tokens = pos.text.split()
            coords = tuple([float(t) for t in tokens])
            coordinates.append(coords)
        return coordinates
        
class EX_GeographicBoundingPolygon(object):
    def __init__(self, md=None):
        if md is None:
            self.is_extent
            self.polygons = []
        else:
            val = md.find(util.nspath_eval('gmd:extentTypeCode', namespaces))
            self.is_extent = util.testXMLValue(val)
            
            md_polygons = md.findall(util.nspath_eval('gmd:polygon', namespaces))
            
            self.polygons = []
            for val in md_polygons:
                self.polygons.append(EX_Polygon(val))
                
class EX_Extent(object):
    """ process EX_Extent """
    def __init__(self, md=None):
        if md is None:
            self.boundingBox = None
            self.boundingPolygon = None
            self.description_code = None
        else:
            self.boundingBox = None
            self.boundingPolygon = None

            if md is not None:
                bboxElement = md.find(util.nspath_eval('gmd:EX_GeographicBoundingBox', namespaces))
                if bboxElement is not None:
                    self.boundingBox = EX_GeographicBoundingBox(bboxElement)
            
                polygonElement = md.find(util.nspath_eval('gmd:EX_BoundingPolygon', namespaces))
                if polygonElement is not None:
                    self.boundingPolygon = EX_GeographicBoundingPolygon(polygonElement)
     
                val = md.find(util.nspath_eval('gmd:EX_GeographicDescription/gmd:geographicIdentifier/gmd:MD_Identifier/gmd:code/gco:CharacterString', namespaces))
                self.description_code = util.testXMLValue(val)

class MD_ReferenceSystem(object):
    """ process MD_ReferenceSystem """
    def __init__(self, md):
        if md is None:
            pass
        else:
            val = md.find(util.nspath_eval('gmd:referenceSystemIdentifier/gmd:RS_Identifier/gmd:code/gco:CharacterString', namespaces))
            self.code = util.testXMLValue(val)

def _testCodeListValue(elpath):
    """ get gco:CodeListValue_Type attribute, else get text content """
    if elpath is not None:  # try to get @codeListValue
        val = util.testXMLValue(elpath.attrib.get('codeListValue'), True)
        if val is not None:
            return val
        else:  # see if there is element text
            return util.testXMLValue(elpath)
    else:
        return None

class CodelistCatalogue(object):
    """ process CT_CodelistCatalogue """
    def __init__(self, ct):
        val = ct.find(util.nspath_eval('gmx:name/gco:CharacterString', namespaces))
        self.name = util.testXMLValue(val)
        val = ct.find(util.nspath_eval('gmx:scope/gco:CharacterString', namespaces))
        self.scope = util.testXMLValue(val)
        val = ct.find(util.nspath_eval('gmx:fieldOfApplication/gco:CharacterString', namespaces))
        self.fieldapp = util.testXMLValue(val)
        val = ct.find(util.nspath_eval('gmx:versionNumber/gco:CharacterString', namespaces))
        self.version = util.testXMLValue(val)
        val = ct.find(util.nspath_eval('gmx:versionDate/gco:Date', namespaces))
        self.date = util.testXMLValue(val)

        self.dictionaries = {}

        for i in ct.findall(util.nspath_eval('gmx:codelistItem/gmx:CodeListDictionary', namespaces)):
            id = i.attrib.get(util.nspath_eval('gml32:id', namespaces))
            self.dictionaries[id] = {}
            val = i.find(util.nspath_eval('gml32:description', namespaces))
            self.dictionaries[id]['description'] = util.testXMLValue(val)
            val = i.find(util.nspath_eval('gml32:identifier', namespaces))
            self.dictionaries[id]['identifier'] = util.testXMLValue(val)
            self.dictionaries[id]['entries'] = {}

            for j in i.findall(util.nspath_eval('gmx:codeEntry', namespaces)):
                id2 = j.find(util.nspath_eval('gmx:CodeDefinition', namespaces)).attrib.get(util.nspath_eval('gml32:id', namespaces))
                self.dictionaries[id]['entries'][id2] = {}
                val = j.find(util.nspath_eval('gmx:CodeDefinition/gml32:description', namespaces))
                self.dictionaries[id]['entries'][id2]['description'] = util.testXMLValue(val)

                val = j.find(util.nspath_eval('gmx:CodeDefinition/gml32:identifier', namespaces))
                self.dictionaries[id]['entries'][id2]['identifier'] = util.testXMLValue(val)

                val = j.find(util.nspath_eval('gmx:CodeDefinition', namespaces)).attrib.get('codeSpace')
                self.dictionaries[id]['entries'][id2]['codespace'] = util.testXMLValue(val, True)

    def getcodelistdictionaries(self):
        return self.dictionaries.keys()

    def getcodedefinitionidentifiers(self, cdl):
        if self.dictionaries.has_key(cdl):
            ids = []
            for i in self.dictionaries[cdl]['entries']:
                ids.append(self.dictionaries[cdl]['entries'][i]['identifier'])
            return ids
        else:
            return None


########NEW FILE########
__FILENAME__ = namespaces
class Namespaces(object):
    """
        Class for holding and maniputlating a dictionary containing the various namespaces for
        each standard.
    """

    namespace_dict = {
        'atom'  :   'http://www.w3.org/2005/Atom',
        'csw'   :   'http://www.opengis.net/cat/csw/2.0.2',
        'dc'    :   'http://purl.org/dc/elements/1.1/',
        'dct'   :   'http://purl.org/dc/terms/',
        'dif'   :   'http://gcmd.gsfc.nasa.gov/Aboutus/xml/dif/',
        'draw'  :   'gov.usgs.cida.gdp.draw',
        'fes'   :   'http://www.opengis.net/fes/2.0',
        'fgdc'  :   'http://www.opengis.net/cat/csw/csdgm',
        'gco'   :   'http://www.isotc211.org/2005/gco',
        'gmd'   :   'http://www.isotc211.org/2005/gmd',
        'gml'   :   'http://www.opengis.net/gml',
        'gml311':   'http://www.opengis.net/gml',
        'gml32' :   'http://www.opengis.net/gml/3.2',
        'gmx'   :   'http://www.isotc211.org/2005/gmx',
        'gts'   :   'http://www.isotc211.org/2005/gts',
        'ogc'   :   'http://www.opengis.net/ogc',
        'om'    :   'http://www.opengis.net/om/1.0',
        'om10'  :   'http://www.opengis.net/om/1.0',
        'om100' :   'http://www.opengis.net/om/1.0',
        'om20'  :   'http://www.opengis.net/om/2.0',
        'ows'   :   'http://www.opengis.net/ows',
        'ows100':   'http://www.opengis.net/ows',
        'ows110':   'http://www.opengis.net/ows/1.1',
        'ows200':   'http://www.opengis.net/ows/2.0',
        'rim'   :   'urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0',
        'rdf'   :   'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
        'sml'   :   'http://www.opengis.net/sensorML/1.0.1',
        'sml101':   'http://www.opengis.net/sensorML/1.0.1',
        'sos'   :   'http://www.opengis.net/sos/1.0',
        'sos20' :   'http://www.opengis.net/sos/2.0',
        'srv'   :   'http://www.isotc211.org/2005/srv',
        'swe'   :   'http://www.opengis.net/swe/1.0.1',
        'swe10' :   'http://www.opengis.net/swe/1.0',
        'swe101':   'http://www.opengis.net/swe/1.0.1',
        'swe20' :   'http://www.opengis.net/swe/2.0',
        'swes'  :   'http://www.opengis.net/swes/2.0',
        'tml'   :   'ttp://www.opengis.net/tml',
        'wfs'   :   'http://www.opengis.net/wfs',
        'wfs20' :   'http://www.opengis.net/wfs/2.0',
        'wcs'   :   'http://www.opengis.net/wcs',
        'wps'   :   'http://www.opengis.net/wps/1.0.0',
        'wps100':   'http://www.opengis.net/wps/1.0.0',
        'xlink' :   'http://www.w3.org/1999/xlink',
        'xs'    :   'http://www.w3.org/2001/XMLSchema',
        'xs2'   :   'http://www.w3.org/XML/Schema',
        'xsi'   :   'http://www.w3.org/2001/XMLSchema-instance'
    }    

    def get_namespace(self, key):
        """
            Retrieves a namespace from the dictionary

            Example:
            --------

            >>> from owslib.namespaces import Namespaces
            >>> ns = Namespaces()
            >>> ns.get_namespace('csw')
            'http://www.opengis.net/cat/csw/2.0.2'
            >>> ns.get_namespace('wfs20')
            'http://www.opengis.net/wfs/2.0'
        """
        retval = None
        if key in self.namespace_dict.keys():
            retval = self.namespace_dict[key]
        return retval
    
    def get_versioned_namespace(self, key, ver=None):
        """
            Retrieves a namespace from the dictionary with a specific version number

            Example:
            --------

            >>> from owslib.namespaces import Namespaces
            >>> ns = Namespaces()
            >>> ns.get_versioned_namespace('ows')
            'http://www.opengis.net/ows'
            >>> ns.get_versioned_namespace('ows','1.1.0')
            'http://www.opengis.net/ows/1.1'
        """
        
        if ver is None:
            return self.get_namespace(key)

        version = ''
        # Strip the decimals out of the passed in version
        for s in ver.split('.'):
            version += s
        
        key += version

        retval = None
        if key in self.namespace_dict.keys():
            retval = self.namespace_dict[key]
            
        return retval
    
    def get_namespaces(self, keys=None):
        """
            Retrieves a dict of namespaces from the namespace mapping

            Parameters
            ----------
            - keys: List of keys query and return

            Example:
            --------
            >>> ns = Namespaces()
            >>> x = ns.get_namespaces(['csw','gmd'])
            >>> x == {'csw': 'http://www.opengis.net/cat/csw/2.0.2', 'gmd': 'http://www.isotc211.org/2005/gmd'}
            True
            >>> x = ns.get_namespaces('csw')
            >>> x == {'csw': 'http://www.opengis.net/cat/csw/2.0.2'}
            True
            >>> ns.get_namespaces()
            {...}
        """
        # If we aren't looking for any namespaces in particular return the whole dict
        if keys is None or len(keys) == 0:
            return self.namespace_dict

        if isinstance(keys, unicode) or isinstance(keys, str):
            return { keys: self.get_namespace(keys) }

        retval = {}
        for key in keys:
            retval[key] = self.get_namespace(key)

        return retval

    def get_namespace_from_url(self, url):
        for k, v in self.namespace_dict.items():
            if v == url:
                return k
        return None

########NEW FILE########
__FILENAME__ = ows
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2008 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

"""
API for OGC Web Services Common (OWS) constructs and metadata.

OWS Common: http://www.opengeospatial.org/standards/common

Currently supports version 1.1.0 (06-121r3).
"""

from owslib.etree import etree
from owslib import crs, util
from owslib.namespaces import Namespaces
n = Namespaces()

OWS_NAMESPACE_1_0_0 = n.get_namespace("ows")
OWS_NAMESPACE_1_1_0 = n.get_namespace("ows110")
OWS_NAMESPACE_2_0   = n.get_namespace("ows200")
XSI_NAMESPACE       = n.get_namespace("xsi")
XLINK_NAMESPACE     = n.get_namespace("xlink")

DEFAULT_OWS_NAMESPACE=OWS_NAMESPACE_1_1_0     #Use this as default for OWSCommon objects

class OwsCommon(object):
    """Initialize OWS Common object"""
    def __init__(self,version):
        self.version = version
        if version == '1.0.0':
            self.namespace = OWS_NAMESPACE_1_0_0
        else:
            self.namespace = OWS_NAMESPACE_1_1_0
    
class ServiceIdentification(object):
    """Initialize an OWS Common ServiceIdentification construct"""
    def __init__(self,infoset,namespace=DEFAULT_OWS_NAMESPACE): 
        self._root = infoset

        val = self._root.find(util.nspath('Title', namespace))
        self.title = util.testXMLValue(val)

        val = self._root.find(util.nspath('Abstract', namespace))
        self.abstract = util.testXMLValue(val)

        self.keywords = []
        for f in self._root.findall(util.nspath('Keywords/Keyword', namespace)):
            if f.text is not None:
                self.keywords.append(f.text)
    

        val = self._root.find(util.nspath('AccessConstraints', namespace))
        self.accessconstraints = util.testXMLValue(val)

        val = self._root.find(util.nspath('Fees', namespace))
        self.fees = util.testXMLValue(val)

        val = self._root.find(util.nspath('ServiceType', namespace))
        self.type = util.testXMLValue(val)
        self.service=self.type #alternative? keep both?discuss

        val = self._root.find(util.nspath('ServiceTypeVersion', namespace))
        self.version = util.testXMLValue(val)

        self.profiles = []
        for p in self._root.findall(util.nspath('Profile', namespace)):
            self.profiles.append(util.testXMLValue(val))

class ServiceProvider(object):
    """Initialize an OWS Common ServiceProvider construct"""
    def __init__(self, infoset,namespace=DEFAULT_OWS_NAMESPACE):
        self._root = infoset
        val = self._root.find(util.nspath('ProviderName', namespace))
        self.name = util.testXMLValue(val)
        self.contact = ServiceContact(infoset, namespace)
        val = self._root.find(util.nspath('ProviderSite', namespace))
        if val is not None:
            urlattrib=val.attrib[util.nspath('href', XLINK_NAMESPACE)]
            self.url = util.testXMLValue(urlattrib, True)
        else:
            self.url =None

class ServiceContact(object):
    """Initialize an OWS Common ServiceContact construct"""
    def __init__(self, infoset,namespace=DEFAULT_OWS_NAMESPACE):
        self._root = infoset
        val = self._root.find(util.nspath('ProviderName', namespace))
        self.name = util.testXMLValue(val)
        
        self.organization=util.testXMLValue(self._root.find(util.nspath('ContactPersonPrimary/ContactOrganization', namespace)))
        
        val = self._root.find(util.nspath('ProviderSite', namespace))
        if val is not None:
            self.site = util.testXMLValue(val.attrib.get(util.nspath('href', XLINK_NAMESPACE)), True)
        else:
            self.site = None

        val = self._root.find(util.nspath('ServiceContact/Role', namespace))
        self.role = util.testXMLValue(val)

        val = self._root.find(util.nspath('ServiceContact/IndividualName', namespace))
        self.name = util.testXMLValue(val)
    
        val = self._root.find(util.nspath('ServiceContact/PositionName', namespace))
        self.position = util.testXMLValue(val)
 
        val = self._root.find(util.nspath('ServiceContact/ContactInfo/Phone/Voice', namespace))
        self.phone = util.testXMLValue(val)
    
        val = self._root.find(util.nspath('ServiceContact/ContactInfo/Phone/Facsimile', namespace))
        self.fax = util.testXMLValue(val)
    
        val = self._root.find(util.nspath('ServiceContact/ContactInfo/Address/DeliveryPoint', namespace))
        self.address = util.testXMLValue(val)
    
        val = self._root.find(util.nspath('ServiceContact/ContactInfo/Address/City', namespace))
        self.city = util.testXMLValue(val)
    
        val = self._root.find(util.nspath('ServiceContact/ContactInfo/Address/AdministrativeArea', namespace))
        self.region = util.testXMLValue(val)
    
        val = self._root.find(util.nspath('ServiceContact/ContactInfo/Address/PostalCode', namespace))
        self.postcode = util.testXMLValue(val)

        val = self._root.find(util.nspath('ServiceContact/ContactInfo/Address/Country', namespace))
        self.country = util.testXMLValue(val)
    
        val = self._root.find(util.nspath('ServiceContact/ContactInfo/Address/ElectronicMailAddress', namespace))
        self.email = util.testXMLValue(val)

        val = self._root.find(util.nspath('ServiceContact/ContactInfo/OnlineResource', namespace))
        if val is not None:
            self.url = util.testXMLValue(val.attrib.get(util.nspath('href', XLINK_NAMESPACE)), True)
        else:
            self.url = None

        val = self._root.find(util.nspath('ServiceContact/ContactInfo/HoursOfService', namespace))
        self.hours = util.testXMLValue(val)
    
        val = self._root.find(util.nspath('ServiceContact/ContactInfo/ContactInstructions', namespace))
        self.instructions = util.testXMLValue(val)
   

class Constraint(object):
    def __init__(self, elem, namespace=DEFAULT_OWS_NAMESPACE):
        self.name    = elem.attrib.get('name')
        self.values  = [i.text for i in elem.findall(util.nspath('Value', namespace))]
        self.values += [i.text for i in elem.findall(util.nspath('AllowedValues/Value', namespace))]

    def __repr__(self):
        if self.values:
            return "Constraint: %s - %s" % (self.name, self.values)
        else:
            return "Constraint: %s" % self.name


class OperationsMetadata(object):
    """Initialize an OWS OperationMetadata construct"""
    def __init__(self, elem, namespace=DEFAULT_OWS_NAMESPACE):
        self.name = elem.attrib['name']
        self.formatOptions = ['text/xml']
        parameters = []
        self.methods = []
        self.constraints = []

        for verb in elem.findall(util.nspath('DCP/HTTP/*', namespace)):
            url = util.testXMLAttribute(verb, util.nspath('href', XLINK_NAMESPACE))
            if url is not None:
                verb_constraints = [Constraint(conts, namespace) for conts in verb.findall(util.nspath('Constraint', namespace))]
                self.methods.append({'constraints' : verb_constraints, 'type' : util.xmltag_split(verb.tag), 'url': url})

        for parameter in elem.findall(util.nspath('Parameter', namespace)):
            if namespace == OWS_NAMESPACE_1_1_0:
                parameters.append((parameter.attrib['name'], {'values': [i.text for i in parameter.findall(util.nspath('AllowedValues/Value', namespace))]}))
            else:
                parameters.append((parameter.attrib['name'], {'values': [i.text for i in parameter.findall(util.nspath('Value', namespace))]}))
        self.parameters = dict(parameters)

        for constraint in elem.findall(util.nspath('Constraint', namespace)):
            self.constraints.append(Constraint(constraint, namespace))


class BoundingBox(object):
    """Initialize an OWS BoundingBox construct"""
    def __init__(self, elem, namespace=DEFAULT_OWS_NAMESPACE): 
        self.minx = None
        self.miny = None
        self.maxx = None
        self.maxy = None

        val = elem.attrib.get('crs')
        if val is not None:
            self.crs = crs.Crs(val)
        else:
            self.crs = None

        val = elem.attrib.get('dimensions')
        if val is not None:
            self.dimensions = int(util.testXMLValue(val, True))
        else:  # assume 2
            self.dimensions = 2

        val = elem.find(util.nspath('LowerCorner', namespace))
        tmp = util.testXMLValue(val)
        if tmp is not None:
            xy = tmp.split()
            if len(xy) > 1:
                if self.crs is not None and self.crs.axisorder == 'yx':
                    self.minx, self.miny = xy[1], xy[0] 
                else:
                    self.minx, self.miny = xy[0], xy[1]

        val = elem.find(util.nspath('UpperCorner', namespace))
        tmp = util.testXMLValue(val)
        if tmp is not None:
            xy = tmp.split()
            if len(xy) > 1:
                if self.crs is not None and self.crs.axisorder == 'yx':
                    self.maxx, self.maxy = xy[1], xy[0]
                else:
                    self.maxx, self.maxy = xy[0], xy[1]

class WGS84BoundingBox(BoundingBox):
    """WGS84 bbox, axis order xy"""
    def __init__(self, elem, namespace=DEFAULT_OWS_NAMESPACE):
        BoundingBox.__init__(self, elem, namespace)
        self.dimensions = 2
        self.crs = crs.Crs('urn:ogc:def:crs:OGC:2:84')



class ExceptionReport(Exception):
    """OWS ExceptionReport"""

    def __init__(self, elem, namespace=DEFAULT_OWS_NAMESPACE):
        self.exceptions = []

        if hasattr(elem, 'getroot'):
            elem = elem.getroot()
            
        for i in elem.findall(util.nspath('Exception', namespace)):
            tmp = {}
            val = i.attrib.get('exceptionCode')
            tmp['exceptionCode'] = util.testXMLValue(val, True)
            val = i.attrib.get('locator')
            tmp['locator'] = util.testXMLValue(val, True)
            val = i.find(util.nspath('ExceptionText', namespace))
            tmp['ExceptionText'] = util.testXMLValue(val)
            self.exceptions.append(tmp)

        # set topmost stacktrace as return message
        self.code = self.exceptions[0]['exceptionCode']
        self.locator = self.exceptions[0]['locator']
        self.msg = self.exceptions[0]['ExceptionText']
        self.xml = etree.tostring(elem)

    def __str__(self):
        return repr(self.msg)

########NEW FILE########
__FILENAME__ = sos
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2013 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

"""
Sensor Observation Service (SOS) methods and metadata. Factory function.
"""

from swe.observation import sos100, sos200

def SensorObservationService(url, version='1.0.0', xml=None):
    """sos factory function, returns a version specific SensorObservationService object"""
    if version in  ['1.0', '1.0.0']:
        return sos100.SensorObservationService_1_0_0.__new__(sos100.SensorObservationService_1_0_0, url, version, xml)
    elif version in ['2.0', '2.0.0']:
        return sos200.SensorObservationService_2_0_0.__new__(sos200.SensorObservationService_2_0_0, url, version, xml)


########NEW FILE########
__FILENAME__ = common
from owslib.util import nspath_eval
from owslib.namespaces import Namespaces
from owslib.util import testXMLAttribute, testXMLValue, InfiniteDateTime, NegativeInfiniteDateTime

from dateutil import parser
from datetime import timedelta

from owslib.etree import etree

def get_namespaces():
    ns = Namespaces()
    return ns.get_namespaces(["swe20", "xlink"])
namespaces = get_namespaces()

def nspv(path):
    return nspath_eval(path, namespaces)

def make_pair(string, cast=None):
    if string is None:
        return None

    string = string.split(" ")
    if cast is not None:
        try:
            string = map(lambda x: cast(x), string)
        except:
            print "Could not cast pair to correct type.  Setting to an empty tuple!"
            string = ""

    return tuple(string)

def get_uom(element):

    uom = testXMLAttribute(element, "code")
    if uom is None:
        uom = testXMLAttribute(element, nspv("xlink:href"))
    return uom

def get_boolean(value):
    if value is None:
        return None
    if value is True or value.lower() in ["yes","true"]:
        return True
    elif value is False or value.lower() in ["no","false"]:
        return False
    else:
        return None

def get_int(value):
    try:
        return int(value)
    except:
        return None

def get_float(value):
    try:
        return float(value)
    except:
        return None

AnyScalar    = map(lambda x: nspv(x), ["swe20:Boolean", "swe20:Count", "swe20:Quantity", "swe20:Time", "swe20:Category", "swe20:Text"])
AnyNumerical = map(lambda x: nspv(x), ["swe20:Count", "swe20:Quantity", "swe20:Time"])
AnyRange     = map(lambda x: nspv(x), ["swe20:QuantityRange", "swe20:TimeRange", "swe20:CountRange", "swe20:CategoryRange"])

class NamedObject(object):
    def __init__(self, element):
        # No call to super(), the type object will process that.
        self.name           = testXMLAttribute(element, "name")
        try:
            self.content    = eval(element[-1].tag.split("}")[-1])(element[-1])
        except IndexError:
            self.content    = None
        except BaseException:
            raise

    # Revert to the content if attribute does not exists
    def __getattr__(self, name):
        return getattr(self.content, name)

class AbstractSWE(object):
    def __init__(self, element):
        # Attributes
        self.id             = testXMLAttribute(element,"id")   # string, optional

        # Elements
        self.extention      = []                            # anyType, min=0, max=X

class AbstractSWEIdentifiable(AbstractSWE):
    def __init__(self, element):
        super(AbstractSWEIdentifiable, self).__init__(element)
        # Elements
        self.identifier     = testXMLValue(element.find(nspv("swe20:identifier")))    # anyURI, min=0
        self.label          = testXMLValue(element.find(nspv("swe20:label")))         # string, min=0
        self.description    = testXMLValue(element.find(nspv("swe20:description")))   # string, min=0

class AbstractDataComponent(AbstractSWEIdentifiable):
    def __init__(self, element):
        super(AbstractDataComponent, self).__init__(element)
        # Attributes
        self.definition     = testXMLAttribute(element,"definition")                        # anyURI, required
        self.updatable      = get_boolean(testXMLAttribute(element,"updatable"))            # boolean, optional
        self.optional       = get_boolean(testXMLAttribute(element,"optional")) or False    # boolean, default=False

class AbstractSimpleComponent(AbstractDataComponent):
    def __init__(self, element):
        super(AbstractSimpleComponent, self).__init__(element)
        # Attributes
        self.referenceFrame = testXMLAttribute(element,"referenceFrame")    # anyURI, optional
        self.axisID         = testXMLAttribute(element,"axisID")            # string, optional

        # Elements
        self.quality        = filter(None, [Quality(q) for q in [e.find('*') for e in element.findall(nspv("swe20:quality"))] if q is not None])
        try:
            self.nilValues  = NilValues(element.find(nspv("swe20:nilValues")))
        except:
            self.nilValues  = None

class Quality(object):
    def __new__(cls, element):
        t = element.tag.split("}")[-1]
        if t == "Quantity":
            return Quantity(element)
        elif t == "QuantityRange":
            return QuantityRange(element)
        elif t == "Category":
            return Category(element)
        elif t == "Text":
            return Text(element)
        else:
            return None

class NilValues(AbstractSWE):
    def __init__(self, element):
        super(NilValues, self).__init__(element)
        self.nilValue           = filter(None, [nilValue(x) for x in element.findall(nspv("swe20:nilValue"))]) # string, min=0, max=X

class nilValue(object):
    def __init__(self, element):
        self.reason             = testXMLAttribute(element, "reason")
        self.value              = testXMLValue(element)

class AllowedTokens(AbstractSWE):
    def __init__(self, element):
        super(AllowedTokens, self).__init__(element)
        self.value              = filter(None, [testXMLValue(x) for x in element.findall(nspv("swe20:value"))]) # string, min=0, max=X
        self.pattern            = testXMLValue(element.find(nspv("swe20:pattern")))                             # string (Unicode Technical Standard #18, Version 13), min=0

class AllowedValues(AbstractSWE):
    def __init__(self, element):
        super(AllowedValues, self).__init__(element)
        self.value              = filter(None, map(lambda x: get_float(x), [testXMLValue(x) for x in element.findall(nspv("swe20:value"))]))
        self.interval           = filter(None, [make_pair(testXMLValue(x)) for x in element.findall(nspv("swe20:interval"))])
        self.significantFigures = get_int(testXMLValue(element.find(nspv("swe20:significantFigures"))))                                         # integer, min=0

class AllowedTimes(AbstractSWE):
    def __init__(self, element):
        super(AllowedTimes, self).__init__(element)
        self.value              = filter(None, [testXMLValue(x) for x in element.findall(nspv("swe20:value"))])
        self.interval           = filter(None, [make_pair(testXMLValue(x)) for x in element.findall(nspv("swe20:interval"))])
        self.significantFigures = get_int(testXMLValue(element.find(nspv("swe20:significantFigures"))))                         # integer, min=0

class Boolean(AbstractSimpleComponent):
    def __init__(self, element):
        super(Boolean, self).__init__(element)
        # Elements
        """
        6.2.1 Boolean
                A Boolean representation of a proptery can take only two values that should be "true/false" or "yes/no".
        """
        value               = get_boolean(testXMLValue(element.find(nspv("swe20:value"))))   # boolean, min=0, max=1

class Text(AbstractSimpleComponent):
    def __init__(self, element):
        super(Text, self).__init__(element)
        # Elements
        """
        Req 6. A textual representation shall at least consist of a character string.
        """
        self.value          = testXMLValue(element.find(nspv("swe20:value")))                               # string, min=0, max=1

        try:
            self.constraint     = AllowedTokens(element.find(nspv("swe20:constraint/swe20:AllowedTokens"))) # AllowedTokens, min=0, max=1
        except:
            self.constraint     = None


class Category(AbstractSimpleComponent):
    def __init__(self, element):
        super(Category, self).__init__(element)
        # Elements
        self.codeSpace      = testXMLAttribute(element.find(nspv("swe20:codeSpace")), nspv("xlink:href"))   # Reference, min=0, max=1
        self.value          = testXMLValue(element.find(nspv("swe20:value")))                               # string, min=0, max=1

        try:
            self.constraint     = AllowedTokens(element.find(nspv("swe20:constraint/swe20:AllowedTokens"))) # AllowedTokens, min=0, max=1
        except:
            self.constraint     = None


class CategoryRange(Category):
    def __init__(self, element):
        super(CategoryRange, self).__init__(element)
        # Elements
        value               = testXMLValue(element.find(nspv("swe20:value")))
        self.values         = make_pair(value) if value is not None else None

class Count(AbstractSimpleComponent):
    def __init__(self, element):
        super(Count, self).__init__(element)
        # Elements
        self.value          = get_int(testXMLValue(element.find(nspv("swe20:value"))))                  # integer, min=0, max=1

        try:
            self.constraint = AllowedValues(element.find(nspv("swe20:constraint/swe20:AllowedValues"))) # AllowedValues, min=0, max=1
        except:
            self.constraint = None


class CountRange(Count):
    def __init__(self, element):
        super(CountRange, self).__init__(element)
        # Elements
        value               = testXMLValue(element.find(nspv("swe20:value")))
        self.value          = make_pair(value,int) if value is not None else None

class Quantity(AbstractSimpleComponent):
    def __init__(self, element):
        super(Quantity, self).__init__(element)
        # Elements
        self.uom            = get_uom(element.find(nspv("swe20:uom")))
        self.value          = get_float(testXMLValue(element.find(nspv("swe20:value"))))                  # double, min=0, max=1

        try:
            self.constraint = AllowedValues(element.find(nspv("swe20:constraint/swe20:AllowedValues")))   # AllowedValues, min=0, max=1
        except:
            self.constraint = None

class QuantityRange(Quantity):
    def __init__(self, element):
        super(QuantityRange, self).__init__(element)
        # Elements
        value               = testXMLValue(element.find(nspv("swe20:value")))
        self.value          = make_pair(value,float) if value is not None else None

def get_time(value, referenceTime, uom):
    try:
        value = parser.parse(value)

    except (AttributeError, ValueError): # Most likely an integer/float using a referenceTime
        try:
            if uom.lower() == "s":
                value  = referenceTime + timedelta(seconds=float(value))
            elif uom.lower() == "min":
                value  = referenceTime + timedelta(minutes=float(value))
            elif uom.lower() == "h":
                value  = referenceTime + timedelta(hours=float(value))
            elif uom.lower() == "d":
                value  = referenceTime + timedelta(days=float(value))

        except (AttributeError, ValueError):
            pass

    except OverflowError: # Too many numbers (> 10) or INF/-INF
        if value.lower() == "inf":
            value  = InfiniteDateTime()
        elif value.lower() == "-inf":
            value  = NegativeInfiniteDateTime()

    return value

class Time(AbstractSimpleComponent):
    def __init__(self, element):
        super(Time, self).__init__(element)
        # Elements
        self.uom                = get_uom(element.find(nspv("swe20:uom")))

        try:
            self.constraint     = AllowedTimes(element.find(nspv("swe20:constraint/swe20:AllowedTimes"))) # AllowedTimes, min=0, max=1
        except:
            self.constraint     = None

        # Attributes
        self.localFrame         = testXMLAttribute(element,"localFrame")                                    # anyURI, optional
        try:
            self.referenceTime  = parser.parse(testXMLAttribute(element,"referenceTime"))                   # dateTime, optional
        except (AttributeError, ValueError):
            self.referenceTime  = None

        value                   = testXMLValue(element.find(nspv("swe20:value")))                           # TimePosition, min=0, max=1
        self.value              = get_time(value, self.referenceTime, self.uom)

class TimeRange(AbstractSimpleComponent):
    def __init__(self, element):
        super(TimeRange, self).__init__(element)
        # Elements
        self.uom                = get_uom(element.find(nspv("swe20:uom")))

        try:
            self.constraint     = AllowedTimes(element.find(nspv("swe20:constraint/swe20:AllowedTimes"))) # AllowedTimes, min=0, max=1
        except:
            self.constraint     = None

        # Attributes
        self.localFrame         = testXMLAttribute(element,"localFrame")                                # anyURI, optional
        try:
            self.referenceTime  = parser.parse(testXMLAttribute(element,"referenceTime"))               # dateTime, optional
        except (AttributeError, ValueError):
            self.referenceTime  = None

        values                  = make_pair(testXMLValue(element.find(nspv("swe20:value"))))            # TimePosition, min=0, max=1
        self.value              = [get_time(t, self.referenceTime, self.uom) for t in values]

class DataRecord(AbstractDataComponent):
    def __init__(self, element):
        super(DataRecord, self).__init__(element)
        # Elements
        self.field          = [Field(x) for x in element.findall(nspv("swe20:field"))]
    def get_by_name(self, name):
        return next((x for x in self.field if x.name == name), None)

class Field(NamedObject):
    def __init__(self, element):
        super(Field, self).__init__(element)

class Vector(AbstractDataComponent):
    def __init__(self, element):
        super(Vector, self).__init__(element)
        # Elements
        self.coordinate     = [Coordinate(x) for x in element.findall(nspv("swe20:coordinate"))]

        # Attributes
        self.referenceFrame = testXMLAttribute(element,"referenceFrame")        # anyURI, required
        self.localFrame     = testXMLAttribute(element,"localFrame")            # anyURI, optional
    def get_by_name(self, name):
        return next((x for x in self.coordinate if x.name == name), None)

class Coordinate(NamedObject):
    def __init__(self, element):
        super(Coordinate, self).__init__(element)
        #if element[-1].tag not in AnyNumerical:
        #    print "Coordinate does not appear to be an AnyNumerical member"

class DataChoice(AbstractDataComponent):
    def __init__(self, element):
        super(DataChoice, self).__init__(element)
        self.item           = [Item(x) for x in element.findall(nspv("swe20:item"))]
    def get_by_name(self, name):
        return next((x for x in self.item if x.name == name), None)

class Item(NamedObject):
    def __init__(self, element):
        super(Item, self).__init__(element)

class DataArray(AbstractDataComponent):
    def __init__(self, element):
        super(DataArray, self).__init__(element)
        self.elementCount   = element.find(nspv("swe20:elementCount/swe20:Count"))      # required
        self.elementType    = ElementType(element.find(nspv("swe20:elementType")))      # required
        self.values         = testXMLValue(element.find(nspv("swe20:values")))
        try:
            self.encoding   = AbstractEncoding(element.find(nspv("swe20:encoding")))
        except:
            self.encoding   = None

class Matrix(AbstractDataComponent):
    def __init__(self, element):
        super(Matrix, self).__init__(element)
        self.elementCount   = element.find(nspv("swe20:elementCount/swe20:Count"))      # required
        self.elementType    = ElementType(element.find(nspv("swe20:elementType")))      # required
        self.encoding       = AbstractEncoding(element.find(nspv("swe20:encoding")))
        self.values         = testXMLValue(element.find(nspv("swe20:values")))
        self.referenceFrame = testXMLAttribute(element, "referenceFrame")               # anyURI, required
        self.localFrame     = testXMLAttribute(element, "localFrame")                   # anyURI, optional

class DataStream(AbstractSWEIdentifiable):
    def __init__(self, element):
        super(DataStream, self).__init__(element)
        self.elementCount   = element.find(nspv("swe20:elementCount/swe20:Count"))      # optional
        self.elementType    = ElementType(element.find(nspv("swe20:elementType")))      # optional
        self.encoding       = AbstractEncoding(element.find(nspv("swe20:encoding")))
        self.values         = testXMLValue(element.find(nspv("swe20:values")))

class ElementType(NamedObject):
    def __init__(self, element):
        super(ElementType, self).__init__(element)

class AbstractEncoding(object):
    def __new__(cls, element):
        t = element[-1].tag.split("}")[-1]
        if t == "TextEncoding":
            return super(AbstractEncoding, cls).__new__(TextEncoding, element)
        elif t == "XMLEncoding":
            return super(AbstractEncoding, cls).__new__(XMLEncoding, element)
        elif t == "BinaryEncoding":
            return super(AbstractEncoding, cls).__new__(BinaryEncoding, element)

class TextEncoding(AbstractEncoding):
    def __init__(self, element):
        self.tokenSeparator         = testXMLAttribute(element[-1], "tokenSeparator")                           # string,  required
        self.blockSeparator         = testXMLAttribute(element[-1], "blockSeparator")                           # string,  required
        self.decimalSeparator       = testXMLAttribute(element[-1], "decimalSeparator") or "."                  # string,  optional, default="."
        self.collapseWhiteSpaces    = get_boolean(testXMLAttribute(element[-1], "collapseWhiteSpaces")) or True # boolean, optional, default=True

class XMLEncoding(AbstractEncoding):
    def __init__(self, element):
        raise NotImplementedError

class BinaryEncoding(AbstractEncoding):
    def __init__(self, element):
        raise NotImplementedError
########NEW FILE########
__FILENAME__ = sos100
import cgi
from owslib.etree import etree
from datetime import datetime
from urllib import urlencode
from owslib import ows
from owslib.crs import Crs
from owslib.fes import FilterCapabilities
from owslib.util import openURL, testXMLValue, nspath_eval, nspath, extract_time
from owslib.namespaces import Namespaces

def get_namespaces():
    n = Namespaces()
    ns = n.get_namespaces(["ogc","sml","gml","sos","swe","xlink"])
    ns["ows"] = n.get_namespace("ows110")
    return ns
namespaces = get_namespaces()

class SensorObservationService_1_0_0(object):
    """
        Abstraction for OGC Sensor Observation Service (SOS).

        Implements ISensorObservationService.
    """

    def __new__(self,url, version, xml=None, username=None, password=None):
        """overridden __new__ method"""
        obj=object.__new__(self)
        obj.__init__(url, version, xml, username, password)
        return obj

    def __getitem__(self,id):
        ''' check contents dictionary to allow dict like access to service observational offerings'''
        if name in self.__getattribute__('contents').keys():
            return self.__getattribute__('contents')[id]
        else:
            raise KeyError, "No Observational Offering with id: %s" % id

    def __init__(self, url, version='1.0.0', xml=None, username=None, password=None):
        """Initialize."""
        self.url = url
        self.username = username
        self.password = password
        self.version = version
        self._capabilities = None

        # Authentication handled by Reader
        reader = SosCapabilitiesReader(
                version=self.version, url=self.url, username=self.username, password=self.password
                )
        if xml:  # read from stored xml
            self._capabilities = reader.read_string(xml)
        else:  # read from server
            self._capabilities = reader.read(self.url)

        # Avoid building metadata if the response is an Exception
        if self._capabilities.tag == nspath_eval("ows:ExceptionReport", namespaces):
            raise ows.ExceptionReport(self._capabilities)

        # build metadata objects
        self._build_metadata()

    def getOperationByName(self, name):
        """Return a named content item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError("No operation named %s" % name)

    def _build_metadata(self):
        """ 
            Set up capabilities metadata objects
        """
        # ows:ServiceIdentification metadata
        service_id_element = self._capabilities.find(nspath_eval('ows:ServiceIdentification', namespaces))
        self.identification = ows.ServiceIdentification(service_id_element)
        
        # ows:ServiceProvider metadata
        service_provider_element = self._capabilities.find(nspath_eval('ows:ServiceProvider', namespaces))
        self.provider = ows.ServiceProvider(service_provider_element)
            
        # ows:OperationsMetadata metadata
        self.operations=[]
        for elem in self._capabilities.findall(nspath_eval('ows:OperationsMetadata/ows:Operation', namespaces)):
            self.operations.append(ows.OperationsMetadata(elem))

        # sos:FilterCapabilities
        filters = self._capabilities.find(nspath_eval('sos:Filter_Capabilities', namespaces))
        if filters is not None:
            self.filters = FilterCapabilities(filters)
        else:
            self.filters = None

        # sos:Contents metadata
        self.contents = {}
        self.offerings = []
        for offering in self._capabilities.findall(nspath_eval('sos:Contents/sos:ObservationOfferingList/sos:ObservationOffering', namespaces)):
            off = SosObservationOffering(offering)
            self.contents[off.id] = off
            self.offerings.append(off)

    def describe_sensor(self,   outputFormat=None,
                                procedure=None,
                                method='Get',
                                **kwargs):

        try:
            base_url = next((m.get('url') for m in self.getOperationByName('DescribeSensor').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url
        request = {'service': 'SOS', 'version': self.version, 'request': 'DescribeSensor'}

        # Required Fields
        assert isinstance(outputFormat, str)
        request['outputFormat'] = outputFormat

        assert isinstance(procedure, str)
        request['procedure'] = procedure

        # Optional Fields
        if kwargs:
            for kw in kwargs:
                request[kw]=kwargs[kw]
       
        data = urlencode(request)        

        response = openURL(base_url, data, method, username=self.username, password=self.password).read()
        tr = etree.fromstring(response)

        if tr.tag == nspath_eval("ows:ExceptionReport", namespaces):
            raise ows.ExceptionReport(tr)

        return response

    def get_observation(self,   responseFormat=None,
                                offerings=None,
                                observedProperties=None,
                                eventTime=None,
                                method='Get',
                                **kwargs):
        """
        Parameters
        ----------
        format : string
            Output format. Provide one that is available for all offerings
        method : string
            Optional. HTTP DCP method name: Get or Post.  Must
        **kwargs : extra arguments
            anything else e.g. vendor specific parameters
        """
        try:
            base_url = next((m.get('url') for m in self.getOperationByName('GetObservation').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url

        request = {'service': 'SOS', 'version': self.version, 'request': 'GetObservation'}

        # Required Fields
        assert isinstance(offerings, list) and len(offerings) > 0
        request['offering'] = ','.join(offerings)

        assert isinstance(observedProperties, list) and len(observedProperties) > 0
        request['observedProperty'] = ','.join(observedProperties)

        assert isinstance(responseFormat, str)
        request['responseFormat'] = responseFormat


        # Optional Fields
        if eventTime is not None:
            request['eventTime'] = eventTime

        if kwargs:
            for kw in kwargs:
                request[kw]=kwargs[kw]

        data = urlencode(request)        

        response = openURL(base_url, data, method, username=self.username, password=self.password).read()
        try:
            tr = etree.fromstring(response)
            if tr.tag == nspath_eval("ows:ExceptionReport", namespaces):
                raise ows.ExceptionReport(tr)
            else:
                return response                
        except ows.ExceptionReport:
            raise
        except BaseException:
            return response

    def get_operation_by_name(self, name): 
        """
            Return a Operation item by name, case insensitive
        """
        for item in self.operations:
            if item.name.lower() == name.lower():
                return item
        raise KeyError, "No Operation named %s" % name

class SosObservationOffering(object):
    def __init__(self, element):
        self._root = element

        self.id = testXMLValue(self._root.attrib.get(nspath_eval('gml:id', namespaces)), True)
        self.description = testXMLValue(self._root.find(nspath_eval('gml:description', namespaces)))
        self.name = testXMLValue(self._root.find(nspath_eval('gml:name', namespaces)))
        val = testXMLValue(self._root.find(nspath_eval('gml:srsName', namespaces)))
        if val is not None:
            self.srs = Crs(val)

        # LOOK: Check on GML boundedBy to make sure we handle all of the cases
        # gml:boundedBy
        try:
            envelope = self._root.find(nspath_eval('gml:boundedBy/gml:Envelope', namespaces))
            lower_left_corner = testXMLValue(envelope.find(nspath_eval('gml:lowerCorner', namespaces))).split()
            upper_right_corner = testXMLValue(envelope.find(nspath_eval('gml:upperCorner', namespaces))).split()
            # (left, bottom, right, top) in self.bbox_srs units
            self.bbox = (float(lower_left_corner[1]), float(lower_left_corner[0]), float(upper_right_corner[1]), float(upper_right_corner[0]))
            self.bbox_srs = Crs(testXMLValue(envelope.attrib.get('srsName'), True))
        except Exception, err:
            self.bbox = None
            self.bbox_srs = None

        # LOOK: Support all gml:TimeGeometricPrimitivePropertyType
        # Right now we are just supporting gml:TimePeriod
        # sos:Time
        begin_position_element = self._root.find(nspath_eval('sos:time/gml:TimePeriod/gml:beginPosition', namespaces))
        self.begin_position = extract_time(begin_position_element)
        end_position_element = self._root.find(nspath_eval('sos:time/gml:TimePeriod/gml:endPosition', namespaces))
        self.end_position = extract_time(end_position_element)

        self.result_model = testXMLValue(self._root.find(nspath_eval('sos:resultModel', namespaces)))

        self.procedures = []
        for proc in self._root.findall(nspath_eval('sos:procedure', namespaces)):
            self.procedures.append(testXMLValue(proc.attrib.get(nspath_eval('xlink:href', namespaces)), True))

        # LOOK: Support swe:Phenomenon here
        # this includes compound properties
        self.observed_properties = []
        for op in self._root.findall(nspath_eval('sos:observedProperty', namespaces)):
            self.observed_properties.append(testXMLValue(op.attrib.get(nspath_eval('xlink:href', namespaces)), True))

        self.features_of_interest = []
        for fot in self._root.findall(nspath_eval('sos:featureOfInterest', namespaces)):
            self.features_of_interest.append(testXMLValue(fot.attrib.get(nspath_eval('xlink:href', namespaces)), True))

        self.response_formats = []
        for rf in self._root.findall(nspath_eval('sos:responseFormat', namespaces)):
            self.response_formats.append(testXMLValue(rf))

        self.response_modes = []
        for rm in self._root.findall(nspath_eval('sos:responseMode', namespaces)):
            self.response_modes.append(testXMLValue(rm))

    def __str__(self):
        return 'Offering id: %s, name: %s' % (self.id, self.name)
        
class SosCapabilitiesReader(object):
    def __init__(self, version="1.0.0", url=None, username=None, password=None):
        self.version = version
        self.url = url
        self.username = username
        self.password = password

    def capabilities_url(self, service_url):
        """
            Return a capabilities url
        """
        qs = []
        if service_url.find('?') != -1:
            qs = cgi.parse_qsl(service_url.split('?')[1])

        params = [x[0] for x in qs]

        if 'service' not in params:
            qs.append(('service', 'SOS'))
        if 'request' not in params:
            qs.append(('request', 'GetCapabilities'))
        if 'acceptVersions' not in params:
            qs.append(('acceptVersions', self.version))

        urlqs = urlencode(tuple(qs))
        return service_url.split('?')[0] + '?' + urlqs

    def read(self, service_url):
        """
            Get and parse a WMS capabilities document, returning an
            elementtree instance

            service_url is the base url, to which is appended the service,
            acceptVersions, and request parameters
        """
        getcaprequest = self.capabilities_url(service_url)
        spliturl=getcaprequest.split('?')
        u = openURL(spliturl[0], spliturl[1], method='Get', username=self.username, password=self.password)
        return etree.fromstring(u.read())

    def read_string(self, st):
        """
            Parse a SOS capabilities document, returning an elementtree instance

            st should be an XML capabilities document
        """
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        return etree.fromstring(st)


########NEW FILE########
__FILENAME__ = sos200
import cgi
from owslib.etree import etree
from datetime import datetime
from urllib import urlencode
from owslib import ows
from owslib.crs import Crs
from owslib.fes import FilterCapabilities200
from owslib.util import openURL, testXMLValue, nspath_eval, nspath, extract_time
from owslib.namespaces import Namespaces

def get_namespaces():
    n = Namespaces()
    ns = n.get_namespaces(["fes","ogc","om","gml32","sml","swe20","swes","xlink"])
    ns["ows"] = n.get_namespace("ows110")
    ns["sos"] = n.get_namespace("sos20")
    return ns
namespaces = get_namespaces()


class SensorObservationService_2_0_0(object):
    """
        Abstraction for OGC Sensor Observation Service (SOS).

        Implements ISensorObservationService.
    """

    def __new__(self,url, version, xml=None, username=None, password=None):
        """overridden __new__ method"""
        obj=object.__new__(self)
        obj.__init__(url, version, xml, username, password)
        return obj

    def __getitem__(self,id):
        ''' check contents dictionary to allow dict like access to service observational offerings'''
        if name in self.__getattribute__('contents').keys():
            return self.__getattribute__('contents')[id]
        else:
            raise KeyError, "No Observational Offering with id: %s" % id

    def __init__(self, url, version='2.0.0', xml=None, username=None, password=None):
        """Initialize."""
        self.url = url
        self.username = username
        self.password = password
        self.version = version
        self._capabilities = None

        # Authentication handled by Reader
        reader = SosCapabilitiesReader(
                version=self.version, url=self.url, username=self.username, password=self.password
                )
        if xml:  # read from stored xml
            self._capabilities = reader.read_string(xml)
        else:  # read from server
            self._capabilities = reader.read(self.url)

        # Avoid building metadata if the response is an Exception
        se = self._capabilities.find(nspath_eval('ows:ExceptionReport', namespaces))
        if se is not None: 
            raise ows.ExceptionReport(se) 

        # build metadata objects
        self._build_metadata()

    def getOperationByName(self, name):
        """Return a named content item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError("No operation named %s" % name)

    def _build_metadata(self):
        """ 
            Set up capabilities metadata objects
        """
        # ows:ServiceIdentification metadata
        service_id_element = self._capabilities.find(nspath_eval('ows:ServiceIdentification', namespaces))
        self.identification = ows.ServiceIdentification(service_id_element)
        
        # ows:ServiceProvider metadata
        service_provider_element = self._capabilities.find(nspath_eval('ows:ServiceProvider', namespaces))
        self.provider = ows.ServiceProvider(service_provider_element)
            
        # ows:OperationsMetadata metadata
        self.operations= []
        for elem in self._capabilities.findall(nspath_eval('ows:OperationsMetadata/ows:Operation', namespaces)):
            self.operations.append(ows.OperationsMetadata(elem))

        # sos:FilterCapabilities
        filters = self._capabilities.find(nspath_eval('sos:Filter_Capabilities', namespaces))
        if filters is not None:
            self.filters = FilterCapabilities200(filters)
        else:
            self.filters = None

        # sos:Contents metadata
        self.contents = {}
        self.offerings = []
        for offering in self._capabilities.findall(nspath_eval('sos:contents/sos:Contents/swes:offering/sos:ObservationOffering', namespaces)):
            off = SosObservationOffering(offering)
            self.contents[off.id] = off
            self.offerings.append(off)

    def describe_sensor(self, outputFormat=None,
                              procedure=None,
                              method='Get',
                              **kwargs):

        try:
            base_url = next((m.get('url') for m in self.getOperationByName('DescribeSensor').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url
        request = {'service': 'SOS', 'version': self.version, 'request': 'DescribeSensor'}

        # Required Fields
        assert isinstance(outputFormat, str)
        request['procedureDescriptionFormat'] = outputFormat

        assert isinstance(procedure, str)
        request['procedure'] = procedure

        # Optional Fields
        if kwargs:
            for kw in kwargs:
                request[kw]=kwargs[kw]
       
        data = urlencode(request)        

        response = openURL(base_url, data, method, username=self.username, password=self.password).read()
        tr = etree.fromstring(response)

        if tr.tag == nspath_eval("ows:ExceptionReport", namespaces):
            raise ows.ExceptionReport(tr)

        return response

    def get_observation(self, responseFormat=None,
                              offerings=None,
                              observedProperties=None,
                              eventTime=None,
                              method='Get',
                              **kwargs):
        """
        Parameters
        ----------
        format : string
            Output format. Provide one that is available for all offerings
        method : string
            Optional. HTTP DCP method name: Get or Post.  Must
        **kwargs : extra arguments
            anything else e.g. vendor specific parameters
        """

        base_url = self.get_operation_by_name('GetObservation').methods[method]['url']        

        request = {'service': 'SOS', 'version': self.version, 'request': 'GetObservation'}

        # Required Fields
        assert isinstance(offerings, list) and len(offerings) > 0
        request['offering'] = ','.join(offerings)

        assert isinstance(observedProperties, list) and len(observedProperties) > 0
        request['observedProperty'] = ','.join(observedProperties)

        if responseFormat is not None:
            request['responseFormat'] = responseFormat

        # Optional Fields
        if eventTime is not None:
            request['temporalFilter'] = eventTime

        if kwargs:
            for kw in kwargs:
                request[kw]=kwargs[kw]

        data = urlencode(request)        

        response = openURL(base_url, data, method, username=self.username, password=self.password).read()
        try:
            tr = etree.fromstring(response)
            if tr.tag == nspath_eval("ows:ExceptionReport", namespaces):
                raise ows.ExceptionReport(tr)
            else:
                return response                
        except ows.ExceptionReport:
            raise
        except BaseException:
            return response

    def get_operation_by_name(self, name): 
        """
            Return a Operation item by name, case insensitive
        """
        for item in self.operations:
            if item.name.lower() == name.lower():
                return item
        raise KeyError, "No Operation named %s" % name

class SosObservationOffering(object):
    def __init__(self, element):
        self._root = element

        self.id = testXMLValue(self._root.find(nspath_eval('swes:identifier', namespaces)))
        if self.id is None:
            self.id = testXMLValue(self._root.attrib.get(nspath_eval('swes:id', namespaces)), True)
        self.description = testXMLValue(self._root.find(nspath_eval('swes:description', namespaces)))
        self.name = testXMLValue(self._root.find(nspath_eval('swes:name', namespaces)))

        # sos:observedArea
        try:
            envelope = self._root.find(nspath_eval('sos:observedArea/gml32:Envelope', namespaces))
            lower_left_corner = testXMLValue(envelope.find(nspath_eval('gml32:lowerCorner', namespaces))).split()
            upper_right_corner = testXMLValue(envelope.find(nspath_eval('gml32:upperCorner', namespaces))).split()
            # (left, bottom, right, top) in self.bbox_srs units
            self.bbox = (float(lower_left_corner[1]), float(lower_left_corner[0]), float(upper_right_corner[1]), float(upper_right_corner[0]))
            self.bbox_srs = Crs(testXMLValue(envelope.attrib.get('srsName'), True))
        except Exception, err:
            self.bbox = None
            self.bbox_srs = None

        # LOOK: Support all gml:TimeGeometricPrimitivePropertyType
        # Right now we are just supporting gml:TimePeriod
        # sos:Time
        begin_position_element = self._root.find(nspath_eval('sos:phenomenonTime/gml32:TimePeriod/gml32:beginPosition', namespaces))
        self.begin_position = extract_time(begin_position_element)
        end_position_element = self._root.find(nspath_eval('sos:phenomenonTime/gml32:TimePeriod/gml32:endPosition', namespaces))
        self.end_position = extract_time(end_position_element)

        self.procedures = []
        for proc in self._root.findall(nspath_eval('swes:procedure', namespaces)):
            self.procedures.append(testXMLValue(proc))

        self.procedure_description_formats = []
        for proc in self._root.findall(nspath_eval('swes:procedureDescriptionFormat', namespaces)):
            self.procedure_description_formats.append(testXMLValue(proc))

        # LOOK: Support swe:Phenomenon here
        # this includes compound properties
        self.observed_properties = []
        for op in self._root.findall(nspath_eval('swes:observableProperty', namespaces)):
            self.observed_properties.append(testXMLValue(op))

        self.features_of_interest = []
        for fot in self._root.findall(nspath_eval('sos:featureOfInterest', namespaces)):
            self.features_of_interest.append(testXMLValue(fot.attrib.get(nspath_eval('xlink:href', namespaces)), True))

        self.response_formats = []
        for rf in self._root.findall(nspath_eval('sos:responseFormat', namespaces)):
            self.response_formats.append(testXMLValue(rf))

        self.observation_models = []
        for om in self._root.findall(nspath_eval('sos:observationType', namespaces)):
            self.observation_models.append(testXMLValue(om))

    def __str__(self):
        return 'Offering id: %s, name: %s' % (self.id, self.name)
        
class SosCapabilitiesReader(object):
    def __init__(self, version="2.0.0", url=None, username=None, password=None):
        self.version = version
        self.url = url
        self.username = username
        self.password = password

    def capabilities_url(self, service_url):
        """
            Return a capabilities url
        """
        qs = []
        if service_url.find('?') != -1:
            qs = cgi.parse_qsl(service_url.split('?')[1])

        params = [x[0] for x in qs]

        if 'service' not in params:
            qs.append(('service', 'SOS'))
        if 'request' not in params:
            qs.append(('request', 'GetCapabilities'))
        if 'acceptversions' not in params:
            qs.append(('acceptversions', self.version))

        urlqs = urlencode(tuple(qs))
        return service_url.split('?')[0] + '?' + urlqs

    def read(self, service_url):
        """
            Get and parse a WMS capabilities document, returning an
            elementtree instance

            service_url is the base url, to which is appended the service,
            version, and request parameters
        """
        getcaprequest = self.capabilities_url(service_url)
        spliturl=getcaprequest.split('?')
        u = openURL(spliturl[0], spliturl[1], method='Get', username=self.username, password=self.password)
        return etree.fromstring(u.read())

    def read_string(self, st):
        """
            Parse a SOS capabilities document, returning an elementtree instance

            st should be an XML capabilities document
        """
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        return etree.fromstring(st)


########NEW FILE########
__FILENAME__ = sml
# encoding: utf-8

from owslib.etree import etree
from owslib import crs, util
from owslib.util import testXMLValue, testXMLAttribute, nspath_eval, xmltag_split, dict_union, extract_xml_list
from owslib.namespaces import Namespaces

def get_namespaces():
    n = Namespaces()
    namespaces = n.get_namespaces(["sml","gml","xlink"])
    namespaces["ism"] = "urn:us:gov:ic:ism:v2"
    return namespaces
namespaces = get_namespaces()

def nsp(path):
    return nspath_eval(path, namespaces)

class SensorML(object):
    def __init__(self, element):
        if isinstance(element, str):
            self._root = etree.fromstring(element)
        else:
            self._root = element

        if hasattr(self._root, 'getroot'):
            self._root = self._root.getroot()

        self.members = [Member(x) for x in self._root.findall(nsp('sml:member'))]

class Member(object):
    def __new__(cls, element):
        t = element[-1].tag.split("}")[-1]
        if t == "System":
            return System(element.find(nsp("sml:System")))
        elif t == "ProcessChain":
            return ProcessChain(element.find(nsp("sml:ProcessChain")))
        elif t == "ProcessModel":
            return ProcessModel(element.find(nsp("sml:ProcessModel")))
        elif t == "Component":
            return Component(element.find(nsp("sml:Component")))

class PropertyGroup(object):
    def __init__(self, element):
        # Both capabilities and characteristics contain a single swe:DataRecord element
        self.capabilities = {}
        for cap in element.findall(nsp('sml:capabilities')):
            name = testXMLAttribute(cap, "name")
            if name is not None:
                self.capabilities[name] = cap[0]

        self.characteristics = {}
        for cha in element.findall(nsp('sml:characteristics')):
            name = testXMLAttribute(cha, "name")
            if name is not None:
                self.characteristics[name] = cha[0]

    def get_capabilities_by_name(self, name):
        """
            Return list of element by name, case insensitive
        """
        return [self.capabilities[capab] for capab in self.capabilities.keys() if capab.lower() == name.lower()]

    def get_characteristics_by_name(self, name):
        """
            Return list of element objects by name, case insensitive
        """
        return [self.characteristics[charac] for charac in self.characteristics.keys() if charac.lower() == name.lower()]

class ConstraintGroup(object):
    def __init__(self, element):
        # ism:SecurityAttributesOptionsGroup
        self.security            = element.findall(nsp("sml:securityConstraint/sml:Security/ism:SecurityAttributesOptionGroup"))
        # gml:TimeInstant or gml:TimePeriod element
        self.validTime           = element.find(nsp("sml:validTime"))
        self.rights              = [Right(x) for x in element.findall(nsp("sml:legalConstraint/sml:Rights"))]

class Documentation(object):
    def __init__(self, element):
        self.arcrole   = testXMLAttribute(element, nsp("xlink:arcrole"))
        self.url       = testXMLAttribute(element, nsp("xlink:href"))
        self.documents = [Document(d) for d in element.findall(nsp("sml:Document"))]

class Document(object):
    def __init__(self, element):
        self.id          = testXMLAttribute(element, nsp("gml:id"))
        self.version     = testXMLValue(element.find(nsp("sml:version")))
        self.description = testXMLValue(element.find(nsp("gml:description")))
        self.date        = testXMLValue(element.find(nsp("sml:date")))
        try:
            self.contact     = Contact(element.find(nsp("sml:contact")))
        except AttributeError:
            self.contact     = None
        self.format      = testXMLValue(element.find(nsp('sml:format')))
        self.url         = testXMLAttribute(element.find(nsp('sml:onlineResource')), nsp('xlink:href'))

class Right(object):
    def __init__(self, element):
        self.id                         = testXMLAttribute(element, nsp('gml:id'))
        self.privacyAct                 = testXMLAttribute(element, nsp('sml:privacyAct'))
        self.intellectualPropertyRights = testXMLAttribute(element, nsp('sml:intellectualPropertyRights'))
        self.copyRights                 = testXMLAttribute(element, nsp('sml:copyRights'))
        self.documentation              = [Documentation(x) for x in element.findall(nsp("sml:documentation"))]

class ReferenceGroup(object):
    def __init__(self, element):
        self.contacts = {}
        for contact in element.findall(nsp('sml:contact')):
            cont                     = Contact(contact)
            self.contacts[cont.role] = cont

        self.documentation = [Documentation(x) for x in element.findall(nsp("sml:documentation"))]

    def get_contacts_by_role(self, role):
        """
            Return a Contact by role, case insensitive
        """
        return [self.contacts[contact] for contact in self.contacts.keys() if contact.lower() == role.lower()]

class GeneralInfoGroup(object):
    def __init__(self, element):
        self.keywords    = extract_xml_list(element.findall(nsp('sml:keywords/sml:KeywordList/sml:keyword')))

        self.identifiers = {}
        for identifier in element.findall(nsp('sml:identification/sml:IdentifierList/sml:identifier')):
            ident = Identifier(identifier)
            self.identifiers[ident.name] = ident

        self.classifiers = {}
        for classifier in element.findall(nsp('sml:classification/sml:ClassifierList/sml:classifier')):
            classi = Classifier(classifier)
            self.classifiers[classi.name] = classi

    def get_identifiers_by_name(self, name):
        """
            Return list of Identifier objects by name, case insensitive
        """
        return [self.identifiers[identifier] for identifier in self.identifiers.keys() if identifier.lower() == name.lower()]

    def get_classifiers_by_name(self, name):
        """
            Return list of Classifier objects by name, case insensitive
        """
        return [self.classifiers[classi] for classi in self.classifiers.keys() if classi.lower() == name.lower()]

class Contact(object):
    def __init__(self, element):
        # TODO: This only supports the sml:contact/sml:ResponsibleParty elements, but there are numerous ways to store
        # contact information here.
        self.role         = testXMLAttribute(element, nsp("xlink:role"))
        self.href         = testXMLAttribute(element, nsp("xlink:href"))
        self.organization = testXMLValue(element.find(nsp('sml:ResponsibleParty/sml:organizationName')))
        self.phone        = testXMLValue(element.find(nsp('sml:ResponsibleParty/sml:contactInfo/sml:phone/sml:voice')))
        self.address      = testXMLValue(element.find(nsp('sml:ResponsibleParty/sml:contactInfo/sml:address/sml:deliveryPoint')))
        self.city         = testXMLValue(element.find(nsp('sml:ResponsibleParty/sml:contactInfo/sml:address/sml:city')))
        self.region       = testXMLValue(element.find(nsp('sml:ResponsibleParty/sml:contactInfo/sml:address/sml:administrativeArea')))
        self.postcode     = testXMLValue(element.find(nsp('sml:ResponsibleParty/sml:contactInfo/sml:address/sml:postalCode')))
        self.country      = testXMLValue(element.find(nsp('sml:ResponsibleParty/sml:contactInfo/sml:address/sml:country')))
        self.email        = testXMLValue(element.find(nsp('sml:ResponsibleParty/sml:contactInfo/sml:address/sml:electronicMailAddress')))
        self.url          = testXMLAttribute(element.find(nsp('sml:ResponsibleParty/sml:contactInfo/sml:onlineResource')), nsp("xlink:href"))

class HistoryGroup(object):
    def __init__(self, element):
        self.history = {}
        for event_member in element.findall(nsp('sml:history/sml:EventList/sml:member')):
            name = testXMLAttribute(event_member, "name")
            if self.history.get(name) is None:
                self.history[name] = []
            for e in event_member.findall(nsp("sml:Event")):
                self.history[name].append(Event(e))

    def get_history_by_name(self, name):
        """
            Return Events list by members name
        """
        return self.history.get(name.lower(), [])

class Event(ReferenceGroup, GeneralInfoGroup):
    def __init__(self, element):
        ReferenceGroup.__init__(self, element)
        GeneralInfoGroup.__init__(self, element)
        self.id            = testXMLAttribute(element, nsp("gml:id"))
        self.date          = testXMLValue(element.find(nsp('sml:date')))
        self.description   = testXMLValue(element.find(nsp('gml:description')))

class MetadataGroup(GeneralInfoGroup, PropertyGroup, ConstraintGroup, ReferenceGroup, HistoryGroup):
    def __init__(self, element):
        GeneralInfoGroup.__init__(self, element)
        PropertyGroup.__init__(self, element)
        ConstraintGroup.__init__(self, element)
        ReferenceGroup.__init__(self, element)
        HistoryGroup.__init__(self, element)

class AbstractFeature(object):
    def __init__(self, element):
        self.name         = testXMLValue(element.find(nsp("gml:name")))
        self.description  = testXMLValue(element.find(nsp("gml:description")))
        self.gmlBoundedBy = testXMLValue(element.find(nsp("gml:boundedBy")))

class AbstractProcess(AbstractFeature, MetadataGroup):
    def __init__(self, element):
        AbstractFeature.__init__(self, element)
        MetadataGroup.__init__(self, element)
        # sml:IoComponentPropertyType
        self.inputs     = element.findall(nsp("sml:input"))
        # sml:IoComponentPropertyType
        self.outputs    = element.findall(nsp("sml:output"))
        # swe:DataComponentPropertyType
        self.parameters = element.findall(nsp("sml:parameter"))

class AbstractRestrictedProcess(AbstractFeature):
    """ Removes ('restricts' in xml schema language) gml:name, gml:description, and sml:metadataGroup from an AbstractProcess """
    def __init__(self, element):
        AbstractFeature.__init__(self, element)
        self.name        = None
        self.description = None

class AbstractPureProcess(AbstractRestrictedProcess):
    def __init__(self, element):
        AbstractRestrictedProcess.__init__(self, element)

        # sml:IoComponentPropertyType
        self.inputs      = element.findall(nsp("sml:input"))
        # sml:IoComponentPropertyType
        self.outputs     = element.findall(nsp("sml:output"))
        # swe:DataComponentPropertyType
        self.parameters  = element.findall(nsp("sml:parameter"))

class ProcessModel(AbstractPureProcess):
    def __init__(self, element):
        AbstractPureProcess.__init__(self, element)
        self.method = ProcessMethod(element.find("method"))

class CompositePropertiesGroup(object):
    def __init__(self, element):
        # All components should be of instance AbstractProcess (sml:_Process)
        self.components  = element.findall(nsp("sml:components/sml:ComponentList/sml:component"))
        # sml:Link or sml:ArrayLink element
        self.connections = element.findall(nsp("sml:connections/sml:ConnectionList/sml:connection"))

class PhysicalPropertiesGroup(object):
    def __init__(self, element):
        # gml:EngieeringCRS element
        self.spatialReferenceFrame  = element.find(nsp("sml:spatialReferenceFrame/gml:EngineeringCRS"))
        # gml:TemporalCRS element
        self.temporalReferenceFrame = element.find(nsp("sml:temporalReferenceFrame/gml:TemporalCRS"))
        # gml:Envelope element
        self.smlBoundedBy           = element.find(nsp("sml:boundedBy"))
        # swe:Time or sml:_Process element
        self.timePosition           = element.find(nsp("sml:timePosition"))

        # It is either a sml:position OR and sml:location element here.  Process both.
        # swe:Position, swe:Vector, or sml:_Process element
        self.positions              = element.findall(nsp("sml:position"))
        # gml:Point of gml:_Curve
        self.location               = element.find(nsp("sml:location"))

        try:
            self.interface = Interface(element.find(nsp("sml:interface")))
        except AttributeError:
            self.interface = None

class ProcessChain(AbstractPureProcess, CompositePropertiesGroup):
    def __init__(self, element):
        AbstractPureProcess.__init__(self, element)
        CompositePropertiesGroup.__init__(self, element)

class System(AbstractProcess, PhysicalPropertiesGroup, CompositePropertiesGroup):
    def __init__(self, element):
        AbstractProcess.__init__(self, element)
        PhysicalPropertiesGroup.__init__(self, element)
        CompositePropertiesGroup.__init__(self, element)

class Component(AbstractProcess, PhysicalPropertiesGroup):
    def __init__(self, element):
        AbstractProcess.__init__(self, element)
        PhysicalPropertiesGroup.__init__(self, element)
        self.method = ProcessMethod(element.find("method"))

class Term(object):
    def __init__(self, element):
        self.codeSpace  = testXMLAttribute(element.find(nsp('sml:Term/sml:codeSpace')), nsp("xlink:href"))
        self.definition = testXMLAttribute(element.find(nsp('sml:Term')), "definition")
        self.value      = testXMLValue(element.find(nsp('sml:Term/sml:value')))

class Classifier(Term):
    def __init__(self, element):
        Term.__init__(self, element)
        self.name      = testXMLAttribute(element, "name")

class Identifier(Term):
    def __init__(self, element):
        Term.__init__(self, element)
        self.name      = testXMLAttribute(element, "name")

class ProcessMethod(MetadataGroup):
    """ Inherits from gml:AbstractGMLType """
    def __init__(self, element):
        MetadataGroup.__init__(self, element)
        self.rules           = element.find(nsp("sml:rules"))
        self.ioStructure     = element.find(nsp("sml:IOStructureDefinition"))
        self.algorithm       = element.find(nsp("sml:algorithm"))
        self.implementations = element.findall(nsp("sml:implementation"))

class Interface(object):
    def __init__(self, element):
        self.name                 = testXMLAttribute(element, "name")
        self.interface_definition = InterfaceDefinition(element.find(nsp("sml:InterfaceDefinition")))

class InterfaceDefinition(object):
    def __init__(self, element):
        raise NotImplementedError("InterfaceDefinition is not implemented in OWSLib (yet)")

class Link(object):
    def __init__(self, element):
        raise NotImplementedError("Link is not implemented in OWSLib (yet)")

class ArrayLink(object):
    def __init__(self, element):
        raise NotImplementedError("ArrayLink is not implemented in OWSLib (yet)")

########NEW FILE########
__FILENAME__ = tms
# -*- coding: UTF-8 -*-
# =============================================================================
# Copyright (C) 2013 Christian Ledermann <christian.ledermann@gmail.com>
#
# Based on wms.py, which has the following copyright statement:
# Copyright (c) 2004, 2006 Sean C. Gillies
# Copyright (c) 2005 Nuxeo SARL <http://nuxeo.com>
#
# Authors : Sean Gillies <sgillies@frii.com>
#           Julien Anguenot <ja@nuxeo.com>
#
# Contact email: sgillies@frii.com
# =============================================================================

# TMS as defined in:
# http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification

from etree import etree
from .util import openURL, testXMLValue

FORCE900913 = False

def force900913(epsg):
# http://osgeo-org.1560.n6.nabble.com/OSGEO-code-td3852851.html
# "EPSG:900913" = ["OSGEO:41001", "EPSG:3785", "EPSG:3857", "EPSG:54004"]
    if  FORCE900913 and epsg.upper() in ["OSGEO:41001", "EPSG:3785",
                                        "EPSG:3857", "EPSG:54004"]:
        return "EPSG:900913"
    else:
        return epsg



class TileMapService(object):
    """Abstraction for OGC Tile Map Service (TMS).

    Implements IWebMapService.
    """

    def __init__(self, url, version='1.0.0', xml=None,
                username=None, password=None, parse_remote_metadata=False
                ):
        """Initialize."""
        self.url = url
        self.username = username
        self.password = password
        self.version = version
        self.services = None
        self._capabilities = None
        self.contents={}

        # Authentication handled by Reader
        reader = TMSCapabilitiesReader(
                self.version, url=self.url, un=self.username, pw=self.password
                )
        if xml:  # read from stored xml
            self._capabilities = reader.readString(xml)
        else:  # read from server
            self._capabilities = reader.read(self.url)

        # build metadata objects
        self._buildMetadata(parse_remote_metadata)


    def _getcapproperty(self):
        if not self._capabilities:
            reader = TMSCapabilitiesReader(
                self.version, url=self.url, un=self.username, pw=self.password
                )
            self._capabilities = ServiceMetadata(reader.read(self.url))
        return self._capabilities


    def _buildMetadata(self, parse_remote_metadata=False):
        ''' set up capabilities metadata objects '''
        if self._capabilities.attrib.get('version'):
            self.version = self._capabilities.attrib.get('version')
        self.identification=ServiceIdentification(self._capabilities, self.version)

        self.contents={}
        tilemaps = self._capabilities.find('TileMaps')
        if tilemaps is not None:
            for tilemap in tilemaps.findall('TileMap'):
                cm = ContentMetadata(tilemap, un=self.username, pw=self.password)
                if cm.id:
                    if cm.id in self.contents:
                        raise KeyError('Content metadata for layer "%s" already exists' % cm.id)
                    self.contents[cm.id] = cm

    def getServiceXML(self):
        xml = None
        if self._capabilities is not None:
            xml = etree.tostring(self._capabilities)
        return xml

    def items(self, srs=None, profile=None):
        '''supports dict-like items() access'''
        items=[]
        if not srs and not profile:
            for item in self.contents:
                items.append((item,self.contents[item]))
        elif srs and profile:
            for item in self.contents:
                if (self.contents[item].srs == srs and
                    self.contents[item].profile == profile):
                    items.append((item,self.contents[item]))
        elif srs:
            for item in self.contents:
                if self.contents[item].srs == srs:
                    items.append((item,self.contents[item]))
        elif profile:
             for item in self.contents:
                if self.contents[item].profile == profile:
                    items.append((item,self.contents[item]))
        return items

    def _gettilefromset(self, tilesets, x, y,z, ext):
        for tileset in tilesets:
            if tileset['order'] == z:
                url = tileset['href'] + '/' + str(x) +'/' + str(y) + '.' + ext
                u = openURL(url, '', username = self.username,
                            password = self.password)
                return u
        else:
            raise ValueError('cannot find zoomlevel %i for TileMap' % z)

    def gettile(self, x,y,z, id=None, title=None, srs=None, mimetype=None):
        if not id and not title and not srs:
            raise ValueError('either id or title and srs must be specified')
        if id:
            return self._gettilefromset(self.contents[id].tilemap.tilesets,
                x, y, z, self.contents[id].tilemap.extension)

        elif title and srs:
            for tm in self.contents.values():
                if tm.title == title and tm.srs == srs:
                    if mimetype:
                        if tm.tilemap.mimetype == mimetype:
                            return self._gettilefromset(tm.tilemap.tilesets,
                                x, y, z, tm.tilemap.extension)
                    else:
                        #if no format is given we return the tile from the
                        # first tilemap that matches name and srs
                        return self._gettilefromset(tm.tilemap.tilesets,
                            x, y,z, tm.tilemap.extension)
            else:
                raise ValueError('cannot find %s with projection %s for zoomlevel %i'
                        %(title, srs, z) )
        elif title or srs:
            ValueError('both title and srs must be specified')
        raise ValueError('''Specified Tile with id %s, title %s
                projection %s format %s at zoomlevel %i cannot be found'''
                %(id, title, srs, format, z))


class ServiceIdentification(object):

    def __init__(self, infoset, version):
        self._root=infoset
        if self._root.tag != 'TileMapService':
            raise ServiceException
        self.version = version
        self.title = testXMLValue(self._root.find('Title'))
        self.abstract = testXMLValue(self._root.find('Abstract'))
        self.keywords = []
        f = self._root.find('KeywordList')
        if f is not None:
            self.keywords = f.text.split()
        self.url = self._root.attrib.get('services')


class ContentMetadata(object):
    """
    Abstraction for TMS layer metadata.
    """
    def __str__(self):
        return 'Layer Title: %s, URL: %s' % (self.title, self.id)

    def __init__(self, elem, un=None, pw=None):
        if elem.tag != 'TileMap':
            raise ValueError('%s should be a TileMap' % (elem,))
        self.id = elem.attrib['href']
        self.title = elem.attrib['title']
        self.srs = force900913(elem.attrib['srs'])
        self.profile = elem.attrib['profile']
        self.password = pw
        self.username = pw
        self._tile_map = None
        self.type = elem.attrib.get('type')

    def _get_tilemap(self):
        if self._tile_map is None:
            self._tile_map = TileMap(self.id, un=self.username, pw=self.password)
            assert(self._tile_map.srs == self.srs)
        return self._tile_map


    @property
    def tilemap(self):
        return self._get_tilemap()

    @property
    def abstract(self):
        return self._get_tilemap().abstract

    @property
    def width(self):
        return self._get_tilemap().width

    @property
    def height(self):
        return self._get_tilemap().height

    @property
    def mimetype(self):
        return self._get_tilemap().mimetype

    @property
    def extension(self):
        return self._get_tilemap().extension

    @property
    def boundingBox(self):
        return self._get_tilemap().boundingBox

    @property
    def origin(self):
        return self._get_tilemap().origin


class TileMap(object):

    title = None
    abstract = None
    srs = None
    boundingBox = None
    origin = None
    width = None
    height = None
    mimetype = None
    extension = None
    _element = None
    version = None
    tilemapservice = None
    tilesets = None
    profile = None

    def __init__(self, url=None, xml=None, un=None, pw=None):
        self.url = url
        self.username = un
        self.password = pw
        self.tilesets = []
        if xml and not url:
            self.readString(xml)
        elif url:
            self.read(url)


    def _parse(self, elem):
        if elem.tag != 'TileMap':
            raise ValueError('%s should be a TileMap' % (elem,))
        self._element = elem
        self.version = elem.attrib.get('version')
        self.tilemapservice = elem.attrib.get('tilemapservice')
        self.title = testXMLValue(elem.find('Title'))
        self.abstract = testXMLValue(elem.find('Abstract'))
        self.srs = force900913(testXMLValue(elem.find('SRS')))

        bbox = elem.find('BoundingBox')
        self.boundingBox = (float(bbox.attrib['minx']),
                            float(bbox.attrib['miny']),
                            float(bbox.attrib['maxx']),
                            float(bbox.attrib['maxy']))
        origin = elem.find('Origin')
        self.origin = (float(origin.attrib['x']), float(origin.attrib['y']))
        tf = elem.find('TileFormat')
        self.width = int(tf.attrib['width'])
        self.height = int(tf.attrib['height'])
        self.mimetype = tf.attrib['mime-type']
        self.extension = tf.attrib['extension']
        ts = elem.find('TileSets')
        if ts is not None:
            self.profile = ts.attrib.get('profile')
            tilesets = ts.findall('TileSet')
            for tileset in tilesets:
                href = tileset.attrib['href']
                upp = float(tileset.attrib['units-per-pixel'])
                order = int(tileset.attrib['order'])
                self.tilesets.append({
                    'href': href,
                    'units-per-pixel': upp,
                    'order': order})

    def read(self, url):
        u = openURL(url, '', method='Get', username = self.username, password = self.password)
        self._parse(etree.fromstring(u.read()))

    def readString(self, st):
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        self._parse(etree.fromstring(st))



class TMSCapabilitiesReader(object):
    """Read and parse capabilities document into a lxml.etree infoset
    """

    def __init__(self, version='1.0.0', url=None, un=None, pw=None):
        """Initialize"""
        self.version = version
        self._infoset = None
        self.url = url
        self.username = un
        self.password = pw


    def read(self, service_url):
        """Get and parse a TMS capabilities document, returning an
        elementtree instance
        """
        u = openURL(service_url, '', method='Get', username = self.username, password = self.password)
        return etree.fromstring(u.read())

    def readString(self, st):
        """Parse a TMS capabilities document, returning an elementtree instance

        string should be an XML capabilities document
        """
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        return etree.fromstring(st)

########NEW FILE########
__FILENAME__ = util
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2008 Tom Kralidis
#
# Authors : Tom Kralidis <tomkralidis@gmail.com>
#
# Contact email: tomkralidis@gmail.com
# =============================================================================

import sys
from dateutil import parser
from datetime import datetime
import pytz
from owslib.etree import etree
from owslib.namespaces import Namespaces
import urlparse, urllib2
from urllib2 import urlopen, HTTPError, Request
from urllib2 import HTTPPasswordMgrWithDefaultRealm
from urllib2 import HTTPBasicAuthHandler
from StringIO import StringIO
import cgi
from urllib import urlencode
import re
from copy import deepcopy
import warnings


"""
Utility functions and classes
"""

class RereadableURL(StringIO,object):
    """ Class that acts like a combination of StringIO and url - has seek method and url headers etc """
    def __init__(self, u):
        #get url headers etc from url
        self.headers = u.headers                
        #get file like seek, read methods from StringIO
        content=u.read()
        super(RereadableURL, self).__init__(content)


class ServiceException(Exception):
    #TODO: this should go in ows common module when refactored.  
    pass

# http://stackoverflow.com/questions/6256183/combine-two-dictionaries-of-dictionaries-python
dict_union = lambda d1,d2: dict((x,(dict_union(d1.get(x,{}),d2[x]) if
  isinstance(d2.get(x),dict) else d2.get(x,d1.get(x)))) for x in
  set(d1.keys()+d2.keys()))


# Infinite DateTimes for Python.  Used in SWE 2.0 and other OGC specs as "INF" and "-INF"
class InfiniteDateTime(object):
    def __lt__(self, other):
        return False
    def __gt__(self, other):
        return True
    def timetuple(self):
        return tuple()
class NegativeInfiniteDateTime(object):
    def __lt__(self, other):
        return True
    def __gt__(self, other):
        return False
    def timetuple(self):
        return tuple()


first_cap_re = re.compile('(.)([A-Z][a-z]+)')
all_cap_re = re.compile('([a-z0-9])([A-Z])')
def format_string(prop_string):
    """
        Formats a property string to remove spaces and go from CamelCase to pep8
        from: http://stackoverflow.com/questions/1175208/elegant-python-function-to-convert-camelcase-to-camel-case
    """
    if prop_string is None:
        return ''
    st_r = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', prop_string)
    st_r = st_r.replace(' ','')
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', st_r).lower()

def xml_to_dict(root, prefix=None, depth=1, diction=None):
    """
        Recursively iterates through an xml element to convert each element in the tree to a (key,val). Where key is the element
        tag and val is the inner-text of the element. Note that this recursively go through the tree until the depth specified.

        Parameters
        ===========
        :root - root xml element, starting point of iteration
        :prefix - a string to prepend to the resulting key (optional)
        :depth - the number of depths to process in the tree (optional)
        :diction - the dictionary to insert the (tag,text) pairs into (optional)

        Return
        =======
        Dictionary of (key,value); where key is the element tag stripped of namespace and cleaned up to be pep8 and
        value is the inner-text of the element. Note that duplicate elements will be replaced by the last element of the 
        same tag in the tree.
    """
    ret = diction if diction is not None else dict()
    for child in root:
        val = testXMLValue(child)
        # skip values that are empty or None
        if val is None or val == '':
            if depth > 1:
                ret = xml_to_dict(child,prefix=prefix,depth=(depth-1),diction=ret)
            continue

        key = format_string(child.tag.split('}')[-1])

        if prefix is not None:
            key = prefix + key

        ret[key] = val
        if depth > 1:
            ret = xml_to_dict(child,prefix=prefix,depth=(depth-1),diction=ret)

    return ret

def openURL(url_base, data, method='Get', cookies=None, username=None, password=None, timeout=30):
    ''' function to open urls - wrapper around urllib2.urlopen but with additional checks for OGC service exceptions and url formatting, also handles cookies and simple user password authentication'''
    url_base.strip() 
    lastchar = url_base[-1]
    if lastchar not in ['?', '&']:
        if url_base.find('?') == -1:
            url_base = url_base + '?'
        else:
            url_base = url_base + '&'
            
    if username and password:
        # Provide login information in order to use the WMS server
        # Create an OpenerDirector with support for Basic HTTP 
        # Authentication...
        passman = HTTPPasswordMgrWithDefaultRealm()
        passman.add_password(None, url_base, username, password)
        auth_handler = HTTPBasicAuthHandler(passman)
        opener = urllib2.build_opener(auth_handler)
        openit = opener.open
    else:
        # NOTE: optionally set debuglevel>0 to debug HTTP connection
        #opener = urllib2.build_opener(urllib2.HTTPHandler(debuglevel=0))
        #openit = opener.open
        openit = urlopen
   
    try:
        if method == 'Post':
            req = Request(url_base, data)
            # set appropriate header if posting XML
            try:
                xml = etree.fromstring(data)
                req.add_header('Content-Type', "text/xml")
            except:
                pass
        else:
            req=Request(url_base + data)
        if cookies is not None:
            req.add_header('Cookie', cookies)
        u = openit(req, timeout=timeout)
    except HTTPError, e: #Some servers may set the http header to 400 if returning an OGC service exception or 401 if unauthorised.
        if e.code in [400, 401]:
            raise ServiceException, e.read()
        else:
            raise e
    # check for service exceptions without the http header set
    if ((u.info().has_key('Content-Type')) and (u.info()['Content-Type'] in ['text/xml', 'application/xml'])):          
        #just in case 400 headers were not set, going to have to read the xml to see if it's an exception report.
        #wrap the url stram in a extended StringIO object so it's re-readable
        u=RereadableURL(u)      
        se_xml= u.read()
        se_tree = etree.fromstring(se_xml)
        serviceException=se_tree.find('{http://www.opengis.net/ows}Exception')
        if serviceException is None:
            serviceException=se_tree.find('ServiceException')
        if serviceException is not None:
            raise ServiceException, \
            str(serviceException.text).strip()
        u.seek(0) #return cursor to start of u      
    return u

#default namespace for nspath is OWS common
OWS_NAMESPACE = 'http://www.opengis.net/ows/1.1'
def nspath(path, ns=OWS_NAMESPACE):

    """

    Prefix the given path with the given namespace identifier.
    
    Parameters
    ----------

    - path: ElementTree API Compatible path expression
    - ns: the XML namespace URI.

    """

    if ns is None or path is None:
        return -1

    components = []
    for component in path.split('/'):
        if component != '*':
            component = '{%s}%s' % (ns, component)
        components.append(component)
    return '/'.join(components)

def nspath_eval(xpath, namespaces):
    ''' Return an etree friendly xpath '''
    out = []
    for chunks in xpath.split('/'):
        namespace, element = chunks.split(':')
        out.append('{%s}%s' % (namespaces[namespace], element))
    return '/'.join(out)

def cleanup_namespaces(element):
    """ Remove unused namespaces from an element """
    if etree.__name__ == 'lxml.etree':
        etree.cleanup_namespaces(element)
        return element
    else:
        return etree.fromstring(etree.tostring(element))


def add_namespaces(root, ns_keys):
    if isinstance(ns_keys, basestring):
        ns_keys = [ns_keys]

    namespaces = Namespaces()

    ns_keys = map(lambda x: (x, namespaces.get_namespace(x)), ns_keys)

    if etree.__name__ != 'lxml.etree':
        # We can just add more namespaces when not using lxml.
        # We can't re-add an existing namespaces.  Get a list of current
        # namespaces in use
        existing_namespaces = set()
        for elem in root.getiterator():
            if elem.tag[0] == "{":
                uri, tag = elem.tag[1:].split("}")
                existing_namespaces.add(namespaces.get_namespace_from_url(uri))
        for key, link in ns_keys:
            if link is not None and key not in existing_namespaces:
                root.set("xmlns:%s" % key, link)
        return root
    else:
        # lxml does not support setting xmlns attributes
        # Update the elements nsmap with new namespaces
        new_map = root.nsmap
        for key, link in ns_keys:
            if link is not None:
                new_map[key] = link
        # Recreate the root element with updated nsmap
        new_root = etree.Element(root.tag, nsmap=new_map)
        # Carry over attributes
        for a, v in root.items():
            new_root.set(a, v)
        # Carry over children
        for child in root:
            new_root.append(deepcopy(child))
        return new_root


def getXMLInteger(elem, tag):
    """
    Return the text within the named tag as an integer.

    Raises an exception if the tag cannot be found or if its textual
    value cannot be converted to an integer.

    Parameters
    ----------

    - elem: the element to search within
    - tag: the name of the tag to look for

    """
    e = elem.find(tag)
    if e is None:
        raise ValueError('Missing %s in %s' % (tag, elem))
    return int(e.text.strip())


def testXMLValue(val, attrib=False):
    """

    Test that the XML value exists, return val.text, else return None

    Parameters
    ----------

    - val: the value to be tested

    """

    if val is not None:
        if attrib:
            return val.strip()
        elif val.text:  
            return val.text.strip()
        else:
            return None	
    else:
        return None

def testXMLAttribute(element, attribute):
    """

    Test that the XML element and attribute exist, return attribute's value, else return None

    Parameters
    ----------

    - element: the element containing the attribute
    - attribute: the attribute name

    """
    if element is not None:
        return element.get(attribute)

    return None

def http_post(url=None, request=None, lang='en-US', timeout=10):
    """

    Invoke an HTTP POST request 

    Parameters
    ----------

    - url: the URL of the server
    - request: the request message
    - lang: the language
    - timeout: timeout in seconds

    """

    if url is not None:
        u = urlparse.urlsplit(url)
        r = urllib2.Request(url, request)
        r.add_header('User-Agent', 'OWSLib (https://geopython.github.io/OWSLib)')
        r.add_header('Content-type', 'text/xml')
        r.add_header('Content-length', '%d' % len(request))
        r.add_header('Accept', 'text/xml')
        r.add_header('Accept-Language', lang)
        r.add_header('Accept-Encoding', 'gzip,deflate')
        r.add_header('Host', u.netloc)

        try:
            up = urllib2.urlopen(r,timeout=timeout);
        except TypeError:
            import socket
            socket.setdefaulttimeout(timeout)
            up = urllib2.urlopen(r)

        ui = up.info()  # headers
        response = up.read()
        up.close()

        # check if response is gzip compressed
        if ui.has_key('Content-Encoding'):
            if ui['Content-Encoding'] == 'gzip':  # uncompress response
                import gzip
                cds = StringIO(response)
                gz = gzip.GzipFile(fileobj=cds)
                response = gz.read()

        return response


def element_to_string(element, encoding=None):
    """
    Returns a string from a XML object

    Parameters
    ----------
    - xml:                 etree Element
    - encoding (optional): encoding in string form. 'utf-8', 'ISO-8859-1', etc.

    """
    if encoding is None:
        encoding = "ISO-8859-1"

    if etree.__name__ == 'lxml.etree':
        if encoding in ['unicode', 'utf-8']:
            return '<?xml version="1.0" encoding="utf-8" standalone="no"?>\n%s' % \
                   etree.tostring(element, encoding='unicode')
        else:
            return etree.tostring(element, encoding=encoding, xml_declaration=True)
    else:
        return '<?xml version="1.0" encoding="%s" standalone="no"?>\n%s' % (encoding,
               etree.tostring(element, encoding=encoding))


def xml2string(xml):
    """

    Return a string of XML object

    Parameters
    ----------

    - xml: xml string

    """
    warnings.warn("DEPRECIATION WARNING!  You should now use the 'element_to_string' method \
                   The 'xml2string' method will be removed in a future version of OWSLib.")
    return '<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>\n' + xml

def xmlvalid(xml, xsd):
    """

    Test whether an XML document is valid

    Parameters
    ----------

    - xml: XML content
    - xsd: pointer to XML Schema (local file path or URL)

    """

    xsd1 = etree.parse(xsd)
    xsd2 = etree.XMLSchema(xsd1)

    doc = etree.parse(StringIO(xml))
    return xsd2.validate(doc)

def xmltag_split(tag):
    ''' Return XML element bare tag name (without prefix) '''
    try:
        return tag.split('}')[1]
    except:
        return tag

def getNamespace(element):
    ''' Utility method to extract the namespace from an XML element tag encoded as {namespace}localname. '''
    if element.tag[0]=='{':
        return element.tag[1:].split("}")[0]
    else:
        return ""

def build_get_url(base_url, params):
    ''' Utility function to build a full HTTP GET URL from the service base URL and a dictionary of HTTP parameters. '''
    
    qs = []
    if base_url.find('?') != -1:
        qs = cgi.parse_qsl(base_url.split('?')[1])

    pars = [x[0] for x in qs]

    for key,value in params.iteritems():
        if key not in pars:
            qs.append( (key,value) )

    urlqs = urlencode(tuple(qs))
    return base_url.split('?')[0] + '?' + urlqs

def dump(obj, prefix=''):
    '''Utility function to print to standard output a generic object with all its attributes.'''
    
    print "%s %s : %s" % (prefix, obj.__class__, obj.__dict__)
    
def getTypedValue(type, value):
    ''' Utility function to cast a string value to the appropriate XSD type. '''
    
    if type=='boolean':
       return bool(value)
    elif type=='integer':
       return int(value)
    elif type=='float':
        return float(value)
    elif type=='string':
        return str(value)
    else:
        return value # no type casting


def extract_time(element):
    ''' return a datetime object based on a gml text string

ex:
<gml:beginPosition>2006-07-27T21:10:00Z</gml:beginPosition>
<gml:endPosition indeterminatePosition="now"/>

If there happens to be a strange element with both attributes and text,
use the text.
ex: <gml:beginPosition indeterminatePosition="now">2006-07-27T21:10:00Z</gml:beginPosition>
Would be 2006-07-27T21:10:00Z, not 'now'

'''
    if element is None:
        return None

    try:
        dt = parser.parse(element.text)
    except Exception:
        att = testXMLValue(element.attrib.get('indeterminatePosition'), True)
        if att and att == 'now':
            dt = datetime.utcnow()
            dt.replace(tzinfo=pytz.utc)
        else:
            dt = None
    return dt


def extract_xml_list(elements):
    """
Some people don't have seperate tags for their keywords and seperate them with
a newline. This will extract out all of the keywords correctly.
"""
    keywords = [re.split(r'[\n\r]+',f.text) for f in elements if f.text]
    flattened = [item.strip() for sublist in keywords for item in sublist]
    remove_blank = filter(None, flattened)
    return remove_blank


def bind_url(url):
    """binds an HTTP GET query string endpiont"""
    if url.find('?') == -1: # like http://host/wms
        binder = '?'

    # if like http://host/wms?foo=bar& or http://host/wms?foo=bar
    if url.find('=') != -1:
        if url.find('&', -1) != -1: # like http://host/wms?foo=bar&
            binder = ''
        else: # like http://host/wms?foo=bar
            binder = '&'

    # if like http://host/wms?foo
    if url.find('?') != -1:
        if url.find('?', -1) != -1: # like http://host/wms?
            binder = ''
        elif url.find('&', -1) == -1: # like http://host/wms?foo=bar
            binder = '&'
    return '%s%s' % (url, binder)

import logging
# Null logging handler
try:
    # Python 2.7
    NullHandler = logging.NullHandler
except AttributeError:
    # Python < 2.7
    class NullHandler(logging.Handler):
        def emit(self, record):
            pass
log = logging.getLogger('owslib')
log.addHandler(NullHandler())

# OrderedDict
try:  # 2.7
    from collections import OrderedDict
except:  # 2.6
    from ordereddict import OrderedDict


########NEW FILE########
__FILENAME__ = wml
from owslib.etree import etree
from owslib.util import nspath, testXMLValue, openURL
from owslib.util import xml_to_dict as _xml_to_dict
from datetime import datetime
from dateutil import parser

namespaces = {
    'wml1.1':'{http://www.cuahsi.org/waterML/1.1/}',
    'wml1.0':'{http://www.cuahsi.org/waterML/1.0/}',
    'xsi':'{http://www.w3.org/2001/XMLSchema-instance',
    'xsd':'{http://www.w3.org/2001/XMLSchema'
}

def ns(namespace):
    return namespaces.get(namespace)

class XMLParser(object):
    """
        Convienence class; provides some useful shortcut methods to make retrieving xml elements from etree
        a little easier.
    """
    def __init__(self,xml_root,namespace):
        try:
            self._root = etree.parse(xml_root)
        except:
            self._root = xml_root

        if not namespace in namespaces:
            raise ValueError('Unsupported namespace passed in to parser!')

        self._ns = namespace

    def _find(self,tofind):
        try:
            return self._root.find(namespaces.get(self._ns) + tofind)
        except:
            return None

    def _findall(self,tofind):
        try:
            return self._root.findall(namespaces.get(self._ns) + tofind)
        except:
            return None

class SitesResponse(XMLParser):
    """
        Parses the response from a 'GetSites' request

        Parameters
        ===========
        :xmlio - A file-like object that holds the xml response from the request.

        Return 
        =======
        An object constructed from a dictionary parse of the response. The object has get access and can iterate
        over the sites returned.
    """
    def __init__(self,xml,version='wml1.1'):
        super(SitesResponse,self).__init__(xml,version)
        self.parse_sites_response()

    def __iter__(self):
        for s in self.sites:
            yield s

    def __getitem__(self,key):
        if isinstance(key,int) and key < len(self.sites):
            return self.sites[key]

        if isinstance(key,str):
            site = [site for site in self.sites for code in site.site_info.site_codes if code == key]
            if len(site) > 0:
                return site[0]

        raise KeyError('Unknown key ' + str(key))

    def parse_sites_response(self,xml=None):
        """
        """
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
        self.query_info = QueryInfo(self._find('queryInfo'), self._ns)
        self.sites = [Site(site, self._ns) for site in self._findall('site')]
        # except:
        #   raise ValueError('Cannot parse sitesResponse element correctly')

    """Accesability properties/methods"""
    @property
    def site_codes(self):
        return [site.site_info.site_codes for site in self.sites]

    @property
    def site_names(self):
        return [site.site_info.site_name for site in self.sites]

class QueryInfo(XMLParser):
    """
    """
    def __init__(self,xml_root,version='wml1.1'):
        super(QueryInfo, self).__init__(xml_root,version)
        self.parse_query_info()

    def parse_query_info(self, xml=None):
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
            # create queryinfo object from dict
        xml_dict = _xml_to_dict(self._root)
        self.creation_time = parser.parse(xml_dict.get('creation_time')) if xml_dict.get('creation_time') is not None else None
        self.notes = [testXMLValue(note) for note in self._findall('note')]
        self.criteria = Criteria(self._find('criteria'), self._ns)
        # except:
        #   raise ValueError('Unable to parse queryInfo element correctly')

class Criteria(XMLParser):
    """
    """
    def __init__(self,xml_root,version='wml1.1'):
        super(Criteria, self).__init__(xml_root,version)
        self.parse_criteria()

    def parse_criteria(self, xml=None):
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
        xml_dict = _xml_to_dict(self._root,depth=4)
        self.method_called = self._root.attrib.get('MethodCalled')
        self.location_param = xml_dict.get('location_param')
        self.variable_param = xml_dict.get('variable_param')
        try:
            self.begin_date_time = parser.parse(xml_dict['begin_date_time'])
        except:
            self.begin_date_time = None

        try:
            self.end_date_time = parser.parse(xml_dict['end_date_time'])
        except:
            self.end_date_time = None

        self.parameters = [(param.attrib.get('name'),param.attrib.get('value')) for param in self._findall('parameter')]
        # except:
        #   raise ValueError('Unable to parse xml for criteria element')

class Site(XMLParser):
    def __init__(self, xml, version='wml1.1'):
        super(Site,self).__init__(xml,version)
        self.parse_site()

    def __iter__(self):
        for c in self.series_catalogs:
            yield c

    def __getitem__(self,key):
        if isinstance(key,int) and key < len(self.series_catalogs):
            return self.series_catalogs[key]

        if isinstance(key,str):
            var = [series.variable for catalog in self.series_catalogs for series in catalog if series.code == key]
            if len(var) > 0:
                return var[0]

        raise KeyError('Unknown key ' + str(key))

    """Accessor propeties/methods"""
    @property
    def name(self):
        return self.site_info.site_name

    @property
    def codes(self):
        return self.site_info.site_codes

    @property
    def variable_names(self):
        return list(set([series.variable.variable_name for catalog in self.series_catalogs for series in catalog]))

    @property
    def variable_codes(self):
        return list(set([series.variable.variable_code for catalog in self.series_catalogs for series in catalog]))

    @property
    def geo_coords(self):
        return self.site_info.location.geo_coords

    @property
    def latitudes(self):
        return [g[1] for g in self.site_info.location.geo_coords]

    @property
    def longitudes(self):
        return [g[0] for g in self.site_info.location.geo_coords]

    def parse_site(self,xml=None):
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
        self.site_info = SiteInfo(self._find('siteInfo'), self._ns)
        self.series_catalogs = [SeriesCatalog(elm, self._ns) for elm in self._findall('seriesCatalog')]
            # self.extension = Extension(self._find('extension'), self._ns)
        # except:
        #   raise ValueError('Unable to parse site element correctly')


class SiteInfo(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(SiteInfo,self).__init__(xml,version)
        self.parse_siteinfo()

    def parse_siteinfo(self,xml=None):
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
        xml_dict = _xml_to_dict(self._root)
        self.site_name = xml_dict.get('site_name')
        self.site_codes = [testXMLValue(code) for code in self._findall('siteCode')]
        self.elevation = xml_dict.get('elevation_m')
        self.vertical_datum = xml_dict.get('vertical_datum')
        self.site_types = [testXMLValue(typ) for typ in self._findall('siteType')]
        self.site_properties = dict([(prop.attrib.get('name'),testXMLValue(prop)) for prop in self._findall('siteProperty')])
        self.altname = xml_dict.get('altname')
        self.notes = [testXMLValue(note) for note in self._findall('note')]
        # sub-objects
        tzi = self._find('timeZoneInfo')
        if tzi is not None:
            self.time_zone_info = TimeZoneInfo(tzi, self._ns)

        self.location = Location(self._find('geoLocation'), self._ns)

        # except:
        #   raise ValueError('Unable to parse siteInfo element')

class Location(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Location,self).__init__(xml,version)
        self.parse_location()

    def parse_location(self,xml=None):
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
        xml_dict = _xml_to_dict(self._root)
        geogs = self._findall('geogLocation')
        self.geo_coords = list()
        self.srs = list()
        for g in geogs:
            self.geo_coords.append((testXMLValue(g.find(ns(self._ns) + 'longitude')),testXMLValue(g.find(ns(self._ns) + 'latitude'))))
            self.srs.append(g.attrib.get('srs'))

        locsite = self._findall('localSiteXY')
        self.local_sites = list()
        self.notes = list()
        self.projections = list()
        for ls in locsite:
            z = testXMLValue(ls.find(ns(self._ns) + 'Z'))
            if z is not None:
                self.local_sites.append((testXMLValue(ls.find(ns(self._ns) + 'X')),testXMLValue(ls.find(ns(self._ns) + 'Y')),z))
            else:
                self.local_sites.append((testXMLValue(ls.find(ns(self._ns) + 'X')),testXMLValue(ls.find(ns(self._ns) + 'Y')),'0'))

            self.notes.append([testXMLValue(note) for note in ls.findall(ns(self._ns) + 'note')])
            self.projections.append(ls.attrib.get('projectionInformation'))

        # except:
        #   raise ValueError('Unable to parse geoLocation element')


class TimeZoneInfo(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(TimeZoneInfo,self).__init__(xml,version)
        self.parse_timezoneinfo()

    def parse_timezoneinfo(self,xml=None):
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
        xml_dict = _xml_to_dict(self._root)
        default = self._find('defaultTimeZone')
        if default is not None:
          self.zone_offset = default.attrib.get('zoneOffset')
          self.zone_abbreviation = default.attrib.get('zoneAbbreviation')

        daylight = self._find('daylightSavingsTimeZone')
        if daylight is not None:
          self.daylight_zone_offset = daylight.attrib.get('zoneOffset')
          self.daylight_zone_abbreviation = daylight.attrib.get('zoneAbbreviation')

        # except:
        #   raise ValueError('Unable to properly parset the timeZoneInfo element')
            

class SeriesCatalog(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(SeriesCatalog,self).__init__(xml,version)
        self.parse_seriescatalog()

    def __iter__(self):
        for s in self.series:
            yield s

    def __getitem__(self,key):
        if isinstance(key,int) and key < len(self.series):
            return self.series[key]

        if isinstance(key,str):
            srs = [series for series in self.series if series.code == key]
            if len(srs) > 0:
                return srs[0]

        raise KeyError('Unknown key ' + str(key))

    def parse_seriescatalog(self,xml=None):
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
        self.series = [Series(elm,self._ns) for elm in self._findall('series')]
        # except:
        #   raise ValueError('Unable to properly parse the seriesCatalog element')


class Series(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Series,self).__init__(xml,version)
        self.parse_series()

    """Accessor proeprties/methods"""
    @property
    def name(self):
        return self.variable.variable_name

    @property
    def code(self):
        return self.variable.variable_code

    def parse_series(self,xml=None):
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
        xml_dict = _xml_to_dict(self._root,depth=3)
        self.value_count = xml_dict.get('value_count')
        self.value_type = xml_dict.get('value_type')
        self.general_category = xml_dict.get('general_category')
        self.sample_medium = xml_dict.get('sample_medium')
        self.data_type = xml_dict.get('data_type')
        # date-time
        self.begin_date_time = parser.parse(xml_dict.get('begin_date_time'))
        self.begin_date_time_utc = parser.parse(xml_dict.get('begin_date_time_utc')) if xml_dict.get('begin_date_time_utc') is not None else None
        self.end_date_time = parser.parse(xml_dict.get('end_date_time'))
        self.end_date_time_utc = parser.parse(xml_dict.get('end_date_time_utc')) if xml_dict.get('end_date_time_utc') is not None else None
        # method info
        self.method_description = xml_dict.get('method_description')
        self.method_code = xml_dict.get('method_code')
        self.method_link = xml_dict.get('method_link')
        method = self._find('method')
        if method is not None:
            self.method_id = method.attrib.get('methodID')
        else:
            self.method_id = None

        # source info
        self.organization = xml_dict.get('organization')
        self.source_description = xml_dict.get('source_description')
        self.citation = xml_dict.get('citation')
        source = self._find('source')
        if source is not None:
            self.source_id = source.attrib.get('sourceID')
        else:
            self.source_id = None

        # quality control info
        self.quality_control_level_code = xml_dict.get('quality_control_level_code')
        self.definition = xml_dict.get('definition')
        qa = self._find('qualityControlLevel')
        if qa is not None:
            self.quality_control_level_id = qa.attrib.get('qualityControlLevelID')
        else:
            self.quality_control_level_id = None

        # properties
        self.properties = dict([(prop.attrib.get('name'),testXMLValue(prop)) for prop in self._findall('seriesProperty')])
        # sub-objects
        self.variable = Variable(self._find('variable'),self._ns)
        # except:
        #   raise ValueError('Unable to correctly parse Series element')


class Variable(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Variable,self).__init__(xml,version)
        self.parse_variable()

    def parse_variable(self,xml=None):
        if xml is not None:
            try:
                self._root = etree.parse(xml)
            except:
                self._root = xml

        # try:
        xml_dict = _xml_to_dict(self._root)
        self.value_type = xml_dict.get('value_type')
        self.data_type = xml_dict.get('data_type')
        self.general_category = xml_dict.get('general_category')
        self.sample_medium = xml_dict.get('sample_medium')
        self.no_data_value = xml_dict.get('no_data_value')
        self.variable_name = xml_dict.get('variable_name')
        self.variable_code = xml_dict.get('variable_code')
        self.variable_description = xml_dict.get('variable_description')
        self.speciation = xml_dict.get('speciation')
        # notes and properties
        notes = [(note.attrib.get('title'),testXMLValue(note)) for note in self._findall('note')]
        none_notes = [note[1] for note in notes if note[0] is None]
        self.notes = dict([note for note in notes if note[0] is not None])
        if len(none_notes) > 0:
            self.notes['none'] = none_notes

        self.properties = dict([(prop.attrib.get('name'),testXMLValue(prop)) for prop in self._findall('variableProperty')])
        # related
        related = self._find('related')
        if related is not None:
            self.parent_codes = [dict([('network',code.attrib.get('network')),('vocabulary',code.attrib.get('vocabulary')),('default',code.attrib.get('default'))])
                             for code in related.findall(ns(self._ns) + 'parentCode')]
            self.related_codes = [dict([('network',d.get('network')),('vocabulary',d.get('vocabulary')),('default',d.get('default'))])
                             for code in related.findall(ns(self._ns) + 'relatedCode')]
        else:
            self.parent_codes = None
            self.related_codes = None

        # sub-objects
        if self._ns == 'wml1.0':
            unit = self._find('units')
            self.unit = Unit1_0(unit, self._ns) if unit is not None else None

            timesupport = self._find('timeSupport')
            self.time_support = TimeScale(timesupport, self._ns) if timesupport is not None else None
        else:
            unit = self._find('unit')
            self.unit = Unit(unit, self._ns) if unit is not None else None

            timescale = self._find('timeScale')
            self.time_scale = TimeScale(timescale, self._ns) if timescale is not None else None

        categories = self._find('categories')
        if categories is not None:
            self.categories = [Category(cat,self._ns) for cat in categories.findall(ns(self._ns) + 'category')]
        else:
            self.categories = None
        # except:
        #   raise ValueError('Unable to correctly parse variable element')


class TimeScale(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(TimeScale,self).__init__(xml,version)
        self.parse_timescale()

    def parse_timescale(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.time_spacing = xml_dict.get('time_spacing')
            self.time_support = xml_dict.get('time_support')
            self.time_interval = xml_dict.get('time_interval')
            unit = self._find('unit')
            self.unit = Unit(unit, self._ns) if unit is not None else None
        except:
            raise


class Unit(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Unit,self).__init__(xml,version)
        self.parse_unit()

    def parse_unit(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.name = xml_dict.get('unit_name')
            self.unit_type = xml_dict.get('unit_type')
            self.description = xml_dict.get('unit_description')
            self.abbreviation = xml_dict.get('unit_abbreviation')
            self.code = xml_dict.get('unit_code')
            self.id = self._root.attrib.get('UnitID')
        except:
            raise


class Unit1_0(XMLParser):
    def __init__(self,xml,version='wml1.0'):
        super(Unit1_0,self).__init__(xml,version)
        self.parse_unit()

    def parse_unit(self):
        try:
            self.name = testXMLValue(self._root)
            self.code = self._root.attrib.get('unitsCode')
            self.abbreviation = self._root.attrib.get('unitsAbbreviation')
            self.type = self._root.attrib.get('unitsType')
            self.id = self._root.attrib.get('unitID')
        except:
            raise


class Category(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Category,self).__init__(xml,version)
        self.parse_category()

    def parse_category(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.data_value = xml_dict.get('data_value')
            self.description = xml_dict.get('description')
            self.id = self._root.attrib.get('categoryID')
        except:
            raise


class TimeSeriesResponse(XMLParser):
    """
        Parses the response from a 'GetValues' request

        Parameters
        ===========
        :xmlio - A file-like object that holds the xml response from the request.

        Return 
        =======
        An object constructed from a dictionary parse of the response. The object has get access and can
        also iterate over each timeSeries element returned.
    """
    def __init__(self,xml,version='wml1.1'):
        super(TimeSeriesResponse,self).__init__(xml,version)
        self.parse_timeseriesresponse()

    """Accessor properties/methods"""
    @property
    def series_names(self):
        return [series.name for series in self.time_series]

    @property
    def variable_names(self):
        return list(set([series.variable.variable_name for series in self.time_series]))

    @property
    def variable_codes(self):
        return list(set([s.variable.variable_code for s in self.time_series]))

    def get_series_by_variable(self,var_name=None,var_code=None):
        if var_code is not None:
            return [s for s in self.time_series if s.variable.variable_code == var_code]

        elif var_name is not None:
            return [series for series in self.time_series if series.variable.variable_name == var_name]

        return None

    def parse_timeseriesresponse(self):
        try:
            qi = self._find('queryInfo')
            self.query_info = QueryInfo(qi,self._ns)
            self.time_series = [TimeSeries(series,self._ns) for series in self._findall('timeSeries')]
        except:
            raise


class TimeSeries(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(TimeSeries,self).__init__(xml,version)
        self.parse_timeseries()

    def parse_timeseries(self):
        try:
            self.variable = Variable(self._find('variable'), self._ns)
            self.values = [Values(val,self._ns) for val in self._findall('values')]
            self.source_info = SiteInfo(self._find('sourceInfo'), self._ns)
            self.name = self._root.attrib.get('name')
        except:
            raise

class Values(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Values,self).__init__(xml,version)
        self.parse_values()

    def __iter__(self):
        for v in self.values:
            yield v

    """Accessor properties/methods"""
    def get_date_values(self,method_id=None,source_id=None,sample_id=None,quality_level=None,utc=False):
        varl = [v for v in self.values]
        if method_id is not None:
            varl = [v for v in varl if v.method_id == method_id]

        if source_id is not None:
            varl = [v for v in varl if v.source_id == source_id]

        if sample_id is not None:
            varl = [v for v in varl if v.sample_id == sample_id]

        if quality_level is not None:
            varl = [v for v in varl if v.quality_control_level == quality_level]

        if not utc:
            return [(v.date_time,v.value) for v in varl]
        else:
            return [(v.date_time_utc,v.value) for v in varl]

    def parse_values(self):
        xml_dict = _xml_to_dict(self._root)
        # method info
        self.methods = [Method(method,self._ns) for method in self._findall('method')]

        # source info
        self.sources = [Source(source,self._ns) for source in self._findall('source')]

        # quality control info
        self.qualit_control_levels = [QualityControlLevel(qal, self._ns) for qal in self._findall('qualityControlLevel')]

        # offset info
        self.offsets = [Offset(os,self._ns) for os in self._findall('offset')]

        # sample info
        self.samples = [Sample(sample,self._ns) for sample in self._findall('sample')]

        # censor codes
        self.censor_codes = [CensorCode(code, self._ns) for code in self._findall('censorCode')]

        # unit
        if self._ns == 'wml1.0':
            self.unit_abbreviation = self._root.attrib.get('unitsAbbreviation')
            self.unit_code = self._root.attrib.get('unitsCode')
            self.count = self._root.attrib.get('count')
        else:
            unit = self._find('unit')
            self.unit = Unit(unit, self._ns) if unit is not None else None

        # values
        self.values = [Value(val, self._ns) for val in self._findall('value')]


class Value(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Value,self).__init__(xml,version)
        self.parse_value()

    def parse_value(self):
        try:
            self.value = testXMLValue(self._root)
            d = self._root.attrib
            self.qualifiers = d.get('qualifiers')
            self.censor_code = d.get('censorCode')
            self.date_time = parser.parse(d.get('dateTime')) if d.get('dateTime') is not None else None
            self.time_offset = d.get('timeOffset')
            self.date_time_utc = parser.parse(d.get('dateTimeUTC')) if d.get('dateTimeUTC') is not None else None
            self.method_id = d.get('methodID')
            self.source_id = d.get('sourceID')
            self.accuracy_std_dev = d.get('accuracyStdDev')
            self.sample_id = d.get('sampleID')
            self.method_code = d.get('methodCode')
            self.source_code = d.get('sourceCode')
            self.lab_sample_code = d.get('lab_sample_code')
            self.offset_value = d.get('offsetValue')
            self.offset_type_id = d.get('offsetTypeID')
            self.offset_type_code = d.get('offsetTypeCode')
            self.coded_vocabulary = d.get('codedVocabulary')
            self.coded_vocabulary_term = d.get('codedVocabularyTerm')
            self.quality_control_level = d.get('qualityControlLevel')
            self.metadata_time = d.get('metadataTime')
            self.oid = d.get('oid')
        except:
            raise


class Sample(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Sample,self).__init__(xml,version)
        self.parse_sample()

    def parse_sample(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.code = xml_dict.get('lab_sample_code')
            self.type = xml_dict.get('sample_type')
            lm = self._find('labMethod')
            self.method = LabMethod(lm, self._ns) if lm is not None else None
        except:
            raise


class LabMethod(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(LabMethod,self).__init__(xml,version)
        self.parse_labmethod()

    def parse_labmethod(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.code = xml_dict.get('lab_code')
            self.name = xml_dict.get('lab_name')
            self.organization = xml_dict.get('lab_organization')
            self.method_name = xml_dict.get('lab_method_name')
            self.method_description = xml_dict.get('lab_method_description')
            self.method_link = xml_dict.get('lab_method_link')
            # sub-objects
            source = self._find('labSourceDetails')
            self.source_details = Source(source,self._ns) if source is not None else None
        except:
            raise


class Source(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Source,self).__init__(xml,version)
        self.parse_source()

    def __str__(self):
        return str(self.__dict__)

    def get_contact(self,name):
        ci = [ci for ci in self.contact_info if ci.name == name]
        if len(ci) < 0:
            return ci[0]
        return None

    def parse_source(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.code = xml_dict.get('source_code')
            self.organization = xml_dict.get('organization')
            self.description = xml_dict.get('source_description')
            self.links = [testXMLValue(link) for link in self._findall('sourceLink')]
            self.citation = xml_dict.get('citation')
            # metadata
            self.topic_category = xml_dict.get('topic_category')
            self.title = xml_dict.get('title')
            self.abstract = xml_dict.get('abstract')
            self.profile_version = xml_dict.get('profile_version')
            self.metadata_link = xml_dict.get('metadata_link')
            # contact info
            self.contact_info = [ContactInformation(ci,self._ns) for ci in self._findall('contactInformation')]
        except:
            raise


class ContactInformation(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(ContactInformation,self).__init__(xml,version)
        self.parse_contactinformation()

    def parse_contactinformation(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.name = xml_dict.get('contact_name')
            self.type = xml_dict.get('type_of_contact')
            self.email = [testXMLValue(email) for email in self._findall('email')]
            self.phone = [testXMLValue(phone) for phone in self._findall('phone')]
            self.address = [testXMLValue(address) for address in self._findall('address')]
        except:
            raise


class Offset(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Offset,self).__init__(xml,version)
        self.parse_offset()

    def parse_offset(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.type_code = xml_dict.get('offset_type_code')
            self.value = xml_dict.get('offset_value')
            self.description = xml_dict.get('offset_description')
            self.is_vertical = xml_dict.get('offset_is_vertical')
            self.azimuth_degrees = xml_dict.get('offset_azimuth_degrees')
            unit = self._root.find('unit')
            if self._ns == 'wml1.0':
                self.unit = Unit1_0(unit, self._ns) if unit is not None else None
            else:
                self.unit = Unit(unit,self._ns) if unit is not None else None
        except:
            raise


class Method(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(Method,self).__init__(xml,version)
        self.parse_method()

    def parse_method(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.code = xml_dict.get('method_code')
            self.description = xml_dict.get('method_description')
            self.link = xml_dict.get('method_link')
            self.id = self._root.attrib.get('methodID')
        except:
            raise


class QualityControlLevel(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(QualityControlLevel,self).__init__(xml,version)
        self.parse_qcl()

    def parse_qcl(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.code = xml_dict.get('quality_control_level_code')
            self.definition = xml_dict.get('definition')
            self.explanation = xml_dict.get('explanation')
            self.id = self._root.attrib.get('qualityControlLevelID')
        except:
            raise


class CensorCode(XMLParser):
    def __init__(self,xml,version='wml1.1'):
        super(CensorCode,self).__init__(xml,version)
        self.parse_censorcode()

    def parse_censorcode(self):
        try:
            xml_dict = _xml_to_dict(self._root)
            self.code = xml_dict.get('censor_code')
            self.description = xml_dict.get('censor_code_description')
            self.id = self._root.attrib.get('censorCodeID')
        except:
            raise

class VariablesResponse(XMLParser):
    """
        Parses the response from a 'GetVariableInfo' request

        Parameters
        ===========
        :xmlio - A file-like object that holds the xml response from the request.

        Return
        =======
        An object constructed from a dictionary parse of the response. The object has get access to its variables and
        can also be used as an iterator.
    """
    def __init__(self,xml,version='wml1.1'):
        super(VariablesResponse,self).__init__(xml,version)
        self.parse_variablesresponse()

    def __iter__(self):
        for v in self.variables:
            yield v

    def __getitem__(self,key):
        if isinstance(key,int) and key < len(self.variables):
            return self.variables[key]

        if isinstance(key,str):
            v = [var for var in self.variables if var.variable_code == key]
            if len(v) > 0:
                return v[0]

            v = [var for var in self.variables if var.variable_name == key]
            if len(v) > 0:
                return v[0]

        raise KeyError('Unknown key ' + str(key))

    """Accessor properties/methods"""
    @property
    def variable_names(self):
        return list(set([var.variable_name for var in self.variables]))

    @property
    def variable_codes(self):
        return  [var.variable_code for var in self.variables]

    def parse_variablesresponse(self):
        try:
            qi = self._find('queryInfo')
            self.query_info = QueryInfo(qi, self._ns) if qi is not None else None
            varis = self._find('variables')
            self.variables = [Variable(var,self._ns) for var in varis.findall(ns(self._ns) + 'variable')]
        except:
            raise


########NEW FILE########
__FILENAME__ = wml10
from owslib.waterml.wml import SitesResponse, TimeSeriesResponse, VariablesResponse, namespaces
from owslib.etree import etree

def ns(namespace):
    return namespaces.get(namespace)

class WaterML_1_0(object):
    def __init__(self, element):

        if isinstance(element, str) or isinstance(element, unicode):
            self._root = etree.fromstring(str(element))
        else:
            self._root = element

        if hasattr(self._root, 'getroot'):
            self._root = self._root.getroot()

        self._ns = 'wml1.0'

    @property
    def response(self):
        try:
            if self._root.tag == str(ns(self._ns) + 'variablesResponse'):
                return VariablesResponse(self._root, self._ns)
            elif self._root.tag == str(ns(self._ns) + 'timeSeriesResponse'):
                return TimeSeriesResponse(self._root, self._ns)
            elif self._root.tag == str(ns(self._ns) + 'sitesResponse'):
                return SitesResponse(self._root, self._ns)
        except:
            raise

        raise ValueError('Unable to determine response type from xml')
########NEW FILE########
__FILENAME__ = wml11
from owslib.waterml.wml import SitesResponse, TimeSeriesResponse, VariablesResponse, namespaces
from owslib.etree import etree

def ns(namespace):
    return namespaces.get(namespace)

class WaterML_1_1(object):
    def __init__(self, element):

        if isinstance(element, str) or isinstance(element, unicode):
            self._root = etree.fromstring(str(element))
        else:
            self._root = element

        if hasattr(self._root, 'getroot'):
            self._root = self._root.getroot()

        self._ns = 'wml1.1'

    @property
    def response(self):
        try:
            if self._root.tag == str(ns(self._ns) + 'variablesResponse'):
                return VariablesResponse(self._root, self._ns)
            elif self._root.tag == str(ns(self._ns) + 'timeSeriesResponse'):
                return TimeSeriesResponse(self._root, self._ns)
            elif self._root.tag == str(ns(self._ns) + 'sitesResponse'):
                return SitesResponse(self._root, self._ns)
        except:
            raise

        raise ValueError('Unable to determine response type from xml')

########NEW FILE########
__FILENAME__ = wcs
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2004, 2006 Sean C. Gillies
# Copyright (c) 2007 STFC <http://www.stfc.ac.uk>
#
# Authors : 
#          Dominic Lowe <d.lowe@rl.ac.uk>
#
# Contact email: d.lowe@rl.ac.uk
# =============================================================================

"""
Web Coverage Server (WCS) methods and metadata. Factory function.
"""


import urllib2
import etree
from coverage import wcs100, wcs110, wcsBase

def WebCoverageService(url, version=None, xml=None, cookies=None, timeout=30):
    ''' wcs factory function, returns a version specific WebCoverageService object '''
    
    if version is None:
        if xml is None:
            reader = wcsBase.WCSCapabilitiesReader()
            request = reader.capabilities_url(url)
            if cookies is None:
                xml = urllib2.urlopen(request, timeout=timeout).read()
            else:
                req = urllib2.Request(request)
                req.add_header('Cookie', cookies)   
                xml=urllib2.urlopen(req, timeout=timeout)
        capabilities = etree.etree.fromstring(xml)
        version = capabilities.get('version')
        del capabilities
        
    if version == '1.0.0':
        return wcs100.WebCoverageService_1_0_0.__new__(wcs100.WebCoverageService_1_0_0, url, xml, cookies)
    elif version == '1.1.0':
        return wcs110.WebCoverageService_1_1_0.__new__(wcs110.WebCoverageService_1_1_0,url, xml, cookies)

########NEW FILE########
__FILENAME__ = wfs
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2004, 2006 Sean C. Gillies
# Copyright (c) 2009 STFC <http://www.stfc.ac.uk>
#
# Authors : 
#          Dominic Lowe <dominic.lowe@stfc.ac.uk>
#
# Contact email: dominic.lowe@stfc.ac.uk
# =============================================================================

"""
Web Feature Server (WFS) methods and metadata. Factory function.
"""

from feature import wfs100, wfs110, wfs200 
def WebFeatureService(url, version='1.0.0', xml=None, parse_remote_metadata=False):
    ''' wfs factory function, returns a version specific WebFeatureService object
    
    @type url: string
    @param url: url of WFS capabilities document
    @type xml: string
    @param xml: elementtree object
    @type parse_remote_metadata: boolean
    @param parse_remote_metadata: whether to fully process MetadataURL elements
    @return: initialized WebFeatureService_2_0_0 object
    '''
    if version in  ['1.0', '1.0.0']:
        return wfs100.WebFeatureService_1_0_0(url, version, xml, parse_remote_metadata)
    elif version in  ['1.1', '1.1.0']:
        return wfs110.WebFeatureService_1_1_0(url, version, xml, parse_remote_metadata)
    elif version in ['2.0', '2.0.0']:
        return wfs200.WebFeatureService_2_0_0(url,  version, xml, parse_remote_metadata)


########NEW FILE########
__FILENAME__ = wmc
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2004 Sean C. Gillies
# Copyright (c) 2005 Nuxeo SARL <http://nuxeo.com>
#
# Authors : Sean Gillies <sgillies@frii.com>
#           Julien Anguenot <ja@nuxeo.com>
#
# Contact email: sgillies@frii.com
# =============================================================================

"""Web Map Context (WMC)

Specification can be found over there :
https://portal.opengeospatial.org/files/?artifact_id=8618

"""

from etree import etree

context_ns_uri = 'http://www.opengis.net/context'
context_schemas_uri = 'http://schemas.opengis.net/context/1.0.0/context.xsd'

def WMCElement(tag):
    """WMC based element
    """
    return etree.Element("{%s}"%context_ns_uri + tag)

class MapContext:
    """ Map Context abstraction

    It uses a Map representation as input and export it as as map
    context
    """

    def __init__(self, map_):
        self._map = map_

    def _getRootElement(self):
        root = WMCElement('ViewContext')
        attrs = {
            '{http://www.w3.org/2001/XMLSchema-instance}schemaLocation':
            context_ns_uri + ' ' + context_schemas_uri,
            'id' : self._map.id,
            'version' : '1.0.0',
            }
        for k, v in attrs.items():
            root.attrib[k] = v
        return root

    def _getGeneralElement(self):
        general = WMCElement('General')
        general.append(self._getWindowElement())
        general.append(self._getBoundingBoxElement())
        return general

    def _getWindowElement(self):
        window = WMCElement('Window')
        window.attrib['width'] = str(self._map.size[0])
        window.attrib['height'] = str(self._map.size[1])
        return window

    def _getBoundingBoxElement(self):
        bbox = WMCElement('BoundingBox')
        bbox.attrib['SRS'] = str(self._map.srs.split()[0])
        bbox.attrib['minx'] = str(self._map.bounds[0])
        bbox.attrib['miny'] = str(self._map.bounds[1])
        bbox.attrib['maxx'] = str(self._map.bounds[2])
        bbox.attrib['maxy'] = str(self._map.bounds[3])
        return bbox

    def _getLayerListElement(self):
        layerlist = WMCElement('LayerList')
        layering = zip(self._map.layernames, self._map.layertitles)
        layer_infos = self._map.getLayerInfos()

        # mapbuilder draws layers in bottom-top order
        for name, title in layering:

            # Layer
            layer = WMCElement('Layer')
            layer.attrib['queryable'] = '0'
            layer.attrib['hidden'] = str(
                int(name not in self._map.visible_layers))

            # Layer styles
            if layer_infos and layer_infos.get(title):
                stylelist = WMCElement('StyleList')
                # Get wms `Style` nodes for a given layer
                for e_style in layer_infos.get(title):
                    e_style.attrib['current'] = '1'
                    # Change namespace to wmc
                    for node in e_style.getiterator():
                        tag_name = node.tag[node.tag.rfind('}')+1:]
                        node.tag = "{%s}"%context_ns_uri + tag_name
                    stylelist.append(e_style)
                layer.append(stylelist)

            # Server
            server = WMCElement('Server')
            server.attrib['service'] = 'OGC:WMS'
            server.attrib['version'] = '1.1.1'
            server.attrib['title'] = 'OGC:WMS'

            # OnlineRessource
            oressource = WMCElement('OnlineResource')
            oressource.attrib[
                '{http://www.w3.org/1999/xlink}type'] = 'simple'
            oressource.attrib[
                '{http://www.w3.org/1999/xlink}href'] = self._map.url
            server.append(oressource)
            layer.append(server)

            # Name
            e_name = WMCElement('Name')
            e_name.text = name
            layer.append(e_name)

            # Title
            e_title = WMCElement('Title')
            e_title.text = title
            layer.append(e_title)

            # Format
            formatlist = WMCElement('FormatList')
            format = WMCElement('Format')
            format.attrib['current'] = '1'
            format.text = self._map.format
            formatlist.append(format)
            layer.append(formatlist)
            layerlist.append(layer)

        return layerlist

    def __call__(self):
        """Export self._map to WMC
        """
        wmc_doc_tree = self._getRootElement()
        wmc_doc_tree.append(self._getGeneralElement())
        wmc_doc_tree.append(self._getLayerListElement())
        return etree.tostring(wmc_doc_tree)


class AggregateMapContext(MapContext):
    """ Map Context abstraction

    It uses a Map representation as input and export it as as map
    context -- with aggregation of all layers accomplished through
    overload of the Layer/Name property
    """

    def _getLayerListElement(self):
        layerlist = WMCElement('LayerList')
        #layering = zip(self._map.layernames, self._map.layertitles)
        layer_infos = self._map.getLayerInfos()

        # Layer
        layer = WMCElement('Layer')
        layer.attrib['queryable'] = '0'
        layer.attrib['hidden'] = '0'

        # Server
        server = WMCElement('Server')
        server.attrib['service'] = 'OGC:WMS'
        server.attrib['version'] = '1.1.1'
        server.attrib['title'] = 'OGC:WMS'

        # OnlineRessource
        oressource = WMCElement('OnlineResource')
        oressource.attrib['{http://www.w3.org/1999/xlink}type'] = 'simple'
        oressource.attrib['{http://www.w3.org/1999/xlink}href'] = self._map.url
        server.append(oressource)
        layer.append(server)

        # Name
        e_name = WMCElement('Name')
        e_name.text = ','.join(self._map.layernames)
        layer.append(e_name)

        # Title
        e_title = WMCElement('Title')
        e_title.text = 'Aggregate Layers'
        layer.append(e_title)

        # Format
        formatlist = WMCElement('FormatList')
        format = WMCElement('Format')
        format.attrib['current'] = '1'
        format.text = self._map.format
        formatlist.append(format)
        layer.append(formatlist)
        layerlist.append(layer)
        
        return layerlist


def mapToWebMapContext(map, aggregate_layers=False):
    """Helper

    if the second argument evaluates to True, then all map layers are
    aggregated into a single map context layer.
    """
    if aggregate_layers:
        return AggregateMapContext(map)()
    else:
        return MapContext(map)()


########NEW FILE########
__FILENAME__ = wms
# -*- coding: ISO-8859-15 -*-
# =============================================================================
# Copyright (c) 2004, 2006 Sean C. Gillies
# Copyright (c) 2005 Nuxeo SARL <http://nuxeo.com>
#
# Authors : Sean Gillies <sgillies@frii.com>
#           Julien Anguenot <ja@nuxeo.com>
#
# Contact email: sgillies@frii.com
# =============================================================================

"""
API for Web Map Service (WMS) methods and metadata.

Currently supports only version 1.1.1 of the WMS protocol.
"""

import cgi
import urllib2
from urllib import urlencode
import warnings
from etree import etree
from .util import openURL, testXMLValue, extract_xml_list, xmltag_split
from fgdc import Metadata
from iso import MD_Metadata

class ServiceException(Exception):
    """WMS ServiceException

    Attributes:
        message -- short error message
        xml  -- full xml error message from server
    """

    def __init__(self, message, xml):
        self.message = message
        self.xml = xml
        
    def __str__(self):
        return repr(self.message)


class CapabilitiesError(Exception):
    pass


class WebMapService(object):
    """Abstraction for OGC Web Map Service (WMS).

    Implements IWebMapService.
    """
    
    def __getitem__(self,name):
        ''' check contents dictionary to allow dict like access to service layers'''
        if name in self.__getattribute__('contents').keys():
            return self.__getattribute__('contents')[name]
        else:
            raise KeyError, "No content named %s" % name

    
    def __init__(self, url, version='1.1.1', xml=None, 
                username=None, password=None, parse_remote_metadata=False
                ):
        """Initialize."""
        self.url = url
        self.username = username
        self.password = password
        self.version = version
        self._capabilities = None
        
        # Authentication handled by Reader
        reader = WMSCapabilitiesReader(
                self.version, url=self.url, un=self.username, pw=self.password
                )
        if xml:  # read from stored xml
            self._capabilities = reader.readString(xml)
        else:  # read from server
            self._capabilities = reader.read(self.url)

        # avoid building capabilities metadata if the response is a ServiceExceptionReport
        se = self._capabilities.find('ServiceException') 
        if se is not None: 
            err_message = str(se.text).strip() 
            raise ServiceException(err_message, xml) 

        # build metadata objects
        self._buildMetadata(parse_remote_metadata)

    def _getcapproperty(self):
        if not self._capabilities:
            reader = WMSCapabilitiesReader(
                self.version, url=self.url, un=self.username, pw=self.password
                )
            self._capabilities = ServiceMetadata(reader.read(self.url))
        return self._capabilities

    def _buildMetadata(self, parse_remote_metadata=False):
        ''' set up capabilities metadata objects '''
        
        #serviceIdentification metadata
        serviceelem=self._capabilities.find('Service')
        self.identification=ServiceIdentification(serviceelem, self.version)   
        
        #serviceProvider metadata
        self.provider=ServiceProvider(serviceelem)   
            
        #serviceOperations metadata 
        self.operations=[]
        for elem in self._capabilities.find('Capability/Request')[:]:
            self.operations.append(OperationMetadata(elem))
          
        #serviceContents metadata: our assumption is that services use a top-level 
        #layer as a metadata organizer, nothing more.
        self.contents={}
        caps = self._capabilities.find('Capability')
        
        #recursively gather content metadata for all layer elements.
        #To the WebMapService.contents store only metadata of named layers.
        def gather_layers(parent_elem, parent_metadata):
            for index, elem in enumerate(parent_elem.findall('Layer')):
                cm = ContentMetadata(elem, parent=parent_metadata, index=index+1, parse_remote_metadata=parse_remote_metadata)
                if cm.id:
                    if cm.id in self.contents:
                        warnings.warn('Content metadata for layer "%s" already exists. Using child layer' % cm.id)
                    self.contents[cm.id] = cm
                gather_layers(elem, cm)
        gather_layers(caps, None)
        
        #exceptions
        self.exceptions = [f.text for f \
                in self._capabilities.findall('Capability/Exception/Format')]
            
    def items(self):
        '''supports dict-like items() access'''
        items=[]
        for item in self.contents:
            items.append((item,self.contents[item]))
        return items
    
    def getcapabilities(self):
        """Request and return capabilities document from the WMS as a 
        file-like object.
        NOTE: this is effectively redundant now"""
        
        reader = WMSCapabilitiesReader(
            self.version, url=self.url, un=self.username, pw=self.password
            )
        u = self._open(reader.capabilities_url(self.url))
        # check for service exceptions, and return
        if u.info().gettype() == 'application/vnd.ogc.se_xml':
            se_xml = u.read()
            se_tree = etree.fromstring(se_xml)
            err_message = str(se_tree.find('ServiceException').text).strip()
            raise ServiceException(err_message, se_xml)
        return u

    def getmap(self, layers=None, styles=None, srs=None, bbox=None,
               format=None, size=None, time=None, transparent=False,
               bgcolor='#FFFFFF',
               exceptions='application/vnd.ogc.se_xml',
               method='Get',
               **kwargs
               ):
        """Request and return an image from the WMS as a file-like object.
        
        Parameters
        ----------
        layers : list
            List of content layer names.
        styles : list
            Optional list of named styles, must be the same length as the
            layers list.
        srs : string
            A spatial reference system identifier.
        bbox : tuple
            (left, bottom, right, top) in srs units.
        format : string
            Output image format such as 'image/jpeg'.
        size : tuple
            (width, height) in pixels.
        transparent : bool
            Optional. Transparent background if True.
        bgcolor : string
            Optional. Image background color.
        method : string
            Optional. HTTP DCP method name: Get or Post.
        **kwargs : extra arguments
            anything else e.g. vendor specific parameters
        
        Example
        -------
            >>> wms = WebMapService('http://giswebservices.massgis.state.ma.us/geoserver/wms', version='1.1.1')
            >>> img = wms.getmap(layers=['massgis:GISDATA.SHORELINES_ARC'],\
                                 styles=[''],\
                                 srs='EPSG:4326',\
                                 bbox=(-70.8, 42, -70, 42.8),\
                                 size=(300, 300),\
                                 format='image/jpeg',\
                                 transparent=True)
            >>> out = open('example.jpg.jpg', 'wb')
            >>> out.write(img.read())
            >>> out.close()

        """        
        try:
            base_url = next((m.get('url') for m in self.getOperationByName('GetMap').methods if m.get('type').lower() == method.lower()))
        except StopIteration:
            base_url = self.url
        request = {'version': self.version, 'request': 'GetMap'}
        
        # check layers and styles
        assert len(layers) > 0
        request['layers'] = ','.join(layers)
        if styles:
            assert len(styles) == len(layers)
            request['styles'] = ','.join(styles)
        else:
            request['styles'] = ''

        # size
        request['width'] = str(size[0])
        request['height'] = str(size[1])
        
        request['srs'] = str(srs)
        request['bbox'] = ','.join([repr(x) for x in bbox])
        request['format'] = str(format)
        request['transparent'] = str(transparent).upper()
        request['bgcolor'] = '0x' + bgcolor[1:7]
        request['exceptions'] = str(exceptions)
        
        if time is not None:
            request['time'] = str(time)
        
        if kwargs:
            for kw in kwargs:
                request[kw]=kwargs[kw]

        data = urlencode(request)
        
        u = openURL(base_url, data, method, username = self.username, password = self.password)

        # check for service exceptions, and return
        if u.info()['Content-Type'] == 'application/vnd.ogc.se_xml':
            se_xml = u.read()
            se_tree = etree.fromstring(se_xml)
            err_message = unicode(se_tree.find('ServiceException').text).strip()
            raise ServiceException(err_message, se_xml)
        return u
        
    def getServiceXML(self):
        xml = None
        if self._capabilities is not None:
            xml = etree.tostring(self._capabilities)
        return xml

    def getfeatureinfo(self):
        raise NotImplementedError

    def getOperationByName(self, name): 
        """Return a named content item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError, "No operation named %s" % name
    
class ServiceIdentification(object):
    ''' Implements IServiceIdentificationMetadata '''
    
    def __init__(self, infoset, version):
        self._root=infoset
        self.type = testXMLValue(self._root.find('Name'))
        self.version = version
        self.title = testXMLValue(self._root.find('Title'))
        self.abstract = testXMLValue(self._root.find('Abstract'))
        self.keywords = extract_xml_list(self._root.findall('KeywordList/Keyword'))
        self.accessconstraints = testXMLValue(self._root.find('AccessConstraints'))
        self.fees = testXMLValue(self._root.find('Fees'))

class ServiceProvider(object):
    ''' Implements IServiceProviderMetatdata '''
    def __init__(self, infoset):
        self._root=infoset
        name=self._root.find('ContactInformation/ContactPersonPrimary/ContactOrganization')
        if name is not None:
            self.name=name.text
        else:
            self.name=None
        self.url=self._root.find('OnlineResource').attrib.get('{http://www.w3.org/1999/xlink}href', '')
        #contact metadata
        contact = self._root.find('ContactInformation')
        ## sometimes there is a contact block that is empty, so make
        ## sure there are children to parse
        if contact is not None and contact[:] != []:
            self.contact = ContactMetadata(contact)
        else:
            self.contact = None
            
    def getContentByName(self, name):
        """Return a named content item."""
        for item in self.contents:
            if item.name == name:
                return item
        raise KeyError, "No content named %s" % name

    def getOperationByName(self, name):
        """Return a named content item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError, "No operation named %s" % name
        
class ContentMetadata:
    """
    Abstraction for WMS layer metadata.

    Implements IContentMetadata.
    """
    def __init__(self, elem, parent=None, index=0, parse_remote_metadata=False, timeout=30):
        if elem.tag != 'Layer':
            raise ValueError('%s should be a Layer' % (elem,))
        
        self.parent = parent
        if parent:
            self.index = "%s.%d" % (parent.index, index)
        else:
            self.index = str(index)
        
        self.id = self.name = testXMLValue(elem.find('Name'))

        # layer attributes
        self.queryable = int(elem.attrib.get('queryable', 0))
        self.cascaded = int(elem.attrib.get('cascaded', 0))
        self.opaque = int(elem.attrib.get('opaque', 0))
        self.noSubsets = int(elem.attrib.get('noSubsets', 0))
        self.fixedWidth = int(elem.attrib.get('fixedWidth', 0))
        self.fixedHeight = int(elem.attrib.get('fixedHeight', 0))

        # title is mandatory property
        self.title = None
        title = testXMLValue(elem.find('Title'))
        if title is not None:
            self.title = title.strip()

        self.abstract = testXMLValue(elem.find('Abstract'))
        
        # bboxes
        b = elem.find('BoundingBox')
        self.boundingBox = None
        if b is not None:
            try: #sometimes the SRS attribute is (wrongly) not provided
                srs=b.attrib['SRS']
            except KeyError:
                srs=None
            self.boundingBox = (
                float(b.attrib['minx']),
                float(b.attrib['miny']),
                float(b.attrib['maxx']),
                float(b.attrib['maxy']),
                srs,
                )
        elif self.parent:
            if hasattr(self.parent, 'boundingBox'):
                self.boundingBox = self.parent.boundingBox

        # ScaleHint 
        sh = elem.find('ScaleHint') 
        self.scaleHint = None 
        if sh is not None: 
            self.scaleHint = {'min': sh.attrib['min'], 'max': sh.attrib['max']} 

        attribution = elem.find('Attribution')
        if attribution is not None:
            self.attribution = dict()
            title = attribution.find('Title')
            url = attribution.find('OnlineResource')
            logo = attribution.find('LogoURL')
            if title is not None: 
                self.attribution['title'] = title.text
            if url is not None:
                self.attribution['url'] = url.attrib['{http://www.w3.org/1999/xlink}href']
            if logo is not None: 
                self.attribution['logo_size'] = (int(logo.attrib['width']), int(logo.attrib['height']))
                self.attribution['logo_url'] = logo.find('OnlineResource').attrib['{http://www.w3.org/1999/xlink}href']

        b = elem.find('LatLonBoundingBox')
        if b is not None:
            self.boundingBoxWGS84 = (
                float(b.attrib['minx']),
                float(b.attrib['miny']),
                float(b.attrib['maxx']),
                float(b.attrib['maxy']),
            )
        elif self.parent:
            self.boundingBoxWGS84 = self.parent.boundingBoxWGS84
        else:
            self.boundingBoxWGS84 = None
            
        #SRS options
        self.crsOptions = []
            
        #Copy any parent SRS options (they are inheritable properties)
        if self.parent:
            self.crsOptions = list(self.parent.crsOptions)

        #Look for SRS option attached to this layer
        if elem.find('SRS') is not None:
            ## some servers found in the wild use a single SRS
            ## tag containing a whitespace separated list of SRIDs
            ## instead of several SRS tags. hence the inner loop
            for srslist in map(lambda x: x.text, elem.findall('SRS')):
                if srslist:
                    for srs in srslist.split():
                        self.crsOptions.append(srs)
                        
        #Get rid of duplicate entries
        self.crsOptions = list(set(self.crsOptions))

        #Set self.crsOptions to None if the layer (and parents) had no SRS options
        if len(self.crsOptions) == 0:
            #raise ValueError('%s no SRS available!?' % (elem,))
            #Comment by D Lowe.
            #Do not raise ValueError as it is possible that a layer is purely a parent layer and does not have SRS specified. Instead set crsOptions to None
            # Comment by Jachym:
            # Do not set it to None, but to [], which will make the code
            # work further. Fixed by anthonybaxter
            self.crsOptions=[]
            
        #Styles
        self.styles = {}
        
        #Copy any parent styles (they are inheritable properties)
        if self.parent:
            self.styles = self.parent.styles.copy()
 
        #Get the styles for this layer (items with the same name are replaced)
        for s in elem.findall('Style'):
            name = s.find('Name')
            title = s.find('Title')
            if name is None or title is None:
                raise ValueError('%s missing name or title' % (s,))
            style = { 'title' : title.text }
            # legend url
            legend = s.find('LegendURL/OnlineResource')
            if legend is not None:
                style['legend'] = legend.attrib['{http://www.w3.org/1999/xlink}href']
            self.styles[name.text] = style

        # keywords
        self.keywords = [f.text for f in elem.findall('KeywordList/Keyword')]

        # timepositions - times for which data is available.
        self.timepositions=None
        self.defaulttimeposition = None
        for extent in elem.findall('Extent'):
            if extent.attrib.get("name").lower() =='time':
                if extent.text:
                    self.timepositions=extent.text.split(',')
                    self.defaulttimeposition = extent.attrib.get("default")
                    break
                
        # Elevations - available vertical levels
        self.elevations=None
        for extent in elem.findall('Extent'):
            if extent.attrib.get("name").lower() =='elevation':
                if extent.text:
                    self.elevations=extent.text.split(',')
                    break                

        # MetadataURLs
        self.metadataUrls = []
        for m in elem.findall('MetadataURL'):
            metadataUrl = {
                'type': testXMLValue(m.attrib['type'], attrib=True),
                'format': testXMLValue(m.find('Format')),
                'url': testXMLValue(m.find('OnlineResource').attrib['{http://www.w3.org/1999/xlink}href'], attrib=True)
            }

            if metadataUrl['url'] is not None and parse_remote_metadata:  # download URL
                try:
                    content = urllib2.urlopen(metadataUrl['url'], timeout=timeout)
                    doc = etree.parse(content)
                    if metadataUrl['type'] is not None:
                        if metadataUrl['type'] == 'FGDC':
                            metadataUrl['metadata'] = Metadata(doc)
                        if metadataUrl['type'] == 'TC211':
                            metadataUrl['metadata'] = MD_Metadata(doc)
                except Exception, err:
                    metadataUrl['metadata'] = None

            self.metadataUrls.append(metadataUrl)

        # DataURLs
        self.dataUrls = []
        for m in elem.findall('DataURL'):
            dataUrl = {
                'format': m.find('Format').text.strip(),
                'url': m.find('OnlineResource').attrib['{http://www.w3.org/1999/xlink}href']
            }
            self.dataUrls.append(dataUrl)
                
        self.layers = []
        for child in elem.findall('Layer'):
            self.layers.append(ContentMetadata(child, self))

    def __str__(self):
        return 'Layer Name: %s Title: %s' % (self.name, self.title)


class OperationMetadata:
    """Abstraction for WMS OperationMetadata.
    
    Implements IOperationMetadata.
    """
    def __init__(self, elem):
        """."""
        self.name = xmltag_split(elem.tag)
        # formatOptions
        self.formatOptions = [f.text for f in elem.findall('Format')]
        self.methods = []
        for verb in elem.findall('DCPType/HTTP/*'):
            url = verb.find('OnlineResource').attrib['{http://www.w3.org/1999/xlink}href']
            self.methods.append({'type' : xmltag_split(verb.tag), 'url': url})


class ContactMetadata:
    """Abstraction for contact details advertised in GetCapabilities.
    """
    def __init__(self, elem):
        name = elem.find('ContactPersonPrimary/ContactPerson')
        if name is not None:
            self.name=name.text
        else:
            self.name=None
        email = elem.find('ContactElectronicMailAddress')
        if email is not None:
            self.email=email.text
        else:
            self.email=None
        self.address = self.city = self.region = None
        self.postcode = self.country = None

        address = elem.find('ContactAddress')
        if address is not None:
            street = address.find('Address')
            if street is not None: self.address = street.text

            city = address.find('City')
            if city is not None: self.city = city.text

            region = address.find('StateOrProvince')
            if region is not None: self.region = region.text

            postcode = address.find('PostCode')
            if postcode is not None: self.postcode = postcode.text

            country = address.find('Country')
            if country is not None: self.country = country.text

        organization = elem.find('ContactPersonPrimary/ContactOrganization')
        if organization is not None: self.organization = organization.text
        else:self.organization = None

        position = elem.find('ContactPosition')
        if position is not None: self.position = position.text
        else: self.position = None

      
class WMSCapabilitiesReader:
    """Read and parse capabilities document into a lxml.etree infoset
    """

    def __init__(self, version='1.1.1', url=None, un=None, pw=None):
        """Initialize"""
        self.version = version
        self._infoset = None
        self.url = url
        self.username = un
        self.password = pw

        #if self.username and self.password:
            ## Provide login information in order to use the WMS server
            ## Create an OpenerDirector with support for Basic HTTP 
            ## Authentication...
            #passman = HTTPPasswordMgrWithDefaultRealm()
            #passman.add_password(None, self.url, self.username, self.password)
            #auth_handler = HTTPBasicAuthHandler(passman)
            #opener = build_opener(auth_handler)
            #self._open = opener.open

    def capabilities_url(self, service_url):
        """Return a capabilities url
        """
        qs = []
        if service_url.find('?') != -1:
            qs = cgi.parse_qsl(service_url.split('?')[1])

        params = [x[0] for x in qs]

        if 'service' not in params:
            qs.append(('service', 'WMS'))
        if 'request' not in params:
            qs.append(('request', 'GetCapabilities'))
        if 'version' not in params:
            qs.append(('version', self.version))

        urlqs = urlencode(tuple(qs))
        return service_url.split('?')[0] + '?' + urlqs

    def read(self, service_url):
        """Get and parse a WMS capabilities document, returning an
        elementtree instance

        service_url is the base url, to which is appended the service,
        version, and request parameters
        """
        getcaprequest = self.capabilities_url(service_url)

        #now split it up again to use the generic openURL function...
        spliturl=getcaprequest.split('?')
        u = openURL(spliturl[0], spliturl[1], method='Get', username = self.username, password = self.password)
        return etree.fromstring(u.read())

    def readString(self, st):
        """Parse a WMS capabilities document, returning an elementtree instance

        string should be an XML capabilities document
        """
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        return etree.fromstring(st)

########NEW FILE########
__FILENAME__ = wmts
# -*- coding: UTF-8 -*-
# =============================================================================
# Copyright (C) 2012 Brad Hards <bradh@frogmouth.net>
#
# Based on wms.py, which has the following copyright statement:
# Copyright (c) 2004, 2006 Sean C. Gillies
# Copyright (c) 2005 Nuxeo SARL <http://nuxeo.com>
#
# Authors : Sean Gillies <sgillies@frii.com>
#           Julien Anguenot <ja@nuxeo.com>
#
# Contact email: sgillies@frii.com
# =============================================================================

"""

Abstract
--------
The wmts module of the OWSlib package provides client-side functionality for fetching tiles from an OGC Web Map Tile Service (WMTS)


Disclaimer
----------
PLEASE NOTE: the owslib wmts module should be considered in early-beta state: it has been tested against only one WMTS server (NASA EODSIS).
More extensive testing is needed and feedback (to bradh@frogmouth.net) would be appreciated.

"""

import warnings
import urlparse
import urllib2
from urllib import urlencode
from etree import etree
from .util import openURL, testXMLValue, getXMLInteger
from fgdc import Metadata
from iso import MD_Metadata
from ows import ServiceProvider, ServiceIdentification, OperationsMetadata


_WMTS_NS = '{http://www.opengis.net/wmts/1.0}'
_TILE_MATRIX_SET_LINK_TAG = _WMTS_NS + 'TileMatrixSetLink'
_TILE_MATRIX_SET_TAG = _WMTS_NS + 'TileMatrixSet'
_TILE_MATRIX_SET_LIMITS_TAG = _WMTS_NS + 'TileMatrixSetLimits'
_TILE_MATRIX_LIMITS_TAG = _WMTS_NS + 'TileMatrixLimits'
_TILE_MATRIX_TAG = _WMTS_NS + 'TileMatrix'
_MIN_TILE_ROW_TAG = _WMTS_NS + 'MinTileRow'
_MAX_TILE_ROW_TAG = _WMTS_NS + 'MaxTileRow'
_MIN_TILE_COL_TAG = _WMTS_NS + 'MinTileCol'
_MAX_TILE_COL_TAG = _WMTS_NS + 'MaxTileCol'


class ServiceException(Exception):
    """WMTS ServiceException

    Attributes:
        message -- short error message
        xml  -- full xml error message from server
    """

    def __init__(self, message, xml):
        self.message = message
        self.xml = xml

    def __str__(self):
        return repr(self.message)


class CapabilitiesError(Exception):
    pass


class WebMapTileService(object):
    """Abstraction for OGC Web Map Tile Service (WMTS).

    Implements IWebMapService.
    """

    def __getitem__(self,name):
        ''' check contents dictionary to allow dict like access to service layers'''
        if name in self.__getattribute__('contents').keys():
            return self.__getattribute__('contents')[name]
        else:
            raise KeyError, "No content named %s" % name


    def __init__(self, url, version='1.0.0', xml=None,
                username=None, password=None, parse_remote_metadata=False
                ):
        """Initialize."""
        self.url = url
        self.username = username
        self.password = password
        self.version = version
        self._capabilities = None

        # Authentication handled by Reader
        reader = WMTSCapabilitiesReader(
                self.version, url=self.url, un=self.username, pw=self.password
                )

        if xml:  # read from stored xml
            self._capabilities = reader.readString(xml)
        else:  # read from server
            self._capabilities = reader.read(self.url)

        # avoid building capabilities metadata if the response is a ServiceExceptionReport
        # TODO: check if this needs a namespace
        se = self._capabilities.find('ServiceException')
        if se is not None:
            err_message = str(se.text).strip()
            raise ServiceException(err_message, xml)

        # build metadata objects
        self._buildMetadata(parse_remote_metadata)

    def _getcapproperty(self):
        if not self._capabilities:
            reader = WMTSCapabilitiesReader(
                self.version, url=self.url, un=self.username, pw=self.password
                )
            self._capabilities = ServiceMetadata(reader.read(self.url))
        return self._capabilities

    def _buildMetadata(self, parse_remote_metadata=False):
        ''' set up capabilities metadata objects '''

        #serviceIdentification metadata
        serviceident=self._capabilities.find('{http://www.opengis.net/ows/1.1}ServiceIdentification')
        self.identification=ServiceIdentification(serviceident)

        #serviceProvider metadata
        serviceprov=self._capabilities.find('{http://www.opengis.net/ows/1.1}ServiceProvider')
        self.provider=ServiceProvider(serviceprov)

        #serviceOperations metadata
        self.operations=[]
        for elem in self._capabilities.find('{http://www.opengis.net/ows/1.1}OperationsMetadata')[:]:
            self.operations.append(OperationsMetadata(elem))

        #serviceContents metadata: our assumption is that services use a top-level
        #layer as a metadata organizer, nothing more.
        self.contents={}
        caps = self._capabilities.find('{http://www.opengis.net/wmts/1.0}Contents')

        def gather_layers(parent_elem, parent_metadata):
            for index, elem in enumerate(parent_elem.findall('{http://www.opengis.net/wmts/1.0}Layer')):
                cm = ContentMetadata(elem, parent=parent_metadata, index=index+1, parse_remote_metadata=parse_remote_metadata)
                if cm.id:
                    if cm.id in self.contents:
                        raise KeyError('Content metadata for layer "%s" already exists' % cm.id)
                    self.contents[cm.id] = cm
                gather_layers(elem, cm)
        gather_layers(caps, None)

        self.tilematrixsets = {}
        for elem in caps.findall('{http://www.opengis.net/wmts/1.0}TileMatrixSet'):
            tms = TileMatrixSet(elem)
            if tms.identifier:
                if tms.identifier in self.tilematrixsets:
                    raise KeyError('TileMatrixSet with identifier "%s" already exists' % tms.identifier)
                self.tilematrixsets[tms.identifier] = tms

        self.themes = {}
        for elem in self._capabilities.findall('{http://www.opengis.net/wmts/1.0}Themes/{http://www.opengis.net/wmts/1.0}Theme'):
            theme = Theme(elem)
            if theme.identifier:
                if theme.identifier in self.themes:
                    raise KeyError('Theme with identifier "%s" already exists' % theme.identifier)
                self.themes[theme.identifier] = theme

        serviceMetadataURL = self._capabilities.find('{http://www.opengis.net/wmts/1.0}ServiceMetadataURL')
        if serviceMetadataURL is not None:
            self.serviceMetadataURL = serviceMetadataURL.attrib['{http://www.w3.org/1999/xlink}href']
        else:
            self.serviceMetadataURL = None

    def items(self):
        '''supports dict-like items() access'''
        items=[]
        for item in self.contents:
            items.append((item,self.contents[item]))
        return items

    def buildTileRequest(self, layer=None, style=None, format=None, tilematrixset=None, tilematrix=None, row=None, column=None, **kwargs):
        """Return the URL-encoded parameters for a GetTile request.

        Parameters
        ----------
        layer : string
            Content layer name.
        style : string
            Optional style name. Defaults to the first style defined for
            the relevant layer in the GetCapabilities response.
        format : string
            Optional output image format,  such as 'image/jpeg'.
            Defaults to the first format defined for the relevant layer
            in the GetCapabilities response.
        tilematrixset : string
            Optional name of tile matrix set to use.
            Defaults to the first tile matrix set defined for the
            relevant layer in the GetCapabilities response.
        tilematrix : string
            Name of the tile matrix to use.
        row : integer
            Row index of tile to request.
        column : integer
            Column index of tile to request.
        **kwargs : extra arguments
            anything else e.g. vendor specific parameters

        Example
        -------
            >>> url = 'http://map1c.vis.earthdata.nasa.gov/wmts-geo/wmts.cgi'
            >>> wmts = WebMapTileService(url)
            >>> wmts.buildTileRequest(layer='VIIRS_CityLights_2012',
            ...                       tilematrixset='EPSG4326_500m',
            ...                       tilematrix='6',
            ...                       row=4, column=4)
            'SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&\
LAYER=VIIRS_CityLights_2012&STYLE=default&TILEMATRIXSET=EPSG4326_500m&\
TILEMATRIX=6&TILEROW=4&TILECOL=4&FORMAT=image%2Fjpeg'

        """
        request = {'version': self.version, 'request': 'GetTile'}

        if (layer is None):
            raise ValueError("layer is mandatory (cannot be None)")
        if style is None:
            style = self[layer].styles.keys()[0]
        if format is None:
            format = self[layer].formats[0]
        if tilematrixset is None:
            tilematrixset = sorted(self[layer].tilematrixsetlinks.keys())[0]
        if tilematrix is None:
            msg = 'tilematrix (zoom level) is mandatory (cannot be None)'
            raise ValueError(msg)
        if row is None:
                raise ValueError("row is mandatory (cannot be None)")
        if column is None:
                raise ValueError("column is mandatory (cannot be None)")

        request = list()
        request.append(('SERVICE', 'WMTS'))
        request.append(('REQUEST', 'GetTile'))
        request.append(('VERSION', '1.0.0'))
        request.append(('LAYER', layer))
        request.append(('STYLE', style))
        request.append(('TILEMATRIXSET', tilematrixset))
        request.append(('TILEMATRIX', tilematrix))
        request.append(('TILEROW', str(row)))
        request.append(('TILECOL', str(column)))
        request.append(('FORMAT', format))

        for key, value in kwargs.iteritems():
            request.append(key, value)

        data = urlencode(request, True)
        return data

    def gettile(self, base_url=None, layer=None, style=None, format=None, tilematrixset=None, tilematrix=None, row=None, column=None, **kwargs):
        """Return a tile from the WMTS.

        Returns the tile image as a file-like object.

        Parameters
        ----------
        base_url : string
            Optional URL for request submission. Defaults to the URL of
            the GetTile operation as declared in the GetCapabilities
            response.
        layer : string
            Content layer name.
        style : string
            Optional style name. Defaults to the first style defined for
            the relevant layer in the GetCapabilities response.
        format : string
            Optional output image format,  such as 'image/jpeg'.
            Defaults to the first format defined for the relevant layer
            in the GetCapabilities response.
        tilematrixset : string
            Optional name of tile matrix set to use.
            Defaults to the first tile matrix set defined for the
            relevant layer in the GetCapabilities response.
        tilematrix : string
            Name of the tile matrix to use.
        row : integer
            Row index of tile to request.
        column : integer
            Column index of tile to request.
        **kwargs : extra arguments
            anything else e.g. vendor specific parameters

        Example
        -------
            >>> url = 'http://map1c.vis.earthdata.nasa.gov/wmts-geo/wmts.cgi'
            >>> wmts = WebMapTileService(url)
            >>> img = wmts.gettile(layer='VIIRS_CityLights_2012',\
                                   tilematrixset='EPSG4326_500m',\
                                   tilematrix='6',\
                                   row=4, column=4)
            >>> out = open('tile.jpg', 'wb')
            >>> out.write(img.read())
            >>> out.close()

        """
        data = self.buildTileRequest(layer, style, format, tilematrixset, tilematrix, row, column, **kwargs)

        if base_url is None:
            base_url = self.url
            try:
                get_verbs = filter(lambda x: x.get('type').lower() == 'get', self.getOperationByName('GetTile').methods)
                if len(get_verbs) > 1:
                    # Filter by constraints
                    base_url = next(x for x in filter(list, ([pv.get('url') for const in pv.get('constraints') if 'kvp' in map(lambda x: x.lower(), const.values)] for pv in get_verbs if pv.get('constraints'))))[0]
                elif len(get_verbs) == 1:
                    base_url = get_verbs[0].get('url')
            except StopIteration:
                pass
        u = openURL(base_url, data, username=self.username,
                    password=self.password)

        # check for service exceptions, and return
        if u.info()['Content-Type'] == 'application/vnd.ogc.se_xml':
            se_xml = u.read()
            se_tree = etree.fromstring(se_xml)
            err_message = unicode(se_tree.find('ServiceException').text)
            raise ServiceException(err_message.strip(), se_xml)
        return u

    def getServiceXML(self):
        xml = None
        if self._capabilities is not None:
            xml = etree.tostring(self._capabilities)
        return xml

    def getfeatureinfo(self):
        raise NotImplementedError

    def getOperationByName(self, name):
        """Return a named content item."""
        for item in self.operations:
            if item.name == name:
                return item
        raise KeyError, "No operation named %s" % name

class TileMatrixSet(object):
    '''Holds one TileMatrixSet'''
    def __init__(self, elem):
        if elem.tag != '{http://www.opengis.net/wmts/1.0}TileMatrixSet':
            raise ValueError('%s should be a TileMatrixSet' % (elem,))
        self.identifier = testXMLValue(elem.find('{http://www.opengis.net/ows/1.1}Identifier')).strip()
        self.crs = testXMLValue(elem.find('{http://www.opengis.net/ows/1.1}SupportedCRS')).strip()
        if (self.crs == None) or (self.identifier == None):
            raise ValueError('%s incomplete TileMatrixSet' % (elem,))
        self.tilematrix = {}
        for tilematrix in elem.findall('{http://www.opengis.net/wmts/1.0}TileMatrix'):
            tm = TileMatrix(tilematrix)
            if tm.identifier:
                if tm.identifier in self.tilematrix:
                    raise KeyError('TileMatrix with identifier "%s" already exists' % tm.identifier)
                self.tilematrix[tm.identifier] = tm

class TileMatrix(object):
    '''Holds one TileMatrix'''
    def __init__(self, elem):
        if elem.tag != '{http://www.opengis.net/wmts/1.0}TileMatrix':
            raise ValueError('%s should be a TileMatrix' % (elem,))
        self.identifier = testXMLValue(elem.find('{http://www.opengis.net/ows/1.1}Identifier')).strip()
        sd = testXMLValue(elem.find('{http://www.opengis.net/wmts/1.0}ScaleDenominator'))
        if sd is None:
            raise ValueError('%s is missing ScaleDenominator' % (elem,))
        self.scaledenominator = float(sd)
        tl = testXMLValue(elem.find('{http://www.opengis.net/wmts/1.0}TopLeftCorner'))
        if tl is None:
            raise ValueError('%s is missing TopLeftCorner' % (elem,))
        (lon, lat) = tl.split(" ")
        self.topleftcorner = (float(lon), float(lat))
        width = testXMLValue(elem.find('{http://www.opengis.net/wmts/1.0}TileWidth'))
        height = testXMLValue(elem.find('{http://www.opengis.net/wmts/1.0}TileHeight'))
        if (width is None) or (height is None):
            raise ValueError('%s is missing TileWidth and/or TileHeight' % (elem,))
        self.tilewidth = int(width)
        self.tileheight = int(height)
        mw = testXMLValue(elem.find('{http://www.opengis.net/wmts/1.0}MatrixWidth'))
        mh = testXMLValue(elem.find('{http://www.opengis.net/wmts/1.0}MatrixHeight'))
        if (mw is None) or (mh is None):
            raise ValueError('%s is missing MatrixWidth and/or MatrixHeight' % (elem,))
        self.matrixwidth = int(mw)
        self.matrixheight = int(mh)

class Theme:
    """
    Abstraction for a WMTS theme
    """
    def __init__(self, elem):
        if elem.tag != '{http://www.opengis.net/wmts/1.0}Theme':
            raise ValueError('%s should be a Theme' % (elem,))
        self.identifier = testXMLValue(elem.find('{http://www.opengis.net/ows/1.1}Identifier')).strip()
        title = testXMLValue(elem.find('{http://www.opengis.net/ows/1.1}Title'))
        if title is not None:
            self.title = title.strip()
        else:
            self.title = None
        abstract = testXMLValue(elem.find('{http://www.opengis.net/ows/1.1}Abstract'))
        if abstract is not None:
            self.abstract = abstract.strip()
        else:
            self.abstract = None

        self.layerRefs = []
        layerRefs = elem.findall('{http://www.opengis.net/wmts/1.0}LayerRef')
        for layerRef in layerRefs:
            if layerRef.text is not None:
                self.layerRefs.append(layerRef.text)


class TileMatrixLimits(object):
    """
    Represents a WMTS TileMatrixLimits element.

    """
    def __init__(self, elem):
        if elem.tag != _TILE_MATRIX_LIMITS_TAG:
            raise ValueError('%s should be a TileMatrixLimits' % elem)

        tm = elem.find(_TILE_MATRIX_TAG)
        if tm is None:
            raise ValueError('Missing TileMatrix in %s' % elem)
        self.tilematrix = tm.text.strip()

        self.mintilerow = getXMLInteger(elem, _MIN_TILE_ROW_TAG)
        self.maxtilerow = getXMLInteger(elem, _MAX_TILE_ROW_TAG)
        self.mintilecol = getXMLInteger(elem, _MIN_TILE_COL_TAG)
        self.maxtilecol = getXMLInteger(elem, _MAX_TILE_COL_TAG)

    def __repr__(self):
        fmt = ('<TileMatrixLimits: {self.tilematrix}'
               ', minRow={self.mintilerow}, maxRow={self.maxtilerow}'
               ', minCol={self.mintilecol}, maxCol={self.maxtilecol}>')
        return fmt.format(self=self)


class TileMatrixSetLink(object):
    """
    Represents a WMTS TileMatrixSetLink element.

    """
    @staticmethod
    def from_elements(link_elements):
        """
        Return a list of TileMatrixSetLink instances derived from the
        given list of <TileMatrixSetLink> XML elements.

        """
        # NB. The WMTS spec is contradictory re. the multiplicity
        # relationships between Layer and TileMatrixSetLink, and
        # TileMatrixSetLink and tileMatrixSet (URI).
        # Try to figure out which model has been used by the server.
        links = []
        for link_element in link_elements:
            matrix_set_elements = link_element.findall(_TILE_MATRIX_SET_TAG)
            if len(matrix_set_elements) == 0:
                raise ValueError('Missing TileMatrixSet in %s' % link_element)
            elif len(matrix_set_elements) > 1:
                set_limits_elements = link_element.findall(
                    _TILE_MATRIX_SET_LIMITS_TAG)
                if set_limits_elements:
                   raise ValueError('Multiple instances of TileMatrixSet'
                                    ' plus TileMatrixSetLimits in %s' %
                                    link_element)
                for matrix_set_element in matrix_set_elements:
                    uri = matrix_set_element.text.strip()
                    links.append(TileMatrixSetLink(uri))
            else:
                uri = matrix_set_elements[0].text.strip()

                tilematrixlimits = {}
                path = '%s/%s' % (_TILE_MATRIX_SET_LIMITS_TAG, _TILE_MATRIX_LIMITS_TAG)
                for limits_element in link_element.findall(path):
                    tml = TileMatrixLimits(limits_element)
                    if tml.tilematrix:
                        if tml.tilematrix in tilematrixlimits:
                            raise KeyError('TileMatrixLimits with tileMatrix "%s" already exists' % tml.tilematrix)
                        tilematrixlimits[tml.tilematrix] = tml

                links.append(TileMatrixSetLink(uri, tilematrixlimits))
        return links

    def __init__(self, tilematrixset, tilematrixlimits=None):
        self.tilematrixset = tilematrixset

        if tilematrixlimits is None:
            self.tilematrixlimits = {}
        else:
            self.tilematrixlimits = tilematrixlimits

    def __repr__(self):
        fmt = ('<TileMatrixSetLink: {self.tilematrixset}'
               ', tilematrixlimits={{...}}>')
        return fmt.format(self=self)


class ContentMetadata:
    """
    Abstraction for WMTS layer metadata.

    Implements IContentMetadata.
    """
    def __init__(self, elem, parent=None, index=0, parse_remote_metadata=False):
        if elem.tag != '{http://www.opengis.net/wmts/1.0}Layer':
            raise ValueError('%s should be a Layer' % (elem,))

        self.parent = parent
        if parent:
            self.index = "%s.%d" % (parent.index, index)
        else:
            self.index = str(index)

        self.id = self.name = testXMLValue(elem.find('{http://www.opengis.net/ows/1.1}Identifier'))
        # title is mandatory property
        self.title = None
        title = testXMLValue(elem.find('{http://www.opengis.net/ows/1.1}Title'))
        if title is not None:
            self.title = title.strip()

        self.abstract = testXMLValue(elem.find('{http://www.opengis.net/ows/1.1}Abstract'))

        # bboxes
        b = elem.find('{http://www.opengis.net/ows/1.1}WGS84BoundingBox')
        self.boundingBox = None
        if b is not None:
            lc = b.find("{http://www.opengis.net/ows/1.1}LowerCorner")
            uc = b.find("{http://www.opengis.net/ows/1.1}UpperCorner")
            ll = [float(s) for s in lc.text.split()]
            ur = [float(s) for s in uc.text.split()]
            self.boundingBoxWGS84 = (ll[0],ll[1],ur[0],ur[1])
        # TODO: there is probably some more logic here, and it should probably be shared code

        self._tilematrixsets = [f.text.strip() for f in
                                elem.findall(_TILE_MATRIX_SET_LINK_TAG + '/' +
                                             _TILE_MATRIX_SET_TAG)]

        link_elements = elem.findall(_TILE_MATRIX_SET_LINK_TAG)
        tile_matrix_set_links = TileMatrixSetLink.from_elements(link_elements)
        self.tilematrixsetlinks = {}
        for tmsl in tile_matrix_set_links:
            if tmsl.tilematrixset:
                if tmsl.tilematrixset in self.tilematrixsetlinks:
                    raise KeyError('TileMatrixSetLink with tilematrixset "%s"'
                                   ' already exists' %
                                   tmsl.tilematrixset)
                self.tilematrixsetlinks[tmsl.tilematrixset] = tmsl

        self.resourceURLs = []
        for resourceURL in elem.findall('{http://www.opengis.net/wmts/1.0}ResourceURL'):
            resource = {}
            for attrib in ['format', 'resourceType', 'template']:
                resource[attrib] = resourceURL.attrib[attrib]
            self.resourceURLs.append(resource)

        #Styles
        self.styles = {}
        for s in elem.findall('{http://www.opengis.net/wmts/1.0}Style'):
            style = {}
            isdefaulttext = s.attrib.get('isDefault')
            style['isDefault'] = (isdefaulttext == "true")
            identifier = s.find('{http://www.opengis.net/ows/1.1}Identifier')
            if identifier is None:
                raise ValueError('%s missing identifier' % (s,))
            title = s.find('{http://www.opengis.net/ows/1.1}Title')
            if title is not None:
                style['title'] = title.text
            self.styles[identifier.text] = style

        self.formats = [f.text for f in elem.findall('{http://www.opengis.net/wmts/1.0}Format')]

        self.infoformats = [f.text for f in elem.findall('{http://www.opengis.net/wmts/1.0}InfoFormat')]

        self.layers = []
        for child in elem.findall('{http://www.opengis.net/wmts/1.0}Layer'):
            self.layers.append(ContentMetadata(child, self))

    @property
    def tilematrixsets(self):
        # NB. This attribute has been superseeded by the
        # `tilematrixsetlinks` attribute defined below, but is included
        # for now to provide continuity.
        warnings.warn("The 'tilematrixsets' attribute has been deprecated"
                      " and will be removed in a future version of OWSLib."
                      " Please use 'tilematrixsetlinks' instead.")
        return self._tilematrixsets

    def __str__(self):
        return 'Layer Name: %s Title: %s' % (self.name, self.title)


class WMTSCapabilitiesReader:
    """Read and parse capabilities document into a lxml.etree infoset
    """

    def __init__(self, version='1.0.0', url=None, un=None, pw=None):
        """Initialize"""
        self.version = version
        self._infoset = None
        self.url = url
        self.username = un
        self.password = pw

    def capabilities_url(self, service_url):
        """Return a capabilities url
        """
        qs = []
        if service_url.find('?') != -1:
            qs = urlparse.parse_qsl(service_url.split('?')[1])

        params = [x[0] for x in qs]

        if 'service' not in params:
            qs.append(('service', 'WMTS'))
        if 'request' not in params:
            qs.append(('request', 'GetCapabilities'))
        if 'version' not in params:
            qs.append(('version', self.version))

        urlqs = urlencode(tuple(qs))
        return service_url.split('?')[0] + '?' + urlqs

    def read(self, service_url):
        """Get and parse a WMTS capabilities document, returning an
        elementtree instance

        service_url is the base url, to which is appended the service,
        version, and request parameters
        """
        getcaprequest = self.capabilities_url(service_url)

        #now split it up again to use the generic openURL function...
        spliturl=getcaprequest.split('?')
        u = openURL(spliturl[0], spliturl[1], method='Get', username = self.username, password = self.password)
        return etree.fromstring(u.read())

    def readString(self, st):
        """Parse a WMTS capabilities document, returning an elementtree instance

        string should be an XML capabilities document
        """
        if not isinstance(st, str):
            raise ValueError("String must be of type string, not %s" % type(st))
        return etree.fromstring(st)

########NEW FILE########
__FILENAME__ = wps
############################################
#
# Author: Luca Cinquini
#
############################################

"""

Abstract
--------
The wps module of the OWSlib package provides client-side functionality for executing invocations to a remote Web Processing Server.


Disclaimer
----------
PLEASE NOTE: the owslib wps module should be considered in beta state: it has been tested versus only a handful of WPS services (deployed by the USGS, BADC and PML).
More extensive testing is needed and feedback is appreciated.


Usage
-----

The module can be used to execute three types of requests versus a remote WPS endpoint: 

a) "GetCapabilities" 
    - use the method wps.getcapabilities(xml=None)
    - the optional keyword argument "xml" may be used to avoid a real live request, and instead read the WPS capabilities document from a cached XML file
    
b) "DescribeProcess"
    - use the method wps.describeprocess(identifier, xml=None)
    - identifier is the process identifier, retrieved from the list obtained from a previous "GetCapabilities" invocation
    - the optional keyword argument "xml" may be used to avoid a real live request, and instead read the WPS process description document from a cached XML file
    
c) "Execute"
    - use the method wps.execute(identifier, inputs, output=None, request=None, response=None), 
      which submits the job to the remote WPS server and returns a WPSExecution object that can be used to periodically check the job status until completion 
      (or error)
    
    - the optional keyword argument "request" may be used to avoid re-building the request XML from input arguments, and instead submit a request from a 
      pre-made XML file
    
    - alternatively, an "Execute" request can be built from input arguments by supplying the "identifier", "inputs" and "output" arguments to the execute() method.
        - "identifier" is the mandatory process identifier
        - "inputs" is a dictionary of (key,value) pairs where:
            - key is a named input parameter
            - value is either a string, or any python object that supports a getXml() method
              In particular, a few classes are included in the package to support a FeatuteCollection input:
                  - "WFSFeatureCollection" can be used in conjunction with "WFSQuery" to define a FEATURE_COLLECTION retrieved from a live WFS server.
                  - "GMLMultiPolygonFeatureCollection" can be used to define one or more polygons of (latitude, longitude) points.
          - "output" is an optional output identifier to be included in the ResponseForm section of the request.
          
    - the optional keyword argument "response" mey be used to avoid submitting a real live request, and instead reading the WPS execution response document
      from a cached XML file (for debugging or testing purposes)
    - the convenience module function monitorExecution() can be used to periodically check the status of a remote running job, and eventually download the output
      either to a named file, or to a file specified by the server.
      
      
Examples
--------

The files examples/wps-usgs-script.py, examples/wps-pml-script-1.py and examples/wps-pml-script-2.py contain real-world usage examples 
that submits a "GetCapabilities", "DescribeProcess" and "Execute" requests to the live USGS and PML servers. To run: 
    cd examples
    python wps-usgs-script.py
    python wps-pml-script-1.py
    python wps-pml-script-2.py
    
The file wps-client.py contains a command-line client that can be used to submit a "GetCapabilities", "DescribeProcess" or "Execute"
request to an arbitratry WPS server. For example, you can run it as follows:
    cd examples
    To prints out usage and example invocations: wps-client -help
    To execute a (fake) WPS invocation: 
        wps-client.py -v -u http://cida.usgs.gov/climate/gdp/process/WebProcessingService -r GetCapabilities -x ../tests/USGSCapabilities.xml
    
The directory tests/ includes several doctest-style files wps_*.txt that show how to interactively submit a 
"GetCapabilities", "DescribeProcess" or "Execute" request, without making a live request but rather parsing the response of cached XML response documents. To run:
    cd tests
    python -m doctest wps_*.txt
    (or python -m doctest -v wps_*.txt for verbose output)

Also, the directory tests/ contains several examples of well-formed "Execute" requests:
    - The files wps_USGSExecuteRequest*.xml contain requests that can be submitted to the live USGS WPS service.
    - The files PMLExecuteRequest*.xml contain requests that can be submitted to the live PML WPS service.

"""

from owslib.etree import etree
from owslib.ows import DEFAULT_OWS_NAMESPACE, ServiceIdentification, ServiceProvider, OperationsMetadata
from time import sleep
from owslib.util import (testXMLValue, build_get_url, dump, getTypedValue, 
                  getNamespace, element_to_string, nspath, openURL, nspath_eval)
from xml.dom.minidom import parseString
from owslib.namespaces import Namespaces

# namespace definition
n = Namespaces()

# These static namespaces are DEPRECIATED.  Please don't use them.
# No great way of printing a message since there are at the file level
WPS_DEFAULT_NAMESPACE = n.get_namespace("wps")
WFS_NAMESPACE = n.get_namespace("wfs")
OGC_NAMESPACE = n.get_namespace("ogc")
GML_NAMESPACE = n.get_namespace("gml")
DRAW_NAMESPACE = n.get_namespace("draw")

GML_SCHEMA_LOCATION = "http://schemas.opengis.net/gml/3.1.1/base/feature.xsd"
DRAW_SCHEMA_LOCATION = 'http://cida.usgs.gov/climate/derivative/xsd/draw.xsd'
WPS_DEFAULT_SCHEMA_LOCATION = 'http://schemas.opengis.net/wps/1.0.0/wpsExecute_request.xsd'
WPS_DEFAULT_VERSION = '1.0.0'

def get_namespaces():
    ns = n.get_namespaces(["ogc","wfs","wps","gml","xsi","xlink"])
    ns[None]  = n.get_namespace("wps")
    ns["ows"] = DEFAULT_OWS_NAMESPACE
    return ns
namespaces = get_namespaces()

class IWebProcessingService():
    """
    Abstract interface for an OGC Web Processing Service (WPS).
    """
    
    url = property("""URL for the remote WPS server (string).""")
    
    def getcapabilities(**kw):
        """
        Makes a GetCapabilities request to the remote WPS server,
        returns an XML document wrapped in a python file-like object.
        """
    
    def describeprocess(**kw):
        """
        Makes a DescribeProcess request to the remote WPS server,
        returns a Process object containing all the process metadata.
        """
        
    def execute(**kw):
        """
        Submits an Execute request to the remote WPS server,
        returns a WPSExecution object, which can be used to monitor the status of the job, and ultimately retrieve the result.
        """

class IComplexData():
    """
    Abstract interface representing complex input object for a WPS request.
    """
    
    def getXml(self):
        """
        Method that returns the object data as an XML snippet, 
        to be inserted into the WPS request document sent to the server.
        """ 
    
class WebProcessingService(object):
    """
    Class that contains client-side functionality for invoking an OGC Web Processing Service (WPS).
    
    Implements IWebProcessingService.
    """
    
    def __init__(self, url, version=WPS_DEFAULT_VERSION, username=None, password=None, verbose=False, skip_caps=False):
        """
        Initialization method resets the object status.
        By default it will execute a GetCapabilities invocation to the remote service, 
        which can be skipped by using skip_caps=True.
        """
        
        # fields passed in from object initializer
        self.url = url
        self.username = username
        self.password = password
        self.version = version
        self.verbose = verbose
                
        # fields populated by method invocations
        self._capabilities = None
        self.identification = None
        self.provider = None
        self.operations=[]
        self.processes=[]

        if not skip_caps:
            self.getcapabilities()
        
    def getcapabilities(self, xml=None):
        """
        Method that requests a capabilities document from the remote WPS server and populates this object's metadata.
        keyword argument xml: local XML GetCapabilities document, prevents actual HTTP invocation.
        """
        
        # read capabilities document
        reader = WPSCapabilitiesReader(version=self.version, verbose=self.verbose)
        if xml:
            # read from stored XML file
            self._capabilities = reader.readFromString(xml)
        else:
            self._capabilities = reader.readFromUrl(self.url, username=self.username, password=self.password)
            
        if self.verbose==True:
            print element_to_string(self._capabilities)

        # populate the capabilities metadata obects from the XML tree
        self._parseCapabilitiesMetadata(self._capabilities)
        
    def describeprocess(self, identifier, xml=None):
        """
        Requests a process document from a WPS service and populates the process metadata.
        Returns the process object.
        """
        
        # read capabilities document
        reader = WPSDescribeProcessReader(version=self.version, verbose=self.verbose)
        if xml:
            # read from stored XML file
            rootElement = reader.readFromString(xml)
        else:
            # read from server
            rootElement = reader.readFromUrl(self.url, identifier)
            
        if self.verbose==True:
            print element_to_string(rootElement)

        # build metadata objects
        return self._parseProcessMetadata(rootElement)
        
    def execute(self, identifier, inputs, output=None, request=None, response=None):
        """
        Submits a WPS process execution request. 
        Returns a WPSExecution object, which can be used to monitor the status of the job, and ultimately retrieve the result.
        
        identifier: the requested process identifier
        inputs: list of process inputs as (key, value) tuples (where value is either a string for LiteralData, or an object for ComplexData)
        output: optional identifier for process output reference (if not provided, output will be embedded in the response)
        request: optional pre-built XML request document, prevents building of request from other arguments
        response: optional pre-built XML response document, prevents submission of request to live WPS server
        """
        
        # instantiate a WPSExecution object
        print 'Executing WPS request...'
        execution = WPSExecution(version=self.version, url=self.url, username=self.username, password=self.password, verbose=self.verbose)

        # build XML request from parameters 
        if request is None:
           requestElement = execution.buildRequest(identifier, inputs, output)
           request = etree.tostring( requestElement )   
        if self.verbose==True:
               print request
        
        # submit the request to the live server
        if response is None:   
            response = execution.submitRequest(request)
        else:
            response = etree.fromstring(response)
            
        if self.verbose==True:
            print etree.tostring(response)
            
        # parse response
        execution.parseResponse(response)
                        
        return execution
    
        
    def _parseProcessMetadata(self, rootElement):
        """
        Method to parse a <ProcessDescriptions> XML element and returned the constructed Process object
        """
        
        processDescriptionElement = rootElement.find( 'ProcessDescription' )
        process = Process(processDescriptionElement, verbose=self.verbose)
    
        # override existing processes in object metadata, if existing already
        found = False
        for n, p in enumerate(self.processes):
            if p.identifier==process.identifier:
                self.processes[n]=process
                found = True
        # otherwise add it
        if not found:
            self.processes.append(process)
            
        return process
                
        
    def _parseCapabilitiesMetadata(self, root):         
        ''' Sets up capabilities metadata objects '''
        
        # use the WPS namespace defined in the document root
        wpsns = getNamespace(root)
        
        # loop over children WITHOUT requiring a specific namespace
        for element in root:
            
            # thie element's namespace
            ns = getNamespace(element)
            
            # <ows:ServiceIdentification> metadata
            if element.tag.endswith('ServiceIdentification'):
                self.identification=ServiceIdentification(element, namespace=ns)
                if self.verbose==True:
                    dump(self.identification)
                    
            # <ows:ServiceProvider> metadata
            elif element.tag.endswith('ServiceProvider'):
                self.provider=ServiceProvider(element, namespace=ns)  
                if self.verbose==True:
                    dump(self.provider)
                    
            # <ns0:OperationsMetadata xmlns:ns0="http://www.opengeospatial.net/ows">
            #   <ns0:Operation name="GetCapabilities">
            #     <ns0:DCP>
            #       <ns0:HTTP>
            #         <ns0:Get xlink:href="http://ceda-wps2.badc.rl.ac.uk/wps?" xmlns:xlink="http://www.w3.org/1999/xlink" />
            #       </ns0:HTTP>
            #    </ns0:DCP>
            #  </ns0:Operation>
            #  ........
            # </ns0:OperationsMetadata>
            elif element.tag.endswith('OperationsMetadata'):
                for child in element.findall( nspath('Operation', ns=ns) ):
                    self.operations.append( OperationsMetadata(child, namespace=ns) )
                    if self.verbose==True:
                        dump(self.operations[-1])
               
            # <wps:ProcessOfferings>
            #   <wps:Process ns0:processVersion="1.0.0">
            #     <ows:Identifier xmlns:ows="http://www.opengis.net/ows/1.1">gov.usgs.cida.gdp.wps.algorithm.filemanagement.ReceiveFiles</ows:Identifier>
            #     <ows:Title xmlns:ows="http://www.opengis.net/ows/1.1">gov.usgs.cida.gdp.wps.algorithm.filemanagement.ReceiveFiles</ows:Title>
            #   </wps:Process>
            #   ......
            # </wps:ProcessOfferings>
            elif element.tag.endswith('ProcessOfferings'):
                for child in element.findall( nspath('Process', ns=ns) ):
                    p = Process(child, verbose=self.verbose)
                    self.processes.append(p)
                    if self.verbose==True:
                        dump(self.processes[-1])

                   
        
class WPSReader(object):
    """
    Superclass for reading a WPS document into a lxml.etree infoset.
    """

    def __init__(self, version=WPS_DEFAULT_VERSION, verbose=False):        
        self.version = version
        self.verbose = verbose
                
    def _readFromUrl(self, url, data, method='Get', username=None, password=None):
        """
        Method to get and parse a WPS document, returning an elementtree instance.
        url: WPS service base url.
        data: GET: dictionary of HTTP (key, value) parameter pairs, POST: XML document to post
        username, password: optional user credentials
        """
        
        if method == 'Get':
            # full HTTP request url
            request_url = build_get_url(url, data)
            if self.verbose==True:
                print request_url
    
            # split URL into base url and query string to use utility function
            spliturl=request_url.split('?')
            u = openURL(spliturl[0], spliturl[1], method='Get', username=username, password=password)
            return etree.fromstring(u.read())
        
        elif method == 'Post':
            u = openURL(url, data, method='Post', username = username, password = password)
            return etree.fromstring(u.read())
            
        else:
            raise Exception("Unrecognized HTTP method: %s" % method)
                
        
    def readFromString(self, string):
        """
        Method to read a WPS GetCapabilities document from an XML string.
        """
        
        if not isinstance(string, str):
            raise ValueError("Input must be of type string, not %s" % type(string))
        return etree.fromstring(string)    

class WPSCapabilitiesReader(WPSReader):
    """
    Utility class that reads and parses a WPS GetCapabilities document into a lxml.etree infoset.
    """
    
    def __init__(self, version=WPS_DEFAULT_VERSION, verbose=False):
        # superclass initializer
        super(WPSCapabilitiesReader,self).__init__(version=version, verbose=verbose)
        
    def readFromUrl(self, url, username=None, password=None):
        """
        Method to get and parse a WPS capabilities document, returning an elementtree instance.
        url: WPS service base url, to which is appended the HTTP parameters: service, version, and request.
        username, password: optional user credentials
        """
        return self._readFromUrl(url, 
                                 {'service':'WPS', 'request':'GetCapabilities', 'version':self.version}, 
                                 username=username, password=password)
            
class WPSDescribeProcessReader(WPSReader):
    """
    Class that reads and parses a WPS DescribeProcess document into a etree infoset
    """

    def __init__(self, version=WPS_DEFAULT_VERSION, verbose=False):
        # superclass initializer
        super(WPSDescribeProcessReader,self).__init__(version=version, verbose=verbose)

                
    def readFromUrl(self, url, identifier, username=None, password=None):
        """
        Reads a WPS DescribeProcess document from a remote service and returns the XML etree object
        url: WPS service base url, to which is appended the HTTP parameters: 'service', 'version', and 'request', and 'identifier'.
        """
        
        return self._readFromUrl(url, 
                                 {'service':'WPS', 'request':'DescribeProcess', 'version':self.version, 'identifier':identifier}, 
                                 username=username, password=password)
        
class WPSExecuteReader(WPSReader):
    """
    Class that reads and parses a WPS Execute response document into a etree infoset
    """
    def __init__(self, verbose=False):
        # superclass initializer
        super(WPSExecuteReader,self).__init__(verbose=verbose)
        
    def readFromUrl(self, url, data={}, method='Get', username=None, password=None):
         """
         Reads a WPS status document from a remote service and returns the XML etree object.
         url: the URL to submit the GET/POST request to.
         """
         
         return self._readFromUrl(url, data, method, username=username, password=password)

    
class WPSExecution():
    """
    Class that represents a single WPS process executed on a remote WPS service.
    """
    
    def __init__(self, version=WPS_DEFAULT_VERSION, url=None, username=None, password=None, verbose=False):
        
        # initialize fields
        self.url = url
        self.version = version
        self.username = username
        self.password = password
        self.verbose = verbose
        
        # request document
        self.request = None
        
        # last response document
        self.response = None
        
        # status fields retrieved from the response documents
        self.process = None
        self.serviceInstance = None
        self.status = None
        self.percentCompleted = 0
        self.statusMessage = None
        self.errors = []
        self.statusLocation = None
        self.dataInputs=[]
        self.processOutputs=[]
        
        
    def buildRequest(self, identifier, inputs=[], output=None):
        """
        Method to build a WPS process request.
        identifier: the requested process identifier
        inputs: array of input arguments for the process.
            - LiteralData inputs are expressed as simple (key,value) tuples where key is the input identifier, value is the value
            - ComplexData inputs are express as (key, object) tuples, where key is the input identifier,
              and the object must contain a 'getXml()' method that returns an XML infoset to be included in the WPS request
        output: optional identifier if process output is to be returned as a hyperlink reference
        """
        
        #<wps:Execute xmlns:wps="http://www.opengis.net/wps/1.0.0" 
        #             xmlns:ows="http://www.opengis.net/ows/1.1" 
        #             xmlns:xlink="http://www.w3.org/1999/xlink" 
        #             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        #             service="WPS" 
        #             version="1.0.0" 
        #             xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsExecute_request.xsd">       
        root = etree.Element(nspath_eval('wps:Execute', namespaces))
        root.set('service', 'WPS')
        root.set('version', WPS_DEFAULT_VERSION)
        root.set(nspath_eval('xsi:schemaLocation', namespaces), '%s %s' % (namespaces['wps'], WPS_DEFAULT_SCHEMA_LOCATION) )
        
        # <ows:Identifier>gov.usgs.cida.gdp.wps.algorithm.FeatureWeightedGridStatisticsAlgorithm</ows:Identifier>
        identifierElement = etree.SubElement(root, nspath_eval('ows:Identifier', namespaces))
        identifierElement.text = identifier
        
        # <wps:DataInputs>
        dataInputsElement = etree.SubElement(root, nspath_eval('wps:DataInputs', namespaces))
        
        for (key,val) in inputs:

            inputElement = etree.SubElement(dataInputsElement, nspath_eval('wps:Input', namespaces))
            identifierElement = etree.SubElement(inputElement, nspath_eval('ows:Identifier', namespaces))
            identifierElement.text = key
            
            # Literal data
            # <wps:Input>
            #   <ows:Identifier>DATASET_URI</ows:Identifier>
            #   <wps:Data>
            #     <wps:LiteralData>dods://igsarm-cida-thredds1.er.usgs.gov:8080/thredds/dodsC/dcp/conus_grid.w_meta.ncml</wps:LiteralData>
            #   </wps:Data>
            # </wps:Input>
            if isinstance(val, str):
                dataElement = etree.SubElement(inputElement, nspath_eval('wps:Data', namespaces))
                literalDataElement = etree.SubElement(dataElement, nspath_eval('wps:LiteralData', namespaces))
                literalDataElement.text = val
                
            # Complex data
            # <wps:Input>
            #   <ows:Identifier>FEATURE_COLLECTION</ows:Identifier>
            #   <wps:Reference xlink:href="http://igsarm-cida-gdp2.er.usgs.gov:8082/geoserver/wfs">
            #      <wps:Body>
            #        <wfs:GetFeature xmlns:wfs="http://www.opengis.net/wfs" xmlns:ogc="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml" service="WFS" version="1.1.0" outputFormat="text/xml; subtype=gml/3.1.1" xsi:schemaLocation="http://www.opengis.net/wfs ../wfs/1.1.0/WFS.xsd">
            #            <wfs:Query typeName="sample:CONUS_States">
            #                <wfs:PropertyName>the_geom</wfs:PropertyName>
            #                <wfs:PropertyName>STATE</wfs:PropertyName>
            #                <ogc:Filter>
            #                    <ogc:GmlObjectId gml:id="CONUS_States.508"/>
            #                </ogc:Filter>
            #            </wfs:Query>
            #        </wfs:GetFeature>
            #      </wps:Body>
            #   </wps:Reference>
            # </wps:Input>
            else:
                inputElement.append( val.getXml() )
        
        # <wps:ResponseForm>
        #   <wps:ResponseDocument storeExecuteResponse="true" status="true">
        #     <wps:Output asReference="true">
        #       <ows:Identifier>OUTPUT</ows:Identifier>
        #     </wps:Output>
        #   </wps:ResponseDocument>
        # </wps:ResponseForm>
        if output is not None:
            responseFormElement = etree.SubElement(root, nspath_eval('wps:ResponseForm', namespaces))
            responseDocumentElement = etree.SubElement(responseFormElement, nspath_eval('wps:ResponseDocument', namespaces), 
                                                       attrib={'storeExecuteResponse':'true', 'status':'true'} )
            if isinstance(output, str):
                self._add_output(responseDocumentElement, output, asReference=True)
            elif isinstance(output, list):
                for (identifier,as_reference) in output:
                    self._add_output(responseDocumentElement, identifier, asReference=as_reference)
            else:
                raise Exception('output parameter is neither string nor list. output=%s' % output)
        return root

    def _add_output(self, element, identifier, asReference=False):
        outputElement = etree.SubElement(element, nspath_eval('wps:Output', namespaces), 
                                                       attrib={'asReference':str(asReference).lower()} )
        outputIdentifierElement = etree.SubElement(outputElement, nspath_eval('ows:Identifier', namespaces)).text = identifier
                  
                
    # wait for 60 seconds by default
    def checkStatus(self, url=None, response=None, sleepSecs=60):
        """
        Method to check the status of a job execution.
        In the process, this method will upadte the object 'response' attribute.
        
        url: optional 'statusLocation' URL retrieved from a previous WPS Execute response document.
             If not provided, the current 'statusLocation' URL will be used.
        sleepSecs: number of seconds to sleep before returning control to the caller.
        """
                    
        reader = WPSExecuteReader(verbose=self.verbose)
        if response is None:
            # override status location
            if url is not None:
                self.statusLocation = url
            print '\nChecking execution status... (location=%s)' % self.statusLocation
            response = reader.readFromUrl(self.statusLocation, username=self.username, password=self.password)
        else:
            response = reader.readFromString(response)
                
        # store latest response
        self.response = etree.tostring(response)
        if self.verbose==True:
            print self.response

        self.parseResponse(response)
                    
        # sleep given number of seconds
        if self.isComplete()==False:
            print 'Sleeping %d seconds...' % sleepSecs
            sleep(sleepSecs)

        
    def getStatus(self):
        return self.status
        
    def isComplete(self):
        if (self.status=='ProcessSucceeded' or self.status=='ProcessFailed' or self.status=='Exception'):
            return True
        elif (self.status=='ProcessStarted'):
            return False
        elif (self.status=='ProcessAccepted' or self.status=='ProcessPaused'):
            return False
        else:
            raise Exception('Unknown process execution status: %s' % self.status)
        
    def isSucceded(self):
         if self.status=='ProcessSucceeded':
             return True
         else:
             return False
        
    def isNotComplete(self):
        return not self.isComplete()
        
    def getOutput(self, filepath=None):
        """
        Method to write the outputs of a WPS process to a file: 
        either retrieves the referenced files from the server, or writes out the content of response embedded output.
        
        filepath: optional path to the output file, otherwise a file will be created in the local directory with the name assigned by the server, 
                  or default name 'wps.out' for embedded output.
        """
        
        if self.isSucceded():
            content = ''
            for output in self.processOutputs:
                
                output_content = output.retrieveData(self.username, self.password)
                
                # ExecuteResponse contains reference to server-side output
                if output_content is not "":
                    content = content + output_content
                    if filepath is None:
                        filepath = output.fileName
                    
                # ExecuteResponse contain embedded output   
                if len(output.data)>0:
                    if filepath is None:
                        filepath = 'wps.out'
                    for data in output.data:
                        content = content + data
                    
            # write out content
            if content is not '':
                out = open(filepath, 'wb')
                out.write(content)
                out.close()
                print 'Output written to file: %s' %filepath
            
        else:
            raise Exception("Execution not successfully completed: status=%s" % self.status)
    
    def submitRequest(self, request):
        """
        Submits a WPS Execute document to a remote service, returns the XML response document from the server.
        This method will save the request document and the first returned response document.
        
        request: the XML request document to be submitted as POST to the server.
        """ 
        
        self.request = request
        reader = WPSExecuteReader(verbose=self.verbose)
        response = reader.readFromUrl(self.url, request, method='Post', username=self.username, password=self.password)
        self.response = response
        return response
 
        '''       
        if response is None:
            # override status location
            if url is not None:
                self.statusLocation = url
            
        else:
            response = reader.readFromString(response)

        
        '''
    
    def parseResponse(self, response):
        """
        Method to parse a WPS response document
        """
    
        rootTag = response.tag.split('}')[1]
        # <ns0:ExecuteResponse>
        if rootTag == 'ExecuteResponse':
            self._parseExecuteResponse(response)
                    
        # <ows:ExceptionReport>
        elif rootTag == 'ExceptionReport':
            self._parseExceptionReport(response)
            
        else:
            print 'Unknown Response'
            
        # print status, errors
        print 'Execution status=%s' % self.status
        print 'Percent completed=%s' % self.percentCompleted
        print 'Status message=%s' % self.statusMessage
        for error in self.errors:
            dump(error)

            
    def _parseExceptionReport(self, root):
        """
        Method to parse a WPS ExceptionReport document and populate this object's metadata.
        """
        # set exception status, unless set already
        if self.status is None:
            self.status = "Exception"
            
        for exceptionEl in root.findall( nspath('Exception', ns=namespaces['ows']) ):
            self.errors.append( WPSException(exceptionEl) )


    def _parseExecuteResponse(self, root):      
        """
        Method to parse a WPS ExecuteResponse response document and populate this object's metadata.
        """
        
        # retrieve WPS namespace directly from root element
        wpsns = getNamespace(root)

        self.serviceInstance = root.get( 'serviceInstance' )
        self.statusLocation = root.get( 'statusLocation' )
        
        # <ns0:Status creationTime="2011-11-09T14:19:50Z">
        #  <ns0:ProcessSucceeded>PyWPS Process v.net.path successfully calculated</ns0:ProcessSucceeded>
        # </ns0:Status>
        # OR
        # <ns0:Status creationTime="2011-11-07T08:26:44.359-06:00">
        #  <ns0:ProcessFailed>
        #   <ows:ExceptionReport xmlns:ows="http://www.opengis.net/ows/1.1">
        #    <ows:Exception>
        #     <ows:ExceptionText>Attribute null not found in feature collection</ows:ExceptionText>
        #    </ows:Exception>
        #   </ows:ExceptionReport>
        #  </ns0:ProcessFailed>
        # </ns0:Status>
        statusEl = root.find( nspath('Status/*', ns=wpsns) )
        self.status = statusEl.tag.split('}')[1]
        # get progress info
        try:
            percentCompleted = int(statusEl.get('percentCompleted'))
            self.percentCompleted = percentCompleted
        except:
            pass
        # get status message
        self.statusMessage = statusEl.text
        # exceptions ?
        for element in statusEl:
            if element.tag.endswith('ExceptionReport'):
                self._parseExceptionReport(element)

        self.process = Process(root.find(nspath('Process', ns=wpsns)), verbose=self.verbose)
        
        #<wps:DataInputs xmlns:wps="http://www.opengis.net/wps/1.0.0"
        #                xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:xlink="http://www.w3.org/1999/xlink">
        for inputElement in root.findall( nspath('DataInputs/Input', ns=wpsns) ):
            self.dataInputs.append( Input(inputElement) )
            if self.verbose==True:
                dump(self.dataInputs[-1])
        
        # <ns:ProcessOutputs>
        # xmlns:ns="http://www.opengis.net/wps/1.0.0" 
        for outputElement in root.findall( nspath('ProcessOutputs/Output', ns=wpsns)  ):
            self.processOutputs.append( Output(outputElement) )
            if self.verbose==True:
                dump(self.processOutputs[-1])
            
class ComplexData(object):
    """
    Class that represents a ComplexData element in a WPS document
    """
    
    def __init__(self, mimeType=None, encoding=None, schema=None):
        self.mimeType = mimeType
        self.encoding = encoding
        self.schema = schema

class InputOutput(object):
    """
    Superclass of a WPS input or output data object.
    """
    
    def __init__(self, element):
                
        # loop over sub-elements without requiring a specific namespace
        for subElement in element:
            
            # <ows:Identifier xmlns:ows="http://www.opengis.net/ows/1.1">SUMMARIZE_TIMESTEP</ows:Identifier>
            if subElement.tag.endswith('Identifier'):
                self.identifier = testXMLValue( subElement )

            # <ows:Title xmlns:ows="http://www.opengis.net/ows/1.1">Summarize Timestep</ows:Title>
            elif subElement.tag.endswith('Title'):
                self.title = testXMLValue( subElement )
        
            # <ows:Abstract xmlns:ows="http://www.opengis.net/ows/1.1">If selected, processing output will include columns with summarized statistics for all feature attribute values for each timestep</ows:Abstract>
            elif subElement.tag.endswith('Abstract'):
                self.abstract = testXMLValue( subElement )
                
        self.allowedValues = []
        self.supportedValues = []
        self.defaultValue = None
        self.dataType = None
        
    def _parseData(self, element):
        """
        Method to parse a "Data" element
        """
        
        # <ns0:Data>
        #        <ns0:ComplexData mimeType="text/plain">
        #             7504912.93758151 -764109.175074507,7750849.82379226 -22141.8611641468,8561828.42371234 -897195.923493867,7724946.16844165 -602984.014261927 
        #        </ns0:ComplexData>
        # </ns0:Data>
        #nspath('Data', ns=WPS_NAMESPACE)
        complexDataElement = element.find( nspath('ComplexData', ns=getNamespace(element)) )
        if complexDataElement is not None:
            self.dataType = "ComplexData"
        
    def _parseLiteralData(self, element, literalElementName):
        """
        Method to parse the LiteralData element.
        """
        
        # <LiteralData>
        #    <ows:DataType ows:reference="xs:string" xmlns:ows="http://www.opengis.net/ows/1.1" />
        #    <ows:AllowedValues xmlns:ows="http://www.opengis.net/ows/1.1">
        #        <ows:Value>COMMA</ows:Value>
        #        <ows:Value>TAB</ows:Value>
        #        <ows:Value>SPACE</ows:Value>
        #    </ows:AllowedValues>
        #    <DefaultValue>COMMA</DefaultValue>
        # </LiteralData>
        
        # <LiteralData>
        #     <ows:DataType ows:reference="xs:anyURI" xmlns:ows="http://www.opengis.net/ows/1.1" />
        #     <ows:AnyValue xmlns:ows="http://www.opengis.net/ows/1.1" />
        # </LiteralData>
        literalDataElement = element.find( literalElementName )
        if literalDataElement is not None:
            self.dataType = 'LiteralData'
            for subElement in literalDataElement:
                subns = getNamespace(subElement)
                if subElement.tag.endswith('DataType'):
                    self.dataType = subElement.get( nspath("reference", ns=subns) ).split(':')[1]
                elif subElement.tag.endswith('AllowedValues'):
                    for value in subElement.findall( nspath('Value', ns=subns) ):
                        self.allowedValues.append( getTypedValue(self.dataType, value.text) )
                elif subElement.tag.endswith('DefaultValue'):
                    self.defaultValue = getTypedValue(self.dataType, subElement.text)
                elif subElement.tag.endswith('AnyValue'):
                    self.allowedValues.append( getTypedValue(self.dataType, 'AnyValue') )
                    

    def _parseComplexData(self, element, complexDataElementName):
        """
        Method to parse a ComplexData or ComplexOutput element.
        """
        
        # <ComplexData>
        #     <Default>
        #         <Format>
        #            <MimeType>text/xml</MimeType>
        #            <Encoding>UTF-8</Encoding>
        #            <Schema>http://schemas.opengis.net/gml/2.0.0/feature.xsd</Schema>
        #        </Format>
        #    </Default>
        #    <Supported>
        #        <Format>
        #            <MimeType>text/xml</MimeType>
        #            <Encoding>UTF-8</Encoding>
        #            <Schema>http://schemas.opengis.net/gml/2.0.0/feature.xsd</Schema>
        #        </Format>
        #        <Format>
        #            <MimeType>text/xml</MimeType>
        #            <Encoding>UTF-8</Encoding>
        #            <Schema>http://schemas.opengis.net/gml/2.1.1/feature.xsd</Schema>
        #        </Format>
        #    </Supported>
        # </ComplexData>
        # OR
        # <ComplexOutput defaultEncoding="UTF-8" defaultFormat="text/XML" defaultSchema="NONE">
        #     <SupportedComplexData>
        #         <Format>text/XML</Format>
        #         <Encoding>UTF-8</Encoding>
        #         <Schema>NONE</Schema>
        #     </SupportedComplexData>
        # </ComplexOutput>
        
        complexDataElement = element.find( complexDataElementName )
        if complexDataElement is not None:
            self.dataType = "ComplexData"
            
            for supportedComlexDataElement in complexDataElement.findall( 'SupportedComplexData' ):
                self.supportedValues.append( ComplexData( mimeType=testXMLValue( supportedComlexDataElement.find( 'Format' ) ),
                                                          encoding=testXMLValue( supportedComlexDataElement.find( 'Encoding' ) ),
                                                          schema=testXMLValue( supportedComlexDataElement.find( 'Schema' ) ) 
                                                         ) 
                )
                
            for formatElement in complexDataElement.findall( 'Supported/Format'):
                self.supportedValues.append( ComplexData( mimeType=testXMLValue( formatElement.find( 'MimeType' ) ),
                                                          encoding=testXMLValue( formatElement.find( 'Encoding' ) ),
                                                          schema=testXMLValue( formatElement.find( 'Schema' ) ) 
                                                         ) 
                )
               
            defaultFormatElement = complexDataElement.find( 'Default/Format' ) 
            if defaultFormatElement is not None:
                self.defaultValue = ComplexData( mimeType=testXMLValue( defaultFormatElement.find( 'MimeType' ) ),
                                                 encoding=testXMLValue( defaultFormatElement.find( 'Encoding' ) ),
                                                 schema=testXMLValue( defaultFormatElement.find( 'Schema' ) ) 
                                               ) 


class Input(InputOutput):
    """
    Class that represents a WPS process input.
    """
    
    def __init__(self, inputElement):
        
        # superclass initializer
        super(Input,self).__init__(inputElement)
        
        # <Input maxOccurs="1" minOccurs="0">
        # OR
        # <MinimumOccurs>1</MinimumOccurs>
        self.minOccurs = -1
        if inputElement.get("minOccurs") is not None:
            self.minOccurs = int( inputElement.get("minOccurs") )
        if inputElement.find('MinimumOccurs') is not None:
            self.minOccurs = int( testXMLValue( inputElement.find('MinimumOccurs') ) )  
        self.maxOccurs = -1
        if inputElement.get("maxOccurs") is not None:
            self.maxOccurs = int( inputElement.get("maxOccurs") )
        if inputElement.find('MaximumOccurs') is not None:
            self.maxOccurs = int( testXMLValue( inputElement.find('MaximumOccurs') ) )       
        
        # <LiteralData>
        self._parseLiteralData(inputElement, 'LiteralData')
                
        # <ComplexData>
        self._parseComplexData(inputElement, 'ComplexData')
                
    
class Output(InputOutput):
    """
    Class that represents a WPS process output.
    """
    
    def __init__(self, outputElement):
    
        # superclass initializer
        super(Output,self).__init__(outputElement)
        
        self.reference = None
        self.mimeType = None
        self.data = []
        self.fileName = None
        self.filePath = None
        
        # extract wps namespace from outputElement itself
        wpsns = getNamespace(outputElement)
        
        # <ns:Reference encoding="UTF-8" mimeType="text/csv"
        #     href="http://cida.usgs.gov/climate/gdp/process/RetrieveResultServlet?id=1318528582026OUTPUT.601bb3d0-547f-4eab-8642-7c7d2834459e" />
        referenceElement = outputElement.find( nspath('Reference', ns=wpsns) )
        if referenceElement is not None:
            self.reference = referenceElement.get('href')
            self.mimeType = referenceElement.get('mimeType')
       
        # <LiteralOutput>
        self._parseLiteralData(outputElement, 'LiteralOutput')
        
        # <ComplexData> or <ComplexOutput>
        self._parseComplexData(outputElement, 'ComplexOutput')
        
        # <Data>   
        # <ns0:Data>
        #        <ns0:ComplexData mimeType="text/plain">
        #             7504912.93758151 -764109.175074507,7750849.82379226 -22141.8611641468,8561828.42371234 -897195.923493867,7724946.16844165 -602984.014261927 
        #        </ns0:ComplexData>
        # </ns0:Data>
        # OR:
        # <ns0:Data>
        #     <ns0:ComplexData encoding="UTF-8" mimeType="text/xml" schema="http://schemas.opengis.net/gml/2.1.2/feature.xsd">
        #         <ns3:FeatureCollection xsi:schemaLocation="http://ogr.maptools.org/ output_0n7ij9D.xsd" xmlns:ns3="http://ogr.maptools.org/">
        #             <gml:boundedBy xmlns:gml="http://www.opengis.net/gml">
        #                 <gml:Box>
        #                     <gml:coord><gml:X>-960123.1421801626</gml:X><gml:Y>4665723.56559387</gml:Y></gml:coord>
        #                     <gml:coord><gml:X>-101288.6510608822</gml:X><gml:Y>5108200.011823481</gml:Y></gml:coord>
        #                 </gml:Box>
        #            </gml:boundedBy>                         
        #            <gml:featureMember xmlns:gml="http://www.opengis.net/gml">
        #                <ns3:output fid="F0">
        #                    <ns3:geometryProperty><gml:LineString><gml:coordinates>-960123.142180162365548,4665723.565593870356679,0 -960123.142180162365548,4665723.565593870356679,0 -960123.142180162598379,4665723.565593870356679,0 -960123.142180162598379,4665723.565593870356679,0 -711230.141176006174646,4710278.48552671354264,0 -711230.141176006174646,4710278.48552671354264,0 -623656.677859728806652,4848552.374973464757204,0 -623656.677859728806652,4848552.374973464757204,0 -410100.337491964863148,4923834.82589447684586,0 -410100.337491964863148,4923834.82589447684586,0 -101288.651060882242746,5108200.011823480948806,0 -101288.651060882242746,5108200.011823480948806,0 -101288.651060882257298,5108200.011823480948806,0 -101288.651060882257298,5108200.011823480948806,0</gml:coordinates></gml:LineString></ns3:geometryProperty>
        #                    <ns3:cat>1</ns3:cat>
        #                    <ns3:id>1</ns3:id>
        #                    <ns3:fcat>0</ns3:fcat>
        #                    <ns3:tcat>0</ns3:tcat>
        #                    <ns3:sp>0</ns3:sp>
        #                    <ns3:cost>1002619.181</ns3:cost>
        #                    <ns3:fdist>0</ns3:fdist>
        #                    <ns3:tdist>0</ns3:tdist>
        #                </ns3:output>
        #            </gml:featureMember>
        #        </ns3:FeatureCollection>
        #     </ns0:ComplexData>
        # </ns0:Data>
        dataElement = outputElement.find( nspath('Data', ns=wpsns) )    
        if dataElement is not None:
            complexDataElement = dataElement.find( nspath('ComplexData', ns=wpsns) )
            if complexDataElement is not None:
                self.dataType = "ComplexData"
                self.mimeType = complexDataElement.get('mimeType')
                #print etree.tostring(complexDataElement)
                if complexDataElement.text is not None and complexDataElement.text.strip() is not '':
                    self.data.append(complexDataElement.text.strip())
                for child in complexDataElement:
                    self.data.append(etree.tostring(child))
            literalDataElement = dataElement.find( nspath('LiteralData', ns=wpsns) )
            if literalDataElement is not None:
                self.dataType = literalDataElement.get('dataType')
                if literalDataElement.text is not None and literalDataElement.text.strip() is not '':
                    self.data.append(literalDataElement.text.strip())
                    
    def retrieveData(self, username=None, password=None):
        """
        Method to retrieve data from server-side reference: 
        returns "" if the reference is not known.
        
        username, password: credentials to access the remote WPS server 
        """
        
        url = self.reference
        if url is None: 
            return ""
        
        # a) 'http://cida.usgs.gov/climate/gdp/process/RetrieveResultServlet?id=1318528582026OUTPUT.601bb3d0-547f-4eab-8642-7c7d2834459e'
        # b) 'http://rsg.pml.ac.uk/wps/wpsoutputs/outputImage-11294Bd6l2a.tif'
        print 'Output URL=%s' % url
        if '?' in url:
            spliturl=url.split('?')
            u = openURL(spliturl[0], spliturl[1], method='Get', username = username, password = password)
            # extract output filepath from URL query string
            self.fileName = spliturl[1].split('=')[1]
        else:
            u = openURL(url, '', method='Get', username = username, password = password)
            # extract output filepath from base URL
            self.fileName = url.split('/')[-1]
                
        return u.read()      

                    
    def writeToDisk(self, path=None, username=None, password=None):
        """
        Method to write an output of a WPS process to disk: 
        it either retrieves the referenced file from the server, or write out the content of response embedded output.
        
        filepath: optional path to the output file, otherwise a file will be created in the local directory with the name assigned by the server,
        username, password: credentials to access the remote WPS server
        """ 
        
        # Check if ExecuteResponse contains reference to server-side output    
        content = self.retrieveData(username, password)
         
        # ExecuteResponse contain embedded output   
        if content is "" and len(self.data)>0:
            self.fileName = self.identifier
            for data in self.data:
                content = content + data
                    
        # write out content
        if content is not "":
            if self.fileName == "":
                self.fileName = self.identifier
            self.filePath = path + self.fileName
            out = open(self.filePath, 'wb')
            out.write(content)
            out.close()
            print 'Output written to file: %s' %self.filePath
                
                    
class WPSException:
    """
    Class representing an exception raised by a WPS.
    """
    
    def __init__(self, root):
        self.code = root.attrib.get("exceptionCode", None)
        self.locator = root.attrib.get("locator", None)
        textEl = root.find( nspath('ExceptionText', ns=getNamespace(root)) )
        if textEl is not None:
            self.text = textEl.text
        else:
            self.text = ""

class Process(object):
    """
    Class that represents a WPS process.
    """
    
    def __init__(self, elem, verbose=False):
        """ Initialization method extracts all available metadata from an XML document (passed in as etree object) """
        
        # <ns0:ProcessDescriptions service="WPS" version="1.0.0" 
        #                          xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsDescribeProcess_response.xsd" 
        #                          xml:lang="en-US" xmlns:ns0="http://www.opengis.net/wps/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        # OR:
        # <ns0:Process ns0:processVersion="1.0.0">
        self._root = elem
        self.verbose = verbose
        
        wpsns = getNamespace(elem)
        
        # <ProcessDescription statusSupported="true" storeSupported="true" ns0:processVersion="1.0.0">
        self.processVersion = elem.get( nspath('processVersion', ns=wpsns) )
        self.statusSupported = bool( elem.get( "statusSupported" ) )
        self.storeSupported = bool( elem.get( "storeSupported" ) )
        
        for child in elem:
            
            # this element's namespace
            ns = getNamespace(child)
            
            # <ows:Identifier xmlns:ows="http://www.opengis.net/ows/1.1">gov.usgs.cida.gdp.wps.algorithm.FeatureWeightedGridStatisticsAlgorithm</ows:Identifier>
            if child.tag.endswith('Identifier'):
                self.identifier = testXMLValue( child )
        
            # <ows:Title xmlns:ows="http://www.opengis.net/ows/1.1">Feature Weighted Grid Statistics</ows:Title>
            elif child.tag.endswith('Title'):
                self.title =  testXMLValue( child )
        
            # <ows:Abstract xmlns:ows="http://www.opengis.net/ows/1.1">This algorithm generates area weighted statistics of a gridded dataset for a set of vector polygon features. Using the bounding-box that encloses the feature data and the time range, if provided, a subset of the gridded dataset is requested from the remote gridded data server. Polygon representations are generated for cells in the retrieved grid. The polygon grid-cell representations are then projected to the feature data coordinate reference system. The grid-cells are used to calculate per grid-cell feature coverage fractions. Area-weighted statistics are then calculated for each feature using the grid values and fractions as weights. If the gridded dataset has a time range the last step is repeated for each time step within the time range or all time steps if a time range was not supplied.</ows:Abstract>
            elif child.tag.endswith('Abstract'):
                self.abstract = testXMLValue( child )
        
        if self.verbose==True:
            dump(self)
        
        # <DataInputs>
        self.dataInputs = []
        for inputElement in elem.findall( 'DataInputs/Input' ):
            self.dataInputs.append( Input(inputElement) )
            if self.verbose==True:
                dump(self.dataInputs[-1], prefix='\tInput: ')
        
        # <ProcessOutputs>
        self.processOutputs = []
        for outputElement in elem.findall( 'ProcessOutputs/Output' ):
            self.processOutputs.append( Output(outputElement) )
            if self.verbose==True:
                dump(self.processOutputs[-1],  prefix='\tOutput: ')
     
    
class FeatureCollection():
    '''
    Base class to represent a Feature Collection used as input to a WPS request.
    The method getXml() is invoked by the WPS execute() method to build the WPS request.
    All subclasses must implement the getXml() method to provide their specific XML.
    
    Implements IComplexData.
    '''
    
    def __init__(self):
        pass
    
    def getXml(self):
        raise NotImplementedError
    
class WFSFeatureCollection(FeatureCollection):
    '''
    FeatureCollection specified by a WFS query.
    All subclasses must implement the getQuery() method to provide the specific query portion of the XML.
    '''
    
    def __init__(self, wfsUrl, wfsQuery):
        '''
        wfsUrl: the WFS service URL
                example: wfsUrl = "http://igsarm-cida-gdp2.er.usgs.gov:8082/geoserver/wfs"
        wfsQuery : a WFS query instance
        '''
        self.url = wfsUrl
        self.query = wfsQuery
    
    #    <wps:Reference xlink:href="http://igsarm-cida-gdp2.er.usgs.gov:8082/geoserver/wfs">
    #      <wps:Body>
    #        <wfs:GetFeature xmlns:wfs="http://www.opengis.net/wfs" xmlns:ogc="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml" service="WFS" version="1.1.0" outputFormat="text/xml; subtype=gml/3.1.1" xsi:schemaLocation="http://www.opengis.net/wfs ../wfs/1.1.0/WFS.xsd">
    #            .......
    #        </wfs:GetFeature>
    #      </wps:Body>
    #   </wps:Reference>
    def getXml(self):
        
        root = etree.Element(nspath_eval('wps:Reference', namespaces), attrib = { nspath_eval("xlink:href",namespaces) : self.url} )
        bodyElement = etree.SubElement(root, nspath_eval('wps:Body', namespaces))
        getFeatureElement = etree.SubElement(bodyElement, nspath_eval('wfs:GetFeature', namespaces),
                                             attrib = { "service":"WFS",
                                                        "version":"1.1.0",
                                                        "outputFormat":"text/xml; subtype=gml/3.1.1",
                                                        nspath_eval("xsi:schemaLocation",namespaces):"%s %s" % (namespaces['wfs'], '../wfs/1.1.0/WFS.xsd')})
        
        #            <wfs:Query typeName="sample:CONUS_States">
        #                <wfs:PropertyName>the_geom</wfs:PropertyName>
        #                <wfs:PropertyName>STATE</wfs:PropertyName>
        #                <ogc:Filter>
        #                    <ogc:GmlObjectId gml:id="CONUS_States.508"/>
        #                </ogc:Filter>
        #            </wfs:Query>
        getFeatureElement.append( self.query.getXml() )
        
        return root
    
class WFSQuery():
    '''
    Class representing a WFS query, for insertion into a WFSFeatureCollection instance.
    
    Implements IComplexData.
    '''
    
    def __init__(self, typeName, propertyNames=[], filters=[]):
        self.typeName = typeName
        self.propertyNames = propertyNames
        self.filters = filters
        
    def getXml(self):
        
        #            <wfs:Query typeName="sample:CONUS_States">
        #                <wfs:PropertyName>the_geom</wfs:PropertyName>
        #                <wfs:PropertyName>STATE</wfs:PropertyName>
        #                <ogc:Filter>
        #                    <ogc:GmlObjectId gml:id="CONUS_States.508"/>
        #                </ogc:Filter>
        #            </wfs:Query>
   
        queryElement = etree.Element(nspath_eval('wfs:Query', namespaces), attrib = { "typeName":self.typeName })
        for propertyName in self.propertyNames:
            propertyNameElement = etree.SubElement(queryElement, nspath_eval('wfs:PropertyName', namespaces))
            propertyNameElement.text = propertyName
        if len(self.filters)>0:
            filterElement = etree.SubElement(queryElement, nspath_eval('ogc:Filter', namespaces))
            for filter in self.filters:
                gmlObjectIdElement = etree.SubElement(filterElement, nspath_eval('ogc:GmlObjectId', namespaces), 
                                                      attrib={nspath_eval('gml:id', namespaces):filter})
        return queryElement
        
class GMLMultiPolygonFeatureCollection(FeatureCollection):
    '''
    Class that represents a FeatureCollection defined as a GML multi-polygon.
    '''
    
    def __init__(self, polygons):
        '''
        Initializer accepts an array of polygons, where each polygon is an array of (lat,lon) tuples.
        Example: polygons = [ [(-102.8184, 39.5273), (-102.8184, 37.418), (-101.2363, 37.418), (-101.2363, 39.5273), (-102.8184, 39.5273)],
                              [(-92.8184, 39.5273), (-92.8184, 37.418), (-91.2363, 37.418), (-91.2363, 39.5273), (-92.8184, 39.5273)] ]
        '''
        self.polygons = polygons
    
    def getXml(self):
        '''
            <wps:Data>
                <wps:ComplexData mimeType="text/xml" encoding="UTF-8"
                    schema="http://schemas.opengis.net/gml/3.1.1/base/feature.xsd">
                    <gml:featureMembers xmlns:ogc="http://www.opengis.net/ogc"
                        xmlns:draw="gov.usgs.cida.gdp.draw" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                        xmlns:ows="http://www.opengis.net/ows" xmlns:gml="http://www.opengis.net/gml"
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xsi:schemaLocation="gov.usgs.cida.gdp.draw http://cida.usgs.gov/climate/derivative/xsd/draw.xsd">
                        <gml:box gml:id="box.1">
                            <gml:the_geom>
                                <gml:MultiPolygon srsDimension="2"
                                    srsName="http://www.opengis.net/gml/srs/epsg.xml#4326">
                                    <gml:polygonMember>
                                        <gml:Polygon>
                                            <gml:exterior>
                                                <gml:LinearRing>
                                                    <gml:posList>-102.8184 39.5273 -102.8184 37.418 -101.2363 37.418 -101.2363 39.5273 -102.8184 39.5273</gml:posList>
                                                </gml:LinearRing>
                                            </gml:exterior>
                                        </gml:Polygon>
                                    </gml:polygonMember>
                                </gml:MultiPolygon>
                            </gml:the_geom>
                            <gml:ID>0</gml:ID>
                        </gml:box>
                    </gml:featureMembers>
                </wps:ComplexData>
            </wps:Data>
        '''
        dataElement = etree.Element(nspath_eval('wps:Data', namespaces))
        complexDataElement = etree.SubElement(dataElement, nspath_eval('wps:ComplexData', namespaces),
                                              attrib={"mimeType":"text/xml", "encoding":"UTF-8", "schema":GML_SCHEMA_LOCATION} )
        featureMembersElement = etree.SubElement(complexDataElement, nspath_eval('gml:featureMembers', namespaces),
                                                 attrib={ nspath_eval("xsi:schemaLocation",namespaces):"%s %s" % (DRAW_NAMESPACE, DRAW_SCHEMA_LOCATION)})
        boxElement = etree.SubElement(featureMembersElement, nspath_eval('gml:box', namespaces), attrib={ nspath_eval("gml:id",namespaces):"box.1" })
        geomElement = etree.SubElement(boxElement, nspath_eval('gml:the_geom', namespaces))
        multiPolygonElement = etree.SubElement(geomElement, nspath_eval('gml:MultiPolygon', namespaces),
                                               attrib={"srsDimension":"2", "srsName":"http://www.opengis.net/gml/srs/epsg.xml#4326"} )
        for polygon in self.polygons:
            polygonMemberElement = etree.SubElement(multiPolygonElement, nspath_eval('gml:polygonMember', namespaces))
            polygonElement = etree.SubElement(polygonMemberElement, nspath_eval('gml:Polygon', namespaces))
            exteriorElement = etree.SubElement(polygonElement, nspath_eval('gml:exterior', namespaces))
            linearRingElement = etree.SubElement(exteriorElement, nspath_eval('gml:LinearRing', namespaces))
            posListElement = etree.SubElement(linearRingElement, nspath_eval('gml:posList', namespaces))
            posListElement.text =  ' '.join(["%s %s" % (x, y) for x, y in polygon[:] ])
        
        idElement = etree.SubElement(boxElement, nspath_eval('gml:ID', namespaces))
        idElement.text = "0"
        return dataElement
    
def monitorExecution(execution, sleepSecs=3, download=False, filepath=None):
    '''
    Convenience method to monitor the status of a WPS execution till it completes (succesfully or not),
    and write the output to file after a succesfull job completion.
    
    execution: WPSExecution instance
    sleepSecs: number of seconds to sleep in between check status invocations
    download: True to download the output when the process terminates, False otherwise
    filepath: optional path to output file (if downloaded=True), otherwise filepath will be inferred from response document
    
    '''
    
    while execution.isComplete()==False:
        execution.checkStatus(sleepSecs=sleepSecs)
        print 'Execution status: %s' % execution.status
        
    if execution.isSucceded():
        if download:
            execution.getOutput(filepath=filepath)
        else:
            for output in execution.processOutputs:               
                if output.reference is not None:
                    print 'Output URL=%s' % output.reference
    else:
        for ex in execution.errors:
            print 'Error: code=%s, locator=%s, text=%s' % (ex.code, ex.locator, ex.text)

def printValue(value):
    '''
    Utility method to format a value for printing.
    '''
    
    # ComplexData type
    if isinstance(value, ComplexData):
        return "mimeType=%s, encoding=%s, schema=%s" % (value.mimeType, value.encoding, value.schema)
    # other type
    else:
        return value

def printInputOutput(value, indent=''):
    '''
    Utility method to inspect an input/output element.
    '''

    # InputOutput fields
    print '%s identifier=%s, title=%s, abstract=%s, data type=%s' % (indent, value.identifier, value.title, value.abstract, value.dataType)
    for val in value.allowedValues:
        print '%s Allowed Value: %s' % (indent, printValue(val))
    for val in value.supportedValues:
        print '%s Supported Value: %s' % (indent, printValue(val))
    print '%s Default Value: %s ' % (indent, printValue(value.defaultValue))
    
    # Input fields
    if isinstance(value, Input):
        print '%s minOccurs=%d, maxOccurs=%d' % (indent, value.minOccurs, value.maxOccurs)
        
    # Output fields
    if isinstance(value, Output):
        print '%s reference=%s, mimeType=%s' % (indent, value.reference, value.mimeType)
        for datum in value.data:
            print '%s Data Value: %s' % (indent, printValue(datum))

########NEW FILE########
__FILENAME__ = utils
import os
from owslib.etree import etree
from urlparse import urlparse

def resource_file(filepath):
    return os.path.join(test_directory(), 'resources', filepath)

def test_directory():
    """Helper function to return path to the tests directory"""
    return os.path.dirname(__file__)

def scratch_directory():
    """Helper function to return path to the tests scratch directory"""
    return os.path.join(test_directory(), 'scratch')

def scratch_file(filename):
    """Helper function to return file path in the tests scratch directory"""
    return os.path.join(scratch_directory(), filename)

def compare_xml(a,b):
    if not isinstance(a, etree._Element):
        a = etree.fromstring(a)
    if not isinstance(b, etree._Element):
        b = etree.fromstring(b)

    return compare_elements(a,b)

def compare_elements(a,b):
    # Tag
    if a.tag != b.tag:
        return False
    # Value
    if a.text != b.text:
        return False
    # Attributes
    if sorted(a.items()) != sorted(b.items()):
        return False
    # Children
    if len(list(a)) != len(list(b)):
        return False
    # Recurse
    for ac, bc in zip(list(a), list(b)):
        if not compare_elements(ac, bc):
            return False

    return True

def cast_tuple_int_list(tup):
    """Set tuple float values to int for more predictable test results"""
    return [int(a) for a in tup]

def cast_tuple_int_list_srs(tup):
    tup2 = cast_tuple_int_list(tup[:4])
    tup2.append(tup[-1])
    return tup2

def sorted_url_query(url):
    return sorted(urlparse(url).query.split("&"))

########NEW FILE########
