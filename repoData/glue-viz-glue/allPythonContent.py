__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Glue documentation build configuration file, created by
# sphinx-quickstart on Mon Jun 25 12:05:47 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.coverage',
              'sphinx.ext.mathjax', 'sphinx.ext.viewcode',
              'astropy.sphinx.ext.astropyautosummary',
              'astropy.sphinx.ext.automodapi',
              'astropy.sphinx.ext.numpydoc',
              'astropy.sphinx.ext.automodsumm', 'sphinx.ext.intersphinx']

intersphinx_cache_limit = 10     # days to keep the cached inventories
intersphinx_mapping = {
    'sphinx': ('http://sphinx.pocoo.org', None),
    'python': ('http://docs.python.org/2.7', None),
    'matplotlib': ('http://matplotlib.sourceforge.net', None),
    'numpy': ('http://docs.scipy.org/doc/numpy', None),
    'astropy': ('http://docs.astropy.org/en/stable/', None),
}

numpydoc_show_class_members = False
autosummary_generate = True
automodapi_toctreedirnm = 'api'

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Glue'
copyright = u'2012-2014, Chris Beaumont, Thomas Robitaille, Michelle Borkin'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build', '_templates']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
try:  # use ReadTheDocs theme, if installed
    import sphinx_rtd_theme
    html_theme = 'sphinx_rtd_theme'
    html_theme_path = [sphinx_rtd_theme.get_html_theme_path(), ]
except ImportError:
    pass

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}


# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = '_static/logo.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Gluedoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'Glue.tex', u'Glue Documentation',
     u'Chris Beaumont, Thomas Robitaille, Michelle Borkin', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'glue', u'Glue Documentation',
     [u'Chris Beaumont, Thomas Robitaille, Michelle Borkin'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', 'Glue', u'Glue Documentation',
     u'Chris Beaumont, Thomas Robitaille, Michelle Borkin', 'Glue', 'One line description of project.',
     'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

todo_include_todos = True
autoclass_content = 'both'

nitpick_ignore = [('py:class', 'object'), ('py:class', 'str'),
                  ('py:class', 'list'), ('py:obj', 'numpy array'),
                  ('py:obj', 'integer'), ('py:obj', 'Callable'),
                  ('py:class', 'PySide.QtGui.QMainWindow'),
                  ('py:class', 'PySide.QtGui.QWidget'),
                  ('py:obj', "str ('file' | 'directory' | 'label')"),
                  ('py:obj', 'function(application)')]


# coax Sphinx into treating descriptors as attributes
# see https://bitbucket.org/birkenfeld/sphinx/issue/1254/#comment-7587063
from glue.qt.widget_properties import WidgetProperty
WidgetProperty.__get__ = lambda self, *args, **kwargs: self

########NEW FILE########
__FILENAME__ = config_link_example
from glue.config import link_function

@link_function(info="Link from deg to rad", output_labels=['rad'])
def deg_to_rad(deg):
    return deg * 3.14159 / 180

########NEW FILE########
__FILENAME__ = coord_convert
from kapteyn import celestial

def radec2glat(ra, dec):
    lonlat = celestial.sky2sky( (celestial.eq, celestial.fk5), celestial.gal,
                               ra.flat, dec.flat).A
    return lonlat[:,0].ravel()

def radec2glon(ra, dec):
    lonlat = celestial.sky2sky( (celestial.eq, celestial.fk5), celestial.gal,
                               ra.flat, dec.flat).A
    return lonlat[:, 1].ravel()

def lonlat2ra(lon, lat):
    radec = celestial.sky2sky( (celestial.eq, celestial.fk5), celestial.gal,
                               lon.flat, lat.flat).A
    return radec[:, 0].ravel()

def lonlat2dec(lon, lat):
    radec = celestial.sky2sky( (celestial.eq, celestial.fk5), celestial.gal,
                               ra.flat, dec.flat).A
    return radec[:, 1].ravel()

########NEW FILE########
__FILENAME__ = emcee_plugin
from glue.core.fitters import BaseFitter1D
from glue.core.simpleforms import IntOption
from glue.config import fit_plugin

import numpy as np
import emcee


def gaussian(x, mean, amplitude, stddev):
    return np.exp(-(x - mean) ** 2 / (2 * stddev ** 2)) * amplitude


def lnprob(param, x, y, dy):
    # mean, amplitude, stddev = param
    if param[-1] < 0:
        return -np.inf
    yp = gaussian(x, *param)
    diff = (y - yp)
    if dy is not None:
        diff /= dy
    return -np.dot(diff, diff)


@fit_plugin
class EmceeGaussianFitter(BaseFitter1D):
    label = "Emcee Gaussian"
    walkers = IntOption(label="Walkers", min=1, max=200, default=50)
    burnin = IntOption(label="Burn in steps", min=1, max=10000, default=500)
    steps = IntOption(label="Steps", min=10, max=10000, default=500)

    def fit(self, x, y, dy, constraints,
            walkers=50, burnin=500, steps=500):
        ndim = 3
        # initialize walker parameters
        amp = y.max()
        mean = (x * y).sum() / y.sum()
        var = ((x - mean) ** 2 * y).sum() / y.sum()
        p0 = np.array([amp, mean, np.sqrt(var)]).reshape(1, -1)
        p0 = np.random.lognormal(sigma=.1, size=(walkers, ndim)) * p0
        sampler = emcee.EnsembleSampler(walkers, ndim, lnprob,
                                        args=[x, y, dy])

        # burnin
        pos, prob, state = sampler.run_mcmc(p0, burnin)
        sampler.reset()

        # run
        sampler.run_mcmc(pos, steps)
        return sampler

    def predict(self, fit_result, x):
        chain = fit_result.flatchain
        params = np.mean(chain, axis=0)
        return gaussian(x, *params)

    def summarize(self, fit_result, x, y, dy):
        af = fit_result.acceptance_fraction.mean()
        chain = fit_result.flatchain
        amp, mean, sigma = chain.mean(axis=0)
        damp, dmean, dsigma = np.std(chain, axis=0)
        walkers, steps, dim = fit_result.chain.shape

        result = [
            "Walkers: %i" % walkers,
            "Steps:   %i" % steps,
            "Acceptance fraction: %0.2f" % af,
            "-------------------------",
            "amplitude = %0.3e +/- %0.1e" % (amp, damp),
            "mean      = %0.3e +/- %0.1e" % (mean, dmean),
            "stddev    = %0.3e +/- %0.1e" % (sigma, dsigma)
        ]
        return '\n'.join(result)

    def plot(self, fit_result, axes, x):
        chain = fit_result.flatchain
        result = []

        # background samples
        for i in range(100):
            row = np.random.randint(0, chain.shape[0])
            params = chain[row]
            y = gaussian(x, *params)
            result.extend(axes.plot(x, y, 'k', alpha=.08))

        # foreground prediction of posterior mean model
        result.extend(
            super(EmceeGaussianFitter, self).plot(fit_result, axes, x))

        return result

########NEW FILE########
__FILENAME__ = line_fit_plugin
from glue.core.fitters import BaseFitter1D
from glue.config import fit_plugin
import numpy as np


@fit_plugin
class LineFit(BaseFitter1D):
    label = "Line"

    def fit(self, x, y, dy, constraints):
        return np.polyfit(x, y, 1)

    def predict(self, fit_result, x):
        return np.polyval(fit_result, x)

########NEW FILE########
__FILENAME__ = poly_fit_plugin
from glue.core.fitters import BaseFitter1D
from glue.core.simpleforms import IntOption
from glue.config import fit_plugin
import numpy as np


@fit_plugin
class PolynomialFitter(BaseFitter1D):
    label = "Polynomial"
    degree = IntOption(min=0, max=5, default=3, label="Polynomial Degree")

    def fit(self, x, y, dy, constraints, degree=2):
        return np.polyfit(x, y, degree)

    def predict(self, fit_result, x):
        return np.polyval(fit_result, x)

    def summarize(self, fit_result, x, y, dy=None):
        return "Coefficients:\n" + "\n".join("%e" % coeff
                                             for coeff in fit_result.tolist())

########NEW FILE########
__FILENAME__ = simple_glue
from glue.core.message import DataMessage, SubsetMessage
from glue.core import Hub, HubListener, Data, DataCollection

class MyClient(HubListener):
    def register_to_hub(self, hub):
        """ Sign up to receive DataMessages from the hub """
        hub.subscribe(self,                     # subscribing object
                      DataMessage, # message type to subscribe to
                      handler = self.receive_message) # method to call


    def receive_message(self, message):
        """ Receives each DataMessage relay """
        print "    MyClient received a message \n"


# create objects
hub = Hub()
client = MyClient()
data = Data()
subset = data.new_subset()
data_collection = DataCollection()

# connect them to each other
data_collection.append(data)
data_collection.register_to_hub(hub)
client.register_to_hub(hub)

# manually send a DataMessage. Relayed to MyClient
print 'Manually sending DataMessage'
message = DataMessage(data)
hub.broadcast(message)

#modify the data object. Automatically generates a DataMessage
print 'Automatically triggering DataMessage'
data.label = "New label"

#send a SubsetMessage to the Hub.
print 'Manually sending SubsetMessage'
message = SubsetMessage(subset)
hub.broadcast(message) # nothing is printed

########NEW FILE########
__FILENAME__ = w5
from glue.core.data_factories import load_data
from glue.core import DataCollection
from glue.core.link_helpers import LinkSame
from glue.qt.glue_application import GlueApplication

#load 2 datasets from files
image = load_data('w5.fits')
catalog = load_data('w5_psc.vot')
dc = DataCollection([image, catalog])

# link positional information
dc.add_link(LinkSame(image.id['World x: RA---TAN'], catalog.id['RAJ2000']))
dc.add_link(LinkSame(image.id['World y: DEC--TAN'], catalog.id['DEJ2000']))

#start Glue
app = GlueApplication(dc)
app.start()

########NEW FILE########
__FILENAME__ = ds9norm
"""
This file implements a matplotlib Normalize object
which mimics the functionality of scaling functions in ds9

The transformation from data values to normalized (0-1) display
intensities are as follows:

- Data to normal:
   y = clip( (x - vmin) / (vmax - vmin), 0, 1)
- normal to warped: Apply a monotonic, non-linear scaling, that preserves
  the endpoints
- warped to greyscale:
  y = clip((x - bias) * contrast + 0.5, 0, 1)
"""

# implementation details
# The relevant ds9 code is located at saotk/frame/colorscale.C and
# saotk/colorbar/colorbar.C
#
# As much as possible, we use verbose but inplace ufuncs to minimize
# temporary arrays
import numpy as np
from matplotlib.colors import Normalize

from .util import fast_limits


def norm(x, vmin, vmax):
    """
    Linearly scale data between [vmin, vmax] to [0, 1]. Clip outliers
    """
    result = (x - 1.0 * vmin)
    result = np.divide(result, vmax - vmin, out=result)
    result = np.clip(result, 0, 1, out=result)
    return result


def cscale(x, bias, contrast):
    """
    Apply bias and contrast scaling. Overwrite input

    Parameters
    ----------
    x : array
      Values between 0 and 1
    bias : float
    contrast : float

    Returns
    -------
    The input x, scaled inplace
    """
    x = np.subtract(x, bias, out=x)
    x = np.multiply(x, contrast, out=x)
    x = np.add(x, 0.5, out=x)
    x = np.clip(x, 0, 1, out=x)
    return x


def linear_warp(x, vmin, vmax, bias, contrast):
    return cscale(norm(x, vmin, vmax), bias, contrast)


def log_warp(x, vmin, vmax, bias, contrast, exp=1000.0):
    black = x < vmin
    x = norm(x, vmin, vmax)
    x = np.multiply(exp, x, out=x)
    # sidestep numpy bug that masks log(1)
    # when out is provided
    x = np.add(x, 1.001, out=x)
    x = np.log(x, out=x)
    x = np.divide(x, np.log(exp + 1.0), out=x)
    x = cscale(x, bias, contrast)
    return x


def pow_warp(x, vmin, vmax, bias, contrast, exp=1000.0):
    x = norm(x, vmin, vmax)
    x = np.power(exp, x, out=x)
    x = np.subtract(x, 1, out=x)
    x = np.divide(x, exp - 1)
    x = cscale(x, bias, contrast)
    return x


def sqrt_warp(x, vmin, vmax, bias, contrast):
    x = norm(x, vmin, vmax)
    x = np.sqrt(x, out=x)
    x = cscale(x, bias, contrast)
    return x


def squared_warp(x, vmin, vmax, bias, contrast):
    x = norm(x, vmin, vmax)
    x = np.power(x, 2, out=x)
    x = cscale(x, bias, contrast)
    return x


def asinh_warp(x, vmin, vmax, bias, contrast):
    x = norm(x, vmin, vmax)
    x = np.divide(np.arcsinh(np.multiply(x, 10, out=x), out=x), 3, out=x)
    x = cscale(x, bias, contrast)
    return x

warpers = dict(linear=linear_warp,
               log=log_warp,
               sqrt=sqrt_warp,
               power=pow_warp,
               squared=squared_warp,
               arcsinh=asinh_warp)


# for mpl <= 1.1, Normalize is an old-style class
# explicitly inheriting from object allows property to work
class DS9Normalize(Normalize, object):

    def __init__(self):
        super(DS9Normalize, self).__init__()
        self.stretch = 'linear'
        self.bias = 0.5
        self.contrast = 1.0
        self.clip_lo = 5.
        self.clip_hi = 95.

    @property
    def stretch(self):
        return self._stretch

    @stretch.setter
    def stretch(self, value):
        if value not in warpers:
            raise ValueError("Invalid stretch: %s\n Valid options are: %s" %
                             (value, warpers.keys()))
        self._stretch = value

    def update_clip(self, image):
        vmin, vmax = fast_limits(image, self.clip_lo, self.clip_hi)
        self.vmin = vmin
        self.vmax = vmax

    def __call__(self, value, clip=False):
        # XXX ignore clip

        self.autoscale_None(value)  # set vmin, vmax if unset
        inverted = self.vmax <= self.vmin

        hi, lo = max(self.vmin, self.vmax), min(self.vmin, self.vmax)

        warp = warpers[self.stretch]
        result = warp(value, lo, hi, self.bias, self.contrast)

        if inverted:
            result = np.subtract(1, result, out=result)

        result = np.ma.MaskedArray(result, copy=False)

        return result

    def __gluestate__(self, context):
        return dict(vmin=self.vmin, vmax=self.vmax, clip_lo=self.clip_lo,
                    clip_hi=self.clip_hi, stretch=self.stretch, bias=self.bias,
                    contrast=self.contrast)

    @classmethod
    def __setgluestate__(cls, rec, context):
        result = cls()
        for k, v in rec.items():
            setattr(result, k, v)
        return result

########NEW FILE########
__FILENAME__ = histogram_client
import numpy as np

from ..core.client import Client
from ..core import message as msg
from ..core.data import Data
from ..core.subset import RangeSubsetState
from ..core.exceptions import IncompatibleDataException, IncompatibleAttribute
from ..core.edit_subset_mode import EditSubsetMode
from .layer_artist import HistogramLayerArtist, LayerArtistContainer
from .util import visible_limits, update_ticks
from ..core.callback_property import CallbackProperty, add_callback
from ..core.util import lookup_class


class UpdateProperty(CallbackProperty):

    """Descriptor that calls client's sync_all() method when changed"""

    def __init__(self, default, relim=False):
        super(UpdateProperty, self).__init__(default)
        self.relim = relim

    def __set__(self, instance, value):
        changed = value != self.__get__(instance)
        super(UpdateProperty, self).__set__(instance, value)
        if not changed:
            return
        instance.sync_all()
        if self.relim:
            instance._relim()


def update_on_true(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        if result:
            args[0].sync_all()
        return result
    return wrapper


class HistogramClient(Client):

    """
    A client class to display histograms
    """
    normed = UpdateProperty(False)
    cumulative = UpdateProperty(False)
    autoscale = UpdateProperty(True)
    nbins = UpdateProperty(30)
    xlog = UpdateProperty(False, relim=True)
    ylog = UpdateProperty(False)

    def __init__(self, data, figure, artist_container=None):
        super(HistogramClient, self).__init__(data)

        self._artists = artist_container or LayerArtistContainer()
        self._axes = figure.add_subplot(111)
        self._component = None

        self._xlim = {}

        try:
            self._axes.figure.set_tight_layout(True)
        except AttributeError:  # pragma: nocover (matplotlib < 1.1)
            pass

    @property
    def bins(self):
        """ An array of bin edges for the histogram.

        Returns None if no histogram has been computed yet.
        """
        for art in self._artists:
            if not isinstance(art, HistogramLayerArtist):
                continue
            return art.x

    @property
    def axes(self):
        return self._axes

    @property
    def xlimits(self):
        try:
            return self._xlim[self.component]
        except KeyError:
            pass

        lo, hi = self._default_limits()
        self._xlim[self.component] = lo, hi
        return lo, hi

    def _default_limits(self):
        if self.component is None:
            return 0, 1
        lo, hi = np.inf, -np.inf
        for a in self._artists:
            try:
                data = a.layer[self.component]
            except IncompatibleAttribute:
                continue

            if data.size == 0:
                continue
            lo = min(lo, np.nanmin(data))
            hi = max(hi, np.nanmax(data))
        return lo, hi

    @xlimits.setter
    @update_on_true
    def xlimits(self, value):
        lo, hi = value
        old = self.xlimits
        if lo is None:
            lo = old[0]
        if hi is None:
            hi = old[1]

        self._xlim[self.component] = min(lo, hi), max(lo, hi)
        self._relim()
        return True

    def layer_present(self, layer):
        return layer in self._artists

    def add_layer(self, layer):
        if layer.data not in self.data:
            raise IncompatibleDataException("Layer not in data collection")

        self._ensure_layer_data_present(layer)
        if self.layer_present(layer):
            return self._artists[layer][0]

        art = HistogramLayerArtist(layer, self._axes)
        self._artists.append(art)

        self._ensure_subsets_present(layer)
        self._sync_layer(layer)
        self._redraw()
        return art

    def _redraw(self):
        self._axes.figure.canvas.draw()

    def _ensure_layer_data_present(self, layer):
        if layer.data is layer:
            return
        if not self.layer_present(layer.data):
            self.add_layer(layer.data)

    def _ensure_subsets_present(self, layer):
        for subset in layer.data.subsets:
            self.add_layer(subset)

    @update_on_true
    def remove_layer(self, layer):
        if not self.layer_present(layer):
            return

        for a in self._artists.pop(layer):
            a.clear()

        if isinstance(layer, Data):
            for subset in layer.subsets:
                self.remove_layer(subset)

        return True

    @update_on_true
    def set_layer_visible(self, layer, state):
        if not self.layer_present(layer):
            return
        for a in self._artists[layer]:
            a.visible = state
        return True

    def is_layer_visible(self, layer):
        if not self.layer_present(layer):
            return False
        return any(a.visible for a in self._artists[layer])

    def _update_axis_labels(self):
        xlabel = self.component.label if self.component is not None else ''
        if self.xlog:
            xlabel = "Log %s" % xlabel
        ylabel = 'N'
        self._axes.set_xlabel(xlabel)
        self._axes.set_ylabel(ylabel)
        components = list(self._get_data_components('x'))
        if components:
            bins = update_ticks(self.axes, 'x',
                                components, False)

            if bins is not None:
                prev_bins = self.nbins
                auto_bins = self._auto_nbin(calculate_only=True)
                if prev_bins == auto_bins:
                    # try to assign a bin to each category,
                    # but only if self.nbins hasn't been overridden
                    # from auto_nbin
                    self.nbins = min(bins, 100)
                    self.xlimits = (-0.5, bins - 0.5)

    def _get_data_components(self, coord):
        """ Returns the components for each dataset for x and y axes.
        """
        if coord == 'x':
            attribute = self.component
        else:
            raise TypeError('coord must be x')

        for data in self._data:
            try:
                yield data.get_component(attribute)
            except IncompatibleAttribute:
                pass

    def _auto_nbin(self, calculate_only=False):
        data = set(a.layer.data for a in self._artists)
        if len(data) == 0:
            return
        dx = np.mean([d.size for d in data])
        val = min(max(5, (dx / 1000) ** (1. / 3.) * 30), 100)
        if not calculate_only:
            self.nbins = val
        return val

    def _sync_layer(self, layer):
        for a in self._artists[layer]:
            a.lo, a.hi = self.xlimits
            a.nbins = self.nbins
            a.xlog = self.xlog
            a.ylog = self.ylog
            a.cumulative = self.cumulative
            a.normed = self.normed
            a.att = self._component
            a.update()

    def sync_all(self):
        layers = set(a.layer for a in self._artists)
        for l in layers:
            self._sync_layer(l)

        self._update_axis_labels()

        if self.autoscale:
            lim = visible_limits(self._artists, 1)
            if lim is not None:
                lo = 1e-5 if self.ylog else 0
                hi = lim[1]
                # pad the top
                if self.ylog:
                    hi = lo * (hi / lo) ** 1.03
                else:
                    hi *= 1.03
                self._axes.set_ylim(lo, hi)

        yscl = 'log' if self.ylog else 'linear'
        self._axes.set_yscale(yscl)

        self._redraw()

    @property
    def component(self):
        return self._component

    def set_component(self, component):
        """
        Redefine which component gets plotted

        Parameters
        ----------
        component: ComponentID
            The new component to plot
        """
        if self._component is component:
            return
        self._component = component
        self._auto_nbin()
        self.sync_all()
        self._relim()

    def _relim(self):
        lim = self.xlimits
        if self.xlog:
            lim = list(np.log10(lim))
            if not np.isfinite(lim[0]):
                lim[0] = 1e-5
            if not np.isfinite(lim[1]):
                lim[1] = 1

        self._axes.set_xlim(lim)
        self._redraw()

    def _update_data(self, message):
        self.sync_all()

    def _update_subset(self, message):
        self._sync_layer(message.subset)
        self._redraw()

    def _add_subset(self, message):
        self.add_layer(message.sender)
        assert self.layer_present(message.sender)
        assert self.is_layer_visible(message.sender)

    def _remove_data(self, message):
        self.remove_layer(message.data)

    def _remove_subset(self, message):
        self.remove_layer(message.subset)

    def apply_roi(self, roi):
        x, _ = roi.to_polygon()
        lo = min(x)
        hi = max(x)

        # expand roi to match bin edges
        bins = self.bins

        if lo >= bins.min():
            lo = bins[bins <= lo].max()
        if hi <= bins.max():
            hi = bins[bins >= hi].min()

        if self.xlog:
            lo = 10 ** lo
            hi = 10 ** hi

        state = RangeSubsetState(lo, hi)
        state.att = self.component
        mode = EditSubsetMode()
        visible = [d for d in self.data if self.is_layer_visible(d)]
        focus = visible[0] if len(visible) > 0 else None
        mode.update(self.data, state, focus_data=focus)

    def register_to_hub(self, hub):
        dfilter = lambda x: x.sender.data in self._artists
        dcfilter = lambda x: x.data in self._artists
        subfilter = lambda x: x.subset in self._artists

        hub.subscribe(self,
                      msg.SubsetCreateMessage,
                      handler=self._add_subset,
                      filter=dfilter)
        hub.subscribe(self,
                      msg.SubsetUpdateMessage,
                      handler=self._update_subset,
                      filter=subfilter)
        hub.subscribe(self,
                      msg.SubsetDeleteMessage,
                      handler=self._remove_subset)
        hub.subscribe(self,
                      msg.DataUpdateMessage,
                      handler=self._update_data,
                      filter=dfilter)
        hub.subscribe(self,
                      msg.DataCollectionDeleteMessage,
                      handler=self._remove_data)

    def restore_layers(self, layers, context):
        for layer in layers:
            lcls = lookup_class(layer.pop('_type'))
            if lcls != HistogramLayerArtist:
                raise ValueError("Cannot restore layers of type %s" % lcls)
            data_or_subset = context.object(layer.pop('layer'))
            result = self.add_layer(data_or_subset)
            result.properties = layer

########NEW FILE########
__FILENAME__ = image_client
import logging
from functools import wraps

import numpy as np

from ..external.modest_image import extract_matched_slices
from ..core.exceptions import IncompatibleAttribute
from ..core.data import Data
from ..core.util import lookup_class, defer
from ..core.subset import Subset, RoiSubsetState
from ..core.roi import PolygonalROI
from ..core.callback_property import (
    callback_property, CallbackProperty)
from ..core.edit_subset_mode import EditSubsetMode

from .viz_client import VizClient, init_mpl
from .layer_artist import (ScatterLayerArtist, LayerArtistContainer,
                           ImageLayerArtist, SubsetImageLayerArtist,
                           RGBImageLayerArtist)


def requires_data(func):
    """Decorator that checks an ImageClient for a non-null display_data
    attribute. Only executes decorated function if present"""
    @wraps(func)
    def result(*args, **kwargs):
        if args[0].display_data is None:
            return
        return func(*args, **kwargs)
    return result


class ImageClient(VizClient):
    display_data = CallbackProperty(None)
    display_attribute = CallbackProperty(None)

    def __init__(self, data, figure=None, axes=None, artist_container=None):

        if axes is not None:
            raise ValueError("ImageClient does not accept an axes")

        figure, axes = init_mpl(figure, axes, wcs=True)

        VizClient.__init__(self, data)

        self.artists = artist_container
        if self.artists is None:
            self.artists = LayerArtistContainer()

        self._slice = None
        self._view_window = None
        self._view = None
        self._image = None
        self._override_image = None

        self._ax = axes
        self._ax.get_xaxis().set_ticks([])
        self._ax.get_yaxis().set_ticks([])
        self._figure = figure
        self._norm_cache = {}

        # custom axes formatter
        def format_coord(x, y):
            data = self.display_data
            if data is None:
                # MPL default method
                return type(self._ax).format_coord(self._ax, x, y)
            info = self.point_details(x, y)
            return '         '.join(info['labels'])

        self._ax.format_coord = format_coord

        self._cid = self._ax.figure.canvas.mpl_connect('button_release_event',
                                                       self.check_update)

        if hasattr(self._ax.figure.canvas, 'homeButton'):
            # test code doesn't always use Glue's custom FigureCanvas
            self._ax.figure.canvas.homeButton.connect(self.check_update)

    def point_details(self, x, y):
        data = self.display_data
        pix = self._pixel_coords(x, y)
        world = data.coords.pixel2world(*pix[::-1])
        world = world[::-1]   # reverse for numpy convention
        labels = ['%s=%s' % (data.get_world_component_id(i).label, w)
                  for i, w in enumerate(world)]

        view = []
        for p, s in zip(pix, data.shape):
            p = int(p)
            if not (0 <= p < s):
                value = None
                break
            view.append(slice(p, p + 1))
        else:
            if self._override_image is None:
                value = self.display_data[self.display_attribute, view]
            else:
                value = self._override_image[int(y), int(x)]

            value = value.ravel()[0]

        return dict(pix=pix, world=world, labels=labels, value=value)

    @callback_property
    def slice(self):
        """
        Returns a tuple describing the current slice through the data

        The tuple has length equal to the dimensionality of the display
        data. Each entry is either:

        'x' if the dimension is mapped to the X image axis
        'y' if the dimension is mapped to the Y image axis
        a number, indicating which fixed slice the dimension is restricted to
        """
        if self._slice is not None:
            return self._slice

        if self.display_data is None:
            return tuple()
        ndim = self.display_data.ndim
        if ndim == 1:
            self._slice = ('x',)
        elif ndim == 2:
            self._slice = ('y', 'x')
        else:
            self._slice = (0,) * (ndim - 2) + ('y', 'x')

        return self._slice

    @slice.setter
    def slice(self, value):
        if self.slice == tuple(value):
            return

        relim = value.index('x') != self._slice.index('x') or \
            value.index('y') != self._slice.index('y')

        self._slice = tuple(value)
        self._clear_override()
        self._update_axis_labels()
        self._update_data_plot(relim=relim)
        self._update_subset_plots()
        self._redraw()

    @property
    def axes(self):
        return self._ax

    @property
    def is_3D(self):
        """
        Returns True if the display data has 3 dimensions """
        if not self.display_data:
            return False
        return len(self.display_data.shape) == 3

    @property
    def slice_ind(self):
        """
        For 3D data, returns the pixel index of the current slice.
        Otherwise, returns None
        """
        if self.is_3D:
            for s in self.slice:
                if s not in ['x', 'y']:
                    return s
        return None

    @property
    def image(self):
        return self._image

    @requires_data
    def override_image(self, image):
        """Temporarily override the current slice view with another
        image (i.e., an aggregate)
        """
        self._override_image = image
        for a in self.artists[self.display_data]:
            if isinstance(a, ImageLayerArtist):
                a.override_image(image)
        self._update_data_plot()
        self._redraw()

    def _clear_override(self):
        self._override_image = None
        for a in self.artists[self.display_data]:
            if isinstance(a, ImageLayerArtist):
                a.clear_override()

    @slice_ind.setter
    def slice_ind(self, value):
        if self.is_3D:
            slc = [s if s in ['x', 'y'] else value for s in self.slice]
            self.slice = slc
            self._update_data_plot()
            self._update_subset_plots()
            self._redraw()
        else:
            raise IndexError("Can only set slice_ind for 3D images")

    def can_image_data(self, data):
        return data.ndim > 1

    def _ensure_data_present(self, data):
        if data not in self.artists:
            self.add_layer(data)

    def check_update(self, *args):
        logging.getLogger(__name__).debug("check update")
        vw = _view_window(self._ax)
        if vw != self._view_window:
            logging.getLogger(__name__).debug("updating")
            self._update_data_plot()
            self._update_subset_plots()
            self._redraw()
            self._view_window = vw

    def set_data(self, data, attribute=None):
        if not self.can_image_data(data):
            return

        self._ensure_data_present(data)
        self._slice = None

        attribute = attribute or _default_component(data)

        self.display_data = data
        self.display_attribute = attribute
        self._update_axis_labels()
        self._update_data_plot(relim=True)
        self._update_subset_plots()
        self._redraw()

    def _update_wcs_axes(self, data, slc):
        wcs = getattr(data.coords, 'wcs', None)

        if wcs is not None and hasattr(self.axes, 'reset_wcs'):
            self.axes.reset_wcs(wcs, slices=slc[::-1])

    @requires_data
    def _update_axis_labels(self):
        labels = _axis_labels(self.display_data, self.slice)
        self._update_wcs_axes(self.display_data, self.slice)
        self._ax.set_xlabel(labels[1])
        self._ax.set_ylabel(labels[0])

    def set_attribute(self, attribute):
        if not self.display_data or \
                attribute not in self.display_data.component_ids():
            raise IncompatibleAttribute(
                "Attribute not in data's attributes: %s" % attribute)
        if self.display_attribute is not None:
            self._norm_cache[self.display_attribute] = self.get_norm()

        self.display_attribute = attribute

        if attribute in self._norm_cache:
            self.set_norm(norm=self._norm_cache[attribute])
        else:
            self.clear_norm()

        self._update_data_plot()
        self._redraw()

    def _redraw(self):
        """
        Re-render the screen
        """
        self._ax.figure.canvas.draw()

    @requires_data
    def set_norm(self, **kwargs):
        for a in self.artists[self.display_data]:
            a.set_norm(**kwargs)
        self._update_data_plot()
        self._redraw()

    @requires_data
    def clear_norm(self):
        for a in self.artists[self.display_data]:
            a.clear_norm()

    @requires_data
    def get_norm(self):
        a = self.artists[self.display_data][0]
        return a.norm

    @requires_data
    def set_cmap(self, cmap):
        for a in self.artists[self.display_data]:
            a.cmap = cmap
            a.redraw()

    def _build_view(self, matched=False):
        att = self.display_attribute
        shp = self.display_data.shape
        shp_2d = _2d_shape(shp, self.slice)
        x, y = np.s_[:], np.s_[:]
        if matched:
            v = extract_matched_slices(self._ax, shp_2d)
            x = slice(v[0], v[1], v[2])
            y = slice(v[3], v[4], v[5])

        slc = list(self.slice)
        slc[slc.index('x')] = x
        slc[slc.index('y')] = y
        return (att,) + tuple(slc)

    @requires_data
    def _update_data_plot(self, relim=False):
        """
        Re-sync the main image and its subsets
        """

        if relim:
            self.relim()

        view = self._build_view(matched=True)
        self._image = self.display_data[view]
        transpose = self.slice.index('x') < self.slice.index('y')

        self._view = view
        for a in list(self.artists):
            if (not isinstance(a, ScatterLayerArtist)) and \
                    a.layer.data is not self.display_data:
                self.artists.remove(a)
            else:
                a.update(view, transpose)
        for a in self.artists[self.display_data]:
            a.update(view, transpose=transpose)

    def relim(self):
        shp = _2d_shape(self.display_data.shape, self.slice)
        self._ax.set_xlim(0, shp[1])
        self._ax.set_ylim(0, shp[0])

    def _update_subset_single(self, s, redraw=False):
        """
        Update the location and visual properties
        of each point in a single subset

        Parameters:
        ----------
        s: A subset instance
        The subset to refresh.

        """
        logging.getLogger(__name__).debug("update subset single: %s", s)

        if s not in self.artists:
            return

        if s.data is not self.display_data:
            return

        self._update_scatter_layer(s)

        view = self._build_view(matched=True)
        transpose = self.slice.index('x') < self.slice.index('y')
        for a in self.artists[s]:
            a.update(view, transpose)

        if redraw:
            self._redraw()

    @property
    def _slice_ori(self):
        if not self.is_3D:
            return None
        for i, s in enumerate(self.slice):
            if s not in ['x', 'y']:
                return i

    @requires_data
    def apply_roi(self, roi):

        subset_state = RoiSubsetState()
        xroi, yroi = roi.to_polygon()
        x, y = self._get_plot_attributes()
        subset_state.xatt = x
        subset_state.yatt = y
        subset_state.roi = PolygonalROI(xroi, yroi)
        mode = EditSubsetMode()
        with defer(self.axes.figure.canvas, 'draw'):
            mode.update(self.data, subset_state, focus_data=self.display_data)

    def _remove_subset(self, message):
        self.delete_layer(message.sender)

    def delete_layer(self, layer):
        if layer not in self.artists:
            return
        for a in self.artists.pop(layer):
            a.clear()

        if layer is self.display_data:
            self.display_data = None

        if isinstance(layer, Data):
            for subset in layer.subsets:
                self.delete_layer(subset)

        self._redraw()

    def _remove_data(self, message):
        self.delete_layer(message.data)
        for s in message.data.subsets:
            self.delete_layer(s)

    def init_layer(self, layer):
        # only auto-add subsets if they are of the main image
        if isinstance(layer, Subset) and layer.data is not self.display_data:
            return
        self.add_layer(layer)

    def rgb_mode(self, enable=None):
        """ Query whether RGB mode is enabled, or toggle RGB mode

        :param enable: bool, or None
        If True or False, explicitly enable/disable RGB mode.
        If None, check if RGB mode is enabled

        :rtype: LayerArtist or None
          If RGB mode is enabled, returns an RGBImageLayerArtist
          If enable=False, return the new ImageLayerArtist
        """
        # XXX need to better handle case where two RGBImageLayerArtists
        #    are created

        if enable is None:
            for a in self.artists:
                if isinstance(a, RGBImageLayerArtist):
                    return a
            return None

        result = None
        layer = self.display_data
        if enable:
            layer = self.display_data
            v = self._view or self._build_view(matched=True)
            a = RGBImageLayerArtist(layer, self._ax, last_view=v)

            for artist in self.artists.pop(layer):
                artist.clear()
            self.artists.append(a)
            result = a
        else:
            for artist in list(self.artists):
                if isinstance(artist, RGBImageLayerArtist):
                    artist.clear()
                self.artists.remove(artist)
            result = self.add_layer(layer)

        self._update_data_plot()
        self._redraw()
        return result

    def add_layer(self, layer):
        if layer in self.artists:
            return self.artists[layer][0]

        if layer.data not in self.data:
            raise TypeError("Data not managed by client's data collection")

        if not self.can_image_data(layer.data):
            # if data is 1D, try to scatter plot
            if len(layer.data.shape) == 1:
                return self.add_scatter_layer(layer)
            logging.getLogger(__name__).warning(
                "Cannot visualize %s. Aborting", layer.label)
            return

        if isinstance(layer, Data):
            result = ImageLayerArtist(layer, self._ax)
            self.artists.append(result)
            for s in layer.subsets:
                self.add_layer(s)
        elif isinstance(layer, Subset):
            result = SubsetImageLayerArtist(layer, self._ax)
            self.artists.append(result)
            self._update_subset_single(layer)
        else:
            raise TypeError("Unrecognized layer type: %s" % type(layer))

        return result

    def add_scatter_layer(self, layer):
        logging.getLogger(
            __name__).debug('Adding scatter layer for %s' % layer)
        if layer in self.artists:
            logging.getLogger(__name__).debug('Layer already present')
            return

        result = ScatterLayerArtist(layer, self._ax)
        self.artists.append(result)
        self._update_scatter_layer(layer)
        return result

    @requires_data
    def _update_scatter_layer(self, layer):
        xatt, yatt = self._get_plot_attributes()
        for a in self.artists[layer]:
            if not isinstance(a, ScatterLayerArtist):
                continue
            a.xatt = xatt
            a.yatt = yatt
            if self.is_3D:
                zatt = self.display_data.get_pixel_component_id(
                    self._slice_ori)
                subset = (
                    zatt > self.slice_ind) & (zatt <= self.slice_ind + 1)
                a.emphasis = subset
            else:
                a.emphasis = None
            a.update()
            a.redraw()
        self._redraw()

    @requires_data
    def _get_plot_attributes(self):
        x, y = _slice_axis(self.display_data.shape, self.slice)
        ids = self.display_data.pixel_component_ids
        return ids[x], ids[y]

    def _pixel_coords(self, x, y):
        """From a slice coordinate (x,y), return the full (possibly
        >2D) numpy index into the full data

        *Note*
        The inputs to this function are the reverse of numpy convention
        (horizontal axis first, then vertical)


        *Returns*
        Either (x,y) or (x,y,z)
        """
        result = list(self.slice)
        result[result.index('x')] = x
        result[result.index('y')] = y
        return result

    def is_visible(self, layer):
        return all(a.visible for a in self.artists[layer])

    def set_visible(self, layer, state):
        for a in self.artists[layer]:
            a.visible = state

    def set_slice_ori(self, ori):
        if not self.is_3D:
            raise IndexError("Can only set slice_ori for 3D images")
        if ori == 0:
            self.slice = (0, 'y', 'x')
        elif ori == 1:
            self.slice = ('y', 0, 'x')
        elif ori == 2:
            self.slice = ('y', 'x', 0)
        else:
            raise ValueError("Orientation must be 0, 1, or 2")

    def restore_layers(self, layers, context):
        """ Restore a list of glue-serialized layer dicts """
        for layer in layers:
            c = lookup_class(layer.pop('_type'))
            props = dict((k, v if k == 'stretch' else context.object(v))
                         for k, v in layer.items())
            l = props['layer']
            if c == ScatterLayerArtist:
                l = self.add_scatter_layer(l)
            elif c == ImageLayerArtist or c == SubsetImageLayerArtist:
                if isinstance(l, Data):
                    self.set_data(l)
                l = self.add_layer(l)
            elif c == RGBImageLayerArtist:
                r = props.pop('r')
                g = props.pop('g')
                b = props.pop('b')
                self.display_data = l
                self.display_attribute = r
                l = self.rgb_mode(True)
                l.r = r
                l.g = g
                l.b = b
            else:
                raise ValueError("Cannot restore layer of type %s" % l)
            l.properties = props


def _2d_shape(shape, slc):
    """Return the shape of the 2D slice through a 2 or 3D image
    """
    # - numpy ordering here
    return shape[slc.index('y')], shape[slc.index('x')]


def _slice_axis(shape, slc):
    """
    Return a 2-tuple of which axes in a dataset lie along the
    x and y axes of the image

    :param shape: Shape of original data. tuple of ints
    :param slc: Slice through the data, tuple of ints, 'x', and 'y'
    """
    return slc.index('x'), slc.index('y')


def _axis_labels(data, slc):
    shape = data.shape
    names = [data.get_world_component_id(i).label
             for i in range(len(shape))]
    return names[slc.index('y')], names[slc.index('x')]


def _view_window(ax):
    """ Return a tuple describing the view window of an axes object.

    The contents should not be used directly, Rather, several
    return values should be compared with == to determine if the
    window has been panned/zoomed
    """
    ext = ax.transAxes.transform([1, 1]) - ax.transAxes.transform([0, 0])
    xlim, ylim = ax.get_xlim(), ax.get_ylim()
    result = xlim[0], ylim[0], xlim[1], ylim[1], ext[0], ext[1]
    logging.getLogger(__name__).debug("view window: %s", result)
    return result


def _default_component(data):
    """Choose a default ComponentID to display for data

    Returns PRIMARY if present
    """
    cid = data.find_component_id('PRIMARY')
    if cid is not None:
        return cid
    return data.component_ids()[0]

########NEW FILE########
__FILENAME__ = layer_artist
"""
LayerArtist classes handle the visualization of an individual subset
or dataset
"""
import logging

import numpy as np
from matplotlib.cm import gray
from ..core.exceptions import IncompatibleAttribute
from ..core.util import color2rgb, PropertySetMixin, Pointer
from ..core.subset import Subset
from .util import view_cascade, get_extent, small_view, small_view_array
from .ds9norm import DS9Normalize


class ChangedTrigger(object):

    """Sets an instance's _changed attribute to True on update"""

    def __init__(self, default=None):
        self._default = default
        self._vals = {}

    def __get__(self, inst, type=None):
        return self._vals.get(inst, self._default)

    def __set__(self, inst, value):
        changed = value != self.__get__(inst)
        self._vals[inst] = value
        if changed:
            inst._changed = True


class LayerArtist(PropertySetMixin):
    _property_set = ['zorder', 'visible', 'layer']

    def __init__(self, layer, axes):
        """Create a new LayerArtist

        :param layer: Data or subset to draw
        :type layer: :class:`~glue.core.data.Data` or `glue.core.subset.Subset`
        """
        self._layer = layer
        self._axes = axes
        self._visible = True

        self._zorder = 0
        self.view = None
        self.artists = []

        self._changed = True
        self._state = None  # cache of subset state, if relevant
        self._disabled_reason = ''

    def disable(self, reason):
        self._disabled_reason = reason
        self.clear()

    def disable_invalid_attributes(self, *attributes):
        if len(attributes) == 0:
            self.disable('')

        msg = ('Layer depends on attributes that '
               'cannot be derived for %s:\n -%s' %
               (self._layer.data.label,
                '\n -'.join(map(str, attributes))))

        self.disable(msg)

    @property
    def disabled_message(self):
        if self.enabled:
            return ''
        return "Cannot visualize this layer\n%s" % self._disabled_reason

    def redraw(self):
        self._axes.figure.canvas.draw()

    @property
    def layer(self):
        return self._layer

    @layer.setter
    def layer(self, value):
        self._layer = value

    @property
    def zorder(self):
        return self._zorder

    @zorder.setter
    def zorder(self, value):
        for artist in self.artists:
            artist.set_zorder(value)
        self._zorder = value

    @property
    def visible(self):
        return self._visible

    @visible.setter
    def visible(self, value):
        self._visible = value
        for a in self.artists:
            a.set_visible(value)

    @property
    def enabled(self):
        return len(self.artists) > 0

    def update(self, view=None):
        """Redraw this layer"""
        raise NotImplementedError()

    def clear(self):
        """Clear the visulaization for this layer"""
        for artist in self.artists:
            try:
                artist.remove()
            except ValueError:  # already removed
                pass
        self.artists = []

    def _check_subset_state_changed(self):
        """Checks to see if layer is a subset and, if so,
        if it has changed subset state. Sets _changed flag to True if so"""
        if not isinstance(self.layer, Subset):
            return
        state = self.layer.subset_state
        if state is not self._state:
            self._changed = True
            self._state = state

    def _sync_style(self):
        style = self.layer.style
        for artist in self.artists:
            edgecolor = style.color if style.marker == '+' else 'none'
            artist.set_markeredgecolor(edgecolor)
            artist.set_markeredgewidth(3)
            artist.set_markerfacecolor(style.color)
            artist.set_marker(style.marker)
            artist.set_markersize(style.markersize)
            artist.set_linestyle('None')
            artist.set_alpha(style.alpha)
            artist.set_zorder(self.zorder)
            artist.set_visible(self.visible and self.enabled)

    def __str__(self):
        return "%s for %s" % (self.__class__.__name__, self.layer.label)

    def __gluestate__(self, context):
        # note, this doesn't yet have a restore method. Will rely on client
        return dict((k, context.id(v)) for k, v in self.properties.items())

    __repr__ = __str__


class ImageLayerArtist(LayerArtist):
    _property_set = LayerArtist._property_set + ['norm']

    def __init__(self, layer, ax):
        super(ImageLayerArtist, self).__init__(layer, ax)
        self._norm = None
        self._cmap = gray
        self._override_image = None
        self._clip_cache = None

    @property
    def norm(self):
        return self._norm

    @norm.setter
    def norm(self, value):
        self._norm = value

    @property
    def cmap(self):
        return self._cmap

    @cmap.setter
    def cmap(self, value):
        self._cmap = value
        for a in self.artists:
            a.set_cmap(value)

    def _default_norm(self, layer):
        vals = np.sort(layer.ravel())
        vals = vals[np.isfinite(vals)]
        result = DS9Normalize()
        result.stretch = 'arcsinh'
        result.clip = True
        if vals.size > 0:
            result.vmin = vals[.01 * vals.size]
            result.vmax = vals[.99 * vals.size]
        return result

    def override_image(self, image):
        """Temporarily show a different image"""
        self._override_image = image

    def clear_override(self):
        self._override_image = None

    def _extract_view(self, view, transpose):
        if self._override_image is None:
            result = self.layer[view]
            if transpose:
                result = result.T
            return result
        else:
            v = [v for v in view if isinstance(v, slice)]
            if transpose:
                v = v[::-1]
            result = self._override_image[v]
            return result

    def _update_clip(self, att):
        key = (att, id(self._override_image),
               self.norm.clip_lo, self.norm.clip_hi)
        if self._clip_cache == key:
            return
        self._clip_cache = key

        if self._override_image is None:
            data = small_view(self.layer, att)
        else:
            data = small_view_array(self._override_image)
        self.norm.update_clip(data)

    def update(self, view, transpose=False):
        self.clear()
        views = view_cascade(self.layer, view)
        artists = []

        lr0 = self._extract_view(views[0], transpose)
        self.norm = self.norm or self._default_norm(lr0)
        self.norm = self.norm or self._default_norm(lr0)
        self._update_clip(views[0][0])

        for v in views:
            image = self._extract_view(v, transpose)
            extent = get_extent(v, transpose)
            artists.append(self._axes.imshow(image, cmap=self.cmap,
                                             norm=self.norm,
                                             interpolation='nearest',
                                             origin='lower',
                                             extent=extent, zorder=0))
            self._axes.set_aspect('equal', adjustable='datalim')
        self.artists = artists
        self._sync_style()

    def set_norm(self, vmin=None, vmax=None,
                 bias=None, contrast=None, stretch=None, norm=None,
                 clip_lo=None, clip_hi=None):
        if norm is not None:
            self.norm = norm  # XXX Should wrap ala DS9Normalize(norm)
            return norm
        if self.norm is None:
            self.norm = DS9Normalize()
        if vmin is not None:
            self.norm.vmin = vmin
        if vmax is not None:
            self.norm.vmax = vmax
        if bias is not None:
            self.norm.bias = bias
        if contrast is not None:
            self.norm.contrast = contrast
        if clip_lo is not None:
            self.norm.clip_lo = clip_lo
        if clip_hi is not None:
            self.norm.clip_hi = clip_hi
        if stretch is not None:
            self.norm.stretch = stretch
        return self.norm

    def clear_norm(self):
        self.norm = None

    def _sync_style(self):
        for artist in self.artists:
            artist.set_zorder(self.zorder)
            artist.set_visible(self.visible and self.enabled)


class RGBImageLayerArtist(ImageLayerArtist):
    _property_set = ImageLayerArtist._property_set + \
        ['r', 'g', 'b', 'rnorm', 'gnorm', 'bnorm', 'color_visible']

    r = ChangedTrigger()
    g = ChangedTrigger()
    b = ChangedTrigger()
    rnorm = Pointer('_rnorm')
    gnorm = Pointer('_gnorm')
    bnorm = Pointer('_bnorm')

    def __init__(self, layer, ax, last_view=None):
        super(RGBImageLayerArtist, self).__init__(layer, ax)
        self.contrast_layer = 'green'
        self.layer_visible = dict(red=True, green=True, blue=True)
        self.last_view = last_view

    def set_norm(self, *args, **kwargs):
        spr = super(RGBImageLayerArtist, self).set_norm
        if self.contrast_layer == 'red':
            self.norm = self.rnorm
            self.rnorm = spr(*args, **kwargs)
        if self.contrast_layer == 'green':
            self.norm = self.gnorm
            self.gnorm = spr(*args, **kwargs)
        if self.contrast_layer == 'blue':
            self.norm = self.bnorm
            self.bnorm = spr(*args, **kwargs)

    @property
    def color_visible(self):
        return [self.layer_visible['red'], self.layer_visible['green'],
                self.layer_visible['blue']]

    @color_visible.setter
    def color_visible(self, value):
        self.layer_visible['red'] = value[0]
        self.layer_visible['green'] = value[1]
        self.layer_visible['blue'] = value[2]

    def update(self, view=None, transpose=False):
        self.clear()
        if self.r is None or self.g is None or self.b is None:
            return

        if view is None:
            view = self.last_view

        if view is None:
            return
        self.last_view = view

        views = view_cascade(self.layer, view)
        artists = []
        for v in views:
            extent = get_extent(v, transpose)
            # first argument = component. swap
            r = tuple([self.r] + list(v[1:]))
            g = tuple([self.g] + list(v[1:]))
            b = tuple([self.b] + list(v[1:]))
            r = self.layer[r]
            g = self.layer[g]
            b = self.layer[b]
            if transpose:
                r = r.T
                g = g.T
                b = b.T
            self.rnorm = self.rnorm or self._default_norm(r)
            self.gnorm = self.gnorm or self._default_norm(g)
            self.bnorm = self.bnorm or self._default_norm(b)
            if v is views[0]:
                self.rnorm.update_clip(small_view(self.layer, self.r))
                self.gnorm.update_clip(small_view(self.layer, self.g))
                self.bnorm.update_clip(small_view(self.layer, self.b))

            image = np.dstack((self.rnorm(r),
                               self.gnorm(g),
                               self.bnorm(b)))

            if not self.layer_visible['red']:
                image[:, :, 0] *= 0
            if not self.layer_visible['green']:
                image[:, :, 1] *= 0
            if not self.layer_visible['blue']:
                image[:, :, 2] *= 0

            artists.append(self._axes.imshow(image,
                                             interpolation='nearest',
                                             origin='lower',
                                             extent=extent, zorder=0))
            self._axes.set_aspect('equal', adjustable='datalim')
        self.artists = artists
        self._sync_style()


class SubsetImageLayerArtist(LayerArtist):

    def update(self, view, transpose=False):
        subset = self.layer
        self.clear()
        logging.debug("View into subset %s is %s", self.layer, view)

        try:
            mask = subset.to_mask(view[1:])
        except IncompatibleAttribute as exc:
            self.disable_invalid_attributes(*exc.args)
            return False
        logging.debug("View mask has shape %s", mask.shape)

        # shortcut for empty subsets
        if not mask.any():
            return

        if transpose:
            mask = mask.T

        extent = get_extent(view, transpose)
        r, g, b = color2rgb(self.layer.style.color)
        mask = np.dstack((r * mask, g * mask, b * mask, mask * .5))
        mask = (255 * mask).astype(np.uint8)
        self.artists = [self._axes.imshow(mask, extent=extent,
                                          interpolation='nearest',
                                          origin='lower',
                                          zorder=5, visible=self.visible)]


class ScatterLayerArtist(LayerArtist):
    xatt = ChangedTrigger()
    yatt = ChangedTrigger()
    _property_set = LayerArtist._property_set + ['xatt', 'yatt']

    def __init__(self, layer, ax):
        super(ScatterLayerArtist, self).__init__(layer, ax)
        self.emphasis = None  # an optional SubsetState of emphasized points

    def _recalc(self):
        self.clear()
        assert len(self.artists) == 0

        try:
            x = self.layer[self.xatt].ravel()
            y = self.layer[self.yatt].ravel()
        except IncompatibleAttribute as exc:
            self.disable_invalid_attributes(*exc.args)
            return False

        self.artists = self._axes.plot(x, y)
        return True

    def update(self, view=None, transpose=False):
        self._check_subset_state_changed()

        if self._changed:  # erase and make a new artist
            if not self._recalc():  # no need to update style
                return
            self._changed = False

        has_emph = False
        if self.emphasis is not None:
            try:
                s = Subset(self.layer.data)
                s.subset_state = self.emphasis
                if hasattr(self.layer, 'subset_state'):
                    s.subset_state &= self.layer.subset_state
                x = s[self.xatt].ravel()
                y = s[self.yatt].ravel()
                self.artists.extend(self._axes.plot(x, y))
                has_emph = True
            except IncompatibleAttribute:
                pass

        self._sync_style()
        if has_emph:
            self.artists[-1].set_mec('green')
            self.artists[-1].set_mew(2)
            self.artists[-1].set_alpha(1)

    def get_data(self):
        try:
            return self.layer[self.xatt].ravel(), self.layer[self.yatt].ravel()
        except IncompatibleAttribute:
            return np.array([]), np.array([])


class LayerArtistContainer(object):

    """A collection of LayerArtists"""

    def __init__(self):
        self.artists = []

    def _duplicate(self, artist):
        for a in self.artists:
            if type(a) == type(artist) and a.layer is artist.layer:
                return True
        return False

    def _check_duplicate(self, artist):
        """Raise an error if this artist is a duplicate"""
        if self._duplicate(artist):
            raise ValueError("Already have an artist for this type "
                             "and data")

    def append(self, artist):
        """Add a LayerArtist to this collection"""
        self._check_duplicate(artist)
        self.artists.append(artist)
        artist.zorder = max(a.zorder for a in self.artists) + 1

    def remove(self, artist):
        """Remove a LayerArtist from this collection

        :param artist: The artist to remove
        :type artist: :class:`LayerArtist`
        """
        try:
            self.artists.remove(artist)
            artist.clear()
        except ValueError:
            pass

    def pop(self, layer):
        """Remove all artists associated with a layer"""
        to_remove = [a for a in self.artists if a.layer is layer]
        for r in to_remove:
            self.remove(r)
        return to_remove

    @property
    def layers(self):
        """A list of the unique layers in the container"""
        return list(set([a.layer for a in self.artists]))

    def __len__(self):
        return len(self.artists)

    def __iter__(self):
        return iter(sorted(self.artists, key=lambda x: x.zorder))

    def __contains__(self, item):
        if isinstance(item, LayerArtist):
            return item in self.artists
        return any(item is a.layer for a in self.artists)

    def __getitem__(self, layer):
        if isinstance(layer, int):
            return self.artists[layer]
        return [a for a in self.artists if a.layer is layer]


class HistogramLayerArtist(LayerArtist):
    _property_set = LayerArtist._property_set + 'lo hi nbins xlog'.split()

    lo = ChangedTrigger(0)
    hi = ChangedTrigger(1)
    nbins = ChangedTrigger(10)
    xlog = ChangedTrigger(False)

    def __init__(self, layer, axes):
        super(HistogramLayerArtist, self).__init__(layer, axes)
        self.ylog = False
        self.cumulative = False
        self.normed = False
        self.y = np.array([])
        self.x = np.array([])
        self._y = np.array([])

        self._scale_state = None

    def has_patches(self):
        return len(self.artists) > 0

    def get_data(self):
        return self.x, self.y

    def clear(self):
        super(HistogramLayerArtist, self).clear()
        self.x = np.array([])
        self.y = np.array([])
        self._y = np.array([])

    def _calculate_histogram(self):
        """Recalculate the histogram, creating new patches"""
        self.clear()
        try:
            data = self.layer[self.att].ravel()
            if not np.isfinite(data).any():
                return False
        except IncompatibleAttribute as exc:
            self.disable_invalid_attributes(*exc.args)
            return False

        if data.size == 0:
            return

        if self.lo > np.nanmax(data) or self.hi < np.nanmin(data):
            return
        if self.xlog:
            data = np.log10(data)
            rng = [np.log10(self.lo), np.log10(self.hi)]
        else:
            rng = self.lo, self.hi
        nbinpatch = self._axes.hist(data,
                                    bins=self.nbins,
                                    range=rng)
        self._y, self.x, self.artists = nbinpatch
        return True

    def _scale_histogram(self):
        """Modify height of bins to match ylog, cumulative, and norm"""
        if self.x.size == 0:
            return

        y = self._y.astype(np.float)
        dx = self.x[1] - self.x[0]
        if self.normed:
            div = y.sum() * dx
            if div == 0:
                div = 1
            y /= div
        if self.cumulative:
            y = y.cumsum()
            y /= y.max()

        self.y = y
        bottom = 0 if not self.ylog else 1e-100

        for a, y in zip(self.artists, y):
            a.set_height(y)
            x, y = a.get_xy()
            a.set_xy((x, bottom))

    def _check_scale_histogram(self):
        """
        If needed, rescale histogram to match cumulative/log/normed state.
        """
        state = (self.normed, self.ylog, self.cumulative)
        if state == self._scale_state:
            return
        self._scale_state = state
        self._scale_histogram()

    def update(self, view=None):
        """Sync plot.

        The _change flag tracks whether the histogram needs to be
        recalculated. If not, the properties of the existing
        artists are updated
        """
        self._check_subset_state_changed()
        if self._changed:
            if not self._calculate_histogram():
                return
            self._changed = False
            self._scale_state = None
        self._check_scale_histogram()
        self._sync_style()

    def _sync_style(self):
        """Update visual properties"""
        style = self.layer.style
        for artist in self.artists:
            artist.set_facecolor(style.color)
            artist.set_alpha(style.alpha)
            artist.set_zorder(self.zorder)
            artist.set_visible(self.visible and self.enabled)

########NEW FILE########
__FILENAME__ = profile_viewer
import numpy as np
from matplotlib.transforms import blended_transform_factory

from ..core.callback_property import CallbackProperty, add_callback


PICK_THRESH = 30  # pixel distance threshold for picking


class Grip(object):

    def __init__(self, viewer, artist=True):
        self.viewer = viewer
        self.enabled = True

        self.artist = None
        if artist:
            self.artist = self._artist_factory()

    def remove(self):
        raise NotImplementedError()

    def _artist_factory(self):
        raise NotImplementedError()

    def pick_dist(self, x, y):
        """
        Return the distance, in pixels,
        between a point in (x,y) data space and
        the grip
        """
        raise NotImplementedError()

    def dblclick(self, x, y):
        """Respond to a double-click event

        Default is to ignore
        """
        pass

    def select(self, x, y):
        """
        Process a selection event (click) at x,y
        """
        raise NotImplementedError()

    def drag(self, x, y):
        """
        Process a drag to x, y
        """
        raise NotImplementedError()

    def release(self):
        """
        Process a release
        """
        raise NotImplementedError()

    def disable(self):
        self.enabled = False
        if self.artist is not None:
            self.artist.set_visible(False)
            self.viewer.axes.figure.canvas.draw()

    def enable(self):
        self.enabled = True
        if self.artist is not None:
            self.artist.set_visible(True)
            self.viewer.axes.figure.canvas.draw()


class ValueGrip(Grip):
    value = CallbackProperty(None)

    def __init__(self, viewer, artist=True):
        super(ValueGrip, self).__init__(viewer, artist)
        self._drag = False

    def _artist_factory(self):
        return ValueArtist(self)

    def dblclick(self, x, y):
        self.value = x

    def pick_dist(self, x, y):
        xy = [[x, y], [self.value, y]]
        xypix = self.viewer.axes.transData.transform(xy)
        return abs(xypix[1, 0] - xypix[0, 0])

    def select(self, x, y):
        if self.pick_dist(x, y) > PICK_THRESH:
            return
        self._drag = True

    def drag(self, x, y):
        if self._drag:
            self.value = x

    def release(self):
        self._drag = False


class RangeGrip(Grip):
    range = CallbackProperty((None, None))

    def __init__(self, viewer):
        super(RangeGrip, self).__init__(viewer)

        # track state during drags
        self._move = None
        self._ref = None
        self._refx = None
        self._refnew = None

    def _artist_factory(self):
        return RangeArtist(self)

    def pick_dist(self, x, y):
        xy = np.array([[x, y],
                       [self.range[0], y],
                       [self.range[1], y],
                       [sum(self.range) / 2, y]])
        xypix = self.viewer.axes.transData.transform(xy)
        dx = np.abs(xypix[1:] - xypix[0])[:, 0]
        return min(dx)

    def select(self, x, y):
        if self.pick_dist(x, y) > PICK_THRESH:
            return self.new_select(x, y)

        cen = sum(self.range) / 2.
        wid = self.range[1] - self.range[0]
        if x < cen - wid / 4.:
            self._move = 'left'
        elif x < cen + wid / 4.:
            self._move = 'center'
            self._ref = self.range
            self._refx = x
        else:
            self._move = 'right'

    def new_select(self, x, y):
        """
        Begin a selection in "new range" mode.
        In this mode, the previous grip position is ignored,
        and the new range is defined by the select/release positions
        """
        self._refnew = x
        self.range = (x, x)

    def new_drag(self, x, y):
        """
        Drag the selection in "new mode"
        """
        if self._refnew is not None:
            self._set_range(self._refnew, x)

    def drag(self, x, y):
        if self._refnew is not None:
            return self.new_drag(x, y)

        if self._move == 'left':
            if x > self.range[1]:
                self._move = 'right'
            self._set_range(x, self.range[1])

        elif self._move == 'center':
            dx = (x - self._refx)
            self._set_range(self._ref[0] + dx, self._ref[1] + dx)
        else:
            if x < self.range[0]:
                self._move = 'left'
            self._set_range(self.range[0], x)

    def _set_range(self, lo, hi):
        self.range = min(lo, hi), max(lo, hi)

    def release(self):
        self._move = None
        self._ref = None
        self._refx = None
        self._refnew = None


class ValueArtist(object):

    def __init__(self, grip, **kwargs):
        self.grip = grip
        add_callback(grip, 'value', self._update)
        ax = self.grip.viewer.axes

        kwargs.setdefault('lw', 2)
        kwargs.setdefault('alpha', 0.5)
        kwargs.setdefault('c', '#ffb304')
        trans = blended_transform_factory(ax.transData, ax.transAxes)
        self._line, = ax.plot([grip.value, grip.value], [0, 1],
                              transform=trans, **kwargs)

    def _update(self, value):
        self._line.set_xdata([value, value])
        self._line.axes.figure.canvas.draw()

    def set_visible(self, visible):
        self._line.set_visible(visible)


class RangeArtist(object):

    def __init__(self, grip, **kwargs):
        self.grip = grip
        add_callback(grip, 'range', self._update)
        ax = grip.viewer.axes
        trans = blended_transform_factory(ax.transData, ax.transAxes)

        kwargs.setdefault('lw', 2)
        kwargs.setdefault('alpha', 0.5)
        kwargs.setdefault('c', '#ffb304')
        self._line, = ax.plot(self.x, self.y, transform=trans, **kwargs)

    @property
    def x(self):
        l, r = self.grip.range
        return [l, l, l, r, r, r]

    @property
    def y(self):
        return [0, 1, .5, .5, 0, 1]

    def _update(self, rng):
        self._line.set_xdata(self.x)
        self._line.axes.figure.canvas.draw()

    def set_visible(self, visible):
        self._line.set_visible(visible)


def _build_axes(figure):

    # tight-layout clobbers manual positioning
    try:
        figure.set_tight_layout(False)
    except AttributeError:  # old MPL
        pass

    ax2 = figure.add_subplot(122)
    ax1 = figure.add_subplot(121, sharex=ax2)

    return ax1, ax2


class ProfileViewer(object):
    value_cls = ValueGrip
    range_cls = RangeGrip

    def __init__(self, figure):
        self.axes, self.resid_axes = _build_axes(figure)

        self._artist = None
        self._resid_artist = None
        self._x = self._xatt = self._y = self._yatt = None
        self._resid = None
        self.connect()

        self._fit_artists = []
        self.active_grip = None  # which grip should receive events?
        self.grips = []
        self._xlabel = ''

    def set_xlabel(self, xlabel):
        self._xlabel = xlabel

    def autoscale_ylim(self):
        x, y = self._x, self._y
        xlim = self.axes.get_xlim()
        mask = (xlim[0] <= x) & (x <= xlim[1])
        ymask = y[mask]
        if ymask.size == 0:
            return

        ylim = np.nan_to_num([np.nanmin(ymask), np.nanmax(ymask)])
        self.axes.set_ylim(ylim[0], ylim[1] + .05 * (ylim[1] - ylim[0]))

        if self._resid is None:
            return
        assert self._resid.size == y.size

        ymask = self._resid[mask]
        ylim = np.nan_to_num([np.nanmin(ymask), np.nanmax(ymask)])
        diff = .05 * (ylim[1] - ylim[0])
        self.resid_axes.set_ylim(ylim[0] - diff, ylim[1] + diff)

    def _relayout(self):
        if self._resid_artist is not None:
            self.axes.set_position([0.1, .35, .88, .6])
            self.resid_axes.set_position([0.1, .15, .88, .2])
            self.resid_axes.set_xlabel(self._xlabel)
            self.resid_axes.set_visible(True)
            self.axes.set_xlabel('')
            [t.set_visible(False) for t in self.axes.get_xticklabels()]
        else:
            self.resid_axes.set_visible(False)
            self.axes.set_position([0.1, .15, .88, .83])
            self.axes.set_xlabel(self._xlabel)
            [t.set_visible(True) for t in self.axes.get_xticklabels()]

    def set_profile(self, x, y, xatt=None, yatt=None, **kwargs):
        """
        Set a new line profile

        :param x: X-coordinate data
        :type x: array-like

        :param y: Y-coordinate data
        :type y: array-like

        :param xatt: ComponentID associated with X axis
        :type xatt: :class:`~glue.core.data.CompoenntID`

        :param yatt: ComponentID associated with Y axis
        :type yatt: :class:`~glue.core.data.CompoenntID`

        Extra kwargs are passed to matplotlib.plot, to
        customize plotting

        Returns the created MPL artist
        """
        self._clear_fit()
        self._x = np.asarray(x).ravel()
        self._xatt = xatt
        self._y = np.asarray(y).ravel()
        self._yatt = yatt
        if self._artist is not None:
            self._artist.remove()

        kwargs.setdefault('drawstyle', 'steps-mid')

        self._artist = self.axes.plot(x, y, **kwargs)[0]
        self._relayout()
        self._redraw()

        return self._artist

    def _clear_fit(self):
        for a in self._fit_artists:
            a.remove()
        self._fit_artists = []
        if self._resid_artist is not None:
            self._resid_artist.remove()
            self._resid_artist = None

    def connect(self):
        connect = self.axes.figure.canvas.mpl_connect
        self._down_id = connect('button_press_event', self._on_down)
        self._up_id = connect('button_release_event', self._on_up)
        self._move_id = connect('motion_notify_event', self._on_move)

    def disconnect(self):
        off = self.axes.figure.canvas.mpl_disconnect
        self._down_id = off(self._down_id)
        self._up_id = off(self._up_id)
        self._move_id = off(self._move_id)

    def _on_down(self, event):
        if not event.inaxes:
            return

        if event.dblclick:
            if self.active_grip is not None:
                self.active_grip.dblclick(event.xdata, event.ydata)
            return

        if self.active_grip is not None and self.active_grip.enabled:
            self.active_grip.select(event.xdata, event.ydata)

    def _on_up(self, event):
        if not event.inaxes:
            return
        if self.active_grip is None or not self.active_grip.enabled:
            return

        self.active_grip.release()

    def _on_move(self, event):
        if not event.inaxes or event.button != 1:
            return
        if self.active_grip is None or not self.active_grip.enabled:
            return

        self.active_grip.drag(event.xdata, event.ydata)

    def _redraw(self):
        self.axes.figure.canvas.draw()

    def profile_data(self, xlim=None):
        if self._x is None or self._y is None:
            raise ValueError("Must set profile first")

        x = self._x
        y = self._y
        if xlim is not None:
            mask = (min(xlim) <= x) & (x <= max(xlim))
            x = x[mask]
            y = y[mask]

        return x, y

    def fit(self, fitter, xlim=None):
        try:
            x, y = self.profile_data(xlim)
            dy = None
        except ValueError:
            raise ValueError("Must set profile before fitting")

        result = fitter.build_and_fit(x, y)

        return result, x, y, dy

    def plot_fit(self, fitter, fit_result):
        self._clear_fit()
        x = self._x
        y = fitter.predict(fit_result, x)
        self._fit_artists = fitter.plot(fit_result, self.axes, x)
        resid = self._y - y
        self._resid = resid
        self._resid_artist, = self.resid_axes.plot(x, resid, 'k')
        self.autoscale_ylim()
        self._relayout()

    def new_value_grip(self, callback=None):
        """
        Create and return new ValueGrip

        :param callback: A callback function to be invoked
        whenever the grip.value property changes
        """
        result = self.value_cls(self)
        result.value = self._center[0]

        if callback is not None:
            add_callback(result, 'value', callback)
        self.grips.append(result)
        self.active_grip = result
        return result

    def new_range_grip(self, callback=None):
        """
        Create and return new RangeGrip

        :param callback: A callback function to be invoked
        whenever the grip.range property changes
        """
        result = self.range_cls(self)
        center = self._center[0]
        width = self._width
        result.range = center - width / 4, center + width / 4

        if callback is not None:
            add_callback(result, 'range', callback)

        self.grips.append(result)
        self.active_grip = result

        return result

    @property
    def _center(self):
        """Return the data coordinates of the axes center, as (x, y)"""
        xy = self.axes.transAxes.transform([.5, .5])
        xy = self.axes.transData.inverted().transform(xy)
        return tuple(xy.ravel())

    @property
    def _width(self):
        """Return the X-width of axes in data units"""
        xlim = self.axes.get_xlim()
        return xlim[1] - xlim[0]

    def pick_grip(self, x, y):
        """
        Given a coordinate in Data units,
        return the enabled Grip object nearest
        that point, or None if none are nearby
        """
        grips = [h for h in self.grips if h.enabled]
        if not grips:
            return

        dist, grip = min((h.pick_dist(x, y), h)
                         for h in grips)

        if dist < PICK_THRESH:
            return grip

########NEW FILE########
__FILENAME__ = scatter_client
import logging
from functools import partial

import numpy as np
from matplotlib.ticker import AutoLocator, MaxNLocator, LogLocator
from matplotlib.ticker import LogFormatterMathtext, ScalarFormatter, FuncFormatter

from ..core.client import Client
from ..core.data import Data, IncompatibleAttribute, ComponentID, CategoricalComponent
from ..core.subset import RoiSubsetState
from ..core.roi import PolygonalROI
from ..core.util import relim, lookup_class
from ..core.edit_subset_mode import EditSubsetMode
from .viz_client import init_mpl
from .layer_artist import ScatterLayerArtist, LayerArtistContainer
from .util import visible_limits, update_ticks
from ..core.callback_property import (CallbackProperty, add_callback,
                                      delay_callback)


class ScatterClient(Client):

    """
    A client class that uses matplotlib to visualize tables as scatter plots.
    """
    xmin = CallbackProperty(0)
    xmax = CallbackProperty(1)
    ymin = CallbackProperty(0)
    ymax = CallbackProperty(1)
    ylog = CallbackProperty(False)
    xlog = CallbackProperty(False)
    yflip = CallbackProperty(False)
    xflip = CallbackProperty(False)
    xatt = CallbackProperty()
    yatt = CallbackProperty()
    jitter = CallbackProperty()

    def __init__(self, data=None, figure=None, axes=None,
                 artist_container=None):
        """
        Create a new ScatterClient object

        :param data: :class:`~glue.core.DataCollection` to use

        :param figure:
           Which matplotlib figure instance to draw to. One will be created if
           not provided

        :param axes:
           Which matplotlib axes instance to use. Will be created if necessary
        """
        Client.__init__(self, data=data)
        figure, axes = init_mpl(figure, axes)
        self.artists = artist_container
        if self.artists is None:
            self.artists = LayerArtistContainer()

        self._layer_updated = False  # debugging
        self._xset = False
        self._yset = False
        self.axes = axes

        self._connect()
        self._set_limits()

    def is_layer_present(self, layer):
        """ True if layer is plotted """
        return layer in self.artists

    def get_layer_order(self, layer):
        """If layer exists as a single artist, return its zorder.
        Otherwise, return None"""
        artists = self.artists[layer]
        if len(artists) == 1:
            return artists[0].zorder
        else:
            return None

    @property
    def layer_count(self):
        return len(self.artists)

    def _connect(self):
        add_callback(self, 'xlog', self._set_xlog)
        add_callback(self, 'ylog', self._set_ylog)

        add_callback(self, 'xflip', self._set_limits)
        add_callback(self, 'yflip', self._set_limits)
        add_callback(self, 'xmin', self._set_limits)
        add_callback(self, 'xmax', self._set_limits)
        add_callback(self, 'ymin', self._set_limits)
        add_callback(self, 'ymax', self._set_limits)
        add_callback(self, 'xatt', partial(self._set_xydata, 'x'))
        add_callback(self, 'yatt', partial(self._set_xydata, 'y'))
        add_callback(self, 'jitter', self._jitter)
        self.axes.figure.canvas.mpl_connect('draw_event',
                                            lambda x: self._pull_properties())

    def _set_limits(self, *args):

        xlim = min(self.xmin, self.xmax), max(self.xmin, self.xmax)
        if self.xflip:
            xlim = xlim[::-1]
        ylim = min(self.ymin, self.ymax), max(self.ymin, self.ymax)
        if self.yflip:
            ylim = ylim[::-1]

        xold = self.axes.get_xlim()
        yold = self.axes.get_ylim()
        self.axes.set_xlim(xlim)
        self.axes.set_ylim(ylim)
        if xlim != xold or ylim != yold:
            self._redraw()

    def plottable_attributes(self, layer, show_hidden=False):
        data = layer.data
        comp = data.components if show_hidden else data.visible_components
        return [c for c in comp if
                data.get_component(c).numeric]

    def add_layer(self, layer):
        """ Adds a new visual layer to a client, to display either a dataset
        or a subset. Updates both the client data structure and the
        plot.

        Returns the created layer artist

        :param layer: the layer to add
        :type layer: :class:`~glue.core.Data` or :class:`~glue.core.Subset`
        """
        if layer.data not in self.data:
            raise TypeError("Layer not in data collection")
        if layer in self.artists:
            return self.artists[layer][0]

        result = ScatterLayerArtist(layer, self.axes)
        self.artists.append(result)
        self._update_layer(layer)
        self._ensure_subsets_added(layer)
        return result

    def _ensure_subsets_added(self, layer):
        if not isinstance(layer, Data):
            return
        for subset in layer.subsets:
            self.add_layer(subset)

    def _visible_limits(self, axis):
        """Return the min-max visible data boundaries for given axis"""
        return visible_limits(self.artists, axis)

    def _snap_xlim(self):
        """
        Reset the plotted x rng to show all the data
        """
        is_log = self.xlog
        rng = self._visible_limits(0)
        if rng is None:
            return
        rng = relim(rng[0], rng[1], is_log)
        if self.xflip:
            rng = rng[::-1]
        self.axes.set_xlim(rng)
        self._pull_properties()

    def _snap_ylim(self):
        """
        Reset the plotted y rng to show all the data
        """
        rng = [np.infty, -np.infty]
        is_log = self.ylog

        rng = self._visible_limits(1)
        if rng is None:
            return
        rng = relim(rng[0], rng[1], is_log)

        if self.yflip:
            rng = rng[::-1]
        self.axes.set_ylim(rng)
        self._pull_properties()

    def snap(self):
        """Rescale axes to fit the data"""
        self._snap_xlim()
        self._snap_ylim()
        self._redraw()

    def set_visible(self, layer, state):
        """ Toggle a layer's visibility

        :param layer: which layer to modify
        :type layer: class:`~glue.core.Data` or :class:`~glue.coret.Subset`

        :param state: True to show. false to hide
        :type state: boolean
        """
        if layer not in self.artists:
            return
        for a in self.artists[layer]:
            a.visible = state
        self._redraw()

    def is_visible(self, layer):
        if layer not in self.artists:
            return False
        return any(a.visible for a in self.artists[layer])

    def _set_xydata(self, coord, attribute, snap=True):
        """ Redefine which components get assigned to the x/y axes

        :param coord: 'x' or 'y'
           Which axis to reassign
        :param attribute:
           Which attribute of the data to use.
        :type attribute: core.data.ComponentID
        :param snap:
           If True, will rescale x/y axes to fit the data
        :type snap: bool
        """

        if coord not in ('x', 'y'):
            raise TypeError("coord must be one of x,y")
        if not isinstance(attribute, ComponentID):
            raise TypeError("attribute must be a ComponentID")

        # update coordinates of data and subsets
        if coord == 'x':
            new_add = not self._xset
            self.xatt = attribute
            self._xset = self.xatt is not None
        elif coord == 'y':
            new_add = not self._yset
            self.yatt = attribute
            self._yset = self.yatt is not None

        # update plots
        map(self._update_layer, self.artists.layers)

        if coord == 'x' and snap:
            self._snap_xlim()
            if new_add:
                self._snap_ylim()
        elif coord == 'y' and snap:
            self._snap_ylim()
            if new_add:
                self._snap_xlim()

        self._update_axis_labels()
        self._pull_properties()
        self._redraw()

    def apply_roi(self, roi):
        # every editable subset is updated
        # using specified ROI
        subset_state = RoiSubsetState()
        subset_state.xatt = self.xatt
        subset_state.yatt = self.yatt
        x, y = roi.to_polygon()
        subset_state.roi = PolygonalROI(x, y)
        mode = EditSubsetMode()
        visible = [d for d in self._data if self.is_visible(d)]
        focus = visible[0] if len(visible) > 0 else None
        mode.update(self._data, subset_state, focus_data=focus)

    def _set_xlog(self, state):
        """ Set the x axis scaling

        :param state:
            The new scaling for the x axis
        :type state: string ('log' or 'linear')
        """
        mode = 'log' if state else 'linear'
        lim = self.axes.get_xlim()
        self.axes.set_xscale(mode)

        # Rescale if switching to log with negative bounds
        if state and min(lim) <= 0:
            self._snap_xlim()

        self._redraw()

    def _set_ylog(self, state):
        """ Set the y axis scaling

        :param state: The new scaling for the y axis
        :type state: string ('log' or 'linear')
        """
        mode = 'log' if state else 'linear'
        lim = self.axes.get_ylim()
        self.axes.set_yscale(mode)
        # Rescale if switching to log with negative bounds
        if state and min(lim) <= 0:
            self._snap_ylim()

        self._redraw()

    def _remove_data(self, message):
        """Process DataCollectionDeleteMessage"""
        for s in message.data.subsets:
            self.delete_layer(s)
        self.delete_layer(message.data)

    def _remove_subset(self, message):
        self.delete_layer(message.subset)

    def delete_layer(self, layer):
        if layer not in self.artists:
            return
        self.artists.pop(layer)
        self._redraw()
        assert not self.is_layer_present(layer)

    def _update_data(self, message):
        data = message.sender
        self._update_layer(data)

    def _redraw(self):
        self.axes.figure.canvas.draw()

    def _jitter(self, *args):

        for attribute in [self.xatt, self.yatt]:
            if attribute is not None:
                for data in self.data:
                    try:
                        comp = data.get_component(attribute)
                        comp.jitter(method=self.jitter)
                    except (IncompatibleAttribute, NotImplementedError):
                        continue

    def _update_axis_labels(self, *args):
        self.axes.set_xlabel(self.xatt)
        self.axes.set_ylabel(self.yatt)
        if self.xatt is not None:
            update_ticks(self.axes, 'x',
                         list(self._get_data_components('x')),
                         self.xlog)

        if self.yatt is not None:
            update_ticks(self.axes, 'y',
                         list(self._get_data_components('y')),
                         self.xlog)

    def _add_subset(self, message):
        subset = message.sender
        # only add subset if data layer present
        if subset.data not in self.artists:
            return
        subset.do_broadcast(False)
        self.add_layer(subset)
        subset.do_broadcast(True)

    def add_data(self, data):
        result = self.add_layer(data)
        for subset in data.subsets:
            self.add_layer(subset)
        return result

    @property
    def data(self):
        """The data objects in the scatter plot"""
        return list(self._data)

    def _get_data_components(self, coord):
        """ Returns the components for each dataset for x and y axes.
        """
        if coord == 'x':
            attribute = self.xatt
        elif coord == 'y':
            attribute = self.yatt
        else:
            raise TypeError('coord must be x or y')

        for data in self._data:
            try:
                yield data.get_component(attribute)
            except IncompatibleAttribute:
                pass

    def _check_categorical(self, attribute):
        """ A simple function to figure out if an attribute is categorical.
        :param attribute: a core.Data.ComponentID
        :return: True iff the attribute represents a CategoricalComponent
        """

        for data in self._data:
            try:
                comp = data.get_component(attribute)
                if isinstance(comp, CategoricalComponent):
                    return True
            except IncompatibleAttribute:
                pass
        return False

    def _update_subset(self, message):
        self._update_layer(message.sender)

    def restore_layers(self, layers, context):
        """ Re-generate a list of plot layers from a glue-serialized list"""
        for l in layers:
            cls = lookup_class(l.pop('_type'))
            if cls != ScatterLayerArtist:
                raise ValueError("Scatter client cannot restore layer of type "
                                 "%s" % cls)
            props = dict((k, context.object(v)) for k, v in l.items())
            layer = self.add_layer(props['layer'])
            layer.properties = props

    def _update_layer(self, layer):
        """ Update both the style and data for the requested layer"""
        if self.xatt is None or self.yatt is None:
            return

        if layer not in self.artists:
            return

        self._layer_updated = True
        for art in self.artists[layer]:
            art.xatt = self.xatt
            art.yatt = self.yatt
            art.update()
        self._redraw()

    def _pull_properties(self):
        xlim = self.axes.get_xlim()
        ylim = self.axes.get_ylim()
        xsc = self.axes.get_xscale()
        ysc = self.axes.get_yscale()

        xflip = (xlim[1] < xlim[0])
        yflip = (ylim[1] < ylim[0])

        with delay_callback(self, 'xmin', 'xmax', 'xflip', 'xlog'):
            self.xmin = min(xlim)
            self.xmax = max(xlim)
            self.xflip = xflip
            self.xlog = (xsc == 'log')

        with delay_callback(self, 'ymin', 'ymax', 'yflip', 'ylog'):
            self.ymin = min(ylim)
            self.ymax = max(ylim)
            self.yflip = yflip
            self.ylog = (ysc == 'log')

########NEW FILE########
__FILENAME__ = test_ds9norm
import numpy as np
import pytest

from ..ds9norm import *


def test_log_warp():
    x = np.array([0, 1, 10, 100, 101])
    y = log_warp(x, 1, 100, .5, 1)
    yexp = np.array([0, 0, .654, 1, 1])
    np.testing.assert_array_almost_equal(y, yexp, 3)


def test_sqrt_warp():
    x = np.array([0, 1, 10, 100, 101])
    y = sqrt_warp(x, 1, 100, .5, 1)
    yexp = np.array([0, 0, .3015, 1, 1])
    np.testing.assert_array_almost_equal(y, yexp, 3)


def test_pow_warp():
    x = np.array([0, 1, 10, 100, 101])
    y = pow_warp(x, 1, 100, .5, 1)
    yexp = np.array([0, 0, .00087, 1, 1])
    np.testing.assert_array_almost_equal(y, yexp, 3)


def test_squared_warp():
    x = np.array([0, 1, 10, 100, 101])
    y = squared_warp(x, 1, 100, .5, 1)
    yexp = np.array([0, 0, .008264, 1, 1])
    np.testing.assert_array_almost_equal(y, yexp, 3)


def test_asinh_warp():
    x = np.array([0, 1, 10, 100, 101])
    y = asinh_warp(x, 1, 100, .5, 1)
    yexp = np.array([0, 0, .27187, 1, 1])
    np.testing.assert_array_almost_equal(y, yexp, 3)


def test_linear_warp():
    x = np.array([0, 1, 10, 100, 101])
    y = linear_warp(x, 1, 100, .5, 1)
    yexp = np.array([0, 0, 9. / 99., 1, 1])
    np.testing.assert_array_almost_equal(y, yexp, 3)


def test_bias():
    x = np.array([0, .4, .5, .6, 1])

    y = cscale(x.copy(), .5, 1)
    np.testing.assert_array_almost_equal(x, y)

    y = cscale(x.copy(), .5, 2)
    yexp = np.array([0, .3, .5, .7, 1])
    np.testing.assert_array_almost_equal(y, yexp)

    y = cscale(x.copy(), .5, 0)
    yexp = np.array([.5, .5, .5, .5, .5])
    np.testing.assert_array_almost_equal(y, yexp)

    y = cscale(x.copy(), .5, 0)
    yexp = np.array([.5, .5, .5, .5, .5])
    np.testing.assert_array_almost_equal(y, yexp)

    y = cscale(x.copy(), .4, 1)
    yexp = np.array([.1, .5, .6, .7, 1])
    np.testing.assert_array_almost_equal(y, yexp)

    y = cscale(x.copy(), .6, 1)
    yexp = np.array([0, .3, .4, .5, .9])
    np.testing.assert_array_almost_equal(y, yexp)


class TestDS9Normalize(object):

    def setup_method(self, method):
        self.norm = DS9Normalize()

    def test_input_unmodified(self):
        x = np.array([1, 2, 3])
        self.norm.contrast = 100
        y = self.norm(x)
        assert np.abs(x - y).max() > .1
        np.testing.assert_array_almost_equal(x, [1, 2, 3])

    def test_call_default(self):
        x = np.array([1, 2, 3])
        np.testing.assert_array_almost_equal(self.norm(x), [0, .5, 1])

    def test_call_invert(self):
        x = np.array([1, 2, 3])
        self.norm.vmin = 3
        self.norm.vmax = 1
        np.testing.assert_array_almost_equal(self.norm(x), [1, .5, 0])

    def test_invalid_stretch(self):
        with pytest.raises(ValueError) as exc:
            self.norm.stretch = 'invalid'
        assert exc.value.args[0].startswith("Invalid stretch")

########NEW FILE########
__FILENAME__ = test_histogram_client
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest

from mock import MagicMock

from ..histogram_client import HistogramClient
from ..layer_artist import HistogramLayerArtist

from ...core.data_collection import DataCollection
from ...core.exceptions import IncompatibleDataException
from ...core.data import Data, CategoricalComponent
from ...core.subset import RangeSubsetState

from .util import renderless_figure

FIGURE = renderless_figure()


class TestException(Exception):
    pass


class TestHistogramClient(object):

    def setup_method(self, method):
        self.data = Data(x=[0, 0, 0, 1, 2, 3, 3, 10, 20],
                         y=[-1, -1, -1, -2, -2, -2, -3, -5, -7])
        self.subset = self.data.new_subset()
        self.collect = DataCollection(self.data)
        self.client = HistogramClient(self.collect, FIGURE)
        self.axes = self.client.axes
        FIGURE.canvas.draw = MagicMock()
        assert FIGURE.canvas.draw.call_count == 0

    def draw_count(self):
        return self.axes.figure.canvas.draw.call_count

    def layer_drawn(self, layer):
        return layer in self.client._artists and \
            all(a.visible for a in self.client._artists[layer]) and \
            all(len(a.artists) > 0 for a in self.client._artists[layer])

    def layer_present(self, layer):
        return layer in self.client._artists

    def assert_autoscaled(self):
        yra = self.client.axes.get_ylim()
        datara = [99999, -99999]
        for a in self.client._artists:
            if a.y.size > 0:
                datara[0] = min(datara[0], a.y.min())
                datara[1] = max(datara[1], a.y.max())

        assert yra[0] <= datara[0]
        assert yra[1] >= datara[1]

    def test_empty_on_creation(self):
        assert self.data not in self.client._artists

    def test_add_layer(self):
        self.client.add_layer(self.data)
        assert self.layer_present(self.data)
        assert not self.layer_drawn(self.data)

        self.client.set_component(self.data.components[0])
        assert self.layer_drawn(self.data)

    def test_add_invalid_layer_raises(self):
        self.collect.remove(self.data)
        with pytest.raises(IncompatibleDataException):
            self.client.add_layer(self.data)

    def test_add_subset_auto_adds_data(self):
        subset = self.data.new_subset()
        self.client.add_layer(subset)
        assert self.layer_present(self.data)
        assert self.layer_present(subset)

        self.client.set_component(self.data.components[0])
        assert self.layer_drawn(self.data)

    def test_double_add_ignored(self):
        self.client.add_layer(self.data)
        art = self.client._artists[self.data]
        self.client.add_layer(self.data)
        assert self.client._artists[self.data] == art

    def test_add_data_auto_adds_subsets(self):
        s = self.data.new_subset()
        self.client.add_layer(self.data)
        assert self.layer_present(s)

    def test_data_removal(self):
        self.client.add_layer(self.data)
        self.client.remove_layer(self.data)
        assert not (self.layer_present(self.data))

    def test_data_removal_removes_subsets(self):
        self.client.add_layer(self.data)
        self.client.remove_layer(self.data)
        self.data.new_subset()
        assert len(self.data.subsets) > 0

        for subset in self.data.subsets:
            assert not (self.layer_present(subset))

    def test_layer_updates_on_data_add(self):
        self.client.add_layer(self.data)
        for s in self.data.subsets:
            assert s in self.client._artists

    def test_set_component_updates_component(self):
        self.client.add_layer(self.data)
        comp = self.data.find_component_id('uniform')
        self.client.set_component(comp)
        assert self.client._component is comp

    def test_set_component_redraws(self):
        self.client.add_layer(self.data)
        comp = self.data.id['x']
        comp2 = self.data.id['y']
        self.client.set_component(comp)
        ct0 = self.draw_count()
        self.client.set_component(comp2)
        assert self.draw_count() > ct0

    def test_remove_not_present_ignored(self):
        self.client.remove_layer(self.data)

    def test_set_visible_external_data(self):
        self.client.set_layer_visible(None, False)

    def test_get_visible_external_data(self):
        assert not (self.client.is_layer_visible(None))

    def test_set_visible(self):
        self.client.add_layer(self.data)
        self.client.set_layer_visible(self.data, False)
        assert not (self.client.is_layer_visible(self.data))

    def test_draw_histogram_one_layer(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.find_component_id('uniform'))

    def test_draw_histogram_subset_hidden(self):
        self.client.add_layer(self.data)
        s = self.data.new_subset()
        self.client.set_layer_visible(s, False)
        self.client.set_component(self.data.find_component_id('uniform'))

    def test_draw_histogram_two_layers(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.find_component_id('uniform'))

    def test_update_property_set_triggers_redraw(self):
        self.client.add_layer(self.data)
        ct = self.draw_count()
        self.client.normed ^= True
        assert self.draw_count() > ct

    @pytest.mark.parametrize(('prop'), ['normed', 'cumulative'])
    def test_set_boolean_property(self, prop):
        """Boolean properties should sync with artists"""
        self.client.add_layer(self.data)
        self.client.set_component(self.data.components[0])

        setattr(self.client, prop, False)
        for a in self.client._artists:
            assert not getattr(a, prop)

        setattr(self.client, prop, True)
        for a in self.client._artists:
            assert getattr(a, prop)

    def test_set_nbins(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.components[0])

        self.client.nbins = 100
        for a in self.client._artists[self.data]:
            assert a.nbins == 100
            assert a.x.size == 100 + 1

    def test_autoscale(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.components[0])
        self.client.axes.set_ylim(0, .1)
        self.client.autoscale = False
        self.client.autoscale = True
        self.assert_autoscaled()

    def test_xlimits(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.components[0])

        self.client.xlimits = -12, 20
        assert self.client.xlimits == (-12, 20)
        for a in self.client._artists[self.data]:
            assert a.lo == -12
            assert a.hi == 20

    def test_set_xlimits_out_of_data_range(self):
        """Setting xlimits outside of range shouldn't crash"""
        self.client.add_layer(self.data)
        self.client.set_component(self.data.components[0])

        self.client.xlimits = 100, 200
        self.client.xlimits = -200, -100

    def test_component_property(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.components[0])
        assert self.client.component is self.data.components[0]

    def test_apply_roi(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['y'])
        # bins are -7...-1

        self.data.edit_subset = [self.data.subsets[0]]

        roi = MagicMock()
        roi.to_polygon.return_value = [-5.1, -4.5, -3.2], [2, 3, 4]

        self.client.apply_roi(roi)
        state = self.data.subsets[0].subset_state
        assert isinstance(state, RangeSubsetState)

        # range should expand to nearest bin edge
        assert state.lo == -6
        assert state.hi == -3

    def test_apply_roi_xlog(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])
        self.data.edit_subset = [self.data.subsets[0]]
        self.client.xlog = True
        roi = MagicMock()
        roi.to_polygon.return_value = [1, 2, 3], [2, 3, 4]

        self.client.apply_roi(roi)
        state = self.data.subsets[0].subset_state
        assert isinstance(state, RangeSubsetState)
        assert state.lo == 10
        assert state.hi == 1000

    def test_xlimits_sticky_with_component(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.components[0])
        self.client.xlimits = 5, 6

        self.client.set_component(self.data.components[1])
        self.client.xlimits = 7, 8

        self.client.set_component(self.data.components[0])
        assert self.client.xlimits == (5, 6)

        self.client.set_component(self.data.components[1])
        assert self.client.xlimits == (7, 8)

    def test_default_xlimits(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])
        assert self.client.xlimits == (0, 20)
        self.client.set_component(self.data.id['y'])
        assert self.client.xlimits == (-7, -1)

    def test_xlimit_single_set(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])

        self.client.xlimits = (None, 5)
        assert self.client.xlimits == (0, 5)
        self.client.xlimits = (3, None)
        assert self.client.xlimits == (3, 5)

    def test_xlimit_reverse_set(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])

        self.client.xlimits = 5, 3
        assert self.client.xlimits == (3, 5)

    def test_xlog_axes_labels(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])

        self.client.xlog = True
        assert self.client.axes.get_xlabel() == 'Log x'

        self.client.xlog = False
        assert self.client.axes.get_xlabel() == 'x'

        self.client.ylog = True
        assert self.client.axes.get_ylabel() == 'N'

        self.client.ylog = False
        assert self.client.axes.get_ylabel() == 'N'

    def test_xlog_snaps_limits(self):

        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])

        self.client.axes.set_xlim((-1, 1))
        self.client.xlog = True
        assert self.client.axes.get_xlim() != (-1, 1)

    def test_artist_clear_resets_arrays(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.components[0])
        for a in self.client._artists[self.data]:
            assert a.get_data()[0].size > 0
            a.clear()
            assert a.get_data()[0].size == 0


class TestCategoricalHistogram(TestHistogramClient):

    def setup_method(self, method):
        self.data = Data(y=[-1, -1, -1, -2, -2, -2, -3, -5, -7])
        self.data.add_component(CategoricalComponent(['a', 'a', 'a', 'b', 'c', 'd', 'd', 'e', 'f']), 'x')
        self.subset = self.data.new_subset()
        self.collect = DataCollection(self.data)
        self.client = HistogramClient(self.collect, FIGURE)
        self.axes = self.client.axes
        FIGURE.canvas.draw = MagicMock()
        assert FIGURE.canvas.draw.call_count == 0

    def test_xlimit_single_set(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])

        self.client.xlimits = (None, 5)
        assert self.client.xlimits == (-0.5, 5)
        self.client.xlimits = (3, None)
        assert self.client.xlimits == (3, 5)

    def test_default_xlimits(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])
        assert self.client.xlimits == (-0.5, 5.5)
        self.client.set_component(self.data.id['y'])
        assert self.client.xlimits == (-7, -1)

    def test_change_default_bins(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])
        assert self.client.nbins == 6

    def test_tick_labels(self):
        self.client.add_layer(self.data)
        self.client.set_component(self.data.id['x'])
        correct_labels = ['a', 'b', 'c', 'd', 'e', 'f']
        formatter = self.client.axes.xaxis.get_major_formatter()
        xlabels = [formatter.format_data(pos) for pos in range(6)]
        assert correct_labels == xlabels

    # REMOVED TESTS
    def test_xlog_axes_labels(self):
        """ log-scale doesn't make sense for categorical data"""
        pass

    def test_xlog_snaps_limits(self):
        """ log-scale doesn't make sense for categorical data"""
        pass

    def test_apply_roi_xlog(self):
        """ log-scale doesn't make sense for categorical data"""
        pass


class TestCommunication(object):

    def setup_method(self, method):
        self.data = Data(x=[1, 2, 3, 2, 2, 3, 1])
        figure = MagicMock()
        self.collect = DataCollection()
        self.client = HistogramClient(self.collect, figure)
        self.axes = self.client.axes
        self.hub = self.collect.hub
        self.connect()

    def draw_count(self):
        return self.axes.figure.canvas.draw.call_count

    def connect(self):
        self.client.register_to_hub(self.hub)
        self.collect.register_to_hub(self.hub)

    def test_ignore_data_add_message(self):
        self.collect.append(self.data)
        assert not (self.client.layer_present(self.data))

    def test_update_data_ignored_if_data_not_present(self):
        self.collect.append(self.data)
        ct0 = self.draw_count()
        self.data.style.color = 'blue'
        assert self.draw_count() == ct0

    def test_update_data_processed_if_data_present(self):
        self.collect.append(self.data)
        self.client.add_layer(self.data)
        ct0 = self.draw_count()
        self.data.style.color = 'blue'
        assert self.draw_count() > ct0

    def test_add_subset_ignored_if_data_not_present(self):
        self.collect.append(self.data)
        sub = self.data.new_subset()
        assert not (self.client.layer_present(sub))

    def test_add_subset_processed_if_data_present(self):
        self.collect.append(self.data)
        self.client.add_layer(self.data)
        sub = self.data.new_subset()
        assert (self.client.layer_present(sub))

    def test_update_subset_ignored_if_not_present(self):
        self.collect.append(self.data)
        self.client.add_layer(self.data)
        sub = self.data.new_subset()
        self.client.remove_layer(sub)
        ct0 = self.draw_count()
        sub.style.color = 'blue'
        assert self.draw_count() == ct0

    def test_update_subset_processed_if_present(self):
        self.collect.append(self.data)
        self.client.add_layer(self.data)
        sub = self.data.new_subset()
        ct0 = self.draw_count()
        sub.style.color = 'blue'
        assert self.draw_count() > ct0

    def test_data_remove_message(self):
        self.collect.append(self.data)
        self.client.add_layer(self.data)
        self.collect.remove(self.data)
        assert not self.client.layer_present(self.data)

    def test_subset_remove_message(self):
        self.collect.append(self.data)
        self.client.add_layer(self.data)
        sub = self.data.new_subset()
        assert self.client.layer_present(sub)
        sub.delete()
        assert not self.client.layer_present(sub)


class TestHistogramLayerArtist(object):

    def setup_subset(self):
        ax = MagicMock()
        d = Data(x=[1, 2, 3])
        s = d.new_subset()
        s.subset_state = d.id['x'] > 1
        self.artist = HistogramLayerArtist(s, ax)

    def setup_hist_calc_counter(self):
        self.setup_subset()
        m = MagicMock()
        self.artist._calculate_histogram = m
        return m

    def setup_hist_scale_counter(self):
        self.setup_subset()
        m = MagicMock()
        self.artist._scale_histogram = m
        self.artist._calculate_histogram = MagicMock()
        return m

    def test_calculate_histogram_efficient(self):
        ct = self.setup_hist_calc_counter()
        self.artist.update()
        assert ct.call_count == 1
        self.artist.update()
        assert ct.call_count == 1

    def test_recalc_on_state_changes(self):
        ct = self.setup_hist_calc_counter()
        assert ct.call_count == 0
        self.artist.update()
        assert ct.call_count == 1

        # lo
        self.artist.lo -= 1
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 2

        # hi
        self.artist.hi -= 1
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 3

        # nbins
        self.artist.nbins += 1
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 4

        # xlog
        self.artist.xlog ^= True
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 5

        # ylog -- no call
        self.artist.ylog ^= True
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 5

        # cumulative -- no call
        self.artist.cumulative ^= True
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 5

        # normed -- no call
        self.artist.normed ^= True
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 5

        # subset style -- no call
        self.artist.layer.style.color = '#00ff00'
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 5

        # subset state
        self.artist.layer.subset_state = self.artist.layer.data.id['x'] > 10
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 6

    def test_rescale_on_state_changes(self):
        ct = self.setup_hist_scale_counter()
        assert ct.call_count == 0
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 1

        # lo
        self.artist.lo -= 1
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 2

        # hi
        self.artist.hi -= 1
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 3

        # nbins
        self.artist.nbins += 1
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 4

        # xlog
        self.artist.xlog ^= True
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 5

        # ylog
        self.artist.ylog ^= True
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 6

        # cumulative
        self.artist.cumulative ^= True
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 7

        # normed
        self.artist.normed ^= True
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 8

        # subset state
        self.artist.layer.subset_state = self.artist.layer.data.id['x'] > 10
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 9

        # subset style -- no call
        self.artist.layer.style.color = '#00ff00'
        self.artist.update()
        self.artist.update()
        assert ct.call_count == 9

########NEW FILE########
__FILENAME__ = test_image_client
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest

from mock import MagicMock
import numpy as np

from ...tests import example_data
from ... import core
from ...core.exceptions import IncompatibleAttribute
from ..layer_artist import RGBImageLayerArtist, ImageLayerArtist
from ..image_client import ImageClient

from .util import renderless_figure

FIGURE = renderless_figure()


class DummyCoords(core.coordinates.Coordinates):

    def pixel2world(self, *args):
        return tuple(a * (i + 1) for i, a in enumerate(args))


class TrueState(core.subset.SubsetState):

    def to_mask(self, view=None):
        data = np.ones(self.parent.data.shape, dtype=bool)
        if view is not None:
            data = data[view]
        return data


class TestImageClient(object):

    def setup_method(self, method):
        self.im = example_data.test_image()
        self.cube = example_data.test_cube()
        self.cube4 = core.Data(x=np.ones((2, 3, 4, 5)))
        self.scatter = core.Data(x=[1, 2, 3, 4], y=[4, 5, 6, 7])
        self.im.edit_subset = self.im.new_subset()
        self.cube.edit_subset = self.cube.new_subset()
        self.collect = core.data_collection.DataCollection()
        FIGURE.canvas.draw.reset_mock()

    def create_client_with_image(self):
        client = ImageClient(self.collect, figure=FIGURE)
        self.collect.append(self.im)
        client.set_data(self.im)
        return client

    def create_client_with_hypercube(self):
        client = ImageClient(self.collect, figure=FIGURE)
        self.collect.append(self.cube4)
        client.set_data(self.cube4)
        return client

    def create_client_with_image_and_scatter(self):
        from glue.core.link_helpers import LinkSame

        client = self.create_client_with_image()
        self.collect.append(self.scatter)

        ix = self.im.get_world_component_id(0)
        iy = self.im.get_world_component_id(1)

        self.collect.add_link(LinkSame(self.scatter.id['x'], ix))
        self.collect.add_link(LinkSame(self.scatter.id['y'], iy))
        client.add_scatter_layer(self.scatter)

        return client

    def create_client_with_cube(self):
        client = ImageClient(self.collect, figure=FIGURE)
        self.collect.append(self.cube)
        client.set_data(self.cube)
        return client

    def test_empty_creation(self):
        client = ImageClient(self.collect, figure=FIGURE)
        assert client.display_data is None

    def test_nonempty_creation(self):
        self.collect.append(self.im)
        client = ImageClient(self.collect, figure=FIGURE)
        assert client.display_data is None
        assert not self.im in client.artists

    def test_invalid_add(self):
        client = ImageClient(self.collect, figure=FIGURE)
        with pytest.raises(TypeError) as exc:
            client.add_layer(self.cube)
        assert exc.value.args[0] == ("Data not managed by client's "
                                     "data collection")

    def test_set_data(self):
        client = self.create_client_with_image()
        assert client.display_data is self.im

    def test_slice_disabled_for_2d(self):
        client = self.create_client_with_image()
        assert client.slice_ind is None
        with pytest.raises(IndexError) as exc:
            client.slice_ind = 10
        assert exc.value.args[0] == "Can only set slice_ind for 3D images"

    def test_slice_disabled_for_no_data(self):
        client = ImageClient(self.collect, figure=FIGURE)
        assert client.slice_ind is None
        with pytest.raises(IndexError) as exc:
            client.slice_ind = 10
        assert exc.value.args[0] == "Can only set slice_ind for 3D images"

    def test_slice_enabled_for_3D(self):
        client = self.create_client_with_cube()
        assert client.slice_ind is not None
        client.slice_ind = 5
        assert client.slice_ind == 5

    def test_add_subset_via_method(self):
        client = ImageClient(self.collect, figure=FIGURE)
        self.collect.append(self.im)
        s = self.im.new_subset()
        client.add_layer(s)
        assert s in client.artists

    def test_remove_data(self):
        client = ImageClient(self.collect, figure=FIGURE)
        self.collect.append(self.im)
        s = self.im.new_subset()
        client.add_layer(self.im)
        assert self.im in client.artists
        assert s in client.artists
        client.delete_layer(self.im)
        assert client.display_data is None
        assert not self.im in client.artists
        assert not s in client.artists

    def test_set_norm(self):
        client = self.create_client_with_image()
        assert client.display_data is not None
        client.set_norm(clip_lo=3, clip_hi=97)
        for a in client.artists[self.im]:
            assert a.norm.clip_lo == 3
            assert a.norm.clip_hi == 97

    def test_delete_data(self):
        client = self.create_client_with_image()
        client.delete_layer(self.im)
        assert not self.im in client.artists

    def test_set_attribute(self):
        client = self.create_client_with_image()
        atts = self.im.component_ids()
        assert len(atts) > 1
        for att in atts:
            client.set_attribute(att)
            assert client.display_attribute is att

    def test_get_attribute(self):
        client = self.create_client_with_image()
        atts = self.im.component_ids()
        assert len(atts) > 1
        for att in atts:
            client.set_attribute(att)
            assert client.display_attribute is att

    def test_set_data_and_attribute(self):
        client = self.create_client_with_image()
        atts = self.im.component_ids()
        assert len(atts) > 1
        for att in atts:
            client.set_data(self.im, attribute=att)
            assert client.display_attribute is att
            assert client.display_data is self.im

    def test_slice_ori_on_2d_raises(self):
        client = self.create_client_with_image()
        with pytest.raises(IndexError) as exc:
            client.set_slice_ori(0)
        assert exc.value.args[0] == "Can only set slice_ori for 3D images"

    def test_slice_ori_out_of_bounds(self):
        client = self.create_client_with_image()
        self.collect.append(self.cube)
        client.set_data(self.cube)
        with pytest.raises(ValueError) as exc:
            client.set_slice_ori(100)
        assert exc.value.args[0] == "Orientation must be 0, 1, or 2"

    def test_apply_roi_2d(self):
        """apply_roi is applied to all edit_subsets"""
        client = self.create_client_with_image()

        roi = core.roi.PolygonalROI(vx=[10, 20, 20, 10],
                                    vy=[10, 10, 20, 20])
        client.apply_roi(roi)
        roi2 = self.im.edit_subset.subset_state.roi
        state = self.im.edit_subset.subset_state

        assert roi2.to_polygon()[0] == roi.to_polygon()[0]
        assert roi2.to_polygon()[1] == roi.to_polygon()[1]
        assert state.xatt is self.im.get_pixel_component_id(1)
        assert state.yatt is self.im.get_pixel_component_id(0)

    def test_apply_roi_3d(self):
        client = self.create_client_with_cube()
        self.cube.coords = DummyCoords()
        roi = core.roi.PolygonalROI(vx=[10, 20, 20, 10],
                                    vy=[10, 10, 20, 20])

        client.set_slice_ori(0)
        client.apply_roi(roi)
        state = self.cube.edit_subset.subset_state
        roi2 = state.roi
        assert state.xatt is self.cube.get_pixel_component_id(2)
        assert state.yatt is self.cube.get_pixel_component_id(1)
        assert roi2.to_polygon()[0] == roi.to_polygon()[0]
        assert roi2.to_polygon()[1] == roi.to_polygon()[1]

        client.set_slice_ori(1)
        client.apply_roi(roi)
        state = self.cube.edit_subset.subset_state
        roi2 = state.roi
        assert state.xatt is self.cube.get_pixel_component_id(2)
        assert state.yatt is self.cube.get_pixel_component_id(0)
        assert roi2.to_polygon()[0] == roi.to_polygon()[0]
        assert roi2.to_polygon()[1] == roi.to_polygon()[1]

        client.set_slice_ori(2)
        client.apply_roi(roi)
        state = self.cube.edit_subset.subset_state
        roi2 = state.roi
        assert state.xatt is self.cube.get_pixel_component_id(1)
        assert state.yatt is self.cube.get_pixel_component_id(0)
        assert roi2.to_polygon()[0] == roi.to_polygon()[0]
        assert roi2.to_polygon()[1] == roi.to_polygon()[1]

    def test_apply_roi_draws_once(self):
        client = self.create_client_with_image()
        client.register_to_hub(self.collect.hub)

        # add some more data
        for _ in range(3):
            self.collect.append(core.Data(x=[1, 2, 3], label='add'))
        sg = self.collect.new_subset_group()
        for d in self.collect:
            d.edit_subset = sg

        roi = core.roi.PolygonalROI(vx=[10, 20, 20, 10],
                                    vy=[10, 10, 20, 20])
        ct = FIGURE.canvas.draw.call_count
        client.apply_roi(roi)
        assert FIGURE.canvas.draw.call_count == ct + 1

    def test_update_subset_deletes_artist_on_error(self):
        client = self.create_client_with_image()
        sub = self.im.edit_subset

        bad_state = MagicMock()
        err = core.exceptions.IncompatibleAttribute("Can't make mask")
        bad_state.to_mask.side_effect = err
        bad_state.to_index_list.side_effect = err
        sub.subset_state = bad_state

        m = MagicMock()
        client.artists[sub][0].clear = m
        client._update_subset_single(sub)
        assert m.call_count == 2

    def test_subsets_shown_on_init(self):
        client = self.create_client_with_image()
        subset = self.im.edit_subset
        assert subset in client.artists

    def test_axis_labels(self):
        client = self.create_client_with_image()
        client.refresh()
        ax = client.axes
        assert ax.get_xlabel() == 'World 1'
        assert ax.get_ylabel() == 'World 0'

    def test_add_scatter_layer(self):
        client = self.create_client_with_image_and_scatter()
        assert self.scatter in client.artists
        for a in client.artists[self.scatter]:
            assert a.visible

    def test_check_update(self):
        client = self.create_client_with_image()
        mm = MagicMock()
        client._redraw = mm
        client.check_update(None)
        ct = mm.call_count
        client.check_update(None)
        assert mm.call_count == ct

        client.axes.set_xlim(100, 500)
        client.check_update(None)
        assert mm.call_count > ct

    def test_set_cmap(self):
        from matplotlib.cm import bone
        client = self.create_client_with_image()
        client.set_data(self.im)
        client.set_cmap(bone)
        for a in client.artists[self.im]:
            assert a.cmap is bone

    def test_bad_attribute(self):
        """Shoudl raise IncompatibleAttribute on bad input"""
        client = self.create_client_with_image()
        client.set_data(self.im)
        with pytest.raises(IncompatibleAttribute) as exc:
            client.set_attribute('bad')
        assert exc.value.args[0] == "Attribute not in data's attributes: bad"

    def test_sticky_norm(self):
        """Norm scaling for each component should be remembered"""
        client = self.create_client_with_image()
        x = self.im[self.im.visible_components[0]]
        y = x * 2
        self.im.add_component(y, 'y')

        client.set_attribute(self.
                             im.visible_components[0])
        client.set_norm(clip_lo=7, clip_hi=80)
        n = client.get_norm()
        assert n.clip_lo == 7
        assert n.clip_hi == 80

        client.set_attribute(self.im.visible_components[1])
        client.set_norm(clip_lo=20, clip_hi=30)

        client.set_attribute(self.im.visible_components[0])
        n == client.get_norm()
        assert n.clip_lo == 7
        assert n.clip_hi == 80

    def test_scatter_persistent(self):
        """Ensure that updates to data plot don't erase scatter artists"""
        client = self.create_client_with_image_and_scatter()
        assert self.scatter in client.artists
        client._update_data_plot()
        assert self.scatter in client.artists

    def test_image_hide_persistent(self):
        """If image layer is disabled, it should stay disabled after update"""
        client = self.create_client_with_image()
        assert client.is_visible(self.im)
        client.set_visible(self.im, False)
        client.axes.set_xlim(1, 2)
        client.check_update(None)
        for a in client.artists[self.im]:
            for aa in a.artists:
                assert not aa.get_visible()

    def test_scatter_subsets_not_auto_added(self):
        """Scatter subsets should not be added by
        SubsetAddMessage"""
        c = self.create_client_with_image()

        self.collect.append(self.scatter)

        c.register_to_hub(self.collect.hub)

        s = self.scatter.new_subset()
        assert s not in c.artists

    def test_scatter_layer_does_not_set_display_data(self):
        c = self.create_client_with_image()
        self.collect.append(self.scatter)
        d = c.display_data
        c.set_data(self.scatter)
        assert c.display_data is d

    def test_rgb_mode_toggle(self):
        c = self.create_client_with_image()
        im = c.rgb_mode(True)
        assert isinstance(im, RGBImageLayerArtist)
        assert c.rgb_mode() is im
        assert isinstance(c.rgb_mode(False), ImageLayerArtist)
        assert c.rgb_mode() is None

    def test_transpose(self):
        c = self.create_client_with_image()
        shp = self.im.shape
        c.slice = 'x', 'y'
        assert c._ax.get_xlim() == (0, shp[0])
        assert c._ax.get_ylim() == (0, shp[1])
        assert c._ax.get_xlabel() == 'World 0'
        assert c._ax.get_ylabel() == 'World 1'

    def test_4d(self):
        c = self.create_client_with_hypercube()
        assert c.display_data is self.cube4

    def test_slice_move_retains_zoom(self):
        # regression test for #224
        c = self.create_client_with_cube()
        c._ax.set_xlim(2, 11)
        c._ax.set_ylim(4, 11)
        c.slice = 1, 'y', 'x'
        assert c._ax.get_xlim() == (2, 11)
        assert c._ax.get_ylim() == (4, 11)


def test_format_coord_2d():
    """Coordinate display is in world coordinates"""

    d = core.Data(x=[[1, 2, 3], [2, 3, 4]])
    d.coords = DummyCoords()

    dc = core.DataCollection([d])
    c = ImageClient(dc, figure=FIGURE)
    c.add_layer(d)
    ax = c.axes

    # no data set. Use default
    xy = ax.format_coord(1, 2)
    assert xy == 'x=1            y=2           '

    # use coord object
    c.set_data(d)
    xy = ax.format_coord(1, 2)
    assert xy == 'World 0=4         World 1=1'


def test_format_coord_3d():
    """Coordinate display is in world coordinates"""

    d = core.Data(x=[[[1, 2, 3], [2, 3, 4]], [[2, 3, 4], [3, 4, 5]]])
    d.coords = DummyCoords()

    dc = core.DataCollection([d])
    c = ImageClient(dc)
    c.add_layer(d)
    ax = c.axes

    # no data set. Use default
    xy = ax.format_coord(1, 2)
    assert xy == 'x=1            y=2           '

    #ori = 0
    c.set_data(d)
    c.set_slice_ori(0)  # constant z
    xy = ax.format_coord(1, 2)
    assert xy == 'World 0=0         World 1=4         World 2=1'

    c.set_slice_ori(1)  # constant y
    xy = ax.format_coord(1, 2)
    assert xy == 'World 0=6         World 1=0         World 2=1'

    c.set_slice_ori(2)  # constant x
    xy = ax.format_coord(1, 2)
    assert xy == 'World 0=6         World 1=2         World 2=0'


class TestRGBImageLayerArtist(object):

    def setup_method(self, method):
        self.ax = MagicMock('matplotlib.axes.Axes')
        self.data = MagicMock('glue.core.Data')
        self.artist = RGBImageLayerArtist(self.data, self.ax)

    def test_set_norm(self):
        a = self.artist
        for c, n in zip(['red', 'green', 'blue'],
                        ['rnorm', 'gnorm', 'bnorm']):
            a.contrast_layer = c
            a.set_norm(vmin=5)
            assert getattr(a, n).vmin == 5

########NEW FILE########
__FILENAME__ = test_layer_artist
from .util import renderless_figure
from ..layer_artist import ScatterLayerArtist
from ...core import Data

FIGURE = renderless_figure()


class TestScatterArtist(object):

    def setup_method(self, method):
        self.ax = FIGURE.add_subplot(111)

    def test_emphasis_compatible_with_data(self):
        # regression test for issue 249
        d = Data(x=[1, 2, 3])
        s = ScatterLayerArtist(d, self.ax)
        s.xatt = d.id['x']
        s.yatt = d.id['x']
        s.emphasis = d.id['x'] > 1

        s.update()

########NEW FILE########
__FILENAME__ = test_profile_viewer
from collections import namedtuple

from mock import MagicMock
import pytest
import numpy as np

from ..profile_viewer import ProfileViewer
from .util import renderless_figure

FIG = renderless_figure()
Event = namedtuple('Event', 'xdata ydata inaxes button dblclick')


class TestProfileViewer(object):

    def setup_method(self, method):
        FIG.clf()
        FIG.canvas.draw = MagicMock()
        self.viewer = ProfileViewer(FIG)
        self.axes = self.viewer.axes

    def test_set_profile(self):
        self.viewer.set_profile([1, 2, 3], [2, 3, 4])
        self.axes.figure.canvas.draw.assert_called_once_with()

    def test_new_value_callback_fire(self):
        cb = MagicMock()
        s = self.viewer.new_value_grip(callback=cb)
        s.value = 20
        cb.assert_called_once_with(20)

    def test_new_range_callback_fire(self):
        cb = MagicMock()
        s = self.viewer.new_range_grip(callback=cb)
        s.range = (20, 40)
        cb.assert_called_once_with((20, 40))

    def test_pick_grip(self):
        self.viewer.set_profile([1, 2, 3], [10, 20, 30])
        s = self.viewer.new_value_grip()

        s.value = 1.7
        assert self.viewer.pick_grip(1.7, 20) is s

    def test_pick_grip_false(self):
        self.viewer.set_profile([1, 2, 3], [10, 20, 30])
        s = self.viewer.new_value_grip()

        s.value = 3
        assert self.viewer.pick_grip(1.7, 20) is None

    def test_pick_range_grip(self):
        self.viewer.set_profile([1, 2, 3], [10, 20, 30])
        s = self.viewer.new_range_grip()

        s.range = (1.5, 2.5)

        assert self.viewer.pick_grip(1.5, 20) is s
        assert self.viewer.pick_grip(2.5, 20) is s
        assert self.viewer.pick_grip(1.0, 20) is None

    def test_value_drag_updates_value(self):
        h = self.viewer.new_value_grip()
        x2 = h.value + 10

        self._click(h.value)
        self._drag(x2)
        self._release()

        assert h.value == x2

    def test_disabled_grips_ignore_events(self):
        h = self.viewer.new_value_grip()
        h.value = 5

        h.disable()

        self._click(h.value)
        self._drag(10)
        self._release()

        assert h.value == 5

    def test_value_ignores_distant_picks(self):
        self.viewer.set_profile([1, 2, 3], [1, 2, 3])
        h = self.viewer.new_value_grip()
        h.value = 3

        self._click(1)
        self._drag(2)
        self._release()

        assert h.value == 3

    def test_range_translates_on_center_drag(self):
        h = self.viewer.new_range_grip()
        h.range = (1, 3)
        self._click_range_center(h)
        self._drag(1)
        self._release()
        assert h.range == (0, 2)

    def test_range_stretches_on_edge_drag(self):
        h = self.viewer.new_range_grip()
        h.range = (1, 3)

        self._click(1)
        self._drag(2)
        self._release()
        assert h.range == (2, 3)

    def test_range_redefines_on_distant_drag(self):
        self.viewer.set_profile([1, 2, 3], [1, 2, 3])
        h = self.viewer.new_range_grip()
        h.range = (2, 2)

        self._click(1)
        self._drag(1.5)
        self._release()

        assert h.range == (1, 1.5)

    def test_dblclick_sets_value(self):
        h = self.viewer.new_value_grip()
        h.value = 1

        self._click(1.5, double=True)
        assert h.value == 1.5

    def _click_range_center(self, grip):
        x, y = sum(grip.range) / 2, 0
        self._click(x, y)

    def _click(self, x, y=0, double=False):
        e = Event(xdata=x, ydata=y, inaxes=True, button=1, dblclick=double)
        self.viewer._on_down(e)

    def _drag(self, x, y=0):
        e = Event(xdata=x, ydata=y, inaxes=True, button=1, dblclick=False)
        self.viewer._on_move(e)

    def _release(self):
        e = Event(xdata=0, ydata=0, inaxes=True, button=1, dblclick=False)
        self.viewer._on_up(e)

    def test_fit(self):
        fitter = MagicMock()
        self.viewer.set_profile([0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6])
        self.viewer.fit(fitter, xlim=[1, 3])

        args = fitter.build_and_fit.call_args[0]
        np.testing.assert_array_equal(args[0], [1, 2, 3])
        np.testing.assert_array_equal(args[1], [2, 3, 4])

    def test_fit_error_without_profile(self):
        with pytest.raises(ValueError) as exc:
            self.viewer.fit(None)
        assert exc.value.args[0] == "Must set profile before fitting"

    def test_new_select(self):
        h = self.viewer.new_range_grip()

        h.new_select(0, 1)
        h.new_drag(1, 1)
        h.release()
        assert h.range == (0, 1)

        h.new_select(1, 1)
        h.new_drag(.5, 1)
        h.release()
        assert h.range == (0.5, 1)

        h.new_select(.4, 1)
        h.new_drag(.4, 1)
        h.release()
        assert h.range == (.4, .4)

########NEW FILE########
__FILENAME__ = test_scatter_client
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest

import numpy as np
from matplotlib.ticker import AutoLocator, MaxNLocator, LogLocator
from matplotlib.ticker import LogFormatterMathtext, ScalarFormatter, FuncFormatter
from mock import MagicMock
from timeit import timeit
from functools import partial

from ...tests import example_data
from ... import core
from ...core.data import ComponentID
from ...core.edit_subset_mode import EditSubsetMode
from ..scatter_client import ScatterClient
from .util import renderless_figure

# share matplotlib instance, and disable rendering, for speed
FIGURE = renderless_figure()


class TestScatterClient(object):

    def setup_method(self, method):
        self.data = example_data.test_data()
        self.ids = [self.data[0].find_component_id('a'),
                    self.data[0].find_component_id('b'),
                    self.data[1].find_component_id('c'),
                    self.data[1].find_component_id('d')]
        self.roi_limits = (0.5, 0.5, 1.5, 1.5)
        self.roi_points = (np.array([1]), np.array([1]))
        self.collect = core.data_collection.DataCollection()
        EditSubsetMode().data_collection = self.collect

        self.hub = self.collect.hub

        FIGURE.clf()
        axes = FIGURE.add_subplot(111)
        self.client = ScatterClient(self.collect, axes=axes)

        self.connect()

    def teardown_method(self, methdod):
        self.assert_properties_correct()
        self.assert_axes_ticks_correct()

    def assert_properties_correct(self):
        ax = self.client.axes
        cl = self.client
        xlim = ax.get_xlim()
        ylim = ax.get_ylim()
        assert abs(cl.xmin - min(xlim)) < 1e-2
        assert abs(cl.xmax - max(xlim)) < 1e-2
        assert abs(cl.ymin - min(ylim)) < 1e-2
        assert abs(cl.ymax - max(ylim)) < 1e-2
        assert cl.xflip == (xlim[1] < xlim[0])
        assert cl.yflip == (ylim[1] < ylim[0])
        assert cl.xlog == (ax.get_xscale() == 'log')
        assert cl.ylog == (ax.get_yscale() == 'log')
        assert (self.client.xatt is None) or isinstance(
            self.client.xatt, ComponentID)
        assert (self.client.yatt is None) or isinstance(
            self.client.yatt, ComponentID)

    def check_ticks(self, axis, is_log, is_cat):
        locator = axis.get_major_locator()
        formatter = axis.get_major_formatter()
        if is_log:
            assert isinstance(locator, LogLocator)
            assert isinstance(formatter, LogFormatterMathtext)
        elif is_cat:
            assert isinstance(locator, MaxNLocator)
            assert isinstance(formatter, FuncFormatter)
        else:
            assert isinstance(locator, AutoLocator)
            assert isinstance(formatter, ScalarFormatter)

    def assert_axes_ticks_correct(self):
        ax = self.client.axes
        client = self.client
        if client.xatt is not None:
            self.check_ticks(ax.xaxis,
                             client.xlog,
                             client._check_categorical(client.xatt))
        if client.yatt is not None:
            self.check_ticks(ax.yaxis,
                             client.ylog,
                             client._check_categorical(client.yatt))

    def plot_data(self, layer):
        """ Return the data bounds for a given layer (data or subset)
        Output format: [xmin, xmax], [ymin, ymax]
        """
        client = self.client
        x, y = client.artists[layer][0].get_data()
        xmin = x.min()
        xmax = x.max()
        ymin = y.min()
        ymax = y.max()
        return [xmin, xmax], [ymin, ymax]

    def plot_limits(self):
        """ Return the plot limits
        Output format [xmin, xmax], [ymin, ymax]
        """
        ax = self.client.axes
        xlim = ax.get_xlim()
        ylim = ax.get_ylim()
        return (min(xlim), max(xlim)), (min(ylim), max(ylim))

    def assert_layer_inside_limits(self, layer):
        """Assert that points of a layer are within plot limits """
        xydata = self.plot_data(layer)
        xylimits = self.plot_limits()
        assert xydata[0][0] >= xylimits[0][0]
        assert xydata[1][0] >= xylimits[1][0]
        assert xydata[0][1] <= xylimits[0][1]
        assert xydata[1][1] <= xylimits[1][1]

    def setup_2d_data(self):
        d = core.Data(x=[[1, 2], [3, 4]], y=[[2, 4], [6, 8]])
        self.collect.append(d)
        self.client.add_layer(d)
        self.client.xatt = d.id['x']
        self.client.yatt = d.id['y']
        return d

    def add_data(self, data=None):
        if data is None:
            data = self.data[0]
        data.edit_subset = data.new_subset()
        self.collect.append(data)
        self.client.add_data(data)
        return data

    def add_data_and_attributes(self):
        data = self.add_data()
        data.edit_subset = data.new_subset()
        self.client.xatt = self.ids[0]
        self.client.yatt = self.ids[1]
        return data

    def is_first_in_front(self, front, back):
        z1 = self.client.get_layer_order(front)
        z2 = self.client.get_layer_order(back)
        return z1 > z2

    def connect(self):
        self.client.register_to_hub(self.hub)
        self.collect.register_to_hub(self.hub)

    def layer_drawn(self, layer):
        return self.client.is_layer_present(layer) and \
            all(a.enabled and a.visible for a in self.client.artists[layer])

    def layer_data_correct(self, layer, x, y):
        xx, yy = self.client.artists[layer][0].get_data()
        if max(abs(xx - x)) > .01:
            return False
        if max(abs(yy - y)) > .01:
            return False
        return True

    def test_empty_on_creation(self):
        for d in self.data:
            assert not self.client.is_layer_present(d)

    def test_add_external_data_raises_exception(self):
        data = core.data.Data()
        with pytest.raises(TypeError) as exc:
            self.client.add_data(data)
        assert exc.value.args[0] == "Layer not in data collection"

    def test_valid_add(self):
        layer = self.add_data()
        assert self.client.is_layer_present(self.data[0])

    def test_axis_labels_sync_with_setters(self):
        layer = self.add_data()
        self.client.xatt = self.ids[1]
        assert self.client.axes.get_xlabel() == self.ids[1].label
        self.client.yatt = self.ids[0]
        assert self.client.axes.get_ylabel() == self.ids[0].label

    def test_setters_require_componentID(self):
        layer = self.add_data()
        with pytest.raises(TypeError):
            self.client.xatt = self.ids[1]._label
        self.client.xatt = self.ids[1]

    def test_logs(self):
        layer = self.add_data()
        self.client.xlog = True
        assert self.client.axes.get_xscale() == 'log'

        self.client.xlog = False
        assert self.client.axes.get_xscale() == 'linear'

        self.client.ylog = True
        assert self.client.axes.get_yscale() == 'log'

        self.client.ylog = False
        assert self.client.axes.get_yscale() == 'linear'

    def test_flips(self):
        layer = self.add_data()

        self.client.xflip = True
        self.assert_flips(True, False)

        self.client.xflip = False
        self.assert_flips(False, False)

        self.client.yflip = True
        self.assert_flips(False, True)

        self.client.yflip = False
        self.assert_flips(False, False)

    def assert_flips(self, xflip, yflip):
        ax = self.client.axes
        xlim = ax.get_xlim()
        ylim = ax.get_ylim()
        assert (xlim[1] < xlim[0]) == xflip
        assert (ylim[1] < ylim[0]) == yflip

    def test_double_add(self):
        n0 = len(self.client.axes.lines)
        layer = self.add_data_and_attributes()
        # data present
        assert len(self.client.axes.lines) == n0 + 1 + len(layer.subsets)
        layer = self.add_data()
        # data still present
        assert len(self.client.axes.lines) == n0 + 1 + len(layer.subsets)

    def test_data_updates_propagate(self):
        layer = self.add_data_and_attributes()
        assert self.layer_drawn(layer)
        self.client._layer_updated = False
        layer.style.color = 'k'
        assert self.client._layer_updated

    def test_data_removal(self):
        layer = self.add_data()
        subset = layer.new_subset()
        self.collect.remove(layer)
        assert not self.client.is_layer_present(layer)
        assert not self.client.is_layer_present(subset)

    def test_add_subset_while_connected(self):
        layer = self.add_data()
        subset = layer.new_subset()
        assert self.client.is_layer_present(subset)

    def test_subset_removal(self):
        layer = self.add_data()
        subset = layer.new_subset()
        assert self.client.is_layer_present(layer)
        subset.delete()
        assert not self.client.is_layer_present(subset)

    def test_subset_removal_removes_from_plot(self):
        layer = self.add_data_and_attributes()
        subset = layer.new_subset()
        ct0 = len(self.client.axes.lines)
        subset.delete()
        assert len(self.client.axes.lines) == ct0 - 1

    def test_add_subset_to_untracked_data(self):
        subset = self.data[0].new_subset()
        assert not self.client.is_layer_present(subset)

    def test_valid_plot_data(self):
        layer = self.add_data_and_attributes()
        x = layer[self.ids[0]]
        y = layer[self.ids[1]]
        assert self.layer_data_correct(layer, x, y)

    def test_attribute_update_plot_data(self):
        layer = self.add_data_and_attributes()
        x = layer[self.ids[0]]
        y = layer[self.ids[0]]
        self.client.yatt = self.ids[0]
        assert self.layer_data_correct(layer, x, y)

    def test_invalid_plot(self):
        layer = self.add_data_and_attributes()
        assert self.layer_drawn(layer)
        c = core.data.ComponentID('bad id')
        self.client.xatt = c
        assert not self.layer_drawn(layer)
        self.client.xatt = self.ids[0]

    def test_redraw_called_on_invalid_plot(self):
        """ Plot should be updated when given invalid data,
        to sync layers' disabled/invisible states"""
        ctr = MagicMock()
        layer = self.add_data_and_attributes()
        assert self.layer_drawn(layer)
        c = core.data.ComponentID('bad id')
        self.client._redraw = ctr
        ct0 = ctr.call_count
        self.client.xatt = c
        ct1 = ctr.call_count
        ncall = ct1 - ct0
        expected = len(self.client.artists)
        assert ncall >= expected
        self.client.xatt = self.ids[0]

    def test_two_incompatible_data(self):
        d0 = self.add_data(self.data[0])
        d1 = self.add_data(self.data[1])
        self.client.xatt = self.ids[0]
        self.client.yatt = self.ids[1]
        x = d0[self.ids[0]]
        y = d0[self.ids[1]]
        assert self.layer_drawn(d0)
        assert self.layer_data_correct(d0, x, y)
        assert not self.layer_drawn(d1)

        self.client.xatt = self.ids[2]
        self.client.yatt = self.ids[3]
        x = d1[self.ids[2]]
        y = d1[self.ids[3]]
        assert self.layer_drawn(d1)
        assert self.layer_data_correct(d1, x, y)
        assert not self.layer_drawn(d0)

    def test_subsets_connect_with_data(self):
        data = self.data[0]
        s1 = data.new_subset()
        s2 = data.new_subset()
        self.collect.append(data)
        self.client.add_data(data)
        assert self.client.is_layer_present(s1)
        assert self.client.is_layer_present(s2)
        assert self.client.is_layer_present(data)

        # should also work with add_layer
        self.collect.remove(data)
        assert data not in self.collect
        assert not self.client.is_layer_present(s1)
        self.collect.append(data)
        self.client.add_layer(data)
        assert self.client.is_layer_present(s1)

    def test_edit_subset_connect_with_data(self):
        data = self.add_data()
        assert self.client.is_layer_present(data.edit_subset)

    def test_edit_subset_removed_with_data(self):
        data = self.add_data()
        self.collect.remove(data)
        assert not self.client.is_layer_present(data.edit_subset)

    def test_apply_roi(self):
        data = self.add_data_and_attributes()
        roi = core.roi.RectangularROI()
        roi.update_limits(*self.roi_limits)
        x, y = self.roi_points
        self.client.apply_roi(roi)
        assert self.layer_data_correct(data.edit_subset, x, y)

    def test_apply_roi_adds_on_empty(self):
        data = self.add_data_and_attributes()
        data._subsets = []
        data.edit_subset = None
        roi = core.roi.RectangularROI()
        roi.update_limits(*self.roi_limits)
        x, y = self.roi_points
        self.client.apply_roi(roi)
        assert data.edit_subset is not None

    def test_apply_roi_applies_to_all_editable_subsets(self):
        d1 = self.add_data_and_attributes()
        d2 = self.add_data()
        state1 = d1.edit_subset.subset_state
        state2 = d2.edit_subset.subset_state
        roi = core.roi.RectangularROI()
        roi.update_limits(*self.roi_limits)
        x, y = self.roi_points
        self.client.apply_roi(roi)
        assert d1.edit_subset.subset_state is not state1
        assert d1.edit_subset.subset_state is not state2

    def test_apply_roi_doesnt_add_if_any_selection(self):
        d1 = self.add_data_and_attributes()
        d2 = self.add_data()
        d1.edit_subset = None
        d2.edit_subset = d2.new_subset()
        ct = len(d1.subsets)
        roi = core.roi.RectangularROI()
        roi.update_limits(*self.roi_limits)
        x, y = self.roi_points
        self.client.apply_roi(roi)
        assert len(d1.subsets) == ct

    def test_subsets_drawn_over_data(self):
        data = self.add_data_and_attributes()
        subset = data.new_subset()
        assert self.is_first_in_front(subset, data)

    def test_log_sticky(self):
        data = self.add_data_and_attributes()
        self.assert_logs(False, False)

        self.client.xlog = True
        self.client.ylog = True
        self.assert_logs(True, True)

        self.client.xatt = self.ids[1]
        self.client.yatt = self.ids[0]
        self.assert_logs(True, True)

    def assert_logs(self, xlog, ylog):
        ax = self.client.axes
        assert ax.get_xscale() == ('log' if xlog else 'linear')
        assert ax.get_yscale() == ('log' if ylog else 'linear')

    def test_flip_sticky(self):
        data = self.add_data_and_attributes()
        self.client.xflip = True
        self.assert_flips(True, False)
        self.client.xatt = self.ids[1]
        self.assert_flips(True, False)
        self.client.xatt = self.ids[0]
        self.assert_flips(True, False)

    def test_visibility_sticky(self):
        data = self.add_data_and_attributes()
        roi = core.roi.RectangularROI()
        roi.update_limits(*self.roi_limits)
        assert self.client.is_visible(data.edit_subset)
        self.client.apply_roi(roi)
        self.client.set_visible(data.edit_subset, False)
        assert not self.client.is_visible(data.edit_subset)
        self.client.apply_roi(roi)
        assert not self.client.is_visible(data.edit_subset)

    def test_2d_data(self):
        """Should be abple to plot 2d data"""
        data = self.setup_2d_data()
        assert self.layer_data_correct(data, [1, 2, 3, 4], [2, 4, 6, 8])

    def test_2d_data_limits_with_subset(self):
        """visible limits should work with subsets and 2d data"""
        d = self.setup_2d_data()
        state = d.id['x'] > 2
        s = d.new_subset()
        s.subset_state = state
        assert self.client._visible_limits(0) == (1, 4)
        assert self.client._visible_limits(1) == (2, 8)

    def test_limits_nans(self):
        d = core.Data()
        x = core.Component(np.array([[1, 2], [np.nan, 4]]))
        y = core.Component(np.array([[2, 4], [np.nan, 8]]))
        xid = d.add_component(x, 'x')
        yid = d.add_component(y, 'y')
        self.collect.append(d)
        self.client.add_layer(d)
        self.client.xatt = xid
        self.client.yatt = yid

        assert self.client._visible_limits(0) == (1, 4)
        assert self.client._visible_limits(1) == (2, 8)

    def test_limits_inf(self):
        d = core.Data()
        x = core.Component(np.array([[1, 2], [np.infty, 4]]))
        y = core.Component(np.array([[2, 4], [-np.infty, 8]]))
        xid = d.add_component(x, 'x')
        yid = d.add_component(y, 'y')
        self.collect.append(d)
        self.client.add_layer(d)
        self.client.xatt = xid
        self.client.yatt = yid

        assert self.client._visible_limits(0) == (1, 4)
        assert self.client._visible_limits(1) == (2, 8)

    def test_xlog_relimits_if_negative(self):
        self.add_data_and_attributes()
        self.client.xflip = False
        self.client.xlog = False

        self.client.axes.set_xlim(-5, 5)
        self.client.xlog = True
        assert self.client.axes.get_xlim()[0] > .9

    def test_ylog_relimits_if_negative(self):
        self.add_data_and_attributes()
        self.client.yflip = False
        self.client.ylog = False
        self.client.axes.set_ylim(-5, 5)

        self.client.ylog = True
        assert self.client.axes.get_ylim()[0] > .9

    def test_subset_added_only_if_data_layer_present(self):
        self.collect.append(self.data[0])
        assert self.data[0] not in self.client.artists
        s = self.data[0].new_subset()
        assert s not in self.client.artists

    def test_pull_properties(self):
        ax = self.client.axes
        ax.set_xlim(6, 5)
        ax.set_ylim(8, 7)
        ax.set_xscale('log')
        ax.set_yscale('log')

        self.client._pull_properties()
        self.assert_properties_correct()

    def test_rescaled_on_init(self):
        layer = self.setup_2d_data()
        self.assert_layer_inside_limits(layer)

    def test_set_limits(self):
        self.client.xmin = 3
        self.client.xmax = 4
        self.client.ymin = 5
        self.client.ymax = 6
        ax = self.client.axes
        xlim = ax.get_xlim()
        ylim = ax.get_ylim()

        assert xlim[0] == self.client.xmin
        assert xlim[1] == self.client.xmax
        assert ylim[0] == self.client.ymin
        assert ylim[1] == self.client.ymax

    def test_ignore_duplicate_updates(self):
        """Need not create new artist on every draw. Enforce this"""
        layer = self.setup_2d_data()

        m = MagicMock()
        self.client.artists[layer][0].clear = m

        self.client._update_layer(layer)
        ct0 = m.call_count

        self.client._update_layer(layer)
        ct1 = m.call_count

        assert ct1 == ct0


class TestCategoricalScatterClient(TestScatterClient):

    def setup_method(self, method):
        self.data = example_data.test_categorical_data()
        self.ids = [self.data[0].find_component_id('x1'),
                    self.data[0].find_component_id('y1'),
                    self.data[1].find_component_id('x2'),
                    self.data[1].find_component_id('y2')]
        self.roi_limits = (0.5, 0.5, 4, 4)
        self.roi_points = (np.array([1]), np.array([3]))
        self.collect = core.data_collection.DataCollection()
        self.hub = self.collect.hub

        FIGURE.clf()
        axes = FIGURE.add_subplot(111)
        self.client = ScatterClient(self.collect, axes=axes)

        self.connect()

    def test_get_category_tick(self):

        self.add_data()
        self.client.xatt = self.ids[0]
        self.client.yatt = self.ids[0]
        axes = self.client.axes
        xformat = axes.xaxis.get_major_formatter()
        yformat = axes.yaxis.get_major_formatter()

        xlabels = [xformat.format_data(pos) for pos in range(2)]
        ylabels = [yformat.format_data(pos) for pos in range(2)]
        assert xlabels == ['a', 'b']
        assert ylabels == ['a', 'b']

    def test_axis_labels_sync_with_setters(self):
        layer = self.add_data()
        self.client.xatt = self.ids[0]
        assert self.client.axes.get_xlabel() == self.ids[0].label
        self.client.yatt = self.ids[1]
        assert self.client.axes.get_ylabel() == self.ids[1].label

    def test_jitter_with_setter_change(self):

        grab_data = lambda client: client.data[0][client.xatt].copy()
        layer = self.add_data()
        self.client.xatt = self.ids[0]
        self.client.yatt = self.ids[1]
        orig_data = grab_data(self.client)
        self.client.jitter = None
        np.testing.assert_equal(orig_data, grab_data(self.client))
        self.client.jitter = 'uniform'
        delta = np.abs(orig_data - grab_data(self.client))
        assert np.all((delta > 0) & (delta < 1))
        self.client.jitter = None
        np.testing.assert_equal(orig_data, grab_data(self.client))

    def test_ticks_go_back_after_changing(self):
        """ If you change to a categorical axis and then change back
        to a numeric, the axis ticks should fix themselves properly.
        """
        data = core.Data()
        data.add_component(core.Component(np.arange(100)), 'y')
        data.add_component(
            core.data.CategoricalComponent(['a'] * 50 + ['b'] * 50), 'xcat')
        data.add_component(core.Component(2 * np.arange(100)), 'xcont')

        self.add_data(data=data)
        self.client.yatt = data.find_component_id('y')
        self.client.xatt = data.find_component_id('xcat')
        self.check_ticks(self.client.axes.xaxis, False, True)
        self.check_ticks(self.client.axes.yaxis, False, False)

        self.client.xatt = data.find_component_id('xcont')
        self.check_ticks(self.client.axes.yaxis, False, False)
        self.check_ticks(self.client.axes.xaxis, False, False)

    def test_high_cardinatility_timing(self):

        card = 50000
        data = core.Data()
        card_data = [str(num) for num in range(card)]
        data.add_component(core.Component(np.arange(card * 5)), 'y')
        data.add_component(
            core.data.CategoricalComponent([card_data] * 5), 'xcat')
        self.add_data(data)
        comp = data.find_component_id('xcat')
        timer_func = partial(self.client._set_xydata, 'x', comp)

        timer = timeit(timer_func, number=1)
        assert timer < 3  # this is set for Travis speed

    # REMOVED TESTS
    def test_invalid_plot(self):
        """ This fails because the axis ticks shouldn't reset after
        invalid plot. Current testing logic can't cope with this."""
        pass

    def test_redraw_called_on_invalid_plot(self):
        """ This fails because the axis ticks shouldn't reset after
        invalid plot. Current testing logic can't cope with this."""
        pass

    def test_xlog_relimits_if_negative(self):
        """ Log-based tests don't make sense here."""
        pass

    def test_log_sticky(self):
        """ Log-based tests don't make sense here."""
        pass

    def test_logs(self):
        """ Log-based tests don't make sense here."""
        pass

########NEW FILE########
__FILENAME__ = test_util
import numpy as np
from numpy.testing import assert_allclose

from ..util import fast_limits


def test_fast_limits_nans():
    x = np.zeros((10, 10)) * np.nan
    assert_allclose(fast_limits(x, 0, 1), [0, 1])


def test_single_value():
    x = np.array([1])
    assert_allclose(fast_limits(x, 5., 95.), [1, 1])

########NEW FILE########
__FILENAME__ = util
import matplotlib.pyplot as plt
from mock import MagicMock


def renderless_figure():
    # Matplotlib figure that skips the render step, for test speed
    fig = plt.figure()
    fig.canvas.draw = MagicMock()
    plt.close('all')
    return fig

########NEW FILE########
__FILENAME__ = tree_client
from ..core.tree_layout import TreeLayout

from .viz_client import VizClient


class TreeClient(VizClient):
    """
    A client for visualizing the tree attributes of data sets
    """

    def __init__(self, data, layout=None):
        """ Create a new client

        Parameters:
        ----------
        layout: A TreeLayout object, to map the tree
                onto an xy coordinate system.
        """

        super(TreeClient, self).__init__(data)

        if (data.tree is None) or (data.tree.index_map is None):
            raise AttributeError("Input data does not have tree "
                                 "with an index_map")
        try:
            data.tree.index()
        except KeyError:
            raise TypeError("Cannot create a tree client with this data "
                            "-- tree cannot be indexed")

        self.layout = layout
        if not self.layout:
            self.layout = TreeLayout(data.tree)

########NEW FILE########
__FILENAME__ = util
import logging
from functools import partial
import numpy as np
from matplotlib.ticker import AutoLocator, MaxNLocator, LogLocator
from matplotlib.ticker import (LogFormatterMathtext, ScalarFormatter,
                               FuncFormatter)
from ..core.data import CategoricalComponent
from ..core.decorators import memoize


def get_extent(view, transpose=False):
    sy, sx = [s for s in view if isinstance(s, slice)]
    if transpose:
        return (sy.start, sy.stop, sx.start, sx.stop)
    return (sx.start, sx.stop, sy.start, sy.stop)


def view_cascade(data, view):
    """ Return a set of views progressively zoomed out of input at roughly
    constant pixel count

    :param data: Data object to view
    :param view: Original view into data

    :rtype: tuple of views
    """
    shp = data.shape
    v2 = list(view)
    logging.debug("image shape: %s, view: %s", shp, view)

    # choose stride length that roughly samples entire image
    # at roughly the same pixel count
    step = max(shp[i - 1] * v.step / max(v.stop - v.start, 1)
               for i, v in enumerate(view) if isinstance(v, slice))
    step = max(step, 1)

    for i, v in enumerate(v2):
        if not(isinstance(v, slice)):
            continue
        v2[i] = slice(0, shp[i - 1], step)

    return tuple(v2), view


def small_view(data, attribute):
    """
    Extract a downsampled view from a dataset, for quick
    statistical summaries
    """
    shp = data.shape
    view = tuple([slice(None, None, max(s / 50, 1)) for s in shp])
    return data[attribute, view]


def small_view_array(data):
    """
    Same as small_view, except using a numpy array as input
    """
    shp = data.shape
    view = tuple([slice(None, None, max(s / 50, 1)) for s in shp])
    return np.asarray(data)[view]


def fast_limits(data, plo, phi):
    """Quickly estimate percentiles in an array,
    using a downsampled version

    :param data: array-like
    :param plo: Lo percentile
    :param phi: High percentile

    :rtype: Tuple of floats. Approximate values of each percentile in
            data[component]
    """
    try:
        from scipy import stats
    except ImportError:
        raise ImportError("Scale clipping requires SciPy")

    shp = data.shape
    view = tuple([slice(None, None, max(s / 50, 1)) for s in shp])
    values = np.asarray(data)[view]
    if ~np.isfinite(values).any():
        return (0.0, 1.0)

    limits = (-np.inf, np.inf)
    lo = stats.scoreatpercentile(values.flat, plo, limit=limits)
    hi = stats.scoreatpercentile(values.flat, phi, limit=limits)
    return lo, hi


def visible_limits(artists, axis):
    """Determines the data limits for the data in a set of artists

    Ignores non-visible artists

    Assumes each artist as a get_data method wich returns a tuple of x,y

    :param artists: An iterable collection of artists
    :param axis: Which axis to compute. 0=xaxis, 1=yaxis

    :rtype: A tuple of min, max for the requested axis, or None if
            no data present
    """
    data = []
    for art in artists:
        if not art.visible:
            continue
        xy = art.get_data()
        assert isinstance(xy, tuple)
        val = xy[axis]
        if val.size > 0:
            data.append(xy[axis])

    if len(data) == 0:
        return
    data = np.hstack(data)
    if data.size == 0:
        return

    data = data[np.isfinite(data)]
    if data.size == 0:
        return

    lo, hi = np.nanmin(data), np.nanmax(data)
    if not np.isfinite(lo):
        return

    return lo, hi


def tick_linker(all_categories, pos, *args):
    try:
        return all_categories[int(pos)]
    except IndexError:
        return ''


def update_ticks(axes, coord, components, is_log):
    """ Changes the axes to have the proper tick formatting based on the
     type of component.
    :param axes: A matplotlib axis object to alter
    :param coord: 'x' or 'y'
    :param components: A list() of components that are plotted along this axis
    :param is_log: Boolean for log-scale.
    :kwarg max_categories: The maximum number of categories to display.
    :return: None or #categories if components is Categorical
    """

    if coord == 'x':
        axis = axes.xaxis
    elif coord == 'y':
        axis = axes.yaxis
    else:
        raise TypeError("coord must be one of x,y")

    is_cat = all(isinstance(comp, CategoricalComponent) for comp in components)
    if is_log:
        axis.set_major_locator(LogLocator())
        axis.set_major_formatter(LogFormatterMathtext())
    elif is_cat:
        all_categories = np.empty((0,), dtype=np.object)
        for comp in components:
            all_categories = np.union1d(comp._categories, all_categories)
        locator = MaxNLocator(10, integer=True)
        locator.view_limits(0, all_categories.shape[0])
        format_func = partial(tick_linker, all_categories)
        formatter = FuncFormatter(format_func)

        axis.set_major_locator(locator)
        axis.set_major_formatter(formatter)
        return all_categories.shape[0]
    else:
        axis.set_major_locator(AutoLocator())
        axis.set_major_formatter(ScalarFormatter())

########NEW FILE########
__FILENAME__ = viz_client
import matplotlib.pyplot as plt
from ..core.client import Client


class VizClient(Client):

    """
    The VizClient class provides an interface (and minimal
    implementation) for a generic client that creates
    visualizations. The goal of VizClient is to provide a reusable way
    to organize client plotting code.

    Clients which extend VizClient should override the following methods
    to perform specific visualization tasks

    * _update_axis_labels
    * _update_data_plot
    * _update_subset_single
    * _redraw
    * init_layer

    VizClient provides a public refresh() method that calls all of
    these methods.

    Attributes:
    ----------

    options: A dictionary of global plot options, to be handled by
             subclasses.

    """

    def __init__(self, data, options=None):
        Client.__init__(self, data)

        if not options:
            self.options = {}
        else:
            self.options = options

    def _add_data(self, message):
        pass

    def _remove_data(self, message):
        pass

    def _update_data(self, message):
        """
        Method to handle messages sent by the dataset. Refreshes the display.
        """
        self._update_data_plot()
        self.refresh()

    def _add_subset(self, message):
        """
        Method to handle messages sent when subsets are created.
        """
        s = message.subset
        self.init_layer(s)
        self._redraw()

    def _update_subset(self, message):
        """
        Method to handle messages sent when subsets are modified.
        The plot properties of the modified subset are refreshed.

        """
        s = message.subset
        self._update_subset_single(s, redraw=True)

    def refresh(self):
        """
        Update and redraw all plot information.
        """
        self._update_data_plot()
        self._update_subset_plots()
        self._update_axis_labels()
        self._redraw()

    def _redraw(self):
        """
        Redraw, but do not update, plot information
        """
        raise NotImplementedError("VizClient cannot draw!")

    def _update_axis_labels(self):
        """
        Sync the axis labels to reflect which components are
        currently being plotted
        """
        raise NotImplementedError("VizClient cannot draw!")

    def _update_data_plot(self):
        """
        Sync the location of the scatter points to
        reflect what components are being plotted
        """
        raise NotImplementedError("VizClient cannot draw!")

    def _update_subset_plots(self, redraw=False):
        """
        Sync the location and visual properties
        of each point in each subset
        """
        junk = [self._update_subset_single(s) for d in self.data
                for s in d.subsets]
        if redraw:
            self._redraw()

    def _update_subset_single(self, s, redraw=False):
        """
        Update the properties of a subset

        Parameters
        ----------
        s: A subset instance
        The subset to refresh.

        """
        raise NotImplementedError("VizClient Cannot Draw!")

    def init_layer(self, layer):
        """Initialize a plot of a data or subset object for the first time.

        Parameters
        ----------
        layer: Data or subset instance
        """
        raise NotImplementedError()


def init_mpl(figure, axes, wcs=False):
    if axes is not None and figure is not None and \
            axes.figure is not figure:
        raise ValueError("Axes and figure are incompatible")

    try:
        from ..external.wcsaxes import WCSAxesSubplot
    except ImportError:
        WCSAxesSubplot = None

    if axes is not None:
        _ax = axes
        _figure = axes.figure
    else:
        _figure = figure or plt.figure()
        if wcs and WCSAxesSubplot is not None:
            _ax = WCSAxesSubplot(_figure, 111)
            _figure.add_axes(_ax)
        else:
            _ax = _figure.add_subplot(1, 1, 1)
    try:
        _figure.set_tight_layout(True)
    except AttributeError:  # matplotlib < 1.1
        pass

    return _figure, _ax

########NEW FILE########
__FILENAME__ = config
import os
import sys
import imp
import logging
from collections import namedtuple
"""
Objects used to configure Glue at runtime.
"""

__all__ = ['Registry', 'SettingRegistry', 'ExporterRegistry',
           'ColormapRegistry', 'DataFactoryRegistry', 'QtClientRegistry',
           'LinkFunctionRegistry', 'LinkHelperRegistry',
           'ProfileFitterRegistry',
           'qt_client', 'data_factory', 'link_function', 'link_helper',
           'colormaps',
           'exporters', 'settings', 'fit_plugin']


class Registry(object):

    """Container to hold groups of objects or settings.

    Registry instances are used by Glue to track objects
    used for various tasks like data linking, widget creation, etc.
    They have the following properties:

        - A `members` property, which lists each item in the registry
        - A `default_members` function, which can be overridden to lazily
          initialize the members list
        - A call interface, allowing the instance to be used as a decorator
          for users to add new items to the registry in their config files
    """

    def __init__(self):
        self._members = []
        self._loaded = False

    @property
    def members(self):
        """ A list of the members in the registry.
        The return value is a list. The contents of the list
        are specified in each subclass"""
        if not self._loaded:
            self._members = self.default_members() + self._members
            self._loaded = True

        return self._members

    def default_members(self):
        """The member items provided by default. These are put in this
        method so that code is only imported when needed"""
        return []

    def add(self, value):
        """ Add a new item to the registry """
        self._members.append(value)

    def __iter__(self):
        return iter(self.members)

    def __len__(self):
        return len(self.members)

    def __contains__(self, value):
        return value in self.members

    def __call__(self, arg):
        """This is provided so that registry instances can be used
        as decorators. The decorators should add the decorated
        code object to the registry, and return the original function"""
        self.add(arg)
        return arg


class SettingRegistry(Registry):

    """Stores key/value settings that code can use to customize Glue

    Each member is a tuple of 3 items:
      - key: the setting name [str]
      - value: the default setting [object]
      - validator: A function which tests whether the input is a valid value,
                   and raises a ValueError if invalid. On valid input,
                   returns the (possibly sanitized) setting value.
    """

    def add(self, key, value, validator=str):
        self.members.append((key, value, validator))


class ExporterRegistry(Registry):

    """Stores functions which can export an applocation to an output file

    The members property is a list of exporters, each represented
    as a (label, save_function, can_save_function, outmode) tuple.

    save_function takes an (application, path) as input, and saves
    the session

    can_save_function takes an application as input, and raises an
    exception if saving this session is not possible

    outmode is a string, with one of 3 values:
      'file': indicates that exporter creates a file
      'directory': exporter creates a directory
      'label': exporter doesn't write to disk, but needs a label
    """

    def default_members(self):
        return []

    def add(self, label, exporter, checker, outmode='file'):
        """
        Add a new exporter
        :param label: Short label for the exporter
        :type label: str

        :param exporter: exporter function
        :type exporter: function(application, path)

        :param checker: function that checks if save is possible
        :type exporter: function(application)

        ``exporter`` should raise an exception if export isn't possible.

        :param outmode: What kind of output is created?
        :type outmode: str ('file' | 'directory' | 'label')
        """
        self.members.append((label, exporter, checker, outmode))


class ColormapRegistry(Registry):

    """Stores colormaps for the Image Viewer. The members property is
    a list of colormaps, each represented as a [name,cmap] pair.
    """

    def default_members(self):
        import matplotlib.cm as cm
        members = []
        members.append(['Gray', cm.gray])
        members.append(['Purple-Blue', cm.PuBu])
        members.append(['Yellow-Green-Blue', cm.YlGnBu])
        members.append(['Yellow-Orange-Red', cm.YlOrRd])
        members.append(['Red-Purple', cm.RdPu])
        members.append(['Blue-Green', cm.BuGn])
        members.append(['Hot', cm.hot])
        members.append(['Red-Blue', cm.RdBu])
        members.append(['Red-Yellow-Blue', cm.RdYlBu])
        members.append(['Purple-Orange', cm.PuOr])
        members.append(['Purple-Green', cm.PRGn])
        return members

    def add(self, label, cmap):
        """
        Add colormap *cmap* with label *label*.
        """
        self.members.append([label, cmap])


class DataFactoryRegistry(Registry):

    """Stores data factories. Data factories take filenames as input,
    and return :class:`~glue.core.data.Data` instances

    The members property returns a list of (function, label, identifier)
    namedtuples:

    - Function is the factory that creates the data object
    - label is a short human-readable description of the factory
    - identifier is a function that takes ``(filename, **kwargs)`` as input
      and returns True if the factory can open the file

    New data factories can be registered via::

        @data_factory('label_name', identifier, default='txt')
        def new_factory(file_name):
            ...

    This has the additional side-effect of associating
    this this factory with filenames ending in ``txt`` by default
    """
    item = namedtuple('DataFactory', 'function label identifier')

    def default_members(self):
        from .core.data_factories import __factories__
        return [self.item(f, f.label, f.identifier) for f in __factories__]

    def __call__(self, label, identifier, default=''):
        from .core.data_factories import set_default_factory

        def adder(func):
            set_default_factory(default, func)
            self.add(self.item(func, label, identifier))
            return func
        return adder


class QtClientRegistry(Registry):

    """Stores QT widgets to visualize data.

    The members property is a list of Qt widget classes

    New widgets can be registered via::

        @qt_client
        class CustomWidget(QMainWindow):
            ...
    """

    def default_members(self):
        try:
            from .qt.widgets.scatter_widget import ScatterWidget
            from .qt.widgets.image_widget import ImageWidget
            from .qt.widgets.histogram_widget import HistogramWidget
            return [ScatterWidget, ImageWidget, HistogramWidget]
        except ImportError:
            logging.getLogger(__name__).warning(
                "could not import glue.qt in ConfigObject")
            return []


class LinkFunctionRegistry(Registry):

    """Stores functions to convert between quantities

    The members properety is a list of (function, info_string,
    output_labels) namedtuples. `info_string` is describes what the
    function does. `output_labels` is a list of names for each output.

    New link functions can be registered via

        @link_function(info="maps degrees to arcseconds",
                       output_labels=['arcsec'])
        def degrees2arcsec(degrees):
            return degress * 3600

    Link functions are expected to receive and return numpy arrays
    """
    item = namedtuple('LinkFunction', 'function info output_labels')

    def default_members(self):
        from .core import link_helpers
        return list(self.item(l, "", l.output_args)
                    for l in link_helpers.__LINK_FUNCTIONS__)

    def __call__(self, info="", output_labels=None):
        out = output_labels or []

        def adder(func):
            self.add(self.item(func, info, out))
            return func
        return adder


class LinkHelperRegistry(Registry):

    """Stores helper objects that compute many ComponentLinks at once

    The members property is a list of (object, info_string,
    input_labels) tuples. `Object` is the link helper. `info_string`
    describes what `object` does. `input_labels` is a list labeling
    the inputs.

    Each link helper takes a list of ComponentIDs as inputs, and
    returns an iterable object (e.g. list) of ComponentLinks.

    New helpers can be registered via

        @link_helper('Links degrees and arcseconds in both directions',
                     ['degree', 'arcsecond'])
        def new_helper(degree, arcsecond):
            return [ComponentLink([degree], arcsecond, using=lambda d: d*3600),
                    ComponentLink([arcsecond], degree, using=lambda a: a/3600)]
    """
    item = namedtuple('LinkHelper', 'helper info input_labels')

    def default_members(self):
        from .core.link_helpers import __LINK_HELPERS__ as helpers
        return list(self.item(l, l.info_text, l.input_args)
                    for l in helpers)

    def __call__(self, info, input_labels):
        def adder(func):
            self.add(self.item(func, info, input_labels))
            return func
        return adder


class ProfileFitterRegistry(Registry):
    item = namedtuple('ProfileFitter', 'cls')

    def add(self, cls):
        """
        Add colormap *cmap* with label *label*.
        """
        self.members.append(cls)

    def default_members(self):
        from .core.fitters import __FITTERS__
        return list(__FITTERS__)


qt_client = QtClientRegistry()
data_factory = DataFactoryRegistry()
link_function = LinkFunctionRegistry()
link_helper = LinkHelperRegistry()
colormaps = ColormapRegistry()
exporters = ExporterRegistry()
settings = SettingRegistry()
fit_plugin = ProfileFitterRegistry()


def load_configuration(search_path=None):
    ''' Find and import a config.py file

    Returns:

       The module object

    Raises:

       Exception, if no module was found
    '''
    search_order = search_path or _default_search_order()
    result = imp.new_module('config')

    for config_file in search_order:
        dir = os.path.dirname(config_file)
        try:
            sys.path.append(dir)
            config = imp.load_source('config', config_file)
            result = config
        except IOError:
            pass
        except Exception as e:
            raise Exception("Error loading config file %s:\n%s" %
                            (config_file, e))
        finally:
            sys.path.remove(dir)

    return result


def _default_search_order():
    """
    The default configuration file search order:

       * current working directory
       * environ var GLUERC
       * HOME/.glue/config.py
       * Glue's own default config
    """
    search_order = [os.path.join(os.getcwd(), 'config.py')]
    if 'GLUERC' in os.environ:
        search_order.append(os.environ['GLUERC'])
    search_order.append(os.path.expanduser('~/.glue/config.py'))
    return search_order[::-1]

########NEW FILE########
__FILENAME__ = config_gen
#!/usr/bin/env python
"""
Script used to create template config.py files for Glue
"""

import os
import sys
from shutil import copyfile

import glue


def get_clobber():
    result = None
    result = raw_input("\nDestination file exists. Overwrite? [y/n] ")
    while result not in ['y', 'n']:
        print "\tPlease choose one of [y/n]"
        result = raw_input("\nDestination file exists. Overwrite? [y/n] ")

    return result == 'y'


def main():
    dest = os.path.expanduser('~/.glue/')
    if not os.path.exists(dest):
        print "Creating directory %s" % dest
        os.makedirs(dest)

    infile = os.path.join(glue.__path__[0], 'default_config.py')
    outfile = os.path.join(dest, 'config.py')

    print "Creating file %s" % outfile

    if os.path.exists(outfile):
        clobber = get_clobber()
        if not clobber:
            print "Exiting"
            sys.exit(1)

    copyfile(infile, outfile)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = aggregate
"""
Classes to perform aggregations over cubes
"""
try:
    from itertools import izip
except ImportError:  # python3
    izip = zip

from functools import wraps

import numpy as np


def check_empty(func):

    @wraps(func)
    def wrapper(self, *args, **kwargs):
        if self.empty_slice:
            return np.zeros(self.shape) * np.nan
        return func(self, *args, **kwargs)

    return wrapper


class Aggregate(object):

    """
    Collapse >=3D datasets into 2D images, using different
    aggregation methods
    """

    def __init__(self, data, attribute, zax, slc, zlim):
        """
        :param data: :class:`~glue.core.data.Data` object
        :param attribute: :class:`~glue.core.data.ComponentID`
        :param zax: integer. Which axis to collapse over
        :param slc: tuple of integers, 'x', or 'y'. Describes the
                    current 2D slice through the image. Used to
                    define the orientation, as well as axis values
                    for remaining dimensions of >3D cubes
        :param zlim: tuple of [lo, hi), describing the limits
                     of the slab to collapse over
        """
        self.data = data
        self.attribute = attribute
        self.zax = zax
        self.slc = slc
        self.zlim = min(zlim), max(zlim)

    @property
    def shape(self):
        """
        The shape of the 2D aggregated array
        """
        s = self.data.shape
        return s[self.slc.index('y')], s[self.slc.index('x')]

    @property
    def empty_slice(self):
        """
        True if the slice is empty
        """
        return self.zlim[0] == self.zlim[1]

    def _subslice(self):
        view = [slice(None, None) for _ in self.data.shape]
        ax_collapse = self.zax
        for i, s in enumerate(self.slc):
            if s not in ['x', 'y'] and i != self.zax:
                view[i] = s
                if i < self.zax:
                    ax_collapse -= 1
        view[self.zax] = slice(*self.zlim)
        return view, ax_collapse

    def _prepare_cube(self, attribute=None):
        view, ax_collapse = self._subslice()
        att = attribute or self.attribute
        cube = self.data[att, view]
        return cube, ax_collapse

    def _iter_slice(self, attribute=None):
        # iterate through the uncollapsed slab one plane at a time
        view, ax_collapse = self._subslice()
        att = attribute or self.attribute

        for z in xrange(*self.zlim):
            view[self.zax] = z
            plane = self.data[att, view]
            yield np.nan_to_num(plane)

    def _iter_slice_index(self):
        """Loop over slices of the target attribute and its world coordinate"""
        att = self.data.get_world_component_id(self.zax)
        loop = izip(self._iter_slice(), self._iter_slice(att))
        return loop

    def _finalize(self, cube):
        if self.slc.index('x') < self.slc.index('y'):
            cube = cube.T
        return cube

    def collapse_using(self, function):
        """
        Produce a collapsed image using a numpy aggregation function
        """
        cube, ax = self._prepare_cube()
        result = function(cube, axis=ax)
        return self._finalize(result)

    def _to_world(self, idx):
        args = [None] * self.data.ndim
        y, x = np.mgrid[:idx.shape[0], :idx.shape[1]]
        for i, s in enumerate(self.slc):
            if s not in ['x', 'y']:
                args[i] = np.ones(idx.size) * s
        args[self.slc.index('y')] = y.ravel()
        args[self.slc.index('x')] = x.ravel()
        args[self.zax] = idx.ravel()
        att = self.data.get_world_component_id(self.zax)
        return self.data[att, args].reshape(idx.shape)

    @staticmethod
    def all_operators():
        return (Aggregate.sum,
                Aggregate.mean,
                Aggregate.max,
                Aggregate.argmax,
                Aggregate.argmin,
                Aggregate.mom1,
                Aggregate.mom2,
                Aggregate.median)

    @staticmethod
    def _mean(cube, axis):
        s = np.nansum(cube, axis)
        ct = np.isfinite(cube).sum(axis)
        return 1. * s / ct

    @check_empty
    def sum(self):
        return self.collapse_using(np.nansum)

    @check_empty
    def mean(self):
        return self.collapse_using(self._mean)

    @check_empty
    def max(self):
        return self.collapse_using(np.nanmax)

    @check_empty
    def median(self):
        # NOTE: nans are treated as infinity in this case
        return self.collapse_using(np.median)

    @check_empty
    def argmax(self):
        """
        Location of peak value, in world coords
        """
        idx = self.collapse_using(np.nanargmax)
        return self._to_world(idx)

    @check_empty
    def argmin(self):
        """
        Location of minimum value, in world coords
        """
        idx = self.collapse_using(np.nanargmin)
        return self._to_world(idx)

    @check_empty
    def mom1(self):
        """
        Intensity-weighted coordinate. Pixel units.
        """
        # build up slice-by-slice, to avoid big temporary cubes
        loop = self._iter_slice_index()
        val, loc = next(loop)

        val = np.maximum(val, 0)
        w, result = val, loc * val
        for val, loc in loop:
            val = np.maximum(val, 0)
            result += val * loc
            w += val
        return self._finalize(result / w)

    @check_empty
    def mom2(self):
        """
        Intensity-weighted coordinate dispersion. Pixel units.
        """
        loop = self._iter_slice_index()
        val, loc = next(loop)

        val = np.maximum(val, 0)
        w, x, x2 = val, val * loc, val * loc * loc
        for val, loc in loop:
            val = np.maximum(val, 0)
            w += val
            x += loc * val
            x2 += loc ** 2 * val

        return self._finalize(np.sqrt(x2 / w - (x / w) ** 2))

########NEW FILE########
__FILENAME__ = application_base
from functools import wraps
import traceback

from .data_collection import DataCollection
from .data_factories import load_data
from . import command
from . import Data, Subset
from .hub import HubListener
from .util import PropertySetMixin
from .edit_subset_mode import EditSubsetMode
from .session import Session
from ..config import settings

__all__ = ['Application', 'ViewerBase']


def catch_error(msg):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                m = "%s\n%s" % (msg, e.message)
                detail = str(traceback.format_exc())
                self = args[0]
                self.report_error(m, detail)
        return wrapper
    return decorator


class Application(HubListener):

    def __init__(self, data_collection=None, session=None):
        if session is not None:
            self._session = session
            session.application = self
            self._data = session.data_collection
        else:
            self._data = data_collection or DataCollection()
            self._session = Session(data_collection=self._data,
                                    application=self)

        EditSubsetMode().data_collection = self._data
        self._hub = self._session.hub
        self._cmds = self._session.command_stack
        self._cmds.add_callback(lambda x: self._update_undo_redo_enabled())

        self._settings = {}
        for key, value, validator in settings:
            self._settings[key] = [value, validator]
        self._load_settings()

    @property
    def session(self):
        return self._session

    def new_data_viewer(self, viewer_class, data=None):
        """
        Create a new data viewer, add it to the UI,
        and populate with data
        """
        if viewer_class is None:
            return

        c = viewer_class(self._session)
        c.register_to_hub(self._session.hub)

        if data and not c.add_data(data):
            c.close(warn=False)
            return

        self.add_widget(c)
        c.show()
        return c

    @catch_error("Failed to save session")
    def save_session(self, path):
        """ Save the data collection and hub to file.

        Can be restored via restore_session

        Note: Saving of client is not currently supported. Thus,
        restoring this session will lose all current viz windows
        """
        from .state import GlueSerializer
        gs = GlueSerializer(self)
        with open(path, 'w') as out:
            gs.dump(out, indent=2)

    def new_tab(self):
        raise NotImplementedError()

    def add_widget(self, widget, label=None, tab=None):
        raise NotImplementedError()

    def close_tab(self):
        raise NotImplementedError()

    def get_setting(self, key):
        """
        Fetch the value of an application setting
        """
        return self._settings[key][0]

    def set_setting(self, key, value):
        """
        Set the value of an application setting

        Raises a KeyError if the setting does not exist
        Raises a ValueError if the value is invalid
        """
        validator = self._settings[key][1]
        self._settings[key][0] = validator(value)

    @property
    def settings(self):
        """Iterate over settings"""
        for key, (value, _) in self._settings.items():
            yield key, value

    def _load_settings(self, path=None):
        raise NotImplementedError()

    @catch_error("Could not load data")
    def load_data(self, path):
        d = load_data(path)
        if not isinstance(d, list):
            d = [d]
        self._data.extend(d)

    def report_error(self, message, detail):
        """ Report an error message to the user.
        Must be implemented in a subclass

        :param message: the message to display
        :type message: str

        :detail: Longer context about the error
        :type message: str
        """
        raise NotImplementedError()

    def do(self, command):
        self._cmds.do(command)

    def undo(self):
        try:
            self._cmds.undo()
        except RuntimeError:
            pass

    def redo(self):
        try:
            self._cmds.redo()
        except RuntimeError:
            pass

    def _update_undo_redo_enabled(self):
        raise NotImplementedError()

    @property
    def viewers(self):
        """Return a tuple of tuples of viewers currently open
        The i'th tuple stores the viewers in the i'th close_tab
        """
        raise NotImplementedError()

    def __gluestate__(self, context):
        viewers = [map(context.id, tab) for tab in self.viewers]
        data = self.session.data_collection

        return dict(session=context.id(self.session), viewers=viewers,
                    data=context.id(data))

    @classmethod
    def __setgluestate__(cls, rec, context):
        self = cls(data_collection=context.object(rec['data']))
        # manually register the newly-created session, which
        # the viewers need
        context.register_object(rec['session'], self.session)
        for i, tab in enumerate(rec['viewers']):
            if self.tab(i) is None:
                self.new_tab()
            for v in tab:
                viewer = context.object(v)
                self.add_widget(viewer, tab=i, hold_position=True)
        return self


class ViewerBase(HubListener, PropertySetMixin):

    """ Base class for data viewers in an application """

    # the glue.clients.layer_artist.LayerArtistContainer
    # class/subclass to use
    _container_cls = None

    def __init__(self, session):
        super(ViewerBase, self).__init__()

        self._session = session
        self._data = session.data_collection
        self._hub = None
        self._container = self._container_cls()

    def register_to_hub(self, hub):
        self._hub = hub

    def unregister(self, hub):
        """ Abstract method to unsubscribe from messages """
        raise NotImplementedError

    def request_add_layer(self, layer):
        """ Issue a command to add a layer """
        cmd = command.AddLayer(layer=layer, viewer=self)
        self._session.command_stack.do(cmd)

    def add_layer(self, layer):
        if isinstance(layer, Data):
            self.add_data(layer)
        elif isinstance(layer, Subset):
            self.add_subset(layer)
        # else: SubsetGroup

    def add_data(self, data):
        """ Add a data instance to the viewer

        This must be overridden by a subclass

        :param data: Data object to add
        :type data: :class:`~glue.core.data.Data`
        """
        raise NotImplementedError

    def add_subset(self, subset):
        """ Add a subset to the viewer

        This must be overridden by a subclass

        :param subset: Subset instance to add
        :type subset: :class:`~glue.core.subset.Subset`
        """
        raise NotImplementedError

    def apply_roi(self, roi):
        """
        Apply an ROI to the client

        :param roi: The ROI to apply
        :type roi: :class:`~glue.core.roi.Roi`
        """
        cmd = command.ApplyROI(client=self.client, roi=roi)
        self._session.command_stack.do(cmd)

    @property
    def session(self):
        return self._session

    @property
    def axes(self):
        return self.client.axes

    def layer_view(self):
        raise NotImplementedError()

    def options_widget(self):
        raise NotImplementedError()

    def move(self, x=None, y=None):
        """ Reposition a viewer within the application.

        :param x: Offset of viewer's left edge from the left edge
                  of the parent window. Optional
        :type x: int

        :param y: Offset of the viewer's top edge from the top edge
                  of the parent window. Optional
        :type y: int
        """
        raise NotImplementedError()

    @property
    def position(self):
        """ Return the location of the viewer

        :rtype: (x, y). Tuple of 2 integers
        """
        raise NotImplementedError()

    @property
    def viewer_size(self):
        """ Return the size of the viewer

        :rtype: (width, height). Tuple of 2 ints
        """
        raise NotImplementedError()

    @viewer_size.setter
    def viewer_size(self, value):
        """ Resize the width and/or height of the viewer

        :param value: (width, height)

        :param width: new width. Optional.
        :type width: int

        :param height: new height. Optional.
        :type height: int
        """
        raise NotImplementedError()

    def restore_layers(self, rec, context):
        """
        Given a list of glue-serialized layers, restore them
        to the viewer
        """
        # if this viewer manages a client, rely on it to restore layers
        if hasattr(self, 'client'):
            return self.client.restore_layers(rec, context)
        raise NotImplementedError()

    @property
    def layers(self):
        """Return a tuple of layers in this viewer.

        A layer is a visual representation of a dataset or subset within
        the viewer"""
        return tuple(self._container)

    def __gluestate__(self, context):
        return dict(session=context.id(self._session),
                    size=self.viewer_size,
                    pos=self.position,
                    properties=dict((k, context.id(v))
                                    for k, v in self.properties.items()),
                    layers=map(context.do, self.layers)
                    )

    @classmethod
    def __setgluestate__(cls, rec, context):
        session = context.object(rec['session'])
        result = cls(session)
        result.register_to_hub(session.hub)
        result.viewer_size = rec['size']
        x, y = rec['pos']
        result.move(x=x, y=y)

        prop = dict((k, context.object(v)) for
                    k, v in rec['properties'].items())
        result.restore_layers(rec['layers'], context)

        result.properties = prop
        return result

########NEW FILE########
__FILENAME__ = callback_property
from ..external.echo import (CallbackProperty, add_callback,
                             delay_callback, ignore_callback,
                             remove_callback, callback_property)

########NEW FILE########
__FILENAME__ = client
from .hub import HubListener
from .data import Data
from .subset import Subset
from .data_collection import DataCollection
from .message import (DataUpdateMessage,
                      SubsetUpdateMessage,
                      SubsetCreateMessage,
                      SubsetDeleteMessage,
                      DataCollectionDeleteMessage)

__all__ = ['Client', 'BasicClient']


class Client(HubListener):
    """
    Base class for interaction / visualization modules

    Attributes
    ----------
    data: DataCollection instance
        The data associated with this client.

    """

    def __init__(self, data):
        """
        Create a new client object.

        Parameters
        ----------
        data: Data, DataCollection, or list of data
            The primary data associated with this client.

        Raises
        ------
        TypeError: If the data input is the wrong type
        """
        super(Client, self).__init__()
        self._data = data
        if not isinstance(data, DataCollection):
            raise TypeError("Input data must be a DataCollection: %s"
                            % type(data))

    @property
    def data(self):
        """ Returns the data collection """
        return self._data

    def register_to_hub(self, hub):
        """The main method to establish a link with a hub,
        and set up event handlers. For common message types

        Client subclasses at a minimum should override these methods
        to provide functionality:
        _add_subset
        _update_subset
        _remove_subset
        _remove_data

        Clients can also override register_to_hub to add additional
        event handlers.

        Attributes
        ----------
        hub: The hub to subscribe to

        """
        has_data = lambda x: x.sender.data in self._data
        has_data_collection = lambda x: x.sender is self._data

        hub.subscribe(self,
                      SubsetCreateMessage,
                      handler=self._add_subset,
                      filter=has_data)
        hub.subscribe(self,
                      SubsetUpdateMessage,
                      handler=self._update_subset,
                      filter=has_data)
        hub.subscribe(self,
                      SubsetDeleteMessage,
                      handler=self._remove_subset,
                      filter=has_data)
        hub.subscribe(self,
                      DataUpdateMessage,
                      handler=self._update_data,
                      filter=has_data)
        hub.subscribe(self,
                      DataCollectionDeleteMessage,
                      handler=self._remove_data,
                      filter=has_data_collection)

    def _add_subset(self, message):
        raise NotImplementedError

    def _remove_data(self, message):
        raise NotImplementedError

    def _remove_subset(self, message):
        raise NotImplementedError

    def _update_data(self, message):
        """ Default handler for DataMessage """
        raise NotImplementedError

    def _update_subset(self, message):
        """ Default handler for SubsetUpdateMessage """
        raise NotImplementedError

    def apply_roi(self, roi):
        raise NotImplementedError


class BasicClient(Client):

    def _add_subset(self, message):
        subset = message.subset
        self.add_layer(subset)

    def _update_subset(self, message):
        subset = message.subset
        self.update_layer(subset)

    def _remove_subset(self, message):
        subset = message.subset
        self.remove_layer(subset)

    def _remove_data(self, message):
        self.remove_layer(message.data)

    def _update_data(self, message):
        self.update_layer(message.data)

    def add_layer(self, layer):
        if self.layer_present(layer):
            return
        if layer.data not in self.data:
            raise TypeError("Data not in collection")

        if isinstance(layer, Data):
            self._do_add_data(layer)
            for subset in layer.subsets:
                self.add_layer(subset)
        else:
            if not self.layer_present(layer.data):
                self.add_layer(layer.data)
            else:
                self._do_add_subset(layer)

        self.update_layer(layer)

    def update_layer(self, layer):
        if not self.layer_present(layer):
            return
        if isinstance(layer, Subset):
            self._do_update_subset(layer)
        else:
            self._do_update_data(layer)

    def remove_layer(self, layer):
        if not self.layer_present(layer):
            return
        if isinstance(layer, Data):
            self._do_remove_data(layer)
            for subset in layer.subsets:
                self._do_remove_subset(subset)
        else:
            self._do_remove_subset(layer)

    def _do_add_data(self, data):
        raise NotImplementedError

    def _do_add_subset(self, subset):
        raise NotImplementedError

    def _do_update_subset(self, subset):
        raise NotImplementedError

    def _do_update_data(self, data):
        raise NotImplementedError

    def _do_remove_subset(self, subset):
        raise NotImplementedError

    def _do_remove_data(self, data):
        raise NotImplementedError

    def layer_present(self, layer):
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = command
from abc import ABCMeta, abstractmethod
import logging

from .data_factories import load_data
from .util import CallbackMixin

MAX_UNDO = 50
"""
The classes in this module allow user actions to be stored as commands,
which can be undone/redone

All UI frontends should map interactions to command objects, instead
of directly performing an action.

Commands have access to two sources of data: the first are the
keyword arguments passed to the constructor. These are stored as
attributes of self. The second is a session object passed to all
Command.do and Command.undo calls.
"""


class Command(object):

    """
    A class to encapsulate (and possibly undo) state changes

    Subclasses of this abstract base class must implement the
    `do` and `undo` methods.

    Both `do` and `undo` receive a single input argument named
    `session` -- this is whatever object is passed to the constructor
    of :class:`glue.core.command.CommandStack`. This object is used
    to store and retrieve resources needed by each command. The
    Glue application itself uses a :class:`~glue.core.session.Session`
    instance for this.

    Each class should also override the class-level kwargs list,
    to list the required keyword arguments that should be passed to the
    command constructor. The base class will check that these
    keywords are indeed provided. Commands should not take
    non-keyword arguments in the constructor method
    """
    __metaclass__ = ABCMeta
    kwargs = []

    def __init__(self, **kwargs):
        kwargs = kwargs.copy()
        for k in self.kwargs:
            if k not in kwargs:
                raise RuntimeError("Required keyword %s not passed to %s" %
                                   (k, type(self)))
            setattr(self, k, kwargs.pop(k))
        self.extra = kwargs

    @abstractmethod
    def do(self, session):
        """
        Execute the command

        :param session: An object used to store and fetch resources
                        needed by a Command.
        """
        pass

    @abstractmethod
    def undo(self, session):
        pass

    @property
    def label(self):
        return type(self).__name__


class CommandStack(CallbackMixin):

    """
    The command stack collects commands,
    and saves them to enable undoing/redoing

    After instantiation, something can be assigned to
    the session property. This is passed as the sole argument
    of all Command (un)do methods.
    """

    def __init__(self):
        super(CommandStack, self).__init__()
        self._session = None
        self._command_stack = []
        self._undo_stack = []

    @property
    def session(self):
        return self._session

    @session.setter
    def session(self, value):
        self._session = value

    @property
    def undo_label(self):
        """ Brief label for the command reversed by an undo """
        if len(self._command_stack) == 0:
            return ''
        cmd = self._command_stack[-1]
        return cmd.label

    @property
    def redo_label(self):
        """ Brief label for the command executed on a redo"""
        if len(self._undo_stack) == 0:
            return ''
        cmd = self._undo_stack[-1]
        return cmd.label

    def do(self, cmd):
        """
        Execute and log a new command

        :rtype: The return value of cmd.do()
        """
        logging.getLogger(__name__).debug("Do %s", cmd)
        self._command_stack.append(cmd)
        result = cmd.do(self._session)
        self._command_stack = self._command_stack[-MAX_UNDO:]
        self._undo_stack = []
        self.notify('do')
        return result

    def undo(self):
        """
        Undo the previous command

        :raises: IndexError, if there are no objects to undo
        """
        try:
            c = self._command_stack.pop()
            logging.getLogger(__name__).debug("Undo %s", c)
        except IndexError:
            raise IndexError("No commands to undo")
        self._undo_stack.append(c)
        c.undo(self._session)
        self.notify('undo')

    def redo(self):
        """
        Redo the previously-undone command

        :raises: IndexError, if there are no undone actions
        """
        try:
            c = self._undo_stack.pop()
            logging.getLogger(__name__).debug("Undo %s", c)
        except IndexError:
            raise IndexError("No commands to redo")
        result = c.do(self._session)
        self._command_stack.append(c)
        self.notify('redo')
        return result

    def can_undo_redo(self):
        """
        Return whether undo and redo options are possible

        :rtype: (bool, bool) - Whether undo and redo are possible, respectively
        """
        return len(self._command_stack) > 0, len(self._undo_stack) > 0


class LoadData(Command):
    kwargs = ['path', 'factory']
    label = 'load data'

    def do(self, session):
        return load_data(self.path, self.factory)

    def undo(self, session):
        pass


class AddData(Command):
    kwargs = ['data']
    label = 'add data'

    def do(self, session):
        session.data_collection.append(self.data)

    def undo(self, session):
        session.data_collection.remove(self.data)


class RemoveData(Command):
    kwargs = ['data']
    label = 'remove data'

    def do(self, session):
        session.data_collection.remove(self.data)

    def undo(self, session):
        session.data_collection.append(self.data)


class NewDataViewer(Command):
    """Add a new data viewer to the application

    :param viewer: The class of viewer to create
    :param data: The data object to initialize the viewer with, or None
    :type date: :class:`~glue.core.Data` or None
    """
    kwargs = ['viewer', 'data']
    label = 'new data viewer'

    def do(self, session):
        v = session.application.new_data_viewer(self.viewer, self.data)
        self.created = v
        return v

    def undo(self, session):
        self.created.close(warn=False)


class AddLayer(Command):
    """Add a new layer to a viewer

    :param layer: The layer to add
    :type layer: :class:`~glue.core.Data` or :class:`~glue.core.Subset`
    :param viewer: The viewer to add the layer to
    """
    kwargs = ['layer', 'viewer']
    label = 'add layer'

    def do(self, session):
        self.viewer.add_layer(self.layer)

    def undo(self, session):
        self.viewer.remove_layer(self.layer)


class ApplyROI(Command):

    """
    Apply an ROI to a client, updating subset states

    :param client: Client to work on
    :type client: :class:`~glue.core.client.Client`

    :param roi: Roi to apply
    :type roi: :class:`~glue.core.roi.Roi`
    """
    kwargs = ['client', 'roi']
    label = 'apply ROI'

    def do(self, session):
        self.old_states = {}
        for data in self.client.data:
            for subset in data.subsets:
                self.old_states[subset] = subset.subset_state

        self.client.apply_roi(self.roi)

    def undo(self, session):
        for data in self.client.data:
            for subset in data.subsets:
                if subset not in self.old_states:
                    subset.delete()

        for k, v in self.old_states.items():
            k.subset_state = v


class LinkData(Command):
    pass


class SetViewState(Command):
    pass


class NewTab(Command):
    pass


class CloseTab(Command):
    pass


class NewSubset(Command):
    pass


class CopySubset(Command):
    pass


class PasteSubset(Command):
    pass


class SpecialPasteSubset(Command):
    pass


class DeleteSubset(Command):
    pass


class SetStyle(Command):
    pass


class SetLabel(Command):
    pass

########NEW FILE########
__FILENAME__ = component_link
import logging
import operator

import numpy as np

from .util import join_component_view
from .subset import InequalitySubsetState

__all__ = ['ComponentLink', 'BinaryComponentLink']


def identity(x):
    return x

OPSYM = {operator.add: '+', operator.sub: '-',
         operator.div: '/', operator.mul: '*',
         operator.pow: '**'}


class ComponentLink(object):

    """ ComponentLinks represent transformation logic between ComponentIDs

    ComponentLinks are be used to derive one
    :class:`~glue.core.data.ComponentID` from another:

    Example::

       def hours_to_minutes(hours):
           return hours * 60

       d = Data(hour=[1, 2, 3])
       hour = d.id['hour']
       minute = ComponentID('minute')
       link = ComponentLink( [hour], minute, using=hours_to_minutes)

       link.compute(d)  # array([ 60, 120, 180])
       d.add_component_link(link)
       d['minute'] # array([ 60, 120, 180])
    """

    def __init__(self, comp_from, comp_to, using=None, inverse=None):
        """
        :param comp_from: The input ComponentIDs
        :type comp_from: list of :class:`~glue.core.data.ComponentID`

        :param comp_to: The target component ID
        :type comp_from: :class:`~glue.core.data.ComponentID`

        :pram using: The translation function which maps data from
                     comp_from to comp_to (optional)

        The using function should satisfy::

               using(data[comp_from[0]],...,data[comp_from[-1]]) = desired data

        :param inverse:
            The inverse translation function, if exists (optional)

        :raises:
           TypeError if input is invalid

        .. note ::
            Both ``inverse`` and ``using`` should accept and return
            numpy arrays

        """
        from .data import ComponentID

        self._from = comp_from
        self._to = comp_to
        if using is None:
            using = identity
        self._using = using
        self._inverse = inverse

        self.hidden = False  # show in widgets?
        self.identity = self._using is identity

        if type(comp_from) is not list:
            raise TypeError("comp_from must be a list: %s" % type(comp_from))

        if not all(isinstance(f, ComponentID) for f in self._from):
            raise TypeError("from argument is not a list of ComponentIDs: %s" %
                            self._from)
        if not isinstance(self._to, ComponentID):
            raise TypeError("to argument is not a ComponentID: %s" %
                            type(self._to))

        if using is identity:
            if len(comp_from) != 1:
                raise TypeError("comp_from must have only 1 element, "
                                "or a 'using' function must be provided")

    def compute(self, data, view=None):
        """For a given data set, compute the component comp_to given
        the data associated with each comp_from and the ``using``
        function

        :param data: The data set to use
        :param view: Optional view (e.g. slice) through the data to use


        *Returns*:

            The data associated with comp_to component

        *Raises*:

            InvalidAttribute, if the data set doesn't have all the
            ComponentIDs needed for the transformation
        """
        logger = logging.getLogger(__name__)
        args = [data[join_component_view(f, view)] for f in self._from]
        logger.debug("shape of first argument: %s", args[0].shape)
        result = self._using(*args)
        logger.debug("shape of result: %s", result.shape)
        if result.shape != args[0].shape:
            logger.warn("ComponentLink function %s changed shape. Fixing",
                        self._using.__name__)
            result.shape = args[0].shape
        return result

    def get_from_ids(self):
        """ The list of input ComponentIDs """
        return self._from

    def replace_ids(self, old, new):
        """Replace all references to an old ComponentID with references
        to new

        :parma old: ComponentID to replace
        :param new: ComponentID to replace with
        """
        for i, f in enumerate(self._from):
            if f is old:
                self._from[i] = new
        if self._to is old:
            self._to = new

    def set_from_ids(self, _from):
        if len(_from) != len(self._from):
            raise ValueError("New ID list has the wrong length.")
        self._from = _from

    def get_to_id(self):
        """ The target ComponentID """
        return self._to

    def set_to_id(self, to):
        self._to = to

    def get_using(self):
        """ The transformation function """
        return self._using

    def get_inverse(self):
        """ The inverse transformation, or None """
        return self._inverse

    def __str__(self):
        args = ", ".join([t.label for t in self._from])
        if self._using is not identity:
            result = "%s <- %s(%s)" % (self._to, self._using.__name__, args)
        else:
            result = "%s <-> %s" % (self._to, self._from)
        return result

    def __repr__(self):
        return str(self)

    def __add__(self, other):
        return BinaryComponentLink(self, other, operator.add)

    def __radd__(self, other):
        return BinaryComponentLink(other, self, operator.add)

    def __sub__(self, other):
        return BinaryComponentLink(self, other, operator.sub)

    def __rsub__(self, other):
        return BinaryComponentLink(other, self, operator.sub)

    def __mul__(self, other):
        return BinaryComponentLink(self, other, operator.mul)

    def __rmul__(self, other):
        return BinaryComponentLink(other, self, operator.mul)

    def __div__(self, other):
        return BinaryComponentLink(self, other, operator.div)

    def __rdiv__(self, other):
        return BinaryComponentLink(other, self, operator.div)

    def __pow__(self, other):
        return BinaryComponentLink(self, other, operator.pow)

    def __rpow__(self, other):
        return BinaryComponentLink(other, self, operator.pow)

    def __lt__(self, other):
        return InequalitySubsetState(self, other, operator.lt)

    def __le__(self, other):
        return InequalitySubsetState(self, other, operator.le)

    def __gt__(self, other):
        return InequalitySubsetState(self, other, operator.gt)

    def __ge__(self, other):
        return InequalitySubsetState(self, other, operator.ge)


class CoordinateComponentLink(ComponentLink):

    def __init__(self, comp_from, comp_to, coords, index, pixel2world=True):
        self.coords = coords
        self.index = index
        self.pixel2world = pixel2world

        # Some coords don't need all pixel coords
        # to compute a given world coord, and vice versa
        # (e.g., spectral data cubes)
        self.ndim = len(comp_from)
        self.from_needed = coords.dependent_axes(index)
        self._from_all = comp_from

        comp_from = [comp_from[i] for i in self.from_needed]
        super(CoordinateComponentLink, self).__init__(
            comp_from, comp_to, self.using)
        self.hidden = True

    def using(self, *args):
        attr = 'pixel2world' if self.pixel2world else 'world2pixel'
        func = getattr(self.coords, attr)

        args2 = [None] * self.ndim
        for f, a in zip(self.from_needed, args):
            args2[f] = a
        for i in range(self.ndim):
            if args2[i] is None:
                args2[i] = np.zeros_like(args[0])
        args2 = tuple(args2)

        return func(*args2[::-1])[::-1][self.index]

    def __str__(self):
        rep = 'pix2world' if self.pixel2world else 'world2pix'
        sup = super(CoordinateComponentLink, self).__str__()
        return sup.replace('using', rep)


class BinaryComponentLink(ComponentLink):

    """
    A ComponentLink that combines two inputs with a binary function

    :param left: The first input argument.
                 ComponentID, ComponentLink, or number

    :param right: The second input argument.
                  ComponentID, ComponentLink, or number

    :param op: A function with two inputs that works on numpy arrays

    The CompoentLink represents the logic of applying `op` to the
    data associated with the inputs `left` and `right`.
    """

    def __init__(self, left, right, op):
        from .data import ComponentID

        self._left = left
        self._right = right
        self._op = op

        from_ = []
        if isinstance(left, ComponentID):
            from_.append(left)
        elif isinstance(left, ComponentLink):
            from_.extend(left.get_from_ids())
        elif not operator.isNumberType(left):
            raise TypeError("Cannot create BinaryComponentLink using %s" %
                            left)

        if isinstance(right, ComponentID):
            from_.append(right)
        elif isinstance(right, ComponentLink):
            from_.extend(right.get_from_ids())
        elif not operator.isNumberType(right):
            raise TypeError("Cannot create BinaryComponentLink using %s" %
                            right)

        to = ComponentID("")
        null = lambda *args: None
        super(BinaryComponentLink, self).__init__(from_, to, null)

    def replace_ids(self, old, new):
        super(BinaryComponentLink, self).replace_ids(old, new)
        if self._left is old:
            self._left = new
        elif isinstance(self._left, ComponentLink):
            self._left.replace_ids(old, new)
        if self._right is old:
            self._right = new
        elif isinstance(self._right, ComponentLink):
            self._right.replace_ids(old, new)

    def compute(self, data, view=None):
        l = self._left
        r = self._right
        if not operator.isNumberType(self._left):
            l = data[self._left, view]
        if not operator.isNumberType(self._right):
            r = data[self._right, view]
        return self._op(l, r)

    def __str__(self):
        sym = OPSYM.get(self._op, self._op.__name__)
        return '(%s %s %s)' % (self._left, sym, self._right)

    def __repr__(self):
        return "<BinaryComponentLink: %s>" % self

########NEW FILE########
__FILENAME__ = coordinates
import logging

import numpy as np

__all__ = ['Coordinates', 'WCSCoordinates']


class Coordinates(object):

    '''
    Base class for coordinate transformation
    '''

    def __init__(self):
        pass

    def pixel2world(self, *args):
        return args

    def world2pixel(self, *args):
        return args

    def axis_label(self, axis):
        return "World %i" % axis

    def dependent_axes(self, axis):
        """Return a tuple of which world-axes are non-indepndent
        from a given pixel axis

        The axis index is given in numpy ordering convention (note that
        opposite the fits convention)
        """
        return (axis,)

    def __gluestate__(self, context):
        return {}  # no state

    @classmethod
    def __setgluestate__(cls, rec, context):
        return cls()


class WCSCoordinates(Coordinates):

    '''
    Class for coordinate transformation based on the WCS FITS
    standard.  This class does not take into account
    distortions.

    References
    ----------
      * Greisen & Calabretta (2002), Astronomy and Astrophysics, 395, 1061
      * Calabretta & Greisen (2002), Astronomy and Astrophysics, 395, 1077
      * Greisen, Calabretta, Valdes & Allen (2006), Astronomy and
        Astrophysics, 446, 747
    '''

    def __init__(self, header, wcs=None):
        super(WCSCoordinates, self).__init__()
        from ..external.astro import WCS

        self._header = header
        wcs = wcs or WCS(header)

        # update WCS interface if using old API
        mapping = {'wcs_pix2world': 'wcs_pix2sky',
                   'wcs_world2pix': 'wcs_sky2pix',
                   'all_pix2world': 'all_pix2sky'}
        for k, v in mapping.items():
            if not hasattr(wcs, k):
                setattr(wcs, k, getattr(wcs, v))

        self._wcs = wcs

    @property
    def wcs(self):
        return self._wcs

    @property
    def header(self):
        return self._header

    def dependent_axes(self, axis):
        # if distorted, all bets are off
        try:
            if any([self._wcs.sip, self._wcs.det2im1, self._wcs.det2im2]):
                return tuple(range(ndim))
        except AttributeError:
            pass

        # here, axis is the index number in numpy convention
        # we flip with [::-1] because WCS and numpy index
        # conventions are reversed
        pc = np.array(self._wcs.wcs.get_pc()[::-1, ::-1])
        ndim = pc.shape[0]
        pc[np.eye(ndim, dtype=np.bool)] = 0
        axes = self._wcs.get_axis_types()[::-1]

        # axes rotated
        if pc[axis, :].any() or pc[:, axis].any():
            return tuple(range(ndim))

        # XXX can spectral still couple with other axes by this point??
        if axes[axis].get('coordinate_type') != 'celestial':
            return (axis,)

        # in some cases, even the celestial coordinates are
        # independent. We don't catch that here.
        return tuple(i for i, a in enumerate(axes) if
                     a.get('coordinate_type') == 'celestial')

    def __setstate__(self, state):
        self.__dict__ = state
        # wcs object doesn't seem to unpickle properly. reconstruct it
        from ..external.astro import WCS
        self._wcs = WCS(self._header)

    def pixel2world(self, *pixel):
        '''
        Convert pixel to world coordinates, preserving input type/shape

        :param args: xpix, ypix[, zpix]: scalars, lists, or Numpy arrays
                     The pixel coordinates to convert

        *Returns*

        xworld, yworld, [zworld]: scalars, lists or Numpy arrays
            The corresponding world coordinates
        '''
        arrs = [np.asarray(p) for p in pixel]
        pix = np.vstack(a.ravel() for a in arrs).T
        result = tuple(self._wcs.wcs_pix2world(pix, 0).T)
        for r, a in zip(result, arrs):
            r.shape = a.shape
        return result

    def world2pixel(self, *world):
        '''
        Convert pixel to world coordinates, preserving input type/shape

        :param world:
            xworld, yworld[, zworld] : scalars, lists or Numpy arrays
            The world coordinates to convert

        *Returns*

        xpix, ypix: scalars, lists, or Numpy arrays
            The corresponding pixel coordinates
        '''
        arrs = [np.asarray(w) for w in world]
        pix = np.vstack(a.ravel() for a in arrs).T
        result = tuple(self._wcs.wcs_world2pix(pix, 0).T)
        for r, a in zip(result, arrs):
            r.shape = a.shape
        return result

    def axis_label(self, axis):
        header = self._header
        ndim = _get_ndim(header)
        num = _get_ndim(header) - axis  # number orientation reversed
        ax = self._header.get('CTYPE%i' % num)
        if ax is not None:
            if len(ax) == 8 or '-' in ax:  # assume standard format
                ax = ax[:5].split('-')[0].title()
            else:
                ax = ax.title()

            translate = dict(
                Glon='Galactic Longitude',
                Glat='Galactic Latitude',
                Ra='Right Ascension',
                Dec='Declination',
                Velo='Velocity',
                Freq='Frequency'
            )
            return translate.get(ax, ax)
        return super(WCSCoordinates, self).axis_label(axis)

    def __gluestate__(self, context):
        return dict(header=self._wcs.to_header_string())

    @classmethod
    def __setgluestate__(cls, rec, context):
        from ..external.astro import fits
        return cls(fits.Header.fromstring(rec['header']))


def coordinates_from_header(header):
    """ Convert a FITS header into a glue Coordinates object

    :param header: Header to convert
    :type header: :class:`astropy.io.fits.Header`

    :rtype: :class:`~glue.core.coordinates.Coordinates`
    """
    try:
        return WCSCoordinates(header)
    except (AttributeError, TypeError, AssertionError) as e:
        print e
        pass
    return Coordinates()


def _get_ndim(header):
    if 'NAXIS' in header:
        return header['NAXIS']
    if 'WCSAXES' in header:
        return header['WCSAXES']
    return None


def coordinates_from_wcs(wcs):
    """Convert a wcs object into a glue Coordinates object

    :param wcs: The WCS object to use
    :rtype: :class:`~glue.core.coordinates.Coordinates`
    """
    from ..external.astro import fits
    hdr_str = wcs.wcs.to_header()
    hdr = fits.Header.fromstring(hdr_str)
    try:
        return WCSCoordinates(hdr, wcs)
    except (AttributeError, TypeError) as e:
        print e
        pass
    return Coordinates()


def header_from_string(string):
    """
    Convert a string to a FITS header
    """
    from ..external.astro import fits
    cards = []
    for s in string.splitlines():
        try:
            l, r = s.split('=')
            key = l.strip()
            value = r.split('/')[0].strip()
            try:
                value = int(value)
            except ValueError:
                pass
        except ValueError:
            continue
        cards.append(fits.Card(key, value))
    return fits.Header(cards)

########NEW FILE########
__FILENAME__ = data
import operator
import logging

import numpy as np
import pandas as pd

from .coordinates import Coordinates
from .visual import VisualAttributes
from .visual import COLORS
from .exceptions import IncompatibleAttribute
from .component_link import (ComponentLink, CoordinateComponentLink,
                             BinaryComponentLink)
from .subset import Subset, InequalitySubsetState, SubsetState
from .hub import Hub
from .util import (split_component_view, view_shape,
                   coerce_numeric, check_sorted)
from .message import (DataUpdateMessage,
                      DataAddComponentMessage,
                      SubsetCreateMessage, ComponentsChangedMessage)

from .odict import OrderedDict

__all__ = ['Data', 'ComponentID', 'Component', 'DerivedComponent',
           'CategoricalComponent', 'CoordinateComponent']

# access to ComponentIDs via .item[name]


class ComponentIDDict(object):

    def __init__(self, data, **kwargs):
        self.data = data

    def __getitem__(self, key):
        result = self.data.find_component_id(key)
        if result is None:
            raise KeyError("ComponentID not found or not unique: %s"
                           % key)
        return result


class ComponentID(object):

    """ References a :class:`Component` object within a :class:`Data` object.

    ComponentIDs behave as keys::

       component_id = data.id[name]
       data[component_id] -> numpy array

    """

    def __init__(self, label, hidden=False):
        """:param label: Name for the ID
           :type label: str"""
        self._label = label
        self._hidden = hidden

    @property
    def label(self):
        return self._label

    @label.setter
    def label(self, value):
        """Change label.

        .. warning::
            Label changes are not currently tracked by client
            classes. Label's should only be changd before creating other
            client objects
        """
        self._label = value

    @property
    def hidden(self):
        """Whether to hide the component by default"""
        return self._hidden

    def __str__(self):
        return str(self._label)

    def __repr__(self):
        return str(self._label)

    def __gt__(self, other):
        return InequalitySubsetState(self, other, operator.gt)

    def __ge__(self, other):
        return InequalitySubsetState(self, other, operator.ge)

    def __lt__(self, other):
        return InequalitySubsetState(self, other, operator.lt)

    def __le__(self, other):
        return InequalitySubsetState(self, other, operator.le)

    def __add__(self, other):
        return BinaryComponentLink(self, other, operator.add)

    def __radd__(self, other):
        return BinaryComponentLink(other, self, operator.add)

    def __sub__(self, other):
        return BinaryComponentLink(self, other, operator.sub)

    def __rsub__(self, other):
        return BinaryComponentLink(other, self, operator.sub)

    def __mul__(self, other):
        return BinaryComponentLink(self, other, operator.mul)

    def __rmul__(self, other):
        return BinaryComponentLink(other, self, operator.mul)

    def __div__(self, other):
        return BinaryComponentLink(self, other, operator.div)

    def __rdiv__(self, other):
        return BinaryComponentLink(other, self, operator.div)

    def __pow__(self, other):
        return BinaryComponentLink(self, other, operator.pow)

    def __rpow__(self, other):
        return BinaryComponentLink(other, self, operator.pow)


class Component(object):

    """ Stores the actual, numerical information for a particular quantity

    Data objects hold one or more components, accessed via
    ComponentIDs. All Components in a data set must have the same
    shape and number of dimensions

    Note
    ----
    Instead of instantiating Components directly, consider using
    :meth:`Component.autotyped`, which chooses a subclass most appropriate
    for the data type.
    """

    def __init__(self, data, units=None):
        """
        :param data: The data to store
        :type data: :class:`numpy.ndarray`

        :param units: Optional unit label
        :type units: str
        """

        # The physical units of the data
        self.units = units

        # The actual data
        # subclasses may pass non-arrays here as placeholders.
        if isinstance(data, np.ndarray):
            data = coerce_numeric(data)
            data.setflags(write=False)  # data is read-only

        self._data = data

    @property
    def hidden(self):
        """Whether the Component is hidden by default"""
        return False

    @property
    def data(self):
        """ The underlying :class:`numpy.ndarray` """
        return self._data

    @property
    def shape(self):
        """ Tuple of array dimensions """
        return self._data.shape

    @property
    def ndim(self):
        """ The number of dimensions """
        return len(self._data.shape)

    def __getitem__(self, key):
        logging.debug("Using %s to index data of shape %s", key, self.shape)
        return self._data[key]

    @property
    def numeric(self):
        """
        Whether or not the datatype is numeric
        """
        return np.can_cast(self.data[0], np.complex)

    def __str__(self):
        return "Component with shape %s" % (self.shape,)

    def jitter(self, method=None):
        raise NotImplementedError

    def to_series(self, **kwargs):
        """ Convert into a pandas.Series object.

        :param kwargs: All kwargs are passed to the Series constructor.
        :return: pandas.Series
        """

        return pd.Series(self.data.ravel(), **kwargs)

    @classmethod
    def autotyped(cls, data, units=None):
        """
        Automatically choose between Component and CategoricalComponent,
        based on the input data type.

        :param data: The data to pack into a Component
        :type data: Array-like
        :param units: Optional units
        :type units: str

        :returns: A Component (or subclass)
        """
        data = np.asarray(data)
        n = coerce_numeric(data)
        thresh = 0.5
        if np.isfinite(n).mean() > thresh:
            return Component(n, units=units)
        elif np.issubdtype(data.dtype, np.character):
            return CategoricalComponent(data, units=units)

        return Component(data, units=units)


class DerivedComponent(Component):

    """ A component which derives its data from a function """

    def __init__(self, data, link, units=None):
        """
        :param data: The data object to use for calculation
        :type data: :class:`~glue.core.data.Data`

        :param link: The link that carries out the function
        :type link: :class:`~glue.core.component_link.ComponentLink`

        :param units: Optional unit description
        """
        super(DerivedComponent, self).__init__(data, units=units)
        self._link = link

    def set_parent(self, data):
        """ Reassign the Data object that this DerivedComponent operates on """
        self._data = data

    @property
    def hidden(self):
        return self._link.hidden

    @property
    def data(self):
        """ Return the numerical data as a numpy array """
        return self._link.compute(self._data)

    @property
    def link(self):
        """ Return the component link """
        return self._link

    def __getitem__(self, key):
        return self._link.compute(self._data, key)


class CoordinateComponent(Component):

    """
    Components associated with pixel or world coordinates

    The numerical values are computed on the fly.
    """

    def __init__(self, data, axis, world=False):
        super(CoordinateComponent, self).__init__(None, None)
        self.world = world
        self._data = data
        self.axis = axis

    @property
    def data(self):
        return self._calculate()

    def _calculate(self, view=None):
        slices = [slice(0, s, 1) for s in self.shape]
        grids = np.broadcast_arrays(*np.ogrid[slices])
        if view is not None:
            grids = [g[view] for g in grids]

        if self.world:
            world = self._data.coords.pixel2world(*grids[::-1])[::-1]
            return world[self.axis]
        else:
            return grids[self.axis]

    @property
    def shape(self):
        """ Tuple of array dimensions. """
        return self._data.shape

    @property
    def ndim(self):
        """ Number of dimensions """
        return len(self._data.shape)

    def __getitem__(self, key):
        return self._calculate(key)

    def __lt__(self, other):
        if self.world == other.world:
            return self.axis < other.axis
        return self.world

    def __gluestate__(self, context):
        return dict(axis=self.axis, world=self.world)

    @classmethod
    def __setgluestate__(cls, rec, context):
        return cls(None, rec['axis'], rec['world'])


class CategoricalComponent(Component):

    """
    Container for categorical data.
    """

    def __init__(self, categorical_data, categories=None, jitter=None, units=None):
        """
        :param categorical_data: The underlying :class:`numpy.ndarray`
        :param categories: List of unique values in the data
        :jitter: Strategy for jittering the data
        """
        super(CategoricalComponent, self).__init__(None, units)
        self._categorical_data = np.asarray(categorical_data, dtype=np.object)
        self._categorical_data.setflags(write=False)

        self._categories = categories
        self._jitter_method = jitter
        self._is_jittered = False
        self._data = None
        if self._categories is None:
            self._update_categories()
        else:
            self._update_data()

    def _update_categories(self, categories=None):
        """
        :param categories: A sorted array of categories to find in the dataset.
        If None the categories are the unique items in the data.
        :return: None
        """
        if categories is None:
            categories, inv = np.unique(self._categorical_data,
                                        return_inverse=True)
            self._categories = categories
            self._data = inv.astype(np.float)
            self._data.setflags(write=False)
            self.jitter(method=self._jitter_method)
        else:
            if check_sorted(categories):
                self._categories = categories
                self._update_data()
            else:
                raise ValueError("Provided categories must be Sorted")

    def _update_data(self):
        """ Converts the categorical data into the numeric representations
        given self._categories
        """
        self._is_jittered = False
        # Complicated because of the case of items not in
        # self._categories may be on either side of the sorted list
        left = np.searchsorted(self._categories,
                               self._categorical_data,
                               side='left')
        right = np.searchsorted(self._categories,
                                self._categorical_data,
                                side='right')
        self._data = left.astype(float)
        self._data[(left == 0) & (right == 0)] = np.nan
        self._data[left == len(self._categories)] = np.nan

        self._data[self._data == len(self._categories)] = np.nan
        self.jitter(method=self._jitter_method)
        self._data.setflags(write=False)

    def jitter(self, method=None):
        """
        Jitter the data so the density of points can be easily seen in a
        scatter plot.

        :param method: None | 'uniform':

        * None: No jittering is done (or any jittering is undone).
        * uniform: A unformly distributed random variable (-0.5, 0.5)
            is applied to each point.

        :return: None
        """

        if method not in {'uniform', None}:
            raise ValueError('%s jitter not supported' % method)
        self._jitter_method = method
        seed = 1234567890
        rand_state = np.random.RandomState(seed)

        if (self._jitter_method is None) and self._is_jittered:
            self._update_data()
        elif (self._jitter_method is 'uniform') and not self._is_jittered:
            iswrite = self._data.flags['WRITEABLE']
            self._data.setflags(write=True)
            self._data += rand_state.uniform(-0.5, 0.5, size=self._data.shape)
            self._is_jittered = True
            self._data.setflags(write=iswrite)

    def to_series(self, **kwargs):
        """ Convert into a pandas.Series object.

        This will be converted as a dtype=np.object!

        :param kwargs: All kwargs are passed to the Series constructor.
        :return: pandas.Series
        """

        return pd.Series(self._categorical_data.ravel(),
                         dtype=np.object, **kwargs)


class Data(object):

    """The basic data container in Glue.

    The data object stores data as a collection of
    :class:`~glue.core.data.Component` objects.  Each component stored in a
    dataset must have the same shape.

    Catalog data sets are stored such that each column is a distinct
    1-dimensional :class:`~glue.core.data.Component`.

    There are several ways to extract the actual numerical data stored in a
    :class:`~glue.core.data.Data` object::

       data = Data(x=[1, 2, 3], label='data')
       xid = data.id['x']

       data[xid]
       data.get_component(xid).data
       data['x']  # if 'x' is a unique component name

    Likewise, datasets support :ref:`fancy indexing <numpy:basics.indexing>`::

        data[xid, 0:2]
        data[xid, [True, False, True]]

    See also: :ref:`data_tutorial`
    """

    def __init__(self, label="", **kwargs):
        """

        :param label: label for data
        :type label: str

        Extra array-like keywords are extracted into components
        """
        # Coordinate conversion object
        self.coords = Coordinates()
        self._shape = ()

        # Components
        self._components = OrderedDict()
        self._pixel_component_ids = []
        self._world_component_ids = []

        self.id = ComponentIDDict(self)

        # Tree description of the data
        # (Deprecated)
        self.tree = None

        # Subsets of the data
        self._subsets = []

        # Hub that the data is attached to
        self.hub = None

        self.style = VisualAttributes(parent=self)

        self._coordinate_links = None

        self.data = self
        self.label = label

        self.edit_subset = None

        for lbl, data in kwargs.items():
            self.add_component(data, lbl)

    @property
    def subsets(self):
        """
        Tuple of subsets attached to this dataset
        """
        return tuple(self._subsets)

    @property
    def ndim(self):
        """
        Dimensionality of the dataset
        """
        return len(self.shape)

    @property
    def shape(self):
        """
        Tuple of array dimensions, like :attr:`numpy.ndarray.shape`
        """
        return self._shape

    @property
    def label(self):
        """ Convenience access to data set's label """
        return self._label

    @label.setter
    def label(self, value):
        """ Set the label to value
        """
        self._label = value
        self.broadcast(attribute='label')

    @property
    def size(self):
        """
        Total number of elements in the dataset.
        """
        return np.product(self.shape)

    def _check_can_add(self, component):
        if isinstance(component, DerivedComponent):
            return component._data is self
        else:
            if len(self._components) == 0:
                return True
            return component.shape == self.shape

    def dtype(self, cid):
        """Lookup the dtype for the data associated with a ComponentID"""

        # grab a small piece of data
        ind = tuple([slice(0, 1)] * self.ndim)
        arr = self[cid, ind]
        return arr.dtype

    def remove_component(self, component_id):
        """ Remove a component from a data set

        :param component_id: the component to remove
        :type component_id: :class:`~glue.core.data.ComponentID`
        """
        if component_id in self._components:
            self._components.pop(component_id)

    def add_component(self, component, label, hidden=False):
        """ Add a new component to this data set.

        :param component: object to add
        :param label:
              The label. If this is a string,
              a new :class:`ComponentID` with this label will be
              created and associated with the Component

        :type component: :class:`~glue.core.data.Component` or
                         array-like
        :type label: :class:`str` or :class:`~glue.core.data.ComponentID`

        :raises:

           TypeError, if label is invalid
           ValueError if the component has an incompatible shape

        :returns:

           The ComponentID associated with the newly-added component
        """
        if not isinstance(component, Component):
            component = Component.autotyped(component)

        if isinstance(component, DerivedComponent):
            component.set_parent(self)

        if not(self._check_can_add(component)):
            raise ValueError("The dimensions of component %s are "
                             "incompatible with the dimensions of this data: "
                             "%r vs %r" % (label, component.shape, self.shape))

        if isinstance(label, ComponentID):
            component_id = label
        elif isinstance(label, basestring):
            component_id = ComponentID(label, hidden=hidden)
        else:
            raise TypeError("label must be a ComponentID or string")

        is_present = component_id in self._components
        self._components[component_id] = component

        first_component = len(self._components) == 1
        if first_component:
            if isinstance(component, DerivedComponent):
                raise TypeError("Cannot add a derived component as "
                                "first component")
            self._shape = component.shape
            self._create_pixel_and_world_components()

        if self.hub and (not is_present):
            msg = DataAddComponentMessage(self, component_id)
            self.hub.broadcast(msg)
            msg = ComponentsChangedMessage(self)
            self.hub.broadcast(msg)

        return component_id

    def add_component_link(self, link, cid=None):
        """ Shortcut method for generating a new :class:`DerivedComponent`
        from a ComponentLink object, and adding it to a data set.

        :param link: :class:`~glue.core.component_link.ComponentLink`

        :returns:
            The :class:`DerivedComponent` that was added
        """
        if cid is not None:
            if isinstance(cid, basestring):
                cid = ComponentID(cid)
            link.set_to_id(cid)

        if link.get_to_id() is None:
            raise TypeError("Cannot add component_link: "
                            "has no 'to' ComponentID")

        dc = DerivedComponent(self, link)
        to_ = link.get_to_id()
        self.add_component(dc, to_)
        return dc

    def _create_pixel_and_world_components(self):
        for i in range(self.ndim):
            comp = CoordinateComponent(self, i)
            label = pixel_label(i, self.ndim)
            cid = self.add_component(comp, "Pixel %s" % label, hidden=True)
            self._pixel_component_ids.append(cid)
        if self.coords:
            for i in range(self.ndim):
                comp = CoordinateComponent(self, i, world=True)
                label = self.coords.axis_label(i)
                cid = self.add_component(comp, label, hidden=True)
                self._world_component_ids.append(cid)

    @property
    def components(self):
        """ All :class:`ComponentIDs <ComponentID>` in the Data

        :rtype: list
        """
        return sorted(self._components.keys(), key=lambda x: x.label)

    @property
    def visible_components(self):
        """ :class:`ComponentIDs <ComponentID>` for all non-hidden components.

        :rtype: list
        """
        return [cid for cid, comp in self._components.items()
                if not cid.hidden and not comp.hidden]

    @property
    def primary_components(self):
        """The ComponentIDs not associated with a :class:`DerivedComponent`

        :rtype: list
        """
        return [c for c in self.component_ids() if
                not isinstance(self._components[c], DerivedComponent)]

    @property
    def derived_components(self):
        """The ComponentIDs for each :class:`DerivedComponent`

        :rtype: list
        """
        return [c for c in self.component_ids() if
                isinstance(self._components[c], DerivedComponent)]

    @property
    def pixel_component_ids(self):
        """
        The :class:`ComponentIDs <ComponentID>` for each pixel coordinate.
        """
        return self._pixel_component_ids

    @property
    def world_component_ids(self):
        """
        The :class:`ComponentIDs <ComponentID>` for each world coordinate.
        """
        return self._world_component_ids

    def find_component_id(self, label):
        """ Retrieve component_ids associated by label name.

        :param label: string to search for

        :returns:
            The associated ComponentID if label is found and unique, else None
        """
        result = [cid for cid in self.component_ids() if
                  cid.label == label]
        if len(result) == 1:
            return result[0]

    @property
    def coordinate_links(self):
        """A list of the ComponentLinks that connect pixel and
        world. If no coordinate transformation object is present,
        return an empty list.
        """
        if self._coordinate_links:
            return self._coordinate_links

        if not self.coords:
            return []

        if self.ndim != len(self._pixel_component_ids) or \
                self.ndim != len(self._world_component_ids):
                # haven't populated pixel, world coordinates yet
            return []

        def make_toworld_func(i):
            def pix2world(*args):
                return self.coords.pixel2world(*args[::-1])[::-1][i]
            return pix2world

        def make_topixel_func(i):
            def world2pix(*args):
                return self.coords.world2pixel(*args[::-1])[::-1][i]
            return world2pix

        result = []
        for i in range(self.ndim):
            link = CoordinateComponentLink(self._pixel_component_ids,
                                           self._world_component_ids[i],
                                           self.coords, i)
            result.append(link)
            link = CoordinateComponentLink(self._world_component_ids,
                                           self._pixel_component_ids[i],
                                           self.coords, i, pixel2world=False)
            result.append(link)

        self._coordinate_links = result
        return result

    def get_pixel_component_id(self, axis):
        """Return the pixel :class:`ComponentID` associated with a given axis
        """
        return self._pixel_component_ids[axis]

    def get_world_component_id(self, axis):
        """Return the world :class:`ComponentID` associated with a given axis
        """
        return self._world_component_ids[axis]

    def component_ids(self):
        """
        Equivalent to :attr:`Data.components`
        """
        return list(self._components.keys())

    def new_subset(self, subset=None, color=None, label=None, **kwargs):
        """
        Create a new subset, and attach to self.

        .. note:: The preferred way for creating subsets is via
            :meth:`~glue.core.data_collection.DataCollection.new_subset_group`.
            Manually-instantiated subsets will **not** be
            represented properly by the UI

        :param subset: optional, reference subset or subset state.
                       If provided, the new subset will copy the logic of
                       this subset.

        :returns: The new subset object
        """
        nsub = len(self.subsets)
        color = color or COLORS[nsub % len(COLORS)]
        label = label or "%s.%i" % (self.label, nsub + 1)
        new_subset = Subset(self, color=color, label=label, **kwargs)
        if subset is not None:
            new_subset.subset_state = subset.subset_state.copy()

        self.add_subset(new_subset)
        return new_subset

    def add_subset(self, subset):
        """Assign a pre-existing subset to this data object.

        :param subset: A :class:`~glue.core.subset.Subset` or
                       :class:`~glue.core.subset.SubsetState` object

        If input is a :class:`~glue.core.subset.SubsetState`,
        it will be wrapped in a new Subset automatically

        .. note:: The preferred way for creating subsets is via
            :meth:`~glue.core.data_collection.DataCollection.new_subset_group`.
            Manually-instantiated subsets will **not** be
            represented properly by the UI
        """
        if subset in self.subsets:
            return  # prevents infinite recursion
        if isinstance(subset, SubsetState):
            # auto-wrap state in subset
            state = subset
            subset = Subset(None)
            subset.subset_state = state

        self._subsets.append(subset)

        if subset.data is not self:
            subset.do_broadcast(False)
            subset.data = self
            subset.label = subset.label  # hacky. disambiguates name if needed

        if self.hub is not None:
            msg = SubsetCreateMessage(subset)
            self.hub.broadcast(msg)

        subset.do_broadcast(True)

    def register_to_hub(self, hub):
        """ Connect to a hub.

        This method usually doesn't have to be called directly, as
        DataCollections manage the registration of data objects
        """
        if not isinstance(hub, Hub):
            raise TypeError("input is not a Hub object: %s" % type(hub))
        self.hub = hub

    def broadcast(self, attribute=None):
        """
        Send a :class:`~glue.core.message.DataUpdateMessage` to the hub

        :param attribute: Name of an attribute that has changed
        :type attribute: str
        """
        if not self.hub:
            return
        msg = DataUpdateMessage(self, attribute=attribute)
        self.hub.broadcast(msg)

    def update_id(self, old, new):
        """Reassign a component to a different :class:`ComponentID`

        :param old: The old :class:`ComponentID`.
        :param new: The new :class:`ComponentID`.
        """
        changed = False
        if old in self._components:
            self._components[new] = self._components.pop(old)
            changed = True
        try:
            index = self._pixel_component_ids.index(old)
            self._pixel_component_ids[index] = new
            changed = True
        except ValueError:
            pass
        try:
            index = self._world_component_ids.index(old)
            self._world_component_ids[index] = new
            changed = True
        except ValueError:
            pass

        if changed and self.hub is not None:
            self.hub.broadcast(ComponentsChangedMessage(self))

    def __str__(self):
        s = "Data Set: %s" % self.label
        s += "Number of dimensions: %i\n" % self.ndim
        s += "Shape: %s\n" % ' x '.join([str(x) for x in self.shape])
        s += "Components:\n"
        for i, component in enumerate(self._components):
            s += " %i) %s\n" % (i, component)
        return s[:-1]

    def __repr__(self):
        return 'Data (label: %s)' % self.label

    def __setattr__(self, name, value):
        if name == "hub" and hasattr(self, 'hub') \
                and self.hub is not value and self.hub is not None:
            raise AttributeError("Data has already been assigned "
                                 "to a different hub")
        object.__setattr__(self, name, value)

    def __getitem__(self, key):
        """ Shortcut syntax to access the numerical data in a component.
        Equivalent to:

        ``component = data.get_component(component_id).data``

        :param key:
          The component to fetch data from

        :type key: :class:`~glue.core.data.ComponentID`

        :returns: :class:`~numpy.ndarray`
        """
        key, view = split_component_view(key)
        if isinstance(key, basestring):
            _k = key
            key = self.find_component_id(key)
            if key is None:
                raise IncompatibleAttribute(_k)

        if isinstance(key, ComponentLink):
            return key.compute(self, view)

        try:
            comp = self._components[key]
        except KeyError:
            raise IncompatibleAttribute(key)

        shp = view_shape(self.shape, view)
        if view is not None:
            result = comp[view]
        else:
            result = comp.data

        assert result.shape == shp, \
            "Component view returned bad shape: %s %s" % (result.shape, shp)
        return result

    def get_component(self, component_id):
        """Fetch the component corresponding to component_id.

        :param component_id: the component_id to retrieve
        """
        if component_id is None:
            raise IncompatibleAttribute()

        if isinstance(component_id, basestring):
            component_id = self.id[component_id]

        try:
            return self._components[component_id]
        except KeyError:
            raise IncompatibleAttribute(component_id)

    def to_dataframe(self, index=None):
        """ Convert the Data object into a pandas.DataFrame object

        :param index: Any 'index-like' object that can be passed to the
        pandas.Series constructor

        :return: pandas.DataFrame
        """

        h = lambda comp: self.get_component(comp).to_series(index=index)
        df = pd.DataFrame({comp.label: h(comp) for comp in self.components})
        order = [comp.label for comp in self.components]
        return df[order]


def pixel_label(i, ndim):
    if ndim == 2:
        return ['y', 'x'][i]
    if ndim == 3:
        return ['z', 'y', 'x'][i]
    return "Axis %s" % i

########NEW FILE########
__FILENAME__ = data_collection
from .hub import Hub, HubListener
from .data import Data
from .link_manager import LinkManager
from .registry import Registry
from .visual import COLORS
from .message import (DataCollectionAddMessage,
                      DataCollectionDeleteMessage,
                      DataAddComponentMessage)
from .util import as_list

__all__ = ['DataCollection']


class DataCollection(HubListener):

    """The top-level object for interacting with datasets in Glue.

    DataCollections have the following responsibilities:

       * Providing a way to retrieve and store data
       * Broadcasting messages when data are added or removed
       * Keeping each managed data set's list of
         :class:`~glue.core.data.DerivedComponent` instances up-to-date
       * Creating the hub that all other objects should use to communicate
         with one another (stored in ``self.hub``)
    """

    def __init__(self, data=None):
        """
        :param data: :class:`~glue.core.data.Data` object, or list of such objects
        """
        super(DataCollection, self).__init__()
        self._link_manager = LinkManager()
        self._data = []

        self.hub = None

        self._subset_groups = []
        self.register_to_hub(Hub())
        self.extend(as_list(data or []))
        self._sg_count = 0

    @property
    def data(self):
        """ The :class:`~glue.core.data.Data` objects in the collection """
        return self._data

    def append(self, data):
        """ Add a new dataset to this collection.

        Appending emits a DataCollectionAddMessage.
        It also updates the list of DerivedComponents that each
        data set can work with.

        :param data: :class:`~glue.core.data.Data` object to add
        """
        if isinstance(data, list):
            self.extend(data)
            return
        if data in self:
            return
        self._data.append(data)
        if self.hub:
            data.register_to_hub(self.hub)
            for s in data.subsets:
                s.register()
            msg = DataCollectionAddMessage(self, data)
            self.hub.broadcast(msg)
        self._sync_link_manager()

    def extend(self, data):
        """Add several new datasets to this collection

        See :meth:`append` for more information

        :param data: List of data objects to add
        """
        [self.append(d) for d in data]

    def remove(self, data):
        """ Remove a data set from the collection

        Emits a DataCollectionDeleteMessage

        :param data: the object to remove
        :type data: :class:`~glue.core.data.Data`
        """
        if data not in self._data:
            return
        self._data.remove(data)
        Registry().unregister(data, Data)
        if self.hub:
            msg = DataCollectionDeleteMessage(self, data)
            self.hub.broadcast(msg)

    def _sync_link_manager(self):
        """ update the LinkManager, so all the DerivedComponents
        for each data set are up-to-date
        """

        # add any links in the data
        for d in self._data:
            for derived in d.derived_components:
                self._link_manager.add_link(d.get_component(derived).link)
            for link in d.coordinate_links:
                self._link_manager.add_link(link)

        for d in self._data:
            self._link_manager.update_data_components(d)

    @property
    def links(self):
        """
        Tuple of :class:`~glue.core.component_link.ComponentLink` objects.
        """
        return tuple(self._link_manager.links)

    def add_link(self, links):
        """Add one or more links to the data collection.

        This will auto-update the components in each data set

        :param links:
           The links to add. A scalar or list of
           :class:`~glue.core.component_link.ComponentLink`
           instances, or a :class:`~glue.core.link_helpers.LinkCollection`
        """
        self._link_manager.add_link(links)
        for d in self._data:
            self._link_manager.update_data_components(d)

    def _merge_link(self, link):
        pass

    def set_links(self, links):
        """Override the links in the collection, and update data
        objects as necessary.

        :param links: The new links. An iterable of
            :class:`~glue.core.component_link.ComponentLink` instances
        """
        self._link_manager.clear()
        for link in links:
            self._link_manager.add_link(link)

        for d in self._data:
            self._link_manager.update_data_components(d)

    def register_to_hub(self, hub):
        """ Register managed data objects to a hub.

        :param hub: The hub to register with
        :type hub: :class:`~glue.core.hub.Hub`
        """
        if self.hub is hub:
            return
        if self.hub is not None:
            raise RuntimeError("Data Collection already registered "
                               "to a different Hub")

        if not isinstance(hub, Hub):
            raise TypeError("Input is not a Hub object: %s" % type(hub))
        self.hub = hub

        # re-assign all data, subset hub instances to this hub
        for d in self._data:
            d.register_to_hub(hub)
            for s in d.subsets:
                s.register()

        hub.subscribe(self, DataAddComponentMessage,
                      lambda msg: self._sync_link_manager(),
                      filter=lambda x: x.sender in self._data)

    def new_subset_group(self, label=None, subset_state=None):
        """
        Create and return a new :class:`~glue.core.subset_group.SubsetGroup`
        """
        from .subset_group import SubsetGroup
        color = COLORS[self._sg_count % len(COLORS)]
        self._sg_count += 1
        label = label or "%i" % (self._sg_count)

        result = SubsetGroup(color=color, label=label, subset_state=subset_state)
        self._subset_groups.append(result)
        result.register(self)
        return result

    def remove_subset_group(self, subset_grp):
        """
        Remove an existing :class:`~glue.core.subset_group.SubsetGroup`
        """
        if subset_grp not in self._subset_groups:
            return

        # remove from list first, so that group appears deleted
        # by the time the first SubsetDelete message is broadcast
        self._subset_groups.remove(subset_grp)
        for s in subset_grp.subsets:
            s.delete()
        subset_grp.unregister(self.hub)

    @property
    def subset_groups(self):
        """
        tuple of current :class:`Subset Groups <glue.core.subset_group.SubsetGroup>`
        """
        return tuple(self._subset_groups)

    def __contains__(self, obj):
        return obj in self._data or obj in self.subset_groups

    def __getitem__(self, key):
        return self._data[key]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def __str__(self):
        result = "DataCollection (%i data sets)\n\t" % len(self)
        result += '\n\t'.join("%3i: %s" % (i, d.label) for
                              i, d in enumerate(self))
        return result

    def __repr__(self):
        return self.__str__()

    def __bool__(self):
        return True

    def __nonzero__(self):
        return True

########NEW FILE########
__FILENAME__ = data_factories
""" Factory methods to build Data objects from files"""

"""
Implementation notes:

Each factory method conforms to the folowing structure, which
helps the GUI Frontend easily load data:

1) The first argument is a file name to open

2) The return value is a Data object

3) The function has a .label attribute that describes (in human
language) what kinds of files it understands

4) The function has a callable .identifier attribute that returns
whether it can handle a requested filename and keyword set

5) The function is added to the __factories__ list

6) Optionally, the function is registered to open a given extension by
default by calling set_default_factory

Putting this together, the simplest data factory code looks like this::

    def dummy_factory(file_name):
        return glue.core.Data()
    dummy_factory.label = "Foo file"
    dummy_factory.identifier = has_extension('foo FOO')
    __factories__.append(dummy_factory)
    set_default_factory("foo", dummy_factory)
"""
import os

import numpy as np

from .data import Component, Data, CategoricalComponent
from .io import extract_data_fits, extract_data_hdf5
from .util import file_format, as_list
from .coordinates import coordinates_from_header, coordinates_from_wcs
from ..external.astro import fits


__all__ = ['load_data', 'gridded_data', 'casalike_cube',
           'tabular_data', 'img_data', 'auto_data']
__factories__ = []
_default_factory = {}


def _extension(path):
    # extract the extension type from a path
    #  test.fits -> fits
    #  test.fits.gz -> fits.gz (special case)
    #  a.b.c.fits -> fits
    _, path = os.path.split(path)
    if '.' not in path:
        return ''
    stems = path.split('.')[1:]

    # special case: test.fits.gz -> fits.gz
    if len(stems) > 1 and any(x == stems[-1]
                              for x in ['gz', 'gzip', 'bz', 'bz2']):
        return '.'.join(stems[-2:])
    return stems[-1]


def has_extension(exts):
    """
    A simple default filetype identifier function

    It returns a function that tests whether its input
    filename contains a particular extension

    Inputs
    ------
    exts : str
      A space-delimited string listing the extensions
      (e.g., 'txt', or 'txt csv fits')

    Returns
    -------
    A function suitable as a factory identifier function
    """

    def tester(x, **kwargs):
        return _extension(x) in set(exts.split())
    return tester


def is_hdf5(filename):
    # All hdf5 files begin with the same sequence
    with open(filename) as infile:
        return infile.read(8) == '\x89HDF\r\n\x1a\n'


def is_fits(filename):
    try:
        with fits.open(filename):
            return True
    except IOError:
        return False


class LoadLog(object):

    """
    This class attaches some metadata to data created
    from load_data, so that the data can be re-constructed
    when loading saved state. It's only meant to be used
    within load_data
    """

    def __init__(self, path, factory, kwargs):
        self.path = os.path.abspath(path)
        self.factory = factory
        self.kwargs = kwargs
        self.components = []
        self.data = []

    def _log_component(self, component):
        self.components.append(component)

    def _log_data(self, data):
        self.data.append(data)

    def log(self, obj):
        if isinstance(obj, Component):
            self._log_component(obj)
        elif isinstance(obj, Data):
            self._log_data(obj)
        obj._load_log = self

    def id(self, component):
        return self.components.index(component)

    def component(self, index):
        return self.components[index]

    def __gluestate__(self, context):
        return dict(path=self.path,
                    factory=context.do(self.factory),
                    kwargs=[list(self.kwargs.items())])

    @classmethod
    def __setgluestate__(cls, rec, context):
        fac = context.object(rec['factory'])
        kwargs = dict(*rec['kwargs'])
        d = load_data(rec['path'], factory=fac, **kwargs)
        return as_list(d)[0]._load_log


def load_data(path, factory=None, **kwargs):
    """Use a factory to load a file and assign a label.

    This is the preferred interface for loading data into Glue,
    as it logs metadata about how data objects relate to files
    on disk.

    :param path: Path to a file
    :param factory: factory function to use. Defaults to :func:`auto_data`

    Extra keywords are passed through to factory functions
    """
    factory = factory or auto_data
    d = factory(path, **kwargs)
    lbl = data_label(path)

    log = LoadLog(path, factory, kwargs)
    for item in as_list(d):
        item.label = lbl
        log.log(item)
        for cid in item.primary_components:
            log.log(item.get_component(cid))
    return d


def data_label(path):
    """Convert a file path into a data label, by stripping out
    slashes, file extensions, etc."""
    _, fname = os.path.split(path)
    name, _ = os.path.splitext(fname)
    return name


def set_default_factory(extension, factory):
    """Register an extension that should be handled by a factory by default

    :param extension: File extension (do not include the '.')
    :param factory: The factory function to dispatch to
    """
    for ex in extension.split():
        _default_factory[ex] = factory


def get_default_factory(extension):
    """Return the default factory function to read a given file extension.

    :param extension: The extension to lookup

    :rtype: A factory function, or None if the extension has no default
    """
    try:
        return _default_factory[extension]
    except KeyError:
        return None


def find_factory(filename, **kwargs):
    from ..config import data_factory

    # on first pass, only try the default factory
    default = _default_factory.get(_extension(filename))
    for func, _, identifier in data_factory:
        if func is auto_data:
            continue
        if (func is default) and identifier(filename, **kwargs):
            return func

    # if that fails, try everything
    for func, _, identifier in data_factory:
        if func is auto_data:
            continue
        if identifier(filename, **kwargs):
            return func


def auto_data(filename, *args, **kwargs):
    """Attempt to automatically construct a data object"""
    fac = find_factory(filename, **kwargs)
    if fac is None:
        raise KeyError("Don't know how to open file: %s" % filename)
    return fac(filename, *args, **kwargs)

auto_data.label = 'Auto'
auto_data.identifier = lambda x: True
__factories__.append(auto_data)


def gridded_data(filename, format='auto', **kwargs):
    """
    Construct an n - dimensional data object from ``filename``. If the
    format cannot be determined from the extension, it can be
    specified using the ``format`` option. Valid formats are 'fits' and
    'hdf5'.
    """
    result = Data()

    # Try and automatically find the format if not specified
    if format == 'auto':
        format = file_format(filename)

    # Read in the data
    if is_fits(filename):
        arrays = extract_data_fits(filename, **kwargs)
        header = fits.getheader(filename)
        result.coords = coordinates_from_header(header)
    elif is_hdf5(filename):
        arrays = extract_data_hdf5(filename, **kwargs)
    else:
        raise Exception("Unkonwn format: %s" % format)

    for component_name in arrays:
        comp = Component.autotyped(arrays[component_name])
        result.add_component(comp, component_name)
    return result


def is_gridded_data(filename, **kwargs):
    if is_hdf5(filename):
        return True

    if is_fits(filename):
        with fits.open(filename) as hdulist:
            for hdu in hdulist:
                if not isinstance(hdu, (fits.PrimaryHDU, fits.ImageHDU)):
                    return False
            return True
    return False


gridded_data.label = "FITS/HDF5 Image"
gridded_data.identifier = is_gridded_data
__factories__.append(gridded_data)
set_default_factory('fits', gridded_data)
set_default_factory('hd5', gridded_data)
set_default_factory('hdf5', gridded_data)


def casalike_cube(filename, **kwargs):
    """
    This provides special support for 4D CASA - like cubes,
    which have 2 spatial axes, a spectral axis, and a stokes axis
    in that order.

    Each stokes cube is split out as a separate component
    """
    result = Data()
    with fits.open(filename, **kwargs) as hdulist:
        array = hdulist[0].data
        header = hdulist[0].header
    result.coords = coordinates_from_header(header)
    for i in range(array.shape[0]):
        result.add_component(array[[i]], label='STOKES %i' % i)
    return result


def is_casalike(filename, **kwargs):
    """
    Check if a file is a CASA like cube,
    with (P, P, V, Stokes) layout
    """
    if not is_fits(filename):
        return False
    with fits.open(filename) as hdulist:
        if len(hdulist) != 1:
            return False
        if hdulist[0].header['NAXIS'] != 4:
            return False

        from astropy.wcs import WCS
        w = WCS(hdulist[0].header)

    ax = [a.get('coordinate_type') for a in w.get_axis_types()]
    return ax == ['celestial', 'celestial', 'spectral', 'stokes']


casalike_cube.label = 'CASA PPV Cube'
casalike_cube.identifier = is_casalike


def _ascii_identifier_v02(origin, args, kwargs):
    # this works for astropy v0.2
    if isinstance(args[0], basestring):
        return args[0].endswith(('csv', 'tsv', 'txt', 'tbl', 'dat',
                                 'csv.gz', 'tsv.gz', 'txt.gz', 'tbl.gz',
                                 'dat.gz'))
    else:
        return False


def _ascii_identifier_v03(origin, *args, **kwargs):
    # this works for astropy v0.3
    return _ascii_identifier_v02(origin, args, kwargs)


def tabular_data(*args, **kwargs):
    """
    Build a data set from a table. We restrict ourselves to tables
    with 1D columns.

    All arguments are passed to
        astropy.table.Table.read(...).
    """
    from distutils.version import LooseVersion
    from astropy import __version__
    if LooseVersion(__version__) < LooseVersion("0.2"):
        raise RuntimeError("Glue requires astropy >= v0.2. Please update")

    result = Data()

    # Read the table
    from astropy.table import Table

    # Add identifiers for ASCII data
    from astropy.io import registry
    if LooseVersion(__version__) < LooseVersion("0.3"):
        registry.register_identifier('ascii', Table, _ascii_identifier_v02,
                                     force=True)
    else:
        registry.register_identifier('ascii', Table, _ascii_identifier_v03,
                                     force=True)
        # Clobber the identifier
        # added in astropy/astropy/pull/1935
        registry.register_identifier('ascii.csv', Table, lambda *a, **k: False,
                                     force=True)

    # Import FITS compatibility (for Astropy 0.2.x)
    from ..external import fits_io

    table = Table.read(*args, **kwargs)

    # Loop through columns and make component list
    for column_name in table.columns:
        c = table[column_name]
        u = c.units

        if table.masked:
            # fill array for now
            try:
                c = c.filled(fill_value=np.nan)
            except ValueError:  # assigning nan to integer dtype
                c = c.filled(fill_value=-1)

        nc = Component.autotyped(c, units=u)
        result.add_component(nc, column_name)

    return result

tabular_data.label = "Catalog"
tabular_data.identifier = has_extension('xml vot csv txt tsv tbl dat fits '
                                        'xml.gz vot.gz csv.gz txt.gz tbl.bz '
                                        'dat.gz fits.gz')

__factories__.append(tabular_data)
set_default_factory('xml', tabular_data)
set_default_factory('vot', tabular_data)
set_default_factory('csv', tabular_data)
set_default_factory('txt', tabular_data)
set_default_factory('tsv', tabular_data)
set_default_factory('tbl', tabular_data)
set_default_factory('dat', tabular_data)


def panda_process(indf):
    """
    Build a data set from a table using pandas. This attempts to respect
    categorical data input by letting pandas.read_csv infer the type

    """

    result = Data()
    for name, column in indf.iteritems():
        if (column.dtype == np.object) | (column.dtype == np.bool):
            # pandas has a 'special' nan implementation and this doesn't
            # play well with np.unique
            c = CategoricalComponent(column.fillna(np.nan))
        else:
            c = Component(column.values)
        result.add_component(c, name)

    return result


def panda_read_excel(path, sheet='Sheet1', **kwargs):
    """ A factory for reading excel data using pandas.
    :param path: path/to/file
    :param sheet: The sheet to read
    :param kwargs: All other kwargs are passed to pandas.read_excel
    :return: core.data.Data object.
    """
    try:
        import pandas as pd
    except ImportError:
        raise ImportError('Pandas is required for Excel input.')

    indf = pd.read_excel(path, sheet, **kwargs)
    return panda_process(indf)

panda_read_excel.label = "Excel"
panda_read_excel.identifier = has_extension('xls xlsx')
__factories__.append(panda_read_excel)
set_default_factory('xls', panda_read_excel)
set_default_factory('xlsx', panda_read_excel)


def pandas_read_table(path, **kwargs):
    """ A factory for reading tabular data using pandas
    :param path: path/to/file
    :param kwargs: All kwargs are passed to pandas.read_csv
    :returns: :class:`glue.core.data.Data` object
    """
    import pandas as pd

    # iterate over common delimiters to search for best option
    delimiters = kwargs.pop('delimiter', [None] + list(',|\t '))

    fallback = None

    for d in delimiters:
        try:
            indf = pd.read_csv(path, delimiter=d, **kwargs)

            # ignore files parsed to empty dataframes
            if len(indf) == 0:
                continue

            # only use files parsed to single-column dataframes
            # if we don't find a better strategy
            if len(indf.columns) < 2:
                fallback = indf
                continue

            return panda_process(indf)

        except pd._parser.CParserError:
            continue

    if fallback is not None:
        return panda_process(fallback)
    raise IOError("Could not parse %s using pandas" % path)

pandas_read_table.label = "Pandas Table"
pandas_read_table.identifier = has_extension('csv csv txt tsv tbl dat')
__factories__.append(pandas_read_table)


img_fmt = ['jpg', 'jpeg', 'bmp', 'png', 'tiff', 'tif']


def img_loader(file_name):
    """Load an image to a numpy array, using either PIL or skimage

    :param file_name: Path of file to load
    :rtype: Numpy array
    """
    try:
        from skimage.io import imread
        return np.asarray(imread(file_name))
    except ImportError:
        pass

    try:
        from PIL import Image
        return np.asarray(Image.open(file_name))
    except ImportError:
        raise ImportError("Reading %s requires PIL or scikit-image" %
                          file_name)


def img_data(file_name):
    """Load common image files into a Glue data object"""
    result = Data()

    data = img_loader(file_name)
    data = np.flipud(data)
    shp = data.shape

    comps = []
    labels = []

    # split 3 color images into each color plane
    if len(shp) == 3 and shp[2] in [3, 4]:
        comps.extend([data[:, :, 0], data[:, :, 1], data[:, :, 2]])
        labels.extend(['red', 'green', 'blue'])
        if shp[2] == 4:
            comps.append(data[:, :, 3])
            labels.append('alpha')
    else:
        comps = [data]
        labels = ['PRIMARY']

    # look for AVM coordinate metadata
    try:
        from pyavm import AVM
        avm = AVM(str(file_name))  # avoid unicode
        wcs = avm.to_wcs()
    except:
        pass
    else:
        result.coords = coordinates_from_wcs(wcs)

    for c, l in zip(comps, labels):
        result.add_component(c, l)

    return result

img_data.label = "Image"
img_data.identifier = has_extension(' '.join(img_fmt))
for i in img_fmt:
    set_default_factory(i, img_data)

__factories__.append(img_data)
__factories__.append(casalike_cube)

########NEW FILE########
__FILENAME__ = decorators
from functools import wraps

__all__ = ['memoize', 'singleton', 'memoize_attr_check']


def _make_key(args, kwargs):
    return args, frozenset(kwargs.items())


def memoize(func):
    """Save results of function calls to avoid repeated calculation"""
    memo = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
        key = _make_key(args, kwargs)
        try:
            return memo[key]
        except KeyError:
            result = func(*args, **kwargs)
            memo[key] = result
            return result
        except TypeError:  # unhashable input
            return func(*args, **kwargs)

    return wrapper


def memoize_attr_check(attr):
    """ Memoize a method call, cached both on arguments and given attribute
    of first argument (which is presumably self)

    Has the effect of re-calculating results if a specific attribute changes
    """

    def decorator(func):
        #must return a decorator function

        @wraps(func)
        def result(*args, **kwargs):
            first_arg = getattr(args[0], attr)
            return memo(first_arg, *args, **kwargs)

        @memoize
        def memo(*args, **kwargs):
            return func(*args[1:], **kwargs)

        return result

    return decorator


def singleton(cls):
    """Turn a class into a singleton, such that new objects
    in this class share the same instance"""
    instances = {}

    @wraps(cls)
    def getinstance():
        if cls not in instances:
            instances[cls] = cls()
        return instances[cls]
    return getinstance

########NEW FILE########
__FILENAME__ = edit_subset_mode
"""These classes define the behavior of how new subset states affect
    the edit_subset of a Data object.

   The EditSubsetMode is universal in Glue -- all datasets and clients
   share the same mode. This is enforced by making the base
   EditSubsetMode object a singleton.
"""
#pylint: disable=I0011, R0903

import logging

from .decorators import singleton
from .data import Data
from .data_collection import DataCollection
from .util import as_list


@singleton
class EditSubsetMode(object):
    """ Implements how new SubsetStates modify the edit_subset state """
    def __init__(self):
        self.mode = ReplaceMode
        self.data_collection = None

    def _combine_data(self, data, new_state, add_if_empty=False):
        """ Dispatches to the combine method of mode attribute.

        The behavior is dependent on the mode it dispatches to.
        By default, the method uses ReplaceMode, which overwrites
        the edit_subsets' subset_state with new_state

        :param edit_subset: The current edit_subset
        :param new_state: The new SubsetState
        :param add_if_empty: If True and a data set has no subsets,
                             a new one will be added and assigned
                             using new-state
        """
        empty = data.edit_subset is None or data.edit_subset == []
        if add_if_empty and empty:
            if self.data_collection is None:
                raise RuntimeError("Must set data_collection before "
                                   "calling update")
            data.edit_subset = self.data_collection.new_subset_group()
        if empty and not add_if_empty:
            logging.getLogger(__name__).info("Ignoring subset update")
            return
        subs = data.edit_subset
        for s in as_list(subs):
            self.mode(s, new_state)

    def update(self, d, new_state, focus_data=None):
        """ Apply a new subset state to editable subsets within a
        :class:`~glue.core.data.Data` or
        :class:`~glue.core.data_collection.DataCollection` instance

        :param d: Data or Collection to act upon
        :type d: Data or DataCollection

        :param new_state: Subset state to combine with
        :type new_state: :class:`~glue.core.subset.SubsetState`

        :param focus_data: The main data set in focus by the client,
        if relevant. If a data set is in focus and has no subsets,
        a new one will be created using new_state.
        """
        logging.getLogger(__name__).debug("Update subset for %s", d)

        if isinstance(d, Data):
            self._combine_data(d, new_state, add_if_empty=d is focus_data)
        elif isinstance(d, DataCollection):
            no_editable = all(data.edit_subset is None or
                              data.edit_subset == []
                              for data in d)
            for data in d:
                doadd = data is focus_data and no_editable
                self._combine_data(data, new_state, add_if_empty=doadd)
        else:
            raise TypeError("input must be a Data or DataCollection: %s" %
                            type(d))


def ReplaceMode(edit_subset, new_state):
    """ Replaces edit_subset.subset_state with new_state """
    logging.getLogger(__name__).debug("Replace %s", edit_subset)
    edit_subset.subset_state = new_state.copy()


def AndMode(edit_subset, new_state):
    """ Edit_subset.subset state is and-combined with new_state """
    new_state.parent = edit_subset
    state = new_state & edit_subset.subset_state
    edit_subset.subset_state = state


def OrMode(edit_subset, new_state):
    """ Edit_subset.subset state is or-combined with new_state """
    new_state.parent = edit_subset
    state = new_state | edit_subset.subset_state
    edit_subset.subset_state = state


def XorMode(edit_subset, new_state):
    """ Edit_subset.subset state is xor-combined with new_state """
    new_state.parent = edit_subset
    state = new_state ^ edit_subset.subset_state
    edit_subset.subset_state = state


def AndNotMode(edit_subset, new_state):
    """ Edit_subset.subset state is and-not-combined with new_state """
    new_state.parent = edit_subset
    state = edit_subset.subset_state & (~new_state)
    edit_subset.subset_state = state

########NEW FILE########
__FILENAME__ = exceptions
class IncompatibleAttribute(Exception):
    pass


class IncompatibleDataException(Exception):
    pass


class UndefinedROI(Exception):
    pass


class InvalidSubscriber(Exception):
    pass


class InvalidMessage(Exception):
    pass

########NEW FILE########
__FILENAME__ = fitters
"""
Glue's fitting classes are designed to be easily subclassed for performing
custom model fitting in Glue.

See the guide on :ref:`writing custom fit plugins <fit_plugins>` for
help with using custom fitting utilities in Glue.
"""

import numpy as np

from .simpleforms import IntOption, Option


__all__ = ['BaseFitter1D',
           'PolynomialFitter',
           'AstropyFitter1D',
           'SimpleAstropyGaussianFitter',
           'BasicGaussianFitter']


class BaseFitter1D(object):

    """
    Base class for 1D fitters.

    This abstract class must be overwritten.
    """

    label = "Fitter"
    """A short label for the fit, used by the GUI"""

    param_names = []
    """list of parameter names that support restrictions"""

    def __init__(self, **params):
        self._constraints = {}

        for k, v in params.items():
            if k in self.param_names:
                self.set_constraint(k, value=v)
            else:
                setattr(self, k, v)

    def plot(self, fit_result, axes, x):
        """
        Plot the result of a fit.

        :param fit_result: The output from fit
        :param axes: The Matplotlib axes to add the fit to
        :param x: The values of X at which to visualize the model

        :returns: A list of matplotlib artists. **This is important:**
                  plots will not be properly cleared if this isn't provided
        """
        y = self.predict(fit_result, x)
        result = axes.plot(x, y, '#4daf4a',
                           lw=3, alpha=0.8,
                           scalex=False, scaley=False)
        return result

    def _sigma_to_weights(self, dy):
        if dy is not None:
            return 1. / np.asarray(dy) ** 2

    @property
    def options(self):
        """
        A dictionary of the current setting of each model hyperparameter.

        Hyperparameters are defined in subclasses by creating class-level
        :mod:`Option <glue.core.simpleforms>` attributes. This attribute
        dict maps ``{hyperparameter_name: current_value}``
        """
        result = []
        for typ in type(self).mro():
            result.extend(k for k, v in typ.__dict__.items()
                          if isinstance(v, Option))
        return dict((o, getattr(self, o)) for o in result)

    def summarize(self, fit_result, x, y, dy=None):
        """
        Return a textual summary of the fit.

        :param fit_result: The return value from :meth:`fit`
        :param x: The x values passed to :meth:`fit`
        :returns: A description of the fit result
        :rtype: str
        """
        return str(fit_result)

    @property
    def constraints(self):
        """
        A dict of the constraints on each parameter in :attr:`param_names`.
        Each value is itself a dict with 3 items:

        :key value: The default value
        :key fixed: True / False, indicating whether the parameter is fixed
        :key bounds: [min, max] or None, indicating lower/upper limits
        """
        result = {}
        for p in self.param_names:
            result[p] = dict(value=None, fixed=False, limits=None)
            result[p].update(self._constraints.get(p, {}))
        return result

    def set_constraint(self, parameter_name, value=None,
                       fixed=None, limits=None):
        """
        Update a constraint.

        :param parameter_name: name of the parameter to update
        :type parameter_name: str
        :param value: Set the default value (optional)
        :param limits: Set the limits to[min, max] (optional)
        :param fixed: Set whether the parameter is fixed (optional)
        """
        c = self._constraints.setdefault(parameter_name, {})
        if value is not None:
            c['value'] = value
        if fixed is not None:
            c['fixed'] = fixed
        if limits is not None:
            c['limits'] = limits

    def build_and_fit(self, x, y, dy=None):
        """
        Method which builds the arguments to fit, and calls that method
        """
        x = np.asarray(x).ravel()
        y = np.asarray(y).ravel()
        if dy is not None:
            dy = np.asarray(dy).ravel()

        return self.fit(x, y, dy=dy,
                        constraints=self.constraints,
                        **self.options)

    def fit(self, x, y, dy, constraints, **options):
        """
        Fit the model to data.

        *This must be overriden by a subclass.*

        :param x: The x values of the data
        :type x:  :class:`numpy.ndarray`
        :param y: The y values of the data
        :type y:  :class:`numpy.ndarray`
        :param dy: 1 sigma uncertainties on each datum (optional)
        :type dy: :class:`numpy.ndarray`
        :param constraints: The current value of :attr:`constraints`
        :param options: kwargs for model hyperparameters.

        :returns: An object representing the fit result.
        """

        raise NotImplementedError()

    def predict(self, fit_result, x):
        """
        Evaulate the model at a set of locations.

        **This must be overridden in a subclass.**

        :param fit_result: The result from the fit method
        :param x: Locations to evaluate model at
        :type x: :class:`numpy.ndarray`

        :returns: model(x)
        :rtype: :class:`numpy.ndarray`
        """
        raise NotImplementedError()


class AstropyFitter1D(BaseFitter1D):

    """
    A base class for wrapping :mod:`astropy.modeling`.

    Subclasses must override :attr:`model_cls` :attr:`fitting_cls`
    to point to the desired Astropy :mod:`model <astropy.modeling>`
    and :mod:`fitter <astropy.modeling.fitting>` classes.

    In addition, they should override :attr:`label` with a better label,
    and :meth:`parameter_guesses` to generate initial guesses
    """

    model_cls = None
    """class describing the model"""

    fitting_cls = None
    """class to fit the model"""

    label = "Base Astropy Fitter"
    """UI Label"""

    @property
    def param_names(self):
        return self.model_cls.param_names

    def predict(self, fit_result, x):
        model, _ = fit_result
        return model(x)

    def summarize(self, fit_result, x, y, dy=None):
        model, fitter = fit_result
        result = [_report_fitter(fitter), ""]
        pnames = list(sorted(model.param_names))
        maxlen = max(map(len, pnames))
        result.extend("%s = %e" % (p.ljust(maxlen), getattr(model, p).value)
                      for p in pnames)
        return "\n".join(result)

    def fit(self, x, y, dy, constraints):
        m, f = self._get_model_fitter(x, y, dy, constraints)

        dy = self._sigma_to_weights(dy)
        return f(m, x, y, weights=dy), f

    def _get_model_fitter(self, x, y, dy, constraints):
        if self.model_cls is None or self.fitting_cls is None:
            raise NotImplementedError("Model or fitting class is unspecified.")

        params = dict((k, v['value']) for k, v in constraints.items())

        # update unset parameters with guesses from data
        for k, v in self.parameter_guesses(x, y, dy).items():
            if params[k] is not None or constraints[k]['fixed']:
                continue
            params[k] = v

        m = self.model_cls(**params)
        f = self.fitting_cls()

        for param_name, constraint in constraints.items():
            param = getattr(m, param_name)
            if constraint['fixed']:
                param.fixed = True
            if constraint['limits']:
                param.min, param.max = constraint['limits']
        return m, f

    def parameter_guesses(self, x, y, dy):
        """
        Provide initial guesses for each model parameter.

        **The base implementation does nothing, and should be overridden**

        :param x: X - values of the data
        :type x: :class:`numpy.ndarray`
        :param y: Y - values of the data
        :type y: :class:`numpy.ndarray`
        :param dy: ncertainties on Y(assumed to be 1 sigma)
        :type dy: :class:`numpy.ndarray`

        :returns: A dict maping ``{parameter_name: value guess}`` for each
                  parameter
        """
        return {}


def _gaussian_parameter_estimates(x, y, dy):

    amplitude = np.percentile(y, 95)
    y = np.maximum(y / y.sum(), 0)
    mean = (x * y).sum()
    stddev = np.sqrt((y * (x - mean) ** 2).sum())
    return dict(mean=mean, stddev=stddev, amplitude=amplitude)


class BasicGaussianFitter(BaseFitter1D):

    """
    Fallback Gaussian fitter, for astropy < 0.3.

    If :mod:`astropy.modeling` is installed, this class is replaced by
    :class:`SimpleAstropyGaussianFitter`
    """
    label = "Gaussian"

    def _errorfunc(self, params, x, y, dy):
        yp = self.eval(x, *params)
        result = (yp - y)
        if dy is not None:
            result /= dy
        return result

    @staticmethod
    def eval(x, amplitude, mean, stddev):
        return np.exp(-(x - mean) ** 2 / (2 * stddev ** 2)) * amplitude

    @staticmethod
    def fit_deriv(x, amplitude, mean, stddev):
        """
        Gaussian1D model function derivatives.
        """

        d_amplitude = np.exp(-0.5 / stddev ** 2 * (x - mean) ** 2)
        d_mean = amplitude * d_amplitude * (x - mean) / stddev ** 2
        d_stddev = amplitude * d_amplitude * (x - mean) ** 2 / stddev ** 3
        return [d_amplitude, d_mean, d_stddev]

    def fit(self, x, y, dy, constraints):
        from scipy import optimize
        init_values = _gaussian_parameter_estimates(x, y, dy)
        init_values = [init_values[p] for p in ['amplitude', 'mean', 'stddev']]
        farg = (x, y, dy)
        dfunc = None
        fitparams, status, dinfo, mess, ierr = optimize.leastsq(
            self._errorfunc, init_values, args=farg, Dfun=dfunc,
            full_output=True)
        return fitparams

    def predict(self, fit_result, x):
        return self.eval(x, *fit_result)

    def summarize(self, fit_result, x, y, dy=None):
        return ("amplitude = %e\n"
                "mean      = %e\n"
                "stddev    = %e" % tuple(fit_result))


GaussianFitter = BasicGaussianFitter


try:
    from astropy.modeling import models, fitting

    class SimpleAstropyGaussianFitter(AstropyFitter1D):

        """
        Guassian fitter using astropy.modeling.
        """
        model_cls = models.Gaussian1D
        fitting_cls = fitting.NonLinearLSQFitter
        label = "Gaussian"

        parameter_guesses = staticmethod(_gaussian_parameter_estimates)

    GaussianFitter = SimpleAstropyGaussianFitter

except ImportError:
    pass


class PolynomialFitter(BaseFitter1D):

    """
    A polynomial model.

    The degree of the polynomial is specified by :attr:`degree`
    """
    label = "Polynomial"
    degree = IntOption(min=0, max=5, default=3, label="Polynomial Degree")

    def fit(self, x, y, dy, constraints, degree=2):
        """
        Fit a ``degree``-th order polynomial to the data.
        """
        w = self._sigma_to_weights(dy)

        return np.polyfit(x, y, degree, w=w)

    def predict(self, fit_result, x):
        return np.polyval(fit_result, x)

    def summarize(self, fit_result, x, y, dy=None):
        return "Coefficients:\n" + "\n".join("%e" % coeff
                                             for coeff in fit_result.tolist())


def _report_fitter(fitter):
    if "nfev" in fitter.fit_info:
        return "Converged in %i iterations" % fitter.fit_info['nfev']
    return 'Converged'

__FITTERS__ = [PolynomialFitter, GaussianFitter]

########NEW FILE########
__FILENAME__ = glue_pickle
from cPickle import dumps, loads
import logging

try:
    from dill import dumps, loads
except ImportError:
    logging.getLogger(__name__).warn("Dill library not installed. "
                                     "Falling back to cPickle")

########NEW FILE########
__FILENAME__ = hub
import logging
from inspect import getmro
from collections import defaultdict

from .message import Message
from .exceptions import InvalidSubscriber, InvalidMessage

__all__ = ['Hub', 'HubListener']


class Hub(object):

    """The hub manages communication between subscribers.

    Objects :func:`subscribe` to receive specific message types. When
    a message is passed to :func:`broadcast`, the hub observes the
    following protocol:

        * For each subscriber, it looks for a message class
          subscription that is a superclass of the input message type
          (if several are found, the most-subclassed one is chosen)

        * If one is found, it calls the subscriptions filter(message)
          class (if provided)

        * If filter(message) == True, it calls handler(message)
          (or notify(message) if handler wasn't provided).

    """

    def __init__(self, *args):
        """
        Any arguments that are passed to Hub will be registered
        to the new hub object.
        """
        # Dictionary of subscriptions
        self._subscriptions = defaultdict(dict)

        from .data import Data
        from .subset import Subset
        from .data_collection import DataCollection

        listeners = set(filter(lambda x: isinstance(x, HubListener), args))
        data = set(filter(lambda x: isinstance(x, Data), args))
        subsets = set(filter(lambda x: isinstance(x, Subset), args))
        dcs = set(filter(lambda x: isinstance(x, DataCollection), args))
        listeners -= (data | subsets | dcs)
        if set(listeners | data | subsets | dcs) != set(args):
            raise TypeError("Inputs must be HubListener, data, subset, or "
                            "data collection objects")

        for l in listeners:
            l.register_to_hub(self)
        for d in data:
            d.register_to_hub(self)
        for dc in dcs:
            dc.register_to_hub(self)
        for s in subsets:
            s.register()

    def subscribe(self, subscriber, message_class,
                  handler=None,
                  filter=lambda x: True):
        """Subscribe an object to a type of message class.

        :param subscriber: The subscribing object
        :type subscriber: :class:`~glue.core.hub.HubListener`

        :param message_class: A :class:`~glue.core.message.Message` class
                              to subscribe to

        :param handler:
           An optional function of the form handler(message) that will
           receive the message on behalf of the subscriber. If not provided,
           this defaults to the HubListener's notify method
        :type handler: Callable


        :param filter:
           An optional function of the form filter(message). Messages
           are only passed to the subscriber if filter(message) == True.
           The default is to always pass messages.
        :type filter: Callable


        Raises:
            InvalidMessage: If the input class isn't a
            :class:`~glue.core.message.Message` class

            InvalidSubscriber: If the input subscriber isn't a
            HubListener object.

        """
        if not isinstance(subscriber, HubListener):
            raise InvalidSubscriber("Subscriber must be a HubListener: %s" %
                                    type(subscriber))
        if not isinstance(message_class, type) or \
                not issubclass(message_class, Message):
            raise InvalidMessage("message class must be a subclass of "
                                 "glue.Message: %s" % type(message_class))
        logging.getLogger(__name__).info("Subscribing %s to %s",
                                         subscriber, message_class.__name__)

        if not handler:
            handler = subscriber.notify

        self._subscriptions[subscriber][message_class] = (filter, handler)

    def is_subscribed(self, subscriber, message):
        """
        Test whether the subscriber has suscribed to a given message class

        :param subscriber: The subscriber to test
        :param message: The message class to test

        Returns:

            True if the subscriber/message pair have been subscribed to the hub

        """
        return subscriber in self._subscriptions and \
            message in self._subscriptions[subscriber]

    def get_handler(self, subscriber, message):
        try:
            return self._subscriptions[subscriber][message][1]
        except KeyError:
            return None

    def unsubscribe(self, subscriber, message):
        """
        Remove a (subscriber,message) pair from subscription list.
        The handler originally attached to the subscription will
        no longer be called when broadcasting messages of type message
        """
        if subscriber not in self._subscriptions:
            return
        if message in self._subscriptions[subscriber]:
            self._subscriptions[subscriber].pop(message)

    def unsubscribe_all(self, subscriber):
        """
        Unsubscribe the object from any subscriptions.
        """
        if subscriber in self._subscriptions:
            self._subscriptions.pop(subscriber)

    def _find_handlers(self, message):
        """Yields all (subscriber, handler) pairs that should receive a message
        """
        # self._subscriptions:
        # subscriber => { message type => (filter, handler)}

        # loop over subscribed objects
        for subscriber, subscriptions in self._subscriptions.items():

            # subscriptions to message or its superclasses
            messages = [msg for msg in subscriptions.keys() if
                        issubclass(type(message), msg)]
            if len(messages) == 0:
                continue

            # narrow to the most-specific message
            candidate = max(messages, key=_mro_count)

            test, handler = subscriptions[candidate]
            if test(message):
                yield subscriber, handler

    def broadcast(self, message):
        """Broadcasts a message to all subscribed objects.

        :param message: The message to broadcast
        :type message: :class:`~glue.core.message.Message`
        """
        logging.getLogger(__name__).info("Broadcasting %s", message)
        for subscriber, handler in self._find_handlers(message):
            handler(message)

    def __getstate__(self):
        """ Return a picklable representation of the hub

        Note: Only objects in glue.core are currently supported
        as pickleable. Thus, any subscriptions from objects outside
        glue.core will note be saved or restored
        """
        result = self.__dict__.copy()
        result['_subscriptions'] = self._subscriptions.copy()
        for s in self._subscriptions:
            try:
                module = s.__module__
            except AttributeError:
                module = ''
            if not module.startswith('glue.core'):
                print 'Pickle warning: Hub removing subscription to %s' % s
                result['_subscriptions'].pop(s)
        return result


class HubListener(object):

    """
    The base class for any object that subscribes to hub messages.
    This interface defines a single method, notify, that receives
    messages
    """

    def register_to_hub(self, hub):
        raise NotImplementedError

    def unregister(self, hub):
        """ Default unregistration action. Calls hub.unsubscribe_all on self"""
        hub.unsubscribe_all(self)

    def notify(self, message):
        raise NotImplementedError("Message has no handler: %s" % message)


def _mro_count(obj):
    return len(getmro(obj))

########NEW FILE########
__FILENAME__ = io
def extract_data_fits(filename, use_hdu='all'):
    '''
    Extract non-tabular HDUs from a FITS file. If `use_hdu` is 'all', then
    all non-tabular HDUs are extracted, otherwise only the ones specified
    by `use_hdu` are extracted (`use_hdu` should then contain a list of
    integers). If the requested HDUs do not have the same dimensions, an
    Exception is raised.
    '''
    from ..external.astro import fits

    # Read in all HDUs
    hdulist = fits.open(filename, memmap=True, ignore_blank=True)

    # If only a subset are requested, extract those
    if use_hdu != 'all':
        hdulist = [hdulist[hdu] for hdu in use_hdu]

    # Now only keep HDUs that are not tables
    for hdu in hdulist:
        if not isinstance(hdu, fits.PrimaryHDU) and \
                not isinstance(hdu, fits.ImageHDU):
            hdulist.remove(hdu)

    # Check that dimensions of all HDU are the same
    reference_shape = hdulist[0].data.shape
    for hdu in hdulist:
        if hdu.data.shape != reference_shape:
            raise Exception("HDUs are not all the same dimensions")

    # Extract data
    arrays = {}
    for hdu in hdulist:
        arrays[hdu.name] = hdu.data

    return arrays


def extract_hdf5_datasets(handle):
    '''
    Recursive function that returns a dictionary with all the datasets
    found in an HDF5 file or group. `handle` should be an instance of
    h5py.highlevel.File or h5py.highlevel.Group.
    '''

    import h5py

    datasets = {}
    for group in handle:
        if isinstance(handle[group], h5py.highlevel.Group):
            sub_datasets = extract_hdf5_datasets(handle[group])
            for key in sub_datasets:
                datasets[key] = sub_datasets[key]
        elif isinstance(handle[group], h5py.highlevel.Dataset):
            datasets[handle[group].name] = handle[group]
    return datasets


def extract_data_hdf5(filename, use_datasets='all'):
    '''
    Extract non-tabular datasets from an HDF5 file. If `use_datasets` is
    'all', then all non-tabular datasets are extracted, otherwise only the
    ones specified by `use_datasets` are extracted (`use_datasets` should
    then contain a list of paths). If the requested datasets do not have
    the same dimensions, an Exception is raised.
    '''

    import h5py

    # Open file
    file_handle = h5py.File(filename, 'r')

    # Define function to read

    # Read in all datasets
    datasets = extract_hdf5_datasets(file_handle)

    # Only keep non-tabular datasets
    remove = []
    for key in datasets:
        if datasets[key].dtype.fields is not None:
            remove.append(key)
    for key in remove:
        datasets.pop(key)

    # Check that dimensions of all datasets are the same
    reference_shape = datasets[datasets.keys()[0]].value.shape
    for key in datasets:
        if datasets[key].value.shape != reference_shape:
            raise Exception("Datasets are not all the same dimensions")

    # Extract data
    arrays = {}
    for key in datasets:
        arrays[key] = datasets[key].value

    # Close HDF5 file
    file_handle.close()

    return arrays

########NEW FILE########
__FILENAME__ = link_helpers
""" This module provides several classes and LinkCollection classes to
assist in linking data.

The functions in this class (and stored in the __LINK_FUNCTIONS__
list) define common coordinate transformations. They are meant to be
used for the `using` parameter in
:class:`glue.core.component_link.ComponentLink` instances.

The :class:`LinkCollection` class and its sublcasses are factories to create
multiple ComponentLinks easily. They are meant to be passed to
:meth:`~glue.core.data_collection.DataCollection.add_link()`
"""
from .component_link import ComponentLink
from .data import ComponentID
from ..external.aplpy import gal2fk5, fk52gal

__all__ = ['LinkCollection', 'LinkSame', 'LinkTwoWay', 'MultiLink',
           'LinkAligned', 'Galactic2Equatorial']

__LINK_FUNCTIONS__ = []
__LINK_HELPERS__ = []


def identity(x):
    return x
identity.output_args = ['y']


def lengths_to_volume(width, height, depth):
    """Compute volume from linear measurements of a box"""
    # included for demonstration purposes
    return width * height * depth


lengths_to_volume.output_args = ['area']

__LINK_FUNCTIONS__.append(identity)
__LINK_FUNCTIONS__.append(lengths_to_volume)


class PartialResult(object):

    def __init__(self, func, index):
        self.func = func
        self.index = index
        self.__name__ = '%s_%i' % (func.__name__, index + 1)

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)[self.index]

    def __gluestate__(self, context):
        return dict(func=context.do(self.func), index=self.index)

    @classmethod
    def __setgluestate__(cls, rec, context):
        return cls(context.object(rec['func']), rec['index'])


def _toid(arg):
    """Coerce the input to a ComponentID, if possible"""
    if isinstance(arg, ComponentID):
        return arg
    elif isinstance(arg, basestring):
        return ComponentID(arg)
    else:
        raise TypeError('Cannot be cast to a ComponentID: %s' % arg)


class LinkCollection(list):
    pass


class LinkSame(LinkCollection):

    """
    Return ComponentLinks to represent that two componentIDs
    describe the same piece of information
    """

    def __init__(self, cid1, cid2):
        self.append(ComponentLink([_toid(cid1)], _toid(cid2)))


class LinkTwoWay(LinkCollection):

    def __init__(self, cid1, cid2, forwards, backwards):
        """ Return 2 links that connect input ComponentIDs in both directions

        :param cid1: First ComponentID to link
        :param cid2: Second ComponentID to link
        :param forwards: Function which maps cid1 to cid2 (e.g. cid2=f(cid1))
        :param backwards: Function which maps cid2 to cid1 (e.g. cid1=f(cid2))

        :returns: Two :class:`~glue.core.component_link.ComponentLink`
                  instances, specifying the link in each direction
        """
        self.append(ComponentLink([_toid(cid1)], _toid(cid2), forwards))
        self.append(ComponentLink([_toid(cid2)], _toid(cid1), backwards))


class MultiLink(LinkCollection):

    """
    Compute all the ComponentLinks to link groups of ComponentIDs

    :param cids_left: first collection of ComponentIDs
    :param cids_right: second collection of ComponentIDs
    :param forwards:
        Function that maps ``cids_left -> cids_right``. Assumed to have
        signature ``cids_right = forwards(*cids_left)``, and assumed
        to return a tuple. If not provided, the relevant ComponentIDs
        will not be generated
    :param backwards:
       The inverse function to forwards. If not provided, the relevant
       ComponentIDs will not be generated

    :returns: a collection of :class:`~glue.core.component_link.ComponentLink`
              objects.
    """

    def __init__(self, cids_left, cids_right, forwards=None, backwards=None):
        cids_left = map(_toid, cids_left)
        cids_right = map(_toid, cids_right)

        if forwards is None and backwards is None:
            raise TypeError("Must supply either forwards or backwards")

        if forwards is not None:
            for i, r in enumerate(cids_right):
                func = PartialResult(forwards, i)
                self.append(ComponentLink(cids_left, r, func))

        if backwards is not None:
            for i, l in enumerate(cids_left):
                func = PartialResult(backwards, i)
                self.append(ComponentLink(cids_right, l, func))


class LinkAligned(LinkCollection):

    """Compute all the links to specify that the input data are pixel-aligned.

    :param data: An iterable of :class:`~glue.core.data.Data` instances
                 that are aligned at the pixel level. They must be the
                 same shape.
    """

    def __init__(self, data):
        shape = data[0].shape
        ndim = data[0].ndim
        for i, d in enumerate(data[1:]):
            if d.shape != shape:
                raise TypeError("Input data do not have the same shape")
            for j in range(ndim):
                self.extend(LinkSame(data[0].get_pixel_component_id(j),
                                     data[i + 1].get_pixel_component_id(j)))


class Galactic2Equatorial(MultiLink):

    """
    Instantiate a ComponentList with four ComponentLinks that map galactic
    and equatorial coordinates

    :param l: ComponentID for galactic longitude
    :param b: ComponentID for galactic latitude
    :param ra: ComponentID for J2000 Right Ascension
    :param dec: ComponentID for J2000 Declination

    Returns a :class:`LinkCollection` object which links
    these ComponentIDs
    """

    # attributes used by the Gui
    info_text = """Link Galactic and Equatorial coordinates"""
    input_args = ['l', 'b', 'ra', 'dec']

    def __init__(self, l, b, ra, dec):
        MultiLink.__init__(self, [ra, dec], [l, b], fk52gal, gal2fk5)


def radec2glon(ra, dec):
    """Compute galactic longitude from right ascension and declination"""
    return fk52gal(ra, dec)[0]
radec2glon.output_args = ['l']


def radec2glat(ra, dec):
    """Compute galactic latitude from right ascension and declination"""
    return fk52gal(ra, dec)[1]
radec2glat.output_args = ['b']


def lb2ra(lon, lat):
    """Compute right ascension from galactic longitude and latitude"""
    return gal2fk5(lon, lat)[0]
lb2ra.output_args = ['ra']


def lb2dec(lon, lat):
    """Compute declination from galactic longitude and latitude"""
    return gal2fk5(lon, lat)[1]
lb2dec.output_args = ['dec']

__LINK_FUNCTIONS__.extend([radec2glon, radec2glat, lb2ra, lb2dec])
__LINK_HELPERS__.append(Galactic2Equatorial)

########NEW FILE########
__FILENAME__ = link_manager
import logging

from .data import DerivedComponent
from .link_helpers import LinkCollection


def accessible_links(cids, links):
    """ Calculate all ComponentLink objects in a list
    that can be calculated from a collection of componentIds

    :param cids: Collection of ComponentID objects
    :param links: Iterable of ComponentLink objects

    :rtype: list
    A list of all links that can be evaluated
    given the input ComponentIDs
    """
    cids = set(cids)
    return [l for l in links if
            set(l.get_from_ids()) <= cids]


def discover_links(data, links):
    """ Discover all links to components that can be derived
    based on the current components known to a dataset, and a set
    of ComponentLinks.

    :param Data: Data object to discover new components for
    :param links: Set of ComponentLinks to use

    :rtype: dict
    A dict of componentID -> componentLink
    The ComponentLink that data can use to generate the componentID.
    """

    # TODO: try to add shortest paths first -- should
    # prevent lots of repeated checking

    cids = set(data.primary_components)
    cid_links = {}
    depth = {}
    for cid in cids:
        depth[cid] = 0

    while True:
        for link in accessible_links(cids, links):
            from_ = set(link.get_from_ids())
            to_ = link.get_to_id()
            cost = max([depth[f] for f in from_]) + 1
            if to_ in cids and cost >= depth[to_]:
                continue
            depth[to_] = cost
            cids.add(to_)
            cid_links[to_] = link
            break
        else:
            # no more links to add
            break
    return cid_links


def find_dependents(data, link):
    """ Determine which `DerivedComponents` in a data set
    depend (either directly or implicitly) on a given
    `ComponentLink`.

    :param data: The data object to consider
    :param link: The `ComponentLink` object to consider

    :rtype: set
    A `set` of `DerivedComponent` IDs that cannot be
    calculated without the input `Link`
    """
    dependents = set()
    visited = set()
    while True:
        for derived in data.derived_components:
            derived = data.get_component(derived)
            if derived in visited:
                continue
            to_, from_ = derived.link.get_to_id(), derived.link.get_from_ids()
            if derived.link is link:
                dependents.add(to_)
                visited.add(derived)
                break
            if any(f in dependents for f in from_):
                dependents.add(to_)
                visited.add(derived)
                break
        else:
            break  # nothing more to remove
    return dependents


class LinkManager(object):
    """A helper class to generate and store ComponentLinks,
    and compute which components are accesible from which data sets
    """
    def __init__(self):
        self._links = set()
        self._duplicated_ids = []

    def add_link(self, link):
        if isinstance(link, (LinkCollection, list)):
            for l in link:
                self.add_link(l)
        else:
            self._links.add(link)
            if link.identity:
                self._add_duplicated_id(link)
        self._reassign_mergers()

    def _add_duplicated_id(self, link):
        frm = link.get_from_ids()
        assert len(frm) == 1
        frm = frm[0]
        to = link.get_to_id()
        if (frm, to) in self._duplicated_ids:
            return
        if (to, frm) in self._duplicated_ids:
            return
        self._duplicated_ids.append((frm, to))

    def _reassign_mergers(self):
        """Update all links such that any reference to a duplicate
        componentID is replaced with the original"""
        for l in self._links:
            for o, d in self._duplicated_ids:
                l.replace_ids(d, o)

    def _merge_duplicate_ids(self, data):
        for o, d in self._duplicated_ids:
            if d in data.components:
                data.update_id(d, o)

    def remove_link(self, link):
        logging.getLogger(__name__).debug('removing link %s', link)
        self._links.remove(link)

    def update_data_components(self, data):
        """Update all the DerivedComponents in a data object, based on
        all the Components deriveable based on the links in self.

        This overrides any ComponentLinks stored in the
        DerivedComponents of the data itself -- any components which
        depend on a link not tracked by the LinkManager will be
        deleted.

        Parameters
        -----------
        data : Data object

        Behavior
        --------
        DerivedComponents will be replaced / added into
        the data object
        """
        self._merge_duplicate_ids(data)
        self._remove_underiveable_components(data)
        self._add_deriveable_components(data)

    def _remove_underiveable_components(self, data):
        """ Find and remove any DerivedComponent in the data
        which requires a ComponentLink not tracked by this LinkManager
        """
        data_links = set(data.get_component(dc).link
                         for dc in data.derived_components)
        missing_links = data_links - self._links
        to_remove = []
        for m in missing_links:
            to_remove.extend(find_dependents(data, m))

        for r in to_remove:
            data.remove_component(r)

    def _add_deriveable_components(self, data):
        """Find and add any DerivedComponents that a data object can
        calculate given the ComponentLinks tracked by this
        LinkManager

        """
        links = discover_links(data, self._links)
        for cid, link in links.iteritems():
            d = DerivedComponent(data, link)
            data.add_component(d, cid)

    @property
    def links(self):
        return list(self._links)

    def clear(self):
        self._links.clear()

    def __contains__(self, item):
        return item in self._links

########NEW FILE########
__FILENAME__ = message
"""
.. module::glue.message

"""
__all__ = ['Message', 'ErrorMessage', 'SubsetMessage', 'SubsetCreateMessage',
           'SubsetUpdateMessage', 'SubsetDeleteMessage', 'DataMessage',
           'DataAddComponentMessage', 'DataUpdateMessage',
           'DataCollectionMessage', 'DataCollectionActiveChange',
           'DataCollectionActiveDataChange', 'DataCollectionAddMessage',
           'DataCollectionDeleteMessage']


class Message(object):

    """
    Base class for messages that the hub handles.

    Each message represents a specific kind of event. After clients
    register to a hub, the subscribe to specific message classes, and
    will only receive those kinds of messages.

    The message class family is hierarchical, and a client subscribing
    to a message class implicitly subscribes to all of its subclasses.

    :attr sender: The object which sent the message
    :attr tag: An optional string describing the message
    """

    def __init__(self, sender, tag=None):
        """Create a new message

        :param sender: The object sending the message
        :param tag: An optional string describing the message
        """
        self.sender = sender
        self.tag = tag

    def __str__(self):
        return '%s: %s\n\t Sent from: %s' % (type(self).__name__,
                                             self.tag or '',
                                             self.sender)


class ErrorMessage(Message):

    """ Used to send general purpose error messages """
    pass


class SubsetMessage(Message):

    """
    A general message issued by a subset.

    """

    def __init__(self, sender, tag=None):
        from .subset import Subset
        if (not isinstance(sender, Subset)):
            raise TypeError("Sender must be a subset: %s"
                            % type(sender))
        Message.__init__(self, sender, tag=tag)
        self.subset = self.sender


class SubsetCreateMessage(SubsetMessage):

    """
    A message that a subset issues when its state changes
    """
    pass


class SubsetUpdateMessage(SubsetMessage):

    """
    A message that a subset issues when its state changes.
    """

    def __init__(self, sender, attribute=None, tag=None):
        """
        :param attribute: An optional label of what attribute has changed
        """
        SubsetMessage.__init__(self, sender, tag=tag)
        self.attribute = attribute

    def __str__(self):
        result = super(SubsetUpdateMessage, self).__str__()
        result += "\n\t Updated %s" % self.attribute
        return result


class SubsetDeleteMessage(SubsetMessage):

    """
    A message that a subset issues when it is deleted
    """
    pass


class DataMessage(Message):

    """
    The base class for messages that data objects issue
    """

    def __init__(self, sender, tag=None):
        from .data import Data
        if (not isinstance(sender, Data)):
            raise TypeError("Sender must be a data instance: %s"
                            % type(sender))
        Message.__init__(self, sender, tag=tag)
        self.data = self.sender


class DataAddComponentMessage(DataMessage):

    def __init__(self, sender, component_id, tag=None):
        super(DataAddComponentMessage, self).__init__(sender, tag=tag)
        self.component_id = component_id


class ComponentsChangedMessage(DataMessage):
    pass


class DataUpdateMessage(DataMessage):

    def __init__(self, sender, attribute, tag=None):
        super(DataUpdateMessage, self).__init__(sender, tag=tag)
        self.attribute = attribute


class DataCollectionMessage(Message):

    def __init__(self, sender, tag=None):
        from .data_collection import DataCollection
        if (not isinstance(sender, DataCollection)):
            raise TypeError("Sender must be a DataCollection instance: %s"
                            % type(sender))
        Message.__init__(self, sender, tag=tag)


class DataCollectionActiveChange(DataCollectionMessage):
    pass


class DataCollectionActiveDataChange(DataCollectionMessage):
    pass


class DataCollectionAddMessage(DataCollectionMessage):

    def __init__(self, sender, data, tag=None):
        DataCollectionMessage.__init__(self, sender, tag=tag)
        self.data = data


class DataCollectionDeleteMessage(DataCollectionMessage):

    def __init__(self, sender, data, tag=None):
        DataCollectionMessage.__init__(self, sender, tag=tag)
        self.data = data

########NEW FILE########
__FILENAME__ = odict
# Licensed under a 3-clause BSD style license - see LICENSE.rst
"""
Backport of the Python 2.7 collections.OrderedDict class to Python 2.6.

Ordered dictionaries are just like regular dictionaries but they remember the
order that items were inserted.  When iterating over an ordered dictionary,
the items are returned in the order their keys were first added.

See: http://docs.python.org/library/collections.html#collections.OrderedDict
"""

from __future__ import absolute_import

__all__ = ['OrderedDict']

try:
    from collections import OrderedDict
except ImportError:

    from collections import MutableMapping
    from operator import eq as _eq
    from itertools import imap as _imap

    try:
        from thread import get_ident
    except ImportError:
        from dummy_thread import get_ident


    def _recursive_repr(user_function):
        'Decorator to make a repr function return "..." for a recursive call'
        repr_running = set()

        def wrapper(self):
            key = id(self), get_ident()
            if key in repr_running:
                return '...'
            repr_running.add(key)
            try:
                result = user_function(self)
            finally:
                repr_running.discard(key)
            return result

        # Can't use functools.wraps() here because of bootstrap issues
        wrapper.__module__ = getattr(user_function, '__module__')
        wrapper.__doc__ = getattr(user_function, '__doc__')
        wrapper.__name__ = getattr(user_function, '__name__')
        return wrapper

    class OrderedDict(dict, MutableMapping):
        'Dictionary that remembers insertion order'
        # An inherited dict maps keys to values.
        # The inherited dict provides __getitem__, __len__, __contains__, and get.
        # The remaining methods are order-aware.
        # Big-O running times for all methods are the same as for regular dictionaries.

        # The internal self.__map dictionary maps keys to links in a doubly linked list.
        # The circular doubly linked list starts and ends with a sentinel element.
        # The sentinel element never gets deleted (this simplifies the algorithm).
        # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

        def __init__(self, *args, **kwds):
            '''Initialize an ordered dictionary.  Signature is the same as for
            regular dictionaries, but keyword arguments are not recommended
            because their insertion order is arbitrary.

            '''
            if len(args) > 1:
                raise TypeError('expected at most 1 arguments, got %d' % len(args))
            try:
                self.__root
            except AttributeError:
                self.__root = root = [None, None, None]     # sentinel node
                PREV = 0
                NEXT = 1
                root[PREV] = root[NEXT] = root
                self.__map = {}
            self.update(*args, **kwds)

        def __setitem__(self, key, value, PREV=0, NEXT=1, dict_setitem=dict.__setitem__):
            'od.__setitem__(i, y) <==> od[i]=y'
            # Setting a new item creates a new link which goes at the end of the linked
            # list, and the inherited dictionary is updated with the new key/value pair.
            if key not in self:
                root = self.__root
                last = root[PREV]
                last[NEXT] = root[PREV] = self.__map[key] = [last, root, key]
            dict_setitem(self, key, value)

        def __delitem__(self, key, PREV=0, NEXT=1, dict_delitem=dict.__delitem__):
            'od.__delitem__(y) <==> del od[y]'
            # Deleting an existing item uses self.__map to find the link which is
            # then removed by updating the links in the predecessor and successor nodes.
            dict_delitem(self, key)
            link = self.__map.pop(key)
            link_prev = link[PREV]
            link_next = link[NEXT]
            link_prev[NEXT] = link_next
            link_next[PREV] = link_prev

        def __iter__(self, NEXT=1, KEY=2):
            'od.__iter__() <==> iter(od)'
            # Traverse the linked list in order.
            root = self.__root
            curr = root[NEXT]
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]

        def __reversed__(self, PREV=0, KEY=2):
            'od.__reversed__() <==> reversed(od)'
            # Traverse the linked list in reverse order.
            root = self.__root
            curr = root[PREV]
            while curr is not root:
                yield curr[KEY]
                curr = curr[PREV]

        def __reduce__(self):
            'Return state information for pickling'
            items = [[k, self[k]] for k in self]
            tmp = self.__map, self.__root
            del self.__map, self.__root
            inst_dict = vars(self).copy()
            self.__map, self.__root = tmp
            if inst_dict:
                return (self.__class__, (items,), inst_dict)
            return self.__class__, (items,)

        def clear(self):
            'od.clear() -> None.  Remove all items from od.'
            try:
                for node in self.__map.itervalues():
                    del node[:]
                self.__root[:] = [self.__root, self.__root, None]
                self.__map.clear()
            except AttributeError:
                pass
            dict.clear(self)

        setdefault = MutableMapping.setdefault
        update = MutableMapping.update
        pop = MutableMapping.pop
        keys = MutableMapping.keys
        values = MutableMapping.values
        items = MutableMapping.items
        iterkeys = MutableMapping.iterkeys
        itervalues = MutableMapping.itervalues
        iteritems = MutableMapping.iteritems
        __ne__ = MutableMapping.__ne__

        def popitem(self, last=True):
            '''od.popitem() -> (k, v), return and remove a (key, value) pair.
            Pairs are returned in LIFO order if last is true or FIFO order if false.

            '''
            if not self:
                raise KeyError('dictionary is empty')
            key = next(reversed(self) if last else iter(self))
            value = self.pop(key)
            return key, value

        @_recursive_repr
        def __repr__(self):
            'od.__repr__() <==> repr(od)'
            if not self:
                return '%s()' % (self.__class__.__name__,)
            return '%s(%r)' % (self.__class__.__name__, self.items())

        def copy(self):
            'od.copy() -> a shallow copy of od'
            return self.__class__(self)

        @classmethod
        def fromkeys(cls, iterable, value=None):
            '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
            and values equal to v (which defaults to None).

            '''
            d = cls()
            for key in iterable:
                d[key] = value
            return d

        def __eq__(self, other):
            '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
            while comparison to a regular mapping is order-insensitive.

            '''
            if isinstance(other, OrderedDict):
                return len(self)==len(other) and \
                       all(_imap(_eq, self.iteritems(), other.iteritems()))
            return dict.__eq__(self, other)

########NEW FILE########
__FILENAME__ = parse
import re

from .data import ComponentID
from .subset import Subset, SubsetState
from .component_link import ComponentLink

TAG_RE = re.compile('\{\s*(?P<tag>\S+)\s*\}')

__all__ = ['ParsedCommand', 'ParsedSubsetState']


def _ensure_only_component_references(cmd, references):
    """ Search through tag references in a command, ensure that
    they all reference ComponentIDs

    Parameters
    ----------
    cmd : string. A template command
    referenes : a mapping from tags to substitution objects

    Raises
    ------
    TypeError, if cmd does not refer only to ComponentIDs
    """
    for match in TAG_RE.finditer(cmd):
        tag = match.group('tag')
        if tag not in references or not \
                isinstance(references[tag], ComponentID):
            raise TypeError(
                "Reference to %s, which is not a ComponentID" % tag)


def _reference_list(cmd, references):
    """ Return a list of the values in the references mapping whose
    keys appear in the command

    Parameters
    ----------
    cmd : string. A template command
    references : a mapping from tags to substitution objects

    Returns
    -------
    A list of the unique values in references that appear in the command

    Examples
    --------
    >>> cmd = '{g} - {r} + {g}'
    >>> references = {'g' : g_object, 'r' : r_object, 'i' : i_object}
    >>> _reference_list(cmd, references)
    [g_object, r_object]

    Raises
    ------
    KeyError: if tags in the command aren't in the reference mapping
    """
    try:
        return list(set(references[m.group('tag')]
                        for m in TAG_RE.finditer(cmd)))
    except KeyError:
        raise KeyError("Tags from command not in reference mapping")


def _dereference(cmd, references):
    """ Dereference references in the template command, to refer
    to objects in the reference mapping

    Parameters
    ----------
    cmd : Command string
    references : mapping from template tags to objects

    Returns
    -------
    A new command, where all the tags have been subsituted as follows:
      "{tag}" -> 'data[references["tag"], __view]', if references[tag] is a ComponentID
      "{tag}" -> 'references["tag"].to_mask(__view)' if references[tag] is a Subset

    __view is a placeholder variable referencing the view
    passed to data.__getitem__ and subset.to_mask

    Raises
    ------
    TypeError, if a tag in the command maps to something other than
    a ComponentID or Subset object
    """
    def sub_func(match):
        tag = match.group('tag')
        if isinstance(references[tag], ComponentID):
            return 'data[references["%s"], __view]' % tag
        elif isinstance(references[tag], Subset):
            return 'references["%s"].to_mask(__view)' % tag
        else:
            raise TypeError("Tag %s maps to unrecognized type: %s" %
                            (tag, type(references[tag])))
    return TAG_RE.sub(sub_func, cmd)


def _validate(cmd, references):
    """ Make sure all references in the command are in the reference mapping

    Raises
    ------
    TypeError, if a tag is missing from references
    """
    for match in TAG_RE.finditer(cmd):
        tag = match.group('tag')
        if tag not in references:
            raise TypeError("Tag %s not in reference mapping: %s" %
                            (tag, references.keys()))


class ParsedCommand(object):
    """ Class to manage commands that define new components and subsets """

    def __init__(self, cmd, references):
        """ Create a new parsed command object

        Parameters
        ----------
        cmd : str. A template command. Can only reference ComponentID objects
        references : mapping from command templates to substitution objects
        """
        _validate(cmd, references)
        self._cmd = cmd
        self._references = references

    def ensure_only_component_references(self):
        _ensure_only_component_references(self._cmd, self._references)

    @property
    def reference_list(self):
        return _reference_list(self._cmd, self._references)

    def evaluate(self, data, view=None):
        from .. import env
        # pylint: disable=W0613, W0612
        references = self._references
        cmd = _dereference(self._cmd, self._references)
        scope = vars(env)
        scope['__view'] = view
        return eval(cmd, vars(env), locals())  # careful!

    def __gluestate__(self, context):
        return dict(cmd=self._cmd,
                    references=dict((k, context.id(v))
                                    for k, v in self._references.items()))

    @classmethod
    def __setgluestate__(cls, rec, context):
        cmd = rec['cmd']
        ref = dict((k, context.object(v))
                   for k, v in rec['references'].items())
        return cls(cmd, ref)


class ParsedComponentLink(ComponentLink):
    """ Class to create a new ComponentLink from a ParsedCommand object. """

    def __init__(self, to_, parsed):
        """ Create a new link

        Parameters
        ----------
        to_ : ComponentID instance to associate with the new component
        parsed : A ParsedCommand object
        """
        parsed.ensure_only_component_references()
        super(ParsedComponentLink, self).__init__(
            parsed.reference_list, to_, 'dummy')
        self._parsed = parsed

    def compute(self, data, view=None):
        return self._parsed.evaluate(data, view)

    def __gluestate__(self, context):
        return dict(parsed=context.do(self._parsed),
                    to=context.id(self.get_to_id()))

    @classmethod
    def __setgluestate__(cls, rec, context):
        return cls(context.object(rec['to']),
                   context.object(rec['parsed']))


class ParsedSubsetState(SubsetState):
    """ A SubsetState defined by a ParsedCommand object """
    def __init__(self, parsed):
        """ Create a new object

        Parameters
        ----------
        parsed : A ParsedCommand object
        """
        super(ParsedSubsetState, self).__init__()
        self._parsed = parsed

    def to_mask(self, data, view=None):
        """ Calculate the new mask by evaluating the dereferenced command """
        result = self._parsed.evaluate(data)
        if view is not None:
            result = result[view]
        return result

########NEW FILE########
__FILENAME__ = registry
from contextlib import contextmanager
from collections import defaultdict
from itertools import count
from functools import wraps

from .decorators import singleton


def disambiguate(label, taken):
    """If necessary, add a suffix to label to avoid name conflicts

    :param label: desired label
    :param taken: set of taken names

    Returns label if it is not in the taken set. Otherwise, returns
    label_NN where NN is the lowest integer such that label_NN not in taken.
    """
    if label not in taken:
        return label
    suffix = "_%2.2i"
    label = str(label)
    for i in count(1):
        candidate = label + (suffix % i)
        if candidate not in taken:
            return candidate


@singleton
class Registry(object):

    """ Stores labels for classes of objects. Ensures uniqueness

    The registry ensures that labels for objects of the same "group"
    are unique, and disambiguates as necessary. By default,
    objects types are used to group, but anything can be used as a group

    Registry is a singleton, and thus all instances of Registry
    share the same information

    Usage:

        >>> r = Registry()
        >>> x, y, z = 3, 4, 5
        >>> w = list()
        >>> r.register(x, 'Label')
        'Label'
        >>> r.register(y, 'Label')  # duplicate label disambiguated
        'Label_01'
        >>> r.register(w, 'Label')  # uniqueness only enforced within groups
        'Label'
        >>> r.register(z, 'Label', group=int) # put z in integer registry
        'Label_02'
    """

    def __init__(self):
        self._registry = defaultdict(dict)
        self._disable = False

    def register(self, obj, label, group=None):
        """ Register label with object (possibly disamgiguating)

        :param obj: The object to label
        :param label: The desired label
        :param group: (optional) use the registry for group (default=type(obj))

        :rtype: str

        *Returns*
        The disambiguated label
        """
        group = group or type(obj)

        reg = self._registry[group]

        has_obj = obj in reg
        has_label = label in reg.values()
        label_is_obj = has_label and has_obj and reg[obj] == label

        if has_label and (not label_is_obj):
            values = set(reg.values())
            if has_obj:
                values.remove(reg[obj])
            if not self._disable:
                label = disambiguate(label, values)

        reg[obj] = label
        return label

    def unregister(self, obj, group=None):
        group = group or type(obj)
        reg = self._registry[group]
        if obj in reg:
            reg.pop(obj)

    def clear(self):
        """ Reset registry, clearing all stored values """
        self._registry = defaultdict(dict)


def disable(func):
    """ Decorator to temporarily disable disambiguation """

    @wraps(func)
    def wrapper(*args, **kwargs):
        r = Registry()
        old = r._disable
        r._disable = True
        try:
            return func(*args, **kwargs)
        finally:
            r._disable = old

    return wrapper

########NEW FILE########
__FILENAME__ = roi
import numpy as np
from matplotlib.patches import Polygon, Rectangle, Ellipse, PathPatch
from matplotlib.patches import Path as mplPath
from matplotlib.transforms import IdentityTransform, blended_transform_factory
import copy

np.seterr(all='ignore')

from .exceptions import UndefinedROI

__all__ = ['Roi', 'RectangularROI', 'CircularROI', 'PolygonalROI',
           'AbstractMplRoi', 'MplRectangularROI', 'MplCircularROI',
           'MplPolygonalROI', 'MplXRangeROI', 'MplYRangeROI',
           'XRangeROI', 'RangeROI', 'YRangeROI']

PATCH_COLOR = '#FFFF00'


try:
    from matplotlib.nxutils import points_inside_poly
except ImportError:  # nxutils removed in MPL v1.3
    from matplotlib.path import Path as mplPath

    def points_inside_poly(xypts, xyvts):
        p = mplPath(xyvts)
        return p.contains_points(xypts)


def aspect_ratio(ax):
    """ Returns the pixel height / width of a box that spans 1
    data unit in x and y
    """
    width = ax.get_position().width * ax.figure.get_figwidth()
    height = ax.get_position().height * ax.figure.get_figheight()
    xmin, xmax = ax.get_xlim()
    ymin, ymax = ax.get_ylim()
    return height / width / (ymax - ymin) * (xmax - xmin)


def data_to_norm(ax, x, y):
    xy = np.column_stack((np.asarray(x).ravel(), np.asarray(y).ravel()))
    pixel = ax.transData.transform(xy)
    norm = ax.transAxes.inverted().transform(pixel)
    return norm


def data_to_pixel(ax, x, y):
    xy = np.column_stack((np.asarray(x).ravel(), np.asarray(y).ravel()))
    return ax.transData.transform(xy)


def pixel_to_data(ax, x, y):
    xy = np.column_stack((np.asarray(x).ravel(), np.asarray(y).ravel()))
    return ax.transData.inverted().transform(xy)


class Roi(object):  # pragma: no cover

    def contains(self, x, y):
        """Return true/false for each x/y pair. Raises UndefinedROI
        exception if not defined
        """
        raise NotImplementedError()

    def center(self):
        """Return the (x,y) coordinates of the ROI center"""
        raise NotImplementedError()

    def move_to(self, x, y):
        """Translate the ROI to a center of (x, y)"""
        raise NotImplementedError()

    def defined(self):
        """ Returns whether or not the subset is properly defined """
        raise NotImplementedError()

    def to_polygon(self):
        """ Returns a tuple of x and y points, approximating the ROI
        as a polygon."""
        raise NotImplementedError

    def copy(self):
        return copy.copy(self)


class RectangularROI(Roi):

    """
    A 2D rectangular region of interest.
    """

    def __init__(self, xmin=None, xmax=None, ymin=None, ymax=None):
        super(RectangularROI, self).__init__()
        self.xmin = xmin
        self.xmax = xmax
        self.ymin = ymin
        self.ymax = ymax

    def __str__(self):
        if self.defined():
            return "x=[%0.3f, %0.3f], y=[%0.3f, %0.3f]" % (self.xmin,
                                                           self.xmax,
                                                           self.ymin,
                                                           self.ymax)
        else:
            return "Undefined Rectangular ROI"

    def center(self):
        return self.xmin + self.width() / 2, self.ymin + self.height() / 2

    def move_to(self, x, y):
        cx, cy = self.center()
        dx = x - cx
        dy = y - cy
        self.xmin += dx
        self.xmax += dx
        self.ymin += dy
        self.ymax += dy

    def corner(self):
        return (self.xmin, self.ymin)

    def width(self):
        return self.xmax - self.xmin

    def height(self):
        return self.ymax - self.ymin

    def contains(self, x, y):
        """
        Test whether a set of (x,y) points falls within
        the region of interest

        :param x: A scalar or numpy array of x points
        :param y: A scalar or numpy array of y points

        *Returns*

            A list of True/False values, for whether each (x,y)
            point falls within the ROI
        """
        if not self.defined():
            raise UndefinedROI

        return (x > self.xmin) & (x < self.xmax) & \
               (y > self.ymin) & (y < self.ymax)

    def update_limits(self, xmin, ymin, xmax, ymax):
        """
        Update the limits of the rectangle
        """
        self.xmin = min(xmin, xmax)
        self.xmax = max(xmin, xmax)
        self.ymin = min(ymin, ymax)
        self.ymax = max(ymin, ymax)

    def reset(self):
        """
        Reset the rectangular region.
        """
        self.xmin = None
        self.xmax = None
        self.ymin = None
        self.ymax = None

    def defined(self):
        return self.xmin is not None

    def to_polygon(self):
        if self.defined():
            return [self.xmin, self.xmax, self.xmax, self.xmin, self.xmin], \
                [self.ymin, self.ymin, self.ymax, self.ymax, self.ymin]
        else:
            return [], []

    def __gluestate__(self, context):
        return dict(xmin=self.xmin, xmax=self.xmax, ymin=self.ymin, ymax=self.ymax)

    @classmethod
    def __setgluestate__(cls, rec, context):
        return cls(xmin=rec['xmin'], xmax=rec['xmax'],
                   ymin=rec['ymin'], ymax=rec['ymax'])


class RangeROI(Roi):

    def __init__(self, orientation, min=None, max=None):
        """:param orientation: 'x' or 'y'. Sets which axis to range"""
        super(RangeROI, self).__init__()
        if orientation not in ['x', 'y']:
            raise TypeError("Orientation must be one of 'x', 'y'")

        self.min = min
        self.max = max
        self.ori = orientation

    def __str__(self):
        if self.defined():
            return "%0.3f < %s < %0.3f" % (self.min, self.ori,
                                           self.max)
        else:
            return "Undefined %s" % type(self).__name__

    def range(self):
        return self.min, self.max

    def set_range(self, lo, hi):
        self.min, self.max = lo, hi

    def contains(self, x, y):
        if not self.defined():
            raise UndefinedROI()

        coord = x if self.ori == 'x' else y
        return (coord > self.min) & (coord < self.max)

    def reset(self):
        self.min = None
        self.max = None

    def defined(self):
        return self.min is not None and self.max is not None

    def to_polygon(self):
        if self.defined():
            on = [self.min, self.max, self.max, self.min, self.min]
            off = [-1e100, -1e100, 1e100, 1e100, -1e100]
            x, y = (on, off) if (self.ori == 'x') else (off, on)
            return x, y
        else:
            return [], []

    def __gluestate__(self, context):
        return dict(ori=self.ori, min=self.min, max=self.max)

    @classmethod
    def __setgluestate__(cls, rec, context):
        return cls(rec['ori'], min=rec['min'], max=rec['max'])


class XRangeROI(RangeROI):

    def __init__(self, min=None, max=None):
        super(XRangeROI, self).__init__('x', min=min, max=max)


class YRangeROI(RangeROI):

    def __init__(self, min=None, max=None):
        super(YRangeROI, self).__init__('y', min=min, max=max)


class CircularROI(Roi):

    """
    A 2D circular region of interest.
    """

    def __init__(self, xc=None, yc=None, radius=None):
        super(CircularROI, self).__init__()
        self.xc = xc
        self.yc = yc
        self.radius = radius

    def contains(self, x, y):
        """
        Test whether a set of (x,y) points falls within
        the region of interest

        :param x: A list of x points
        :param y: A list of y points

        *Returns*

           A list of True/False values, for whether each (x,y)
           point falls within the ROI

        """
        if not self.defined():
            raise UndefinedROI

        if not isinstance(x, np.ndarray):
            x = np.asarray(x)
        if not isinstance(y, np.ndarray):
            y = np.asarray(y)
        return (x - self.xc) ** 2 + (y - self.yc) ** 2 < self.radius ** 2

    def set_center(self, x, y):
        """
        Set the center of the circular region
        """
        self.xc = x
        self.yc = y

    def set_radius(self, radius):
        """
        Set the radius of the circular region
        """
        self.radius = radius

    def get_center(self):
        return self.xc, self.yc

    def get_radius(self):
        return self.radius

    def reset(self):
        """
        Reset the rectangular region.
        """
        self.xc = None
        self.yc = None
        self.radius = 0.

    def defined(self):
        """ Returns True if the ROI is defined """
        return self.xc is not None and \
            self.yc is not None and self.radius is not None

    def to_polygon(self):
        """ Returns x, y, where each is a list of points """
        if not self.defined():
            return [], []
        theta = np.linspace(0, 2 * np.pi, num=20)
        x = self.xc + self.radius * np.cos(theta)
        y = self.yc + self.radius * np.sin(theta)
        return x, y

    def __gluestate__(self, context):
        return dict(xc=self.xc, yc=self.yc, radius=self.radius)

    @classmethod
    def __setgluestate__(cls, rec, context):
        return cls(xc=rec['xc'], yc=rec['yc'], radius=rec['radius'])


class VertexROIBase(Roi):

    def __init__(self, vx=None, vy=None):
        """
        :param vx: initial x vertices
        :type vx: list
        :param vy: initial y vertices
        :type vy: list
        """
        super(VertexROIBase, self).__init__()
        self.vx = vx
        self.vy = vy
        if self.vx is None:
            self.vx = []
        if self.vy is None:
            self.vy = []

    def add_point(self, x, y):
        """
        Add another vertex to the ROI

        :param x: The x coordinate
        :param y: The y coordinate
        """
        self.vx.append(x)
        self.vy.append(y)

    def reset(self):
        """
        Reset the vertex list.
        """
        self.vx = []
        self.vy = []

    def replace_last_point(self, x, y):
        if len(self.vx) > 0:
            self.vx[-1] = x
            self.vy[-1] = y

    def remove_point(self, x, y, thresh=None):
        """Remove the vertex closest to a reference (xy) point

        :param x: The x coordinate of the reference point
        :param y: The y coordinate of the reference point

        :param thresh: An optional threshhold. If present, the vertex
                closest to (x,y) will only be removed if the distance
                is less than thresh

        """
        if len(self.vx) == 0:
            return

        # find distance between vertices and input
        dist = [(x - a) ** 2 + (y - b) ** 2 for a, b
                in zip(self.vx, self.vy)]
        inds = range(len(dist))
        near = min(inds, key=lambda x: dist[x])

        if thresh is not None and dist[near] > (thresh ** 2):
            return

        self.vx = [self.vx[i] for i in inds if i != near]
        self.vy = [self.vy[i] for i in inds if i != near]

    def defined(self):
        return len(self.vx) > 0

    def to_polygon(self):
        return self.vx, self.vy

    def __gluestate__(self, context):
        return dict(vx=np.asarray(self.vx).tolist(),
                    vy=np.asarray(self.vy).tolist())

    @classmethod
    def __setgluestate__(cls, rec, context):
        return cls(vx=rec['vx'], vy=rec['vy'])


class PolygonalROI(VertexROIBase):

    """
    A class to define 2D polygonal regions-of-interest
    """

    def __str__(self):
        result = 'Polygonal ROI ('
        result += ','.join(['(%s, %s)' % (x, y)
                            for x, y in zip(self.vx, self.vy)])
        result += ')'
        return result

    def contains(self, x, y):
        """
        Test whether a set of (x,y) points falls within
        the region of interest

        :param x: A list of x points
        :param y: A list of y points

        *Returns*

           A list of True/False values, for whether each (x,y)
           point falls within the ROI

        """
        if not self.defined():
            raise UndefinedROI
        if not isinstance(x, np.ndarray):
            x = np.asarray(x)
        if not isinstance(y, np.ndarray):
            y = np.asarray(y)

        xypts = np.column_stack((x.flat, y.flat))
        xyvts = np.column_stack((self.vx, self.vy))
        result = points_inside_poly(xypts, xyvts)
        good = np.isfinite(xypts).all(axis=1)
        result[~good] = False
        result.shape = x.shape
        return result


class Path(VertexROIBase):

    def __str__(self):
        result = 'Path ('
        result += ','.join(['(%s, %s)' % (x, y)
                            for x, y in zip(self.vx, self.vy)])
        result += ')'
        return result


class AbstractMplRoi(object):  # pragma: no cover

    """ Base class for objects which use
    Matplotlib user events to edit/display ROIs
    """

    def __init__(self, ax):
        """
        :param ax: The Matplotlib Axes object to draw to
        """

        self._ax = ax
        self._roi = self._roi_factory()
        self._mid_selection = False

    def _draw(self):
        self._ax.figure.canvas.draw()

    def _roi_factory(self):
        raise NotImplementedError()

    def roi(self):
        return self._roi.copy()

    def reset(self):
        self._roi.reset()
        self._mid_selection = False
        self._sync_patch()

    def active(self):
        return self._mid_selection

    def start_selection(self, event):
        raise NotImplementedError()

    def update_selection(self, event):
        raise NotImplementedError()

    def finalize_selection(self, event):
        raise NotImplementedError()

    def _sync_patch(self):
        raise NotImplementedError()


class MplRectangularROI(AbstractMplRoi):

    """
    A subclass of RectangularROI that also renders the ROI to a plot

    *Attributes*:

        plot_opts:

                   Dictionary instance
                   A dictionary of plot keywords that are passed to
                   the patch representing the ROI. These control
                   the visual properties of the ROI
    """

    def __init__(self, ax):
        """
        :param ax: A matplotlib Axes object to attach the graphical ROI to
        """

        AbstractMplRoi.__init__(self, ax)

        self._xi = None
        self._yi = None
        self._scrubbing = False

        self.plot_opts = {'edgecolor': PATCH_COLOR, 'facecolor': PATCH_COLOR,
                          'alpha': 0.3}

        self._patch = Rectangle((0., 0.), 1., 1.)
        self._patch.set_zorder(100)
        self._setup_patch()

    def _setup_patch(self):
        self._ax.add_patch(self._patch)
        self._patch.set_visible(False)

        self._sync_patch()

    def _roi_factory(self):
        return RectangularROI()

    def start_selection(self, event):
        if event.inaxes != self._ax:
            return

        self._xi = event.xdata
        self._yi = event.ydata

        if self._roi.defined() and \
                self._roi.contains(event.xdata, event.ydata):
            self._scrubbing = True
            self._cx, self._cy = self._roi.center()
        else:
            self._scrubbing = False
            self._roi.reset()
            self._roi.update_limits(event.xdata, event.ydata,
                                    event.xdata, event.ydata)

        self._mid_selection = True
        self._sync_patch()

    def update_selection(self, event):
        if not self._mid_selection or event.inaxes != self._ax:
            return

        if self._scrubbing:
            self._roi.move_to(self._cx + event.xdata - self._xi,
                              self._cy + event.ydata - self._yi)
        else:
            self._roi.update_limits(min(event.xdata, self._xi),
                                    min(event.ydata, self._yi),
                                    max(event.xdata, self._xi),
                                    max(event.ydata, self._yi))
        self._sync_patch()

    def finalize_selection(self, event):
        self._mid_selection = False
        self._patch.set_visible(False)
        self._draw()

    def _sync_patch(self):
        if self._roi.defined():
            corner = self._roi.corner()
            width = self._roi.width()
            height = self._roi.height()
            self._patch.set_xy(corner)
            self._patch.set_width(width)
            self._patch.set_height(height)
            self._patch.set(**self.plot_opts)
            self._patch.set_visible(True)
        else:
            self._patch.set_visible(False)
        self._draw()

    def __str__(self):
        return "MPL Rectangle: %s" % self._patch


class MplXRangeROI(AbstractMplRoi):

    def __init__(self, ax):
        """
        :param ax: A matplotlib Axes object to attach the graphical ROI to
        """

        AbstractMplRoi.__init__(self, ax)
        self._xi = None

        self.plot_opts = {'edgecolor': PATCH_COLOR, 'facecolor': PATCH_COLOR,
                          'alpha': 0.3}

        trans = blended_transform_factory(self._ax.transData,
                                          self._ax.transAxes)
        self._patch = Rectangle((0., 0.), 1., 1., transform=trans)
        self._patch.set_zorder(100)
        self._setup_patch()

    def _setup_patch(self):
        self._ax.add_patch(self._patch)
        self._patch.set_visible(False)
        self._sync_patch()

    def _roi_factory(self):
        return XRangeROI()

    def start_selection(self, event):
        if event.inaxes != self._ax:
            return

        self._roi.reset()
        self._roi.set_range(event.xdata, event.xdata)
        self._xi = event.xdata
        self._mid_selection = True
        self._sync_patch()

    def update_selection(self, event):
        if not self._mid_selection or event.inaxes != self._ax:
            return
        self._roi.set_range(min(event.xdata, self._xi),
                            max(event.xdata, self._xi))
        self._sync_patch()

    def finalize_selection(self, event):
        self._mid_selection = False
        self._patch.set_visible(False)
        self._draw()

    def _sync_patch(self):
        if self._roi.defined():
            rng = self._roi.range()
            self._patch.set_xy((rng[0], 0))
            self._patch.set_width(rng[1] - rng[0])
            self._patch.set_height(1)
            self._patch.set(**self.plot_opts)
            self._patch.set_visible(True)
        else:
            self._patch.set_visible(False)
        self._draw()


class MplYRangeROI(AbstractMplRoi):

    def __init__(self, ax):
        """
        :param ax: A matplotlib Axes object to attach the graphical ROI to
        """

        AbstractMplRoi.__init__(self, ax)
        self._xi = None

        self.plot_opts = {'edgecolor': PATCH_COLOR, 'facecolor': PATCH_COLOR,
                          'alpha': 0.3}

        trans = blended_transform_factory(self._ax.transAxes,
                                          self._ax.transData)
        self._patch = Rectangle((0., 0.), 1., 1., transform=trans)
        self._patch.set_zorder(100)
        self._setup_patch()

    def _setup_patch(self):
        self._ax.add_patch(self._patch)
        self._patch.set_visible(False)
        self._sync_patch()

    def _roi_factory(self):
        return YRangeROI()

    def start_selection(self, event):
        if event.inaxes != self._ax:
            return

        self._roi.reset()
        self._roi.set_range(event.ydata, event.ydata)
        self._xi = event.ydata
        self._mid_selection = True
        self._sync_patch()

    def update_selection(self, event):
        if not self._mid_selection or event.inaxes != self._ax:
            return
        self._roi.set_range(min(event.ydata, self._xi),
                            max(event.ydata, self._xi))
        self._sync_patch()

    def finalize_selection(self, event):
        self._mid_selection = False
        self._patch.set_visible(False)
        self._draw()

    def _sync_patch(self):
        if self._roi.defined():
            rng = self._roi.range()
            self._patch.set_xy((0, rng[0]))
            self._patch.set_height(rng[1] - rng[0])
            self._patch.set_width(1)
            self._patch.set(**self.plot_opts)
            self._patch.set_visible(True)
        else:
            self._patch.set_visible(False)
        self._draw()


class MplCircularROI(AbstractMplRoi):

    """
    Class to display / edit circular ROIs using matplotlib

    Since circles on the screen may not be circles in the data
    (due, e.g., to logarithmic scalings on the axes), the
    ultimate ROI that is created is a polygonal ROI

    :param plot_opts:

               A dictionary of plot keywords that are passed to
               the patch representing the ROI. These control
               the visual properties of the ROI
    """

    def __init__(self, ax):
        """
        :param ax: A matplotlib Axes object to attach the graphical ROI to
        """

        AbstractMplRoi.__init__(self, ax)
        self.plot_opts = {'edgecolor': PATCH_COLOR, 'facecolor': PATCH_COLOR,
                          'alpha': 0.3}

        self._xi = None
        self._yi = None
        self._setup_patch()

    def _setup_patch(self):
        self._patch = Ellipse((0., 0.), transform=IdentityTransform(),
                              width=0., height=0.,)
        self._patch.set_zorder(100)
        self._patch.set(**self.plot_opts)
        self._ax.add_patch(self._patch)
        self._patch.set_visible(False)
        self._sync_patch()

    def _roi_factory(self):
        return CircularROI()

    def _sync_patch(self):
        # Update geometry
        if not self._roi.defined():
            self._patch.set_visible(False)
        else:
            xy = self._roi.get_center()
            r = self._roi.get_radius()
            self._patch.center = xy
            self._patch.width = 2. * r
            self._patch.height = 2. * r
            self._patch.set_visible(True)

        # Update appearance
        self._patch.set(**self.plot_opts)

        # Refresh
        self._ax.figure.canvas.draw()

    def start_selection(self, event):
        if event.inaxes != self._ax:
            return

        xy = data_to_pixel(self._ax, [event.xdata], [event.ydata])
        self._roi.set_center(xy[0, 0], xy[0, 1])
        self._roi.set_radius(0.)
        self._xi = xy[0, 0]
        self._yi = xy[0, 1]
        self._mid_selection = True
        self._sync_patch()

    def update_selection(self, event):
        if not self._mid_selection or event.inaxes != self._ax:
            return

        xy = data_to_pixel(self._ax, [event.xdata], [event.ydata])
        dx = xy[0, 0] - self._xi
        dy = xy[0, 1] - self._yi
        self._roi.set_radius(np.hypot(dx, dy))
        self._sync_patch()

    def roi(self):
        if not self._roi.defined():
            return PolygonalROI()

        theta = np.linspace(0, 2 * np.pi, num=200)
        xy_center = self._roi.get_center()
        rad = self._roi.get_radius()
        x = xy_center[0] + rad * np.cos(theta)
        y = xy_center[1] + rad * np.sin(theta)
        xy_data = pixel_to_data(self._ax, x, y)
        vx = xy_data[:, 0].ravel().tolist()
        vy = xy_data[:, 1].ravel().tolist()
        result = PolygonalROI(vx, vy)
        return result

    def finalize_selection(self, event):
        self._mid_selection = False
        self._patch.set_visible(False)
        self._ax.figure.canvas.draw()


class MplPolygonalROI(AbstractMplRoi):

    """
    Defines and displays polygonal ROIs on matplotlib plots

    Attributes:

        plot_opts: Dictionary instance
                   A dictionary of plot keywords that are passed to
                   the patch representing the ROI. These control
                   the visual properties of the ROI
    """

    def __init__(self, ax):
        """
        :param ax: A matplotlib Axes object to attach the graphical ROI to
        """
        AbstractMplRoi.__init__(self, ax)
        self.plot_opts = {'edgecolor': PATCH_COLOR, 'facecolor': PATCH_COLOR,
                          'alpha': 0.3}

        self._setup_patch()

    def _setup_patch(self):
        self._patch = Polygon(np.array(zip([0, 1], [0, 1])))
        self._patch.set_zorder(100)
        self._patch.set(**self.plot_opts)
        self._ax.add_patch(self._patch)
        self._patch.set_visible(False)
        self._sync_patch()

    def _roi_factory(self):
        return PolygonalROI()

    def _sync_patch(self):
        # Update geometry
        if not self._roi.defined():
            self._patch.set_visible(False)
        else:
            x, y = self._roi.to_polygon()
            self._patch.set_xy(zip(x + [x[0]],
                                   y + [y[0]]))
            self._patch.set_visible(True)

        # Update appearance
        self._patch.set(**self.plot_opts)

        # Refresh
        self._ax.figure.canvas.draw()

    def start_selection(self, event):
        if event.inaxes != self._ax:
            return

        self._roi.reset()
        self._roi.add_point(event.xdata, event.ydata)
        self._mid_selection = True
        self._sync_patch()

    def update_selection(self, event):
        if not self._mid_selection or event.inaxes != self._ax:
            return
        self._roi.add_point(event.xdata, event.ydata)
        self._sync_patch()

    def finalize_selection(self, event):
        self._mid_selection = False
        self._patch.set_visible(False)
        self._ax.figure.canvas.draw()


class MplPathROI(MplPolygonalROI):

    def roi_factory(self):
        return Path()

    def _setup_patch(self):
        self._patch = None

    def _sync_patch(self):
        if self._patch is not None:
            self._patch.remove()
            self._patch = None

        # Update geometry
        if not self._roi.defined():
            return
        else:
            x, y = self._roi.to_polygon()
            p = MplPath(np.column_stack((x, y)))
            self._patch = PatchPath(p)
            self._patch.set_visible(True)

        # Update appearance
        self._patch.set(**self.plot_opts)

        # Refresh
        self._ax.figure.canvas.draw()

    def finalize_selection(self, event):
        self._mid_selection = False
        if self._patch is not None:
            self._patch.set_visible(False)
        self._ax.figure.canvas.draw()

########NEW FILE########
__FILENAME__ = session
from . import DataCollection, CommandStack


class Session(object):

    def __init__(self, application=None, data_collection=None,
                 command_stack=None, hub=None):

        # applications can be added after instantiation
        self.application = application

        self.data_collection = data_collection or DataCollection()
        self.hub = self.data_collection.hub
        self.command_stack = command_stack or CommandStack()
        self.command_stack.session = self

########NEW FILE########
__FILENAME__ = simpleforms
"""
The descriptors in this module are meant to be added to classes, to
specify simple user-settable forms. These classes are used to automatically
construct GUIs, without having to write GUI code in the form class itself.

:class:`Option` objects are defined at the class-level. To instances of
these classes, an :class:`Option` behaves like a normal instance attribute.

See :ref:`fit_plugins` for example usage.
"""


class Option(object):

    """
    Base class for other options.

    This shouldn't be used directly
    """

    def __init__(self, default, label):
        """
        :param default: The default value for this option.
        :type default: object
        :param label: A short label for this option, to use in the GUI
        :type label: str
        """
        self.label = label
        """A UI label for the setting"""
        self.default = default
        """The default value"""

        self._name = "__%s_%i" % (type(self), id(self))

    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        return getattr(instance, self._name, self.default)

    def __set__(self, instance, value):
        value = self._validate(value)
        setattr(instance, self._name, value)

    def _validate(self, value):
        return value


class IntOption(Option):

    def __init__(self, min=0, max=10, default=1, label="Integer"):
        """
        An integer-valued option

        :param min: The minimum valid value
        :type min: integer
        :param max: The maximum valid value
        :type max: integer
        :param default: The default value
        :type default: integer
        :param label: A short label for this option
        :type label: str
        """
        super(IntOption, self).__init__(default, label)

        self.min = min
        self.max = max

    def _validate(self, value):

        try:
            if value != int(value):
                raise ValueError()
            value = int(value)
        except ValueError:
            raise ValueError("%s must be an integer" % self.label)

        if value < self.min:
            raise ValueError("%s must be >= %i" % (self.label, self.min))

        if value > self.max:
            raise ValueError("%s must be <= %i" % (self.label, self.max))

        return value


class FloatOption(Option):

    def __init__(self, min=0, max=10, default=1, label="Float"):
        """
        An floating-point option

        :param min: The minimum valid value
        :type min: float
        :param max: The maximum valid value
        :type max: float
        :param default: The default value
        :type default: float
        :param label: A short label for this option
        :type label: str
        """
        super(FloatOption, self).__init__(default, label)
        self.min = min
        self.max = max

    def _validate(self, value):
        value = float(value)

        if value < self.min or value > self.max:
            raise ValueError("%s must be between %e and %e" % (self.label,
                             self.min, self.max))
        return value


class BoolOption(Option):

    def __init__(self, label="Bool", default=False):
        """
        A boolean-valued option

        :param default: The default True/False value
        :type default: bool

        :param label: A short label for this option
        :type label: str
        """
        super(BoolOption, self).__init__(default, label)

    def _validate(self, value):
        if value not in [True, False]:
            raise ValueError(
                "%s must be True or False: %s" % (self.label, value))

        return value

########NEW FILE########
__FILENAME__ = state
"""
Module to convert Glue objects to and from JSON descriptions

Example Usage:

s = GlueSerializer(object)
s.dumpo() -> a JSON-serializeable dict
s.dumps() -> a JSON string
s.dump(file) -> dump to a file object

varname = s.id(x) -> string identifier that uniquely labels an object in
                     the Serialized state

u = GlueUnSerializer.load(file)
u = GlueUnSerializer.loads(str)
u.object(varname) -> A reconstituted version of `x`
u.object('__main__') -> The object passed to the GlueSerializer constructor

Developer Notes:

Custom methods to serialize a class of objects can be registered either by:
 - wrapping a serialization function in the @saver decorator::

    @saver(TypeToSave)
    def save(object, context):
        ...

 - Defining a __gluestate__(self, context) method

These methods should return a JSON-serializable dict representing the
object.  context is a GlueSerializer instance. The `context.id` and
`context.do` methods are helpful for referencing or serializing or
dependencies

Unserializer methods can be registered either via:
 - wrapping the method in the @loader decorator::

     @loader(TypeToLoad)
     def load(rec, context)

`rec` is the JSON dict created from the saver, and `context` is a
GlueUnserializer object. context.object() is useful for unserializing
dependencies.

Versions:

Both the @saver and @loader take an optional version keyword. Whenever
you modify the serialization format for an object, you should register a
new saver and loader version. This ensures Glue can still load old
serialization protocols. Versions must be sequential integers,
starting from 1.
"""
from itertools import count
from collections import defaultdict
import json
import types
import logging
from cStringIO import StringIO
from inspect import isgeneratorfunction

import numpy as np

from .subset import (OPSYM, SYMOP, CompositeSubsetState,
                     SubsetState, Subset, RoiSubsetState,
                     InequalitySubsetState, RangeSubsetState)
from .data import (Data, Component, ComponentID, DerivedComponent,
                   CoordinateComponent)
from . import (VisualAttributes, ComponentLink, DataCollection)
from .component_link import CoordinateComponentLink
from .util import lookup_class
from .roi import Roi
from . import glue_pickle as gp
from .. import core
from .subset_group import coerce_subset_groups

literals = tuple([types.NoneType, types.FloatType,
                 types.IntType, types.LongType,
                 types.NoneType, types.StringType,
                 types.BooleanType, types.UnicodeType, types.ListType,
                 tuple])
literals += np.ScalarType

_lookup = lookup_class


class GlueSerializeError(RuntimeError):
    pass


class VersionedDict(object):

    """
    A dict-like object which associates (key, version_int) pairs
    with an object. Bracket syntax (d[key]) returns the highest-version
    value stored with a key.

    Versions must be sequential integers starting with 1, and must be
    added in order

    Examples
    --------
    v = VersionedDict()
    v['key', 1] = 'v1'
    v['key', 2] = 'v2'

    v['key'] -> 'v2', 2
    v.get_version('key', 2) -> 'v2'
    v.get_version('key', 1) -> 'v1'
    'key' in v -> True

    Not allowed:
    v['key', 4] = 'cannot skip versions'
    v['key', 2] = 'cannot overwrite versions'
    v['key', 'bad'] = 'versions must be integers'
    """

    def __init__(self):
        self._data = defaultdict(dict)

    def __contains__(self, key):
        return key in self._data

    def get_version(self, key, version=None):
        """
        Get a specific version of a value stored with a key

        :param key: The key to fetch
        :param value: the version of the value to fetch. Defaults to latest
        """
        if version is None:
            if key not in self._data:
                raise KeyError("No value associated with any version of %s"
                               % key)
            vs = self._data[key]
            return vs[max(vs)]

        try:
            return self._data[key][version]
        except KeyError:
            raise KeyError("No value associated with version %s of %s" %
                           (version, key))

    def __getitem__(self, key):
        """Retrieve the highest-version value stored with a key

        Returns a tuple of the value, and the version it is associated with
        """
        if key not in self._data:
            raise KeyError(key)
        versions = self._data[key]
        return versions[max(versions)], max(versions)

    def __delitem__(self, key):
        raise ValueError("Cannot remove items from VersionedDict")

    def __len__(self):
        return len(self._data)

    def __setitem__(self, key, value):
        """ Assign a new value with a particular key and version

        :param key: a tuple of (key, version)
        version must be an integer, equal to the previous version + 1 (or 1)
        Overwriting versions is not permitted, and will raise a KeyError

        :param value: The value to associate with the (key, version) pair
        """
        if len(key) != 2:
            raise ValueError("Key must be a (item, version) pair")
        item, version = key
        try:
            version = int(version)
        except ValueError:
            raise ValueError("Version must be an integer: %s" % version)
        if version > 1 and (version - 1) not in self._data[item]:
            raise KeyError("Cannot assign version %i of item before adding "
                           "version %i" % (version, version - 1))
        if version in self._data[item]:
            raise KeyError("Cannot overwrite version %i of %s" %
                           (version, item))

        self._data[item][version] = value


class GlueSerializer(object):

    """
    Serialize an object graph
    """
    dispatch = VersionedDict()

    def __init__(self, obj):
        self._names = {}  # map id(object) -> name
        self._objs = {}   # map name -> object
        self._working = set()
        self._main = obj
        self.id(obj)

    @classmethod
    def serializes(cls, obj, version=1):
        def decorator(func):
            cls.dispatch[(obj, version)] = func
            return func
        return decorator

    def _label(self, obj):
        if obj is self._main:
            return '__main__'
        elif hasattr(obj, 'label'):
            return self._disambiguate(obj.label)
        else:
            return self._disambiguate(type(obj).__name__)

    def id(self, obj):
        """
        Return a unique name for an object,
        and add it to the ID registry if necessary
        """
        if isinstance(obj, literals):
            return obj

        oid = id(obj)

        if oid in self._names:
            return self._names[oid]

        name = self._label(obj)
        assert name not in self._objs

        logging.debug("Registering %r as %s", obj, name)
        self._objs[name] = obj
        self._names[oid] = name

        return name

    def object(self, name):
        return self._objs[name]

    def do_all(self):
        sz = -1
        while sz != len(self._objs):
            sz = len(self._objs)
            result = dict((oid, self.do(obj))
                          for oid, obj in self._objs.items())
        return result

    def do(self, obj):
        """
        Serialize an object, but do not add it to
        the ID registry
        """
        if isinstance(obj, literals):
            return obj

        oid = id(obj)
        if oid in self._working:
            raise GlueSerializeError("Circular reference detected")
        self._working.add(oid)

        fun, version = self._dispatch(obj)
        logging.debug("Serializing %s with %s", obj, fun)
        result = fun(obj, self)

        if isinstance(obj, types.FunctionType):
            result['_type'] = 'types.FunctionType'
        else:
            result['_type'] = "%s.%s" % (type(obj).__module__,
                                         type(obj).__name__)
        if version > 1:
            result['_protocol'] = version

        self._working.remove(oid)
        return result

    def _dispatch(self, obj):
        if hasattr(obj, '__gluestate__'):
            return type(obj).__gluestate__, 1

        for typ in type(obj).mro():
            if typ in self.dispatch:
                return self.dispatch[typ]

        raise GlueSerializeError("Don't know how to serialize"
                                 " %r of type %s" % (obj, type(obj)))

    def _disambiguate(self, name):
        if name not in self._objs:
            return name

        for i in count(0):
            newname = "%s_%i" % (name, i)
            if newname not in self._objs:
                return newname

    def dumpo(self):
        """
        Dump an object (with needed dependencies) into a
        JSON Serializable data structure.

        Note: If eventually dumping to a string or file, dumps or dump
              are more robust
        """
        return self.do_all()

    @staticmethod
    def json_default(o):
        """Default JSON enconding, to handle some special cases

        In particular, coerces numpy scalars to the equivalent
        python types

        Can be used as default kwarg in json.dumps/json.dump
        """
        if np.isscalar(o):
            return np.asscalar(o)  # coerce to pure-python type
        if isinstance(o, tuple):
            return list(o)
        return o

    def dumps(self, indent=None):
        result = self.dumpo()
        return json.dumps(result, indent=indent, default=self.json_default)

    def dump(self, outfile, indent=None):
        result = self.dumpo()
        return json.dump(result, outfile, default=self.json_default,
                         indent=indent)


class GlueUnSerializer(object):
    dispatch = VersionedDict()

    def __init__(self, string=None, fobj=None):
        if string is None and fobj is None:
            raise ValueError("Most provide either a string or a file")
        self._names = {}  # map id(object) -> name
        self._objs = {}   # map name -> object
        self._working = set()
        self._rec = json.loads(string) if string else json.load(fobj)

    @classmethod
    def loads(cls, string):
        return cls(string=string)

    @classmethod
    def load(cls, fobj):
        return cls(fobj=fobj)

    @classmethod
    def unserializes(cls, obj, version=1):
        def decorator(func):
            cls.dispatch[(obj, version)] = func
            return func
        return decorator

    def _dispatch(self, rec):
        typ = _lookup(rec['_type'])
        version = rec.get('_protocol')

        if hasattr(typ, '__setgluestate__'):
            return typ.__setgluestate__

        for t in typ.mro():
            try:
                return self.dispatch.get_version(t, version)
            except KeyError:
                continue

        raise GlueSerializeError("Don't know how to load"
                                 " objects of type %s" % typ)

    def register_object(self, obj_id, obj):
        self._objs[obj_id] = obj

    @core.registry.disable
    def object(self, obj_id):
        if isinstance(obj_id, basestring):
            if obj_id in self._objs:
                return self._objs[obj_id]

            if obj_id not in self._rec:
                raise GlueSerializeError("Unrecognized object %s" % obj_id)

            if obj_id in self._working:
                raise GlueSerializeError(
                    "Circular Reference detected: %s" % obj_id)

            self._working.add(obj_id)
            rec = self._rec[obj_id]

        elif isinstance(obj_id, literals):
            return obj_id
        else:
            rec = obj_id

        func = self._dispatch(rec)
        obj = func(rec, self)

        # loader functions might yield the constructed value,
        # and then futher populate it. This deals with circular
        # dependencies.
        if isgeneratorfunction(func):
            gen, obj = obj, next(obj)  # get the partially-constructed value...

        if isinstance(obj_id, basestring):  # ... add it to the registry ...
            self._objs[obj_id] = obj
            self._working.remove(obj_id)

        if isgeneratorfunction(func):
            for _ in gen:  # ... and finish constructing it
                pass

        return obj


saver = GlueSerializer.serializes
loader = GlueUnSerializer.unserializes


@saver(CompositeSubsetState)
def _save_composite_subset_state(state, context):
    return dict(state1=context.id(state.state1),
                state2=context.id(state.state2))


@loader(CompositeSubsetState)
def _load_composite_subset_state(rec, context):
    cls = _lookup(rec['_type'])
    result = cls(context.object(rec['state1']),
                 context.object(rec['state2']))
    return result


@saver(SubsetState)
def _save_subset_state(state, context):
    return {}


@loader(SubsetState)
def _load_subset_state(rec, context):
    return SubsetState()


@saver(RangeSubsetState)
def _save_range_subset_state(state, context):
    return dict(lo=state.lo, hi=state.hi, att=context.id(state.att))


@loader(RangeSubsetState)
def _load_range_subset_state(rec, context):
    return RangeSubsetState(rec['lo'], rec['hi'], context.object(rec['att']))


@saver(RoiSubsetState)
def _save_roi_subset_state(state, context):
    return dict(xatt=context.id(state.xatt),
                yatt=context.id(state.yatt),
                roi=context.id(state.roi))


@loader(RoiSubsetState)
def _load_roi_subset_state(rec, context):
    return RoiSubsetState(context.object(rec['xatt']),
                          context.object(rec['yatt']),
                          context.object(rec['roi']))


@saver(InequalitySubsetState)
def _save_inequality_subset_state(state, context):
    return dict(left=context.id(state.left),
                right=context.id(state.right),
                op=OPSYM.get(state.operator))


@loader(InequalitySubsetState)
def _load_inequality_subset_state(rec, context):
    return InequalitySubsetState(context.object(rec['left']),
                                 context.object(rec['right']),
                                 SYMOP[rec['op']])


@saver(Roi)
def _save_roi(roi, context):
    raise NotImplementedError


@loader(Roi)
def _laod_roi(roi, context):
    raise NotImplementedError


@saver(VisualAttributes)
def _save_style(style, context):
    return dict((a, getattr(style, a)) for a in style._atts)


@loader(VisualAttributes)
def _load_style(rec, context):
    result = VisualAttributes()
    for attr in result._atts:
        setattr(result, attr, rec[attr])
    return result


@saver(Subset)
def _save_subset(subset, context):
    return dict(style=context.do(subset.style),
                state=context.id(subset.subset_state),
                label=subset.label)


@loader(Subset)
def _load_subset(rec, context):
    result = Subset(None)
    result.style = context.object(rec['style'])
    result.subset_state = context.object(rec['state'])
    result.label = rec['label']
    return result


@saver(DataCollection)
def _save_data_collection(dc, context):
    cids = [c for data in dc for c in data.component_ids()]
    components = [data.get_component(c)
                  for data in dc for c in data.component_ids()]
    return dict(data=map(context.id, dc),
                links=map(context.id, dc.links),
                cids=map(context.id, cids),
                components=map(context.id, components))


@saver(DataCollection, version=2)
def _save_data_collection_2(dc, context):
    result = _save_data_collection(dc, context)
    result['groups'] = map(context.id, dc.subset_groups)
    return result


@loader(DataCollection)
def _load_data_collection(rec, context):
    dc = DataCollection(map(context.object, rec['data']))
    for link in rec['links']:
        dc.add_link(context.object(link))
    coerce_subset_groups(dc)
    return dc


@loader(DataCollection, version=2)
def _load_data_collection_2(rec, context):
    result = _load_data_collection(rec, context)
    result._subset_groups = map(context.object, rec['groups'])
    for grp in result.subset_groups:
        grp.register_to_hub(result.hub)
    return result


@saver(Data)
def _save_data(data, context):

    return dict(components=[(context.id(c),
                            context.id(data.get_component(c)))
                            for c in data._components],
                subsets=[context.id(s) for s in data.subsets],
                label=data.label,
                coords=context.id(data.coords))


@saver(Data, version=2)
def _save_data_2(data, context):
    result = _save_data(data, context)
    result['style'] = context.do(data.style)
    return result


@loader(Data)
def _load_data(rec, context):
    label = rec['label']
    result = Data(label=label)
    result.coords = context.object(rec['coords'])

    # we manually rebuild pixel/world components, so
    # we override this function. This is pretty ugly
    result._create_pixel_and_world_components = lambda: None

    comps = [map(context.object, [cid, comp])
             for cid, comp in rec['components']]
    comps = sorted(comps,
                   key=lambda x: isinstance(x[1], (DerivedComponent,
                                                   CoordinateComponent)))
    for cid, comp in comps:
        if isinstance(comp, CoordinateComponent):
            comp._data = result
        result.add_component(comp, cid)

    assert result._world_component_ids == []

    coord = [c for c in comps if isinstance(c[1], CoordinateComponent)]
    coord = [x[0] for x in sorted(coord, key=lambda x: x[1])]

    assert len(coord) == result.ndim * 2

    result._world_component_ids = coord[:len(coord) / 2]
    result._pixel_component_ids = coord[len(coord) / 2:]

    for s in rec['subsets']:
        result.add_subset(context.object(s))

    return result


@loader(Data, version=2)
def _load_datda_2(rec, context):
    # adds style saving
    result = _load_data(rec, context)
    result.style = context.object(rec['style'])
    return result


@saver(ComponentID)
def _save_component_id(cid, context):
    return dict(label=cid.label, hidden=cid.hidden)


@loader(ComponentID)
def _load_component_id(rec, context):
    return ComponentID(rec['label'], rec['hidden'])


@saver(Component)
def _save_component(component, context):
    if hasattr(component, '_load_log'):
        log = component._load_log
        return dict(log=context.id(log),
                    log_item=log.id(component))

    return dict(data=context.do(component.data),
                units=component.units)


@loader(Component)
def _load_component(rec, context):
    if 'log' in rec:
        return context.object(rec['log']).component(rec['log_item'])

    return Component(data=context.object(rec['data']),
                     units=rec['units'])


@saver(DerivedComponent)
def _save_derived_component(component, context):
    return dict(link=context.id(component.link))


@loader(DerivedComponent)
def _load_derived_component(rec, context):
    return DerivedComponent(None, link=context.object(rec['link']))


@saver(ComponentLink)
def _save_component_link(link, context):
    frm = map(context.id, [context.id(f) for f in link.get_from_ids()])
    to = map(context.id, [link.get_to_id()])
    using = context.do(link.get_using())
    inverse = context.do(link.get_inverse())
    hidden = link.hidden
    return dict(frm=frm, to=to, using=using, inverse=inverse, hidden=hidden)


@loader(ComponentLink)
def _load_component_link(rec, context):
    frm = map(context.object, rec['frm'])
    to = map(context.object, rec['to'])[0]
    using = context.object(rec['using'])
    inverse = context.object(rec['inverse'])
    result = ComponentLink(frm, to, using, inverse)
    result.hidden = rec['hidden']
    return result


@saver(CoordinateComponentLink)
def _save_coordinate_component_link(link, context):
    frm = map(context.id, [context.id(f) for f in link._from_all])
    to = map(context.id, [link.get_to_id()])
    coords = context.id(link.coords)
    index = link.index
    pix2world = link.pixel2world
    return dict(frm=frm, to=to, coords=coords, index=index,
                pix2world=pix2world)


@loader(CoordinateComponentLink)
def _load_coordinate_component_link(rec, context):
    to = map(context.object, rec['to'])[0]  # XXX why is this a list?
    coords = context.object(rec['coords'])
    index = rec['index']
    pix2world = rec['pix2world']
    frm = map(context.object, rec['frm'])

    return CoordinateComponentLink(frm, to, coords, index, pix2world)


@saver(types.FunctionType)
def _save_function(function, context):
    ref = "%s.%s" % (function.__module__, function.__name__)
    if _lookup(ref) is function:
        l = _lookup(ref)
        return {'function': ref}
    return {'pickle': gp.dumps(function).encode('base64')}


@loader(types.FunctionType)
def _load_function(rec, context):
    if 'pickle' in rec:
        return gp.loads(rec['pickle'].decode('base64'))
    return _lookup(rec['function'])


@saver(core.Session)
def _save_session(session, context):
    # we will rely on GlueApplication to re-populate
    return {}


@loader(np.ndarray)
def _load_numpy(rec, context):
    s = StringIO(rec['data'].decode('base64'))
    return np.load(s)


@saver(np.ndarray)
def _save_numpy(obj, context):
    f = StringIO()
    np.save(f, obj)
    f.seek(0)
    data = f.read().encode('base64')
    return dict(data=data)

########NEW FILE########
__FILENAME__ = subset
import operator
import numpy as np

from .visual import VisualAttributes, RED
from .decorators import memoize
from .message import SubsetDeleteMessage, SubsetUpdateMessage
from .registry import Registry
from .util import split_component_view, view_shape

__all__ = ['Subset', 'SubsetState', 'RoiSubsetState', 'CompositeSubsetState',
           'OrState', 'AndState', 'XorState', 'InvertState',
           'ElementSubsetState', 'RangeSubsetState']

OPSYM = {operator.ge: '>=', operator.gt: '>',
         operator.le: '<=', operator.lt: '<',
         operator.and_: '&', operator.or_: '|',
         operator.xor: '^'}
SYMOP = dict((v, k) for k, v in OPSYM.items())


class Subset(object):

    """Base class to handle subsets of data.

    These objects both describe subsets of a dataset, and relay any
    state changes to the hub that their parent data are assigned to.

    This base class only directly impements the logic that relays
    state changes back to the hub. Subclasses implement the actual
    description and manipulation of data subsets

    :param data:
        The dataset that this subset describes
    :type data: :class:`~glue.core.data.Data`

    :param style: VisualAttributes instance
        Describes visual attributes of the subset
    """

    def __init__(self, data, color=RED, alpha=0.5, label=None):
        """ Create a new subset object.

        Note: the preferred way for creating subsets is
        via DataCollection.new_subset_group. Manually-instantiated
        subsets will probably *not* be represented properly by the UI
        """
        self._broadcasting = False  # must be first def
        self.data = data
        self._subset_state = None
        self._label = None
        self._setup(color, alpha, label)

    def _setup(self, color, alpha, label):
        self.color = color
        self.label = label  # trigger disambiguation
        self.style = VisualAttributes(parent=self)
        self.style.markersize *= 2.5
        self.style.color = color
        self.style.alpha = alpha
        self.subset_state = SubsetState()  # calls proper setter method

    @property
    def subset_state(self):
        return self._subset_state

    @subset_state.setter
    def subset_state(self, state):
        self._subset_state = state

    @property
    def style(self):
        return self._style

    @style.setter
    def style(self, value):
        value.parent = self
        self._style = value

    @property
    def label(self):
        """ Convenience access to subset's label """
        return self._label

    @label.setter
    def label(self, value):
        """Set the subset's label

        Subset labels within a data object must be unique. The input
        will be auto-disambiguated if necessary
        """
        value = Registry().register(self, value, group=self.data)
        self._label = value

    @property
    def attributes(self):
        """
        Returns a tuple of the ComponentIDs that this subset
        depends upon
        """
        return self.subset_state.attributes

    def register(self):
        """ Register a subset to its data, and start broadcasting
        state changes

        """
        self.data.add_subset(self)
        self.do_broadcast(True)

    def to_index_list(self):
        """
        Convert the current subset to a list of indices. These index
        the elements in the (flattened) data object that belong to the subset.

        If x is the numpy array corresponding to some component.data,
        the two following statements are equivalent::

           x.flat[subset.to_index_list()]
           x[subset.to_mask()]

        Returns:

           A numpy array, giving the indices of elements in the data that
           belong to this subset.

        Raises:

           IncompatibleDataException: if an index list cannot be created
           for the requested data set.

        """
        return self.subset_state.to_index_list(self.data)

    def to_mask(self, view=None):
        """
        Convert the current subset to a mask.

        :param view: An optional view into the dataset (e.g. a slice)
                     If present, the mask will pertain to the view and not the
                     entire dataset.

        Returns:
           A boolean numpy array, the same shape as the data, that
           defines whether each element belongs to the subset.

        """
        return self.subset_state.to_mask(self.data, view)

    def do_broadcast(self, value):
        """
        Set whether state changes to the subset are relayed to a hub.

        It can be useful to turn off broadcasting, when modifying the
        subset in ways that don't impact any of the clients.

        Attributes:
        value: Whether the subset should broadcast state changes (True/False)

        """
        object.__setattr__(self, '_broadcasting', value)

    def broadcast(self, attribute=None):
        """
        Explicitly broadcast a SubsetUpdateMessage to the hub

        :param attribute:
                   The name of the attribute (if any) that should be
                   broadcast as updated.
        :type attribute: ``str``

        """
        if not hasattr(self, 'data') or not hasattr(self.data, 'hub'):
            return

        if self._broadcasting and self.data.hub:
            msg = SubsetUpdateMessage(self, attribute=attribute)
            self.data.hub.broadcast(msg)

    def delete(self):
        """Broadcast a SubsetDeleteMessage to the hub, and stop broadcasting

        Also removes subset reference from parent data's subsets list
        """

        dobroad = self._broadcasting and self.data is not None and \
            self.data.hub is not None

        self.do_broadcast(False)

        if self.data is not None and self in self.data.subsets:
            self.data._subsets.remove(self)

        if dobroad:
            msg = SubsetDeleteMessage(self)
            self.data.hub.broadcast(msg)

        Registry().unregister(self, group=self.data)

    def write_mask(self, file_name, format="fits"):
        """ Write a subset mask out to file

        :param file_name: name of file to write to
        :param format:
           Name of format to write to. Currently, only "fits" is
           supported

        """
        mask = np.short(self.to_mask())
        if format == 'fits':
            try:
                from ..external.astro import fits
                fits.writeto(file_name, mask, clobber=True)
            except ImportError:
                raise ImportError("Cannot write mask -- requires astropy")
        else:
            raise AttributeError("format not supported: %s" % format)

    def read_mask(self, file_name):
        try:
            from ..external.astro import fits
            mask = fits.open(file_name)[0].data
        except ImportError:
            raise ImportError("Cannot write mask -- requires astropy")
        except IOError:
            raise IOError("Could not read %s (not a fits file?)" % file_name)
        ind = np.where(mask.flat)[0]
        state = ElementSubsetState(indices=ind)
        self.subset_state = state

    def __del__(self):
        self.delete()

    def __setattr__(self, attribute, value):
        object.__setattr__(self, attribute, value)
        if not attribute.startswith('_'):
            self.broadcast(attribute)

    def __getitem__(self, view):
        """ Retrieve the elements from a data view within the subset

        :param view: View of the data. See data.__getitem__ for detils
        """
        c, v = split_component_view(view)
        ma = self.to_mask(v)
        return self.data[view][ma]

    def paste(self, other_subset):
        """paste subset state from other_subset onto self """
        state = other_subset.subset_state.copy()
        self.subset_state = state

    def __str__(self):
        dlabel = "(no data)"
        if self.data is not None:
            dlabel = "(data: %s)" % self.data.label
        slabel = "Subset: (no label)"
        if self.label:
            slabel = "Subset: %s" % self.label
        return "%s %s" % (slabel, dlabel)

    def __repr__(self):
        return self.__str__()

    def __or__(self, other):
        return _combine([self, other], operator.or_)

    def __and__(self, other):
        return _combine([self, other], operator.and_)

    def __invert__(self):
        return _combine([self], operator.invert)

    def __xor__(self, other):
        return _combine([self, other], operator.xor)

    def __eq__(self, other):
        if not isinstance(other, Subset):
            return False
        # XXX need to add equality specification for subset states
        return (self.subset_state == other.subset_state and
                self.style == other.style)


class SubsetState(object):

    def __init__(self):
        pass

    @property
    def attributes(self):
        return tuple()

    @property
    def subset_state(self):  # convenience method, mimic interface of Subset
        return self

    def to_index_list(self, data):
        return np.where(self.to_mask(data).flat)[0]

    def to_mask(self, data, view=None):
        shp = view_shape(data.shape, view)
        return np.zeros(shp, dtype=bool)

    def copy(self):
        return SubsetState()

    def __or__(self, other_state):
        return OrState(self, other_state)

    def __and__(self, other_state):
        return AndState(self, other_state)

    def __invert__(self):
        return InvertState(self)

    def __xor__(self, other_state):
        return XorState(self, other_state)


class RoiSubsetState(SubsetState):

    def __init__(self, xatt=None, yatt=None, roi=None):
        super(RoiSubsetState, self).__init__()
        self.xatt = xatt
        self.yatt = yatt
        self.roi = roi

    @property
    def attributes(self):
        return (self.xatt, self.yatt)

    @memoize
    def to_mask(self, data, view=None):
        x = data[self.xatt, view]
        y = data[self.yatt, view]
        result = self.roi.contains(x, y)
        assert x.shape == result.shape
        return result

    def copy(self):
        result = RoiSubsetState()
        result.xatt = self.xatt
        result.yatt = self.yatt
        result.roi = self.roi
        return result


class RangeSubsetState(SubsetState):

    def __init__(self, lo, hi, att=None):
        super(RangeSubsetState, self).__init__()
        self.lo = lo
        self.hi = hi
        self.att = att

    @property
    def attributes(self):
        return (self.att,)

    def to_mask(self, data, view=None):
        x = data[self.att, view]
        result = (x >= self.lo) & (x <= self.hi)
        return result

    def copy(self):
        return RangeSubsetState(self.lo, self.hi, self.att)


class CompositeSubsetState(SubsetState):
    op = None

    def __init__(self, state1, state2=None):
        super(CompositeSubsetState, self).__init__()
        self.state1 = state1.copy()
        if state2:
            state2 = state2.copy()
        self.state2 = state2

    def copy(self):
        return type(self)(self.state1, self.state2)

    @property
    def attributes(self):
        att = self.state1.attributes
        if self.state2 is not None:
            att += self.state2.attributes
        return tuple(sorted(set(att)))

    @memoize
    def to_mask(self, data, view=None):
        return self.op(self.state1.to_mask(data, view),
                       self.state2.to_mask(data, view))

    def __str__(self):
        sym = OPSYM.get(self.op, self.op)
        return "(%s %s %s)" % (self.state1, sym, self.state2)


class OrState(CompositeSubsetState):
    op = operator.or_


class AndState(CompositeSubsetState):
    op = operator.and_


class XorState(CompositeSubsetState):
    op = operator.xor


class InvertState(CompositeSubsetState):

    @memoize
    def to_mask(self, data, view=None):
        return ~self.state1.to_mask(data, view)

    def __str__(self):
        return "(~%s)" % self.state1


class ElementSubsetState(SubsetState):

    def __init__(self, indices=None):
        super(ElementSubsetState, self).__init__()
        self._indices = indices

    @memoize
    def to_mask(self, data, view=None):
        # XXX this is inefficient for views
        result = np.zeros(data.shape, dtype=bool)
        if self._indices is not None:
            result.flat[self._indices] = True
        if view is not None:
            result = result[view]
        return result

    def copy(self):
        return ElementSubsetState(self._indices)


class InequalitySubsetState(SubsetState):

    def __init__(self, left, right, op):
        from .component_link import ComponentLink

        super(InequalitySubsetState, self).__init__()
        from .data import ComponentID
        valid_ops = [operator.gt, operator.ge,
                     operator.lt, operator.le]
        if op not in valid_ops:
            raise TypeError("Invalid boolean operator: %s" % op)
        if not isinstance(left, ComponentID) and not \
                operator.isNumberType(left) and not \
                isinstance(left, ComponentLink):
            raise TypeError("Input must be ComponenID or NumberType: %s"
                            % type(left))
        if not isinstance(right, ComponentID) and not \
                operator.isNumberType(right) and not \
                isinstance(right, ComponentLink):
            raise TypeError("Input must be ComponenID or NumberType: %s"
                            % type(right))
        self._left = left
        self._right = right
        self._operator = op

    @property
    def left(self):
        return self._left

    @property
    def right(self):
        return self._right

    @property
    def operator(self):
        return self._operator

    @memoize
    def to_mask(self, data, view=None):
        from .data import ComponentID
        left = self._left
        if not operator.isNumberType(self._left):
            left = data[self._left, view]

        right = self._right
        if not operator.isNumberType(self._right):
            right = data[self._right, view]

        return self._operator(left, right)

    def copy(self):
        return InequalitySubsetState(self._left, self._right, self._operator)

    def __str__(self):
        sym = OPSYM.get(self._operator, self._operator)
        return "(%s %s %s)" % (self._left, sym, self._right)

    def __repr__(self):
        return '<%s: %s>' % (self.__class__.__name__, self)


def _combine(subsets, operator):
    state = operator(*[s.subset_state for s in subsets])
    result = Subset(None)
    result.subset_state = state
    return result

########NEW FILE########
__FILENAME__ = subset_group
"""
A :class:`~glue.core.subset_group.SubsetGroup` unites a group of
:class:`~glue.core.subset.Subset` instances together with a consistent state,
label, and style.

While subsets are internally associated with particular datasets, it's
confusing for the user to juggle multiple similar or identical
subsets, applied to different datasets. Because of this, the GUI
manages SubsetGroups, and presents each group to the user as a single
entity. The individual subsets are held in-sync by the SubsetGroup.

Client code should *only* create Subset Groups via
DataCollection.new_subset_group. It should *not* call Data.add_subset
or Data.new_subset directly
"""
from warnings import warn

from . import Subset
from .subset import SubsetState
from .util import Pointer
from .hub import HubListener
from .visual import VisualAttributes, RED
from .message import (DataCollectionAddMessage,
                      DataCollectionDeleteMessage
                      )

__all__ = ['GroupedSubset', 'SubsetGroup']


class GroupedSubset(Subset):

    """
    A member of a SubsetGroup, whose internal representation
    is shared with other group members
    """
    subset_state = Pointer('group.subset_state')
    label = Pointer('group.label')

    def __init__(self, data, group):
        """
        :param data: :class:`~glue.core.data.Data` instance to bind to
        :param group: :class:`~glue.core.subset_group.SubsetGroup`
        """
        self.group = group
        super(GroupedSubset, self).__init__(data, label=group.label,
                                            color=group.style.color,
                                            alpha=group.style.alpha)

    def _setup(self, color, alpha, label):
        self.color = color
        self.label = label  # trigger disambiguation
        self.style = VisualAttributes(parent=self)
        self.style.markersize *= 2.5
        self.style.color = color
        self.style.alpha = alpha
        # skip state setting here

    @property
    def verbose_label(self):
        return "%s (%s)" % (self.label, self.data.label)

    def sync_style(self, other):
        self.style.set(other)

    def __eq__(self, other):
        return other is self

    def __gluestate__(self, context):
        return dict(group=context.id(self.group),
                    style=context.do(self.style))

    @classmethod
    def __setgluestate__(cls, rec, context):
        dummy_grp = SubsetGroup()  # __init__ needs group.label
        self = cls(None, dummy_grp)
        yield self
        self.group = context.object(rec['group'])
        self.style = context.object(rec['style'])


class SubsetGroup(HubListener):

    def __init__(self, color=RED, alpha=0.5, label=None, subset_state=None):
        """
        Create a new empty SubsetGroup

        Note: By convention, SubsetGroups should be created via
        DataCollection.new_subset.
        """
        self.subsets = []
        if subset_state is None:
            subset_state = SubsetState()
        else:
            print 'using', subset_state
        self.subset_state = subset_state
        self.label = label
        self._style = None

        self.style = VisualAttributes(parent=self)
        self.style.markersize *= 2.5
        self.style.color = color
        self.style.alpha = alpha

    def register(self, data):
        """
        Register to a :class:`~glue.core.data_collection.DataCollection`

        This is called automatically by
        :meth:`glue.core.data_collection.DataCollection.new_subset_group`
        """
        self.register_to_hub(data.hub)

        # add to self, then register, so fully populated by first
        # broadcast

        for d in data:
            s = GroupedSubset(d, self)
            self.subsets.append(s)

        for d, s in zip(data, self.subsets):
            d.add_subset(s)

    def paste(self, other_subset):
        """paste subset state from other_subset onto self """
        state = other_subset.subset_state.copy()
        self.subset_state = state

    def _add_data(self, data):
        s = GroupedSubset(data, self)
        data.add_subset(s)
        self.subsets.append(s)

    def _remove_data(self, data):
        for s in list(self.subsets):
            if s.data is data:
                self.subsets.remove(s)

    def register_to_hub(self, hub):
        hub.subscribe(self, DataCollectionAddMessage,
                      lambda x: self._add_data(x.data))
        hub.subscribe(self, DataCollectionDeleteMessage,
                      lambda x: self._remove_data(x.data))

    @property
    def style(self):
        return self._style

    @style.setter
    def style(self, value):
        self._style = value
        self._sync_style()

    def _sync_style(self):
        for s in self.subsets:
            s.sync_style(self.style)

    def broadcast(self, item):
        # used by __setattr__ and VisualAttributes.__setattr__
        if isinstance(item, VisualAttributes):
            self._sync_style()
            return

        for s in self.subsets:
            s.broadcast(item)

    def __setattr__(self, attr, value):
        object.__setattr__(self, attr, value)
        if attr in ['subset_state', 'label', 'style']:
            self.broadcast(attr)

    def __gluestate__(self, context):
        return dict(label=self.label,
                    state=context.id(self.subset_state),
                    style=context.do(self.style),
                    subsets=map(context.id, self.subsets))

    @classmethod
    def __setgluestate__(cls, rec, context):
        result = cls()
        yield result
        result.subset_state = context.object(rec['state'])
        result.label = rec['label']
        result.style = context.object(rec['style'])
        result.subsets = map(context.object, rec['subsets'])

    def __and__(self, other):
        return self.subset_state & other.subset_state

    def __or__(self, other):
        return self.subset_state | other.subset_state

    def __xor__(self, other):
        return self.subset_state ^ other.subset_state

    def __invert__(self):
        return ~self.subset_state


def coerce_subset_groups(collect):
    """
    If necessary, reassign non-grouped subsets in a DataCollection
    into SubsetGroups.

    This is used to support DataCollections saved with
    version 1 of glue.core.state.save_data_collection
    """
    for data in collect:
        for subset in data.subsets:
            if not isinstance(subset, GroupedSubset):
                warn("DataCollection has subsets outside of "
                     "subset groups, which are no longer supported. "
                     "Moving to subset groups")
                subset.delete()
                grp = collect.new_subset_group()
                grp.subset_state = subset.subset_state
                grp.style = subset.style
                grp.label = subset.label

########NEW FILE########
__FILENAME__ = test_aggregate
import numpy as np
from numpy.testing import assert_allclose

import pytest

from ..aggregate import Aggregate
from .. import Data


class TestFunctions(object):

    def setup_method(self, method):
        self.d = Data(a=np.random.random((3, 3, 3)) - 0.5)
        self.agg = Aggregate(self.d, 'a', 0, (0, 'y', 'x'), (0, 3))

    def test_max(self):
        actual = self.agg.max()
        expected = self.d['a'].max(axis=0)
        np.testing.assert_array_equal(expected, actual)

    def test_mean(self):
        actual = self.agg.mean()
        expected = self.d['a'].mean(axis=0)
        np.testing.assert_array_equal(expected, actual)

    def test_median(self):
        actual = self.agg.median()
        expected = np.median(self.d['a'], axis=0)
        np.testing.assert_array_equal(expected, actual)

    def test_argmax(self):
        actual = self.agg.argmax()
        expected = np.nanargmax(self.d['a'], axis=0)
        np.testing.assert_array_equal(expected, actual)

    def test_argmin(self):
        actual = self.agg.argmin()
        expected = np.nanargmin(self.d['a'], axis=0)
        np.testing.assert_array_equal(expected, actual)

    def test_mom1(self):
        actual = self.agg.mom1()
        a = np.maximum(self.d['a'], 0)
        z = self.d[self.d.get_world_component_id(0)]
        expected = (a * z).sum(axis=0) / a.sum(axis=0)
        np.testing.assert_array_equal(expected, actual)

    def test_mom2(self):
        # this is a different implementation, as a sanity check
        actual = self.agg.mom2()

        # negative values clipped at 0 for weight calculation
        a = np.maximum(self.d['a'], 0)
        z = self.d[self.d.get_world_component_id(0)]
        a = a / a.sum(axis=0)
        mom1 = self.agg.mom1()

        expected = np.sqrt((a * (z - mom1) ** 2).sum(axis=0))
        actual = self.agg.mom2()

        np.testing.assert_array_almost_equal(expected, actual)


class TestSliceDescriptions(object):

    """Look at various slice orientations and limits"""

    def test_cube(self):
        d = Data(a=np.random.random((3, 3, 3)))

        actual = Aggregate(d, 'a', 0, (0, 'y', 'x'), (0, 3)).sum()
        expected = d['a'].sum(axis=0)

        np.testing.assert_array_equal(expected, actual)

    def test_cube_transpose(self):
        d = Data(a=np.random.random((3, 3, 3)))

        actual = Aggregate(d, 'a', 0, (0, 'x', 'y'), (0, 3)).sum()
        expected = d['a'].sum(axis=0).T

        np.testing.assert_array_equal(expected, actual)

    def test_cube_axis1(self):
        d = Data(a=np.random.random((3, 3, 3)))
        actual = Aggregate(d, 'a', 1, ('x', 0, 'y'), (0, 3)).sum()
        expected = d['a'].sum(axis=1).T

        np.testing.assert_array_equal(expected, actual)

    def test_cube_zlim(self):
        d = Data(a=np.random.random((3, 3, 3)))
        actual = Aggregate(d, 'a', 0, (0, 'x', 'y'), (0, 2)).sum()
        expected = d['a'][0:2].sum(axis=0).T

        np.testing.assert_array_equal(expected, actual)

    def test_4cube(self):
        d = Data(a=np.random.random((3, 3, 3, 3)))
        actual = Aggregate(d, 'a', 2, ('x', 2, 0, 'y'), (0, 3)).sum()
        expected = d['a'][:, 2, :, :].sum(axis=1).T

        np.testing.assert_array_equal(expected, actual)

    @pytest.mark.parametrize('func', Aggregate.all_operators())
    def test_empty_slices(self, func):
        d = Data(a=np.random.random((3, 4, 5)))
        a = Aggregate(d, 'a', 0, (0, 'y', 'x'), (0, 0))
        actual = func(a)
        expected = np.zeros((4, 5)) * np.nan
        np.testing.assert_array_equal(expected, actual)


@pytest.mark.parametrize('func', Aggregate.all_operators())
def test_transpose(func):
    d = Data(a=np.random.random((3, 3, 3)))
    a1 = Aggregate(d, 'a', 0, (0, 'x', 'y'), (0, 3))
    a2 = Aggregate(d, 'a', 0, (0, 'y', 'x'), (0, 3))
    np.testing.assert_array_equal(func(a1).T, func(a2))


@pytest.mark.parametrize('func',
                         (Aggregate.sum, Aggregate.mom1, Aggregate.mom2))
def test_nans_like_zeros(func):
    a = np.random.random((3, 3, 3))
    a[0] = np.nan
    d = Data(a=a)
    d2 = Data(a=np.nan_to_num(a))

    a1 = Aggregate(d, 'a', 0, (0, 'x', 'y'), (0, 3))
    a2 = Aggregate(d2, 'a', 0, (0, 'x', 'y'), (0, 3))
    np.testing.assert_array_equal(func(a1), func(a2))


def test_reverse_limits():
    a = np.random.random((3, 3, 3))
    d = Data(a=a)

    a = Aggregate(d, 'a', 0, (0, 'y', 'x'), (3, 0))
    b = Aggregate(d, 'a', 0, (0, 'y', 'x'), (0, 3))
    assert_allclose(a.sum(), b.sum())

########NEW FILE########
__FILENAME__ = test_application_base
import tempfile
import os

import numpy as np
from mock import MagicMock

from ..application_base import Application
from .. import Data


class MockApplication(Application):

    def __init__(self, data=None, hub=None):
        super(MockApplication, self).__init__(data, hub)
        self.tab = MagicMock()
        self.errors = MagicMock()

    def report_error(self, message, detail):
        self.errors.report(message, detail)

    def new_tab(self):
        self.tab.tab()

    def add_widget(self, widget, label=None, tab=None):
        self.tab.add(widget, label)

    def close_tab(self):
        self.tab.close()

    def _load_settings(self):
        pass


class TestApplicationBase(object):
    def setup_method(self, method):
        self.app = MockApplication()

########NEW FILE########
__FILENAME__ = test_client
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103,W0612
from mock import MagicMock

import pytest
from ..client import Client, BasicClient
from ..data import Data
from ..data_collection import DataCollection
from ..hub import Hub
from ..subset import Subset


class MockClient(Client):  # pylint: disable=W0223

    def __init__(self, *args, **kwargs):
        super(MockClient, self).__init__(*args, **kwargs)
        self.present = set()

    def _do_add_layer(self, layer):
        self.present.add(layer)

    def _do_remove_layer(self, layer):
        self.present.remove(layer)

    def _do_update_layer(self, layer):
        pass

    def layer_present(self, layer):
        return layer in self.present


class BasicClientStub(BasicClient):

    def __init__(self, *args, **kwargs):
        super(BasicClientStub, self).__init__(*args, **kwargs)
        self.added = set()

    def _do_add_subset(self, subset):
        self.do_add_layer(subset)

    def _do_add_data(self, data):
        self.do_add_layer(data)

    def do_add_layer(self, layer):
        if layer in self.added:
            raise Exception("Un-caught double add")
        self.added.add(layer)

    def layer_present(self, layer):
        return layer in self.added

    def do_remove_layer(self, layer):
        if layer not in self.added:
            raise Exception("Removing non-present layer")
        self.added.remove(layer)

    def do_update_layer(self, layer):
        if layer not in self.added:
            raise Exception("Updating an absent layer")

    def _do_update_subset(self, subset):
        self.do_update_layer(subset)

    def _do_update_data(self, data):
        self.do_update_layer(data)

    def _do_remove_subset(self, subset):
        self.do_remove_layer(subset)

    def _do_remove_data(self, data):
        self.do_remove_layer(data)


class TestClient(object):

    def _data(self):
        return MagicMock(spec_set=DataCollection)

    def _hub(self):
        return MagicMock(spec_set=Hub)

    def _client(self, data):
        return MockClient(data)

    def test_data_property(self):
        data = self._data()
        c = self._client(data)
        assert c.data is data

    def test_invalid_init(self):
        with pytest.raises(TypeError) as exc:
            Client(None)
        assert exc.value.args[0].startswith("Input data must be a "
                                            "DataCollection:")

    def test_register(self):
        hub = self._hub()
        data = self._data()
        client = self._client(data)
        client.register_to_hub(hub)
        assert hub.subscribe.called


class TestBasicClient(object):

    def _create_objects(self):
        collection = DataCollection()
        data = Data()
        subset = data.new_subset()
        collection.append(data)
        client = BasicClientStub(collection)
        return client, collection, data, subset

    def _add_subset(self):
        client, collection, data, subset = self._create_objects()
        client.add_layer(subset)
        return client, collection, data, subset

    def _add_data(self):
        client, collection, data, subset = self._create_objects()
        client.add_layer(data)
        return client, collection, data, subset

    def test_add_subset(self):
        client, collection, data, subset = self._add_subset()
        assert client.layer_present(subset)

    def test_data_added_with_subset(self):
        client, collection, data, subset = self._add_subset()
        assert client.layer_present(data)

    def test_add_data(self):
        client, collection, data, subset = self._add_data()
        assert client.layer_present(data)

    def test_subsets_added_with_data(self):
        client, collection, data, subset = self._add_data()
        for subset in data.subsets:
            assert client.layer_present(subset)

    def test_remove_subset(self):
        client, collection, data, subset = self._add_data()
        client.remove_layer(subset)
        assert not client.layer_present(subset)

    def test_data_not_removed_with_subset(self):
        client, collection, data, subset = self._add_data()
        client.remove_layer(subset)
        assert client.layer_present(data)

    def test_remove_data(self):
        client, collection, data, subset = self._add_data()
        client.remove_layer(data)
        assert not client.layer_present(data)

    def test_subsets_removed_with_data(self):
        client, collection, data, subset = self._add_data()
        client.remove_layer(data)
        assert not client.layer_present(data)
        for subset in data.subsets:
            assert not client.layer_present(subset)

    def test_add_subset_raises_if_not_in_collection(self):
        client, collection, data, subset = self._add_data()
        d = Data()
        s = Subset(d)
        with pytest.raises(TypeError) as exc:
            client.add_layer(s)
        assert exc.value.args[0] == "Data not in collection"

    def test_add_data_raises_if_not_in_collection(self):
        client, collection, data, subset = self._add_data()
        d = Data()
        d.new_subset()
        with pytest.raises(TypeError) as exc:
            client.add_layer(d)
        assert exc.value.args[0] == "Data not in collection"

    def test_double_add_ignored(self):
        client, collection, data, subset = self._add_subset()
        client.add_layer(subset)
        client.add_layer(data)

    def test_remove_ignored_if_not_present(self):
        client, collection, data, subset = self._add_subset()
        client.remove_layer(subset)
        client.remove_layer(subset)

    def test_update_subset_ignored_if_not_present(self):
        client, collection, data, subset = self._add_subset()
        d = Data()
        s = d.new_subset()
        client.update_layer(s)

    def test_update_data_ignored_if_not_present(self):
        client, collection, data, subset = self._add_subset()
        d = Data()
        d.new_subset()
        client.update_layer(d)

    def test_subset_messages(self):
        client, collection, data, subset = self._create_objects()
        m = MagicMock()
        m.subset = subset

        client._add_subset(m)
        assert client.layer_present(subset)
        client._update_subset(m)
        client._remove_subset(m)
        assert not client.layer_present(subset)

    def test_data_messages(self):
        client, collection, data, subset = self._create_objects()
        m = MagicMock()
        m.data = data
        client.add_layer(data)
        client._update_data(m)
        client._remove_data(m)
        assert not client.layer_present(data)

########NEW FILE########
__FILENAME__ = test_command
from mock import MagicMock
import pytest
import numpy as np

from ... import core
from .. import roi
from .. import command as c
from ..data_factories import tabular_data
from .util import simple_session, simple_catalog


class TestCommandStack(object):

    def setup_method(self, method):
        self.session = simple_session()
        self.stack = self.session.command_stack

    def make_command(self):
        return MagicMock(c.Command)

    def make_data(self):
        with simple_catalog() as path:
            cmd = c.LoadData(path=path, factory=tabular_data)
            data = self.stack.do(cmd)
        return data

    def test_do(self):

        c1 = self.make_command()
        self.stack.do(c1)

        c1.do.assert_called_once_with(self.session)

    def test_undo(self):
        c1, c2 = self.make_command(), self.make_command()

        self.stack.do(c1)
        self.stack.do(c2)

        self.stack.undo()
        c2.undo.assert_called_once_with(self.session)

        self.stack.undo()
        c1.undo.assert_called_once_with(self.session)

    def test_redo(self):
        c1, c2 = self.make_command(), self.make_command()

        self.stack.do(c1)
        self.stack.do(c2)

        self.stack.undo()
        self.stack.redo()

        c2.undo.assert_called_once_with(self.session)

        assert c2.do.call_count == 2
        assert c2.undo.call_count == 1
        assert c1.do.call_count == 1
        assert c1.undo.call_count == 0

    def test_max_undo(self):
        cmds = [self.make_command() for _ in xrange(c.MAX_UNDO + 1)]

        for cmd in cmds:
            self.stack.do(cmd)

        for cmd in cmds[:-1]:
            self.stack.undo()

        with pytest.raises(IndexError):
            self.stack.undo()

    def test_invalid_redo(self):
        with pytest.raises(IndexError) as exc:
            self.stack.redo()
        assert exc.value.args[0] == 'No commands to redo'

    def test_load_data(self):
        data = self.make_data()
        np.testing.assert_array_equal(data['a'], [1, 3])

    def test_add_data(self):
        data = self.make_data()
        cmd = c.AddData(data=data)

        self.stack.do(cmd)
        assert len(self.session.data_collection) == 1

        self.stack.undo()
        assert len(self.session.data_collection) == 0

    def test_remove_data(self):
        data = self.make_data()

        add = c.AddData(data=data)
        remove = c.RemoveData(data=data)

        self.stack.do(add)
        assert len(self.session.data_collection) == 1

        self.stack.do(remove)
        assert len(self.session.data_collection) == 0

        self.stack.undo()
        assert len(self.session.data_collection) == 1

    def test_new_data_viewer(self):
        cmd = c.NewDataViewer(viewer=None, data=None)
        v = self.stack.do(cmd)

        self.session.application.new_data_viewer.assert_called_once_with(
            None, None)

        self.stack.undo()
        v.close.assert_called_once_with(warn=False)

    def test_apply_roi(self):
        x = core.Data(x=[1, 2, 3])
        s = x.new_subset()
        dc = self.session.data_collection
        dc.append(x)

        r = MagicMock(roi.Roi)
        client = MagicMock(core.client.Client)
        client.data = dc

        cmd = c.ApplyROI(client=client, roi=r)

        self.stack.do(cmd)
        client.apply_roi.assert_called_once_with(r)

        old_state = s.subset_state
        s.subset_state = MagicMock()

        self.stack.undo()
        assert s.subset_state is old_state

########NEW FILE########
__FILENAME__ = test_communication
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest

from ..hub import Hub
from ..client import Client
from ..data import Data
from ..subset import Subset
from ..data_collection import DataCollection
from ..message import (SubsetCreateMessage, SubsetDeleteMessage,
                       SubsetUpdateMessage, Message, DataUpdateMessage)

"""
Client communication protocol

subsets added to data on creation
subsets subscribe to hub when data does

data are not added to clients automatically
subsets added to client only if data is in client

All create, update, delete events should emit signals
Processed (or ignored!) by clients
"""


class TestClient(Client):

    def __init__(self, data):
        Client.__init__(self, data)
        self.last_message = None
        self.call = None

    def _add_subset(self, message):
        self.last_message = message
        self.call = self._add_subset

    def _remove_subset(self, message):
        self.last_message = message
        self.call = self._remove_subset

    def _update_subset(self, message):
        self.last_message = message
        self.call = self._update_subset

    def _update_data(self, message):
        self.last_message = message
        self.call = self._update_data


class TestCommunication(object):

    def setup_method(self, method):
        self.hub = Hub()
        self.d1 = Data()
        self.d2 = Data()
        self.d3 = Data()
        dc = DataCollection([self.d1])
        self.c1 = TestClient(dc)
        self.c2 = TestClient(DataCollection([self.d2]))
        self.c3 = TestClient(dc)
        self.s1 = Subset(self.d1)
        self.s2 = Subset(self.d2)
        self.m1 = SubsetCreateMessage(self.s1)
        self.m2 = SubsetDeleteMessage(self.s1)
        self.m3 = SubsetUpdateMessage(self.s1)
        self.m4 = DataUpdateMessage(self.d1, 'dummy_attribute')

    def test_basic_register(self):
        #create and register a client. Make sure it's
        #added to subscription table

        h = Hub()
        d = Data()
        c = TestClient(DataCollection([d]))
        assert not c in h._subscriptions
        c.register_to_hub(h)
        assert c in h._subscriptions

    def test_basic_broadcast(self):
        #broadcast a subsetCreateMessage.
        #make sure the registered client catches it.
        #make sure an unregistered one doesn't

        self.c1.register_to_hub(self.hub)
        self.hub.broadcast(self.m1)

        assert self.c1.last_message is self.m1
        assert self.c1.call == self.c1._add_subset
        assert self.c2.last_message is None

    def test_proper_handlers(self):
        #broadcast the 4 basic methods. make sure the proper handlers
        #catch them
        self.c1.register_to_hub(self.hub)
        assert self.c1.call is None

        self.hub.broadcast(self.m1)
        assert self.c1.call == self.c1._add_subset

        self.hub.broadcast(self.m2)
        assert self.c1.call == self.c1._remove_subset

        self.hub.broadcast(self.m3)
        assert self.c1.call == self.c1._update_subset

        self.hub.broadcast(self.m4)
        assert self.c1.call == self.c1._update_data

    def test_ignore_message(self):
        #send a message that should be ignored
        class IgnoredMessage(Message):
            pass
        self.c1.register_to_hub(self.hub)
        self.hub.broadcast(IgnoredMessage(None))
        assert self.c1.last_message is None
        assert self.c1.call is None

    @pytest.mark.skip("Relaxed requirement. Hub now ignores exceptions")
    def test_uncaught_message(self):
        #broadcast a message without a message handler
        self.hub.subscribe(self.c1, Message)
        with pytest.raises(NotImplementedError) as exc:
            self.hub.broadcast(Message(None))
        assert exc.value.args[0].startswith("Message has no handler:")

    def test_multi_client(self):
        #register 2 clients with same data to hub
        #make sure events get to both

        self.c1.register_to_hub(self.hub)
        self.c3.register_to_hub(self.hub)
        self.hub.broadcast(self.m1)
        assert self.c1.last_message is self.m1
        assert self.c3.last_message is self.m1

    def test_standard_filter(self):
        #register 2 clients with 2 different data sets
        #make sure events are filtered properly
        self.c1.register_to_hub(self.hub)
        self.c2.register_to_hub(self.hub)

        msg = DataUpdateMessage(self.d2, 'test_attribute')
        self.hub.broadcast(msg)

        assert self.c1.last_message is None
        assert self.c2.last_message is msg

    def test_unsubscribe(self):
        # subscribe and unsubscribe an object.
        # make sure message passing stays correct

        self.c1.register_to_hub(self.hub)
        self.hub.broadcast(self.m1)
        assert self.c1.last_message is self.m1

        self.hub.unsubscribe(self.c1, type(self.m2))
        self.hub.broadcast(self.m2)
        assert self.c1.last_message is self.m1

    def test_remove_client(self):

        self.c1.register_to_hub(self.hub)
        self.hub.broadcast(self.m1)
        assert self.c1.last_message is self.m1

        self.hub.unsubscribe_all(self.c1)
        self.hub.broadcast(self.m2)
        assert self.c1.last_message is self.m1

    def test_subset_relay(self):
        #make sure subset modification
        #sends messages
        d = Data()
        dc = DataCollection(d)
        c = TestClient(dc)

        c.register_to_hub(dc.hub)
        sub = d.new_subset()
        assert c.last_message.sender is sub
        assert c.call == c._add_subset

        sub.modified = "modify"
        assert c.call == c._update_subset
        assert c.last_message.attribute == 'modified'

########NEW FILE########
__FILENAME__ = test_component
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import operator

from mock import MagicMock
import pytest
import numpy as np

from ..data import (Component, ComponentID, Data,
                    DerivedComponent, CoordinateComponent,
                    CategoricalComponent)
from ... import core


VIEWS = (np.s_[:], np.s_[1], np.s_[::-1], np.s_[0, :])


class TestComponent(object):

    def setup_method(self, method):
        self.data = MagicMock()
        self.data.shape = [1, 2]
        self.component = Component(self.data)

    def test_data(self):
        assert self.component.data is self.data

    def test_shape(self):
        assert self.component.shape is self.data.shape

    def test_ndim(self):
        assert self.component.ndim is len(self.data.shape)


class TestComponentID(object):

    def setup_method(self, method):
        self.cid = ComponentID('test')

    def test_label(self):
        assert self.cid.label == 'test'

    def test_str(self):
        """ str should return """
        str(self.cid)

    def test_repr(self):
        """ str should return """
        repr(self.cid)


class TestDerivedComponent(object):

    def setup_method(self, method):
        data = MagicMock()
        link = MagicMock()
        self.cid = DerivedComponent(data, link)
        self.link = link
        self.data = data

    def test_data(self):
        """ data property should wrap to links compute method """
        self.cid.data
        self.link.compute.assert_called_once_with(self.data)

    def test_link(self):
        assert self.cid.link == self.link


class TestCategoricalComponent(object):

    def setup_method(self, method):
        self.list_data = ['a', 'a', 'b', 'b']
        self.array_data = np.array(self.list_data)

    def test_autodetection(self):
        assert isinstance(Component.autotyped(self.array_data),
                          CategoricalComponent)
        assert isinstance(Component.autotyped(self.list_data),
                          CategoricalComponent)

        x = np.array([True, False, True, False])
        assert not isinstance(Component.autotyped(x), CategoricalComponent)

        x = np.array([1, 2, 3, 4])
        assert not isinstance(Component.autotyped(x), CategoricalComponent)

        x = np.array(['1', '2', '3', '4'])
        assert not isinstance(Component.autotyped(x), CategoricalComponent)

        d = Data(x=['a', 'b', 'c'])
        assert isinstance(d.get_component('x'), CategoricalComponent)

    def test_accepts_numpy(self):
        cat_comp = CategoricalComponent(self.array_data)
        assert cat_comp._categorical_data.shape == (4,)

    def test_accepts_list(self):
        """Should accept a list and convert to numpy!"""
        cat_comp = CategoricalComponent(self.list_data)
        np.testing.assert_equal(cat_comp._categorical_data, self.array_data)

    def test_multi_nans(self):
        cat_comp = CategoricalComponent([np.nan, np.nan, 'a', 'b', 'c', 'zanthia'])
        np.testing.assert_equal(cat_comp._data,
                                np.array([0, 0, 1, 2, 3, 4]))
        np.testing.assert_equal(cat_comp._categories,
                                np.asarray([np.nan, 'a', 'b', 'c', 'zanthia'],
                                           dtype=np.object))

    def test_calculate_grouping(self):
        cat_comp = CategoricalComponent(self.array_data)
        np.testing.assert_equal(cat_comp._categories, np.asarray(['a', 'b']))
        np.testing.assert_equal(cat_comp._data, np.array([0, 0, 1, 1]))
        assert cat_comp._data.dtype == np.float

    def test_accepts_provided_grouping(self):
        ncategories = ['b', 'c']
        cat_data = list('aaabbbcccddd')
        cat_comp = CategoricalComponent(cat_data, categories=ncategories)

        assert cat_comp._categories == ncategories
        assert np.all(np.isnan(cat_comp._data[:3]))
        assert np.all(cat_comp._data[3:6] == 0)
        assert np.all(cat_comp._data[6:9] == 1)
        assert np.all(np.isnan(cat_comp._data[9:]))

    def test_uniform_jitter(self):
        cat_comp = CategoricalComponent(self.array_data)
        second_comp = CategoricalComponent(self.array_data)
        cat_comp.jitter(method='uniform')
        assert np.all(cat_comp._data != second_comp._data), "Didn't jitter data!"
        second_comp.jitter(method='uniform')
        np.testing.assert_equal(cat_comp._data,
                                second_comp._data,
                                "Didn't jitter data consistently!")
        assert cat_comp._jitter_method == 'uniform'

    def test_no_double_jitter(self):
        cat_comp = CategoricalComponent(self.array_data)
        second_comp = CategoricalComponent(self.array_data)
        cat_comp.jitter(method='uniform')
        delta = np.abs(cat_comp._data - second_comp._data).sum()
        assert delta > 0
        second_comp.jitter(method='uniform')
        second_comp.jitter(method='uniform')
        np.testing.assert_equal(cat_comp._data,
                                second_comp._data,
                                "Data double jittered!")

    def test_unjitter_data(self):
        cat_comp = CategoricalComponent(self.array_data)
        second_comp = CategoricalComponent(self.array_data)

        cat_comp.jitter(method='uniform')
        delta = np.abs(cat_comp._data - second_comp._data).sum()
        assert delta > 0

        cat_comp.jitter(method=None)
        np.testing.assert_equal(cat_comp._data,
                                second_comp._data,
                                "Didn't un-jitter data!")

    def test_jitter_on_init(self):
        cat_comp = CategoricalComponent(self.array_data, jitter='uniform')
        second_comp = CategoricalComponent(self.array_data)
        second_comp.jitter(method='uniform')
        delta = np.abs(cat_comp._data - second_comp._data).sum()
        assert delta == 0

    def test_valueerror_on_bad_jitter(self):

        with pytest.raises(ValueError):
            cat_comp = CategoricalComponent(self.array_data)
            cat_comp.jitter(method='this will never be a jitter method')


class TestCoordinateComponent(object):

    def setup_method(self, method):
        class TestCoords(object):

            def pixel2world(self, *args):
                return [a * (i + 1) for i, a in enumerate(args)]

        data = core.Data()
        data.add_component(Component(np.zeros((3, 3, 3))), 'test')
        data.coords = TestCoords()
        self.data = data
        self.px = CoordinateComponent(data, 2)
        self.py = CoordinateComponent(data, 1)
        self.pz = CoordinateComponent(data, 0)
        self.wx = CoordinateComponent(data, 2, world=True)
        self.wy = CoordinateComponent(data, 1, world=True)
        self.wz = CoordinateComponent(data, 0, world=True)

    def test_data(self):
        z, y, x = np.mgrid[0:3, 0:3, 0:3]
        np.testing.assert_array_equal(self.px.data, x)
        np.testing.assert_array_equal(self.py.data, y)
        np.testing.assert_array_equal(self.pz.data, z)
        np.testing.assert_array_equal(self.wx.data, x * 1)
        np.testing.assert_array_equal(self.wy.data, y * 2)
        np.testing.assert_array_equal(self.wz.data, z * 3)

    @pytest.mark.parametrize(('view'), VIEWS)
    def test_view(self, view):
        z, y, x = np.mgrid[0:3, 0:3, 0:3]

        np.testing.assert_array_equal(self.px[view], x[view])
        np.testing.assert_array_equal(self.py[view], y[view])
        np.testing.assert_array_equal(self.pz[view], z[view])
        np.testing.assert_array_equal(self.wx[view], x[view] * 1)
        np.testing.assert_array_equal(self.wy[view], y[view] * 2)
        np.testing.assert_array_equal(self.wz[view], z[view] * 3)


def check_binary(result, left, right, op):
    assert isinstance(result, core.subset.InequalitySubsetState)
    assert result.left is left
    assert result.right is right
    assert result.operator is op


def check_link(result, left, right):
    assert isinstance(result, core.component_link.ComponentLink)
    if isinstance(left, ComponentID):
        assert left in result.get_from_ids()
    if isinstance(right, ComponentID):
        assert right in result.get_from_ids()

# componentID overload
COMPARE_OPS = (operator.gt, operator.ge, operator.lt, operator.le)
NUMBER_OPS = (operator.add, operator.mul, operator.div, operator.sub)


@pytest.mark.parametrize(('op'), COMPARE_OPS)
def test_inequality_scalar(op):
    cid = ComponentID('test')
    result = op(cid, 3)
    check_binary(result, cid, 3, op)


@pytest.mark.parametrize(('op'), COMPARE_OPS)
def test_inequality_id(op):
    cid = ComponentID('test')
    cid2 = ComponentID('test2')
    result = op(cid, cid2)
    check_binary(result, cid, cid2, op)


@pytest.mark.parametrize(('op'), NUMBER_OPS)
def test_arithmetic_scalar(op):
    cid = ComponentID('test')
    result = op(cid, 3)
    check_link(result, cid, 3)


@pytest.mark.parametrize(('op'), NUMBER_OPS)
def test_arithmetic_scalar_right(op):
    cid = ComponentID('test')
    result = op(3, cid)
    check_link(result, 3, cid)


@pytest.mark.parametrize(('op'), NUMBER_OPS)
def test_arithmetic_cid(op):
    cid = ComponentID('test')
    cid2 = ComponentID('test2')
    result = op(cid, cid2)
    check_link(result, cid, cid2)


def test_pow_scalar():
    cid = ComponentID('test')
    result = cid ** 3
    check_link(result, cid, 3)


@pytest.mark.parametrize(('view'), VIEWS)
def test_view(view):
    comp = Component(np.array([[1, 2, 3], [2, 3, 4]]))
    np.testing.assert_array_equal(comp[view], comp.data[view])


@pytest.mark.parametrize(('view'), VIEWS)
def test_view_derived(view):
    comp = Component(np.array([[1, 2, 3], [2, 3, 4]]))
    d = core.Data()
    cid = d.add_component(comp, 'primary')
    cid2 = ComponentID("derived")
    link = core.ComponentLink([cid], cid2, using=lambda x: x * 3)
    dc = DerivedComponent(d, link)

    np.testing.assert_array_equal(dc[view], comp.data[view] * 3)

########NEW FILE########
__FILENAME__ = test_component_link
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103,W0612
import pytest

import numpy as np

from ..data import ComponentID, Data, Component
from ..component_link import ComponentLink, BinaryComponentLink
from ..subset import InequalitySubsetState


class TestComponentLink(object):

    def toy_data(self):
        data = Data()
        from_comp = Component(np.array([1, 2, 3]))
        to_comp = Component(np.array([4, 5, 6]))
        return data, from_comp, to_comp

    def test_valid_init(self):
        link = ComponentLink([ComponentID('from')], ComponentID('to'))

    def test_valid_init_using(self):
        data, from_, to_ = self.toy_data()
        using = lambda x: x
        link = ComponentLink([ComponentID('from')], ComponentID('to'), using)

    def test_invalid_init_multi_from_no_using(self):
        with pytest.raises(TypeError) as exc:
            ComponentLink([ComponentID('a'), ComponentID('b')],
                          ComponentID('c'))
        assert exc.value.args[0] == ("comp_from must have only 1 element, "
                                     "or a 'using' function must be provided")

    def test_invalid_init_scalar_from(self):
        with pytest.raises(TypeError) as exc:
            ComponentLink(ComponentID('from'), ComponentID('to'))
        assert exc.value.args[0].startswith("comp_from must be a list")

    def test_compute_direct(self):
        data, from_, to_ = self.toy_data()
        from_id = data.add_component(from_, 'from_label')
        to_id = ComponentID('to_label')
        link = ComponentLink([from_id], to_id)

        result = link.compute(data)
        expected = from_.data
        np.testing.assert_array_equal(result, expected)

    def test_compute_using(self):
        data, from_, to_ = self.toy_data()
        from_id = data.add_component(from_, 'from_label')
        to_id = ComponentID('to_label')
        using = lambda x: 3 * x
        link = ComponentLink([from_id], to_id, using)

        result = link.compute(data)
        expected = from_.data * 3
        np.testing.assert_array_equal(result, expected)

    def test_getters(self):
        data, from_, to_ = self.toy_data()
        from_id = data.add_component(from_, 'from_label')
        to_id = ComponentID('to_label')
        using = lambda x: 3 * x
        link = ComponentLink([from_id], to_id, using)

        assert link.get_from_ids()[0] is from_id
        assert link.get_to_id() is to_id
        assert link.get_using() is using

    def test_str(self):
        """ str method returns without error """
        data, from_, to_ = self.toy_data()
        from_id = data.add_component(from_, 'from_label')
        to_id = ComponentID('to_label')
        link = ComponentLink([from_id], to_id)
        str(link)
        link = ComponentLink([from_id], to_id, using=lambda x: 3 * x)
        str(link)

    def test_repr(self):
        """ repr method returns without error """
        data, from_, to_ = self.toy_data()
        from_id = data.add_component(from_, 'from_label')
        to_id = ComponentID('to_label')
        link = ComponentLink([from_id], to_id)
        repr(link)

    def test_type_check(self):
        """Should raise an exception if non ComponentIDs are passed as input"""
        cid = ComponentID('test')
        with pytest.raises(TypeError) as exc:
            ComponentLink([None], cid)
        assert exc.value.args[0].startswith('from argument is not a list '
                                            'of ComponentIDs')

        with pytest.raises(TypeError) as exc:
            ComponentLink([cid], None)
        assert exc.value.args[0].startswith('to argument is not a ComponentID')

        with pytest.raises(TypeError) as exc:
            ComponentLink([cid, None], None, using=lambda x, y: None)
        assert exc.value.args[0].startswith('from argument is not a list '
                                            'of ComponentIDs')

l = ComponentLink([ComponentID('a')], ComponentID('b'))
cid = ComponentID('a')
scalar = 3


@pytest.mark.parametrize(('a', 'b'), [(l, l), (l, cid), (l, scalar)])
def test_arithmetic_overload(a, b):
    for x in [a + b, a - b, a * b, a / b, a ** b]:
        assert isinstance(x, BinaryComponentLink)
    for x in [b + a, b - a, b * a, b / a, b ** a]:
        assert isinstance(x, BinaryComponentLink)


@pytest.mark.parametrize(('a', 'b'), [(l, l), (l, cid), (l, scalar)])
def test_inequality_overload(a, b):
    for x in [a < b, a <= b, a > b, a >= b]:
        assert isinstance(x, InequalitySubsetState)
    for x in [b < a, b <= a, b > a, b >= a]:
        assert isinstance(x, InequalitySubsetState)


def test_link_bad_input():
    with pytest.raises(TypeError) as exc:
        l = BinaryComponentLink(ComponentID('x'), None, None)
    assert exc.value.args[0] == 'Cannot create BinaryComponentLink using None'

    with pytest.raises(TypeError) as exc:
        l = BinaryComponentLink(None, ComponentID('x'), None)
    assert exc.value.args[0] == 'Cannot create BinaryComponentLink using None'


def test_arithmetic_id_scalar():
    d = Data(x=[1, 2, 3, 4], y=[10, 20, 10, 20])
    np.testing.assert_array_equal(d[d.id['x'] + 3], [4, 5, 6, 7])
    np.testing.assert_array_equal(d[d.id['x'] - 3], [-2, -1, 0, 1])
    np.testing.assert_array_equal(d[d.id['x'] * 3], [3, 6, 9, 12])
    np.testing.assert_array_equal(d[d.id['y'] / 10], [1, 2, 1, 2])
    np.testing.assert_array_equal(d[d.id['x'] ** 2], [1, 4, 9, 16])

    np.testing.assert_array_equal(d[3 + d.id['x']], [4, 5, 6, 7])
    np.testing.assert_array_equal(d[3 - d.id['x']], [2, 1, 0, -1])
    np.testing.assert_array_equal(d[3 * d.id['x']], [3, 6, 9, 12])
    np.testing.assert_array_equal(d[24 / d.id['x']], [24, 12, 8, 6])
    np.testing.assert_array_equal(d[2 ** d.id['x']], [2, 4, 8, 16])


def test_arithmetic_id_id():
    d = Data(x=[1, 2, 3, 4], y=[10, 20, 10, 20])
    np.testing.assert_array_equal(d[d.id['x'] + d.id['y']], [11, 22, 13, 24])
    np.testing.assert_array_equal(d[d.id['x'] - d.id['y']], [-9, -18, -7, -16])
    np.testing.assert_array_equal(d[d.id['x'] * d.id['y']], [10, 40, 30, 80])
    np.testing.assert_array_equal(
        d[d.id['y'] / d.id['x']], [10, 10, 10 / 3, 5])
    np.testing.assert_array_equal(d[d.id['y'] ** d.id['x']],
                                  [10, 400, 1000, 20 ** 4])


def test_arithmetic_id_link():
    d = Data(x=[1, 2, 3, 4], y=[10, 20, 10, 20])
    y10 = d.id['y'] / 10
    np.testing.assert_array_equal(d[d.id['x'] + y10], [2, 4, 4, 6])
    np.testing.assert_array_equal(d[d.id['x'] - y10], [0, 0, 2, 2])
    np.testing.assert_array_equal(d[d.id['x'] * y10], [1, 4, 3, 8])
    np.testing.assert_array_equal(d[d.id['x'] / y10], [1, 1, 3, 2])
    np.testing.assert_array_equal(d[d.id['x'] ** y10], [1, 4, 3, 16])

    np.testing.assert_array_equal(d[y10 + d.id['x']], [2, 4, 4, 6])
    np.testing.assert_array_equal(d[y10 - d.id['x']], [0, 0, -2, -2])
    np.testing.assert_array_equal(d[y10 * d.id['x']], [1, 4, 3, 8])
    np.testing.assert_array_equal(d[y10 / d.id['x']], [1, 1, 0, 0])
    np.testing.assert_array_equal(d[y10 ** d.id['x']], [1, 4, 1, 16])


def test_arithmetic_link_link():
    d = Data(x=[1, 2, 3, 4], y=[10, 20, 10, 20])
    x = d[d.id['x']]
    y = d[d.id['y']]
    xpy = d.id['x'] + d.id['y']
    xt3 = d.id['x'] * 3
    np.testing.assert_array_equal(d[xpy + xt3], x + y + x * 3)
    np.testing.assert_array_equal(d[xpy - xt3], x + y - x * 3)
    np.testing.assert_array_equal(d[xpy * xt3], (x + y) * x * 3)
    np.testing.assert_array_equal(d[xpy / xt3], (x + y) / (x * 3))
    np.testing.assert_array_equal(d[xpy ** xt3], (x + y) ** (x * 3))


def test_inequality():
    d = Data(x=[1, 2, 3, 4], y=[10, 20, 10, 20])
    s = d.new_subset()

    xpy = d.id['x'] + d.id['y']
    twentytwo = xpy * 0 + 22
    x = d[d.id['x']]
    y = d[d.id['y']]

    s.subset_state = xpy < 22
    np.testing.assert_array_equal(s.to_mask(), (x + y) < 22)

    s.subset_state = xpy <= 22
    np.testing.assert_array_equal(s.to_mask(), (x + y) <= 22)

    s.subset_state = xpy >= 22
    np.testing.assert_array_equal(s.to_mask(), (x + y) >= 22)

    s.subset_state = xpy > 22
    np.testing.assert_array_equal(s.to_mask(), (x + y) > 22)

    s.subset_state = 22 < xpy
    np.testing.assert_array_equal(s.to_mask(), 22 < (x + y))

    s.subset_state = 22 <= xpy
    np.testing.assert_array_equal(s.to_mask(), 22 <= (x + y))

    s.subset_state = 22 > xpy
    np.testing.assert_array_equal(s.to_mask(), 22 > (x + y))

    s.subset_state = 22 >= xpy
    np.testing.assert_array_equal(s.to_mask(), 22 >= (x + y))

    s.subset_state = twentytwo < xpy
    np.testing.assert_array_equal(s.to_mask(), 22 < (x + y))

    s.subset_state = twentytwo <= xpy
    np.testing.assert_array_equal(s.to_mask(), 22 <= (x + y))

    s.subset_state = twentytwo > xpy
    np.testing.assert_array_equal(s.to_mask(), 22 > (x + y))

    s.subset_state = twentytwo >= xpy
    np.testing.assert_array_equal(s.to_mask(), 22 >= (x + y))


def test_link_fixes_shape():
    def double(x):
        return (x * 2).reshape((2, 2))

    d = Data(x=[1, 2, 3, 4])
    y = ComponentID('y')
    link = ComponentLink([d.id['x']], y, using=double)
    np.testing.assert_array_equal(d[link], [2, 4, 6, 8])


def test_link_str():
    """Links should have sensible names"""
    d = Data(x=[1, 2, 3], y=[2, 3, 4])
    x = d.id['x']
    y = d.id['y']

    assert str(x + y) == ('(x + y)')
    assert str(x - y) == ('(x - y)')
    assert str(x * y) == ('(x * y)')
    assert str(x / y) == ('(x / y)')
    assert str(x ** y) == ('(x ** y)')
    assert str(x ** 3) == ('(x ** 3)')
    assert str(3 + x * y) == ('(3 + (x * y))')
    assert str(x + x + y) == ('((x + x) + y)')

    assert repr(x + y) == '<BinaryComponentLink: (x + y)>'

########NEW FILE########
__FILENAME__ = test_coordinates
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest

from mock import patch
import numpy as np
from numpy.testing import assert_almost_equal

from ..coordinates import (coordinates_from_header,
                           WCSCoordinates,
                           Coordinates,
                           header_from_string)


class TestWcsCoordinates(object):

    def default_header(self):
        from ...external.astro import fits
        hdr = fits.Header()
        hdr.update('NAXIS', 2)
        hdr.update('CRVAL1', 0)
        hdr.update('CRVAL2', 5)
        hdr.update('CRPIX1', 250)
        hdr.update('CRPIX2', 187.5)
        hdr.update('CTYPE1', 'GLON-TAN')
        hdr.update('CTYPE2', 'GLAT-TAN')
        hdr.update('CD1_1', -0.0166666666667)
        hdr.update('CD1_2', 0.)
        hdr.update('CD2_1', 0.)
        hdr.update('CD2_2', 0.01666666666667)
        return hdr

    def test_pixel2world_scalar(self):
        hdr = self.default_header()
        coord = WCSCoordinates(hdr)

        x, y = 250., 187.5
        result = coord.pixel2world(x, y)
        expected = 359.9832692105993601, 5.0166664867400375
        assert_almost_equal(result[0], expected[0])
        assert_almost_equal(result[1], expected[1])

    def test_pixel2world_different_input_types(self):
        hdr = self.default_header()
        coord = WCSCoordinates(hdr)

        x, y = 250, 187.5
        result = coord.pixel2world(x, y)
        expected = 359.9832692105993601, 5.0166664867400375
        assert_almost_equal(result[0], expected[0])
        assert_almost_equal(result[1], expected[1])

    def test_pixel2world_list(self):
        hdr = self.default_header()
        coord = WCSCoordinates(hdr)

        x, y = [250, 250], [187.5, 187.5]
        result = coord.pixel2world(x, y)
        expected = ([359.9832692105993601, 359.9832692105993601],
                    [5.0166664867400375, 5.0166664867400375])

        for i in range(0, 1):
            for r, e in zip(result[i], expected[i]):
                assert_almost_equal(r, e)

    def test_pixel2world_numpy(self):
        hdr = self.default_header()
        coord = WCSCoordinates(hdr)

        x, y = np.array([250, 250]), np.array([187.5, 187.5])
        result = coord.pixel2world(x, y)
        expected = (np.array([359.9832692105993601, 359.9832692105993601]),
                    np.array([5.0166664867400375, 5.0166664867400375]))

        np.testing.assert_array_almost_equal(result[0], expected[0])
        np.testing.assert_array_almost_equal(result[1], expected[1])

    def test_world2pixel_numpy(self):
        hdr = self.default_header()
        coord = WCSCoordinates(hdr)

        x, y = np.array([0, 0]), np.array([0, 0])
        expected = (np.array([249.0000000000000284, 249.0000000000000284]),
                    np.array([-114.2632689899972434, -114.2632689899972434]))

        result = coord.world2pixel(x, y)
        np.testing.assert_array_almost_equal(result[0], expected[0], 3)
        np.testing.assert_array_almost_equal(result[1], expected[1], 3)

    def test_world2pixel_list(self):
        hdr = self.default_header()
        coord = WCSCoordinates(hdr)

        x, y = [0, 0], [0, 0]
        expected = ([249.0000000000000284, 249.0000000000000284],
                    [-114.2632689899972434, -114.2632689899972434])

        result = coord.world2pixel(x, y)
        for i in range(0, 1):
            for r, e in zip(result[i], expected[i]):
                assert_almost_equal(r, e)

    def test_world2pixel_scalar(self):
        hdr = self.default_header()
        coord = WCSCoordinates(hdr)

        expected = 249.0000000000000284, -114.2632689899972434
        x, y = 0, 0

        result = coord.world2pixel(x, y)
        assert_almost_equal(result[0], expected[0], 3)
        assert_almost_equal(result[1], expected[1], 3)

    def test_world2pixel_mismatched_input(self):
        coord = WCSCoordinates(self.default_header())
        x, y = 0., [0.]
        expected = coord.world2pixel(x, y[0])

        result = coord.world2pixel(x, y)
        assert_almost_equal(result[0], expected[0])
        assert_almost_equal(result[1], expected[1])

    def test_pixel2world_mismatched_input(self):
        coord = WCSCoordinates(self.default_header())
        x, y = [250.], 187.5
        expected = coord.pixel2world(x[0], y)

        result = coord.pixel2world(x, y)
        assert_almost_equal(result[0], expected[0])
        assert_almost_equal(result[1], expected[1])

    def test_pixel2world_invalid_input(self):
        coord = WCSCoordinates(None)
        x, y = {}, {}
        with pytest.raises(TypeError) as exc:
            coord.pixel2world(x, y)

    def test_world2pixel_invalid_input(self):
        coord = WCSCoordinates(None)
        x, y = {}, {}
        with pytest.raises(TypeError) as exc:
            coord.world2pixel(x, y)

    def test_axis_label(self):
        hdr = self.default_header()
        coord = WCSCoordinates(hdr)

        assert coord.axis_label(0) == 'Galactic Latitude'
        assert coord.axis_label(1) == 'Galactic Longitude'


class TestCoordinatesFromHeader(object):

    def test_2d(self):
        hdr = {"NAXIS": 2}
        with patch('glue.core.coordinates.WCSCoordinates') as wcs:
            coord = coordinates_from_header(hdr)
            wcs.assert_called_once_with(hdr)

    def test_3d(self):
        hdr = {"NAXIS": 3}
        with patch('glue.core.coordinates.WCSCoordinates') as wcs:
            coord = coordinates_from_header(hdr)
            wcs.assert_called_once_with(hdr)

    def test_nod(self):
        hdr = 0
        with patch('glue.core.coordinates.Coordinates') as wcs:
            coord = coordinates_from_header(hdr)
            wcs.assert_called_once_with()

    def test_attribute_error(self):
        hdr = {"NAXIS": 2}
        with patch('glue.core.coordinates.WCSCoordinates') as wcs:
            wcs.side_effect = AttributeError
            coord = coordinates_from_header(hdr)
            wcs.assert_called_once_with(hdr)
            assert type(coord) is Coordinates

HDR_2D_VALID = """
SIMPLE  =                    T / Written by IDL:  Wed Jul 27 10:01:47 2011
BITPIX  =                  -32 / number of bits per data pixel
NAXIS   =                    2 / number of data axes
NAXIS1  =                  501 / length of data axis 1
NAXIS2  =                  376 / length of data axis 2
EXTEND  =                    T / FITS dataset may contain extensions
RADESYS = 'FK5     '           / Frame of reference
CRVAL1  =                   0. / World coordinate 1 at reference point
CRVAL2  =                   5. / World coordinate 2 at reference point
CRPIX1  =              250.000 / Pixel coordinate 1 at reference point
CRPIX2  =              187.500 / Pixel coordinate 2 at reference point
CTYPE1  = 'GLON-TAN'           / Projection type
CTYPE2  = 'GLAT-TAN'           / Projection type
CUNIT1  = 'deg     '           / Unit used for axis 1
CUNIT2  = 'deg     '           / Unit used for axis 2
CD1_1   =         -0.016666667 / Pixel trasformation matrix
CD1_2   =                   0.
CD2_1   =                   0.
CD2_2   =          0.016666667
"""

HDR_3D_VALID_NOWCS = """SIMPLE  = T / Written by IDL:  Fri Mar 18 11:58:30 2011
BITPIX  =                  -32 / Number of bits per data pixel
NAXIS   =                    3 / Number of data axes
NAXIS1  =                  128 /
NAXIS2  =                  128 /
NAXIS3  =                  128 /
"""

HDR_3D_VALID_WCS = """
SIMPLE  =                    T / Written by IDL:  Thu Jul  7 15:37:21 2011
BITPIX  =                  -32 / Number of bits per data pixel
NAXIS   =                    3 / Number of data axes
NAXIS1  =                   82 /
NAXIS2  =                   82 /
NAXIS3  =                  248 /
DATE    = '2011-07-07'         / Creation UTC (CCCC-MM-DD) date of FITS header
COMMENT FITS (Flexible Image Transport System) format is defined in 'Astronomy
COMMENT and Astrophysics', volume 376, page 359; bibcode 2001A&A...376..359H
CTYPE1  = 'RA---CAR'           /
CTYPE2  = 'DEC--CAR'           /
CTYPE3  = 'VELO-LSR'           /
CRVAL1  =              55.3500 /
CRPIX1  =              41.5000 /
CDELT1  =    -0.00638888900000 /
CRVAL2  =              31.8944 /
CRPIX2  =              41.5000 /
CDELT2  =     0.00638888900000 /
CRVAL3  =       -9960.07902777 /
CRPIX3  =             -102.000 /
CDELT3  =        66.4236100000 /
"""


def test_coords_preserve_shape_2d():
    coord = coordinates_from_header(header_from_string(HDR_2D_VALID))
    x = np.zeros(12)
    y = np.zeros(12)
    result = coord.pixel2world(x, y)
    for r in result:
        assert r.shape == x.shape
    result = coord.world2pixel(x, y)
    for r in result:
        assert r.shape == x.shape

    x.shape = (4, 3)
    y.shape = (4, 3)
    result = coord.pixel2world(x, y)
    for r in result:
        assert r.shape == x.shape
    result = coord.world2pixel(x, y)
    for r in result:
        assert r.shape == x.shape

    x.shape = (2, 2, 3)
    y.shape = (2, 2, 3)
    result = coord.pixel2world(x, y)
    for r in result:
        assert r.shape == x.shape
    result = coord.world2pixel(x, y)
    for r in result:
        assert r.shape == x.shape


def test_coords_preserve_shape_3d():
    coord = coordinates_from_header(header_from_string(HDR_3D_VALID_NOWCS))
    x = np.zeros(12)
    y = np.zeros(12)
    z = np.zeros(12)
    result = coord.pixel2world(x, y, z)
    for r in result:
        assert r.shape == x.shape
    result = coord.world2pixel(x, y, z)
    for r in result:
        assert r.shape == x.shape

    x.shape = (4, 3)
    y.shape = (4, 3)
    z.shape = (4, 3)
    result = coord.pixel2world(x, y, z)
    for r in result:
        assert r.shape == x.shape
    result = coord.world2pixel(x, y, z)
    for r in result:
        assert r.shape == x.shape

    x.shape = (2, 2, 3)
    y.shape = (2, 2, 3)
    z.shape = (2, 2, 3)
    result = coord.pixel2world(x, y, z)
    for r in result:
        assert r.shape == x.shape
    result = coord.world2pixel(x, y, z)
    for r in result:
        assert r.shape == x.shape

########NEW FILE########
__FILENAME__ = test_coordinate_links
import numpy as np
from astropy.io import fits
from cStringIO import StringIO

from .. import Data, DataCollection
from ..coordinates import coordinates_from_header
from ..link_helpers import LinkSame
from .util import make_file


def test_wcs_3d_to_2d():
    """ For a "normal" XYV cube, linking XY world should be
    enough to propagate XY pixel
    """
    d = Data(label='D1')
    with make_file(test_fits, suffix='.fits', decompress=True) as file:
        header = fits.getheader(file)
    d.coords = coordinates_from_header(header)
    d.add_component(np.zeros((3, 2, 1)), label='test')

    d2 = Data(label='D2')
    d2.coords = coordinates_from_header(header)
    d2.add_component(np.zeros((3, 2, 1)), label='test2')

    dc = DataCollection([d, d2])
    dc.add_link(LinkSame(d.get_world_component_id(1),
                         d2.get_world_component_id(1)))
    dc.add_link(LinkSame(d.get_world_component_id(2),
                         d2.get_world_component_id(2)))

    py = d.get_pixel_component_id(1)
    px = d.get_pixel_component_id(2)
    py2 = d2.get_pixel_component_id(1)
    px2 = d2.get_pixel_component_id(2)

    np.testing.assert_array_almost_equal(d2[px], d2[px2])
    np.testing.assert_array_almost_equal(d2[py], d2[py2])


def test_link_velocity():
    """ For a normal PPV cube, linking velocity world should be
    enough to get pixel V"""
    d = Data(label='D1')
    with make_file(test_fits, suffix='.fits', decompress=True) as file:
        header = fits.getheader(file)
    d.coords = coordinates_from_header(header)
    d.add_component(np.zeros((3, 2, 1)), label='test')

    d2 = Data(label='D2')
    d2.coords = coordinates_from_header(header)
    d2.add_component(np.zeros((3, 2, 1)), label='test2')

    dc = DataCollection([d, d2])
    dc.add_link(LinkSame(d.get_world_component_id(0),
                         d2.get_world_component_id(0)))

    pz = d.get_pixel_component_id(0)
    pz2 = d2.get_pixel_component_id(0)

    np.testing.assert_array_almost_equal(d2[pz], d2[pz2])


class TestDependentAxes(object):

    def test_base(self):
        d = Data(x=[1, 2, 3])
        assert d.coords.dependent_axes(0) == (0,)

        d = Data(x=[[1, 2], [3, 4]])
        assert d.coords.dependent_axes(0) == (0,)
        assert d.coords.dependent_axes(1) == (1,)

    def header2(self, proj='SIN'):
        result = fits.Header()
        result['NAXIS'] = 2
        result['NAXIS1'] = 100
        result['NAXIS2'] = 100
        result['CRPIX1'] = 1
        result['CRPIX2'] = 1
        result['CDELT1'] = 1
        result['CDELT2'] = 1
        result['CTYPE1'] = 'RA---%s' % proj
        result['CTYPE2'] = 'DEC--%s' % proj
        result['CRVAL1'] = 1
        result['CRVAL2'] = 1
        return result

    def header3(self, proj='SIN'):
        result = self.header2(proj)
        result.update(NAXIS=3, NAXIS3=1, CDELT3=1,
                      CRPIX3=3, CTYPE3='VOPT')
        return result

    def header4(self):
        result = fits.Header()
        result.update(WCSAXES=4,
                      CRPIX1=513,
                      CRPIX2=513,
                      CRPIX3=1,
                      CRPIX4=1,
                      CDELT1=-6.94444444444E-05,
                      CDELT2=6.94444444444E-05,
                      CDELT3=10000.1667626,
                      CDELT4=1,
                      CTYPE1='RA---SIN',
                      CTYPE2='DEC--SIN',
                      CTYPE3='VOPT',
                      CTYPE4='STOKES',
                      CRVAL1=56.7021416715,
                      CRVAL2=68.0961055596,
                      CRVAL3=-280000.000241,
                      CRVAL4=1,
                      PV2_1=0,
                      PV2_2=0,
                      LONPOLE=180,
                      LATPOLE=68.0961055596,
                      RESTFRQ=34596380000,
                      RADESYS='FK5',
                      EQUINOX=2000,
                      SPECSYS='BARYCENT')
        return result

    def test_wcs_ppv(self):

        header = self.header3()

        d = Data(label='D1')
        d.coords = coordinates_from_header(header)
        d.add_component(np.zeros((3, 2, 1)), label='test')

        assert d.coords.dependent_axes(0) == (0,)
        assert d.coords.dependent_axes(1) == (1, 2)
        assert d.coords.dependent_axes(2) == (1, 2)

    def test_wcs_alma(self):
        header = self.header4()

        d = Data(label='D1')
        d.coords = coordinates_from_header(header)
        d.add_component(np.zeros((3, 2, 1, 1)), label='test')

        assert d.coords.dependent_axes(0) == (0,)
        assert d.coords.dependent_axes(1) == (1,)
        assert d.coords.dependent_axes(2) == (2, 3)
        assert d.coords.dependent_axes(3) == (2, 3)


test_fits = 'x\x9c\xed\x97Qs\xa2H\x14\x85\xf7\xa7\xdc\xa75I\x05B\x83\xa0\xb8\x95\x07\xd462\x11q\xa0\xcdL\xe6%\x85\xd21T!X\x80\x93\xf1\xdf\xef\x05uuv\xccN\xc0<mq\x1e\x04\x11>O\x9f\xee\xa6o\xbb\xa65\x19Q\x80[8!\x0670\x8f\xa3\xe78Y\xa6\x90\xc500\x99\x0bi\xe6E\xbe\x97\xf8\xa7\x1e\x00\xe8\x9alb~=\xc9\x13\xb4&\xf2\xbc$\xf16\xe0{\x99\x07\xd9f\xc5OS\x0e\x1a\x1b_M\x17\xde\xf0\xa7 /Z/g<\x81\xf8yO\x0e\x96<J\x838J\xdf\xe6\x917x\xe4wn\xde\xe0\xc9\x1f\xccS>\x8e\xd7\xb3-\x8b\x8e\x19\x9e\x15\x9dw1\x08\xf9\x8f`\x16r0\x97\xde\x82\x03K\xbc(]\xc5I\x06\xee&\xcd\xf8\xf2\x12\xf2\xce\xf62\x08R\xf0\xf9s\x10q\x1f\x82\x08\x1aF\x9a%q\x14/7\x07\x1e\x8e\x02(.\xaf^6i0O\x1b\xd7\xf0=\x0e\xd7K\x0eJK\xbb\x86U\x8eWT\xfd/\x98\x05\xb3y\xec\xf3\x0e\xc8\x92D\x8c?\rQ\x14\xf1\x0e\xfcP\xf5!\xf4\rFs\x9f\xb7\xd0\xc0\x9f\x9b\x82\xa4\x08De2\xe9\xc8\xed\x8e,7\xb0\x83\x9f\x03t;O\xb8\x97a\xa7\xe6\x03\x87\xc3\xc5#J\xb0,\xa1\xdfg//\x9d\xe5\xb2\x93\xa60e\x97\xc8\xb1\xbb\x9fh\x8f\x15\xbc\tu\\:u\x8b\x18\x1a\xbb8n\xca\xe6\xc7\xe8\x88\xba={\x82\xbcA\xcf1l\x814\xad\xc6\xe1\xe7\xd2<s\xec2gjQ\xe4\xb9\xf4\xf3\xd46\r8\xc2\x95\xe7\xd9]\xf7)\xcfp7^0CY\x94u\xa2\xabDk\x11R\x9e7e\xdb\xe3\xcf\xe3\x8f(bS\xd7\x8a\xf9;\xb4\xa7\x8e\xfb~\xde\xc8e\'x\xb2\x8cC@\xd1\x95\xf2<:\xb1{\xc3_xP\xb4\\\x12\xcb\xb7\xd7\xf8fZS6\xdc\xf1\xb4\xb6\xd8&\x8a\xdeV\xe5\x96Nd\xb9\x8d\xbc>\xbds(}\xb7C\x1c.\x0f\x063\xed-O\xd6DM\xd1\x9b\xedv\x13\x91\x9a\xa2\x95\xe7=\x8c\\\'?\x9ex\x1f\x90\xa2\xbd\xf7\xd6M\x89\xf8\xa0;\x1d\x9b\xac\xe0\xe5\xc3\xee>\xbf\xf4\xf3\xf8c\xc6U\t\x1c\xb8\xf7\x8fO\x03\x87~\xde\xfa#\xe8\x89\xb4u\x89\xb4U]\x95\x9b*\xf2\xee\x86\xdf\xca\xf0F\xe6\x98\x1ex;\xe5XY"J\xab<\xaf\xfbe{<\x91\x9f\xac\xe6\xf9Y\xe5\xfd\x8d\x8db\xfe\x12\xa5g?\x11A:k\xfe\xf6\xd8\xe3\x84\x16\xebQ\xc31\x04Ap\x07\xa3\xf3x\xce\x831:^\xdf\xd4\x96\xa8\xa9\xfaN\x15x}:b{\x9e \x89\x92\xa4)m\x94.\xe5\xaa\xe2\x0f\xcb\x83c\x7fJ\xce\xdc\xabb~\xc5\xfa\xdb\xe8\xd3\xde\x07\xe5\xf7\xebz\xbe3Y1\xbf\x7fx\x1f\x94\xdf\x91?\xa1\xa9\xe9MQ\'\xca9\xf9\x15\xf5F\xe3\x81\x8el\x01_7\xe7\xe7wT\xbf\x08\xba\xaea\xab[\xba$\xb7Z\xad\x8a\xf9\x1d\xd7C\x9a&6eE#\xe7\xe4w\xaa\xbeB\xa3\xa2T\x96\x0604]f;\x8fp\xc7#\x9e`m\xe2\xc3l\x03E\xa5\x00\x0e_$\x81\xef\x07\xd1\x02&I\xbcH\xbc%\xe0\xda\xfc\x9b\xff\xd8\xf3\xba^\xcaC,\xbf\xc0]\xcf\xb2\xc4\x9b\xe7\xe4*\xda\xf3\n\xdd\x85\xf1\xcc\x0b\x0f\xec\x89\x87\xa6x\xc6\x93\xb4\x83\xb5e\x9c\xf8XH\xaf\xe2p\x83\x85^\x80\xf7\xfd\x17\xefK\x10\xf9\xf1+0,\xe1o\xbf\xf30\x9e\x07\xd9\xe6l\x7fE}\x9b\xcf\x11\xc8\xd7\xf3\xed\xb1"o\x1c\x07)\x87W\x1e,^\xb2\xbc\x07\xc8\xcd*~\xbdp\xcd;\xcb\xb8\x96/\xab\xf0`\x10b]<\x08xXt)n8\xfa\xf9&\xa6\xa2?w\x85\xf5,f<\x08B\xcc\xbf\x03\x9f\x82h~\xb5\xf0\xd6i\x1ax\xd1U\xfe\xad\x1c\xcf\x8cV\xeb\x0cl6\x00w\x8e%}\xa7\xac\xaf\x7f\xf3@ST-\xdf\xf3\xe1I\xab\xc2\xbec/:\xeeW\x7f\xb8V\xadZ\xb5j\xd5\xaa\xf5\xbf\xd4\x1f\xb5j\xd5\xaaU\xabV\xadZ\xb5j\xd5z\xb7\xfe\x06\xb6\x02\x94\xfe'

########NEW FILE########
__FILENAME__ = test_data
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103,R0903,R0904
import pytest
import numpy as np
from mock import MagicMock

from ..data import (ComponentID, Component, Data,
                    DerivedComponent, pixel_label, CategoricalComponent)
from ..coordinates import Coordinates
from ..subset import Subset, SubsetState
from ..hub import Hub
from ..exceptions import IncompatibleAttribute
from ..component_link import ComponentLink
from ..registry import Registry


class TestCoordinates(Coordinates):

    def pixel2world(self, *args):
        return [(i + 2.) * a for i, a in enumerate(args)]

    def world2pixel(self, *args):
        return [a / (i + 2.) for i, a in enumerate(args)]


class TestData(object):

    def setup_method(self, method):
        self.data = Data(label="Test Data")
        Registry().clear()
        comp = Component(np.random.random((2, 3)))
        self.comp = comp
        self.data.coords = TestCoordinates()
        self.comp_id = self.data.add_component(comp, 'Test Component')

    def test_2d_component_print(self):
        assert str(self.comp) == 'Component with shape (2, 3)'

    def test_shape_empty(self):
        d = Data()
        assert d.shape == ()

    def test_ndim_empty(self):
        d = Data()
        assert d.ndim == 0

    def test_shape(self):
        assert self.data.shape == (2, 3)

    def test_ndim(self):
        assert self.data.ndim == 2

    def test_size(self):
        assert self.data.size == 6

    def test_label(self):
        d = Data()
        assert d.label == ''
        assert self.data.label == "Test Data"

    def test_set_label(self):
        d = Data()
        d.label = 'test_set_label'
        assert d.label == 'test_set_label'

    def test_add_component_with_id(self):
        cid = ComponentID("test")
        comp = Component(np.random.random((2, 3)))
        cid2 = self.data.add_component(comp, cid)
        assert cid2 is cid

    def test_add_component_incompatible_shape(self):
        comp = MagicMock()
        comp.data.shape = (3, 2)
        with pytest.raises(TypeError) as exc:
            self.data.add_component(comp("junk label"))
        if isinstance(exc.value, basestring):  # python 2.6
            assert exc.value == ("add_component() takes at least 3 "
                                 "arguments (2 given)")
        else:
            assert exc.value.args[0] == ("add_component() takes at least 3 "
                                         "arguments (2 given)")

    def test_get_getitem_incompatible_attribute(self):
        cid = ComponentID('bad')
        with pytest.raises(IncompatibleAttribute) as exc:
            self.data.__getitem__(cid)
        assert exc.value.args[0] is cid

    def test_get_component_incompatible_attribute(self):
        cid = ComponentID('bad')
        with pytest.raises(IncompatibleAttribute) as exc:
            self.data.get_component(cid)
        assert exc.value.args[0] is cid

    def test_get_component_name(self):
        d = Data(x=[1, 2, 3])
        assert isinstance(d.get_component('x'), Component)

    def test_component_ids(self):
        cid = self.data.component_ids()
        assert self.comp_id in cid

    def test_new_subset(self):
        sub = self.data.new_subset()
        assert sub in self.data.subsets

    def test_data_not_created_with_subsets(self):
        assert len(self.data.subsets) == 0

    def test_register(self):
        hub = MagicMock(spec_set=Hub)
        not_hub = MagicMock()
        self.data.register_to_hub(hub)
        assert hub is self.data.hub
        with pytest.raises(TypeError) as exc:
            self.data.register_to_hub(not_hub)
        assert exc.value.args[0].startswith("input is not a Hub object")

    def test_component_order(self):
        """Components should be returned in the order they were specified"""
        data = Data()
        comp = Component(np.array([1, 2, 3]))
        labels = 'asldfkjaAREGWoibasiwnsldkgajsldkgslkg'
        for label in labels:
            data.add_component(comp, label)
        ids = data.visible_components
        assert [cid.label for cid in ids] == list(labels)

    def test_broadcast(self):
        hub = MagicMock(spec_set=Hub)

        # make sure broadcasting with no hub is ok
        self.data.broadcast()

        # make sure broadcast with hub gets relayed
        self.data.register_to_hub(hub)
        self.data.broadcast()
        assert hub.broadcast.call_count == 1

    def test_double_hub_add(self):
        hub = MagicMock(spec_set=Hub)
        hub2 = MagicMock(spec_set=Hub)
        self.data.register_to_hub(hub)
        with pytest.raises(AttributeError) as exc:
            self.data.__setattr__('hub', hub2)
        assert exc.value.args[0] == ("Data has already been assigned "
                                     "to a different hub")

    def test_primary_components(self):
        compid = ComponentID('virtual')
        link = MagicMock(spec_set=ComponentLink)
        comp = DerivedComponent(self.data, link)

        self.data.add_component(comp, compid)

        pricomps = self.data.primary_components
        print self.comp_id, compid, pricomps
        print self.comp_id in pricomps
        print compid not in pricomps
        assert self.comp_id in pricomps
        assert compid not in pricomps

    def test_add_component_invalid_label(self):
        with pytest.raises(TypeError) as exc:
            self.data.add_component(self.comp, label=5)
        assert exc.value.args[0] == "label must be a ComponentID or string"

    def test_add_component_invalid_component(self):
        comp = Component(np.array([1]))
        with pytest.raises(ValueError) as exc:
            self.data.add_component(comp, label='bad')
        assert exc.value.args[0].startswith("The dimensions of component bad")

    def test_add_component_link(self):
        link = MagicMock(spec_set=ComponentLink)
        cid = ComponentID("new id")
        link.get_to_id.return_value = cid

        self.data.add_component_link(link)
        assert cid in self.data.derived_components

    def test_derived_components(self):
        compid = ComponentID('virtual')
        link = MagicMock(spec_set=ComponentLink)
        comp = DerivedComponent(self.data, link)

        self.data.add_component(comp, compid)

        pricomps = self.data.derived_components
        assert self.comp_id not in pricomps
        assert compid in pricomps

    def test_str_empty(self):
        d = Data()
        str(d)

    def test_str_(self):
        str(self.data)

    def test_add_derived_component(self):
        compid = ComponentID('virtual')
        link = MagicMock(spec_set=ComponentLink)
        comp = DerivedComponent(self.data, link)
        comp.data.shape = self.data.shape
        self.data.add_component(comp, compid)

        result = self.data[compid]
        link.compute.assert_called_with(self.data)

    def test_find_component_id(self):
        cid = self.data.find_component_id('Test Component')
        assert cid == self.comp_id
        assert self.data.find_component_id('does not exist') is None

    def test_add_subset(self):
        s = Subset(None)
        self.data.add_subset(s)
        assert s in self.data.subsets

    def test_add_subset_with_subset_state(self):
        """Passing a subset state auto-wraps into a subset object"""
        state = SubsetState()
        self.data.add_subset(state)
        added = self.data.subsets[-1]
        assert added.subset_state is state
        assert added.data is self.data

    def test_add_subset_reparents_subset(self):
        """add_subset method updates subset.data reference"""
        s = Subset(None)
        self.data.add_subset(s)
        assert s.data is self.data

    def test_add_subset_disambiguates_label(self):
        """adding subset should disambiguate label if needed"""
        s1 = Subset(None)
        self.data.add_subset(s1)
        s1.label = "test_subset_label"
        s2 = Subset(None)
        s2.label = "test_subset_label"
        assert s2.label == "test_subset_label"
        self.data.add_subset(s2)
        assert s2.label != "test_subset_label"

    def test_add_subset_with_hub(self):
        s = Subset(None)
        hub = MagicMock(spec_set=Hub)
        self.data.register_to_hub(hub)

        self.data.add_subset(s)
        assert s in self.data.subsets
        assert hub.broadcast.call_count == 1

    def test_remove_component(self):
        self.data.remove_component(self.comp_id)
        assert not self.comp_id in self.data.components

    def test_get_component(self):
        assert self.data.get_component(self.comp_id) is self.comp

    def test_get_None_component(self):

        with pytest.raises(IncompatibleAttribute):
            self.data.get_component(None)

    def test_get_item(self):
        assert self.data[self.comp_id] is self.comp.data

    def test_coordinate_links(self):
        links = self.data.coordinate_links
        w0 = self.data[self.data.get_world_component_id(0)]
        w1 = self.data[self.data.get_world_component_id(1)]
        p0 = self.data[self.data.get_pixel_component_id(0)]
        p1 = self.data[self.data.get_pixel_component_id(1)]

        w0prime = links[0].compute(self.data)
        p0prime = links[1].compute(self.data)
        w1prime = links[2].compute(self.data)
        p1prime = links[3].compute(self.data)

        np.testing.assert_array_equal(w0, w0prime)
        np.testing.assert_array_equal(w1, w1prime)
        np.testing.assert_array_equal(p0, p0prime)
        np.testing.assert_array_equal(p1, p1prime)

    def test_coordinate_links_empty_data(self):
        d = Data()
        d.coords = None
        assert d.coordinate_links == []

    def test_coordinate_links_idempotent(self):
        """Should only calculate links once, and
        return the same objects every time"""
        links = self.data.coordinate_links
        links2 = self.data.coordinate_links
        assert links == links2

    def test_fancy_view(self):
        result = self.data[self.comp_id, :, 2]
        np.testing.assert_array_equal(result, self.data[self.comp_id][:, 2])

    def test_get_by_string(self):
        result = self.data['Test Component']
        assert result is self.comp.data

    def test_get_by_missing_string(self):
        with pytest.raises(IncompatibleAttribute) as exc:
            result = self.data['xyz']
        assert exc.value.args[0] == 'xyz'

    def test_immutable(self):
        d = Data(x=[1, 2, 3])
        with pytest.raises(ValueError) as exc:
            d['x'][:] = 5
        assert 'read-only' in exc.value.args[0]
        assert not d['x'].flags['WRITEABLE']

    def test_categorical_immutable(self):
        d = Data()
        c = CategoricalComponent(['M', 'M', 'F'], categories=['M', 'F'])
        d.add_component(c, label='gender')

        with pytest.raises(ValueError) as exc:
            d['gender'][:] = 5
        assert 'read-only' in exc.value.args[0]
        assert not d['gender'].flags['WRITEABLE']


def test_component_id_item_access():

    data = Data()

    c1 = Component(np.array([1, 2, 3]))
    data.add_component(c1, 'values')

    c2 = Component(np.array([4., 5., 6.]))
    data.add_component(c2, 'Flux')

    assert data.id['values'] == data.find_component_id('values')
    assert data.id['Flux'] == data.find_component_id('Flux')


def test_component_id_item_access_missing():
    """id attribute should raise KeyError if requesting a bad ComponentID"""
    data = Data()
    with pytest.raises(KeyError):
        data.id['not found']


class TestPixelLabel(object):

    def test(self):
        assert pixel_label(0, 2) == "y"
        assert pixel_label(1, 2) == "x"
        assert pixel_label(0, 3) == "z"
        assert pixel_label(1, 3) == "y"
        assert pixel_label(2, 3) == "x"
        assert pixel_label(1, 0) == "Axis 1"
        assert pixel_label(1, 4) == "Axis 1"


@pytest.mark.parametrize(('kwargs'),
                         [{'x': [1, 2, 3]},
                          {'x': np.array([1, 2, 3])},
                          {'x': [[1, 2, 3], [2, 3, 4]]},
                          {'x': [1, 2], 'y': [2, 3]}])
def test_init_with_inputs(kwargs):
    """Passing array-like objects as keywords to Data
    auto-populates Components with label names = keywords"""
    d = Data(**kwargs)
    for label, data in kwargs.items():
        np.testing.assert_array_equal(d[d.id[label]], data)


def test_init_with_invalid_kwargs():
    with pytest.raises(ValueError) as exc:
        d = Data(x=[1, 2], y=[1, 2, 3])
    assert exc.value.args[0].startswith('The dimensions of component')


def test_getitem_with_component_link():
    d = Data(x=[1, 2, 3, 4])
    y = d.id['x'] * 5
    np.testing.assert_array_equal(d[y], [5, 10, 15, 20])


def test_getitem_with_component_link_and_slice():
    d = Data(x=[1, 2, 3, 4])
    y = d.id['x'] * 5
    np.testing.assert_array_equal(d[y, ::2], [5, 15])


def test_add_link_with_binary_link():
    d = Data(x=[1, 2, 3, 4], y=[4, 5, 6, 7])
    z = d.id['x'] + d.id['y']
    d.add_component_link(z, 'z')
    np.testing.assert_array_equal(d[d.id['z']], [5, 7, 9, 11])


def test_foreign_pixel_components_not_in_visible():
    """Pixel components from other data should not be visible"""

    # currently, this is trivially satisfied since all coordinates are hidden
    from ..link_helpers import LinkSame
    from ..data_collection import DataCollection

    d1 = Data(x=[1], y=[2])
    d2 = Data(w=[3], v=[4])
    dc = DataCollection([d1, d2])
    dc.add_link(LinkSame(d1.id['x'], d2.id['w']))

    dc.add_link(LinkSame(d1.get_world_component_id(0),
                         d2.get_world_component_id(0)))

    assert d2.get_pixel_component_id(0) not in d1.visible_components
    np.testing.assert_array_equal(d1[d2.get_pixel_component_id(0)], [0])

########NEW FILE########
__FILENAME__ = test_data_collection
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import numpy as np
from mock import MagicMock
import pytest

from ..data import Data, Component, ComponentID, DerivedComponent
from ..hub import Hub, HubListener
from ..data_collection import DataCollection
from ..message import (Message, DataCollectionAddMessage,
                       DataCollectionDeleteMessage,
                       ComponentsChangedMessage)
from ..component_link import ComponentLink


class HubLog(HubListener):
    def __init__(self):
        self.messages = []

    def register_to_hub(self, hub):
        hub.subscribe(self, Message)

    def notify(self, message):
        self.messages.append(message)


class TestDataCollection(object):

    def setup_method(self, method):
        self.dc = DataCollection()
        self.data = MagicMock()
        self.hub = self.dc.hub
        self.log = HubLog()
        self.log.register_to_hub(self.hub)

    def test_init_scalar(self):
        """Single data object passed to init adds to collection"""
        d = Data()
        dc = DataCollection(d)
        assert d in dc

    def test_init_list(self):
        """List of data objects passed to init auto-added to collection"""
        d1 = Data()
        d2 = Data()
        dc = DataCollection([d1, d2])
        assert d1 in dc
        assert d2 in dc

    def test_data(self):
        """ data attribute is a list of all appended data"""
        self.dc.append(self.data)
        assert self.dc.data == [self.data]

    def test_append(self):
        """ append method adds to collection """
        self.dc.append(self.data)
        assert self.data in self.dc

    def test_multi_append(self):
        """ append method works with lists """
        d = Data('test1', x=[1, 2, 3])
        d2 = Data('test2', y=[2, 3, 4])
        self.dc.append([d, d2])
        assert d in self.dc
        assert d2 in self.dc

    def test_ignore_multi_add(self):
        """ data only added once, even after multiple calls to append """
        self.dc.append(self.data)
        self.dc.append(self.data)
        assert len(self.dc) == 1

    def test_remove(self):
        self.dc.append(self.data)
        self.dc.remove(self.data)
        assert not self.data in self.dc

    def test_ignore_multi_remove(self):
        self.dc.append(self.data)
        self.dc.remove(self.data)
        self.dc.remove(self.data)
        assert not self.data in self.dc

    def test_append_broadcast(self):
        """ Call to append generates a DataCollectionAddMessage """
        self.dc.append(self.data)
        msg = self.log.messages[-1]
        assert msg.sender == self.dc
        assert isinstance(msg, DataCollectionAddMessage)
        assert msg.data is self.data

    def test_remove_broadcast(self):
        """ call to remove generates a DataCollectionDeleteMessage """
        self.dc.append(self.data)
        self.dc.remove(self.data)
        msg = self.log.messages[-1]
        assert msg.sender == self.dc
        assert isinstance(msg, DataCollectionDeleteMessage)
        assert msg.data is self.data

    def test_register_assigns_hub_of_data(self):
        self.dc.append(self.data)
        self.data.register_to_hub.assert_called_once_with(self.hub)

    def test_get_item(self):
        self.dc.append(self.data)
        assert self.dc[0] is self.data

    def test_iter(self):
        self.dc.append(self.data)
        assert set(self.dc) == set([self.data])

    def test_len(self):
        assert len(self.dc) == 0
        self.dc.append(self.data)
        assert len(self.dc) == 1
        self.dc.append(self.data)
        assert len(self.dc) == 1
        self.dc.remove(self.data)
        assert len(self.dc) == 0

    def test_derived_links_autoadd(self):
        """When appending a data set, its DerivedComponents
        should be ingested into the LinkManager"""
        d = Data()
        id1 = ComponentID("id1")
        id2 = ComponentID("id2")
        link = ComponentLink([id1], id2)
        dc = DerivedComponent(d, link)
        d.add_component(Component(np.array([1, 2, 3])), id1)
        d.add_component(dc, id2)

        dc = DataCollection()
        dc.append(d)

        assert link in dc._link_manager

    def test_catch_data_add_component_message(self):
        """DerviedAttributes added to a dataset in a collection
        should generate messages that the collection catches.
        """
        d = Data()
        id1 = ComponentID("id1")
        id2 = ComponentID("id2")
        link = ComponentLink([id1], id2)
        dc = DerivedComponent(d, link)

        self.dc.append(d)
        d.add_component(Component(np.array([1, 2, 3])), id1)
        assert not link in self.dc._link_manager
        d.add_component(dc, id2)

        msg = self.log.messages[-1]
        assert isinstance(msg, ComponentsChangedMessage)
        assert link in self.dc._link_manager

    def test_coordinate_links_auto_added(self):
        d = Data()
        id1 = ComponentID("id1")
        id2 = ComponentID("id2")
        link = ComponentLink([id1], id2)
        self.data.coordinate_links = [link]
        self.dc.append(self.data)
        assert link in self.dc.links

    def test_add_links(self):
        """ links attribute behaves like an editable list """
        d = Data()
        comp = MagicMock(spec_set=Component)
        id1 = ComponentID("id1")
        id2 = ComponentID("id2")
        link = ComponentLink([id1], id2)
        self.dc.set_links([link])
        assert link in self.dc.links

    def test_add_links_updates_components(self):
        """setting links attribute automatically adds components to data"""
        d = Data()
        comp = MagicMock(spec_set=Component)
        id1 = ComponentID("id1")
        d.add_component(comp, id1)
        id2 = ComponentID("id2")
        self.dc.append(d)
        link = ComponentLink([id1], id2, using=lambda x: None)

        self.dc.set_links([link])
        assert id2 in d.components

    def test_links_propagated(self):
        """Web of links is grown and applied to data automatically"""
        from ..component_link import ComponentLink
        d = Data()
        dc = DataCollection([d])

        cid1 = d.add_component(np.array([1, 2, 3]), 'a')
        cid2 = ComponentID('b')
        cid3 = ComponentID('c')

        dummy = lambda x: None
        links = ComponentLink([cid1], cid2, dummy)
        dc.add_link(links)
        assert cid2 in d.components

        links = ComponentLink([cid2], cid3, dummy)
        dc.add_link(links)
        assert cid3 in d.components

    def test_merge_links(self):
        """Trivial links should be merged, discarding the duplicate ID"""
        d1 = Data(x=[1, 2, 3])
        d2 = Data(x=[2, 3, 4])
        dc = DataCollection([d1, d2])

        duplicated_id = d2.id['x']
        link = ComponentLink([d1.id['x']], d2.id['x'])
        dc.add_link(link)

        assert d1.id['x'] is d2.id['x']
        assert d1.id['x'] is not duplicated_id
        assert duplicated_id not in d1.components
        assert duplicated_id not in d2.components

        np.testing.assert_array_equal(d1[d1.id['x']], [1, 2, 3])
        np.testing.assert_array_equal(d2[d1.id['x']], [2, 3, 4])

########NEW FILE########
__FILENAME__ = test_data_factories
import pytest
from mock import MagicMock
import numpy as np

import glue.core.data_factories as df
from glue.core.data import CategoricalComponent
from .util import make_file


def test_load_data():
    factory = MagicMock()
    d = df.load_data('test.fits', factory)
    factory.assert_called_once_with('test.fits')
    assert d.label == 'test'


def test_extension():
    assert df._extension('test.fits') == 'fits'
    assert df._extension('test.fits.gz') == 'fits.gz'
    assert df._extension('test.fits.gzip') == 'fits.gzip'
    assert df._extension('test.fits.bz') == 'fits.bz'
    assert df._extension('test.fits.bz2') == 'fits.bz2'
    assert df._extension('test.other.names.fits') == 'fits'


def test_data_label():
    assert df.data_label('test.fits') == 'test'
    assert df.data_label('/Leading/Path/test.fits') == 'test'
    assert df.data_label('') == ''
    assert df.data_label('/Leading/Path/no_extension') == 'no_extension'
    assert df.data_label('no_extension') == 'no_extension'


def test_png_loader():
    data = '\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x02\x00\x00\x00\x02\x08\x00\x00\x00\x00W\xddR\xf8\x00\x00\x00\x0eIDATx\x9ccdddab\x04\x00\x00&\x00\x0b\x8e`\xe7A\x00\x00\x00\x00IEND\xaeB`\x82'
    with make_file(data, '.png') as fname:
        d = df.load_data(fname)
        assert df.find_factory(fname) is df.img_data
    np.testing.assert_array_equal(d['PRIMARY'], [[3, 4], [1, 2]])


def test_fits_image_loader():
    with make_file(TEST_FITS_DATA, '.fits') as fname:
        d = df.load_data(fname)
        assert df.find_factory(fname) is df.gridded_data
    np.testing.assert_array_equal(d['PRIMARY'], [1, 2, 3])


@pytest.mark.parametrize('suffix', ['.h5', '.hdf5', '.hd5', '.h5custom'])
def test_hdf5_loader(suffix):
    data = 'x\xda\xeb\xf4pq\xe3\xe5\x92\xe2b\x00\x01\x0e\x0e\x06\x16\x06\x01\x06d\xf0\x1f\n*8P\xf90\xf9\x04(\xcd\x08\xa5;\xa0\xf4\n&\x988#XN\x02*.\x085\x1f]]H\x90\xab+H\xf5\x7f4\x00\xb3\xc7\x80\x05Bs0\x8c\x82\x91\x08<\\\x1d\x03@t\x04\x94\x0fK\xa5\'\x98P\xd5U\xa0\xa5G\x0f\n\xeded`\x83\x98\xc5\x08\xe3CR2##D\x80\x19\xaa\x0eA\x0b\x80\x95\np\xc0\xd2\xaa\x03\x98d\x05\xf2@\xe2LLL\x8c\x90t,\x01\xe633&@\x93\xb4\x04\x8a\xbdBP\xdd 5\xc9\xd5]A\x0c\x0c\r\x83"\x1e\x82\xfd\xfc]@9\x1a\x96\x0f\x15\x98G\xd3\xe6(\x18\x05\xa3\x00W\xf9\t\x01Lh\xe5$\x00\xc2A.\xaf'
    with make_file(data, suffix, decompress=True) as fname:
        d = df.load_data(fname)
        assert df.find_factory(fname) is df.gridded_data
    np.testing.assert_array_equal(d['/x'], [1, 2, 3])


def test_fits_catalog_factory():
    data = '\x1f\x8b\x08\x08\x19\r\x9cQ\x02\x03test.fits\x00\xed\xd7AO\x830\x18\xc6\xf1\xe9\'yo\x1c\'\x1c\x8c\x97\x1d\x86c\xa6\x911"5\xc1c\x91n\x92\x8cBJ\x97\xb8o\xef\x06\xd3\x98H\xdd\x16\x97]|~\x17\x12H\xfeyI{h\x136\x8b\xc3\x80hD=8\r\xe9\xb5R\x8bJ\x97\r\x99\x8a\xa6\x8c\'\xd4\x18\xa1r\xa1s\xea\xe53\x1e\xb3\xd4\xd2\xbb\xdb\xf6\x84\xd6bC\xb90\x82\xcc\xa6\x96t@4NYB\x96\xde\xcd\xb6\xa7\xd6e&5U\x8b\xcfrQJ\xd5\x14\x95jz{A\xca\x83hb\xfd\xdf\x93\xb51\x00\x00\x00\x00\xf87v\xc7\xc9\x84\xcd\xa3\x119>\x8b\xf8\xd8\x0f\x03\xe7\xdb\xe7!e\x85\x12zCFd+I\xf2\xddt\x87Sk\xef\xa2\xe7g\xef\xf4\xf3s\xdbs\xfb{\xee\xed\xb6\xb7\x92ji\xdev\xbd\xaf\x12\xb9\x07\xe6\xf3,\xf3\xb9\x96\x9eg\xef\xc5\xf7\xf3\xe7\x88\x1fu_X\xeaj]S-\xb4(\xa5\x91\xba\xff\x7f\x1f~\xeb\xb9?{\xcd\x81\xf5\xe0S\x16\x84\x93\xe4\x98\xf5\xe8\xb6\xcc\xa2\x90\xab\xdc^\xe5\xfc%\x0e\xda\xf5p\xc4\xfe\x95\xf3\x97\xfd\xcc\xa7\xf3\xa7Y\xd7{<Ko7_\xbb\xbeNv\xb6\xf9\xbc\xf3\xcd\x87\xfb\x1b\x00\x00\xc0\xe5\r:W\xfb\xe7\xf5\x00\x00\x00\x00\x00\x00\xac>\x00\x04\x01*\xc7\xc0!\x00\x00'
    with make_file(data, '.fits') as fname:
        d = df.load_data(fname)
        assert df.find_factory(fname) is df.tabular_data

    np.testing.assert_array_equal(d['a'], [1])
    np.testing.assert_array_equal(d['b'], [2])


@pytest.mark.parametrize(('delim', 'suffix'),
                         ((',', '.csv'),
                          ('\t', '.tsv'),
                          ('|', '.txt'),
                          (' ', '.dat'),
                          ('\t', '.tbl')))
def test_ascii_catalog_factory(delim, suffix):
    data = "#a%sb\n1%s2" % (delim, delim)
    with make_file(data, suffix) as fname:
        d = df.load_data(fname)
        assert df.find_factory(fname) is df.tabular_data

    np.testing.assert_array_equal(d['a'], [1])
    np.testing.assert_array_equal(d['b'], [2])


@pytest.mark.parametrize(('delim', 'suffix'),
                         ((',', '.csv'),
                          ('\t', '.tsv'),
                          ('|', '.txt'),
                          (' ', '.dat'),
                          ('\t', '.tbl')))
def test_pandas_parse_delimiters(delim, suffix):
    data = "a%sb\n1%s2" % (delim, delim)
    with make_file(data, suffix) as fname:
        d = df.load_data(fname, factory=df.pandas_read_table)

    print d
    np.testing.assert_array_equal(d['a'], [1])
    np.testing.assert_array_equal(d['b'], [2])


def test_fits_gz_factory():
    data = '\x1f\x8b\x08\x08\xdd\x1a}R\x00\x03test.fits\x00\xed\xd1\xb1\n\xc20\x10\xc6q\x1f\xe5\xde@ZA]\x1cZ\x8d\x10\xd0ZL\x87\xe2\x16m\x0b\x1d\x9aHR\x87n>\xba\xa5".\tRq\x11\xbe_\xe6\xfb\x93\xe3\x04\xdf\xa7;F\xb4"\x87\x8c\xa6t\xd1\xaa\xd2\xa6\xb1\xd4j\xda\xf2L\x90m\xa5*\xa4)\\\x03D1\xcfR\x9e\xbb{\xc1\xbc\xefIcdG\x85l%\xb5\xdd\xb5tW\xde\x92(\xe7\x82<\xff\x0b\xfb\x9e\xba5\xe7\xd2\x90\xae^\xe5\xba)\x95\xad\xb5\xb2\xfe^\xe0\xed\x8d6\xf4\xc2\xdf\xf5X\x9e\xb1d\xe3\xbd\xc7h\xb1XG\xde\xfb\x06_\xf4N\xecx Go\x16.\xe6\xcb\xf1\xbdaY\x00\x00\x00\x80?r\x9f<\x1f\x00\x00\x00\x00\x00|\xf6\x00\x03v\xd8\xf6\x80\x16\x00\x00'

    with make_file(data, '.fits.gz') as fname:
        d = df.load_data(fname)
        assert df.find_factory(fname) is df.gridded_data

    np.testing.assert_array_equal(d['PRIMARY'], [[0, 0], [0, 0]])


def test_csv_gz_factory():
    data = '\x1f\x8b\x08\x08z\x1e}R\x00\x03test.csv\x00\xab\xe02\xe42\xe22\xe6\x02\x00y\xffzx\x08\x00\x00\x00'
    with make_file(data, '.csv.gz') as fname:
        d = df.load_data(fname)
        assert df.find_factory(fname) is df.tabular_data

    np.testing.assert_array_equal(d['x'], [1, 2, 3])


def test_csv_pandas_factory():
    data = """a,b,c,d
1,2.1,some,True
2,2.4,categorical,False
3,1.4,data,True
4,4.0,here,True
5,6.3,,False
6,8.7,,False
8,9.2,,True"""

    with make_file(data, '.csv') as fname:
        d = df.load_data(fname, factory=df.pandas_read_table)
    assert d['a'].dtype == np.int
    assert d['b'].dtype == np.float
    assert d['c'].dtype == np.float
    cat_comp = d.find_component_id('c')
    assert isinstance(d.get_component(cat_comp), CategoricalComponent)
    correct_cats = np.unique(np.asarray(['some', 'categorical',
                                         'data', 'here',
                                         np.nan, np.nan, np.nan],
                                        dtype=np.object))
    np.testing.assert_equal(d.get_component(cat_comp)._categories,
                            correct_cats)
    cat_comp = d.find_component_id('d')
    assert isinstance(d.get_component(cat_comp), CategoricalComponent)


def test_dtype_int():
    data = '# a, b\n1, 1 \n2, 2 \n3, 3'
    with make_file(data, '.csv') as fname:
        d = df.load_data(fname)
    assert d['a'].dtype == np.int


def test_dtype_float():
    data = '# a, b\n1., 1 \n2, 2 \n3, 3'
    with make_file(data, '.csv') as fname:
        d = df.load_data(fname)
    assert d['a'].dtype == np.float


def test_dtype_float_on_categorical():
    data = '# a, b\nf, 1 \nr, 2 \nk, 3'
    with make_file(data, '.csv') as fname:
        d = df.load_data(fname)
    assert d['a'].dtype == np.float


def test_dtype_badtext():
    data = '# a, b\nlabel1, 1 \n2, 2 \n3, 3\n4, 4\n5, 5\n6, 6'
    with make_file(data, '.csv') as fname:
        d = df.load_data(fname)
    assert d['a'].dtype == np.float
    np.testing.assert_array_equal(d['a'], [np.nan, 2, 3, 4, 5, 6])


def test_dtype_missing_data_col2():
    data = '# a, b\n1 , 1 \n2,  \n3, 3.0'
    with make_file(data, '.csv') as fname:
        d = df.load_data(fname)
    assert d['b'].dtype == np.float
    np.testing.assert_array_equal(d['b'], [1, np.nan, 3])


def test_dtype_missing_data_col1():
    data = '# a, b\n1.0, 1 \n , 2 \n3, 3'
    with make_file(data, '.csv') as fname:
        d = df.load_data(fname)
    assert d['a'].dtype == np.float
    np.testing.assert_array_equal(d['a'], [1, np.nan, 3])


def test_column_spaces():
    data = '#a, b\nhere I go, 1\n2, 3\n3, 4\n5, 6\n7, 8'
    with make_file(data, '.csv') as fname:
        d = df.load_data(fname)
    assert d['a'].dtype == np.float
    np.testing.assert_array_equal(d['a'], [np.nan, 2, 3, 5, 7])


def test_casalike():
    data = 'x\xda\xed\x98Qo\xa3F\x10\xc7\xfbQ\xe6\xcd\x89\xce`v\xd9] R\x1f0\xde$$\xd8\xf8\x80Xq_*.!\xa9%\x1b\xa7@zM?}w\xc1v.\x97\xf8\xae\xc6\xfb\xd0\x07\xfe\xf2\x83e\xc9?\r\xf3\x1fvf6\xf6\xc7\xd3\x80\x03\xfc\n\x1f(\x81\x01\xdc\xad\xf3\x87u\xb1*\xa1Z\xc3\xb9\x9f\xc4PVi~\x9f\x16\xf7\xf0\xa1\x86~2\xf5o?\xe4i\x8c\x08^Z\x14\xe9\x0b\xdc\xa7U\n\xd5\xcbS\x06?\xd1\xc4\xbd\xf5c\xd8\x13\x9f\xe4\xe5\xcf\xab/Y\x01\xeb\x87-y\xb1\xca\xf2r\xb1\xce\xcb\xfd<\xb4\x87\x87\xe1`\xd5<\xac\x98g*\xe6\x91\xbd\xf9;X\xc3\xb1{\x05\x1b?\x98\xce,\xc2lF\x0cj:\x84kF+\x9e?y\xe5\x99\x14[\x84\xda\x98\x98\x8e\xd1\x927ua\xc3\xd3\x88Nm\xdbf\xb6i"\xc7p\xf8\'\x03\xb5\xe0%\xf3)\xafy=?\xafdeU/=h\xafpx\xc5\xbd\xa4\xe1y\x00&\xc1p\x0cN\xb9\x867\x13?i\x9e\xf7j>\x18rw\xfc&\xbe\xc1\xb0X<\xfeQ\xe5YY\xc2\xc9\xd3\xe2\xefly\n\xcf\xf9\xa2\xda\xcb\xe3\x9fo\xfcIx[\xfb\x8bu\xe3\x1b\t?\xcc\xc3\xe3\x8b\xdc\x11\x8f\xe7\xb1\x8c\xef\xfc\x9a\xd6?\x1d\x95\xbf \x9cLCq\x00\xca\xf8\x90n\xbf\x8d\xaf\xc5\xfb\x16\xb8\xc9\x8e\xc7\x04\xcfa\xc8\xa0\x94:\x94\xb5\xab\xbf\xa9g\x18H|\x9a\xf8\xbe\xcb\x9f\xd1\x8e\x877<C\x11\xcfT\xcc#\x8ay"\x7fX%\x0foxH]\xfe\xb0\xe2\xfca\xc5\xf93\x15\xe7\xcfT\\\x7f\xa6J?\x88\xe2\xf8D\xfe\x88\xe2\xfc\x11\xc5\xf9#\x8a\xeb\x8f\xa8\xf2\xc3\x93\xfd\xb7\x9e\xd7z\x91\xabiZ\xecO\x8e:\xef\xbdh\xe6\x06\x9b\xf9\x8f\x8a\xf9\xc5\xc0\x88 f!j\xb4;\x9f\xbd\x11\x0f\x92\x86\xa71\xdd!\xaf\x12\xf3\x0bm\x13\x9f\x18\x9fw\xf1!\xf3\xd8~\xe4\xc9~\xde\xe4\xef>{<\xbe_\xd6~\xd4\xf3no\xc4=E~`P\xd6/k?v<E~`\xc5~`\xc5~\xd4\xfbBo\x16N\x93\xe3y\xd2\x8ff\xff\xd0\xf0n\x1e\xc2\x04!\xf1\xbc\xb4\xa5\x1f\x9b}\xa69\x0f\x10c\x16\xc3\xd4\x12<\xd2\xd2\x8f7\xbc#\xcf\x17\xe9G\x93\xbf\xd5\xa0T\xe4G\xbdo\xf5\xe2$\xbc\xe6\xb1\n?\x88\xc2\xe7\x95~\xa8\xe4I?\x88b?\x9a\xfcm\x7f:*\x7f\xd3\x19\xfe\x1dm\xf6K%\xfdM\xf0\xb0B^\xc4\xe3\xe4<\xfa\\\xf3L\x9dP\x87\x99\xf6\x96\x87\x0c\x18DYY\xc1y\x91\xfd\xf9\x9c\xe5w/pr\xf9\xcf\xe9\x0fy\xf1\x94{\x9b\xfdh\xe8Fs\x8fO\x927\xfb[\xfc\x94\xddUE\xba\x84"{\xc8\n\xc1\xcc\xe0\xa1HW{\xefa\xdc \x91\x15\xb8\x8d\x8fa\xdb\xc2\x98"j\xa3&>wYeE\x9eV\x12\xb3\r\xf2\x15\xfdW\xba|\xce\xde\xf1\xe4\x05\xd1\x9ez\xf9\t\xaf\xde8\xdf\xf0f<\x88\xf8\xf9\xde\xfb\x92\x01\x82 \x8e\xfa\xe2\xdb%\x0f\xfa`\x8a\xfd;\xee\xc3\'L\x19D\xe9\xfdb\xfd\xbe\xfe\xc2\xf1X\xe4\x0c\xee\xd22\xbd[\x17\x19\xe4\xeb\\\xdb]y=\x97\xe9cv\x06D@G}\xa0p\xc1\xc3>0\x88\xc3\x9b>Xp!\xf2\xf4\xee\n\x8d\x07<\xf6\xc2\xa9\xf0\x83\xcf\x02\xf7\xe8z\x16\xf1\xf3h\xc6#\xd9\x7f\x0b\x1d\xdc\x95\x8c\x0c\xdc\xdd\xb7\xeb\xeci\x99\x1dpC1r\x13\xae\t\xa8\xe0a\x03!M|\xb0\x95\x18\xe8\x8c\x18g\x86\xa5\xd3\xda\x9a\x03"N\xfc\xf1v?\xbfI<P\xf1\xbc\x91\x0b\xea\xe65\xc1\x13s\x8b\xbayC\xf0D\x11h\xb7\xb2_"\x9d\x89\x14R\xd1\xdfL\xf1\x9a\x08\x1ek\xcd\x9bK\x1e\xd5\r\x82\x1c\xdbvlf0v\x14\xef\xb7\xe6\xfd\xa5\x94\xd8\x96\x83Mfc\xd4\x8e\'\xeb\xa5\xb9_\x93\xf5\x82\xc5L%J&A\xd6\x191\xcf(\xd6\x19\xa5u\xbd\x0cF\xf2\x15\xae\xef\x8b\x1f\x16\xcb\x0c\xbe\xa6%|-\x16U\x95\xe5\xdf\xc5\x17\xf9\x17\xf2\x06P\xf0<7v\xe5\x19\xa3\x1bp"\xde\xb8/\xe2o\x05r\x18\xc3\xa7\x07T\xd0\xa5/\xdan4\x87\x1a\x16\'n\x94@\x10^$\xee0\xe0\xad\xea\x8fOF\xd0\xa9S\xa7N\x9d:u\xea\xd4\xa9\xd3\xffE\xbft\xea\xd4\xa9S\xa7N\x9d:u\xea\xd4\xe9?\xeb_\xdc?$\x07'
    with make_file(data, '.fits', decompress=True) as fname:
        d = df.load_data(fname, factory=df.casalike_cube)

    assert d.shape == (1, 2, 2, 2)
    d['STOKES 0']
    d['STOKES 1']
    d['STOKES 2']
    d['STOKES 3']


TEST_FITS_DATA = '\x1f\x8b\x08\x08\xac\xf6\x9bQ\x00\x03test.fits\x00\xed\xd0\xb1\n\xc20\x14\x85\xe1\xaa/r\xde@\x8a\xe2\xe6\xa0X!\xa0\xa5\xd0\x0c]\xa3m\xa1C\x13I\xe2\xd0\xb7\xb7b\xc5\xa1)\xe2\xe6p\xbe\xe5N\xf7\xe7rsq\xceN\t\xb0E\x80\xc4\x12W\xa3kc[\x07op\x142\x87\xf3J\x97\xca\x96\xa1\x05`/d&\x8apo\xb3\xee{\xcaZ\xd5\xa1T^\xc1w\xb7*\\\xf9Hw\x85\xc81q_\xdc\xf7\xf4\xbd\xbdT\x16\xa6~\x97\x9b\xb6\xd2\xae1\xdaM\xf7\xe2\x89\xde\xea\xdb5cI!\x93\xf40\xf9\xbf\xdf{\xcf\x18\x11\x11\x11\x11\xfd\xad\xe8e6\xcc\xf90\x17\x11\x11\x11\x11\x11\x11\x8d<\x00\x8d,\xdc\xe8\x80\x16\x00\x00'

########NEW FILE########
__FILENAME__ = test_data_retrieval
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import numpy as np

from ..data import Data, Component


class TestDataRetrieval(object):

    def setup_method(self, method):

        data1 = Data()
        comp1 = Component(np.arange(5))
        id1 = data1.add_component(comp1, 'comp_1')
        comp2 = Component(np.arange(5) * 2)
        id2 = data1.add_component(comp2, 'comp_2')

        data2 = Data()
        comp3 = Component(np.arange(5) * 3)
        id3 = data2.add_component(comp3, 'comp_3')
        comp4 = Component(np.arange(5) * 4)
        id4 = data2.add_component(comp4, 'comp_4')

        self.data = [data1, data2]
        self.components = [comp1, comp2, comp3, comp4]
        self.component_ids = [id1, id2, id3, id4]

    def test_direct_get(self):
        assert self.data[0][self.component_ids[0]] is self.components[0].data
        assert self.data[0][self.component_ids[1]] is self.components[1].data
        assert self.data[1][self.component_ids[2]] is self.components[2].data
        assert self.data[1][self.component_ids[3]] is self.components[3].data

########NEW FILE########
__FILENAME__ = test_decorators
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103, R0903

from ..decorators import singleton, memoize, memoize_attr_check


@singleton
class SingletonOne(object):
    """test docstring"""
    pass


@singleton
class SingletonTwo(object):
    pass


class MemoAtt(object):
    def __init__(self):
        self.target = 1
        self.trigger = 0

    @memoize_attr_check('trigger')
    def test(self):
        return self.target

    @memoize_attr_check('trigger')
    def test_kwarg(self, x=0):
        return self.target + x


def test_singleton():
    f = SingletonOne()
    g = SingletonOne()
    h = SingletonTwo()
    k = SingletonTwo()
    assert f is g
    assert h is k
    assert f is not h


def test_memoize():
    class Bar(object):
        pass

    @memoize
    def func(x):
        return x.att

    b = Bar()
    b.att = 5

    assert func(b) == 5
    b.att = 7
    assert func(b) == 5  # should return memoized func


def test_memoize_attribute():
    f = MemoAtt()
    assert f.test() == 1
    f.target = 2
    assert f.test() == 1
    f.trigger = 1
    assert f.test() == 2


def test_decorators_maintain_docstrings():
    assert SingletonOne.__doc__ == "test docstring"

    @memoize
    def test():
        """test docstring"""

    assert test.__doc__ == "test docstring"

    class MemoClass(object):
        @memoize_attr_check('test')
        def test(self):
            """123"""
            pass

    assert MemoClass.test.__doc__ == "123"


def test_memoize_kwargs():

    @memoize
    def memoadd(x, y=0):
        return x + y

    assert memoadd(3) == 3
    assert memoadd(3, 2) == 5
    assert memoadd(3, y=3) == 6


def test_memoize_attribute_kwargs():

    f = MemoAtt()
    assert f.test_kwarg() == 1
    assert f.test_kwarg(x=5) == 6
    f.target = 2
    assert f.test_kwarg() == 1
    f.trigger = 1
    assert f.test_kwarg() == 2
    assert f.test_kwarg(x=6) == 8

########NEW FILE########
__FILENAME__ = test_edit_subset_mode
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import itertools

import numpy as np
import pytest

from ..edit_subset_mode import (EditSubsetMode, ReplaceMode, OrMode, AndMode,
                                XorMode, AndNotMode)
from ..subset import ElementSubsetState, SubsetState
from ..data import Component, Data
from ..data_collection import DataCollection


class TestEditSubsetMode(object):
    def setup_method(self, method):
        data = Data()
        comp = Component(np.array([1, 2, 3]))

        ind1 = np.array([0, 1])
        ind2 = np.array([1, 2])

        cid = data.add_component(comp, 'test')
        state1 = ElementSubsetState(ind1)
        state2 = ElementSubsetState(ind2)

        data.edit_subset = data.new_subset()

        data.edit_subset.subset_state = state1
        self.data = data
        self.cid = cid
        self.state1 = state1
        self.state2 = state2

    def check_mode(self, mode, expected):
        edit_mode = EditSubsetMode()
        edit_mode.mode = mode
        edit_mode.update(self.data, self.state2)
        np.testing.assert_array_equal(self.data.edit_subset.to_mask(),
                                      expected)

    def test_replace(self):
        self.check_mode(ReplaceMode, [False, True, True])

    def test_or(self):
        self.check_mode(OrMode, [True, True, True])

    def test_and(self):
        self.check_mode(AndMode, [False, True, False])

    def test_xor(self):
        self.check_mode(XorMode, [True, False, True])

    def test_and_not(self):
        self.check_mode(AndNotMode, [True, False, False])

    def test_combine_maps_over_multiselection(self):
        """If data has many edit subsets, act on all of them"""
        mode = EditSubsetMode()
        mode.mode = ReplaceMode
        for i in range(5):
            self.data.new_subset()

        self.data.edit_subset = list(self.data.subsets)

        mode.update(self.data, self.state2)
        expected = np.array([False, True, True])
        for s in self.data.subsets:
            np.testing.assert_array_equal(s.to_mask(), expected)

    def test_combine_with_collection(self):
        """A data collection input works on each data object"""
        mode = EditSubsetMode()
        mode.mode = ReplaceMode

        for i in range(5):
            self.data.new_subset()
        self.data.edit_subset = list(self.data.subsets)

        dc = DataCollection([self.data])

        mode.update(dc, self.state2)
        expected = np.array([False, True, True])
        for s in self.data.subsets:
            np.testing.assert_array_equal(s.to_mask(), expected)

    def test_combines_make_copy(self):
        mode = EditSubsetMode()
        mode.mode = ReplaceMode
        self.data.edit_subset = self.data.new_subset()
        mode.update(self.data, self.state2)
        assert self.data.edit_subset.subset_state is not self.state2


def test_invlid_update_args():
    """First argument of update must be a Data or Data Collection"""
    mode = EditSubsetMode()
    mode.mode = ReplaceMode
    with pytest.raises(TypeError) as exc:
        mode.update(None, SubsetState())
    assert exc.value.args[0].startswith('input must be a Data')

#Tests for multiselection logic
combs = list(itertools.product([True, False], [True, False],
                               [True, False], [True, False]))


@pytest.mark.parametrize(("emp", "loc", "glob", "foc"), combs)
def test_multiselect(emp, loc, glob, foc):
    """Test logic of when subsets should be updated/added, given
    the state of all editable subsets in a data collection.

    We consider four variables. The first data set in the collection
    is tested, and considired the 'local' data
    :param emp: Is the local set empty (i.e. no subsets)?
    :param loc: Are any of the local subsets editable?
    :param glob: Are any non-local subsets editable?
    :param foc: Does the local dataset have focus?
    """
    if emp and loc:  # can't be empty with selections
        return
    dc, state = setup_multi(emp, loc, glob, foc)
    did_add, did_apply = apply(dc, state, foc)
    assert did_add == should_add(emp, loc, glob, foc)
    assert did_apply == should_apply(emp, loc, glob, foc)


def setup_multi(empty, local_select, global_select, focus):
    d1 = Data()
    d2 = Data()
    dc = DataCollection([d1, d2])
    EditSubsetMode().data_collection = dc

    d2.new_subset()
    if not empty:
        d1.new_subset()
    if (not empty) and local_select:
        d1.edit_subset = d1.subsets[0]

    if global_select:
        d2.edit_subset = d2.subsets[0]

    state = SubsetState()
    return dc, state


def should_add(emp, loc, glob, foc):
    return foc and not (loc or glob)


def should_apply(emp, loc, glob, foc):
    return loc and not emp


def apply(dc, state, focus=False):
    """Update data collection, return did_add, did_apply for
    first data object"""

    ct = len(dc[0].subsets)

    sub = dc[0].edit_subset
    if isinstance(sub, list):
        sub = None if len(sub) == 0 else sub[0]

    old_state = None
    if sub is not None:
        old_state = sub.subset_state

    mode = EditSubsetMode()
    mode.mode = ReplaceMode
    mode.update(dc, state, dc[0] if focus else None)

    print len(dc[0].subsets)
    did_add = len(dc[0].subsets) > ct
    did_apply = sub is not None and sub.subset_state is not old_state
    return did_add, did_apply

########NEW FILE########
__FILENAME__ = test_fitters
import pytest

from mock import MagicMock
import numpy as np

needs_modeling = pytest.mark.skipif(False, reason='')

try:
    from astropy.modeling.models import Gaussian1D
    from astropy.modeling.fitting import NonLinearLSQFitter
    from ..fitters import SimpleAstropyGaussianFitter
except ImportError:
    needs_modeling = pytest.mark.skipif(True,
                                        reason='Requires astropy >= v0.3')

from ..fitters import (PolynomialFitter, IntOption,
                       BasicGaussianFitter)


@needs_modeling
class TestAstropyFitter(object):

    def test_fit(self):

        f = SimpleAstropyGaussianFitter(amplitude=1, mean=2, stddev=3)
        f.fitting_cls = fitter = MagicMock()

        f.build_and_fit([1, 2, 3], [2, 3, 4])
        (model, x, y), kwargs = fitter().call_args

        assert model.amplitude == 1
        assert model.mean == 2
        assert model.stddev == 3

        np.testing.assert_array_equal(x, [1, 2, 3])
        np.testing.assert_array_equal(y, [2, 3, 4])

    def test_fit_converts_errors_to_weights(self):
        f = SimpleAstropyGaussianFitter(amplitude=1, mean=2, stddev=3)
        f.fitting_cls = fitter = MagicMock()
        f.build_and_fit([1, 2, 3], [2, 3, 4], [3, 4, 5])

        args, kwargs = fitter().call_args
        np.testing.assert_array_equal(kwargs['weights'],
                                      1. / np.array([3., 4., 5]) ** 2)

    def test_fit_returns_model_and_fitter(self):
        f = SimpleAstropyGaussianFitter(amplitude=1, mean=2, stddev=3)
        model, fitter = f.build_and_fit([1, 2, 3], [2, 3, 4])
        assert isinstance(model, Gaussian1D)
        assert isinstance(fitter, NonLinearLSQFitter)

    def test_predict_uses_model(self):
        f = SimpleAstropyGaussianFitter(amplitude=1, mean=2, stddev=3)
        result = f.build_and_fit([1, 2, 3], [2, 3, 4])
        model, _ = result
        np.testing.assert_array_equal(model([3]),
                                      f.predict(result, [3]))

    def test_summarize(self):
        f = SimpleAstropyGaussianFitter(amplitude=1, mean=2, stddev=3)
        model, fitter = f.build_and_fit([1, 2, 3], [2, 3, 4])

        expected = ["Converged in %i iterations" % fitter.fit_info['nfev'],
                    "",
                    "amplitude = %e" % model.amplitude.value,
                    "mean      = %e" % model.mean.value,
                    "stddev    = %e" % model.stddev.value
                    ]
        expected = '\n'.join(expected)
        actual = f.summarize((model, fitter), [1, 2, 3], [2, 3, 4])
        assert expected == actual

    def test_range_constraints(self):
        f = SimpleAstropyGaussianFitter(amplitude=1, mean=0, stddev=1)
        x = np.linspace(0, 10, 10)
        y = np.exp(-x ** 2 / 2)
        f.set_constraint('mean', limits=[1, 2])

        model, fitter = f.build_and_fit(x, y)
        np.testing.assert_almost_equal(model.mean.value, 1)

    def test_fixed_constraints(self):
        f = SimpleAstropyGaussianFitter(amplitude=1.5, mean=0, stddev=1)
        x = np.linspace(-5, 5, 10)
        y = np.exp(-x ** 2 / 2)
        f.set_constraint('amplitude', fixed=True)

        model, fitter = f.build_and_fit(x, y)
        np.testing.assert_almost_equal(model.amplitude.value, 1.5)


class TestPolynomialFitter(object):

    def test_fit(self):
        f = PolynomialFitter()
        result = f.build_and_fit([1, 2, 3], [2, 3, 4])
        expected = np.polyfit([1, 2, 3], [2, 3, 4], 3)
        np.testing.assert_array_equal(result, expected)

    def test_predict(self):
        f = PolynomialFitter(degree=1)
        fit = f.build_and_fit([1, 2, 3], [2, 3, 4])
        result = f.predict(fit, [4])
        expected = [5]
        np.testing.assert_almost_equal(result, expected)

    def test_summarize(self):
        f = PolynomialFitter(degree=1)
        fit = f.build_and_fit([1, 2, 3], [2, 3, 4])

        assert f.summarize(
            fit, [1, 2, 3], [2, 3, 4]) == "Coefficients:\n%e\n%e" % (1, 1)


class TestOptions(object):

    def test_options(self):
        p = PolynomialFitter(degree=3)
        assert p.options == {'degree': 3}

    def test_inherited(self):
        class Inherit(PolynomialFitter):
            test = IntOption(default=5)
        assert Inherit().options == dict(degree=3, test=5)

    def test_options_passed_to_fit(self):

        p = PolynomialFitter(degree=4)
        p.fit = MagicMock()

        p.build_and_fit([1, 2, 3], [2, 3, 4])
        assert p.fit.call_args[1]['degree'] == 4


@needs_modeling
class TestFitWrapper(object):

    def setup_method(self, method):
        f = SimpleAstropyGaussianFitter(amplitude=1, mean=2, stddev=3)
        f.fit = MagicMock()
        self.x = [1, 2, 3]
        self.y = [2, 3, 4]
        self.f = f

    def call_info(self):
        return self.f.fit.call_args

    def test_basic(self):
        self.f.build_and_fit(self.x, self.y)
        (x, y), kwargs = self.call_info()
        assert kwargs['constraints'] == {'amplitude': dict(value=1,
                                                           fixed=False,
                                                           limits=None),
                                         'mean': dict(value=2,
                                                      fixed=False,
                                                      limits=None),
                                         'stddev': dict(value=3,
                                                        fixed=False,
                                                        limits=None)}
        np.testing.assert_array_equal(x, self.x)
        np.testing.assert_array_equal(y, self.y)


@needs_modeling
class TestSetConstraints(object):

    def test(self):
        f = SimpleAstropyGaussianFitter(amplitude=1, mean=2, stddev=3)
        f.set_constraint('amplitude', value=3, fixed=True)
        f.set_constraint('mean', limits=[1, 2])
        assert f.constraints == {
            'amplitude': dict(value=3, fixed=True, limits=None),
            'mean': dict(value=2, fixed=False, limits=[1, 2]),
            'stddev': dict(value=3, fixed=False, limits=None)
        }


class TestBasicGaussianFitter(object):

    def test(self):

        f = BasicGaussianFitter()

        x = np.linspace(-10, 10)
        y = np.exp(-x ** 2)
        r = f.build_and_fit(x, y)

        expected = [3.67879441e-01, 1.83156389e-02, 1.23409804e-04]
        np.testing.assert_array_almost_equal(f.predict(r, [1, 2, 3]),
                                             expected)

########NEW FILE########
__FILENAME__ = test_hub
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest
from mock import MagicMock

from ..exceptions import InvalidSubscriber, InvalidMessage
from ..message import SubsetMessage, Message
from ..hub import Hub, HubListener
from ..subset import Subset
from ..data import Data
from ..data_collection import DataCollection


class TestHub(object):

    def setup_method(self, method):
        self.hub = Hub()

    def get_subscription(self):
        msg = Message
        handler = MagicMock()
        subscriber = MagicMock(spec_set=HubListener)
        return msg, handler, subscriber

    def test_subscribe(self):
        msg, handler, subscriber = self.get_subscription()
        self.hub.subscribe(subscriber, msg, handler)
        assert self.hub.is_subscribed(subscriber, msg)
        assert self.hub.get_handler(subscriber, msg) == handler

    def test_get_handler(self):
        msg, handler, subscriber = self.get_subscription()
        self.hub.subscribe(subscriber, msg, handler)
        assert self.hub.get_handler(subscriber, msg) == handler
        assert self.hub.get_handler(subscriber, None) is None
        assert self.hub.get_handler(None, msg) is None

    def test_unsubscribe(self):
        msg, handler, subscriber = self.get_subscription()
        self.hub.subscribe(subscriber, msg, handler)
        self.hub.unsubscribe(subscriber, msg)

        assert not self.hub.is_subscribed(subscriber, msg)
        assert self.hub.get_handler(subscriber, msg) is None

    def test_unsubscribe_all(self):
        msg, handler, subscriber = self.get_subscription()
        msg2 = SubsetMessage
        self.hub.subscribe(subscriber, msg, handler)
        self.hub.subscribe(subscriber, msg2, handler)
        self.hub.unsubscribe_all(subscriber)
        assert not self.hub.is_subscribed(subscriber, msg)
        assert not self.hub.is_subscribed(subscriber, msg2)

    def test_unsubscribe_specific_to_message(self):
        msg, handler, subscriber = self.get_subscription()
        msg2 = SubsetMessage
        self.hub.subscribe(subscriber, msg, handler)
        self.hub.subscribe(subscriber, msg2, handler)
        self.hub.unsubscribe(subscriber, msg)
        assert not self.hub.is_subscribed(subscriber, msg)
        assert self.hub.is_subscribed(subscriber, msg2)

    def test_broadcast(self):
        msg, handler, subscriber = self.get_subscription()
        self.hub.subscribe(subscriber, msg, handler)
        msg_instance = msg("Test")
        self.hub.broadcast(msg_instance)
        handler.assert_called_once_with(msg_instance)

    def test_unsubscribe_halts_broadcast(self):
        msg, handler, subscriber = self.get_subscription()
        self.hub.subscribe(subscriber, msg, handler)
        self.hub.unsubscribe(subscriber, msg)
        msg_instance = msg("Test")
        self.hub.broadcast(msg_instance)
        assert handler.call_count == 0

    def test_unsubscribe_spec_setific_to_message(self):
        msg, handler, subscriber = self.get_subscription()
        msg2 = SubsetMessage
        self.hub.subscribe(subscriber, msg2, handler)
        msg_instance = msg("Test")
        self.hub.broadcast(msg_instance)
        assert handler.call_count == 0

    def test_subscription_catches_message_subclasses(self):
        msg, handler, subscriber = self.get_subscription()
        msg2 = SubsetMessage
        self.hub.subscribe(subscriber, msg, handler)
        msg_instance = msg2(MagicMock(spec_set=Subset))
        self.hub.broadcast(msg_instance)
        handler.assert_called_once_with(msg_instance)

    def test_handler_ignored_if_subset_handler_present(self):
        msg, handler, subscriber = self.get_subscription()
        handler2 = MagicMock()
        msg2 = SubsetMessage
        self.hub.subscribe(subscriber, msg, handler)
        self.hub.subscribe(subscriber, msg2, handler2)
        msg_instance = SubsetMessage(Subset(None))
        self.hub.broadcast(msg_instance)
        handler2.assert_called_once_with(msg_instance)
        assert handler.call_count == 0

    def test_filter(self):
        msg, handler, subscriber = self.get_subscription()
        filter = lambda x: False
        self.hub.subscribe(subscriber, msg, handler)
        msg_instance = msg("Test")
        self.hub.broadcast(msg)
        assert handler.call_count == 0

    def test_broadcast_sends_to_all_subsribers(self):
        msg, handler, subscriber = self.get_subscription()
        msg, handler2, subscriber2 = self.get_subscription()

        self.hub.subscribe(subscriber, msg, handler)
        self.hub.subscribe(subscriber2, msg, handler2)
        msg_instance = msg("Test")
        self.hub.broadcast(msg_instance)
        handler.assert_called_once_with(msg_instance)
        handler2.assert_called_once_with(msg_instance)

    def test_invalid_unsubscribe_ignored(self):
        msg, handler, subscriber = self.get_subscription()
        self.hub.unsubscribe(handler, subscriber)

    def test_invalid_subscribe(self):

        msg, handler, subscriber = self.get_subscription()

        with pytest.raises(InvalidSubscriber) as exc:
            self.hub.subscribe(None, msg, handler)
        assert exc.value.args[0].startswith("Subscriber must be a HubListener")

        with pytest.raises(InvalidMessage) as exc:
            self.hub.subscribe(subscriber, None, handler)
        assert exc.value.args[0].startswith("message class must be "
                                            "a subclass of glue.Message")

    def test_default_handler(self):
        msg, handler, subscriber = self.get_subscription()
        self.hub.subscribe(subscriber, msg)
        msg_instance = msg("Test")

        self.hub.broadcast(msg_instance)
        subscriber.notify.assert_called_once_with(msg_instance)

    def test_autosubscribe(self):
        l = MagicMock(spec_set=HubListener)
        d = MagicMock(spec_set=Data)
        s = MagicMock(spec_set=Subset)
        dc = MagicMock(spec_set=DataCollection)
        hub = Hub(l, d, s, dc)

        l.register_to_hub.assert_called_once_with(hub)
        d.register_to_hub.assert_called_once_with(hub)
        dc.register_to_hub.assert_called_once_with(hub)
        s.register.assert_called_once_with()

    def test_invalid_init(self):
        with pytest.raises(TypeError) as exc:
            Hub(None)
        assert exc.value.args[0] == ("Inputs must be HubListener, data, "
                                     "subset, or data collection objects")


class TestHubListener(object):
    """This is a dumb test, I know. Fixated on code coverage"""
    def test_unimplemented(self):
        hl = HubListener()
        with pytest.raises(NotImplementedError):
            hl.register_to_hub(None)
        with pytest.raises(NotImplementedError):
            hl.notify(None)

########NEW FILE########
__FILENAME__ = test_links
"""This file contains tests concerning linking data and accessing
linked components"""

from glue.core import Data, DataCollection
from glue.core.link_helpers import LinkSame
import numpy as np
from numpy.random import random as r


def test_1d_world_link():
    x, y = r(10), r(10)
    d1 = Data(label='d1', x=x)
    d2 = Data(label='d2', y=y)
    dc = DataCollection([d1, d2])

    dc.add_link(LinkSame(d2.get_world_component_id(0), d1.id['x']))

    assert d2.get_world_component_id(0) in d1.components
    np.testing.assert_array_equal(d1[d2.get_world_component_id(0)], x)
    np.testing.assert_array_equal(d1[d2.get_pixel_component_id(0)], x)


def test_3d_world_link():
    """Should be able to grab pixel coords after linking world"""
    x, y, z = r(10), r(10), r(10)
    cat = Data(label='cat', x=x, y=y, z=z)
    im = Data(label='im', inten=r((3, 3, 3)))

    dc = DataCollection([cat, im])

    dc.add_link(LinkSame(im.get_world_component_id(2), cat.id['x']))
    dc.add_link(LinkSame(im.get_world_component_id(1), cat.id['y']))
    dc.add_link(LinkSame(im.get_world_component_id(0), cat.id['z']))

    np.testing.assert_array_equal(cat[im.get_pixel_component_id(2)], x)
    np.testing.assert_array_equal(cat[im.get_pixel_component_id(1)], y)
    np.testing.assert_array_equal(cat[im.get_pixel_component_id(0)], z)


def test_2d_world_link():
    """Should be able to grab pixel coords after linking world"""

    x, y = r(10), r(10)
    cat = Data(label='cat', x=x, y=y)
    im = Data(label='im', inten=r((3, 3)))

    dc = DataCollection([cat, im])

    dc.add_link(LinkSame(im.get_world_component_id(0), cat.id['x']))
    dc.add_link(LinkSame(im.get_world_component_id(1), cat.id['y']))

    np.testing.assert_array_equal(cat[im.get_pixel_component_id(0)], x)
    np.testing.assert_array_equal(cat[im.get_pixel_component_id(1)], y)

########NEW FILE########
__FILENAME__ = test_link_helpers
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest
import numpy as np

from .. import link_helpers as lh
from ..link_helpers import (LinkTwoWay, MultiLink, Galactic2Equatorial,
                            lb2ra, lb2dec, radec2glon, radec2glat,
                            LinkSame, LinkAligned)
from ...core import ComponentID, ComponentLink, Data, Component, DataCollection
from ...external.aplpy import fk52gal, gal2fk5

R, D, L, B = (ComponentID('ra'), ComponentID('dec'),
              ComponentID('lon'), ComponentID('lat'))


def forwards(x, y):
    print 'forwads inputs', x, y
    return x * 3, y * 5


def backwards(x, y):
    print 'backwards inputs', x, y
    return x / 3, y / 5


def check_link(link, from_, to, using=None):
    assert link.get_from_ids() == from_
    assert link.get_to_id() == to
    if using:
        assert link.get_using() == using


def check_using(link, inp, out):
    np.testing.assert_array_almost_equal(link.get_using()(*inp), out)


def test_LinkTwoWay():
    result = LinkTwoWay(R, D, forwards, backwards)
    check_link(result[0], [R], D, forwards)
    check_link(result[1], [D], R, backwards)


def test_multilink_forwards():
    result = MultiLink([R, D], [L, B], forwards)
    assert len(result) == 2
    check_link(result[0], [R, D], L)
    check_link(result[1], [R, D], B)
    check_using(result[0], (3, 4), 9)
    check_using(result[1], (3, 4), 20)


def test_multilink_backwards():
    result = MultiLink([R, D], [L, B], backwards=backwards)
    assert len(result) == 2
    check_link(result[0], [L, B], R)
    check_link(result[1], [L, B], D)
    check_using(result[0], (9, 20), 3)
    check_using(result[1], (9, 20), 4)


def test_multilink_forwards_backwards():
    result = MultiLink([R, D], [L, B], forwards, backwards)
    assert len(result) == 4
    check_link(result[0], [R, D], L)
    check_link(result[1], [R, D], B)
    check_link(result[2], [L, B], R)
    check_link(result[3], [L, B], D)
    check_using(result[0], (3, 4), 9)
    check_using(result[1], (3, 4), 20)
    check_using(result[2], (9, 20), 3)
    check_using(result[3], (9, 20), 4)


def test_Galactic2Equatorial():
    result = Galactic2Equatorial(L, B, R, D)
    assert len(result) == 4
    check_link(result[0], [R, D], L)
    check_link(result[1], [R, D], B)
    check_link(result[2], [L, B], R)
    check_link(result[3], [L, B], D)
    x = np.array([0])
    y = np.array([0])
    check_using(result[0], (x, y), fk52gal(x, y)[0])
    check_using(result[1], (x, y), fk52gal(x, y)[1])
    check_using(result[2], (x, y), gal2fk5(x, y)[0])
    check_using(result[3], (x, y), gal2fk5(x, y)[1])


def test_galactic2equatorial_individual():

    r = ComponentLink([L, B], R, lb2ra)
    d = ComponentLink([L, B], R, lb2dec)
    l = ComponentLink([R, D], L, radec2glon)
    b = ComponentLink([R, D], B, radec2glat)

    x = np.array([0])
    y = np.array([0])
    check_using(l, (x, y), fk52gal(x, y)[0])
    check_using(b, (x, y), fk52gal(x, y)[1])
    check_using(r, (x, y), gal2fk5(x, y)[0])
    check_using(d, (x, y), gal2fk5(x, y)[1])


def test_multilink_nofunc():
    with pytest.raises(TypeError) as exc:
        MultiLink([R, D], [L, B])
    assert exc.value.args[0] == "Must supply either forwards or backwards"


def test_linksame_string():
    """String inputs auto-converted to component IDs"""
    #ComponentLink does type checking to ensure conversion happens
    links = LinkSame('a', 'b')


def test_identity():
    assert lh.identity('3') == '3'


def test_toid():
    assert lh._toid('test').label == 'test'

    cid = ComponentID('test2')
    assert lh._toid(cid) is cid

    with pytest.raises(TypeError) as exc:
        lh._toid(None)


@pytest.mark.parametrize(('ndata', 'ndim'),
                         [(1, 1), (2, 0), (2, 1), (2, 2), (3, 2)])
def test_link_aligned(ndata, ndim):
    ds = []
    shp = tuple([2] * ndim)
    for i in range(ndata):
        d = Data()
        c = Component(np.random.random(shp))
        d.add_component(c, 'test')
        ds.append(d)

    #assert that all componentIDs are interchangeable
    links = LinkAligned(ds)
    dc = DataCollection(ds)
    dc.add_link(links)

    for i in range(ndim):
        id0 = ds[0].get_pixel_component_id(i)
        for j in range(1, ndata):
            id1 = ds[j].get_pixel_component_id(i)
            np.testing.assert_array_equal(ds[j][id0], ds[j][id1])

########NEW FILE########
__FILENAME__ = test_link_manager
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import numpy as np

from ..data import Data, Component
from ..component_link import ComponentLink
from ..link_manager import (LinkManager, accessible_links, discover_links,
                            find_dependents)
from ..data import ComponentID, DerivedComponent
from ..data_collection import DataCollection

comp = Component(data=np.array([1, 2, 3]))


def example_components(self, add_derived=True):
    """ Link Topology

           --- c1---c3--\
    data --|             --c5,c6   (c7,c8 disconnected)
           --- c2---c4--/
    """
    self.data = Data()
    c1 = ComponentID('c1')
    c2 = ComponentID('c2')
    c3 = ComponentID('c3')
    c4 = ComponentID('c4')
    c5 = ComponentID('c5')
    c6 = ComponentID('c6')
    c7 = ComponentID('c7')
    c8 = ComponentID('c8')

    dummy_using = lambda x, y: (x, y)
    self.cs = [c1, c2, c3, c4, c5, c6, c7, c8]
    self.links = [ComponentLink([c1], c3, lambda x:x),
                  ComponentLink([c2], c4, lambda x:x),
                  ComponentLink([c3], c1, lambda x:x),
                  ComponentLink([c4], c2, lambda x:x),
                  ComponentLink([c3, c4], c5, dummy_using),
                  ComponentLink([c3, c4], c6, dummy_using)]

    self.data.add_component(comp, c1)
    self.data.add_component(comp, c2)
    if add_derived:
        for i in [0, 1, 4, 5]:
            dc = DerivedComponent(self.data, self.links[i])
            self.data.add_component(dc, dc.link.get_to_id())

    self.primary = [c1, c2]
    self.direct = [c3, c4]
    self.derived = [c5, c6]
    self.inaccessible = [c7, c8]


class TestAccessibleLinks(object):

    def setup_method(self, method):
        self.cs = [ComponentID("%i" % i) for i in xrange(10)]

    def test_returned_if_available(self):
        cids = self.cs[0:5]
        links = [ComponentLink([self.cs[0]], self.cs[1])]
        assert links[0] in accessible_links(cids, links)

    def test_returned_if_reachable(self):
        cids = self.cs[0:5]
        links = [ComponentLink([self.cs[0]], self.cs[6])]
        assert links[0] in accessible_links(cids, links)

    def test_not_returned_if_not_reachable(self):
        cids = self.cs[0:5]
        links = [ComponentLink([self.cs[6]], self.cs[7])]
        assert not links[0] in accessible_links(cids, links)


class TestDiscoverLinks(object):
    def setup_method(self, method):
        example_components(self)

    def test_correct_discover(self):
        """discover_links finds the correct links"""
        links = discover_links(self.data, self.links)

        for i in self.inaccessible:
            assert not i in links

        for d in self.direct:
            assert d in links

        for d in self.derived:
            assert d in links

        for p in self.primary:
            assert not p in links

    def test_links_point_to_proper_ids(self):
        """ Dictionary values are ComponentLinks which
        point to the keys """
        links = discover_links(self.data, self.links)
        for cid in links:
            assert cid == links[cid].get_to_id()

    def test_shortest_path(self):
        """ Shortcircuit c5 to c1, yielding 2 ways to get to c5.
        Ensure that the shortest path is chosen """
        self.links.append(ComponentLink([self.cs[0]], self.cs[4]))
        links = discover_links(self.data, self.links)

        assert links[self.cs[4]] is self.links[-1]


class TestFindDependents(object):
    def setup_method(self, method):
        example_components(self)

    def test_propagated(self):
        to_remove = self.links[0]
        result = find_dependents(self.data, to_remove)
        expected = set([self.cs[2], self.cs[4], self.cs[5]])
        assert expected == result

    def test_basic(self):
        to_remove = self.links[4]
        result = find_dependents(self.data, to_remove)
        expected = set([self.cs[4]])
        assert expected == result


class TestLinkManager(object):

    def test_add_links(self):
        id1 = ComponentID('id1')
        id2 = ComponentID('id2')
        id3 = ComponentID('id3')
        lm = LinkManager()
        using = lambda x, y: 0
        link = ComponentLink([id1, id2], id3, using)
        lm.add_link(link)
        links = lm.links
        assert links == [link]

    def test_remove_link(self):
        id1 = ComponentID('id1')
        id2 = ComponentID('id2')
        id3 = ComponentID('id3')
        lm = LinkManager()
        using = lambda x, y: 0
        link = ComponentLink([id1, id2], id3, using)
        lm.add_link(link)
        lm.remove_link(link)
        links = lm.links
        assert links == []

    def test_setup(self):
        example_components(self, add_derived=False)
        expected = set()
        assert set(self.data.derived_components) == expected

    def test_update_data_components_adds_correctly(self):
        example_components(self, add_derived=False)
        lm = LinkManager()
        map(lm.add_link, self.links)

        lm.update_data_components(self.data)
        derived = set(self.data.derived_components)
        expected = set(self.derived + self.direct)
        assert derived == expected

    def test_update_data_components_removes_correctly(self):
        #add all but last link to manager
        example_components(self, add_derived=False)
        lm = LinkManager()
        map(lm.add_link, self.links[:-1])

        #manually add last link as derived component
        dc = DerivedComponent(self.data, self.links[-1])
        self.data.add_component(dc, dc.link.get_to_id())
        removed = set([dc.link.get_to_id()])
        assert dc.link.get_to_id() in self.data.derived_components

        # this link should be removed upon update_components
        lm.update_data_components(self.data)
        derived = set(self.data.derived_components)
        expected = set(self.direct + self.derived) - removed
        assert derived == expected

    def test_derived_links_correctwith_mergers(self):
        """When the link manager merges components, links that depend on the
        merged components remain functional"""
        from ..link_helpers import LinkSame

        d1 = Data(x=[[1, 2], [3, 4]])
        d2 = Data(u=[[5, 6], [7, 8]])

        dc = DataCollection([d1, d2])

        #link world coordinates...
        dc.add_link(LinkSame(
            d1.get_world_component_id(0), d2.get_world_component_id(0)))
        dc.add_link(LinkSame(
            d1.get_world_component_id(1), d2.get_world_component_id(1)))

        #and then retrieve pixel coordinates
        np.testing.assert_array_equal(
            d2[d1.get_pixel_component_id(0)], [[0, 0], [1, 1]])
        np.testing.assert_array_equal(
            d1[d2.get_pixel_component_id(1)], [[0, 1], [0, 1]])

    def test_binary_links_correct_with_mergers(self):
        """Regression test. BinaryComponentLinks should work after mergers"""
        from ..link_helpers import LinkSame

        d1 = Data(x=[1, 2, 3], y=[2, 3, 4])
        d2 = Data(u=[2, 3, 4], v=[3, 4, 5])

        z = d1.id['x'] + d1.id['y']
        d1.add_component_link(z, 'z')

        dc = DataCollection([d1, d2])
        dc.add_link(LinkSame(d2.id['u'], d1.id['x']))
        assert d1.find_component_id('x') is None

        np.testing.assert_array_equal(d1['z'], [3, 5, 7])

    def test_complex_links_correct_with_mergers(self):
        """Regression test. multi-level links should work after mergers"""
        from ..link_helpers import LinkSame

        d1 = Data(x=[1, 2, 3], y=[2, 3, 4])
        d2 = Data(u=[2, 3, 4], v=[3, 4, 5])

        z = d1.id['x'] + d1.id['y'] + 5
        d1.add_component_link(z, 'z')

        dc = DataCollection([d1, d2])
        dc.add_link(LinkSame(d2.id['u'], d1.id['x']))
        assert d1.find_component_id('x') is None

        np.testing.assert_array_equal(d1['z'], [8, 10, 12])

########NEW FILE########
__FILENAME__ = test_message
import pytest
from .. import message as msg


def test_invalid_subset_msg():
    with pytest.raises(TypeError) as exc:
        msg.SubsetMessage(None)
    assert exc.value.args[0].startswith('Sender must be a subset')


def test_invalid_data_msg():
    with pytest.raises(TypeError) as exc:
        msg.DataMessage(None)
    assert exc.value.args[0].startswith('Sender must be a data')


def test_invalid_data_collection_msg():
    with pytest.raises(TypeError) as exc:
        msg.DataCollectionMessage(None)
    assert exc.value.args[0].startswith('Sender must be a DataCollection')

########NEW FILE########
__FILENAME__ = test_pandas
import operator

from mock import MagicMock
import pytest
import numpy as np
import pandas as pd
from pandas.util.testing import (assert_series_equal,
                                 assert_frame_equal)

from ..data import (Component, ComponentID, Data,
                    DerivedComponent, CoordinateComponent,
                    CategoricalComponent)
from ... import core


class TestPandasConversion(object):

    def test_Component_conversion(self):

        comp = Component(np.arange(5))
        series = pd.Series(np.arange(5))

        assert_series_equal(series, comp.to_series())

    def test_DerivedComponent_conversion(self):

        data = MagicMock()
        link = MagicMock()
        link.compute.return_value = np.arange(5)
        comp = DerivedComponent(data, link)

        series = pd.Series(np.arange(5))
        assert_series_equal(series, comp.to_series())

    def test_CategoricalComponent_conversion(self):

        comp = CategoricalComponent(np.array(['a', 'b', 'c', 'd']))
        series = pd.Series(['a', 'b', 'c', 'd'])

        assert_series_equal(series, comp.to_series())

    def test_CoordinateComponent_conversion(self):

        d = Data(x=[1, 2, 3])
        series = pd.Series([0, 1, 2])
        comp = d.get_component(d.get_pixel_component_id(0))
        assert_series_equal(series, comp.to_series())

    def test_Data_conversion(self):

        d = Data(n=[4, 5, 6, 7])
        cat_comp = CategoricalComponent(np.array(['a', 'b', 'c', 'd']))
        d.add_component(cat_comp, 'c')
        link = MagicMock()
        link.compute.return_value = np.arange(4)
        deriv_comp = DerivedComponent(d, link)
        d.add_component(deriv_comp, 'd')
        order = [comp.label for comp in d.components]

        frame = pd.DataFrame({
            'n': [4, 5, 6, 7],
            'c': ['a', 'b', 'c', 'd'],
            'd': np.arange(4),
            'Pixel Axis 0': np.arange(4),
            'World 0': np.arange(4)
        })
        out_frame = d.to_dataframe()
        assert_frame_equal(out_frame, frame)
        assert list(out_frame.columns) == order

    def test_multi_dimensional(self):

        a = np.array([[2, 3], [5, 4], [6, 7]])
        comp = Component(a)
        series = pd.Series(a.ravel())

        assert_series_equal(series, comp.to_series())

########NEW FILE########
__FILENAME__ = test_parse
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest
import numpy as np
from mock import MagicMock

from ..data import ComponentID, Component, Data
from ..subset import Subset
from .. import parse


class TestParse(object):

    def test_re_matches_valid_names(self):
        reg = parse.TAG_RE
        valid = ['{a}', '{ a }', '{A}', '{a }', '{ a}',
                 '{a_}', '{abc_1}', '{_abc_1}', '{1}', '{1_}']
        invalid = ['', '{}', '{a b}']
        for v in valid:
            assert reg.match(v) is not None
        for i in invalid:
            assert reg.match(i) is None

    def test_group(self):
        reg = parse.TAG_RE
        assert reg.match('{a}').group('tag') == 'a'
        assert reg.match('{ a }').group('tag') == 'a'
        assert reg.match('{ A }').group('tag') == 'A'
        assert reg.match('{ Abc_ }').group('tag') == 'Abc_'

    def test_reference_list(self):
        cmd = '{a} - {b} + {c}'
        refs = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
        expected = set([1, 2, 3])
        result = set(parse._reference_list(cmd, refs))
        assert expected == result

    def test_reference_list_invalid_cmd(self):
        with pytest.raises(KeyError) as exc:
            parse._reference_list('{a}', {})
        assert exc.value.args[0] == ("Tags from command not in "
                                     "reference mapping")

    def test_dereference(self):
        c1 = ComponentID('c1')
        c2 = ComponentID('c2')
        s1 = Subset(None, label='s1')
        s2 = Subset(None, label='s2')
        refs = dict([('c1', c1), ('c2', c2), ('s1', s1), ('s2', s2)])
        cmd = '({c1} > 10) and {s1}'
        expected = ('(data[references["c1"], __view] > 10) and '
                    'references["s1"].to_mask(__view)')
        result = parse._dereference(cmd, refs)
        assert expected == result

    def test_validate(self):
        ref = {'a': 1, 'b': 2}
        parse._validate('{a} + {b}', ref)
        parse._validate('{a}', ref)
        parse._validate('3 + 4', ref)
        with pytest.raises(TypeError) as exc:
            parse._validate('{c}', ref)
        assert exc.value.args[0] == ("Tag c not in reference mapping: "
                                     "['a', 'b']")

    def test_ensure_only_component_references(self):
        ref = {'a': 1, 'b': ComponentID('b')}
        F = parse._ensure_only_component_references
        F('{b} + 5', ref)
        with pytest.raises(TypeError) as exc:
            F('{b} + {a}', ref)
        assert exc.value.args[0] == ("Reference to a, which is not a "
                                     "ComponentID")
        with pytest.raises(TypeError) as exc:
            F('{b} + {d}', ref)
        assert exc.value.args[0] == ("Reference to d, which is not a "
                                     "ComponentID")


class TestParsedCommand(object):

    def test_evaluate_component(self):
        data = MagicMock()
        c1 = ComponentID('c1')
        data.__getitem__.return_value = 5
        cmd = '{comp1} * 5'
        refs = {'comp1': c1}
        pc = parse.ParsedCommand(cmd, refs)
        assert pc.evaluate(data) == 25
        data.__getitem__.assert_called_once_with((c1, None))

    def test_evaluate_subset(self):
        sub = MagicMock(spec_set=Subset)
        sub2 = MagicMock(spec_set=Subset)
        sub.to_mask.return_value = 3
        sub2.to_mask.return_value = 4
        cmd = '{s1} and {s2}'
        refs = {'s1': sub, 's2': sub2}
        pc = parse.ParsedCommand(cmd, refs)
        assert pc.evaluate(None) == (3 and 4)

    def test_evaluate_function(self):
        data = MagicMock()
        c1 = ComponentID('c1')
        data.__getitem__.return_value = 5
        cmd = 'max({comp1}, 100)'
        refs = {'comp1': c1}
        pc = parse.ParsedCommand(cmd, refs)
        assert pc.evaluate(data) == 100
        data.__getitem__.assert_called_once_with((c1, None))


class TestParsedComponentLink(object):

    def make_link(self):
        data = Data()
        comp = Component(np.array([1, 2, 3]))
        c1 = ComponentID('c1')
        c2 = ComponentID('c2')
        data.add_component(comp, c1)

        cmd = '{comp1} * 100'
        refs = {'comp1': c1}
        pc = parse.ParsedCommand(cmd, refs)

        cl = parse.ParsedComponentLink(c2, pc)
        data.add_component_link(cl)
        return data, c2

    def test(self):
        data, cid = self.make_link()
        result = data[cid]
        expected = np.array([100, 200, 300])
        np.testing.assert_array_equal(result, expected)

    def test_not_identity(self):
        # regression test
        d = Data(x=[1, 2, 3])
        c2 = ComponentID('c2')
        cmd = '{x}'
        refs = {'x': d.id['x']}
        pc = parse.ParsedCommand(cmd, refs)
        link = parse.ParsedComponentLink(c2, pc)
        assert not link.identity

    def test_slice(self):
        data, cid = self.make_link()
        result = data[cid, ::2]
        np.testing.assert_array_equal(result, [100, 300])

    def test_save_load(self):
        from .test_state import clone

        d = Data(x=[1, 2, 3])
        c2 = ComponentID('c2')
        cmd = '{x} + 1'
        refs = {'x': d.id['x']}
        pc = parse.ParsedCommand(cmd, refs)
        link = parse.ParsedComponentLink(c2, pc)
        d.add_component_link(link)

        d2 = clone(d)
        np.testing.assert_array_equal(d2['c2'], [2, 3, 4])


class TestParsedSubsetState(object):

    def setup_method(self, method):
        data = Data()
        c1 = Component(np.array([2, 4, 6, 8]))
        g = ComponentID('g')
        data.add_component(c1, g)

        s1 = data.new_subset()
        s2 = data.new_subset()

        state1 = MagicMock()
        state1.to_mask.return_value = np.array([1, 1, 1, 0], dtype=bool)
        state2 = MagicMock()
        state2.to_mask.return_value = np.array([0, 1, 1, 1], dtype=bool)

        s1.subset_state = state1
        s2.subset_state = state2

        self.refs = {'s1': s1, 's2': s2, 'g': g}
        self.data = data

    def test_two_subset(self):
        cmd = '{s1} & {s2}'
        s = self.data.new_subset()
        p = parse.ParsedCommand(cmd, self.refs)
        state = parse.ParsedSubsetState(p)

        s.subset_state = state

        result = s.to_mask()
        expected = np.array([0, 1, 1, 0], dtype=bool)

        np.testing.assert_array_equal(result, expected)

    def test_two_subset_and_component(self):
        cmd = '{s1} & {s2} & ({g} < 6)'
        s = self.data.new_subset()
        p = parse.ParsedCommand(cmd, self.refs)
        state = parse.ParsedSubsetState(p)

        s.subset_state = state
        result = s.to_mask()
        expected = np.array([0, 1, 0, 0], dtype=bool)

        np.testing.assert_array_equal(result, expected)

########NEW FILE########
__FILENAME__ = test_registry
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
from ..registry import Registry


def setup_function(function):
    Registry().clear()


def test_singleton():
    assert Registry() is Registry()


def test_unique():
    r = Registry()
    assert r.register(3, "test") == "test"
    assert r.register(4, "test2") == "test2"


def test_disambiguate():
    r = Registry()
    assert r.register(3, "test") == "test"
    assert r.register(4, "test") == "test_01"


def test_rename():
    r = Registry()
    assert r.register(3, "test") == "test"
    assert r.register(4, "test2") == "test2"
    assert r.register(3, "test") == "test"


def test_rename_then_new():
    r = Registry()
    assert r.register(3, "test") == "test"
    assert r.register(3, "test2") == "test2"
    assert r.register(4, "test") == "test"


def test_cross_class():
    r = Registry()
    assert r.register(3, "test") == "test"
    assert r.register(3.5, "test") == "test"
    assert r.register(4.5, "test") == "test_01"


def test_group_override():
    r = Registry()
    assert r.register(3, "test") == "test"
    assert r.register(3.5, "test", group=int) == "test_01"
    assert r.register(4, "test", group=float) == "test"


def test_unregister():
    r = Registry()
    assert r.register(3, "test") == "test"
    r.unregister(3)
    assert r.register(4, "test") == "test"


def test_relabel_to_self():
    r = Registry()
    assert r.register(3, "test") == "test"
    assert r.register(3, "test") == "test"


def test_lowest_disambiguation():
    r = Registry()
    assert r.register(3, "test") == "test"
    assert r.register(4, "test") == "test_01"
    assert r.register(4, "test") == "test_01"

########NEW FILE########
__FILENAME__ = test_roi
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest

import numpy as np
from numpy.testing import assert_almost_equal
from matplotlib.figure import Figure
from mock import MagicMock

from ..roi import (RectangularROI, UndefinedROI, CircularROI, PolygonalROI,
                   MplCircularROI, MplRectangularROI, MplPolygonalROI,
                   XRangeROI, MplXRangeROI, YRangeROI, MplYRangeROI)

from .. import roi as r

FIG = Figure()
AXES = FIG.add_subplot(111)


class TestRectangle(object):

    def setup_method(self, method):
        self.roi = RectangularROI()

    def test_empty_roi_contains_raises(self):
        with pytest.raises(UndefinedROI):
            self.roi.contains(1, 2)

    def test_scalar_contains(self):
        self.roi.update_limits(0, 0, 10, 10)
        assert self.roi.contains(5, 5)
        assert not self.roi.contains(11, 11)

    def test_reset(self):
        assert not self.roi.defined()
        self.roi.update_limits(0, 0, 10, 10)
        assert self.roi.defined()
        self.roi.reset()
        assert not self.roi.defined()
        with pytest.raises(UndefinedROI):
            self.roi.contains(5, 5)

    def test_empty_to_polygon(self):
        x, y = self.roi.to_polygon()
        assert x == []
        assert y == []

    def test_to_polygon(self):
        self.roi.update_limits(0, 0, 10, 10)
        x, y = self.roi.to_polygon()
        poly = PolygonalROI(vx=x, vy=y)
        assert poly.contains(5, 5)

    def test_ndarray(self):
        self.roi.update_limits(0, 0, 10, 10)

        x = np.array([5, 6, 2, 11])
        y = np.array([5, 11, 2, 11])
        result = self.roi.contains(x, y)
        assert result[0]
        assert not result[1]
        assert result[2]
        assert not result[3]

    def test_corner(self):
        self.roi.update_limits(6, 7, 10, 10)
        assert self.roi.corner() == (6, 7)

    def test_width(self):
        self.roi.update_limits(2, 2, 10, 12)
        assert self.roi.width() == 8

    def test_height(self):
        self.roi.update_limits(2, 2, 10, 12)
        assert self.roi.height() == 10

    def test_multidim_ndarray(self):
        self.roi.update_limits(0, 0, 10, 10)
        x = np.array([1, 2, 3, 4]).reshape(2, 2)
        y = np.array([1, 2, 3, 4]).reshape(2, 2)
        assert self.roi.contains(x, y).all()
        assert not self.roi.contains(x + 10, y).any()
        assert self.roi.contains(x, y).shape == x.shape

    def test_str_undefined(self):
        """ str method should not crash """
        assert type(str(self.roi)) == str

    def test_str_defined(self):
        """ str method should not crash """
        self.roi.update_limits(1, 2, 3, 4)
        assert type(str(self.roi)) == str


class TestXRange(object):
    def test_undefined_on_init(self):
        assert not XRangeROI().defined()

    def test_str(self):
        roi = XRangeROI()
        assert str(roi) == "Undefined XRangeROI"

        roi.set_range(1, 2)
        assert str(roi) == "1.000 < x < 2.000"

    def test_reset(self):
        roi = XRangeROI()
        roi.set_range(1, 2)
        assert roi.defined()
        roi.reset()
        assert not roi.defined()

    def test_contains(self):
        roi = XRangeROI()
        roi.set_range(1, 3)
        x = np.array([0, 1, 2, 3])
        y = np.array([-np.inf, 100, 200, 0])
        np.testing.assert_array_equal(roi.contains(x, y),
                                      [False, False, True, False])

    def test_contains_undefined(self):
        roi = XRangeROI()
        with pytest.raises(UndefinedROI):
            roi.contains(1, 2)

    def test_to_polygon(self):
        roi = XRangeROI()
        assert roi.to_polygon() == ([], [])
        roi.set_range(1, 2)
        x, y = roi.to_polygon()
        np.testing.assert_array_equal(x, [1, 2, 2, 1, 1])
        np.testing.assert_array_equal(y,
                                      [-1e100, -1e100, 1e100, 1e100, -1e100])


class TestYRange(object):
    def test_undefined_on_init(self):
        assert not YRangeROI().defined()

    def test_str(self):
        roi = YRangeROI()
        assert str(roi) == "Undefined YRangeROI"

        roi.set_range(1, 2)
        assert str(roi) == "1.000 < y < 2.000"

    def test_reset(self):
        roi = YRangeROI()
        roi.set_range(1, 2)
        assert roi.defined()
        roi.reset()
        assert not roi.defined()

    def test_contains(self):
        roi = YRangeROI()
        roi.set_range(1, 3)
        y = np.array([0, 1, 2, 3])
        x = np.array([-np.inf, 100, 200, 0])
        np.testing.assert_array_equal(roi.contains(x, y),
                                      [False, False, True, False])

    def test_contains_undefined(self):
        roi = YRangeROI()
        with pytest.raises(UndefinedROI):
            roi.contains(1, 2)

    def test_to_polygon(self):
        roi = YRangeROI()
        assert roi.to_polygon() == ([], [])
        roi.set_range(1, 2)
        x, y = roi.to_polygon()
        np.testing.assert_array_equal(y, [1, 2, 2, 1, 1])
        np.testing.assert_array_equal(x,
                                      [-1e100, -1e100, 1e100, 1e100, -1e100])


class TestCircle(object):
    def setup_method(self, method):
        self.roi = CircularROI()

    def test_undefined_on_creation(self):
        assert not self.roi.defined()

    def test_contains_on_undefined_contains_raises(self):
        with pytest.raises(UndefinedROI):
            self.roi.contains(1, 1)

    def test_set_center(self):
        self.roi.set_center(0, 0)
        self.roi.set_radius(1)
        assert self.roi.contains(0, 0)
        assert not self.roi.contains(2, 2)
        self.roi.set_center(2, 2)
        assert not self.roi.contains(0, 0)
        assert self.roi.contains(2, 2)

    def test_set_radius(self):
        self.roi.set_center(0, 0)
        self.roi.set_radius(1)
        assert not self.roi.contains(1.5, 0)
        self.roi.set_radius(5)
        assert self.roi.contains(1.5, 0)

    def test_contains_many(self):
        x = [0, 0, 0, 0, 0]
        y = [0, 0, 0, 0, 0]
        self.roi.set_center(0, 0)
        self.roi.set_radius(1)
        assert all(self.roi.contains(x, y))
        assert all(self.roi.contains(np.asarray(x), np.asarray(y)))
        assert not any(self.roi.contains(np.asarray(x) + 10, y))

    def test_poly(self):
        self.roi.set_center(0, 0)
        self.roi.set_radius(1)
        x, y = self.roi.to_polygon()
        poly = PolygonalROI(vx=x, vy=y)
        assert poly.contains(0, 0)
        assert not poly.contains(10, 0)

    def test_poly_undefined(self):
        x, y = self.roi.to_polygon()
        assert x == []
        assert y == []

    def test_reset(self):
        assert not self.roi.defined()
        self.roi.set_center(0, 0)
        assert not self.roi.defined()
        self.roi.set_radius(2)
        assert self.roi.defined()
        self.roi.reset()
        assert not self.roi.defined()

    def test_multidim(self):
        self.roi.set_center(0, 0)
        self.roi.set_radius(1)
        x = np.array([.1, .2, .3, .4]).reshape(2, 2)
        y = np.array([-.1, -.2, -.3, -.4]).reshape(2, 2)
        assert self.roi.contains(x, y).all()
        assert not self.roi.contains(x + 1, y).any()
        assert self.roi.contains(x, y).shape == (2, 2)


class TestPolygon(object):
    def setup_method(self, method):
        self.roi = PolygonalROI()

    def define_as_square(self):
        self.roi.reset()
        assert not self.roi.defined()
        self.roi.add_point(0, 0)
        self.roi.add_point(0, 1)
        self.roi.add_point(1, 1)
        self.roi.add_point(1, 0)
        assert self.roi.defined()

    def test_contains_on_empty_raises(self):
        with pytest.raises(UndefinedROI):
            self.roi.contains(1, 2)

    def test_remove_empty(self):
        self.roi.remove_point(1, 0)

    def test_replace(self):
        self.define_as_square()
        assert self.roi.contains(.9, .02)
        self.roi.replace_last_point(0, 0)
        assert not self.roi.contains(.9, .01)

    def test_remove_successful(self):
        self.define_as_square()
        assert self.roi.contains(.9, .02)
        self.roi.remove_point(1, 0)
        assert not self.roi.contains(.9, .01)

    def test_nan(self):
        self.define_as_square()
        assert not self.roi.contains(np.nan, .5)

    def test_remove_unsuccessful(self):
        self.define_as_square()
        assert self.roi.contains(.9, .02)
        self.roi.remove_point(1.5, 0, thresh=.49)
        assert self.roi.contains(.9, .01)

    def test_to_poly(self):
        self.define_as_square()
        x, y = self.roi.to_polygon()
        assert x == [0, 0, 1, 1]
        assert y == [0, 1, 1, 0]

    def test_to_poly_undefined(self):
        assert self.roi.to_polygon() == ([], [])

    def test_rect(self):
        self.roi.reset()
        self.roi.add_point(4.95164474584, 0.136922625654)
        self.roi.add_point(6.08256580223, 0.136922625654)
        self.roi.add_point(6.08256580223, 0.423771697842)
        self.roi.add_point(4.95164474584, 0.423771697842)
        self.roi.add_point(4.95164474584, 0.136922625654)
        x = np.array([4.4, 3.18, 4.49, 4.49])
        y = np.array([.2, .2, .2, .2])
        assert not self.roi.contains(4.4000001, 0.2)
        assert not self.roi.contains(3.1800001, 0.2)
        assert not self.roi.contains(4.4899998, 0.2)
        assert not self.roi.contains(x, y).any()
        x.shape = (2, 2)
        y.shape = (2, 2)
        assert not self.roi.contains(x, y).any()
        assert self.roi.contains(x, y).shape == (2, 2)

    def test_empty(self):
        assert not self.roi.defined()
        with pytest.raises(UndefinedROI):
            self.roi.contains(0, 0)

    def test_contains_scalar(self):
        self.define_as_square()
        assert self.roi.contains(.5, .5)
        assert not self.roi.contains(1.5, 1.5)

    def test_contains_list(self):
        self.define_as_square()
        assert self.roi.contains([.5, .4], [.5, .4]).all()
        assert not self.roi.contains([1.5, 1.5], [0, 0]).any()

    def test_contains_numpy(self):
        self.define_as_square()
        x = np.array([.4, .5, .4])
        y = np.array([.4, .5, .4])
        assert self.roi.contains(x, y).all()
        assert not self.roi.contains(x + 5, y).any()

    def test_str(self):
        """ __str__ returns a string """
        assert type(str(self.roi)) == str


class DummyEvent(object):
    def __init__(self, x, y, inaxes=True):
        self.inaxes = inaxes
        self.xdata = x
        self.ydata = y


class MockAxes(object):
    def __init__(self):
        self.figure = MagicMock()
        self.figure.canvas = MagicMock()

    def add_patch(self, patch):
        pass


class TestMpl(object):

    def setup_method(self, method):
        self.axes = MagicMock()
        self.roi = self._roi_factory()

    def _roi_factory(self):
        raise NotImplementedError

    def test_undefined_on_creation(self):
        assert not self.roi._roi.defined()

    def test_large_zorder(self):
        assert self.roi._patch.get_zorder() >= 100

    def test_proper_roi(self):
        raise NotImplementedError

    def test_start_ignored_if_not_inaxes(self):
        ev = DummyEvent(0, 0, inaxes=None)
        self.roi.start_selection(ev)
        assert not self.roi._roi.defined()

    def test_canvas_syncs_properly(self):
        assert self.axes.figure.canvas.draw.call_count == 1
        event = DummyEvent(5, 5, inaxes=self.axes)
        self.roi.start_selection(event)
        assert self.axes.figure.canvas.draw.call_count == 2
        self.roi.update_selection(event)
        assert self.axes.figure.canvas.draw.call_count == 3
        self.roi.update_selection(event)
        assert self.axes.figure.canvas.draw.call_count == 4
        self.roi.finalize_selection(event)
        assert self.axes.figure.canvas.draw.call_count == 5

    def test_patch_shown_on_start(self):
        assert not self.roi._patch.get_visible()
        event = DummyEvent(5, 5, inaxes=self.axes)
        self.roi.start_selection(event)
        assert self.roi._patch.get_visible()

    def test_patch_hidden_on_finalise(self):
        event = DummyEvent(5, 5, inaxes=self.axes)
        self.roi.start_selection(event)
        self.roi.finalize_selection(event)
        assert not self.roi._patch.get_visible()

    def test_update_before_start_ignored(self):
        self.roi.update_selection(None)
        assert not self.roi._roi.defined()

    def test_finalize_before_start_ignored(self):
        self.roi.finalize_selection(None)
        assert not self.roi._roi.defined()

    def test_roi_defined_after_start(self):
        event = DummyEvent(5, 5, inaxes=self.axes)
        self.roi.start_selection(event)
        assert self.roi._roi.defined()

    def test_roi_undefined_before_start(self):
        assert not self.roi._roi.defined()


class TestRectangleMpl(TestMpl):

    def _roi_factory(self):
        return MplRectangularROI(self.axes)

    def test_scrub(self):
        roi = self._roi_factory()

        event = DummyEvent(5, 5, inaxes=self.axes)
        roi.start_selection(event)
        event = DummyEvent(10, 10, inaxes=self.axes)
        roi.update_selection(event)

        #restart without finalize = scrub
        roi.start_selection(DummyEvent(6, 6, inaxes=self.axes))
        roi.update_selection(DummyEvent(7, 8, inaxes=self.axes))

        print roi
        print roi._roi
        assert roi._roi.xmin == 6
        assert roi._roi.xmax == 11
        assert roi._roi.ymin == 7
        assert roi._roi.ymax == 12

    def assert_roi_correct(self, x0, x1, y0, y1):
        corner = self.roi.roi().corner()
        height = self.roi.roi().height()
        width = self.roi.roi().width()
        assert self.roi.roi().defined()
        assert_almost_equal(corner[0], min(x0, x1), 4)
        assert_almost_equal(corner[1], min(y0, y1), 4)
        assert_almost_equal(abs(y1 - y0), height, 4)
        assert_almost_equal(abs(x1 - x0), width, 4)

    def assert_patch_correct(self, x0, x1, y0, y1):
        corner = self.roi._patch.get_xy()
        width = self.roi._patch.get_width()
        height = self.roi._patch.get_height()
        assert_almost_equal(corner, (min(x0, x1), min(y0, y1)), 4)
        assert_almost_equal(width, abs(x0 - x1))
        assert_almost_equal(height, abs(y0 - y1))

    def test_str(self):
        assert type(str(self.roi)) == str

    def test_proper_roi(self):
        assert isinstance(self.roi._roi, RectangularROI)

    def test_roi_on_start_selection(self):
        event = DummyEvent(5, 5, inaxes=self.axes)
        self.roi.start_selection(event)
        self.assert_roi_correct(5, 5, 5, 5)

    def test_patch_on_start_selection(self):
        event = DummyEvent(5, 5, inaxes=self.axes)
        self.roi.start_selection(event)
        self.assert_patch_correct(5, 5, 5, 5)

    def test_update_selection(self):
        event = DummyEvent(5, 6, inaxes=self.axes)
        self.roi.start_selection(event)
        event = DummyEvent(10, 11, inaxes=self.axes)
        self.roi.update_selection(event)
        self.assert_roi_correct(5, 10, 6, 11)
        self.assert_patch_correct(5, 10, 6, 11)

    def test_finalize_selection(self):
        event = DummyEvent(5, 6, inaxes=self.axes)
        self.roi.start_selection(event)
        event = DummyEvent(10, 11, inaxes=self.axes)
        self.roi.update_selection(event)
        self.roi.finalize_selection(event)
        self.assert_roi_correct(5, 10, 6, 11)
        self.assert_patch_correct(5, 10, 6, 11)

    def test_define_roi_to_right(self):
        ev0 = DummyEvent(0.5, 0.5, inaxes=self.axes)
        ev1 = DummyEvent(1, 1, inaxes=self.axes)
        self.roi.start_selection(ev0)
        self.roi.update_selection(ev1)
        self.roi.finalize_selection(ev1)

        self.assert_roi_correct(.5, 1, .5, 1)
        self.assert_patch_correct(.5, 1, .5, 1)

    def test_define_roi_to_left(self):
        ev0 = DummyEvent(1, 1, inaxes=self.axes)
        ev1 = DummyEvent(0.5, 0.5, inaxes=self.axes)
        self.roi.start_selection(ev0)
        self.roi.update_selection(ev1)
        self.roi.finalize_selection(ev1)

        self.assert_roi_correct(.5, 1, .5, 1)
        self.assert_patch_correct(.5, 1, .5, 1)


class TestXRangeMpl(TestMpl):
    def _roi_factory(self):
        return MplXRangeROI(self.axes)

    def test_proper_roi(self):
        assert isinstance(self.roi._roi, XRangeROI)

    def test_start_selection(self):
        event = DummyEvent(1, 1, inaxes=self.axes)
        self.roi.start_selection(event)
        assert self.roi._roi.defined()

    def test_update_selection(self):
        ev0 = DummyEvent(1, 1, inaxes=self.axes)
        ev1 = DummyEvent(2, 1, inaxes=self.axes)
        self.roi.start_selection(ev0)
        self.roi.update_selection(ev1)
        assert self.roi._roi.defined()
        assert self.roi._roi.range() == (1, 2)

    def test_finalize_selection(self):
        ev0 = DummyEvent(1, 1, inaxes=self.axes)
        ev1 = DummyEvent(2, 1, inaxes=self.axes)
        self.roi.start_selection(ev0)
        self.roi.update_selection(ev1)
        self.roi.finalize_selection(ev1)
        assert self.roi._roi.defined()
        assert self.roi._roi.range() == (1, 2)

        assert not self.roi._patch.get_visible()


class TestYRangeMpl(TestMpl):
    def _roi_factory(self):
        return MplYRangeROI(self.axes)

    def test_proper_roi(self):
        assert isinstance(self.roi._roi, YRangeROI)

    def test_start_selection(self):
        event = DummyEvent(1, 1, inaxes=self.axes)
        self.roi.start_selection(event)
        assert self.roi._roi.defined()

    def test_update_selection(self):
        ev0 = DummyEvent(1, 1, inaxes=self.axes)
        ev1 = DummyEvent(1, 2, inaxes=self.axes)
        self.roi.start_selection(ev0)
        self.roi.update_selection(ev1)
        assert self.roi._roi.defined()
        assert self.roi._roi.range() == (1, 2)

    def test_finalize_selection(self):
        ev0 = DummyEvent(1, 1, inaxes=self.axes)
        ev1 = DummyEvent(1, 2, inaxes=self.axes)
        self.roi.start_selection(ev0)
        self.roi.update_selection(ev1)
        self.roi.finalize_selection(ev1)
        assert self.roi._roi.defined()
        assert self.roi._roi.range() == (1, 2)

        assert not self.roi._patch.get_visible()


class TestCircleMpl(TestMpl):

    def _roi_factory(self):
        return MplCircularROI(self.axes)

    def setup_method(self, method):
        super(TestCircleMpl, self).setup_method(method)
        self.pixel_to_data = r.pixel_to_data
        self.data_to_pixel = r.data_to_pixel

        r.pixel_to_data = lambda x, y, z: np.column_stack((y, z))
        r.data_to_pixel = lambda x, y, z: np.column_stack((y, z))

    def teardown_method(self, method):
        # restore methods
        r.pixel_to_data = self.pixel_to_data
        r.data_to_pixel = self.data_to_pixel

    def test_proper_roi(self):
        assert isinstance(self.roi._roi, CircularROI)

    def test_to_polygon_undefined(self):
        """to_polygon() result should be undefined before defining polygon"""
        roi = self.roi.roi()
        assert not roi.defined()

    def test_roi_defined_correctly(self):
        ev0 = DummyEvent(0, 0, inaxes=self.axes)
        ev1 = DummyEvent(5, 0, inaxes=self.axes)
        self.roi.start_selection(ev0)
        self.roi.update_selection(ev1)
        self.roi.finalize_selection(ev1)
        self.assert_roi_correct(0, 0, 5)

    def assert_roi_correct(self, x, y, r):
        roi = self.roi.roi()
        assert roi.defined()
        assert roi.contains(x, y)
        assert roi.contains(x + .95 * r, y)
        assert not roi.contains(x + 1.05 * r, y)
        assert not roi.contains(x + .8 * r, y + .8 * r)


class TestPolyMpl(TestMpl):
    def _roi_factory(self):
        return MplPolygonalROI(self.axes)

    def test_proper_roi(self):
        return isinstance(self.roi._roi, PolygonalROI)

    def send_events(self):
        ev0 = DummyEvent(0, 0, inaxes=self.axes)
        ev1 = DummyEvent(0, 1, inaxes=self.axes)
        ev2 = DummyEvent(1, 1, inaxes=self.axes)
        ev3 = DummyEvent(1, 0, inaxes=self.axes)
        self.roi.start_selection(ev0)
        self.roi.update_selection(ev1)
        self.roi.update_selection(ev2)
        self.roi.update_selection(ev3)
        self.roi.finalize_selection(ev3)

    def assert_roi_correct(self):
        roi = self.roi.roi()
        assert roi.contains(.5, .5)
        assert not roi.contains(1.5, .5)

    def test_define(self):
        self.send_events()
        self.assert_roi_correct()


class TestUtil(object):

    def setup_method(self, method):
        self.axes = AXES

    def test_aspect_ratio(self):
        self.axes.figure.set_figheight(5)
        self.axes.figure.set_figwidth(5)
        self.axes.set_ylim([0, 10])
        self.axes.set_xlim([0, 10])

        ax0 = r.aspect_ratio(self.axes)
        self.axes.set_ylim(0, 20)
        assert_almost_equal(r.aspect_ratio(self.axes), ax0 / 2, 4)
        self.axes.set_ylim(0, 5)
        assert_almost_equal(r.aspect_ratio(self.axes), ax0 * 2, 4)
        self.axes.set_xlim(0, 5)
        assert_almost_equal(r.aspect_ratio(self.axes), ax0, 4)
        self.axes.set_xlim(0, 10)
        assert_almost_equal(r.aspect_ratio(self.axes), ax0 * 2, 4)

    def test_data_to_norm_with_scalars(self):
        # assume data that gets submitted to axes is valid.
        # testing to see if we can get there
        self.axes.set_xlim(0, 10)
        self.axes.set_ylim(0, 10)
        func = r.data_to_norm
        assert_almost_equal(func(self.axes, 0, 0)[0, 0], 0, 3)
        assert_almost_equal(func(self.axes, 0, 0)[0, 1], 0, 3)
        assert_almost_equal(func(self.axes, 0, 10)[0, 0], 0, 3)
        assert_almost_equal(func(self.axes, 0, 10)[0, 1], 1, 3)
        assert_almost_equal(func(self.axes, 10, 10)[0, 0], 1, 3)
        assert_almost_equal(func(self.axes, 10, 10)[0, 1], 1, 3)
        assert_almost_equal(func(self.axes, 10, 0)[0, 0], 1, 3)
        assert_almost_equal(func(self.axes, 10, 0)[0, 1], 0, 3)

        x = np.array([0, 0, 10, 10])
        y = np.array([0, 10, 0, 10])
        xans = [0, 0, 1, 1]
        yans = [0, 1, 0, 1]
        norm = func(self.axes, x, y)
        assert_almost_equal(norm[0, 0], xans[0], 3)
        assert_almost_equal(norm[1, 0], xans[1], 3)
        assert_almost_equal(norm[2, 0], xans[2], 3)
        assert_almost_equal(norm[3, 0], xans[3], 3)
        assert_almost_equal(norm[0, 1], yans[0], 3)
        assert_almost_equal(norm[1, 1], yans[1], 3)
        assert_almost_equal(norm[2, 1], yans[2], 3)
        assert_almost_equal(norm[3, 1], yans[3], 3)

        x = [0, 0, 10, 10]
        y = [0, 10, 0, 10]
        assert_almost_equal(norm[0, 0], xans[0], 3)
        assert_almost_equal(norm[1, 0], xans[1], 3)
        assert_almost_equal(norm[2, 0], xans[2], 3)
        assert_almost_equal(norm[3, 0], xans[3], 3)
        assert_almost_equal(norm[0, 1], yans[0], 3)
        assert_almost_equal(norm[1, 1], yans[1], 3)
        assert_almost_equal(norm[2, 1], yans[2], 3)
        assert_almost_equal(norm[3, 1], yans[3], 3)

    def test_data_to_pixel(self):
        xp = 100
        yp = 100
        data = r.pixel_to_data(self.axes, xp, yp)
        pixel = r.data_to_pixel(self.axes, data[:, 0], data[:, 1])
        assert_almost_equal(pixel[0, 0], xp, 3)
        assert_almost_equal(pixel[0, 1], yp, 3)

del TestMpl  # prevents unittest discovery from running abstract base class

########NEW FILE########
__FILENAME__ = test_simpleforms
import pytest

from ..simpleforms import IntOption, FloatOption, BoolOption


class Stub(object):
    int_opt = IntOption(min=0, max=10, default=3)
    float_opt = FloatOption(min=1, max=2, default=1.5)
    bool_opt = BoolOption()


class TestSimpleForms(object):

    def test_get_set_int(self):
        assert Stub.int_opt.min == 0
        assert Stub.int_opt.max == 10
        assert Stub().int_opt == 3

    def test_get_set_bool(self):
        s = Stub()
        assert s.bool_opt is False
        s.bool_opt = True
        assert s.bool_opt

    def test_get_set_float(self):

        s = Stub()
        assert s.float_opt == 1.5

        s.float_opt = 1
        assert s.float_opt == 1.0
        assert isinstance(s.float_opt, float)

    def test_invalid_int(self):

        s = Stub()
        s.int_opt = 4

        with pytest.raises(ValueError):
            s.int_opt = -1

        with pytest.raises(ValueError):
            s.int_opt = 11

        with pytest.raises(ValueError):
            s.int_opt = 2.5

    def test_invalid_float(self):
        s = Stub()

        with pytest.raises(ValueError):
            s.float_opt = -0.1

        with pytest.raises(ValueError):
            s.float_opt = 10.1

    def test_invalid(self):
        s = Stub()

        with pytest.raises(ValueError):
            s.bool_opt = 3

########NEW FILE########
__FILENAME__ = test_state
import numpy as np
import json
import pytest

from ..state import (GlueSerializer, GlueUnSerializer,
                     saver, loader, VersionedDict)

from ... import core
from ...qt.glue_application import GlueApplication
from ...qt.widgets.scatter_widget import ScatterWidget
from ...qt.widgets.image_widget import ImageWidget
from ...qt.widgets.histogram_widget import HistogramWidget
from .util import make_file
from ..data_factories import load_data
from .test_data_factories import TEST_FITS_DATA


def clone(object):
    gs = GlueSerializer(object)
    oid = gs.id(object)
    dump = gs.dumps()
    gu = GlueUnSerializer.loads(dump)
    result = gu.object(oid)
    return result


def doubler(x):
    return 2 * x


class Cloner(object):

    def __init__(self, obj):
        self.s = GlueSerializer(obj)
        self.us = GlueUnSerializer.loads(self.s.dumps())

    def get(self, o):
        return self.us.object(self.s.id(o))


class Circular(object):

    def __gluestate__(self, context):
        return dict(other=context.id(self.other))

    @classmethod
    def __setgluestate__(cls, rec, context):
        result = cls()
        yield result
        result.other = context.object(rec['other'])


def test_generator_loaders():

    f = Circular()
    b = Circular()
    f.other = b
    b.other = f

    f2 = clone(f)
    assert f2.other.other is f2


def test_none():
    assert clone(None) is None


def test_data():
    d = core.Data(x=[1, 2, 3], label='testing')
    d2 = clone(d)
    assert d2.label == 'testing'

    np.testing.assert_array_equal(d2['x'], [1, 2, 3])
    np.testing.assert_array_equal(d2['Pixel Axis 0'], [0, 1, 2])


def test_data_style():
    d = core.Data(x=[1, 2, 3])
    d.style.color = 'blue'
    d2 = clone(d)
    assert d2.style.color == 'blue'


def test_data_factory():
    with make_file(TEST_FITS_DATA, '.fits') as infile:
        d = load_data(infile)
        d2 = clone(d)

    np.testing.assert_array_equal(d['PRIMARY'], d2['PRIMARY'])


def test_save_numpy_scalar():
    assert clone(np.float32(5)) == 5


def tests_data_factory_double():

    from cStringIO import StringIO
    from astropy.io import fits
    d = np.random.normal(0, 1, (100, 100, 100))
    s = StringIO()
    fits.writeto(s, d)

    with make_file(s.getvalue(), '.fits') as infile:
        d = load_data(infile)
        d2 = clone(d)

    assert len(GlueSerializer(d).dumps()) < \
        1.1 * len(GlueSerializer(d2).dumps())


def test_inequality_subset():
    d = core.Data(x=[1, 2, 3], label='testing')
    s = d.new_subset(label='abc')
    s.subset_state = d.id['x'] > 1
    d2 = clone(d)
    s2 = d2.subsets[0]
    assert s.label == s2.label
    np.testing.assert_array_equal(s2.to_mask(), [False, True, True])
    assert s.style == s2.style


def test_compound_state():
    d = core.Data(x=[1, 2, 3])
    s = d.new_subset(label='abc')
    s.subset_state = (d.id['x'] > 2) | (d.id['x'] < 1.5)
    d2 = clone(d)
    np.testing.assert_array_equal(d2.subsets[0].to_mask(), [True, False, True])


def test_empty_subset():
    d = core.Data(x=[1, 2, 3], label='testing')
    s = d.new_subset(label='abc')
    s.style.color = 'blue'
    s2 = clone(s)
    assert s.style == s2.style
    assert s2.style.color == 'blue'


def test_box_roi_subset():
    d = core.Data(x=[1, 2, 3], y=[2, 4, 8])
    s = d.new_subset(label='box')
    roi = core.roi.RectangularROI(xmin=1.1, xmax=2.1, ymin=2.2, ymax=4.2)
    s.subset_state = core.subset.RoiSubsetState(xatt=d.id['x'],
                                                yatt=d.id['y'], roi=roi)

    d2 = clone(d)
    np.testing.assert_array_equal(
        d2.subsets[0].to_mask(), [False, True, False])


def test_range_subset():
    d = core.Data(x=[1, 2, 3])
    s = d.new_subset(label='range')
    s.subset_state = core.subset.RangeSubsetState(0.5, 2.5, att=d.id['x'])
    d2 = clone(d)

    np.testing.assert_array_equal(
        d2.subsets[0].to_mask(), [True, True, False])


def test_complex_state():
    d = core.Data(x=[1, 2, 3], y=[2, 4, 8])
    s = d.new_subset(label='test')
    s.subset_state = (d.id['x'] > 2) | (d.id['y'] < 4)
    s.subset_state = s.subset_state & (d.id['x'] < 4)

    d2 = clone(d)
    s2 = d2.subsets[0]
    np.testing.assert_array_equal(s2.to_mask(), [True, False, True])


def test_range_roi():
    roi = core.roi.RangeROI('x', min=1, max=2)
    r2 = clone(roi)
    assert r2.ori == 'x'
    assert r2.min == 1
    assert r2.max == 2


def test_circular_roi():
    roi = core.roi.CircularROI(xc=0, yc=1, radius=2)
    r2 = clone(roi)
    assert r2.xc == 0
    assert r2.yc == 1
    assert r2.radius == 2


def test_polygonal_roi():
    roi = core.roi.PolygonalROI()
    roi.add_point(0, 0)
    roi.add_point(0, 1)
    roi.add_point(1, 0)
    r2 = clone(roi)
    assert r2.vx == [0, 0, 1]
    assert r2.vy == [0, 1, 0]


class TestApplication(object):

    def check_clone(self, app):
        c = Cloner(app)
        copy = c.us.object('__main__')

        hub1 = app.session.hub
        hub2 = copy.session.hub

        assert len(hub1._subscriptions) == len(hub2._subscriptions)

        # data collections are the same
        for d1, d2 in zip(app.session.data_collection,
                          copy.session.data_collection):
            assert d1.label == d2.label
            for cid1, cid2 in zip(d1.components, d2.components):
                assert cid1.label == cid2.label

                # order of components unspecified if label collisions
                cid2 = c.get(cid1)
                np.testing.assert_array_almost_equal(d1[cid1, 0:1],
                                                     d2[cid2, 0:1], 3)

        # same data viewers, in the same tabs
        for tab1, tab2 in zip(app.viewers, copy.viewers):
            assert len(tab1) == len(tab2)
            for v1, v2 in zip(tab1, tab2):
                assert type(v1) == type(v2)
                # same window properties
                assert v1.viewer_size == v2.viewer_size
                assert v1.position == v2.position

                # same viewer-level properties (axis label, scaling, etc)
                assert set(v1.properties.keys()) == set(v2.properties.keys())
                for k in v1.properties:
                    if hasattr(v1.properties[k], 'label'):
                        assert v1.properties[k].label == v2.properties[k].label
                    else:
                        assert v1.properties[k] == v2.properties[k]

                assert len(v1.layers) == len(v2.layers)
                for l1, l2 in zip(v1.layers, v2.layers):
                    assert l1.layer.label == l2.layer.label  # same data/subset
                    assert l1.layer.style == l2.layer.style

        return copy

    def test_bare_application(self):
        app = GlueApplication()
        self.check_clone(app)

    def test_data_application(self):
        dc = core.DataCollection([core.Data(label='test',
                                            x=[1, 2, 3], y=[2, 3, 4])])
        app = GlueApplication(dc)
        self.check_clone(app)

    def test_links(self):
        d1 = core.Data(label='x', x=[1, 2, 3])
        d2 = core.Data(label='y', y=[3, 4, 8])
        dc = core.DataCollection([d1, d2])
        link = core.ComponentLink([d1.id['x']], d2.id['y'], doubler)
        dc.add_link(link)

        np.testing.assert_array_equal(d1['y'], [2, 4, 6])

        app = GlueApplication(dc)
        self.check_clone(app)

    def test_scatter_viewer(self):
        d = core.Data(label='x', x=[1, 2, 3, 4, 5], y=[2, 3, 4, 5, 6])
        dc = core.DataCollection([d])
        app = GlueApplication(dc)
        w = app.new_data_viewer(ScatterWidget, data=d)
        self.check_clone(app)

        s1 = dc.new_subset_group()
        s2 = dc.new_subset_group()
        assert len(w.layers) == 3
        l1, l2, l3 = w.layers
        l1.zorder, l2.zorder = l2.zorder, l1.zorder
        l3.visible = False
        assert l3.visible is False
        copy = self.check_clone(app)
        assert copy.viewers[0][0].layers[-1].visible is False

    def test_multi_tab(self):
        d = core.Data(label='hist', x=[[1, 2], [2, 3]])
        dc = core.DataCollection([d])

        app = GlueApplication(dc)
        w1 = app.new_data_viewer(HistogramWidget, data=d)
        app.new_tab()
        w2 = app.new_data_viewer(HistogramWidget, data=d)
        assert app.viewers == ((w1,), (w2,))

        self.check_clone(app)

    def test_histogram(self):
        d = core.Data(label='hist', x=[[1, 2], [2, 3]])
        dc = core.DataCollection([d])

        app = GlueApplication(dc)
        w = app.new_data_viewer(HistogramWidget, data=d)
        self.check_clone(app)

        dc.new_subset_group()
        assert len(w.layers) == 2
        self.check_clone(app)

        w.nbins = 7
        self.check_clone(app)


class TestVersioning(object):

    def setup_method(self, method):

        @saver(core.Data, version=3)
        def s(d, context):
            return dict(v=3)

        @loader(core.Data, version=3)
        def l(d, context):
            return 3

        @saver(core.Data, version=4)
        def s(d, context):
            return dict(v=4)

        @loader(core.Data, version=4)
        def l(rec, context):
            return 4

    def teardown_method(self, method):
        GlueSerializer.dispatch._data[core.Data].pop(3)
        GlueSerializer.dispatch._data[core.Data].pop(4)
        GlueUnSerializer.dispatch._data[core.Data].pop(3)
        GlueUnSerializer.dispatch._data[core.Data].pop(4)

    def test_default_latest_save(self):
        assert GlueSerializer(core.Data()).dumpo().values()[0]['v'] == 4

    def test_legacy_load(self):
        data = json.dumps({'': {'_type': 'glue.core.Data',
                                '_protocol': 3, 'v': 2}})
        assert GlueUnSerializer(data).object('') == 3

    def test_default_latest_load(self):
        data = json.dumps({'': {'_type': 'glue.core.Data'}})
        assert GlueUnSerializer(data).object('') == 4


class TestVersionedDict(object):

    def test_bad_add(self):
        d = VersionedDict()
        with pytest.raises(KeyError):
            d['nonsequential', 2] = 5

    def test_get(self):
        d = VersionedDict()
        d['key', 1] = 5
        d['key', 2] = 6
        d['key', 3] = 7

        assert d['key'] == (7, 3)
        assert d.get_version('key', 1) == 5
        assert d.get_version('key', 2) == 6
        assert d.get_version('key', 3) == 7

        with pytest.raises(KeyError) as exc:
            d['missing']

    def test_get_missing(self):
        d = VersionedDict()
        d['key', 1] = 5
        with pytest.raises(KeyError) as exc:
            d.get_version('key', 2)
        assert exc.value.args[0] == 'No value associated with version 2 of key'

    def test_contains(self):

        d = VersionedDict()
        assert 'key' not in d

        d['key', 1] = 3
        assert 'key' in d

    def test_overwrite_forbidden(self):

        d = VersionedDict()
        d['key', 1] = 3

        with pytest.raises(KeyError) as exc:
            d['key', 1] = 3

    def test_noninteger_version(self):
        d = VersionedDict()
        with pytest.raises(ValueError) as exc:
            d['key', 'bad'] = 4

########NEW FILE########
__FILENAME__ = test_subset
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import tempfile
import operator as op

import pytest
import numpy as np
from mock import MagicMock

from ..data import Data, ComponentID, Component
from ..subset import (Subset, SubsetState,
                      ElementSubsetState, RoiSubsetState, RangeSubsetState)
from ..subset import OrState
from ..subset import AndState
from ..subset import XorState
from ..subset import InvertState
from ..message import SubsetDeleteMessage
from ..registry import Registry


class TestSubset(object):

    def setup_method(self, method):
        self.data = MagicMock()
        self.data.label = "data"
        Registry().clear()

    def test_subset_mask_wraps_state(self):
        s = Subset(self.data)
        state = MagicMock(spec=SubsetState)
        s.subset_state = state
        s.to_mask()
        state.to_mask.assert_called_once_with(self.data, None)

    def test_subset_index_wraps_state(self):
        s = Subset(self.data)
        state = MagicMock(spec=SubsetState)
        s.subset_state = state
        s.to_index_list()
        state.to_index_list.assert_called_once_with(self.data)

    def test_set_label(self):
        s = Subset(self.data, label='hi')
        assert s.label == 'hi'

    def test_str(self):
        s = Subset(self.data, label="hi")
        assert str(s) == "Subset: hi (data: data)"
        s = Subset(None, label="hi")
        assert str(s) == "Subset: hi (no data)"
        s = Subset(None)
        assert str(s) == "Subset: (no label) (no data)"
        s = Subset(self.data)
        assert str(s) == "Subset: (no label) (data: data)"

    def test_set_color(self):
        s = Subset(self.data, color='blue')
        assert s.style.color == 'blue'

    def test_paste_returns_copy_of_state(self):
        s = Subset(self.data)
        state1 = MagicMock(spec=SubsetState)
        state1_copy = MagicMock()
        state1.copy.return_value = state1_copy
        s.subset_state = state1

        s2 = Subset(self.data)

        s2.paste(s)
        assert s2.subset_state is state1_copy

    def test_register_enables_braodcasting(self):
        s = Subset(self.data)
        s.register()
        assert s._broadcasting

    def test_register_adds_subset_to_data(self):
        s = Subset(self.data)
        s.register()
        s.data.add_subset.assert_called_once_with(s)

    def test_delete_without_hub(self):
        self.data.hub = None
        s = Subset(self.data)
        s.register()
        s.delete()
        assert not s._broadcasting

    def test_delete_disables_broadcasting(self):
        """Subset no longer broadcasts after delete"""
        s = Subset(self.data)
        s.register()
        s.delete()
        assert not s._broadcasting

    def test_delete_sends_message_if_hub_present(self):
        """delete() broadcasts a SubsetDelteMessage"""
        s = Subset(self.data)
        s.register()
        s.delete()
        assert s.data.hub.broadcast.call_count == 1
        args = s.data.hub.broadcast.call_args[0]
        msg = args[0]
        assert isinstance(msg, SubsetDeleteMessage)

    def test_delete_removes_from_data(self):
        """delete method removes reference from data.subsets"""
        data = Data()
        s = data.new_subset()
        assert s in data.subsets
        s.delete()
        assert s not in data.subsets

    def test_delete_with_no_data(self):
        """delete method doesnt crash if subset has no data"""
        s = Subset(None)
        assert s.data is None
        s.delete()

    def test_double_delete_ignored(self):
        """calling delete twice doesnt crash"""
        data = Data()
        s = data.new_subset()
        assert s in data.subsets
        s.delete()
        s.delete()
        assert s not in data.subsets

    def test_broadcast_ignore(self):
        """subset doesn't broadcast until do_broadcast(True)"""
        s = Subset(self.data)
        s.broadcast()
        assert s.data.hub.broadcast.call_count == 0

    def test_broadcast_processed(self):
        """subset broadcasts after do_broadcast(True)"""
        s = Subset(self.data)
        s.do_broadcast(True)
        s.broadcast()
        assert s.data.hub.broadcast.call_count == 1

    def test_del(self):
        s = Subset(self.data)
        s.__del__()

    def test_getitem_empty(self):
        s = Subset(self.data)
        s.to_index_list = MagicMock()
        s.to_index_list.return_value = []
        get = s['test']
        assert list(get) == []

target_states = ((op.and_, AndState),
                 (op.or_, OrState),
                 (op.xor, XorState))


@pytest.mark.parametrize(("x"), target_states)
def test_binary_subset_combination(x):
    operator, target = x
    s1 = Subset(None)
    s2 = Subset(None)
    newsub = operator(s1, s2)
    assert isinstance(newsub, Subset)
    assert isinstance(newsub.subset_state, target)


class TestSubsetStateCombinations(object):
    def setup_method(self, method):
        self.data = None

    def test_or(self):
        s1 = Subset(self.data)
        s2 = Subset(self.data)
        s3 = s1.subset_state | s2.subset_state
        assert isinstance(s3, OrState)

    def test_and(self):
        s1 = Subset(self.data)
        s2 = Subset(self.data)
        s3 = s1.subset_state & s2.subset_state
        assert isinstance(s3, AndState)

    def test_invert(self):
        s1 = Subset(self.data)
        s3 = ~s1.subset_state
        assert isinstance(s3, InvertState)

    def test_xor(self):
        s1 = Subset(self.data)
        s2 = Subset(self.data)
        s3 = s1.subset_state ^ s2.subset_state
        assert isinstance(s3, XorState)


class TestCompositeSubsetStates(object):
    class DummyState(SubsetState):
        def __init__(self, mask):
            self._mask = mask

        def to_mask(self, data, view):
            return self._mask

        def copy(self):
            return TestCompositeSubsetStates.DummyState(self._mask)

    def setup_method(self, method):
        self.sub1 = self.DummyState(np.array([1, 1, 0, 0], dtype='bool'))
        self.sub2 = self.DummyState(np.array([1, 0, 1, 0], dtype='bool'))
        self.data = None

    def test_or(self):
        s3 = OrState(self.sub1, self.sub2)
        answer = s3.to_mask(self.data)
        expected = np.array([True, True, True, False])
        np.testing.assert_array_equal(answer, expected)

    def test_and(self):
        s3 = AndState(self.sub1, self.sub2)
        answer = s3.to_mask(self.data)
        expected = np.array([True, False, False, False])
        np.testing.assert_array_equal(answer, expected)

    def test_xor(self):
        s3 = XorState(self.sub1, self.sub2)
        answer = s3.to_mask(self.data)
        expected = np.array([False, True, True, False])
        np.testing.assert_array_equal(answer, expected)

    def test_invert(self):
        s3 = InvertState(self.sub1)
        answer = s3.to_mask(self.data)
        expected = np.array([False, False, True, True])
        np.testing.assert_array_equal(answer, expected)

    def test_multicomposite(self):
        s3 = AndState(self.sub1, self.sub2)
        s4 = XorState(s3, self.sub1)
        answer = s4.to_mask(self.data)
        expected = np.array([False, True, False, False])
        np.testing.assert_array_equal(answer, expected)


class TestElementSubsetState(object):

    def setup_method(self, method):
        self.state = ElementSubsetState()
        self.data = Data(x=[[1], [2]])

    def test_empty_mask(self):
        mask = self.state.to_mask(self.data)
        np.testing.assert_array_equal(mask, np.array([[False], [False]]))

    def test_empty_index_list(self):
        ilist = self.state.to_index_list(self.data)
        np.testing.assert_array_equal(ilist, np.array([]))

    def test_nonempty_index_list(self):
        self.state._indices = [0]
        ilist = self.state.to_index_list(self.data)
        np.testing.assert_array_equal(ilist, np.array([0]))

    def test_nonempty_mask(self):
        self.state._indices = [0]
        mask = self.state.to_mask(self.data)
        np.testing.assert_array_equal(mask, np.array([[True], [False]]))

    def test_define_on_init(self):
        ind = np.array([0, 1])
        state = ElementSubsetState(indices=ind)
        np.testing.assert_array_equal(ind, state._indices)


class TestSubsetIo(object):

    def setup_method(self, method):
        self.data = MagicMock()
        self.data.shape = (4, 4)
        self.subset = Subset(self.data)
        inds = np.array([1, 2, 3])
        self.subset.subset_state = ElementSubsetState(indices=inds)

    def test_write(self):
        fobj, tmp = tempfile.mkstemp()

        self.subset.write_mask(tmp)
        from ...external.astro import fits
        data = fits.open(tmp)[0].data
        expected = np.array([[0, 1, 1, 1],
                             [0, 0, 0, 0],
                             [0, 0, 0, 0],
                             [0, 0, 0, 0]], dtype=np.int16)
        np.testing.assert_array_equal(data, expected)

    def test_read(self):
        fobj, tmp = tempfile.mkstemp()

        self.subset.write_mask(tmp)
        sub2 = Subset(self.data)
        sub2.read_mask(tmp)
        mask1 = self.subset.to_mask()
        mask2 = sub2.to_mask()
        np.testing.assert_array_equal(mask1, mask2)

    def test_read_error(self):
        with pytest.raises(IOError) as exc:
            self.subset.read_mask('file_does_not_exist')
        assert exc.value.args[0] == ("Could not read file_does_not_exist "
                                     "(not a fits file?)")

    def test_write_unsupported_format(self):
        with pytest.raises(AttributeError) as exc:
            self.subset.write_mask('file_will_fail', format='.hd5')
        assert exc.value.args[0] == "format not supported: .hd5"


class TestSubsetState(object):

    def setup_method(self, method):
        self.state = SubsetState()

    def mask_check(self, mask, answer):
        self.state.to_mask = MagicMock()
        self.state.to_mask.return_value = mask
        np.testing.assert_array_equal(self.state.to_index_list(None), answer)

    def test_to_index_list_1d(self):
        mask = np.array([False, True])
        answer = np.array([1])
        self.mask_check(mask, answer)

    def test_to_index_list_2d(self):
        mask = np.array([[False, True], [False, True]])
        answer = np.array([1, 3])
        self.mask_check(mask, answer)

    def test_empty_to_index_1d(self):
        mask = np.array([False, False])
        answer = np.array([])
        self.mask_check(mask, answer)

    def test_empty_to_index_2d(self):
        mask = np.array([[False, False], [False, False]])
        answer = np.array([])
        self.mask_check(mask, answer)


class TestCompositeSubsetStateCopy(object):
    def assert_composite_copy(self, cls):
        """Copying composite state should create new
        state with same type, with copies of sub states"""
        state1 = MagicMock()
        state2 = MagicMock()
        s1 = cls(state1, state2)
        s2 = s1.copy()

        assert type(s1) == type(s2)
        assert s1.state1.copy() is s2.state1
        assert s1.state2.copy() is s2.state2

    def test_invert(self):
        self.assert_composite_copy(InvertState)

    def test_and(self):
        self.assert_composite_copy(AndState)

    def test_or(self):
        self.assert_composite_copy(OrState)

    def test_xor(self):
        self.assert_composite_copy(XorState)


class DummySubsetState(SubsetState):
    def to_mask(self, data, view=None):
        result = np.ones(data.shape, dtype=bool)
        if view is not None:
            result = result[view]
        return result


class TestSubsetViews(object):

    def setup_method(self, method):
        d = Data()
        c = Component(np.array([1, 2, 3, 4]))
        self.cid = d.add_component(c, 'test')
        self.s = d.new_subset()
        self.c = c
        self.s.subset_state = DummySubsetState()

    def test_cid_get(self):
        np.testing.assert_array_equal(self.s[self.cid],
                                      self.c.data)

    def test_label_get(self):
        np.testing.assert_array_equal(self.s['test'],
                                      self.c.data)

    def test_cid_slice(self):
        np.testing.assert_array_equal(self.s[self.cid, ::2],
                                      self.c.data[::2])

    def test_label_slice(self):
        np.testing.assert_array_equal(self.s['test', ::-1],
                                      self.c.data[::-1])


#Test Fancy Indexing into the various subset states


def roifac(comp, cid):
    from ..roi import RectangularROI
    from ..subset import RoiSubsetState

    result = RoiSubsetState()
    result.xatt = cid
    result.yatt = cid
    roi = RectangularROI()
    roi.update_limits(0.5, 0.5, 1.5, 1.5)
    result.roi = roi
    return result


def rangefac(comp, cid):
    from ..subset import RangeSubsetState
    return RangeSubsetState(.5, 2.5, att=cid)


def compfac(comp, cid, oper):
    s1 = roifac(comp, cid)
    s2 = rangefac(comp, cid)
    return oper(s1, s2)


def orfac(comp, cid):
    return compfac(comp, cid, op.or_)


def andfac(comp, cid):
    return compfac(comp, cid, op.and_)


def xorfac(comp, cid):
    return compfac(comp, cid, op.xor)


def invertfac(comp, cid):
    return ~rangefac(comp, cid)


def elementfac(comp, cid):
    return ElementSubsetState(np.array([0, 1]))


def inequalityfac(comp, cid):
    return cid > 2.5


def basefac(comp, cid):
    return SubsetState()


views = (np.s_[:],
         np.s_[::-1, 0],
         np.s_[0, :],
         np.s_[:, 0],
         np.array([[True, False], [False, True]]),
         np.where(np.array([[True, False], [False, True]])),
         np.zeros((2, 2), dtype=bool),
         )
facs = [roifac, rangefac, orfac, andfac, xorfac, invertfac,
        elementfac, inequalityfac, basefac]


@pytest.mark.parametrize(('statefac', 'view'), [(f, v) for f in facs
                                                for v in views])
def test_mask_of_view_is_view_of_mask(statefac, view):
    print statefac, view
    d = Data()
    d.edit_subset = d.new_subset()
    c = Component(np.array([[1, 2], [3, 4]]))
    cid = d.add_component(c, 'test')
    s = d.edit_subset
    s.subset_state = statefac(c, cid)

    v1 = s.to_mask(view)
    v2 = s.to_mask()[view]
    np.testing.assert_array_equal(v1, v2)

    v1 = s[cid, view]
    m0 = np.zeros_like(c.data, dtype=bool)
    m0[view] = True
    v2 = c.data[s.to_mask() & m0]
    np.testing.assert_array_equal(v1, v2)


def test_inequality_state_str():
    d = Data(x=[1, 2, 3], y=[2, 3, 4])
    x = d.id['x']
    y = d.id['y']

    assert str(x > 3) == '(x > 3)'
    assert str(x < 2) == '(x < 2)'
    assert str(x < y) == '(x < y)'
    assert str((3 * x) < 5) == '((3 * x) < 5)'
    assert str((x < y) & (x < 2)) == '((x < y) & (x < 2))'
    assert str((x < y) | (x < 2)) == '((x < y) | (x < 2))'
    assert str(~(x < y)) == '(~(x < y))'
    assert repr(x < 5) == ('<InequalitySubsetState: (x < 5)>')


class TestAttributes(object):

    def test_empty(self):
        assert SubsetState().attributes == tuple()

    def test_roi(self):
        d = Data(x=[1], y=[2])
        s = RoiSubsetState(xatt=d.id['x'], yatt=d.id['y'])
        assert s.attributes == (d.id['x'], d.id['y'])

    def test_range(self):
        d = Data(x=[1])
        s = RangeSubsetState(0, 1, att=d.id['x'])
        assert s.attributes == (d.id['x'],)

    def test_composite(self):
        d = Data(x=[1])
        s = RangeSubsetState(0, 1, att=d.id['x'])
        assert (s & s).attributes == (d.id['x'],)

    def test_not(self):
        d = Data(x=[1])
        s = RangeSubsetState(0, 1, att=d.id['x'])
        assert (~s).attributes == (d.id['x'],)

    def test_subset(self):
        d = Data(x=[1])
        s = d.new_subset()
        s.subset_state = RangeSubsetState(0, 1, att=d.id['x'])
        assert s.attributes == (d.id['x'],)

########NEW FILE########
__FILENAME__ = test_subset_group
from mock import MagicMock, patch
import numpy as np

from .. import DataCollection, Data, SubsetGroup
from .. import subset
from ..subset import SubsetState
from ..subset_group import coerce_subset_groups
from .test_state import clone


class TestSubsetGroup(object):

    def setup_method(self, method):
        x = Data(label='x', x=[1, 2, 3])
        y = Data(label='y', y=[2, 4, 8])
        self.dc = DataCollection([x, y])
        self.sg = SubsetGroup()

    def test_creation(self):
        self.sg.register(self.dc)
        sg = self.sg
        for subset, data in zip(sg.subsets, self.dc):
            assert subset is data.subsets[0]

    def test_attributes_matched_to_group(self):
        self.sg.register(self.dc)
        sg = self.sg
        for subset in sg.subsets:
            assert subset.subset_state is sg.subset_state
            assert subset.label is sg.label

    def test_attributes_synced_to_group(self):
        self.sg.register(self.dc)
        sg = self.sg
        sg.subsets[0].subset_state = SubsetState()
        sg.subsets[0].label = 'testing'
        for subset in sg.subsets:
            assert subset.subset_state is sg.subset_state
            assert subset.label is sg.label

    def test_set_style_overrides(self):
        self.sg.register(self.dc)
        sg = self.sg
        sg.subsets[0].style.color = 'blue'
        for s in sg.subsets[1:]:
            assert s.style.color != 'blue'
        assert sg.subsets[0].style.color == 'blue'

    def test_new_subset_group_syncs_style(self):
        sg = self.dc.new_subset_group()
        for s in sg.subsets:
            assert s.style == sg.style

    def test_set_group_style_clears_override(self):
        sg = self.dc.new_subset_group()
        style = sg.style.copy()
        style.parent = sg.subsets[0]
        sg.subsets[0].style = style
        style.color = 'blue'
        sg.style.color = 'red'
        assert sg.subsets[0].style.color == 'red'

    def test_new_data_creates_subset(self):
        sg = self.dc.new_subset_group()
        d = Data(label='z', z=[10, 20, 30])
        self.dc.append(d)
        assert d.subsets[0] in sg.subsets

    def test_remove_data_deletes_subset(self):
        sg = self.dc.new_subset_group()
        sub = self.dc[0].subsets[0]
        self.dc.remove(self.dc[0])
        assert sub not in sg.subsets

    def test_subsets_given_data_reference(self):
        sg = self.dc.new_subset_group()
        assert sg.subsets[0].data is self.dc[0]

    def test_data_collection_subset(self):
        sg = self.dc.new_subset_group()
        assert tuple(self.dc.subset_groups) == (sg,)
        sg2 = self.dc.new_subset_group()
        assert tuple(self.dc.subset_groups) == (sg, sg2)

    def test_remove_subset(self):
        sg = self.dc.new_subset_group()
        n = len(self.dc[0].subsets)
        self.dc.remove_subset_group(sg)
        assert len(self.dc[0].subsets) == n - 1

    def test_edit_broadcasts(self):
        sg = self.dc.new_subset_group()
        bcast = MagicMock()
        sg.subsets[0].broadcast = bcast
        bcast.reset_mock()
        sg.subsets[0].style.color = 'red'
        assert bcast.call_count == 1

    def test_braodcast(self):
        sg = self.dc.new_subset_group()
        bcast = MagicMock()
        sg.subsets[0].broadcast = bcast
        bcast.reset_mock()

        sg.subset_state = SubsetState()
        assert bcast.call_count == 1

        sg.style.color = '#123456'
        assert bcast.call_count == 2

        sg.label = 'new label'
        assert bcast.call_count == 3

    def test_auto_labeled(self):
        sg = self.dc.new_subset_group()
        assert sg.label is not None

    def test_label_color_cycle(self):
        sg1 = self.dc.new_subset_group()
        sg2 = self.dc.new_subset_group()

        assert sg1.label != sg2.label
        assert sg1.style.color != sg2.style.color

    def test_new_label(self):
        sg = self.dc.new_subset_group(label='test')
        assert sg.label == 'test'

    def test_new_state(self):
        state = SubsetState()
        sg = self.dc.new_subset_group(subset_state=state)
        assert sg.subset_state is state

    def test_deleted_subsets_dont_respawn(self):
        # regression test
        sg1 = self.dc.new_subset_group()
        self.dc.remove_subset_group(sg1)
        d = Data(label='z', z=[1, 2, 3])
        self.dc.append(d)
        assert len(d.subsets) == 0


class TestSerialze(TestSubsetGroup):

    def test_save_group(self):
        sg = self.dc.new_subset_group()
        sg2 = clone(sg)

        assert sg.style == sg2.style
        assert sg.label == sg2.label

    def test_save_subset(self):
        sg = self.dc.new_subset_group()
        sg.subset_state = self.dc[0].id['x'] > 1

        sub = sg.subsets[0]
        dc = clone(self.dc)

        sub2 = dc[0].subsets[0]

        np.testing.assert_array_equal(sub2.to_mask(), [False, True, True])
        assert sub2.style == sg.style
        assert sub2.label == sg.label

    def test_save_override(self):
        sg = self.dc.new_subset_group()
        sg.subsets[0].style.color = 'blue'

        dc = clone(self.dc)

        assert dc.subset_groups[0].style == sg.style
        assert dc.subset_groups[0].subsets[0].style.color == 'blue'


class TestCombination(object):

    def check_type_and_children(self, s1, s2, s3, statetype):
        assert isinstance(s3, statetype)
        assert s3.state1 is s1.subset_state
        assert s3.state2 is s2.subset_state

    def test_and(self):
        s1, s2 = SubsetGroup(), SubsetGroup()
        assert isinstance(s1 & s2, subset.AndState)

    def test_or(self):
        s1, s2 = SubsetGroup(), SubsetGroup()
        assert isinstance(s1 | s2, subset.OrState)

    def test_xor(self):
        s1, s2 = SubsetGroup(), SubsetGroup()
        assert isinstance(s1 ^ s2, subset.XorState)

    def test_invert(self):
        s1 = SubsetGroup()
        assert isinstance(~s1, subset.InvertState)


class TestCoerce(object):

    def setup_method(self, method):
        self.x = Data(label='x', x=[1, 2, 3])
        self.y = Data(label='y', y=[1, 2, 3])
        self.dc = DataCollection([self.x, self.y])

    def test_noop_on_good_setup(self):
        with patch('glue.core.subset_group.warn') as warn:
            coerce_subset_groups(self.dc)
        assert warn.call_count == 0

    def test_reassign_non_grouped_subsets(self):
        s = self.x.new_subset()
        dc = self.dc
        with patch('glue.core.subset_group.warn') as warn:
            coerce_subset_groups(dc)

        assert len(dc.subset_groups) == 1
        assert dc.subset_groups[0].subset_state is s.subset_state
        assert dc.subset_groups[0].style == s.style
        assert dc.subset_groups[0].label == s.label
        assert warn.call_count == 1

########NEW FILE########
__FILENAME__ = test_tree
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest

import numpy as np

from ..tree import Tree, NewickTree, DendroMerge


class TestTree(object):

    def test_tree_creation(self):

        root = Tree(id=0, value=100)
        c1 = Tree()
        c2 = Tree()
        c11 = Tree()
        c12 = Tree()
        c21 = Tree()
        c211 = Tree()

        root.add_child(c1)
        root.add_child(c2)
        c1.add_child(c11)
        c1.add_child(c12)
        c2.add_child(c21)
        c21.add_child(c211)

        assert root.id == 0
        assert root.value == 100

        assert c1.parent is root
        assert c2.parent is root
        assert c11.parent is c1
        assert c12.parent is c1
        assert c21.parent is c2
        assert c211.parent is c21

        assert c1 in root.children
        assert c2 in root.children
        assert c11 in c1.children
        assert c12 in c1.children
        assert c21 in c2.children
        assert c211 in c21.children

    def test_newick_tree(self):

        # no labels
        n0 = "0;"
        n1 = "(0,1)2;"
        n2 = "((0,1)4,(2,3)5)6;"
        n3 = "(3,(2,(0,1)4)5)6;"
        n4 = "(1,2,3,4)5;"

        tree0 = NewickTree(n0)
        tree1 = NewickTree(n1)
        tree2 = NewickTree(n2)
        tree3 = NewickTree(n3)
        tree4 = NewickTree(n4)

        assert tree0.id == 0
        assert tree1.id == 2
        assert not tree1.value
        assert 0 in [x.id for x in tree1.children]
        assert 1 in [x.id for x in tree1.children]

        assert tree2.id == 6
        assert not tree1.value
        assert 4 in [x.id for x in tree2.children]
        assert 5 in [x.id for x in tree2.children]
        assert not 0 in [x.id for x in tree2.children]
        assert not 1 in [x.id for x in tree2.children]

        assert 1 in [x.id for x in tree4.children]
        assert 2 in [x.id for x in tree4.children]
        assert 3 in [x.id for x in tree4.children]
        assert 4 in [x.id for x in tree4.children]

        assert n1 == tree1.to_newick()
        assert n2 == tree2.to_newick()
        assert n3 == tree3.to_newick()
        assert n4 == tree4.to_newick()

        # with labels
        n1 = "(0:0,1:10)2:20;"
        n2 = "((0:0,1:10)4:4,(2:20,3:30)5:50)6:60;"
        n3 = "(3:30,(2:20,(0:0,1:10)4:40)5:50)6:60;"

        tree1 = NewickTree(n1)
        tree2 = NewickTree(n2)
        tree3 = NewickTree(n3)

        assert tree1.value == '20'

        assert n1 == tree1.to_newick()
        assert n2 == tree2.to_newick()
        assert n3 == tree3.to_newick()

    def test_dendro_merge(self):
        m1 = np.array([[0, 1], [2, 3], [4, 5]])
        n1 = "((0,1)4,(2,3)5)6;"
        m2 = np.array([[0, 1], [4, 2], [5, 3]])
        n2 = "(3,(2,(0,1)4)5)6;"
        t1 = DendroMerge(m1)
        t2 = DendroMerge(m2)

        #invalid merge lists
        m3 = np.array([[0, 1], [5, 2], [5, 3]])
        m4 = np.array([[-1, 1], [4, 2], [5, 3]])
        m5 = np.array([[0, 1], [1, 2], [5, 3]])

        assert t1.to_newick() == n1
        assert t2.to_newick() == n2
        assert t1.id == 6
        assert t2.id == 6

        with pytest.raises(TypeError) as exc:
            DendroMerge(m3)
        assert exc.value.args[0] == "Invalid mergelist: contains duplicates"
        with pytest.raises(TypeError) as exc:
            DendroMerge(m4)
        assert exc.value.args[0] == ("Invalid mergelist: does not "
                                     "run from 0-nleaf")

        with pytest.raises(TypeError) as exc:
            DendroMerge(m5)
        assert exc.value.args[0] == "Invalid mergelist: contains duplicates"

########NEW FILE########
__FILENAME__ = test_tree_layout
import numpy as np

import pytest

from .. import tree_layout as tl
from ..tree import NewickTree


def test_invalid_input():
    with pytest.raises(TypeError) as exc:
        layout = tl.TreeLayout(None)
    assert exc.value.args[0] == 'Input not a tree object: %s' % type(None)


def test_layout_indexable_by_tree_or_id():
    tree = NewickTree('((0,1)4,(2,3)5)6;')
    layout = tl.TreeLayout(tree)
    assert layout[tree] is layout[tree.id]


def test_default_layout():
    tree = NewickTree('((0,1)4,(2,3)5)6;')
    layout = tl.TreeLayout(tree)

    t6 = tree
    t4, t5 = t6.children
    t0, t1 = t4.children
    t2, t3 = t5.children

    ts = [t0, t1, t2, t3, t4, t5, t6]
    xs = [-1.5, -.5, .5, 1.5, -1, 1, 0]
    ys = [2, 2, 2, 2, 1, 1, 0]

    for t, x, y in zip(ts, xs, ys):
        assert layout[t].x == x
        assert layout[t].y == y
        assert layout[t].width == 1
        assert layout[t].height == 0


def test_layout_single_leaf():
    tree = NewickTree('0;')
    layout = tl.TreeLayout(tree)
    assert layout[tree].x == 0
    assert layout[tree].y == 0


def test_pick():

    tree = NewickTree('((0,1)4,(2,3)5)6;')
    layout = tl.TreeLayout(tree)

    #exact match
    assert layout.pick(0, 0) is tree

    #closest match, below
    assert layout.pick(0, -1) is tree

    #only pick if y position is <= node
    assert layout.pick(-.01, .01) is tree.children[0]
    assert layout.pick(0, 2.1) is None


def test_tree_to_xy():
    tree = NewickTree('(0,1)2;')
    layout = tl.TreeLayout(tree)

    x = np.array([0, 0, -.5, -.5, None, 0, .5, .5, None], dtype=float)
    y = np.array([0, 0, 0, 1, None, 0, 0, 1, None], dtype=float)

    xx, yy = layout.tree_to_xy(tree)

    np.testing.assert_array_almost_equal(x, np.array(xx, dtype=float))
    np.testing.assert_array_almost_equal(y, np.array(yy, dtype=float))


def test_tree_to_xy_list():
    tree = NewickTree('(0,1)2;')
    layout = tl.TreeLayout(tree)

    x = np.array([-0.5, None, .5, None], dtype=float)
    y = np.array([1, None, 1, None], dtype=float)

    xx, yy = layout.tree_to_xy(tree.children)

    np.testing.assert_array_almost_equal(x, np.array(xx, dtype=float))
    np.testing.assert_array_almost_equal(y, np.array(yy, dtype=float))


def test_branch_to_xy_branch():
    tree = NewickTree('((0,1)4,(2,3)5)6;')
    layout = tl.TreeLayout(tree)

    x = [-1, -1, 0]
    y = [1, 0, 0]

    xx, yy = layout.branch_to_xy(tree.children[0])

    np.testing.assert_array_almost_equal(x, xx)
    np.testing.assert_array_almost_equal(y, yy)


def test_branch_to_xy_root():
    tree = NewickTree('((0,1)4,(2,3)5)6;')
    layout = tl.TreeLayout(tree)

    x = [0]
    y = [0]
    xx, yy = layout.branch_to_xy(tree)
    np.testing.assert_array_almost_equal(x, xx)
    np.testing.assert_array_almost_equal(y, yy)


def test_branch_to_xy_leaf():
    tree = NewickTree('((0,1)4,(2,3)5)6;')
    layout = tl.TreeLayout(tree)

    x = [-1.5, -1.5, -1]
    y = [2, 1, 1]
    xx, yy = layout.branch_to_xy(tree.children[0].children[0])
    np.testing.assert_array_almost_equal(x, xx)
    np.testing.assert_array_almost_equal(y, yy)


def test_branch_to_xy_list():
    tree = NewickTree('((0,1)4,(2,3)5)6;')
    layout = tl.TreeLayout(tree)
    x = np.array([0, None, 0, None], dtype=float)
    y = np.array([0, None, 0, None], dtype=float)

    xx, yy = layout.branch_to_xy([tree, tree])
    np.testing.assert_array_almost_equal(x, np.array(xx, dtype=float))
    np.testing.assert_array_almost_equal(y, np.array(yy, dtype=float))

########NEW FILE########
__FILENAME__ = test_tree_traversal
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest

from ..tree import NewickTree
from ..tree_traversal import PreOrderTraversal, PostOrderTraversal


def pre_string(tree):
    result = []
    for t in PreOrderTraversal(tree):
        result.append(str(t.id))
    return ''.join(result)


def post_string(tree):
    result = []
    for t in PostOrderTraversal(tree):
        result.append(str(t.id))
    return ''.join(result)


class TestTreeTraversal(object):

    def setup_method(self, method):
        n0 = "0;"
        n1 = "(0,1)2;"
        n2 = "((0,1)4,(2,3)5)6;"
        n3 = "(3,(2,(0,1)4)5)6;"
        n4 = "(1,2,3,4)5;"

        self.t0 = NewickTree(n0)
        self.t1 = NewickTree(n1)
        self.t2 = NewickTree(n2)
        self.t3 = NewickTree(n3)
        self.t4 = NewickTree(n4)

    def test_leaf(self):
        assert pre_string(self.t0) == '0'
        assert post_string(self.t0) == '0'

    def test_simple(self):
        assert pre_string(self.t1) == '201'
        assert post_string(self.t1) == '012'

    def test_two_deep(self):
        assert pre_string(self.t2) == '6401523'
        assert post_string(self.t2) == '0142356'

    def test_unbalanced(self):
        assert pre_string(self.t3) == '6352401'
        assert post_string(self.t3) == '3201456'

    def test_non_binary(self):
        assert pre_string(self.t4) == '51234'
        assert post_string(self.t4) == '12345'

    def test_input_check(self):
        with pytest.raises(TypeError) as exc:
            PreOrderTraversal(5)
        assert exc.value.args[0].startswith("Input is not a tree object")
        with pytest.raises(TypeError) as exc:
            PreOrderTraversal(None)
        assert exc.value.args[0].startswith("Input is not a tree object")
        with pytest.raises(TypeError) as exc:
            PostOrderTraversal(5)
        assert exc.value.args[0].startswith("Input is not a tree object")

########NEW FILE########
__FILENAME__ = test_util
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import numpy as np

from ..util import (file_format, point_contour, view_shape, facet_subsets,
                    colorize_subsets, coerce_numeric)


class TestRelim(object):
    pass


class TestFileFormat(object):

    def test_gz(self):
        fmt = file_format('test.tar.gz')
        assert fmt == 'tar'

    def test_normal(self):
        fmt = file_format('test.data')
        assert fmt == 'data'

    def test_underscores(self):
        fmt = file_format('test_file.fits_file')
        assert fmt == 'fits_file'

    def test_multidot(self):
        fmt = file_format('test.a.b.c')
        assert fmt == 'c'

    def test_nodot(self):
        fmt = file_format('test')
        assert fmt == ''


class TestPointContour(object):

    def test(self):
        data = np.array([[0, 0, 0, 0],
                         [0, 2, 3, 0],
                         [0, 4, 2, 0],
                         [0, 0, 0, 0]])
        xy = point_contour(2, 2, data)
        x = np.array([2., 2. + 1. / 3., 2., 2., 1, .5, 1, 1, 2])
        y = np.array([2. / 3., 1., 2., 2., 2.5, 2., 1., 1., 2. / 3])

        np.testing.assert_array_almost_equal(xy[:, 0], x)
        np.testing.assert_array_almost_equal(xy[:, 1], y)


def test_view_shape():
    assert view_shape((10, 10), np.s_[:]) == (10, 10)
    assert view_shape((10, 10, 10), np.s_[:]) == (10, 10, 10)
    assert view_shape((10, 10), np.s_[:, 1]) == (10,)
    assert view_shape((10, 10), np.s_[2:3, 2:3]) == (1, 1)
    assert view_shape((10, 10), None) == (10, 10)
    assert view_shape((10, 10), ([1, 2, 3], [2, 3, 4])) == (3,)


class TestFacetSubsets(object):

    def setup_method(self, method):
        from glue.core import Data, DataCollection
        self.data = Data(label='data', x=[1, 2, 3, 4, 5, 6, 7])
        self.collect = DataCollection([self.data])

    def test_facet_fully_specified(self):
        grps = facet_subsets(self.collect, self.data.id['x'],
                             lo=3, hi=6, steps=3)
        assert len(grps) == 3
        np.testing.assert_array_equal(grps[0].subsets[0].to_mask(),
                                      [False, False, True,
                                       False, False, False, False])
        np.testing.assert_array_equal(grps[1].subsets[0].to_mask(),
                                      [False, False, False,
                                       True, False, False, False])
        np.testing.assert_array_equal(grps[2].subsets[0].to_mask(),
                                      [False, False, False,
                                       False, True, False, False])

    def test_default_lo_value(self):
        grps = facet_subsets(self.collect, self.data.id['x'],
                             hi=7, steps=2)
        assert len(grps) == 2
        np.testing.assert_array_equal(grps[0].subsets[0].to_mask(),
                                      [True, True, True, False,
                                       False, False, False])
        np.testing.assert_array_equal(grps[1].subsets[0].to_mask(),
                                      [False, False, False, True,
                                       True, True, False])

    def test_default_hi_value(self):
        grps = facet_subsets(self.collect, self.data.id['x'],
                             lo=3, steps=2)
        assert len(grps) == 2
        np.testing.assert_array_equal(grps[0].subsets[0].to_mask(),
                                      [False, False, True, True, False,
                                       False, False])
        np.testing.assert_array_equal(grps[1].subsets[0].to_mask(),
                                      [False, False, False, False, True,
                                       True, False])

    def test_default_steps(self):
        grps = facet_subsets(self.collect, self.data.id['x'])
        assert len(grps) == 5

    def test_prefix(self):
        grps = facet_subsets(self.collect, self.data.id['x'], prefix='test')
        for i, s in enumerate(grps, start=1):
            assert s.label == "test_%i" % i

        grps = facet_subsets(self.collect, self.data.id['x'])
        for i, s in enumerate(grps, start=1):
            assert s.label.startswith('x')

    def test_facet_reversed(self):
        grps = facet_subsets(self.collect, self.data.id['x'],
                             lo=3, hi=1, steps=2)
        assert len(grps) == 2
        # ranges should be (2, 3] and (1, 2]
        np.testing.assert_array_equal(grps[0].subsets[0].to_mask(),
                                      [False, False, True, False, False,
                                       False, False])
        np.testing.assert_array_equal(grps[1].subsets[0].to_mask(),
                                      [False, True, False, False, False,
                                       False, False])


def test_colorize_subsets():
    from glue.core import Data, DataCollection
    from matplotlib.cm import gray

    data = Data(label='test', x=[1, 2, 3])
    dc = DataCollection(data)
    grps = facet_subsets(dc, data.id['x'], steps=2)
    colorize_subsets(grps, gray)

    assert grps[0].style.color == '#000000'
    assert grps[1].style.color == '#ffffff'


def test_colorize_subsets_clip():
    from glue.core import Data, DataCollection
    from matplotlib.cm import gray

    data = Data(label='test', x=[1, 2, 3])
    grps = facet_subsets(DataCollection(data), data.id['x'], steps=2)

    colorize_subsets(grps, gray, hi=0.5)
    assert grps[0].style.color == '#000000'
    assert grps[1].style.color == '#808080'

    colorize_subsets(grps, gray, lo=0.5)
    assert grps[0].style.color == '#808080'
    assert grps[1].style.color == '#ffffff'


def test_coerce_numeric():

    x = np.array(['1', '2', '3.14', '4'])

    np.testing.assert_array_equal(coerce_numeric(x),
                                  [1, 2, 3.14, 4])

    x = np.array([1, 2, 3])

    assert x is coerce_numeric(x)

########NEW FILE########
__FILENAME__ = util
import tempfile
from contextlib import contextmanager
import os
import zlib

from mock import MagicMock

from ... import core
from ...core.application_base import Application


@contextmanager
def make_file(contents, suffix, decompress=False):
    """Context manager to write data to a temporary file,
    and delete on exit

    :param contents: Data to write. string
    :param suffix: File suffix. string
    """
    if decompress:
        contents = zlib.decompress(contents)

    try:
        _, fname = tempfile.mkstemp(suffix=suffix)
        with open(fname, 'wb') as infile:
            infile.write(contents)
        yield fname
    finally:
        os.unlink(fname)


@contextmanager
def simple_catalog():
    """Context manager to create a temporary data file

    :param suffix: File suffix. string
    """
    with make_file('#a, b\n1, 2\n3, 4', '.csv') as result:
        yield result


def simple_session():
    collect = core.data_collection.DataCollection()
    hub = core.hub.Hub()
    result = core.Session(data_collection=collect, hub=hub,
                          application=MagicMock(Application),
                          command_stack=core.CommandStack())
    result.command_stack.session = result
    return result

########NEW FILE########
__FILENAME__ = tree
import numpy as np

__all__ = ['Tree', 'NewickTree', 'DendroMerge']


class Tree(object):
    """
    Base class for hierarchical segmentations of data sets.

    The tree is represented by its root node, which contains reference
    to 0 or more children nodes.

    Attributes
    ----------
    id: Integer
          An identifier for this node.
    parent: Tree instance
          A reference to this node's parent, if any
    value:
          A value associated with this node
    children: List of Tre instances
          The children of this node
    index_map: Component instance
          The tree id that each element to which each
          element in the original data belongs.
    """

    def __init__(self, id=None, value=None, index_map=None):
        """
        Create a new Tree object.

        Parameters
        ----------
        id: Integer
              Id of the tree
        value:
              Value of the tree
        index_map: Component instance
              index_map of the data


        Raises
        ------
        TypeError: if any of the inputs are the wrong type
        """
        if (id is not None):
            try:
                id = int(id)
            except ValueError:
                raise TypeError("Input id must be in integer")

        self.id = id

        self.value = value

        self.children = []

        self.parent = None

        self.index_map = index_map

        self._index = None

    def add_child(self, child):
        """
        Add a new child node to this tree.

        This is the preferred way for building trees, as it takes care
        of input checking and linking between parent and child. Do not
        append to the children attribute directly.

        Parameters
        ----------
        child: Tree instance
             The child to add

        Raises
        ------
        TypeError: If the input is not a Tree instance
        """

        if (not isinstance(child, Tree)):
            raise TypeError("Child must be a tree instance")

        self.children.append(child)
        child.parent = self

    def to_newick(self):
        """
        Convert the tree to a newick string

        Returns
        -------
        A newick string representation of the tree
        """

        result = ''
        if (self.children):
            result = '(' + ','.join([c.to_newick()[0:-1]
                                     for c in self.children]) + ')'
        if (self.id is not None):
            result += ('%s' % self.id)
        if (self.value is not None):
            result += (':%s' % self.value)
        return result + ';'

    @property
    def index(self):
        """
        A flattened index of all the nodes at and below this
        branch

        This property is a dictionary holding each node in the
        tree, keyed by the node ids. Index will only work if the node
        id's are unique.

        The user of the index is responsible for making sure that the
        tree hasn't changed since the index was created.
        """
        if self._index is not None:
            return self._index

        self._index = {}
        stack = [self]
        while stack:
            s = stack.pop()
            if s.id in self._index:
                raise KeyError("Cannot index this tree -- "
                               "node id's are non-unique")
            self._index[s.id] = s
            for c in s.children:
                stack.append(c)
        return self._index

    def get_subtree_indices(self):
        result = []
        stack = [self]
        while stack:
            s = stack.pop()
            result.append(s.id)
            stack += s.children
        return result

    def get_leaves(self):
        st = self.get_subtree_indices()
        return [x for x in st if len(x.children) == 0]

    def get_ancestors(self):
        if self.parent is None:
            return []
        result = [self.parent]
        while result[-1].parent is not None:
            result.append(result[-1].parent)
        return result


class NewickTree(Tree):
    """
    A subclass of Tree, which generates trees from Newick Strings.

    Attributes
    ----------
    newick: The newick string
    """

    def __init__(self, newick, index_map=None):
        """
        Create a new tree from a newick string representation of a
        tree

        Attributes
        ----------
        newick: String
              The newick string
        index_map: Component
              The index map of the data
        """
        self.newick = newick

        self.__validateNewick()
        (id, value) = self.__parse_id_value()
        Tree.__init__(self, index_map=index_map,
                      id=id, value=value)
        self.__parse_children()

    def __validateNewick(self):
        """
        Ensure that the suppied string represents a valid Newick
        description.

        Raises
        ------
        ValueError: If the newick string is invalid
        """
        pass

    def __parse_id_value(self):
        """
        Parse the root node id and value

        Returns
        -------
        The root's id and value, as a list
        """

        newick = self.newick
        first = max([newick.rfind(')'),
                     newick.rfind(',')]) + 1
        comma = newick.find(',', first)
        if comma == -1:
            comma = len(newick) - 1
        paren = newick.find(')', first)
        if paren == -1:
            paren = len(newick) - 1

        last = min([paren, comma])
        mid = newick.find(':', first)

        if (mid != -1):
            id = newick[first:mid]
            value = newick[mid + 1:last]
        else:
            id = newick[first:last]
            value = None
        return (id, value)

    def __parse_children(self):
        """
        Find and parse the children of the root.

        This method recursively builds the tree, and populates the
        root's children attribute.

        Side Effects
        ------------
        Any children currently stored in the root's children list are
        erased.
        """
        newick = self.newick
        if newick[0] != '(':
            return
        depth = 0
        start = 1
        self.children = []
        for i in range(1, len(newick)):
            if (newick[i] == '('):
                depth += 1
            elif (newick[i] == ')' and depth != 0):
                depth -= 1
            elif ((newick[i] == ',' or newick[i] == ')')
                  and depth == 0):
                child = NewickTree(newick[start:i] + ';',
                                   index_map=self.index_map)
                self.add_child(child)
                start = i + 1


class DendroMerge(Tree):
    """
    A dendrogram created from a merge array.

    The merge array is a [nleaf - 1, 2] array where the ith row lists
    the 2 nodes merge to form node nleaf + i.  This data structure is
    used in many older dendrogram creation tools (e.g., that of
    Rosolowsky et al. 2008ApJ...679.1338R)
    """

    def __init__(self, merge_list,
                 index_map=None, _id=-1):
        """
        Create a new DendroMerge tree

        Parameters
        ----------
        merge_list: numpy array
                  a [nleaf - 1, 2] merge list (see class description above)
        index_map: Component
                 See Tree documentation

        """

        if(_id == -1):
            self.validate_mergelist(merge_list)
            nleaf = merge_list.shape[0] + 1
            _id = 2 * nleaf - 2
        else:
            nleaf = merge_list.shape[0] + 1

        Tree.__init__(self, id=_id,
                      index_map=index_map)

        # base case: leaf
        if (_id < nleaf):
            return
        # recursive case: branch. Create children
        else:
            c1 = min(merge_list[_id - nleaf, :])
            c2 = max(merge_list[_id - nleaf, :])
            c1 = DendroMerge(merge_list,
                             index_map=index_map,
                             _id=c1)
            c2 = DendroMerge(merge_list,
                             index_map=index_map,
                             _id=c2)
            self.add_child(c1)
            self.add_child(c2)

    def validate_mergelist(self, merge_list, msg=None):
        """
        Ensure that merge_list is a vlid merge list

        A valid merge_list is a [nleaf - 1, 2] numpy array,
        that includes the numbers 0 through 2 * nleaf - 3
        exactly once.

        Parameters
        ----------
        merge_list: ndarray instance

        Raises
        ------
        TypeError: If the merge_list is invalid
        """

        if (not isinstance(merge_list, np.ndarray)):
            raise TypeError("Invalid mergelist: not a numpy array")
        if (merge_list.shape[1] != 2):
            raise TypeError("Invalid mergelist: not a 2 column array")

        f = merge_list.flatten()
        if (len(f) != len(set(f))):
            raise TypeError("Invalid mergelist: contains duplicates")
        if ((min(f) != 0) or (max(f) != len(f) - 1)):
            raise TypeError("Invalid mergelist: does not "
                            "run from 0-nleaf")

########NEW FILE########
__FILENAME__ = tree_layout
import numpy as np

from .tree import Tree


class TreeLayout(object):
    """ The TreeLayout class maps trees onto an xy coordinate space for
    plotting.

    TreeLayout provides a dictionary-like interface for access to the
    location of each node in a tree. The typical use looks something like:

    tl = TreeLayout(tree_object)
    x_location = tl[key].x
    y_location = t1[key].y
    width = t1[key].width
    height = t1[key].height

    where key is either a reference to one of the nodes in the tree,
    or the id of that node.

    In this base class, the layout assigns each node a width of 1. It
    places the root at (0,0). The y position of every other node is
    one higher than its parent, and the x location is such that
    subtrees are centered over the parent tree.

    Subclasses of TreeLayout can override the layout() method to
    provide alternative layout styles.
    """

    class Layout(object):
        """ A small class to hold the layout information for each
        tree node.

        Attributes:
        -----------
        node: Tree instance
              The node that this layout object describes
        x: X location of this node
        y: Y location of this node
        width: Width of this node
        height: Height of this node

        """
        def __init__(self, node, x=0., y=0., width=0., height=0.):
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.node = node

        def __str__(self):
            return ("Node %s: (x, y) = (%f, %f). (w x h) = (%f, %f)" %
                    (self.node.id, self.x, self.y, self.width, self.height))

    def __init__(self, tree):
        """ Create a new TreeLayout object

        Parameters:
        -----------
        Tree: Tree instance
              The root node of the tree to layout. The tree must be
              indexable (i.e. it must have the .index property)

        """

        if not isinstance(tree, Tree):
            raise TypeError("Input not a tree object: %s" % type(tree))

        self.tree = tree
        self._dict = {}

        try:
            tree.index
        except KeyError:
            raise TypeError("Cannot create tree layout -- "
                            "input tree can't be indexed")
        self.layout()

    def __getitem__(self, key):
        return self._dict[key]

    def layout(self):
        """
        Calculate the layout of this tree.
        """
        self._tree_width(self.tree)
        self._tree_pos(self.tree)
        for t in self.tree.index:
            self[t].width = 1

    def _tree_width(self, tree):
        """
        Recursively calculates the width of each subtree. Also populates the
        layout dictionary.

        """
        node = TreeLayout.Layout(tree, x=0., y=0.,
                                 width=1., height=0.)
        self._dict[tree] = node
        self._dict[tree.id] = node

        width = 0.
        for c in tree.children:
            self._tree_width(c)
            width += self[c].width
            node.width = width

    def _tree_pos(self, tree):
        """
        Based on the width of each subtree, recursively moves the
        subtrees so they don't overlap.
        """
        w = 0.
        node = self[tree]
        for c in tree.children:
            self[c].x = node.x - node.width / 2. + w + self[c].width / 2.
            w += self[c].width
            self[c].y = node.y + 1
            self._tree_pos(c)

    def pick(self, x, y):
        """
        Based on the layout of the tree, choose a nearby branch to an
        x,y location

        Parameters:
        -----------
        x: The x coordinate to search from
        y: The y coordinate to search from

        Outputs:
        --------
        A reference to the closest tree node, if one is
        found. Otherwise, returns None

        """
        sz = len(self.tree.index)
        off = np.zeros(sz)
        candidate = np.zeros(sz, dtype=bool)

        for i, t in enumerate(self.tree.index):
            off[i] = abs(x - self[t].x)
            parent = self[t].node.parent
            if parent:
                candidate[i] = self[parent].y <= y < self[t].y
            else:
                candidate[i] = y <= self[t].y
        if not candidate.any():
            return None

        off[~candidate] = off.max()
        best = np.argmin(off)
        return self.tree.index[best]

    def tree_to_xy(self, tree):
        """
        Convert the locations of one or more (sub)trees into a list of
        x,y coordinates suitable for plotting.

        Parameters:
        -----------
        tree: Tree instance, or list of trees
              The (sub) tree(s) to generate xy coordinates for

        Outputs:
        --------
        A list of x and y values tracing the tree. If the input is a
        list of trees, then the xy list for each tree will be
        separated by None. This is convenient for plotting to
        matplotlib, since it will not draw lines between the different
        trees.

        """
        #code for when t is a list of trees
        if isinstance(tree, list):
            x = []
            y = []
            for t in tree:
                xx, yy = self.tree_to_xy(t)
                x.extend(xx)
                y.extend(yy)
                x.append(None)
                y.append(None)
            return (x, y)

        # code for when tree is a scalar
        x = [self[tree].x]
        y = [self[tree].y]
        for c in tree.children:
            xx, yy = self.tree_to_xy(c)
            x.extend([self[tree].x, xx[0]])
            y.extend([self[tree].y, self[tree].y])
            x += xx
            y += yy
            x.append(None)
            y.append(None)
        return (x, y)

    def branch_to_xy(self, branch):
        """
        Convert one or more single branches to a list of line segments
        for plotting.

        Parameters:
        -----------
        branch: Tree instance, or id of a tree, or a list of these
              The branch(es) to consider

        Outputs:
        --------
        A set of xy coordinates describing the branches

        """
        # code for when branch is a list of branches
        if isinstance(branch, list):
            x = []
            y = []
            for b in branch:
                xx, yy = self.branch_to_xy(b)
                x.extend(xx)
                y.extend(yy)
                x.append(None)
                y.append(None)
            return (x, y)

        #code for when branch is a scalar
        node = self[branch].node
        parent = node.parent
        if parent:
            x = [self[branch].x, self[branch].x, self[parent].x]
            y = [self[branch].y, self[parent].y, self[parent].y]
            return (x, y)
        else:
            return ([self[branch].x], [self[branch].y])


class DendrogramLayout(TreeLayout):

    def __init__(self, tree, data):
        self.data = data
        super(DendrogramLayout, self).__init__(tree)

    def layout(self):
        super(DendrogramLayout, self).layout()
        self.set_height()

    def set_height(self):

        nbranch = len(self.tree.index)
        nleaf = (nbranch + 1) / 2

        hival = self.data.max()
        for id in self.tree.index:
            self[id].y = hival

        for id in self.tree.index:
            hit = np.where(self.tree.index_map == id)
            assert(len(hit) > 0)

            if id < nleaf:
                self[id].y = self.data[hit].max()

            if len(hit) == 0:
                loval = 0
            else:
                loval = self.data[hit].min()
            parent = self[id].node.parent
            if not parent:
                continue
            self[parent].y = min(self[parent].y, loval)

########NEW FILE########
__FILENAME__ = tree_traversal
from .tree import Tree


class TreeTraversal(object):
    def __init__(self, tree):
        if not isinstance(tree, Tree):
            raise TypeError("Input is not a tree object: %s" %
                            type(tree))
        self.tree = tree
        self.stack = [tree]

    def __iter__(self):
        return self

    def next(self):
        raise NotImplementedError()


class PreOrderTraversal(TreeTraversal):

    def next(self):
        if not self.stack:
            raise StopIteration()
        result = self.stack.pop()
        c = result.children

        for i in range(len(c)):
            self.stack.append(c[len(c) - i - 1])
        return result


class PostOrderTraversal(TreeTraversal):

    def __init__(self, tree):
        TreeTraversal.__init__(self, tree)
        self.popped = {}

    def next(self):
        if not self.stack:
            raise StopIteration()

        result = self.stack.pop()
        c = result.children
        if result in self.popped:
            return result

        self.popped[result] = 1
        self.stack.append(result)
        for i in range(len(c)):
            self.stack.append(c[len(c) - i - 1])

        return self.next()

########NEW FILE########
__FILENAME__ = util
import logging
from contextlib import contextmanager

import numpy as np


def identity(x):
    return x


def relim(lo, hi, log=False):
    logging.getLogger(__name__).debug("Inputs to relim: %r %r", lo, hi)
    x, y = lo, hi
    if log:
        if lo < 0:
            x = 1e-5
        if hi < 0:
            y = 1e5
        return x * .95, y * 1.05
    delta = y - x
    return (x - .02 * delta, y + .02 * delta)


def file_format(filename):
    if filename.find('.') == -1:
        return ''
    if filename.lower().endswith('.gz'):
        result = filename.lower().rsplit('.', 2)[1]
    else:
        result = filename.lower().rsplit('.', 1)[1]
    return result


def point_contour(x, y, data):
    """Calculate the contour that passes through (x,y) in data

    :param x: x location
    :param y: y location
    :param data: 2D image
    :type data: :class:`numpy.ndarray`

    Returns:

       * A (nrow, 2column) numpy array. The two columns give the x and
         y locations of the contour vertices
    """
    try:
        from scipy import ndimage
    except ImportError:
        raise ImportError("Image processing in Glue requires SciPy")

    inten = data[y, x]
    labeled, nr_objects = ndimage.label(data >= inten)
    z = data * (labeled == labeled[y, x])
    y, x = np.mgrid[0:data.shape[0], 0:data.shape[1]]
    from matplotlib import _cntr
    cnt = _cntr.Cntr(x, y, z)
    xy = cnt.trace(inten)
    if not xy:
        return None
    xy = xy[0]
    return xy


def split_component_view(arg):
    """Split the input to data or subset.__getitem__ into its pieces.

    :param arg: The input passed to data or subset.__getitem__.
                Assumed to be either a scalar or tuple

    :rtype: tuple

    The first item is the Component selection (a ComponentID or
    string)

    The second item is a view (tuple of slices, slice scalar, or view
    object)
    """
    if isinstance(arg, tuple):
        if len(arg) == 1:
            raise TypeError("Expected a scalar or >length-1 tuple, "
                            "got length-1 tuple")
        if len(arg) == 2:
            return arg[0], arg[1]
        return arg[0], arg[1:]
    else:
        return arg, None


def join_component_view(component, view):
    """Pack a componentID and optional view into single tuple

    Returns an object compatible with data.__getitem__ and related
    methods.  Handles edge cases of when view is None, a scalar, a
    tuple, etc.

    :param component: ComponentID
    :param view: view into data, or None

    """
    if view is None:
        return component
    result = [component]
    try:
        result.extend(view)
    except TypeError:  # view is a scalar
        result = [component, view]

    return tuple(result)


def view_shape(shape, view):
    """Return the shape of a view of an array

    :param shape: Tuple describing shape of the array
    :param view: View object -- a valid index into a numpy array, or None

    Returns equivalent of np.zeros(shape)[view].shape
    """
    if view is None:
        return shape
    shp = tuple(slice(0, s, 1) for s in shape)
    xy = np.broadcast_arrays(*np.ogrid[shp])
    assert xy[0].shape == shape
    return xy[0][view].shape


def color2rgb(color):
    from matplotlib.colors import ColorConverter
    result = ColorConverter().to_rgb(color)
    return result


def facet_subsets(data_collection, cid, lo=None, hi=None, steps=5,
                  prefix=None, log=False):
    """Create a series of subsets that partition the values of
    a particular attribute into several bins

    This creates `steps` new subet groups, adds them to the data collection,
    and returns the list of newly created subset groups.

    :param data: DataCollection object to use
    :type data: :class:`~glue.core.data_collection.DataCollection`

    :param cid: ComponentID to facet on
    :type data: :class:`~glue.core.data.ComponentID`

    :param lo: The lower bound for the faceting. Defaults to minimum value
               in data
    :type lo: float

    :param hi: The upper bound for the faceting. Defaults to maximum
               value in data
    :type hi: float

    :param steps: The number of subsets to create. Defaults to 5
    :type steps: int

    :param prefix: If present, the new subsets will be labeled `prefix_1`, etc.
    :type prefix: str

    :param log: If True, space divisions logarithmically. Default=False
    :type log: bool

    :returns: List of :class:`~glue.core.subset_group.SubsetGroup` instances
              added to `data`

    Example::

        facet_subset(data, data.id['mass'], lo=0, hi=10, steps=2)

    creates 2 new subsets. The first represents the constraint 0 <=
    mass < 5. The second represents 5 <= mass < 10::

        facet_subset(data, data.id['mass'], lo=10, hi=0, steps=2)

    Creates 2 new subsets. The first represents the constraint 10 >= x > 5
    The second represents 5 >= mass > 0::

        facet_subset(data, data.id['mass'], lo=0, hi=10, steps=2, prefix='m')

    Labels the subsets ``m_1`` and ``m_2``

    """
    from .exceptions import IncompatibleAttribute
    if lo is None or hi is None:
        for data in data_collection:
            try:
                vals = data[cid]
                break
            except IncompatibleAttribute:
                continue
        else:
            raise ValueError("Cannot infer data limits for ComponentID %s"
                             % cid)
        if lo is None:
            lo = np.nanmin(vals)
        if hi is None:
            hi = np.nanmax(vals)

    prefix = prefix or cid.label
    reverse = lo > hi
    if log:
        rng = np.logspace(np.log10(lo), np.log10(hi), steps + 1)
    else:
        rng = np.linspace(lo, hi, steps + 1)

    states = []
    for i in range(steps):
        if reverse:
            states.append((cid <= rng[i]) & (cid > rng[i + 1]))

        else:
            states.append((cid >= rng[i]) & (cid < rng[i + 1]))

    result = []
    for i, s in enumerate(states, start=1):
        result.append(data_collection.new_subset_group())
        result[-1].subset_state = s
        result[-1].label = "%s_%i" % (prefix, i)

    return result


def colorize_subsets(subsets, cmap, lo=0, hi=1):
    """Re-color a list of subsets according to a colormap

    :param subsets: List of subsets
    :param cmap: Matplotlib colormap instance
    :param lo: Start location in colormap. 0-1. Defaults to 0
    :param hi: End location in colormap. 0-1. Defaults to 1

    The colormap will be sampled at `len(subsets)` even intervals
    between `lo` and `hi`. The color at the `ith` interval will be
    applied to `subsets[i]`
    """

    from matplotlib import cm
    sm = cm.ScalarMappable(cmap=cmap)
    sm.norm.vmin = 0
    sm.norm.vmax = 1

    vals = np.linspace(lo, hi, len(subsets))
    rgbas = sm.to_rgba(vals)

    for color, subset in zip(rgbas, subsets):
        r, g, b, a = color
        r = int(255 * r)
        g = int(255 * g)
        b = int(255 * b)
        subset.style.color = '#%2.2x%2.2x%2.2x' % (r, g, b)


def coerce_numeric(arr):
    """Coerce an array into a numeric array, replacing
       non-numeric elements with nans.

       If the array is already a numeric type, it is returned
       unchanged

       :param arr: array to coerce
       :type arr: :class:`numpy.ndarray`

       :returns: array.
    """
    # already numeric type
    if np.issubdtype(arr.dtype, np.number):
        return arr

    if np.issubdtype(arr.dtype, np.bool_):
        return arr.astype(np.int)

    # a string dtype
    if np.issubdtype(arr.dtype, np.character):
        lens = np.char.str_len(arr)
        lmax = lens.max()
        nonnull = lens > 0
        coerced = np.genfromtxt(arr, delimiter=lmax + 1)
        has_missing = not nonnull.all()
        dtype = np.float if has_missing else coerced.dtype
        result = np.empty(arr.shape, dtype=dtype)
        result[nonnull] = coerced
        if has_missing:
            result[~nonnull] = np.nan
        return result

    return np.genfromtxt(arr)


def check_sorted(array):
    """ Return True if the array is sorted, False otherwise.
    """
    # this ignores NANs, and does the right thing if nans
    # are concentrated at beginning or end of array
    # otherwise, it will miss things at nan/finite boundaries
    return not (array[:-1] > array[1:]).any()


def lookup_class(ref):
    """ Look up an object via it's module string (e.g., 'glue.core.Data')

    :param ref: reference
    :type ref: str
    :rtype: object, or None if not found
    """
    mod = ref.split('.')[0]
    try:
        result = __import__(mod)
    except ImportError:
        return None
    try:
        for attr in ref.split('.')[1:]:
            result = getattr(result, attr)
        return result
    except AttributeError:
        return None


class PropertySetMixin(object):

    """An object that provides a set of properties that
    are meant to encapsulate state information

    This class exposes a properties attribute, which is a dict
    of all properties. Similarly, assigning to the properties dict
    will update the individual properties
    """
    _property_set = []

    @property
    def properties(self):
        """ A dict mapping property names to values """
        return {p: getattr(self, p) for p in self._property_set}

    @properties.setter
    def properties(self, value):
        """ Update the properties with a new dict.

        Keys in the new dict must be valid property names defined in
        the _property_set class level attribute"""
        invalid = set(value.keys()) - set(self._property_set)
        if invalid:
            raise ValueError("Invalid property values: %s" % invalid)

        for k in self._property_set:
            if k not in value:
                continue
            setattr(self, k, value[k])


class CallbackMixin(object):

    """
    A mixin that provides a utility for attaching callback
    functions to methods
    """

    def __init__(self):
        self._callbacks = []

    def add_callback(self, function):
        self._callbacks.append(function)

    def remove_callback(self, function):
        self._callbacks.remove(function)

    def notify(self, *args, **kwargs):
        for func in self._callbacks:
            func(*args, **kwargs)


def as_list(x):
    if isinstance(x, list):
        return x
    return [x]


class Pointer(object):

    def __init__(self, key):
        self.key = key

    def __get__(self, instance, type=None):
        val = instance
        for k in self.key.split('.'):
            val = getattr(val, k, None)
        return val

    def __set__(self, instance, value):
        v = self.key.split('.')
        attr = reduce(getattr, [instance] + v[:-1])
        setattr(attr, v[-1], value)


@contextmanager
def defer(instance, method):
    """
    Defer the calling of a method inside a context manager,
    and then call it 0 or 1 times afterwards.

    :param instance: The instance of the method to defer
    :param method: The name of the method to defer
    :type method: str

    Within the context block, calls to the method will be
    intercepted, logged, and skipped.

    Upon exiting the context block, the method will be
    invoked a single time, with the arguments of the
    most recent invokation inside the context block.

    If the method is never invoked in the context block,
    it is not called when leaving that block.
    """
    history = []

    def log(*a, **k):
        history.append((a, k))

    orig = getattr(instance, method)
    setattr(instance, method, log)
    try:
        yield
    finally:
        setattr(instance, method, orig)
        for a, k in history[-1:]:
            orig(*a, **k)

########NEW FILE########
__FILENAME__ = visual
# Define acceptable line styles
VALID_LINESTYLES = ['solid', 'dashed', 'dash-dot', 'dotted', 'none']

GREY = '#B2B2B2'
GRAY = GREY
BLUE = "#1F78B4"
GREEN = "#33A02C"
RED = "#E31A1C"
ORANGE = "#FF7F00"
PURPLE = "#6A3D9A"
YELLOW = "#FFFF99"
BROWN = "#8C510A"
PINK = "#FB9A99"
LIGHT_BLUE = "#A6CEE3"
LIGHT_GREEN = "#B2DF8A"
LIGHT_RED = "#FB9A99"
LIGHT_ORANGE = "#FDBF6F"
LIGHT_PURPLE = "#CAB2D6"
COLORS = [RED, GREEN, BLUE, BROWN, ORANGE, PURPLE, PINK]

__all__ = ['VisualAttributes']


class VisualAttributes(object):

    '''
    This class is used to define visual attributes for any kind of objects
    '''

    def __init__(self, parent=None, washout=False, color=GREY):

        # Color can be specified using Matplotlib notation. Specifically, it
        # can be:
        #  * A string with a common color (e.g. 'black', 'red', 'orange')
        #  * A string containing a float in the rng [0:1] for a shade of
        #    gray ('0.0' = black,'1.0' = white)
        #  * A tuple of three floats in the rng [0:1] for (R, G, B)
        # * An HTML hexadecimal string (e.g. '#eeefff')
        self.color = color
        self.alpha = .5

        # Line width in points (float or int)
        self.linewidth = 1

        # Line style, which can be one of 'solid', 'dashed', 'dash-dot',
        # 'dotted', or 'none'
        self.linestyle = 'solid'

        self.marker = 'o'
        self.markersize = 4

        self.parent = parent

        self._atts = ['color', 'alpha', 'linewidth', 'linestyle', 'marker',
                      'markersize']

    def __eq__(self, other):
        if not isinstance(other, VisualAttributes):
            return False
        return all(getattr(self, a) == getattr(other, a) for a in self._atts)

    def set(self, other):
        for att in self._atts:
            setattr(self, att, getattr(other, att))

    def copy(self, new_parent=None):
        result = VisualAttributes()
        result.set(self)
        if new_parent is not None:
            result.parent = new_parent
        return result

    def __eq__(self, other):
        return all(getattr(self, att) == getattr(other, att)
                   for att in self._atts)

    def __setattr__(self, attribute, value):

        # Check that line style is valid
        if attribute == 'linestyle' and value not in VALID_LINESTYLES:
            raise Exception("Line style should be one of %s" %
                            '/'.join(VALID_LINESTYLES))

        # Check that line width is valid
        if attribute == 'linewidth':
            if type(value) not in [float, int]:
                raise Exception("Line width should be a float or an int")
            if value < 0:
                raise Exception("Line width should be positive")

        # Check that the attribute exists (don't allow new attributes)
        allowed = set(['color', 'linewidth', 'linestyle',
                       'alpha', 'parent', 'marker', 'markersize', '_atts'])
        if attribute not in allowed:
            raise Exception("Attribute %s does not exist" % attribute)

        changed = getattr(self, attribute, None) != value
        object.__setattr__(self, attribute, value)

        # if parent has a broadcast method, broadcast the change
        if (changed and hasattr(self, 'parent') and
            hasattr(self.parent, 'broadcast') and
                attribute != 'parent'):
            self.parent.broadcast(self)

########NEW FILE########
__FILENAME__ = default_config
from glue.config import qt_client, data_factory, link_function


"""Declare any extra link functions like this"""
#@link_function(info='translates A to B', output_labels=['b'])
#def a_to_b(a):
#    return a * 3


"""Data factories take a filename as input and return a Data object"""
#@data_factory('JPEG Image')
#def jpeg_reader(file_name):
#    ...
#    return data


"""Extra qt clients"""
#qt_client(ClientClass)

########NEW FILE########
__FILENAME__ = aplpy
# This file is adapted from aplpy/wcs_util.py.

# APLpy - The Astronomical Plotting Library in Python
# Copyright (c) 2010 Thomas P. Robitaille and Eli Bressert
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
import numpy as np

# Galactic conversion constants
RA_NGP = np.radians(192.859508333333)
DEC_NGP = np.radians(27.1283361111111)
L_CP = np.radians(122.932)
L_0 = L_CP - np.pi / 2.
RA_0 = RA_NGP + np.pi / 2.
DEC_0 = np.pi / 2. - DEC_NGP


def fk52gal(ra, dec):
    """ Convert from equatorial to galactic coordinates

    :param ra: scalar or array. Right Ascension
    :param dec: scalar or array. Declination

    :rtype: Tuple of L,B coordinates for each input
    """
    ra, dec = np.radians(ra), np.radians(dec)

    sinb = np.sin(dec) * np.cos(DEC_0) - np.cos(dec) * np.sin(ra - RA_0) \
        * np.sin(DEC_0)

    b = np.arcsin(sinb)

    cosl = np.cos(dec) * np.cos(ra - RA_0) / np.cos(b)
    sinl = (np.sin(dec) * np.sin(DEC_0) + np.cos(dec) * np.sin(ra - RA_0) *
            np.cos(DEC_0)) / np.cos(b)

    b = np.degrees(b)

    l = np.arccos(cosl)
    l[np.where(sinl < 0.)] = - l[np.where(sinl < 0.)]

    l = np.degrees(l + L_0)

    l = np.mod(l, 360.)
    b = np.mod(b + 90., 180.) - 90.

    return l, b


def gal2fk5(l, b):
    """ Convert from galactic to equatorial coordinates

    :param l: scalar or array. Galactic longitude
    :param b: scalar or array. Galactic latitude

    :rtype: Tuple of RA, dec coordinates for each input
    """

    l = np.radians(l)
    b = np.radians(b)

    sind = np.sin(b) * np.sin(DEC_NGP) + \
        np.cos(b) * np.cos(DEC_NGP) * np.sin(l - L_0)

    dec = np.arcsin(sind)

    cosa = np.cos(l - L_0) * np.cos(b) / np.cos(dec)
    sina = (np.cos(b) * np.sin(DEC_NGP) * np.sin(l - L_0) -
            np.sin(b) * np.cos(DEC_NGP)) / np.cos(dec)

    dec = np.degrees(dec)

    ra = np.arccos(cosa)
    ra[np.where(sina < 0.)] = -ra[np.where(sina < 0.)]

    ra = np.degrees(ra + RA_0)

    ra = np.mod(ra, 360.)
    dec = np.mod(dec + 90., 180.) - 90.

    return ra, dec

########NEW FILE########
__FILENAME__ = astro
"""
Interface to import astronomy specific libraries.

Since the astronomy community is currently migrating towards astropy,
there are several packages that provide ~identical functionality (i.e.
legacy libraries like pyfits, and their equivalent submodule in
astropy)

This module provides a transparent interface that defaults to astropy,
but falls back to legacy libraries if astropy isn't installed on the
users' system
"""

try:
    from astropy.io import fits
except ImportError:
    import pyfits as fits

try:
    from astropy.wcs import WCS
except ImportError:
    from pywcs import WCS
    #update interface
    WCS.all_pix2world = WCS.all_pix2sky
    WCS.wcs_pix2world = WCS.wcs_pix2sky
    WCS.wcs_world2pix = WCS.wcs_sky2pix


try:
    from astropy.io import ascii
except ImportError:
    import asciitable as ascii

try:
    from astropy.io import votable
except ImportError:
    import vo as votable

########NEW FILE########
__FILENAME__ = axescache
"""
The AxesCache class alters how an Axes instance is rendered.
While enabled, the AxesCache quickly re-renders an original view,
properly scaled and translated to reflect changes in the viewport.
The downside is that the re-rendered image is fuzzy and/or truncated.

The best way to use an AxesCache is to enable it during
window resize drags and pan/zoom mouse drags; these generate
rapid draw requests, and users might prefer high refresh
rates to pixel-perfect renders.

Unfortunately, Matplotlib on it's own doesn't provide an easy
mechanism to attach event handlers to either window resize drags
or pan/zoom drags. This code must be added separately.
"""
import numpy as np
from matplotlib.axes import Axes
from matplotlib.image import AxesImage
from matplotlib.collections import QuadMesh


class RenderCapture(object):

    """
    A RemderCapture saves an image of a fully-rendered
    Axes instance, and provides a method for re-rendering
    a properly transformed image during panning and zooming
    """

    def __init__(self, axes, renderer):
        self.axes = axes
        self._corners = self._get_corners(axes)
        px, py, dx, dy = self._corners

        im = self.extract_image(renderer)
        im = im[py[0]: py[-1] + 1, px[0]: px[-1] + 1, :]
        self.im = im
        self._mesh = None
        self._image = None
        self.image

    @property
    def image(self):
        if self._image is not None:
            return self._image

        px, py, dx, dy = self._corners
        self._image = AxesImage(self.axes,
                                origin='lower',
                                interpolation='nearest')
        self._image.set_data(self.im)
        self._image.set_extent((dx[0], dx[-1], dy[0], dy[-1]))
        self.axes._set_artist_props(self._image)

        return self._image

    @property
    def mesh(self):
        if self._mesh is not None:
            return self._mesh
        px, py, dx, dy = self._corners
        x, y, c = self.axes._pcolorargs('pcolormesh', dx, dy,
                                        self.im[:, :, 0],
                                        allmatch=False)
        ny, nx = x.shape
        coords = np.column_stack((x.ravel(), y.ravel()))
        collection = QuadMesh(nx - 1, ny - 1, coords,
                              shading='flat', antialiased=False,
                              edgecolors='None',
                              cmap='gray')
        collection.set_array(c.ravel())
        collection.set_clip_path(self.axes.patch)
        collection.set_transform(self.axes.transData)
        self._mesh = collection
        return self._mesh

    def draw(self, renderer, *args, **kwargs):
        if self.axes.get_xscale() == 'linear' and \
                self.axes.get_yscale() == 'linear':
            self.image.draw(renderer, *args, **kwargs)
        else:
            self.mesh.draw(renderer, *args, **kwargs)

    @staticmethod
    def _get_corners(axes):
        """
        Return the device and data coordinates
        for a box slightly inset from the edge
        of an axes instance

        Returns 4 1D arrays:
        px : Pixel X locations for each column of the box
        py : Pixel Y locations for each row of the box
        dx : Data X locations for each column of the box
        dy : Data Y locations for each row of the box
        """
        xlim = axes.get_xlim()
        ylim = axes.get_ylim()
        pts = np.array([[xlim[0], ylim[0]],
                        [xlim[1], ylim[1]]])

        corners = axes.transData.transform(pts).astype(np.int)

        # move in 5 pixels, to avoid grabbing the tick marks
        px = np.arange(corners[0, 0] + 5, corners[1, 0] - 5)
        py = np.arange(corners[0, 1] + 5, corners[1, 1] - 5)

        tr = axes.transData.inverted().transform
        dx = tr(np.column_stack((px, px)))[:, 0]
        dy = tr(np.column_stack((py, py)))[:, 1]
        return px, py, dx, dy

    @staticmethod
    def extract_image(renderer):
        try:
            buf = renderer.buffer_rgba()
        except TypeError:  # mpl v1.1 has different signature
            buf = renderer.buffer_rgba(0, 0)

        result = np.frombuffer(buf, dtype=np.uint8)
        result = result.reshape((int(renderer.height),
                                 int(renderer.width), 4)).copy()
        return np.flipud(result)


class AxesCache(object):

    def __init__(self, axes):
        self.axes = axes

        self._capture = None
        self.axes.draw = self.draw
        self._enabled = False

    def draw(self, renderer, *args, **kwargs):
        if self._capture is None or not self._enabled:
            Axes.draw(self.axes, renderer, *args, **kwargs)
            self._capture = RenderCapture(self.axes, renderer)
        else:
            self.axes.axesPatch.draw(renderer, *args, **kwargs)
            self._capture.draw(renderer, *args, **kwargs)
            self.axes.xaxis.draw(renderer, *args, **kwargs)
            self.axes.yaxis.draw(renderer, *args, **kwargs)
            for s in self.axes.spines.values():
                s.draw(renderer, *args, **kwargs)

    def clear_cache(self):
        """
        Clear the cache, forcing the a full re-render
        """
        self._capture = None

    def disable(self):
        """
        Temporarily disable cache re-renders. Render
        results are still saved, for when
        enable() is next called
        """
        self._enabled = False
        self.axes.figure.canvas.draw()

    def enable(self):
        """
        Enable cached-rerenders
        """
        self._enabled = True

    def teardown(self):
        """
        Permanently disable this cache, and restore
        normal Axes render behavior
        """
        self.axes.draw = Axes.draw.__get__(self.axes)


if __name__ == "__main__":
    import matplotlib.pyplot as plt

    num = 1000000
    plt.subplot(111)
    plt.subplots_adjust(bottom=.5, top=.8)
    plt.scatter(np.random.randn(num), np.random.randn(num),
                s=np.random.randint(10, 50, num),
                c=np.random.randint(0, 255, num),
                alpha=.2, linewidths=0)
    plt.plot([0, 1, 2, 3], [0, 1, 2, 3])
    cache = AxesCache(plt.gca())
    cache.enable()
    plt.grid('on')
    # plt.xscale('log')

    plt.show()

########NEW FILE########
__FILENAME__ = echo
from contextlib import contextmanager
from weakref import WeakKeyDictionary


__all__ = ['CallbackProperty', 'callback_property',
           'add_callback', 'remove_callback',
           'delay_callback', 'ignore_callback']


class CallbackProperty(object):

    """A property that callback functions can be added to.

    When a callback property changes value, each callback function
    is called with information about the state change. Otherwise,
    callback properties behave just like normal instance variables.

    CallbackProperties must be defined at the class level. Use
    the helper function :func:`add_callback` to attach a callback to
    a specific instance of a class with CallbackProperties
    """

    def __init__(self, default=None, getter=None, setter=None):
        """
        :param default: The initial value for the property
        """
        self._default = default
        self._callbacks = WeakKeyDictionary()
        self._2arg_callbacks = WeakKeyDictionary()
        self._disabled = WeakKeyDictionary()
        self._values = WeakKeyDictionary()

        if getter is None:
            getter = self._default_getter

        if setter is None:
            setter = self._default_setter

        self._getter = getter
        self._setter = setter

    def _default_getter(self, instance, owner=None):
        return self._values.get(instance, self._default)

    def _default_setter(self, instance, value):
        self._values.__setitem__(instance, value)

    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        return self._getter(instance)

    def __set__(self, instance, value):
        old = self.__get__(instance)
        self._setter(instance, value)
        new = self.__get__(instance)
        if old != new:
            self.notify(instance, old, new)

    def setter(self, func):
        """
        Method to use as a decorator, to mimic @property.setter
        """
        self._setter = func
        return self

    def notify(self, instance, old, new):
        """Call all callback functions with the current value

        :param instance: The instance to consider
        :param old: The old value of the property
        :param new: The new value of the property

        Each callback will either be called using
        callback(new) or callback(old, new) depending
        on whether echo_old was True during add_callback
        """
        if self._disabled.get(instance, False):
            return
        for cback in self._callbacks.get(instance, []):
            cback(new)
        for cback in self._2arg_callbacks.get(instance, []):
            cback(old, new)

    def disable(self, instance):
        """Disable callbacks for a specific instance"""
        self._disabled[instance] = True

    def enable(self, instance):
        """Enable previously-disabled callbacks for a specific instance"""
        self._disabled[instance] = False

    def add_callback(self, instance, func, echo_old=False):
        """Add a callback to a specific instance that manages this property

        :param instance: Instance to bind the callback to
        :param func: Callback function
        :param echo_old: If true, the callback function will be invoked
        with both the old and new values of the property, as func(old, new)
        If False (the default), will be invoked as func(new)
        """
        if echo_old:
            self._2arg_callbacks.setdefault(instance, []).append(func)
        else:
            self._callbacks.setdefault(instance, []).append(func)

    def remove_callback(self, instance, func):
        """Remove a previously-added callback

        :param instance: The instance to detach the callback from
        :param func: The callback function to remove
        """
        for cb in [self._callbacks, self._2arg_callbacks]:
            if instance not in cb:
                continue
            try:
                cb[instance].remove(func)
                break
            except ValueError:
                pass
        else:
            raise ValueError("Callback function not found: %s" % func)


def add_callback(instance, prop, callback, echo_old=False):
    """Attach a callback function to a property in an instance

    :param instance: Instance of a class with callback properties

    :param prop: Name of callback property in `instance`
    :type prop: str

    :param callback: Callback function
    :type callback: Callable

    Example::

        class Foo:
            bar = CallbackProperty(0)

        def callback(value):
            pass

        f = Foo()
        add_callback(f, 'bar', callback)

    """
    p = getattr(type(instance), prop)
    if not isinstance(p, CallbackProperty):
        raise TypeError("%s is not a CallbackProperty" % prop)
    p.add_callback(instance, callback, echo_old=echo_old)


def remove_callback(instance, prop, callback):
    """Remove a callback function from a property in an instance

    :param instance: Instance of a class with callback properties

    :param prop: Name of callback property in `instance`
    :type prop: str

    :param callback: Callback function
    :type callback: Callable
    """
    p = getattr(type(instance), prop)
    if not isinstance(p, CallbackProperty):
        raise TypeError("%s is not a CallbackProperty" % prop)
    p.remove_callback(instance, callback)


def callback_property(getter):
    """
    A decorator to build a CallbackProperty,
    by wrapping a getter method, similar to the use
    of @property::

        class Foo(object):
            @callback_property
            def x(self):
                 return self._x

            @x.setter
            def x(self, value):
                self._x = value

    In simple cases with no getter or setter logic, it's
    easier to create a CallbackProperty directly::

        class Foo(object);
            x = CallbackProperty(initial_value)
    """
    return CallbackProperty(getter=getter)


@contextmanager
def delay_callback(instance, *props):
    """Delay any callback functions from one or more callback properties

    This is a context manager. Within the context block, no callbacks
    will be issued. Each callback will be called once on exit

    :param instance: An instance object with CallbackProperties

    :param props: One or more properties within instance to delay
    :type prop: str

    Example::

        with delay_callback(foo, 'bar', 'baz'):
            f.bar = 20
            f.baz = 30
            f.bar = 10
        print 'done'  # callbacks triggered at this point, if needed
    """
    vals = []
    for prop in props:
        p = getattr(type(instance), prop)
        if not isinstance(p, CallbackProperty):
            raise TypeError("%s is not a CallbackProperty" % prop)
        vals.append(p.__get__(instance))
        p.disable(instance)

    yield

    for old, prop in zip(vals, props):
        p = getattr(type(instance), prop)
        assert isinstance(p, CallbackProperty)
        p.enable(instance)
        new = p.__get__(instance)
        if old != new:
            p.notify(instance, old, new)


@contextmanager
def ignore_callback(instance, *props):
    """Temporarily ignore any callbacks from one or more callback properties

    This is a context manager. Within the context block, no callbacks
    will be issued. In contrast with delay_callback, no callbakcs
    will be called on exiting the context manager

    :param instance: An instance object with CallbackProperties

    :param props: One or more properties within instance to delay
    :type prop: str

    Example::

        with ignore_callback(foo, 'bar', 'baz'):
                f.bar = 20
                f.baz = 30
                f.bar = 10
        print 'done'  # no callbacks called

    """
    for prop in props:
        p = getattr(type(instance), prop)
        if not isinstance(p, CallbackProperty):
            raise TypeError("%s is not a CallbackProperty" % prop)
        p.disable(instance)

    yield

    for prop in props:
        p = getattr(type(instance), prop)
        assert isinstance(p, CallbackProperty)
        p.enable(instance)

########NEW FILE########
__FILENAME__ = fits_io
# This file is adapted from astropy/io/fits/connect.py in the developer version
# of Astropy. It can be removed once support for Astropy v0.2 is dropped (since
# Astropy v0.3 and later will include it).

# Copyright (c) 2011-2013, Astropy Developers
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice, this
#   list of conditions and the following disclaimer in the documentation and/or
#   other materials provided with the distribution.
# * Neither the name of the Astropy Team nor the names of its contributors may be
#   used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from __future__ import print_function

import os
import re
import warnings

import numpy as np

from astropy.utils import OrderedDict
from astropy.io import registry as io_registry
from astropy.table import Table
from astropy import log
from astropy import units as u

from astropy.io.fits import HDUList, TableHDU, BinTableHDU, GroupsHDU
from astropy.io.fits.hdu.hdulist import fitsopen as fits_open


# FITS file signature as per RFC 4047
FITS_SIGNATURE = (b"\x53\x49\x4d\x50\x4c\x45\x20\x20\x3d\x20\x20\x20\x20\x20"
                  b"\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20"
                  b"\x20\x54")

# Keywords to remove for all tables that are read in
REMOVE_KEYWORDS = ['XTENSION', 'BITPIX', 'NAXIS', 'NAXIS1', 'NAXIS2',
                   'PCOUNT', 'GCOUNT', 'TFIELDS']

# Column-specific keywords
COLUMN_KEYWORDS = ['TFORM[0-9]+',
                   'TBCOL[0-9]+',
                   'TSCAL[0-9]+',
                   'TZERO[0-9]+',
                   'TNULL[0-9]+',
                   'TTYPE[0-9]+',
                   'TUNIT[0-9]+',
                   'TDISP[0-9]+',
                   'TDIM[0-9]+',
                   'THEAP']


def is_column_keyword(keyword):
    for c in COLUMN_KEYWORDS:
        if re.match(c, keyword) is not None:
            return True
    return False


def is_fits(origin, args, kwargs):
    """
    Determine whether `origin` is a FITS file.

    Parameters
    ----------
    origin : str or readable file-like object
        Path or file object containing a potential FITS file.

    Returns
    -------
    is_fits : bool
        Returns `True` if the given file is a FITS file.
    """
    if isinstance(args[0], basestring):
        if args[0].lower().endswith(('.fits', '.fits.gz', '.fit', '.fit.gz')):
            return True
        elif origin == 'read':
            with open(args[0], 'rb') as f:
                sig = f.read(30)
            return sig == FITS_SIGNATURE
    elif hasattr(args[0], 'read'):
        pos = args[0].tell()
        sig = args[0].read(30)
        args[0].seek(pos)
        return sig == FITS_SIGNATURE
    elif isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU)):
        return True
    else:
        return False


def read_table_fits(input, hdu=None):
    """
    Read a Table object from an FITS file

    Parameters
    ----------
    input : str or file-like object or compatible `astropy.io.fits` HDU object
        If a string, the filename to read the table from. If a file object, or
        a compatible HDU object, the object to extract the table from. The
        following `astropy.io.fits` HDU objects can be used as input:
        - :class:`~astropy.io.fits.hdu.table.TableHDU`
        - :class:`~astropy.io.fits.hdu.table.BinTableHDU`
        - :class:`~astropy.io.fits.hdu.table.GroupsHDU`
        - :class:`~astropy.io.fits.hdu.hdulist.HDUList`
    hdu : int or str, optional
        The HDU to read the table from.
    """

    if isinstance(input, basestring):
        input = fits_open(input)
        to_close = input
    else:
        to_close = None

    if hasattr(input, 'read'):
        input = fits_open(input)

    try:

        # Parse all table objects
        tables = OrderedDict()
        if isinstance(input, HDUList):
            for ihdu, hdu_item in enumerate(input):
                if isinstance(hdu_item, (TableHDU, BinTableHDU, GroupsHDU)):
                    tables[ihdu] = hdu_item

            if len(tables) > 1:

                if hdu is None:
                    warnings.warn("hdu= was not specified but multiple tables"
                                  " are present, reading in first available"
                                  " table (hdu={0})".format(tables.keys()[0]))
                    hdu = tables.keys()[0]

                # hdu might not be an integer, so we first need to convert it
                # to the correct HDU index
                hdu = input.index_of(hdu)

                if hdu in tables:
                    table = tables[hdu]
                else:
                    raise ValueError("No table found in hdu={0}".format(hdu))

            elif len(tables) == 1:
                table = tables[tables.keys()[0]]
            else:
                raise ValueError("No table found")

        elif isinstance(input, (TableHDU, BinTableHDU, GroupsHDU)):

            table = input

        else:

            raise ValueError("Input should be a string, a file-like object, "
                             "an  HDUList, TableHDU, BinTableHDU, or "
                             "GroupsHDU instance")

        # Check if table is masked
        masked = False
        for col in table.columns:
            if col.null is not None:
                masked = True
                break

        # Convert to an astropy.table.Table object
        t = Table(table.data, masked=masked)

        # Copy over null values if needed
        if masked:
            for col in table.columns:
                t[col.name].set_fill_value(col.null)
                t[col.name].mask[t[col.name] == col.null] = True

        # Copy over units
        for col in table.columns:
            if col.unit is not None:
                try:
                    t[col.name].units = u.Unit(col.unit, format='fits')
                except ValueError:
                    t[col.name].units = u.UnrecognizedUnit(col.unit)

        # TODO: deal properly with unsigned integers

        for key, value, comment in table.header.cards:

            if key in ['COMMENT', 'HISTORY']:
                if key in t.meta:
                    t.meta[key].append(value)
                else:
                    t.meta[key] = [value]

            elif key in t.meta:  # key is duplicate

                if isinstance(t.meta[key], list):
                    t.meta[key].append(value)
                else:
                    t.meta[key] = [t.meta[key], value]

            elif (is_column_keyword(key.upper()) or
                  key.upper() in REMOVE_KEYWORDS):

                pass

            else:

                t.meta[key] = value

        # TODO: implement masking

    finally:

        if to_close is not None:
            to_close.close()

    return t


def write_table_fits(input, output, overwrite=False):
    """
    Write a Table object to a FITS file

    Parameters
    ----------
    input : Table
        The table to write out.
    output : str
        The filename to write the table to.
    overwrite : bool
        Whether to overwrite any existing file without warning.
    """

    # Check if output file already exists
    if isinstance(output, basestring) and os.path.exists(output):
        if overwrite:
            os.remove(output)
        else:
            raise IOError("File exists: {0}".format(output))

    # Create a new HDU object
    if input.masked:
        table_hdu = BinTableHDU(np.array(input.filled()))
        for col in table_hdu.columns:
            # The astype is necessary because if the string column is less
            # than one character, the fill value will be N/A by default which
            # is too long, and so no values will get masked.
            fill_value = input[col.name].get_fill_value()
            col.null = fill_value.astype(input[col.name].dtype)
    else:
        table_hdu = BinTableHDU(np.array(input))

    # Set units for output HDU
    for col in table_hdu.columns:
        if input[col.name].units is not None:
            col.unit = input[col.name].units.to_string(format='fits')

    for key, value in input.meta.items():

        if is_column_keyword(key.upper()) or key.upper() in REMOVE_KEYWORDS:

            log.warn("Meta-data keyword {0} will be ignored since it "
                     "conflicts with a FITS reserved keyword".format(key))

        if isinstance(value, list):
            for item in value:
                try:
                    table_hdu.header.append((key, item))
                except ValueError:
                    log.warn("Attribute `{0}` of type {1} cannot be written "
                             "to FITS files - skipping".format(key,
                                                               type(value)))
        else:
            try:
                table_hdu.header[key] = value
            except ValueError:
                log.warn("Attribute `{0}` of type {1} cannot be written to "
                         "FITS files - skipping".format(key, type(value)))

    # Write out file
    table_hdu.writeto(output)

try:
    io_registry.register_reader('fits', Table, read_table_fits)
    io_registry.register_writer('fits', Table, write_table_fits)
    io_registry.register_identifier('fits', Table, is_fits)
except:  # FITS readers/writers have already been registered
    pass

########NEW FILE########
__FILENAME__ = modest_image
import matplotlib
rcParams = matplotlib.rcParams

import matplotlib.image as mi
import matplotlib.colors as mcolors
import matplotlib.cbook as cbook
import numpy as np


class ModestImage(mi.AxesImage):

    """
    Computationally modest image class.

    ModestImage is an extension of the Matplotlib AxesImage class
    better suited for the interactive display of larger images. Before
    drawing, ModestImage resamples the data array based on the screen
    resolution and view window. This has very little affect on the
    appearance of the image, but can substantially cut down on
    computation since calculations of unresolved or clipped pixels
    are skipped.

    The interface of ModestImage is the same as AxesImage. However, it
    does not currently support setting the 'extent' property. There
    may also be weird coordinate warping operations for images that
    I'm not aware of. Don't expect those to work either.
    """

    def __init__(self, *args, **kwargs):
        if 'extent' in kwargs and kwargs['extent'] is not None:
            raise NotImplementedError("ModestImage does not support extents")

        self._full_res = None
        self._sx, self._sy = None, None
        self._bounds = (None, None, None, None)
        super(ModestImage, self).__init__(*args, **kwargs)

    def set_data(self, A):
        """
        Set the image array

        ACCEPTS: numpy/PIL Image A
        """
        self._full_res = A
        self._A = A

        if self._A.dtype != np.uint8 and not np.can_cast(self._A.dtype,
                                                         np.float):
            raise TypeError("Image data can not convert to float")

        if (self._A.ndim not in (2, 3) or
                (self._A.ndim == 3 and self._A.shape[-1] not in (3, 4))):
                raise TypeError("Invalid dimensions for image data")

        self._imcache = None
        self._rgbacache = None
        self._oldxslice = None
        self._oldyslice = None
        self._sx, self._sy = None, None

    def get_array(self):
        """Override to return the full-resolution array"""
        return self._full_res

    def _scale_to_res(self):
        """ Change self._A and _extent to render an image whose
        resolution is matched to the eventual rendering."""

        ax = self.axes
        shp = self._full_res.shape
        x0, x1, sx, y0, y1, sy = extract_matched_slices(ax, shp)
        # have we already calculated what we need?
        if sx >= self._sx and sy >= self._sy and \
            x0 >= self._bounds[0] and x1 <= self._bounds[1] and \
                y0 >= self._bounds[2] and y1 <= self._bounds[3]:
            return
        self._A = self._full_res[y0:y1:sy, x0:x1:sx]
        self._A = cbook.safe_masked_invalid(self._A)
        if self.origin == 'upper':
            self.set_extent([x0 - .5, x1 - .5, y1 - .5, y0 - .5])
        else:
            self.set_extent([x0 - .5, x1 - .5, y0 - .5, y1 - .5])
        self._sx = sx
        self._sy = sy
        self._bounds = (x0, x1, y0, y1)
        self.changed()

    def draw(self, renderer, *args, **kwargs):
        self._scale_to_res()
        super(ModestImage, self).draw(renderer, *args, **kwargs)


def main():
    from time import time
    import matplotlib.pyplot as plt
    x, y = np.mgrid[0:2000, 0:2000]
    data = np.sin(x / 10.) * np.cos(y / 30.)

    f = plt.figure()
    ax = f.add_subplot(111)

    # try switching between
    artist = ModestImage(ax, data=data)
    #artist = mi.AxesImage(ax, data=data)

    ax.set_aspect('equal')
    artist.norm.vmin = -1
    artist.norm.vmax = 1

    ax.add_artist(artist)
    ax.set_xlim(0, 1000)
    ax.set_ylim(0, 1000)

    t0 = time()
    plt.gcf().canvas.draw()
    t1 = time()

    print "Draw time for %s: %0.1f ms" % (artist.__class__.__name__,
                                          (t1 - t0) * 1000)

    plt.show()


def imshow(axes, X, cmap=None, norm=None, aspect=None,
           interpolation=None, alpha=None, vmin=None, vmax=None,
           origin=None, extent=None, shape=None, filternorm=1,
           filterrad=4.0, imlim=None, resample=None, url=None, **kwargs):
    """Similar to matplotlib's imshow command, but produces a ModestImage

    Unlike matplotlib version, must explicitly specify axes
    """

    if not axes._hold:
        axes.cla()
    if norm is not None:
        assert(isinstance(norm, mcolors.Normalize))
    if aspect is None:
        aspect = rcParams['image.aspect']
    axes.set_aspect(aspect)
    im = ModestImage(axes, cmap, norm, interpolation, origin, extent,
                     filternorm=filternorm,
                     filterrad=filterrad, resample=resample, **kwargs)

    im.set_data(X)
    im.set_alpha(alpha)
    axes._set_artist_props(im)

    if im.get_clip_path() is None:
        # image does not already have clipping set, clip to axes patch
        im.set_clip_path(axes.patch)

    # if norm is None and shape is None:
    #    im.set_clim(vmin, vmax)
    if vmin is not None or vmax is not None:
        im.set_clim(vmin, vmax)
    elif norm is None:
        im.autoscale_None()

    im.set_url(url)

    # update ax.dataLim, and, if autoscaling, set viewLim
    # to tightly fit the image, regardless of dataLim.
    im.set_extent(im.get_extent())

    axes.images.append(im)
    im._remove_method = lambda h: axes.images.remove(h)

    return im


def extract_matched_slices(ax, shape):
    """Determine the slice parameters to use, matched to the screen.

    :param ax: Axes object to query. It's extent and pixel size
               determine the slice parameters

    :param shape: Tuple of the full image shape to slice into. Upper
               boundaries for slices will be cropped to fit within
               this shape.

    :rtype: tulpe of x0, x1, sx, y0, y1, sy

    Indexing the full resolution array as array[y0:y1:sy, x0:x1:sx] returns
    a view well-matched to the axes' resolution and extent
    """
    ext = ax.transAxes.transform([1, 1]) - ax.transAxes.transform([0, 0])
    xlim, ylim = ax.get_xlim(), ax.get_ylim()
    dx, dy = xlim[1] - xlim[0], ylim[1] - ylim[0]

    def _clip(val, hi):
        return int(max(min(val, hi), 0))

    y0 = _clip(min(ylim) - 5, shape[0])
    y1 = _clip(max(ylim) + 5, shape[0])
    x0 = _clip(min(xlim) - 5, shape[1])
    x1 = _clip(max(xlim) + 5, shape[1])

    sy = int(max(1, min((y1 - y0) / 5., np.ceil(abs(dy / ext[1])))))
    sx = int(max(1, min((x1 - x0) / 5., np.ceil(abs(dx / ext[0])))))

    return x0, x1, sx, y0, y1, sy

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = line_slices
from __future__ import print_function

import numpy as np

from scipy.ndimage import map_coordinates


def extract_line_slice(cube, x, y, order=3, respect_nan=True):
    """
    Given an array with shape (z, y, x), extract a (z, n) slice by
    interpolating at n (x, y) points.

    All units are in *pixels*.

    .. note:: If there are NaNs in the cube, they will be treated as zeros when
              using spline interpolation.

    Parameters
    ----------
    cube : `~numpy.ndarray`
        The data cube to extract the slice from
    curve : list or tuple
        A list or tuple of (x, y) pairs, with minimum length 2
    order : int, optional
        Spline interpolation order. Set to ``0`` for nearest-neighbor
        interpolation.

    Returns
    -------
    slice : `numpy.ndarray`
        The (z, d) slice
    """

    if order == 0:

        total_slice = np.zeros([cube.shape[0], len(x)]) + np.nan

        x = np.round(x)
        y = np.round(y)

        ok = (x >= 0) & (y >= 0) & (x < cube.shape[2]) & (y < cube.shape[1])

        total_slice[:,ok] = cube[:, y[ok].astype(int), x[ok].astype(int)]

    elif order > 0 and order == int(order):

        nx = len(x)
        nz = cube.shape[0]

        zi = np.outer(np.arange(nz, dtype=int), np.ones(nx))
        xi = np.outer(np.ones(nz), x)
        yi = np.outer(np.ones(nz), y)

        if np.any(np.isnan(cube)):

            # map_coordinates does not deal well with NaN values so we have
            # to remove the NaN values then re-mask the final slice.

            total_slice = map_coordinates(np.nan_to_num(cube), [zi,yi,xi], order=order, cval=np.nan)

            slice_bad = map_coordinates(np.nan_to_num(np.isnan(cube).astype(int)),
                                        [zi,yi,xi], order=order)

            total_slice[np.nonzero(slice_bad)] = np.nan

        else:

            total_slice = map_coordinates(cube, [zi,yi,xi], order=order, cval=np.nan)

    else:

        raise TypeError("order should be a positive integer")

    return total_slice

########NEW FILE########
__FILENAME__ = path
from __future__ import print_function

import sys

import numpy as np
from astropy.wcs import WCSSUB_CELESTIAL

try:
    from astropy.coordinates import BaseCoordinateFrame
except ImportError:  # astropy <= 0.3
    from astropy.coordinates import SphericalCoordinatesBase as BaseCoordinateFrame

from ..utils.wcs_utils import get_wcs_system_frame

class Polygon(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y


def segment_angles(x, y):

    dx = np.diff(x)
    dy = np.diff(y)

    d = np.hypot(dx, dy)

    cos_theta = (-dx[:-1] * dx[1:] - dy[:-1] * dy[1:]) / (d[:-1] * d[1:])
    cos_theta = np.clip(cos_theta, -1., 1.)

    sin_theta = (-dx[:-1] * dy[1:] + dy[:-1] * dx[1:]) / (d[:-1] * d[1:])
    sin_theta = np.clip(sin_theta, -1., 1.)

    theta = np.arctan2(sin_theta, cos_theta)

    theta[0] = np.pi
    theta[-1] = np.pi

    return theta


def get_endpoints(x, y, width):

    # Pad with same values at ends, to find slope of perpendicular end
    # lines.
    xp = np.pad(x, 1, mode='edge')
    yp = np.pad(y, 1, mode='edge')

    dx = np.diff(xp)
    dy = np.diff(yp)

    alpha = segment_angles(xp, yp) / 2.
    beta = np.arctan2(dy, dx)[:-1]
    beta[0] = beta[1]
    gamma = -(np.pi - alpha - beta)

    dx = np.cos(gamma)
    dy = np.sin(gamma)

    angles = segment_angles(xp, yp) / 2.

    # Find points offset from main curve, on bisecting lines
    x1 = x - dx * width * 0.5 / np.sin(angles)
    x2 = x + dx * width * 0.5 / np.sin(angles)
    y1 = y - dy * width * 0.5 / np.sin(angles)
    y2 = y + dy * width * 0.5 / np.sin(angles)

    return x1, y1, x2, y2


class Path(object):
    """
    A curved path that may have a non-zero width and is used to extract
    slices from cubes.

    Parameters
    ----------
    xy_or_coords : list or Astropy coordinates
        The points defining the path. This can be passed as a list of (x, y)
        tuples, which is interpreted as being pixel positions, or it can be
        an Astropy coordinate object containing an array of 2 or more
        coordinates.
    width : None or float or :class:`~astropy.units.Quantity`
        The width of the path. If ``coords`` is passed as a list of pixel
        positions, the width should be given (if passed) as a floating-point
        value in pixels. If ``coords`` is a coordinate object, the width
        should be passed as a :class:`~astropy.units.Quantity` instance with
        units of angle.
    """

    def __init__(self, xy_or_coords, width=None):
        if isinstance(xy_or_coords, list):
            self._xy = xy_or_coords
            self._coords = None
        elif sys.version_info[0] > 2 and isinstance(xy_or_coords, zip):
            self._xy = list(xy_or_coords)
            self._coords = None
        else:
            self._xy = None
            self._coords = xy_or_coords
        self.width = width

    def add_point(self, xy_or_coord):
        """
        Add a point to the path

        Parameters
        ----------
        xy_or_coord : tuple or Astropy coordinate
            A tuple (x, y) containing the coordinates of the point to add (if
            the path is defined in pixel space), or an Astropy coordinate
            object (if it is defined in world coordinates).
        """
        if self._xy is not None:
            if isinstance(xy_or_coord, tuple):
                self._xy.append(xy_or_coord)
            else:
                raise TypeError("Path is defined as a list of pixel "
                                "coordinates, so `xy_or_coord` should be "
                                "a tuple of `(x,y)` pixel coordinates.")
        else:
            if isinstance(xy_or_coord, BaseCoordinateFrame):
                raise NotImplementedError("Cannot yet append world coordinates to path")
            else:
                raise TypeError("Path is defined in world coordinates, "
                                "so `xy_or_coord` should be an Astropy "
                                "coordinate object.")

    def get_xy(self, wcs=None):
        """
        Return the pixel coordinates of the path.

        If the path is defined in world coordinates, the appropriate WCS
        transformation should be passed.

        Parameters
        ----------
        wcs : :class:`~astropy.wcs.WCS`
            The WCS transformation to assume in order to transform the path
            to pixel coordinates.
        """
        if self._xy is not None:
            return self._xy
        else:
            if wcs is None:
                raise ValueError("`wcs` is needed in order to compute "
                                 "the pixel coordinates")
            else:

                # Extract the celestial component of the WCS
                wcs_sky = wcs.sub([WCSSUB_CELESTIAL])

                # Find the astropy name for the coordinates
                # TODO: return a frame class with Astropy 0.4, since that can
                # also contain equinox/epoch info.
                celestial_system = get_wcs_system_frame(wcs_sky)

                world_coords = self._coords.transform_to(celestial_system)

                try:
                    xw, yw = world_coords.spherical.lon.degree, world_coords.spherical.lat.degree
                except AttributeError:  # astropy <= 0.3
                    xw, yw = world_coords.lonangle.degree, world_coords.latangle.degree

                return list(zip(*wcs_sky.wcs_world2pix(xw, yw, 0)))

    def sample_points_edges(self, spacing, wcs=None):

        x, y = zip(*self.get_xy(wcs=wcs))

        # Find the distance interval between all pairs of points
        dx = np.diff(x)
        dy = np.diff(y)
        dd = np.hypot(dx, dy)

        # Find the total displacement along the broken curve
        d = np.hstack([0., np.cumsum(dd)])

        # Figure out the number of points to sample, and stop short of the
        # last point.
        n_points = np.floor(d[-1] / spacing)

        if n_points == 0:
            raise ValueError("Path is shorter than spacing")

        d_sampled = np.linspace(0., n_points * spacing, n_points + 1)

        x_sampled = np.interp(d_sampled, d, x)
        y_sampled = np.interp(d_sampled, d, y)

        return d_sampled, x_sampled, y_sampled

    def sample_points(self, spacing, wcs=None):

        d_sampled, x_sampled, y_sampled = self.sample_points_edges(spacing, wcs=wcs)

        x_sampled = 0.5 * (x_sampled[:-1] + x_sampled[1:])
        y_sampled = 0.5 * (y_sampled[:-1] + y_sampled[1:])

        return x_sampled, y_sampled

    def sample_polygons(self, spacing, wcs=None):

        x, y = zip(*self.get_xy(wcs=wcs))

        d_sampled, x_sampled, y_sampled = self.sample_points_edges(spacing, wcs=wcs)

        # Find the distance interval between all pairs of points
        dx = np.diff(x)
        dy = np.diff(y)
        dd = np.hypot(dx, dy)

        # Normalize to find unit vectors
        dx = dx / dd
        dy = dy / dd

        # Find the total displacement along the broken curve
        d = np.hstack([0., np.cumsum(dd)])

        interval = np.searchsorted(d, d_sampled) - 1
        interval[0] = 0

        dx = dx[interval]
        dy = dy[interval]

        polygons = []

        x_beg = x_sampled - dx * spacing * 0.5
        x_end = x_sampled + dx * spacing * 0.5

        y_beg = y_sampled - dy * spacing * 0.5
        y_end = y_sampled + dy * spacing * 0.5

        x1 = x_beg - dy * self.width * 0.5
        y1 = y_beg + dx * self.width * 0.5

        x2 = x_end - dy * self.width * 0.5
        y2 = y_end + dx * self.width * 0.5

        x3 = x_end + dy * self.width * 0.5
        y3 = y_end - dx * self.width * 0.5

        x4 = x_beg + dy * self.width * 0.5
        y4 = y_beg - dx * self.width * 0.5

        for i in range(len(x_sampled) - 1):
            p = Polygon([x1[i], x2[i], x3[i], x4[i]], [y1[i], y2[i], y3[i], y4[i]])
            polygons.append(p)

        return polygons

########NEW FILE########
__FILENAME__ = polygon
"""
This module implements polygon-square intersection using matplotlib. It is
twice as fast as Shapely for this specific case and avoids requiring another
dependency.
"""

import numpy as np

from matplotlib.path import Path
from matplotlib.transforms import Bbox


def square_polygon_intersection(xmin, xmax, ymin, ymax, x, y):
    poly = Path(list(zip(x, y)))
    box = Bbox([[xmin, ymin], [xmax, ymax]])
    try:
        clipped_poly = poly.clip_to_bbox(box)
    except ValueError:
        return [], []
    else:
        return clipped_poly.vertices[:, 0], clipped_poly.vertices[:, 1]


def polygon_area(x, y):
    x1 = x
    x2 = np.roll(x, -1)
    y1 = y
    y2 = np.roll(y, -1)
    return abs(0.5 * np.sum(x1 * y2 - x2 * y1))


def square_polygon_overlap_area(xmin, xmax, ymin, ymax, x, y):
    x, y = square_polygon_intersection(xmin, xmax, ymin, ymax, x, y)
    if len(x) == 0:
        return 0.
    else:
        return polygon_area(x, y)

########NEW FILE########
__FILENAME__ = poly_slices
from __future__ import print_function

import numpy as np
from astropy.utils.console import ProgressBar

from .polygon import square_polygon_overlap_area


def extract_poly_slice(cube, polygons):

    nx = len(polygons)
    nz = cube.shape[0]

    total_slice = np.zeros((nz, nx))
    total_area = np.zeros((nz, nx))

    p = ProgressBar(len(polygons))

    for i, polygon in enumerate(polygons):

        p.update()

        # Find bounding box
        bbxmin = int(round(np.min(polygon.x))-1)
        bbxmax = int(round(np.max(polygon.x))+2)
        bbymin = int(round(np.min(polygon.y))-1)
        bbymax = int(round(np.max(polygon.y))+2)

        # Clip to cube box
        bbxmin = max(bbxmin, 0)
        bbxmax = min(bbxmax, cube.shape[2])
        bbymin = max(bbymin, 0)
        bbymax = min(bbymax, cube.shape[1])

        # Loop through pixels that might overlap
        for xmin in np.arange(bbxmin, bbxmax):
            for ymin in np.arange(bbymin, bbymax):

                area = square_polygon_overlap_area(xmin-0.5, xmin+0.5,
                                                   ymin-0.5, ymin+0.5,
                                                   polygon.x, polygon.y)

                if area > 0:
                    total_slice[:, i] += cube[:, ymin, xmin] * area
                    total_area[:, i] += area

    total_slice[total_area == 0.] = np.nan
    total_slice[total_area > 0.] /= total_area[total_area > 0.]

    print("")

    return total_slice

########NEW FILE########
__FILENAME__ = slices
import numpy as np

from .line_slices import extract_line_slice
from .poly_slices import extract_poly_slice


def extract_slice(cube, path, spacing=1.0, order=3, respect_nan=True, width=None, wcs=None):
    """
    Given an array with shape (z, y, x), extract a (z, n) slice from a path
    with ``n`` segments.
    
    All units are in *pixels*

    .. note:: If there are NaNs in the cube, they will be treated as zeros when
              using spline interpolation.

    Parameters
    ----------
    path : `Path`
        The path along which to define the slice
    spacing : float
        The position resolution in the final slice
    order : int, optional
        Spline interpolation order when using line paths. Does not have any
        effect for polygon paths.
    respect_nan : bool, optional
        If set to `False`, NaN values are changed to zero before computing
        the slices.

    Returns
    -------
    slice : `numpy.ndarray`
        The slice
    """

    if not respect_nan:
        cube = np.nan_to_num(cube)

    if path.width is None:
        x, y = path.sample_points(spacing=spacing, wcs=wcs)
        slice = extract_line_slice(cube, x, y, order=order)
    else:
        polygons = path.sample_polygons(spacing=spacing, wcs=wcs)
        slice = extract_poly_slice(cube, polygons)

    return slice
########NEW FILE########
__FILENAME__ = gui
from __future__ import print_function

import os
import math
import warnings

import numpy as np

from matplotlib.collections import LineCollection
from matplotlib.transforms import Bbox
from matplotlib.patches import Polygon

from .geometry.path import Path, get_endpoints
from . import extract_pv_slice


def distance(x1, y1, x2, y2, x3, y3):
    """
    Find the shortest distance between a point (x3, y3) and the line passing
    through the points (x1, y1) and (x2, y2).
    """

    px = x2-x1
    py = y2-y1

    something = px * px + py * py

    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)

    x = x1 + u * px
    y = y1 + u * py

    dx = x - x3
    dy = y - y3

    dist = math.sqrt(dx*dx + dy*dy)

    return dist


class MovableSliceBox(object):

    def __init__(self, box, callback):
        self.box = box
        self.press = None
        self.background = None
        self.point_counter = 0
        self.callback = callback
        self.mode = 0
        self.show_poly = False
        self.cidpress = self.box.figure.canvas.mpl_connect('draw_event', self.draw_slicer)


    def connect(self):
        self.cidpress = self.box.figure.canvas.mpl_connect('key_press_event', self.key_press)
        self.cidpress = self.box.figure.canvas.mpl_connect('button_press_event', self.on_press)
        self.cidmotion = self.box.figure.canvas.mpl_connect('motion_notify_event', self.on_motion)

    def draw_slicer(self, event):

        axes = self.box.axes
        canvas = self.box.figure.canvas

        self.box.axes.draw_artist(self.box)

        if self.show_poly:

            path = Path(zip(self.box.x, self.box.y))
            path.width = self.box.width

            for poly in path.sample_polygons(1):
                self.box.axes.draw_artist(Polygon(zip(poly.x, poly.y),
                                          ec='green', fc='none',
                                          transform=self.box.axes.transData,
                                          clip_on=True, clip_box=self.box.axes.bbox))

    def on_press(self, event):

        if self.box.figure.canvas.toolbar.mode != '':
            return

        if event.inaxes != self.box.axes:
            return

        if self.mode == 1:
            self.callback(self.box)
            self.mode += 1
            return

        if self.mode == 2:
            self.box.x = []
            self.box.y = []
            self.mode = 0
            self.point_counter = 0

        self.press = event.xdata, event.ydata

        self.point_counter += 1

        axes = self.box.axes
        canvas = self.box.figure.canvas

        if self.point_counter == 1:  # first point

            self.box.x.append(event.xdata)
            self.box.x.append(event.xdata)
            self.box.y.append(event.ydata)
            self.box.y.append(event.ydata)

            self.box.width = 0.

            self.box.set_animated(True)
            canvas.draw()
            self.background = canvas.copy_from_bbox(self.box.axes.bbox)

        elif self.mode == 0:

            self.box.x.append(event.xdata)
            self.box.y.append(event.ydata)

        self.box._update_segments()

        # now redraw just the lineangle
        axes.draw_artist(self.box)

        canvas.blit(axes.bbox)

    def key_press(self, event):

        if self.box.figure.canvas.toolbar.mode != '':
            return

        if event.key == 'enter' and self.mode == 0:
            self.mode += 1
            self.box.x = self.box.x[:-1]
            self.box.y = self.box.y[:-1]

        if event.key == 'y' and self.mode == 2:
            self.show_poly = not self.show_poly
            self.draw_slicer(event)
            self.box.figure.canvas.draw()

    def on_motion(self, event):

        if self.box.figure.canvas.toolbar.mode != '':
            return

        if self.point_counter == 0:
            return

        if self.mode == 2:
            return

        canvas = self.box.figure.canvas
        axes = self.box.axes
        canvas.restore_region(self.background)

        if event.inaxes != self.box.axes:
            return

        if self.mode == 0:
            self.box.x[-1] = event.xdata
            self.box.y[-1] = event.ydata
        elif self.mode == 1:
            self.box.width = distance(self.box.x[-2], self.box.y[-2], self.box.x[-1], self.box.y[-1], event.xdata, event.ydata) * 2

        self.box._update_segments()

        # redraw just the current lineangle
        axes.draw_artist(self.box)

        # blit just the redrawn area
        canvas.blit(axes.bbox)

    def disconnect(self):
        self.box.figure.canvas.mpl_disconnect(self.cidpress)
        self.box.figure.canvas.mpl_disconnect(self.cidmotion)


class SliceBox(LineCollection):

    def __init__(self, x0=None, y0=None, x1=None, y1=None, width=None, **kwargs):

        super(SliceBox, self).__init__([], **kwargs)

        self.x0 = x0
        self.y0 = y0
        self.x1 = x1
        self.y1 = y1
        self.width = width

        self._update_segments()

    def _update_segments(self):

        if self.x0 is None:
            return

        # Find angle of normal to line
        theta = np.arctan2(self.y1 - self.y0, self.x1 - self.x0) + np.pi / 2.

        # Find displacement vectors
        dx = np.cos(theta) * self.width / 2.
        dy = np.sin(theta) * self.width / 2.

        # Find central line
        line = [(self.x0, self.y0), (self.x1, self.y1)]

        # Find bounding rectangle
        rect = [(self.x0 + dx, self.y0 + dy), (self.x0 - dx, self.y0 - dy),
                (self.x1 - dx, self.y1 - dy), (self.x1 + dx, self.y1 + dy),
                (self.x0 + dx, self.y0 + dy)]

        self.set_segments((line, rect))
        self.set_linestyles(('solid', 'dashed'))
        self.set_linewidths((2, 1))


class SliceCurve(LineCollection):

    def __init__(self, x=[], y=[], width=None, **kwargs):

        super(SliceCurve, self).__init__([], **kwargs)

        self.x = x
        self.y = y
        self.width = width

        self._update_segments()

    def _update_segments(self):

        if not self.x:
            return

        x1, y1, x2, y2 = get_endpoints(self.x, self.y, self.width)

        # Find central line
        line = zip(self.x, self.y)

        # Find bounding rectangle
        rect = zip(np.hstack([x1,x2[::-1], x1[0]]),
                   np.hstack([y1,y2[::-1], y1[0]]))

        self.set_segments((line, rect))
        self.set_linestyles(('solid', 'dashed'))
        self.set_linewidths((2, 1))




class PVSlicer(object):

    def __init__(self, filename, backend="Qt4Agg", clim=None):

        self.filename = filename

        try:
            from spectral_cube import SpectralCube
            cube = SpectralCube.read(filename, format='fits')
            self.array = cube._data
        except:
            warnings.warn("spectral_cube package is not available - using astropy.io.fits directly")
            from astropy.io import fits
            self.array = fits.getdata(filename)
            if self.array.ndim != 3:
                raise ValueError("dataset does not have 3 dimensions (install the spectral_cube package to avoid this error)")

        self.backend = backend

        import matplotlib as mpl
        mpl.use(self.backend)
        import matplotlib.pyplot as plt

        self.fig = plt.figure(figsize=(14, 8))

        self.ax1 = self.fig.add_axes([0.1, 0.1, 0.4, 0.7])

        if clim is None:
            warnings.warn("clim not defined and will be determined from the data")
            # To work with large arrays, sub-sample the data
            n1 = self.array.shape[0] / 10
            n2 = self.array.shape[1] / 10
            n3 = self.array.shape[2] / 10
            sub_array = self.array[::n1,::n2,::n3]
            cmin = np.min(sub_array[~np.isnan(sub_array) & ~np.isinf(sub_array)])
            cmax = np.max(sub_array[~np.isnan(sub_array) & ~np.isinf(sub_array)])
            crange = cmax - cmin
            self._clim = (cmin - crange, cmax + crange)
        else:
            self._clim = clim

        self.slice = int(round(self.array.shape[0] / 2.))

        from matplotlib.widgets import Slider

        self.slice_slider_ax = self.fig.add_axes([0.1, 0.95, 0.4, 0.03])
        self.slice_slider_ax.set_xticklabels("")
        self.slice_slider_ax.set_yticklabels("")
        self.slice_slider = Slider(self.slice_slider_ax, "3-d slice", 0, self.array.shape[0], valinit=self.slice, valfmt="%i")
        self.slice_slider.on_changed(self.update_slice)
        self.slice_slider.drawon = False

        self.image = self.ax1.imshow(self.array[self.slice, :,:], origin='lower', interpolation='nearest', vmin=self._clim[0], vmax=self._clim[1], cmap=plt.cm.gray)

        self.vmin_slider_ax = self.fig.add_axes([0.1, 0.90, 0.4, 0.03])
        self.vmin_slider_ax.set_xticklabels("")
        self.vmin_slider_ax.set_yticklabels("")
        self.vmin_slider = Slider(self.vmin_slider_ax, "vmin", self._clim[0], self._clim[1], valinit=self._clim[0])
        self.vmin_slider.on_changed(self.update_vmin)
        self.vmin_slider.drawon = False

        self.vmax_slider_ax = self.fig.add_axes([0.1, 0.85, 0.4, 0.03])
        self.vmax_slider_ax.set_xticklabels("")
        self.vmax_slider_ax.set_yticklabels("")
        self.vmax_slider = Slider(self.vmax_slider_ax, "vmax", self._clim[0], self._clim[1], valinit=self._clim[1])
        self.vmax_slider.on_changed(self.update_vmax)
        self.vmax_slider.drawon = False

        self.grid1 = None
        self.grid2 = None
        self.grid3 = None

        self.ax2 = self.fig.add_axes([0.55, 0.1, 0.4, 0.7])

        # Add slicing box
        self.box = SliceCurve(colors=(0.8, 0.0, 0.0))
        self.ax1.add_collection(self.box)
        self.movable = MovableSliceBox(self.box, callback=self.update_pv_slice)
        self.movable.connect()

        # Add save button
        from matplotlib.widgets import Button
        self.save_button_ax = self.fig.add_axes([0.65, 0.90, 0.20, 0.05])
        self.save_button = Button(self.save_button_ax, 'Save slice to FITS')
        self.save_button.on_clicked(self.save_fits)

        self.pv_slice = None

        self.cidpress = self.fig.canvas.mpl_connect('button_press_event', self.click)

    def click(self, event):

        if event.inaxes != self.ax2:
            return

        self.slice_slider.set_val(event.ydata)

    def save_fits(self, *args, **kwargs):

        if self.backend == 'Qt4Agg':
            from matplotlib.backends.backend_qt4 import _getSaveFileName
            plot_name = _getSaveFileName(self.fig.canvas.manager.window, "Choose filename",
                                         os.path.dirname(os.path.abspath(self.filename)), "", None)
            plot_name = str(plot_name)
        else:
            print("Enter filename: ", end='')
            plot_name = raw_input()

        if self.pv_slice is None:
            return

        from astropy.io import fits
        fits.writeto(plot_name, self.pv_slice, clobber=True)
        print("Saved file to: ", plot_name)

    def update_pv_slice(self, box):

        path = Path(zip(box.x, box.y))
        path.width = box.width

        self.pv_slice = extract_pv_slice(self.array, path)

        self.ax2.cla()
        self.ax2.imshow(self.pv_slice, origin='lower', aspect='auto', interpolation='nearest')

        self.fig.canvas.draw()

    def show(self):
        import matplotlib.pyplot as plt
        plt.show()

    def update_slice(self, pos=None):

        if self.array.ndim == 2:
            self.image.set_array(self.array)
        else:
            self.slice = int(round(pos))
            self.image.set_array(self.array[self.slice, :, :])

        self.fig.canvas.draw()

    def update_vmin(self, vmin):
        if vmin > self._clim[1]:
            self._clim = (self._clim[1], self._clim[1])
        else:
            self._clim = (vmin, self._clim[1])
        self.image.set_clim(*self._clim)
        self.fig.canvas.draw()

    def update_vmax(self, vmax):
        if vmax < self._clim[0]:
            self._clim = (self._clim[0], self._clim[0])
        else:
            self._clim = (self._clim[0], vmax)
        self.image.set_clim(*self._clim)
        self.fig.canvas.draw()

########NEW FILE########
__FILENAME__ = pvextractor
from __future__ import print_function

import numpy as np

from astropy import units as u
from astropy.io.fits import PrimaryHDU, ImageHDU, Header

from . import six
from .utils.wcs_utils import get_spatial_scale, sanitize_wcs
from .geometry import extract_slice
from .utils.wcs_slicing import slice_wcs


def extract_pv_slice(cube, path, wcs=None, spacing=1.0, order=3,
                     respect_nan=True):
    """
    Given a position-position-velocity cube with dimensions (nv, ny, nx), and
    a path, extract a position-velocity slice.

    Alternative implementations:
        gipsy::sliceview
        karma::kpvslice
        casaviewer::slice

    Parameters
    ----------
    cube : :class:`~numpy.ndarray` or :class:`~spectral_cube.SpectralCube` or str or HDU
        The cube to extract a slice from. If this is a plain
        :class:`~numpy.ndarray` instance, the WCS information can optionally
        be specified with the ``wcs`` parameter. If a string, it should be
        the name of a file containing a spectral cube.
    path : `Path`
        The path along which to define the position-velocity slice. The path
        can contain coordinates defined in pixel or world coordinates.
    wcs : :class:`~astropy.wcs.WCS`, optional
        The WCS information to use for the cube. This should only be
        specified if the ``cube`` parameter is a plain
        :class:`~numpy.ndarray` instance.
    spacing : float
        The position resolution in the final position-velocity slice. This
        can be given in pixel coordinates or as a
        :class:`~astropy.units.Quantity` instance with angle units.
    order : int, optional
        Spline interpolation order when using paths with zero width. Does not
        have any effect for paths with a non-zero width.
    respect_nan : bool, optional
        If set to `False`, NaN values are changed to zero before computing
        the slices. If set to `True`, in the case of line paths a second
        computation is performed to ignore the NaN value while interpolating,
        and set the output values of NaNs to NaN.

    Returns
    -------
    slice : `numpy.ndarray`
        The position-velocity slice
    """

    if isinstance(cube, (six.string_types, ImageHDU, PrimaryHDU)):
        try:
            from spectral_cube import SpectralCube
            cube = SpectralCube.read(cube)
        except ImportError:
            raise ImportError("spectral_cube package required for working "
                              "with fits data. Install spectral_cube or "
                              "use NumPy arrays")

    if _is_spectral_cube(cube):
        wcs = cube.wcs
        cube = cube.filled_data[...]
    else:
        wcs = None

    if wcs is not None:
        wcs = sanitize_wcs(wcs)

    if not isinstance(cube, np.ndarray) or wcs is not None:
        scale = get_spatial_scale(wcs)
        if isinstance(spacing, u.Quantity):
            pixel_spacing = (spacing / scale).decompose()
            world_spacing = spacing
        else:
            pixel_spacing = spacing
            world_spacing = spacing * scale
    else:
        if isinstance(spacing, u.Quantity):
            raise TypeError("No WCS has been specified, so spacing should be given in pixels")
        else:
            pixel_spacing = spacing
            world_spacing = None

    pv_slice = extract_slice(cube, path, wcs=wcs, spacing=pixel_spacing, order=order, respect_nan=respect_nan)

    # Generate output header
    if wcs is None:
        header = Header()
    else:
        header = slice_wcs(wcs, spatial_scale=world_spacing).to_header()

    # TODO: write path to BinTableHDU

    return PrimaryHDU(data=pv_slice, header=header)


def _is_spectral_cube(obj):
    try:
        from spectral_cube import SpectralCube
        return isinstance(obj, SpectralCube)
    except ImportError:
        return False

########NEW FILE########
__FILENAME__ = pvregions
import numpy as np
from .geometry import path
from astropy import coordinates
from astropy import units as u
import re

try:
    csystems = {'galactic': coordinates.Galactic,
                'fk5': coordinates.FK5,
                'fk4': coordinates.FK4,
                'icrs': coordinates.ICRS}
except AttributeError:  # astropy v0.2
    csystems = {'galactic': coordinates.GalacticCoordinates,
                'fk5': coordinates.FK5Coordinates,
                'fk4': coordinates.FK4Coordinates,
                'icrs': coordinates.ICRSCoordinates}

cel_systems = ['fk5', 'fk4', 'icrs']
# ecliptic, detector, etc. not supported (because I don't know what they mean)
# (or with ecliptic, how to deal with them)
all_systems = cel_systems + ['galactic', 'image', 'physical']


class SimpleRegion(object):

    def __init__(self, coord_list, coord_format, name):
        self.name = name
        self.coord_format = coord_format
        self.coord_list = coord_list

    def __repr__(self):
        return "Region: {0}, {1}, {2}".format(self.name, self.coord_list,
                                              self.coord_format)


valid_regions = ['line', 'segment', 'vector']
valid_region_re = [re.compile("^"+n) for n in valid_regions]

def simple_region_parser(regionstring, coord_format):
    rs = regionstring.lstrip("# ")

    rtype = None
    for rt, rre in zip(valid_regions, valid_region_re):
        if rre.search(rs):
            rtype = rt
            break

    if rtype is None:
        # not a usable region
        return

    coordre = re.compile("^[a-z]*\((.*)\)")
    coord_list = coordre.findall(rs)
    if len(coord_list) != 1:
        raise ValueError("Invalid region")

    coords = coord_list[0].split(",")

    outcoords = []
    for ii,cs in enumerate(coords):
        if coord_format in csystems:
            if ":" in cs:
                # sexagesimal
                if coord_format in cel_systems and ii % 2 == 0:
                    # odd, celestial = RA = hours
                    crd = coordinates.Angle(cs, unit=u.hour)
                else:
                    crd = coordinates.Angle(cs, unit=u.deg)
            else:
                try:
                    # if it's a float, it's in degrees
                    crd = float(cs) * u.deg
                except ValueError:
                    crd = coordinates.Angle(cs)
        else:
            # assume pixel units
            crd = float(cs)
        outcoords.append(crd)

    reg = SimpleRegion(coord_list=outcoords, coord_format=coord_format,
                       name=rtype)

    return reg

def load_regions_file(rfile):
    with open(rfile,'r') as fh:
        lines = fh.readlines()
    return load_regions_stringlist(lines)

def load_regions_stringlist(lines):

    coord_format = None
    for line in lines:
        if line.strip() in all_systems:
            coord_format = line.strip()
            break
    if coord_format is None:
        raise ValueError("No valid coordinate format found.")

    regions_ = [simple_region_parser(line, coord_format) for line in lines]
    regions = [r for r in regions_ if r is not None]
    
    return regions


def line_to_path(region, wcs=None):
    """
    Convert a line or segment to a path
    """

    l,b = None,None

    endpoints = []

    for x in region.coord_list:
        if l is None:
            l = x.to(u.deg).value
        else:
            b = x.to(u.deg).value
            if l is not None and b is not None:
                endpoints.append((l,b))
                l,b = None,None
            else:
                raise ValueError("unmatched l,b")

    lbarr = np.array(endpoints)
    C = csystems[region.coord_format](lbarr[:,0]*u.deg, lbarr[:,1]*u.deg)

    # TODO: add widths for projection

    p = path.WCSPath(C, wcs=wcs)

    return p

def vector_to_path(vector_region, wcs=None):
    """
    Convert a vector region to a path

    # vector(48.944348,-0.36432694,485.647",124.082) vector=1
    """

    x,y = vector_region.coord_list[:2]
    length = vector_region.coord_list[2]
    angle = vector_region.coord_list[3]
    
    C1 = csystems[vector_region.coord_format](x, y)
    dx,dy = length * np.cos(angle), length * np.sin(angle)
    # -dx because we're in the flippy coordsys
    C2 = csystems[vector_region.coord_format](C1.lonangle - dx, C1.latangle + dy)

    C = csystems[vector_region.coord_format]([C1.lonangle,C2.lonangle],
                                             [C1.latangle,C2.latangle])

    p = path.WCSPath(C, wcs=wcs)

    return p

region_converters = {'line':line_to_path, 'segment':line_to_path,
                     'vector':vector_to_path}

def paths_from_regfile(regfile, wcs=None):
    """
    Given a ds9 region file, extract pv diagrams for each:
        group of points [NOT IMPLEMENTED]
        panda [NOT IMPLEMENTED]
        vector [NOT IMPLEMENTED]
        segment [NOT IMPLEMENTED]
        group of lines [NOT IMPLEMENTED]
    """
    #import pyregion
    #regions = pyregion.open(regfile)
    regions = load_regions_file(regfile)
    return paths_from_regions(regions, wcs=wcs)

def paths_from_regions(regions, wcs=None):
    paths = [region_converters[r.name](r, wcs=wcs)
             for r in regions
             if r.name in region_converters]
    return paths

########NEW FILE########
__FILENAME__ = six
"""Utilities for writing code that runs on Python 2 and 3"""

# Copyright (c) 2010-2014 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.5.2"


# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):
            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
        del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        result = self._resolve()
        setattr(obj, self.name, result) # Invokes __set__.
        # This is a bit ugly, but it avoids running this again.
        delattr(obj.__class__, self.name)
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)

    def __getattr__(self, attr):
        # Hack around the Django autoreloader. The reloader tries to get
        # __file__ or __name__ of every module in sys.modules. This doesn't work
        # well if this MovedModule is for an module that is unavailable on this
        # machine (like winreg on Unix systems). Thus, we pretend __file__ and
        # __name__ don't exist if the module hasn't been loaded yet. See issues
        # #51 and #53.
        if attr in ("__file__", "__name__") and self.mod not in sys.modules:
            raise AttributeError
        _module = self._resolve()
        value = getattr(_module, attr)
        setattr(self, attr, value)
        return value


class _LazyModule(types.ModuleType):

    def __init__(self, name):
        super(_LazyModule, self).__init__(name)
        self.__doc__ = self.__class__.__doc__

    def __dir__(self):
        attrs = ["__doc__", "__name__"]
        attrs += [attr.name for attr in self._moved_attributes]
        return attrs

    # Subclasses should override this
    _moved_attributes = []


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)



class _MovedItems(_LazyModule):
    """Lazy loading of moved objects"""


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("reload_module", "__builtin__", "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("UserString", "UserString", "collections"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),

    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("_thread", "thread", "_thread"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
    MovedModule("winreg", "_winreg"),
]
for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
    if isinstance(attr, MovedModule):
        sys.modules[__name__ + ".moves." + attr.name] = attr
del attr

_MovedItems._moved_attributes = _moved_attributes

moves = sys.modules[__name__ + ".moves"] = _MovedItems(__name__ + ".moves")


class Module_six_moves_urllib_parse(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_parse"""


_urllib_parse_moved_attributes = [
    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
    MovedAttribute("quote", "urllib", "urllib.parse"),
    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
    MovedAttribute("unquote", "urllib", "urllib.parse"),
    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
    MovedAttribute("urlencode", "urllib", "urllib.parse"),
]
for attr in _urllib_parse_moved_attributes:
    setattr(Module_six_moves_urllib_parse, attr.name, attr)
del attr

Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes

sys.modules[__name__ + ".moves.urllib_parse"] = sys.modules[__name__ + ".moves.urllib.parse"] = Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse")


class Module_six_moves_urllib_error(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_error"""


_urllib_error_moved_attributes = [
    MovedAttribute("URLError", "urllib2", "urllib.error"),
    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
]
for attr in _urllib_error_moved_attributes:
    setattr(Module_six_moves_urllib_error, attr.name, attr)
del attr

Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes

sys.modules[__name__ + ".moves.urllib_error"] = sys.modules[__name__ + ".moves.urllib.error"] = Module_six_moves_urllib_error(__name__ + ".moves.urllib.error")


class Module_six_moves_urllib_request(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_request"""


_urllib_request_moved_attributes = [
    MovedAttribute("urlopen", "urllib2", "urllib.request"),
    MovedAttribute("install_opener", "urllib2", "urllib.request"),
    MovedAttribute("build_opener", "urllib2", "urllib.request"),
    MovedAttribute("pathname2url", "urllib", "urllib.request"),
    MovedAttribute("url2pathname", "urllib", "urllib.request"),
    MovedAttribute("getproxies", "urllib", "urllib.request"),
    MovedAttribute("Request", "urllib2", "urllib.request"),
    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
    MovedAttribute("URLopener", "urllib", "urllib.request"),
    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
    MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
]
for attr in _urllib_request_moved_attributes:
    setattr(Module_six_moves_urllib_request, attr.name, attr)
del attr

Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes

sys.modules[__name__ + ".moves.urllib_request"] = sys.modules[__name__ + ".moves.urllib.request"] = Module_six_moves_urllib_request(__name__ + ".moves.urllib.request")


class Module_six_moves_urllib_response(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_response"""


_urllib_response_moved_attributes = [
    MovedAttribute("addbase", "urllib", "urllib.response"),
    MovedAttribute("addclosehook", "urllib", "urllib.response"),
    MovedAttribute("addinfo", "urllib", "urllib.response"),
    MovedAttribute("addinfourl", "urllib", "urllib.response"),
]
for attr in _urllib_response_moved_attributes:
    setattr(Module_six_moves_urllib_response, attr.name, attr)
del attr

Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes

sys.modules[__name__ + ".moves.urllib_response"] = sys.modules[__name__ + ".moves.urllib.response"] = Module_six_moves_urllib_response(__name__ + ".moves.urllib.response")


class Module_six_moves_urllib_robotparser(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_robotparser"""


_urllib_robotparser_moved_attributes = [
    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
]
for attr in _urllib_robotparser_moved_attributes:
    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
del attr

Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes

sys.modules[__name__ + ".moves.urllib_robotparser"] = sys.modules[__name__ + ".moves.urllib.robotparser"] = Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser")


class Module_six_moves_urllib(types.ModuleType):
    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
    parse = sys.modules[__name__ + ".moves.urllib_parse"]
    error = sys.modules[__name__ + ".moves.urllib_error"]
    request = sys.modules[__name__ + ".moves.urllib_request"]
    response = sys.modules[__name__ + ".moves.urllib_response"]
    robotparser = sys.modules[__name__ + ".moves.urllib_robotparser"]

    def __dir__(self):
        return ['parse', 'error', 'request', 'response', 'robotparser']


sys.modules[__name__ + ".moves.urllib"] = Module_six_moves_urllib(__name__ + ".moves.urllib")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_closure = "__closure__"
    _func_code = "__code__"
    _func_defaults = "__defaults__"
    _func_globals = "__globals__"

    _iterkeys = "keys"
    _itervalues = "values"
    _iteritems = "items"
    _iterlists = "lists"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_closure = "func_closure"
    _func_code = "func_code"
    _func_defaults = "func_defaults"
    _func_globals = "func_globals"

    _iterkeys = "iterkeys"
    _itervalues = "itervalues"
    _iteritems = "iteritems"
    _iterlists = "iterlists"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


try:
    callable = callable
except NameError:
    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
    def get_unbound_function(unbound):
        return unbound

    create_bound_method = types.MethodType

    Iterator = object
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    def create_bound_method(func, obj):
        return types.MethodType(func, obj, obj.__class__)

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_closure = operator.attrgetter(_func_closure)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)
get_function_globals = operator.attrgetter(_func_globals)


def iterkeys(d, **kw):
    """Return an iterator over the keys of a dictionary."""
    return iter(getattr(d, _iterkeys)(**kw))

def itervalues(d, **kw):
    """Return an iterator over the values of a dictionary."""
    return iter(getattr(d, _itervalues)(**kw))

def iteritems(d, **kw):
    """Return an iterator over the (key, value) pairs of a dictionary."""
    return iter(getattr(d, _iteritems)(**kw))

def iterlists(d, **kw):
    """Return an iterator over the (key, [values]) pairs of a dictionary."""
    return iter(getattr(d, _iterlists)(**kw))


if PY3:
    def b(s):
        return s.encode("latin-1")
    def u(s):
        return s
    unichr = chr
    if sys.version_info[1] <= 1:
        def int2byte(i):
            return bytes((i,))
    else:
        # This is about 2x faster than the implementation above on 3.2+
        int2byte = operator.methodcaller("to_bytes", 1, "big")
    byte2int = operator.itemgetter(0)
    indexbytes = operator.getitem
    iterbytes = iter
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    def b(s):
        return s
    # Workaround for standalone backslash
    def u(s):
        return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
    unichr = unichr
    int2byte = chr
    def byte2int(bs):
        return ord(bs[0])
    def indexbytes(buf, i):
        return ord(buf[i])
    def iterbytes(buf):
        return (ord(byte) for byte in buf)
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


if PY3:
    exec_ = getattr(moves.builtins, "exec")


    def reraise(tp, value, tb=None):
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
        raise value

else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")


    exec_("""def reraise(tp, value, tb=None):
    raise tp, value, tb
""")


print_ = getattr(moves.builtins, "print", None)
if print_ is None:
    def print_(*args, **kwargs):
        """The new-style print function for Python 2.4 and 2.5."""
        fp = kwargs.pop("file", sys.stdout)
        if fp is None:
            return
        def write(data):
            if not isinstance(data, basestring):
                data = str(data)
            # If the file has an encoding, encode unicode with it.
            if (isinstance(fp, file) and
                isinstance(data, unicode) and
                fp.encoding is not None):
                errors = getattr(fp, "errors", None)
                if errors is None:
                    errors = "strict"
                data = data.encode(fp.encoding, errors)
            fp.write(data)
        want_unicode = False
        sep = kwargs.pop("sep", None)
        if sep is not None:
            if isinstance(sep, unicode):
                want_unicode = True
            elif not isinstance(sep, str):
                raise TypeError("sep must be None or a string")
        end = kwargs.pop("end", None)
        if end is not None:
            if isinstance(end, unicode):
                want_unicode = True
            elif not isinstance(end, str):
                raise TypeError("end must be None or a string")
        if kwargs:
            raise TypeError("invalid keyword arguments to print()")
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode):
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n")
            space = unicode(" ")
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args):
            if i:
                write(sep)
            write(arg)
        write(end)

_add_doc(reraise, """Reraise an exception.""")


def with_metaclass(meta, *bases):
    """Create a base class with a metaclass."""
    return meta("NewBase", bases, {})

def add_metaclass(metaclass):
    """Class decorator for creating a class with a metaclass."""
    def wrapper(cls):
        orig_vars = cls.__dict__.copy()
        orig_vars.pop('__dict__', None)
        orig_vars.pop('__weakref__', None)
        slots = orig_vars.get('__slots__')
        if slots is not None:
            if isinstance(slots, str):
                slots = [slots]
            for slots_var in slots:
                orig_vars.pop(slots_var)
        return metaclass(cls.__name__, cls.__bases__, orig_vars)
    return wrapper

########NEW FILE########
__FILENAME__ = wcs_slicing
import numpy as np

from astropy import units as u
from astropy.wcs import WCS, WCSSUB_SPECTRAL
from .wcs_utils import get_spectral_scale


def slice_wcs(wcs, spatial_scale):
    """
    Slice a WCS header for a spectral cube to a Position-Velocity WCS, with
    ctype "OFFSET" for the spatial offset direction

    Parameters
    ----------
    wcs : :class:`~astropy.wcs.WCS`
        The WCS of the spectral cube. This should already be sanitized and
        have the spectral axis along the third dimension.
    spatial_scale: :class:`~astropy.units.Quantity`
        The spatial scale of the position axis

    Returns
    -------
    wcs_slice :class:`~astropy.wcs.WCS`
        The resulting WCS slice
    """

    # Extract spectral slice
    wcs_slice = wcs.sub([0, WCSSUB_SPECTRAL])

    # Set spatial parameters
    wcs_slice.wcs.crpix[0] = 1.
    wcs_slice.wcs.cdelt[0] = spatial_scale.to(u.degree).value
    wcs_slice.wcs.crval[0] = 0.
    wcs_slice.wcs.ctype[0] = "OFFSET"
    wcs_slice.wcs.cunit[0] = 'deg'

    return wcs_slice

########NEW FILE########
__FILENAME__ = wcs_utils
import numpy as np
from astropy import units as u
from astropy.wcs import WCSSUB_CELESTIAL, WCSSUB_SPECTRAL


def get_spatial_scale(wcs, assert_square=True):

    # Code adapted from APLpy

    wcs = wcs.sub([WCSSUB_CELESTIAL])
    cdelt = np.matrix(wcs.wcs.get_cdelt())
    pc = np.matrix(wcs.wcs.get_pc())
    scale = np.array(cdelt * pc)

    if assert_square:
        try:
            np.testing.assert_almost_equal(abs(cdelt[0,0]), abs(cdelt[0,1]))
            np.testing.assert_almost_equal(abs(pc[0,0]), abs(pc[1,1]))
            np.testing.assert_almost_equal(abs(scale[0,0]), abs(scale[0,1]))
        except AssertionError:
            raise ValueError("Non-square pixels.  Please resample data.")

    return abs(scale[0,0]) * u.Unit(wcs.wcs.cunit[0])


def get_spectral_scale(wcs):

    # Code adapted from APLpy

    wcs = wcs.sub([WCSSUB_SPECTRAL])
    cdelt = np.matrix(wcs.wcs.get_cdelt())
    pc = np.matrix(wcs.wcs.get_pc())
    scale = np.array(cdelt * pc)

    return abs(scale[0,0]) * u.Unit(wcs.wcs.cunit[0])


def sanitize_wcs(mywcs):
    pc = np.matrix(mywcs.wcs.get_pc())
    if (pc[:,2].sum() != pc[2,2] or pc[2,:].sum() != pc[2,2]):
        raise ValueError("Non-independent 3rd axis.")
    axtypes = mywcs.get_axis_types()
    if ((axtypes[0]['coordinate_type'] != 'celestial' or
         axtypes[1]['coordinate_type'] != 'celestial' or
         axtypes[2]['coordinate_type'] != 'spectral')):
        cunit3 = mywcs.wcs.cunit[2]
        ctype3 = mywcs.wcs.ctype[2]
        if cunit3 != '':
            cunit3 = u.Unit(cunit3)
            if cunit3.is_equivalent(u.m/u.s):
                mywcs.wcs.ctype[2] = 'VELO'
            elif cunit3.is_equivalent(u.Hz):
                mywcs.wcs.ctype[2] = 'FREQ'
            elif cunit3.is_equivalent(u.m):
                mywcs.wcs.ctype[2] = 'WAVE'
            else:
                raise ValueError("Could not determine type of 3rd axis.")
        elif ctype3 != '':
            if 'VELO' in ctype3:
                mywcs.wcs.ctype[2] = 'VELO'
            elif 'FELO' in ctype3:
                mywcs.wcs.ctype[2] = 'VELO-F2V'
            elif 'FREQ' in ctype3:
                mywcs.wcs.ctype[2] = 'FREQ'
            elif 'WAVE' in ctype3:
                mywcs.wcs.ctype[2] = 'WAVE'
            else:
                raise ValueError("Could not determine type of 3rd axis.")
        else:
            raise ValueError("Cube axes not in expected orientation: PPV")
    return mywcs


def get_wcs_system_frame(wcs):
    """TODO: move to astropy.wcs.utils"""
    ct = wcs.sub([WCSSUB_CELESTIAL]).wcs.ctype
    if 'GLON' in ct[0]:
        from astropy.coordinates import Galactic
        return Galactic
    elif 'RA' in ct[0]:
        from astropy.coordinates import ICRS
        return ICRS
    else:
        raise ValueError("Unrecognized coordinate system")

########NEW FILE########
__FILENAME__ = qt
""" A Qt API selector that can be used to switch between PyQt and PySide.

This file lovingly borrows from the IPython and python_qt_binding project

https://github.com/ipython/ipython/blob/master/IPython/external/qt.py
https://github.com/ros-visualization/python_qt_binding/


See also this discussion
http://qt-project.org/wiki/Differences_Between_PySide_and_PyQt

Do not use this if you need PyQt with the old QString/QVariant API.
"""

import os
import sys


# Available APIs.
QT_API_PYQT = 'pyqt'
QT_API_PYSIDE = 'pyside'
QT_API = None

# import hook to protect importing of both PySide and PyQt4


class ImportDenier(object):
    __forbidden = set()

    def __init__(self):
        self.__forbidden = None

    def forbid(self, module_name):
        self.__forbidden = module_name

    def find_module(self, mod_name, pth):
        if pth:
            return
        if mod_name == self.__forbidden:
            return self

    def load_module(self, mod_name):
        raise ImportError("Importing %s forbidden by %s"
                          % (mod_name, __name__))


_import_hook = ImportDenier()
sys.meta_path.append(_import_hook)


def prepare_pyqt4():
    # For PySide compatibility, use the new-style string API that automatically
    # converts QStrings to Unicode Python strings. Also, automatically unpack
    # QVariants to their underlying objects.
    import sip
    sip.setapi('QString', 2)
    sip.setapi('QVariant', 2)


def register_module(module, modlabel):
    """Register an imported module into a
    submodule of glue.external.qt. Enables syntax like
    from glue.qt.QtGui import QMessageBox
    """
    sys.modules[__name__ + '.' + modlabel] = module


def deny_module(mod_name):
    _import_hook.forbid(mod_name)


def _load_pyqt4():
    prepare_pyqt4()
    from PyQt4 import QtCore, QtGui, QtTest
    from distutils.version import LooseVersion
    if LooseVersion(QtCore.PYQT_VERSION_STR) < LooseVersion('4.8'):
        raise ImportError("Glue Requires PyQt4 >= 4.8")

    QtCore.Signal = QtCore.pyqtSignal
    QtCore.Slot = QtCore.pyqtSlot
    QtCore.Property = QtCore.pyqtProperty

    from PyQt4.QtGui import QFileDialog
    QFileDialog.getOpenFileName = QFileDialog.getOpenFileNameAndFilter
    QFileDialog.getSaveFileName = QFileDialog.getSaveFileNameAndFilter

    register_module(QtCore, 'QtCore')
    register_module(QtGui, 'QtGui')
    register_module(QtTest, 'QtTest')

    global QT_API
    QT_API = QT_API_PYQT

    deny_module('PySide')


def _load_pyside():
    from PySide import QtCore, QtGui, __version__, QtTest
    if __version__ < '1.0.3':
        # old PySide, fallback on PyQt
        raise ImportError("Glue requires PySide >= 1.0.3")

    register_module(QtCore, 'QtCore')
    register_module(QtGui, 'QtGui')
    register_module(QtTest, 'QtTest')

    def setMargin(self, x):
        self.setContentsMargins(x, x, x, x)
    QtGui.QLayout.setMargin = setMargin

    global QT_API
    QT_API = QT_API_PYSIDE

    deny_module('PyQt4')

loaders = [_load_pyqt4, _load_pyside]
if os.environ.get('QT_API') == QT_API_PYSIDE:
    loaders = loaders[::-1]

msgs = []

# acutally do the loading
for loader in loaders:
    try:
        loader()
        # we set this env var, since IPython also looks for it
        os.environ['QT_API'] = QT_API
        QtCore = sys.modules[__name__ + '.QtCore']
        QtGui = sys.modules[__name__ + '.QtGui']
        break
    except ImportError as e:
        msgs.append(str(e))
        pass
else:
    raise ImportError("Could not find a suitable QT installation."
                      " Encountered the following errors: %s" %
                      '\n'.join(msgs))


def is_pyside():
    return QT_API == QT_API_PYSIDE


def is_pyqt():
    return QT_API == QT_API_PYQT

########NEW FILE########
__FILENAME__ = test_echo
from mock import MagicMock
import pytest

from ..echo import (CallbackProperty, add_callback,
                    remove_callback, delay_callback,
                    ignore_callback, callback_property)


class Stub(object):
    prop1 = CallbackProperty()
    prop2 = CallbackProperty(5)
    prop3 = 5


class DecoratorStub(object):

    def __init__(self):
        self._val = 1

    @callback_property
    def prop(self):
        return self._val * 2

    @prop.setter
    def prop(self, value):
        self._val = value


def test_attribute_like_access():
    stub = Stub()
    assert stub.prop1 is None
    assert stub.prop2 == 5


def test_attribute_like_set():
    stub = Stub()
    stub.prop1 = 10
    assert stub.prop1 == 10


def test_class_access():
    stub = Stub()
    assert isinstance(type(stub).prop1, CallbackProperty)


def test_callback_fire_on_change():
    stub = Stub()
    test = MagicMock()
    add_callback(stub, 'prop1', test)
    stub.prop1 = 5
    test.assert_called_once_with(5)


def test_callbacks_only_called_on_value_change():
    stub = Stub()
    test = MagicMock()
    add_callback(stub, 'prop1', test)
    stub.prop1 = 5
    test.assert_called_once_with(5)
    stub.prop1 = 5
    assert test.call_count == 1


def test_callbacks_are_instance_specific():
    s1, s2 = Stub(), Stub()
    test = MagicMock()
    add_callback(s2, 'prop1', test)
    s1.prop1 = 100
    assert test.call_count == 0


def test_remove_callback():
    stub = Stub()
    test = MagicMock()
    add_callback(stub, 'prop1', test)
    remove_callback(stub, 'prop1', test)
    stub.prop1 = 5
    assert test.call_count == 0


def test_add_callback_attribute_error_on_bad_name():
    stub = Stub()
    with pytest.raises(AttributeError):
        add_callback(stub, 'bad_property', None)


def test_add_callback_type_error_if_not_calllback():
    stub = Stub()
    with pytest.raises(TypeError) as exc:
        add_callback(stub, 'prop3', None)
    assert exc.value.args[0] == "prop3 is not a CallbackProperty"


def test_remove_callback_attribute_error_on_bad_name():
    stub = Stub()
    with pytest.raises(AttributeError):
        remove_callback(stub, 'bad_property', None)


def test_remove_callback_wrong_function():
    stub = Stub()
    test = MagicMock()
    test2 = MagicMock()
    add_callback(stub, 'prop1', test)
    with pytest.raises(ValueError) as exc:
        remove_callback(stub, 'prop1', test2)
    assert exc.value.args[0].startswith('Callback function not found')


def test_remove_non_callback_property():
    stub = Stub()
    with pytest.raises(TypeError) as exc:
        remove_callback(stub, 'prop3', None)
    assert exc.value.args[0] == 'prop3 is not a CallbackProperty'


def test_remove_callback_not_found():
    stub = Stub()
    with pytest.raises(ValueError) as exc:
        remove_callback(stub, 'prop1', None)
    assert exc.value.args[0] == "Callback function not found: None"


def test_disable_callback():
    stub = Stub()
    test = MagicMock()

    add_callback(stub, 'prop1', test)
    Stub.prop1.disable(stub)

    stub.prop1 = 100
    assert test.call_count == 0

    Stub.prop1.enable(stub)
    stub.prop1 = 100
    assert test.call_count == 0  # not changed
    stub.prop1 = 200
    assert test.call_count == 1


def test_delay_callback():
    test = MagicMock()
    stub = Stub()

    add_callback(stub, 'prop1', test)
    with delay_callback(stub, 'prop1'):
        stub.prop1 = 100
        stub.prop1 = 200
        stub.prop1 = 300
        assert test.call_count == 0
    test.assert_called_once_with(300)


def test_delay_callback_not_called_if_unmodified():
    test = MagicMock()
    stub = Stub()
    add_callback(stub, 'prop1', test)
    with delay_callback(stub, 'prop1'):
        pass
    assert test.call_count == 0


def test_callback_with_two_arguments():
    stub = Stub()
    stub.prop1 = 5
    on_change = MagicMock()
    add_callback(stub, 'prop1', on_change, echo_old=True)
    stub.prop1 = 10

    on_change.assert_called_once_with(5, 10)


@pytest.mark.parametrize('context_func', (delay_callback, ignore_callback))
def test_context_on_non_callback(context_func):
    stub = Stub()
    with pytest.raises(TypeError) as exc:
        with context_func(stub, 'prop3'):
            pass
    assert exc.value.args[0] == "prop3 is not a CallbackProperty"


def test_delay_multiple():
    stub = Stub()
    test = MagicMock()
    test2 = MagicMock()

    add_callback(stub, 'prop1', test)
    add_callback(stub, 'prop2', test2)

    with delay_callback(stub, 'prop1', 'prop2'):
        stub.prop1 = 50
        stub.prop1 = 100
        stub.prop2 = 200
        assert test.call_count == 0
        assert test2.call_count == 0

    test.assert_called_once_with(100)
    test2.assert_called_once_with(200)


def test_ignore_multiple():
    stub = Stub()
    test = MagicMock()
    test2 = MagicMock()

    add_callback(stub, 'prop1', test)
    add_callback(stub, 'prop2', test2)

    with ignore_callback(stub, 'prop1', 'prop2'):
        stub.prop1 = 100
        stub.prop2 = 200
        assert test.call_count == 0
        assert test2.call_count == 0

    assert test.call_count == 0
    assert test2.call_count == 0


def test_delay_only_calls_if_changed():
    stub = Stub()
    test = MagicMock()

    add_callback(stub, 'prop1', test)

    with delay_callback(stub, 'prop1'):
        pass
    assert test.call_count == 0

    val = stub.prop1
    with delay_callback(stub, 'prop1'):
        stub.prop1 = val
    assert test.call_count == 0


def test_decorator_form():
    stub = DecoratorStub()
    test = MagicMock()
    add_callback(stub, 'prop', test)

    assert stub.prop == 2

    stub.prop = 5
    test.assert_called_once_with(10)

    assert stub.prop == 10

########NEW FILE########
__FILENAME__ = test_qt
import os
import sys

from .. import qt

import pytest
from mock import MagicMock


"""
We don't run these tests by default, since they import both PyQt4 and
PySide, and this brings all manner of sadness to subsequent tests.

To run these tests, run `py.test --qtapi`
"""


@pytest.mark.skipif("'--qtapi' not in sys.argv")
class TestQT(object):
    def teardown_class(cls):
        for m in sys.modules.keys():
            if m.startswith('PyQt4') or m.startswith('PySide'):
                sys.modules.pop(m)

    def setup_method(self, method):
        qt.deny_module(None)
        os.environ.pop('QT_API')

    def test_defaults_to_qt4(self):
        reload(qt)
        assert qt.QT_API == qt.QT_API_PYQT

    def _load_qt4(self):
        os.environ['QT_API'] = qt.QT_API_PYQT
        reload(qt)

    def _load_pyside(self):
        os.environ['QT_API'] = qt.QT_API_PYSIDE
        reload(qt)

    def test_overridden_with_env(self):
        os.environ['QT_API'] = qt.QT_API_PYSIDE
        reload(qt)
        assert qt.QT_API == qt.QT_API_PYSIDE

    def test_main_import(self):
        self._load_qt4()
        from ..qt import QtCore
        from ..qt import QtGui

        from PyQt4 import QtCore as core, QtGui as gui
        assert QtCore is core
        assert QtGui is gui

        self._load_pyside()
        from ..qt import QtCore
        from ..qt import QtGui

        from PySide import QtCore as core, QtGui as gui
        assert QtCore is core
        assert QtGui is gui

    def test_submodule_import(self):
        self._load_qt4()
        from ..qt.QtGui import QMessageBox
        from ..qt.QtCore import Qt
        from PyQt4.QtGui import QMessageBox as qmb
        from PyQt4.QtCore import Qt as _qt
        assert qmb is QMessageBox
        assert _qt is Qt

        self._load_pyside()
        from ..qt.QtGui import QMessageBox
        from ..qt.QtCore import Qt

        from PySide.QtGui import QMessageBox as qmb
        from PySide.QtCore import Qt as _qt
        assert qmb is QMessageBox
        assert _qt is Qt

    def test_signal_slot_property(self):
        self._load_qt4()
        from ..qt.QtCore import Signal, Slot, Property

    def test_qt4_unavailable(self):
        import PyQt4
        try:
            sys.modules['PyQt4'] = None
            self._load_qt4()
            assert qt.QT_API == qt.QT_API_PYSIDE
        finally:
            sys.modules['PyQt4'] = PyQt4

    def test_pyside_unavailable(self):
        import PySide
        try:
            sys.modules['PySide'] = None
            self._load_pyside()
            assert qt.QT_API == qt.QT_API_PYQT
        finally:
            sys.modules['PySide'] = PySide

    def test_both_unavailable(self):
        import PySide
        import PyQt4
        try:
            sys.modules['PySide'] = None
            sys.modules['PyQt4'] = None
            with pytest.raises(ImportError) as e:
                reload(qt)
        finally:
            sys.modules['PySide'] = PySide
            sys.modules['PyQt4'] = PyQt4

########NEW FILE########
__FILENAME__ = axislabels
import numpy as np

from matplotlib.text import Text


class AxisLabels(Text):

    def __init__(self, frame, *args, **kwargs):
        self._frame = frame
        super(AxisLabels, self).__init__(*args, **kwargs)
        self.set_clip_on(True)
        self.set_visible_axes('all')
        self.set_ha('center')
        self.set_va('center')

    def set_visible_axes(self, visible_axes):
        self._visible_axes = visible_axes

    def get_visible_axes(self):
        if self._visible_axes == 'all':
            return self._frame.keys()
        else:
            return [x for x in self._visible_axes if x in self._frame]

    def draw(self, renderer, bboxes):

        text_size = renderer.points_to_pixels(self.get_size())

        for axis in self.get_visible_axes():

            # Find position of the axis label. For now we pick the mid-point
            # along the path but in future we could allow this to be a
            # parameter.
            x_disp, y_disp = self._frame[axis].pixel[:,0], self._frame[axis].pixel[:,1]
            d = np.hstack([0., np.cumsum(np.sqrt(np.diff(x_disp)**2 + np.diff(y_disp)**2))])
            xcen = np.interp(d[-1]/2., d, x_disp)
            ycen = np.interp(d[-1]/2., d, y_disp)

            # Find segment along which the mid-point lies
            imin = np.searchsorted(d, d[-1] / 2.) - 1

            # Find normal of the axis label facing outwards on that segment
            normal_angle = self._frame[axis].normal_angle[imin] + 180.

            label_angle = (normal_angle - 90.) % 360.
            if label_angle < 225 and label_angle > 135:
                label_angle += 180
            self.set_rotation(label_angle)

            # Find label position, by trying to move it successively further
            # away from the axis and then checking for intersection with tick
            # labels. Obviously this could be optimized if needed.
            dx = np.cos(np.radians(normal_angle)) * text_size
            dy = np.sin(np.radians(normal_angle)) * text_size

            for pad in np.linspace(0.8, 8.8, 21):

                xlabel = xcen + dx * pad
                ylabel = ycen + dy * pad

                self.set_position((xlabel, ylabel))

                bb = super(AxisLabels, self).get_window_extent(renderer)

                if bb.count_overlaps(bboxes) == 0:
                    break

            self.set_position((xlabel + dx * pad * 0.3, ylabel + dy * pad * 0.3))
            super(AxisLabels, self).draw(renderer)

            bb = super(AxisLabels, self).get_window_extent(renderer)
            bboxes.append(bb)

########NEW FILE########
__FILENAME__ = coordinates_map
from .coordinate_helpers import CoordinateHelper
from .transforms import WCSPixel2WorldTransform
from .utils import coord_type_from_ctype
from .frame import RectangularFrame

from . import six


class CoordinatesMap(object):

    def __init__(self, axes, wcs, transform=None, slice=None):

        # Keep track of parent axes and WCS
        self._axes = axes
        self._wcs = wcs

        # Set up transform
        if transform is None:
            self._transform = WCSPixel2WorldTransform(self._wcs, slice=slice)
        else:
            self._transform = transform

        self.frame = RectangularFrame(axes, self._transform)

        # Set up coordinates
        self._coords = []
        self._aliases = {}

        for coord_index in range(self._wcs.wcs.naxis):

            coord_type = coord_type_from_ctype(wcs.wcs.ctype[coord_index])
            self._coords.append(CoordinateHelper(parent_axes=axes,
                                                 transform=self._transform,
                                                 coord_index=coord_index,
                                                 coord_type=coord_type,
                                                 frame=self.frame))


            # Set up aliases for coordinates
            name = self._wcs.wcs.ctype[coord_index][:4].replace('-', '')
            self._aliases[name.lower()] = coord_index

    def __getitem__(self, item):
        if isinstance(item, six.string_types):
            return self._coords[self._aliases[item.lower()]]
        else:
            return self._coords[item]

    def set_visible(self, visibility):
        raise NotImplementedError()

    def enable_offset_mode(self, reference_coordinates):
        raise NotImplementedError()

    def disable_offset_mode(self):
        raise NotImplementedError()

    def __iter__(self):
        for coord in self._coords:
            yield coord

    def grid(self, draw_grid=True, grid_type='lines', **kwargs):
        """
        Plot gridlines for both coordinates.

        Standard matplotlib appearance options (color, alpha, etc.) can be
        passed as keyword arguments.

        Parameters
        ----------
        draw_grid : bool
            Whether to show the gridlines
        grid_type : { 'lines' | 'contours' }
            Whether to plot the contours by determining the grid lines in
            world coordinates and then plotting them in world coordinates
            (``'lines'``) or by determining the world coordinates at many
            positions in the image and then drawing contours
            (``'contours'``). The first is recommended for 2-d images, while
            for 3-d (or higher dimensional) cubes, the ``'contours'`` option
            is recommended.
        """
        for coord in self:
            coord.grid(draw_grid=draw_grid, grid_type=grid_type, **kwargs)

########NEW FILE########
__FILENAME__ = coordinate_helpers
"""
This file defines the classes used to represent a 'coordinate', which includes
axes, ticks, tick labels, and grid lines.
"""

import numpy as np

from matplotlib.ticker import Formatter
from matplotlib.transforms import Affine2D, ScaledTranslation
from matplotlib.patches import PathPatch

from .formatter_locator import AngleFormatterLocator, ScalarFormatterLocator
from .ticks import Ticks
from .ticklabels import TickLabels
from .axislabels import AxisLabels
from .grid_paths import get_lon_lat_path, get_gridline_path
from . import settings

from . import six

__all__ = ['CoordinateHelper']


def wrap_angle_at(values, coord_wrap):
    return np.mod(values - coord_wrap, 360.) - (360. - coord_wrap)


class CoordinateHelper(object):

    def __init__(self, parent_axes=None, transform=None, coord_index=None,
                 coord_type='scalar', coord_wrap=None, frame=None):

        # Keep a reference to the parent axes and the transform
        self.parent_axes = parent_axes
        self.transform = transform
        self.coord_index = coord_index
        self.coord_type = coord_type
        self.frame = frame

        if coord_type == 'longitude' and coord_wrap is None:
            self.coord_wrap = 360
        elif coord_type != 'longitude' and coord_wrap is not None:
            raise NotImplementedError('coord_wrap is not yet supported for non-longitude coordinates')
        else:
            self.coord_wrap = coord_wrap

        # Initialize tick formatter/locator
        if coord_type == 'scalar':
            self._formatter_locator = ScalarFormatterLocator()
        elif coord_type in ['longitude', 'latitude']:
            self._formatter_locator = AngleFormatterLocator()
        else:
            raise ValueError("coord_type should be one of 'scalar', 'longitude', or 'latitude'")

        # Initialize ticks
        self.dpi_transform = Affine2D()
        self.offset_transform = ScaledTranslation(0, 0, self.dpi_transform)
        self.ticks = Ticks(transform=parent_axes.transData + self.offset_transform)

        # Initialize tick labels
        self.ticklabels = TickLabels(transform=None,  # display coordinates
                                     figure=parent_axes.get_figure())

        # Initialize axis labels
        self.axislabels = AxisLabels(self.frame,
                                     transform=None,  # display coordinates
                                     figure=parent_axes.get_figure())

        # Initialize container for the grid lines
        self.grid_lines = []
        self.grid_lines_kwargs = {'visible':False,
                                  'facecolor':'none',
                                  'transform':self.parent_axes.transData}

    def grid(self, draw_grid=True, grid_type='lines', **kwargs):
        """
        Plot grid lines for this coordinate.

        Standard matplotlib appearance options (color, alpha, etc.) can be
        passed as keyword arguments.

        Parameters
        ----------
        draw_grid : bool
            Whether to show the gridlines
        grid_type : { 'lines' | 'contours' }
            Whether to plot the contours by determining the grid lines in
            world coordinates and then plotting them in world coordinates
            (``'lines'``) or by determining the world coordinates at many
            positions in the image and then drawing contours
            (``'contours'``). The first is recommended for 2-d images, while
            for 3-d (or higher dimensional) cubes, the ``'contours'`` option
            is recommended.
        """

        if grid_type in ('lines', 'contours'):
            self._grid_type = grid_type
        else:
            raise ValueError("grid_type should be 'lines' or 'contours'")

        if 'color' in kwargs:
            kwargs['edgecolor'] = kwargs.pop('color')

        self.grid_lines_kwargs.update(kwargs)

        if self.grid_lines_kwargs['visible']:
            if not draw_grid:
                self.grid_lines_kwargs['visible'] = False
        else:
            self.grid_lines_kwargs['visible'] = True

    def set_major_formatter(self, formatter):
        """
        Set the formatter to use for the major tick labels.

        Parameters
        ----------
        formatter : str or Formatter
            The format or formatter to use.
        """
        if isinstance(formatter, Formatter):
            raise NotImplementedError()  # figure out how to swap out formatter
        elif isinstance(formatter, six.string_types):
            self._formatter_locator.format = formatter
        else:
            raise TypeError("formatter should be a string or a Formatter "
                            "instance")

    def set_ticks(self, values=None, spacing=None, number=None, size=None,
                  color=None, alpha=None):
        """
        Set the location and properties of the ticks.

        At most one of the options from ``values``, ``spacing``, or
        ``number`` can be specified.

        Parameters
        ----------
        values : iterable, optional
            The coordinate values at which to show the ticks.
        spacing : float, optional
            The spacing between ticks.
        number : float, optional
            The approximate number of ticks shown.
        size : float, optional
            The length of the ticks in points
        color : str or tuple
            A valid Matplotlib color for the ticks
        """

        if sum([values is None, spacing is None, number is None]) < 2:
            raise ValueError("At most one of values, spacing, or number should "
                             "be specified")

        if values is not None:
            self._formatter_locator.values = values
        elif spacing is not None:
            self._formatter_locator.spacing = spacing
        elif number is not None:
            self._formatter_locator.number = number

        if size is not None:
            self.ticks.set_ticksize(size)

        if color is not None:
            self.ticks.set_color(color)

        if alpha is not None:
            self.ticks.set_alpha(alpha)

    def set_ticks_position(self, position):
        """
        Set where ticks should appear

        Parameters
        ----------
        position : str
            The axes on which the ticks for this coordinate should appear.
            Should be a string containing zero or more of ``'b'``, ``'t'``,
            ``'l'``, ``'r'``. For example, ``'lb'`` will lead the ticks to be
            shown on the left and bottom axis.
        """
        self.ticks.set_visible_axes(position)

    def set_ticklabel(self, **kwargs):
        """
        Set the visual properties for the tick labels.

        Parameters
        ----------
        kwargs
            Keyword arguments are passed to :class:`matplotlib.text.Text`. These
            can include keywords to set the ``color``, ``size``, ``weight``, and
            other text properties.
        """
        self.ticklabels.set(**kwargs)

    def set_ticklabel_position(self, position):
        """
        Set where tick labels should appear

        Parameters
        ----------
        position : str
            The axes on which the tick labels for this coordinate should
            appear. Should be a string containing zero or more of ``'b'``,
            ``'t'``, ``'l'``, ``'r'``. For example, ``'lb'`` will lead the
            tick labels to be shown on the left and bottom axis.
        """
        self.ticklabels.set_visible_axes(position)

    def set_axislabel(self, text, **kwargs):
        """
        Set the text and optionally visual properties for the axis label.

        Parameters
        ----------
        text : str
            The axis label text.
        kwargs
            Keywords are passed to :class:`matplotlib.text.Text`. These
            can include keywords to set the ``color``, ``size``, ``weight``, and
            other text properties.
        """
        self.axislabels.set_text(text)
        self.axislabels.set(**kwargs)

    def get_axislabel(self):
        """
        Get the text for the axis label

        Returns
        -------
        label : str
            The axis label
        """
        return self.axislabels.get_text()

    def set_axislabel_position(self, position):
        """
        Set where axis labels should appear

        Parameters
        ----------
        position : str
            The axes on which the axis label for this coordinate should
            appear. Should be a string containing zero or more of ``'b'``,
            ``'t'``, ``'l'``, ``'r'``. For example, ``'lb'`` will lead the
            axis label to be shown on the left and bottom axis.
        """
        self.axislabels.set_visible_axes(position)

    @property
    def locator(self):
        return self._formatter_locator.locator

    @property
    def formatter(self):
        return self._formatter_locator.formatter

    def _draw(self, renderer, bboxes):

        renderer.open_group('coordinate_axis')

        self._update_ticks(renderer)

        self.ticks.draw(renderer)
        self.ticklabels.draw(renderer, bboxes=bboxes)

        if self.grid_lines_kwargs['visible']:

            if self._grid_type == 'lines':
                self._update_grid_lines()
            else:
                self._update_grid_contour()

            if self._grid_type == 'lines':

                for path in self.grid_lines:
                    p = PathPatch(path, **self.grid_lines_kwargs)
                    p.set_clip_path(self.frame.path, Affine2D())
                    p.draw(renderer)

            else:

                for line in self.grid.collections:
                    line.set(**self.grid_lines_kwargs)
                    line.draw(renderer)

        renderer.close_group('coordinate_axis')

    def _draw_axislabels(self, renderer, bboxes):

        renderer.open_group('axis labels')

        self.axislabels.draw(renderer, bboxes=bboxes)

        renderer.close_group('axis labels')

    def _update_ticks(self, renderer):

        # TODO: this method should be optimized for speed

        # Here we determine the location and rotation of all the ticks. For
        # each axis, we can check the intersections for the specific
        # coordinate and once we have the tick positions, we can use the WCS
        # to determine the rotations.

        # Find the range of coordinates in all directions
        coord_range = self.parent_axes.get_coord_range(self.transform)

        # First find the ticks we want to show
        tick_world_coordinates, spacing = self._formatter_locator.locator(*coord_range[self.coord_index])

        # We want to allow non-standard rectangular frames, so we just rely on
        # the parent axes to tell us what the bounding frame is.
        frame = self.frame.sample(settings.FRAME_BOUNDARY_SAMPLES)

        self.ticks.clear()
        self.ticklabels.clear()
        lblinfo = []
        lbl_world = []

        for axis, spine in frame.iteritems():

            # Determine tick rotation in display coordinates and compare to
            # the normal angle in display coordinates.

            pixel0 = spine.data
            world0 = spine.world[:,self.coord_index]
            world0 = self.transform.transform(pixel0)[:,self.coord_index]

            pixel1 = pixel0.copy()
            pixel1[:,0] += 1
            world1 = self.transform.transform(pixel1)[:,self.coord_index]

            pixel2 = pixel0.copy()
            pixel2[:,1] += 1 if self.frame.origin == 'lower' else -1
            world2 = self.transform.transform(pixel2)[:,self.coord_index]

            dx = (world1 - world0)
            dy = (world2 - world0)

            # Rotate by 90 degrees
            dx, dy = -dy, dx

            if self.coord_type == 'longitude':
                # Here we wrap at 180 not self.coord_wrap since we want to
                # always ensure abs(dx) < 180 and abs(dy) < 180
                dx = wrap_angle_at(dx, 180.)
                dy = wrap_angle_at(dy, 180.)

            tick_angle = np.degrees(np.arctan2(dy, dx))

            normal_angle_full = np.hstack([spine.normal_angle, spine.normal_angle[-1]])
            reset = (((normal_angle_full - tick_angle) % 360 > 90.) &
                    ((tick_angle - normal_angle_full) % 360 > 90.))
            tick_angle[reset] -= 180.

            # We find for each interval the starting and ending coordinate,
            # ensuring that we take wrapping into account correctly for
            # longitudes.
            w1 = spine.world[:-1, self.coord_index]
            w2 = spine.world[1:, self.coord_index]
            if self.coord_type == 'longitude':
                w1 = wrap_angle_at(w1, self.coord_wrap)
                w2 = wrap_angle_at(w2, self.coord_wrap)
                w1[w2 - w1 > 180.] += 360
                w2[w1 - w2 > 180.] += 360

            # For longitudes, we need to check ticks as well as ticks + 360,
            # since the above can produce pairs such as 359 to 361 or 0.5 to
            # 1.5, both of which would match a tick at 0.75. Otherwise we just
            # check the ticks determined above.
            if self.coord_type == 'longitude':
                tick_world_coordinates = np.hstack([tick_world_coordinates,
                                                    tick_world_coordinates + 360.])

            for t in tick_world_coordinates:

                # Find steps where a tick is present
                intersections = np.nonzero(((t - w1) * (t - w2)) < 0)[0]

                # Loop over ticks, and find exact pixel coordinates by linear
                # interpolation
                for imin in intersections:

                    imax = imin + 1

                    frac = (t - w1[imin]) / (w2[imin] - w1[imin])
                    x_data_i = spine.data[imin, 0] + frac * (spine.data[imax, 0] - spine.data[imin, 0])
                    y_data_i = spine.data[imin, 1] + frac * (spine.data[imax, 1] - spine.data[imin, 1])
                    x_pix_i = spine.pixel[imin, 0] + frac * (spine.pixel[imax, 0] - spine.pixel[imin, 0])
                    y_pix_i = spine.pixel[imin, 1] + frac * (spine.pixel[imax, 1] - spine.pixel[imin, 1])
                    delta_angle = tick_angle[imax] - tick_angle[imin]
                    if delta_angle > 180.:
                        delta_angle -= 360.
                    elif delta_angle < -180.:
                        delta_angle += 360.
                    angle_i = tick_angle[imin] + frac * delta_angle

                    if self.coord_type == 'longitude':
                        world = wrap_angle_at(t, self.coord_wrap)
                    else:
                        world = t

                    self.ticks.add(axis=axis,
                                   pixel=(x_data_i, y_data_i),
                                   world=world,
                                   angle=angle_i,
                                   axis_displacement=imin + frac)

                    # store information to pass to ticklabels.add
                    # it's faster to format many ticklabels at once outside
                    # of the loop
                    lblinfo.append(dict(axis=axis,
                                   pixel=(x_pix_i, y_pix_i),
                                   world=world,
                                   angle=spine.normal_angle[imin],
                                   axis_displacement=imin + frac))
                    lbl_world.append(world)

        # format tick labels, add to scene
        text = self._formatter_locator.formatter(lbl_world, spacing=spacing)
        for kwargs, txt in zip(lblinfo, text):
            self.ticklabels.add(text=txt, **kwargs)

    def _update_grid_lines(self):

        # For 3-d WCS with a correlated third axis, the *proper* way of
        # drawing a grid should be to find the world coordinates of all pixels
        # and drawing contours. What we are doing here assumes that we can
        # define the grid lines with just two of the coordinates (and
        # therefore assumes that the other coordinates are fixed and set to
        # the value in the slice). Here we basically assume that if the WCS
        # had a third axis, it has been abstracted away in the transformation.

        coord_range = self.parent_axes.get_coord_range(self.transform)

        tick_world_coordinates, spacing = self._formatter_locator.locator(*coord_range[self.coord_index])

        self.grid_lines = []
        for w in tick_world_coordinates:
            if self.coord_index == 0:
                x_world = np.repeat(w, 1000)
                y_world = np.linspace(coord_range[1][0], coord_range[1][1], 1000)
            else:
                x_world = np.linspace(coord_range[0][0], coord_range[0][1], 1000)
                y_world = np.repeat(w, 1000)
            xy_world = np.vstack([x_world, y_world]).transpose()
            self.grid_lines.append(self._get_gridline(xy_world))

    def _get_gridline(self, xy_world):
        if self.coord_type == 'scalar':
            return get_gridline_path(self.parent_axes, self.transform, xy_world)
        else:
            return get_lon_lat_path(self.parent_axes, self.transform, xy_world)

    def _update_grid_contour(self):

        xmin, xmax = self.parent_axes.get_xlim()
        ymin, ymax = self.parent_axes.get_ylim()

        X, Y, field = self.transform.get_coord_slices(xmin, xmax, ymin, ymax, 200, 200)

        coord_range = self.parent_axes.get_coord_range(self.transform)

        tick_world_coordinates, spacing = self._formatter_locator.locator(*coord_range[self.coord_index])

        field = field[self.coord_index]

        if self.coord_type == 'longitude':

            # Find biggest gap in tick_world_coordinates and wrap in  middle
            # For now just assume spacing is equal, so any mid-point will do
            mid = 0.5 * (tick_world_coordinates[0] + tick_world_coordinates[1])
            field = wrap_angle_at(field, mid)
            tick_world_coordinates = wrap_angle_at(tick_world_coordinates, mid)

            # Replace wraps by NaN
            reset = (np.abs(np.diff(field[:,:-1], axis=0)) > 180) | (np.abs(np.diff(field[:-1,:], axis=1)) > 180)
            field[:-1,:-1][reset] = np.nan
            field[1:,:-1][reset] = np.nan
            field[:-1,1:][reset] = np.nan
            field[1:,1:][reset] = np.nan

        self.grid = self.parent_axes.contour(X, Y, field.transpose(), levels=tick_world_coordinates)

########NEW FILE########
__FILENAME__ = coordinate_range
import numpy as np

from . import settings

# Algorithm inspired by PGSBOX from WCSLIB by M. Calabretta


def wrap_180(values):
    values_new = values % 360.
    values_new[values_new > 180.] -= 360
    return values_new


def find_coordinate_range(transform, extent, coord_types):
    '''
    Find the range of coordinates to use for ticks/grids

    Parameters
    ----------
    pix2world : func
        Function to transform pixel to world coordinates. Should take two
        values (the pixel coordinates) and return two values (the world
        coordinates).
    extent : iterable
        The range of the image viewport in pixel coordinates, given as [xmin,
        xmax, ymin, ymax].
    coord_types : list of str
        Whether each coordinate is a ``'longitude'``, ``'latitude'``, or
        ``'scalar'`` value.
    '''

    # Sample coordinates on a NX x NY grid.
    NX = NY = settings.COORDINATE_RANGE_SAMPLES
    x = np.linspace(extent[0], extent[1], NX + 1)
    y = np.linspace(extent[2], extent[3], NY + 1)
    xp, yp = np.meshgrid(x, y)
    world = transform.transform(np.vstack([xp.ravel(), yp.ravel()]).transpose())

    ranges = []

    for coord_index, coord_type in enumerate(coord_types):

        xw = world[:, coord_index].reshape(xp.shape)

        if coord_type in ['longitude', 'latitude']:

            # Iron out coordinates along first row
            wjump = xw[0, 1:] - xw[0, :-1]
            reset = np.abs(wjump) > 180.
            if np.any(reset):
                wjump = wjump + np.sign(wjump) * 180.
                wjump = 360. * (wjump / 360.).astype(int)
                xw[0, 1:][reset] -= wjump[reset]

            # Now iron out coordinates along all columns, starting with first row.
            wjump = xw[1:] - xw[:1]
            reset = np.abs(wjump) > 180.
            if np.any(reset):
                wjump = wjump + np.sign(wjump) * 180.
                wjump = 360. * (wjump / 360.).astype(int)
                xw[1:][reset] -= wjump[reset]

        xw_min = np.nanmin(xw)
        xw_max = np.nanmax(xw)

        # Check if range is smaller when normalizing to the range 0 to 360

        if coord_type in ['longitude', 'latitude']:

            xw_min_check = np.min(xw % 360.)
            xw_max_check = np.max(xw % 360.)

            if xw_max - xw_min < 360. and xw_max - xw_min >= xw_max_check - xw_min_check:
                xw_min = xw_min_check
                xw_max = xw_max_check

        # Check if range is smaller when normalizing to the range -180 to 180

        if coord_type in ['longitude', 'latitude']:

            xw_min_check = np.min(wrap_180(xw))
            xw_max_check = np.max(wrap_180(xw))

            if xw_max_check - xw_min_check < 360. and xw_max - xw_min >= xw_max_check - xw_min_check:
                xw_min = xw_min_check
                xw_max = xw_max_check

        x_range = xw_max - xw_min
        if coord_type == 'longitude':
            if x_range > 300.:
                xw_min = 0.
                xw_max = 360.
            elif xw_min < 0.:
                xw_min = max(-180., xw_min - 0.1 * x_range)
                xw_max = min(+180., xw_max + 0.1 * x_range)
            else:
                xw_min = max(0., xw_min - 0.1 * x_range)
                xw_max = min(360., xw_max + 0.1 * x_range)
        elif coord_type == 'latitude':
            xw_min = max(-90., xw_min - 0.1 * x_range)
            xw_max = min(+90., xw_max + 0.1 * x_range)

        ranges.append((xw_min, xw_max))

    return ranges

########NEW FILE########
__FILENAME__ = formatter_locator
# This file defines the AngleFormatterLocator class which is a class that
# provides both a method for a formatter and one for a locator, for a given
# label spacing. The advantage of keeping the two connected is that we need to
# make sure that the formatter can correctly represent the spacing requested and
# vice versa. For example, a format of dd:mm cannot work with a tick spacing
# that is not a multiple of one arcminute.

import re
import warnings

import numpy as np

from astropy import units as u
from astropy.coordinates import Angle

from . import six


DMS_RE = re.compile('^dd(:mm(:ss(.(s)+)?)?)?$')
HMS_RE = re.compile('^hh(:mm(:ss(.(s)+)?)?)?$')
DDEC_RE = re.compile('^d(.(d)+)?$')
DMIN_RE = re.compile('^m(.(m)+)?$')
DSEC_RE = re.compile('^s(.(s)+)?$')
SCAL_RE = re.compile('^x(.(x)+)?$')


class BaseFormatterLocator(object):
    """
    A joint formatter/locator
    """

    def __init__(self, values=None, number=None, spacing=None, format=None):

        if (values, number, spacing).count(None) < 2:
            raise ValueError("At most one of values/number/spacing can be specifed")

        if values is not None:
            self.values = values
        elif number is not None:
            self.number = number
        elif spacing is not None:
            self.spacing = spacing
        else:
            self.number = 5

        self.format = format

    @property
    def values(self):
        return self._values

    @values.setter
    def values(self, values):
        self._number = None
        self._spacing = None
        self._values = values

    @property
    def number(self):
        return self._number

    @number.setter
    def number(self, number):
        self._number = number
        self._spacing = None
        self._values = None

    @property
    def spacing(self):
        return self._spacing

    @spacing.setter
    def spacing(self, spacing):
        self._number = None
        self._spacing = spacing
        self._values = None


class AngleFormatterLocator(BaseFormatterLocator):
    """
    A joint formatter/locator
    """

    def __init__(self, values=None, number=None, spacing=None, format=None):
        self._unit = u.degree
        super(AngleFormatterLocator, self).__init__(values=values,
                                                    number=number,
                                                    spacing=spacing,
                                                    format=format)

    @property
    def spacing(self):
        return self._spacing

    @spacing.setter
    def spacing(self, spacing):
        if spacing is not None and (not isinstance(spacing, u.Quantity)
                                    or spacing.unit.physical_type != 'angle'):
            raise TypeError("spacing should be an astropy.units.Quantity instance with units of angle")
        self._number = None
        self._spacing = spacing
        self._values = None

    @property
    def format(self):
        return self._format

    @format.setter
    def format(self, value):

        self._format = value

        if value is None:
            return

        if DMS_RE.match(value) is not None:
            self._decimal = False
            self._unit = u.degree
            if '.' in value:
                self._precision = len(value) - value.index('.') - 1
                self._fields = 3
            else:
                self._precision = 0
                self._fields = value.count(':') + 1
        elif HMS_RE.match(value) is not None:
            self._decimal = False
            self._unit = u.hourangle
            if '.' in value:
                self._precision = len(value) - value.index('.') - 1
                self._fields = 3
            else:
                self._precision = 0
                self._fields = value.count(':') + 1
        elif DDEC_RE.match(value) is not None:
            self._decimal = True
            self._unit = u.degree
            self._fields = 1
            if '.' in value:
                self._precision = len(value) - value.index('.') - 1
            else:
                self._precision = 0
        elif DMIN_RE.match(value) is not None:
            self._decimal = True
            self._unit = u.arcmin
            self._fields = 1
            if '.' in value:
                self._precision = len(value) - value.index('.') - 1
            else:
                self._precision = 0
        elif DSEC_RE.match(value) is not None:
            self._decimal = True
            self._unit = u.arcsec
            self._fields = 1
            if '.' in value:
                self._precision = len(value) - value.index('.') - 1
            else:
                self._precision = 0
        else:
            raise ValueError("Invalid format: {0}".format(value))

        if self.spacing is not None and self.spacing < self.base_spacing:
            warnings.warn("Spacing is too small - resetting spacing to match format")
            self.spacing = self.base_spacing

        if self.spacing is not None and (self.spacing % self.base_spacing) > 1e-10 * u.deg:
            warnings.warn("Spacing is not a multiple of base spacing - resetting spacing to match format")
            self.spacing = self.base_spacing * np.round(self.spacing / self.spacing)

    @property
    def base_spacing(self):

        if self._decimal:

            spacing = self._unit / (10. ** self._precision)

        else:

            if self._fields == 1:
                spacing = 1. * u.degree
            elif self._fields == 2:
                spacing = 1. * u.arcmin
            elif self._fields == 3:
                if self._precision == 0:
                    spacing = 1. * u.arcsec
                else:
                    spacing = u.arcsec / (10. ** self._precision)

        if self._unit is u.hourangle:
            spacing *= 15

        return spacing

    def locator(self, value_min, value_max):

        if self.values is not None:

            # values were manually specified
            return np.asarray(self.values), 1.1 * u.arcsec

        else:

            if self.spacing is not None:

                # spacing was manually specified
                spacing_deg = self.spacing.to(u.degree).value

            elif self.number is not None:

                # number of ticks was specified, work out optimal spacing

                # first compute the exact spacing
                dv = abs(float(value_max - value_min)) / self.number * u.degree

                if self.format is not None and dv < self.base_spacing:
                    # if the spacing is less than the minimum spacing allowed by the format, simply
                    # use the format precision instead.
                    spacing_deg = self.base_spacing.to(u.degree).value
                else:
                    # otherwise we clip to the nearest 'sensible' spacing
                    if self._unit is u.degree:
                        from .utils import select_step_degree
                        spacing_deg = select_step_degree(dv).to(u.degree).value
                    else:
                        from .utils import select_step_hour
                        spacing_deg = select_step_hour(dv).to(u.degree).value


            # We now find the interval values as multiples of the spacing and
            # generate the tick positions from this.
            imin = np.ceil(value_min / spacing_deg)
            imax = np.floor(value_max / spacing_deg)
            values = np.arange(imin, imax + 1, dtype=int) * spacing_deg
            return values, spacing_deg * u.degree

    def formatter(self, values, spacing):

        if len(values) > 0:
            if self.format is None:
                spacing = spacing.to(u.arcsec).value
                if spacing > 3600:
                    fields = 1
                    precision = 0
                elif spacing > 60:
                    fields = 2
                    precision = 0
                elif spacing > 1:
                    fields = 3
                    precision = 0
                else:
                    fields = 3
                    precision = -int(np.floor(np.log10(spacing)))
                decimal = False
                unit = u.degree
            else:
                fields = self._fields
                precision = self._precision
                decimal = self._decimal
                unit = self._unit

            if decimal:
                sep = None
            else:
                if unit == u.degree:
                    sep=(six.u('\xb0'), "'", '"')[:fields]
                else:
                    sep=('h', 'm', 's')[:fields]

            angles = Angle(np.asarray(values), unit=u.deg)
            string = angles.to_string(unit=unit,
                                      precision=precision,
                                      decimal=decimal,
                                      fields=fields,
                                      sep=sep).tolist()
            return string
        else:
            return []


class ScalarFormatterLocator(BaseFormatterLocator):
    """
    A joint formatter/locator
    """

    def __init__(self, values=None, number=None, spacing=None, format=None):
        super(ScalarFormatterLocator, self).__init__(values=values,
                                                     number=number,
                                                     spacing=spacing,
                                                     format=format)

    @property
    def format(self):
        return self._format

    @format.setter
    def format(self, value):

        self._format = value

        if value is None:
            return

        if SCAL_RE.match(value) is not None:
            if '.' in value:
                self._precision = len(value) - value.index('.') - 1
            else:
                self._precision = 0
        else:
            raise ValueError("Invalid format: {0}".format(value))

        if self.spacing is not None and self.spacing < self.base_spacing:
            warnings.warn("Spacing is too small - resetting spacing to match format")
            self.spacing = self.base_spacing

        if self.spacing is not None and (self.spacing % self.base_spacing) > 1e-10:
            warnings.warn("Spacing is not a multiple of base spacing - resetting spacing to match format")
            self.spacing = self.base_spacing * np.round(self.spacing / self.spacing)

    @property
    def base_spacing(self):
        return 1. / (10. ** self._precision)

    def locator(self, value_min, value_max):

        if self.values is not None:

            # values were manually specified
            return np.asarray(self.values), 1.1

        else:

            if self.spacing is not None:

                # spacing was manually specified
                spacing = self.spacing

            elif self.number is not None:

                # number of ticks was specified, work out optimal spacing

                # first compute the exact spacing
                dv = abs(float(value_max - value_min)) / self.number

                if self.format is not None and dv < self.base_spacing:
                    # if the spacing is less than the minimum spacing allowed by the format, simply
                    # use the format precision instead.
                    spacing = self.base_spacing
                else:
                    from .utils import select_step_scalar
                    spacing = select_step_scalar(dv)

            # We now find the interval values as multiples of the spacing and generate the tick
            # positions from this
            imin = np.ceil(value_min / spacing)
            imax = np.floor(value_max / spacing)
            values = np.arange(imin, imax + 1, dtype=int) * spacing
            return values, spacing

    def formatter(self, values, spacing):

        if len(values) > 0:

            if self.format is None:
                if spacing < 1.:
                    precision = -int(np.floor(np.log10(spacing)))
                else:
                    precision = 0
            else:
                precision = self._precision

            return [("{0:." + str(precision) + "f}").format(x) for x in values]

        else:
            return []

########NEW FILE########
__FILENAME__ = frame
import numpy as np
from astropy.utils import OrderedDict
from matplotlib.lines import Line2D, Path

# TODO: once we want to start writing more complex frames, use an abstract base
# class.

class Spine(object):

    def __init__(self, parent_axes, transform):

        self.parent_axes = parent_axes
        self.transform = transform

        self.data = None
        self.pixel = None
        self.world = None

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, value):
        if value is None:
            self._data = None
            self._pixel = None
            self._world = None
        else:
            self._data = value
            self._pixel = self.parent_axes.transData.transform(self._data)
            self._world = self.transform.transform(self._data)
            self._update_normal()

    @property
    def pixel(self):
        return self._pixel

    @pixel.setter
    def pixel(self, value):
        if value is None:
            self._data = None
            self._pixel = None
            self._world = None
        else:
            self._data = self.parent_axes.transData.inverted().transform(self._data)
            self._pixel = value
            self._world = self.transform.transform(self._data)
            self._update_normal()

    @property
    def world(self):
        return self._world

    @world.setter
    def world(self, value):
        if value is None:
            self._data = None
            self._pixel = None
            self._world = None
        else:
            self._data = self.transform.transform(value)
            self._pixel = self.parent_axes.transData.transform(self._data)
            self._world = value
            self._update_normal()

    def _update_normal(self):
        # Find angle normal to border and inwards, in display coordinate
        dx = self.pixel[1:,0] - self.pixel[:-1,0]
        dy = self.pixel[1:,1] - self.pixel[:-1,1]
        self.normal_angle = np.degrees(np.arctan2(dx, -dy))


class RectangularFrame(OrderedDict):

    def __init__(self, parent_axes, transform):

        super(RectangularFrame, self).__init__()

        self.parent_axes = parent_axes
        self._transform = transform

        for axis in 'brtl':
            self[axis] = Spine(parent_axes, transform)


    @property
    def origin(self):
        ymin, ymax = self.parent_axes.get_ylim()
        return 'lower' if ymin < ymax else 'upper'

    @property
    def transform(self):
        return self._transform

    @transform.setter
    def transform(self, value):
        self._transform = value
        for axis in self:
            self[axis].transform = value

    def update(self):

        xmin, xmax = self.parent_axes.get_xlim()
        ymin, ymax = self.parent_axes.get_ylim()

        self['b'].data = np.array(([xmin, xmax], [ymin, ymin])).transpose()
        self['r'].data = np.array(([xmax, xmax], [ymin, ymax])).transpose()
        self['t'].data = np.array(([xmax, xmin], [ymax, ymax])).transpose()
        self['l'].data = np.array(([xmin, xmin], [ymax, ymin])).transpose()

    def sample(self, n_samples):

        self.update()

        spines = OrderedDict()

        for axis in self:

            data = self[axis].data
            p = np.linspace(0., 1., data.shape[0])
            p_new = np.linspace(0., 1., n_samples)
            spines[axis] = Spine(self.parent_axes, self.transform)
            spines[axis].data = np.array([np.interp(p_new, p, data[:,0]),
                                          np.interp(p_new, p, data[:,1])]).transpose()

        return spines

    @property
    def path(self):
        x, y = [], []
        for axis in self:
            x.append(self[axis].pixel[:,0])
            y.append(self[axis].pixel[:,1])
        return Path(np.vstack([np.hstack(x), np.hstack(y)]).transpose())

    def draw(self, renderer):
        for axis in self:
            x, y = self[axis].pixel[:,0], self[axis].pixel[:,1]
            line = Line2D(x, y, color='black', zorder=1000)
            line.draw(renderer)

########NEW FILE########
__FILENAME__ = grid_paths
import numpy as np

from matplotlib.lines import Path

from astropy.coordinates.angle_utilities import angular_separation

# Tolerance for WCS round-tripping
ROUND_TRIP_TOL = 1e-1

# Tolerance for discontinuities relative to the median
DISCONT_FACTOR = 10.


def get_lon_lat_path(ax, transform, lon_lat):
    """
    Draw a curve, taking into account discontinuities.

    Parameters
    ----------
    ax : ~matplotlib.axes.Axes
        The axes in which to plot the grid
    transform : transformation class
        The transformation between the world and pixel coordinates
    lon_lat : `~numpy.ndarray`
        The longitude and latitude values along the curve, given as a (n,2)
        array.
    """

    # Get pixel limits
    # xlim = ax.get_xlim()
    # ylim = ax.get_ylim()

    # Transform line to pixel coordinates
    pixel = transform.inverted().transform(lon_lat)

    # In some spherical projections, some parts of the curve are 'behind' or
    # 'in front of' the plane of the image, so we find those by reversing the
    # transformation and finding points where the result is not consistent.

    lon_lat_check = transform.transform(pixel)

    sep = angular_separation(np.radians(lon_lat[:, 0]),
                             np.radians(lon_lat[:, 1]),
                             np.radians(lon_lat_check[:, 0]),
                             np.radians(lon_lat_check[:, 1]))

    sep[sep > np.pi] -= 2. * np.pi

    mask = np.abs(sep > ROUND_TRIP_TOL)

    # Mask values with invalid pixel positions
    mask = mask | np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])

    # Mask values outside the viewport
    # This has now been disabled because it assumes specifically rectangular
    # axes, and also doesn't work if the coordinate direction is flipped.
    # outside = ((pixel[:, 0] < xlim[0]) | (pixel[:, 0] > xlim[-1]) |
    #            (pixel[:, 1] < ylim[0]) | (pixel[:, 1] > ylim[-1]))
    # mask[1:-1] = mask[1:-1] | (outside[2:] & outside[:-2])

    # We can now start to set up the codes for the Path.
    codes = np.zeros(lon_lat.shape[0], dtype=np.uint8)
    codes[:] = Path.LINETO
    codes[0] = Path.MOVETO
    codes[mask] = Path.MOVETO

    # Also need to move to point *after* a hidden value
    codes[1:][mask[:-1]] = Path.MOVETO

    # We now go through and search for discontinuities in the curve that would
    # be due to the curve going outside the field of view, invalid WCS values,
    # or due to discontinuities in the projection.

    # We start off by pre-computing the step in pixel coordinates from one
    # point to the next. The idea is to look for large jumps that might indicate
    # discontinuities.
    step = np.sqrt((pixel[1:, 0] - pixel[:-1, 0]) ** 2 +
                   (pixel[1:, 1] - pixel[:-1, 1]) ** 2)

    # We search for discontinuities by looking for places where the step
    # is larger by more than a given factor compared to the median
    # discontinuous = step > DISCONT_FACTOR * np.median(step)
    discontinuous = step[1:] > DISCONT_FACTOR * step[:-1]

    # Skip over discontinuities
    codes[2:][discontinuous] = Path.MOVETO

    # The above missed the first step, so check that too
    if step[0] > DISCONT_FACTOR * step[1]:
        codes[1] = Path.MOVETO

    # Create the path
    path = Path(pixel, codes=codes)

    # And add to the axes
    return path


def get_gridline_path(ax, transform, world):
    """
    Draw a grid line

    Parameters
    ----------
    ax : ~matplotlib.axes.Axes
        The axes in which to plot the grid
    transform : transformation class
        The transformation between the world and pixel coordinates
    world : `~numpy.ndarray`
        The world coordinates along the curve, given as a (n,2)
        array.
    """

    # Get pixel limits
    # xlim = ax.get_xlim()
    # ylim = ax.get_ylim()

    # Transform line to pixel coordinates
    pixel = transform.inverted().transform(world)

    # Mask values with invalid pixel positions
    mask = np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])

    # Mask values outside the viewport
    # This has now been disabled because it assumes specifically rectangular
    # axes, and also doesn't work if the coordinate direction is flipped.
    # outside = ((pixel[:, 0] < xlim[0]) | (pixel[:, 0] > xlim[-1]) |
    #            (pixel[:, 1] < ylim[0]) | (pixel[:, 1] > ylim[-1]))
    # mask[1:-1] = mask[1:-1] | (outside[2:] & outside[:-2])

    # We can now start to set up the codes for the Path.
    codes = np.zeros(world.shape[0], dtype=np.uint8)
    codes[:] = Path.LINETO
    codes[0] = Path.MOVETO
    codes[mask] = Path.MOVETO

    # Also need to move to point *after* a hidden value
    codes[1:][mask[:-1]] = Path.MOVETO

    # We now go through and search for discontinuities in the curve that would
    # be due to the curve going outside the field of view, invalid WCS values,
    # or due to discontinuities in the projection.

    # Create the path
    path = Path(pixel, codes=codes)

    # And add to the axes
    return path

########NEW FILE########
__FILENAME__ = settings
COORDINATE_RANGE_SAMPLES = 50
FRAME_BOUNDARY_SAMPLES = 1000

########NEW FILE########
__FILENAME__ = six
"""Utilities for writing code that runs on Python 2 and 3"""

# Copyright (c) 2010-2013 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.3.0"


# True if we are running on Python 3.
PY3 = sys.version_info[0] == 3

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):
            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
            del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        result = self._resolve()
        setattr(obj, self.name, result)
        # This is a bit ugly, but it avoids running this again.
        delattr(tp, self.name)
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)



class _MovedItems(types.ModuleType):
    """Lazy loading of moved objects"""


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("reload_module", "__builtin__", "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),

    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("winreg", "_winreg"),
]
for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
del attr

moves = sys.modules[__name__ + ".moves"] = _MovedItems("moves")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_closure = "__closure__"
    _func_code = "__code__"
    _func_defaults = "__defaults__"
    _func_globals = "__globals__"

    _iterkeys = "keys"
    _itervalues = "values"
    _iteritems = "items"
    _iterlists = "lists"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_closure = "func_closure"
    _func_code = "func_code"
    _func_defaults = "func_defaults"
    _func_globals = "func_globals"

    _iterkeys = "iterkeys"
    _itervalues = "itervalues"
    _iteritems = "iteritems"
    _iterlists = "iterlists"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


try:
    callable = callable
except NameError:
    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
    def get_unbound_function(unbound):
        return unbound

    Iterator = object
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_closure = operator.attrgetter(_func_closure)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)
get_function_globals = operator.attrgetter(_func_globals)


def iterkeys(d, **kw):
    """Return an iterator over the keys of a dictionary."""
    return iter(getattr(d, _iterkeys)(**kw))

def itervalues(d, **kw):
    """Return an iterator over the values of a dictionary."""
    return iter(getattr(d, _itervalues)(**kw))

def iteritems(d, **kw):
    """Return an iterator over the (key, value) pairs of a dictionary."""
    return iter(getattr(d, _iteritems)(**kw))

def iterlists(d, **kw):
    """Return an iterator over the (key, [values]) pairs of a dictionary."""
    return iter(getattr(d, _iterlists)(**kw))


if PY3:
    def b(s):
        return s.encode("latin-1")
    def u(s):
        return s
    if sys.version_info[1] <= 1:
        def int2byte(i):
            return bytes((i,))
    else:
        # This is about 2x faster than the implementation above on 3.2+
        int2byte = operator.methodcaller("to_bytes", 1, "big")
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    def b(s):
        return s
    def u(s):
        return unicode(s, "unicode_escape")
    int2byte = chr
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


if PY3:
    import builtins
    exec_ = getattr(builtins, "exec")


    def reraise(tp, value, tb=None):
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
        raise value


    print_ = getattr(builtins, "print")
    del builtins

else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")


    exec_("""def reraise(tp, value, tb=None):
    raise tp, value, tb
""")


    def print_(*args, **kwargs):
        """The new-style print function."""
        fp = kwargs.pop("file", sys.stdout)
        if fp is None:
            return
        def write(data):
            if not isinstance(data, basestring):
                data = str(data)
            fp.write(data)
        want_unicode = False
        sep = kwargs.pop("sep", None)
        if sep is not None:
            if isinstance(sep, unicode):
                want_unicode = True
            elif not isinstance(sep, str):
                raise TypeError("sep must be None or a string")
        end = kwargs.pop("end", None)
        if end is not None:
            if isinstance(end, unicode):
                want_unicode = True
            elif not isinstance(end, str):
                raise TypeError("end must be None or a string")
        if kwargs:
            raise TypeError("invalid keyword arguments to print()")
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode):
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n")
            space = unicode(" ")
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args):
            if i:
                write(sep)
            write(arg)
        write(end)

_add_doc(reraise, """Reraise an exception.""")


def with_metaclass(meta, base=object):
    """Create a base class with a metaclass."""
    return meta("NewBase", (base,), {})

########NEW FILE########
__FILENAME__ = slice
import numpy as np

from astropy.wcs import WCS


def select_axes(iterable, dimensions):
    return [iterable[i] for i in dimensions]


class WCSParameters(object):

    def __init__(self, wcs, dimensions):

        self.ctype = select_axes(wcs.ctype, dimensions)
        self.crval = select_axes(wcs.crval, dimensions)
        self.crpix = select_axes(wcs.crpix, dimensions)
        self.cdelt = select_axes(wcs.cdelt, dimensions)
        self.cunit = select_axes(wcs.cunit, dimensions)

        self.naxis = wcs.naxis


class WCSSlice(object):

    # The purpose of this class is to wrap n-dimensional WCS objects into a
    # 2-dimensional WCS object.

    def __init__(self, *args, **kwargs):

        if 'slices' in kwargs:
            self._slices = kwargs.pop('slices')

        if 'dimensions' in kwargs:
            self._dimensions = kwargs.pop('dimensions')

        self._wcs_orig = WCS(*args, **kwargs)

        # Now find the values of the coordinates in the slices - only needed if
        # data has more than two dimensions
        if len(self._slices) > 0:

            self.nx = args[0]['NAXIS%i' % (self._dimensions[0] + 1)]
            self.ny = args[0]['NAXIS%i' % (self._dimensions[1] + 1)]
            xpix = np.arange(self.nx) + 1.
            ypix = np.arange(self.ny) + 1.
            xpix, ypix = np.meshgrid(xpix, ypix)
            xpix, ypix = xpix.reshape(self.nx * self.ny), ypix.reshape(self.nx * self.ny)
            s = 0
            coords = []
            for dim in range(self._wcs_orig.naxis):
                if dim == self._dimensions[0]:
                    coords.append(xpix)
                elif dim == self._dimensions[1]:
                    coords.append(ypix)
                else:
                    coords.append(np.repeat(self._slices[s], xpix.shape))
                    s += 1
            coords = np.vstack(coords).transpose()
            result = self._wcs_orig.wcs_pix2world(coords, 1)
            self._mean_world = np.mean(result, axis=0)

        # Now set up fake .wcs attribute

        self.wcs = WCSParameters(self._wcs_orig.wcs, self._dimensions)

    def wcs_world2pix(self, x, y, origin):
        if self._wcs_orig.naxis == 2:
            if self._dimensions[1] < self._dimensions[0]:
                xp, yp = self._wcs_orig.wcs_world2pix(y, x, origin)
                return yp, xp
            else:
                return self._wcs_orig.wcs_world2pix(x, y, origin)
        else:
            coords = []
            s = 0
            for dim in range(self._wcs_orig.naxis):
                if dim == self._dimensions[0]:
                    coords.append(x)
                elif dim == self._dimensions[1]:
                    coords.append(y)
                else:
                    # The following is an approximation, and will break down if
                    # the world coordinate changes significantly over the slice
                    coords.append(np.repeat(self._mean_world[dim], x.shape))
                    s += 1
            coords = np.vstack(coords).transpose()

            # Due to a bug in pywcs, we need to loop over each coordinate
            # result = AstropyWCS.wcs_world2pix(self, coords, origin)
            result = np.zeros(coords.shape)
            for i in range(result.shape[0]):
                result[i:i + 1, :] = self._wcs_orig.wcs_world2pix(coords[i:i + 1, :], origin)

            return result[:, self._dimensions[0]], result[:, self._dimensions[1]]

    def wcs_pix2world(self, x, y, origin):
        if self._wcs_orig.naxis == 2:
            if self._dimensions[1] < self._dimensions[0]:
                xw, yw = self._wcs_orig.wcs_pix2world(y, x, origin)
                return yw, xw
            else:
                return self._wcs_orig.wcs_pix2world(x, y, origin)
        else:
            coords = []
            s = 0
            for dim in range(self._wcs_orig.naxis):
                if dim == self._dimensions[0]:
                    coords.append(x)
                elif dim == self._dimensions[1]:
                    coords.append(y)
                else:
                    coords.append(np.repeat(self._slices[s] + 0.5, x.shape))
                    s += 1
            coords = np.vstack(coords).transpose()
            result = self._wcs_orig.wcs_pix2world(coords, origin)
            return result[:, self._dimensions[0]], result[:, self._dimensions[1]]

########NEW FILE########
__FILENAME__ = ticklabels
import numpy as np

from matplotlib.text import Text


def sort_using(X, Y):
    return [x for (y,x) in sorted(zip(Y,X))]


class TickLabels(Text):

    def __init__(self, *args, **kwargs):
        self.clear()
        super(TickLabels, self).__init__(*args, **kwargs)
        self.set_clip_on(True)
        self.set_visible_axes('all')

    def clear(self):
        self.world = {}
        self.pixel = {}
        self.angle = {}
        self.text = {}
        self.disp = {}

    def add(self, axis, world, pixel, angle, text, axis_displacement):
        if axis not in self.world:
            self.world[axis] = [world]
            self.pixel[axis] = [pixel]
            self.angle[axis] = [angle]
            self.text[axis] = [text]
            self.disp[axis] = [axis_displacement]
        else:
            self.world[axis].append(world)
            self.pixel[axis].append(pixel)
            self.angle[axis].append(angle)
            self.text[axis].append(text)
            self.disp[axis].append(axis_displacement)

    def sort(self):
        """
        Sort by axis displacement, which allows us to figure out which parts
        of labels to not repeat.
        """
        for axis in self.world:
            self.world[axis] = sort_using(self.world[axis], self.disp[axis])
            self.pixel[axis] = sort_using(self.pixel[axis], self.disp[axis])
            self.angle[axis] = sort_using(self.angle[axis], self.disp[axis])
            self.text[axis] = sort_using(self.text[axis], self.disp[axis])
            self.disp[axis] = sort_using(self.disp[axis], self.disp[axis])

    def simplify_labels(self):
        """
        Figure out which parts of labels can be dropped to avoid repetition.
        """
        self.sort()
        for axis in self.world:
            t1 = self.text[axis][0]
            for i in range(1, len(self.world[axis])):
                t2 = self.text[axis][i]
                if len(t1) != len(t2):
                    t1 = self.text[axis][i]
                    continue
                start = 0
                for j in range(len(t1)):
                    if t1[j] != t2[j]:
                        break
                    if t1[j] not in '-0123456789.':
                        start = j + 1
                if start == 0:
                    t1 = self.text[axis][i]
                else:
                    self.text[axis][i] = self.text[axis][i][start:]

    def set_visible_axes(self, visible_axes):
        self._visible_axes = visible_axes

    def get_visible_axes(self):
        if self._visible_axes == 'all':
            return self.world.keys()
        else:
            return [x for x in self._visible_axes if x in self.world]

    def draw(self, renderer, bboxes):

        self.simplify_labels()

        text_size = renderer.points_to_pixels(self.get_size())

        for axis in self.get_visible_axes():

            for i in range(len(self.world[axis])):

                self.set_text(self.text[axis][i])

                # TODO: do something smarter for arbitrary directions
                if np.abs(self.angle[axis][i]) < 45.:
                    ha = 'right'
                    va = 'bottom'
                    dx = - text_size * 0.5
                    dy = - text_size * 0.5
                elif np.abs(self.angle[axis][i] - 90.) < 45:
                    ha = 'center'
                    va = 'bottom'
                    dx = 0
                    dy = - text_size * 1.5
                elif np.abs(self.angle[axis][i] - 180.) < 45:
                    ha = 'left'
                    va = 'bottom'
                    dx = text_size * 0.5
                    dy = - text_size * 0.5
                else:
                    ha = 'center'
                    va = 'bottom'
                    dx = 0
                    dy = text_size * 0.2

                x, y = self.pixel[axis][i]

                self.set_position((x + dx, y + dy))
                self.set_ha(ha)
                self.set_va(va)

                bb = super(TickLabels, self).get_window_extent(renderer)

                # TODO: the problem here is that we might get rid of a label
                # that has a key starting bit such as -0:30 where the -0
                # might be dropped from all other labels.

                if bb.count_overlaps(bboxes) == 0:
                    super(TickLabels, self).draw(renderer)
                    bboxes.append(bb)

########NEW FILE########
__FILENAME__ = ticks
import numpy as np

from matplotlib.lines import Path, Line2D
from matplotlib.transforms import Affine2D


class Ticks(Line2D):
    """
    Ticks are derived from Line2D, and note that ticks themselves
    are markers. Thus, you should use set_mec, set_mew, etc.

    To change the tick size (length), you need to use
    set_ticksize. To change the direction of the ticks (ticks are
    in opposite direction of ticklabels by default), use
    set_tick_out(False).
    """

    def __init__(self, ticksize=5., tick_out=False, **kwargs):
        self.set_ticksize(ticksize)
        self.set_tick_out(tick_out)
        self.clear()
        Line2D.__init__(self, [0.], [0.], **kwargs)
        self.set_color('black')
        self.set_visible_axes('all')

    def set_tick_out(self, tick_out):
        """
        set True if tick need to be rotated by 180 degree.
        """
        self._tick_out = tick_out

    def get_tick_out(self):
        """
        Return True if the tick will be rotated by 180 degree.
        """
        return self._tick_out

    def set_ticksize(self, ticksize):
        """
        set length of the ticks in points.
        """
        self._ticksize = ticksize

    def get_ticksize(self):
        """
        Return length of the ticks in points.
        """
        return self._ticksize

    def set_visible_axes(self, visible_axes):
        self._visible_axes = visible_axes

    def get_visible_axes(self):
        if self._visible_axes == 'all':
            return self.world.keys()
        else:
            return [x for x in self._visible_axes if x in self.world]

    def clear(self):
        self.world = {}
        self.pixel = {}
        self.angle = {}
        self.disp = {}

    def add(self, axis, world, pixel, angle, axis_displacement):
        if axis not in self.world:
            self.world[axis] = [world]
            self.pixel[axis] = [pixel]
            self.angle[axis] = [angle]
            self.disp[axis] = [axis_displacement]
        else:
            self.world[axis].append(world)
            self.pixel[axis].append(pixel)
            self.angle[axis].append(angle)
            self.disp[axis].append(axis_displacement)

    def __len__(self):
        return len(self.world)

    _tickvert_path = Path([[0., 0.], [1., 0.]])

    def draw(self, renderer):
        """
        Draw the ticks.
        """

        if not self.get_visible():
            return

        path_trans = self.get_transform()

        gc = renderer.new_gc()
        gc.set_foreground(self.get_color())
        gc.set_alpha(self.get_alpha())

        offset = renderer.points_to_pixels(self.get_ticksize())
        marker_scale = Affine2D().scale(offset, offset)
        marker_rotation = Affine2D()
        marker_transform = marker_scale + marker_rotation

        initial_angle = 180. if self.get_tick_out() else 0.

        for axis in self.get_visible_axes():

            for loc, angle in zip(self.pixel[axis], self.angle[axis]):

                # Set the rotation for this tick
                marker_rotation.rotate_deg(initial_angle + angle)

                # Draw the markers
                locs = path_trans.transform_non_affine(np.array([loc, loc]))
                renderer.draw_markers(gc, self._tickvert_path, marker_transform,
                                      Path(locs), path_trans.get_affine())

                # Reset the tick rotation before moving to the next tick
                marker_rotation.clear()

        gc.restore()

########NEW FILE########
__FILENAME__ = transforms
# Note: This file incldues code dervived from pywcsgrid2
#
# This file contains Matplotlib transformation objects (e.g. from pixel to world
# coordinates, but also world-to-world).

import abc

import numpy as np
from matplotlib.path import Path
from matplotlib.transforms import Transform
from astropy import units as u


class CurvedTransform(Transform):
    """
    Abstract base class for non-affine curved transforms
    """

    __metaclass__ = abc.ABCMeta

    input_dims = 2
    output_dims = 2
    is_separable = False

    def transform_path(self, path):
        """
        Transform a Matplotlib Path

        Parameters
        ----------
        path : :class:`~matplotlib.path.Path`
            The path to transform

        Returns
        -------
        path : :class:`~matplotlib.path.Path`
            The resulting path
        """
        return Path(self.transform(path.vertices), path.codes)

    transform_path_non_affine = transform_path

    @abc.abstractmethod
    def transform(self, input):
        raise NotImplemented("")

    @abc.abstractmethod
    def inverted(self):
        raise NotImplemented("")


class WCSWorld2PixelTransform(CurvedTransform):

    """
    WCS transformation from world to pixel coordinates
    """

    def __init__(self, wcs, slice=None):
        super(WCSWorld2PixelTransform, self).__init__()
        self.wcs = wcs
        if self.wcs.wcs.naxis > 2:
            if slice is None:
                raise ValueError("WCS has more than 2 dimensions, so ``slice`` should be set")
            elif len(slice) != self.wcs.wcs.naxis:
                raise ValueError("slice should have as many elements as WCS "
                                 "has dimensions (should be {0})".format(self.wcs.wcs.naxis))
            else:
                self.slice = slice
                self.x_index = slice.index('x')
                self.y_index = slice.index('y')
        else:
            self.slice = None

    def transform(self, world):
        """
        Transform world to pixel coordinates. You should pass in a NxM array
        where N is the number of points to transform, and M is the number of
        dimensions in the WCS. This then returns the (x, y) pixel coordinates
        as a Nx2 array.
        """

        if world.shape[1] != self.wcs.wcs.naxis:
            raise ValueError("Second dimension of input values should match number of WCS coordinates")

        pixel = self.wcs.wcs_world2pix(world, 1) - 1

        if self.slice is None:
            return pixel
        else:
            return pixel[:,(self.x_index, self.y_index)]


    transform_non_affine = transform

    def inverted(self):
        """
        Return the inverse of the transform
        """
        return WCSPixel2WorldTransform(self.wcs, slice=self.slice)


class WCSPixel2WorldTransform(CurvedTransform):

    """
    WCS transformation from pixel to world coordinates
    """

    def __init__(self, wcs, slice=None):
        super(WCSPixel2WorldTransform, self).__init__()
        self.wcs = wcs
        self.slice = slice
        if self.slice is not None:
            self.x_index = slice.index('x')
            self.y_index = slice.index('y')

    def get_coord_slices(self, xmin, xmax, ymin, ymax, nx, ny):
        """
        Get a coordinate slice
        """
        x = np.linspace(xmin, xmax, nx)
        y = np.linspace(ymin, ymax, ny)
        Y, X = np.meshgrid(y, x)
        pixel = np.array([X.ravel(), Y.ravel()]).transpose()
        world = self.transform(pixel)
        return X, Y, [world[:,i].reshape(nx, ny).transpose() for i in range(self.wcs.wcs.naxis)]

    def transform(self, pixel):
        """
        Transform pixel to world coordinates. You should pass in a Nx2 array
        of (x, y) pixel coordinates to transform to world coordinates. This
        will then return an NxM array where M is the number of dimensions in
        the WCS
        """

        if self.slice is None:
            pixel_full = pixel.copy()
        else:
            pixel_full = []
            for index in self.slice:
                if index == 'x':
                    pixel_full.append(pixel[:, 0])
                elif index == 'y':
                    pixel_full.append(pixel[:, 1])
                else:
                    pixel_full.append(index)
            pixel_full = np.array(np.broadcast_arrays(*pixel_full)).transpose()

        pixel_full += 1

        world = self.wcs.wcs_pix2world(pixel_full, 1)

        # At the moment, one has to manually check that the transformation
        # round-trips, otherwise it should be considered invalid.
        pixel_check = self.wcs.wcs_world2pix(world, 1)
        invalid = np.any(np.abs(pixel_check - pixel_full) > 1., axis=1)
        world[invalid] = np.nan

        return world

    transform_non_affine = transform

    def inverted(self):
        """
        Return the inverse of the transform
        """
        return WCSWorld2PixelTransform(self.wcs, slice=self.slice)


class CoordinateTransform(CurvedTransform):

    def __init__(self, input_system, output_system):
        super(CoordinateTransform, self).__init__()
        self.input_system = input_system
        self.output_system = output_system

    def transform(self, input_coords):
        """
        Transform one set of coordinates to another
        """

        x_in, y_in = input_coords[:, 0], input_coords[:, 1]

        c_in = self.input_system(x_in, y_in, unit=(u.deg, u.deg))

        c_out = c_in.transform_to(self.output_system)

        return np.concatenate((c_out.lonangle.deg[:, np.newaxis], c_out.latangle.deg[:, np.newaxis]), 1)

    transform_non_affine = transform

    def inverted(self):
        """
        Return the inverse of the transform
        """
        return CoordinateTransform(self.output_system, self.input_system)

########NEW FILE########
__FILENAME__ = utils
import numpy as np
from astropy import units as u

# Modified from axis_artist, supports astropy.units


def select_step_degree(dv):

    # Modified from axis_artist, supports astropy.units

    if dv > 1. * u.arcsec:

        degree_limits_ = [1.5, 3, 7, 13, 20, 40, 70, 120, 270, 520]
        degree_steps_ = [1, 2, 5, 10, 15, 30, 45, 90, 180, 360]
        degree_units = [u.degree] * len(degree_steps_)

        minsec_limits_ = [1.5, 2.5, 3.5, 8, 11, 18, 25, 45]
        minsec_steps_ = [1, 2, 3, 5, 10, 15, 20, 30]

        minute_limits_ = np.array(minsec_limits_) / 60.
        minute_units = [u.arcmin] * len(minute_limits_)

        second_limits_ = np.array(minsec_limits_) / 3600.
        second_units = [u.arcsec] * len(second_limits_)

        degree_limits = np.concatenate([second_limits_,
                                        minute_limits_,
                                        degree_limits_])

        degree_steps = minsec_steps_ + minsec_steps_ + degree_steps_
        degree_units = second_units + minute_units + degree_units

        n = degree_limits.searchsorted(dv.to(u.degree))
        step = degree_steps[n]
        unit = degree_units[n]

        return step * unit

    else:

        return select_step_scalar(dv.to(u.arcsec).value) * u.arcsec


def select_step_hour(dv):

    if dv > 15. * u.arcsec:

        hour_limits_ = [1.5, 2.5, 3.5, 5, 7, 10, 15, 21, 36]
        hour_steps_ = [1, 2, 3, 4, 6, 8, 12, 18, 24]
        hour_units = [u.hourangle] * len(hour_steps_)

        minsec_limits_ = [1.5, 2.5, 3.5, 4.5, 5.5, 8, 11, 14, 18, 25, 45]
        minsec_steps_ = [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30]

        minute_limits_ = np.array(minsec_limits_) / 60.
        minute_units = [15. * u.arcmin] * len(minute_limits_)

        second_limits_ = np.array(minsec_limits_) / 3600.
        second_units = [15. * u.arcsec] * len(second_limits_)

        hour_limits = np.concatenate([second_limits_,
                                      minute_limits_,
                                      hour_limits_])

        hour_steps = minsec_steps_ + minsec_steps_ + hour_steps_
        hour_units = second_units + minute_units + hour_units

        n = hour_limits.searchsorted(dv.to(u.hourangle))
        step = hour_steps[n]
        unit = hour_units[n]

        return step * unit

    else:

        return select_step_scalar(dv.to(15. * u.arcsec).value) * (15. * u.arcsec)


def select_step_scalar(dv):

    log10_dv = np.log10(dv)

    base = np.floor(log10_dv)
    frac = log10_dv - base

    steps = np.log10([1, 2, 5, 10])

    imin = np.argmin(np.abs(frac - steps))

    return 10. ** (base + steps[imin])


def get_coordinate_system(wcs):
    """
    Given a WCS object for a pair of spherical coordinates, return the
    corresponding astropy coordinate class.
    """

    xcoord = wcs.wcs.ctype[0][0:4]
    ycoord = wcs.wcs.ctype[1][0:4]

    from astropy.coordinates import FK5, Galactic

    if xcoord == 'RA--' and ycoord == 'DEC-':
        coordinate_class = FK5
    elif xcoord == 'GLON' and ycoord == 'GLAT':
        coordinate_class = Galactic
    else:
        raise ValueError("System not supported (yet): {0}/{1}".format(xcoord, ycoord))

    return coordinate_class


def coord_type_from_ctype(ctype):
    """
    Determine whether a particular WCS ctype corresponds to an angle or scalar
    coordinate.
    """
    if ctype[:4] in ['RA--', 'HPLN'] or ctype[1:4] == 'LON':
        return 'longitude'
    elif ctype[:4] in ['DEC-', 'HPLT'] or ctype[1:4] == 'LAT':
        return 'latitude'
    else:
        return 'scalar'

########NEW FILE########
__FILENAME__ = wcsaxes
from matplotlib.axes import Axes, subplot_class_factory
from matplotlib.transforms import Affine2D, Bbox, Transform

from astropy.wcs import WCS

from .transforms import (WCSPixel2WorldTransform, WCSWorld2PixelTransform,
                         CoordinateTransform)
from .coordinates_map import CoordinatesMap
from .utils import get_coordinate_system
from .coordinate_range import find_coordinate_range

__all__ = ['WCSAxes', 'WCSAxesSubplot']

IDENTITY = WCS(naxis=2)
IDENTITY.wcs.ctype = ["X", "Y"]
IDENTITY.wcs.crval = [1., 1.]
IDENTITY.wcs.crpix = [1., 1.]
IDENTITY.wcs.cdelt = [1., 1.]


class WCSAxes(Axes):

    def __init__(self, fig, rect, wcs=IDENTITY, transData=None, slices=None,
                 **kwargs):

        super(WCSAxes, self).__init__(fig, rect, **kwargs)
        self._bboxes = []

        self.reset_wcs(wcs, slices=slices)
        self._hide_parent_artists()

        if not (transData is None):
            # User wants to override the transform for the final
            # data->pixel mapping
            self.transData = transData

    def _hide_parent_artists(self):
        # Turn off spines and current axes
        for s in self.spines.values():
            s.set_visible(False)

        self.xaxis.set_visible(False)
        self.yaxis.set_visible(False)

    def reset_wcs(self, wcs, slices=None):
        """
        Reset the current Axes, to use a new WCS object.
        """

        # Here determine all the coordinate axes that should be shown.
        if wcs is None:
            wcs = IDENTITY

        self.wcs = wcs
        self.coords = CoordinatesMap(self, self.wcs, slice=slices)

        self._all_coords = [self.coords]

        if slices is None:
            slices = ('x', 'y')

        # Common default settings
        for coord_index in range(len(slices)):
            if slices[coord_index] == 'x':
                self.coords[coord_index].set_axislabel_position('b')
                self.coords[coord_index].set_ticklabel_position('b')
            elif slices[coord_index] == 'y':
                self.coords[coord_index].set_axislabel_position('l')
                self.coords[coord_index].set_ticklabel_position('l')
            else:
                self.coords[coord_index].set_axislabel_position('')
                self.coords[coord_index].set_ticklabel_position('')
                self.coords[coord_index].set_ticks_position('')

    def get_coord_range(self, transform):
        xmin, xmax = self.get_xlim()
        ymin, ymax = self.get_ylim()
        return find_coordinate_range(transform,
                                     [xmin, xmax, ymin, ymax],
                                     [coord.coord_type for coord in self.coords])

    def draw(self, renderer, inframe=False):

        super(WCSAxes, self).draw(renderer, inframe)

        # Here need to find out range of all coordinates, and update range for
        # each coordinate axis. For now, just assume it covers the whole sky.

        self._bboxes = []

        for coords in self._all_coords:

            coords.frame.update()
            for coord in coords:
                coord._draw(renderer, bboxes=self._bboxes)

        for coords in self._all_coords:

            for coord in coords:
                coord._draw_axislabels(renderer, bboxes=self._bboxes)

        self.coords.frame.draw(renderer)

    def set_xlabel(self, label):
        self.coords[0].set_axislabel(label)

    def set_ylabel(self, label):
        self.coords[1].set_axislabel(label)

    def get_xlabel(self):
        return self.coords[0].get_axislabel()

    def get_ylabel(self):
        return self.coords[1].get_axislabel()

    def get_coords_overlay(self, frame, equinox=None, obstime=None):

        # Here we can't use get_transform because that deals with
        # pixel-to-pixel transformations when passing a WCS object.
        if isinstance(frame, WCS):
            coords = CoordinatesMap(self, frame)
        else:
            transform = self._get_transform_no_transdata(frame, equinox=equinox, obstime=obstime)
            coords = CoordinatesMap(self, self.wcs, transform=transform)

        self._all_coords.append(coords)

        # Common settings for overlay
        coords[0].set_axislabel_position('t')
        coords[1].set_axislabel_position('r')
        coords[0].set_ticklabel_position('t')
        coords[1].set_ticklabel_position('r')

        return coords

    def get_transform(self, frame, equinox=None, obstime=None):
        """
        Return a transform from the specified frame to display coordinates.

        This does not include the transData transformation

        Parameters
        ----------
        frame : :class:`~astropy.wcs.WCS` or :class:`~matplotlib.transforms.Transform` or str
            The ``frame`` parameter can have several possible types:
                * :class:`~astropy.wcs.WCS` instance: assumed to be a
                  transformation from pixel to world coordinates, where the
                  world coordinates are the same as those in the WCS
                  transformation used for this ``WCSAxes`` instance. This is
                  used for example to show contours, since this involves
                  plotting an array in pixel coordinates that are not the
                  final data coordinate and have to be transformed to the
                  common world coordinate system first.
                * :class:`~matplotlib.transforms.Transform` instance: it is
                  assumed to be a transform to the world coordinates that are
                  part of the WCS used to instantiate this ``WCSAxes``
                  instance.
                * ``'pixel'`` or ``'world'``: return a transformation that
                  allows users to plot in pixel/data coordinates (essentially
                  an identity transform) and ``world`` (the default
                  world-to-pixel transformation used to instantiate the
                  ``WCSAxes`` instance).
                * ``'fk5'`` or ``'galactic'``: return a transformation from
                  the specified frame to the pixel/data coordinates.
        """
        return self._get_transform_no_transdata(frame, equinox=equinox, obstime=obstime).inverted() + self.transData

    def _get_transform_no_transdata(self, frame, equinox=None, obstime=None):
        """
        Return a transform from data to the specified frame
        """

        if self.wcs is None and frame != 'pixel':
            raise ValueError('No WCS specified, so only pixel coordinates are available')

        if isinstance(frame, WCS):

            coord_in = get_coordinate_system(self.wcs)
            coord_out = get_coordinate_system(frame)

            if coord_in == coord_out:

                return (WCSPixel2WorldTransform(self.wcs)
                        + WCSWorld2PixelTransform(frame))

            else:

                return (WCSPixel2WorldTransform(self.wcs)
                        + CoordinateTransform(coord_in, coord_out)
                        + WCSWorld2PixelTransform(frame))

        elif frame == 'pixel':

            return Affine2D()

        elif isinstance(frame, Transform):

            pixel2world = WCSPixel2WorldTransform(self.wcs)

            return pixel2world + frame

        else:

            from astropy.coordinates import FK5, Galactic

            pixel2world = WCSPixel2WorldTransform(self.wcs)

            if frame == 'world':

                return pixel2world

            elif frame == 'fk5':

                coord_class = get_coordinate_system(self.wcs)

                if coord_class is FK5:
                    return pixel2world
                else:
                    return (pixel2world
                            + CoordinateTransform(coord_class, FK5))

            elif frame == 'galactic':

                coord_class = get_coordinate_system(self.wcs)

                if coord_class is Galactic:
                    return pixel2world
                else:
                    return (pixel2world
                            + CoordinateTransform(coord_class, Galactic))

            else:

                raise NotImplemented("frame {0} not implemented".format(frame))

    def get_tightbbox(self, renderer):

        if not self.get_visible():
            return

        bb = [b for b in self._bboxes if b and (b.width != 0 or b.height != 0)]

        if bb:
            _bbox = Bbox.union(bb)
            return _bbox
        else:
            return self.get_window_extent(renderer)

    def grid(self, draw_grid=True, **kwargs):
        """
        Plot gridlines for both coordinates.

        Standard matplotlib appearance options (color, alpha, etc.) can be
        passed as keyword arguments.

        Parameters
        ----------
        draw_grid : bool
            Whether to show the gridlines
        """
        if draw_grid:
            self.coords.grid(draw_grid=draw_grid, **kwargs)


WCSAxesSubplot = subplot_class_factory(WCSAxes)

########NEW FILE########
__FILENAME__ = main
#!/usr/bin/env python
import sys
import optparse
import logging

from glue import __version__


def parse(argv):
    """ Parse argument list, check validity

    :param argv: Arguments passed to program

    *Returns*
    A tuple of options, position arguments
    """
    usage = """usage: %prog [options] [FILE FILE...]

    # start a new session
    %prog

    # start a new session and load a file
    %prog image.fits

    #start a new session with multiple files
    %prog image.fits catalog.csv

    #restore a saved session
    %prog saved_session.glu
    or
    %prog -g saved_session.glu

    #run a script
    %prog -x script.py

    #run the test suite
    %prog -t
    """
    parser = optparse.OptionParser(usage=usage,
                                   version=str(__version__))

    parser.add_option('-x', '--execute', action='store_true', dest='script',
                      help="Execute FILE as a python script", default=False)
    parser.add_option('-g', action='store_true', dest='restore',
                      help="Restore glue session from FILE", default=False)
    parser.add_option('-t', '--test', action='store_true', dest='test',
                      help="Run test suite", default=False)
    parser.add_option('-c', '--config', type='string', dest='config',
                      metavar='CONFIG',
                      help='use CONFIG as configuration file')

    err_msg = verify(parser, argv)
    if err_msg:
        sys.stderr.write('\n%s\n' % err_msg)
        parser.print_help()
        sys.exit(1)

    return parser.parse_args(argv)


def verify(parser, argv):
    """ Check for input errors

    :param parser: OptionParser instance
    :param argv: Argument list
    :type argv: List of strings

    *Returns*
    An error message, or None
    """
    opts, args = parser.parse_args(argv)
    err_msg = None

    if opts.script and opts.restore:
        err_msg = "Cannot specify -g with -x"
    elif opts.script and opts.config:
        err_msg = "Cannot specify -c with -x"
    elif opts.script and len(args) != 1:
        err_msg = "Must provide a script\n"
    elif opts.restore and len(args) != 1:
        err_msg = "Must provide a .glu file\n"

    return err_msg


def die_on_error(msg):
    """Decorator that catches errors, displays a popup message, and quits"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                import traceback
                from . import qt
                from .external.qt.QtGui import QMessageBox
                m = "%s\n%s" % (msg, e)
                detail = str(traceback.format_exc())
                if len(m) > 500:
                    detail = "Full message:\n\n%s\n\n%s" % (m, detail)
                    m = m[:500] + '...'

                qmb = QMessageBox(QMessageBox.Critical, "Error", m)
                qmb.setDetailedText(detail)
                qmb.show()
                qmb.raise_()
                qmb.exec_()
                sys.exit(1)
        return wrapper
    return decorator


@die_on_error("Error restoring Glue session")
def restore_session(gluefile):
    """Load a .glu file and return a DataCollection, Hub tuple"""
    from glue.qt.glue_application import GlueApplication
    return GlueApplication.restore(gluefile)


@die_on_error("Error reading data file")
def load_data_files(datafiles):
    """Load data files and return a DataCollection"""
    import glue
    from glue.core.data_factories import auto_data, load_data

    dc = glue.core.DataCollection()
    for df in datafiles:
        dc.append(load_data(df, auto_data))
    return dc


def run_tests():
    from glue import test
    test.main()


def start_glue(gluefile=None, config=None, datafiles=None):
    """Run a glue session and exit

    :param gluefile: An optional .glu file to restore
    :type gluefile: str

    :param config: An optional configuration file to use
    :type config: str

    :param datafiles: An optional list of data files to load
    :type datafiles: list of str
    """
    import glue
    from glue.qt.glue_application import GlueApplication

    datafiles = datafiles or []

    data, hub = None, None

    if gluefile is not None:
        app = restore_session(gluefile)
        return app.start()

    if config is not None:
        glue.env = glue.config.load_configuration(search_path=[config])

    if datafiles:
        data = load_data_files(datafiles)

    if not data:
        data = glue.core.DataCollection()

    hub = data.hub

    session = glue.core.Session(data_collection=data, hub=hub)
    ga = GlueApplication(session=session)
    #ga.show()
    #splash.close()
    #ga.raise_()
    #QApplication.instance().processEvents()
    return ga.start()


@die_on_error("Error running script")
def execute_script(script):
    """ Run a python script and exit.

    Provides a way for people with pre-installed binaries to use
    the glue library
    """
    execfile(script)
    sys.exit(0)


def get_splash():
    """Instantiate a splash screen"""
    from .external.qt.QtGui import QSplashScreen, QPixmap
    from .external.qt.QtCore import Qt
    import os

    pth = os.path.join(os.path.dirname(__file__), 'logo.png')
    pm = QPixmap(pth)
    splash = QSplashScreen(pm, Qt.WindowStaysOnTopHint)
    splash.show()

    return splash


def main(argv=sys.argv):
    logging.getLogger(__name__).info("Input arguments: %s", sys.argv)

    opt, args = parse(argv[1:])
    if opt.test:
        return run_tests()
    elif opt.restore:
        start_glue(gluefile=args[0], config=opt.config)
    elif opt.script:
        execute_script(args[0])
    else:
        has_file = len(args) == 1
        has_files = len(args) > 1
        has_py = has_file and args[0].endswith('.py')
        has_glu = has_file and args[0].endswith('.glu')
        if has_py:
            execute_script(args[0])
        elif has_glu:
            start_glue(gluefile=args[0], config=opt.config)
        elif has_file or has_files:
            start_glue(datafiles=args, config=opt.config)
        else:
            start_glue(config=opt.config)


if __name__ == "__main__":
    sys.exit(main(sys.argv))  # prama: no cover

########NEW FILE########
__FILENAME__ = export_d3po
import json
import os

from astropy.table import Table, Column

from ..config import exporters
from ..qt.widgets import ScatterWidget, HistogramWidget
from ..core import Subset


def save_page(page, page_number, label, subset):
    """ Convert a tab of a glue session into a D3PO page

    :param page: Tuple of data viewers to save
    :param label: Tab label
    """
    result = {}

    # layout settings
    result['grid'] = {'nRows': 1, 'nColumns': len(page)}
    result['name'] = str(label)
    result['caption'] = 'Generated by Glue'

    # style settings
    d = page[0]._data[0]
    unselected = dict(opacity=d.style.alpha,
                      size=d.style.markersize / 2,
                      color=d.style.color)
    result['markerStyle'] = dict(unselected=unselected)

    if subset is not None:
        s = subset.style
        selected = dict(opacity=s.alpha, size=s.markersize / 2, color=s.color)
        result['markerStyle']['selected'] = selected
        result['selection'] = {'type': 'booleanColumn',
                               'columnName': 'selection_%i' % page_number}
    result['histogramStyle'] = result['markerStyle']

    # save each plot
    result['plots'] = map(save_plot, page, range(len(page)))

    return result


def save_plot_base(plot, index):
    result = {}
    result['gridPosition'] = [0, index]
    return result


def save_plot(plot, index):
    dispatch = {ScatterWidget: save_scatter,
                HistogramWidget: save_histogram}
    typ = type(plot)
    return dispatch[typ](plot, index)


def save_scatter(plot, index):
    """ Convert a single glue scatter plot to a D3PO plot

    :param plot: Glue scatter plot
    :class:`~glue.qt.widgets.scatter_widget.ScatterWidget`
    :param index: 1D index of plot on the page
    :type index: int

    :rtype: json-serializable dict
    """
    result = save_plot_base(plot, index)
    props = plot.properties
    result['type'] = 'scatter'
    result['xAxis'] = dict(columnName=props['xatt'].label,
                           range=[props['xmin'], props['xmax']])
    result['yAxis'] = dict(columnName=props['yatt'].label,
                           range=[props['ymin'], props['ymax']])
    # XXX log scales
    return result


def save_histogram(plot, index):
    """ Convert a single histogram to a D3PO plot

    :param plot: Glue histogram
    :type plot: :class:`~glue.qt.widgets.histogram_widget.HistogramWidget`

    :param index: 1D index of plot on the page
    :type index: int

    :rtype: json-serializable dict
    """
    result = save_plot_base(plot, index)
    props = plot.properties
    result['type'] = 'histogram'
    result['xAxis'] = dict(columnName=props['component'].label,
                           bins=props['nbins'],
                           range=[props['xmin'], props['xmax']])
    # XXX normed, cumultive, log
    return result


def stage_subsets(application):
    """
    Return a tuple of the subset to use for each stage/tab,
    or None if the tab has no subset

    If more than one subset is used per stage/tab, returns None
    """
    result = []
    for page in application.viewers:
        subset = None
        for viewer in page:
            for layer_artist in viewer.layers:
                if not layer_artist.visible:
                    continue
                s = layer_artist.layer
                if not isinstance(s, Subset):
                    continue
                if subset is not None and s is not subset:
                    return None
                if subset is None:
                    subset = s
        result.append(subset)
    return tuple(result)


def can_save_d3po(application):
    """
    Check whether an application can be exported to D3PO.

    Raises an exception if not
    """
    dc = application.session.data_collection

    if len(dc) != 1:
        raise ValueError("D3PO Export only supports a single dataset")
    data = dc[0]

    for tab in application.viewers:
        for viewer in tab:
            if not isinstance(viewer, (ScatterWidget, HistogramWidget)):
                raise ValueError("D3PO Export only supports scatter "
                                 "and histogram plots")
    if sum(len(tab) for tab in application.viewers) == 0:
        raise ValueError("D3PO Export requires at least one scatterplot "
                         "or histogram")

    if stage_subsets(application) is None:
        raise ValueError("D3PO Export restricted to 0 or 1 subsets visible "
                         "in each tab")


def make_data_file(data, subsets, path):
    """
    Create the data.csv file, given Data and tuple of subsets
    """
    data_path = os.path.join(path, 'data.csv')

    t = Table([data[c] for c in data.components],
              names=[c.label for c in data.components])

    for i, subset in enumerate(subsets):
        if subset is None:
            continue
        c = Column(data=subset.to_mask().astype('i'), name='selection_%i' % i)
        t.add_column(c)

    t.write(data_path, format='ascii', delimiter=',')


def save_d3po(application, path):
    """Save a Glue session to a D3PO bundle.

    Currently, this has the following restrictions:
    - The Glue session must have only one dataset open, and 0 or 1 subsets
    - Only scatter plots or histograms are present
    - At least one plot is present

    :param application: Glue appication to save
    :param path: Path to directory to save in. Will be created if needed
    """
    if os.path.exists(path) and not os.path.isdir(path):
        os.unlink(path)

    if not os.path.exists(path):
        os.mkdir(path)

    data = application.session.data_collection[0]
    subsets = stage_subsets(application)
    viewers = application.viewers

    # data.csv
    make_data_file(data, subsets, path)

    # states.json
    result = {}
    result['filename'] = 'data.csv'  # XXX don't think this is needed?
    result['title'] = "Glue export of %s" % data.label
    result['states'] = map(save_page, application.viewers,
                           range(len(viewers)),
                           application.tab_names,
                           subsets)

    state_path = os.path.join(path, 'states.json')
    with open(state_path, 'w') as outfile:
        json.dump(result, outfile, indent=2)

    # index.html
    html_path = os.path.join(path, 'index.html')
    with open(html_path, 'w') as outfile:
        outfile.write(HTML)

    # show the result
    launch(path)


def launch(path):
    """Start a server to view an exported D3PO bundle, and open a browser.

    :param path: The TLD of the bundle
    """
    from SocketServer import TCPServer
    from SimpleHTTPServer import SimpleHTTPRequestHandler
    from random import randrange
    from socket import error
    import webbrowser
    from threading import Thread

    os.chdir(path)

    while True:
        try:
            PORT = randrange(8000, 9000)
            server = TCPServer(("", PORT), SimpleHTTPRequestHandler, False)
            server.allow_reuse_address = True
            server.server_bind()
            break
        except error:  # port already taken
            pass

    print 'Serving D3PO on port 0.0.0.0:%i' % PORT
    server.server_activate()

    thread = Thread(target=server.serve_forever)
    thread.setDaemon(True)  # do not prevent shutdown
    thread.start()
    webbrowser.open('http://0.0.0.0:%i' % PORT)


exporters.add('D3PO', save_d3po, can_save_d3po, outmode='directory')


HTML = """
<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8" />

<link rel="stylesheet" type="text/css" href="http://d3po.org/static/css/style.css">
<link rel="stylesheet" type="text/css" href="http://d3po.org/static/css/d3po.css">
<link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:100,200,300,400,700' rel='stylesheet' type='text/css'>

<style>
#footer {
position: fixed;
bottom: 0;
right: 0;
}
</style>
<!-- not to be confused with Planet Telex -->

<!-- Javscript dependencies -->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="http://d3po.org/static/js/util.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://d3po.org/static/js/d3po.js"></script>
<script src="http://d3po.org/static/js/d3po.init.js"></script>
</head>

<body>
<div id="svg"><svg></svg></div>
<div id="controls">
<ul class="navigation">
</ul>
</div>
<div id="caption"></div>

<div id="footer">
More information: <a href="http://d3po.org">d3po.org</a>
</div>

<script type="text/javascript">
$(document).ready(function() {
initialize('states.json', 'data.csv');
}
);
</script>
</body>
</html>
"""

########NEW FILE########
__FILENAME__ = export_plotly
import logging

import numpy as np
try:
    import plotly
except ImportError:
    plotly = None

from ..config import exporters, settings
from ..qt.widgets import ScatterWidget, HistogramWidget


SYM = {'o': 'circle', 's': 'square', '+': 'cross', '^': 'triangle-up',
       '*': 'cross'}


def _sanitize(*arrs):
    mask = np.ones(arrs[0].shape, dtype=np.bool)
    for a in arrs:
        mask &= (~np.isnan(a))
    return tuple(a[mask].ravel() for a in arrs)


def _stack_horizontal(layout):
    layout['xaxis']['domain'] = [0, 0.45]
    layout['xaxis2']['domain'] = [0.55, 1]
    layout['yaxis2']['anchor'] = 'x2'


def _grid_2x23(layout):
    opts = {
        'xaxis': {'domain': [0, 0.45]},
        'yaxis': {'domain': [0, 0.45]},
        'xaxis2': {"domain": [0.55, 1]},
        'yaxis2': {"domain": [0, 0.45],
                   "anchor": "x2"
                   },
        'xaxis3': {
            "domain": [0, 0.45],
            "anchor": "y3"
        },
        'yaxis3': {
            "domain": [0.55, 1],
        },
        'xaxis4': {
            "domain": [0.55, 1],
            "anchor": "y4",
        },
        'yaxis4': {
            "domain": [0.55, 1],
            "anchor": "x4"
        }
    }
    for k, v in opts.items():
        if k not in layout:
            continue
        layout[k].update(**v)


def _axis(log=False, lo=0, hi=1, title=''):
    if log:
        if lo < 0:
            lo = 1e-3
        if hi < 0:
            hi = 1e-3
        lo = np.log10(lo)
        hi = np.log10(hi)

    return dict(type='log' if log else 'linear',
                rangemode='normal',
                range=[lo, hi], title=title)


def _fix_legend_duplicates(traces, layout):
    """Prevent repeat entries in the legend"""
    seen = set()
    for t in traces:
        key = (t.get('name'), t.get('marker', {}).get('color'))
        if key in seen:
            t['showlegend'] = False
        else:
            seen.add(key)


def _color(style):
    color = int(style.color[1:], base=16)
    r = color / 256 / 256
    g = color / 256 % 256
    b = color % 256
    a = style.alpha
    return 'rgba(%i, %i, %i, %0.1f)' % (r, g, b, a)


def export_scatter(viewer):
    """Export a scatter viewer to a list of
    plotly-formatted data dictionaries"""
    traces = []
    xatt, yatt = viewer.xatt, viewer.yatt
    for layer in viewer.layers:
        if not layer.visible:
            continue
        l = layer.layer
        marker = dict(symbol=SYM.get(l.style.marker, 'circle'),
                      color=_color(l.style),
                      size=l.style.markersize)

        x, y = _sanitize(l[xatt], l[yatt])
        trace = dict(x=x, y=y,
                     type='scatter',
                     mode='markers',
                     marker=marker,
                     name=l.label)

        traces.append(trace)

    xaxis = _axis(log=viewer.xlog, lo=viewer.xmin, hi=viewer.xmax,
                  title=viewer.xatt.label)
    yaxis = _axis(log=viewer.ylog, lo=viewer.ymin, hi=viewer.ymax,
                  title=viewer.yatt.label)

    return traces, xaxis, yaxis


def export_histogram(viewer):
    traces = []
    att = viewer.component
    ymax = 1e-3
    for artist in viewer.layers:
        if not artist.visible:
            continue
        layer = artist.layer
        x, y = _sanitize(artist.x[:-1], artist.y)
        trace = dict(
            name=layer.label,
            type='bar',
            marker=dict(color=_color(layer.style)),
            x=x,
            y=y)
        traces.append(trace)
        ymax = max(ymax, artist.y.max())

    xlabel = att.label
    xmin, xmax = viewer.xmin, viewer.xmax
    if viewer.xlog:
        xlabel = 'Log ' + xlabel
        xmin = np.log10(xmin)
        xmax = np.log10(xmax)
    xaxis = _axis(lo=xmin, hi=xmax, title=xlabel)
    yaxis = _axis(log=viewer.ylog, lo=0 if not viewer.ylog else 1e-3,
                  hi=ymax * 1.05)

    return traces, xaxis, yaxis


def build_plotly_call(app):
    args = []
    layout = {'showlegend': True, 'barmode': 'overlay',
              'title': 'Autogenerated by Glue'}
    dispatch = {ScatterWidget: export_scatter,
                HistogramWidget: export_histogram
                }

    ct = 1
    for tab in app.viewers:
        for viewer in tab:
            if hasattr(viewer, '__plotly__'):
                p, xaxis, yaxis = viewer.__plotly__()
            else:
                assert type(viewer) in dispatch
                p, xaxis, yaxis = dispatch[type(viewer)](viewer)

            xaxis['zeroline'] = False
            yaxis['zeroline'] = False

            suffix = '' if ct == 1 else '%i' % ct
            layout['xaxis' + suffix] = xaxis
            layout['yaxis' + suffix] = yaxis
            if ct > 1:
                yaxis['anchor'] = 'x' + suffix
                for item in p:
                    item['xaxis'] = 'x' + suffix
                    item['yaxis'] = 'y' + suffix
            ct += 1
            args.extend(p)

    nplot = sum(len(tab) for tab in app.viewers)
    if nplot == 2:
        _stack_horizontal(layout)
    if nplot > 2:
        _grid_2x23(layout)

    _fix_legend_duplicates(args, layout)
    return args, dict(layout=layout)


def can_save_plotly(application):
    """
    Check whether an application can be exported to plotly

    Raises an exception if not
    """
    if not plotly:
        raise ValueError("Plotly Export requires the plotly python library. "
                         "Please install first")

    user = application.get_setting('PLOTLY_USER')
    apikey = application.get_setting('PLOTLY_APIKEY')
    if not user or not apikey:
        raise ValueError("Plotly username and API Key required. "
                         "Please enter them in File->Edit Settings")

    for tab in application.viewers:
        for viewer in tab:
            if hasattr(viewer, '__plotly__'):
                continue

            if not isinstance(viewer, (ScatterWidget, HistogramWidget)):
                raise ValueError("Plotly Export cannot handle viewer: %s"
                                 % type(viewer))

    if len(application.viewers) != 1:
        raise ValueError("Plotly Export only supports a single tab. "
                         "Please close other tabs to export")

    nplot = sum(len(t) for t in application.viewers)
    if nplot == 0:
        raise ValueError("Plotly Export requires at least one plot")

    if nplot > 4:
        raise ValueError("Plotly Export supports at most 4 plots")


def save_plotly(application, label):
    """Save a Glue session to a plotly plot

    This is currently restricted to 1-4 scatterplots or histograms

    :param application: Glue application to save
    :param path: Label for the exported plot
    """
    user = application.get_setting('PLOTLY_USER')
    apikey = application.get_setting('PLOTLY_APIKEY')

    args, kwargs = build_plotly_call(application)
    kwargs['filename'] = label

    logging.getLogger(__name__).debug(args, kwargs)

    py = plotly.plotly(user, key=apikey)
    py.plot(args, **kwargs)


exporters.add('Plotly', save_plotly, can_save_plotly, outmode='label')
settings.add('PLOTLY_USER', '')
settings.add('PLOTLY_APIKEY', '')

########NEW FILE########
__FILENAME__ = test_d3po
from tempfile import mkdtemp
import os
from shutil import rmtree

from astropy.table import Table
import numpy as np

from ..export_d3po import make_data_file
from ...core import Data, Subset


def test_make_data_file():
    # astropy.Table interface has changed across versions. Check
    # that we build a valid table
    d = Data(x=[1, 2, 3], y=[2, 3, 4], label='data')
    s = d.new_subset(label='test')
    s.subset_state = d.id['x'] > 1

    dir = mkdtemp()
    try:
        make_data_file(d, (s,), dir)
        t = Table.read(os.path.join(dir, 'data.csv'), format='ascii')
        np.testing.assert_array_equal(t['x'], [1, 2, 3])
        np.testing.assert_array_equal(t['y'], [2, 3, 4])
        np.testing.assert_array_equal(t['selection_0'], [0, 1, 1])
    finally:
        rmtree(dir, ignore_errors=True)

########NEW FILE########
__FILENAME__ = test_plotly
import pytest
import numpy as np

from ...core import Data, DataCollection
from ...qt.glue_application import GlueApplication
from ...qt.widgets import ScatterWidget, ImageWidget, HistogramWidget
from ..export_plotly import build_plotly_call

try:
    import plotly
    PLOTLY_INSTALLED = True
except ImportError:
    PLOTLY_INSTALLED = False


pytest.mark.skipif('not PLOTLY_INSTALLED')


class TestPlotly(object):

    def setup_method(self, method):
        d = Data(x=[1, 2, 3], y=[2, 3, 4], label='data')
        dc = DataCollection([d])
        self.app = GlueApplication(dc)
        self.data = d

    def test_scatter(self):
        app = self.app
        d = self.data
        d.style.markersize = 6
        d.style.color = '#ff0000'
        d.style.alpha = .4
        v = app.new_data_viewer(ScatterWidget, data=d)
        v.xatt = d.id['y']
        v.yatt = d.id['x']

        args, kwargs = build_plotly_call(app)

        expected = dict(type='scatter', mode='markers', name=d.label,
                        marker=dict(size=6, color='rgba(255, 0, 0, 0.4)',
                                    symbol='circle'))
        for k, v in expected.items():
            assert args[0][k] == v

        np.testing.assert_array_equal(args[0]['x'], d['y'])
        np.testing.assert_array_equal(args[0]['y'], d['x'])

        assert 'layout' in kwargs
        layout = kwargs['layout']
        assert layout['showlegend']

    def test_scatter_subset(self):
        app = self.app
        d = self.data
        s = d.new_subset(label='subset')
        s.subset_state = d.id['x'] > 1
        s.style.marker = 's'

        v = app.new_data_viewer(ScatterWidget, data=d)
        v.xatt = d.id['x']
        v.yatt = d.id['x']

        args, kwargs = build_plotly_call(app)

        # check that subset is on Top
        assert len(args) == 2
        assert args[0]['name'] == 'data'
        assert args[1]['name'] == 'subset'

    def test_axes(self):
        app = self.app
        v = app.new_data_viewer(ScatterWidget, data=self.data)
        v.xlog = True
        v.xmin = 10
        v.xmax = 100

        v.ylog = False
        v.ymin = 2
        v.ymax = 4

        args, kwargs = build_plotly_call(app)

        xaxis = dict(type='log', rangemode='normal',
                     range=[1, 2], title='y', zeroline=False)
        yaxis = dict(type='linear', rangemode='normal',
                     range=[2, 4], title='x', zeroline=False)
        layout = kwargs['layout']
        assert layout['xaxis'] == xaxis
        assert layout['yaxis'] == yaxis

    def test_histogram(self):
        app = self.app
        d = self.data
        d.style.color = '#000000'
        v = app.new_data_viewer(HistogramWidget, data=d)
        v.component = d.id['y']
        v.xmin = 0
        v.xmax = 10
        v.bins = 20

        args, kwargs = build_plotly_call(app)

        expected = dict(
            name='data',
            type='bar',
            marker=dict(
                color='rgba(0, 0, 0, 0.5)'
            ),
        )
        for k in expected:
            assert expected[k] == args[0][k]
        assert kwargs['layout']['barmode'] == 'overlay'

    def test_2plot(self):
        app = self.app
        d = self.data
        v = app.new_data_viewer(HistogramWidget, data=d)
        v2 = app.new_data_viewer(ScatterWidget, data=d)

        args, kwargs = build_plotly_call(app)

        assert len(args) == 2
        assert 'xaxis' not in args[0] and 'yaxis' not in args[0]
        assert args[1]['xaxis'] == 'x2'
        assert args[1]['yaxis'] == 'y2'

        layout = kwargs['layout']
        assert layout['xaxis']['domain'] == [0, .45]
        assert layout['xaxis2']['domain'] == [.55, 1]
        assert layout['yaxis2']['anchor'] == 'x2'

    def test_can_multiplot(self):
        # check that no errors are raised with 2-4 plots
        app = self.app
        d = self.data
        for i in range(2, 5):
            app.new_data_viewer(HistogramWidget, data=d)
            args, kwargs = build_plotly_call(app)

    def test_4plot(self):
        app = self.app
        d = self.data
        v = [app.new_data_viewer(HistogramWidget, data=d) for _ in range(4)]

        args, kwargs = build_plotly_call(app)

        assert len(args) == 4
        assert 'xaxis' not in args[0] and 'yaxis' not in args[0]
        assert args[1]['xaxis'] == 'x2'
        assert args[1]['yaxis'] == 'y2'
        assert args[2]['xaxis'] == 'x3'
        assert args[2]['yaxis'] == 'y3'
        assert args[3]['xaxis'] == 'x4'
        assert args[3]['yaxis'] == 'y4'

        layout = kwargs['layout']
        assert layout['xaxis']['domain'] == [0, .45]
        assert layout['yaxis']['domain'] == [0, .45]
        assert layout['xaxis2']['domain'] == [.55, 1]
        assert layout['yaxis2']['domain'] == [0, 0.45]
        assert layout['yaxis2']['anchor'] == 'x2'
        assert layout['xaxis3']['domain'] == [0, 0.45]
        assert layout['xaxis3']['anchor'] == 'y3'
        assert layout['yaxis3']['domain'] == [0.55, 1]
        assert layout['xaxis4']['anchor'] == 'y4'
        assert layout['yaxis4']['domain'] == [0.55, 1]
        assert layout['yaxis4']['anchor'] == 'x4'

########NEW FILE########
__FILENAME__ = qglue
from contextlib import contextmanager
import sys

import numpy as np

from .core import Data, DataCollection, ComponentLink
from .core.link_helpers import MultiLink
from .core.data_factories import load_data, as_list

__all__ = ['qglue']


@contextmanager
def restore_io():
    stdin = sys.stdin
    stdout = sys.stdout
    stderr = sys.stderr
    _in = sys.__stdin__
    _out = sys.__stdout__
    _err = sys.__stderr__
    try:
        yield
    finally:
        sys.stdin = stdin
        sys.stdout = stdout
        sys.stderr = stderr
        sys.__stdin__ = _in
        sys.__stdout__ = _out
        sys.__stderr__ = _err


def _parse_data_dataframe(data, label):
    label = label or 'Data'
    result = Data(label=label)
    for c in data.columns:
        result.add_component(data[c], c)
    return [result]


def _parse_data_dict(data, label):
    result = Data(label=label)

    for label, component in data.items():
        result.add_component(component, label)

    return [result]


def _parse_data_recarray(data, label):
    print data.dtype.names
    return [Data(label=label, **{n: data[n] for n in data.dtype.names})]


def _parse_data_astropy_table(data, label):
    return [Data(label=label, **{c: data[c] for c in data.columns})]


def _parse_data_glue_data(data, label):
    data.label = label
    return [data]


def _parse_data_path(path, label):
    data = load_data(path)
    for d in as_list(data):
        d.label = label
    return as_list(data)


_parsers = {}  # map base classes -> parser functions
_parsers[dict] = _parse_data_dict
_parsers[np.recarray] = _parse_data_recarray
_parsers[Data] = _parse_data_glue_data
_parsers[basestring] = _parse_data_path


def _parse_data(data, label):
    for typ, prsr in _parsers.items():
        if isinstance(data, typ):
            try:
                return prsr(data, label)
            except Exception as e:
                raise ValueError("Invalid format for data '%s'\n\n%s" %
                                 (label, e))

    raise TypeError("Invalid data description: %s" % data)

try:
    import pandas as pd
    _parsers[pd.DataFrame] = _parse_data_dataframe
except ImportError:
    pass

try:
    from astropy.table import Table
    _parsers[Table] = _parse_data_astropy_table
except ImportError:
    pass


def _parse_links(dc, links):
    data = {d.label: d for d in dc}
    result = []

    def find_cid(s):
        dlabel, clabel = s.split('.')
        d = data[dlabel]
        c = d.find_component_id(clabel)
        if c is None:
            raise ValueError("Invalid link (no component named %s)" % s)
        return c

    for link in links:
        f, t = link[0:2]  # from and to component names
        u = u2 = None
        if len(link) >= 3:  # forward translation function
            u = link[2]
        if len(link) == 4:  # reverse translation function
            u2 = link[3]

        # component names -> component IDs
        if isinstance(f, basestring):
            f = [find_cid(f)]
        else:
            f = [find_cid(item) for item in f]

        if isinstance(t, basestring):
            t = find_cid(t)
            result.append(ComponentLink(f, t, u))
        else:
            t = [find_cid(item) for item in t]
            result += MultiLink(f, t, u, u2)

    return result


def qglue(**kwargs):
    """
    Quickly send python variables to Glue for visualization.

    The generic calling sequence is::

      qglue(label1=data1, label2=data2, ..., [links=links])

    The kewyords label1, label2, ... can be named anything besides ``links``

    data1, data2, ... can be in many formats:
      * A numpy rec array
      * A pandas data frame
      * A dictionary of numpy arrays with the same shape
      * An astropy Table

    ``Links`` is an optional list of link descriptions, each of which has
    the format: ([left_ids], [right_ids], forward, backward)

    Each ``left_id``/``right_id`` is a string naming a component in a dataset
    (i.e., ``data1.x``). ``forward`` and ``backward`` are functions which
    map quantities on the left to quantities on the right, and vice
    versa. `backward` is optional

    Examples::

        balls = {'kg': [1, 2, 3], 'radius_cm': [10, 15, 30]}
        cones = {'lbs': [5, 3, 3, 1]}
        def lb2kg(lb):
            return lb / 2.2
        def kg2lb(kg):
            return kg * 2.2

        links = [(['balls.kg'], ['cones.lbs'], lb2kg, kb2lb)]
        qglue(balls=balls, cones=cones, links=links)

    :returns: A :class:`~glue.core.data_collection.DataCollection` object
    """
    from glue.qt.glue_application import GlueApplication

    links = kwargs.pop('links', None)

    dc = DataCollection()
    for label, data in kwargs.items():
        dc.extend(_parse_data(data, label))

    if links is not None:
        dc.add_link(_parse_links(dc, links))

    with restore_io():
        ga = GlueApplication(dc)
        ga.start()
    return dc

########NEW FILE########
__FILENAME__ = actions
from ..external.qt.QtGui import QAction
from .qtutil import get_icon


def act(name, parent, tip='', icon=None, shortcut=None):
    """ Factory for making a new action """
    a = QAction(name, parent)
    a.setToolTip(tip)
    if icon:
        a.setIcon(get_icon(icon))
    if shortcut:
        a.setShortcut(shortcut)
    return a
"""
tab_new = act('New Tab',
              shortcut=QKeySequence.AddTab,
              tip='Add a new tab')

tab_tile = act("Tile",
               tip="Tile windows in the current tab")

tab_cascade = act("Cascade",
                  tip = "Cascade windows in the current tab")

window_new = act('New Window',
                 shortcut=QKeySequence.New,
                 tip='Add a new visualization window to the current tab')

subset_or = act("Union Combine",
                icon='glue_or',
                tip = 'Define a new subset as a union of selection')

subste_and = act("Intersection Combine",
                 icon="glue_and",
                 tip = 'Define a new subset as intersection of selection')

subset_xor = act("XOR Combine",
                 icon='glue_xor',
                 tip= 'Define a new subset as non-intersection of selection')

subset_not = act("Invert",
                 icon="glue_not",
                 tip="Invert current subset")

subset_copy = act("Copy subset",
                  tip="Copy the definition for the selected subset",
                  shortcut=QKeySequence.Copy)

subset_paste = act("Paste subset",
                   tip = "Replace the selected subset with clipboard",
                   shortcut=QKeySequence.Paste)

subset_new = act("New subset",
                 tip="Create a new subset for the selected data",
                 shortcut=QKeySequence.New)

subset_clear = act("Clear subset",
                   tip="Clear current selection")

subset_duplicate = act("Duplicate subset",
                       tip="Duplicate the current subset",
                       shortcut="Ctrl+D")

layer_delete = act("Delete layer",
                   shortcut=QKeySequence.Delete,
                   tip="Remove the highlighted layer")


"""

########NEW FILE########
__FILENAME__ = component_selector
from ..external.qt.QtGui import QWidget, QListWidgetItem
from ..external.qt.QtCore import Signal

from .qtutil import load_ui


class ComponentSelector(QWidget):
    """ An interface to view the components and data of a DataCollection

    Components can be draged and dropped.

    The currently-selected componentID is stored in the
    Component property. The currently-selected Data is stored in the
    Data property.

    Usage:

       >>> widget = ComponentSelector()
       >>> widget.setup(data_collection)
    """
    component_changed = Signal()

    def __init__(self, parent=None):
        super(ComponentSelector, self).__init__(parent)
        self._data = None
        self._ui = load_ui('component_selector', self)
        self._init_widgets()
        self._connect()

    def _init_widgets(self):
        self._ui.component_selector.setDragEnabled(True)
        self._ui.setMinimumWidth(300)

    def _connect(self):
        #attach Qt signals
        ds = self._ui.data_selector
        ds.currentIndexChanged.connect(self._set_components)
        self._ui.component_selector.currentItemChanged.connect(
            lambda *args: self.component_changed.emit())

    def set_current_row(self, row):
        """Select which component is selected

        :param row: Row number
        """
        self._ui.component_selector.setCurrentRow(row)

    def set_data_row(self, row):
        """Select which data object is selected

        :param row: Row number
        """
        self._ui.data_selector.setCurrentIndex(row)

    def setup(self, data_collection):
        """ Set up the widgets.

        :param data_collection: Object to browse
        :type data_colleciton:
           :class:`~glue.core.data_collection.DataCollection`
        """
        self._data = data_collection
        self._set_data()
        self._set_components()

    def _set_components(self):
        """ Set list of component widgets to match current data set """
        index = self._ui.data_selector.currentIndex()
        if index < 0:
            return
        data = self._data[index]
        cids = data.components

        c_list = self._ui.component_selector
        c_list.clear()
        for c in cids:
            item = QListWidgetItem(c.label)
            c_list.addItem(item)
            c_list.set_data(item, c)

    def _set_data(self):
        """ Populate the data list with data sets in the collection """
        d_list = self._ui.data_selector
        for d in self._data:
            d_list.addItem(d.label)

    @property
    def component(self):
        """Returns the currently-selected ComponentID
        :rtype: :class:`~glue.core.data.ComponentID`
        """
        item = self._ui.component_selector.currentItem()
        return self._ui.component_selector.get_data(item)

    @property
    def data(self):
        index = self._ui.data_selector.currentIndex()
        if index < 0:
            return
        return self._data[index]

    @data.setter
    def data(self, value):
        for i, d in enumerate(self._data):
            if d is value:
                self._ui.data_selector.setCurrentIndex(i)
                return
        else:
            raise ValueError("Data is not part of the DataCollection")


def main():  # pragma: no cover
    import glue
    import numpy as np
    from . import get_qapp
    from ..external.qt.QtGui import QApplication

    d = glue.core.Data(label="hi")
    d2 = glue.core.Data(label="there")

    c1 = glue.core.Component(np.array([1, 2, 3]))
    c2 = glue.core.Component(np.array([1, 2, 3]))
    c3 = glue.core.Component(np.array([1, 2, 3]))

    dc = glue.core.DataCollection()
    dc.append(d)
    dc.append(d2)
    d.add_component(c1, "a")
    d.add_component(c2, "b")
    d2.add_component(c3, "c")

    app = get_qapp()
    w = ComponentSelector()
    w.setup(dc)
    w.show()
    app.exec_()

if __name__ == "__main__":  # pragma: no cover
    main()

########NEW FILE########
__FILENAME__ = data_collection_model
# pylint: disable=E1101,F0401
from ..external.qt.QtCore import (QAbstractItemModel, QModelIndex,
                                  QObject, Qt, QTimer, Signal)
from ..external.qt.QtGui import (QFont, QTreeView, QItemSelectionModel,
                                 QAbstractItemView, QStyledItemDelegate)

from .qtutil import layer_icon
from .mime import LAYERS_MIME_TYPE, PyMimeData
from ..core.decorators import memoize
from ..core import message as m
from ..core.hub import HubListener
from .. import core
from .widgets.style_dialog import StyleDialog

DATA_IDX = 0
SUBSET_IDX = 1


def full_edit_factory(item, pos):
    StyleDialog.dropdown_editor(item, pos)


def restricted_edit_factory(item, pos):
    StyleDialog.dropdown_editor(item, pos, edit_label=False)


class Item(object):
    edit_factory = None
    glue_data = None
    flags = Qt.ItemIsEnabled
    tooltip = None

    def font(self):
        return QFont()

    def icon(self):
        return None

    @property
    def label(self):
        return self._label


class DataCollectionItem(Item):

    def __init__(self, dc):
        self.dc = dc
        self.row = 0
        self.column = 0
        self.parent = None
        self._label = ''
        self.children_count = 2

    @memoize
    def child(self, row):
        if row == DATA_IDX:
            return DataListItem(self.dc, self)
        if row == SUBSET_IDX:
            return SubsetListItem(self.dc, self)
        return None


class DataListItem(Item):

    def __init__(self, dc, parent):
        self.dc = dc
        self.parent = parent
        self.row = DATA_IDX
        self.column = 0
        self._label = 'Data'

    @memoize
    def child(self, row):
        if row < len(self.dc):
            return DataItem(self.dc, row, self)

    @property
    def children_count(self):
        return len(self.dc)

    def font(self):
        result = QFont()
        result.setBold(True)
        return result


class DataItem(Item):
    edit_factory = full_edit_factory
    flags = (Qt.ItemIsSelectable | Qt.ItemIsEnabled |
             Qt.ItemIsDragEnabled)

    def __init__(self, dc, row, parent):
        self.dc = dc
        self.row = row
        self.parent = parent
        self.column = 0
        self.children_count = 0

    @property
    def data(self):
        return self.dc[self.row]

    @property
    def glue_data(self):
        return self.data

    @property
    def label(self):
        return self.data.label

    @label.setter
    def label(self, value):
        self.data.label = value

    @property
    def style(self):
        return self.data.style

    def icon(self):
        return layer_icon(self.data)


class SubsetListItem(Item):

    def __init__(self, dc, parent):
        self.dc = dc
        self.parent = parent
        self.row = SUBSET_IDX
        self._label = 'Subsets'
        self.column = 0

    @memoize
    def child(self, row):
        if row < self.dc.subset_groups:
            return SubsetGroupItem(self.dc, row, self)

    @property
    def children_count(self):
        return len(self.dc.subset_groups)

    def font(self):
        result = QFont()
        result.setBold(True)
        return result


class SubsetGroupItem(Item):
    edit_factory = full_edit_factory
    flags = Qt.ItemIsSelectable | Qt.ItemIsEnabled | Qt.ItemIsEditable

    def __init__(self, dc, row, parent):
        self.parent = parent
        self.dc = dc
        self.row = row
        self.column = 0

    @property
    def subset_group(self):
        return self.dc.subset_groups[self.row]

    @property
    def glue_data(self):
        return self.subset_group

    @property
    def label(self):
        return self.subset_group.label

    @label.setter
    def label(self, value):
        self.subset_group.label = value

    @property
    def tooltip(self):
        if type(self.subset_group.subset_state) == core.subset.SubsetState:
            return "Empty subset"

        atts = self.subset_group.subset_state.attributes
        atts = [a for a in atts if isinstance(a, core.ComponentID)]

        if len(atts) > 0:
            lbl = ', '.join(a.label for a in atts)
            return "Selection on %s" % lbl

    @property
    def style(self):
        return self.subset_group.style

    @property
    def children_count(self):
        return len(self.subset_group.subsets)

    @memoize
    def child(self, row):
        return SubsetItem(self.dc, self.subset_group, row, self)

    def icon(self):
        return layer_icon(self.subset_group)


class SubsetItem(Item):
    edit_factory = restricted_edit_factory
    flags = Qt.ItemIsSelectable | Qt.ItemIsEnabled | Qt.ItemIsDragEnabled

    def __init__(self, dc, subset_group, subset_idx, parent):
        self.parent = parent
        self.subset_group = subset_group
        self.row = subset_idx
        self.parent = parent
        self.children_count = 0
        self.column = 0

    @property
    def subset(self):
        return self.subset_group.subsets[self.row]

    @property
    def label(self):
        return self.subset.verbose_label

    def icon(self):
        return layer_icon(self.subset)

    @property
    def style(self):
        return self.subset.style

    @property
    def glue_data(self):
        return self.subset


class DataCollectionModel(QAbstractItemModel, HubListener):
    new_item = Signal(QModelIndex)

    def __init__(self, data_collection, parent=None):
        QAbstractItemModel.__init__(self, parent)
        HubListener.__init__(self)

        self.data_collection = data_collection
        self.root = DataCollectionItem(data_collection)
        self._items = {}   # map hashes of Model pointers to model items
        # without this reference, PySide clobbers instance
        # data of model items
        self.register_to_hub(self.data_collection.hub)
        self.setSupportedDragActions(Qt.CopyAction)

    def index(self, row, column, parent=QModelIndex()):
        if column != 0:
            return QModelIndex()

        if not parent.isValid():
            parent_item = self.root
        else:
            parent_item = self._get_item(parent)
            if parent_item is None:
                return QModelIndex()

        child_item = parent_item.child(row)
        if child_item:
            return self._make_index(row, column, child_item)
        else:
            return QModelIndex()

    def _get_item(self, index):
        if not index.isValid():
            return None
        return self._items.get(id(index.internalPointer()), None)

    def _make_index(self, row, column, item):
        if item is not None:
            result = self.createIndex(row, column, item)
            self._items[id(result.internalPointer())] = item
            assert result.internalPointer() is item
            return result
        return self.createIndex(row, column)

    def to_indices(self, items):
        """Translate a list of Data, Subset, or SubsetGroups
        to a list of indices"""
        result = []
        for item in items:
            if isinstance(item, core.Data):
                idx = self.data_index(list(self.data_collection).index(item))
            elif isinstance(item, core.SubsetGroup):
                idx = self.subsets_index(
                    self.data_collection.subset_groups.index(item))
            elif isinstance(item, core.subset_group.GroupedSubset):
                grp = item.group
                idx = self.subsets_index(
                    self.data_collection.subset_groups.index(grp))
                row = list(self.data_collection).index(item.data)
                idx = self.index(grow, idx)
            else:
                raise NotImplementedError(type(item))
            result.append(idx)
        return result

    def flags(self, index=QModelIndex()):
        if not index.isValid():
            return Qt.NoItemFlags

        return self._get_item(index).flags

    def data(self, index, role):
        if not index.isValid():
            return

        dispatch = {
            Qt.DisplayRole: self._display_data,
            Qt.FontRole: self._font_data,
            Qt.DecorationRole: self._icon_data,
            Qt.UserRole: self._user_data,
            Qt.ToolTipRole: self._tooltip_data}

        if role in dispatch:
            return dispatch[role](index)

    def setData(self, index, value, role=Qt.EditRole):
        if role != Qt.EditRole:
            return False
        try:
            self._get_item(index).label = value
            return True
        except AttributeError:
            return False

    def _tooltip_data(self, index):
        tooltip = self._get_item(index).tooltip
        return tooltip

    def _user_data(self, index):
        return self._get_item(index)

    def _display_data(self, index):
        return self._get_item(index).label

    def _font_data(self, index):
        item = self._get_item(index)
        return item.font()

    def _icon_data(self, index):
        return self._get_item(index).icon()

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        return ''

    def data_index(self, data_number=None):
        """
        Fetch the QModelIndex for a given data index,
        or the index for the parent data item

        :param data_number: position of data set to fetch, or None
        """
        base = self.index(DATA_IDX, 0)
        if data_number is None:
            return base
        return self.index(data_number, 0, base)

    def subsets_index(self, subset_number=None):
        """
        Fetch the QModelIndex for a given subset,
        or the index for the parent subset item

        :param data_number: position of subset group to fetch, or None
        """
        base = self.index(SUBSET_IDX, 0)
        assert isinstance(self._get_item(base), SubsetListItem)
        if subset_number is None:
            return base
        return self.index(subset_number, 0, base)

    def rowCount(self, index=QModelIndex()):
        item = self._get_item(index)

        if item is None:
            return self.root.children_count

        return item.children_count

    def parent(self, index=None):

        if index is None:  # overloaded QObject.parent()
            return QObject.parent(self)

        item = self._get_item(index)
        if item is None:
            return QModelIndex()

        return self._make_index(item.row, item.column, item.parent)

    def columnCount(self, index):
        return 1

    def register_to_hub(self, hub):
        for msg in [m.DataCollectionDeleteMessage,
                    m.SubsetDeleteMessage]:
            hub.subscribe(self, msg, lambda x: self.invalidate())

        hub.subscribe(self, m.DataCollectionAddMessage, self._on_add_data)
        hub.subscribe(self, m.SubsetCreateMessage, self._on_add_subset)

    def _on_add_data(self, message):
        self.invalidate()
        idx = self.data_index(len(self.data_collection) - 1)
        self.new_item.emit(idx)

    def _on_add_subset(self, message):
        self.invalidate()
        idx = self.subsets_index(len(self.data_collection.subset_groups) - 1)
        self.new_item.emit(idx)

    def invalidate(self):
        self.root = DataCollectionItem(self.data_collection)
        self._items.clear()
        self.reset()
        self.layoutChanged.emit()

    def glue_data(self, indices):
        """ Given a list of indices, return a list of all selected
        Data, Subset, and SubsetGroup objects.
        """
        items = [self._get_item(idx) for idx in indices]
        items = [item.glue_data for item in items]
        return items

    def mimeData(self, indices):
        data = self.glue_data(indices)
        result = PyMimeData(data, **{LAYERS_MIME_TYPE: data})
        self._mime = result  # hold reference to prevent segfault
        return result

    def mimeTypes(self):
        return [LAYERS_MIME_TYPE]


class DataCollectionView(QTreeView):
    selection_changed = Signal()

    def __init__(self, parent=None):
        super(DataCollectionView, self).__init__(parent)

        self.doubleClicked.connect(self._edit)

        # this keeps the full-row of the selection bar in-sync
        self.pressed.connect(lambda x: self.viewport().update())

        # only edit label on model.new_item
        self.setItemDelegate(LabeledDelegate())
        self.setEditTriggers(self.NoEditTriggers)

        self._timer = QTimer(self)
        self._timer.timeout.connect(self.viewport().update)
        self._timer.start(1000)

    def selected_layers(self):
        idxs = self.selectedIndexes()
        return self._model.glue_data(idxs)

    def set_selected_layers(self, layers):
        sm = self.selectionModel()
        idxs = self._model.to_indices(layers)
        self.select_indices(*idxs)

    def select_indices(self, *indices):
        sm = self.selectionModel()
        sm.clearSelection()
        for idx in indices:
            sm.select(idx, sm.Select)

    def set_data_collection(self, data_collection):
        self._model = DataCollectionModel(data_collection)
        self.setModel(self._model)

        sm = QItemSelectionModel(self._model)
        sm.selectionChanged.connect(lambda *args:
                                    self.selection_changed.emit())
        self.setSelectionModel(sm)

        self.setRootIsDecorated(False)
        self.setExpandsOnDoubleClick(False)
        self.expandToDepth(0)
        self._model.layoutChanged.connect(lambda: self.expandToDepth(0))
        self._model.layoutChanged.connect(self.selection_changed.emit)
        self._model.new_item.connect(self.select_indices)
        self._model.new_item.connect(self.edit_label)

        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.setDragEnabled(True)
        self.setDropIndicatorShown(True)
        self.setDragDropMode(QAbstractItemView.DragOnly)

    def edit_label(self, index):
        if not (self._model.flags(index) & Qt.ItemIsEditable):
            return
        self.edit(index)

    def _edit(self, index):
        item = self._model.data(index, role=Qt.UserRole)
        if item is None or item.edit_factory is None:
            return

        rect = self.visualRect(index)
        pos = self.mapToGlobal(rect.bottomLeft())
        pos.setY(pos.y() + 1)
        item.edit_factory(pos)


class LabeledDelegate(QStyledItemDelegate):

    """ Add placeholder text to default delegate """

    def setEditorData(self, editor, index):
        super(LabeledDelegate, self).setEditorData(editor, index)
        label = index.model().data(index, role=Qt.DisplayRole)
        editor.selectAll()
        editor.setText(label)


if __name__ == "__main__":
    from glue.qt import get_qapp
    from glue.external.qt.QtGui import QTreeView
    from glue.core import Data, DataCollection

    app = get_qapp()

    dc = DataCollection()
    dc.append(Data(label='w'))

    view = DataCollectionView()
    view.set_data_collection(dc)
    view.show()
    view.raise_()
    dc.extend([Data(label='x', x=[1, 2, 3]),
               Data(label='y', y=[1, 2, 3]),
               Data(label='z', z=[1, 2, 3])])
    app.exec_()

########NEW FILE########
__FILENAME__ = decorators
from functools import wraps
import traceback
from ..external.qt.QtGui import QMessageBox


def set_cursor(shape):
    """Set the Qt cursor for the duration of a function call, and unset

    :param shape: Cursor shape to set.
    """
    def wrapper(func):
        @wraps(func)
        def result(*args, **kwargs):
            from . import get_qapp
            app = get_qapp()
            app.setOverrideCursor(shape)
            try:
                return func(*args, **kwargs)
            finally:
                app.restoreOverrideCursor()
        return result

    return wrapper


def messagebox_on_error(msg):
    """Decorator that catches exceptions and displays an error message"""

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                m = "%s\n%s" % (msg, e.message)
                detail = str(traceback.format_exc())
                qmb = QMessageBox(QMessageBox.Critical, "Error", m)
                qmb.setDetailedText(detail)
                qmb.resize(400, qmb.size().height())
                qmb.exec_()
        return wrapper

    return decorator

########NEW FILE########
__FILENAME__ = feedback
"""
Widgets for sending feedback reports
"""
from urllib2 import Request, urlopen
from urllib import urlencode
import sys

from ..external.qt.QtGui import QTextCursor
from .qtutil import load_ui

__all__ = ['submit_bug_report']


def _send_feedback(report):
    """
    Send a report to bugs.glueviz.org

    :param report: Report message to send
    :type report: str
    """

    # website expects a post request with a report and specific key
    url = 'http://bugs.glueviz.org'
    values = dict(report=report, key='72z29Q9BzM8sgATeQdu4')

    data = urlencode(values)
    req = Request(url, data)
    urlopen(req)


def _diagnostics():
    """
    Return a some system informaton useful for debugging
    """
    from glue.external.qt import QtCore
    from matplotlib import __version__ as mplversion
    from numpy import __version__ as npversion
    from astropy import __version__ as apversion

    result = []
    result.append('Platform: %s' % sys.platform)
    result.append('Version: %s' % sys.version)
    result.append('Qt Binding: %s' % QtCore.__name__.split('.')[0])
    result.append('Matplotlib version: %s' % mplversion)
    result.append('Numpy version: %s' % npversion)
    result.append('AstroPy version: %s' % apversion)
    return '\n'.join(result)


class FeedbackWidget(object):

    """
    A Dialog to enter and send feedback
    """

    def __init__(self, feedback='', parent=None):
        """
        :param feedback: The default feedback report
        :type feedback: str

        Feedback will be supplemented with diagnostic system information.
        The user can modify or add to any of this
        """
        self._ui = load_ui('feedbackwidget', None)
        feedback = '\n'.join(['-' * 80,
                              feedback,
                              _diagnostics()])
        self._ui.report_area.insertPlainText('\n' + feedback)
        self._ui.report_area.moveCursor(QTextCursor.Start)

    def exec_(self):
        """
        Show and execute the dialog.

        :returns: True if the user clicked "OK"
        """
        self._ui.show()
        self._ui.raise_()
        return self._ui.exec_() == self._ui.Accepted

    @property
    def report(self):
        """
        The contents of the report window
        """
        return self._ui.report_area.document().toPlainText()


def submit_bug_report(report=''):
    """
    Present a user interface for modifying and sending a feedback message

    :param report: A default report message
    :type report: str

    :returns: True if a report was submitted
    """
    widget = FeedbackWidget(report)
    if widget.exec_():
        _send_feedback(widget.report)
        return True
    return False

########NEW FILE########
__FILENAME__ = glue_application
# pylint: disable=W0223
import sys
import webbrowser

from ..external.qt.QtGui import (QKeySequence, QMainWindow, QGridLayout,
                                 QMenu, QMdiSubWindow, QAction, QMessageBox,
                                 QFileDialog, QInputDialog,
                                 QToolButton, QVBoxLayout, QWidget, QPixmap,
                                 QBrush, QPainter, QLabel, QHBoxLayout,
                                 QTextEdit, QTextCursor, QPushButton)
from ..external.qt.QtCore import Qt, QSize, QSettings, Signal

from ..core import command
from .. import env
from ..qt import get_qapp
from .decorators import set_cursor, messagebox_on_error
from ..core.application_base import Application

from .actions import act
from .qtutil import (pick_class, data_wizard,
                     GlueTabBar, load_ui, get_icon, nonpartial)
from .widgets.glue_mdi_area import GlueMdiArea
from .widgets.edit_subset_mode_toolbar import EditSubsetModeToolBar
from .widgets.layer_tree_widget import PlotAction, LayerTreeWidget
from .widgets.data_viewer import DataViewer
from .widgets.settings_editor import SettingsEditor
from .widgets.mpl_widget import defer_draw
from .feedback import submit_bug_report

__all__ = ['GlueApplication']
DOCS_URL = 'http://www.glue-viz.org'


def _fix_ipython_pylab():
    try:
        from IPython import get_ipython
    except ImportError:
        return
    shell = get_ipython()
    if shell is None:
        return
    try:
        shell.enable_pylab('inline', import_all=True)
    except ValueError:
        # if the shell is a normal terminal shell, we get here
        pass


def status_pixmap(attention=False):
    """
    A small icon to grab attention

    :param attention: If True, return attention-grabbing pixmap
    """
    color = Qt.red if attention else Qt.lightGray

    pm = QPixmap(15, 15)
    p = QPainter(pm)
    b = QBrush(color)
    p.fillRect(-1, -1, 20, 20, b)
    return pm


class ClickableLabel(QLabel):

    """
    A QLabel you can click on to generate events
    """

    clicked = Signal()

    def mousePressEvent(self, event):
        self.clicked.emit()


class GlueLogger(QWidget):

    """
    A window to display error messages
    """

    def __init__(self, parent=None):
        super(GlueLogger, self).__init__(parent)
        self._text = QTextEdit()
        self._text.setTextInteractionFlags(Qt.TextSelectableByMouse)

        clear = QPushButton("Clear")
        clear.clicked.connect(self._clear)

        report = QPushButton("Send Bug Report")
        report.clicked.connect(self._send_report)

        self.stderr = sys.stderr
        sys.stderr = self

        self._status = ClickableLabel()
        self._status.setToolTip("View Errors and Warnings")
        self._status.clicked.connect(self._show)
        self._status.setPixmap(status_pixmap())
        self._status.setContentsMargins(0, 0, 0, 0)

        l = QVBoxLayout()
        h = QHBoxLayout()
        l.setContentsMargins(2, 2, 2, 2)
        l.setSpacing(2)
        h.setContentsMargins(0, 0, 0, 0)

        l.addWidget(self._text)
        h.insertStretch(0)
        h.addWidget(report)
        h.addWidget(clear)
        l.addLayout(h)

        self.setLayout(l)

    @property
    def status_light(self):
        """
        The icon representing the status of the log
        """
        return self._status

    def write(self, message):
        """
        Interface for sys.excepthook
        """
        self.stderr.write(message)
        self._text.moveCursor(QTextCursor.End)
        self._text.insertPlainText(message)
        self._status.setPixmap(status_pixmap(attention=True))

    def flush(self):
        """
        Interface for sys.excepthook
        """
        pass

    def _send_report(self):
        """
        Send the contents of the log as a bug report
        """
        text = self._text.document().toPlainText()
        if submit_bug_report(text):
            self._clear()

    def _clear(self):
        """
        Erase the log
        """
        self._text.setText('')
        self._status.setPixmap(status_pixmap(attention=False))
        self.close()

    def _show(self):
        """
        Show the log
        """
        self.show()
        self.raise_()

    def keyPressEvent(self, event):
        """
        Hide window on escape key
        """
        if event.key() == Qt.Key_Escape:
            self.hide()


class GlueApplication(Application, QMainWindow):

    """ The main GUI application for the Qt frontend"""

    def __init__(self, data_collection=None, session=None):
        QMainWindow.__init__(self)
        Application.__init__(self, data_collection=data_collection,
                             session=session)

        self.app = get_qapp()

        self.setWindowIcon(self.app.windowIcon())
        self.setAttribute(Qt.WA_DeleteOnClose)
        self._actions = {}
        self._terminal = None
        self._setup_ui()
        self.tab_widget.setMovable(True)
        self.tab_widget.setTabsClosable(True)

        lwidget = self._ui.layerWidget
        a = PlotAction(lwidget, self)
        lwidget.layerTree.addAction(a)
        lwidget.bind_selection_to_edit_subset()

        self._tweak_geometry()
        self._create_actions()
        self._create_menu()
        self._connect()
        self.new_tab()
        self._create_terminal()
        self._update_plot_dashboard(None)

    def _setup_ui(self):
        self._ui = load_ui('glue_application', None)
        self.setCentralWidget(self._ui)
        self._ui.tabWidget.setTabBar(GlueTabBar())

        lw = LayerTreeWidget()
        lw.set_checkable(False)
        vb = QVBoxLayout()
        vb.setContentsMargins(0, 0, 0, 0)
        vb.addWidget(lw)
        self._ui.data_layers.setLayout(vb)
        self._ui.layerWidget = lw

        # log window + status light
        self._ui.log = GlueLogger()
        self._ui.log.window().setWindowTitle("Console Log")
        self._ui.log.resize(550, 550)
        self.statusBar().addPermanentWidget(self._ui.log.status_light)
        self.statusBar().setContentsMargins(2, 0, 20, 2)
        self.statusBar().setSizeGripEnabled(False)

    def _tweak_geometry(self):
        """Maximize window"""
        self.setWindowState(Qt.WindowMaximized)
        self._ui.main_splitter.setSizes([100, 800])
        self._ui.data_plot_splitter.setSizes([100, 400])
        self._ui.plot_splitter.setSizes([150, 250])

    @property
    def tab_widget(self):
        return self._ui.tabWidget

    @property
    def tab_bar(self):
        return self._ui.tabWidget.tabBar()

    @property
    def tab_count(self):
        """
        The number of open tabs
        """
        return self._ui.tabWidget.count()

    @property
    def current_tab(self):
        return self._ui.tabWidget.currentWidget()

    def tab(self, index=None):
        if index is None:
            return self.current_tab
        return self._ui.tabWidget.widget(index)

    def new_tab(self):
        """Spawn a new tab page"""
        layout = QGridLayout()
        layout.setSpacing(1)
        layout.setContentsMargins(0, 0, 0, 0)
        widget = GlueMdiArea(self)
        widget.setLayout(layout)
        tab = self.tab_widget
        tab.addTab(widget, str("Tab %i" % (tab.count() + 1)))
        tab.setCurrentWidget(widget)
        widget.subWindowActivated.connect(self._update_plot_dashboard)

    def close_tab(self, index):
        """ Close a tab window and all associated data viewers """
        # do not delete the last tab
        if self.tab_widget.count() == 1:
            return
        w = self.tab_widget.widget(index)
        w.close()
        self.tab_widget.removeTab(index)

    def add_widget(self, new_widget, label=None, tab=None,
                   hold_position=False):
        """ Add a widget to one of the tabs

        :param new_widget: new QWidget to add

        :param label: label for the new window. Optional
        :type label: str

        :param tab: Tab to add to. Optional (default: current tab)
        :type tab: int

        :param hold_position: If True, then override Qt's default
                              placement and retain the original position
                              of new_widget
        :type hold_position: bool

        :rtype: QMdiSubWindow. The window that this widget is wrapped in
        """
        page = self.tab(tab)
        pos = getattr(new_widget, 'position', None)
        sub = new_widget.mdi_wrap()

        if label:
            sub.setWindowTitle(label)
        page.addSubWindow(sub)
        page.setActiveSubWindow(sub)
        if hold_position and pos is not None:
            new_widget.move(pos[0], pos[1])
        return sub

    def set_setting(self, key, value):
        """
        Update a persistent setting in the application.

        :param key: Name of a setting in the
                    :attr:`Settings registry <glue.core.config.settings>`
        :type key: str
        :param value: New value for the setting
        :type value: str
        """
        super(GlueApplication, self).set_setting(key, value)
        settings = QSettings('glue-viz', 'glue')
        settings.setValue(key, value)

    def _load_settings(self, path=None):
        settings = QSettings('glue-viz', 'glue')
        for k, v in self.settings:
            if settings.contains(k):
                super(GlueApplication, self).set_setting(k, settings.value(k))

    def _edit_settings(self):
        # save it to prevent garbage collection
        self._editor = SettingsEditor(self)
        self._editor.widget.show()

    def gather_current_tab(self):
        """Arrange windows in current tab via tiling"""
        self.current_tab.tileSubWindows()

    def _get_plot_dashboards(self, sub_window):
        if not isinstance(sub_window, QMdiSubWindow):
            return QWidget(), QWidget(), ""

        widget = sub_window.widget()
        if not isinstance(widget, DataViewer):
            return QWidget(), QWidget(), ""

        return widget.layer_view(), widget.options_widget(), str(widget)

    def _update_plot_dashboard(self, sub_window):
        if sub_window is None:
            return

        layer_view, options_widget, title = \
            self._get_plot_dashboards(sub_window)

        layout = self._ui.plot_layers.layout()
        if not layout:
            layout = QVBoxLayout()
            self._ui.plot_layers.setLayout(layout)
        while layout.count():
            layout.takeAt(0).widget().hide()
        layout.addWidget(layer_view)

        layout = self._ui.plot_options.layout()
        if not layout:
            layout = QVBoxLayout()
            self._ui.plot_options.setLayout(layout)
        while layout.count():
            layout.takeAt(0).widget().hide()
        layout.addWidget(options_widget)

        layer_view.show()
        options_widget.show()

        if title:
            self._ui.plot_options.setTitle("Plot Options - %s" % title)
            self._ui.plot_layers.setTitle("Plot Layers - %s" % title)
        else:
            self._ui.plot_options.setTitle("Plot Options")
            self._ui.plot_layers.setTitle("Plot Layers")

        self._update_focus_decoration()

    def _update_focus_decoration(self):
        mdi_area = self.current_tab
        active = mdi_area.activeSubWindow()

        for win in mdi_area.subWindowList():
            widget = win.widget()
            if isinstance(widget, DataViewer):
                widget.set_focus(win is active)

    def _connect(self):
        self.setAcceptDrops(True)
        self._ui.layerWidget.setup(self._data)

        def sethelp(*args):
            model = self._ui.layerWidget.layerTree.model()
            self.current_tab.show_help = model.rowCount() > 0

        model = self._ui.layerWidget.layerTree.model()
        model.rowsInserted.connect(sethelp)
        model.rowsRemoved.connect(sethelp)

        self.tab_widget.tabCloseRequested.connect(self.close_tab)

    def _create_menu(self):
        mbar = self.menuBar()
        menu = QMenu(mbar)
        menu.setTitle("File")

        menu.addAction(self._actions['data_new'])
        # menu.addAction(self._actions['data_save'])  # XXX add this
        menu.addAction(self._actions['session_restore'])
        menu.addAction(self._actions['session_save'])
        if 'session_export' in self._actions:
            submenu = menu.addMenu("Export")
            for a in self._actions['session_export']:
                submenu.addAction(a)
        menu.addSeparator()
        menu.addAction("Edit Settings", self._edit_settings)
        mbar.addMenu(menu)

        menu = QMenu(mbar)
        menu.setTitle("Edit ")
        menu.addAction(self._actions['undo'])
        menu.addAction(self._actions['redo'])
        mbar.addMenu(menu)

        menu = QMenu(mbar)
        menu.setTitle("Canvas")
        menu.addAction(self._actions['tab_new'])
        menu.addAction(self._actions['viewer_new'])
        menu.addSeparator()
        menu.addAction(self._actions['gather'])
        menu.addAction(self._actions['tab_rename'])
        mbar.addMenu(menu)

        menu = QMenu(mbar)
        menu.setTitle("Data Manager")
        menu.addActions(self._ui.layerWidget.actions())

        mbar.addMenu(menu)

        menu = QMenu(mbar)
        menu.setTitle("Toolbars")
        tbar = EditSubsetModeToolBar()
        self._mode_toolbar = tbar
        self.addToolBar(tbar)
        tbar.hide()
        a = QAction("Selection Mode Toolbar", menu)
        a.setCheckable(True)
        a.toggled.connect(tbar.setVisible)
        try:
            tbar.visibilityChanged.connect(a.setChecked)
        except AttributeError:  # Qt < 4.7. Signal not supported
            pass

        menu.addAction(a)
        menu.addActions(tbar.actions())
        mbar.addMenu(menu)

        # trigger inclusion of Mac Native "Help" tool
        menu = mbar.addMenu("Help")
        a = QAction("Online Documentation", menu)
        a.triggered.connect(nonpartial(webbrowser.open, DOCS_URL))
        menu.addAction(a)

        a = QAction("Send Feedback", menu)
        a.triggered.connect(nonpartial(submit_bug_report))
        menu.addAction(a)

    def _choose_load_data(self):
        for d in data_wizard():
            self._data.append(d)

    def _create_actions(self):
        """ Create and connect actions, store in _actions dict """
        self._actions = {}

        a = act("Open Data Set", self,
                tip="Open a new data set",
                shortcut=QKeySequence.Open)
        a.triggered.connect(nonpartial(self._choose_load_data))
        self._actions['data_new'] = a

        a = act("New Data Viewer", self,
                tip="Open a new visualization window in the current tab",
                shortcut=QKeySequence.New
                )
        a.triggered.connect(nonpartial(self.choose_new_data_viewer))
        self._actions['viewer_new'] = a

        a = act('New Tab', self,
                shortcut=QKeySequence.AddTab,
                tip='Add a new tab')
        a.triggered.connect(nonpartial(self.new_tab))
        self._actions['tab_new'] = a

        a = act('Rename Tab', self,
                shortcut="Ctrl+R",
                tip='Set a new label for the current tab')
        a.triggered.connect(nonpartial(self.tab_bar.rename_tab))
        self._actions['tab_rename'] = a

        a = act('Gather Windows', self,
                tip='Gather plot windows side-by-side',
                shortcut='Ctrl+G')
        a.triggered.connect(nonpartial(self.gather_current_tab))
        self._actions['gather'] = a

        a = act('Save Session', self,
                tip='Save the current session')
        a.triggered.connect(nonpartial(self._choose_save_session))
        self._actions['session_save'] = a

        from glue.config import exporters
        if len(exporters) > 0:
            acts = []
            for e in exporters:
                label, saver, checker, mode = e
                a = act(label, self,
                        tip='Export the current session to %s format' %
                        label)
                a.triggered.connect(nonpartial(self._choose_export_session,
                                               saver, checker, mode))
                acts.append(a)

            self._actions['session_export'] = acts

        a = act('Open Session', self,
                tip='Restore a saved session')
        a.triggered.connect(nonpartial(self._restore_session))
        self._actions['session_restore'] = a

        a = act("Undo", self,
                tip='Undo last action',
                shortcut=QKeySequence.Undo)
        a.triggered.connect(nonpartial(self.undo))
        a.setEnabled(False)
        self._actions['undo'] = a

        a = act("Redo", self,
                tip='Redo last action',
                shortcut=QKeySequence.Redo)
        a.triggered.connect(nonpartial(self.redo))
        a.setEnabled(False)
        self._actions['redo'] = a

    def choose_new_data_viewer(self, data=None):
        """ Create a new visualization window in the current tab
        """

        from ..config import qt_client
        from .widgets import ScatterWidget, ImageWidget

        if data and data.ndim == 1 and ScatterWidget in qt_client.members:
            default = qt_client.members.index(ScatterWidget)
        elif data and data.ndim > 1 and ImageWidget in qt_client.members:
            default = qt_client.members.index(ImageWidget)
        else:
            default = 0

        client = pick_class(list(qt_client.members), title='Data Viewer',
                            label="Choose a new data viewer",
                            default=default)

        cmd = command.NewDataViewer(viewer=client, data=data)
        return self.do(cmd)

    new_data_viewer = defer_draw(Application.new_data_viewer)

    @set_cursor(Qt.WaitCursor)
    def _choose_save_session(self):
        """ Save the data collection and hub to file.

        Can be restored via restore_session

        Note: Saving of client is not currently supported. Thus,
        restoring this session will lose all current viz windows
        """
        outfile, file_filter = QFileDialog.getSaveFileName(self)
        if not outfile:
            return
        self.save_session(outfile)

    @messagebox_on_error("Failed to export session")
    def _choose_export_session(self, saver, checker, outmode):
        checker(self)
        if outmode in ['file', 'directory']:
            outfile, file_filter = QFileDialog.getSaveFileName(self)
            if not outfile:
                return
            return saver(self, outfile)
        else:
            assert outmode == 'label'
            label, ok = QInputDialog.getText(self, 'Choose a label:',
                                             'Choose a label:')
            if not ok:
                return
            return saver(self, label)

    @messagebox_on_error("Failed to restore session")
    @set_cursor(Qt.WaitCursor)
    def _restore_session(self, show=True):
        """ Load a previously-saved state, and restart the session """
        fltr = "Glue sessions (*.glu)"
        file_name, file_filter = QFileDialog.getOpenFileName(self,
                                                             filter=fltr)
        if not file_name:
            return

        ga = self.restore(file_name, show=True)
        self.close()
        return ga

    @staticmethod
    def restore(path, show=True):
        """Reload a previously-saved session

        :param path: Path to the file to load
        :type path: str
        :param show: If True (the default), immediately show the widget
        :type show: bool

        :returns: A new :class:`GlueApplication`
        """
        from ..core.state import GlueUnSerializer

        with open(path) as infile:
            state = GlueUnSerializer.load(infile)

        ga = state.object('__main__')
        if show:
            ga.show()
        return ga

    def has_terminal(self):
        """
        Returns True if the IPython terminal is present.
        """
        return self._terminal is not None

    def _create_terminal(self):
        assert self._terminal is None, \
            "should only call _create_terminal once"

        self._terminal_button = QToolButton(self._ui)
        self._terminal_button.setToolTip("Toggle IPython Prompt")
        i = get_icon('IPythonConsole')
        self._terminal_button.setIcon(i)
        self._terminal_button.setIconSize(QSize(25, 25))

        self._ui.layerWidget.button_row.addWidget(self._terminal_button)

        try:
            from .widgets.terminal import glue_terminal
            widget = glue_terminal(data_collection=self._data,
                                   dc=self._data,
                                   hub=self._hub,
                                   session=self.session,
                                   application=self,
                                   **vars(env))
            self._terminal_button.clicked.connect(self._toggle_terminal)
        except Exception as e:  # pylint: disable=W0703
            import traceback
            self._terminal_exception = traceback.format_exc()
            self._setup_terminal_error_dialog(e)
            return

        self._terminal = self.add_widget(widget, label='IPython')
        self._hide_terminal()

    def _setup_terminal_error_dialog(self, exception):
        """ Reassign the terminal toggle button to show dialog on error"""
        title = "Terminal unavailable"
        msg = ("Glue encountered an error trying to start the Terminal"
               "\nReason:\n%s" % exception)

        def show_msg():
            mb = QMessageBox(QMessageBox.Critical,
                             title, msg)
            mb.setDetailedText(self._terminal_exception)
            mb.exec_()

        self._terminal_button.clicked.connect(show_msg)

    def _toggle_terminal(self):
        if self._terminal.isVisible():
            self._hide_terminal()
            assert not self._terminal.isVisible()
        else:
            self._show_terminal()
            assert self._terminal.isVisible()

    def _hide_terminal(self):
        self._terminal.hide()

    def _show_terminal(self):
        self._terminal.show()
        self._terminal.widget().show()

    def start(self):
        """
        Show the GUI and start the application.
        """
        self.show()
        self.raise_()  # bring window to front
        # at some point during all this, the MPL backend
        # switches. This call restores things, so
        # figures are still inlined in the notebook.
        # XXX find out a better place for this
        _fix_ipython_pylab()
        return self.app.exec_()

    exec_ = start

    def keyPressEvent(self, event):
        """Hold down modifier keys to temporarily set edit mode"""
        mod = event.modifiers()
        if mod == Qt.ShiftModifier:
            self._mode_toolbar.set_mode('or')

    def keyReleaseEvent(self, event):
        """Unset any temporary edit mode"""
        self._mode_toolbar.unset_mode()

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event):
        urls = event.mimeData().urls()
        for url in urls:
            self.load_data(url.path())
        event.accept()

    def report_error(self, message, detail):
        """
        Display an error in a modal

        :param message: A short description of the error
        :type message: str
        :param detail: A longer description
        :type detail: str
        """
        qmb = QMessageBox(QMessageBox.Critical, "Error", message)
        qmb.setDetailedText(detail)
        qmb.resize(400, qmb.size().height())
        qmb.exec_()

    def _update_undo_redo_enabled(self):
        undo, redo = self._cmds.can_undo_redo()
        self._actions['undo'].setEnabled(undo)
        self._actions['redo'].setEnabled(redo)
        self._actions['undo'].setText('Undo ' + self._cmds.undo_label)
        self._actions['redo'].setText('Redo ' + self._cmds.redo_label)

    @property
    def viewers(self):
        """
        A list of lists of open Data Viewers.

        Each inner list contains the viewers open on a particular tab.
        """
        result = []
        for t in range(self.tab_count):
            tab = self.tab(t)
            item = []
            for subwindow in tab.subWindowList():
                widget = subwindow.widget()
                if isinstance(widget, DataViewer):
                    item.append(widget)
            result.append(tuple(item))
        return tuple(result)

    @property
    def tab_names(self):
        """
        The name of each tab

        A list of strings
        """
        return [self.tab_bar.tabText(i) for i in range(self.tab_count)]

########NEW FILE########
__FILENAME__ = glue_toolbar
import os
import matplotlib
from matplotlib.backends.backend_qt4 import NavigationToolbar2QT
from ..external.qt import QtCore, QtGui
from ..external.qt.QtGui import QMenu
from ..external.qt.QtCore import Qt, Signal
from ..core.callback_property import add_callback
from .qtutil import get_icon, nonpartial


class GlueToolbar(NavigationToolbar2QT):
    pan_begin = Signal()
    pan_end = Signal()
    mode_activated = Signal()
    mode_deactivated = Signal()

    def __init__(self, canvas, frame, name=None):
        """ Create a new toolbar object

        Parameters
        ----------
        data_collection : DataCollection instance
         The data collection that this toolbar is meant to edit.
         The toolbar looks to this collection for the available subsets
         to manipulate.
        canvas : Maptloblib canvas instance
         The drawing canvas to interact with
        frame : QWidget
         The QT frame that the canvas is embedded within.
        """
        self.buttons = {}
        self.__active = None
        self.basedir = None
        NavigationToolbar2QT.__init__(self, canvas, frame)
        if name is not None:
            self.setWindowTitle(name)
        self.setIconSize(QtCore.QSize(25, 25))
        self.layout().setSpacing(1)
        self.setFocusPolicy(Qt.StrongFocus)
        self._idKey = None

        # pyside is prone to segfaults if slots hold the only
        # reference to a signal, so we hold an extra reference
        # see https://bugreports.qt-project.org/browse/PYSIDE-88
        self.__signals = []

    def _init_toolbar(self):
        self.basedir = os.path.join(matplotlib.rcParams['datapath'], 'images')
        parent = QtGui.QToolBar.parent(self)

        a = QtGui.QAction(get_icon('glue_home'),
                          'Home', parent)
        a.triggered.connect(nonpartial(self.home))
        a.setToolTip('Reset original zoom')
        a.setShortcut('H')
        a.setShortcutContext(Qt.WidgetShortcut)
        parent.addAction(a)
        self.buttons['HOME'] = a
        self.addAction(a)

        a = QtGui.QAction(get_icon('glue_filesave'),
                          'Save', parent)
        a.triggered.connect(nonpartial(self.save_figure))
        a.setToolTip('Save the figure')
        a.setShortcut('Ctrl+Shift+S')
        parent.addAction(a)
        self.buttons['SAVE'] = a
        self.addAction(a)

        a = QtGui.QAction(get_icon('glue_back'),
                          'Back', parent)
        a.triggered.connect(nonpartial(self.back))
        parent.addAction(a)
        self.addAction(a)
        self.buttons['BACK'] = a
        a.setToolTip('Back to previous view')

        a = QtGui.QAction(get_icon('glue_forward'),
                          'Forward', parent)
        a.triggered.connect(nonpartial(self.forward))
        a.setToolTip('Forward to next view')
        parent.addAction(a)
        self.buttons['FORWARD'] = a
        self.addAction(a)

        a = QtGui.QAction(get_icon('glue_move'),
                          'Pan', parent)
        a.triggered.connect(nonpartial(self.pan))
        a.setToolTip('Pan axes with left mouse, zoom with right')
        a.setCheckable(True)
        a.setShortcut('M')
        a.setShortcutContext(Qt.WidgetShortcut)
        parent.addAction(a)
        self.addAction(a)
        self.buttons['PAN'] = a

        a = QtGui.QAction(get_icon('glue_zoom_to_rect'),
                          'Zoom', parent)
        a.triggered.connect(nonpartial(self.zoom))
        a.setToolTip('Zoom to rectangle')
        a.setShortcut('Z')
        a.setShortcutContext(Qt.WidgetShortcut)
        a.setCheckable(True)
        parent.addAction(a)
        self.addAction(a)
        self.buttons['ZOOM'] = a

        #self.adj_window = None

    @property
    def _active(self):
        return self.__active

    @_active.setter
    def _active(self, value):
        if self.__active == value:
            return

        self.__active = value
        if value not in [None, '']:
            self.mode_activated.emit()
        else:
            self.mode_deactivated.emit()

    def home(self, *args):
        super(GlueToolbar, self).home(*args)
        self.canvas.homeButton.emit()

    def zoom(self, *args):
        self._deactivate_custom_modes()
        super(GlueToolbar, self).zoom(*args)
        self._update_buttons_checked()

    def pan(self, *args):
        self._deactivate_custom_modes()
        super(GlueToolbar, self).pan(*args)
        self._update_buttons_checked()

    def _deactivate_custom_modes(self):
        if self._idPress is not None:
            self._idPress = self.canvas.mpl_disconnect(self._idPress)
        if self._idRelease is not None:
            self._idRelease = self.canvas.mpl_disconnect(self._idRelease)
        if self._idDrag is not None:
            self._idDrag = self.canvas.mpl_disconnect(
                self._idDrag)
            self._idDrag = self.canvas.mpl_connect('motion_notify_event',
                                                   self.mouse_move)
        if self._idKey is not None:
            self._idKey = self.canvas.mpl_disconnect(self._idKey)

        self.mode = ''

    def add_mode(self, mode):
        parent = QtGui.QToolBar.parent(self)

        def toggle():
            self._custom_mode(mode)

        def enable():
            # turn on if not
            if self._active != mode.mode_id:
                self._custom_mode(mode)

        action = QtGui.QAction(mode.icon, mode.action_text, parent)
        action.triggered.connect(nonpartial(toggle))
        parent.addAction(action)

        self.__signals.extend([toggle, enable])

        if mode.shortcut is not None:
            action.setShortcut(mode.shortcut)
            action.setShortcutContext(Qt.WidgetShortcut)

        action.setToolTip(mode.tool_tip)
        action.setCheckable(True)
        self.buttons[mode.mode_id] = action

        menu_actions = mode.menu_actions()
        if len(menu_actions) > 0:
            menu = QMenu(self)
            for ma in mode.menu_actions():
                ma.setParent(self)
                menu.addAction(ma)
            action.setMenu(menu)
            menu.triggered.connect(nonpartial(enable))

        self.addAction(action)

        # bind action status to mode.enabled
        def toggle(state):
            action.setVisible(state)
            action.setEnabled(state)
        add_callback(mode, 'enabled', toggle)

        return action

    def set_mode(self, mode):
        if self._active != mode.mode_id:
            self._custom_mode(mode)

    def _custom_mode(self, mode):
        if self._active == mode.mode_id:
            self._active = None
        else:
            self._active = mode.mode_id

        self._deactivate_custom_modes()

        if self._active:
            self._idPress = self.canvas.mpl_connect(
                'button_press_event', mode.press)
            self._idDrag = self.canvas.mpl_connect(
                'motion_notify_event', mode.move)
            self._idRelease = self.canvas.mpl_connect(
                'button_release_event', mode.release)
            self._idKey = self.canvas.mpl_connect(
                'key_press_event', mode.key)
            self.mode = mode.action_text
            self.canvas.widgetlock(self)
        else:
            self.canvas.widgetlock.release(self)

        for a in self.canvas.figure.get_axes():
            a.set_navigate_mode(None)

        self.set_message(self.mode)
        self._update_buttons_checked()

    def press_pan(self, event):
        self.pan_begin.emit()
        super(GlueToolbar, self).press_pan(event)

    def release_pan(self, event):
        self.pan_end.emit()
        super(GlueToolbar, self).release_pan(event)

    def _update_buttons_checked(self):
        for mode in self.buttons:
            self.buttons[mode].setChecked(self._active == mode)

    def set_message(self, s):
        self.emit(QtCore.SIGNAL("message"), s)
        parent = QtGui.QToolBar.parent(self)
        if parent is None:
            return
        sb = parent.statusBar()
        if sb is None:
            return
        sb.showMessage(s.replace(', ', '\n'))

########NEW FILE########
__FILENAME__ = layer_artist_model
"""
This module provides two classes for managing LayerArtists with Qt.

The LayerArtistModel implements a QtModel to interface with a list of
LayerManagers.

The LayerArtistView is a list widget that displays
these layers, and provides GUI access to the model
"""
#pylint: disable=I0011, W0613, R0913, R0904, W0611
from ..external.qt.QtGui import (QColor,
                                 QListView, QAbstractItemView, QAction,
                                 QPalette, QKeySequence)

from ..external.qt.QtCore import (Qt, QAbstractListModel, QModelIndex,
                                  QSize, QTimer)

from .qtutil import (layer_artist_icon, nonpartial)

from .mime import PyMimeData, LAYERS_MIME_TYPE
from ..clients.layer_artist import LayerArtist, LayerArtistContainer

from .widgets.style_dialog import StyleDialog


class LayerArtistModel(QAbstractListModel):
    """A Qt model to manage a list of LayerArtists. Multiple
    views into this model should stay in sync, thanks to Qt.

    To properly maintain sync, any client that uses
    this list of LayerArtists should always edit the
    list in-place (so that the list managed by this model
    and the client are the same object)
    """
    def __init__(self, artists, parent=None):
        super(LayerArtistModel, self).__init__(parent)
        self.artists = artists

    def rowCount(self, parent=None):
        """Number of rows"""
        return len(self.artists)

    def headerData(self, section, orientation, role):
        """Column labels"""
        if role != Qt.DisplayRole:
            return None
        return "%i" % section

    def data(self, index, role):
        """Retrieve data at each index"""
        if not index.isValid():
            return None
        if role == Qt.DisplayRole or role == Qt.EditRole:
            return self.row_label(index.row())
        if role == Qt.DecorationRole:
            art = self.artists[index.row()]
            result = layer_artist_icon(art)
            return result
        if role == Qt.CheckStateRole:
            art = self.artists[index.row()]
            result = Qt.Checked if art.visible else Qt.Unchecked
            return result
        if role == Qt.ToolTipRole:
            art = self.artists[index.row()]
            if not art.enabled:
                return art.disabled_message

    def flags(self, index):
        result = super(LayerArtistModel, self).flags(index)
        if index.isValid():
            result = (result | Qt.ItemIsEditable | Qt.ItemIsDragEnabled |
                      Qt.ItemIsUserCheckable)
        else:  # only drop between rows, where index isn't valid
            result = (result | Qt.ItemIsDropEnabled)

        return result

    def setData(self, index, value, role):
        if not index.isValid():
            return False
        if role == Qt.EditRole:
            self.change_label(index.row(), str(value))
        if role == Qt.CheckStateRole:
            vis = value == Qt.Checked
            self.artists[index.row()].visible = vis
            self.artists[index.row()].redraw()

        self.dataChanged.emit(index, index)
        return True

    def removeRow(self, row, parent=None):
        if row < 0 or row >= len(self.artists):
            return False

        self.beginRemoveRows(QModelIndex(), row, row)
        art = self.artists.pop(row)
        art.clear()
        art.redraw()
        self.endRemoveRows()
        return True

    def mimeTypes(self):
        return [PyMimeData.MIME_TYPE, LAYERS_MIME_TYPE]

    def mimeData(self, indexes):
        arts = [self.artists[index.row()] for index in indexes]
        layers = [a.layer for a in arts]

        if len(indexes) == 0:
            return 0
        return PyMimeData(arts, **{LAYERS_MIME_TYPE: layers})

    def supportedDropActions(self):
        return Qt.MoveAction

    def dropMimeData(self, data, action, row, column, index):
        data = data.data(PyMimeData.MIME_TYPE)
        #list of a single artist. Move
        if isinstance(data, list) and len(data) == 1 and \
                isinstance(data[0], LayerArtist) and data[0] in self.artists:
            self.move_artist(data[0], row)
            return True

        return False

    def move_artist(self, artist, row):
        """Move an artist before the entry in row

        Row could be the end of the list (-> put it at the end)
        """
        if len(self.artists) < 2:  # can't rearrange lenght 0 or 1 list
            return

        try:
            loc = self.artists.index(artist)
        except ValueError:
            return

        dest = row
        if not self.beginMoveRows(QModelIndex(), loc, loc,
                                  QModelIndex(), dest):
            return
        if dest >= loc:
            row -= 1
        self.artists.pop(loc)
        self.artists.insert(row, artist)
        self._update_zorder()
        self.endMoveRows()

    def _update_zorder(self):
        """Redistribute zorders to match location in the list"""
        zs = [m.zorder for m in self.artists]
        zs = reversed(sorted(zs))
        for z, m in zip(zs, self.artists):
            m.zorder = z
        if len(self.artists) > 0:
            self.artists[0].redraw()

    def row_label(self, row):
        """ The textual label for the row"""
        layer = self.artists[row].layer
        if hasattr(layer, 'verbose_label'):
            return layer.verbose_label
        return layer.label

    def change_label(self, row, label):
        """ Reassign the labeel for whatever layer the artist manages"""
        try:
            art = self.artists[row]
            art.layer.label = label
        except IndexError:
            pass

    def add_artist(self, row, artist):
        """Add a new artist"""
        self.beginInsertRows(QModelIndex(), row, row)
        self.artists.insert(row, artist)
        self.endInsertRows()
        self.rowsInserted.emit(self.index(row), row, row)

    def row_artist(self, row):
        return self.artists[row]


class LayerArtistView(QListView):
    """A list view into an artist model. The zorder
    of each artist can be shuffled by dragging and dropping
    items. Right-clicking brings up a menu to edit style or delete"""
    def __init__(self, parent=None):
        super(LayerArtistView, self).__init__(parent)
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.setIconSize(QSize(15, 15))
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setContextMenuPolicy(Qt.ActionsContextMenu)
        self.doubleClicked.connect(lambda x: self._edit_style())
        self.setEditTriggers(self.NoEditTriggers)

        self._set_palette()
        self._actions = {}
        self._create_actions()

        self._timer = QTimer(self)
        self._timer.timeout.connect(self.viewport().update)
        self._timer.start(1000)

    def selectionChanged(self, selected, deselected):
        super(LayerArtistView, self).selectionChanged(selected, deselected)
        self._update_actions()

    def current_artist(self):
        model = self.selectionModel()
        if model is None:
            return
        rows = model.selectedRows()
        if len(rows) != 1:
            return
        return self.model().row_artist(rows[0].row())

    def single_selection(self):
        return self.current_artist() is not None

    def current_row(self):
        model = self.selectionModel()
        if model is None:
            return
        rows = model.selectedRows()
        if len(rows) != 1:
            return
        return rows[0].row()

    def _set_palette(self):
        p = self.palette()
        c = QColor(240, 240, 240)
        p.setColor(QPalette.Highlight, c)
        p.setColor(QPalette.HighlightedText, QColor(Qt.black))
        self.setPalette(p)

    def _update_actions(self):
        pass

    def _bottom_left_of_current_index(self):
        idx = self.currentIndex()
        if not idx.isValid():
            return
        rect = self.visualRect(idx)
        pos = self.mapToGlobal(rect.bottomLeft())
        pos.setY(pos.y() + 1)
        return pos

    def _edit_style(self):
        pos = self._bottom_left_of_current_index()
        if pos is None:
            return
        item = self.current_artist().layer
        StyleDialog.dropdown_editor(item, pos, edit_label=False)

    def _create_actions(self):
        act = QAction('Edit style', self)
        act.triggered.connect(nonpartial(self._edit_style))
        self.addAction(act)

        act = QAction('Remove', self)
        act.setShortcut(QKeySequence(Qt.Key_Backspace))
        act.setShortcutContext(Qt.WidgetShortcut)
        act.triggered.connect(
            lambda *args: self.model().removeRow(self.current_row()))
        self.addAction(act)


class QtLayerArtistContainer(LayerArtistContainer):
    """A subclass of LayerArtistContainer that dispatches to a
    LayerArtistModel"""
    def __init__(self):
        super(QtLayerArtistContainer, self).__init__()
        self.model = LayerArtistModel(self.artists)

    def append(self, artist):
        self._check_duplicate(artist)
        self.model.add_artist(0, artist)
        artist.zorder = max(a.zorder for a in self.artists) + 1
        assert self.artists[0] is artist

    def remove(self, artist):
        try:
            index = self.artists.index(artist)
        except ValueError:
            return
        self.model.removeRow(index)
        assert artist not in self.artists

    def __nonzero__(self):
        return True

########NEW FILE########
__FILENAME__ = link_editor
from ..external.qt.QtGui import QDialog, QListWidgetItem, QWidget

from .. import core

from .qtutil import load_ui


class LinkEditor(object):

    def __init__(self, collection, functions=None, parent=None):
        self._collection = collection

        self._ui = load_ui('link_editor', parent)
        self._init_widgets()
        self._connect()
        if len(collection) > 1:
            self._ui.right_components.set_data_row(1)
        self._size = None

    def _init_widgets(self):
        self._ui.left_components.setup(self._collection)
        self._ui.right_components.setup(self._collection)
        self._ui.signature_editor.hide()
        for link in self._collection.links:
            self._add_link(link)

    def _connect(self):
        self._ui.add_link.clicked.connect(self._add_new_link)
        self._ui.remove_link.clicked.connect(self._remove_link)
        self._ui.toggle_editor.clicked.connect(self._toggle_advanced)
        self._ui.signature_editor._ui.addButton.clicked.connect(
            self._add_new_link)

    @property
    def advanced(self):
        return self._ui.signature_editor.isVisible()

    @advanced.setter
    def advanced(self, state):
        """Set whether the widget is in advanced state"""
        self._ui.signature_editor.setVisible(state)
        self._ui.toggle_editor.setText("Basic" if state else "Advanced")

    def _toggle_advanced(self):
        """Show or hide the signature editor widget"""
        self.advanced = not self.advanced

    def _selected_components(self):
        result = []
        id1 = self._ui.left_components.component
        id2 = self._ui.right_components.component
        if id1:
            result.append(id1)
        if id2:
            result.append(id2)
        return result

    def _simple_links(self):
        """Return identity links which connect the highlighted items
        in each component selector.

        Returns:
          A list of :class:`~glue.core.ComponentLink` objects
          If items are not selected in the component selectors,
          an empty list is returned
        """
        comps = self._selected_components()
        if len(comps) != 2:
            return []
        assert isinstance(comps[0], core.data.ComponentID), comps[0]
        assert isinstance(comps[1], core.data.ComponentID), comps[1]
        link1 = core.component_link.ComponentLink([comps[0]], comps[1])
        return [link1]

    def _add_link(self, link):
        current = self._ui.current_links
        item = QListWidgetItem(str(link))
        current.addItem(item)
        item.setHidden(link.hidden)
        current.set_data(item, link)

    def _add_new_link(self):
        if not self.advanced:
            links = self._simple_links()
        else:
            links = self._ui.signature_editor.links()
            self._ui.signature_editor.clear_inputs()

        for link in links:
            self._add_link(link)

    def links(self):
        current = self._ui.current_links
        return current.data.values()

    def _remove_link(self):
        current = self._ui.current_links
        item = current.currentItem()
        row = current.currentRow()
        if item is None:
            return
        current.drop_data(item)
        deleted = current.takeItem(row)
        assert deleted == item  # sanity check

    @classmethod
    def update_links(cls, collection):
        widget = cls(collection)
        isok = widget._ui.exec_()
        if isok:
            links = widget.links()
            collection.set_links(links)


def main():
    import numpy as np
    from glue.core import Data, DataCollection

    x = np.array([1, 2, 3])
    d = Data(label='data', x=x, y=x * 2)
    dc = DataCollection(d)

    LinkEditor.update_links(dc)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = link_equation
from inspect import getargspec

from ..external.qt.QtGui import (QWidget, QHBoxLayout, QVBoxLayout,
                                 QLabel, QLineEdit)

from ..external.qt.QtGui import QSpacerItem, QSizePolicy

from .. import core
from ..core.odict import OrderedDict
from .qtutil import load_ui, is_pyside


def function_label(function):
    """ Provide a label for a function

    :param function: A member from the glue.config.link_function registry
    """
    name = function.function.__name__
    args = getargspec(function.function)[0]
    args = ', '.join(args)
    output = function.output_labels
    output = ', '.join(output)
    label = "Link from %s to %s" % (args, output)
    return label


def helper_label(helper):
    """ Provide a label for a link helper

    :param helper: A member from the glue.config.link_helper registry
    """
    return helper.info


class ArgumentWidget(QWidget):

    def __init__(self, argument, parent=None):
        super(ArgumentWidget, self).__init__(parent)
        self.layout = QHBoxLayout()
        self.layout.setContentsMargins(1, 0, 1, 1)
        self.setLayout(self.layout)
        label = QLabel(argument)
        self._label = label
        self._component_id = None
        self.layout.addWidget(label)
        self.editor = QLineEdit()
        self.editor.setReadOnly(True)
        try:
            self.editor.setPlaceholderText("Drag a component from above")
        except AttributeError:  # feature added in Qt 4.7
            pass
        self.layout.addWidget(self.editor)
        self.setAcceptDrops(True)

    @property
    def component_id(self):
        return self._component_id

    @component_id.setter
    def component_id(self, cid):
        self._component_id = cid
        self.editor.setText(str(cid))

    @property
    def label(self):
        return self._label.text()

    @label.setter
    def label(self, label):
        self._label.setText(label)

    @property
    def editor_text(self):
        return self.editor.text()

    def clear(self):
        self.component_id = None
        self.editor.clear()

    def dragEnterEvent(self, event):
        if event.mimeData().hasFormat('application/py_instance'):
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event):
        obj = event.mimeData().data('application/py_instance')
        if isinstance(obj, list):
            obj = obj[0]
        if not isinstance(obj, core.data.ComponentID):
            event.ignore()
            return
        self.component_id = obj
        event.accept()


class LinkEquation(QWidget):

    """ Interactively define ComponentLinks from existing functions

    This widget inspects the calling signatures of helper functions,
    and presents the user with an interface for assigning componentIDs
    to the input and output arguments. It also generates ComponentLinks
    from this information.

    ComponentIDs are assigned to arguments via drag and drop. This
    widget is used within the LinkEditor dialog

    Usage::

       widget = LinkEquation()
    """

    def __init__(self, parent=None):
        super(LinkEquation, self).__init__(parent)
        from ..config import link_function, link_helper
        # map of function/helper name -> function/helper tuple
        f = [f for f in link_function.members if len(f.output_labels) == 1]
        self._functions = OrderedDict((l[0].__name__, l) for l in
                                      f + link_helper.members)
        self._argument_widgets = []
        self.spacer = None
        self._output_widget = ArgumentWidget("")

        # pyqt4 can't take self as second argument here
        # for some reason. Manually embed
        self._ui = load_ui('link_equation', None)
        l = QHBoxLayout()
        l.addWidget(self._ui)
        self.setLayout(l)

        self._init_widgets()
        self._populate_function_combo()
        self._connect()
        self._setup_editor()

    def set_result_visible(self, state):
        self._ui.output_canvas.setVisible(state)
        self._ui.output_label.setVisible(state)

    def is_helper(self):
        return self.function is not None and \
            type(self.function).__name__ == 'LinkHelper'

    def is_function(self):
        return self.function is not None and \
            type(self.function).__name__ == 'LinkFunction'

    def _init_widgets(self):
        layout = QVBoxLayout()
        layout.setSpacing(1)
        self._ui.input_canvas.setLayout(layout)
        layout = QVBoxLayout()
        layout.setContentsMargins(1, 0, 1, 1)
        self._ui.output_canvas.setLayout(layout)
        layout.addWidget(self._output_widget)
        spacer = QSpacerItem(5, 5, QSizePolicy.Minimum, QSizePolicy.Expanding)
        layout.addItem(spacer)

    @property
    def add_button(self):
        return self._ui.addButton

    @property
    def signature(self):
        """ Returns the ComponentIDs assigned to the input and output arguments

        :rtype: tuple of (input, output). Input is a list of ComponentIDs.
                output is a ComponentID
        """
        inp = [a.component_id for a in self._argument_widgets]
        out = self._output_widget.component_id
        return inp, out

    @signature.setter
    def signature(self, inout):
        inp, out = inout
        for i, a in zip(inp, self._argument_widgets):
            a.component_id = i
        self._output_widget.component_id = out

    @property
    def function(self):
        """ The currently-selected function

        :rtype: A function or helper tuple
        """
        fname = str(self._ui.function.currentText())
        func = self._functions[fname]
        return func

    @function.setter
    def function(self, val):
        name = val[0].__name__
        pos = self._ui.function.findText(name)
        if pos < 0:
            raise KeyError("No function or helper found %s" % [val])
        self._ui.function.setCurrentIndex(pos)

    def links(self):
        """ Create ComponentLinks from the state of the widget

        :rtype: list of ComponentLinks that can be created.

        If no links can be created (e.g. because of missing input),
        the empty list is returned
        """
        inp, out = self.signature
        if self.is_function():
            using = self.function.function
            if not all(inp) or not out:
                return []
            link = core.component_link.ComponentLink(inp, out, using)
            return [link]
        if self.is_helper():
            helper = self.function.helper
            if not all(inp):
                return []
            return helper(*inp)

    def _update_add_enabled(self):
        state = True
        for a in self._argument_widgets:
            state = state and a.component_id is not None
        if self.is_function():
            state = state and self._output_widget.component_id is not None
        self._ui.addButton.setEnabled(state)

    def _connect(self):
        signal = self._ui.function.currentIndexChanged
        signal.connect(self._setup_editor)
        signal.connect(self._update_add_enabled)
        self._output_widget.editor.textChanged.connect(
            self._update_add_enabled)

    def clear_inputs(self):
        for w in self._argument_widgets:
            w.clear()
        self._output_widget.clear()

    def _setup_editor(self):
        if self.is_function():
            self._setup_editor_function()
        else:
            self._setup_editor_helper()

    def _setup_editor_function(self):
        """ Prepare the widget for the active function."""
        assert self.is_function()
        self.set_result_visible(True)
        func = self.function.function
        args = getargspec(func)[0]
        label = function_label(self.function)
        self._ui.info.setText(label)
        self._output_widget.label = self.function.output_labels[0]
        self._clear_input_canvas()
        for a in args:
            self._add_argument_widget(a)

        self.spacer = QSpacerItem(5, 5, QSizePolicy.Minimum,
                                  QSizePolicy.Expanding)
        self._ui.input_canvas.layout().addItem(self.spacer)

    def _setup_editor_helper(self):
        """Setup the editor for the selected link helper"""
        assert self.is_helper()
        self.set_result_visible(False)
        label = helper_label(self.function)
        args = self.function.input_labels
        self._ui.info.setText(label)

        self._clear_input_canvas()
        for a in args:
            self._add_argument_widget(a)

        self.spacer = QSpacerItem(5, 5, QSizePolicy.Minimum,
                                  QSizePolicy.Expanding)
        self._ui.input_canvas.layout().addItem(self.spacer)

    def _add_argument_widget(self, argument):
        """ Create and add a single argument widget to the input canvas
        :param arguement: The argument name (string)
        """
        widget = ArgumentWidget(argument)
        widget.editor.textChanged.connect(self._update_add_enabled)
        self._ui.input_canvas.layout().addWidget(widget)
        self._argument_widgets.append(widget)

    def _clear_input_canvas(self):
        """ Remove all widgets from the input canvas """
        layout = self._ui.input_canvas.layout()
        for a in self._argument_widgets:
            layout.removeWidget(a)
            a.close()

        if not is_pyside():
            # PySide crashing here
            layout.removeItem(self.spacer)

        self._argument_widgets = []

    def _populate_function_combo(self):
        """ Add name of functions to function combo box """
        self._ui.function.clear()
        for f in self._functions:
            self._ui.function.addItem(f)

########NEW FILE########
__FILENAME__ = mime
from ..external.qt.QtCore import QMimeData, QByteArray


class PyMimeData(QMimeData):
    """
    A custom MimeData object that stores live python objects

    Associate specific objects with a mime type by passing
    mime type / object kev/value pairs to the __init__ method

    If a single object is passed to the init method, that
    object is associated with the PyMimeData.MIME_TYPE mime type
    """
    MIME_TYPE = 'application/py_instance'

    def __init__(self, instance=None, **kwargs):
        """
        :param instance: The python object to store

        kwargs: Optional mime type / objects pairs to store as objects
        """
        super(PyMimeData, self).__init__()

        self._instances = {}

        self.setData(self.MIME_TYPE, instance)
        for k, v in kwargs.items():
            self.setData(k, v)

    def formats(self):
        return list(set(super(PyMimeData, self).formats() +
                        self._instances.keys()))

    def hasFormat(self, fmt):
        return fmt in self._instances or super(PyMimeData, self).hasFormat(fmt)

    def setData(self, mime, data):
        super(PyMimeData, self).setData(mime, QByteArray('1'))
        self._instances[mime] = data

    def data(self, mime_type):
        """ Retrieve the data stored at the specified mime_type

        If mime_type is application/py_instance, a python object
        is returned. Otherwise, a QByteArray is returned """
        if str(mime_type) in self._instances:
            return self._instances[mime_type]

        return super(PyMimeData, self).data(mime_type)


#some standard glue mime types
LAYER_MIME_TYPE = 'glue/layer'
LAYERS_MIME_TYPE = 'glue/layers'
INSTANCE_MIME_TYPE = PyMimeData.MIME_TYPE

########NEW FILE########
__FILENAME__ = mouse_mode
"""MouseModes define various mouse gestures.

The :class:`~glue.qt.glue_toolbar.GlueToolbar` maintains a list of
MouseModes from the visualization it is assigned to, and sees to it
that only one MouseMode is active at a time.

Each MouseMode appears as an Icon in the GlueToolbar. Classes can
assign methods to the press_callback, move_callback, and
release_callback methods of each Mouse Mode, to implement custom
functionality

The basic usage pattern is thus:
 * visualization object instantiates the MouseModes it wants
 * each of these is passed to the add_mode method of the GlueToolbar
 * visualization object optionally attaches methods to the 3 _callback
   methods in a MouseMode, for additional behavior

"""
from ..external.qt.QtGui import QAction

from ..core import util
from ..core import roi
from ..core.callback_property import CallbackProperty
from . import get_qapp
from .qtutil import get_icon, nonpartial
from . import qt_roi


class MouseMode(object):

    """ The base class for all MouseModes.

    MouseModes have the following attributes:

    * Icon : QIcon object
    * action_text : The action title (used in some menus)
    * tool_tip : string giving the tool itp
    * shortcut : Keyboard shortcut to toggle the mode
    * _press_callback : Callback method that will be called
      whenever a MouseMode processes a mouse press event
    * _move_callback : Same as above, for move events
    * _release_callback : Same as above, for release events

    The _callback hooks are called with the MouseMode as its only
    argument
    """
    enabled = CallbackProperty(True)

    def __init__(self, axes,
                 press_callback=None,
                 move_callback=None,
                 release_callback=None,
                 key_callback=None):

        self.icon = None
        self.mode_id = None
        self.action_text = None
        self.tool_tip = None
        self._axes = axes
        self._press_callback = press_callback
        self._move_callback = move_callback
        self._release_callback = release_callback
        self._key_callback = key_callback
        self.shortcut = None
        self._event_x = None
        self._event_y = None
        self._event_xdata = None
        self._event_ydata = None

    def _log_position(self, event):
        if event is None:
            return
        self._event_x, self._event_y = event.x, event.y
        self._event_xdata, self._event_ydata = event.xdata, event.ydata

    def press(self, event):
        """ Handles mouse presses

        Logs mouse position and calls press_callback method

        :param event: Mouse event
        :type event: Matplotlib event
        """
        self._log_position(event)
        if self._press_callback is not None:
            self._press_callback(self)

    def move(self, event):
        """ Handles mouse move events

        Logs mouse position and calls move_callback method

        :param event: Mouse event
        :type event: Matplotlib event
        """
        self._log_position(event)
        if self._move_callback is not None:
            self._move_callback(self)

    def release(self, event):
        """ Handles mouse release events.

        Logs mouse position and calls release_callback method

        :param event: Mouse event
        :type event: Matplotlib event
        """
        self._log_position(event)
        if self._release_callback is not None:
            self._release_callback(self)

    def key(self, event):
        """ Handles key press events

        Calls key_callback method

        :param event: Key event
        :type event: Matplotlib event
        """
        if self._key_callback is not None:
            self._key_callback(self)

    def menu_actions(self):
        """ List of QActions to be attached to this mode as a context menu """
        return []


class RoiModeBase(MouseMode):

    """ Base class for defining ROIs. ROIs accessible via the roi() method

    See RoiMode and ClickRoiMode subclasses for interaction details

    Clients can provide an roi_callback function. When ROIs are
    finalized (i.e. fully defined), this function will be called with
    the RoiMode object as the argument. Clients can use RoiMode.roi()
    to retrieve the new ROI, and take the appropriate action.
    """
    persistent = False  # clear the shape when drawing completes?

    def __init__(self, axes, **kwargs):
        """
        :param roi_callback: Function that will be called when the
                             ROI is finished being defined.
        :type roi_callback:  function
        """
        self._roi_callback = kwargs.pop('roi_callback', None)
        super(RoiModeBase, self).__init__(axes, **kwargs)
        self._roi_tool = None

    def roi(self):
        """ The ROI defined by this mouse mode

        :rtype: :class:`~glue.core.roi.Roi`
        """
        return self._roi_tool.roi()

    def _finish_roi(self, event):
        """Called by subclasses when ROI is fully defined"""
        if not self.persistent:
            self._roi_tool.finalize_selection(event)
        if self._roi_callback is not None:
            self._roi_callback(self)


class RoiMode(RoiModeBase):

    """ Define Roi Modes via click+drag events

    ROIs are updated continuously on click+drag events, and finalized
    on each mouse release
    """

    def __init__(self, axes, **kwargs):
        super(RoiMode, self).__init__(axes, **kwargs)

        self._start_event = None
        self._drag = False
        app = get_qapp()
        self._drag_dist = app.startDragDistance()

    def _update_drag(self, event):
        if self._drag or self._start_event is None:
            return

        dx = abs(event.x - self._start_event.x)
        dy = abs(event.y - self._start_event.y)
        if (dx + dy) > self._drag_dist:
            self._roi_tool.start_selection(self._start_event)
            self._drag = True

    def press(self, event):
        self._start_event = event
        super(RoiMode, self).press(event)

    def move(self, event):
        self._update_drag(event)
        if self._drag:
            self._roi_tool.update_selection(event)
        super(RoiMode, self).move(event)

    def release(self, event):
        if self._drag:
            self._finish_roi(event)
        self._drag = False
        self._start_event = None

        super(RoiMode, self).release(event)


class PersistentRoiMode(RoiMode):

    """
    Same functionality as RoiMode, but the Roi is never
    finalized, and remains rendered after mouse gestures
    """

    def _finish_roi(self, event):
        if self._roi_callback is not None:
            self._roi_callback(self)


class ClickRoiMode(RoiModeBase):

    """
    Generate ROIs using clicks and click+drags.

    ROIs updated on each click, and each click+drag.
    ROIs are finalized on enter press, and reset on escape press
    """

    def __init__(self, axes, **kwargs):
        super(ClickRoiMode, self).__init__(axes, **kwargs)
        self._last_event = None

    def press(self, event):
        if not self._roi_tool.active():
            self._roi_tool.start_selection(event)
        else:
            self._roi_tool.update_selection(event)
        self._last_event = event
        super(ClickRoiMode, self).press(event)

    def move(self, event):
        if event.button is not None and self._roi_tool.active():
            self._roi_tool.update_selection(event)
            self._last_event = event
        super(ClickRoiMode, self).move(event)

    def key(self, event):
        if event.key == 'enter':
            self._finish_roi(self._last_event)
        elif event.key == 'escape':
            self._roi_tool.reset()
        super(ClickRoiMode, self).key(event)


class RectangleMode(RoiMode):

    """ Defines a Rectangular ROI, accessible via the roi() method"""

    def __init__(self, axes, **kwargs):
        super(RectangleMode, self).__init__(axes, **kwargs)
        self.icon = get_icon('glue_square')
        self.mode_id = 'Rectangle'
        self.action_text = 'Rectangular ROI'
        self.tool_tip = 'Define a rectangular region of interest'
        self._roi_tool = qt_roi.QtRectangularROI(self._axes)
        self.shortcut = 'R'


class PathMode(ClickRoiMode):
    persistent = True

    def __init__(self, axes, **kwargs):
        super(PathMode, self).__init__(axes, **kwargs)
        self.icon = get_icon('glue_slice')
        self.mode_id = 'Slice'
        self.action_text = 'Slice Extraction'
        self.tool_tip = 'Extract a slice from an arbitrary path'
        self._roi_tool = qt_roi.QtPathROI(self._axes)
        self.shortcut = 'P'

        self._roi_tool.plot_opts.update(edgecolor='#de2d26',
                                        facecolor=None,
                                        edgewidth=3,
                                        alpha=0.4)


class CircleMode(RoiMode):

    """ Defines a Circular ROI, accessible via the roi() method"""

    def __init__(self, axes, **kwargs):
        super(CircleMode, self).__init__(axes, **kwargs)
        self.icon = get_icon('glue_circle')
        self.mode_id = 'Circle'
        self.action_text = 'Circular ROI'
        self.tool_tip = 'Define a circular region of interest'
        self._roi_tool = qt_roi.QtCircularROI(self._axes)
        self.shortcut = 'C'


class PolyMode(ClickRoiMode):

    """ Defines a Polygonal ROI, accessible via the roi() method"""

    def __init__(self, axes, **kwargs):
        super(PolyMode, self).__init__(axes, **kwargs)
        self.icon = get_icon('glue_lasso')
        self.mode_id = 'Polygon'
        self.action_text = 'Polygonal ROI'
        self.tool_tip = 'Lasso a region of interest'
        self._roi_tool = qt_roi.QtPolygonalROI(self._axes)
        self.shortcut = 'G'


class LassoMode(RoiMode):

    """ Defines a Polygonal ROI, accessible via the roi() method"""

    def __init__(self, axes, **kwargs):
        super(LassoMode, self).__init__(axes, **kwargs)
        self.icon = get_icon('glue_lasso')
        self.mode_id = 'Lasso'
        self.action_text = 'Polygonal ROI'
        self.tool_tip = 'Lasso a region of interest'
        self._roi_tool = qt_roi.QtPolygonalROI(self._axes)
        self.shortcut = 'L'


class HRangeMode(RoiMode):

    """ Defines a Range ROI, accessible via the roi() method.
    This class defines horizontal ranges"""

    def __init__(self, axes, **kwargs):
        super(HRangeMode, self).__init__(axes, **kwargs)
        self.icon = get_icon('glue_xrange_select')
        self.mode_id = 'X range'
        self.action_text = 'X range'
        self.tool_tip = 'Select a range of x values'
        self._roi_tool = qt_roi.QtXRangeROI(self._axes)
        self.shortcut = 'H'


class VRangeMode(RoiMode):

    """ Defines a Range ROI, accessible via the roi() method.
    This class defines vertical ranges"""

    def __init__(self, axes, **kwargs):
        super(VRangeMode, self).__init__(axes, **kwargs)
        self.icon = get_icon('glue_yrange_select')
        self.mode_id = 'Y range'
        self.action_text = 'Y range'
        self.tool_tip = 'Select a range of y values'
        self._roi_tool = qt_roi.QtYRangeROI(self._axes)
        self.shortcut = 'V'


class ContrastMode(MouseMode):

    """Uses right mouse button drags to set bias and contrast, ala DS9

    The horizontal position of the mouse sets the bias, the vertical
    position sets the contrast. The get_scaling method converts
    this information into scaling information for a particular data set
    """

    def __init__(self, *args, **kwargs):
        super(ContrastMode, self).__init__(*args, **kwargs)
        self.icon = get_icon('glue_contrast')
        self.mode_id = 'Contrast'
        self.action_text = 'Contrast'
        self.tool_tip = 'Adjust the bias/contrast'
        self.shortcut = 'B'

        self.bias = 0.5
        self.contrast = 1.0

        self._last = None
        self._result = None
        self._percent_lo = 1.
        self._percent_hi = 99.
        self.stretch = 'linear'

    def set_clip_percentile(self, lo, hi):
        """Percentiles at which to clip the data at black/white"""
        if lo == self._percent_lo and hi == self._percent_hi:
            return
        self._percent_lo = lo
        self._percent_hi = hi

    def get_clip_percentile(self):
        return self._percent_lo, self._percent_hi

    def move(self, event):
        """ MoveEvent. Update bias and contrast on Right Mouse button drag """
        if event.button != 3:  # RMB drag only
            return
        x, y = event.x, event.y
        dx, dy = self._axes.figure.canvas.get_width_height()
        x = 1.0 * x / dx
        y = 1.0 * y / dy

        self.bias = x
        self.contrast = (1 - y) * 10

        super(ContrastMode, self).move(event)

    def menu_actions(self):
        result = []

        a = QAction("minmax", None)
        a.triggered.connect(nonpartial(self.set_clip_percentile, 0, 100))
        result.append(a)

        a = QAction("99%", None)
        a.triggered.connect(nonpartial(self.set_clip_percentile, 1, 99))
        result.append(a)

        a = QAction("95%", None)
        a.triggered.connect(nonpartial(self.set_clip_percentile, 5, 95))
        result.append(a)

        a = QAction("90%", None)
        a.triggered.connect(nonpartial(self.set_clip_percentile, 10, 90))
        result.append(a)

        a = QAction("", None)
        a.setSeparator(True)
        result.append(a)

        a = QAction("linear", None)
        a.triggered.connect(nonpartial(setattr, self, 'stretch', 'linear'))
        result.append(a)

        a = QAction("log", None)
        a.triggered.connect(nonpartial(setattr, self, 'stretch', 'log'))
        result.append(a)

        a = QAction("power", None)
        a.triggered.connect(nonpartial(setattr, self, 'stretch', 'power'))
        result.append(a)

        a = QAction("square root", None)
        a.triggered.connect(nonpartial(setattr, self, 'stretch', 'sqrt'))
        result.append(a)

        a = QAction("squared", None)
        a.triggered.connect(nonpartial(setattr, self, 'stretch', 'squared'))
        result.append(a)

        a = QAction("asinh", None)
        a.triggered.connect(nonpartial(setattr, self, 'stretch', 'arcsinh'))
        result.append(a)

        for r in result:
            if self._move_callback is not None:
                r.triggered.connect(nonpartial(self._move_callback, self))

        return result


class SpectrumExtractorMode(RoiMode):

    """
    Let's the user select a region in an image and,
    when connected to a SpectrumExtractorTool, uses this
    to display spectra extracted from that position
    """
    persistent = True

    def __init__(self, axes, **kwargs):
        super(SpectrumExtractorMode, self).__init__(axes, **kwargs)
        self.icon = get_icon('glue_spectrum')
        self.mode_id = 'Spectrum'
        self.action_text = 'Spectrum'
        self.tool_tip = 'Extract a spectrum from the selection'
        self._roi_tool = qt_roi.QtRectangularROI(self._axes)
        self._roi_tool.plot_opts.update(edgecolor='#c51b7d',
                                        facecolor=None,
                                        edgewidth=3,
                                        alpha=1.0)
        self.shortcut = 'S'

    def clear(self):
        self._roi_tool.reset()


class ContourMode(MouseMode):

    """ Creates ROIs by using the mouse to 'pick' contours out of the data """

    def __init__(self, *args, **kwargs):
        super(ContourMode, self).__init__(*args, **kwargs)

        self.icon = get_icon("glue_contour")
        self.mode_id = 'Contour'
        self.action_text = 'Contour'
        self.tool_tip = 'Define a region of intrest via contours'
        self.shortcut = 'N'

    def roi(self, data):
        """Caculate an ROI as the contour which passes through the mouse

        :param data: The data set to use
        :type data: ndarray

        Returns

           * A :class:`~glue.core.roi.PolygonalROI` object, or None if one
             could not be calculated

        This method calculates the (single) contour that passes
        through the mouse location, and uses this path to define
        a new ROI
        """
        x, y = self._event_xdata, self._event_ydata
        return contour_to_roi(x, y, data)


def contour_to_roi(x, y, data):
    """ Return a PolygonalROI for the contour that passes through (x,y) in data

    :param x: x coordinate
    :param y: y coordinate
    :param data: data
    :type data: numpy array

    Returns:
       * A :class:`~glue.core.roi.PolygonalROI` instance
    """
    if x is None or y is None:
        return None

    xy = util.point_contour(x, y, data)
    if xy is None:
        return None

    p = roi.PolygonalROI(vx=xy[:, 0], vy=xy[:, 1])
    return p

########NEW FILE########
__FILENAME__ = qtutil
"""
Various standalone utility code for
working with Qt
"""
import os

import pkg_resources
from matplotlib.colors import ColorConverter
from matplotlib import cm
import numpy as np

from ..external.axescache import AxesCache
from ..external.qt import QtGui
from ..external.qt.QtCore import Qt, QThread
from ..external.qt.QtGui import (QColor, QInputDialog, QColorDialog,
                                 QListWidget, QTreeWidget, QPushButton,
                                 QMessageBox,
                                 QTabBar, QBitmap, QIcon, QPixmap, QImage,
                                 QWidget,
                                 QLabel, QGridLayout,
                                 QRadioButton, QButtonGroup, QCheckBox)

from .decorators import set_cursor
from .mime import PyMimeData, LAYERS_MIME_TYPE
from ..external.qt import is_pyside
from ..external.qt.QtCore import Signal
from .. import core
from . import ui, icons


def mpl_to_qt4_color(color, alpha=1.0):
    """ Convert a matplotlib color stirng into a Qt QColor object

    :param color:
       A color specification that matplotlib understands
    :type color: str

    :param alpha:
       Optional opacity. Float in range [0,1]
    :type alpha: float

    * Returns *
    A QColor object representing color

    :rtype: QColor
    """
    if color in [None, 'none', 'None']:
        return QColor(0, 0, 0, 0)

    cc = ColorConverter()
    r, g, b = cc.to_rgb(color)
    alpha = max(0, min(255, int(256 * alpha)))
    return QColor(r * 255, g * 255, b * 255, alpha)


def qt4_to_mpl_color(color):
    """
    Convert a QColor object into a string that matplotlib understands

    Note: This ignores opacity

    :param color: QColor instance

    *Returns*
        A hex string describing that color
    """
    hexid = color.name()
    return str(hexid)


def data_wizard():
    """ QT Dialog to load a file into a new data object

    Returns:
       A list of new data objects. Returns an empty list if
       selection is canceled.
    """
    def report_error(error, factory):
        import traceback
        retry = QMessageBox.Retry
        cancel = QMessageBox.Cancel
        buttons = retry | cancel
        detail = traceback.format_exc()
        msg = "\n".join(["Could not load data (wrong load method?)",
                         "File load method: %s" % factory.label])
        detail = "\n\n".join(["Error message: %s" % error, detail])
        mb = QMessageBox(QMessageBox.Critical, "Data Load Error", msg)
        mb.setDetailedText(detail)
        mb.setDefaultButton(cancel)
        mb.setStandardButtons(buttons)
        ok = mb.exec_()
        return ok == retry

    while True:
        gdd = GlueDataDialog()
        try:
            result = gdd.load_data()
            break
        except Exception as e:
            decision = report_error(e, gdd.factory())
            if not decision:
                return []
    return result


class GlueDataDialog(object):

    def __init__(self, parent=None):
        self._fd = QtGui.QFileDialog(parent)
        from glue.config import data_factory
        self.filters = [(f, self._filter(f))
                        for f in data_factory.members]
        self.setNameFilter()
        self._fd.setFileMode(QtGui.QFileDialog.ExistingFiles)
        try:
            self._fd.setOption(QtGui.QFileDialog.Option.HideNameFilterDetails,
                               True)
        except AttributeError:  # HideNameFilterDetails not present
            pass

    def factory(self):
        fltr = self._fd.selectedNameFilter()
        for k, v in self.filters:
            if v.startswith(fltr):
                return k

    def setNameFilter(self):
        fltr = ";;".join([flt for fac, flt in self.filters])
        self._fd.setNameFilter(fltr)

    def _filter(self, factory):
        return "%s (*)" % factory.label

    def paths(self):
        """
        Return all selected paths, as a list of unicode strings
        """
        return self._fd.selectedFiles()

    def _get_paths_and_factory(self):
        """Show dialog to get a file path and data factory

        :rtype: tuple of (list-of-strings, func)
                giving the path and data factory.
                returns ([], None) if user cancels dialog
        """
        result = self._fd.exec_()
        if result == QtGui.QDialog.Rejected:
            return [], None
        path = map(str, self.paths())  # cast out of unicode
        factory = self.factory()
        return path, factory

    @set_cursor(Qt.WaitCursor)
    def load_data(self):
        """Highest level method to interactively load a data set.

        :rtype: A list of constructed data objects
        """
        from glue.core.data_factories import data_label
        paths, fac = self._get_paths_and_factory()
        result = []

        for path in paths:
            d = fac.function(path)
            if not isinstance(d, list):
                d.label = data_label(path)
                d = [d]
            result.extend(d)

        return result


def edit_layer_color(layer):
    """ Interactively edit a layer's color """
    initial = mpl_to_qt4_color(layer.style.color, alpha=layer.style.alpha)
    color = QColorDialog.getColor(initial, None, "Change layer color",
                                  options=QColorDialog.ShowAlphaChannel)
    if color.isValid():
        layer.style.color = qt4_to_mpl_color(color)
        layer.style.alpha = color.alpha() / 256.


def edit_layer_symbol(layer):
    """ Interactively edit a layer's symbol """
    options = ['o', '^', '*', 's']
    try:
        initial = options.index(layer.style.marker)
    except IndexError:
        initial = 0
    symb, isok = QInputDialog.getItem(None, 'Pick a Symbol',
                                      'Pick a Symbol',
                                      options, current=initial)
    if isok and symb != layer.style.marker:
        layer.style.marker = symb


def edit_layer_point_size(layer):
    """ Interactively edit a layer's point size """
    size, isok = QInputDialog.getInt(None, 'Point Size', 'Point Size',
                                     value=layer.style.markersize,
                                     min=1, max=1000, step=1)
    if isok and size != layer.style.markersize:
        layer.style.markersize = size


def edit_layer_label(layer):
    """ Interactively edit a layer's label """
    label, isok = QInputDialog.getText(None, 'New Label:', 'New Label:',
                                       text=layer.label)
    if isok and str(label) != layer.label:
        layer.label = str(label)


def pick_item(items, labels, title="Pick an item", label="Pick an item",
              default=0):
    """ Prompt the user to choose an item

    :param items: List of items to choose
    :param labels: List of strings to label items
    :param title: Optional widget title
    :param label: Optional prompt

    Returns the selected item, or None
    """
    choice, isok = QInputDialog.getItem(None, title, label,
                                        labels, current=default,
                                        editable=False)
    if isok:
        index = labels.index(str(choice))
        return items[index]


def pick_class(classes, **kwargs):
    """Prompt the user to pick from a list of classes using QT

    :param classes: list of class objects
    :param title: string of the prompt

    Returns:
       The class that was selected, or None
    """
    def _label(c):
        try:
            return c.LABEL
        except AttributeError:
            return c.__name__

    choices = [_label(c) for c in classes]
    return pick_item(classes, choices, **kwargs)


def get_text(title='Enter a label'):
    """Prompt the user to enter text using QT

    :param title: Name of the prompt

    *Returns*
       The text the user typed, or None
    """
    result, isok = QInputDialog.getText(None, title, title)
    if isok:
        return str(result)


class GlueItemWidget(object):

    """ A mixin for QListWidget/GlueTreeWidget subclasses, that
    provides drag+drop funtionality.
    """
    # Implementation detail: QXXWidgetItems are unhashable in PySide,
    # and cannot be used as dictionary keys. we hash on IDs instead

    def __init__(self, parent=None):
        super(GlueItemWidget, self).__init__(parent)
        self._mime_data = {}
        self.setDragEnabled(True)

    def mimeTypes(self):
        """Return the list of MIME Types supported for this object"""
        types = [LAYERS_MIME_TYPE]
        return types

    def mimeData(self, selected_items):
        """Return a list of MIME data associated with the each selected item

        :param selected_items: List of QListWidgetItems or QTreeWidgetItems
        :rtype: List of MIME objects
        """
        try:
            data = [self.get_data(i) for i in selected_items]
        except KeyError:
            data = None
        result = PyMimeData(data, **{LAYERS_MIME_TYPE: data})

        # apparent bug in pyside garbage collects custom mime
        # data, and crashes. Save result here to avoid
        self._mime = result

        return result

    def get_data(self, item):
        """Convenience method to fetch the data associated with a
        QxxWidgetItem"""
        # return item.data(Qt.UserRole)
        return self._mime_data[id(item)]

    def set_data(self, item, data):
        """Convenience method to set data associated with a QxxWidgetItem"""
        #item.setData(Qt.UserRole, data)
        self._mime_data[id(item)] = data

    def drop_data(self, item):
        self._mime_data.pop(id(item))

    @property
    def data(self):
        return self._mime_data


POINT_ICONS = {'o': 'glue_circle_point',
               's': 'glue_box_point',
               '^': 'glue_triangle_up',
               '*': 'glue_star',
               '+': 'glue_cross'}


def symbol_icon(symbol, color=None):
    bm = QBitmap(icon_path(POINT_ICONS.get(symbol, 'glue_circle')))

    if color is not None:
        return QIcon(tint_pixmap(bm, color))

    return QIcon(bm)


def layer_icon(layer):
    """Create a QIcon for a Data or Subset instance

    :type layer: :class:`~glue.core.data.Data`,
                 :class:`~glue.core.subset.Subset`,
                 or object with a .style attribute

    :rtype: QIcon
    """
    icon = POINT_ICONS.get(layer.style.marker, 'circle_point')

    bm = QBitmap(icon_path(icon))
    color = mpl_to_qt4_color(layer.style.color)
    pm = tint_pixmap(bm, color)
    return QIcon(pm)


def layer_artist_icon(artist):
    """Create a QIcon for a LayerArtist instance"""
    from ..clients.layer_artist import ImageLayerArtist

    if not artist.enabled:
        bm = QBitmap(icon_path('glue_delete'))
    elif isinstance(artist, ImageLayerArtist):
        bm = QBitmap(icon_path('glue_image'))
    else:
        bm = QBitmap(icon_path(POINT_ICONS.get(artist.layer.style.marker,
                                               'glue_circle_point')))
    color = mpl_to_qt4_color(artist.layer.style.color)

    pm = tint_pixmap(bm, color)
    return QIcon(pm)


def tint_pixmap(bm, color):
    """Re-color a monochrome pixmap object using `color`

    :param bm: QBitmap instance
    :param color: QColor instance

    :rtype: QPixmap. The new pixma;
    """
    if bm.depth() != 1:
        raise TypeError("Input pixmap must have a depth of 1: %i" % bm.depth())

    image = bm.toImage()
    image.setColor(1, color.rgba())
    image.setColor(0, QColor(0, 0, 0, 0).rgba())

    result = QPixmap.fromImage(image)
    return result


class GlueListWidget(GlueItemWidget, QListWidget):
    pass


class GlueTreeWidget(GlueItemWidget, QTreeWidget):
    pass


class GlueActionButton(QPushButton):

    def set_action(self, action, text=True):
        self._text = text
        self._action = action
        self.clicked.connect(action.trigger)
        action.changed.connect(self._sync_to_action)
        self._sync_to_action()

    def _sync_to_action(self):
        self.setIcon(self._action.icon())
        if self._text:
            self.setText(self._action.text())
        self.setToolTip(self._action.toolTip())
        self.setWhatsThis(self._action.whatsThis())
        self.setEnabled(self._action.isEnabled())


class GlueTabBar(QTabBar):

    def __init__(self, *args, **kwargs):
        super(GlueTabBar, self).__init__(*args, **kwargs)

    def rename_tab(self, index=None):
        """ Prompt user to rename a tab
        :param index: integer. Index of tab to edit. Defaults to current index
        """
        index = index or self.currentIndex()
        label = get_text("New Tab Label")
        if not label:
            return
        self.setTabText(index, label)

    def mouseDoubleClickEvent(self, event):
        if event.button() != Qt.LeftButton:
            return
        index = self.tabAt(event.pos())
        if index >= 0:
            self.rename_tab(index)


def cmap2pixmap(cmap, steps=50):
    """Convert a maplotlib colormap into a QPixmap

    :param cmap: The colormap to use
    :type cmap: Matplotlib colormap instance (e.g. matplotlib.cm.gray)
    :param steps: The number of color steps in the output. Default=50
    :type steps: int

    :rtype: QPixmap
    """
    sm = cm.ScalarMappable(cmap=cmap)
    sm.norm.vmin = 0.0
    sm.norm.vmax = 1.0
    inds = np.linspace(0, 1, steps)
    rgbas = sm.to_rgba(inds)
    rgbas = [QColor(int(r * 255), int(g * 255),
                    int(b * 255), int(a * 255)).rgba() for r, g, b, a in rgbas]
    im = QImage(steps, 1, QImage.Format_Indexed8)
    im.setColorTable(rgbas)
    for i in range(steps):
        im.setPixel(i, 0, i)
    im = im.scaled(100, 100)
    pm = QPixmap.fromImage(im)
    return pm


def pretty_number(numbers):
    """Convert a list of numbers into a nice list of strings

    :param numbers: Numbers to convert
    :type numbers: List or other iterable of numbers

    :rtype: A list of strings
    """
    try:
        return [pretty_number(n) for n in numbers]
    except TypeError:
        pass

    n = numbers
    if n == 0:
        result = '0'
    elif (abs(n) < 1e-3) or (abs(n) > 1e3):
        result = "%0.3e" % n
    elif abs(int(n) - n) < 1e-3 and int(n) != 0:
        result = "%i" % n
    else:
        result = "%0.3f" % n
    if result.find('.') != -1:
        result = result.rstrip('0')

    return result


class RGBEdit(QWidget):

    """A widget to set the contrast for individual layers in an RGB image

    Based off the ds9 RGB Frame widget

    :param artist: A :class:`~glue.clients.layer_artists.RGBLayerArtist`
                   instance to control

    :param parent: Optional widget parent

    This widget sets the state of the artist object, such that contrast
    adjustments from a :class:`~glue.clients.image_client` affect
    a particular RGB slice
    """
    current_changed = Signal(str)
    colors_changed = Signal()

    def __init__(self, parent=None, artist=None):
        super(RGBEdit, self).__init__(parent)
        self._artist = artist

        l = QGridLayout()

        current = QLabel("Contrast")
        visible = QLabel("Visible")
        l.addWidget(current, 0, 2, 1, 1)
        l.addWidget(visible, 0, 3, 1, 1)
        l.setColumnStretch(0, 0)
        l.setColumnStretch(1, 10)
        l.setColumnStretch(2, 0)
        l.setColumnStretch(3, 0)

        l.setRowStretch(0, 0)
        l.setRowStretch(1, 0)
        l.setRowStretch(2, 0)
        l.setRowStretch(3, 0)
        l.setRowStretch(4, 10)

        curr_grp = QButtonGroup()
        self.current = {}
        self.vis = {}
        self.cid = {}

        for row, color in enumerate(['red', 'green', 'blue'], 1):
            lbl = QLabel(color.title())

            cid = ComponentIDCombo()

            curr = QRadioButton()
            curr_grp.addButton(curr)

            vis = QCheckBox()
            vis.setChecked(True)

            l.addWidget(lbl, row, 0, 1, 1)
            l.addWidget(cid, row, 1, 1, 1)
            l.addWidget(curr, row, 2, 1, 1)
            l.addWidget(vis, row, 3, 1, 1)

            curr.clicked.connect(self.update_current)
            vis.toggled.connect(self.update_visible)
            cid.currentIndexChanged.connect(self.update_layers)

            self.cid[color] = cid
            self.vis[color] = vis
            self.current[color] = curr

        self.setLayout(l)
        self.current['red'].click()

    @property
    def attributes(self):
        """A 3-tuple of the ComponentIDs for each RGB layer"""
        return tuple(self.cid[c].component for c in ['red', 'green', 'blue'])

    @attributes.setter
    def attributes(self, cids):
        for cid, c in zip(cids, ['red', 'green', 'blue']):
            if cid is None:
                continue
            self.cid[c].component = cid

    @property
    def rgb_visible(self):
        """ A 3-tuple of the visibility of each layer, as bools """
        return tuple(self.vis[c].isChecked() for c in ['red', 'green', 'blue'])

    @rgb_visible.setter
    def rgb_visible(self, value):
        for v, c in zip(value, 'red green blue'.split()):
            self.vis[c].setChecked(v)

    @property
    def artist(self):
        return self._artist

    @artist.setter
    def artist(self, value):
        self._artist = value
        for cid in self.cid.values():
            cid.data = value.layer

    def update_layers(self):
        if self.artist is None:
            return

        r = self.cid['red'].component
        g = self.cid['green'].component
        b = self.cid['blue'].component
        changed = self.artist.r is not r or \
            self.artist.g is not g or\
            self.artist.b is not b

        self.artist.r = r
        self.artist.g = g
        self.artist.b = b

        if changed:
            self.colors_changed.emit()

        self.artist.update()
        self.artist.redraw()

    def update_current(self, *args):
        if self.artist is None:
            return

        for c in ['red', 'green', 'blue']:
            if self.current[c].isChecked():
                self.artist.contrast_layer = c
                self.current_changed.emit(c)
                break
        else:
            raise RuntimeError("Could not determine which layer is current")

    def update_visible(self, *args):
        if self.artist is None:
            return

        self.artist.layer_visible['red'] = self.vis['red'].isChecked()
        self.artist.layer_visible['green'] = self.vis['green'].isChecked()
        self.artist.layer_visible['blue'] = self.vis['blue'].isChecked()
        self.artist.update()
        self.artist.redraw()


class GlueComboBox(QtGui.QComboBox):

    """ Modification of QComboBox, that sidesteps PySide
    sefgaults when storing some python objects as user data
    """

    def __init__(self, parent=None):
        super(GlueComboBox, self).__init__(parent)
        self._data = []

    def addItem(self, text, userData=None):
        # set before super, since super may trigger signals
        self._data.append(userData)
        super(GlueComboBox, self).addItem(text)

    def addItems(self, items):
        self._data.extend(None for _ in items)
        super(GlueComboBox, self).addItems(items)

    def itemData(self, index, role=Qt.UserRole):
        assert len(self._data) == self.count()
        if role != Qt.UserRole:
            return super(GlueComboBox, self).itemData(index, role)
        return self._data[index]

    def setItemData(self, index, value, role=Qt.UserRole):
        if role != Qt.UserRole:
            return super(GlueComboBox, self).setItemData(index, value, role)
        self._data[index] = value

    def clear(self):
        self._data = []
        return super(GlueComboBox, self).clear()

    def insertItem(self, *args):
        raise NotImplementedError()

    def insertItems(self, *args):
        raise NotImplementedError()

    def insertSeparator(self, index):
        raise NotImplementedError()

    def removeItem(self, index):
        self._data.pop(index)
        return super(GlueComboBox, self).removeItem(index)


def _custom_widgets():
    # iterate over custom widgets referenced in .ui files
    yield GlueListWidget
    yield GlueComboBox
    yield GlueActionButton
    yield RGBEdit

    from .component_selector import ComponentSelector
    yield ComponentSelector

    from .link_equation import LinkEquation
    yield LinkEquation


def _load_ui_pyside(path, parent):
    from PySide.QtUiTools import QUiLoader
    loader = QUiLoader()

    # must register custom widgets referenced in .ui files
    for w in _custom_widgets():
        loader.registerCustomWidget(w)

    widget = loader.load(path, parent)

    return widget


def _load_ui_pyqt4(path, parent):
    from PyQt4.uic import loadUi
    return loadUi(path, parent)


def load_ui(name, parent=None):
    """
    Load a UI file, given it's name

    Parameters
    ----------
    name : str
      Name of ui file to load (without .ui extension)

    parent : QObject
      Object to use as the parent of this widget

    Returns
    -------
    w : QWidget
      The new widget
    """
    path = ui_path(name)
    if is_pyside():
        return _load_ui_pyside(path, parent)
    return _load_ui_pyqt4(path, parent)


def ui_path(ui_name):
    """Return the absolute path to a .ui file

    Parameters
    ----------
    ui_name : str
      The name of a ui_file to load (without directory prefix or
      file extensions)

    Returns
    -------
    path : str
      Path of a file
    """
    if not ui_name.endswith('.ui'):
        ui_name = ui_name + '.ui'

    try:
        result = pkg_resources.resource_filename('glue.qt.ui', ui_name)
        return result
    except NotImplementedError:
        # workaround for mac app
        result = os.path.dirname(ui.__file__)
        return os.path.join(result.replace('site-packages.zip', 'glue'),
                            ui_name)


def icon_path(icon_name):
    """Return the absolute path to an icon

    Parameters
    ----------
    icon_name : str
       Name of icon, without extension or directory prefix

    Returns
    -------
    path : str
      Full path to icon
    """
    if not icon_name.endswith('.png'):
        icon_name += '.png'

    try:
        rc = icon_name
        if pkg_resources.resource_exists('glue.qt.icons', rc):
            result = pkg_resources.resource_filename('glue.qt.icons', rc)
            return result
        else:
            raise RuntimeError("Icon does not exist: %s" % icon_name)
    except NotImplementedError:  # workaround for mac app
        result = os.path.dirname(icons.__file__)
        return os.path.join(result.replace('site-packages.zip', 'glue'),
                            icon_name)


def get_icon(icon_name):
    """
    Build a QIcon from an image name

    Parameters
    ----------
    icon_name : str
      Name of image file. Assumed to be a png file in glue/qt/icons
      Do not include the extension

    Returns
    -------
    A QIcon object
    """
    return QIcon(icon_path(icon_name))


class ComponentIDCombo(QtGui.QComboBox, core.HubListener):

    """ A widget to select among componentIDs in a dataset """

    def __init__(self, data=None, parent=None, visible_only=True):
        QtGui.QComboBox.__init__(self, parent)
        self._data = data
        self._visible_only = visible_only

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, value):
        if value is None:
            return
        self._data = value
        if value.hub is not None:
            self.register_to_hub(value.hub)
        self.refresh_components()

    @property
    def component(self):
        return self.itemData(self.currentIndex())

    @component.setter
    def component(self, value):
        for i in range(self.count()):
            if self.itemData(i) is value:
                self.setCurrentIndex(i)
                return
        else:
            raise ValueError("Unable to select %s" % value)

    def refresh_components(self):
        if self.data is None:
            return

        self.blockSignals(True)
        old_data = self.itemData(self.currentIndex())

        self.clear()
        if self._visible_only:
            fields = self.data.visible_components
        else:
            fields = self.data.components

        index = 0
        for i, f in enumerate(fields):
            self.addItem(f.label, userData=f)
            if f == old_data:
                index = i

        self.blockSignals(False)
        self.setCurrentIndex(index)

    def register_to_hub(self, hub):
        hub.subscribe(self,
                      core.message.ComponentsChangedMessage,
                      handler=lambda x: self.refresh_components,
                      filter=lambda x: x.data is self._data)


def cache_axes(axes, toolbar):
    """ Setup an caching for an axes object

    After this, cached renders will be used to quickly
    re-render an axes during window resizing or
    interactive pan/zooming.

    :param axes: The matplotlib Axes object to cache
    :param toolbar: The GlueToolbar managing the axes' canvas

    :rtype: The AxesCache instance
    """
    canvas = axes.figure.canvas
    cache = AxesCache(axes)
    canvas.resize_begin.connect(cache.enable)
    canvas.resize_end.connect(cache.disable)
    toolbar.pan_begin.connect(cache.enable)
    toolbar.pan_end.connect(cache.disable)
    return cache


if __name__ == "__main__":
    from glue.qt import get_qapp

    class Foo(object):
        layer_visible = {}
        layer = None

        def update(self):
            print 'update', self.layer_visible

        def redraw(self):
            print 'draw'

    app = get_qapp()
    f = Foo()

    rgb = RGBEdit()
    rgb.show()
    app.exec_()

    print f.layer_visible
    print f.contrast_layer


def nonpartial(func, *args, **kwargs):
    """Like functools.partial, this returns a function which,
    when called, calls func(*args, **kwargs). Unlike functools.partial,
    extra arguments passed to the returned function are *not* passed
    to the input function.

    This is used when connecting slots to QAction.triggered signals,
    which appear to have different signatures, which seem to add
    and extra argument in PyQt4 but not PySide
    """
    def result(*a, **k):
        return func(*args, **kwargs)

    return result


class Worker(QThread):
    result = Signal(object)
    error = Signal(object)

    def __init__(self, func, *args, **kwargs):
        """
        Execute a function call on a different QThread

        :param func: The function object to call
        :param args: arguments to pass to the function
        :param kwargs: kwargs to pass to the function
        """
        super(Worker, self).__init__()
        self.func = func
        self.args = args
        self.kwargs = kwargs

    def run(self):
        """
        Invoke the function
        Upon successful completion, the result signal will be fired
        with the output of the function
        If an exception occurs, the error signal will be fired with
        the result form sys.exc_infno()
        """
        try:
            result = self.func(*self.args, **self.kwargs)
            self.result.emit(result)
        except:
            import sys
            self.error.emit(sys.exc_info())

########NEW FILE########
__FILENAME__ = qt_roi
import numpy as np

from ..core import roi
from ..external.qt import QtGui, QtCore
from ..external.qt.QtCore import Qt
from .qtutil import mpl_to_qt4_color


class QtROI(object):

    """
    A mixin class used to override the drawing methods used by
    the MPL ROIs in core.roi. Paints to the Widget directly,
    avoiding calls that redraw the entire matplotlib plot.

    This permits smoother ROI selection for dense plots
    that take long to render
    """

    def setup_patch(self):
        pass

    def _draw(self):
        pass

    def _sync_patch(self):
        self.canvas.roi_callback = self._paint_check
        self.canvas.update()  # QT repaint without MPL redraw

    @property
    def canvas(self):
        return self._ax.figure.canvas

    def _paint_check(self, canvas):
        # check if the ROI should be rendered
        # called within the Qt paint loop
        if not (self._roi.defined() and self._mid_selection):
            return
        self.paint(canvas)

    def paint(self, canvas):
        x, y = self._roi.to_polygon()
        self.draw_polygon(canvas, x, y)

    def draw_polygon(self, canvas, x, y):
        x, y = self._transform(x, y)
        poly = QtGui.QPolygon()
        points = [QtCore.QPoint(xx, yy) for xx, yy in zip(x, y)]
        for p in points:
            poly.append(p)

        p = self.get_painter(canvas)
        p.drawPolygon(poly)
        p.end()

    def _transform(self, x, y):
        """ Convert points from MPL data coords to Qt Widget coords"""
        t = self._ax.transData
        xy = np.column_stack((x, y))
        pts = t.transform(xy)
        pts[:, 1] = self.canvas.height() - pts[:, 1]
        return pts[:, 0], pts[:, 1]

    def get_painter(self, canvas):
        p = QtGui.QPainter(canvas)
        facecolor = mpl_to_qt4_color(self.plot_opts['facecolor'],
                                     self.plot_opts['alpha'])
        edgecolor = mpl_to_qt4_color(self.plot_opts['edgecolor'],
                                     self.plot_opts['alpha'])

        pen = QtGui.QPen(edgecolor)
        pen.setWidth(self.plot_opts.get('edgewidth', 0))
        p.setPen(pen)

        p.setBrush(QtGui.QBrush(facecolor))

        return p


class QtPathROI(QtROI, roi.MplPathROI):

    def get_painter(self, canvas):
        p = super(QtPathROI, self).get_painter(canvas)
        p.setBrush(Qt.NoBrush)
        p.setRenderHint(p.HighQualityAntialiasing)
        return p

    def draw_polygon(self, canvas, x, y):
        x, y = self._transform(x, y)
        poly = QtGui.QPolygon()
        points = [QtCore.QPoint(xx, yy) for xx, yy in zip(x, y)]
        for p in points:
            poly.append(p)

        p = self.get_painter(canvas)
        p.drawPolyline(poly)
        p.end()


class QtRectangularROI(QtROI, roi.MplRectangularROI):

    def __init__(self, axes):
        roi.MplRectangularROI.__init__(self, axes)


class QtPolygonalROI(QtROI, roi.MplPolygonalROI):

    def __init__(self, axes):
        roi.MplPolygonalROI.__init__(self, axes)


class QtXRangeROI(QtROI, roi.MplXRangeROI):

    def __init__(self, axes):
        roi.MplXRangeROI.__init__(self, axes)

    def paint(self, canvas):
        x = self._roi.range()
        xy = self._ax.transAxes.transform([(0, 0), (1.0, 1.0)])
        xy = self._ax.transData.inverted().transform(xy)
        y = xy[:, 1]
        self.draw_polygon(canvas, [x[0], x[1], x[1], x[0]],
                                  [y[0], y[0], y[1], y[1]])


class QtYRangeROI(QtROI, roi.MplYRangeROI):

    def __init__(self, axes):
        roi.MplYRangeROI.__init__(self, axes)

    def paint(self, canvas):
        y = self._roi.range()
        xy = self._ax.transAxes.transform([(0, 0.0), (1.0, 1.0)])
        xy = self._ax.transData.inverted().transform(xy)
        x = xy[:, 0]
        self.draw_polygon(canvas, [x[0], x[1], x[1], x[0]],
                                  [y[0], y[0], y[1], y[1]])


class QtCircularROI(QtROI, roi.MplCircularROI):

    def __init__(self, axes):
        roi.MplCircularROI.__init__(self, axes)

    def paint(self, canvas):
        xy = map(int, self._roi.get_center())
        radius = int(self._roi.get_radius())
        center = QtCore.QPoint(xy[0], canvas.height() - xy[1])

        p = self.get_painter(canvas)
        p.drawEllipse(center, radius, radius)
        p.end()

########NEW FILE########
__FILENAME__ = simpleforms
from ..external.qt.QtGui import QSpinBox, QDoubleSpinBox, QCheckBox
from ..external.qt.QtCore import QObject, Signal

from ..core.simpleforms import IntOption, FloatOption, BoolOption
from .qtutil import nonpartial

_dispatch = {}


class FormItem(QObject):
    changed = Signal()

    def __init__(self, instance, option):
        super(FormItem, self).__init__()
        self.option = option
        self.instance = instance

    @property
    def label(self):
        return self.option.label


class NumberFormItem(FormItem):
    widget_cls = None

    def __init__(self, instance, option):
        super(NumberFormItem, self).__init__(instance, option)

        value = option.__get__(instance)

        w = self.widget_cls()
        w.setRange(option.min, option.max)
        w.setValue(value)
        w.valueChanged.connect(nonpartial(self.changed.emit))
        self.widget = w

    @property
    def value(self):
        return self.widget.value()


class IntFormItem(NumberFormItem):
    widget_cls = QSpinBox


class FloatFormItem(NumberFormItem):
    widget_cls = QDoubleSpinBox


class BoolFormItem(FormItem):

    def __init__(self, instance, option):
        super(BoolFormItem, self).__init__(instance, option)

        value = option.__get__(instance)
        self.widget = QCheckBox()
        self.widget.setChecked(value)
        self.widget.clicked.connect(nonpartial(self.changed.emit))

    @property
    def value(self):
        return self.widget.isChecked()


def build_form_item(instance, option_name):
    option = getattr(type(instance), option_name)
    option_type = type(option)
    return _dispatch[option_type](instance, option)


def register(option_cls, form_cls):
    _dispatch[option_cls] = form_cls


register(IntOption, IntFormItem)
register(FloatOption, FloatFormItem)
register(BoolOption, BoolFormItem)

########NEW FILE########
__FILENAME__ = spectrum_tool
import traceback

import numpy as np

from ..external.qt.QtCore import Qt, Signal
from ..external.qt.QtGui import (QMainWindow, QWidget,
                                 QHBoxLayout, QTabWidget,
                                 QComboBox, QFormLayout, QPushButton,
                                 QAction, QTextEdit, QFont, QDialog,
                                 QDialogButtonBox, QLineEdit,
                                 QDoubleValidator, QCheckBox, QGridLayout,
                                 QLabel, QMdiSubWindow)

from ..clients.profile_viewer import ProfileViewer
from .widgets.mpl_widget import MplWidget
from .mouse_mode import SpectrumExtractorMode
from ..core.callback_property import add_callback, ignore_callback
from ..core.util import Pointer
from ..core import Subset
from ..core.exceptions import IncompatibleAttribute
from .glue_toolbar import GlueToolbar
from .qtutil import load_ui, nonpartial, Worker
from .widget_properties import CurrentComboProperty
from ..core.aggregate import Aggregate
from .mime import LAYERS_MIME_TYPE
from .simpleforms import build_form_item
from ..config import fit_plugin


class Extractor(object):
    # Warning:
    # Coordinate conversion is not well-defined if pix2world is not
    # monotonic!

    @staticmethod
    def abcissa(data, axis):
        slc = [0 for _ in data.shape]
        slc[axis] = slice(None, None)
        att = data.get_world_component_id(axis)
        return data[att, tuple(slc)].ravel()

    @staticmethod
    def spectrum(data, attribute, roi, slc, zaxis):
        xaxis = slc.index('x')
        yaxis = slc.index('y')
        ndim, nz = data.ndim, data.shape[zaxis]

        l, r, b, t = roi.xmin, roi.xmax, roi.ymin, roi.ymax
        shp = data.shape
        l, r = np.clip([l, r], 0, shp[xaxis])
        b, t = np.clip([b, t], 0, shp[yaxis])

        # extract sub-slice, without changing dimension
        slc = [slice(s, s + 1)
               if s not in ['x', 'y'] else slice(None)
               for s in slc]
        slc[xaxis] = slice(l, r)
        slc[yaxis] = slice(b, t)
        slc[zaxis] = slice(None)
        x = Extractor.abcissa(data, zaxis)

        data = data[attribute, tuple(slc)]
        finite = np.isfinite(data)

        assert data.ndim == ndim

        for i in reversed(list(range(ndim))):
            if i != zaxis:
                data = np.nansum(data, axis=i)
                finite = finite.sum(axis=i)

        assert data.ndim == 1
        assert data.size == nz

        data = (1. * data / finite).ravel()
        return x, data

    @staticmethod
    def world2pixel(data, axis, value):
        x = Extractor.abcissa(data, axis)
        if x.size > 1 and (x[1] < x[0]):
            x = x[::-1]
            result = x.size - np.searchsorted(x, value) - 1
        else:
            result = np.searchsorted(x, value)
        return np.clip(result, 0, x.size - 1)

    @staticmethod
    def pixel2world(data, axis, value):
        x = Extractor.abcissa(data, axis)
        return x[np.clip(value, 0, x.size - 1)]

    @staticmethod
    def subset_spectrum(subset, attribute, slc, zaxis):
        """
        Extract a spectrum from a subset.

        This makes a mask of the subset in the **current slice**,
        and extracts a tube of this shape over all slices along ``zaxis``.
        In other words, the variation of the subset along ``zaxis`` is ignored,
        and only the interaction of the subset and the slice is relevant.

        :param subset: A :class:`~glue.core.subset.Subset`
        :param attribute: The :class:`~glue.core.data.ComponentID` to extract
        :param slc: A tuple describing the slice
        :param zaxis: Which axis to integrate over
        """
        data = subset.data
        x = Extractor.abcissa(data, zaxis)

        view = [slice(s, s + 1)
                if s not in ['x', 'y'] else slice(None)
                for s in slc]

        mask = np.squeeze(subset.to_mask(view))
        if slc.index('x') < slc.index('y'):
            mask = mask.T

        w = np.where(mask)
        view[slc.index('x')] = w[1]
        view[slc.index('y')] = w[0]

        result = np.empty(x.size)

        # treat each channel separately, to reduce memory storage
        for i in xrange(data.shape[zaxis]):
            view[zaxis] = i
            val = data[attribute, view]
            result[i] = np.nansum(val) / np.isfinite(val).sum()

        y = result

        return x, y


class SpectrumContext(object):
    client = Pointer('main.client')
    data = Pointer('main.data')
    profile_axis = Pointer('main.profile_axis')
    canvas = Pointer('main.canvas')
    profile = Pointer('main.profile')

    def __init__(self, main):

        self.main = main
        self.grip = None
        self.panel = None
        self.widget = None

        self._setup_grip()
        self._setup_widget()
        self._connect()

    def _setup_grip(self):
        raise NotImplementedError()

    def _setup_widget(self):
        raise NotImplementedError()

    def _connect(self):
        pass

    def set_enabled(self, enabled):
        self.enable() if enabled else self.disable()

    def enable(self):
        if self.grip is not None:
            self.grip.enable()

    def disable(self):
        if self.grip is not None:
            self.grip.disable()

    def recenter(self, lim):
        """Re-center the grip to the given x axlis limit tuple"""
        if self.grip is None:
            return
        if hasattr(self.grip, 'value'):
            self.grip.value = sum(lim) / 2.
            return

        # Range grip
        cen = sum(lim) / 2
        wid = max(lim) - min(lim)
        self.grip.range = cen - wid / 4, cen + wid / 4


class NavContext(SpectrumContext):

    def _setup_grip(self):
        def _set_client_from_grip(value):
            """Update client.slice given grip value"""
            slc = list(self.client.slice)

            # client.slice stored in pixel coords
            value = Extractor.world2pixel(
                self.data,
                self.profile_axis, value)
            slc[self.profile_axis] = value

            self.client.slice = tuple(slc)

        def _set_grip_from_client(slc):
            """Update grip.value given client.slice"""
            # grip.value is stored in world coordinates
            val = slc[self.profile_axis]
            val = Extractor.pixel2world(self.data, self.profile_axis, val)

            # If pix2world not monotonic, this can trigger infinite recursion.
            # Avoid by disabling callback loop
            # XXX better to specifically ignore _set_client_from_grip
            with ignore_callback(self.client, 'slice'):
                self.grip.value = val

        self.grip = self.main.profile.new_value_grip()

        add_callback(self.client, 'slice', _set_grip_from_client)
        add_callback(self.grip, 'value', _set_client_from_grip)

    def _connect(self):
        pass

    def _setup_widget(self):
        self.widget = QTextEdit()
        self.widget.setHtml("To <b> slide </b> through the cube, "
                            "drag the handle or double-click<br><br><br>"
                            "To make a <b> new profile </b>, "
                            "click-drag a new box in the image, or drag "
                            "a subset onto the plot to the left")
        self.widget.setTextInteractionFlags(Qt.NoTextInteraction)


class CollapseContext(SpectrumContext):

    def _setup_grip(self):
        self.grip = self.main.profile.new_range_grip()

    def _setup_widget(self):
        w = QWidget()
        l = QFormLayout()
        w.setLayout(l)

        combo = QComboBox()
        combo.addItem("Mean", userData=Aggregate.mean)
        combo.addItem("Median", userData=Aggregate.median)
        combo.addItem("Max", userData=Aggregate.max)
        combo.addItem("Centroid", userData=Aggregate.mom1)
        combo.addItem("Linewidth", userData=Aggregate.mom2)

        run = QPushButton("Collapse")
        self._run = run

        l.addRow("", combo)
        l.addRow("", run)
        self.widget = w
        self._combo = combo

    def _connect(self):
        self._run.clicked.connect(nonpartial(self._aggregate))

    def _aggregate(self):
        func = self._combo.itemData(self._combo.currentIndex())

        rng = list(self.grip.range)
        rng[1] += 1
        rng = Extractor.world2pixel(self.data,
                                    self.profile_axis,
                                    rng)

        agg = Aggregate(self.data, self.client.display_attribute,
                        self.main.profile_axis, self.client.slice, rng)

        im = func(agg)
        self.client.override_image(im)


class ConstraintsWidget(QWidget):

    def __init__(self, constraints, parent=None):
        super(ConstraintsWidget, self).__init__(parent)
        self.constraints = constraints

        self.layout = QGridLayout()
        self.layout.setContentsMargins(2, 2, 2, 2)
        self.layout.setSpacing(4)

        self.setLayout(self.layout)

        self.layout.addWidget(QLabel("Estimate"), 0, 1)
        self.layout.addWidget(QLabel("Fixed"), 0, 2)
        self.layout.addWidget(QLabel("Bounded"), 0, 3)
        self.layout.addWidget(QLabel("Lower Bound"), 0, 4)
        self.layout.addWidget(QLabel("Upper Bound"), 0, 5)

        self._widgets = {}
        names = sorted(list(self.constraints.keys()))

        for k in names:
            row = []
            w = QLabel(k)
            row.append(w)

            v = QDoubleValidator()
            e = QLineEdit()
            e.setValidator(v)
            e.setText(str(constraints[k]['value'] or ''))
            row.append(e)

            w = QCheckBox()
            w.setChecked(constraints[k]['fixed'])
            fix = w
            row.append(w)

            w = QCheckBox()
            limits = constraints[k]['limits']
            w.setChecked(limits is not None)
            bound = w
            row.append(w)

            e = QLineEdit()
            e.setValidator(v)
            if limits is not None:
                e.setText(str(limits[0]))
            row.append(e)

            e = QLineEdit()
            e.setValidator(v)
            if limits is not None:
                e.setText(str(limits[1]))
            row.append(e)

            def unset(w):
                def result(active):
                    if active:
                        w.setChecked(False)
                return result

            fix.toggled.connect(unset(bound))
            bound.toggled.connect(unset(fix))

            self._widgets[k] = row

        for i, row in enumerate(names, 1):
            for j, widget in enumerate(self._widgets[row]):
                self.layout.addWidget(widget, i, j)

    def settings(self, name):
        row = self._widgets[name]
        name, value, fixed, limited, lo, hi = row
        value = float(value.text()) if value.text() else None
        fixed = fixed.isChecked()
        limited = limited.isChecked()
        lo = lo.text()
        hi = hi.text()
        limited = limited and not ((not lo) or (not hi))
        limits = None if not limited else [float(lo), float(hi)]
        return dict(value=value, fixed=fixed, limits=limits)

    def update_constraints(self, fitter):
        for name in self._widgets:
            s = self.settings(name)
            fitter.set_constraint(name, **s)


class FitSettingsWidget(QDialog):

    def __init__(self, fitter, parent=None):
        super(FitSettingsWidget, self).__init__(parent)
        self.fitter = fitter

        self._build_form()
        self._connect()
        self.setModal(True)

    def _build_form(self):
        fitter = self.fitter

        l = QFormLayout()
        options = fitter.options
        self.widgets = {}
        self.forms = {}

        for k in sorted(options):
            item = build_form_item(fitter, k)
            l.addRow(item.label, item.widget)
            self.widgets[k] = item.widget
            self.forms[k] = item  # need to prevent garbage collection

        constraints = fitter.constraints
        if constraints:
            self.constraints = ConstraintsWidget(constraints)
            l.addRow(self.constraints)
        else:
            self.constraints = None

        self.okcancel = QDialogButtonBox(QDialogButtonBox.Ok |
                                         QDialogButtonBox.Cancel)
        l.addRow(self.okcancel)
        self.setLayout(l)

    def _connect(self):
        self.okcancel.accepted.connect(self.accept)
        self.okcancel.rejected.connect(self.reject)
        self.accepted.connect(self.update_fitter_from_settings)

    def update_fitter_from_settings(self):
        for k, v in self.widgets.items():
            setattr(self.fitter, k, v.value())
        if self.constraints is not None:
            self.constraints.update_constraints(self.fitter)


class FitContext(SpectrumContext):
    error = CurrentComboProperty('ui.uncertainty_combo')
    fitter = CurrentComboProperty('ui.profile_combo')

    def _setup_grip(self):
        self.grip = self.main.profile.new_range_grip()

    def _setup_widget(self):
        self.ui = load_ui('spectrum_fit_panel')
        self.ui.uncertainty_combo.hide()
        self.ui.uncertainty_label.hide()
        font = QFont("Courier")
        font.setStyleHint(font.Monospace)
        self.ui.results_box.document().setDefaultFont(font)
        self.ui.results_box.setLineWrapMode(self.ui.results_box.NoWrap)
        self.widget = self.ui

        for fitter in list(fit_plugin):
            self.ui.profile_combo.addItem(fitter.label,
                                          userData=fitter())

    def _edit_model_options(self):

        d = FitSettingsWidget(self.fitter)
        d.exec_()

    def _connect(self):
        self.ui.fit_button.clicked.connect(nonpartial(self.fit))
        self.ui.settings_button.clicked.connect(
            nonpartial(self._edit_model_options))

    def fit(self):
        """
        Fit a model to the data

        The fitting happens on a dedicated thread, to keep the UI
        responsive
        """
        xlim = self.grip.range
        fitter = self.fitter

        def on_success(result):
            fit_result, _, _, _ = result
            self._report_fit(fitter.summarize(*result))
            self.main.profile.plot_fit(fitter, fit_result)

        def on_fail(exc_info):
            exc = '\n'.join(traceback.format_exception(*exc_info))
            self._report_fit("Error during fitting:\n%s" % exc)

        def on_done():
            self.ui.fit_button.setText("Fit")
            self.ui.fit_button.setEnabled(True)
            self.canvas.draw()

        self.ui.fit_button.setText("Running...")
        self.ui.fit_button.setEnabled(False)

        w = Worker(self.main.profile.fit, fitter, xlim=xlim)
        w.result.connect(on_success)
        w.error.connect(on_fail)
        w.finished.connect(on_done)

        self._fit_worker = w  # hold onto a reference
        w.start()

    def _report_fit(self, report):
        self.ui.results_box.document().setPlainText(report)


class SpectrumMainWindow(QMainWindow):

    subset_dropped = Signal(object)

    def __init__(self, parent=None):
        super(SpectrumMainWindow, self).__init__(parent=parent)
        self.setAcceptDrops(True)

    def dragEnterEvent(self, event):
        if event.mimeData().hasFormat(LAYERS_MIME_TYPE):
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event):
        layer = event.mimeData().data(LAYERS_MIME_TYPE)[0]
        if isinstance(layer, Subset):
            self.subset_dropped.emit(layer)


class SpectrumTool(object):

    def __init__(self, image_widget):
        self._relim_requested = True

        self.image_widget = image_widget
        self._build_main_widget()

        self.client = self.image_widget.client
        self.profile = ProfileViewer(self.canvas.fig)
        self.axes = self.profile.axes

        self.mouse_mode = self._setup_mouse_mode()
        self._setup_toolbar()

        self._setup_ctxbar()

        self._connect()
        self.image_widget.session.application.add_widget(self,
                                                         label='Profile')

    def mdi_wrap(self):
        sub = QMdiSubWindow()
        sub.setWidget(self.widget)
        self.widget.destroyed.connect(sub.close)
        sub.resize(self.widget.size())
        self._mdi_wrapper = sub
        return sub

    def _build_main_widget(self):
        self.widget = SpectrumMainWindow()

        w = QWidget()
        l = QHBoxLayout()
        l.setSpacing(2)
        l.setContentsMargins(2, 2, 2, 2)
        w.setLayout(l)

        mpl = MplWidget()
        self.canvas = mpl.canvas
        l.addWidget(mpl)
        l.setStretchFactor(mpl, 5)

        self.widget.setCentralWidget(w)

    def _setup_ctxbar(self):
        l = self.widget.centralWidget().layout()
        self._contexts = [NavContext(self),
                          FitContext(self),
                          CollapseContext(self)]

        tabs = QTabWidget()
        tabs.addTab(self._contexts[0].widget, 'Navigate')
        tabs.addTab(self._contexts[1].widget, 'Fit')
        tabs.addTab(self._contexts[2].widget, 'Collapse')
        self._tabs = tabs
        self._tabs.setVisible(False)
        l.addWidget(tabs)
        l.setStretchFactor(tabs, 0)

    def _connect(self):
        add_callback(self.client, 'slice',
                     self._check_invalidate,
                     echo_old=True)

        def _on_tab_change(index):
            for i, ctx in enumerate(self._contexts):
                ctx.set_enabled(i == index)
                if i == index:
                    self.profile.active_grip = ctx.grip

        self._tabs.currentChanged.connect(_on_tab_change)
        _on_tab_change(self._tabs.currentIndex())

        self.widget.subset_dropped.connect(self._extract_subset_profile)

    def _setup_mouse_mode(self):
        # This will be added to the ImageWidget's toolbar
        mode = SpectrumExtractorMode(self.image_widget.client.axes,
                                     release_callback=self._update_profile)
        return mode

    def _setup_toolbar(self):
        tb = GlueToolbar(self.canvas, self.widget)

        # disable ProfileViewer mouse processing during mouse modes
        tb.mode_activated.connect(self.profile.disconnect)
        tb.mode_deactivated.connect(self.profile.connect)

        self._menu_toggle_action = QAction("Options", tb)
        self._menu_toggle_action.setCheckable(True)
        self._menu_toggle_action.toggled.connect(self._toggle_menu)

        tb.addAction(self._menu_toggle_action)
        self.widget.addToolBar(tb)
        return tb

    def _toggle_menu(self, active):
        self._tabs.setVisible(active)

    def _check_invalidate(self, slc_old, slc_new):
        """
        If we change the orientation of the slice,
        reset and hide the profile viewer
        """
        if self.profile_axis is None:
            return

        if (slc_old.index('x') != slc_new.index('x') or
           slc_old.index('y') != slc_new.index('y')):
            self.reset()

    def reset(self):
        self.hide()
        self.mouse_mode.clear()
        self._relim_requested = True

    @property
    def data(self):
        return self.client.display_data

    @property
    def profile_axis(self):
        # XXX make this settable
        # defaults to the non-xy axis with the most channels
        slc = self.client.slice
        candidates = [i for i, s in enumerate(slc) if s not in ['x', 'y']]
        return max(candidates, key=lambda i: self.data.shape[i])

    def _recenter_grips(self):
        for ctx in self._contexts:
            ctx.recenter(self.axes.get_xlim())

    def _extract_subset_profile(self, subset):
        slc = self.client.slice
        try:
            x, y = Extractor.subset_spectrum(subset,
                                             self.client.display_attribute,
                                             slc,
                                             self.profile_axis)
        except IncompatibleAttribute:
            return

        self._set_profile(x, y)

    def _update_profile(self, *args):
        data = self.data
        att = self.client.display_attribute
        slc = self.client.slice
        roi = self.mouse_mode.roi()

        if data is None or att is None:
            return

        zax = self.profile_axis

        x, y = Extractor.spectrum(data, att, roi, slc, zax)
        self._set_profile(x, y)

    def _set_profile(self, x, y):
        data = self.data

        xid = data.get_world_component_id(self.profile_axis)
        units = data.get_component(xid).units
        xlabel = str(xid) if units is None else '%s [%s]' % (xid, units)

        xlim = self.axes.get_xlim()
        self.profile.set_xlabel(xlabel)
        self.profile.set_profile(x, y, c='k')

        # relim x range if requested
        if self._relim_requested:
            self._relim_requested = False
            self.axes.set_xlim(np.nanmin(x), np.nanmax(x))

        # relim y range to data within the view window
        self.profile.autoscale_ylim()

        if self.axes.get_xlim() != xlim:
            self._recenter_grips()

        self.axes.figure.canvas.draw()
        self.show()

    def _move_below_image_widget(self):
        rect = self.image_widget.frameGeometry()
        pos = rect.bottomLeft()
        self._mdi_wrapper.setGeometry(pos.x(), pos.y(),
                                      rect.width(), 300)

    def show(self):
        if self.widget.isVisible():
            return
        self._move_below_image_widget()
        self.widget.show()

    def hide(self):
        self.widget.close()

########NEW FILE########
__FILENAME__ = test_application
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
from distutils.version import LooseVersion
import tempfile
import os

import pytest
from mock import patch, MagicMock
import numpy as np

try:
    from IPython import __version__ as ipy_version
except:
    ipy_version = '0.0'

from ..glue_application import GlueApplication
from ...external.qt.QtCore import QMimeData, QUrl
from ..widgets.scatter_widget import ScatterWidget
from ..widgets.image_widget import ImageWidget
from ...core import Data


def tab_count(app):
    return app.tab_bar.count()


class TestGlueApplication(object):

    def setup_method(self, method):
        self.app = GlueApplication()

    def teardown_method(self, method):
        self.app.close()

    def test_new_tabs(self):
        t0 = tab_count(self.app)
        self.app.new_tab()
        assert tab_count(self.app) == t0 + 1

    def test_save_session(self):
        self.app.save_session = MagicMock()
        with patch('glue.qt.glue_application.QFileDialog') as fd:
            fd.getSaveFileName.return_value = '/tmp/junk', 'jnk'
            self.app._choose_save_session()
            self.app.save_session.assert_called_once_with('/tmp/junk')

    def test_save_session_cancel(self):
        """shouldnt try to save file if no file name provided"""
        self.app.save_session = MagicMock()
        with patch('glue.qt.glue_application.QFileDialog') as fd:
            fd.getSaveFileName.return_value = '', 'jnk'
            self.app._choose_save_session()
            assert self.app.save_session.call_count == 0

    def test_choose_save_session_ioerror(self):
        """should show box on ioerror"""
        with patch('glue.qt.glue_application.QFileDialog') as fd:
            with patch('__builtin__.open') as op:
                op.side_effect = IOError
                fd.getSaveFileName.return_value = '/tmp/junk', '/tmp/junk'
                with patch('glue.qt.glue_application.QMessageBox') as mb:
                    self.app._choose_save_session()
                    assert mb.call_count == 1

    @pytest.mark.xfail("LooseVersion(ipy_version) <= LooseVersion('0.11')")
    def test_terminal_present(self):
        """For good setups, terminal is available"""
        if not self.app.has_terminal():
            import sys
            sys.stderr.write(self.app._terminal_exception)
            assert False

    def app_without_terminal(self):
        if not self.app.has_terminal():
            return self.app

        with patch('glue.qt.widgets.terminal.glue_terminal') as terminal:
            terminal.side_effect = Exception("disabled")
            app = GlueApplication()
            return app

    def test_functional_without_terminal(self):
        """Can still create app without terminal"""
        app = self.app_without_terminal()

    def test_messagebox_on_disabled_terminal(self):
        """Clicking on the terminal toggle button raises messagebox on error"""
        app = self.app_without_terminal()
        with patch('glue.qt.glue_application.QMessageBox') as qmb:
            app._terminal_button.click()
            assert qmb.call_count == 1

    def is_terminal_importable(self):
        try:
            import glue.qt.widgets.glue_terminal
            return True
        except:
            return False

    @pytest.mark.xfail("LooseVersion(ipy_version) <= LooseVersion('0.11')")
    def test_toggle_terminal(self):
        term = MagicMock()
        self.app._terminal = term

        term.isVisible.return_value = False
        self.app._terminal_button.click()
        assert term.show.call_count == 1

        term.isVisible.return_value = True
        self.app._terminal_button.click()
        assert term.hide.call_count == 1

    def test_close_tab(self):
        assert self.app.tab_widget.count() == 1
        self.app.new_tab()
        assert self.app.tab_widget.count() == 2
        self.app.close_tab(0)
        assert self.app.tab_widget.count() == 1
        # do not delete last tab
        self.app.close_tab(0)
        assert self.app.tab_widget.count() == 1

    def test_new_data_viewer_cancel(self):
        with patch('glue.qt.glue_application.pick_class') as pc:
            pc.return_value = None

            ct = len(self.app.current_tab.subWindowList())

            self.app.choose_new_data_viewer()
            assert len(self.app.current_tab.subWindowList()) == ct

    def test_new_data_viewer(self):
        with patch('glue.qt.glue_application.pick_class') as pc:

            pc.return_value = ScatterWidget

            ct = len(self.app.current_tab.subWindowList())

            self.app.choose_new_data_viewer()
            assert len(self.app.current_tab.subWindowList()) == ct + 1

    def test_move(self):
        viewer = self.app.new_data_viewer(ScatterWidget)
        viewer.move(10, 20)
        assert viewer.position == (10, 20)

    def test_resize(self):
        viewer = self.app.new_data_viewer(ScatterWidget)
        viewer.viewer_size = (100, 200)
        assert viewer.viewer_size == (100, 200)

    def test_new_data_defaults(self):
        from ...config import qt_client

        with patch('glue.qt.glue_application.pick_class') as pc:
            pc.return_value = None

            d2 = Data(x=np.array([[1, 2, 3], [4, 5, 6]]))
            d1 = Data(x=np.array([1, 2, 3]))

            self.app.choose_new_data_viewer(data=d1)
            args, kwargs = pc.call_args
            assert qt_client.members[kwargs['default']] == ScatterWidget

            self.app.choose_new_data_viewer(data=d2)
            args, kwargs = pc.call_args
            assert qt_client.members[kwargs['default']] == ImageWidget

    def test_drop_load_data(self):
        m = QMimeData()
        m.setUrls([QUrl('test.fits')])
        e = MagicMock()
        e.mimeData.return_value = m
        load = MagicMock()
        self.app.load_data = load
        self.app.dropEvent(e)
        assert load.call_count == 1

########NEW FILE########
__FILENAME__ = test_component_selector
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
from numpy import array

from ..component_selector import ComponentSelector
from ... import core
from ...core.data import ComponentID


def data_collection():
    d = core.data.Data(label='test data')
    c1 = core.data.Component(array([1, 2, 3]))
    c2 = core.data.Component(array([1, 2, 3]))
    dc = core.data_collection.DataCollection()
    dc.append(d)
    d.add_component(c1, 'test1')
    d.add_component(c2, 'test2')
    dc.append(core.data.Data(label='test 2'))
    return dc


class TestComponentSelector(object):

    def setup_method(self, method):
        self.comp = ComponentSelector()
        self.data = data_collection()
        self.comp.setup(self.data)

    def test_component(self):
        self.comp.set_current_row(1)
        c = self.comp.component
        assert isinstance(c, ComponentID)

    def test_data(self):
        self.comp.set_data_row(0)
        assert self.comp.data is self.data[0]

        self.comp.set_data_row(1)
        assert self.comp.data is self.data[1]

########NEW FILE########
__FILENAME__ = test_data_collection_model
from ...external.qt.QtCore import Qt
from ...core import DataCollection, Data
from ..data_collection_model import DataCollectionModel
from ..qtutil import LAYERS_MIME_TYPE


class TestDataCollectionModel(object):

    def make_model(self, n_data=1, n_subsets=0):
        dc = DataCollection([Data(x=[1, 2, 3]) for _ in range(n_data)])
        for _ in range(n_subsets):
            dc.new_subset_group()
        return DataCollectionModel(dc)

    def test_row_count_empty_index(self):
        model = self.make_model(1, 0)
        assert model.rowCount() == 2

    def test_row_count_data_row(self):
        model = self.make_model(1, 0)
        assert model.rowCount(model.data_index()) == 1

        model = self.make_model(2, 0)
        assert model.rowCount(model.data_index()) == 2

    def test_row_count_subset_row(self):
        model = self.make_model(1, 0)
        assert model.rowCount(model.subsets_index()) == 0

        model = self.make_model(1, 5)
        assert model.rowCount(model.subsets_index()) == 5

    def test_row_count_single_subset(self):
        model = self.make_model(2, 1)
        assert model.rowCount(model.subsets_index(0)) == 2

    def test_row_count_single_subset(self):
        model = self.make_model(2, 1)
        s = model.subsets_index(0)

        idx = model.index(0, 0, s)
        assert model.rowCount(idx) == 0

        idx = model.index(1, 0, s)
        assert model.rowCount(s) == 2

    def test_invalid_indices(self):
        model = self.make_model(1, 2)

        index = model.index(0, 1)
        assert not index.isValid()

        index = model.index(2, 0)
        assert not index.isValid()

        index = model.index(2, 0, model.index(0, 0))
        assert not index.isValid()

    def test_heading_labels(self):
        model = self.make_model()
        assert model.data(model.data_index(), Qt.DisplayRole) == 'Data'
        assert model.data(model.subsets_index(), Qt.DisplayRole) == 'Subsets'

    def test_dc_labels(self):
        model = self.make_model(1, 2)
        dc = model.data_collection
        dc[0].label = 'test1'
        dc[0].subsets[0].label = 'subset1'
        dc[0].subsets[1].label = 'subset2'

        assert model.data(model.data_index(0), Qt.DisplayRole) == 'test1'
        assert model.data(model.subsets_index(0), Qt.DisplayRole) == 'subset1'
        assert model.data(model.subsets_index(1), Qt.DisplayRole) == 'subset2'
        assert model.data(model.index(0, 0, model.subsets_index(0)),
                          Qt.DisplayRole) == 'subset1 (test1)'

    def test_column_count(self):
        model = self.make_model(1, 2)

        assert model.columnCount(model.data_index()) == 1
        assert model.columnCount(model.data_index(0)) == 1
        assert model.columnCount(model.subsets_index()) == 1
        assert model.columnCount(model.subsets_index(0)) == 1
        assert model.columnCount(model.subsets_index(1)) == 1

    def test_header_data(self):
        model = self.make_model()

        assert model.headerData(0, Qt.Vertical) == ''
        assert model.headerData(0, Qt.Horizontal) == ''

    def test_font_role(self):
        model = self.make_model(1, 2)

        assert model.data(model.data_index(), Qt.FontRole).bold()
        assert model.data(model.subsets_index(), Qt.FontRole).bold()

    def test_drag_flags(self):
        model = self.make_model(1, 2)

        sg = model.subsets_index(0)
        subset = model.index(0, 0, sg)
        assert model.flags(model.data_index(0)) & Qt.ItemIsDragEnabled
        assert model.flags(subset) & Qt.ItemIsDragEnabled

        assert not model.flags(model.data_index()) & Qt.ItemIsDragEnabled
        assert not model.flags(model.subsets_index()) & Qt.ItemIsDragEnabled
        assert not model.flags(sg) & Qt.ItemIsDragEnabled

    def test_selectable_flags(self):
        model = self.make_model(1, 2)

        assert not model.flags(model.data_index()) & Qt.ItemIsSelectable
        assert not model.flags(model.subsets_index()) & Qt.ItemIsSelectable

    def test_layers_mime_type_data(self):
        model = self.make_model(1, 2)
        index = model.data_index(0)

        expected = [model.data_collection[0]]
        assert model.mimeData([index]).data(LAYERS_MIME_TYPE) == expected

    def test_layers_mime_type_multiselection(self):
        model = self.make_model(1, 2)
        idxs = [model.data_index(0),
                model.subsets_index(0),
                model.index(0, 0, model.subsets_index(0))]

        dc = model.data_collection
        expected = [dc[0], dc.subset_groups[0], dc.subset_groups[0].subsets[0]]
        assert model.mimeData(idxs).data(LAYERS_MIME_TYPE) == expected

########NEW FILE########
__FILENAME__ = test_layer_artist_model
from ...external.qt.QtCore import Qt

from mock import MagicMock

from ..layer_artist_model import LayerArtistModel, LayerArtistView
from ...clients.layer_artist import LayerArtist
from ...core import Data


def setup_model(num):
    ax = MagicMock()
    mgrs = [LayerArtist(Data(label=str(i)), ax) for i in range(num)]
    model = LayerArtistModel(mgrs)
    return model, mgrs


def test_row_count():
    for n in range(4):
        assert setup_model(n)[0].rowCount() == n


def test_row_label():
    model, mgrs = setup_model(5)
    for i in range(5):
        assert model.row_label(i) == mgrs[i].layer.label


def test_add_artist_updates_row_count():
    mgrs = [LayerArtist(Data(label='A'), None)]
    model = LayerArtistModel(mgrs)
    model.add_artist(0, LayerArtist(Data(label='B'), None))
    assert model.rowCount() == 2


def test_add_artist_updates_artist_list():
    mgrs = [LayerArtist(Data(label='A'), None)]
    model = LayerArtistModel(mgrs)
    model.add_artist(0, LayerArtist(Data(label='B'), None))
    assert len(mgrs) == 2


def test_valid_remove():
    mgr = MagicMock(spec_set=LayerArtist)
    mgrs = [mgr]
    model = LayerArtistModel(mgrs)
    remove = model.removeRow(0)
    assert remove
    assert mgr not in mgrs


def test_invalid_remove():
    mgr = MagicMock(spec_set=LayerArtist)
    mgrs = [mgr]
    model = LayerArtistModel(mgrs)
    remove = model.removeRow(1)
    assert not remove
    assert mgr in mgrs


def test_artist_cleared_on_remove():
    mgr = MagicMock(spec_set=LayerArtist)
    mgrs = [mgr]
    model = LayerArtistModel(mgrs)

    model.removeRow(0)
    mgr.clear.assert_called_once_with()


def test_change_label():
    model, (mgr,) = setup_model(1)

    lbl = mgr.layer.label
    model.change_label(0, 'new label')
    assert mgr.layer.label != lbl


def test_change_label_invalid_row():
    model, (mgr,) = setup_model(1)

    lbl = mgr.layer.label
    model.change_label(1, 'new label')
    assert mgr.layer.label == lbl


def test_flags():
    model, _ = setup_model(1)

    assert model.flags(model.index(0)) == (Qt.ItemIsEditable |
                                           Qt.ItemIsDragEnabled |
                                           Qt.ItemIsEnabled |
                                           Qt.ItemIsSelectable |
                                           Qt.ItemIsUserCheckable)
    assert model.flags(model.index(-1)) == (Qt.ItemIsDropEnabled)


def test_move_artist_empty():
    mgrs = []
    model = LayerArtistModel(mgrs)
    model.move_artist(None, 0)

    assert mgrs == []


def test_move_artist_single():
    ax = MagicMock()
    m0 = LayerArtist(Data(label="test 0"), ax)
    mgrs = [m0]

    model = LayerArtistModel(mgrs)
    model.move_artist(m0, 0)
    assert mgrs == [m0]
    model.move_artist(m0, -1)
    assert mgrs == [m0]
    model.move_artist(m0, 1)
    assert mgrs == [m0]
    model.move_artist(m0, 2)
    assert mgrs == [m0]


def test_move_artist_two():
    model, mgrs = setup_model(2)
    m0, m1 = mgrs

    model.move_artist(m0, 0)
    assert mgrs == [m0, m1]

    model.move_artist(m0, 1)
    assert mgrs == [m0, m1]

    model.move_artist(m0, 2)
    assert mgrs == [m1, m0]

    model.move_artist(m0, 0)
    assert mgrs == [m0, m1]


def test_move_artist_three():
    model, mgrs = setup_model(3)
    m0, m1, m2 = mgrs

    model.move_artist(m0, 0)
    assert mgrs == [m0, m1, m2]

    model.move_artist(m0, 1)
    assert mgrs == [m0, m1, m2]

    model.move_artist(m0, 2)
    assert mgrs == [m1, m0, m2]
    model.move_artist(m0, 0)

    model.move_artist(m0, 3)
    assert mgrs == [m1, m2, m0]
    model.move_artist(m0, 0)

    model.move_artist(m2, 0)
    assert mgrs == [m2, m0, m1]


def test_move_updates_zorder():
    m0 = LayerArtist(Data(label='test 0'), MagicMock())
    m1 = LayerArtist(Data(label='test 1'), MagicMock())
    m2 = LayerArtist(Data(label='test 2'), MagicMock())
    m0.zorder = 10
    m1.zorder = 20
    m2.zorder = 30

    mgrs = [m0, m1, m2]
    model = LayerArtistModel(mgrs)

    model.move_artist(m2, 0)
    assert m2.zorder == 30
    assert m0.zorder == 20
    assert m1.zorder == 10


def test_check_syncs_to_visible():
    m0 = LayerArtist(Data(label='test 0'), MagicMock())
    m0.artists = [MagicMock()]
    mgrs = [m0]
    model = LayerArtistModel(mgrs)

    m0.visible = True
    assert m0.visible
    assert model.data(model.index(0), Qt.CheckStateRole) == Qt.Checked
    m0.visible = False
    assert not m0.visible
    assert model.data(model.index(0), Qt.CheckStateRole) == Qt.Unchecked

    model.setData(model.index(0), Qt.Checked, Qt.CheckStateRole)
    assert m0.visible


def test_data():

    model, mgrs = setup_model(3)
    idx = model.index(3)
    assert model.data(idx, Qt.DisplayRole) is None
    idx = model.index(1)
    assert model.data(idx, Qt.DisplayRole) == model.row_label(1)
    assert model.data(idx, Qt.EditRole) == model.row_label(1)


class TestLayerArtistView(object):

    def setup_method(self, method):
        self.model, self.artists = setup_model(2)
        self.view = LayerArtistView()
        self.view.setModel(self.model)

    def test_current_row(self):
        for row in [0, 1]:
            idx = self.model.index(row)
            self.view.setCurrentIndex(idx)
            self.view.current_row() == row
            assert self.view.current_artist() is self.artists[row]

########NEW FILE########
__FILENAME__ = test_link_equation
from mock import MagicMock
import pytest

from ..link_equation import (function_label, helper_label,
                             LinkEquation, ArgumentWidget)
from ...config import link_function, link_helper


@link_function('testing function', ['y'])
def func1(x):
    return x


@link_function('testing function', ['a', 'b'])
def func2(x, z):
    return x + z, x - z


@link_helper('test helper', ['a', 'b'])
def helper(x, y):
    return [x, x, y]


def test_function_label():
    f1 = [f for f in link_function if f[0] is func1][0]
    f2 = [f for f in link_function if f[0] is func2][0]
    assert function_label(f1) == "Link from x to y"
    assert function_label(f2) == "Link from x, z to a, b"


def test_helper_label():
    f1 = [h for h in link_helper if h[0] is helper][0]
    assert helper_label(f1) == 'test helper'


class TestArgumentWidget(object):
    def test_label(self):
        a = ArgumentWidget('test')
        assert a.label == 'test'

    def test_set_label(self):
        a = ArgumentWidget('test')
        a.label = 'b'
        assert a.label == 'b'

    def test_drop(self):
        from glue.core import ComponentID
        target_id = ComponentID('test')
        event = MagicMock()
        event.mimeData().data.return_value = target_id
        a = ArgumentWidget('test')
        a.dropEvent(event)
        assert a.component_id is target_id
        assert a.editor_text == 'test'

    def test_drop_invalid(self):
        event = MagicMock()
        event.mimeData().data.return_value = 5
        a = ArgumentWidget('')
        a.dropEvent(event)
        assert a.component_id is None

    def test_clear(self):
        from glue.core import ComponentID
        target_id = ComponentID('test')
        event = MagicMock()
        event.mimeData().data.return_value = target_id
        a = ArgumentWidget('test')
        a.dropEvent(event)
        assert a.component_id is target_id
        a.clear()
        assert a.component_id is None
        assert a.editor_text == ''

    def test_drag_enter_accept(self):
        event = MagicMock()
        event.mimeData().hasFormat.return_value = True
        a = ArgumentWidget('x')
        a.dragEnterEvent(event)
        event.accept.assert_called_once_with()

    def test_drag_enter_ignore(self):
        event = MagicMock()
        event.mimeData().hasFormat.return_value = False
        a = ArgumentWidget('x')
        a.dragEnterEvent(event)
        event.ignore.assert_called_once_with()


class TestLinkEquation(object):
    def setup_method(self, method):
        self.widget = LinkEquation()

    def test_select_function_member(self):
        member = link_function.members[1]
        assert self.widget.function is not member
        self.widget.function = member
        assert self.widget.function is member

    def test_select_function_helper(self):
        member = link_helper.members[-1]
        self.widget.function = member
        assert self.widget.function is member

    def test_select_invalid_function(self):
        with pytest.raises(KeyError) as exc:
            def bad(x):
                pass
            self.widget.function = (bad, None, None)
        assert exc.value.args[0].startswith('No function or helper found')

    def test_make_link_function(self):
        from glue.core import ComponentID
        widget = LinkEquation()
        f1 = [f for f in link_function if f[0] is func1][0]
        widget.function = f1
        x, y = ComponentID('x'), ComponentID('y')
        widget.signature = [x], y
        links = widget.links()
        assert len(links) == 1
        assert links[0].get_from_ids() == [x]
        assert links[0].get_to_id() == y
        assert links[0].get_using() is func1

    def test_make_link_helper(self):
        from glue.core import ComponentID
        widget = LinkEquation()
        f1 = [f for f in link_helper if f[0] is helper][0]
        widget.function = f1
        x, y = ComponentID('x'), ComponentID('y')
        widget.signature = [x, y], None
        links = widget.links()
        assert links == helper(x, y)

    def test_links_empty(self):
        assert LinkEquation().links() == []

    def test_links_empty_helper(self):
        widget = LinkEquation()
        f1 = [f for f in link_helper if f[0] is helper][0]
        widget.function = f1
        assert widget.is_helper()
        assert widget.links() == []

    def test_clear_inputs(self):
        from glue.core import ComponentID
        widget = LinkEquation()
        f1 = [f for f in link_helper if f[0] is helper][0]
        widget.function = f1
        x, y = ComponentID('x'), ComponentID('y')

        widget.signature = [x, y], None
        assert widget.signature == ([x, y], None)

        widget.clear_inputs()
        assert widget.signature == ([None, None], None)

    def test_signal_connections(self):
        #testing that signal-slot connections don't crash
        widget = LinkEquation()

        signal = widget._ui.function.currentIndexChanged
        signal.emit(5)

        signal = widget._output_widget.editor.textChanged
        signal.emit('changing')

########NEW FILE########
__FILENAME__ = test_mime
from ...external.qt.QtGui import QWidget, QDrag
from ...external.qt.QtCore import QMimeData, Qt
from ...external.qt.QtTest import QTest

from .. import mime

import pytest


class TestWidget(QWidget):
    def __init__(self, out_mime, parent=None):
        super(TestWidget, self).__init__(parent)
        self.setAcceptDrops(True)

        self.last_mime = None
        self.out_mime = out_mime

    def dragEnterEvent(self, event):
        print 'drag enter'
        event.accept()

    def dropEvent(self, event):
        print 'drop'
        self.last_mime = event.mimeData()

    def mousePressEvent(self, event):
        print 'mouse event'
        drag = QDrag(self)
        drag.setMimeData(self.out_mime)
        drop_action = drag.exec_()
        print drop_action
        event.accept()


class TestMime(object):
    def test_formats(self):
        d = mime.PyMimeData()
        assert set(d.formats()) == set([mime.INSTANCE_MIME_TYPE])

        d = mime.PyMimeData(**{'text/plain': 'hello'})
        assert set(d.formats()) == set([mime.INSTANCE_MIME_TYPE, 'text/plain'])

    def test_empty_has_format(self):
        d = mime.PyMimeData()
        assert d.hasFormat(mime.INSTANCE_MIME_TYPE)
        assert not d.hasFormat(mime.LAYER_MIME_TYPE)
        assert not d.hasFormat(mime.LAYERS_MIME_TYPE)

    def test_instance_format(self):
        d = mime.PyMimeData(5)
        assert d.hasFormat(mime.INSTANCE_MIME_TYPE)
        assert not d.hasFormat(mime.LAYER_MIME_TYPE)
        assert not d.hasFormat(mime.LAYERS_MIME_TYPE)

    def test_layer_format(self):
        d = mime.PyMimeData(5, **{mime.LAYER_MIME_TYPE: 10})
        assert d.hasFormat(mime.INSTANCE_MIME_TYPE)
        assert d.hasFormat(mime.LAYER_MIME_TYPE)
        assert not d.hasFormat(mime.LAYERS_MIME_TYPE)

    def test_layers_format(self):
        d = mime.PyMimeData(5, **{mime.LAYERS_MIME_TYPE: 10})
        assert d.hasFormat(mime.INSTANCE_MIME_TYPE)
        assert d.hasFormat(mime.LAYERS_MIME_TYPE)
        assert not d.hasFormat(mime.LAYER_MIME_TYPE)

    def test_retrieve_instance(self):
        d = mime.PyMimeData(10)
        assert d.retrieveData(mime.INSTANCE_MIME_TYPE) == 10

    def test_retrieve_layer(self):
        d = mime.PyMimeData(**{mime.LAYERS_MIME_TYPE: 12})
        assert d.retrieveData(mime.LAYERS_MIME_TYPE) == 12

        d = mime.PyMimeData(**{mime.LAYER_MIME_TYPE: 12})
        assert d.retrieveData(mime.LAYER_MIME_TYPE) == 12

    def test_retrieve_not_present_returns_null(self):
        d = mime.PyMimeData()
        assert d.retrieveData('not-a-format') is None


@pytest.skip
class TestMimeDragAndDrop(object):
    def setup_method(self, method):

        m1 = mime.PyMimeData(1, **{'text/plain': 'hi', 'test': 4})
        m2 = mime.PyMimeData(1, **{'test': 5})

        w1 = TestWidget(m1)
        w2 = TestWidget(m2)

        self.w1 = w1
        self.w2 = w2
        self.m1 = m1
        self.m2 = m2

    def test_drag_drop(self):
        QTest.mousePress(self.w1, Qt.LeftButton)
        QTest.mouseMove(self.w2)
        QTest.mouseRelease(self.w2, Qt.LeftButton)

        assert self.w2.last_mime == self.m1

########NEW FILE########
__FILENAME__ = test_mouse_mode
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
from mock import MagicMock, patch
import numpy as np
from numpy.testing import assert_almost_equal

from ..mouse_mode import (MouseMode, RectangleMode, CircleMode, PolyMode,
                          ContrastMode, ContourMode, contour_to_roi, LassoMode,
                          ClickRoiMode)


class Event(object):
    def __init__(self, x, y, button=3, key='a'):
        self.x = x
        self.y = y
        self.xdata = x
        self.ydata = y
        self.button = button
        self.key = key
        self.inaxes = True


def axes():
    result = MagicMock()
    result.figure.canvas.get_width_height.return_value = (640, 480)
    return result


class TestMouseMode(object):

    def setup_method(self, method):
        self.mode = self.mode_factory()(axes())
        self.axes = self.mode._axes
        self.attach_callbacks()

    def attach_callbacks(self):
        self.press = self.mode._press_callback = MagicMock()
        self.move = self.mode._move_callback = MagicMock()
        self.release = self.mode._release_callback = MagicMock()

    def mode_factory(self):
        return MouseMode

    def test_press_callback(self):
        e = Event(1, 2)
        self.mode.press(e)
        self.press.assert_called_once_with(self.mode)
        assert self.move.call_count == 0
        assert self.release.call_count == 0

    #def test_log_null_event(self):
    #    """ Should exit quietly if event is None """
    #    self.mode._log_position(None)

    def test_move_callback(self):
        e = Event(1, 2)
        self.mode.move(e)
        self.move.assert_called_once_with(self.mode)
        assert self.press.call_count == 0
        assert self.release.call_count == 0

    def test_release_callback(self):
        e = Event(1, 2)
        self.mode.release(e)
        self.release.assert_called_once_with(self.mode)
        assert self.press.call_count == 0
        assert self.move.call_count == 0

    def test_press_log(self):
        e = Event(1, 2)
        self.mode.press(e)
        assert self.mode._event_x == 1
        assert self.mode._event_y == 2

    def test_move_log(self):
        e = Event(1, 2)
        self.mode.move(e)
        assert self.mode._event_x == 1
        assert self.mode._event_y == 2

    def test_release_log(self):
        e = Event(1, 2)
        self.mode.release(e)
        assert self.mode._event_x == 1
        assert self.mode._event_y == 2


class TestRoiMode(TestMouseMode):

    def setup_method(self, method):
        TestMouseMode.setup_method(self, method)
        self.mode._roi_tool = MagicMock()

    def mode_factory(self):
        raise NotImplementedError()

    def test_roi_not_called_on_press(self):
        e = Event(1, 2)
        self.mode.press(e)
        assert self.mode._roi_tool.start_selection.call_count == 0

    def test_roi_called_on_drag(self):
        e = Event(1, 2)
        e2 = Event(10, 200)
        self.mode.press(e)
        self.mode.move(e2)
        self.mode._roi_tool.start_selection.assert_called_once_with(e)
        self.mode._roi_tool.update_selection.assert_called_once_with(e2)

    def test_roi_ignores_small_drags(self):
        e = Event(1, 2)
        e2 = Event(1, 3)
        self.mode.press(e)
        self.mode.move(e2)
        assert self.mode._roi_tool.start_selection.call_count == 0
        assert self.mode._roi_tool.update_selection.call_count == 0

    def test_roi_called_on_release(self):
        e = Event(1, 2)
        e2 = Event(10, 20)
        self.mode.press(e)
        self.mode.move(e2)
        self.mode.release(e2)
        self.mode._roi_tool.finalize_selection.assert_called_once_with(e2)

    def test_roi(self):
        r = self.mode.roi()
        self.mode._roi_tool.roi.assert_called_once_with()


class TestClickRoiMode(TestMouseMode):

    def setup_method(self, method):
        TestMouseMode.setup_method(self, method)
        self.mode._roi_tool = MagicMock()
        self.mode._roi_tool.active.return_value = False

    def mode_factory(self):
        raise NotImplementedError()

    def test_roi_started_on_press(self):
        e = Event(1, 2)
        self.mode.press(e)
        assert self.mode._roi_tool.start_selection.call_count == 1

    def test_roi_updates_on_subsequent_presses(self):
        e = Event(1, 2)
        e2 = Event(1, 30)
        self.mode.press(e)
        self.mode._roi_tool.active.return_value = True
        self.mode.press(e2)
        assert self.mode._roi_tool.start_selection.call_count == 1
        assert self.mode._roi_tool.update_selection.call_count == 1

    def test_roi_finalizes_on_enter(self):
        e = Event(1, 2)
        e2 = Event(1, 20)
        e3 = Event(1, 30, key='enter')
        self.mode.press(e)
        self.mode._roi_tool.active.return_value = True
        self.mode.press(e2)
        self.mode.key(e3)
        self.mode._roi_tool.start_selection.assert_called_once_with(e)
        self.mode._roi_tool.update_selection.assert_called_once_with(e2)
        self.mode._roi_tool.finalize_selection.assert_called_once_with(e2)

    def test_roi_resets_on_escape(self):
        e = Event(1, 2)
        e2 = Event(1, 30, key='escape')
        self.mode.press(e)
        self.mode.key(e2)
        self.mode.press(e)
        assert self.mode._roi_tool.reset.call_count == 1
        assert self.mode._roi_tool.start_selection.call_count == 2


class TestRectangleMode(TestRoiMode):
    def mode_factory(self):
        return RectangleMode


class TestCircleMode(TestRoiMode):
    def mode_factory(self):
        return CircleMode


class TestLassoMode(TestRoiMode):
    def mode_factory(self):
        return LassoMode


class TestPolyMode(TestClickRoiMode):
    def mode_factory(self):
        return PolyMode


class TestContrastMode(TestMouseMode):
    def mode_factory(self):
        return ContrastMode

    def test_move_ignored_if_not_right_drag(self):
        e = Event(1, 2, button=1)
        self.mode.move(e)
        count = self.mode._axes.figure.canvas.get_width_height.call_count
        assert count == 0


class TestContourMode(TestMouseMode):

    def mode_factory(self):
        return ContourMode

    def test_roi_before_event(self):
        data = MagicMock()
        roi = self.mode.roi(data)
        assert roi is None

    def test_roi(self):
        with patch('glue.qt.mouse_mode.contour_to_roi') as cntr:
            data = MagicMock()
            e = Event(1, 2)
            self.mode.press(e)
            self.mode.roi(data)
            cntr.assert_called_once_with(1, 2, data)


class TestContourToRoi(object):

    def test_roi(self):
        with patch('glue.core.util.point_contour') as point_contour:
            point_contour.return_value = np.array([[1, 2], [2, 3]])
            p = contour_to_roi(1, 2, None)
            np.testing.assert_array_almost_equal(p.vx, [1, 2])
            np.testing.assert_array_almost_equal(p.vy, [2, 3])

    def test_roi_null_result(self):
        with patch('glue.core.util.point_contour') as point_contour:
            point_contour.return_value = None
            p = contour_to_roi(1, 2, None)
            assert p is None

del TestRoiMode  # prevents test discovery from running abstract test
del TestClickRoiMode

########NEW FILE########
__FILENAME__ = test_qtutil
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
from .. import qtutil
from ...external.qt import QtGui
from ...external.qt.QtCore import Qt
from mock import MagicMock, patch
from ..qtutil import GlueDataDialog
from ..qtutil import pretty_number, GlueComboBox

from glue.config import data_factory
from glue.core import Subset


def test_glue_action_button():
    a = QtGui.QAction(None)
    a.setToolTip("testtooltip")
    a.setWhatsThis("testwhatsthis")
    a.setIcon(QtGui.QIcon("dummy_file"))
    a.setText('testtext')
    b = qtutil.GlueActionButton()
    b.set_action(a)

    # assert b.icon() == a.icon() icons are copied, apparently
    assert b.text() == a.text()
    assert b.toolTip() == a.toolTip()
    assert b.whatsThis() == a.whatsThis()

    #stays in sync
    a.setText('test2')
    assert b.text() == 'test2'


@data_factory('testing_factory', '*.*')
def dummy_factory(filename):
    from glue.core import Data
    result = Data()
    result.made_with_dummy_factory = True
    return result
dummy_factory_member = [f for f in data_factory.members
                        if f[0] is dummy_factory][0]


class TestGlueDataDialog(object):

    def test_factory(self):
        """Factory method should always match with filter"""
        fd = GlueDataDialog()
        assert len(fd.filters) > 0
        for k, v in fd.filters:
            fd._fd.setFilter(v)
            assert fd.factory() is k

    def test_load_data_cancel(self):
        """Return None if user cancels operation"""
        fd = GlueDataDialog()
        mock_file_exec(fd, cancel=True)
        assert fd.load_data() == []

    def test_load_data_normal(self):
        """normal load_data dispatches path to factory"""
        fd = GlueDataDialog()
        mock_file_exec(fd, cancel=False, path='ld_data_nrml',
                       factory=dummy_factory_member)
        d = fd.load_data()
        assert len(d) == 1
        d = d[0]
        assert d.label == 'ld_data_nrml'
        assert d.made_with_dummy_factory is True

    def test_filters(self):
        """Should build filter list from data_factories env var"""
        fd = GlueDataDialog()
        assert len(fd.filters) == len(data_factory.members)

    def test_load_multiple(self):
        fd = GlueDataDialog()
        mock_file_exec(fd, cancel=False, path=['a.fits', 'b.fits'],
                       factory=dummy_factory_member)
        ds = fd.load_data()
        assert len(ds) == 2
        for d, label in zip(ds, 'ab'):
            assert d.label == label
            assert d.made_with_dummy_factory is True


def mock_file_exec(fd, cancel=False, path='junk',
                   factory=dummy_factory_member):
    if not isinstance(path, list):
        path = [path]

    fd._fd.exec_ = MagicMock()
    fd._fd.exec_.return_value = 1 - cancel
    fd.factory = MagicMock()
    fd.factory.return_value = factory
    fd.paths = MagicMock()
    fd.paths.return_value = path


def test_data_wizard_cancel():
    """Returns empty list if user cancel's dialog"""
    with patch('glue.qt.qtutil.GlueDataDialog') as mock:
        mock().load_data.return_value = []
        assert qtutil.data_wizard() == []


def test_data_wizard_normal():
    """Returns data list if successful"""
    with patch('glue.qt.qtutil.GlueDataDialog') as mock:
        mock().load_data.return_value = [1]
        assert qtutil.data_wizard() == [1]


def test_data_wizard_error_cancel():
    """Returns empty list of error generated and then canceled"""
    with patch('glue.qt.qtutil.GlueDataDialog') as mock:
        mock().load_data.side_effect = Exception
        with patch('glue.qt.qtutil.QMessageBox') as qmb:
            qmb().exec_.return_value = 0
            assert qtutil.data_wizard() == []


class TestPrettyNumber(object):

    def test_single(self):
        assert pretty_number([1]) == ['1']
        assert pretty_number([0]) == ['0']
        assert pretty_number([-1]) == ['-1']
        assert pretty_number([1.0001]) == ['1']
        assert pretty_number([1.01]) == ['1.01']
        assert pretty_number([1e-5]) == ['1.000e-05']
        assert pretty_number([1e5]) == ['1.000e+05']
        assert pretty_number([3.3]) == ['3.3']

    def test_list(self):
        assert pretty_number([1, 2, 3.3, 1e5]) == ['1', '2', '3.3',
                                                   '1.000e+05']


class TestGlueComboBox(object):

    def setup_method(self, method):
        self.combo = GlueComboBox()

    def test_add_data(self):
        self.combo.addItem('hi', userData=3)
        assert self.combo.itemData(0) == 3

    def test_add_multi_data(self):
        self.combo.addItem('hi', userData=3)
        self.combo.addItem('ho', userData=4)
        assert self.combo.itemData(0) == 3
        assert self.combo.itemData(1) == 4

    def test_replace(self):
        self.combo.addItem('hi', userData=3)
        self.combo.removeItem(0)
        self.combo.addItem('ho', userData=4)
        assert self.combo.itemData(0) == 4

    def test_clear(self):
        self.combo.addItem('a', 1)
        self.combo.addItem('b', 2)
        self.combo.addItem('c', 3)
        self.combo.clear()
        self.combo.addItem('d', 4)
        assert self.combo.itemData(0) == 4

    def test_mid_remove(self):
        self.combo.addItem('a', 1)
        self.combo.addItem('b', 2)
        self.combo.addItem('c', 3)
        self.combo.removeItem(1)
        assert self.combo.itemData(1) == 3

    def test_set_item_data(self):
        self.combo.addItem('a', 1)
        self.combo.setItemData(0, 2)
        assert self.combo.itemData(0) == 2

    def test_default_data(self):
        self.combo.addItem('a')
        assert self.combo.itemData(0) is None

    def test_add_items(self):
        self.combo.addItem('a', 1)
        self.combo.addItems(['b', 'c', 'd'])
        assert self.combo.itemData(0) == 1
        assert self.combo.itemData(1) is None
        assert self.combo.itemData(2) is None
        assert self.combo.itemData(3) is None

    def test_non_user_role(self):
        """methods that edit data other than userRole dispatched to super"""
        self.combo.addItem('a', 1)
        assert self.combo.itemData(0, role=Qt.DisplayRole) == 'a'
        self.combo.setItemData(0, 'b', role=Qt.DisplayRole)
        assert self.combo.itemData(0, role=Qt.DisplayRole) == 'b'

    def test_consistent_with_signals(self):
        """Ensure that when signal/slot connections interrupt
        methods mid-call, internal data state is consistent"""

        # Qt swallows exceptions in signals, so we can't assert in this
        # instead, store state and assert after signal
        good = [False]

        def assert_consistent(*args):
            good[0] = len(self.combo._data) == self.combo.count()

        # addItem
        self.combo.currentIndexChanged.connect(assert_consistent)
        self.combo.addItem('a', 1)
        assert good[0]

        # addItems
        self.combo.clear()
        good[0] = False
        self.combo.addItems('b c d'.split())
        assert good[0]

        # removeItem
        self.combo.clear()
        self.combo.addItem('a', 1)
        good[0] = False
        self.combo.removeItem(0)
        assert good[0]


def test_qt4_to_mpl_color():
    assert qtutil.qt4_to_mpl_color(QtGui.QColor(255, 0, 0)) == '#ff0000'
    assert qtutil.qt4_to_mpl_color(QtGui.QColor(255, 255, 255)) == '#ffffff'


def test_edit_color():
    with patch('glue.qt.qtutil.QColorDialog') as d:
        d.getColor.return_value = QtGui.QColor(0, 1, 0)
        d.isValid.return_value = True
        s = Subset(None)
        qtutil.edit_layer_color(s)
        assert s.style.color == '#000100'


def test_edit_color_cancel():
    with patch('glue.qt.qtutil.QColorDialog') as d:
        d.getColor.return_value = QtGui.QColor(0, -1, 0)
        s = Subset(None)
        qtutil.edit_layer_color(s)


def test_edit_symbol():
    with patch('glue.qt.qtutil.QInputDialog') as d:
        d.getItem.return_value = ('*', True)
        s = Subset(None)
        qtutil.edit_layer_symbol(s)
        assert s.style.marker == '*'


def test_edit_symbol_cancel():
    with patch('glue.qt.qtutil.QInputDialog') as d:
        d.getItem.return_value = ('*', False)
        s = Subset(None)
        qtutil.edit_layer_symbol(s)
        assert s.style.marker != '*'


def test_edit_point_size():
    with patch('glue.qt.qtutil.QInputDialog') as d:
        d.getInt.return_value = 123, True
        s = Subset(None)
        qtutil.edit_layer_point_size(s)
        assert s.style.markersize == 123


def test_edit_point_size_cancel():
    with patch('glue.qt.qtutil.QInputDialog') as d:
        d.getInt.return_value = 123, False
        s = Subset(None)
        qtutil.edit_layer_point_size(s)
        assert s.style.markersize != 123


def test_edit_layer_label():
    with patch('glue.qt.qtutil.QInputDialog') as d:
        d.getText.return_value = ('accepted label', True)
        s = Subset(None)
        qtutil.edit_layer_label(s)
        assert s.label == 'accepted label'


def test_edit_layer_label_cancel():
    with patch('glue.qt.qtutil.QInputDialog') as d:
        d.getText.return_value = ('rejected label', False)
        s = Subset(None)
        qtutil.edit_layer_label(s)
        assert s.label != 'rejected label'


def test_pick_item():
    items = ['a', 'b', 'c']
    labels = ['1', '2', '3']
    with patch('glue.qt.qtutil.QInputDialog') as d:
        d.getItem.return_value = '1', True
        assert qtutil.pick_item(items, labels) == 'a'
        d.getItem.return_value = '2', True
        assert qtutil.pick_item(items, labels) == 'b'
        d.getItem.return_value = '3', True
        assert qtutil.pick_item(items, labels) == 'c'
        d.getItem.return_value = '3', False
        assert qtutil.pick_item(items, labels) is None


def test_pick_class():
    class Foo:
        pass

    class Bar:
        pass
    Bar.LABEL = 'Baz'
    with patch('glue.qt.qtutil.pick_item') as d:
        qtutil.pick_class([Foo, Bar])
        d.assert_called_once_with([Foo, Bar], ['Foo', 'Baz'])


def test_get_text():
    with patch('glue.qt.qtutil.QInputDialog') as d:
        d.getText.return_value = 'abc', True
        assert qtutil.get_text() == 'abc'

        d.getText.return_value = 'abc', False
        assert qtutil.get_text() is None


class TestGlueListWidget(object):

    def setup_method(self, method):
        self.w = qtutil.GlueListWidget()

    def test_mime_type(self):
        assert self.w.mimeTypes() == [qtutil.LAYERS_MIME_TYPE]

    def test_mime_data(self):
        self.w.set_data(3, 'test data')
        self.w.set_data(4, 'do not pick')
        mime = self.w.mimeData([3])
        mime.data(qtutil.LAYERS_MIME_TYPE) == ['test data']

    def test_mime_data_multiselect(self):
        self.w.set_data(3, 'test data')
        self.w.set_data(4, 'also pick')
        mime = self.w.mimeData([3, 4])
        mime.data(qtutil.LAYERS_MIME_TYPE) == ['test data', 'also pick']


class TestRGBEdit(object):

    def setup_method(self, method):
        from glue.clients.layer_artist import RGBImageLayerArtist
        from glue.core import Data
        d = Data()
        self.artist = RGBImageLayerArtist(d, None)
        self.w = qtutil.RGBEdit(artist=self.artist)

    def test_update_visible(self):
        for color in ['red', 'green', 'blue']:
            state = self.artist.layer_visible[color]
            self.w.vis[color].click()
            assert self.artist.layer_visible[color] != state

    def test_update_current(self):
        for color in ['red', 'green', 'blue']:
            self.w.current[color].click()
            assert self.artist.contrast_layer == color

########NEW FILE########
__FILENAME__ = test_simpleforms
from ..simpleforms import build_form_item, FloatOption, IntOption, BoolOption


class Stub(object):
    i = IntOption(label="int", min=0, max=3, default=2)
    f = FloatOption(label="x", min=0, max=1, default=0.5)
    b = BoolOption(label="y", default=True)


class TestBuildFormItem(object):

    def test_int(self):
        s = Stub()
        w = build_form_item(s, 'i')
        assert w.label == "int"
        assert w.widget.value() == 2
        assert w.widget.minimum() == 0
        assert w.widget.maximum() == 3
        assert w.value == 2

    def test_float(self):
        s = Stub()
        w = build_form_item(s, 'f')
        assert w.label == "x"
        assert w.value == 0.5
        assert w.widget.minimum() == 0
        assert w.widget.maximum() == 1

    def test_bool(self):
        s = Stub()
        w = build_form_item(s, 'b')

        assert w.label == 'y'
        assert w.value is True
        assert w.widget.isChecked()

########NEW FILE########
__FILENAME__ = test_spectrum_tool
import pytest
import numpy as np
from mock import MagicMock

from ...core.tests.util import simple_session
from ...core import Data, Coordinates
from ...core.roi import RectangularROI
from ..widgets import ImageWidget

from ..spectrum_tool import Extractor, ConstraintsWidget, FitSettingsWidget
from ...core.fitters import PolynomialFitter

needs_modeling = lambda x: x
try:
    from ...core.fitters import SimpleAstropyGaussianFitter
except ImportError:
    needs_modeling = pytest.mark.skipif(True, reason='Needs astropy >= 0.3')


class MockCoordinates(Coordinates):

    def pixel2world(self, *args):
        return [a * 2 for a in args]

    def world2pixel(self, *args):
        return [a / 2 for a in args]


class TestSpectrumTool(object):

    def setup_method(self, method):
        d = Data(x=np.zeros((3, 3, 3)))
        session = simple_session()
        session.data_collection.append(d)

        self.image = ImageWidget(session)
        self.image.add_data(d)
        self.image.data = d
        self.image.attribute = d.id['x']
        self.tool = self.image._spectrum_tool
        self.tool.show = lambda *args: None

    def build_spectrum(self):
        roi = RectangularROI()
        roi.update_limits(0, 2, 0, 2)
        self.tool._update_profile()

    def test_reset_on_view_change(self):
        self.build_spectrum()

        self.tool.reset = MagicMock()
        self.image.client.slice = ('x', 1, 'y')
        assert self.tool.reset.call_count > 0


class Test3DExtractor(object):

    def setup_method(self, method):
        self.data = Data()
        self.data.coords = MockCoordinates()
        self.data.add_component(np.random.random((3, 4, 5)), label='x')
        self.x = self.data['x']

    def test_abcissa(self):
        expected = [0, 2, 4]
        actual = Extractor.abcissa(self.data, 0)
        np.testing.assert_equal(expected, actual)

        expected = [0, 2, 4, 6]
        actual = Extractor.abcissa(self.data, 1)
        np.testing.assert_equal(expected, actual)

        expected = [0, 2, 4, 6, 8]
        actual = Extractor.abcissa(self.data, 2)
        np.testing.assert_equal(expected, actual)

    def test_spectrum(self):
        roi = RectangularROI()
        roi.update_limits(0, 0, 3, 3)

        expected = self.x[:, :3, :3].mean(axis=1).mean(axis=1)
        _, actual = Extractor.spectrum(
            self.data, self.data.id['x'], roi, (0, 'x', 'y'), 0)
        np.testing.assert_array_almost_equal(expected, actual)

    def test_spectrum_oob(self):
        roi = RectangularROI()
        roi.update_limits(-1, -1, 3, 3)

        expected = self.x[:, :3, :3].mean(axis=1).mean(axis=1)

        _, actual = Extractor.spectrum(self.data, self.data.id['x'],
                                       roi, (0, 'x', 'y'), 0)
        np.testing.assert_array_almost_equal(expected, actual)

    def test_pixel2world(self):
        # p2w(x) = 2x, 0 <= x <= 2
        assert Extractor.pixel2world(self.data, 0, 1) == 2

        # clips to boundary
        assert Extractor.pixel2world(self.data, 0, -1) == 0
        assert Extractor.pixel2world(self.data, 0, 5) == 4

    def test_world2pixel(self):
        # w2p(x) = x/2, 0 <= x <= 4
        assert Extractor.world2pixel(self.data, 0, 2) == 1

        # clips to boundary
        assert Extractor.world2pixel(self.data, 0, -1) == 0
        assert Extractor.world2pixel(self.data, 0, 8) == 2

    def test_extract_subset(self):
        sub = self.data.new_subset()
        sub.subset_state = self.data.id['x'] > .5
        slc = (0, 'y', 'x')
        mask = sub.to_mask()[0]
        mask = mask.reshape(-1, mask.shape[0], mask.shape[1])

        expected = (self.x * mask).sum(axis=1).sum(axis=1)
        expected /= mask.sum(axis=1).sum(axis=1)
        _, actual = Extractor.subset_spectrum(sub, self.data.id['x'],
                                              slc, 0)
        np.testing.assert_array_almost_equal(expected, actual)


class Test4DExtractor(object):

    def setup_method(self, method):
        self.data = Data()
        self.data.coords = MockCoordinates()
        x, y, z, w = np.mgrid[:3, :4, :5, :4]
        self.data.add_component(1. * w, label='x')

    def test_extract(self):

        roi = RectangularROI()
        roi.update_limits(0, 0, 2, 3)

        expected = self.data['x'][:, :2, :3, 1].mean(axis=1).mean(axis=1)
        _, actual = Extractor.spectrum(self.data, self.data.id['x'],
                                       roi, (0, 'x', 'y', 1), 0)

        np.testing.assert_array_equal(expected, actual)


class TestConstraintsWidget(object):

    def setup_method(self, method):
        self.constraints = dict(a=dict(fixed=True, value=1, limits=None))
        self.widget = ConstraintsWidget(self.constraints)

    def test_settings(self):
        assert self.widget.settings('a') == dict(fixed=True, value=1,
                                                 limits=None)

    def test_update_settings(self):
        self.widget._widgets['a'][2].setChecked(False)
        assert self.widget.settings('a')['fixed'] is False

    def test_update_constraints(self):
        self.widget._widgets['a'][2].setChecked(False)
        fitter = MagicMock()
        self.widget.update_constraints(fitter)
        fitter.set_constraint.assert_called_once_with('a',
                                                      fixed=False, value=1,
                                                      limits=None)


class TestFitSettingsWidget(object):

    def test_option(self):
        f = PolynomialFitter()
        f.degree = 1
        w = FitSettingsWidget(f)
        w.widgets['degree'].setValue(5)
        w.update_fitter_from_settings()
        assert f.degree == 5

    @needs_modeling
    def test_set_constraints(self):
        f = SimpleAstropyGaussianFitter()
        w = FitSettingsWidget(f)
        w.constraints._widgets['amplitude'][2].setChecked(True)
        w.update_fitter_from_settings()
        assert f.constraints['amplitude']['fixed']


def test_4d_single_channel():

    x = np.random.random((1, 7, 5, 9))
    d = Data(x=x)
    slc = (0, 0, 'x', 'y')
    zaxis = 1
    expected = x[0, :, :, :].mean(axis=1).mean(axis=1)
    roi = RectangularROI()
    roi.update_limits(0, 0, 10, 10)

    _, actual = Extractor.spectrum(d, d.id['x'], roi, slc, zaxis)

    np.testing.assert_array_almost_equal(expected, actual)

########NEW FILE########
__FILENAME__ = test_toolbar
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import matplotlib.pyplot as plt
from ...external.qt.QtGui import QMainWindow, QIcon
from ..widgets import MplWidget
from ..glue_toolbar import GlueToolbar
from ..mouse_mode import MouseMode
from ..qtutil import get_icon


class TestMode(MouseMode):

    def __init__(self, axes, release_callback=None):
        super(TestMode, self).__init__(axes, release_callback=release_callback)
        self.icon = get_icon('square')
        self.mode_id = 'TEST'
        self.action_text = 'test text'
        self.tool_tip = 'just testing'
        self.last_mode = None

    def press(self, event):
        self.last_mode = 'PRESS'

    def move(self, event):
        self.last_mode = 'MOVE'


class TestToolbar(object):

    def setup_method(self, method):
        from ...external.qt.QtGui import QApplication
        assert QApplication.instance() is not None
        self.win = QMainWindow()
        widget, axes = self._make_plot_widget(self.win)
        self.canvas = widget.canvas
        self.axes = axes
        self.tb = GlueToolbar(self.canvas, self.win)
        self.mode = TestMode(self.axes, release_callback=self.callback)
        self.tb.add_mode(self.mode)
        self.win.addToolBar(self.tb)
        self._called_back = False

    def _make_plot_widget(self, parent):
        widget = MplWidget(parent)
        ax = widget.canvas.fig.add_subplot(111)
        p = ax.plot([1, 2, 3])[0]
        return widget, ax

    def callback(self, mode):
        self._called_back = True

    def assert_valid_mode_state(self, target_mode):
        for mode in self.tb.buttons:
            if mode == target_mode and self.tb.buttons[mode].isCheckable():
                assert self.tb.buttons[mode].isChecked()
                self.tb._active == target_mode
            else:
                assert not self.tb.buttons[mode].isChecked()

    def test_callback(self):
        self.tb.buttons['TEST'].trigger()
        self.mode.release(None)
        assert self._called_back

########NEW FILE########
__FILENAME__ = test_widget_properties
from ..widget_properties import (ButtonProperty,
                                 FloatLineProperty)

from ...external.qt.QtGui import QCheckBox, QLineEdit


class TestClass(object):
    b = ButtonProperty('_button')
    fl = FloatLineProperty('_float')

    def __init__(self):
        self._button = QCheckBox()
        self._float = QLineEdit()


def test_button():
    tc = TestClass()
    assert tc.b == tc._button.checkState()

    tc.b = True
    assert tc._button.isChecked()

    tc.b = False
    assert not tc._button.isChecked()

    tc._button.setChecked(True)
    assert tc.b

    tc._button.setChecked(False)
    assert not tc.b


def test_float():
    tc = TestClass()

    tc.fl = 1.0
    assert float(tc._float.text()) == 1.0

    tc._float.setText('10')
    assert tc.fl == 10.0

########NEW FILE########
__FILENAME__ = layertree
from glue.external.qt import QtCore, QtGui
from ..data_collection_model import DataCollectionView
from ..qtutil import GlueActionButton, get_icon


class Ui_LayerTree(object):
    def setupUi(self, LayerTree):
        font = QtGui.QFont()
        font.setPointSize(11)

        LayerTree.setObjectName("LayerTree")
        LayerTree.resize(241, 282)

        self.layout = QtGui.QVBoxLayout(LayerTree)
        self.layout.setSpacing(2)
        self.layout.setContentsMargins(5, 5, 5, 0)
        self.layout.setObjectName("layout")

        self.layerTree = DataCollectionView(LayerTree)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred,
                                       QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(10)
        sizePolicy.setHeightForWidth(self.layerTree.sizePolicy().hasHeightForWidth())
        self.layerTree.setSizePolicy(sizePolicy)
        self.layerTree.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
        self.layerTree.setObjectName("layerTree")
        self.layout.addWidget(self.layerTree)

        self.button_row = QtGui.QHBoxLayout()
        self.button_row.setSpacing(3)
        self.button_row.setObjectName("button_row")

        self.layerAddButton = QtGui.QPushButton(LayerTree)
        self.layerAddButton.setFont(font)
        icon = get_icon('glue_open')
        self.layerAddButton.setIcon(icon)
        self.layerAddButton.setIconSize(QtCore.QSize(18, 18))
        self.layerAddButton.setDefault(False)
        self.layerAddButton.setObjectName("layerAddButton")

        self.button_row.addWidget(self.layerAddButton)
        self.newSubsetButton = GlueActionButton(LayerTree)
        self.newSubsetButton.setIcon(get_icon('glue_subset'))
        self.newSubsetButton.setIconSize(QtCore.QSize(19, 19))
        self.newSubsetButton.setObjectName("newSubsetButton")
        self.button_row.addWidget(self.newSubsetButton)
        self.newSubsetButton.setFont(font)

        self.layerRemoveButton = QtGui.QPushButton(LayerTree)
        self.layerRemoveButton.setEnabled(False)
        self.layerRemoveButton.setIcon(get_icon('glue_delete'))
        self.layerRemoveButton.setObjectName("layerRemoveButton")
        self.layerRemoveButton.setFont(font)
        self.button_row.addWidget(self.layerRemoveButton)

        self.linkButton = GlueActionButton(LayerTree)
        self.linkButton.setEnabled(True)
        self.linkButton.setIcon(get_icon('glue_link'))
        self.linkButton.setObjectName("linkButton")
        self.linkButton.setFont(font)
        self.button_row.addWidget(self.linkButton)

        spacerItem = QtGui.QSpacerItem(20, 20,
                                       QtGui.QSizePolicy.Expanding,
                                       QtGui.QSizePolicy.Minimum)
        self.button_row.addItem(spacerItem)
        self.layout.addLayout(self.button_row)

        self.retranslateUi(LayerTree)
        QtCore.QMetaObject.connectSlotsByName(LayerTree)

    def retranslateUi(self, LayerTree):
        LayerTree.setWindowTitle(QtGui.QApplication.translate("LayerTree", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.layerAddButton.setToolTip(QtGui.QApplication.translate("LayerTree", "Load a new data set", None, QtGui.QApplication.UnicodeUTF8))
        self.newSubsetButton.setToolTip(QtGui.QApplication.translate("LayerTree", "Create a new empty subset", None, QtGui.QApplication.UnicodeUTF8))
        self.layerRemoveButton.setToolTip(QtGui.QApplication.translate("LayerTree", "Delete Layer", None, QtGui.QApplication.UnicodeUTF8))
        self.linkButton.setToolTip(QtGui.QApplication.translate("LayerTree", "Link data", None, QtGui.QApplication.UnicodeUTF8))

########NEW FILE########
__FILENAME__ = custom_component_widget
from ...external.qt.QtGui import QDialog

from ... import core
from ...core import parse

from ..qtutil import load_ui


def disambiguate(label, labels):
    """ Changes name of label if it conflicts with labels list

    Parameters
    ----------
    label : string
    labels : collection of strings

    Returns
    -------
    label, perhaps appended with a suffix "_{number}". The output
    does not appear in labels
    """
    label = label.replace(' ', '_')
    if label not in labels:
        return label
    suffix = 1
    while label + ('_%i' % suffix) in labels:
        suffix += 1
    return label + ('_%i' % suffix)


class CustomComponentWidget(object):
    """ Dialog to add derived components to data via parsed commands """
    def __init__(self, collection, parent=None):
        self.ui = load_ui('custom_component_widget', parent)
        self._labels = {}
        self._data = {}
        self._collection = collection
        self._gather_components()
        self._gather_data()
        self._init_widgets()
        self._connect()

    def _connect(self):
        cl = self.ui.component_list
        cl.itemDoubleClicked.connect(self._add_to_expression)

    def _init_widgets(self):
        """ Set up default state of widget """
        comps = self.ui.component_list
        comps.addItems(sorted(self._labels.keys()))
        data = self.ui.data_list
        data.addItems(sorted(self._data.keys()))

    def _gather_components(self):
        """ Build a mapping from unique labels -> componentIDs """
        comps = set()
        for data in self._collection:
            for c in data.components:
                if c in comps:
                    continue
                label = "%s  (%s)" % (c, data.label)
                label = disambiguate(label, self._labels)
                self._labels[label] = c
                comps.add(c)

    def _gather_data(self):
        """ Build a mapping from unique labels -> data objects """
        for data in self._collection:
            label = data.label
            label = disambiguate(label, self._data)
            self._data[label] = data

    def _selected_data(self):
        """ Yield all data objects that are selected in the DataList """
        for items in self.ui.data_list.selectedItems():
            yield self._data[str(items.text())]

    def _create_link(self):
        """ Create a ComponentLink form the state of the GUI

        Returns
        -------
        A new component link
        """
        expression = str(self.ui.expression.text())
        pc = parse.ParsedCommand(expression, self._labels)
        label = str(self.ui.new_label.text()) or 'new component'
        new_id = core.data.ComponentID(label)
        link = parse.ParsedComponentLink(new_id, pc)
        return link

    def _add_link_to_targets(self, link):
        """ Add a link to all the selected data """
        for target in self._selected_data():
            target.add_component_link(link)

    def _add_to_expression(self, item):
        """ Add a component list item to the expression editor """
        addition = ' {%s} ' % item.text()
        expression = self.ui.expression
        pos = expression.cursorPosition()
        text = str(expression.displayText())
        expression.setText(text[:pos] + addition + text[pos:])

    @staticmethod
    def create_component(collection):
        """Present user with a dialog to define and add new components.

        Parameters
        ----------
        collection : A `DataCollection` to edit
        """
        # pylint: disable=W0212
        widget = CustomComponentWidget(collection)
        widget.ui.show()
        if widget.ui.exec_() == QDialog.Accepted:
            link = widget._create_link()
            if link:
                widget._add_link_to_targets(link)


def main():
    from glue.core.data import Data
    from glue.core.data_collection import DataCollection
    import numpy as np

    x = np.random.random((5, 5))
    y = x * 3
    data = DataCollection(Data(label='test', x=x, y=y))

    CustomComponentWidget.create_component(data)
    for d in data:
        print d.label
        for c in d.components:
            print '\t%s' % c

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = data_slice_widget
from functools import partial
from collections import Counter

from ...external.qt.QtGui import (QWidget, QSlider, QLabel, QComboBox,
                                  QHBoxLayout, QVBoxLayout)
from ...external.qt.QtCore import Qt, Signal

from ..widget_properties import (TextProperty,
                                 ValueProperty,
                                 CurrentComboProperty)


class SliceWidget(QWidget):
    label = TextProperty('_ui_label')
    slice_center = ValueProperty('_ui_slider')
    mode = CurrentComboProperty('_ui_mode')

    slice_changed = Signal(int)
    mode_changed = Signal(str)

    def __init__(self, label='', pix2world=None, lo=0, hi=10,
                 parent=None, aggregation=None):
        super(SliceWidget, self).__init__(parent)
        if aggregation is not None:
            raise NotImplemented("Aggregation option not implemented")
        if pix2world is not None:
            raise NotImplemented("Pix2world option not implemented")

        layout = QVBoxLayout()
        layout.setContentsMargins(3, 1, 3, 1)

        top = QHBoxLayout()
        top.setContentsMargins(3, 3, 3, 3)
        label = QLabel(label)
        top.addWidget(label)

        mode = QComboBox()
        mode.addItem('x', 'x')
        mode.addItem('y', 'y')
        mode.addItem('slice', 'slice')
        mode.currentIndexChanged.connect(lambda x:
                                         self.mode_changed.emit(self.mode))
        mode.currentIndexChanged.connect(self._update_mode)
        top.addWidget(mode)

        layout.addLayout(top)

        slider = QSlider(Qt.Horizontal)
        slider.setMinimum(lo)
        slider_lbl = QLabel()
        slider.setMaximum(hi)
        slider.setValue((lo + hi) / 2)
        slider.valueChanged.connect(lambda x:
                                    self.slice_changed.emit(self.mode))
        slider.valueChanged.connect(lambda x: slider_lbl.setText(str(x)))
        layout.addWidget(slider_lbl)
        layout.addWidget(slider)

        self.setLayout(layout)

        self._ui_label = label
        self._ui_slider = slider
        self._slider_lbl = slider_lbl
        self._ui_mode = mode
        self._update_mode()
        self._frozen = False

    def _update_mode(self, *args):
        if self.mode != 'slice':
            self._ui_slider.hide()
            self._slider_lbl.hide()
        else:
            self._ui_slider.show()
            self._slider_lbl.show()

    def freeze(self):
        self.mode = 'slice'
        self._ui_mode.setEnabled(False)
        self._ui_slider.hide()
        self._frozen = True

    @property
    def frozen(self):
        return self._frozen


class DataSlice(QWidget):

    """
    A DatSlice widget provides an inteface for selection
    slices through an N-dimensional dataset

    Signals
    -------
    slice_changed : triggered when the slice through the data changes
    """
    slice_changed = Signal()

    def __init__(self, data=None, parent=None):
        """
        :param data: :class:`~glue.core.Data` instance, or None
        """
        super(DataSlice, self).__init__(parent)
        self._slices = []
        layout = QVBoxLayout()
        layout.setSpacing(4)
        layout.setContentsMargins(0, 3, 0, 3)
        self.layout = layout
        self.setLayout(layout)
        self.set_data(data)

    def _clear(self):
        for _ in range(self.layout.count()):
            self.layout.takeAt(0)

        for s in self._slices:
            s.close()
        self._slices = []

    def set_data(self, data):
        """
        Change datasets

        :parm data: :class:`~glue.core.Data` instance
        """
        self._clear()
        if data is None:
            self.ndim = 0
            return

        self.ndim = len(data.shape)
        if self.ndim < 3:
            return

        for i, s in enumerate(data.shape):
            slider = SliceWidget(data.get_world_component_id(i).label,
                                 hi=s - 1)

            if i == self.ndim - 1:
                slider.mode = 'x'
            elif i == self.ndim - 2:
                slider.mode = 'y'
            else:
                slider.mode = 'slice'
            self._slices.append(slider)

            # save ref to prevent PySide segfault
            self.__on_slice = partial(self._on_slice, i)
            self.__on_mode = partial(self._on_mode, i)

            slider.slice_changed.connect(self.__on_slice)
            slider.mode_changed.connect(self.__on_mode)
            if s == 1:
                slider.freeze()

        for s in self._slices[::-1]:
            self.layout.addWidget(s)
        self.layout.addStretch(5)

    def _on_slice(self, index, slice_val):
        self.slice_changed.emit()

    def _on_mode(self, index, mode_index):
        s = self.slice

        def isok(ss):
            # valid slice description: 'x' and 'y' both appear
            c = Counter(ss)
            return c['x'] == 1 and c['y'] == 1

        if isok(s):
            self.slice_changed.emit()
            return

        for i in range(len(s)):
            if i == index:
                continue
            if self._slices[i].frozen:
                continue

            for mode in 'x', 'y', 'slice':
                if self._slices[i].mode == mode:
                    continue

                ss = list(s)
                ss[i] = mode
                if isok(ss):
                    self._slices[i].mode = mode
                    return

        else:
            raise RuntimeError("Corrupted Data Slice")

    @property
    def slice(self):
        """
        A description of the slice through the dataset

        A tuple of lenght equal to the dimensionality of the data

        Each element is an integer, 'x', or 'y'
        'x' and 'y' indicate the horizontal and vertical orientation
        of the slice
        """
        if self.ndim < 3:
            return {0: tuple(), 1: ('x',), 2: ('y', 'x')}[self.ndim]

        return tuple(s.mode if s.mode != 'slice' else s.slice_center
                     for s in self._slices)

    @slice.setter
    def slice(self, value):
        for v, s in zip(value, self._slices):
            if v in ['x', 'y']:
                s.mode = v
            else:
                s.mode = 'slice'
                s.slice_center = v

########NEW FILE########
__FILENAME__ = data_viewer
import os

from ...external.qt.QtGui import (
    QMainWindow, QMessageBox, QWidget, QMdiSubWindow)

from ...external.qt.QtCore import Qt

from ...core.application_base import ViewerBase
from ..decorators import set_cursor

from ..layer_artist_model import QtLayerArtistContainer, LayerArtistView
from .. import get_qapp
from ..mime import LAYERS_MIME_TYPE, LAYER_MIME_TYPE

__all__ = ['DataViewer']


class DataViewer(QMainWindow, ViewerBase):

    """Base class for all Qt DataViewer widgets.

    This defines a minimal interface, and implemlements the following::

       * An automatic call to unregister on window close
       * Drag and drop support for adding data
    """
    _container_cls = QtLayerArtistContainer

    def __init__(self, session, parent=None):
        """
        :type session: :class:`~glue.core.Session`
        """
        QMainWindow.__init__(self, parent)
        ViewerBase.__init__(self, session)
        self.setWindowIcon(get_qapp().windowIcon())
        self._view = LayerArtistView()
        self._view.setModel(self._container.model)
        self._tb_vis = {}  # store whether toolbars are enabled
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setAcceptDrops(True)
        self.setAnimated(False)
        self._toolbars = []
        self._warn_close = True
        self.setContentsMargins(2, 2, 2, 2)
        self._mdi_wrapper = None  # QMdiSubWindow that self is embedded in
        self.statusBar().setStyleSheet("QStatusBar{font-size:10px}")

    def remove_layer(self, layer):
        self._container.pop(layer)

    def dragEnterEvent(self, event):
        """ Accept the event if it has data layers"""
        if event.mimeData().hasFormat(LAYER_MIME_TYPE):
            event.accept()
        elif event.mimeData().hasFormat(LAYERS_MIME_TYPE):
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event):
        """ Add layers to the viewer if contained in mime data """

        if event.mimeData().hasFormat(LAYER_MIME_TYPE):
            self.request_add_layer(event.mimeData().data(LAYER_MIME_TYPE))

        assert event.mimeData().hasFormat(LAYERS_MIME_TYPE)

        for layer in event.mimeData().data(LAYERS_MIME_TYPE):
            self.request_add_layer(layer)

        event.accept()

    def mousePressEvent(self, event):
        """ Consume mouse press events, and prevent them from propagating
            down to the MDI area """
        event.accept()

    apply_roi = set_cursor(Qt.WaitCursor)(ViewerBase.apply_roi)

    def close(self, warn=True):
        self._warn_close = warn
        super(DataViewer, self).close()
        self._warn_close = True

    def mdi_wrap(self):
        """Wrap this object in a QMdiSubWindow"""
        sub = QMdiSubWindow()
        sub.setWidget(self)
        self.destroyed.connect(sub.close)
        sub.resize(self.size())
        self._mdi_wrapper = sub

        return sub

    @property
    def position(self):
        target = self._mdi_wrapper or self
        pos = target.pos()
        return pos.x(), pos.y()

    def move(self, x=None, y=None):
        x0, y0 = self.position
        if x is None:
            x = x0
        if y is None:
            y = y0
        if self._mdi_wrapper is not None:
            self._mdi_wrapper.move(x, y)
        else:
            QMainWindow.move(self, x, y)

    @property
    def viewer_size(self):
        sz = QMainWindow.size(self)
        return sz.width(), sz.height()

    @viewer_size.setter
    def viewer_size(self, value):
        width, height = value
        self.resize(width, height)
        if self._mdi_wrapper is not None:
            self._mdi_wrapper.resize(width, height)

    def closeEvent(self, event):
        """ Call unregister on window close """
        if not self._confirm_close():
            event.ignore()
            return

        if self._hub is not None:
            self.unregister(self._hub)
        super(DataViewer, self).closeEvent(event)

    def _confirm_close(self):
        """Ask for close confirmation

        :rtype: bool. True if user wishes to close. False otherwise
        """
        if self._warn_close and (not os.environ.get('GLUE_TESTING')):
            buttons = QMessageBox.Ok | QMessageBox.Cancel
            dialog = QMessageBox.warning(self, "Confirm Close",
                                         "Do you want to close this window?",
                                         buttons=buttons,
                                         defaultButton=QMessageBox.Cancel)
            return dialog == QMessageBox.Ok
        return True

    def _confirm_large_data(self, data):
        warn_msg = ("WARNING: Data set has %i points, and may render slowly."
                    " Continue?" % data.size)
        title = "Add large data set?"
        ok = QMessageBox.Ok
        cancel = QMessageBox.Cancel
        buttons = ok | cancel
        result = QMessageBox.question(self, title, warn_msg,
                                      buttons=buttons,
                                      defaultButton=cancel)
        return result == ok

    def layer_view(self):
        return self._view

    def options_widget(self):
        return QWidget()

    def addToolBar(self, tb):
        super(DataViewer, self).addToolBar(tb)
        self._toolbars.append(tb)
        self._tb_vis[tb] = True

    def show_toolbars(self):
        """Re-enable any toolbars that were hidden with `hide_toolbars()`

        Does not re-enable toolbars that were hidden by other means
        """
        for tb in self._toolbars:
            if self._tb_vis.get(tb, False):
                tb.setEnabled(True)

    def hide_toolbars(self):
        """ Disable all the toolbars in the viewer.

        This action can be reversed by calling `show_toolbars()`
        """
        for tb in self._toolbars:
            self._tb_vis[tb] = self._tb_vis.get(tb, False) or tb.isVisible()
            tb.setEnabled(False)

    def set_focus(self, state):
        if state:
            css = """
            DataViewer
            {
            border: 2px solid;
            border-color: rgb(56, 117, 215);
            }
            """
            self.setStyleSheet(css)
            self.show_toolbars()
        else:
            css = """
            DataViewer
            {
            border: none;
            }
            """
            self.setStyleSheet(css)
            self.hide_toolbars()

########NEW FILE########
__FILENAME__ = edit_subset_mode_toolbar
from ...external.qt import QtGui

from ...core.edit_subset_mode import (EditSubsetMode, OrMode, AndNotMode,
                                      AndMode, XorMode, ReplaceMode)
from ..actions import act
from ..qtutil import nonpartial


def set_mode(mode):
    edit_mode = EditSubsetMode()
    edit_mode.mode = mode


class EditSubsetModeToolBar(QtGui.QToolBar):

    def __init__(self, title="Subset Update Mode", parent=None):
        super(EditSubsetModeToolBar, self).__init__(title, parent)
        self._group = QtGui.QActionGroup(self)
        self._modes = {}
        self._add_actions()
        self._modes[EditSubsetMode().mode].trigger()
        self._backup_mode = None

    def _make_mode(self, name, tip, icon, mode):
        a = act(name, self, tip, icon)
        a.setCheckable(True)
        a.triggered.connect(nonpartial(set_mode, mode))
        self._group.addAction(a)
        self.addAction(a)
        self._modes[mode] = a
        label = name.split()[0].lower()
        self._modes[label] = mode

    def _add_actions(self):
        self._make_mode("Replace Mode", "Replace selection",
                        'glue_replace', ReplaceMode)
        self._make_mode("Or Mode", "Add to selection",
                        'glue_or', OrMode)
        self._make_mode("And Mode", "Set selection as intersection",
                        'glue_and', AndMode)
        self._make_mode("Xor Mode", "Set selection as exclusive intersection",
                        'glue_xor', XorMode)
        self._make_mode("Not Mode", "Remove from selection",
                        'glue_andnot', AndNotMode)

    def set_mode(self, mode):
        """Temporarily set the edit mode to mode
        :param mode: Name of the mode (Or, Not, And, Xor, Replace)
        :type mode: str
        """
        try:
            mode = self._modes[mode]  # label to mode class
        except KeyError:
            raise KeyError("Unrecognized mode: %s" % mode)

        self._backup_mode = self._backup_mode or EditSubsetMode().mode
        self._modes[mode].trigger()  # mode class to action

    def unset_mode(self):
        """Restore the mode to the state before set_mode was called"""
        mode = self._backup_mode
        self._backup_mode = None
        if mode:
            self._modes[mode].trigger()

########NEW FILE########
__FILENAME__ = glue_mdi_area
from ...external.qt import QtGui
from ...external.qt.QtCore import Qt

from ... import core
from ..mime import LAYER_MIME_TYPE, LAYERS_MIME_TYPE


class GlueMdiArea(QtGui.QMdiArea):
    """Glue's MdiArea implementation.

    Drop events with :class:`~glue.core.Data` objects in
    :class:`~glue.qt.mime.PyMimeData` load these objects into new
    data viewers
    """
    def __init__(self, application, parent=None):
        """
        :param application: The Glue application to which this is attached
        :type application: :class:`~glue.qt.glue_application.GlueApplication`
        """
        super(GlueMdiArea, self).__init__(parent)
        self._application = application
        self.setAcceptDrops(True)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setBackground(QtGui.QBrush(QtGui.QColor(250, 250, 250)))
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self._show_help = False

    @property
    def show_help(self):
        return self._show_help

    @show_help.setter
    def show_help(self, value):
        self._show_help = value
        self.repaint()

    def addSubWindow(self, sub):
        super(GlueMdiArea, self).addSubWindow(sub)
        self.repaint()

    def dragEnterEvent(self, event):
        """ Accept the event if it has an application/py_instance format """

        if event.mimeData().hasFormat(LAYERS_MIME_TYPE):
            event.accept()
        elif event.mimeData().hasFormat(LAYER_MIME_TYPE):
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event):
        """ Load a new data viewer if the event has a glue Data object """
        md = event.mimeData()

        def new_layer(layer):
            if isinstance(layer, core.data.Data):
                self._application.choose_new_data_viewer(layer)
            else:
                assert isinstance(layer, core.subset.Subset)
                self._application.choose_new_data_viewer(layer.data)

        if md.hasFormat(LAYER_MIME_TYPE):
            new_layer(md.data(LAYER_MIME_TYPE))

        assert md.hasFormat(LAYERS_MIME_TYPE)
        for layer in md.data(LAYERS_MIME_TYPE):
            new_layer(layer)

        event.accept()

    def mousePressEvent(self, event):
        """Right mouse press in the MDI area opens a new data viewer"""
        if event.button() != Qt.RightButton:
            return
        self._application.choose_new_data_viewer()

    def close(self):
        self.closeAllSubWindows()
        super(GlueMdiArea, self).close()

    def paintEvent(self, event):
        super(GlueMdiArea, self).paintEvent(event)
        if (not self.show_help):
            return

        painter = QtGui.QPainter(self.viewport())
        painter.setPen(QtGui.QColor(210, 210, 210))
        font = painter.font()
        font.setPointSize(48)
        font.setWeight(font.Black)
        painter.setFont(font)
        rect = self.contentsRect()
        painter.drawText(rect, Qt.AlignHCenter | Qt.AlignVCenter,
                         "Drag Data To Plot")

########NEW FILE########
__FILENAME__ = histogram_widget
from functools import partial

from ...external.qt import QtGui
from ...external.qt.QtCore import Qt

from ...core import message as msg
from ...clients.histogram_client import HistogramClient
from ..widget_properties import (connect_int_spin, ButtonProperty,
                                 FloatLineProperty,
                                 ValueProperty)
from ..glue_toolbar import GlueToolbar
from ..mouse_mode import HRangeMode
from .data_viewer import DataViewer
from .mpl_widget import MplWidget, defer_draw
from ..qtutil import pretty_number, load_ui

__all__ = ['HistogramWidget']


WARN_SLOW = 10000000


def _hash(x):
    return str(id(x))


class HistogramWidget(DataViewer):
    LABEL = "Histogram"
    _property_set = DataViewer._property_set + \
        'component xlog ylog normed cumulative autoscale xmin xmax nbins'.split(
        )

    xmin = FloatLineProperty('ui.xmin', 'Minimum value')
    xmax = FloatLineProperty('ui.xmax', 'Maximum value')
    normed = ButtonProperty('ui.normalized_box', 'Normalized?')
    autoscale = ButtonProperty('ui.autoscale_box',
                               'Autoscale view to histogram?')
    cumulative = ButtonProperty('ui.cumulative_box', 'Cumulative?')
    nbins = ValueProperty('ui.binSpinBox', 'Number of bins')
    xlog = ButtonProperty('ui.xlog_box', 'Log-scale the x axis?')
    ylog = ButtonProperty('ui.ylog_box', 'Log-scale the y axis?')

    def __init__(self, session, parent=None):
        super(HistogramWidget, self).__init__(session, parent)

        self.central_widget = MplWidget()
        self.setCentralWidget(self.central_widget)
        self.option_widget = QtGui.QWidget()
        self.ui = load_ui('histogramwidget', self.option_widget)
        self._tweak_geometry()
        self.client = HistogramClient(self._data,
                                      self.central_widget.canvas.fig,
                                      artist_container=self._container)
        self._init_limits()
        self.make_toolbar()
        self._connect()
        # maps _hash(componentID) -> componentID
        self._component_hashes = {}

    def _init_limits(self):
        validator = QtGui.QDoubleValidator(None)
        validator.setDecimals(7)
        self.ui.xmin.setValidator(validator)
        self.ui.xmax.setValidator(validator)
        lo, hi = self.client.xlimits
        self.ui.xmin.setText(str(lo))
        self.ui.xmax.setText(str(hi))

    def _tweak_geometry(self):
        self.central_widget.resize(600, 400)
        self.resize(self.central_widget.size())

    def _connect(self):
        ui = self.ui
        cl = self.client
        ui.attributeCombo.currentIndexChanged.connect(
            self._set_attribute_from_combo)
        ui.attributeCombo.currentIndexChanged.connect(
            self._update_minmax_labels)
        connect_int_spin(cl, 'nbins', ui.binSpinBox)
        ui.normalized_box.toggled.connect(partial(setattr, cl, 'normed'))
        ui.autoscale_box.toggled.connect(partial(setattr, cl, 'autoscale'))
        ui.cumulative_box.toggled.connect(partial(setattr, cl, 'cumulative'))
        ui.xlog_box.toggled.connect(partial(setattr, cl, 'xlog'))
        ui.ylog_box.toggled.connect(partial(setattr, cl, 'ylog'))
        ui.xmin.editingFinished.connect(self._set_limits)
        ui.xmax.editingFinished.connect(self._set_limits)

    @defer_draw
    def _set_limits(self):
        lo = float(self.ui.xmin.text())
        hi = float(self.ui.xmax.text())
        self.client.xlimits = lo, hi

    def _update_minmax_labels(self):
        lo, hi = pretty_number(self.client.xlimits)
        self.ui.xmin.setText(lo)
        self.ui.xmax.setText(hi)

    def make_toolbar(self):
        result = GlueToolbar(self.central_widget.canvas, self,
                             name='Histogram')
        for mode in self._mouse_modes():
            result.add_mode(mode)
        self.addToolBar(result)
        return result

    def _mouse_modes(self):
        axes = self.client.axes

        def apply_mode(mode):
            return self.apply_roi(mode.roi())

        rect = HRangeMode(axes, roi_callback=apply_mode)
        return [rect]

    @defer_draw
    def _update_attributes(self):
        """Repopulate the combo box that selects the quantity to plot"""
        combo = self.ui.attributeCombo
        component = self.component
        combo.blockSignals(True)
        combo.clear()

        # implementation note:
        # PySide doesn't robustly store python objects with setData
        # use _hash(x) instead
        model = QtGui.QStandardItemModel()
        data_ids = set(_hash(d) for d in self._data)
        self._component_hashes = dict((_hash(c), c) for d in self._data
                                      for c in d.components)

        for d in self._data:
            if d not in self._container:
                continue
            item = QtGui.QStandardItem(d.label)
            item.setData(_hash(d), role=Qt.UserRole)
            assert item.data(Qt.UserRole) == _hash(d)
            item.setFlags(item.flags() & ~Qt.ItemIsEnabled)
            model.appendRow(item)
            for c in d.visible_components:
                if not d.get_component(c).numeric:
                    continue
                item = QtGui.QStandardItem(c.label)
                item.setData(_hash(c), role=Qt.UserRole)
                model.appendRow(item)
        combo.setModel(model)

        # separators below data items
        for i in range(combo.count()):
            if combo.itemData(i) in data_ids:
                combo.insertSeparator(i + 1)

        combo.blockSignals(False)

        if component is not None:
            self.component = component
        else:
            combo.setCurrentIndex(2)  # skip first data + separator
        self._set_attribute_from_combo()

    @property
    def component(self):
        combo = self.ui.attributeCombo
        index = combo.currentIndex()
        return self._component_hashes.get(combo.itemData(index), None)

    @component.setter
    def component(self, component):
        combo = self.ui.attributeCombo
        if combo.count() == 0:  # cold start problem, when restoring
            self._update_attributes()

        # combo.findData doesn't seem to work robustly
        for i in range(combo.count()):
            data = combo.itemData(i)
            if data == _hash(component):
                combo.setCurrentIndex(i)
                return
        raise IndexError("Component not present: %s" % component)

    @defer_draw
    def _set_attribute_from_combo(self, *args):
        self.client.set_component(self.component)
        self._update_window_title()

    @defer_draw
    def add_data(self, data):
        """ Add data item to combo box.
        If first addition, also update attributes """

        if self.data_present(data):
            return True

        if data.size > WARN_SLOW and not self._confirm_large_data(data):
            return False

        self.client.add_layer(data)
        self._update_attributes()
        self._update_minmax_labels()

        return True

    def add_subset(self, subset):
        pass

    def _remove_data(self, data):
        """ Remove data item from the combo box """
        pass

    def data_present(self, data):
        return data in self._container

    def register_to_hub(self, hub):
        super(HistogramWidget, self).register_to_hub(hub)
        self.client.register_to_hub(hub)

        hub.subscribe(self,
                      msg.DataCollectionDeleteMessage,
                      handler=lambda x: self._remove_data(x.data))

        hub.subscribe(self,
                      msg.DataUpdateMessage,
                      handler=lambda *args: self._update_labels())

        hub.subscribe(self,
                      msg.ComponentsChangedMessage,
                      handler=lambda x: self._update_attributes())

    def unregister(self, hub):
        self.client.unregister(hub)
        hub.unsubscribe_all(self)

    def _update_window_title(self):
        c = self.client.component
        if c is not None:
            label = str(c.label)
        else:
            label = 'Histogram'
        self.setWindowTitle(label)

    def _update_labels(self):
        self._update_window_title()
        self._update_attributes()

    def __str__(self):
        return "Histogram Widget"

    def options_widget(self):
        return self.option_widget

########NEW FILE########
__FILENAME__ = image_widget
import numpy as np

from ...external.qt.QtGui import (QAction, QLabel, QCursor, QMainWindow,
                                  QToolButton, QIcon, QMessageBox,
                                  QMdiSubWindow)

from ...external.qt.QtCore import Qt, QRect

from .data_viewer import DataViewer
from ... import core
from ... import config

from ...clients.image_client import ImageClient
from ...clients.ds9norm import DS9Normalize
from ...external.modest_image import imshow

from ...clients.layer_artist import Pointer
from ...core.callback_property import add_callback

from .data_slice_widget import DataSlice

from ..mouse_mode import (RectangleMode, CircleMode, PolyMode,
                          ContrastMode, ContourMode, PathMode)
from ..glue_toolbar import GlueToolbar
from ..spectrum_tool import SpectrumTool
from .mpl_widget import MplWidget, defer_draw

from ..decorators import set_cursor
from ..qtutil import cmap2pixmap, load_ui, get_icon, nonpartial
from ..widget_properties import CurrentComboProperty, ButtonProperty

WARN_THRESH = 10000000  # warn when contouring large images

__all__ = ['ImageWidget']


class ImageWidget(DataViewer):
    LABEL = "Image Viewer"
    _property_set = DataViewer._property_set + \
        'data attribute rgb_mode rgb_viz ratt gatt batt slice'.split()

    attribute = CurrentComboProperty('ui.attributeComboBox',
                                     'Current attribute')
    data = CurrentComboProperty('ui.displayDataCombo',
                                'Current data')
    rgb_mode = ButtonProperty('ui.rgb',
                              'RGB Mode?')
    rgb_viz = Pointer('ui.rgb_options.rgb_visible')

    def __init__(self, session, parent=None):
        super(ImageWidget, self).__init__(session, parent)
        self.central_widget = MplWidget()
        self.label_widget = QLabel("", self.central_widget)
        self.setCentralWidget(self.central_widget)
        self.ui = load_ui('imagewidget', None)
        self.option_widget = self.ui
        self.ui.slice = DataSlice()
        self.ui.slice_layout.addWidget(self.ui.slice)
        self.client = ImageClient(self._data,
                                  self.central_widget.canvas.fig,
                                  artist_container=self._container)
        self._spectrum_tool = SpectrumTool(self)
        self._tweak_geometry()

        self.make_toolbar()
        self._connect()
        self._init_widgets()
        self.set_data(0)
        self.statusBar().setSizeGripEnabled(False)
        self.setFocusPolicy(Qt.StrongFocus)
        self._slice_widget = None

    def _tweak_geometry(self):
        self.central_widget.resize(600, 400)
        self.resize(self.central_widget.size())
        self.ui.rgb_options.hide()

    def make_toolbar(self):
        result = GlueToolbar(self.central_widget.canvas, self, name='Image')
        for mode in self._mouse_modes():
            result.add_mode(mode)

        cmap = _colormap_mode(self, self.client.set_cmap)
        result.addWidget(cmap)

        # connect viewport update buttons to client commands to
        # allow resampling
        cl = self.client
        result.buttons['HOME'].triggered.connect(nonpartial(cl.check_update))
        result.buttons['FORWARD'].triggered.connect(nonpartial(
            cl.check_update))
        result.buttons['BACK'].triggered.connect(nonpartial(cl.check_update))

        self.addToolBar(result)
        return result

    def _mouse_modes(self):
        axes = self.client.axes

        def apply_mode(mode):
            self.apply_roi(mode.roi())

        def slice(mode):
            self._extract_slice(mode.roi())

        rect = RectangleMode(axes, roi_callback=apply_mode)
        circ = CircleMode(axes, roi_callback=apply_mode)
        poly = PolyMode(axes, roi_callback=apply_mode)
        contrast = ContrastMode(axes, move_callback=self._set_norm)
        contour = ContourMode(axes, release_callback=self._contour_roi)
        spectrum = self._spectrum_tool.mouse_mode
        path = PathMode(axes, roi_callback=slice)

        def toggle_3d_modes(data):
            is3d = data.ndim > 2
            path.enabled = is3d
            spectrum.enabled = is3d

        add_callback(self.client, 'display_data', toggle_3d_modes)

        self._contrast = contrast
        return [rect, circ, poly, contour, contrast, spectrum, path]

    def _extract_slice(self, roi):
        """
        Extract a PV-like slice, given a path traced on the widget
        """
        vx, vy = roi.to_polygon()
        pv, x, y = _slice_from_path(vx, vy, self.data, self.attribute, self.slice)
        if self._slice_widget is None:
            self._slice_widget = PVSliceWidget(pv, x, y, self)
            self._session.application.add_widget(self._slice_widget,
                                                 label='Custom Slice')
        else:
            self._slice_widget.set_image(pv, x, y)

        result = self._slice_widget
        result.axes.set_xlabel("Position Along Slice")
        result.axes.set_ylabel(_slice_label(self.data, self.slice))

        result.show()

    def _init_widgets(self):
        pass

    @defer_draw
    def add_data(self, data):
        """Private method to ingest new data into widget"""
        self.client.add_layer(data)
        self.add_data_to_combo(data)
        self.set_data(self._data_index(data))
        return True

    @defer_draw
    def add_subset(self, subset):
        self.client.add_scatter_layer(subset)
        assert subset in self.client.artists

    def _data_index(self, data):
        combo = self.ui.displayDataCombo

        for i in range(combo.count()):
            if combo.itemData(i) is data:
                return i

        return None

    def add_data_to_combo(self, data):
        """ Add a data object to the combo box, if not already present
        """
        if not self.client.can_image_data(data):
            return
        combo = self.ui.displayDataCombo
        label = data.label
        pos = combo.findText(label)
        if pos == -1:
            combo.addItem(label, userData=data)
        assert combo.findText(label) >= 0

    @property
    def ratt(self):
        """ComponentID assigned to R channel in RGB Mode"""
        return self.ui.rgb_options.attributes[0]

    @ratt.setter
    def ratt(self, value):
        att = list(self.ui.rgb_options.attributes)
        att[0] = value
        self.ui.rgb_options.attributes = att

    @property
    def gatt(self):
        """ComponentID assigned to G channel in RGB Mode"""
        return self.ui.rgb_options.attributes[1]

    @gatt.setter
    def gatt(self, value):
        att = list(self.ui.rgb_options.attributes)
        att[1] = value
        self.ui.rgb_options.attributes = att

    @property
    def batt(self):
        """ComponentID assigned to B channel in RGB Mode"""
        return self.ui.rgb_options.attributes[2]

    @batt.setter
    def batt(self, value):
        att = list(self.ui.rgb_options.attributes)
        att[2] = value
        self.ui.rgb_options.attributes = att

    @defer_draw
    def set_data(self, index):
        if index is None:
            return

        if self.ui.displayDataCombo.count() == 0:
            return

        data = self.ui.displayDataCombo.itemData(index)
        self.ui.slice.set_data(data)
        self.client.set_data(data)
        self.client.slice = self.ui.slice.slice
        self.ui.displayDataCombo.setCurrentIndex(index)
        self.set_attribute_combo(data)
        self._update_window_title()

    @property
    def slice(self):
        return self.client.slice

    @slice.setter
    def slice(self, value):
        self.ui.slice.slice = value

    @defer_draw
    def set_attribute(self, index):
        combo = self.ui.attributeComboBox
        component_id = combo.itemData(index)
        self.client.set_attribute(component_id)
        self.ui.attributeComboBox.setCurrentIndex(index)
        self._update_window_title()

    def set_attribute_combo(self, data):
        """ Update attribute combo box to reflect components in data"""
        combo = self.ui.attributeComboBox
        combo.blockSignals(True)
        combo.clear()
        fields = data.visible_components
        index = 0
        for i, f in enumerate(fields):
            combo.addItem(f.label, userData=f)
            if f == self.client.display_attribute:
                index = i
        combo.blockSignals(False)
        combo.setCurrentIndex(index)
        self.set_attribute(index)

    def _connect(self):
        ui = self.ui

        ui.displayDataCombo.currentIndexChanged.connect(self.set_data)
        ui.attributeComboBox.currentIndexChanged.connect(self.set_attribute)

        ui.monochrome.toggled.connect(self._update_rgb_console)
        ui.rgb_options.colors_changed.connect(self._update_window_title)
        ui.rgb_options.current_changed.connect(
            lambda: self._toolbars[0].set_mode(self._contrast))
        ui.slice.slice_changed.connect(self._update_slice)

        update_ui_slice = lambda val: setattr(ui.slice, 'slice', val)
        add_callback(self.client, 'slice', update_ui_slice)

    def _update_slice(self):
        self.client.slice = self.ui.slice.slice

    @defer_draw
    def _update_rgb_console(self, is_monochrome):
        if is_monochrome:
            self.ui.rgb_options.hide()
            self.ui.mono_att_label.show()
            self.ui.attributeComboBox.show()
            self.client.rgb_mode(False)
        else:
            self.ui.mono_att_label.hide()
            self.ui.attributeComboBox.hide()
            self.ui.rgb_options.show()
            rgb = self.client.rgb_mode(True)
            if rgb is not None:
                self.ui.rgb_options.artist = rgb

    def register_to_hub(self, hub):
        super(ImageWidget, self).register_to_hub(hub)
        self.client.register_to_hub(hub)

        dc_filt = lambda x: x.sender is self.client._data
        layer_present_filter = lambda x: x.data in self.client.artists

        hub.subscribe(self,
                      core.message.DataCollectionAddMessage,
                      handler=lambda x: self.add_data_to_combo(x.data),
                      filter=dc_filt)
        hub.subscribe(self,
                      core.message.DataCollectionDeleteMessage,
                      handler=lambda x: self.remove_data_from_combo(x.data),
                      filter=dc_filt)
        hub.subscribe(self,
                      core.message.DataUpdateMessage,
                      handler=lambda x: self._sync_data_labels()
                      )
        hub.subscribe(self,
                      core.message.ComponentsChangedMessage,
                      handler=lambda x: self.set_attribute_combo(x.data),
                      filter=layer_present_filter)

    def unregister(self, hub):
        for obj in [self, self.client]:
            hub.unsubscribe_all(obj)

    def remove_data_from_combo(self, data):
        """ Remvoe a data object from the combo box, if present """
        combo = self.ui.displayDataCombo
        pos = combo.findText(data.label)
        if pos >= 0:
            combo.removeItem(pos)

    def _set_norm(self, mode):
        """ Use the `ContrastMouseMode` to adjust the transfer function """
        clip_lo, clip_hi = mode.get_clip_percentile()
        stretch = mode.stretch
        return self.client.set_norm(clip_lo=clip_lo, clip_hi=clip_hi,
                                    stretch=stretch,
                                    bias=mode.bias, contrast=mode.contrast)

    @set_cursor(Qt.WaitCursor)
    def _contour_roi(self, mode):
        """ Callback for ContourMode. Set edit_subset as new ROI """
        im = self.client.display_data
        att = self.client.display_attribute

        if im is None or att is None:
            return
        if im.size > WARN_THRESH and not self._confirm_large_image(im):
            return

        roi = mode.roi(im[att])
        if roi:
            self.apply_roi(roi)

    def _update_window_title(self):
        if self.client.display_data is None:
            title = ''
        else:
            data = self.client.display_data.label
            a = self.client.rgb_mode()
            if a is None:  # monochrome mode
                title = "%s - %s" % (self.client.display_data.label,
                                     self.client.display_attribute.label)
            else:
                r = a.r.label if a.r is not None else ''
                g = a.g.label if a.g is not None else ''
                b = a.b.label if a.b is not None else ''
                title = "%s Red = %s  Green = %s  Blue = %s" % (data, r, g, b)
        self.setWindowTitle(title)

    def _update_data_combo(self):
        combo = self.ui.displayDataCombo
        for i in range(combo.count()):
            combo.setItemText(i, combo.itemData(i).label)

    def _sync_data_labels(self):
        self._update_window_title()
        self._update_data_combo()

    def __str__(self):
        return "Image Widget"

    def _confirm_large_image(self, data):
        """Ask user to confirm expensive contour operations

        :rtype: bool. Whether the user wishes to continue
        """

        warn_msg = ("WARNING: Image has %i pixels, and may render slowly."
                    " Continue?" % data.size)
        title = "Contour large image?"
        ok = QMessageBox.Ok
        cancel = QMessageBox.Cancel
        buttons = ok | cancel
        result = QMessageBox.question(self, title, warn_msg,
                                      buttons=buttons,
                                      defaultButton=cancel)
        return result == ok

    def options_widget(self):
        return self.option_widget

    @defer_draw
    def restore_layers(self, rec, context):
        self.client.restore_layers(rec, context)
        for artist in self.layers:
            self.add_data_to_combo(artist.layer.data)

        self.set_attribute_combo(self.client.display_data)
        self._update_data_combo()

    def paintEvent(self, event):
        super(ImageWidget, self).paintEvent(event)
        pos = self.central_widget.canvas.mapFromGlobal(QCursor.pos())
        x, y = pos.x(), self.central_widget.canvas.height() - pos.y()
        self._update_intensity_label(x, y)

    def _intensity_label(self, x, y):
        x, y = self.client.axes.transData.inverted().transform([x, y])
        value = self.client.point_details(x, y)['value']
        lbl = '' if value is None else "data: %s" % value
        return lbl

    def _update_intensity_label(self, x, y):
        lbl = self._intensity_label(x, y)
        self.label_widget.setText(lbl)

        fm = self.label_widget.fontMetrics()
        w, h = fm.width(lbl), fm.height()
        g = QRect(20, self.central_widget.geometry().height() - h, w, h)
        self.label_widget.setGeometry(g)


class ColormapAction(QAction):

    def __init__(self, label, cmap, parent):
        super(ColormapAction, self).__init__(label, parent)
        self.cmap = cmap
        pm = cmap2pixmap(cmap)
        self.setIcon(QIcon(pm))


def _colormap_mode(parent, on_trigger):

    # actions for each colormap
    acts = []
    for label, cmap in config.colormaps:
        a = ColormapAction(label, cmap, parent)
        a.triggered.connect(nonpartial(on_trigger, cmap))
        acts.append(a)

    # Toolbar button
    tb = QToolButton()
    tb.setWhatsThis("Set color scale")
    tb.setToolTip("Set color scale")
    icon = get_icon('glue_rainbow')
    tb.setIcon(icon)
    tb.setPopupMode(QToolButton.InstantPopup)
    tb.addActions(acts)

    return tb


class StandaloneImageWidget(QMainWindow):

    """
    A simplified image viewer, without any brushing or linking,
    but with the ability to adjust contrast and resample.
    """

    def __init__(self, image, parent=None, **kwargs):
        """
        :param image: Image to display (2D numpy array)
        :param parent: Parent widget (optional)

        :param kwargs: Extra keywords to pass to imshow
        """
        super(StandaloneImageWidget, self).__init__(parent)
        self.central_widget = MplWidget()
        self.setCentralWidget(self.central_widget)
        self._setup_axes()

        self._im = None
        self._norm = DS9Normalize()

        self.make_toolbar()
        self.set_image(image, **kwargs)

    def _setup_axes(self):
        self._axes = self.central_widget.canvas.fig.add_subplot(111)
        self._axes.set_aspect('equal', adjustable='datalim')

    def set_image(self, image, **kwargs):
        """
        Update the image shown in the widget
        """
        if self._im is not None:
            self._im.remove()
            self._im = None

        kwargs.setdefault('origin', 'upper')

        self._im = imshow(self._axes, image,
                          norm=self._norm, cmap='gray', **kwargs)
        self._im_array = image
        self._axes.set_xticks([])
        self._axes.set_yticks([])
        self._redraw()

    @property
    def axes(self):
        """
        The Matplolib axes object for this figure
        """
        return self._axes

    def show(self):
        super(StandaloneImageWidget, self).show()
        self._redraw()

    def _redraw(self):
        self.central_widget.canvas.draw()

    def _set_cmap(self, cmap):
        self._im.set_cmap(cmap)
        self._redraw()

    def mdi_wrap(self):
        """
        Embed this widget in a QMdiSubWindow
        """
        sub = QMdiSubWindow()
        sub.setWidget(self)
        self.destroyed.connect(sub.close)
        sub.resize(self.size())
        self._mdi_wrapper = sub

        return sub

    def _set_norm(self, mode):
        """ Use the `ContrastMouseMode` to adjust the transfer function """
        clip_lo, clip_hi = mode.get_clip_percentile()
        stretch = mode.stretch
        self._norm.clip_lo = clip_lo
        self._norm.clip_hi = clip_hi
        self._norm.stretch = stretch
        self._norm.bias = mode.bias
        self._norm.contrast = mode.contrast
        self._im.set_norm(self._norm)
        self._redraw()

    def make_toolbar(self):
        """
        Setup the toolbar
        """
        result = GlueToolbar(self.central_widget.canvas, self,
                             name='Image')
        result.add_mode(ContrastMode(self._axes, move_callback=self._set_norm))
        cm = _colormap_mode(self, self._set_cmap)
        result.addWidget(cm)
        self._cmap_actions = cm.actions()
        self.addToolBar(result)
        return result


class PVSliceWidget(StandaloneImageWidget):

    """ A standalone image widget with extra interactivity for PV slices """

    def __init__(self, image, x, y, image_widget):
        self._parent = image_widget
        super(PVSliceWidget, self).__init__(image, x=x, y=y)
        conn = self.axes.figure.canvas.mpl_connect
        self._down_id = conn('button_press_event', self._on_click)
        self._move_id = conn('motion_notify_event', self._on_move)

    def set_image(self, im, x, y):
        super(PVSliceWidget, self).set_image(im)
        self._axes.set_aspect('auto')
        self._axes.set_xlim(0, im.shape[1])
        self._axes.set_ylim(0, im.shape[0])
        self._slc = self._parent.slice
        self._x = x
        self._y = y

    def _sync_slice(self, event):
        s = list(self._slc)

        # XXX breaks if display_data changes
        _, _, z = self._pos_in_parent(event)
        s[_slice_index(self._parent.data, s)] = z
        self._parent.slice = tuple(s)

    def _draw_crosshairs(self, event):
        x, y, _ = self._pos_in_parent(event)
        ax = self._parent.client.axes
        m, = ax.plot([x], [y], '+', ms=12, mfc='none', mec='#de2d26',
                     mew=2, zorder=100)
        ax.figure.canvas.draw()
        m.remove()

    def _on_move(self, event):
        if not event.button:
            return

        if not event.inaxes or event.canvas.toolbar.mode != '':
            return

        self._sync_slice(event)
        self._draw_crosshairs(event)

    def _pos_in_parent(self, event):
        ind = np.clip(event.xdata, 0, self._im_array.shape[1] - 1)
        x = self._x[ind]
        y = self._y[ind]
        z = event.ydata

        return x, y, z

    def _on_click(self, event):
        if not event.inaxes or event.canvas.toolbar.mode != '':
            return
        self._sync_slice(event)
        self._draw_crosshairs(event)


def _slice_index(data, slc):
    """
    The axis over which to extract PV slices
    """
    return max([i for i in range(len(slc))
               if isinstance(slc[i], int)],
               key=lambda x: data.shape[x])


def _slice_from_path(x, y, data, attribute, slc):
    """
    Extract a PV-like slice from a cube

    :param x: An array of x values to extract (pixel units)
    :param y: An array of y values to extract (pixel units)
    :param data: :class:`~glue.core.data.Data`
    :param attribute: :claass:`~glue.core.data.Component`
    :param slc: orientation of the image widget that `pts` are defined on

    :returns: (slice, x, y)
              slice is a 2D Numpy array, corresponding to a "PV ribbon"
              cutout from the cube
              x and y are the resampled points along which the
              ribbon is extracted

    :note: For >3D cubes, the "V-axis" of the PV slice is the longest
           cube axis ignoring the x/y axes of `slc`
    """
    from ...external.pvextractor import Path, extract_pv_slice
    p = Path(list(zip(x, y)))

    cube = data[attribute]
    dims = list(range(data.ndim))
    s = list(slc)
    ind = _slice_index(data, slc)

    # transpose cube to (z, y, x, <whatever>)
    def _swap(x, s, i, j):
        x[i], x[j] = x[j], x[i]
        s[i], s[j] = s[j], s[i]

    _swap(dims, s, ind, 0)
    _swap(dims, s, s.index('y'), 1)
    _swap(dims, s, s.index('x'), 2)
    cube = cube.transpose(dims)

    # slice down from >3D to 3D if needed
    s = [slice(None)] * 3 + [slc[d] for d in dims[3:]]
    cube = cube[s]

    # sample cube
    spacing = 1  # pixel
    x, y = [np.round(_x).astype(int) for _x in p.sample_points(spacing)]
    result = extract_pv_slice(cube, p, order=0).data

    return result, x, y


def _slice_label(data, slc):
    """
    Returns a formatted axis label corresponding to the slice dimension
    in a PV slice

    :param data: Data that slice is extracted from
    :param slc: orientation in the image widget from which the PV slice
                was defined
    """
    idx = _slice_index(data, slc)
    return data.get_world_component_id(idx).label

########NEW FILE########
__FILENAME__ = layer_tree_widget
"""
Class which embellishes the DataCollectionView with buttons and actions for
editing the data collection
"""
import operator

from ...external.qt.QtGui import (QWidget, QMenu,
                                  QAction, QKeySequence, QFileDialog)


from ...external.qt.QtCore import Qt, Signal, QObject

from ..ui.layertree import Ui_LayerTree

from ... import core

from ..link_editor import LinkEditor
from .. import qtutil
from ..qtutil import get_icon, nonpartial
from .custom_component_widget import CustomComponentWidget
from ..actions import act as _act
from ...core.edit_subset_mode import AndMode, OrMode, XorMode, AndNotMode
from .subset_facet import SubsetFacet


@core.decorators.singleton
class Clipboard(object):

    def __init__(self):
        self.contents = None


class LayerAction(QAction):
    _title = ''
    _icon = None
    _tooltip = None
    _enabled_on_init = False
    _shortcut = None
    _shortcut_context = Qt.WidgetShortcut

    def __init__(self, layer_tree_widget):
        self._parent = layer_tree_widget.layerTree
        super(LayerAction, self).__init__(self._title.title(), self._parent)
        self._layer_tree = layer_tree_widget
        if self._icon:
            self.setIcon(get_icon(self._icon))
        if self._tooltip:
            self.setToolTip(self._tooltip)
        self.setEnabled(self._enabled_on_init)
        if self._shortcut_context is not None:
            self.setShortcutContext(self._shortcut_context)
        if self._shortcut:
            self.setShortcut(self._shortcut)
        self._parent.addAction(self)
        self._connect()

    def _connect(self):
        self._parent.selection_changed.connect(
            self.update_enabled)
        self.triggered.connect(nonpartial(self._do_action))

    def selected_layers(self):
        return self._layer_tree.selected_layers()

    @property
    def data_collection(self):
        return self._layer_tree.data_collection

    def update_enabled(self):
        enabled = self._can_trigger()
        self.setEnabled(enabled)
        self.setVisible(enabled)

    def single_selection(self):
        return len(self.selected_layers()) == 1

    def single_selection_subset(self):
        layers = self.selected_layers()
        if len(layers) != 1:
            return False
        return isinstance(layers[0], core.Subset)

    def single_selection_subset_group(self):
        layers = self.selected_layers()
        if len(layers) != 1:
            return False
        return isinstance(layers[0], core.SubsetGroup)

    def _can_trigger(self):
        raise NotImplementedError

    def _do_action(self):
        raise NotImplementedError


class PlotAction(LayerAction):

    """Visualize the selection. Requires GlueApplication"""
    _title = "Plot Data"
    _tooltip = "Make a plot of this selection"

    def __init__(self, tree, app):
        super(PlotAction, self).__init__(tree)
        self.app = app

    def _can_trigger(self):
        return self.single_selection()

    def _do_action(self):
        assert self._can_trigger()
        data = self.selected_layers()[0].data
        self.app.choose_new_data_viewer(data)


class FacetAction(LayerAction):

    """Add a sequence of subsets which facet a ComponentID"""
    _title = "Create faceted subsets"
    _tooltip = "Create faceted subsets"

    def _can_trigger(self):
        return len(self._layer_tree.data_collection) > 0

    def _do_action(self):
        layers = self.selected_layers()
        default = layers[0].data if len(layers) > 0 else None
        SubsetFacet.facet(self._layer_tree.data_collection,
                          parent=self._layer_tree, default=default)


class NewAction(LayerAction):
    _title = "New Subset"
    _tooltip = "Create a new subset"
    _icon = "glue_subset"
    _shortcut = QKeySequence('Ctrl+Shift+N')

    def _can_trigger(self):
        return len(self.data_collection) > 0

    def _do_action(self):
        assert self._can_trigger()
        self.data_collection.new_subset_group()


class ClearAction(LayerAction):
    _title = "Clear subset"
    _tooltip = "Clear current subset"
    _shortcut = QKeySequence('Ctrl+K')

    def _can_trigger(self):
        return self.single_selection_subset_group()

    def _do_action(self):
        assert self._can_trigger()
        subset = self.selected_layers()[0]
        subset.subset_state = core.subset.SubsetState()


class DeleteAction(LayerAction):
    _title = "Delete Layer"
    _tooltip = "Delete the selected data and/or subset Groups"
    _shortcut = QKeySequence(Qt.Key_Backspace)

    def _can_trigger(self):
        selection = self.selected_layers()
        return all(isinstance(s, (core.Data, core.SubsetGroup))
                   for s in selection)

    def _do_action(self):
        assert self._can_trigger()
        selection = self.selected_layers()
        for s in selection:
            if isinstance(s, core.Data):
                self._layer_tree.data_collection.remove(s)
            else:
                assert isinstance(s, core.SubsetGroup)
                self._layer_tree.data_collection.remove_subset_group(s)


class LinkAction(LayerAction):
    _title = "Link Data"
    _tooltip = "Define links between data sets"
    _data_link_message = "Define links between data sets"
    _icon = "glue_link"

    def __init__(self, *args, **kwargs):
        super(LinkAction, self).__init__(*args, **kwargs)
        self._link_icon = get_icon(self._icon)
        self._unlink_icon = get_icon('glue_unlink')

    def _can_trigger(self):
        return len(self.data_collection) > 0

    def _do_action(self):
        LinkEditor.update_links(self.data_collection)


class SaveAction(LayerAction):
    _title = "Save subset"
    _tooltip = "Save the mask for this subset to a file"

    def _can_trigger(self):
        return self.single_selection_subset()

    def _do_action(self):
        assert self._can_trigger()
        subset = self.selected_layers()[0]
        save_subset(subset)


class CopyAction(LayerAction):
    _title = "Copy subset"
    _tooltip = "Copy the definition for the selected subset"
    _shortcut = QKeySequence.Copy

    def _can_trigger(self):
        return self.single_selection_subset_group()

    def _do_action(self):
        assert self._can_trigger()
        subset = self.selected_layers()[0]
        Clipboard().contents = subset.subset_state


class PasteAction(LayerAction):
    _title = "Paste subset"
    _tooltip = "Overwrite selected subset with contents from clipboard"
    _shortcut = QKeySequence.Paste

    def _can_trigger(self):
        if not self.single_selection_subset_group():
            return False
        cnt = Clipboard().contents
        if not isinstance(cnt, core.subset.SubsetState):
            return False
        return True

    def _do_action(self):
        assert self._can_trigger()
        layer = self.selected_layers()[0]
        layer.paste(Clipboard().contents)


class PasteSpecialAction(PasteAction):
    _title = "Paste Special..."
    _tooltip = "Paste with boolean logic"
    _shortcut = None

    def __init__(self, *args, **kwargs):
        super(PasteSpecialAction, self).__init__(*args, **kwargs)
        self.setMenu(self.menu())

    def menu(self):
        m = QMenu()

        a = QAction("Or", m)
        a.setIcon(get_icon('glue_or'))
        a.triggered.connect(nonpartial(self._paste, OrMode))
        m.addAction(a)

        a = QAction("And", m)
        a.setIcon(get_icon('glue_and'))
        a.triggered.connect(nonpartial(self._paste, AndMode))
        m.addAction(a)

        a = QAction("XOR", m)
        a.setIcon(get_icon('glue_xor'))
        a.triggered.connect(nonpartial(self._paste, XorMode))
        m.addAction(a)

        a = QAction("Not", m)
        a.setIcon(get_icon('glue_andnot'))
        a.triggered.connect(nonpartial(self._paste, AndNotMode))
        m.addAction(a)
        return m

    def _paste(self, mode):
        if not self._can_trigger():
            return
        assert self._can_trigger()
        layer = self.selected_layers()[0]
        mode(layer, Clipboard().contents)

    def _do_action(self):
        pass


class Inverter(LayerAction):
    _title = "Invert"
    _icon = "glue_not"
    _tooltip = "Invert selected subset"

    def _can_trigger(self):
        """ Can trigger iff one subset is selected """
        return self.single_selection_subset_group()

    def _do_action(self):
        """Replace selected subset with its inverse"""
        assert self._can_trigger()
        subset, = self.selected_layers()
        subset.subset_state = core.subset.InvertState(subset.subset_state)


class LayerCommunicator(QObject):
    layer_check_changed = Signal(object, bool)


class LayerTreeWidget(QWidget, Ui_LayerTree):

    """The layertree widget provides a way to visualize the various
    data and subset layers in a Glue session.

    This widget relies on sending/receiving messages to/from the hub
    to maintin synchronization with the data collection it manages. If
    it isn't attached to a hub, interactions may not propagate properly.
    """

    def __init__(self, parent=None):
        Ui_LayerTree.__init__(self)
        QWidget.__init__(self, parent)

        self._signals = LayerCommunicator()
        self._is_checkable = True
        self._layer_check_changed = self._signals.layer_check_changed
        self._layer_dict = {}

        self._actions = {}

        self.setupUi(self)
        self._create_actions()
        self._connect()
        self._data_collection = None
        self._hub = None
        self.layerTree.setDragEnabled(True)

    @property
    def data_collection(self):
        return self._data_collection

    def setup(self, collection):
        self._data_collection = collection
        self._hub = collection.hub
        self.layerTree.set_data_collection(collection)

    def unregister(self, hub):
        """Unsubscribe from hub"""
        self.layerTree.unregister(hub)

    def is_checkable(self):
        """ Return whether checkboxes appear next o layers"""
        return self.layerTree.checkable

    def set_checkable(self, state):
        """ Setw hether checkboxes appear next o layers"""
        self.layerTree.checkable = state

    def selected_layers(self):
        """ Return a list of selected layers (subsets and data objects) """
        return self.layerTree.selected_layers()

    def current_layer(self):
        """Return the layer if a single item is selected, else None """
        layers = self.selected_layers()
        if len(layers) == 1:
            return layers[0]

    def actions(self):
        """ Return the list of actions attached to this widget """
        return self.layerTree.actions()

    def _connect(self):
        """ Connect widget signals to methods """
        self._actions['link'] = LinkAction(self)
        self.layerAddButton.clicked.connect(self._load_data)
        self.layerRemoveButton.clicked.connect(self._actions['delete'].trigger)
        self.linkButton.set_action(self._actions['link'])
        self.newSubsetButton.set_action(self._actions['new'], text=False)

        rbut = self.layerRemoveButton

        def update_enabled():
            return rbut.setEnabled(self._actions['delete'].isEnabled())
        self.layerTree.selection_changed.connect(update_enabled)

    def bind_selection_to_edit_subset(self):
        self.layerTree.selection_changed.connect(
            self._update_editable_subset)

    def _update_editable_subset(self):
        """Update edit subsets to match current selection"""
        layers = self.selected_layers()
        layers.extend(s for l in layers
                      if isinstance(l, core.SubsetGroup)
                      for s in l.subsets)

        for data in self.data_collection:
            data.edit_subset = [s for s in data.subsets if s in layers]

    def _create_component(self):
        CustomComponentWidget.create_component(self.data_collection)

    def _create_actions(self):
        tree = self.layerTree

        sep = QAction("", tree)
        sep.setSeparator(True)
        tree.addAction(sep)

        self._actions['save'] = SaveAction(self)
        self._actions['copy'] = CopyAction(self)
        self._actions['paste'] = PasteAction(self)
        self._actions['paste_special'] = PasteSpecialAction(self)
        self._actions['invert'] = Inverter(self)
        self._actions['new'] = NewAction(self)
        self._actions['clear'] = ClearAction(self)
        self._actions['delete'] = DeleteAction(self)
        self._actions['facet'] = FacetAction(self)

        # new component definer
        separator = QAction("sep", tree)
        separator.setSeparator(True)
        tree.addAction(separator)

        a = _act("Define new component", self,
                 tip="Define a new component using python expressions")
        tree.addAction(a)
        a.triggered.connect(nonpartial(self._create_component))
        self._actions['new_component'] = a

        # right click pulls up menu
        tree.setContextMenuPolicy(Qt.ActionsContextMenu)

    def _on_item_change(self, item, column):
        """emit check_state_changed signal when checkbox clicked"""
        if item is None or item not in self or column != 0:
            return
        is_checked = item.checkState(0) == Qt.Checked
        layer = self[item]
        self._layer_check_changed.emit(layer, is_checked)

    def _load_data(self):
        """ Interactively loads data from a data set. Adds
        as new layer """
        layers = qtutil.data_wizard()
        for layer in layers:
            self.data_collection.append(layer)

    def __getitem__(self, key):
        raise NotImplementedError()
        return self.layerTree[key]

    def __setitem__(self, key, value):
        raise NotImplementedError()
        self.layerTree[key] = value

    def __contains__(self, obj):
        return obj in self.layerTree

    def __len__(self):
        return len(self.layerTree)


def save_subset(subset):
    assert isinstance(subset, core.subset.Subset)
    fname, fltr = QFileDialog.getSaveFileName(caption="Select an output name")
    fname = str(fname)
    if not fname:
        return
    subset.write_mask(fname)

########NEW FILE########
__FILENAME__ = message_widget
from time import ctime

from ...external.qt.QtGui import QWidget, QTableWidgetItem

from ... import core

from ..qtutil import load_ui


class MessageWidget(QWidget, core.hub.HubListener):
    """ This simple class displays all messages broadcast
    by a hub. It is mainly intended for debugging """
    def __init__(self):
        QWidget.__init__(self)
        self.ui = load_ui('messagewidget', self)
        self.ui.messageTable.setColumnCount(3)
        labels = ['Time', 'Message', 'Sender']
        self.ui.messageTable.setHorizontalHeaderLabels(labels)

    def register_to_hub(self, hub):
        # catch all messages
        hub.subscribe(self, core.message.Message,
                      handler=self.process_message,
                      filter=lambda x: True)

    def process_message(self, message):
        row = self.ui.messageTable.rowCount() * 0
        self.ui.messageTable.insertRow(0)
        tm = QTableWidgetItem(ctime().split()[3])
        typ = str(type(message)).split("'")[-2].split('.')[-1]
        mtyp = QTableWidgetItem(typ)
        typ = str(type(message.sender)).split("'")[-2].split('.')[-1]
        sender = QTableWidgetItem(typ)
        self.ui.messageTable.setItem(row, 0, tm)
        self.ui.messageTable.setItem(row, 1, mtyp)
        self.ui.messageTable.setItem(row, 2, sender)
        self.ui.messageTable.resizeColumnsToContents()

########NEW FILE########
__FILENAME__ = mpl_widget
#!/usr/bin/env python
from functools import partial, wraps

from ...external.qt import QtGui
from ...external.qt.QtCore import Signal, Qt, QTimer

from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as \
    FigureCanvas

try:
    from matplotlib.backends.backend_qt4agg import FigureManagerQTAgg as \
        FigureManager
except ImportError:  # mpl >= 1.4
    from matplotlib.backends.backend_qt4agg import FigureManagerQT as \
        FigureManager

import matplotlib
from matplotlib.figure import Figure


class DeferredMethod(object):
    """
    This class stubs out a method, and provides a
    callable interface that logs its calls. These
    can later be actually executed on the original (non-stubbed)
    method by calling executed_deferred_calls
    """
    def __init__(self, method):
        self.method = method
        self.calls = []  # avoid hashability issues with dict/set

    @property
    def original_method(self):
        return self.method

    def __call__(self, instance, *a, **k):
        if instance not in (c[0] for c in self.calls):
            self.calls.append((instance, a, k))

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return partial(self.__call__, instance)

    def execute_deferred_calls(self):
        for instance, args, kwargs in self.calls:
            self.method(instance, *args, **kwargs)


def defer_draw(func):
    """
    Decorator that globally defers all MplCanvas draw requests until
    function exit.

    If an MplCanvas instance's draw method is invoked multiple times,
    it will only be called once after the wrapped function returns.
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            MplCanvas.draw = DeferredMethod(MplCanvas.draw)
            result = func(*args, **kwargs)
        finally:
            MplCanvas.draw.execute_deferred_calls()
            MplCanvas.draw = MplCanvas.draw.original_method
        return result

    return wrapper


class MplCanvas(FigureCanvas):

    """Class to represent the FigureCanvas widget"""

    rightDrag = Signal(float, float)
    leftDrag = Signal(float, float)
    homeButton = Signal()
    resize_begin = Signal()
    resize_end = Signal()

    def __init__(self):
        interactive = matplotlib.is_interactive()
        matplotlib.interactive(False)
        self.roi_callback = None

        self.fig = Figure(facecolor='#ffffff')
        try:
            self.fig.set_tight_layout(True)
        except AttributeError:  # matplotlib < 1.1
            pass

        FigureCanvas.__init__(self, self.fig)
        FigureCanvas.setSizePolicy(self,
                                   QtGui.QSizePolicy.Expanding,
                                   QtGui.QSizePolicy.Expanding)

        FigureCanvas.updateGeometry(self)
        self.manager = FigureManager(self, 0)
        matplotlib.interactive(interactive)

        self._resize_timer = QTimer()
        self._resize_timer.setInterval(250)
        self._resize_timer.setSingleShot(True)
        self._resize_timer.timeout.connect(self._on_timeout)

        self.renderer = None

    def _on_timeout(self):
        buttons = QtGui.QApplication.instance().mouseButtons()
        if buttons != Qt.NoButton:
            self._resize_timer.start()
        else:
            self.resize_end.emit()

    def paintEvent(self, event):
        # draw the zoom rectangle more prominently
        drawRect = self.drawRect
        self.drawRect = False

        # super needs this
        if self.renderer is None:
            self.renderer = self.get_renderer()

        super(MplCanvas, self).paintEvent(event)
        if drawRect:
            p = QtGui.QPainter(self)
            p.setPen(QtGui.QPen(Qt.red, 2, Qt.DotLine))
            p.drawRect(self.rect[0], self.rect[1], self.rect[2], self.rect[3])
            p.end()

        if self.roi_callback is not None:
            self.roi_callback(self)

    def resizeEvent(self, event):
        if not self._resize_timer.isActive():
            self.resize_begin.emit()
        self._resize_timer.start()
        super(MplCanvas, self).resizeEvent(event)


class MplWidget(QtGui.QWidget):

    """Widget defined in Qt Designer"""

    # signals
    rightDrag = Signal(float, float)
    leftDrag = Signal(float, float)

    def __init__(self, parent=None):
        # initialization of Qt MainWindow widget
        QtGui.QWidget.__init__(self, parent)
        # set the canvas to the Matplotlib widget
        self.canvas = MplCanvas()
        # create a vertical box layout
        self.vbl = QtGui.QVBoxLayout()
        self.vbl.setContentsMargins(0, 0, 0, 0)
        self.vbl.setSpacing(0)
        # add mpl widget to the vertical box
        self.vbl.addWidget(self.canvas)
        # set the layout to the vertical box
        self.setLayout(self.vbl)

        self.canvas.rightDrag.connect(self.rightDrag)
        self.canvas.leftDrag.connect(self.leftDrag)

########NEW FILE########
__FILENAME__ = scatter_widget
from ...external.qt import QtGui
from ...external.qt.QtCore import Qt
from ... import core

from ...clients.scatter_client import ScatterClient
from ..glue_toolbar import GlueToolbar
from ..mouse_mode import (RectangleMode, CircleMode,
                          PolyMode, HRangeMode, VRangeMode)

from .data_viewer import DataViewer
from .mpl_widget import MplWidget, defer_draw
from ..widget_properties import (ButtonProperty, FloatLineProperty,
                                 CurrentComboProperty,
                                 connect_bool_button, connect_float_edit)

from ..qtutil import load_ui, cache_axes

__all__ = ['ScatterWidget']

WARN_SLOW = 1000000  # max number of points which render quickly


class ScatterWidget(DataViewer):

    """
    An interactive scatter plot.
    """

    LABEL = "Scatter Plot"
    _property_set = DataViewer._property_set + \
        'xlog ylog xflip yflip hidden xatt yatt xmin xmax ymin ymax'.split()

    xlog = ButtonProperty('ui.xLogCheckBox', 'log scaling on x axis?')
    ylog = ButtonProperty('ui.yLogCheckBox', 'log scaling on y axis?')
    xflip = ButtonProperty('ui.xFlipCheckBox', 'invert the x axis?')
    yflip = ButtonProperty('ui.yFlipCheckBox', 'invert the y axis?')
    xmin = FloatLineProperty('ui.xmin', 'Lower x limit of plot')
    xmax = FloatLineProperty('ui.xmax', 'Upper x limit of plot')
    ymin = FloatLineProperty('ui.ymin', 'Lower y limit of plot')
    ymax = FloatLineProperty('ui.ymax', 'Upper y limit of plot')
    hidden = ButtonProperty('ui.hidden_attributes', 'Show hidden attributes')
    xatt = CurrentComboProperty('ui.xAxisComboBox',
                                'Attribute to plot on x axis')
    yatt = CurrentComboProperty('ui.yAxisComboBox',
                                'Attribute to plot on y axis')

    def __init__(self, session, parent=None):
        super(ScatterWidget, self).__init__(session, parent)
        self.central_widget = MplWidget()
        self.option_widget = QtGui.QWidget()

        self.setCentralWidget(self.central_widget)

        self.ui = load_ui('scatterwidget', self.option_widget)
        self._tweak_geometry()

        self.client = ScatterClient(self._data,
                                    self.central_widget.canvas.fig,
                                    artist_container=self._container)

        self._connect()
        self.unique_fields = set()
        tb = self.make_toolbar()
        cache_axes(self.client.axes, tb)
        self.statusBar().setSizeGripEnabled(False)
        self.setFocusPolicy(Qt.StrongFocus)

    def _tweak_geometry(self):
        self.central_widget.resize(600, 400)
        self.resize(self.central_widget.size())

    def _connect(self):
        ui = self.ui
        cl = self.client

        connect_bool_button(cl, 'xlog', ui.xLogCheckBox)
        connect_bool_button(cl, 'ylog', ui.yLogCheckBox)
        connect_bool_button(cl, 'xflip', ui.xFlipCheckBox)
        connect_bool_button(cl, 'yflip', ui.yFlipCheckBox)

        ui.xAxisComboBox.currentIndexChanged.connect(self.update_xatt)
        ui.yAxisComboBox.currentIndexChanged.connect(self.update_yatt)
        ui.hidden_attributes.toggled.connect(lambda x: self._update_combos())
        ui.swapAxes.clicked.connect(self.swap_axes)
        ui.snapLimits.clicked.connect(cl.snap)

        connect_float_edit(cl, 'xmin', ui.xmin)
        connect_float_edit(cl, 'xmax', ui.xmax)
        connect_float_edit(cl, 'ymin', ui.ymin)
        connect_float_edit(cl, 'ymax', ui.ymax)

    def make_toolbar(self):
        result = GlueToolbar(self.central_widget.canvas, self,
                             name='Scatter Plot')
        for mode in self._mouse_modes():
            result.add_mode(mode)
        self.addToolBar(result)
        return result

    def _mouse_modes(self):
        axes = self.client.axes

        def apply_mode(mode):
            return self.apply_roi(mode.roi())

        rect = RectangleMode(axes, roi_callback=apply_mode)
        xra = HRangeMode(axes, roi_callback=apply_mode)
        yra = VRangeMode(axes, roi_callback=apply_mode)
        circ = CircleMode(axes, roi_callback=apply_mode)
        poly = PolyMode(axes, roi_callback=apply_mode)
        return [rect, xra, yra, circ, poly]

    @defer_draw
    def _update_combos(self):
        """ Update contents of combo boxes """
        layer_ids = []

        # look at all plottable components of datasets we are plotting,
        # + hidden values if requested
        for l in self.client.data:
            if not self.client.is_layer_present(l):
                continue
            for lid in self.client.plottable_attributes(
                    l, show_hidden=self.hidden):
                if lid not in layer_ids:
                    layer_ids.append(lid)

        for combo, att in zip([self.ui.xAxisComboBox, self.ui.yAxisComboBox],
                              [self.xatt, self.yatt]):
            combo.blockSignals(True)
            combo.clear()

            for lid in layer_ids:
                combo.addItem(lid.label, userData=lid)
            try:
                combo.setCurrentIndex(layer_ids.index(att))
            except ValueError:
                combo.setCurrentIndex(0)
            combo.blockSignals(False)

    @defer_draw
    def add_data(self, data):
        """Add a new data set to the widget

        :returns: True if the addition was expected, False otherwise
        """
        if self.client.is_layer_present(data):
            return

        if data.size > WARN_SLOW and not self._confirm_large_data(data):
            return False

        first_layer = self.client.layer_count == 0

        self.client.add_data(data)
        self._update_combos()

        if first_layer:  # forces both x and y axes to be rescaled
            self.update_xatt(None)
            self.update_yatt(None)

            self.ui.xAxisComboBox.setCurrentIndex(0)
            if len(data.visible_components) > 1:
                self.ui.yAxisComboBox.setCurrentIndex(1)
            else:
                self.ui.yAxisComboBox.setCurrentIndex(0)

        self._update_window_title()
        return True

    @defer_draw
    def add_subset(self, subset):
        """Add a subset to the widget

        :returns: True if the addition was accepted, False otherwise
        """
        if self.client.is_layer_present(subset):
            return

        data = subset.data
        if data.size > WARN_SLOW and not self._confirm_large_data(data):
            return False

        first_layer = self.client.layer_count == 0

        self.client.add_layer(subset)
        self._update_combos()

        if first_layer:  # forces both x and y axes to be rescaled
            self.update_xatt(None)
            self.update_yatt(None)

            self.ui.xAxisComboBox.setCurrentIndex(0)
            if len(data.visible_components) > 1:
                self.ui.yAxisComboBox.setCurrentIndex(1)
            else:
                self.ui.yAxisComboBox.setCurrentIndex(0)

        self._update_window_title()
        return True

    def register_to_hub(self, hub):
        super(ScatterWidget, self).register_to_hub(hub)
        self.client.register_to_hub(hub)
        hub.subscribe(self, core.message.DataUpdateMessage,
                      lambda x: self._sync_labels())
        hub.subscribe(self, core.message.ComponentsChangedMessage,
                      lambda x: self._update_combos())

    def unregister(self, hub):
        hub.unsubscribe_all(self.client)
        hub.unsubscribe_all(self)

    @defer_draw
    def swap_axes(self):
        xid = self.ui.xAxisComboBox.currentIndex()
        yid = self.ui.yAxisComboBox.currentIndex()
        xlog = self.ui.xLogCheckBox.isChecked()
        ylog = self.ui.yLogCheckBox.isChecked()
        xflip = self.ui.xFlipCheckBox.isChecked()
        yflip = self.ui.yFlipCheckBox.isChecked()

        self.ui.xAxisComboBox.setCurrentIndex(yid)
        self.ui.yAxisComboBox.setCurrentIndex(xid)
        self.ui.xLogCheckBox.setChecked(ylog)
        self.ui.yLogCheckBox.setChecked(xlog)
        self.ui.xFlipCheckBox.setChecked(yflip)
        self.ui.yFlipCheckBox.setChecked(xflip)

    @defer_draw
    def update_xatt(self, index):
        component_id = self.xatt
        self.client.xatt = component_id

    @defer_draw
    def update_yatt(self, index):
        component_id = self.yatt
        self.client.yatt = component_id

    def _update_window_title(self):
        data = self.client.data
        label = ', '.join([d.label for d in data if
                           self.client.is_visible(d)])
        self.setWindowTitle(label)

    def _sync_labels(self):
        self._update_window_title()

    def __str__(self):
        return "Scatter Widget"

    def options_widget(self):
        return self.option_widget

    @defer_draw
    def restore_layers(self, rec, context):
        self.client.restore_layers(rec, context)
        self._update_combos()
        # manually force client attributes to sync
        self.update_xatt(None)
        self.update_yatt(None)

########NEW FILE########
__FILENAME__ = settings_editor
from ...external.qt.QtGui import QTableWidget, QTableWidgetItem
from ...external.qt.QtCore import Qt


class SettingsEditor(object):

    def __init__(self, app):
        w = QTableWidget(parent=None)
        w.setColumnCount(2)
        w.setRowCount(len(list(app.settings)))
        w.setHorizontalHeaderLabels(["Setting", "Value"])
        for row, (key, value) in enumerate(app.settings):
            k = QTableWidgetItem(key)
            v = QTableWidgetItem(value)
            k.setFlags(k.flags() ^ (Qt.ItemIsEditable | Qt.ItemIsSelectable))
            w.setItem(row, 0, k)
            w.setItem(row, 1, v)
        w.sortItems(0)
        w.cellChanged.connect(self.update_setting)
        w.setWindowModality(Qt.ApplicationModal)
        w.resize(350, 340)
        w.setColumnWidth(0, 160)
        w.setColumnWidth(1, 160)
        w.setWindowTitle("Glue Settings")
        self._widget = w
        self.app = app

    def update_setting(self, row, column):
        key = self._widget.item(row, 0).text()
        value = self._widget.item(row, 1).text()
        old = self.app.get_setting(key)
        try:
            self.app.set_setting(key, value)
        except ValueError:
            self._widget.item(row, 1).setText(old)

    @property
    def widget(self):
        return self._widget

########NEW FILE########
__FILENAME__ = style_dialog
from ..qtutil import (mpl_to_qt4_color, symbol_icon, POINT_ICONS,
                      qt4_to_mpl_color)

from ...external.qt.QtGui import (QFormLayout, QDialogButtonBox, QColorDialog,
                                  QWidget, QLineEdit, QListWidget,
                                  QListWidgetItem, QPixmap, QDialog, QLabel,
                                  QSpinBox, QComboBox)

from ...external.qt.QtCore import QSize, Signal, Qt


class ColorWidget(QLabel):
    mousePressed = Signal()

    def mousePressEvent(self, event):
        self.mousePressed.emit()
        event.accept()


class StyleDialog(QDialog):

    """Dialog which edits the style of a layer (Data or Subset)

    Use via StyleDialog.edit_style(layer)
    """

    def __init__(self, layer, parent=None, edit_label=True):
        super(StyleDialog, self).__init__(parent)
        self.setWindowTitle("Style Editor")
        self.layer = layer
        self._edit_label = edit_label
        self._symbols = POINT_ICONS.keys()

        self._setup_widgets()
        self._connect()

    def _setup_widgets(self):
        self.layout = QFormLayout()

        self.size_widget = QSpinBox()
        self.size_widget.setMinimum(1)
        self.size_widget.setMaximum(40)
        self.size_widget.setValue(self.layer.style.markersize)

        self.label_widget = QLineEdit()
        self.label_widget.setText(self.layer.label)
        self.label_widget.selectAll()

        self.symbol_widget = QComboBox()
        for idx, symbol in enumerate(self._symbols):
            icon = symbol_icon(symbol)
            self.symbol_widget.addItem(icon, '')
            if symbol is self.layer.style.marker:
                self.symbol_widget.setCurrentIndex(idx)
        self.symbol_widget.setIconSize(QSize(20, 20))
        self.symbol_widget.setMinimumSize(10, 32)

        self.color_widget = ColorWidget()
        self.color_widget.setStyleSheet('ColorWidget {border: 1px solid;}')
        color = self.layer.style.color
        color = mpl_to_qt4_color(color, alpha=self.layer.style.alpha)
        self.set_color(color)

        self.okcancel = QDialogButtonBox(QDialogButtonBox.Ok |
                                         QDialogButtonBox.Cancel)

        if self._edit_label:
            self.layout.addRow("Label", self.label_widget)
        self.layout.addRow("Symbol", self.symbol_widget)
        self.layout.addRow("Color", self.color_widget)
        self.layout.addRow("Size", self.size_widget)

        self.layout.addWidget(self.okcancel)

        self.setLayout(self.layout)
        self.layout.setContentsMargins(6, 6, 6, 6)

    def _connect(self):
        self.color_widget.mousePressed.connect(self.query_color)
        self.symbol_widget.currentIndexChanged.connect(
            lambda x: self.set_color(self.color()))
        self.okcancel.accepted.connect(self.accept)
        self.okcancel.rejected.connect(self.reject)
        self.setFocusPolicy(Qt.StrongFocus)

    def query_color(self, *args):
        color = QColorDialog.getColor(self._color, self.color_widget,
                                      "",
                                      QColorDialog.ShowAlphaChannel)
        if color.isValid():
            self.set_color(color)

    def color(self):
        return self._color

    def set_color(self, color):
        self._color = color
        pm = symbol_icon(self.symbol(), color).pixmap(30, 30)
        self.color_widget.setPixmap(pm)

    def size(self):
        return self.size_widget.value()

    def label(self):
        return str(self.label_widget.text())

    def symbol(self):
        return self._symbols[self.symbol_widget.currentIndex()]

    def update_style(self):
        if self._edit_label:
            self.layer.label = self.label()
        self.layer.style.color = qt4_to_mpl_color(self.color())
        self.layer.style.alpha = self.color().alpha() / 255.
        self.layer.style.marker = self.symbol()
        self.layer.style.markersize = self.size()

    @classmethod
    def edit_style(cls, layer):
        self = cls(layer)
        result = self.exec_()

        if result == self.Accepted:
            self.update_style()

    @classmethod
    def dropdown_editor(cls, item, pos, **kwargs):
        """
        Create a dropdown-style modal editor to edit the style of a
        given item

        :param item: Item with a .label and .style to edit
        :param pos: A QPoint to anchor the top-left corner of the dropdown at
        :param kwargs: Extra keywords to pass to StyleDialogs's constructor
        """
        self = cls(item, **kwargs)
        self.setWindowFlags(Qt.Tool | Qt.FramelessWindowHint)

        pos = self.mapFromGlobal(pos)
        self.move(pos)
        if self.exec_() == self.Accepted:
            self.update_style()


if __name__ == "__main__":
    from glue.core import Data

    d = Data(label='data label', x=[1, 2, 3, 4])
    StyleDialog.edit_style(d)

    print "New layer properties"
    print d.label
    print 'color: ', d.style.color
    print 'marker: ', d.style.marker
    print 'marker size: ', d.style.markersize
    print 'alpha ', d.style.alpha

########NEW FILE########
__FILENAME__ = subset_facet
from ...external.qt.QtGui import (QDialog, QDoubleValidator, QIcon)
import numpy as np
from matplotlib import cm


from ..qtutil import pretty_number, cmap2pixmap, load_ui
from ...core.util import colorize_subsets, facet_subsets
from ..widget_properties import ButtonProperty


class SubsetFacet(object):
    log = ButtonProperty('ui.log')

    def __init__(self, collect, default=None, parent=None):
        """Create a new dialog for subset faceting

        :param collect: The :class:`~glue.core.DataCollection` to use
        :param default: The default dataset in the collection (optional)
        """
        self.ui = load_ui('subset_facet', parent)
        self.ui.setWindowTitle("Subset Facet")
        self._collect = collect

        self.ui.component_selector.setup(self._collect)
        if default is not None:
            self.ui.component_selector.data = default

        val = QDoubleValidator(-1e100, 1e100, 4, None)
        self.ui.component_selector.component_changed.connect(self._set_limits)

        combo = self.ui.color_scale
        for cmap in [cm.cool, cm.RdYlBu, cm.RdYlGn, cm.RdBu, cm.Purples]:
            combo.addItem(QIcon(cmap2pixmap(cmap)), cmap.name, cmap)

    def _set_limits(self):
        data = self.ui.component_selector.data
        cid = self.ui.component_selector.component

        vals = data[cid]

        wmin = self.ui.min
        wmax = self.ui.max

        wmin.setText(pretty_number(np.nanmin(vals)))
        wmax.setText(pretty_number(np.nanmax(vals)))

    @property
    def cmap(self):
        combo = self.ui.color_scale
        index = combo.currentIndex()
        return combo.itemData(index)

    def _apply(self):
        lo, hi = self.ui.min.text(), self.ui.max.text()
        try:
            lo, hi = float(lo), float(hi)
        except ValueError:
            return  # limits not set. Abort
        if not np.isfinite(lo) or not np.isfinite(hi):
            return

        steps = self.ui.num.value()

        data = self.ui.component_selector.data
        cid = self.ui.component_selector.component

        subsets = facet_subsets(self._collect, cid, lo=lo, hi=hi,
                                steps=steps, log=self.log)
        colorize_subsets(subsets, self.cmap)

    @classmethod
    def facet(cls, collect, default=None, parent=None):
        """Class method to create facted subsets
        The arguments are the same as __init__
        """
        self = cls(collect, parent=parent, default=default)
        value = self.ui.exec_()

        if value == QDialog.Accepted:
            self._apply()

########NEW FILE########
__FILENAME__ = table_widget
from .data_viewer import DataViewer

from ...external.qt.QtGui import QTableView
from ...external.qt.QtCore import Qt, QAbstractTableModel

import numpy as np


class DataTableModel(QAbstractTableModel):

    def __init__(self, data):
        super(DataTableModel, self).__init__()
        self._data = data
        self.show_hidden = False

    @property
    def columns(self):
        if self.show_hidden:
            return self._data.components
        else:
            return self._data.visible_components

    def columnCount(self, index=None):
        return len(self.columns)

    def rowCount(self, index=None):
        #Qt bug: Crashes on tables bigger than this
        return min(self._data.size, 71582788)

    def headerData(self, section, orientation, role):
        if role != Qt.DisplayRole:
            return None

        if orientation == Qt.Horizontal:
            return self.columns[section].label
        elif orientation == Qt.Vertical:
            return str(section)

    def data(self, index, role):
        if not index.isValid():
            return None
        if role == Qt.DisplayRole:
            c = self.columns[index.column()]
            idx = np.unravel_index([index.row()], self._data.shape)
            return str(self._data[c, idx][0])


class TableWidget(DataViewer):
    def __init__(self, session, parent=None):
        super(TableWidget, self).__init__(session, parent)
        self.widget = QTableView()
        self.setCentralWidget(self.widget)

        hdr = self.widget.horizontalHeader()
        hdr.setStretchLastSection(True)
        hdr.setResizeMode(hdr.Interactive)

        hdr = self.widget.verticalHeader()
        hdr.setResizeMode(hdr.Interactive)

    def __str__(self):
        return "Table Widget"

    def unregister(self, hub):
        pass

    def add_data(self, data):
        self.set_data(data)
        return True

    def add_subset(self, subset):
        self.set_data(subset.data)
        return True

    def set_data(self, data):
        self.setUpdatesEnabled(False)
        model = DataTableModel(data)
        self.widget.setModel(model)
        self.setUpdatesEnabled(True)

    def closeEvent(self, event):
        """
        On close, QT seems to scan through the entire model
        if the data set is big. To sidestep that,
        we swap out with a tiny data set before closing
        """
        from ...core import Data
        d = Data(x=[0])
        self.widget.setModel(DataTableModel(d))
        event.accept()

########NEW FILE########
__FILENAME__ = terminal
"""
A GUI Ipython terminal window which can interact
with Glue. Based on code from

http://stackoverflow.com/a/9796491/1332492
and
http://stackoverflow.com/a/11525205/1332492

Usage:
   new_widget = glue_terminal(**kwargs)

Implementation Note:

Since v1.0dev, IPython implements embeddable in-process terminal widgets.
This functionality doesn't exist in v0.12 and v0.13 -- this module provides
a fallback implmentation for older IPython versions
"""

import sys
import atexit
from contextlib import contextmanager

# must import these first, to set up Qt properly
from ...external.qt import QtCore
from ...external.qt.QtGui import QInputDialog, QMdiSubWindow
from ...version import __version__

from zmq import ZMQError
from zmq.eventloop.zmqstream import ZMQStream
from zmq.eventloop import ioloop

from IPython.utils.traitlets import TraitError
from IPython.lib.kernel import find_connection_file
from IPython.core.usage import default_banner

try:   # IPython 1.0
    from IPython.kernel.zmq.ipkernel import Kernel
    from IPython.kernel.zmq.kernelapp import IPKernelApp
    from IPython.kernel.zmq.iostream import OutStream
    from IPython.qt.manager import QtKernelManager
    from IPython.qt.console.rich_ipython_widget import RichIPythonWidget

    # these are only needed for v1.0
    from IPython.kernel.connect import get_connection_file
    from IPython import get_ipython
    from IPython.qt.client import QtKernelClient
    from IPython.kernel.inprocess.ipkernel import InProcessKernel
    from IPython.kernel.inprocess.ipkernel import InProcessInteractiveShell
    from IPython.qt.inprocess import \
        QtInProcessKernelManager

except ImportError:
    from IPython.zmq.ipkernel import Kernel
    from IPython.zmq.ipkernel import IPKernelApp
    from IPython.zmq.iostream import OutStream
    from IPython.frontend.qt.kernelmanager import QtKernelManager
    from IPython.frontend.qt.console.rich_ipython_widget import \
        RichIPythonWidget


def in_process_console(console_class=RichIPythonWidget, **kwargs):
    """Create a console widget, connected to an in-process Kernel

    This only works on IPython v 0.13 and above

    Parameters
    ----------
    console_class : The class of the console widget to create
    kwargs : Extra variables to put into the namespace
    """

    km = QtInProcessKernelManager()
    km.start_kernel()

    kernel = km.kernel
    kernel.gui = 'qt4'

    client = km.client()
    client.start_channels()

    control = console_class()
    control.kernel_manager = km
    control.kernel_client = client
    control.shell = kernel.shell
    control.shell.user_ns.update(**kwargs)
    return control


def connected_console(console_class=RichIPythonWidget, **kwargs):
    """Create a console widget, connected to another kernel running in
       the current process

    This only works on IPython v1.0 and above

    Parameters
    ----------
    console_class : The class of the console widget to create
    kwargs : Extra variables to put into the namespace
    """
    shell = get_ipython()
    if shell is None:
        raise RuntimeError("There is no IPython kernel in this process")

    client = QtKernelClient(connection_file=get_connection_file())
    client.load_connection_file()
    client.start_channels()

    control = console_class()
    control.kernel_client = client
    control.shell = shell
    control.shell.user_ns.update(**kwargs)
    return control


glue_banner_parts = []
glue_banner_parts.append("Glue %s " % __version__)
glue_banner_parts.append("Predefined variables - drag additional items into "
                         "this window to use:")
glue_banner_parts.append("\t* data_collection (aliased to dc)")
glue_banner_parts.append("\t* application")
glue_banner_parts.append("\t* hub")

glue_banner = '\n'.join(glue_banner_parts)


class DragAndDropTerminal(RichIPythonWidget):
    banner = default_banner + '\n' + glue_banner

    def __init__(self, **kwargs):
        super(DragAndDropTerminal, self).__init__(**kwargs)
        self.setAcceptDrops(True)
        self.shell = None

    def mdi_wrap(self):
        sub = QMdiSubWindow()
        sub.setWidget(self)
        self.destroyed.connect(sub.close)
        sub.resize(self.size())
        self._mdi_wrapper = sub
        return sub

    @property
    def namespace(self):
        return self.shell.user_ns if self.shell is not None else None

    def dragEnterEvent(self, event):
        fmt = 'application/py_instance'
        if self.shell is not None and event.mimeData().hasFormat(fmt):
            event.accept()
        else:
            event.ignore()

    def update_namespace(self, kwargs):
        if self.shell is not None:
            self.shell.push(kwargs)

    def dropEvent(self, event):
        obj = event.mimeData().data('application/py_instance')

        var, ok = QInputDialog.getText(self, "Choose a variable name",
                                       "Choose a variable name", text="x")
        if ok:
            # unpack single-item lists for convenience
            if isinstance(obj, list) and len(obj) == 1:
                obj = obj[0]

            var = {str(var): obj}
            self.update_namespace(var)
            event.accept()
        else:
            event.ignore()


# Works for IPython 0.12, 0.13
def default_kernel_app():
    """ Return a configured IPKernelApp """

    def event_loop(kernel):
        """ Non-blocking qt event loop."""
        kernel.timer = QtCore.QTimer()
        kernel.timer.timeout.connect(kernel.do_one_iteration)
        kernel.timer.start(1000 * kernel._poll_interval)

    app = IPKernelApp.instance()
    try:
        app.initialize(['python', '--pylab=qt'])
    except ZMQError:
        pass  # already set up

    app.kernel.eventloop = event_loop

    try:
        app.start()
    except RuntimeError:  # already started
        pass

    return app


def default_manager(kernel):
    """ Return a configured QtKernelManager

    :param kernel: An IPKernelApp instance
    """
    connection_file = find_connection_file(kernel.connection_file)
    manager = QtKernelManager(connection_file=connection_file)
    manager.load_connection_file()
    manager.start_channels()
    atexit.register(manager.cleanup_connection_file)
    return manager


def _glue_terminal_1(**kwargs):
    """ Used for IPython v0.13, v0.12
    """
    kernel_app = default_kernel_app()
    manager = default_manager(kernel_app)

    try:  # IPython v0.13
        widget = DragAndDropTerminal(gui_completion='droplist')
    except TraitError:  # IPython v0.12
        widget = DragAndDropTerminal(gui_completion=True)
    widget.kernel_manager = manager
    widget.shell = kernel_app.shell

    # update namespace
    widget.update_namespace(kwargs)

    # IPython v0.12 turns on MPL interactive. Turn it back off
    import matplotlib
    matplotlib.interactive(False)
    return widget


# works on IPython v0.13, v0.14
@contextmanager
def redirect_output(session, pub_socket):
    """Prevent any of the widgets from permanently hijacking stdout or
    stderr"""
    sys.stdout = OutStream(session, pub_socket, u'stdout')
    sys.stderr = OutStream(session, pub_socket, u'stderr')
    try:
        yield
    finally:
        sys.stdout = sys.__stdout__
        sys.stderr = sys.__stderr__


def non_blocking_eventloop(kernel):
    kernel.timer = QtCore.QTimer()
    kernel.timer.timeout.connect(kernel.do_one_iteration)
    kernel.timer.start(1000 * kernel._poll_interval)


class EmbeddedQtKernel(Kernel):

    def __init__(self, *args, **kwargs):
        super(EmbeddedQtKernel, self).__init__(*args, **kwargs)
        self.eventloop = non_blocking_eventloop

    def do_one_iteration(self):
        with redirect_output(self.session, self.iopub_socket):
            super(EmbeddedQtKernel, self).do_one_iteration()

    def execute_request(self, stream, ident, parent):
        with redirect_output(self.session, self.iopub_socket):
            super(EmbeddedQtKernel, self).execute_request(
                stream, ident, parent)


class EmbeddedQtKernelApp(IPKernelApp):

    def init_kernel(self):
        shell_stream = ZMQStream(self.shell_socket)
        kernel = EmbeddedQtKernel(config=self.config, session=self.session,
                                  shell_streams=[shell_stream],
                                  iopub_socket=self.iopub_socket,
                                  stdin_socket=self.stdin_socket,
                                  log=self.log,
                                  profile_dir=self.profile_dir,
                                  )
        self.kernel = kernel
        kernel.record_ports(self.ports)

    def start(self):
        # handoff between IOLoop and QApplication event loops
        loop = ioloop.IOLoop.instance()
        # We used to have a value of 0ms as the second argument
        # (callback_time) in the following call, but this caused the
        # application to hang on certain setups, so use 1ms instead.
        stopper = ioloop.PeriodicCallback(loop.stop, 1, loop)
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(loop.start)
        self.timer.start(100)
        stopper.start()
        super(EmbeddedQtKernelApp, self).start()


class EmbeddedIPythonWidget(DragAndDropTerminal):
    gui_completion = 'droplist'

    def __init__(self, **kwargs):
        super(EmbeddedIPythonWidget, self).__init__(**kwargs)
        self._init_kernel_app()
        self._init_kernel_manager()
        self.update_namespace(kwargs)

    def _init_kernel_app(self):
        app = EmbeddedQtKernelApp.instance()
        try:
            app.initialize([])
        except ZMQError:
            pass  # already set up
        try:
            app.start()
        except RuntimeError:  # already started
            pass
        self.app = app
        self.shell = app.shell

    def _init_kernel_manager(self):
        connection_file = find_connection_file(self.app.connection_file)
        manager = QtKernelManager(connection_file=connection_file)
        manager.load_connection_file()
        manager.start_channels()
        atexit.register(manager.cleanup_connection_file)
        self.kernel_manager = manager

    def update_namespace(self, ns):
        self.app.shell.user_ns.update(ns)


def _glue_terminal_2(**kwargs):
    """Used for IPython v0.13, v0.14"""
    return EmbeddedIPythonWidget(**kwargs)


def _glue_terminal_3(**kwargs):
    """Used for IPython v1.0 and beyond

    :param kwargs: Keywords which are passed to Widget init,
    and which are also passed to the current namespace
    """
    # see IPython/docs/examples/frontends/inprocess_qtconsole.p

    shell = get_ipython()
    if shell is None or isinstance(shell, InProcessInteractiveShell):
        return in_process_console(console_class=DragAndDropTerminal, **kwargs)
    return connected_console(console_class=DragAndDropTerminal, **kwargs)


def glue_terminal(**kwargs):
    """ Return a qt widget which embed an IPython interpreter.

        Extra keywords will be added to the namespace of the shell

        :param kwargs: Extra variables to be added to the namespace

        :rtype: QWidget
    """
    from distutils.version import LooseVersion
    import IPython
    ver = LooseVersion(IPython.__version__)
    v1_0 = LooseVersion('1.0')
    v0_12 = LooseVersion('0.12')
    v0_13 = LooseVersion('0.13')

    if ver >= v1_0:
        return _glue_terminal_3(**kwargs)
    if ver >= v0_13:
        return _glue_terminal_2(**kwargs)
    if ver >= v0_12:
        return _glue_terminal_1(**kwargs)

    raise RuntimeError("Glue terminal requires IPython >= 0.12")

########NEW FILE########
__FILENAME__ = test_data_slice
import numpy as np
from mock import MagicMock

from .... import core
from ..data_slice_widget import DataSlice


class TestArraySlice(object):

    def test_1d(self):
        d = core.Data(x=[1, 2, 3])
        s = DataSlice(d)
        assert s.slice == ('x',)

    def test_2d(self):
        d = core.Data(x=[[1]])
        s = DataSlice(d)
        assert s.slice == ('y', 'x')

    def test_3d(self):
        d = core.Data(x=np.zeros((3, 3, 3)))
        s = DataSlice(d)

        assert s.slice == (1, 'y', 'x')

    def test_3d_change_mode(self):
        d = core.Data(x=np.zeros((3, 4, 5)))
        s = DataSlice(d)
        changed = MagicMock()
        s.slice_changed.connect(changed)

        assert s.slice == (1, 'y', 'x')

        s._slices[1].mode = 'slice'
        assert s.slice == ('y', 1, 'x')
        assert changed.call_count == 1

        s._slices[2].mode = 'slice'
        assert s.slice == ('y', 'x', 2)
        assert changed.call_count == 2

        s._slices[2].mode = 'y'
        assert s.slice == (1, 'x', 'y')
        assert changed.call_count == 3

        s._slices[2].mode = 'x'
        assert s.slice == (1, 'y', 'x')
        assert changed.call_count == 4

    def test_3d_change_slice(self):
        d = core.Data(x=np.zeros((3, 4, 5)))
        s = DataSlice(d)
        changed = MagicMock()
        s.slice_changed.connect(changed)

        s._slices[0].slice_center = 2
        assert s.slice == (2, 'y', 'x')
        assert changed.call_count == 1

        s._slices[1].mode = 'slice'
        s._slices[1].slice_center = 0
        assert s.slice == ('y', 0, 'x')
        assert changed.call_count == 3

        s._slices[2].mode = 'slice'
        assert s.slice == ('y', 'x', 2)
        assert changed.call_count == 4

########NEW FILE########
__FILENAME__ = test_data_viewer
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103

from ....core import Data, DataCollection
from ..histogram_widget import HistogramWidget
from ..scatter_widget import ScatterWidget
from ..image_widget import ImageWidget
from ...glue_application import GlueApplication

from . import simple_session

import pytest
from mock import MagicMock

ALL_WIDGETS = [HistogramWidget, ScatterWidget, ImageWidget]


def setup_function(func):
    import os
    os.environ['GLUE_TESTING'] = 'True'


@pytest.mark.parametrize(('widget'), ALL_WIDGETS)
def test_unregister_on_close(widget):
    unreg = MagicMock()
    session = simple_session()
    hub = session.hub

    w = widget(session)
    w.unregister = unreg
    w.register_to_hub(hub)
    w.close()
    unreg.assert_called_once_with(hub)


@pytest.mark.parametrize(('widget'), ALL_WIDGETS)
def test_single_draw_call_on_create(widget):
    d = Data(x=[[1, 2], [3, 4]])
    dc = DataCollection([d])
    app = GlueApplication(dc)

    try:
        from glue.qt.widgets.mpl_widget import MplCanvas
        draw = MplCanvas.draw
        MplCanvas.draw = MagicMock()

        app.new_data_viewer(widget, data=d)

        # each Canvas instance gives at most 1 draw call
        selfs = [c[0][0] for c in MplCanvas.draw.call_arg_list]
        assert len(set(selfs)) == len(selfs)
    finally:
        MplCanvas.draw = draw

########NEW FILE########
__FILENAME__ = test_histogram_widget
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import pytest

from . import simple_session
from ..histogram_widget import HistogramWidget, _hash
from .... import core


def mock_data():
    return core.Data(label='d1', x=[1, 2, 3], y=[2, 3, 4])

import os
os.environ['GLUE_TESTING'] = 'True'


class TestHistogramWidget(object):

    def setup_method(self, method):
        self.data = mock_data()
        self.session = simple_session()
        self.collect = self.session.data_collection
        self.hub = self.session.hub
        self.collect.append(self.data)
        self.widget = HistogramWidget(self.session)

    def teardown_method(self, method):
        self.widget.close()

    def set_up_hub(self):
        self.collect.register_to_hub(self.hub)
        self.widget.register_to_hub(self.hub)
        return self.hub

    def assert_component_integrity(self, dc=None, widget=None):
        dc = dc or self.collect
        widget = widget or self.widget
        combo = widget.ui.attributeCombo
        row = 0
        for data in dc:
            if data not in widget._container:
                continue
            assert combo.itemText(row) == data.label
            assert combo.itemData(row) == _hash(data)
            row += 2  # next row is separator
            for c in data.visible_components:
                assert combo.itemText(row) == c.label
                assert combo.itemData(row) == _hash(c)
                row += 1

    def test_attribute_set_with_combo(self):
        self.widget.ui.attributeCombo.setCurrentIndex(1)
        obj = self.widget.ui.attributeCombo.itemData(1)
        assert self.widget.client.component is obj

        obj = self.widget.ui.attributeCombo.itemData(0)
        self.widget.ui.attributeCombo.setCurrentIndex(0)
        assert self.widget.client.component is obj

    def test_attributes_populated_after_first_data_add(self):
        d2 = self.data
        self.collect.append(d2)
        self.widget.add_data(d2)
        assert self.widget.client.layer_present(d2)
        print list(self.widget.client._artists)

        self.assert_component_integrity()

    def test_double_add_ignored(self):
        self.widget.add_data(self.data)
        self.widget.add_data(self.data)

    def test_remove_data(self):
        """ should remove entry fom combo box """
        hub = self.set_up_hub()
        self.widget.add_data(self.data)
        self.collect.remove(self.data)
        assert not self.widget.data_present(self.data)

    def test_remove_all_data(self):
        self.set_up_hub()
        self.collect.append(core.Data())
        for data in list(self.collect):
            self.collect.remove(data)
            assert not self.widget.data_present(self.data)

    @pytest.mark.parametrize(('box', 'prop'),
                             [('normalized_box', 'normed'),
                              ('autoscale_box', 'autoscale'),
                              ('cumulative_box', 'cumulative'),
                              ('xlog_box', 'xlog'),
                              ('ylog_box', 'ylog')])
    def test_check_box_syncs_to_property(self, box, prop):
        box = getattr(self.widget.ui, box)
        box.toggle()
        assert getattr(self.widget.client, prop) == box.isChecked()
        box.toggle()
        assert getattr(self.widget.client, prop) == box.isChecked()

    def test_nbin_change(self):
        self.widget.ui.binSpinBox.setValue(7.0)
        assert self.widget.client.nbins == 7

    def test_update_xmin(self):
        self.widget.ui.xmin.setText('-5')
        self.widget._set_limits()
        assert self.widget.client.xlimits[0] == -5

    def test_update_xmax(self):
        self.widget.ui.xmin.setText('15')
        self.widget._set_limits()
        assert self.widget.client.xlimits[1] == 15

    def test_update_component_updates_title(self):
        self.widget.add_data(self.data)
        for comp in self.data.visible_components:
            self.widget.component = comp
            assert self.widget.windowTitle() == str(comp)

    def test_update_attributes_preserves_current_component(self):
        self.widget.add_data(self.data)
        self.widget.component = self.data.visible_components[1]
        self.widget._update_attributes()
        assert self.widget.component is self.data.visible_components[1]

    def test_invalid_component_set(self):
        with pytest.raises(IndexError) as exc:
            self.widget.component = None
        assert exc.value.args[0] == "Component not present: None"

    def test_combo_updates_with_component_add(self):
        hub = self.set_up_hub()
        self.widget.add_data(self.data)
        self.data.add_component(self.data[self.data.components[0]], 'testing')
        self.assert_component_integrity()

    def test_nonnumeric_first_component(self):
        # regression test for #208. Shouldn't complain if
        # first component is non-numerical
        data = core.Data()
        data.add_component(['a', 'b', 'c'], label='c1')
        data.add_component([1, 2, 3], label='c2')
        self.collect.append(data)
        self.widget.add_data(data)

########NEW FILE########
__FILENAME__ = test_image_widget
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
import numpy as np

from ..image_widget import ImageWidget

from .... import core
from ....core.tests.test_state import TestApplication
from ...glue_application import GlueApplication

from . import simple_session

import os
os.environ['GLUE_TESTING'] = 'True'


class TestImageWidget(object):

    def setup_method(self, method):
        self.session = simple_session()
        self.hub = self.session.hub
        self.collect = self.session.data_collection

        self.im = core.Data(label='im',
                            x=[[1, 2], [3, 4]],
                            y=[[2, 3], [4, 5]])
        self.cube = core.Data(label='cube',
                              x=[[[1, 2], [3, 4]], [[1, 2], [3, 4]]],
                              y=[[[1, 2], [3, 4]], [[1, 2], [3, 4]]])
        self.widget = ImageWidget(self.session)
        self.connect_to_hub()
        self.collect.append(self.im)
        self.collect.append(self.cube)

    def assert_title_correct(self):
        expected = "%s - %s" % (self.widget.client.display_data.label,
                                self.widget.client.display_attribute.label)
        assert self.widget.windowTitle() == expected

    def connect_to_hub(self):
        self.widget.register_to_hub(self.hub)
        self.collect.register_to_hub(self.hub)

    def _test_widget_synced_with_collection(self):
        dc = self.widget.ui.displayDataCombo
        assert dc.count() == len(self.collect)
        for data in self.collect:
            label = data.label
            pos = dc.findText(label)
            assert pos >= 0
            assert dc.itemData(pos) is data

    def test_synced_on_init(self):
        self._test_widget_synced_with_collection()

    def test_multi_add_ignored(self):
        """calling add_data multiple times doesn't corrupt data combo"""
        self.widget.add_data(self.collect[0])
        self.widget.add_data(self.collect[0])
        self._test_widget_synced_with_collection()

    def test_synced_on_remove(self):
        self.collect.remove(self.cube)
        self._test_widget_synced_with_collection()

    def test_window_title_matches_data(self):
        self.widget.add_data(self.collect[0])
        self.assert_title_correct()

    def test_window_title_updates_on_label_change(self):
        self.connect_to_hub()
        self.widget.add_data(self.collect[0])
        self.collect[0].label = 'Changed'
        self.assert_title_correct()

    def test_window_title_updates_on_component_change(self):
        self.connect_to_hub()
        self.widget.add_data(self.collect[0])
        self.widget.ui.attributeComboBox.setCurrentIndex(1)
        self.assert_title_correct()

    def test_data_combo_updates_on_change(self):
        self.connect_to_hub()
        self.widget.add_data(self.collect[0])
        self.collect[0].label = 'changed'
        data_labels = self._data_combo_labels()
        assert self.collect[0].label in data_labels

    def _data_combo_labels(self):
        combo = self.widget.ui.displayDataCombo
        return [combo.itemText(i) for i in range(combo.count())]

    def test_data_not_added_on_init(self):
        w = ImageWidget(self.session)
        assert self.im not in w.client.artists

    def test_selection_switched_on_add(self):
        w = ImageWidget(self.session)
        assert self.im not in w.client.artists
        w.add_data(self.im)
        assert self.im in w.client.artists
        w.add_data(self.cube)
        assert self.im not in w.client.artists
        assert self.cube in w.client.artists

    def test_component_add_updates_combo(self):
        self.widget.add_data(self.im)
        self.im.add_component(self.im[self.im.components[0]], 'testing')
        combo = self.widget.ui.attributeComboBox
        cids = [combo.itemText(i) for i in range(combo.count())]
        assert 'testing' in cids

    def test_image_correct_on_init_if_first_attribute_hidden(self):
        """Regression test for #127"""
        self.im.components[0]._hidden = True
        self.widget.add_data(self.im)
        combo = self.widget.ui.attributeComboBox
        index = combo.currentIndex()
        assert self.widget.client.display_attribute is combo.itemData(index)

    def test_paint(self):
        # make sure paint Events don't trigger any errors
        self.widget.add_data(self.im)
        self.widget.show()
        self.widget.close()

    def test_intensity_label(self):
        self.widget.add_data(self.im)
        att = self.widget.attribute
        intensity = self.im[att][1, 0]
        x, y = self.widget.client.axes.transData.transform([0.5, 1.5])
        assert self.widget._intensity_label(x, y) == 'data: %s' % intensity


class TestStateSave(TestApplication):

    def setup_method(self, method):
        LinkSame = core.link_helpers.LinkSame

        d = core.Data(label='im', x=[[1, 2], [2, 3]], y=[[2, 3], [4, 5]])
        d2 = core.Data(label='cat',
                       x=[0, 1, 0, 1],
                       y=[0, 0, 1, 1],
                       z=[1, 2, 3, 4])

        dc = core.DataCollection([d, d2])
        dc.add_link(LinkSame(d.get_pixel_component_id(0), d2.id['x']))
        dc.add_link(LinkSame(d.get_pixel_component_id(1), d2.id['y']))

        app = GlueApplication(dc)
        w = app.new_data_viewer(ImageWidget, data=d)
        self.d = d
        self.app = app
        self.w = w
        self.d2 = d2
        self.dc = dc

    def test_image_viewer(self):
        self.check_clone(self.app)

    def test_subset(self):
        d, w, app = self.d, self.w, self.app
        self.dc.new_subset_group()
        assert len(w.layers) == 2
        self.check_clone(app)

    def test_scatter_layer(self):
        # add scatter layer
        d, w, app, d2 = self.d, self.w, self.app, self.d2
        w.add_data(d2)
        assert len(w.layers) == 2
        self.check_clone(app)

    def test_cube(self):
        d = core.Data(label='cube',
                      x=np.zeros((2, 2, 2)))
        dc = core.DataCollection([d])
        app = GlueApplication(dc)
        w = app.new_data_viewer(ImageWidget, d)
        w.slice = ('x', 'y', 1)
        c = self.check_clone(app)
        w2 = c.viewers[0][0]
        assert w2.ui.slice.slice == ('x', 'y', 1)

    def test_rgb_layer(self):
        d, w, app = self.d, self.w, self.app

        x = d.id['x']
        y = d.id['y']
        w.client.display_data = d
        w.rgb_mode = True
        w.rgb_viz = (True, True, False)
        w.ratt = x
        w.gatt = y
        w.batt = x

        clone = self.check_clone(app)

        w = clone.viewers[0][0]

        assert w.rgb_viz == (True, True, False)
        assert w.rgb_mode
        assert w.ratt.label == 'x'
        assert w.gatt.label == 'y'
        assert w.batt.label == 'x'

########NEW FILE########
__FILENAME__ = test_layer_tree_widget
# pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
from ....external.qt.QtGui import QMainWindow
from ....external.qt.QtTest import QTest
from ....external.qt.QtCore import Qt
from ....external.qt.QtGui import QItemSelectionModel

from mock import MagicMock, patch
import pytest

from ..layer_tree_widget import (LayerTreeWidget, Clipboard,
                                 save_subset)

from ....tests import example_data
from .... import core


class TestLayerTree(object):

    """ Unit tests for the layer_tree_widget class """

    def setup_method(self, method):
        self.data = example_data.test_data()
        self.collect = core.data_collection.DataCollection(list(self.data))
        self.hub = self.collect.hub
        self.widget = LayerTreeWidget()
        self.win = QMainWindow()
        self.win.setCentralWidget(self.widget)
        self.widget.setup(self.collect)
        for key, value in self.widget._actions.items():
            self.__setattr__("%s_action" % key, value)

    def teardown_method(self, method):
        self.win.close()

    def select_layers(self, *layers):
        self.widget.layerTree.set_selected_layers(layers)

    def remove_layer(self, layer):
        """ Remove a layer via the widget remove button """
        self.select_layers(layer)
        QTest.mousePress(self.widget.layerRemoveButton, Qt.LeftButton)
        QTest.mouseRelease(self.widget.layerRemoveButton, Qt.LeftButton)

    def add_layer(self, layer=None):
        """ Add a layer through a hub message """
        layer = layer or core.Data()
        self.widget.data_collection.append(layer)
        return layer

    def layer_present(self, layer):
        """ Test that a layer exists in the data collection """
        return layer in self.collect or \
            getattr(layer, 'data', None) in self.collect

    def test_current_layer_method_correct(self):
        layer = self.add_layer()
        self.select_layers(layer)
        assert self.widget.current_layer() is layer

    def test_add(self):
        """ Test that a layer exists in widget once added """
        data = core.Data()
        assert not self.layer_present(data)
        self.add_layer(data)
        assert self.layer_present(data)

    def test_remove_layer(self):
        """ Test that widget remove button works properly """
        layer = self.add_layer()
        self.remove_layer(layer)
        assert not self.layer_present(layer)

    def test_remove_subset_triggers_selection_changed(self):
        layer = self.add_layer()
        grp = self.collect.new_subset_group()
        mock = MagicMock()
        self.select_layers(grp)
        self.widget.layerTree.selection_changed.connect(mock)
        QTest.mousePress(self.widget.layerRemoveButton, Qt.LeftButton)
        QTest.mouseRelease(self.widget.layerRemoveButton, Qt.LeftButton)
        assert mock.call_count > 0

    def test_remove_subset_layer(self):
        """ Test that widget remove button works properly on subset groups"""
        layer = self.add_layer()
        grp = self.collect.new_subset_group()
        assert self.layer_present(grp)
        self.remove_layer(grp)
        assert not self.layer_present(grp)

    def test_empty_removal_does_nothing(self):
        """ Make sure widgets are only removed when selected """
        layer = self.add_layer()
        self.widget.layerTree.clearSelection()
        QTest.mousePress(self.widget.layerRemoveButton, Qt.LeftButton)
        assert self.layer_present(layer)

    @patch('glue.qt.widgets.layer_tree_widget.LinkEditor')
    def test_link_data(self, le):
        layer = self.add_layer()
        self.select_layers(layer)
        self.link_action.trigger()
        assert le.update_links.call_count == 1

    def test_new_subset_action(self):
        """ new action creates a new subset group """
        layer = self.add_layer()
        self.new_action.trigger()
        assert len(self.collect.subset_groups) == 1

    def test_copy_paste_subset_action(self):
        layer = self.add_layer()
        grp = self.collect.new_subset_group()
        self.select_layers(grp)
        self.copy_action.trigger()
        grp2 = self.collect.new_subset_group()
        self.select_layers(grp2)
        state0 = grp2.subset_state
        self.paste_action.trigger()
        assert grp2.subset_state is not state0

    def setup_two_subset_selection(self):
        layer = self.add_layer()
        g1 = self.collect.new_subset_group()
        g2 = self.collect.new_subset_group()
        self.select_layers(g1, g2)
        return layer

    def test_invert(self):
        layer = self.add_layer()
        sub = self.collect.new_subset_group()
        self.select_layers(sub)
        self.invert_action.trigger()
        assert isinstance(sub.subset_state, core.subset.InvertState)

    def test_actions_enabled_single_subset_group_selection(self):
        Clipboard().contents = None
        layer = self.add_layer()
        grp = self.collect.new_subset_group()
        self.select_layers(grp)

        assert self.new_action.isEnabled()
        assert self.copy_action.isEnabled()
        assert not self.paste_action.isEnabled()
        assert self.invert_action.isEnabled()
        assert self.clear_action.isEnabled()

    def test_actions_enabled_single_data_selection(self):
        layer = self.add_layer()
        self.select_layers(layer)

        assert self.new_action.isEnabled()
        assert not self.copy_action.isEnabled()
        assert not self.paste_action.isEnabled()
        assert not self.invert_action.isEnabled()
        assert not self.clear_action.isEnabled()

    def test_actions_enabled_multi_subset_group_selection(self):
        layer = self.setup_two_subset_selection()
        assert self.new_action.isEnabled()
        assert not self.copy_action.isEnabled()
        assert not self.paste_action.isEnabled()
        assert not self.invert_action.isEnabled()
        assert not self.clear_action.isEnabled()

    def test_checkable_toggle(self):
        self.widget.set_checkable(True)
        assert self.widget.is_checkable()
        self.widget.set_checkable(False)
        assert not self.widget.is_checkable()

    def test_load_data(self):
        pth = 'glue.qt.widgets.layer_tree_widget.qtutil.data_wizard'
        with patch(pth) as wizard:
            wizard.return_value = [self.data[0]]
            self.widget._load_data()
            assert self.layer_present(self.data[0])

    def test_clear_subset_group(self):
        layer = self.add_layer()
        sub = self.collect.new_subset_group()
        self.select_layers(sub)
        dummy_state = MagicMock()
        sub.subset_state = dummy_state
        self.clear_action.trigger()
        assert sub.subset_state is not dummy_state

    def test_single_selection_updates_editable(self):
        self.widget.bind_selection_to_edit_subset()
        layer = self.add_layer()
        grp1 = self.collect.new_subset_group()
        grp2 = self.collect.new_subset_group()
        assert layer.edit_subset[0].group is not grp1
        self.select_layers(grp1)
        assert layer.edit_subset[0].group is grp1

    def test_multi_selection_updates_editable(self):
        """Selection disables edit_subset for all other data"""
        self.widget.bind_selection_to_edit_subset()
        layer = self.add_layer()
        layer2 = self.add_layer()
        grps = [self.collect.new_subset_group() for _ in range(3)]
        self.select_layers(*grps[:2])
        selected = [s.group for s in layer.edit_subset + layer2.edit_subset]
        assert grps[0] in selected
        assert grps[1] in selected
        assert grps[2] not in selected

    def test_selection_updates_on_data_add(self):
        layer = self.add_layer()
        assert self.widget.selected_layers() == [layer]

    def test_selection_updates_on_subset_group_add(self):
        layer = self.add_layer()
        grp = self.collect.new_subset_group()
        assert self.widget.selected_layers() == [grp]

    def test_save_subset(self):
        subset = MagicMock(core.Subset)
        with patch('glue.qt.widgets.layer_tree_widget.QFileDialog') as d:
            d.getSaveFileName.return_value = ('test.fits', None)
            save_subset(subset)
        subset.write_mask.assert_called_once_with('test.fits')

    def test_save_subset_cancel(self):
        subset = MagicMock(core.Subset)
        with patch('glue.qt.widgets.layer_tree_widget.QFileDialog') as d:
            d.getSaveFileName.return_value = ('', '')
            save_subset(subset)
        assert subset.write_mask.call_count == 0

########NEW FILE########
__FILENAME__ = test_pv
import numpy as np
from numpy.testing import assert_allclose
from mock import MagicMock

from ..image_widget import (_slice_from_path, _slice_label, _slice_index,
                            StandaloneImageWidget, PVSliceWidget)
from ....core import Data


class TestSliceExtraction(object):

    def setup_method(self, method):
        self.x = np.random.random((2, 3, 4))
        self.d = Data(x=self.x)

    def test_constant_y(self):

        slc = (0, 'y', 'x')
        x = [-0.5, 3.5]
        y = [0, 0]
        s, _, _ = _slice_from_path(x, y, self.d, 'x', slc)
        assert_allclose(s, self.x[:, 0, :])

    def test_constant_x(self):

        slc = (0, 'y', 'x')
        y = [-0.5, 2.5]
        x = [0, 0]
        s, _, _ = _slice_from_path(x, y, self.d, 'x', slc)
        assert_allclose(s, self.x[:, :, 0])

    def test_transpose(self):
        slc = (0, 'x', 'y')
        y = [-0.5, 3.5]
        x = [0, 0]
        s, _, _ = _slice_from_path(x, y, self.d, 'x', slc)
        assert_allclose(s, self.x[:, 0, :])


def test_slice_label():
    d = Data(x=np.zeros((2, 3, 4)))
    assert _slice_label(d, (0, 'y', 'x')) == 'World 0'
    assert _slice_label(d, ('y', 0, 'x')) == 'World 1'
    assert _slice_label(d, ('y', 'x', 0)) == 'World 2'


def test_slice_index():
    d = Data(x=np.zeros((2, 3, 4, 1)))
    assert _slice_index(d, (0, 'y', 'x', 0)) == 0
    assert _slice_index(d, (0, 'y', 0, 'x')) == 2


class TestStandaloneImageWidget(object):

    def setup_method(self, method):
        im = np.random.random((3, 3))
        self.w = StandaloneImageWidget(im)

    def test_set_cmap(self):
        act = self.w._cmap_actions[1]
        act.trigger()
        assert self.w._im.cmap is act.cmap

    def tesT_double_set_image(self):
        assert self.w._axes.images == 1
        self.w.set_image(np.zeros((3, 3)))
        assert len(self.w._axes.images) == 1


class MockImageWidget(object):

    def __init__(self, slice, data):
        self.slice = slice
        self.data = data
        self.client = MagicMock()


class TestPVSliceWidget(object):

    def setup_method(self, method):

        self.d = Data(x=np.zeros((2, 3, 4)))
        self.slc = (0, 'y', 'x')
        self.image = MockImageWidget(self.slc, self.d)
        self.w = PVSliceWidget(np.zeros((3, 4)),
                               [0, 1, 2, 3], [0, 1, 2], self.image)

    def test_basic(self):
        pass

########NEW FILE########
__FILENAME__ = test_scatter_widget
#pylint: disable=I0011,W0613,W0201,W0212,E1101,E1103
from distutils.version import LooseVersion  # pylint:disable=W0611

import pytest
from mock import patch

from ..scatter_widget import ScatterWidget
from ..mpl_widget import MplCanvas
from .... import core
from . import simple_session

from matplotlib import __version__ as mpl_version  # pylint:disable=W0611


class TestScatterWidget(object):

    def setup_method(self, method):
        s = simple_session()
        self.hub = s.hub
        self.d1 = core.Data(x=[1, 2, 3], y=[2, 3, 4],
                            z=[3, 4, 5], w=[4, 5, 6])
        self.d1.label = 'd1'
        self.d2 = core.Data(x=[1, 2, 3], y=[2, 3, 4],
                            z=[3, 4, 5], w=[4, 5, 6])
        self.d2.label = 'd2'
        self.data = [self.d1, self.d2]
        self.collect = s.data_collection
        self.collect.append(self.data)
        self.widget = ScatterWidget(s)
        self.session = s
        self.connect_to_hub()

    def teardown_method(self, method):
        self.assert_widget_synced()

    def assert_widget_synced(self):
        cl = self.widget.client
        w = self.widget
        assert abs(w.xmin - cl.xmin) < 1e-3
        assert abs(w.xmax - cl.xmax) < 1e-3
        assert w.xlog == cl.xlog
        assert w.ylog == cl.ylog
        assert w.xflip == cl.xflip
        assert w.yflip == cl.yflip
        assert abs(w.ymin - cl.ymin) < 1e-3
        assert abs(w.ymax - cl.ymax) < 1e-3

    def connect_to_hub(self):
        self.widget.register_to_hub(self.hub)
        self.collect.register_to_hub(self.hub)

    def add_layer_via_hub(self):
        layer = self.data[0]
        layer.label = 'Test Layer'
        self.collect.append(layer)
        return layer

    def add_layer_via_method(self, index=0):
        layer = self.data[index]
        self.widget.add_data(layer)
        return layer

    def plot_data(self, layer):
        """ Return the data bounds for a given layer (data or subset)
        Output format: [xmin, xmax], [ymin, ymax]
        """
        client = self.widget.client
        x, y = client.artists[layer][0].get_data()
        assert x.size > 0
        assert y.size > 0
        xmin = x.min()
        xmax = x.max()
        ymin = y.min()
        ymax = y.max()
        return [xmin, xmax], [ymin, ymax]

    def plot_limits(self):
        """ Return the plot limits
        Output format [xmin, xmax], [ymin, ymax]
        """
        ax = self.widget.client.axes
        xlim = ax.get_xlim()
        ylim = ax.get_ylim()
        return xlim, ylim

    def assert_layer_inside_limits(self, layer):
        """Assert that points of a layer are within plot limits """
        xydata = self.plot_data(layer)
        xylimits = self.plot_limits()
        assert xydata[0][0] >= xylimits[0][0]
        assert xydata[1][0] >= xylimits[1][0]
        assert xydata[0][1] <= xylimits[0][1]
        assert xydata[1][1] <= xylimits[1][1]

    def is_layer_present(self, layer):
        return self.widget.client.is_layer_present(layer)

    def is_layer_visible(self, layer):
        return self.widget.client.is_visible(layer)

    def test_rescaled_on_init(self):
        layer = self.add_layer_via_method()
        self.assert_layer_inside_limits(layer)

    def test_hub_data_add_is_ignored(self):
        layer = self.add_layer_via_hub()
        assert not self.widget.client.is_layer_present(layer)

    def test_valid_add_data_via_method(self):
        layer = self.add_layer_via_method()
        assert self.is_layer_present(layer)

    def test_add_first_data_updates_combos(self):
        layer = self.add_layer_via_method()
        xatt = str(self.widget.ui.xAxisComboBox.currentText())
        yatt = str(self.widget.ui.yAxisComboBox.currentText())
        assert xatt is not None
        assert yatt is not None

    def test_flip_x(self):
        layer = self.add_layer_via_method()
        self.widget.xflip = True
        assert self.widget.client.xflip
        self.widget.xflip = False
        assert not self.widget.client.xflip

    def test_flip_y(self):
        layer = self.add_layer_via_method()
        self.widget.yflip = True
        assert self.widget.client.yflip
        self.widget.yflip = False
        assert not self.widget.client.yflip

    def test_log_x(self):
        layer = self.add_layer_via_method()
        self.widget.xlog = True
        assert self.widget.client.xlog
        self.widget.xlog = False
        assert not self.widget.client.xlog

    def test_log_y(self):
        self.widget.ylog = True
        assert self.widget.client.ylog
        self.widget.ylog = False
        assert not self.widget.client.ylog

    def test_double_add_ignored(self):
        layer = self.add_layer_via_method()
        nobj = self.widget.ui.xAxisComboBox.count()
        layer = self.add_layer_via_method()
        assert self.widget.ui.xAxisComboBox.count() == nobj

    def test_subsets_dont_duplicate_fields(self):
        layer = self.add_layer_via_method()
        nobj = self.widget.ui.xAxisComboBox.count()
        subset = layer.new_subset()
        subset.register()
        assert self.widget.ui.xAxisComboBox.count() == nobj

    def test_correct_title_single_data(self):
        ct = self.widget.client.layer_count
        assert ct == 0
        layer = self.add_layer_via_method()
        ct = self.widget.client.layer_count
        assert ct == 1
        assert len(layer.label) > 0
        assert self.widget.windowTitle() == layer.label

    def test_title_updates_with_label_change(self):
        layer = self.add_layer_via_method()
        assert layer.hub is self.hub
        layer.label = "changed label"
        assert self.widget.windowTitle() == layer.label

    def test_title_updates_with_second_data(self):
        l1 = self.add_layer_via_method(0)
        l2 = self.add_layer_via_method(1)
        expected = '%s | %s' % (l1.label, l2.label)
        self.widget.windowTitle() == expected

    def test_second_data_add_preserves_plot_variables(self):
        l1 = self.add_layer_via_method(0)
        self.widget.ui.xAxisComboBox.setCurrentIndex(3)
        self.widget.ui.yAxisComboBox.setCurrentIndex(2)
        l2 = self.add_layer_via_method(1)

        assert self.widget.ui.xAxisComboBox.currentIndex() == 3
        assert self.widget.ui.yAxisComboBox.currentIndex() == 2

    def test_set_limits(self):
        l1 = self.add_layer_via_method(0)
        w = self.widget
        c = self.widget.client
        ax = self.widget.client.axes

        print w.xmin, w.xmax, w.ymin, w.ymax
        print c.xmin, c.xmax, c.ymin, c.ymax
        print ax.get_xlim(), ax.get_ylim()

        self.widget.xmax = 20
        print w.xmin, w.xmax, w.ymin, w.ymax
        print c.xmin, c.xmax, c.ymin, c.ymax
        print ax.get_xlim(), ax.get_ylim()

        self.widget.xmin = 10
        print w.xmin, w.xmax, w.ymin, w.ymax
        print c.xmin, c.xmax, c.ymin, c.ymax
        print ax.get_xlim(), ax.get_ylim()

        self.widget.ymax = 40
        print w.xmin, w.xmax, w.ymin, w.ymax
        print c.xmin, c.xmax, c.ymin, c.ymax
        print ax.get_xlim(), ax.get_ylim()

        self.widget.ymin = 30
        print w.xmin, w.xmax, w.ymin, w.ymax
        print c.xmin, c.xmax, c.ymin, c.ymax
        print ax.get_xlim(), ax.get_ylim()

        assert self.widget.client.axes.get_xlim() == (10, 20)
        assert self.widget.client.axes.get_ylim() == (30, 40)
        assert float(self.widget.ui.xmin.text()) == 10
        assert float(self.widget.ui.xmax.text()) == 20
        assert float(self.widget.ui.ymin.text()) == 30
        assert float(self.widget.ui.ymax.text()) == 40

    def test_widget_props_synced_with_client(self):

        self.widget.client.xmax = 100
        assert self.widget.xmax == 100
        self.widget.client.ymax = 200
        assert self.widget.ymax == 200

        self.widget.client.xmin = 10
        assert self.widget.xmin == 10

        self.widget.client.ymin = 30
        assert self.widget.ymin == 30

    @pytest.mark.xfail("LooseVersion(mpl_version) <= LooseVersion('1.1.0')")
    def test_labels_sync_with_plot_limits(self):
        """For some reason, manually calling draw() doesnt trigger the
        draw_event in MPL 1.1.0. Ths functionality nevertheless seems
        to work when actually using Glue"""

        l1 = self.add_layer_via_method(0)
        self.widget.client.axes.set_xlim((3, 4))
        self.widget.client.axes.set_ylim((5, 6))

        #call MPL draw to force render, not Glue draw
        super(MplCanvas, self.widget.client.axes.figure.canvas).draw()

        assert float(self.widget.ui.xmin.text()) == 3
        assert float(self.widget.ui.xmax.text()) == 4
        assert float(self.widget.ui.ymin.text()) == 5
        assert float(self.widget.ui.ymax.text()) == 6

    def assert_component_present(self, label):
        ui = self.widget.ui
        for combo in [ui.xAxisComboBox, ui.yAxisComboBox]:
            atts = [combo.itemText(i) for i in range(combo.count())]
            assert label in atts

    def test_component_change_syncs_with_combo(self):
        l1 = self.add_layer_via_method()
        cid = l1.add_component(l1[l1.components[0]], 'testing')
        self.assert_component_present('testing')

    def test_swap_axes(self):
        l1 = self.add_layer_via_method()
        cl = self.widget.client
        cl.xlog, cl.xflip = True, True
        cl.ylog, cl.yflip = False, False

        x, y = cl.xatt, cl.yatt

        self.widget.swap_axes()
        assert (cl.xlog, cl.xflip) == (False, False)
        assert (cl.ylog, cl.yflip) == (True, True)
        assert (cl.xatt, cl.yatt) == (y, x)

    def test_hidden(self):
        l1 = self.add_layer_via_method()
        xcombo = self.widget.ui.xAxisComboBox

        self.widget.hidden = False
        assert xcombo.count() == 4
        self.widget.hidden = True
        assert xcombo.count() == 6
        self.widget.hidden = False
        assert xcombo.count() == 4

    def test_add_subset_preserves_plot_variables(self):
        l1 = self.add_layer_via_method(0)
        print self.widget.client.layer_count

        self.widget.ui.xAxisComboBox.setCurrentIndex(3)
        self.widget.ui.yAxisComboBox.setCurrentIndex(2)
        assert self.widget.ui.xAxisComboBox.currentIndex() == 3
        assert self.widget.ui.yAxisComboBox.currentIndex() == 2

        s = self.data[1].new_subset(label='new')
        self.widget.add_subset(s)

        assert self.widget.ui.xAxisComboBox.currentIndex() == 3
        assert self.widget.ui.yAxisComboBox.currentIndex() == 2


class TestDrawCount(TestScatterWidget):

    def patch_draw(self):
        return patch('glue.qt.widgets.mpl_widget.MplCanvas.draw')

    def test_xatt_redraws_once(self):
        self.add_layer_via_method()
        with self.patch_draw() as draw:
            self.widget.yatt = self.widget.xatt
        assert draw.call_count == 1

    def test_swap_redraws_once(self):
        self.add_layer_via_method()
        with self.patch_draw() as draw:
            self.widget.swap_axes()
        assert draw.call_count == 1

########NEW FILE########
__FILENAME__ = test_settings
from ..settings_editor import SettingsEditor


class MockApplication(object):

    def __init__(self, data):
        self.data = data

    @property
    def settings(self):
        return list(self.data.items())

    def get_setting(self, key):
        return self.data[key]

    def set_setting(self, key, value):
        self.data[key] = value


class TestSettings(object):

    def setup_method(self, method):
        self.a = MockApplication({'k1': 'v1'})
        self.editor = SettingsEditor(self.a)
        self.widget = self.editor.widget

    def test_init(self):
        assert self.widget.item(0, 0).text() == 'k1'
        assert self.widget.item(0, 1).text() == 'v1'

    def test_set_setting(self):
        self.widget.item(0, 1).setText('v2')
        assert self.a.get_setting('k1') == 'v2'

########NEW FILE########
__FILENAME__ = test_table_widget
from ..table_widget import DataTableModel
from ....core import Data

from ....external.qt.QtCore import Qt


class TestDataTableModel(object):

    def setup_method(self, method):
        self.data = Data(x=[1, 2, 3, 4], y=[2, 3, 4, 5])
        self.model = DataTableModel(self.data)

    def test_column_count(self):
        assert self.model.columnCount() == 2

    def test_column_count_hidden(self):
        self.model.show_hidden = True
        assert self.model.columnCount() == 4

    def test_header_data(self):
        for i, c in enumerate(self.data.visible_components):
            result = self.model.headerData(i, Qt.Horizontal, Qt.DisplayRole)
            assert result == c.label

        for i in range(self.data.size):
            result = self.model.headerData(i, Qt.Vertical, Qt.DisplayRole)
            assert result == str(i)

    def test_row_count(self):
        assert self.model.rowCount() == 4

    def test_data(self):
        for i, c in enumerate(self.data.visible_components):
            for j in range(self.data.size):
                idx = self.model.index(j, i)
                result = self.model.data(idx, Qt.DisplayRole)
                assert float(result) == self.data[c, j]

    def test_data_2d(self):
        self.data = Data(x=[[1, 2], [3, 4]], y=[[2, 3], [4, 5]])
        self.model = DataTableModel(self.data)
        for i, c in enumerate(self.data.visible_components):
            for j in range(self.data.size):
                idx = self.model.index(j, i)
                result = self.model.data(idx, Qt.DisplayRole)
                assert float(result) == self.data[c].ravel()[j]

########NEW FILE########
__FILENAME__ = test_terminal
from ..terminal import glue_terminal

from mock import MagicMock, patch


class TestTerminal(object):
    def test_mpl_non_interactive(self):
        """IPython v0.12 sometimes turns on mpl interactive. Ensure
           we catch that"""

        import matplotlib
        assert not matplotlib.is_interactive()
        gt = glue_terminal()
        assert not matplotlib.is_interactive()

    def test_update_namespace(self):
        """Test that top level namespace API works without error"""
        gt = glue_terminal()
        gt.update_namespace({'x': 3})
        assert 'x' in gt.namespace

    def test_accepts_drops(self):
        gt = glue_terminal()
        assert gt.acceptDrops()

    def test_drops_update_namespace(self):
        """DnD adds variable name to namespace"""
        with patch('glue.qt.widgets.terminal.QInputDialog') as dialog:
            dialog.getText.return_value = 'accept_var', True

            gt = glue_terminal()
            event = MagicMock()
            event.mimeData().data.return_value = [5]

            gt.dropEvent(event)
            assert gt.namespace.get('accept_var') == 5

    def test_cancel_drop(self):
        """Drop not added if user cancels dialog box"""

        with patch('glue.qt.widgets.terminal.QInputDialog') as dialog:
            dialog.getText.return_value = 'cancel_var', False

            gt = glue_terminal()
            event = MagicMock()
            event.mimeData().data.return_value = [5]

            gt.dropEvent(event)
            assert 'cancel_var' not in gt.namespace

    def test_ignore_drag_enter(self):
        event = MagicMock()
        event.mimeData().hasFormat.return_value = False

        gt = glue_terminal()
        gt.dragEnterEvent(event)

        event.ignore.assert_called_once_with()

    def test_accept_drag_enter(self):
        event = MagicMock()
        event.mimeData().hasFormat.return_value = True

        gt = glue_terminal()
        gt.dragEnterEvent(event)

        event.accept.assert_called_once_with()


if __name__ == "__main__":
    import pytest
    pytest.main([__file__])

########NEW FILE########
__FILENAME__ = widget_properties
"""
The classes in this module provide a property-like interface
to widget instance variables in a class. These properties translate
essential pieces of widget state into more convenient python objects
(for example, the check state of a button to a bool).

Example Use::

    class Foo(object):
        bar = ButtonProperty('_button')

        def __init__(self):
            self._button = QtGui.QCheckBox()

    f = Foo()
    f.bar = True  # equivalent to f._button.setChecked(True)
    assert f.bar == True
"""
from functools import partial

from .qtutil import pretty_number
from ..external.qt import QtGui
from ..core.callback_property import add_callback


class WidgetProperty(object):

    """ Base class for widget properties

    Subclasses implement, at a minimum, the "get" and "set" methods,
    which translate between widget states and python variables
    """

    def __init__(self, att, docstring=''):
        """
        :param att: The location, within a class instance, of the widget
        to wrap around. If the widget is nested inside another variable,
        normal '.' syntax can be used (e.g. 'sub_window.button')

        :type att: str
        :param docstring: Optional short summary for the property.
                          Used by sphinx. Should be 1 sentence or less.
        :type docstring: str
        """
        self.__doc__ = docstring
        self._att = att.split('.')

    def __get__(self, instance, type=None):
        widget = reduce(getattr, [instance] + self._att)
        return self.getter(widget)

    def __set__(self, instance, value):
        widget = reduce(getattr, [instance] + self._att)
        self.setter(widget, value)

    def getter(self, widget):
        """ Return the state of a widget. Depends on type of widget,
        and must be overridden"""
        raise NotImplementedError()

    def setter(self, widget, value):
        """ Set the state of a widget to a certain value"""
        raise NotImplementedError()


class CurrentComboProperty(WidgetProperty):

    """Wrapper around ComboBoxes"""

    def getter(self, widget):
        """ Return the itemData stored in the currently-selected item """
        return widget.itemData(widget.currentIndex())

    def setter(self, widget, value):
        """ Update the currently selected item to the one which stores value in
        its itemData
        """
        for i in range(widget.count()):
            if widget.itemData(i) == value:
                widget.setCurrentIndex(i)
                return
        else:
            raise ValueError("%s not found in combo box" % value)


class TextProperty(WidgetProperty):

    """ Wrapper around the text() and setText() methods for QLabel etc"""

    def getter(self, widget):
        return widget.text()

    def setter(self, widget, value):
        widget.setText(value)


class ButtonProperty(WidgetProperty):

    """Wrapper around the check state for QAbstractButton widgets"""

    def getter(self, widget):
        return widget.isChecked()

    def setter(self, widget, value):
        widget.setChecked(value)


class FloatLineProperty(WidgetProperty):

    """Wrapper around the text state for QLineEdit widgets.

    Assumes that the text is a floating point number
    """

    def getter(self, widget):
        try:
            return float(widget.text())
        except ValueError:
            return 0

    def setter(self, widget, value):
        widget.setText(pretty_number(value))
        widget.editingFinished.emit()


class ValueProperty(WidgetProperty):

    """Wrapper around value() and setValue() intspin boxes"""

    def getter(self, widget):
        return widget.value()

    def setter(self, widget, value):
        widget.setValue(value)


def connect_bool_button(client, prop, widget):
    """ Connect widget.setChecked and client.prop

    client.prop should be a callback property
    """
    add_callback(client, prop, widget.setChecked)
    widget.toggled.connect(partial(setattr, client, prop))


def connect_float_edit(client, prop, widget):
    """ Connect widget.setText and client.prop
    Also pretty-print the number

    client.prop should be a callback property
    """
    v = QtGui.QDoubleValidator(None)
    v.setDecimals(4)
    widget.setValidator(v)

    def update_prop():
        val = widget.text()
        try:
            setattr(client, prop, float(val))
        except ValueError:
            setattr(client, prop, 0)

    def update_widget(val):
        widget.setText(pretty_number(val))

    add_callback(client, prop, update_widget)
    widget.editingFinished.connect(update_prop)
    update_widget(getattr(client, prop))


def connect_int_spin(client, prop, widget):
    """
    Connect client.prop to widget.valueChanged

    client.prop should be a callback property
    """
    add_callback(client, prop, widget.setValue)
    widget.valueChanged.connect(partial(setattr, client, prop))

########NEW FILE########
__FILENAME__ = test
import sys


def main():
    import glue
    try:
        import pytest
    except ImportError:
        raise ImportError("Glue testing requires pytest")

    return pytest.main(glue.__path__[0])

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = example_data
import pkgutil

import numpy as np

import glue


def test_histogram_data():
    data = glue.core.data.Data(label="Test Data")
    comp_a = glue.core.data.Component(np.random.uniform(size=500))
    comp_b = glue.core.data.Component(np.random.normal(size=500))
    data.add_component(comp_a, 'uniform')
    data.add_component(comp_b, 'normal')
    return data


def test_data():
    data = glue.core.data.Data(label="Test Data 1")
    data2 = glue.core.data.Data(label="Teset Data 2")

    comp_a = glue.core.data.Component(np.array([1, 2, 3]))
    comp_b = glue.core.data.Component(np.array([1, 2, 3]))
    comp_c = glue.core.data.Component(np.array([2, 4, 6]))
    comp_d = glue.core.data.Component(np.array([1, 3, 5]))
    data.add_component(comp_a, 'a')
    data.add_component(comp_b, 'b')
    data2.add_component(comp_c, 'c')
    data2.add_component(comp_d, 'd')
    return data, data2


def test_categorical_data():

    data = glue.core.data.Data(label="Test Cat Data 1")
    data2 = glue.core.data.Data(label="Teset Cat Data 2")

    comp_x1 = glue.core.data.CategoricalComponent(np.array(['a', 'a', 'b']))
    comp_y1 = glue.core.data.Component(np.array([1, 2, 3]))
    comp_x2 = glue.core.data.CategoricalComponent(np.array(['c', 'a', 'b']))
    comp_y2 = glue.core.data.Component(np.array([1, 3, 5]))
    data.add_component(comp_x1, 'x1')
    data.add_component(comp_y1, 'y1')
    data2.add_component(comp_x2, 'x2')
    data2.add_component(comp_y2, 'y2')
    return data, data2


def test_image():
    data = glue.core.data.Data(label="Test Image")
    comp_a = glue.core.data.Component(np.ones((25, 25)))
    data.add_component(comp_a, 'test_1')
    comp_b = glue.core.data.Component(np.zeros((25, 25)))
    data.add_component(comp_b, 'test_2')
    return data


def test_cube():
    data = glue.core.data.Data(label="Test Cube")
    comp_a = glue.core.data.Component(np.ones((16, 16, 16)))
    data.add_component(comp_a, 'test_3')
    return data

########NEW FILE########
__FILENAME__ = test_config
from ..config import qt_client, link_function, data_factory


def test_default_clients():
    from glue.qt.widgets.image_widget import ImageWidget
    from glue.qt.widgets.scatter_widget import ScatterWidget
    from glue.qt.widgets.histogram_widget import HistogramWidget
    import glue.config

    assert ImageWidget in qt_client
    assert ScatterWidget in qt_client
    assert HistogramWidget in qt_client


def test_add_client():
    @qt_client
    class TestClient(object):
        pass

    assert TestClient in qt_client


def test_link_defaults():
    from ..core.link_helpers import __LINK_FUNCTIONS__
    assert len(__LINK_FUNCTIONS__) > 0

    for l in __LINK_FUNCTIONS__:
        assert l in [ll[0] for ll in link_function]


def test_add_link_default():
    @link_function(info='maps x to y', output_labels=['y'])
    def foo(x):
        return 3
    val = (foo, 'maps x to y', ['y'])
    assert val in link_function


def test_data_facotry_defaults():
    from ..core.data_factories import __factories__
    assert len(__factories__) > 0

    for f in __factories__:
        assert f in (ff[0] for ff in data_factory.members)


def test_add_data_factory():
    @data_factory('XYZ file', "*txt")
    def foo(x):
        pass
    assert (foo, 'XYZ file', '*txt') in data_factory


def test_data_factory_default():
    from ..core.data_factories import get_default_factory

    @data_factory("XYZ file", '*xyz', 'xyz abc')
    def foo(x):
        pass
    assert get_default_factory('xyz') is foo
    assert get_default_factory('abc') is foo

    @data_factory('ABC file', '*abc', 'abc')
    def bar(x):
        pass

    assert get_default_factory('xyz') is foo
    assert get_default_factory('abc') is bar

    @data_factory('', '', '')
    def baz(x):
        pass

########NEW FILE########
__FILENAME__ = test_deps
from mock import MagicMock, patch

from .._deps import Dependency
from .. import _deps as dep


class TestDependency(object):

    def test_installed(self):
        d = Dependency('math', 'the math module')
        assert d.installed

    def test_uninstalled(self):
        d = Dependency('asdfasdf', 'Non-existent module')
        assert not d.installed

    def test_noinstall(self):
        with patch('glue._deps.check_call') as check_call:
            d = Dependency('math', 'exists')
            d.install()
            assert check_call.call_count == 0

    def test_install(self):
        with patch('glue._deps.check_call') as check_call:
            d = Dependency('asdfasdf', 'never exists')
            d.install()
            check_call.assert_called_once_with(['pip',
                                                'install',
                                                'asdfasdf'])

    def test_install_with_package_arg(self):
        with patch('glue._deps.check_call') as check_call:
            d = Dependency('asdfasdf', 'never exists', package='bcd')
            d.install()
            check_call.assert_called_once_with(['pip',
                                                'install',
                                                'bcd'])

    def test_installed_str(self):
        d = Dependency('math', 'info')
        assert str(d) == "                math:\tINSTALLED"

    def test_noinstalled_str(self):
        d = Dependency('asdf', 'info')
        assert str(d) == "                asdf:\tMISSING (info)"

    def test_failed_str(self):
        d = Dependency('asdf', 'info')
        d.failed = True
        assert str(d) == "                asdf:\tFAILED (info)"

########NEW FILE########
__FILENAME__ = test_main
import pytest
from mock import patch, MagicMock

from ..main import (die_on_error, restore_session, load_data_files,
                    main, start_glue)

from ..core import Data, DataCollection, Hub


def test_die_on_error_exception():
    """Decorator should spawn a QMessageBox and exit"""
    with pytest.raises(SystemExit):
        with patch('glue.external.qt.QtGui.QMessageBox') as qmb:
            @die_on_error('test_msg')
            def test():
                raise Exception()
            test()
            assert qmb.call_count == 1


def test_die_on_error_noexception():
    """Decorator should have no effect"""
    @die_on_error('test_msg')
    def test():
        return 0
    assert test() == 0


def test_load_data_files():
    with patch('glue.core.data_factories.load_data') as ld:
        ld.return_value = Data()
        dc = load_data_files(['test.py'])
        assert len(dc) == 1


def check_main(cmd, glue, config, data):
    """Pass command to main program, check for expected parsing"""
    with patch('glue.main.start_glue') as sg:
        main(cmd.split())
        args, kwargs = sg.call_args
        assert kwargs.get('datafiles', None) == data
        assert kwargs.get('gluefile', None) == glue
        assert kwargs.get('config', None) == config


def check_exec(cmd, pyfile):
    """Assert that main correctly dispatches to execute_script"""
    with patch('glue.main.execute_script') as es:
        main(cmd.split())
        args, kwargs = es.call_args
        assert args[0] == pyfile


def test_main_single_data():
    check_main('glueqt test.fits', None, None, ['test.fits'])


def test_main_multi_data():
    check_main('glueqt test.fits t2.csv', None, None, ['test.fits', 't2.csv'])


def test_main_config():
    check_main('glueqt -c config.py', None, 'config.py', None)


def test_main_glu_arg():
    check_main('glueqt -g test.glu', 'test.glu', None, None)


def test_main_auto_glu():
    check_main('glueqt test.glu', 'test.glu', None, None)


def test_main_many_args():
    check_main('glueqt -c config.py data.fits d2.csv', None,
               'config.py', ['data.fits', 'd2.csv'])


def test_exec():
    check_exec('glueqt -x test.py', 'test.py')


def test_auto_exec():
    check_exec('glueqt test.py', 'test.py')


@pytest.mark.parametrize(('cmd'), ['glueqt -g test.glu test.fits',
                                   'glueqt -g test.py test.fits',
                                   'glueqt -x test.py -g test.glu',
                                   'glueqt -x test.py -c test.py',
                                   'glueqt -x',
                                   'glueqt -g',
                                   'glueqt -c'])
def test_invalid(cmd):
    with pytest.raises(SystemExit):
        main(cmd.split())


@pytest.mark.parametrize(('glue', 'config', 'data'),
                         [('test.glu', None, None),
                          (None, 'test.py', None),
                          (None, None, ['test.fits']),
                          (None, None, ['a.fits', 'b.fits']),
                          (None, 'test.py', ['a.fits'])])
def test_start(glue, config, data):
    with patch('glue.main.restore_session') as rs:
        with patch('glue.config.load_configuration') as lc:
            with patch('glue.main.load_data_files') as ldf:
                with patch('glue.qt.glue_application.GlueApplication') as ga:
                    with patch('glue.external.qt.QtGui') as qt:

                        rs.return_value = ga
                        ldf.return_value = Data()

                        start_glue(glue, config, data)
                        if glue:
                            rs.assert_called_once_with(glue)
                        if config:
                            lc.assert_called_once_with(search_path=[config])
                        if data:
                            ldf.assert_called_once_with(data)

########NEW FILE########
__FILENAME__ = test_qglue
import numpy as np
from astropy.table import Table

from mock import patch
import pytest

from .. import qglue
from ..core.registry import Registry
from ..core.exceptions import IncompatibleAttribute
from ..core import Data


def has_pandas():
    try:
        import pandas
        return True
    except:
        return False


class TestQGlue(object):
    def setup_method(self, method):
        Registry().clear()

        x = [1, 2, 3]
        y = [2, 3, 4]

        u = [10, 20, 30, 40]
        v = [20, 40, 60, 80]

        self.xy = {'x': x, 'y': y}
        self.dict_data = {'u': u, 'v': v}
        self.recarray_data = np.rec.array([(0, 1), (2, 3)],
                                          dtype=[('a', 'i'), ('b', 'i')])
        self.astropy_table = Table({'x': x, 'y': y})
        self.bad_data = {'x': x, 'u': u}

        self.x = np.array(x)
        self.y = np.array(y)
        self.u = np.array(u)
        self.v = np.array(v)

    def check_setup(self, dc, expected):
        #assert that the assembled data collection returned
        #form qglue matches expected structure

        #test for expected data, components
        for data in dc:
            components = set(c.label for c in data.components)
            e = expected.pop(data.label)
            for component in e:
                assert component in components
        assert len(expected) == 0

    @pytest.mark.skipif("not has_pandas()")
    def test_qglue_starts_application(self):
        import pandas as pd
        pandas_data = pd.DataFrame(self.xy)

        with patch('glue.qt.glue_application.GlueApplication') as ga:
            dc = qglue(data1=pandas_data)
            ga.assert_called_once_with(dc)
            ga().start.assert_called_once_with()

    def test_single_pandas(self):
        with patch('glue.qt.glue_application.GlueApplication') as ga:
            dc = qglue(data1=self.xy)
            self.check_setup(dc, {'data1': ['x', 'y']})

    def test_single_dict(self):
        with patch('glue.qt.glue_application.GlueApplication') as ga:
            dc = qglue(data2=self.dict_data)
            self.check_setup(dc, {'data2': ['u', 'v']})

    def test_recarray(self):
        with patch('glue.qt.glue_application.GlueApplication') as ga:
            dc = qglue(data3=self.recarray_data)
            self.check_setup(dc, {'data3': ['a', 'b']})

    def test_astropy_table(self):
        with patch('glue.qt.glue_application.GlueApplication') as ga:
            dc = qglue(data4=self.astropy_table)
            self.check_setup(dc, {'data4': ['x', 'y']})

    def test_multi_data(self):
        with patch('glue.qt.glue_application.GlueApplication') as ga:
            dc = qglue(data1=self.dict_data, data2=self.xy)
            self.check_setup(dc, {'data1': ['u', 'v'],
                                  'data2': ['x', 'y']})

    def test_glue_data(self):
        d = Data(x=[1, 2, 3])
        with patch('glue.qt.glue_application.GlueApplication') as ga:
            dc = qglue(x=d)
        assert d.label == 'x'

    def test_simple_link(self):
        with patch('glue.qt.glue_application.GlueApplication') as ga:
            using = lambda x: x * 2
            links = [['data1.x', 'data2.u', using]]
            dc = qglue(data1=self.xy, data2=self.dict_data,
                       links=links)

            links = [[['x'], 'u', using]]
            self.check_setup(dc, {'data1': ['x', 'y'],
                                  'data2': ['u', 'v']})

            d = dc[0] if dc[0].label == 'data1' else dc[1]
            np.testing.assert_array_equal(d['x'], self.x)
            np.testing.assert_array_equal(d['u'], self.x * 2)
            d = dc[0] if dc[0].label == 'data2' else dc[1]
            with pytest.raises(IncompatibleAttribute) as exc:
                d['x']

    def test_multi_link(self):
        with patch('glue.qt.glue_application.GlueApplication') as ga:
            forwards = lambda *args: (args[0] * 2, args[1] * 3)
            backwards = lambda *args: (args[0] / 2, args[1] / 3)

            links = [[['Data1.x', 'Data1.y'],
                      ['Data2.u', 'Data2.v'], forwards, backwards]]
            dc = qglue(Data1=self.xy, Data2=self.dict_data,
                       links=links)

            self.check_setup(dc, {'Data1': ['x', 'y'],
                                  'Data2': ['u', 'v']})

            for d in dc:
                if d.label == 'Data1':
                    np.testing.assert_array_equal(d['x'], self.x)
                    np.testing.assert_array_equal(d['y'], self.y)
                    np.testing.assert_array_equal(d['u'], self.x * 2)
                    np.testing.assert_array_equal(d['v'], self.y * 3)
                else:
                    np.testing.assert_array_equal(d['x'], self.u / 2)
                    np.testing.assert_array_equal(d['y'], self.v / 3)
                    np.testing.assert_array_equal(d['u'], self.u)
                    np.testing.assert_array_equal(d['v'], self.v)

    def test_implicit_identity_link(self):
        with patch('glue.qt.glue_application.GlueApplication') as ga:
            links = [('Data1.x', 'Data2.v'),
                     ('Data1.y', 'Data2.u')]
            dc = qglue(Data1=self.xy, Data2=self.dict_data,
                       links=links)
        #currently, identity links rename the second link to first,
        #so u/v disappear
        for d in dc:
            if d.label == 'Data1':
                np.testing.assert_array_equal(d['x'], self.x)
                np.testing.assert_array_equal(d['y'], self.y)
            else:
                np.testing.assert_array_equal(d['y'], self.u)
                np.testing.assert_array_equal(d['x'], self.v)

    def test_bad_link(self):
        forwards = lambda *args: args
        links = [(['Data1.a'], ['Data2.b'], forwards)]
        with pytest.raises(ValueError) as exc:
            dc = qglue(Data1=self.xy, Data2=self.dict_data,
                       links=links)
        assert exc.value.args[0] == "Invalid link (no component named Data1.a)"

    def test_bad_data_shape(self):
        with pytest.raises(ValueError) as exc:
            dc = qglue(d=self.bad_data)
        assert exc.value.args[0].startswith("Invalid format for data 'd'")

    def test_bad_data_format(self):
        with pytest.raises(TypeError) as exc:
            dc = qglue(d=np.array([1, 2, 3]))
        assert exc.value.args[0].startswith("Invalid data description")

    def test_malformed_data_dict(self):
        with pytest.raises(ValueError) as exc:
            dc = qglue(d={'x': 'bad'})
        assert exc.value.args[0].startswith("Invalid format for data 'd'")

########NEW FILE########
__FILENAME__ = version
__version__ = '0.1.0dev'

########NEW FILE########
__FILENAME__ = _deps
#!/usr/bin/env python
"""
Guide users through installing Glue's dependencies
"""

# Unfortunately, we can't rely on setuptools' install_requires
# keyword, because matplotlib doesn't properly install its dependencies
from subprocess import check_call, CalledProcessError
import sys
from imp import find_module


class Dependency(object):

    def __init__(self, module, info, package=None, min_version=None):
        self.module = module
        self.info = info
        self.package = package or module
        self.min_version = min_version
        self.failed = False

    @property
    def installed(self):
        try:
            find_module(self.module)
            return True
        except ImportError:
            return False

    def install(self):
        if self.installed:
            return

        try:
            check_call(['pip', 'install', self.package])
        except CalledProcessError:
            self.failed = True

    def help(self):
        result = """
{module}:
******************

{info}

PIP package name:
{package}
""".format(module=self.module, info=self.info, package=self.package)
        return result

    def __str__(self):
        if self.installed:
            status = 'INSTALLED'
        elif self.failed:
            status = 'FAILED (%s)' % self.info
        else:
            status = 'MISSING (%s)' % self.info
        return "%20s:\t%s" % (self.module, status)


class QtDep(Dependency):

    def __init__(self):
        self.module = 'PyQt4 or PySide'
        self.info = ('GUI Library (install at http://bit.ly/YfTFxj or '
                     'http://bit.ly/Zci3Di)')
        self.package = 'N/A'

    @property
    def installed(self):
        for mod in ['PyQt4', 'PySide']:
            try:
                find_module(mod)
                return True
            except ImportError:
                pass
        else:
            return False

    def install(self):
        print ("*******************************\n"
               "CANNOT AUTOMATICALLY INSTALL PyQt4 or PySide.\n"
               "Install PyQt4 at http://bit.ly/YfTFxj, or\n"
               "Install PySide at http://bit.ly/Zci3Di\n"
               "*******************************\n"
               )


# Add any dependencies here
# Make sure to add new categories to the categories tuple
required = (
    QtDep(),
    Dependency('numpy', 'Required', min_version='1.4'),
    Dependency('matplotlib', 'Required for plotting', min_version='1.1'),
    Dependency('pandas', 'Adds support for Excel files and DataFrames', min_version='0.13.1'),
    Dependency('astropy', 'Used for FITS I/O, table reading, and WCS Parsing'))

general = (
    Dependency('dill', 'Used when saving Glue sessions'),
    Dependency('scipy', 'Used for some image processing calculation'),
    Dependency('skimage',
               'Used to read popular image formats (jpeg, png, etc.)',
               'scikit-image'))


ipython = (
    Dependency('IPython', 'Needed for interactive IPython terminal'),
    Dependency('pygments', 'Needed for interactive IPython terminal'),
    Dependency('zmq', 'Needed for interactive IPython terminal', 'pyzmq'))


astronomy = (
    Dependency('pyavm', 'Used to parse AVM metadata in image files', 'PyAVM'),)


testing = (
    Dependency('mock', 'Used in test code'),
    Dependency('pytest', 'Used in test code'))

export = (
    Dependency('plotly', 'Used to explort plots to Plot.ly'),
)

categories = (('required', required),
              ('general', general),
              ('ipython terminal', ipython),
              ('astronomy', astronomy),
              ('testing', testing),
              ('export', export))

dependencies = {d.module: d for c in categories for d in c[1]}


def show_status():
    for category, deps in categories:
        print "%21s" % category.upper()
        for dep in deps:
            print dep
        print '\n'


def install_all():
    for category, deps in categories:
        for dep in deps:
            dep.install()


def install_selected(modules):
    modules = set(m.lower() for m in modules)

    for category, deps in categories:
        for dep in deps:
            if dep.installed:
                continue
            if dep.module.lower() in modules or category.lower() in modules:
                dep.install()


def main(argv=None):
    argv = argv or sys.argv

    usage = """usage:
    #install all dependencies
    %s install

    #show all dependencies
    %s list

    #install a specific dependency or category
    %s install astropy
    %s install astronomy

    #display information about a dependency
    %s info astropy
""" % ('glue-deps', 'glue-deps', 'glue-deps', 'glue-deps', 'glue-deps')

    if len(argv) < 2 or argv[1] not in ['install', 'list', 'info']:
        sys.stderr.write(usage)
        sys.exit(1)

    if argv[1] == 'info':
        if len(argv) != 3:
            sys.stderr.write(usage)
            sys.stderr.write("Please specify a dependency\n")
            sys.exit(1)

        dep = dependencies.get(argv[2], None)

        if dep is None:
            sys.stderr.write("Unrecognized dependency: %s\n" % argv[2])
            sys.exit(1)

        print dep.help()
        sys.exit(0)

    if argv[1] == 'list':
        show_status()
        sys.exit(0)

    # argv[1] == 'install'
    if len(argv) == 2:
        install_all()
        show_status()
        sys.exit(0)

    install_selected(argv[2:])
    show_status()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = runtests
#! /usr/bin/env python

sources = """
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
xmyBd3J2fZxjp+ULOUhv/+e++H9Pqn4x
"""

import sys
import base64
import zlib
import imp

class DictImporter(object):
    def __init__(self, sources):
        self.sources = sources

    def find_module(self, fullname, path=None):
        if fullname in self.sources:
            return self
        if fullname + '.__init__' in self.sources:
            return self
        return None

    def load_module(self, fullname):
        # print "load_module:",  fullname
        from types import ModuleType
        try:
            s = self.sources[fullname]
            is_pkg = False
        except KeyError:
            s = self.sources[fullname + '.__init__']
            is_pkg = True

        co = compile(s, fullname, 'exec')
        module = sys.modules.setdefault(fullname, ModuleType(fullname))
        module.__file__ = "%s/%s" % (__file__, fullname)
        module.__loader__ = self
        if is_pkg:
            module.__path__ = [fullname]

        do_exec(co, module.__dict__)
        return sys.modules[fullname]

    def get_source(self, name):
        res = self.sources.get(name)
        if res is None:
            res = self.sources.get(name + '.__init__')
        return res

if __name__ == "__main__":
    if sys.version_info >= (3, 0):
        exec("def do_exec(co, loc): exec(co, loc)\n")
        import pickle
        sources = sources.encode("ascii") # ensure bytes
        sources = pickle.loads(zlib.decompress(base64.decodebytes(sources)))
    else:
        import cPickle as pickle
        exec("def do_exec(co, loc): exec co in loc\n")
        sources = pickle.loads(zlib.decompress(base64.decodestring(sources)))

    importer = DictImporter(sources)
    sys.meta_path.append(importer)

    entry = "import py; raise SystemExit(py.test.cmdline.main())"
    do_exec(entry, locals())

########NEW FILE########
