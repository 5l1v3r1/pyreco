__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# rabbitpy documentation build configuration file, created by
# sphinx-quickstart on Wed Mar 27 18:31:37 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys

sys.path.insert(0, '../')

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.viewcode',
              'sphinx.ext.autosummary', 'sphinx.ext.intersphinx']
# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'rabbitpy'
copyright = u'2013, Gavin M. Roy'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.

import rabbitpy
release = rabbitpy.__version__
version = '.'.join(release.split('.')[0:1])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

intersphinx_mapping = {'pamqp': ('https://pamqp.readthedocs.org/en/latest/',
                                 None),
                       'python': ('https://docs.python.org/2/', None)}

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'rabbitpydoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'rabbitpy.tex', u'rabbitpy Documentation',
   u'Gavin M. Roy', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'rabbitpy', u'rabbitpy Documentation',
     [u'Gavin M. Roy'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'rabbitpy', u'rabbitpy Documentation',
   u'Gavin M. Roy', 'rabbitpy', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = consumer
#!/usr/bin/env python
import rabbitpy

with rabbitpy.Connection('amqp://guest:guest@localhost:5672/%2f') as conn:
    with conn.channel() as channel:
        queue = rabbitpy.Queue(channel, 'example')

        # Exit on CTRL-C
        try:

            # Consume the message
            for message in queue.consume_messages():
                print('Message:')
                print(' ID: %s' % message.properties['message_id'])
                print(' Time: %s' % message.properties['timestamp'])
                print(' Body: %s' % message.body)
                message.ack()

        except KeyboardInterrupt:
            print('Exited consumer')

########NEW FILE########
__FILENAME__ = getter
#!/usr/bin/env python
import rabbitpy

url = 'amqp://guest:guest@localhost:5672/%2F'
connection = rabbitpy.Connection(url)
channel = connection.channel()
queue = rabbitpy.Queue(channel, 'example')

while len(queue) > 0:
    message = queue.get()
    print('Message:')
    print(' ID: %s' % message.properties['message_id'])
    print(' Time: %s' % message.properties['timestamp'].isoformat())
    print(' Body: %s' % message.body)
    message.ack()

    print('There are %i more messages in the queue' % len(queue))
########NEW FILE########
__FILENAME__ = publisher
#!/usr/bin/env python
import rabbitpy
import logging
logging.basicConfig(level=logging.DEBUG)

# Use a new connection as a context manager
with rabbitpy.Connection('amqp://guest:guest@localhost:5672/%2f') as conn:

    # Use the channel as a context manager
    with conn.channel() as channel:

        # Create the exchange
        exchange = rabbitpy.Exchange(channel, 'example_exchange')
        exchange.declare()

        # Create the queue
        queue = rabbitpy.Queue(channel, 'example')
        queue.declare()

        # Bind the queue
        queue.bind(exchange, 'test-routing-key')

        # Create the msg by passing channel, message and properties (as a dict)
        message = rabbitpy.Message(channel,
                                   'Lorem ipsum dolor sit amet, consectetur '
                                   'adipiscing elit.',
                                   {'content_type': 'text/plain',
                                    'delivery_mode': 1,
                                    'message_type': 'Lorem ipsum'})

        # Publish the message
        message.publish(exchange, 'test-routing-key')

########NEW FILE########
__FILENAME__ = transactional_publisher
#!/usr/bin/env python
import rabbitpy

with rabbitpy.Connection('amqp://guest:guest@localhost:5672/%2f') as conn:
    with conn.channel() as channel:

        # Create the exchange
        exchange = rabbitpy.Exchange(channel, 'example_exchange')
        exchange.declare()

        # Create the queue
        queue = rabbitpy.Queue(channel, 'example')
        queue.declare()

        # Bind the queue
        queue.bind(exchange, 'test-routing-key')

        # Create and start the transaction
        tx = rabbitpy.Tx(channel)
        tx.select()

        # Create the message
        message = rabbitpy.Message(channel,
                                   'Lorem ipsum dolor sit amet, consectetur '
                                   'adipiscing elit.',
                                   {'content_type': 'text/plain',
                                    'message_type': 'Lorem ipsum'})

        # Publish the message
        message.publish(exchange, 'test-routing-key')

        # Commit the message
        tx.commit()

        print('Message published')

########NEW FILE########
__FILENAME__ = amqp_queue
"""
The rabbitpy.amqp_queue module contains two classes :py:class:`Queue` and
:py:class:`Consumer`. The :py:class:`Queue` class is an object that is used
create and work with queues on a RabbitMQ server.


To consume messages you can iterate over the Queue object itself if the
defaults for the :py:meth:`Queue.__iter__() <Queue.__iter__>` method work
for your needs::

    with conn.channel() as channel:
        for message in rabbitpy.Queue(channel, 'example'):
            print 'Message: %r' % message
            message.ack()

or by the :py:meth:`Queue.consume_messages() <Queue.consume_messages>` method
if you would like to specify `no_ack`, `prefetch_count`, or `priority`::

    with conn.channel() as channel:
        queue = rabbitpy.Queue(channel, 'example')
        for message in queue.consume_messages():
            print 'Message: %r' % message
            message.ack()

"""
import contextlib
import logging
from pamqp import specification

from rabbitpy import base
from rabbitpy import utils

LOGGER = logging.getLogger(__name__)


class Queue(base.AMQPClass):
    """Create and manage RabbitMQ queues.

    :param channel: The channel object to communicate on
    :type channel: :py:class:`rabbitpy.channel.Channel`
    :param str name: The name of the queue
    :param exclusive: Queue can only be used by this channel and will
                      auto-delete once the channel is closed.
    :type exclusive: bool
    :param durable: Indicates if the queue should survive a RabbitMQ is restart
    :type durable: bool
    :param bool auto_delete: Automatically delete when all consumers disconnect
    :param int max_length: Maximum queue length
    :param int message_ttl: Time-to-live of a message in milliseconds
    :param expires: Milliseconds until a queue is removed after becoming idle
    :type expires: int
    :param dead_letter_exchange: Dead letter exchange for rejected messages
    :type dead_letter_exchange: str
    :param dead_letter_routing_key: Routing key for dead lettered messages
    :type dead_letter_routing_key: str
    :param dict arguments: Custom arguments for the queue

    """
    arguments = dict()
    auto_delete = False
    dead_letter_exchange = None
    dead_letter_routing_key = None
    durable = False
    exclusive = False
    expires = None
    max_length = None
    message_ttl = None

    def __init__(self, channel, name='',
                 durable=False, exclusive=False, auto_delete=False,
                 max_length=None, message_ttl=None, expires=None,
                 dead_letter_exchange=None, dead_letter_routing_key=None,
                 arguments=None):
        """Create a new Queue object instance. Only the
        :class:`rabbitpy.Channel` object is required.

        """
        super(Queue, self).__init__(channel, name)

        # Defaults
        self.consumer_tag = 'rabbitpy.%s.%s' % (self.channel.id, id(self))
        self.consuming = False

        # Assign Arguments
        self.durable = durable
        self.exclusive = exclusive
        self.auto_delete = auto_delete
        self.arguments = arguments or {}
        self.max_length = max_length
        self.message_ttl = message_ttl
        self.expires = expires
        self.dead_letter_exchange = dead_letter_exchange
        self.dead_letter_routing_key = dead_letter_routing_key

    def __iter__(self):
        """Quick way to consume messages using defaults of no_ack=False,
        prefetch of 100, and no priority set.

        :yields: rabbitpy.message.Message

        """
        with self.consumer() as consumer:
            for message in consumer.next_message():
                yield message

    def __len__(self):
        """Return the pending number of messages in the queue by doing a
        passive Queue declare.

        :rtype: int

        """
        response = self._rpc(self._declare(True))
        return response.message_count

    def __setattr__(self, name, value):
        """Validate the data types for specific attributes when setting them,
        otherwise fall throw to the parent __setattr__

        :param str name: The attribute to set
        :param mixed value: The value to set
        :raises: ValueError

        """
        if value is not None:

            if (name in ['auto_delete', 'durable', 'exclusive'] and
                    not isinstance(value, bool)):
                raise ValueError('%s must be True or False' % name)

            if (name in ['max_length', 'message_ttl', 'expires'] and
                    not isinstance(value, int)):
                    raise ValueError('%s must be an int' % name)

            if (name in ['dead_letter_exchange', 'dead_letter_routing_key'] and
                    not utils.is_string(value)):
                    raise ValueError('%s must be a str, bytes or unicode' %
                                     name)

            if name == 'arguments' and not isinstance(value, dict):
                raise ValueError('arguments must be a dict')

        # Set the value
        super(Queue, self).__setattr__(name, value)

    def bind(self, source, routing_key=None, arguments=None):
        """Bind the queue to the specified exchange or routing key.

        :type source: str or :py:class:`rabbitpy.exchange.Exchange` exchange
        :param source: The exchange to bind to
        :param str routing_key: The routing key to use
        :param dict arguments: Optional arguments for for RabbitMQ
        :return: bool

        """
        if hasattr(source, 'name'):
            source = source.name
        frame = specification.Queue.Bind(queue=self.name,
                                         exchange=source,
                                         routing_key=routing_key or '',
                                         arguments=arguments)
        response = self._rpc(frame)
        return isinstance(response, specification.Queue.BindOk)

    @contextlib.contextmanager
    def consumer(self, no_ack=False, prefetch=None, priority=None):
        """Consumer message context manager, returns a consumer message
        generator.

        :param bool no_ack: Do not require acknowledgements
        :param int prefetch: Set a prefetch count for the channel
        :param int priority: Consumer priority
        :rtype: :py:class:`Consumer <rabbitpy.queue.Consumer>`

        """
        if prefetch is not None:
            self.channel.prefetch_count(prefetch)
        self.channel._consume(self, no_ack, priority)
        self.consuming = True
        yield Consumer(self)

    def consume_messages(self, no_ack=False, prefetch=None, priority=None):
        """Consume messages from the queue as a generator:

        ```
            for message in queue.consume_messages():
                message.ack()
        ```

        :param bool no_ack: Do not require acknowledgements
        :param int prefetch: Set a prefetch count for the channel
        :param int priority: Consumer priority
        :rtype: :py:class:`Iterator`

        """
        with self.consumer(no_ack, prefetch, priority) as consumer:
            for message in consumer.next_message():
                yield message

    def declare(self, passive=False):
        """Declare the queue on the RabbitMQ channel passed into the
        constructor, returning the current message count for the queue and
        its consumer count as a tuple.

        :param bool passive: Passive declare to retrieve message count and
                             consumer count information
        :return: Message count, Consumer count
        :rtype: tuple(int, int)

        """
        response = self._rpc(self._declare(passive))
        if not self.name:
            self.name = response.queue
        return response.message_count, response.consumer_count

    def delete(self, if_unused=False, if_empty=False):
        """Delete the queue

        :param bool if_unused: Delete only if unused
        :param bool if_empty: Delete only if empty

        """
        self._rpc(specification.Queue.Delete(queue=self.name,
                                             if_unused=if_unused,
                                             if_empty=if_empty))

    def get(self, acknowledge=True):
        """Request a single message from RabbitMQ using the Basic.Get AMQP
        command.

        :param bool acknowledge: Let RabbitMQ know if you will manually
                                 acknowledge or negatively acknowledge the
                                 message after each get.
        :rtype: rabbitpy.message.Message or None

        """
        self._write_frame(specification.Basic.Get(queue=self.name,
                                                  no_ack=not acknowledge))
        return self.channel._get_message()

    def ha_declare(self, nodes=None):
        """Declare a the queue as highly available, passing in a list of nodes
        the queue should live  on. If no nodes are passed, the queue will be
        declared across all nodes in the cluster.

        :param list nodes: A list of nodes to declare. If left empty, queue
                           will be declared on all cluster nodes.
        :return: Message count, Consumer count
        :rtype: tuple(int, int)

        """
        if nodes:
            self.arguments['x-ha-policy'] = 'nodes'
            self.arguments['x-ha-nodes'] = nodes
        else:
            self.arguments['x-ha-policy'] = 'all'
            if 'x-ha-nodes' in self.arguments:
                del self.arguments['x-ha-nodes']
        return self.declare()

    def purge(self):
        """Purge the queue of all of its messages."""
        self._rpc(specification.Queue.Purge())

    def unbind(self, source, routing_key=None):
        """Unbind queue from the specified exchange where it is bound the
        routing key. If routing key is None, use the queue name.

        :type source: str or :py:class:`rabbitpy.exchange.Exchange` exchange
        :param source: The exchange to unbind from
        :param str routing_key: The routing key that binds them

        """
        if hasattr(source, 'name'):
            source = source.name
        routing_key = routing_key or self.name
        self._rpc(specification.Queue.Unbind(queue=self.name, exchange=source,
                                           routing_key=routing_key))

    def _declare(self, passive=False):
        """Return a specification.Queue.Declare class pre-composed for the rpc
        method since this can be called multiple times.

        :param bool passive: Passive declare to retrieve message count and
                             consumer count information
        :rtype: pamqp.specification.Queue.Declare

        """
        arguments = dict(self.arguments)
        if self.expires:
            arguments['x-expires'] = self.expires
        if self.message_ttl:
            arguments['x-message-ttl'] = self.message_ttl
        if self.max_length:
            arguments['x-max-length'] = self.max_length
        if self.dead_letter_exchange:
            arguments['x-dead-letter-exchange'] = self.dead_letter_exchange
        if self.dead_letter_routing_key:
            arguments['x-dead-letter-routing-key'] = \
                self.dead_letter_routing_key

        LOGGER.debug('Declaring Queue %s, durable=%s, passive=%s, '
                     'exclusive=%s, auto_delete=%s, arguments=%r',
                     self.name, self.durable, passive, self.exclusive,
                     self.auto_delete, arguments)

        return specification.Queue.Declare(queue=self.name,
                                           durable=self.durable,
                                           passive=passive,
                                           exclusive=self.exclusive,
                                           auto_delete=self.auto_delete,
                                           arguments=arguments)


class Consumer(object):
    """The Consumer class implements an interator that will retrieve the next
    message from the stack of messages RabbitMQ has delivered until the client
    exists the iterator. It should be used with the
    :py:meth:`Queue.consumer() <rabbitpy.queue.Queue.consumer>` method which
    returns a context manager for consuming.

    """
    def __init__(self, queue):
        self.queue = queue

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Called when exiting the consumer iterator

        """
        self.queue.channel.rpc(self._basic_cancel)
        self.queue.consuming = False

    @property
    def _basic_cancel(self):
        return specification.Basic.Cancel(consumer_tag=self.queue.consumer_tag)

    def next_message(self):
        """Retrieve the nest message from the queue as an iterator, blocking
        until the next message is available.

        :rtype: :py:class:`rabbitpy.message.Message`

        """
        while self.queue.consuming:
            yield self.queue.channel._consume_message()

########NEW FILE########
__FILENAME__ = base
"""
Base classes for various parts of rabbitpy

"""
import logging
try:
    import queue
except ImportError:
    import Queue as queue
import socket
from pamqp import specification

from rabbitpy import exceptions
from rabbitpy import utils

LOGGER = logging.getLogger(__name__)


class AMQPClass(object):
    """Base Class object for wrapping the specification.Frame classes

    """
    def __init__(self, channel, name):
        """Create a new ClassObject.

        :param rabbitpy.Channel channel: The channel to execute commands on
        :param str name: Set the name
        :raises: ValueError

        """
        # Use type so there's not a circular dependency
        if channel.__class__.__name__ != 'Channel':
            raise ValueError('channel must be a valid rabbitpy Channel object')
        if not utils.is_string(name):
            raise ValueError('name must be str, bytes or unicode')

        self.channel = channel
        self.name = name

    def _rpc(self, frame_value):
        """Execute the RPC command for the frame.

        :param pamqp.specification.Frame frame_value: The frame to send
        :rtype: pamqp.specification.Frame or pamqp.message.Message

        """
        LOGGER.debug('Issuing RPC to RabbitMQ: %r', frame_value)
        if self.channel.closed:
            raise exceptions.ChannelClosedException()
        return self.channel.rpc(frame_value)

    def _write_frame(self, frame_value):
        """Write a frame to the channel's connection

        :param pamqp.specification.Frame frame_value: The frame to send

        """
        self.channel._write_frame(frame_value)


class StatefulObject(object):
    """Base object for rabbitpy classes that need to maintain state such as
    connection and channel.

    """
    CLOSED = 0x00
    CLOSING = 0x01
    OPEN = 0x02
    OPENING = 0x03

    STATES = {0x00: 'Closed',
              0x01: 'Closing',
              0x02: 'Open',
              0x03: 'Opening'}

    def __init__(self):
        """Create a new instance of the object defaulting to a closed state."""
        self._state = self.CLOSED

    def _set_state(self, value):
        """Set the state to the specified value, validating it is a supported
        state value.

        :param int value: The new state value
        :raises: ValueError
        """
        if value not in list(self.STATES.keys()):
            raise ValueError('Invalid state value: %r' % value)
        LOGGER.debug('%s setting state to %r',
                     self.__class__.__name__, self.STATES[value])
        self._state = value

    @property
    def closed(self):
        """Returns True if in the CLOSED runtime state

        :rtype: bool

        """
        return self._state == self.CLOSED

    @property
    def closing(self):
        """Returns True if in the CLOSING runtime state

        :rtype: bool

        """
        return self._state == self.CLOSING

    @property
    def open(self):
        """Returns True if in the OPEN runtime state

        :rtype: bool

        """
        return self._state == self.OPEN

    @property
    def opening(self):
        """Returns True if in the OPENING runtime state

        :rtype: bool

        """
        return self._state == self.OPENING

    @property
    def state(self):
        """Return the runtime state value

        :rtype: int

        """
        return self._state

    @property
    def state_description(self):
        """Returns the text based description of the runtime state

        :rtype: str

        """
        return self.STATES[self._state]


class AMQPChannel(StatefulObject):

    CLOSE_REQUEST_FRAME = specification.Channel.Close
    DEFAULT_CLOSE_CODE = 200
    DEFAULT_CLOSE_REASON = 'Normal Shutdown'

    def __init__(self, exception_queue, write_trigger):
        super(AMQPChannel, self).__init__()
        self._channel_id = None
        self._exceptions = exception_queue
        self._state = self.CLOSED
        self._read_queue = None
        self._write_queue = None
        self._write_trigger = write_trigger

    def __int__(self):
        return self._channel_id

    def close(self):
        if self.closed:
            LOGGER.debug('AMQPChannel %i close invoked and already closed',
                         self._channel_id)
            return
        LOGGER.debug('Channel %i close invoked while %s',
                     self._channel_id, self.state_description)
        if not self.closing:
            self._set_state(self.CLOSING)
        frame_value = self._build_close_frame()
        LOGGER.debug('Channel %i Waiting for a valid response for %s',
                     self._channel_id, frame_value.name)
        self.rpc(frame_value)
        self._set_state(self.CLOSED)
        LOGGER.debug('Channel #%i closed', self._channel_id)

    def rpc(self, frame_value):
        """Send a RPC command to the remote server.

        :param pamqp.specification.Frame frame_value: The frame to send
        :rtype: pamqp.specification.Frame or None

        """
        if self.closed:
            raise exceptions.ChannelClosedException()
        self._write_frame(frame_value)
        if frame_value.synchronous:
            return self._wait_on_frame(frame_value.valid_responses)

    def _build_close_frame(self):
        """Return the proper close frame for this object.

        :rtype: pamqp.specification.Channel.Close

        """
        return self.CLOSE_REQUEST_FRAME(self.DEFAULT_CLOSE_CODE,
                                        self.DEFAULT_CLOSE_REASON)

    def _check_for_exceptions(self):
        """Check if there are any queued exceptions to raise, raising it if
        there is.

        """
        if not self._exceptions.empty():
            exception = self._exceptions.get()
            self._exceptions.task_done()
            raise exception

    def _check_for_rpc_request(self, value):
        """Implement in child objects to inspect frames for channel specific
        RPC requests from RabbitMQ.

        """
        pass

    def _force_close(self):
        """Force the channel to mark itself as closed"""
        self._set_state(self.CLOSED)
        LOGGER.debug('Channel #%i closed', self._channel_id)

    def _read_from_queue(self):
        """Check to see if a frame is in the queue and if so, return it

        :rtype: amqp.specification.Frame or None

        """
        self._check_for_exceptions()
        try:
            value = self._read_queue.get(True, 1)
            self._read_queue.task_done()
            return value
        except queue.Empty:
            pass
        return None

    def _trigger_write(self):
        """Notifies the IO loop we need to write a frame by writing a byte
        to a local socket.

        """
        try:
            self._write_trigger.send(b'0')
        except socket.error:
            pass

    def _validate_frame_type(self, frame_value, frame_type):
        """Validate the frame value against the frame type. The frame type can
        be an individual frame type or a list of frame types.

        :param pamqp.specification.Frame frame_value: The frame to check
        :param frame_type: The frame(s) to check against
        :type frame_type: pamqp.specification.Frame or list
        :rtype: bool

        """
        if frame_value is None:
            LOGGER.debug('Frame value is none?')
            return False
        if isinstance(frame_type, str):
            if frame_value.name == frame_type:
                return True
        elif isinstance(frame_type, list):
            for frame_t in frame_type:
                result = self._validate_frame_type(frame_value, frame_t)
                if result:
                    return True
            return False
        elif isinstance(frame_value, specification.Frame):
            return frame_value.name == frame_type.name
        return False

    def _wait_on_frame(self, frame_type=None):
        """Read from the queue, blocking until a result is returned. An
        individual frame type or a list of frame types can be passed in to wait
        for specific frame types. If there is no match on the frame retrieved
        from the queue, put the frame back in the queue and recursively
        call the method.

        :param frame_type: The name or list of names of the frame type(s)
        :type frame_type: str or list or pamqp.specification.Frame
        :rtype: Frame

        """
        if isinstance(frame_type, list) and len(frame_type) == 1:
            frame_type = frame_type[0]
        start_state = self.state
        while not self.closed and start_state == self.state:
            value = self._read_from_queue()
            if value is not None:
                self._check_for_rpc_request(value)
                if frame_type and self._validate_frame_type(value, frame_type):
                    return value
                self._read_queue.put(value)

    def _write_frame(self, frame):
        """Put the frame in the write queue for the IOWriter object to write to
        the socket when it can.

        :param pamqp.specification.Frame frame: The frame to write

        """
        if self.closed:
            return
        self._check_for_exceptions()
        self._write_queue.put((self._channel_id, frame))
        self._trigger_write()

########NEW FILE########
__FILENAME__ = channel
"""


"""
import logging
try:
    import queue
except ImportError:
    import Queue as queue

from pamqp import specification
from pamqp import PYTHON3

from rabbitpy import base
from rabbitpy import exceptions
from rabbitpy import message

LOGGER = logging.getLogger(__name__)


class Channel(base.AMQPChannel):
    """The Channel object is the communications object used by Exchanges,
    Messages, Queues, and Transactions. It is created by invoking the
    :py:meth:`rabbitpy.Connection.channel()
    <rabbitpy.connection.Connection.channel>` method. It can act as a context
    manager, allowing for quick shorthand use:

    .. code:: python

        with connection.channel():
           # Do something

    To create a new channel, invoke
    py:meth:`rabbitpy.connection.Connection.channel`

    """
    DEFAULT_CLOSE_CODE = 200
    DEFAULT_CLOSE_REASON = 'Normal Shutdown'
    REMOTE_CLOSED = 0x04
    STATES = base.AMQPChannel.STATES
    STATES[0x04] = 'Remotely Closed'

    def __init__(self, channel_id, events,
                 exception_queue, read_queue, write_queue,
                 maximum_frame_size, write_trigger):
        """Create a new instance of the Channel class

        :param int channel_id: The channel # to use for this instance
        :param events rabbitpy.Events: Event management object
        :param queue.Queue exception_queue: Exception queue
        :param queue.Queue read_queue: Queue to read pending frames from
        :param queue.Queue write_queue: Queue to write pending AMQP objs to
        :param int maximum_frame_size: The max frame size for msg bodies
        :param socket write_trigger: Write to this socket to break IO waiting

        """
        super(Channel, self).__init__(exception_queue, write_trigger)
        self._channel_id = channel_id
        self._consumers = []
        self._events = events
        self._maximum_frame_size = maximum_frame_size
        self._read_queue = read_queue
        self._write_queue = write_queue
        self._publisher_confirms = False

    def __enter__(self):
        """For use as a context manager, return a handle to this object
        instance.

        :rtype: Channel

        """
        return self

    def __exit__(self, exc_type, exc_val, unused_exc_tb):
        """When leaving the context, examine why the context is leaving, if
        it's  an exception or what.

        """
        if exc_val:
            LOGGER.error('Shutting down channel on unhandled exception: %s',
                         exc_type)
        if self.open:
            self.close()

    def close(self):
        """Close the channel, cancelling any active consumers, purging the read
        queue, while looking to see if a Basic.Nack should be sent, sending it
        if so.

        """
        if self.closed:
            LOGGER.debug('Channel %i close invoked when already closed',
                         self._channel_id)
            return
        self._set_state(self.CLOSING)

        # Empty the queue and nack the max id (and all previous)
        if self._consumers:
            delivery_tag = 0
            discard_counter = 0
            ack_tags = []
            for queue_obj, no_ack in self._consumers:
                self._cancel_consumer(queue_obj)
                if not no_ack:
                    LOGGER.debug('Channel %i will nack messages for %s',
                                 self._channel_id, queue_obj.consumer_tag)
                    ack_tags.append(queue_obj.consumer_tag)

            # If there are any ack tags, get the last msg to nack
            if ack_tags:
                while not self._read_queue.empty():
                    frame_value = self._get_from_read_queue()
                    if not frame_value:
                        break
                    if (frame_value.name == 'Basic.Deliver' and
                            frame_value.consumer_tag in ack_tags):
                        if delivery_tag < frame_value.delivery_tag:
                            delivery_tag = frame_value.delivery_tag
                    discard_counter += 1
                if delivery_tag:
                    self._multi_nack(delivery_tag)

        super(Channel, self).close()

    def _get_from_read_queue(self):
        """Fetch a frame from the read queue and return it, otherwise return
        None

        :rtype: pamqp.specification.Frame

        """
        try:
            frame_value = self._read_queue.get(False)
            self._read_queue.task_done()
        except queue.Empty:
            return None
        return frame_value

    def enable_publisher_confirms(self):
        """Turn on Publisher Confirms. If confirms are turned on, the
        Message.publish command will return a bool indicating if a message has
        been successfully published.

        """
        self.rpc(specification.Confirm.Select())
        self._publisher_confirms = True

    @property
    def id(self):
        """Return the channel id

        :rtype: int

        """
        return self._channel_id

    @property
    def maximum_frame_size(self):
        return self._maximum_frame_size

    def open(self):
        """Open the channel, invoked directly upon creation by the Connection

        """
        self._set_state(self.OPENING)
        self._write_frame(self._build_open_frame())
        self._wait_on_frame(specification.Channel.OpenOk)
        self._set_state(self.OPEN)
        LOGGER.debug('Channel #%i open', self._channel_id)

    def prefetch_count(self, value, all_channels=False):
        """Set a prefetch count for the channel (or all channels on the same
        connection).

        :param int value: The prefetch count to set
        :param bool all_channels: Set the prefetch count on all channels on the
                                  same connection

        """
        self.rpc(specification.Basic.Qos(prefetch_count=value,
                                         global_=all_channels))

    def prefetch_size(self, value, all_channels=False):
        """Set a prefetch size in bytes for the channel (or all channels on the
        same connection).

        :param int value: The prefetch size to set
        :param bool all_channels: Set the prefetch size on all channels on the
                                  same connection

        """
        if value is None:
            return
        self.rpc(specification.Basic.Qos(prefetch_count=value,
                                         global_=all_channels))

    @property
    def publisher_confirms(self):
        """Returns True if publisher confirms are enabled.

        :rtype: bool

        """
        return self._publisher_confirms

    def recover(self, requeue=False):
        """Recover all unacknowledged messages that are associated with this
        channel.

        :param bool requeue: Requeue the message

        """
        self.rpc(specification.Basic.Recover(requeue=requeue))

    @staticmethod
    def _build_open_frame():
        """Build and return a channel open frame

        :rtype: pamqp.specification.Channel.Open

        """
        return specification.Channel.Open()

    def _cancel_consumer(self, obj):
        """Cancel the consuming of a queue.

        :param rabbitpy.amqp_queue.Queue obj: The queue to cancel

        """
        frame_value = specification.Basic.Cancel(consumer_tag=obj.consumer_tag)
        self._write_frame(frame_value)
        if not self.closed:
            self._wait_on_frame(specification.Basic.CancelOk)
            LOGGER.debug('Basic.CancelOk received')

    def _check_for_rpc_request(self, value):

        if isinstance(value, specification.Channel.Close):
            self._on_remote_close(value)
        elif isinstance(value, specification.Basic.Cancel):
            pass

        elif isinstance(value, specification.Basic.Return):
            self._on_basic_return(self._wait_for_content_frames(value))

    def _consume(self, obj, no_ack, priority):
        """Register a Queue object as a consumer, issuing Basic.Consume.

        :param rabbitpy.amqp_queue.Queue obj: The queue to consume
        :param bool no_ack: no_ack mode
        :param int priority: Consumer priority
        :raises: ValueError

        """
        args = dict()
        if priority is not None:
            if not isinstance(priority, int):
                raise ValueError('Consumer priority must be an int')
            args['x-priority'] = priority
        self.rpc(specification.Basic.Consume(queue=obj.name,
                                             consumer_tag=obj.consumer_tag,
                                             no_ack=no_ack,
                                             arguments=args))
        self._consumers.append((obj, no_ack))

    def _consume_message(self):
        """Get a message from the stack, blocking while doing so.

        :rtype: rabbitpy.message.Message

        """
        frame_value = self._wait_on_frame('Basic.Deliver')
        return self._wait_for_content_frames(frame_value)

    def _create_message(self, method_frame, header_frame, body):
        """Create a message instance with the channel it was received on and
        the dictionary of message parts. Will return None if no message can be
        created.

        :param pamqp.specification.Frame method_frame: The method frame value
        :param header_frame: Header frame value
        :type header_frame: pamqp.header.ContentHeader or None
        :param body: The message body
        :type body: str or None
        :rtype: rabbitpy.message.Message or None

        """
        if not method_frame:
            LOGGER.warning('Received empty method_frame, returning None')
            return None
        if not header_frame:
            LOGGER.debug('Malformed header frame: %r', header_frame)
        props = header_frame.properties.to_dict() if header_frame else dict()
        msg = message.Message(self, body, props)
        msg.method = method_frame
        msg.name = method_frame.name
        return msg

    def _get_message(self):
        """Try and get a delivered message from the connection's message stack.

        :rtype: rabbitpy.message.Message or None

        """
        LOGGER.debug('Waiting on GetOk or GetEmpty')
        frame_value = self._wait_on_frame([specification.Basic.GetOk,
                                           specification.Basic.GetEmpty])
        LOGGER.debug('Returned with %r', frame_value)
        if isinstance(frame_value, specification.Basic.GetEmpty):
            return None
        LOGGER.debug('Waiting on content frames for %r', frame_value)
        return self._wait_for_content_frames(frame_value)

    def _multi_nack(self, delivery_tag):
        """Send a multiple negative acknowledgement, re-queueing the items

        :param int delivery_tag: The delivery tag for this channel

        """
        LOGGER.debug('Sending Basic.Nack with requeue')
        self.rpc(specification.Basic.Nack(delivery_tag=delivery_tag,
                                          multiple=True,
                                          requeue=True))

    def _on_basic_return(self, msg):
        """Raise a MessageReturnedException so the publisher can handle
        returned messages.

        :param pmqid.message.message msg: The message to add
        :raises: rabbitpy.exceptions.MessageReturnedException

        """
        # Could happen when closing
        if not msg:
            return
        LOGGER.warning('Basic.Return received on channel %i', self._channel_id)
        message_id = msg.properties.get('message_id', 'Unknown')
        raise exceptions.MessageReturnedException(message_id,
                                                  msg.method.reply_code,
                                                  msg.method.reply_text)

    def _on_remote_close(self, value):
        """Handle RabbitMQ remotely closing the channel

        :param value: The Channel.Close method frame
        :type value: pamqp.specification.Channel.Close

        """
        self._set_state(self.REMOTE_CLOSED)
        if value.reply_code in exceptions.AMQP:
            LOGGER.error('Received remote close (%s): %s',
                         value.reply_code, value.reply_text)
            raise exceptions.AMQP[value.reply_code](value)
        else:
            raise exceptions.RemoteClosedChannelException(self._channel_id,
                                                          value.reply_code,
                                                          value.reply_text)

    def _wait_for_confirmation(self):
        """Used by the Message.publish method when publisher confirmations are
        enabled.

        :rtype: pamqp.frame.Frame

        """
        return self._wait_on_frame(['Basic.Ack', 'Basic.Nack'])

    def _wait_for_content_frames(self, method_frame):
        """Used by both Channel._get_message and Channel._consume_message for
        getting a message parts off the queue and returning the fully
        constructed message.

        :param method_frame: The method frame for the message
        :type method_frame: Basic.Deliver or Basic.Get or Basic.Return
        :rtype: rabbitpy.Message

        """
        if self.closing or self.closed:
            return None
        header_value = self._wait_on_frame('ContentHeader')
        if not header_value:
            return self._create_message(method_frame, None, None)
        body_value = bytes() if PYTHON3 else str()
        while len(body_value) < header_value.body_size:
            body_part = self._wait_on_frame('ContentBody')
            if not body_part:
                break
            body_value += body_part.value
            if len(body_value) == header_value.body_size:
                break
            if self.closing or self.closed:
                return None
        return self._create_message(method_frame, header_value, body_value)

########NEW FILE########
__FILENAME__ = channel0
"""
Channel0 is used for connection level communication between RabbitMQ and the
client on channel 0.

"""
import locale
import logging
try:
    import queue
except ImportError:
    import Queue as queue
import sys

from pamqp import header
from pamqp import heartbeat
from pamqp import specification

from rabbitpy import __version__
from rabbitpy import base
from rabbitpy import events
from rabbitpy import exceptions

LOGGER = logging.getLogger(__name__)


class Channel0(base.AMQPChannel):
    """Channel0 is used to negotiate a connection with RabbitMQ and for
    processing and dispatching events on channel 0 once connected.

    :param dict connection_args: Data required to negotiate the connection

    """
    CHANNEL = 0

    CLOSE_REQUEST_FRAME = specification.Connection.Close
    DEFAULT_LOCALE = 'en-US'

    def __init__(self, connection_args, events_obj, exception_queue,
                 write_queue, write_trigger):
        super(Channel0, self).__init__(exception_queue, write_trigger)
        self._channel_id = 0
        self._args = connection_args
        self._events = events_obj
        self._exceptions = exception_queue
        self._read_queue = queue.Queue()
        self._write_queue = write_queue
        self._write_trigger = write_trigger
        self._maximum_channels = 0
        self._state = self.CLOSED
        self.maximum_frame_size = specification.FRAME_MAX_SIZE
        self.minimum_frame_size = specification.FRAME_MIN_SIZE
        self.properties = None
        self._heartbeat = connection_args.get('heartbeat', 0)

    def close(self):
        self._set_state(self.CLOSING)
        self._write_frame(specification.Connection.Close())

    @property
    def maximum_channels(self):
        return self._maximum_channels

    def on_frame(self, value):
        """Process a RPC frame received from the server

        :param pamqp.message.Message value: The message value

        """
        LOGGER.debug('Received frame: %r', value)
        if value.name == 'Connection.Close':
            LOGGER.warning('RabbitMQ closed the connection (%s): %s',
                           value.reply_code, value.reply_text)
            self._set_state(self.CLOSED)
            self._events.set(events.SOCKET_CLOSE)
            self._events.set(events.CHANNEL0_CLOSED)
            if value.reply_code in exceptions.AMQP:
                err = exceptions.AMQP[value.reply_code](value.reply_text)
            else:
                err = exceptions.RemoteClosedException(value.reply_code,
                                                       value.reply_text)
            self._exceptions.put(err)
            self._trigger_write()
        elif value.name == 'Connection.Blocked':
            LOGGER.warning('RabbitMQ has blocked the connection: %s',
                           value.reason)
            self._events.set(events.CONNECTION_BLOCKED)
        elif value.name == 'Connection.CloseOk':
            self._set_state(self.CLOSED)
            self._events.set(events.CHANNEL0_CLOSED)
        elif value.name == 'Connection.OpenOk':
            self._on_connection_open_ok()
        elif value.name == 'Connection.Start':
            self._on_connection_start(value)
        elif value.name == 'Connection.Tune':
            self._on_connection_tune(value)
            LOGGER.debug('Adding frame to read queue: %r', value)
        elif value.name == 'Connection.Unblocked':
            LOGGER.info('Connection is no longer blocked')
            self._events.clear(events.CONNECTION_BLOCKED)
        elif value.name == 'Heartbeat':
            LOGGER.debug('Received Heartbeat, sending one back')
            self._write_frame(heartbeat.Heartbeat())
            self._trigger_write()
        else:
            LOGGER.warning('Unexpected Channel0 Frame: %r', value)
            raise specification.AMQPUnexpectedFrame(value)

    def start(self):
        self._set_state(self.OPENING)
        self._write_protocol_header()

    def _build_open_frame(self):
        """Build and return the Connection.Open frame.

        :rtype: pamqp.specification.Connection.Open

        """
        return specification.Connection.Open(self._args['virtual_host'])

    def _build_start_ok_frame(self):
        """Build and return the Connection.StartOk frame.

        :rtype: pamqp.specification.Connection.StartOk

        """
        version = sys.version_info
        properties = {'product': 'rabbitpy',
                      'platform': 'Python %s.%s.%s' % (version[0],
                                                       version[1],
                                                       version[2]),
                      'capabilities': {'authentication_failure_close': True,
                                       'basic.nack': True,
                                       'connection.blocked': True,
                                       'consumer_cancel_notify': True,
                                       'publisher_confirms': True},
                      'information': 'See http://rabbitpy.readthedocs.org',
                      'version': __version__}
        return specification.Connection.StartOk(client_properties=properties,
                                                response=self._credentials,
                                                locale=self._get_locale())

    def _build_tune_ok_frame(self):
        """Build and return the Connection.TuneOk frame.

        :rtype: pamqp.specification.Connection.TuneOk

        """
        return specification.Connection.TuneOk(self._maximum_channels,
                                               self.maximum_frame_size,
                                               self._heartbeat)

    def _on_connection_open_ok(self):
        LOGGER.debug('Connection opened')
        self._set_state(self.OPEN)
        self._events.set(events.CHANNEL0_OPENED)

    def _on_connection_start(self, frame_value):
        """Negotiate the Connection.Start process, writing out a
        Connection.StartOk frame when the Connection.Start frame is received.

        :type frame_value: pamqp.specification.Connection.Start
        :raises: rabbitpy.exceptions.ConnectionException

        """
        if not self._validate_connection_start(frame_value):
            LOGGER.error('Could not negotiate a connection, disconnecting')
            raise exceptions.ConnectionResetException()

        self.properties = frame_value.server_properties
        for key in self.properties:
            if key == 'capabilities':
                for capability in self.properties[key]:
                    LOGGER.debug('Server supports %s: %r',
                                 capability, self.properties[key][capability])
            else:
                LOGGER.debug('Server %s: %r', key, self.properties[key])
        self._write_frame(self._build_start_ok_frame())

    def _on_connection_tune(self, frame_value):
        """Negotiate the Connection.Tune frames, waiting for the
        Connection.Tune frame from RabbitMQ and sending the Connection.TuneOk
        frame.

        :param specification.Connection.Tune frame_value: Tune frame

        """
        self._maximum_channels = frame_value.channel_max
        if frame_value.frame_max != self.maximum_frame_size:
            self.maximum_frame_size = frame_value.frame_max
        if frame_value.heartbeat:
            if self._heartbeat is None:
                self._heartbeat = frame_value.heartbeat
            elif self._heartbeat > frame_value.heartbeat:
                self._heartbeat = frame_value.heartbeat
        self._write_frame(self._build_tune_ok_frame())
        self._write_frame(self._build_open_frame())

    @property
    def _credentials(self):
        """Return the marshaled credentials for the AMQP connection.

        :rtype: str

        """
        return '\0%s\0%s' % (self._args['username'], self._args['password'])

    def _get_locale(self):
        """Return the current locale for the python interpreter or the default
        locale.

        :rtype: str

        """
        if not self._args['locale']:
            return locale.getdefaultlocale()[0] or self.DEFAULT_LOCALE
        return self._args['locale']

    @staticmethod
    def _validate_connection_start(frame_value):
        """Validate the received Connection.Start frame

        :param specification.Connection.Start frame_value: Frame to validate
        :rtype: bool

        """
        if (frame_value.version_major,
            frame_value.version_minor) != (specification.VERSION[0],
                                           specification.VERSION[1]):
            LOGGER.warning('AMQP version error (received %i.%i, expected %r)',
                           frame_value.version_major,
                           frame_value.version_minor,
                           specification.VERSION)
            return False
        return True

    def _write_protocol_header(self):
        """Send the protocol header to the connected server."""
        self._write_frame(header.ProtocolHeader())

########NEW FILE########
__FILENAME__ = connection
"""
The Connection class negotiates and manages the connection state.

"""
import logging
try:
    import queue
except ImportError:
    import Queue as queue
import socket
try:
    import ssl
except ImportError:
    ssl = None
import time

from rabbitpy import base
from rabbitpy import io
from rabbitpy import channel
from rabbitpy import channel0
from rabbitpy import events
from rabbitpy import exceptions
from rabbitpy import message
from rabbitpy import utils

LOGGER = logging.getLogger(__name__)

AMQP = 'amqp'
AMQPS = 'amqps'

if ssl:
    SSL_CERT_MAP = {'ignore': ssl.CERT_NONE,
                    'optional': ssl.CERT_OPTIONAL,
                    'required': ssl.CERT_REQUIRED}
    SSL_VERSION_MAP = dict()
    if hasattr(ssl, 'PROTOCOL_SSLv2'):
        SSL_VERSION_MAP['SSLv2'] = ssl.PROTOCOL_SSLv2
    if hasattr(ssl, 'PROTOCOL_SSLv3'):
        SSL_VERSION_MAP['SSLv3'] = ssl.PROTOCOL_SSLv3
    if hasattr(ssl, 'PROTOCOL_SSLv23'):
        SSL_VERSION_MAP['SSLv23'] = ssl.PROTOCOL_SSLv23
    if hasattr(ssl, 'PROTOCOL_TLSv1'):
        SSL_VERSION_MAP['TLSv1'] = ssl.PROTOCOL_TLSv1
else:
    SSL_CERT_MAP, SSL_VERSION_MAP = dict(), dict()


class Connection(base.StatefulObject):
    """The Connection object is responsible for negotiating a connection and
    managing its state. When creating a new instance of the Connection object,
    if no URL is passed in, it uses the default connection parameters of
    localhost port 5672, virtual host / with the guest/guest username/password
    combination. Represented as a AMQP URL the connection information is:

        :code:`amqp://guest:guest@localhost:5672/%2F`

    To use a different connection, pass in a AMQP URL that follows the standard
    format:

        :code:`[scheme]://[username]:[password]@[host]:[port]/[virtual_host]`

    The following example connects to the test virtual host on a RabbitMQ
    server running at 192.168.1.200 port 5672 as the user "www" and the
    password rabbitmq:

        :code:`amqp://admin192.168.1.200:5672/test`

    :param str url: The AMQP connection URL

    """
    CANCEL_METHOD = ['Basic.Cancel']
    DEFAULT_HEARTBEAT_INTERVAL = 3
    DEFAULT_LOCALE = 'en_US'
    DEFAULT_URL = 'amqp://guest:guest@localhost:5672/%2F'
    DEFAULT_VHOST = '%2F'
    GUEST = 'guest'
    PORTS = {'amqp': 5672, 'amqps': 5671, 'api': 15672}

    QUEUE_WAIT = 0.01

    def __init__(self, url=None):
        """Create a new instance of the Connection object"""
        super(Connection, self).__init__()

        # Create a name for the connection
        self._name = '0x%x' % id(self)

        # Extract parts of connection URL for use later
        self._args = self._process_url(url or self.DEFAULT_URL)

        # General events and queues shared across threads
        self._events = events.Events()

        # A queue for the child threads to put exceptions in
        self._exceptions = queue.Queue()

        # One queue for writing frames, regardless of the channel sending them
        self._write_queue = queue.Queue()

        # Attributes for core object threads
        self._channel0 = None
        self._channels = dict()
        self._io = None

        # Used by Message for breaking up body frames
        self._maximum_frame_size = None

        # Connect to RabbitMQ
        self._connect()

    def __enter__(self):
        """For use as a context manager, return a handle to this object
        instance.

        :rtype: Connection

        """
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """When leaving the context, examine why the context is leaving, if
        it's an exception or what.

        """
        if exc_type:
            LOGGER.error('Shutting down connection on unhandled exception: %s',
                         exc_type)
        self._set_state(self.CLOSED)
        self._shutdown_connection(True)

    @property
    def blocked(self):
        """Indicates if the connection is blocked from publishing by RabbitMQ.

        This flag indicates communication from RabbitMQ that the connection is
        blocked using the Connection.Blocked RPC notification from RabbitMQ
        that was added in RabbitMQ 3.2.

        @TODO If RabbitMQ version < 3.2, use the HTTP management API to query
        the value

        :rtype: bool

        """
        return self._events.is_set(events.CONNECTION_BLOCKED)

    def channel(self):
        """Create a new channel"""
        channel_id = self._get_next_channel_id()
        channel_frames = queue.Queue()
        self._channels[channel_id] = channel.Channel(channel_id,
                                                     self._events,
                                                     self._exceptions,
                                                     channel_frames,
                                                     self._write_queue,
                                                     self._maximum_frame_size,
                                                     self._io.write_trigger)
        self._add_channel_to_io(self._channels[channel_id], channel_frames)
        self._channels[channel_id].open()
        return self._channels[channel_id]

    def close(self):
        """Close the connection, including all open channels"""
        if not self.closed:
            self._set_state(self.CLOSING)

            # Shutdown the IO thread and socket
            self._shutdown_connection()

            # Set state and clear out remote name
            self._set_state(self.CLOSED)

    @property
    def server_properties(self):
        """Return the RabbitMQ Server properties from the connection
        negotiation process.

        :rtype: dict

        """
        return self._channel0.properties

    def _add_channel_to_io(self, channel_id, channel_queue):
        """Add a channel and queue to the IO object.

        :param Queue.Queue channel_queue: Channel inbound msg queue
        :param rabbitpy.base.AMQPChannel: The channel to add

        """
        LOGGER.debug('Adding channel %s to io', int(channel_id))
        self._io.add_channel(channel_id, channel_queue)

    @property
    def _api_credentials(self):
        """Return the auth credentials as a tuple

        @rtype: tuple

        """
        return self._args['username'], self._args['password']

    def _close_channels(self):
        """Close all the channels that are currently open."""
        for channel_id in self._channels:
            if (self._channels[channel_id].open and
                    not self._channels[channel_id].closing):
                self._channels[channel_id].close()

    def _connect(self):
        """Connect to the RabbitMQ Server"""
        self._set_state(self.OPENING)

        # Create and start the IO object that reads, writes & dispatches frames
        self._io = self._create_io_thread()
        self._io.daemon = True
        self._io.start()

        # Wait for IO to connect to the socket or raise an exception
        while self.opening and not self._events.is_set(events.SOCKET_OPENED):
            if not self._exceptions.empty():
                exception = self._exceptions.get()
                raise exception
            self._events.wait(events.SOCKET_OPENED)

        # If the socket could not be opened, return instead of waiting
        if self.closed:
            return self.close()

        # Create the Channel0 queue and add it to the IO thread
        self._channel0 = self._create_channel0()
        self._add_channel_to_io(self._channel0, None)
        self._channel0.start()

        # Wait for Channel0 to raise an exception or negotiate the connection
        while not self._channel0.open:
            if not self._exceptions.empty():
                exception = self._exceptions.get()
                self._io.stop()
                raise exception
            time.sleep(0.01)

        # Set the maximum frame size for channel use
        self._maximum_frame_size = self._channel0.maximum_frame_size

    def _create_channel0(self):
        """Each connection should have a distinct channel0

        :rtype: rabbitpy.channel0.Channel0

        """
        return channel0.Channel0(connection_args=self._args,
                                 events_obj=self._events,
                                 exception_queue=self._exceptions,
                                 write_queue=self._write_queue,
                                 write_trigger=self._io.write_trigger)

    def _create_io_thread(self):
        """Create the IO thread and the objects it uses for communication.

        :rtype: rabbitpy.io.IO

        """
        return io.IO(name='%s-io' % self._name,
                     kwargs={'events': self._events,
                             'exceptions': self._exceptions,
                             'connection_args': self._args,
                             'write_queue': self._write_queue})

    def _create_message(self, channel_id, method_frame, header_frame, body):
        """Create a message instance with the channel it was received on and
        the dictionary of message parts.

        :param int channel_id: The channel id the message was sent on
        :param pamqp.specification.Frame method_frame: The method frame value
        :param pamqp.header.ContentHeader header_frame: The header frame value
        :param str body: The message body
        :rtype: rabbitpy.message.Message

        """
        msg = message.Message(self._channels[channel_id],
                              body,
                              header_frame.properties.to_dict())
        msg.method = method_frame
        msg.name = method_frame.name
        return msg

    def _get_next_channel_id(self):
        """Return the next channel id

        :rtype: int

        """
        if not self._channels:
            return 1
        if self._max_channel_id == self._channel0.maximum_channels:
            raise exceptions.TooManyChannelsError
        return self._max_channel_id + 1

    @staticmethod
    def _get_ssl_validation(values):
        """Return the value mapped from the string value in the query string
        for the AMQP URL specifying which level of server certificate
        validation is required, if any.

        :param dict values: The dict of query values from the AMQP URI
        :rtype: int

        """
        validation = values.get('ssl_validation', [None])[0]
        if validation is None:
            return None
        if validation not in SSL_CERT_MAP:
            raise ValueError('Unsupported server cert validation option: %s',
                             validation)
        return SSL_VERSION_MAP[validation]

    @staticmethod
    def _get_ssl_version(values):
        """Return the value mapped from the string value in the query string
        for the AMQP URL for SSL version.

        :param dict values: The dict of query values from the AMQP URI
        :rtype: int

        """
        version = values.get('ssl_version', [None])[0]
        if version is None:
            return None
        if version not in SSL_VERSION_MAP:
            raise ValueError('Unuspported SSL version: %s' % version)
        return SSL_VERSION_MAP[version]

    @property
    def _max_channel_id(self):
        return max(list(self._channels.keys()))

    @staticmethod
    def _normalize_expectations(channel_id, expectations):
        """Turn a class or list of classes into a list of class names.

        :param expectations: List of classes or class name or class obj
        :type expectations: list or str or pamqp.specification.Frame
        :rtype: list

        """
        if isinstance(expectations, list):
            output = list()
            for value in expectations:
                if isinstance(value, str):
                    output.append('%i:%s' % (channel_id, value))
                else:
                    output.append('%i:%s' % (channel_id, value.name))
            return output
        elif utils.is_string(expectations):
            return ['%i:%s' % (channel_id, expectations)]
        return ['%i:%s' % (channel_id, expectations.name)]

    def _process_url(self, url):
        """Parse the AMQP URL passed in and return the configuration
        information in a dictionary of values.

        The URL format is as follows:

            amqp[s]://username:password@host:port/virtual_host[?query string]

        Values in the URL such as the virtual_host should be URL encoded or
        quoted just as a URL would be in a web browser. The default virtual
        host / in RabbitMQ should be passed as %2F.

        Default values:

            - If port is omitted, port 5762 is used for AMQP and port 5671 is
              used for AMQPS
            - If username or password is omitted, the default value is guest
            - If the virtual host is omitted, the default value of %2F is used

        Query string options:

            - heartbeat_interval
            - locale
            - ssl_cacert - Path to CA certificate file
            - ssl_cert - Path to client certificate file
            - ssl_key - Path to client certificate key
            - ssl_validation - Server certificate validation requirements (1)
            - ssl_version - SSL version to use (2)

            (1) Should be one of three values:

               - ignore - Ignore the cert if provided (default)
               - optional - Cert is validated if provided
               - required - Cert is required and validated

            (2) Should be one of four values:

              - SSLv2
              - SSLv3
              - SSLv23
              - TLSv1

        :param str url: The AMQP url passed in
        :rtype: dict
        :raises: ValueError

        """
        parsed = utils.urlparse(url)

        # Ensure the protocol scheme is what is expected
        if parsed.scheme not in list(self.PORTS.keys()):
            raise ValueError('Unsupported protocol: %s' % parsed.scheme)

        # Toggle the SSL flag based upon the URL scheme
        use_ssl = True if parsed.scheme == 'amqps' else False

        # Ensure that SSL is available if SSL is requested
        if use_ssl and not ssl:
            LOGGER.warning('SSL requested but not available, disabling')
            use_ssl = False

        # Use the default ports if one is not specified
        port = parsed.port or (self.PORTS[AMQPS] if parsed.scheme == AMQPS
                               else self.PORTS[AMQP])

        # Set the vhost to be after the base slash if it was specified
        vhost = parsed.path[1:] if parsed.path else self.DEFAULT_VHOST

        # If the path was just the base path, set the vhost to the default
        if not vhost:
            vhost = self.DEFAULT_VHOST

        # Parse the query string
        query_values = utils.parse_qs(parsed.query)

        # Make sure the heartbeat is an int if it is not None
        heartbeat = int(query_values.get('heartbeat_interval', [None])[0] or 0)

        # Return the configuration dictionary to use when connecting
        return {'host': parsed.hostname,
                'port': port,
                'virtual_host': utils.unquote(vhost),
                'username': parsed.username or self.GUEST,
                'password': parsed.password or self.GUEST,
                'heartbeat': heartbeat,
                'locale': query_values.get('locale', [None])[0],
                'ssl': use_ssl,
                'ssl_cacert': query_values.get('ssl_cacert', [None])[0],
                'ssl_cert': query_values.get('ssl_cert', [None])[0],
                'ssl_key': query_values.get('ssl_key', [None])[0],
                'ssl_validation': self._get_ssl_validation(query_values),
                'ssl_version': self._get_ssl_version(query_values)}

    def _shutdown_connection(self, force=False):
        """Tell Channel0 and IO to stop if they are not stopped.

        :param bool force: Force the connection to shutdown without AMQP negotiation

        """
        if not force and not self._io.is_alive():
            self._set_state(self.CLOSED)
            LOGGER.debug('Cant shutdown connection, IO is no longer alive')
            return

        # Close any open channels
        for chan_id in [chan_id for chan_id in self._channels
                        if not self._channels[chan_id].closed]:
            if force:
                self._channels[chan_id]._force_close()
            else:
                self._channels[chan_id].close()

        # If the connection is still established, close it
        if self._channel0.open and not self._events.is_set(events.CHANNEL0_CLOSED):
            self._channel0.close()

            # Loop while Channel 0 closes
            LOGGER.debug('Waiting on channel0 to close')
            while not self._channel0.closed and self._io.is_alive():
                LOGGER.debug('Waiting on channel0 to close')
                time.sleep(0.1)
            LOGGER.debug('channel0 closed')

        # Close the socket
        if (self._events.is_set(events.SOCKET_OPENED) and
                not self._events.is_set(events.SOCKET_CLOSED)):
            LOGGER.debug('Requesting IO socket close')
            self._events.set(events.SOCKET_CLOSE)

            # Break out of select waiting
            self._trigger_write()

            LOGGER.debug('Waiting on socket to close')
            self._events.wait(events.SOCKET_CLOSED, 0.1)
            while self._io.is_alive():
                time.sleep(0.25)

    def _trigger_write(self):
        """Notifies the IO loop we need to write a frame by writing a byte
        to a local socket.

        """
        try:
            self._io.write_trigger.send(b'0')
        except socket.error:
            pass

########NEW FILE########
__FILENAME__ = events
"""
Common rabbitpy events

"""
import logging
import threading

LOGGER = logging.getLogger(__name__)

CHANNEL0_CLOSE = 0x01
CHANNEL0_CLOSED = 0x02
CHANNEL0_OPENED = 0x03
CONNECTION_BLOCKED = 0x04
CONNECTION_EVENT = 0x05
EXCEPTION_RAISED = 0x06
SOCKET_CLOSE = 0x07
SOCKET_CLOSED = 0x08
SOCKET_OPENED = 0x09

DESCRIPTIONS = {0x01: 'Channel 0 Close Requested',
                0x02: 'Channel 0 Closed',
                0x03: 'Channel 0 Opened',
                0x04: 'Connection is blocked',
                0x05: 'Connection Event Occurred',
                0x06: 'Exception Raised',
                0x07: 'Socket Close Requested',
                0x08: 'Socket Closed',
                0x09: 'Socket Connected'}


def description(event_id):
    """Return the text description for an event"""
    return DESCRIPTIONS.get(event_id, event_id)


class Events(object):
    """All events that get triggered in rabbitpy are funneled through this
    object for a common structure and method for raising and checking for them.

    """
    def __init__(self):
        """Create a new instance of Events"""
        self._events = self._create_event_objects()

    def _create_event_objects(self):
        """Events are used like signals across threads for communicating state
        changes, used by the various threaded objects to communicate with each
        other when an action needs to be taken.

        """
        events = dict()
        for event in [CHANNEL0_CLOSE,
                      CHANNEL0_CLOSED,
                      CHANNEL0_OPENED,
                      CONNECTION_BLOCKED,
                      CONNECTION_EVENT,
                      EXCEPTION_RAISED,
                      SOCKET_CLOSE,
                      SOCKET_CLOSED,
                      SOCKET_OPENED]:
            events[event] = threading.Event()
        return events

    def clear(self, event_id):
        """Clear a set event, returning bool indicating success and None for
        an invalid event.

        :param int event_id: The event to set
        :rtype: bool

        """
        if event_id not in self._events:
            LOGGER.debug('Event does not exist: %s', description(event_id))
            return None

        if not self.is_set(event_id):
            LOGGER.debug('Event is not set: %s', description(event_id))
            return False

        self._events[event_id].clear()
        return True

    def is_set(self, event_id):
        """Check if an event is triggered. Returns bool indicating state of the
        event being set. If the event is invalid, a None is returned instead.

        :param int event_id: The event to fire
        :rtype: bool

        """
        if event_id not in self._events:
            LOGGER.debug('Event does not exist: %s', description(event_id))
            return None
        return self._events[event_id].is_set()

    def set(self, event_id):
        """Trigger an event to fire. Returns bool indicating success in firing
        the event. If the event is not valid, return None.

        :param int event_id: The event to fire
        :rtype: bool

        """
        if event_id not in self._events:
            LOGGER.debug('Event does not exist: %s', description(event_id))
            return None

        if self.is_set(event_id):
            LOGGER.debug('Event is already set: %s', description(event_id))
            return False

        self._events[event_id].set()
        return True

    def wait(self, event_id, timeout=1):
        """Wait for an event to be set for up to `timeout` seconds. If
        `timeout` is None, block until the event is set. If the event is
        invalid, None will be returned, otherwise False is used to indicate
        the event is still not set when using a timeout.

        :param int event_id: The event to wait for
        :param float timeout: The number of seconds to wait

        """
        if event_id not in self._events:
            LOGGER.debug('Event does not exist: %s', description(event_id))
            return None
        LOGGER.debug('Waiting for %i seconds on event: %s',
                     timeout, description(event_id))
        return self._events[event_id].wait(timeout)

########NEW FILE########
__FILENAME__ = exceptions
"""
Exceptions that may be raised by rabbitpy during use
----------------------------------------------------

"""

class ActionException(Exception):
    """Raised when an action is taken on a rabbitpy object that is not
    supported due to the state of the object. An example would be trying to
    ack a Message object when the message object was locally created and not
    sent by RabbitMQ via an AMQP Basic.Get or Basic.Consume.

    """
    def __repr__(self):
        return self.args[0]


class ChannelClosedException(Exception):
    """Raised when an action is attempted on a channel that is closed."""
    def __repr__(self):
        return 'Can not perform RPC requests on a closed channel, you must ' \
               'create a new channel'


class ConnectionException(Exception):
    """Raised when rabbitpy can not connect to the specified server and if
    a connection fails and the RabbitMQ version does not support the
    authentication_failure_close feature added in RabbitMQ 3.2.

    """
    def __repr__(self):
        return 'Unable to connect to the remote server %r' % self.args


class ConnectionResetException(Exception):
    """Raised if the socket level connection was reset. This can happen due
    to the loss of network connection or socket timeout.

    """
    def __repr__(self):
        return 'Connection was reset at socket level'


class RemoteClosedChannelException(Exception):
    """Raised if RabbitMQ closes the channel and the reply_code in the
    Channel.Close RPC request does not have a mapped exception in rabbitpy.

    """
    def __repr__(self):
        return 'Channel %i was closed by the remote server (%i): %s' % \
               (self.args[0], self.args[1], self.args[2])


class RemoteClosedException(Exception):
    """Raised if RabbitMQ closes the connection and the reply_code in the
    Connection.Close RPC request does not have a mapped exception in rabbitpy.

    """
    def __repr__(self):
        return 'Connection was closed by the remote server (%i): %s' % \
               (self.args[0], self.args[1])


class MessageReturnedException(Exception):
    """Raised if the RabbitMQ sends a message back to a publisher via
    the Basic.Return RPC call.

    """
    def __repr__(self):
        return 'Message %s was returned by RabbitMQ: (%s) %s' % \
               (self.args[0], self.args[1], self.args[2])


class NoActiveTransactionError(Exception):
    """Raised when a transaction method is issued but the transaction has not
    been initiated.

    """
    def __repr__(self):
        return 'No active transaction for the request, channel closed'


class TooManyChannelsError(Exception):
    """Raised if an application attempts to create a channel, exceeding the
    maximum number of channels (MAXINT or 2,147,483,647) available for a
    single connection. Note that each time a channel object is created, it will
    take a new channel id. If you create and destroy 2,147,483,648 channels,
    this exception will be raised.

    """
    def __repr__(self):
        return 'The maximum amount of negotiated channels has been reached'


class UnexpectedResponseError(Exception):
    """Raised when an RPC call is made to RabbitMQ but the response it sent
    back is not recognized.

    """
    def __repr__(self):
        return 'Received an expected response, expected %s, received %s' % \
               (self.args[0], self.args[1])


# AMQP Exceptions


class AMQPContentTooLarge(Warning):
    """
    The client attempted to transfer content larger than the server could
    accept at the present time. The client may retry at a later time.

    """
    pass


class AMQPNoRoute(Warning):
    """
    Undocumented AMQP Soft Error

    """
    pass


class AMQPNoConsumers(Warning):
    """
    When the exchange cannot deliver to a consumer when the immediate flag is
    set. As a result of pending data on the queue or the absence of any
    consumers of the queue.

    """
    pass


class AMQPAccessRefused(Warning):
    """
    The client attempted to work with a server entity to which it has no access
    due to security settings.

    """
    pass


class AMQPNotFound(Warning):
    """
    The client attempted to work with a server entity that does not exist.

    """
    pass


class AMQPResourceLocked(Warning):
    """
    The client attempted to work with a server entity to which it has no access
    because another client is working with it.

    """
    pass


class AMQPPreconditionFailed(Warning):
    """
    The client requested a method that was not allowed because some
    precondition failed.

    """
    pass


class AMQPConnectionForced(Exception):
    """
    An operator intervened to close the connection for some reason. The client
    may retry at some later date.

    """
    pass


class AMQPInvalidPath(Exception):
    """
    The client tried to work with an unknown virtual host.

    """
    pass


class AMQPFrameError(Exception):
    """
    The sender sent a malformed frame that the recipient could not decode. This
    strongly implies a programming error in the sending peer.

    """
    pass


class AMQPSyntaxError(Exception):
    """
    The sender sent a frame that contained illegal values for one or more
    fields. This strongly implies a programming error in the sending peer.

    """
    pass


class AMQPCommandInvalid(Exception):
    """
    The client sent an invalid sequence of frames, attempting to perform an
    operation that was considered invalid by the server. This usually implies a
    programming error in the client.

    """
    pass


class AMQPChannelError(Exception):
    """
    The client attempted to work with a channel that had not been correctly
    opened. This most likely indicates a fault in the client layer.

    """
    pass


class AMQPUnexpectedFrame(Exception):
    """
    The peer sent a frame that was not expected, usually in the context of a
    content header and body.  This strongly indicates a fault in the peer's
    content processing.

    """
    pass


class AMQPResourceError(Exception):
    """
    The server could not complete the method because it lacked sufficient
    resources. This may be due to the client creating too many of some type of
    entity.

    """
    pass


class AMQPNotAllowed(Exception):
    """
    The client tried to work with some entity in a manner that is prohibited by
    the server, due to security settings or by some other criteria.

    """
    pass

class AMQPNotImplemented(Exception):
    """
    The client tried to use functionality that is not implemented in the
    server.

    """
    pass


class AMQPInternalError(Exception):
    """
    The server could not complete the method because of an internal error. The
    server may require intervention by an operator in order to resume normal
    operations.

    """
    pass


AMQP = {311: AMQPContentTooLarge,
        312: AMQPNoRoute,
        313: AMQPNoConsumers,
        320: AMQPConnectionForced,
        402: AMQPInvalidPath,
        403: AMQPAccessRefused,
        404: AMQPNotFound,
        405: AMQPResourceLocked,
        406: AMQPPreconditionFailed,
        501: AMQPFrameError,
        502: AMQPSyntaxError,
        503: AMQPCommandInvalid,
        504: AMQPChannelError,
        505: AMQPUnexpectedFrame,
        506: AMQPResourceError,
        530: AMQPNotAllowed,
        540: AMQPNotImplemented,
        541: AMQPInternalError}

########NEW FILE########
__FILENAME__ = exchange
"""
The :py:class:`Exchange` class is used to create and manage exchanges in
RabbitMQ and provides four classes as wrappers:

* :py:class:`DirectExchange`
* :py:class:`FanoutExchange`
* :py:class:`HeadersExchange`
* :py:class:`TopicExchange`

"""
import logging
from pamqp import specification

from rabbitpy import base

LOGGER = logging.getLogger(__name__)


class Exchange(base.AMQPClass):
    """Exchange class for interacting with an exchange in RabbitMQ including
    declaration, binding and deletion.

    :param channel: The channel object to communicate on
    :type channel: :py:class:`rabbitpy.channel.Channel`
    :param str name: The name of the exchange
    :param str exchange_type: The exchange type
    :param bool durable: Request a durable exchange
    :param bool auto_delete: Automatically delete when not in use
    :param dict arguments: Optional key/value arguments

    """
    durable = False
    arguments = dict()
    auto_delete = False
    type = 'direct'

    def __init__(self, channel, name, exchange_type='direct',
                 durable=False, auto_delete=False,
                 arguments=None):
        """Create a new instance of the exchange object."""
        super(Exchange, self).__init__(channel, name)
        self.type = exchange_type
        self.durable = durable
        self.auto_delete = auto_delete
        self.arguments = arguments or dict()

    def bind(self, source, routing_key=None):
        """Bind to another exchange with the routing key.

        :param source: The exchange to bind to
        :type source: str or :py:class:`rabbitpy.Exchange`
        :param str routing_key: The routing key to use

        """
        if hasattr(source, 'name'):
            source = source.name
        self._rpc(specification.Exchange.Bind(destination=self.name,
                                              source=source,
                                              routing_key=routing_key))

    def declare(self, passive=False):
        """Declare the exchange with RabbitMQ. If passive is True and the
        command arguments do not match, the channel will be closed.

        :param bool passive: Do not actually create the exchange

        """
        self._rpc(specification.Exchange.Declare(exchange=self.name,
                                                 exchange_type=self.type,
                                                 durable=self.durable,
                                                 passive=passive,
                                                 auto_delete=self.auto_delete,
                                                 arguments=self.arguments))

    def delete(self, if_unused=False):
        """Delete the exchange from RabbitMQ.

        :param bool if_unused: Delete only if unused

        """
        self._rpc(specification.Exchange.Delete(exchange=self.name,
                                                if_unused=if_unused))

    def unbind(self, source, routing_key=None):
        """Unbind the exchange from the source exchange with the
        routing key. If routing key is None, use the queue or exchange name.

        :param source: The exchange to unbind from
        :type source: str or :py:class:`rabbitpy.Exchange`
        :param str routing_key: The routing key that binds them

        """
        if hasattr(source, 'name'):
            source = source.name
        self._rpc(specification.Exchange.Unbind(destination=self.name,
                                              source=source,
                                              routing_key=routing_key))


class DirectExchange(Exchange):
    """The DirectExchange class is used for interacting with direct exchanges
    only.

    :param channel: The channel object to communicate on
    :type channel: :py:class:`rabbitpy.channel.Channel`
    :param str name: The name of the exchange
    :param bool durable: Request a durable exchange
    :param bool auto_delete: Automatically delete when not in use
    :param dict arguments: Optional key/value arguments

    """
    def __init__(self, channel, name, durable=False, auto_delete=False,
                 arguments=None):
        """Create a new instance of the exchange object."""
        super(DirectExchange, self).__init__(channel, name, 'direct', durable,
                                             auto_delete, arguments)


class FanoutExchange(Exchange):
    """The FanoutExchange class is used for interacting with fanout exchanges
    only.

    :param channel: The channel object to communicate on
    :type channel: :py:class:`rabbitpy.channel.Channel`
    :param str name: The name of the exchange
    :param bool durable: Request a durable exchange
    :param bool auto_delete: Automatically delete when not in use
    :param dict arguments: Optional key/value arguments

    """
    def __init__(self, channel, name, durable=False, auto_delete=False,
                 arguments=None):
        """Create a new instance of the exchange object."""
        super(FanoutExchange, self).__init__(channel, name, 'fanout', durable,
                                             auto_delete, arguments)


class HeadersExchange(Exchange):
    """The HeadersExchange class is used for interacting with direct exchanges
    only.

    :param channel: The channel object to communicate on
    :type channel: :py:class:`rabbitpy.channel.Channel`
    :param str name: The name of the exchange
    :param bool durable: Request a durable exchange
    :param bool auto_delete: Automatically delete when not in use
    :param dict arguments: Optional key/value arguments

    """
    def __init__(self, channel, name, durable=False, auto_delete=False,
                 arguments=None):
        """Create a new instance of the exchange object."""
        super(HeadersExchange, self).__init__(channel, name, 'headers',
                                              durable, auto_delete, arguments)


class TopicExchange(Exchange):
    """The TopicExchange class is used for interacting with topic exchanges
    only.

    :param channel: The channel object to communicate on
    :type channel: :py:class:`rabbitpy.channel.Channel`
    :param str name: The name of the exchange
    :param bool durable: Request a durable exchange
    :param bool auto_delete: Automatically delete when not in use
    :param dict arguments: Optional key/value arguments

    """
    def __init__(self, channel, name, durable=False, auto_delete=False,
                 arguments=None):
        """Create a new instance of the exchange object."""
        super(TopicExchange, self).__init__(channel, name, 'topic', durable,
                                            auto_delete, arguments)

########NEW FILE########
__FILENAME__ = io
"""
Core IO for rabbitpy

"""
import errno
import logging
try:
    import queue
except ImportError:
    import Queue as queue
import select
import socket
import ssl
import threading

LOGGER = logging.getLogger(__name__)

from pamqp import frame
from pamqp import exceptions as pamqp_exceptions
from pamqp import specification

from rabbitpy import base
from rabbitpy import events
from rabbitpy import exceptions

MAX_READ = 16
MAX_WRITE = 16
POLL_TIMEOUT = 3600.0


class IOLoop(object):

    NONE = 0
    READ = 0x001
    WRITE = 0x004
    ERROR = 0x008 | 0x010

    def __init__(self, fd, error_callback, read_callback, write_queue,
                 event_obj, write_trigger, exception_stack):
        self._data = threading.local()
        self._data.fd = fd
        self._data.error_callback = error_callback
        self._data.read_callback = read_callback
        self._data.write_queue = write_queue
        self._data.running = False
        self._data.failed_write = None
        self._data.ssl = hasattr(fd, 'read')
        self._data.events = event_obj
        self._data.write_trigger = write_trigger
        self._exceptions = exception_stack

        # Materialized lists for select
        self._data.read_only = [[fd, write_trigger], [], [fd], POLL_TIMEOUT]
        self._data.read_write = [[fd, write_trigger], [fd], [fd], POLL_TIMEOUT]

    def run(self):
        self._data.running = True
        while self._data.running:
            try:
                self._poll()
            except EnvironmentError as exception:
                if (getattr(exception, 'errno', None) == errno.EINTR or
                    (isinstance(getattr(exception, 'args', None), tuple) and
                     len(exception.args) == 2 and
                     exception.args[0] == errno.EINTR)):
                    continue

            if self._data.events.is_set(events.SOCKET_CLOSE):
                LOGGER.debug('Exiting due to closed socket')
                break
        LOGGER.debug('Exiting IOLoop.run')

    def stop(self):
        LOGGER.debug('Stopping IOLoop')
        self._data.running = False
        try:
            self._data.write_trigger.close()
        except socket.error:
            pass

    def _poll(self):
        # Poll select with the materialized lists
        #LOGGER.debug('Polling')
        if not self._data.running:
            LOGGER.debug('Exiting poll')

        if self._data.write_queue.empty() and not self._data.failed_write:
            read, write, err = select.select(*self._data.read_only)
        else:
            read, write, err = select.select(*self._data.read_write)
        if err:
            self._data.running = False
            self._data.error_callback(None)
            return

        # Clear out the trigger socket
        if self._data.write_trigger in read:
            self._data.write_trigger.recv(1024)

        if self._data.fd in read:
            self._read()
        if write:
            self._write()
        #LOGGER.debug('End of poll')

    def _read(self):
        if not self._data.running:
            LOGGER.debug('Skipping read, not running')
            return
        try:
            if self._data.ssl:
                self._data.read_callback(self._data.fd.read(MAX_READ))
            else:
                self._data.read_callback(self._data.fd.recv(MAX_READ))
        except socket.timeout:
            pass
        except socket.error as exception:
            self._data.running = False
            self._data.error_callback(exception)

    def _write(self):
        # If there is data that still needs to be sent, use it instead
        if self._data.failed_write:
            data = self._data.failed_write
            self._data.failed_write = None
            return self._write_frame(data[0], data[1])

        frames = 0
        while frames < MAX_WRITE:
            try:
                data = self._data.write_queue.get(False)
            except queue.Empty:
                break
            self._write_frame(data[0], data[1])
            frames += 1
            if self._data.write_queue.empty():
                break

    def _write_frame(self, channel, value):
        if not self._data.running:
            LOGGER.debug('Skipping write frame, not running')
            return
        frame_data = frame.marshal(value, channel)
        try:
            self._data.fd.sendall(frame_data)
        except socket.timeout:
            self._data.failed_write = channel, value
        except socket.error as exception:
            self._data.running = False
            self._data.error_callback(exception)


class IO(threading.Thread, base.StatefulObject):

    CONNECTION_TIMEOUT = 3
    CONTENT_METHODS = ['Basic.Deliver', 'Basic.GetOk', 'Basic.Return']
    READ_BUFFER_SIZE = specification.FRAME_MAX_SIZE
    SSL_KWARGS = {'keyfile': 'ssl_key',
                  'certfile': 'ssl_cert',
                  'cert_reqs': 'ssl_validation',
                  'ssl_version': 'ssl_version',
                  'cacerts': 'ssl_cacert'}

    def __init__(self, group=None, target=None, name=None, args=(),
                 kwargs=None):
        if kwargs is None:
            kwargs = dict()
        super(IO, self).__init__(group, target, name, args, kwargs)

        self._args = kwargs['connection_args']
        self._events = kwargs['events']
        self._exceptions = kwargs['exceptions']
        self._write_queue = kwargs['write_queue']

        # A socket to trigger write interrupts with
        self._write_listener, self._write_trigger = self._socketpair()

        self._buffer = bytes()
        self._lock = threading.RLock()
        self._channels = dict()
        self._remote_name = None
        self._socket = None
        self._state = None
        self._loop = None

    def add_channel(self, channel, write_queue):
        """Add a channel to the channel queue dict for dispatching frames
        to the channel.

        :param rabbitpy.channel.Channel: The channel to add
        :param Queue.Queue write_queue: Queue for sending frames to the channel

        """
        self._channels[int(channel)] = channel, write_queue

    def run(self):
        """

        """
        self._connect()
        LOGGER.debug('Socket connected')

        # Create the remote name
        local_socket = self._socket.getsockname()
        peer_socket = self._socket.getpeername()
        self._remote_name = '%s:%s -> %s:%s' % (local_socket[0],
                                                local_socket[1],
                                                peer_socket[0],
                                                peer_socket[1])
        self._loop = IOLoop(self._socket, self.on_error, self.on_read,
                            self._write_queue,
                            self._events,
                            self._write_listener,
                            self._exceptions)
        self._loop.run()
        LOGGER.debug('Exiting IO.run')

    def on_error(self, exception):
        """Common functions when a socket error occurs. Make sure to set closed
        and add the exception, and note an exception event.

        :param socket.error exception: The socket error

        """
        LOGGER.error('Socket error: %s', exception, exc_info=True)
        args = [self._args['host'], self._args['port'], exception[1]]
        if self._channels[0][0].open:
            self._exceptions.put(exceptions.ConnectionResetException(*args))
        else:
            self._exceptions.put(exceptions.ConnectionException(*args))
        self._events.set(events.EXCEPTION_RAISED)

    def on_read(self, data):
        # Append the data to the buffer
        self._buffer += data

        while self._buffer:

            # Read and process data
            value = self._read_frame()

            # Break out if a frame could not be decoded
            if self._buffer and value[0] is None:
                break

            #LOGGER.debug('Received (%i) %r', value[0], value[1])

            # If it's channel 0, call the Channel0 directly
            if value[0] == 0:
                self._lock.acquire(True)
                self._channels[0][0].on_frame(value[1])
                self._lock.release()
                continue

            self._add_frame_to_queue(value[0], value[1])

    def stop(self):
        """Stop the IO Layer due to exception or other problem.

        """
        self._close()

    @property
    def write_trigger(self):
        return self._write_trigger

    def _add_frame_to_queue(self, channel_id, frame_value):
        """Add the frame to the stack by creating the key value used in
        expectations and then add it to the list.

        :param int channel_id: The channel id the frame was received on
        :param pamqp.specification.Frame frame_value: The frame to add

        """
        #LOGGER.debug('Adding %s to channel %s', frame_value.name, channel_id)
        self._channels[channel_id][1].put(frame_value)

    def _close(self):
        self._set_state(self.CLOSING)
        if hasattr(self, '_socket') and self._socket:
            self._socket.close()
        self._events.clear(events.SOCKET_OPENED)
        self._events.set(events.SOCKET_CLOSED)
        self._set_state(self.CLOSED)

    def _connect_socket(self, sock, address):
        """Connect the socket to the specified host and port."""
        LOGGER.debug('Connecting to %r', address)
        sock.settimeout(self.CONNECTION_TIMEOUT)
        sock.connect(address)

    def _connect(self):
        """Connect to the RabbitMQ Server

        :raises: ConnectionException

        """
        self._set_state(self.OPENING)
        sock = None
        for (af, socktype, proto,
             canonname, sockaddr) in self._get_addr_info():
            try:
                sock = self._create_socket(af, socktype, proto)
                self._connect_socket(sock, sockaddr)
                break
            except socket.error as error:
                LOGGER.debug('Error connecting to %r: %s', sockaddr, error)
                sock = None
                continue

        if not sock:
            args = [self._args['host'], self._args['port'],
                    'Could not connect']
            self._exceptions.put(exceptions.ConnectionException(*args))
            self._events.set(events.EXCEPTION_RAISED)
            return

        self._socket = sock
        self._socket.settimeout(0)
        self._events.set(events.SOCKET_OPENED)
        self._set_state(self.OPEN)

    def _create_socket(self, af, socktype, proto):
        """Create the new socket, optionally with SSL support.

        :rtype: socket.socket or ssl.SSLSocket

        """
        sock = socket.socket(af, socktype, proto)
        if self._args['ssl']:
            kwargs = {'sock': sock,
                      'server_side': False}
            for argv, key in self.SSL_KWARGS.iteritems():
                if self._args[key]:
                    kwargs[argv] = self._args[key]
            LOGGER.debug('Wrapping socket for SSL: %r', kwargs)
            return ssl.wrap_socket(**kwargs)
        return sock

    def _disconnect_socket(self):
        """Close the existing socket connection"""
        self._socket.close()

    def _get_addr_info(self):
        family = socket.AF_UNSPEC
        if not socket.has_ipv6:
            family = socket.AF_INET
        try:
            res = socket.getaddrinfo(self._args['host'],
                                     self._args['port'],
                                     family,
                                     socket.SOCK_STREAM,
                                     0)
        except socket.error as error:
            LOGGER.error('Could not resolve %s: %s',
                         self._args['host'], error, exc_info=True)
            return []
        return res

    @staticmethod
    def _get_frame_from_str(value):
        """Get the pamqp frame from the string value.

        :param str value: The value to parse for an pamqp frame
        :return (str, int, pamqp.specification.Frame): Remainder of value,
                                                       channel id and
                                                       frame value
        """
        if not value:
            return value, None, None
        try:
            byte_count, channel_id, frame_in = frame.unmarshal(value)
        except pamqp_exceptions.UnmarshalingException:
            return value, None, None
        except specification.AMQPFrameError as error:
            LOGGER.error('Failed to demarshal: %r', error, exc_info=True)
            LOGGER.debug(value)
            return value, None, None
        return value[byte_count:], channel_id, frame_in

    def _notify_of_basic_return(self, channel_id, frame_value):
        """Invoke the on_basic_return code in the specified channel. This will
        block the IO loop unless the exception is caught.

        :param int channel_id: The channel for the basic return
        :param pamqp.specification.Frame frame_value: The Basic.Return frame

        """
        self._channels[channel_id][0].on_basic_return(frame_value)

    def _read_frame(self):
        """Read from the buffer and try and get the demarshaled frame.

        :rtype (int, pamqp.specification.Frame): The channel and frame

        """
        self._buffer, chan_id, value = self._get_frame_from_str(self._buffer)
        return chan_id, value

    def _remote_close_channel(self, channel_id, frame_value):
        """Invoke the on_channel_close code in the specified channel. This will
        block the IO loop unless the exception is caught.

        :param int channel_id: The channel to remote close
        :param pamqp.specification.Frame frame_value: The Channel.Close frame

        """
        self._channels[channel_id][0].on_remote_close(frame_value)

    def _socketpair(self):
        """Return a socket pair regardless of platform.

        :rtype: (socket, socket)

        """
        try:
            server, client = socket.socketpair()
        except AttributeError:
            # Connect in Windows
            LOGGER.debug('Falling back to emulated socketpair behavior')

            # Create the listening server socket & bind it to a random port
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.bind(('127.0.0.1', 0))

            # Get the port for the notifying socket to connect to
            port = s.getsockname()[1]

            # Create the notifying client socket and connect using a timer
            client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            def connect():
                client.connect(('127.0.0.1', port))

            t = threading.Timer(0.01, connect)
            t.start()

            # Have the listening server socket listen and accept the connect
            s.listen(0)
            server, _unused = s.accept()

        # Don't block on either socket
        server.setblocking(0)
        client.setblocking(0)
        return server, client

    def _trigger_write(self):
        """Notifies the IO loop we need to write a frame by writing a byte
        to a local socket.

        """
        try:
            self._write_trigger.send(b'0')
        except socket.error:
            pass

########NEW FILE########
__FILENAME__ = message
"""
The Message class represents a message that is sent or received and contains
methods for publishing the message, or in the case that the message was
delivered by RabbitMQ, acknowledging it, rejecting it or negatively
acknowledging it.

"""
import datetime
import json
import logging
import math
import time
import pprint
import uuid

from pamqp import body
from pamqp import header
from pamqp import PYTHON3
from pamqp import specification

from rabbitpy import base
from rabbitpy import exceptions
from rabbitpy import utils

LOGGER = logging.getLogger(__name__)


class Properties(specification.Basic.Properties):
    """Proxy class for :py:class:`pamqp.specification.Basic.Properties`"""
    pass


class Message(base.AMQPClass):
    """Created by both rabbitpy internally when a message is delivered or
    returned from RabbitMQ and by implementing applications, the Message class
    is used to publish a message to and access and respond to a message from
    RabbitMQ.

    When specifying properties for a message, pass in a dict of key value items
    that match the AMQP Basic.Properties specification with a small caveat.

    Due to an overlap in the AMQP specification and the Python keyword
    :code:`type`, the :code:`type` property is referred to as
    :code:`message_type`.

    The following is a list of the available properties:

    * app_id
    * content_type
    * content_encoding
    * correlation_id
    * delivery_node
    * expiration
    * headers
    * message_id
    * message_type
    * priority
    * reply_to
    * timestamp
    * user_id

    **Automated features**

    When passing in the body value, if it is a dict or list, it will
    automatically be JSON serialized and the content type "application/json"
    will be set on the message properties.

    When publishing a message to RabbitMQ, if the auto_id value is True and no
    message_id value was passed in as a property, a UUID will be generated and
    specified as a property of the message.

    If a timestamp is not specified when passing in properties, the current
    Unix epoch value will be set in the message properties.

    :param channel: The channel object for the message object to act upon
    :type channel: :py:class:`rabbitpy.channel.Channel`
    :param str or dict or list body_value: The message body
    :param dict properties: A dictionary of message properties
    :param bool auto_id: Add a message id if no properties were passed in.

    """
    method = None
    name = 'Message'

    def __init__(self, channel, body_value, properties=None, auto_id=True):
        """Create a new instance of the Message object."""
        super(Message, self).__init__(channel, 'Message')

        if isinstance(body_value, dict) or isinstance(body_value, list):
            body_value = json.dumps(body_value, ensure_ascii=False)
            if properties is None:
                properties = {'content_type': 'application/json'}
            else:
                properties['content_type'] = 'application/json'
        self.body = body_value
        self.properties = properties or self._base_properties
        if auto_id and 'message_id' not in self.properties:
            self._add_auto_message_id()
        if 'timestamp' not in self.properties:
            self._add_timestamp()
        if isinstance(self.properties['timestamp'], time.struct_time):
            self.properties['timestamp'] = self._timestamp_from_struct_time()

    def _add_auto_message_id(self):
        """Set the message_id property to a new UUID."""
        self.properties['message_id'] = str(uuid.uuid4())

    def _add_timestamp(self):
        """Add the timestamp to the properties"""
        self.properties['timestamp'] = datetime.datetime.now()

    def _timestamp_from_struct_time(self):
        """Return a datetime.datetime object from struct_time

        :rtype: datetime.datetime

        """
        return datetime.datetime(*self.properties['timestamp'][:6])

    @property
    def delivery_tag(self):
        """Return the delivery tag for a message that was delivered or gotten
        from RabbitMQ.

        :rtype: int or None

        """
        return self.method.delivery_tag if self.method else None

    @property
    def redelivered(self):
        """Indicates if this message may have been delivered before (but not
        acknowledged)"

        :rtype: bool or None

        """
        return self.method.redelivered if self.method else None

    @property
    def routing_key(self):
        """Return the routing_key for a message that was delivered or gotten
        from RabbitMQ.

        :rtype: int or None

        """
        return self.method.routing_key if self.method else None

    @property
    def _base_properties(self):
        """Return a base set of properties if no properties were passed into
        the constructor.

        :rtype: dict

        """
        return {"message_id": str(uuid.uuid4()),
                "timestamp": datetime.datetime.now()}

    @property
    def _properties(self):
        """Return a new Basic.Properties object representing the message
        properties.

        :rtype: pamqp.specification.Basic.Properties

        """
        invalid_keys = [key for key in self.properties
                        if key not in
                        specification.Basic.Properties.attributes]
        self._prune_invalid_properties(invalid_keys)
        self._coerce_properties()
        return specification.Basic.Properties(**self.properties)

    def _coerce_properties(self):
        """Force properties to be set to the correct data type"""
        for key in self.properties:
            _type = getattr(specification.Basic.Properties, key)
            #LOGGER.debug('Type: %s, %s', _type, type(self.properties[key]))
            if _type == 'shortstr' and \
                    not utils.is_string(self.properties[key]):
                LOGGER.warning('Coercing property %s to bytes', key)
                self.properties[key] = bytes(self.properties[key])
            elif _type == 'octet' and not isinstance(self.properties[key],
                                                     int):
                LOGGER.warning('Coercing property %s to int', key)
                self.properties[key] = int(self.properties[key])
            elif _type == 'table' and not isinstance(self.properties[key],
                                                     dict):
                LOGGER.warning('Resetting invalid value for %s to None', key)
                self.properties[key] = {}
            elif _type == 'timestamp' and isinstance(self.properties[key],
                                                     int):
                LOGGER.warning('Coercing property %s to datetime', key)
                self.properties[key] = \
                    datetime.datetime.fromtimestamp(self.properties[key])

    def _prune_invalid_properties(self, invalid_keys):
        """Remove invalid properties from the message properties.

        :param list invalid_keys: A list of invalid property names to remove

        """
        for key in invalid_keys:
            LOGGER.warning('Removing invalid property "%s"', key)
            del self.properties[key]

    def ack(self, all_previous=False):
        """Acknowledge receipt of the message to RabbitMQ. Will raise an
        ActionException if the message was not received from a broker.

        :raises: ActionException

        """
        if not self.method:
            raise exceptions.ActionException('Can not ack non-received '
                                             'message')
        basic_ack = specification.Basic.Ack(self.method.delivery_tag,
                                            multiple=all_previous)
        self.channel._write_frame(basic_ack)

    def json(self):
        """Deserialize the message body if it is JSON, returning the value.

        :rtype: any

        """
        return json.loads(self.body)

    def nack(self, requeue=False, all_previous=False):
        """Negatively acknowledge receipt of the message to RabbitMQ. Will
        raise an ActionException if the message was not received from a broker.

        :param bool requeue: Requeue the message
        :param bool all_previous: Nack all previous unacked messages up to and
                                  including this one
        :raises: ActionException

        """
        if not self.method:
            raise exceptions.ActionException('Can not nack non-received '
                                             'message')
        basic_nack = specification.Basic.Nack(self.method.delivery_tag,
                                              requeue=requeue,
                                              multiple=all_previous)
        self.channel._write_frame(basic_nack)

    def pprint(self, properties=False):
        """Print a formatted representation of the message.

        :param bool properties: Include properties in the representation

        """
        print('Exchange: %s\n' % self.method.exchange)
        print('Routing Key: %s\n' % self.method.routing_key)
        if properties:
            print('Properties:\n')
            pprint.pprint(self.properties)
            print('\nBody:\n')
        pprint.pprint(self.body)

    def publish(self, exchange, routing_key='', mandatory=False):
        """Publish the message to the exchange with the specified routing
        key.

        :param exchange: The exchange to publish the message to
        :type exchange: str or :class:`rabbitpy.Exchange`
        :param str routing_key: The routing key to use
        :param bool mandatory: Requires the message is published
        :return: bool or None
        :raises: rabbitpy.exceptions.MessageReturnedException

        """
        if isinstance(exchange, base.AMQPClass):
            exchange = exchange.name
        method_frame = specification.Basic.Publish(exchange=exchange,
                                                   routing_key=
                                                   routing_key or '',
                                                   mandatory=mandatory)
        self.channel._write_frame(method_frame)
        header_frame = header.ContentHeader(body_size=len(self.body),
                                            properties=self._properties)
        self.channel._write_frame(header_frame)

        if PYTHON3:
            if isinstance(self.body, str):
                self.body = bytes(self.body.encode('UTF-8'))
        else:
            if isinstance(self.body, unicode):
                self.body = self.body.encode('UTF-8')

        pieces = int(math.ceil(len(self.body) /
                               float(self.channel.maximum_frame_size)))

        # Send the message
        for offset in range(0, pieces):
            start = self.channel.maximum_frame_size * offset
            end = start + self.channel.maximum_frame_size
            if end > len(self.body):
                end = len(self.body)
            self.channel._write_frame(body.ContentBody(self.body[start:end]))

        # If publisher confirmations are enabled, wait for the response
        if self.channel.publisher_confirms:
            response = self.channel._wait_for_confirmation()
            if isinstance(response, specification.Basic.Ack):
                return True
            elif isinstance(response, specification.Basic.Nack):
                return False
            else:
                raise exceptions.UnexpectedResponseError(response)

    def reject(self, requeue=False):
        """Reject receipt of the message to RabbitMQ. Will raise
        an ActionException if the message was not received from a broker.

        :param bool requeue: Requeue the message
        :raises: ActionException

        """
        if not self.method:
            raise exceptions.ActionException('Can not reject non-received '
                                             'message')
        basic_reject = specification.Basic.Reject(self.method.delivery_tag,
                                                  requeue=requeue)
        self.channel._write_frame(basic_reject)

########NEW FILE########
__FILENAME__ = simple
"""
Wrapper methods for easy access to common operations, making them both less
complex and less verbose for one off or simple use cases.

"""
from rabbitpy import connection
from rabbitpy import exchange
from rabbitpy import exceptions
from rabbitpy import amqp_queue
from rabbitpy import message


def consume(uri=None, queue_name=None, no_ack=False, prefetch=100,
            priority=None):
    """Consume messages from the queue as a generator:

    ```
        for message in rabbitpy.consume('amqp://localhost/%2F', 'my_queue'):
            message.ack()
    ```

    :param str uri: AMQP connection URI
    :param str queue_name: The name of the queue to consume from
    :param bool no_ack: Do not require acknowledgements
    :param int prefetch: Set a prefetch count for the channel
    :param int priority: Set the consumer priority
    :rtype: :py:class:`Iterator`
    :raises: py:class:`ValueError`

    """
    if not queue_name:
        raise ValueError('You must specify a queue name to consume from')

    with connection.Connection(uri) as conn:
        with conn.channel() as channel:
            q = amqp_queue.Queue(channel, queue_name)
            for msg in q.consume_messages(no_ack, prefetch, priority):
                yield msg


def get(uri=None, queue_name=None):
    """Get a message from RabbitMQ, auto-acknowledging with RabbitMQ if one
    is returned.

    Invoke directly as rabbitpy.get()


    :param str uri: AMQP URI to connect to
    :param str queue_name: The queue name to get the message from
    :rtype: py:class:`rabbitpy.message.Message` or None
    :raises: py:class:`ValueError`

    """
    if not queue_name:
        raise ValueError('You must specify a queue name to get a message from')

    with connection.Connection(uri) as conn:
        with conn.channel() as channel:
            q = amqp_queue.Queue(channel, queue_name)
            return q.get(False)


def publish(uri=None, exchange=None, routing_key=None,
            body=None, properties=None, confirm=False):
    """Publish a message to RabbitMQ. This should only be used for one-off
    publishing, as you will suffer a performance penalty if you use it
    repeatedly instead creating a connection and channel and publishing on that

    :param str uri: AMQP URI to connect to
    :param str exchange: The exchange to publish to
    :param str routing_key: The routing_key to publish with
    :param str or unicode or bytes or dict or list: The message body
    :param dict properties: Dict representation of Basic.Properties
    :param bool confirm: Confirm this delivery with Publisher Confirms
    :rtype: bool or None
    :raises: :py:class:`ValueError`

    """
    if not exchange:
        raise ValueError('You must specify an exchange to pubish to')

    with connection.Connection(uri) as conn:
        with conn.channel() as channel:
            msg = message.Message(channel, body or '', properties or dict())
            if confirm:
                channel.enable_publisher_confirms()
                return msg.publish(exchange, routing_key or '')
            else:
                msg.publish(exchange, routing_key or '')


def create_queue(uri=None, queue_name='', durable=True, auto_delete=False,
                 max_length=None, message_ttl=None, expires=None,
                 dead_letter_exchange=None, dead_letter_routing_key=None,
                 arguments=None):
    """Create a queue with RabbitMQ. This should only be used for one-off
    operations. If a queue name is omitted, the name will be automatically
    generated by RabbitMQ.

    :param str uri: AMQP URI to connect to
    :param str queue_name: The queue name to create
    :param durable: Indicates if the queue should survive a RabbitMQ is restart
    :type durable: bool
    :param bool auto_delete: Automatically delete when all consumers disconnect
    :param int max_length: Maximum queue length
    :param int message_ttl: Time-to-live of a message in milliseconds
    :param expires: Milliseconds until a queue is removed after becoming idle
    :type expires: int
    :param dead_letter_exchange: Dead letter exchange for rejected messages
    :type dead_letter_exchange: str
    :param dead_letter_routing_key: Routing key for dead lettered messages
    :type dead_letter_routing_key: str
    :param dict arguments: Custom arguments for the queue
    :raises: :py:class:`ValueError`
    :raises: :py:class:`rabbitpy.RemoteClosedException`

    """
    with connection.Connection(uri) as conn:
        with conn.channel() as channel:
            obj = amqp_queue.Queue(channel, queue_name,
                                   durable=durable,
                                   auto_delete=auto_delete,
                                   max_length=max_length,
                                   message_ttl=message_ttl,
                                   expires=expires,
                                   dead_letter_exchange=dead_letter_exchange,
                                   dead_letter_routing_key=
                                   dead_letter_routing_key,
                                   arguments=arguments)
            obj.declare()


def delete_queue(uri=None, queue_name=None):
    """Delete a queue from RabbitMQ. This should only be used for one-off
    operations.

    :param str uri: AMQP URI to connect to
    :param str queue_name: The queue name to delete
    :rtype: bool
    :raises: :py:class:`rabbitpy.exceptions.EmptyQueueNameError`
    :raises: :py:class:`rabbitpy.RemoteClosedException`

    """
    if not queue_name:
        raise exceptions.EmptyQueueNameError()

    with connection.Connection(uri) as conn:
        with conn.channel() as channel:
            queue = amqp_queue.Queue(channel, queue_name)
            queue.delete()


def create_direct_exchange(uri=None, exchange_name=None, durable=True):
    """Create a direct exchange with RabbitMQ. This should only be used for
    one-off operations.

    :param str uri: AMQP URI to connect to
    :param str exchange_name: The exchange name to create
    :param bool durable: Exchange should survive server restarts
    :raises: :py:class:`rabbitpy.exceptions.EmptyExchangeNameError`
    :raises: :py:class:`rabbitpy.RemoteClosedException`

    """
    if not exchange_name:
        raise exceptions.EmptyExchangeNameError()

    with connection.Connection(uri) as conn:
        with conn.channel() as channel:
            obj = exchange.DirectExchange(channel, exchange_name,
                                          durable=durable)
            obj.declare()


def create_fanout_exchange(uri=None, exchange_name=None, durable=True):
    """Create a fanout exchange with RabbitMQ. This should only be used for
    one-off operations.

    :param str uri: AMQP URI to connect to
    :param str exchange_name: The exchange name to create
    :param bool durable: Exchange should survive server restarts
    :raises: :py:class:`rabbitpy.exceptions.EmptyExchangeNameError`
    :raises: :py:class:`rabbitpy.RemoteClosedException`

    """
    if not exchange_name:
        raise exceptions.EmptyExchangeNameError()

    with connection.Connection(uri) as conn:
        with conn.channel() as channel:
            obj = exchange.FanoutExchange(channel, exchange_name,
                                          durable=durable)
            obj.declare()


def create_topic_exchange(uri=None, exchange_name=None, durable=True):
    """Create an exchange from RabbitMQ. This should only be used for one-off
    operations.

    :param str uri: AMQP URI to connect to
    :param str exchange_name: The exchange name to create
    :param bool durable: Exchange should survive server restarts
    :raises: :py:class:`rabbitpy.exceptions.EmptyExchangeNameError`
    :raises: :py:class:`rabbitpy.RemoteClosedException`

    """
    if not exchange_name:
        raise exceptions.EmptyExchangeNameError()

    with connection.Connection(uri) as conn:
        with conn.channel() as channel:
            obj = exchange.TopicExchange(channel, exchange_name,
                                         durable=durable)
            obj.declare()


def delete_exchange(uri=None, exchange_name=None):
    """Delete an exchange from RabbitMQ. This should only be used for one-off
    operations.

    :param str uri: AMQP URI to connect to
    :param str exchange_name: The exchange name to delete
    :raises: :py:class:`rabbitpy.exceptions.EmptyExchangeNameError`
    :raises: :py:class:`rabbitpy.RemoteClosedException`

    """
    if not exchange_name:
        raise exceptions.EmptyExchangeNameError()

    with connection.Connection(uri) as conn:
        with conn.channel() as channel:
            obj = exchange.Exchange(channel, exchange_name)
            obj.delete()

########NEW FILE########
__FILENAME__ = tx
"""
The TX or transaction class implements transactional functionality in RabbitMQ
and allows for any AMQP command to be issued, then committed or rolled back.

"""
import logging
from pamqp import specification as spec

from rabbitpy import base
from rabbitpy import exceptions

LOGGER = logging.getLogger(__name__)


class Tx(base.AMQPClass):
    """Work with transactions

    The Tx class allows publish and ack operations to be batched into atomic
    units of work.  The intention is that all publish and ack requests issued
    within a transaction will complete successfully or none of them will.
    Servers SHOULD implement atomic transactions at least where all publish or
    ack requests affect a single queue.  Transactions that cover multiple
    queues may be non-atomic, given that queues can be created and destroyed
    asynchronously, and such events do not form part of any transaction.
    Further, the behaviour of transactions with respect to the immediate and
    mandatory flags on Basic.Publish methods is not defined.

    :param channel: The channel object to start the transaction on
    :type channel: :py:class:`rabbitpy.channel.Channel`

    """
    def __init__(self, channel):
        super(Tx, self).__init__(channel, 'Tx')
        self._selected = False

    def __enter__(self):
        """For use as a context manager, return a handle to this object
        instance.

        :rtype: Connection

        """
        self.select()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """When leaving the context, examine why the context is leaving, if
        it's an exception or what.

        """
        if exc_type:
            LOGGER.warning('Exiting Transaction on exception: %r', exc_val)
            if self._selected:
                self.rollback()
            raise exc_val
        else:
            LOGGER.debug('Committing transaction on exit of context block')
            if self._selected:
                self.commit()

    def select(self):
        """Select standard transaction mode

        This method sets the channel to use standard transactions. The client
        must use this method at least once on a channel before using the Commit
        or Rollback methods.

        :rtype: bool

        """
        response = self._rpc(spec.Tx.Select())
        result = isinstance(response, spec.Tx.SelectOk)
        self._selected = result
        return result

    def commit(self):
        """Commit the current transaction

        This method commits all message publications and acknowledgments
        performed in the current transaction.  A new transaction starts
        immediately after a commit.

        :raises: rabbitpy.exceptions.NoActiveTransactionError
        :rtype: bool

        """
        try:
            response = self._rpc(spec.Tx.Commit())
        except exceptions.ChannelClosedException as error:
            LOGGER.warning('Error committing transaction: %s', error)
            raise exceptions.NoActiveTransactionError()
        self._selected = False
        return isinstance(response, spec.Tx.CommitOk)

    def rollback(self):
        """Abandon the current transaction

        This method abandons all message publications and acknowledgments
        performed in the current transaction. A new transaction starts
        immediately after a rollback. Note that unacked messages will not be
        automatically redelivered by rollback; if that is required an explicit
        recover call should be issued.

        :raises: rabbitpy.exceptions.NoActiveTransactionError
        :rtype: bool

        """
        try:
            response = self._rpc(spec.Tx.Rollback())
        except exceptions.ChannelClosedException as error:
            LOGGER.warning('Error rolling back transaction: %s', error)
            raise exceptions.NoActiveTransactionError()
        self._selected = False
        return isinstance(response, spec.Tx.RollbackOk)

########NEW FILE########
__FILENAME__ = utils
"""Utilities to make Python 3 support easier, providing wrapper methods which
can call the appropriate method for either Python 2 or Python 3 but creating
a single API point for rabbitpy to use.

"""
import collections
try:
    from urllib import parse as _urlparse
except ImportError:
    import urlparse as _urlparse

from pamqp import PYTHON3

Parsed = collections.namedtuple('Parsed',
                                'scheme,netloc,path,params,query,fragment,'
                                'username,password,hostname,port')


def parse_qs(query_string):
    return _urlparse.parse_qs(query_string)


def urlparse(url):
    value = 'http%s' % url[4:] if url[:4] == 'amqp' else url
    parsed = _urlparse.urlparse(value)
    return Parsed(parsed.scheme.replace('http', 'amqp'), parsed.netloc,
                  parsed.path, parsed.params, parsed.query, parsed.fragment,
                  parsed.username, parsed.password, parsed.hostname,
                  parsed.port)


def unquote(value):
    return _urlparse.unquote(value)


def is_string(value):
    checks = [isinstance(value, bytes), isinstance(value, str)]
    if not PYTHON3:
        checks.append(isinstance(value, unicode))
    return any(checks)

########NEW FILE########
__FILENAME__ = base_tests
"""
Test the rabbitpy.base classes

"""
try:
    import unittest2 as unittest
except ImportError:
    import unittest

from rabbitpy import base
from rabbitpy import channel
from rabbitpy import utils


class AMQPClassTests(unittest.TestCase):

    def setUp(self):
        self.chan = channel.Channel(1, None, None, None, None, 32768, None)

    def test_channel_valid(self):
        obj = base.AMQPClass(self.chan, 'Foo')
        self.assertEqual(obj.channel, self.chan)

    def test_channel_invalid(self):
        self.assertRaises(ValueError, base.AMQPClass, 'Foo', 'Bar')

    def test_name_bytes(self):
        obj = base.AMQPClass(self.chan, b'Foo')
        self.assertIsInstance(obj.name, bytes)

    def test_name_str(self):
        obj = base.AMQPClass(self.chan, 'Foo')
        self.assertIsInstance(obj.name, str)

    @unittest.skipIf(utils.PYTHON3, 'No unicode in Python 3')
    def test_name_unicode(self):
        obj = base.AMQPClass(self.chan, unicode('Foo'))
        self.assertIsInstance(obj.name, unicode)

    def test_name_value(self):
        obj = base.AMQPClass(self.chan, 'Foo')
        self.assertEqual(obj.name, 'Foo')

    def test_name_invalid(self):
        self.assertRaises(ValueError, base.AMQPClass, self.chan, 1)

########NEW FILE########
__FILENAME__ = events_tests
"""
Test the rabbitpy events class

"""
import mock
import threading
try:
    import unittest2 as unittest
except ImportError:
    import unittest

from rabbitpy import events


class BaseEventsTest(unittest.TestCase):

    def setUp(self):
        self._events = events.Events()

    def tearDown(self):
        del self._events


class EventClearTests(BaseEventsTest):

    def test_invalid_event(self):
        self.assertIsNone(self._events.clear(0))

    def test_valid_clear_returns_true(self):
        self._events.set(events.CHANNEL0_OPENED)
        self.assertTrue(self._events.clear(events.CHANNEL0_OPENED))

    def test_unset_event_returns_false(self):
        self.assertFalse(self._events.clear(events.CHANNEL0_OPENED))


class EventInitTests(BaseEventsTest):

    def test_all_events_created(self):
        try:
            cls = threading._Event
        except AttributeError:
            cls = threading.Event
        for event in events.DESCRIPTIONS.keys():
            self.assertIsInstance(self._events._events[event], cls,
                                  type(self._events._events[event]))


class EventIsSetTests(BaseEventsTest):

    def test_invalid_event(self):
        self.assertIsNone(self._events.is_set(0))

    def test_valid_is_set_returns_true(self):
        self._events.set(events.CHANNEL0_CLOSED)
        self.assertTrue(self._events.is_set(events.CHANNEL0_CLOSED))

    def test_unset_event_returns_false(self):
        self.assertFalse(self._events.is_set(events.CHANNEL0_OPENED))


class EventSetTests(BaseEventsTest):

    def test_invalid_event(self):
        self.assertIsNone(self._events.set(0))

    def test_valid_set_returns_true(self):
        self.assertTrue(self._events.set(events.CHANNEL0_CLOSED))

    def test_already_set_event_returns_false(self):
        self._events.set(events.CHANNEL0_OPENED)
        self.assertFalse(self._events.set(events.CHANNEL0_OPENED))


class EventWaitTests(BaseEventsTest):

    def test_invalid_event(self):
        self.assertIsNone(self._events.wait(0))

    def test_blocking_wait_returns_true(self):
        try:
            cls = threading._Event
        except AttributeError:
            cls = threading.Event
        with mock.patch.object(cls, 'wait') as mock_method:
            mock_method.return_value = True
            self.assertTrue(self._events.wait(events.CHANNEL0_CLOSED))

    def test_blocking_wait_returns_false(self):
        try:
            cls = threading._Event
        except AttributeError:
            cls = threading.Event
        with mock.patch.object(cls, 'wait') as mock_method:
            mock_method.return_value = False
            self.assertFalse(self._events.wait(events.CHANNEL0_CLOSED, 1))

########NEW FILE########
__FILENAME__ = queue_tests
"""
Test the rabbitpy.amqp_queue classes

"""
try:
    import unittest2 as unittest
except ImportError:
    import unittest

from rabbitpy import amqp_queue
from rabbitpy import channel
from rabbitpy import utils


class QueueInitializationTests(unittest.TestCase):

    def setUp(self):
        self.chan = channel.Channel(1, None, None, None, None, 32768, None)

    def test_empty_queue_name(self):
        queue = amqp_queue.Queue(self.chan)
        self.assertEqual(queue.name, '')

    def test_invalid_queue_name(self):
        self.assertRaises(ValueError, amqp_queue.Queue, self.chan, None)

    def test_auto_delete_default(self):
        queue = amqp_queue.Queue(self.chan)
        self.assertFalse(queue.auto_delete)

    def test_auto_delete_true(self):
        queue = amqp_queue.Queue(self.chan, auto_delete=True)
        self.assertTrue(queue.auto_delete)

    def test_auto_delete_false(self):
        queue = amqp_queue.Queue(self.chan, auto_delete=False)
        self.assertFalse(queue.auto_delete)

    def test_auto_delete_validation(self):
        self.assertRaises(ValueError, amqp_queue.Queue,
                          self.chan, None, None, None, 10)

    def test_durable_default(self):
        queue = amqp_queue.Queue(self.chan)
        self.assertFalse(queue.durable)

    def test_durable_true(self):
        queue = amqp_queue.Queue(self.chan, durable=True)
        self.assertTrue(queue.durable)

    def test_durable_false(self):
        queue = amqp_queue.Queue(self.chan, durable=False)
        self.assertFalse(queue.durable)

    def test_durable_validation(self):
        self.assertRaises(ValueError, amqp_queue.Queue,
                          self.chan, None, 'Foo')

    def test_exclusive_default(self):
        queue = amqp_queue.Queue(self.chan)
        self.assertFalse(queue.exclusive)

    def test_exclusive_true(self):
        queue = amqp_queue.Queue(self.chan, exclusive=True)
        self.assertTrue(queue.exclusive)

    def test_exclusive_false(self):
        queue = amqp_queue.Queue(self.chan, exclusive=False)
        self.assertFalse(queue.exclusive)

    def test_exclusive_validation(self):
        self.assertRaises(ValueError, amqp_queue.Queue,
                          self.chan, None, None, 'Bar')

    def test_expires_default(self):
        queue = amqp_queue.Queue(self.chan)
        self.assertIsNone(queue.expires)

    def test_expires_named_value(self):
        queue = amqp_queue.Queue(self.chan, expires=10)
        self.assertEqual(queue.expires, 10)
        self.assertIsInstance(queue.expires, int)

    def test_expires_positional_value(self):
        queue = amqp_queue.Queue(self.chan, '', True, False, True,
                                 None, None, 10)
        self.assertEqual(queue.expires, 10)
        self.assertIsInstance(queue.expires, int)

    def test_expires_validation(self):
        self.assertRaises(ValueError, amqp_queue.Queue,
                          self.chan, '', True, False, True, None, None, 'Foo')

    def test_max_length_default(self):
        queue = amqp_queue.Queue(self.chan)
        self.assertIsNone(queue.max_length)

    def test_max_length_named_value(self):
        queue = amqp_queue.Queue(self.chan, max_length=10)
        self.assertEqual(queue.max_length, 10)
        self.assertIsInstance(queue.max_length, int)

    def test_max_length_positional_value(self):
        queue = amqp_queue.Queue(self.chan, '', True, False, True, 10)
        self.assertEqual(queue.max_length, 10)
        self.assertIsInstance(queue.max_length, int)

    def test_max_length_validation(self):
        self.assertRaises(ValueError, amqp_queue.Queue,
                          self.chan, '', True, False, True, 'Foo')

    def test_message_ttl_default(self):
        queue = amqp_queue.Queue(self.chan)
        self.assertIsNone(queue.message_ttl)

    def test_message_ttl_value(self):
        queue = amqp_queue.Queue(self.chan, message_ttl=10)
        self.assertEqual(queue.message_ttl, 10)
        self.assertIsInstance(queue.message_ttl, int)

    def test_message_ttl_positional_value(self):
        queue = amqp_queue.Queue(self.chan, '', True, False, True, None, 10)
        self.assertEqual(queue.message_ttl, 10)
        self.assertIsInstance(queue.message_ttl, int)

    def test_message_ttl_validation(self):
        self.assertRaises(ValueError, amqp_queue.Queue,
                          self.chan, '', True, False, True, None, 'Foo')

    def test_dlx_default(self):
        queue = amqp_queue.Queue(self.chan)
        self.assertIsNone(queue.dead_letter_exchange)

    def test_dlx_value(self):
        queue = amqp_queue.Queue(self.chan, dead_letter_exchange='dlx-name')
        self.assertEqual(queue.dead_letter_exchange, 'dlx-name')

    def test_dlx_bytes(self):
        queue = amqp_queue.Queue(self.chan, dead_letter_exchange=b'dlx-name')
        self.assertIsInstance(queue.dead_letter_exchange, bytes)

    def test_dlx_str(self):
        queue = amqp_queue.Queue(self.chan, dead_letter_exchange='dlx-name')
        self.assertIsInstance(queue.dead_letter_exchange, str)

    @unittest.skipIf(utils.PYTHON3, 'No unicode in Python 3')
    def test_dlx_unicode(self):
        queue = amqp_queue.Queue(self.chan,
                                 dead_letter_exchange=unicode('dlx-name'))
        self.assertIsInstance(queue.dead_letter_exchange, unicode)

    def test_message_dlx_validation(self):
        self.assertRaises(ValueError, amqp_queue.Queue, self.chan, '', True,
                          False, True, None, None, None, True)

    def test_dlr_default(self):
        queue = amqp_queue.Queue(self.chan)
        self.assertIsNone(queue.dead_letter_routing_key)

    def test_dlr_value(self):
        queue = amqp_queue.Queue(self.chan,
                                 dead_letter_routing_key='routing-key')
        self.assertEqual(queue.dead_letter_routing_key, 'routing-key')

    def test_dlr_bytes(self):
        queue = amqp_queue.Queue(self.chan,
                                 dead_letter_routing_key=b'routing-key')
        self.assertIsInstance(queue.dead_letter_routing_key, bytes)

    def test_dlr_str(self):
        queue = amqp_queue.Queue(self.chan,
                                 dead_letter_routing_key='routing-key')
        self.assertIsInstance(queue.dead_letter_routing_key, str)


    @unittest.skipIf(utils.PYTHON3, 'No unicode in Python 3')
    def test_dlr_unicode(self):
        queue = amqp_queue.Queue(self.chan,
                                 dead_letter_routing_key=
                                 unicode('routing-key'))
        self.assertIsInstance(queue.dead_letter_routing_key, unicode)

    def test_dlr_validation(self):
        self.assertRaises(ValueError, amqp_queue.Queue, self.chan, '', True,
                          False, True, None, None, None, None, True)


class QueueDeclareTests(unittest.TestCase):

    def setUp(self):
        self.chan = channel.Channel(1, None, None, None, None, 32768, None)

    def test_default_declare(self):
        obj = amqp_queue.Queue(self.chan)
        expectation = {'arguments': {},
                       'auto_delete': False,
                       'durable': False,
                       'exclusive': False,
                       'nowait': False,
                       'passive': False,
                       'queue': '',
                       'ticket': 0}
        self.assertDictEqual(obj._declare(False).__dict__, expectation)

    def test_default_declare_passive(self):
        obj = amqp_queue.Queue(self.chan)
        expectation = {'arguments': {},
                       'auto_delete': False,
                       'durable': False,
                       'exclusive': False,
                       'nowait': False,
                       'passive': True,
                       'queue': '',
                       'ticket': 0}
        self.assertDictEqual(obj._declare(True).__dict__, expectation)

    def test_queue_name(self):
        obj = amqp_queue.Queue(self.chan, 'my-queue')
        expectation = {'arguments': {},
                       'auto_delete': False,
                       'durable': False,
                       'exclusive': False,
                       'nowait': False,
                       'passive': False,
                       'queue': 'my-queue',
                       'ticket': 0}
        self.assertDictEqual(obj._declare(False).__dict__, expectation)

    def test_non_defaults(self):
        obj = amqp_queue.Queue(self.chan, 'my-queue', False, True, True,
                               100, 30000, 60000, 'dlx-name', 'dlrk')
        expectation = {'arguments': {'x-expires': 60000,
                                     'x-max-length': 100,
                                     'x-message-ttl': 30000,
                                     'x-dead-letter-exchange': 'dlx-name',
                                     'x-dead-letter-routing-key': 'dlrk'},
                       'auto_delete': True,
                       'durable': False,
                       'exclusive': True,
                       'nowait': False,
                       'passive': False,
                       'queue': 'my-queue',
                       'ticket': 0}
        self.assertDictEqual(obj._declare(False).__dict__, expectation)




########NEW FILE########
__FILENAME__ = utils_tests
"""
Test the rabbitpy utils module

"""
try:
    import unittest2 as unittest
except ImportError:
    import unittest
import sys
from rabbitpy import utils

# 3 Unicode Compatibility hack
if sys.version_info[0] == 3:
    unicode = str


class UtilsTestCase(unittest.TestCase):

    AMQP = 'amqp://guest:guest@localhost:5672/%2F?heartbeat_interval=1'
    AMQPS = 'amqps://guest:guest@localhost:5672/%2F?heartbeat_interval=1'

    NETLOC = 'guest:guest@localhost:5672'
    PATH = '/%2F'
    PARAMS = ''
    QUERY = 'heartbeat_interval=1'
    FRAGMENT = ''

    def test_urlparse_amqp_scheme(self):
        self.assertEqual(utils.urlparse(self.AMQP).scheme, 'amqp')

    def test_urlparse_amqps_scheme(self):
        self.assertEqual(utils.urlparse(self.AMQPS).scheme, 'amqps')

    def test_urlparse_netloc(self):
        self.assertEqual(utils.urlparse(self.AMQPS).netloc, self.NETLOC)

    def test_urlparse_url(self):
        self.assertEqual(utils.urlparse(self.AMQPS).path, self.PATH)

    def test_urlparse_params(self):
        self.assertEqual(utils.urlparse(self.AMQPS).params, self.PARAMS)

    def test_urlparse_query(self):
        self.assertEqual(utils.urlparse(self.AMQPS).query, self.QUERY)

    def test_urlparse_fragment(self):
        self.assertEqual(utils.urlparse(self.AMQPS).fragment, self.FRAGMENT)

    def test_parse_qs(self):
        self.assertDictEqual(utils.parse_qs(self.QUERY),
                             {'heartbeat_interval': ['1']})

    def test_is_string_str(self):
        self.assertTrue(utils.is_string('Foo'))

    def test_is_string_bytes(self):
        self.assertTrue(utils.is_string(b'Foo'))

    @unittest.skipIf(sys.version_info[0] == 3, 'No unicode obj in 3')
    def test_is_string_unicode(self):
        self.assertTrue(utils.is_string(unicode('Foo')))

    def test_is_string_false_int(self):
        self.assertFalse(utils.is_string(123))

    def test_unqoute(self):
        self.assertEqual(utils.unquote(self.PATH), '//')

########NEW FILE########
