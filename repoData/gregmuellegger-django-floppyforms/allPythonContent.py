__FILENAME__ = benchmark
"""
Compares the rendering speed between Django forms and django-floppyforms

Usage: DJANGO_SETTINGS_MODULE=benchmark python benchmark.py [--cache]
"""
import sys
import timeit

django = """from django import forms

class DjangoForm(forms.Form):
    text = forms.CharField()
    slug = forms.SlugField()
    some_bool = forms.BooleanField()
    email = forms.EmailField()
    date = forms.DateTimeField()
    file_ = forms.FileField()

rendered = DjangoForm().as_p()"""

flop = """import floppyforms as forms

class FloppyForm(forms.Form):
    text = forms.CharField()
    slug = forms.SlugField()
    some_bool = forms.BooleanField()
    email = forms.EmailField()
    date = forms.DateTimeField()
    file_ = forms.FileField()

rendered = FloppyForm().as_p()"""

def time(stmt):
    t = timeit.Timer(stmt=stmt)
    return t.timeit(number=1000)

if __name__ == '__main__':
    print "Plain Django:", time(django)
    print "django-floppyforms:", time(flop)

INSTALLED_APPS = (
    'floppyforms'
)

if '--cache' in sys.argv:
    TEMPLATE_LOADERS = (
        ('django.template.loaders.cached.Loader', (
            'django.template.loaders.filesystem.Loader',
            'django.template.loaders.app_directories.Loader',
        )),
    )

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-floppyforms documentation build configuration file, created by
# sphinx-quickstart on Fri Nov 26 16:01:17 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import datetime

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-floppyforms'
copyright = u'2010-{0}, Bruno Renié and contributors'.format(
    datetime.datetime.today().year)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
try:
    from floppyforms import __version__
    # The short X.Y version.
    version = '.'.join(__version__.split('.')[:2])
    # The full version, including alpha/beta/rc tags.
    release = __version__
except ImportError:
    version = release = 'dev'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-floppyformsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-floppyforms.tex', u'django-floppyforms Documentation',
   u'Bruno Renié', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-floppyforms', u'django-floppyforms Documentation',
     [u'Bruno Renié'], 1)
]

# gorun
DIRECTORIES = (
    ('', 'make html'),
)

########NEW FILE########
__FILENAME__ = fields
from django import forms

from .widgets import (TextInput, HiddenInput, CheckboxInput, Select,
                      ClearableFileInput, SelectMultiple, DateInput,
                      DateTimeInput, TimeInput, URLInput, NumberInput,
                      EmailInput, NullBooleanSelect, SlugInput, IPAddressInput,
                      SplitDateTimeWidget, SplitHiddenDateTimeWidget)

__all__ = (
    'Field', 'CharField', 'IntegerField', 'DateField', 'TimeField',
    'DateTimeField', 'EmailField', 'FileField', 'ImageField', 'URLField',
    'BooleanField', 'NullBooleanField', 'ChoiceField', 'MultipleChoiceField',
    'FloatField', 'DecimalField', 'SlugField', 'RegexField', 'IPAddressField',
    'GenericIPAddressField', 'TypedChoiceField', 'FilePathField',
    'TypedMultipleChoiceField', 'ComboField', 'MultiValueField',
    'SplitDateTimeField',
)


class Field(forms.Field):
    widget = TextInput
    hidden_widget = HiddenInput


class CharField(Field, forms.CharField):
    widget = TextInput

    def widget_attrs(self, widget):
        attrs = super(CharField, self).widget_attrs(widget)
        if attrs is None:
            attrs = {}
        if self.max_length is not None and isinstance(widget, (TextInput, HiddenInput)):
            # The HTML attribute is maxlength, not max_length.
            attrs.update({'maxlength': str(self.max_length)})
        return attrs


class BooleanField(Field, forms.BooleanField):
    widget = CheckboxInput


class NullBooleanField(Field, forms.NullBooleanField):
    widget = NullBooleanSelect


class ChoiceField(Field, forms.ChoiceField):
    widget = Select


class TypedChoiceField(ChoiceField, forms.TypedChoiceField):
    widget = Select


class FilePathField(ChoiceField, forms.FilePathField):
    widget = Select


class FileField(Field, forms.FileField):
    widget = ClearableFileInput


class ImageField(Field, forms.ImageField):
    widget = ClearableFileInput


class MultipleChoiceField(Field, forms.MultipleChoiceField):
    widget = SelectMultiple


class TypedMultipleChoiceField(MultipleChoiceField,
                               forms.TypedMultipleChoiceField):
    pass


class DateField(Field, forms.DateField):
    widget = DateInput


class DateTimeField(Field, forms.DateTimeField):
    widget = DateTimeInput


class TimeField(Field, forms.TimeField):
    widget = TimeInput


class FloatField(Field, forms.FloatField):
    widget = NumberInput


class IntegerField(Field, forms.IntegerField):
    widget = NumberInput

    def __init__(self, *args, **kwargs):
        kwargs.setdefault('widget', NumberInput if not kwargs.get('localize') else self.widget)
        super(IntegerField, self).__init__(*args, **kwargs)

    def widget_attrs(self, widget):
        attrs = super(IntegerField, self).widget_attrs(widget) or {}
        if self.min_value is not None:
            attrs['min'] = self.min_value
        if self.max_value is not None:
            attrs['max'] = self.max_value
        return attrs


class DecimalField(Field, forms.DecimalField):
    widget = NumberInput

    def __init__(self, *args, **kwargs):
        kwargs.setdefault('widget', NumberInput if not kwargs.get('localize') else self.widget)
        super(DecimalField, self).__init__(*args, **kwargs)


class EmailField(Field, forms.EmailField):
    widget = EmailInput


class URLField(Field, forms.URLField):
    widget = URLInput


class SlugField(Field, forms.SlugField):
    widget = SlugInput


class RegexField(Field, forms.RegexField):
    widget = TextInput

    def __init__(self, regex, js_regex=None, max_length=None, min_length=None,
                 error_message=None, *args, **kwargs):
        self.js_regex = js_regex
        super(RegexField, self).__init__(regex, max_length, min_length,
                                         *args, **kwargs)

    def widget_attrs(self, widget):
        attrs = super(RegexField, self).widget_attrs(widget) or {}
        if self.js_regex is not None:
            attrs['pattern'] = self.js_regex
        return attrs


class IPAddressField(Field, forms.IPAddressField):
    widget = IPAddressInput


class GenericIPAddressField(Field, forms.GenericIPAddressField):
    pass


class ComboField(Field, forms.ComboField):
    pass


class MultiValueField(Field, forms.MultiValueField):
    pass


class SplitDateTimeField(forms.SplitDateTimeField):
    widget = SplitDateTimeWidget
    hidden_widget = SplitHiddenDateTimeWidget

    def __init__(self, *args, **kwargs):
        super(SplitDateTimeField, self).__init__(*args, **kwargs)
        for widget in self.widget.widgets:
            widget.is_required = self.required

########NEW FILE########
__FILENAME__ = forms
from django import forms, template
from django.utils.encoding import python_2_unicode_compatible

from .templatetags.floppyforms import FormNode


__all__ = ('BaseForm', 'Form',)


@python_2_unicode_compatible
class LayoutRenderer(object):
    _template_node = FormNode(
        'form',
        [template.Variable('form')],
        {
            'using': template.Variable('layout'),
            'only': False,
            'with': None,
        })

    def _render_as(self, layout):
        context = template.Context({
            'form': self,
            'layout': layout,
        })
        return self._template_node.render(context)

    def __str__(self):
        return self._render_as('floppyforms/layouts/default.html')

    def as_p(self):
        return self._render_as('floppyforms/layouts/p.html')

    def as_ul(self):
        return self._render_as('floppyforms/layouts/ul.html')

    def as_table(self):
        return self._render_as('floppyforms/layouts/table.html')


class BaseForm(LayoutRenderer, forms.BaseForm):
    pass


class Form(LayoutRenderer, forms.Form):
    pass

########NEW FILE########
__FILENAME__ = fields
try:
    from django.contrib.gis.forms import GeometryField as BaseGeometryField
except ImportError:
    from floppyforms.fields import CharField as BaseGeometryField  # noqa

from . import widgets

__all__ = ('GeometryField', 'GeometryCollectionField',
           'PointField', 'MultiPointField',
           'LineStringField', 'MultiLineStringField',
           'PolygonField', 'MultiPolygonField')


class GeometryWidget(widgets.BaseMetacartaWidget, widgets.GeometryWidget):
    pass


class GeometryField(BaseGeometryField):
    widget = GeometryWidget

    def __init__(self, *args, **kwargs):
        super(GeometryField, self).__init__(*args, **kwargs)
        self.widget.is_required = self.required  # Django < 1.3 support


class GeometryCollectionWidget(widgets.BaseMetacartaWidget,
                               widgets.GeometryCollectionWidget):
    pass


class GeometryCollectionField(GeometryField):
    widget = GeometryCollectionWidget

    def __init__(self, *args, **kwargs):
        kwargs['geom_type'] = 'GEOMETRYCOLLECTION'
        super(GeometryCollectionField, self).__init__(*args, **kwargs)


class PointWidget(widgets.BaseMetacartaWidget, widgets.PointWidget):
    pass


class PointField(GeometryField):
    widget = PointWidget

    def __init__(self, *args, **kwargs):
        kwargs['geom_type'] = 'POINT'
        super(PointField, self).__init__(*args, **kwargs)


class MultiPointWidget(widgets.BaseMetacartaWidget, widgets.MultiPointWidget):
    pass


class MultiPointField(GeometryField):
    widget = MultiPointWidget

    def __init__(self, *args, **kwargs):
        kwargs['geom_type'] = 'MULTIPOINT'
        super(MultiPointField, self).__init__(*args, **kwargs)


class LineStringWidget(widgets.BaseMetacartaWidget, widgets.LineStringWidget):
    pass


class LineStringField(GeometryField):
    widget = LineStringWidget

    def __init__(self, *args, **kwargs):
        kwargs['geom_type'] = 'LINESTRING'
        super(LineStringField, self).__init__(*args, **kwargs)


class MultiLineStringWidget(widgets.BaseMetacartaWidget,
                            widgets.MultiLineStringWidget):
    pass


class MultiLineStringField(GeometryField):
    widget = MultiLineStringWidget

    def __init__(self, *args, **kwargs):
        kwargs['geom_type'] = 'MULTILINESTRING'
        super(MultiLineStringField, self).__init__(*args, **kwargs)


class PolygonWidget(widgets.BaseMetacartaWidget, widgets.PolygonWidget):
    pass


class PolygonField(GeometryField):
    widget = PolygonWidget

    def __init__(self, *args, **kwargs):
        kwargs['geom_type'] = 'POLYGON'
        super(PolygonField, self).__init__(*args, **kwargs)


class MultiPolygonWidget(widgets.BaseMetacartaWidget,
                         widgets.MultiPolygonWidget):
    pass


class MultiPolygonField(GeometryField):
    widget = MultiPolygonWidget

    def __init__(self, *args, **kwargs):
        kwargs['geom_type'] = 'MULTIPOLYGON'
        super(MultiPolygonField, self).__init__(*args, **kwargs)

########NEW FILE########
__FILENAME__ = widgets
from django.conf import settings
from django.utils import translation, six

try:
    from django.contrib.gis import gdal, geos
except ImportError:
    """GDAL / GEOS not installed"""

import floppyforms as forms

__all__ = ('GeometryWidget', 'GeometryCollectionWidget',
           'PointWidget', 'MultiPointWidget',
           'LineStringWidget', 'MultiLineStringWidget',
           'PolygonWidget', 'MultiPolygonWidget',
           'BaseGeometryWidget', 'BaseMetacartaWidget',
           'BaseOsmWidget', 'BaseGMapWidget')


class BaseGeometryWidget(forms.Textarea):
    """
    The base class for rich geometry widgets. Custom widgets may be
    obtained by subclassing this base widget.
    """
    display_wkt = False
    map_width = 600
    map_height = 400
    map_srid = 4326
    template_name = 'floppyforms/gis/openlayers.html'

    # Internal API #
    is_point = False
    is_linestring = False
    is_polygon = False
    is_collection = False
    geom_type = 'GEOMETRY'

    map_attrs = ('map_width', 'map_height', 'map_srid', 'display_wkt')

    def __init__(self, *args, **kwargs):
        super(BaseGeometryWidget, self).__init__(*args, **kwargs)
        attrs = kwargs.pop('attrs', {})
        for key in self.map_attrs:
            setattr(self, key, attrs.pop(key, getattr(self, key)))

    def get_context_data(self):
        ctx = super(BaseGeometryWidget, self).get_context_data()
        for key in ('is_polygon', 'is_linestring',
                    'is_point', 'is_collection'):
            ctx[key] = getattr(self, key)
        ctx['geom_type'] = gdal.OGRGeomType(self.geom_type)

        for key in self.map_attrs:
            ctx[key] = getattr(self, key)

        if self.geom_type == 'GEOMETRYCOLLECTION':
            ctx['geom_type'] = 'Collection'
        return ctx

    def get_context(self, name, value, attrs=None, extra_context={}):
        # If a string reaches here (via a validation error on another
        # field) then just reconstruct the Geometry.
        if isinstance(value, six.text_type):
            try:
                value = geos.GEOSGeometry(value)
            except (geos.GEOSException, ValueError):
                value = None

        if (
            value and value.geom_type.upper() != self.geom_type and
            self.geom_type != 'GEOMETRY'
        ):
            value = None

        # Defaulting the WKT value to a blank string
        wkt = ''
        if value:
            srid = self.map_srid
            if value.srid != srid:
                try:
                    ogr = value.ogr
                    ogr.transform(srid)
                    wkt = ogr.wkt
                except gdal.OGRException:
                    pass  # wkt left as an empty string
            else:
                wkt = value.wkt
        context = super(BaseGeometryWidget, self).get_context(name, wkt, attrs)
        context['module'] = 'map_%s' % name.replace('-', '_')
        context['name'] = name
        # Django >= 1.4 doesn't have ADMIN_MEDIA_PREFIX anymore, we must
        # rely on contrib.staticfiles.
        if hasattr(settings, 'ADMIN_MEDIA_PREFIX'):
            context['ADMIN_MEDIA_PREFIX'] = settings.ADMIN_MEDIA_PREFIX
        else:
            context['ADMIN_MEDIA_PREFIX'] = settings.STATIC_URL + 'admin/'
        context['LANGUAGE_BIDI'] = translation.get_language_bidi()
        return context


class GeometryWidget(BaseGeometryWidget):
    pass


class GeometryCollectionWidget(GeometryWidget):
    is_collection = True
    geom_type = 'GEOMETRYCOLLECTION'


class PointWidget(BaseGeometryWidget):
    is_point = True
    geom_type = 'POINT'


class MultiPointWidget(PointWidget):
    is_collection = True
    geom_type = 'MULTIPOINT'


class LineStringWidget(BaseGeometryWidget):
    is_linestring = True
    geom_type = 'LINESTRING'


class MultiLineStringWidget(LineStringWidget):
    is_collection = True
    geom_type = 'MULTILINESTRING'


class PolygonWidget(BaseGeometryWidget):
    is_polygon = True
    geom_type = 'POLYGON'


class MultiPolygonWidget(PolygonWidget):
    is_collection = True
    geom_type = 'MULTIPOLYGON'


class BaseMetacartaWidget(BaseGeometryWidget):

    class Media:
        js = (
            'http://openlayers.org/api/OpenLayers.js',
            'floppyforms/js/MapWidget.js',
        )


class BaseOsmWidget(BaseGeometryWidget):
    """An OpenStreetMap base widget"""
    map_srid = 900913
    template_name = 'floppyforms/gis/osm.html'

    class Media:
        js = (
            'http://openlayers.org/api/OpenLayers.js',
            'http://www.openstreetmap.org/openlayers/OpenStreetMap.js',
            'floppyforms/js/MapWidget.js',
        )


class BaseGMapWidget(BaseGeometryWidget):
    """A Google Maps base widget"""
    map_srid = 900913
    template_name = 'floppyforms/gis/google.html'

    class Media:
        js = (
            'http://openlayers.org/api/OpenLayers.js',
            'floppyforms/js/MapWidget.js',
            'http://maps.google.com/maps/api/js?sensor=false',
        )

########NEW FILE########
__FILENAME__ = models
import warnings

from django.forms import models

from .fields import Field
from .forms import LayoutRenderer
from .widgets import Select, SelectMultiple

__all__ = ('ModelForm', 'ModelChoiceField', 'ModelMultipleChoiceField')


class ModelForm(LayoutRenderer, models.ModelForm):
    def __new__(cls, *args, **kwargs):
        url = '<TODO>'
        warnings.warn(
            'The behaviour of subclasses of floppyforms.models.ModelForm will '
            'change with django-floppyforms 1.3. '
            'Use `import floppyforms.__future__ as forms` instead of '
            '`import floppyforms as forms` to use the new behaviour now. '
            'See announcement here: %s' % url,
            FutureWarning)
        return super(ModelForm, cls).__new__(cls, *args, **kwargs)


class ModelChoiceField(Field, models.ModelChoiceField):
    widget = Select


class ModelMultipleChoiceField(Field, models.ModelMultipleChoiceField):
    widget = SelectMultiple

########NEW FILE########
__FILENAME__ = floppyforms
from collections import defaultdict
from contextlib import contextmanager

from django.conf import settings
from django.forms.forms import BoundField
from django.forms.util import ErrorList
from django.template import (Library, Node, Variable,
                             TemplateSyntaxError, VariableDoesNotExist)
from django.template.base import token_kwargs
from django.template.loader import get_template
from django.utils.functional import empty

register = Library()


class ConfigFilter(object):
    """
    Can be used as ``filter`` argument to ``FormConfig.configure()``. This
    filter matches to a bound field based on three criterias:

    It will return ``True`` if:

    * the bound field passed into the constructor equals the filtered field.
    * the string passed into the constructor equals the fields name.
    * the string passed into the constructor equals the field's class name.
    * the string passed into the constructor equals the field's widget class name.
    """
    def __init__(self, var):
        self.var = var

    def __call__(self, bound_field):
        # when var is a bound_field ...
        # bound fields cannot be compared directly since form['field'] returns
        # a new instance every time it's called
        if hasattr(self.var, 'form') and hasattr(self.var, 'name'):
            if self.var.form is bound_field.form:
                if self.var.name == bound_field.name:
                    return True
        if self.var == bound_field.name:
            return True
        # ignore 'object' in the mro, because it would be a match-all filter
        # anyway. And 'object' could clash with a field that is named the
        # same.
        for class_ in bound_field.field.__class__.__mro__:
            if class_.__name__ == 'object':
                continue
            if self.var == class_.__name__:
                return True
        for class_ in bound_field.field.widget.__class__.__mro__:
            if class_.__name__ == 'object':
                continue
            if self.var == class_.__name__:
                return True

    def __repr__(self):
        return "<%s: %r>" % (self.__class__.__name__, self.var)


def default_label(bound_field, **kwargs):
    if bound_field:
        return bound_field.label


def default_help_text(bound_field, **kwargs):
    if bound_field:
        return bound_field.field.help_text


def default_widget(bound_field, **kwargs):
    if bound_field:
        return bound_field.field.widget


def default_widget_template(bound_field, **kwargs):
    if bound_field:
        if hasattr(bound_field.field.widget, 'template_name'):
            return bound_field.field.widget.template_name
        return None


class ConfigPopException(Exception):
    "pop() has been called more times than push()"
    pass


class FormConfig(object):
    """
    A stack of form-configuration dictionaries, where each configured value can
    be associated with a filter function that determines whether that value
    applies in specific situations.

    """
    defaults = {
        'layout': lambda **kwargs: 'floppyforms/layouts/default.html',
        'row_template': lambda **kwargs: 'floppyforms/rows/default.html',
        'label': default_label,
        'help_text': default_help_text,
        'widget': default_widget,
        'widget_template': default_widget_template,
    }

    def __init__(self):
        self.dicts = [self._dict()]

    def _dict(self):
        return defaultdict(lambda: [])

    def push(self):
        d = self._dict()
        self.dicts.append(d)
        return d

    def pop(self):
        if len(self.dicts) == 1:
            raise ConfigPopException
        return self.dicts.pop()

    def configure(self, key, value, filter=None):
        """
        Stores ``value`` under ``key``, optionally protected by given
        ``filter``.

        """
        if filter is None:
            filter = lambda **kwargs: True
        self.dicts[-1][key].append((value, filter))

    def retrieve(self, key, **kwargs):
        """
        Return most-recently-set value for ``key`` whose ``filter`` returns
        ``True`` when passed the given ``kwargs``.

        If no value is found and ``key`` has a default value: return
        ``self.defaults[key](**kwargs)``

        """
        for d in reversed(self.dicts):
            for value, filter in reversed(d[key]):
                if filter(**kwargs):
                    return value

        if key not in self.defaults:
            return None
        return self.defaults[key](**kwargs)

    def retrieve_all(self, key, **kwargs):
        """
        Returns a list of all applicable values for ``key``, ordered by
        most-recently-configured.

        """
        values = []
        for d in self.dicts:
            for value, filter in d[key]:
                if filter(**kwargs):
                    values.insert(0, value)
        return values


class BaseFormNode(Node):
    """
    Base class for the form rendering tags. Holds methods to parse common
    arguments like "using <template>" and "with <context>" in a standard way.
    """
    CONFIG_CONTEXT_ATTR = '_form_config'
    IN_FORM_CONTEXT_VAR = '_form_render'

    optional_using_parameter = False
    optional_with_parameter = False
    accept_only_parameter = True
    accept_for_parameter = False
    optional_for_parameter = False

    form_config = FormConfig
    single_template_var = None
    list_template_var = None

    def __init__(self, tagname, variables, options):
        self.tagname = tagname
        self.variables = variables
        self.options = options

    def get_config(self, context):
        try:
            return getattr(context, self.CONFIG_CONTEXT_ATTR)
        except AttributeError:
            config = self.form_config()
            setattr(context, self.CONFIG_CONTEXT_ATTR, config)
            return config

    @classmethod
    def parse_variables(cls, tagname, parser, bits, options):
        variables = []
        while bits and bits[0] not in ('using', 'with', 'only'):
            variables.append(Variable(bits.pop(0)))
        if not variables:
            raise TemplateSyntaxError(u'%s tag expectes at least one '
                                      'template variable as argument.' %
                                      tagname)
        return variables

    @classmethod
    def parse_using(cls, tagname, parser, bits, options):
        if bits:
            if bits[0] == 'using':
                bits.pop(0)
                if len(bits):
                    if bits[0] in ('with', 'only'):
                        raise TemplateSyntaxError(
                            '%s: you must provide one template after '
                            '"using" and before "with" or "only".' %
                            tagname)
                    options['using'] = Variable(bits.pop(0))
                else:
                    raise TemplateSyntaxError('%s: expected a template name '
                                              'after "using".' % tagname)
            elif not cls.optional_using_parameter:
                raise TemplateSyntaxError('Unknown argument for %s tag: %r.' %
                                          (tagname, bits[0]))

    @classmethod
    def parse_with(cls, tagname, parser, bits, options):
        if bits:
            if bits[0] == 'with':
                bits.pop(0)
                arguments = token_kwargs(bits, parser, support_legacy=False)
                if not arguments:
                    raise TemplateSyntaxError('"with" in %s tag needs at '
                                              'least one keyword argument.' %
                                              tagname)
                options['with'] = arguments
            elif bits[0] not in ('only',) and not cls.optional_with_parameter:
                raise TemplateSyntaxError('Unknown argument for %s tag: %r.' %
                                          (tagname, bits[0]))

        if bits:
            if cls.accept_only_parameter and bits[0] == 'only':
                bits.pop(0)
                options['only'] = True

    @classmethod
    def parse_for(cls, tagname, parser, bits, options):
        if bits:
            if bits[0] == 'for':
                bits.pop(0)
                if len(bits):
                    options['for'] = Variable(bits.pop(0))
                else:
                    raise TemplateSyntaxError('%s: expected an argument '
                                              'after "for".' % tagname)
            elif not cls.optional_for_parameter:
                raise TemplateSyntaxError('Unknown argument for %s tag: %r.' %
                                          (tagname, bits[0]))

    @classmethod
    def parse(cls, parser, tokens):
        bits = tokens.split_contents()
        tagname = bits.pop(0)
        options = {
            'only': False,
            'with': None,
        }

        variables = cls.parse_variables(tagname, parser, bits, options)
        cls.parse_using(tagname, parser, bits, options)
        cls.parse_with(tagname, parser, bits, options)

        if bits:
            raise TemplateSyntaxError('Unknown argument for %s tag: %r.' %
                                      (tagname, ' '.join(bits)))

        return cls(tagname, variables, options)


class ModifierBase(BaseFormNode):
    """
    Base class for the form modifiers that can be used in the {% formconfig
    <modifier> ... %} tag.

    A modifier is simply yet another template tag that just doesn't get
    registered in a template tag lib. Instead it gets called by the
    ``formconfig`` tag, based on the modifier keyword and gets all the
    remaining arguments.

    Example::

        {% formconfig row using "row.html" %}

    Will call the RowModifier class with the arguments ``using`` and
    ``"row.html"``. See the ``FormConfigNode.parse`` method for more details.
    """
    accept_for_parameter = False

    template_config_name = None
    context_config_name = None

    def __init__(self, tagname, modifier, options):
        self.tagname = tagname
        self.modifer = modifier
        self.options = options

    def enforce_form_tag(self, context):
        if not context.get(self.IN_FORM_CONTEXT_VAR, False):
            raise TemplateSyntaxError('%s must be used inside a form tag.' %
                                      self.tagname)

    def render(self, context):
        self.enforce_form_tag(context)
        config = self.get_config(context)
        filter = None
        if self.options['for']:
            try:
                for_ = self.options['for'].resolve(context)
            except VariableDoesNotExist:
                if settings.TEMPLATE_DEBUG:
                    raise
                return ''
            filter = ConfigFilter(for_)
        if self.options['using']:
            try:
                template_name = self.options['using'].resolve(context)
            except VariableDoesNotExist:
                if settings.TEMPLATE_DEBUG:
                    raise
                return ''
            config.configure(self.template_config_name,
                             template_name, filter=filter)
        if self.options['with']:
            extra_context = dict([
                (name, var.resolve(context))
                for name, var in self.options['with'].items()])
            config.configure(self.context_config_name,
                             extra_context, filter=filter)
        return u''

    @classmethod
    def parse_bits(cls, tagname, modifier, bits, parser, tokens):
        options = {
            'using': None,
            'with': None,
            'for': None,
        }
        if not bits:
            raise TemplateSyntaxError('%s %s: at least one argument '
                                      'is required.' %
                                      (tagname, modifier))

        cls.parse_using(tagname, parser, bits, options)
        cls.parse_with(tagname, parser, bits, options)
        if cls.accept_for_parameter:
            cls.parse_for(tagname, parser, bits, options)

        if bits:
            raise TemplateSyntaxError('Unknown argument for %s %s tag: %r.' %
                                      (tagname, modifier, ' '.join(bits)))

        return cls(tagname, modifier, options)


class RowModifier(ModifierBase):
    """
    {% formconfig row ... %}
    """
    optional_using_parameter = True
    optional_with_parameter = True
    accept_only_parameter = False
    accept_for_parameter = False

    template_config_name = 'row_template'
    context_config_name = 'row_context'


class FieldModifier(ModifierBase):
    """
    {% formconfig field ... %}
    """
    optional_using_parameter = True
    optional_with_parameter = True
    accept_only_parameter = False
    accept_for_parameter = True
    optional_for_parameter = True

    template_config_name = 'widget_template'
    context_config_name = 'widget_context'


class FormConfigNode(BaseFormNode):
    """
    {% formconfig ... %}
    """
    MODIFIERS = {
        'row': RowModifier,
        'field': FieldModifier,
    }

    @classmethod
    def parse(cls, parser, tokens):
        bits = tokens.split_contents()
        tagname = bits.pop(0)
        if not bits or bits[0] not in cls.MODIFIERS:
            raise TemplateSyntaxError(
                '%s needs one of the following keywords as first argument: '
                '%s' % (tagname, ', '.join(cls.MODIFIERS.keys())))
        modifier = bits.pop(0)
        modifier_cls = cls.MODIFIERS[modifier]
        return modifier_cls.parse_bits(tagname, modifier, bits, parser, tokens)


class BaseFormRenderNode(BaseFormNode):
    """
    Base class for ``form``, ``formrow`` and ``formfield`` -- tags that are
    responsible for actually rendering a form and outputting HTML.

    """
    def is_list_variable(self, var):
        return False

    def get_template_name(self, context):
        raise NotImplementedError

    def get_nodelist(self, context, extra_context):
        if 'nodelist' in self.options:
            return self.options['nodelist']
        try:
            if 'using' in self.options:
                template_name = self.options['using'].resolve(context)
            else:
                template_name = self.get_template_name(context)
            return get_template(template_name)
        except:
            if settings.TEMPLATE_DEBUG:
                raise

    def get_extra_context(self, context):
        variables = []
        for variable in self.variables:
            try:
                variable = variable.resolve(context)
                if variable is not None:
                    if self.is_list_variable(variable):
                        variables.extend(variable)
                    else:
                        variables.append(variable)
            except VariableDoesNotExist:
                pass

        extra_context = {
            self.single_template_var: variables[0] if variables else None,
        }
        if self.list_template_var:
            extra_context[self.list_template_var] = variables

        if self.options['with']:
            extra_context.update(dict([
                (name, var.resolve(context))
                for name, var in self.options['with'].items()]))

        return extra_context

    def render(self, context):
        only = self.options['only']

        config = self.get_config(context)
        config.push()

        extra_context = self.get_extra_context(context)
        nodelist = self.get_nodelist(context, extra_context)
        if nodelist is None:
            return ''

        if only:
            context = context.new(extra_context)
            output = nodelist.render(context)
        else:
            context.update(extra_context)
            output = nodelist.render(context)
            context.pop()

        config.pop()
        return output


class FormNode(BaseFormRenderNode):
    """
    {% form ... %}
    """
    single_template_var = 'form'
    list_template_var = 'forms'

    def is_list_variable(self, var):
        if not hasattr(var, '__iter__'):
            return False
        # we assume it is a formset if the var has these fields
        significant_attributes = ('forms', 'management_form')
        if all(hasattr(var, attr) for attr in significant_attributes):
            return True
        # we assume it is a form if the var has these fields
        significant_attributes = ('is_bound', 'data', 'fields')
        if any(hasattr(var, attr) for attr in significant_attributes):
            return False
        # form duck-typing was not successful so it must be a list
        return True

    def get_template_name(self, context):
        config = self.get_config(context)
        return config.retrieve('layout')

    def get_extra_context(self, context):
        extra_context = super(FormNode, self).get_extra_context(context)
        extra_context[self.IN_FORM_CONTEXT_VAR] = True
        return extra_context

    @classmethod
    def parse_using(cls, tagname, parser, bits, options):
        """
        Parses content until ``{% endform %}`` if no template name is
        specified after "using".
        """
        if bits:
            if bits[0] == 'using':
                bits.pop(0)
                if len(bits):
                    if bits[0] in ('with', 'only'):
                        raise TemplateSyntaxError(
                            '%s: you must provide one template after "using" '
                            'and before "with" or "only".')
                    options['using'] = Variable(bits.pop(0))
                else:
                    nodelist = parser.parse(('end%s' % tagname,))
                    parser.delete_first_token()
                    options['nodelist'] = nodelist
            else:
                raise TemplateSyntaxError('Unknown argument for %s tag: %r.' %
                                          (tagname, bits[0]))


class FormRowNode(BaseFormRenderNode):
    """
    {% formrow <bounds fields> ... %}
    """
    single_template_var = 'field'
    list_template_var = 'fields'

    optional_using_parameter = True

    def is_list_variable(self, var):
        if hasattr(var, '__iter__') and not isinstance(var, BoundField):
            return True
        return False

    def get_template_name(self, context):
        config = self.get_config(context)
        return config.retrieve('row_template')

    def get_extra_context(self, context):
        extra_context = super(FormRowNode, self).get_extra_context(context)
        config = self.get_config(context)
        configured_context = {}
        # most recently used values should overwrite older ones
        for extra in reversed(config.retrieve_all('row_context')):
            configured_context.update(extra)
        configured_context.update(extra_context)
        return configured_context


@contextmanager
def attributes(widget, **kwargs):
    old = {}
    for name, value in kwargs.items():
        old[name] = getattr(widget, name, empty)
        setattr(widget, name, value)
    yield widget
    for name, value in old.items():
        if value is not empty:
            setattr(widget, name, value)


class FormFieldNode(BaseFormRenderNode):
    """
    {% formfield <bound field> ... %}
    """
    single_template_var = 'field'
    optional_using_parameter = True

    def get_extra_context(self, context):
        extra_context = super(FormFieldNode, self).get_extra_context(context)
        field = extra_context[self.single_template_var]
        config = self.get_config(context)
        configured_context = {}
        # most recently used values should overwrite older ones
        widget_context = config.retrieve_all('widget_context',
                                             bound_field=field)
        for extra in reversed(widget_context):
            configured_context.update(extra)
        configured_context.update(extra_context)
        return configured_context

    def render(self, context):
        config = self.get_config(context)

        assert len(self.variables) == 1
        try:
            bound_field = self.variables[0].resolve(context)
        except VariableDoesNotExist:
            if settings.DEBUG:
                raise
            return u''

        widget = config.retrieve('widget', bound_field=bound_field)
        extra_context = self.get_extra_context(context)
        template_name = config.retrieve('widget_template',
                                        bound_field=bound_field)
        if 'using' in self.options:
            try:
                template_name = self.options['using'].resolve(context)
            except VariableDoesNotExist:
                if settings.DEBUG:
                    raise
                return u''

        if self.options['only']:
            context_instance = context.new(extra_context)
        else:
            context.update(extra_context)
            context_instance = context

        config.push()

        # Using a context manager here until Django's BoundField takes
        # template name and context instance parameters
        with attributes(widget, template_name=template_name,
                        context_instance=context_instance) as widget:
            output = bound_field.as_widget(widget=widget)

        config.pop()

        if not self.options['only']:
            context.pop()

        if bound_field.field.show_hidden_initial:
            return output + bound_field.as_hidden(only_initial=True)
        return output

    @classmethod
    def parse_variables(cls, tagname, parser, bits, options):
        variables = []
        while bits and bits[0] not in ('using', 'with', 'only'):
            variables.append(Variable(bits.pop(0)))
        if len(variables) != 1:
            raise TemplateSyntaxError('%s tag expectes exactly one '
                                      'template variable as argument.' %
                                      tagname)
        return variables


class WidgetNode(Node):
    """A template tag for rendering a widget with the outer context available.

    This is useful for for instance for using floppyforms with
    django-sekizai."""

    def __init__(self, field):
        self.field = Variable(field)

    def render(self, context):
        field = self.field.resolve(context)

        if callable(getattr(field.field.widget, 'get_context', None)):
            name = field.html_name
            attrs = {'id': field.auto_id}
            value = field.value()
            widget_ctx = field.field.widget.get_context(name, value, attrs)
            template = field.field.widget.template_name
        else:
            widget_ctx = {'field': field}
            template = 'floppyforms/dummy.html'

        template = get_template(template)
        context.update(widget_ctx)
        rendered = template.render(context)
        context.pop()
        return rendered

    @classmethod
    def parse(cls, parser, tokens):
        bits = tokens.split_contents()
        if len(bits) != 2:
            raise TemplateSyntaxError("{% widget %} takes one and only one argument")
        field = bits.pop(1)
        return cls(field)


@register.filter
def hidden_field_errors(form):
    hidden_field_errors = ErrorList()
    for field in form.hidden_fields():
        hidden_field_errors.extend(field.errors)
    return hidden_field_errors


@register.filter
def id(bound_field):
    widget = bound_field.field.widget
    for_id = widget.attrs.get('id') or bound_field.auto_id
    if for_id:
        for_id = widget.id_for_label(for_id)
    return for_id


register.tag('formconfig', FormConfigNode.parse)
register.tag('form', FormNode.parse)
register.tag('formrow', FormRowNode.parse)
register.tag('formfield', FormFieldNode.parse)
register.tag('widget', WidgetNode.parse)

########NEW FILE########
__FILENAME__ = widgets
from itertools import chain
import re
import datetime

import django
from django import forms
try:
    from django.forms.utils import to_current_timezone
except ImportError:
    # Fall back to old module name for Django <= 1.5
    from django.forms.util import to_current_timezone
from django.forms.widgets import FILE_INPUT_CONTRADICTION
from django.conf import settings
from django.template import loader
from django.utils.datastructures import MultiValueDict, MergeDict
from django.utils.html import conditional_escape
from django.utils.translation import ugettext_lazy as _
from django.utils import datetime_safe, formats, six
from django.utils.dates import MONTHS
from django.utils.encoding import force_text


RE_DATE = re.compile(r'(\d{4})-(\d\d?)-(\d\d?)$')


__all__ = (
    'TextInput', 'PasswordInput', 'HiddenInput', 'ClearableFileInput',
    'FileInput', 'DateInput', 'DateTimeInput', 'TimeInput', 'Textarea',
    'CheckboxInput', 'Select', 'NullBooleanSelect', 'SelectMultiple',
    'RadioSelect', 'CheckboxSelectMultiple', 'SearchInput', 'RangeInput',
    'ColorInput', 'EmailInput', 'URLInput', 'PhoneNumberInput', 'NumberInput',
    'IPAddressInput', 'MultiWidget', 'Widget', 'SplitDateTimeWidget',
    'SplitHiddenDateTimeWidget', 'MultipleHiddenInput', 'SelectDateWidget',
    'SlugInput',
)


class Widget(forms.Widget):
    is_required = False


class Input(Widget):
    template_name = 'floppyforms/input.html'
    input_type = None
    datalist = None

    def __init__(self, *args, **kwargs):
        datalist = kwargs.pop('datalist', None)
        if datalist is not None:
            self.datalist = datalist
        template_name = kwargs.pop('template_name', None)
        if template_name is not None:
            self.template_name = template_name
        super(Input, self).__init__(*args, **kwargs)
        self.context_instance = None

    def get_context_data(self):
        return {}

    def _format_value(self, value):
        if self.is_localized:
            value = formats.localize_input(value)
        return force_text(value)

    def get_context(self, name, value, attrs=None):
        context = {
            'type': self.input_type,
            'name': name,
            'hidden': self.is_hidden,
            'required': self.is_required,
            'True': True,
        }
        # True is injected in the context to allow stricter comparisons
        # for widget attrs. See #25.
        if self.is_hidden:
            context['hidden'] = True

        if value is None:
            value = ''

        if value != '':
            # Only add the value if it is non-empty
            context['value'] = self._format_value(value)

        context.update(self.get_context_data())
        context['attrs'] = self.build_attrs(attrs)

        for key, attr in context['attrs'].items():
            if attr == 1:
                # 1 == True so 'key="1"' will show up only as 'key'
                # Casting to a string so that it doesn't equal to True
                # See #25.
                if not isinstance(attr, bool):
                    context['attrs'][key] = str(attr)

        if self.datalist is not None:
            context['datalist'] = self.datalist
        return context

    def render(self, name, value, attrs=None, **kwargs):
        template_name = kwargs.pop('template_name', None)
        if template_name is None:
            template_name = self.template_name
        context = self.get_context(name, value, attrs=attrs or {}, **kwargs)
        return loader.render_to_string(
            template_name,
            dictionary=context,
            context_instance=self.context_instance)


class TextInput(Input):
    input_type = 'text'

    def __init__(self, *args, **kwargs):
        if kwargs.get('attrs', None) is not None:
            self.input_type = kwargs['attrs'].pop('type', self.input_type)
        super(TextInput, self).__init__(*args, **kwargs)


class PasswordInput(TextInput):
    input_type = 'password'

    def __init__(self, attrs=None, render_value=False):
        super(PasswordInput, self).__init__(attrs)
        self.render_value = render_value

    def render(self, name, value, attrs=None):
        if not self.render_value:
            value = None
        return super(PasswordInput, self).render(name, value, attrs)


class HiddenInput(Input):
    input_type = 'hidden'
    is_hidden = True


class MultipleHiddenInput(HiddenInput):
    """<input type="hidden"> for fields that have a list of values"""
    def __init__(self, attrs=None, choices=()):
        super(MultipleHiddenInput, self).__init__(attrs)
        self.choices = choices

    def render(self, name, value, attrs=None, choices=()):
        if value is None:
            value = []

        final_attrs = self.build_attrs(attrs)
        id_ = final_attrs.get('id', None)
        inputs = []
        for i, v in enumerate(value):
            input_attrs = final_attrs.copy()
            if id_:
                input_attrs['id'] = '%s_%s' % (id_, i)
            input_ = HiddenInput()
            input_.is_required = self.is_required
            inputs.append(input_.render(name, force_text(v), input_attrs))
        return "\n".join(inputs)

    def value_from_datadict(self, data, files, name):
        if isinstance(data, (MultiValueDict, MergeDict)):
            return data.getlist(name)
        return data.get(name, None)


class SlugInput(TextInput):
    """<input type="text"> validating slugs with a pattern"""
    def get_context(self, name, value, attrs):
        context = super(SlugInput, self).get_context(name, value, attrs)
        context['attrs']['pattern'] = "[-\w]+"
        return context


class IPAddressInput(TextInput):
    """<input type="text"> validating IP addresses with a pattern"""
    ip_pattern = ("(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25"
                  "[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}")

    def get_context(self, name, value, attrs):
        context = super(IPAddressInput, self).get_context(name, value, attrs)
        context['attrs']['pattern'] = self.ip_pattern
        return context


class FileInput(Input):
    input_type = 'file'
    needs_multipart_form = True
    omit_value = True

    def render(self, name, value, attrs=None):
        if self.omit_value:
            # File inputs can't render an existing value if it's not saved
            value = None
        return super(FileInput, self).render(name, value, attrs=attrs)

    def value_from_datadict(self, data, files, name):
        return files.get(name, None)

    if django.VERSION < (1, 6):
        def _has_changed(self, initial, data):
            if data is None:
                return False
            return True


class ClearableFileInput(FileInput):
    template_name = 'floppyforms/clearable_input.html'
    omit_value = False

    def clear_checkbox_name(self, name):
        return name + '-clear'

    def clear_checkbox_id(self, name):
        return name + '_id'

    def get_context(self, name, value, attrs):
        context = super(ClearableFileInput, self).get_context(name, value,
                                                              attrs)
        ccb_name = self.clear_checkbox_name(name)
        context.update({
            'checkbox_name': ccb_name,
            'checkbox_id': self.clear_checkbox_id(ccb_name),
        })
        return context

    def value_from_datadict(self, data, files, name):
        upload = super(ClearableFileInput, self).value_from_datadict(
            data, files, name
        )
        if not self.is_required and CheckboxInput().value_from_datadict(
            data, files, self.clear_checkbox_name(name)
        ):
            if upload:
                return FILE_INPUT_CONTRADICTION
            return False
        return upload

    def _format_value(self, value):
        return value


class Textarea(Input):
    template_name = 'floppyforms/textarea.html'
    rows = 10
    cols = 40

    def __init__(self, attrs=None):
        default_attrs = {'cols': self.cols, 'rows': self.rows}
        if attrs:
            default_attrs.update(attrs)
        super(Textarea, self).__init__(default_attrs)

    def _format_value(self, value):
        return conditional_escape(force_text(value))


class DateInput(Input):
    input_type = 'date'

    def __init__(self, attrs=None, format=None):
        super(DateInput, self).__init__(attrs)
        if format:
            self.format = format
            self.manual_format = True
        else:
            self.format = formats.get_format('DATE_INPUT_FORMATS')[0]
            self.manual_format = False

    def _format_value(self, value):
        if hasattr(value, 'strftime'):
            value = datetime_safe.new_date(value)
            return value.strftime(self.format)
        return value

    if django.VERSION < (1, 6):
        def _has_changed(self, initial, data):
            try:
                input_format = formats.get_format('DATE_INPUT_FORMATS')[0]
                initial = datetime.datetime.strptime(initial, input_format).date()
            except (TypeError, ValueError):
                pass
            return super(DateInput, self)._has_changed(
                self._format_value(initial), data
            )


class DateTimeInput(Input):
    input_type = 'datetime'

    def __init__(self, attrs=None, format=None):
        super(DateTimeInput, self).__init__(attrs)
        if format:
            self.format = format
            self.manual_format = True
        else:
            self.format = formats.get_format('DATETIME_INPUT_FORMATS')[0]
            self.manual_format = False

    def _format_value(self, value):
        if hasattr(value, 'strftime'):
            value = datetime_safe.new_datetime(value)
            return value.strftime(self.format)
        return value

    if django.VERSION < (1, 6):
        def _has_changed(self, initial, data):
            try:
                input_format = formats.get_format('DATETIME_INPUT_FORMATS')[0]
                initial = datetime.datetime.strptime(initial, input_format)
            except (TypeError, ValueError):
                pass
            return super(DateTimeInput, self)._has_changed(
                self._format_value(initial), data
            )


class TimeInput(Input):
    input_type = 'time'

    def __init__(self, attrs=None, format=None):
        super(TimeInput, self).__init__(attrs)
        if format:
            self.format = format
            self.manual_format = True
        else:
            self.format = formats.get_format('TIME_INPUT_FORMATS')[0]
            self.manual_format = False

    def _format_value(self, value):
        if hasattr(value, 'strftime'):
            return value.strftime(self.format)
        return value

    if django.VERSION < (1, 6):
        def _has_changed(self, initial, data):
            try:
                input_format = formats.get_format('TIME_INPUT_FORMATS')[0]
                initial = datetime.datetime.strptime(initial, input_format).time()
            except (TypeError, ValueError):
                pass
            return super(TimeInput, self)._has_changed(
                self._format_value(initial), data
            )


class SearchInput(Input):
    input_type = 'search'


class EmailInput(TextInput):
    input_type = 'email'


class URLInput(TextInput):
    input_type = 'url'


class ColorInput(Input):
    input_type = 'color'


class NumberInput(TextInput):
    input_type = 'number'
    min = None
    max = None
    step = None

    def __init__(self, attrs=None):
        default_attrs = {'min': self.min, 'max': self.max, 'step': self.step}
        if attrs:
            default_attrs.update(attrs)
        # Popping attrs if they're not set
        for key in list(default_attrs.keys()):
            if default_attrs[key] is None:
                default_attrs.pop(key)
        super(NumberInput, self).__init__(default_attrs)


class RangeInput(NumberInput):
    input_type = 'range'


class PhoneNumberInput(Input):
    input_type = 'tel'


def boolean_check(v):
    return not (v is False or v is None or v == '')


class CheckboxInput(Input, forms.CheckboxInput):
    input_type = 'checkbox'

    def __init__(self, attrs=None, check_test=None):
        super(CheckboxInput, self).__init__(attrs)
        self.check_test = boolean_check if check_test is None else check_test

    def get_context(self, name, value, attrs):
        result = self.check_test(value)
        context = super(CheckboxInput, self).get_context(name, value, attrs)
        if result:
            context['attrs']['checked'] = True
        return context

    def _format_value(self, value):
        if value in ('', True, False, None):
            value = None
        else:
            value = force_text(value)
        return value

    def value_from_datadict(self, data, files, name):
        if name not in data:
            return False
        value = data.get(name)
        values = {'true': True, 'false': False}
        if isinstance(value, six.text_type):
            value = values.get(value.lower(), value)
        return value

    if django.VERSION < (1, 6):
        def _has_changed(self, initial, data):
            if initial == 'False':
                # show_hidden_initial may have transformed False to 'False'
                initial = False
            return bool(initial) != bool(data)


class Select(Input):
    allow_multiple_selected = False
    template_name = 'floppyforms/select.html'

    def __init__(self, attrs=None, choices=()):
        super(Select, self).__init__(attrs)
        self.choices = list(choices)

    def get_context(self, name, value, attrs=None, choices=()):
        if not hasattr(value, '__iter__') or isinstance(value,
                                                        six.string_types):
            value = [value]
        context = super(Select, self).get_context(name, value, attrs)

        if self.allow_multiple_selected:
            context['attrs']['multiple'] = "multiple"

        # 'groups' look like this:
        # (
        #   ("Optgroup name", (
        #       (value1, label1),
        #       (value2, label2),
        #   )),
        #   (None, [
        #       (value3, label3),
        #       (value4, label4),
        #   ]),
        # )
        groups = []
        for option_value, option_label in chain(self.choices, choices):
            if isinstance(option_label, (list, tuple)):
                group = []
                for val, lab in option_label:
                    group.append((force_text(val), lab))
                groups.append((option_value, group))
            else:
                option_value = force_text(option_value)
                if groups and groups[-1][0] is None:
                    groups[-1][1].append((option_value, option_label))
                else:
                    groups.append((None, [(option_value, option_label)]))
        context["optgroups"] = groups
        return context

    def _format_value(self, value):
        if len(value) == 1 and value[0] is None:
            return []
        return set(force_text(v) for v in value)


class NullBooleanSelect(Select):
    def __init__(self, attrs=None):
        choices = ((u'1', _('Unknown')),
                   (u'2', _('Yes')),
                   (u'3', _('No')))
        super(NullBooleanSelect, self).__init__(attrs, choices)

    def _format_value(self, value):
        value = value[0]
        try:
            value = {True: u'2', False: u'3', u'2': u'2', u'3': u'3'}[value]
        except KeyError:
            value = u'1'
        return value

    def value_from_datadict(self, data, files, name):
        value = data.get(name, None)
        return {u'2': True,
                True: True,
                'True': True,
                u'3': False,
                'False': False,
                False: False}.get(value, None)

    if django.VERSION < (1, 6):
        def _has_changed(self, initial, data):
            if initial is not None:
                initial = bool(initial)
            if data is not None:
                data = bool(data)
            return initial != data


class SelectMultiple(Select):
    allow_multiple_selected = True

    def _format_value(self, value):
        if len(value) == 1 and value[0] is None:
            value = []
        return [force_text(v) for v in value]

    def value_from_datadict(self, data, files, name):
        if isinstance(data, (MultiValueDict, MergeDict)):
            return data.getlist(name)
        return data.get(name, None)

    if django.VERSION < (1, 6):
        def _has_changed(self, initial, data):
            if initial is None:
                initial = []
            if data is None:
                data = []
            if len(initial) != len(data):
                return True
            initial_set = set([force_text(value) for value in initial])
            data_set = set([force_text(value) for value in data])
            return data_set != initial_set


class RadioSelect(Select):
    template_name = 'floppyforms/radio.html'


class CheckboxSelectMultiple(SelectMultiple):
    template_name = 'floppyforms/checkbox_select.html'


class MultiWidget(forms.MultiWidget):
    pass


class SplitDateTimeWidget(MultiWidget):
    def __init__(self, attrs=None, date_format=None, time_format=None):
        widgets = (DateInput(attrs=attrs, format=date_format),
                   TimeInput(attrs=attrs, format=time_format))
        super(SplitDateTimeWidget, self).__init__(widgets, attrs)

    def decompress(self, value):
        if value:
            value = to_current_timezone(value)
            return [value.date(), value.time().replace(microsecond=0)]
        return [None, None]


class SplitHiddenDateTimeWidget(SplitDateTimeWidget):
    is_hidden = True

    def __init__(self, attrs=None, date_format=None, time_format=None):
        super(SplitHiddenDateTimeWidget, self).__init__(attrs, date_format,
                                                        time_format)
        for widget in self.widgets:
            widget.input_type = 'hidden'
            widget.is_hidden = True


class SelectDateWidget(forms.Widget):
    """
    A Widget that splits date input into three <select> boxes.

    This also serves as an example of a Widget that has more than one HTML
    element and hence implements value_from_datadict.
    """
    none_value = (0, '---')
    month_field = '%s_month'
    day_field = '%s_day'
    year_field = '%s_year'
    template_name = 'floppyforms/select_date.html'

    def __init__(self, attrs=None, years=None, required=True):
        # years is an optional list/tuple of years to use in the
        # "year" select box.
        self.attrs = attrs or {}
        self.required = required
        if years:
            self.years = years
        else:
            this_year = datetime.date.today().year
            self.years = range(this_year, this_year + 10)

    def get_context_data(self):
        return {}

    def get_context(self, name, value, attrs=None, extra_context={}):
        context = {
            'year_field': self.year_field % name,
            'month_field': self.month_field % name,
            'day_field': self.day_field % name
        }
        context.update(extra_context)

        if value is None:
            value = ''

        context.update(self.get_context_data())
        attrs.update(self.attrs)

        # for things like "checked", set the value to False so that the
        # template doesn't render checked="".
        for key, value in attrs.items():
            if value is True:
                attrs[key] = False
        context['year_id'] = self.year_field % attrs['id']
        context['month_id'] = self.month_field % attrs['id']
        context['day_id'] = self.day_field % attrs['id']
        del attrs['id']

        context['attrs'] = attrs
        return context

    def render(self, name, value, attrs=None, extra_context={}):
        try:
            year_val, month_val, day_val = value.year, value.month, value.day
        except AttributeError:
            year_val = month_val = day_val = None
            if isinstance(value, six.text_type):
                if settings.USE_L10N:
                    try:
                        input_format = formats.get_format(
                            'DATE_INPUT_FORMATS'
                        )[0]
                        v = datetime.datetime.strptime(value, input_format)
                        year_val, month_val, day_val = v.year, v.month, v.day
                    except ValueError:
                        pass
                else:
                    match = RE_DATE.match(value)
                    if match:
                        year_val, month_val, day_val = map(int, match.groups())

        context = self.get_context(name, value, attrs=attrs,
                                   extra_context=extra_context)

        context['year_choices'] = [(i, i) for i in self.years]
        context['year_val'] = year_val

        context['month_choices'] = list(MONTHS.items())
        context['month_val'] = month_val

        context['day_choices'] = [(i, i) for i in range(1, 32)]
        context['day_val'] = day_val

        # Theoretically the widget should use self.is_required to determine
        # whether the field is required. For some reason this widget gets a
        # required parameter. The Django behaviour is preferred in this
        # implementation.

        # Django also adds none_value only if there is no value. The choice
        # here is to treat the Django behaviour as a bug: if the value isn't
        # required, then it can be unset.
        if self.required is False:
            context['year_choices'].insert(0, self.none_value)
            context['month_choices'].insert(0, self.none_value)
            context['day_choices'].insert(0, self.none_value)

        return loader.render_to_string(self.template_name, context)

    def value_from_datadict(self, data, files, name):
        y = data.get(self.year_field % name)
        m = data.get(self.month_field % name)
        d = data.get(self.day_field % name)
        if y == m == d == "0":
            return None
        if y and m and d:
            if settings.USE_L10N:
                input_format = formats.get_format('DATE_INPUT_FORMATS')[0]
                try:
                    date_value = datetime.date(int(y), int(m), int(d))
                except ValueError:
                    return '%s-%s-%s' % (y, m, d)
                else:
                    date_value = datetime_safe.new_date(date_value)
                    return date_value.strftime(input_format)
            else:
                return '%s-%s-%s' % (y, m, d)
        return data.get(name, None)

########NEW FILE########
__FILENAME__ = models
# flake8: noqa
import django
from django.db import models as db_models
from django.forms.models import (ModelForm as _ModelForm,
                                 ModelFormMetaclass as _ModelFormMetaclass,
                                 modelform_factory as _modelform_factory,
                                 modelformset_factory as _modelformset_factory,
                                 inlineformset_factory as _inlineformset_factory,
                                 model_to_dict, fields_for_model, BaseModelForm,
                                 save_instance, BaseModelFormSet,
                                 BaseInlineFormSet)
from django.utils import six

from floppyforms import fields
from floppyforms.forms import LayoutRenderer
from floppyforms.models import (ModelChoiceField, ModelMultipleChoiceField)
from floppyforms.widgets import Textarea


__all__ = (
    'ModelForm', 'BaseModelForm', 'model_to_dict', 'fields_for_model',
    'save_instance', 'ModelChoiceField', 'ModelMultipleChoiceField',
    'BaseModelFormSet', 'modelformset_factory', 'BaseInlineFormSet',
    'inlineformset_factory',
)


if django.VERSION > (1, 7):
    from django.forms.models import ALL_FIELDS

    __all__ = __all__ + ('ALL_FIELDS',)


FORMFIELD_OVERRIDES = {
    db_models.BooleanField: {'form_class': fields.BooleanField},
    db_models.CharField: {'form_class': fields.CharField},
    db_models.CommaSeparatedIntegerField: {'form_class': fields.CharField},
    db_models.DateField: {'form_class': fields.DateField},
    db_models.DateTimeField: {'form_class': fields.DateTimeField},
    db_models.DecimalField: {'form_class': fields.DecimalField},
    db_models.EmailField: {'form_class': fields.EmailField},
    db_models.FilePathField: {'form_class': fields.FilePathField},
    db_models.FloatField: {'form_class': fields.FloatField},
    db_models.IntegerField: {'form_class': fields.IntegerField},
    db_models.BigIntegerField: {'form_class': fields.IntegerField},
    db_models.IPAddressField: {'form_class': fields.IPAddressField},
    db_models.GenericIPAddressField: {'form_class': fields.GenericIPAddressField},
    db_models.NullBooleanField: {'form_class': fields.NullBooleanField},
    db_models.PositiveIntegerField: {'form_class': fields.IntegerField},
    db_models.PositiveSmallIntegerField: {'form_class': fields.IntegerField},
    db_models.SlugField: {'form_class': fields.SlugField},
    db_models.SmallIntegerField: {'form_class': fields.IntegerField},
    db_models.TextField: {'form_class': fields.CharField, 'widget': Textarea},
    db_models.TimeField: {'form_class': fields.TimeField},
    db_models.URLField: {'form_class': fields.URLField},
    # Binary field is never editable, so we don't need to convert it.

    db_models.FileField: {'form_class': fields.FileField},
    db_models.ImageField: {'form_class': fields.ImageField},

    db_models.ForeignKey: {'form_class': ModelChoiceField},
    db_models.ManyToManyField: {'form_class': ModelMultipleChoiceField},
    db_models.OneToOneField: {'form_class': ModelChoiceField},
}

for value in FORMFIELD_OVERRIDES.values():
    value['choices_form_class'] = fields.TypedChoiceField


def formfield_callback(db_field, **kwargs):
    defaults = FORMFIELD_OVERRIDES.get(db_field.__class__, {}).copy()
    defaults.update(kwargs)
    return db_field.formfield(**defaults)


class ModelFormMetaclass(_ModelFormMetaclass):
    def __new__(mcs, name, bases, attrs):
        if not attrs.get('formfield_callback'):
            attrs['formfield_callback'] = formfield_callback
        return super(ModelFormMetaclass, mcs).__new__(mcs, name, bases, attrs)


class ModelForm(six.with_metaclass(ModelFormMetaclass, LayoutRenderer, _ModelForm)):
    pass


def modelform_factory(model, form=ModelForm, fields=None, exclude=None,
                      formfield_callback=formfield_callback, *args, **kwargs):
    return _modelform_factory(model, form, fields, exclude, formfield_callback,
                              *args, **kwargs)


def modelformset_factory(model, form=ModelForm,
                         formfield_callback=formfield_callback,
                         *args, **kwargs):
    return _modelformset_factory(model, form, formfield_callback,
                                 *args, **kwargs)


def inlineformset_factory(parent_model, model, form=ModelForm,
                          formset=BaseInlineFormSet, fk_name=None,
                          fields=None, exclude=None, extra=3, can_order=False,
                          can_delete=True, max_num=None,
                          formfield_callback=formfield_callback,
                          *args, **kwargs):
    return _inlineformset_factory(parent_model, model, form, formset, fk_name,
                                  fields, exclude, extra, can_order,
                                  can_delete, max_num, formfield_callback,
                                  *args, **kwargs)

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
import argparse
import os, sys


os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.settings'


# Adding current directory to ``sys.path``.
parent = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, parent)


def runtests(*argv):
    argv = list(argv) or [
        'floppyforms',
        'tests',
    ]
    opts = argparser.parse_args(argv)

    if opts.coverage:
        from coverage import coverage
        test_coverage = coverage(
            branch=True,
            source=['floppyforms'])
        test_coverage.start()

    # Run tests.
    from django.core.management import execute_from_command_line
    execute_from_command_line([sys.argv[0], 'test'] + opts.appname)

    if opts.coverage:
        test_coverage.stop()

        # Report coverage to commandline.
        test_coverage.report(file=sys.stdout)


argparser = argparse.ArgumentParser(description='Process some integers.')
argparser.add_argument('appname', nargs='*')
argparser.add_argument('--no-coverage', dest='coverage', action='store_const',
    const=False, default=True, help='Do not collect coverage data.')


if __name__ == '__main__':
    runtests(*sys.argv[1:])

########NEW FILE########
__FILENAME__ = base
import sys

from django.utils import six


class InvalidVariable(six.text_type):
    if sys.version_info[0] >= 3:
        def __bool__(self):
            return False
    else:
        def __nonzero__(self):
            return False

########NEW FILE########
__FILENAME__ = deprecations
import warnings

import django.forms
from django.test import TestCase

import floppyforms as forms
from .models import Registration


class ModelFormDeprecationTests(TestCase):
    def test_model_form_is_deprecated(self):
        class RegistrationModelForm(forms.ModelForm):
            class Meta:
                model = Registration
                fields = (
                    'firstname',
                    'lastname',
                    'username',
                    'age',
                )

        with warnings.catch_warnings(record=True) as w:
            modelform = RegistrationModelForm()
            self.assertEqual(len(w), 1)
            self.assertTrue(w[0].category is FutureWarning)

        self.assertFalse(isinstance(modelform.base_fields['firstname'], forms.CharField))
        self.assertIsInstance(modelform.base_fields['firstname'], django.forms.CharField)

########NEW FILE########
__FILENAME__ = fields
from django.test import TestCase

import floppyforms as forms


class IntegerFieldTests(TestCase):
    def test_parse_int(self):
        int_field = forms.IntegerField()
        result = int_field.clean('15')
        self.assertEqual(15, result)
        self.assertIsInstance(result, int)

    def test_pass_values(self):
        class IntForm(forms.Form):
            num = forms.IntegerField(max_value=10)
            other = forms.IntegerField()
            third = forms.IntegerField(min_value=10, max_value=150)

        rendered = IntForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_num">Num:</label>
            <input type="number" name="num" id="id_num" max="10" required>
        </p>
        <p>
            <label for="id_other">Other:</label>
            <input type="number" name="other" id="id_other" required>
        </p>
        <p>
            <label for="id_third">Third:</label>
            <input type="number" name="third" id="id_third" min="10" max="150" required>
        </p>""")

########NEW FILE########
__FILENAME__ = forms
from decimal import Decimal
import django
from django.core.exceptions import ValidationError
from django.test import TestCase
from django.utils import six
from django.utils import translation
from django.utils.translation import ugettext_lazy as _
from django.utils.unittest import expectedFailure, skipIf

import floppyforms.__future__ as forms

from .models import Registration


class RegistrationForm(forms.Form):
    honeypot = forms.CharField(required=False, widget=forms.HiddenInput)
    firstname = forms.CharField(label=_(u'Your first name?'))
    lastname = forms.CharField(label=_(u'Your last name:'))
    username = forms.CharField(max_length=30)
    password = forms.CharField(
        widget=forms.PasswordInput,
        help_text=_(u'Make sure to use a secure password.'),
    )
    password2 = forms.CharField(label=_(u'Retype password'), widget=forms.PasswordInput)
    age = forms.IntegerField(required=False)
    height = forms.DecimalField(localize=True, required=False)
    agree_to_terms = forms.BooleanField()

    def clean_honeypot(self):
        if self.cleaned_data.get('honeypot'):
            raise ValidationError(u'Haha, you trapped into the honeypot.')
        return self.cleaned_data['honeypot']

    def clean(self):
        if self.errors:
            raise ValidationError(u'Please correct the errors below.')


class RegistrationModelForm(forms.ModelForm):
    class Meta:
        model = Registration
        fields = (
            'firstname',
            'lastname',
            'username',
            'age',
        )


class FormRenderAsMethodsTests(TestCase):
    def test_default_rendering(self):
        form = RegistrationForm()
        with self.assertTemplateUsed('floppyforms/layouts/default.html'):
            with self.assertTemplateUsed('floppyforms/layouts/table.html'):
                rendered = six.text_type(form)
                self.assertTrue(' name="firstname"' in rendered)

        form = RegistrationModelForm()
        with self.assertTemplateUsed('floppyforms/layouts/default.html'):
            with self.assertTemplateUsed('floppyforms/layouts/table.html'):
                rendered = six.text_type(form)
                self.assertTrue(' name="firstname"' in rendered)

    def test_as_p(self):
        form = RegistrationForm()
        with self.assertTemplateUsed('floppyforms/layouts/p.html'):
            rendered = form.as_p()
            self.assertTrue(' name="firstname"' in rendered)

        form = RegistrationModelForm()
        with self.assertTemplateUsed('floppyforms/layouts/p.html'):
            rendered = form.as_p()
            self.assertTrue(' name="firstname"' in rendered)

    def test_as_table(self):
        form = RegistrationForm()
        with self.assertTemplateUsed('floppyforms/layouts/table.html'):
            rendered = form.as_table()
            self.assertTrue(' name="firstname"' in rendered)

        form = RegistrationModelForm()
        with self.assertTemplateUsed('floppyforms/layouts/table.html'):
            rendered = form.as_table()
            self.assertTrue(' name="firstname"' in rendered)

    def test_as_ul(self):
        form = RegistrationForm()
        with self.assertTemplateUsed('floppyforms/layouts/ul.html'):
            rendered = form.as_ul()
            self.assertTrue(' name="firstname"' in rendered)

        form = RegistrationModelForm()
        with self.assertTemplateUsed('floppyforms/layouts/ul.html'):
            rendered = form.as_ul()
            self.assertTrue(' name="firstname"' in rendered)


class FormHasChangedTests(TestCase):
    def test_basic_has_changed(self):
        form = RegistrationForm()
        self.assertFalse(form.has_changed())

        form = RegistrationForm({'height': '1.89'})
        self.assertTrue(form.has_changed())

        form = RegistrationForm({'height': '1.89'},
                                initial={'height': Decimal('1.89')})
        self.assertFalse(form.has_changed())

    def test_custom_has_changed_logic_for_checkbox_input(self):
        form = RegistrationForm({'agree_to_terms': True})
        self.assertTrue(form.has_changed())

        form = RegistrationForm({'agree_to_terms': False},
                                initial={'agree_to_terms': False})
        self.assertFalse(form.has_changed())

        form = RegistrationForm({'agree_to_terms': False},
                                initial={'agree_to_terms': 'False'})
        self.assertFalse(form.has_changed())

    @skipIf(django.VERSION < (1, 6), 'Only applies to Django >= 1.6')
    def test_widgets_do_not_have_has_changed_method(self):
        self.assertFalse(hasattr(forms.CheckboxInput, '_has_changed'))
        self.assertFalse(hasattr(forms.NullBooleanSelect, '_has_changed'))
        self.assertFalse(hasattr(forms.SelectMultiple, '_has_changed'))
        self.assertFalse(hasattr(forms.FileInput, '_has_changed'))
        self.assertFalse(hasattr(forms.DateInput, '_has_changed'))
        self.assertFalse(hasattr(forms.DateTimeInput, '_has_changed'))
        self.assertFalse(hasattr(forms.TimeInput, '_has_changed'))

    def test_has_changed_logic_with_localized_values(self):
        '''
        See: https://code.djangoproject.com/ticket/16612
        '''
        with translation.override('de-de'):
            form = RegistrationForm({'height': '1,89'},
                                    initial={'height': Decimal('1.89')})
            self.assertFalse(form.has_changed())

    if django.VERSION < (1, 6):
        test_has_changed_logic_with_localized_values = expectedFailure(
            test_has_changed_logic_with_localized_values)

########NEW FILE########
__FILENAME__ = gis
from django.conf import settings
from django.test import TestCase
from django.utils import unittest
from django.utils.functional import wraps

try:
    from django.contrib.gis.geos import GEOSGeometry
except (ImportError, Exception):
    """GDAL / GEOS not installed. Tests will fail if contrib.gis
    is installed, and will be skipped otherwise"""
    GEOSGeometry = None  # noqa

import floppyforms as forms


# Some test data, geometries as OpenLayers serializes them.
# GEOS's WKT reader normalizes them.
# This is a callable to prevent us from getting warnings from the GEOS C api
GEOMETRIES = lambda: {
    'point': GEOSGeometry("""SRID=4326;POINT(9.052734375 42.451171875)"""),
    'multipoint': GEOSGeometry("SRID=4326;MULTIPOINT("
                               "(13.18634033203125 14.504356384277344),"
                               "(13.207969665527 14.490966796875),"
                               "(13.177070617675 14.454917907714))"),
    'linestring': GEOSGeometry("SRID=4326;LINESTRING("
                               "-8.26171875 -0.52734375,"
                               "-7.734375 4.21875,"
                               "6.85546875 3.779296875,"
                               "5.44921875 -3.515625)"),
    'multilinestring': GEOSGeometry("SRID=4326;MULTILINESTRING("
                                    "(-16.435546875 -2.98828125,"
                                    "-17.2265625 2.98828125,"
                                    "-0.703125 3.515625,"
                                    "-1.494140625 -3.33984375),"
                                    "(-8.0859375 -5.9765625,"
                                    "8.525390625 -8.7890625,"
                                    "12.392578125 -0.87890625,"
                                    "10.01953125 7.646484375))"),
    'polygon': GEOSGeometry("SRID=4326;POLYGON("
                            "(-1.669921875 6.240234375,"
                            "-3.8671875 -0.615234375,"
                            "5.9765625 -3.955078125,"
                            "18.193359375 3.955078125,"
                            "9.84375 9.4921875,"
                            "-1.669921875 6.240234375))"),
    'multipolygon': GEOSGeometry("SRID=4326;MULTIPOLYGON("
                                 "((-17.578125 13.095703125,"
                                 "-17.2265625 10.8984375,"
                                 "-13.974609375 10.1953125,"
                                 "-13.359375 12.744140625,"
                                 "-15.732421875 13.7109375,"
                                 "-17.578125 13.095703125)),"
                                 "((-8.525390625 5.537109375,"
                                 "-8.876953125 2.548828125,"
                                 "-5.888671875 1.93359375,"
                                 "-5.09765625 4.21875,"
                                 "-6.064453125 6.240234375,"
                                 "-8.525390625 5.537109375)))"),
    'geometrycollection': GEOSGeometry("SRID=4326;GEOMETRYCOLLECTION("
                                       "POINT(5.625 -0.263671875),"
                                       "POINT(6.767578125 -3.603515625),"
                                       "POINT(8.525390625 0.087890625),"
                                       "POINT(8.0859375 -2.13134765625),"
                                       "LINESTRING("
                                       "6.273193359375 -1.175537109375,"
                                       "5.77880859375 -1.812744140625,"
                                       "7.27294921875 -2.230224609375,"
                                       "7.657470703125 -1.25244140625))"),
}


def _deferredSkip(condition, reason):
    def decorator(test_func):
        if (not (isinstance(test_func, type)
                 and issubclass(test_func, TestCase))):
            @wraps(test_func)
            def skip_wrapper(*args, **kwargs):
                if condition():
                    raise unittest.SkipTest(reason)
                return test_func(*args, **kwargs)
            test_item = skip_wrapper
        else:
            test_item = test_func
        test_item.__unittest_skip_why__ = reason
        return test_item
    return decorator


def skipUnlessInstalled(app):
    """Skips the test if ``app`` is not installed"""
    condition = lambda: app not in settings.INSTALLED_APPS
    return _deferredSkip(condition, "%s is not installed" % app)


def skipUnlessGisAvailable():
    condition = lambda: GEOSGeometry is None
    return _deferredSkip(condition, "GEOSGeometry could not be imported")


class GisTests(TestCase):
    """Tests for the GeoDjango widgets"""

    def assertMapWidget(self, form_instance):
        """Makes sure the MapWidget js is passed in the form media
        and a MapWidget is actually created"""
        rendered = form_instance.as_p()
        self.assertTrue('new MapWidget(options);' in rendered, rendered)
        js_path = 'floppyforms/js/MapWidget.js'
        self.assertTrue(js_path in str(form_instance.media))

    def assertTextarea(self, wkt, rendered):
        """Makes sure the wkt and a textarea are in the content"""
        self.assertTrue('<textarea ' in rendered, rendered)
        self.assertTrue(' required ' in rendered, rendered)
        self.assertTrue(wkt in rendered, rendered)

    @skipUnlessInstalled('django.contrib.gis')
    @skipUnlessGisAvailable()
    def test_point(self):
        class PointForm(forms.Form):
            p = forms.gis.PointField()

        geom = GEOMETRIES()['point']
        data = {'p': geom}
        rendered = PointForm(data=data).as_p()
        self.assertTextarea(geom.wkt, rendered)
        self.assertMapWidget(PointForm(data=data))
        self.assertTrue(PointForm(data=data).is_valid())
        self.assertFalse(PointForm().is_valid())
        invalid = PointForm(data={'p': 'some invalid geom'})
        self.assertFalse(invalid.is_valid())
        self.assertTrue('Invalid geometry value' in str(invalid.errors))

        valid_geoms = ['point']
        invalid_geoms = ['multipoint', 'linestring', 'multilinestring',
                         'polygon', 'multipolygon', 'geometrycollection']
        for valid in valid_geoms:
            data = {'p': GEOMETRIES()[valid].wkt}
            self.assertTrue(PointForm(data=data).is_valid())

        for invalid in invalid_geoms:
            data = {'p': GEOMETRIES()[invalid].wkt}
            self.assertFalse(PointForm(data=data).is_valid())

    @skipUnlessInstalled('django.contrib.gis')
    @skipUnlessGisAvailable()
    def test_multipoint(self):
        class PointForm(forms.Form):
            p = forms.gis.MultiPointField()

        geom = GEOMETRIES()['multipoint']
        data = {'p': geom}
        rendered = PointForm(data=data).as_p()
        self.assertTextarea(geom.wkt, rendered)
        self.assertMapWidget(PointForm(data=data))
        self.assertTrue(PointForm(data=data).is_valid())

        valid_geoms = ['multipoint']
        invalid_geoms = ['point', 'linestring', 'multilinestring',
                         'polygon', 'multipolygon', 'geometrycollection']
        for valid in valid_geoms:
            data = {'p': GEOMETRIES()[valid].wkt}
            self.assertTrue(PointForm(data=data).is_valid())

        for invalid in invalid_geoms:
            data = {'p': GEOMETRIES()[invalid].wkt}
            self.assertFalse(PointForm(data=data).is_valid())

    @skipUnlessInstalled('django.contrib.gis')
    @skipUnlessGisAvailable()
    def test_linestring(self):
        class LineStringForm(forms.Form):
            l = forms.gis.LineStringField()

        geom = GEOMETRIES()['linestring']
        data = {'l': geom}
        rendered = LineStringForm(data=data).as_p()
        self.assertTextarea(geom.wkt, rendered)
        self.assertMapWidget(LineStringForm(data=data))
        self.assertTrue(LineStringForm(data=data).is_valid())

        valid_geoms = ['linestring']
        invalid_geoms = ['point', 'multipoint', 'multilinestring',
                         'polygon', 'multipolygon', 'geometrycollection']
        for valid in valid_geoms:
            data = {'l': GEOMETRIES()[valid].wkt}
            self.assertTrue(LineStringForm(data=data).is_valid())

        for invalid in invalid_geoms:
            data = {'l': GEOMETRIES()[invalid].wkt}
            self.assertFalse(LineStringForm(data=data).is_valid())

    @skipUnlessInstalled('django.contrib.gis')
    @skipUnlessGisAvailable()
    def test_multilinestring(self):
        class LineStringForm(forms.Form):
            l = forms.gis.MultiLineStringField()

        geom = GEOMETRIES()['multilinestring']
        data = {'l': geom}
        rendered = LineStringForm(data=data).as_p()
        self.assertTextarea(geom.wkt, rendered)
        self.assertMapWidget(LineStringForm(data=data))
        self.assertTrue(LineStringForm(data=data).is_valid())

        valid_geoms = ['multilinestring']
        invalid_geoms = ['point', 'multipoint', 'linestring',
                         'polygon', 'multipolygon', 'geometrycollection']
        for valid in valid_geoms:
            data = {'l': GEOMETRIES()[valid].wkt}
            self.assertTrue(LineStringForm(data=data).is_valid())

        for invalid in invalid_geoms:
            data = {'l': GEOMETRIES()[invalid].wkt}
            self.assertFalse(LineStringForm(data=data).is_valid())

    @skipUnlessInstalled('django.contrib.gis')
    @skipUnlessGisAvailable()
    def test_polygon(self):
        class PolygonForm(forms.Form):
            p = forms.gis.PolygonField()

        geom = GEOMETRIES()['polygon']
        data = {'p': geom}
        rendered = PolygonForm(data=data).as_p()
        self.assertTextarea(geom.wkt, rendered)
        self.assertMapWidget(PolygonForm(data=data))
        self.assertTrue(PolygonForm(data=data).is_valid())

        valid_geoms = ['polygon']
        invalid_geoms = ['point', 'multipoint', 'linestring',
                         'multilinestring', 'multipolygon',
                         'geometrycollection']
        for valid in valid_geoms:
            data = {'p': GEOMETRIES()[valid].wkt}
            self.assertTrue(PolygonForm(data=data).is_valid())

        for invalid in invalid_geoms:
            data = {'p': GEOMETRIES()[invalid].wkt}
            self.assertFalse(PolygonForm(data=data).is_valid())

    @skipUnlessInstalled('django.contrib.gis')
    @skipUnlessGisAvailable()
    def test_multipolygon(self):
        class PolygonForm(forms.Form):
            p = forms.gis.MultiPolygonField()

        geom = GEOMETRIES()['multipolygon']
        data = {'p': geom}
        rendered = PolygonForm(data=data).as_p()
        self.assertTextarea(geom.wkt, rendered)
        self.assertMapWidget(PolygonForm(data=data))
        self.assertTrue(PolygonForm(data=data).is_valid())

        valid_geoms = ['multipolygon']
        invalid_geoms = ['point', 'multipoint', 'linestring',
                         'multilinestring', 'polygon', 'geometrycollection']
        for valid in valid_geoms:
            data = {'p': GEOMETRIES()[valid].wkt}
            self.assertTrue(PolygonForm(data=data).is_valid())

        for invalid in invalid_geoms:
            data = {'p': GEOMETRIES()[invalid].wkt}
            self.assertFalse(PolygonForm(data=data).is_valid())

    @skipUnlessInstalled('django.contrib.gis')
    @skipUnlessGisAvailable()
    def test_geometry(self):
        class GeometryForm(forms.Form):
            g = forms.gis.GeometryField()

        geom = GEOMETRIES()['point']
        data = {'g': geom}
        rendered = GeometryForm(data=data).as_p()
        self.assertTextarea(geom.wkt, rendered)
        self.assertMapWidget(GeometryForm(data=data))
        self.assertTrue(GeometryForm(data=data).is_valid())

        # GeometryField will accept anything...
        valid_geoms = ['point', 'multipoint', 'linestring', 'multilinestring',
                       'polygon', 'multipolygon', 'geometrycollection']
        invalid_geoms = []
        for valid in valid_geoms:
            data = {'g': GEOMETRIES()[valid].wkt}
            self.assertTrue(GeometryForm(data=data).is_valid())

        for invalid in invalid_geoms:
            data = {'g': GEOMETRIES()[invalid].wkt}
            self.assertFalse(GeometryForm(data=data).is_valid())

    @skipUnlessInstalled('django.contrib.gis')
    @skipUnlessGisAvailable()
    def test_geometrycollection(self):
        class GeometryForm(forms.Form):
            g = forms.gis.GeometryCollectionField()

        geom = GEOMETRIES()['geometrycollection']
        data = {'g': geom}
        rendered = GeometryForm(data=data).as_p()
        self.assertTextarea(geom.wkt, rendered)
        self.assertMapWidget(GeometryForm(data=data))
        self.assertTrue(GeometryForm(data=data).is_valid())
        self.assertFalse(GeometryForm(data={'g': 'bah'}).is_valid())

        valid_geoms = ['geometrycollection']
        invalid_geoms = ['point', 'multipoint', 'linestring',
                         'multilinestring', 'polygon', 'multipolygon']
        for valid in valid_geoms:
            data = {'g': GEOMETRIES()[valid].wkt}
            self.assertTrue(GeometryForm(data=data).is_valid())

        for invalid in invalid_geoms:
            data = {'g': GEOMETRIES()[invalid].wkt}
            self.assertFalse(GeometryForm(data=data).is_valid())

########NEW FILE########
__FILENAME__ = layouts
from django.conf import settings
from django.core.exceptions import ValidationError
from django.forms.formsets import formset_factory
from django.template import Context, Template
from django.test import TestCase
from django.utils.translation import ugettext_lazy as _

import floppyforms as forms

from .base import InvalidVariable


def render(template, context=None):
    if context is None:
        context = {}
    c = Context(context)
    t = Template('{% load floppyforms %}' + template)
    return t.render(c)


class HiddenForm(forms.Form):
    hide = forms.CharField(widget=forms.HiddenInput())


class OneFieldForm(forms.Form):
    text = forms.CharField()

    def clean(self):
        if self.errors:
            raise ValidationError(u'Please correct the errors below.')


class ShortForm(forms.Form):
    name = forms.CharField(label=_(u'Your first name?'))
    age = forms.IntegerField(required=False)
    metadata = forms.CharField(required=False, widget=forms.HiddenInput)


class RegistrationForm(forms.Form):
    honeypot = forms.CharField(required=False, widget=forms.HiddenInput)
    firstname = forms.CharField(label=_(u'Your first name?'))
    lastname = forms.CharField(label=_(u'Your last name:'))
    username = forms.CharField(max_length=30)
    password = forms.CharField(
        widget=forms.PasswordInput,
        help_text=_(u'Make sure to use a secure password.'),
    )
    password2 = forms.CharField(label=_(u'Retype password'), widget=forms.PasswordInput)
    age = forms.IntegerField(required=False)

    def clean_honeypot(self):
        if self.cleaned_data.get('honeypot'):
            raise ValidationError(u'Haha, you trapped into the honeypot.')
        return self.cleaned_data['honeypot']

    def clean(self):
        if self.errors:
            raise ValidationError(u'Please correct the errors below.')


class PLayoutTests(TestCase):
    def test_default_layout_is_same_as_p_layout(self):
        form = RegistrationForm()
        default = render('{% form form %}', {'form': form})
        layout = render('{% form form using "floppyforms/layouts/table.html" %}', {'form': form})
        self.assertEqual(default, layout)

    def test_layout(self):
        form = RegistrationForm()
        with self.assertTemplateUsed('floppyforms/layouts/p.html'):
            with self.assertTemplateUsed('floppyforms/rows/p.html'):
                layout = render('{% form form using "floppyforms/layouts/p.html" %}', {'form': form})
        self.maxDiff = None
        self.assertHTMLEqual(layout, """
        <p><label for="id_firstname">Your first name?</label> <input type="text" name="firstname" id="id_firstname" required />
        </p>
        <p><label for="id_lastname">Your last name:</label> <input type="text" name="lastname" id="id_lastname" required />
        </p>
        <p><label for="id_username">Username:</label> <input type="text" name="username" id="id_username" maxlength="30" required />
        </p>
        <p><label for="id_password">Password:</label> <input type="password" name="password" id="id_password" required />
         <span class="helptext">Make sure to use a secure password.</span></p>
        <p><label for="id_password2">Retype password:</label> <input type="password" name="password2" id="id_password2" required />
        </p>
        <p><label for="id_age">Age:</label> <input type="number" name="age" id="id_age" />
        <input type="hidden" name="honeypot" id="id_honeypot" />
        </p>
        """)

    def test_layout_with_errors(self):
        form = RegistrationForm({'non_field_errors': True})
        layout = render('{% form form using "floppyforms/layouts/p.html" %}', {'form': form})
        self.maxDiff = None
        self.assertHTMLEqual(layout, """
        <ul class="errorlist"><li>Please correct the errors below.</li></ul>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p><label for="id_firstname">Your first name?</label> <input type="text" name="firstname" id="id_firstname" required /></p>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p><label for="id_lastname">Your last name:</label> <input type="text" name="lastname" id="id_lastname" required /></p>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p><label for="id_username">Username:</label> <input type="text" name="username" id="id_username" maxlength="30" required /></p>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p>
            <label for="id_password">Password:</label> <input type="password" name="password" id="id_password" required />
            <span class="helptext">Make sure to use a secure password.</span>
        </p>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p><label for="id_password2">Retype password:</label> <input type="password" name="password2" id="id_password2" required /></p>
        <p><label for="id_age">Age:</label> <input type="number" name="age" id="id_age" />
            <input type="hidden" name="honeypot" id="id_honeypot" /></p>
        """)

        form = RegistrationForm({'non_field_errors': True, 'honeypot': 1})
        layout = render('{% form form using "floppyforms/layouts/p.html" %}', {'form': form})
        self.assertHTMLEqual(layout, """
        <ul class="errorlist">
            <li>Please correct the errors below.</li>
            <li>Haha, you trapped into the honeypot.</li>
        </ul>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p><label for="id_firstname">Your first name?</label> <input type="text" name="firstname" id="id_firstname" required /></p>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p><label for="id_lastname">Your last name:</label> <input type="text" name="lastname" id="id_lastname" required /></p>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p><label for="id_username">Username:</label> <input type="text" name="username" id="id_username" maxlength="30" required /></p>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p>
            <label for="id_password">Password:</label> <input type="password" name="password" id="id_password" required />
            <span class="helptext">Make sure to use a secure password.</span>
        </p>
        <ul class="errorlist"><li>This field is required.</li></ul>
        <p><label for="id_password2">Retype password:</label> <input type="password" name="password2" id="id_password2" required /></p>
        <p><label for="id_age">Age:</label> <input type="number" name="age" id="id_age" />
            <input type="hidden" name="honeypot" id="id_honeypot" value="1" /></p>
        """)

    def test_layout_with_custom_label(self):
        form = OneFieldForm()
        layout = render("""
            {% form form using %}
                {% formrow form.text using "floppyforms/rows/p.html" with label="Custom label" %}
            {% endform %}
        """, {'form': form})
        self.assertHTMLEqual(layout, """
        <p><label for="id_text">Custom label:</label> <input type="text" name="text" id="id_text" required /></p>
        """)

    def test_layout_with_custom_help_text(self):
        form = OneFieldForm()
        layout = render("""
            {% form form using %}
                {% formrow form.text using "floppyforms/rows/p.html" with help_text="Would you mind entering text here?" %}
            {% endform %}
        """, {'form': form})
        self.assertHTMLEqual(layout, """
        <p>
            <label for="id_text">Text:</label> <input type="text" name="text" id="id_text" required />
            <span class="helptext">Would you mind entering text here?</span>
        </p>
        """)

    def test_hidden_only_fields(self):
        form = HiddenForm()
        rendered = render("""{% form form using "floppyforms/layouts/p.html" %}""", {'form': form})
        self.assertHTMLEqual(rendered, """
        <input type="hidden" name="hide" id="id_hide" required>
        """)

    def test_formsets_with_hidden_fields(self):
        ShortFormset = formset_factory(form=ShortForm, extra=1)
        formset = ShortFormset(initial=[{'name': 'Johnson', 'age': 23, 'metadata': 'Hidden details'}])
        rendered = render("""{% form formset using "floppyforms/layouts/p.html" %}""", {'formset': formset})
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_form-0-name">Your first name?</label>
            <input type="text" name="form-0-name" value="Johnson" required id="id_form-0-name">
        </p>
        <p>
            <label for="id_form-0-age">Age:</label>
            <input type="number" name="form-0-age" value="23" id="id_form-0-age">
            <input type="hidden" name="form-0-metadata" value="Hidden details" id="id_form-0-metadata">
        </p>
        <p>
            <label for="id_form-1-name">Your first name?</label>
            <input type="text" name="form-1-name" required id="id_form-1-name">
        </p>
        <p>
            <label for="id_form-1-age">Age:</label>
            <input type="number" name="form-1-age" id="id_form-1-age">
            <input type="hidden" name="form-1-metadata" id="id_form-1-metadata">
        </p>
        """)


class TableLayoutTests(TestCase):
    def test_layout(self):
        form = RegistrationForm()
        with self.assertTemplateUsed('floppyforms/layouts/table.html'):
            with self.assertTemplateUsed('floppyforms/rows/tr.html'):
                layout = render('{% form form using "floppyforms/layouts/table.html" %}', {'form': form})
        self.assertHTMLEqual(layout, """
        <tr><th><label for="id_firstname">Your first name?</label></th><td><input type="text" name="firstname" id="id_firstname" required /></td></tr>
        <tr><th><label for="id_lastname">Your last name:</label></th><td><input type="text" name="lastname" id="id_lastname" required /></td></tr>
        <tr><th><label for="id_username">Username:</label></th><td><input type="text" name="username" id="id_username" maxlength="30" required /></td></tr>
        <tr><th>
            <label for="id_password">Password:</label></th><td><input type="password" name="password" id="id_password" required />
            <br /><span class="helptext">Make sure to use a secure password.</span></td></tr>
        <tr><th><label for="id_password2">Retype password:</label></th><td><input type="password" name="password2" id="id_password2" required /></td></tr>
        <tr><th>
            <label for="id_age">Age:</label></th><td><input type="number" name="age" id="id_age" />
            <input type="hidden" name="honeypot" id="id_honeypot" />
        </td></tr>
        """)

    def test_layout_with_errors(self):
        form = RegistrationForm({'non_field_errors': True})
        layout = render('{% form form using "floppyforms/layouts/table.html" %}', {'form': form})
        self.assertHTMLEqual(layout, """
        <tr><td colspan="2"><ul class="errorlist"><li>Please correct the errors below.</li></ul></td></tr>
        <tr><th><label for="id_firstname">Your first name?</label></th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="firstname" id="id_firstname" required /></td></tr>
        <tr><th><label for="id_lastname">Your last name:</label></th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="lastname" id="id_lastname" required /></td></tr>
        <tr><th><label for="id_username">Username:</label></th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="username" id="id_username" maxlength="30" required /></td></tr>
        <tr>
            <th><label for="id_password">Password:</label></th>
            <td>
                <ul class="errorlist"><li>This field is required.</li></ul>
                <input type="password" name="password" id="id_password" required />
                <br /><span class="helptext">Make sure to use a secure password.</span>
            </td>
        </tr>
        <tr>
            <th><label for="id_password2">Retype password:</label></th>
            <td><ul class="errorlist"><li>This field is required.</li></ul><input type="password" name="password2" id="id_password2" required /></td>
        </tr>
        <tr><th><label for="id_age">Age:</label></th><td><input type="number" name="age" id="id_age" />
            <input type="hidden" name="honeypot" id="id_honeypot" /></td></tr>
        """)

        form = RegistrationForm({'non_field_errors': True, 'honeypot': 1})
        layout = render('{% form form using "floppyforms/layouts/table.html" %}', {'form': form})
        self.assertHTMLEqual(layout, """
        <tr><td colspan="2"><ul class="errorlist"><li>Please correct the errors below.</li><li>Haha, you trapped into the honeypot.</li></ul></td></tr>
        <tr><th><label for="id_firstname">Your first name?</label></th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="firstname" id="id_firstname" required /></td></tr>
        <tr><th><label for="id_lastname">Your last name:</label></th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="lastname" id="id_lastname" required /></td></tr>
        <tr><th><label for="id_username">Username:</label></th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="username" id="id_username" maxlength="30" required /></td></tr>
        <tr><th><label for="id_password">Password:</label></th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="password" name="password" id="id_password" required /><br /><span class="helptext">Make sure to use a secure password.</span></td></tr>
        <tr><th><label for="id_password2">Retype password:</label></th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="password" name="password2" id="id_password2" required /></td></tr>
        <tr><th><label for="id_age">Age:</label></th><td><input type="number" name="age" id="id_age" />
            <input type="hidden" name="honeypot" value="1" id="id_honeypot" /></td></tr>
        """)

    def test_layout_with_custom_label(self):
        form = OneFieldForm()
        layout = render("""
            {% form form using %}
                {% formrow form.text using "floppyforms/rows/tr.html" with label="Custom label" %}
            {% endform %}
        """, {'form': form})
        self.assertHTMLEqual(layout, """
        <tr><th><label for="id_text">Custom label:</label></th><td><input type="text" name="text" id="id_text" required /></td></tr>
        """)

    def test_layout_with_custom_help_text(self):
        form = OneFieldForm()
        layout = render("""
            {% form form using %}
                {% formrow form.text using "floppyforms/rows/tr.html" with help_text="Would you mind entering text here?" %}
            {% endform %}
        """, {'form': form})
        self.assertHTMLEqual(layout, """
        <tr><th>
            <label for="id_text">Text:</label>
        </th><td>
            <input type="text" name="text" id="id_text" required />
            <br /><span class="helptext">Would you mind entering text here?</span>
        </td></tr>
        """)

    def test_hidden_only_fields(self):
        form = HiddenForm()
        rendered = render("""{% form form using "floppyforms/layouts/table.html" %}""", {'form': form})
        self.assertHTMLEqual(rendered, """
        <input type="hidden" name="hide" id="id_hide" required>
        """)

    def test_formsets_with_hidden_fields(self):
        ShortFormset = formset_factory(form=ShortForm, extra=1)
        formset = ShortFormset(initial=[{'name': 'Johnson', 'age': 23, 'metadata': 'Hidden details'}])
        rendered = render("""{% form formset using "floppyforms/layouts/table.html" %}""", {'formset': formset})
        self.assertHTMLEqual(rendered, """
        <tr>
            <th><label for="id_form-0-name">Your first name?</label></th>
            <td>
                <input type="text" name="form-0-name" value="Johnson" required id="id_form-0-name">
            </td>
        </tr>
        <tr>
            <th><label for="id_form-0-age">Age:</label></th>
            <td>
                <input type="number" name="form-0-age" value="23" id="id_form-0-age">
                <input type="hidden" name="form-0-metadata" value="Hidden details" id="id_form-0-metadata">
            </td>
        </tr>
        <tr>
            <th><label for="id_form-1-name">Your first name?</label></th>
            <td>
                <input type="text" name="form-1-name" required id="id_form-1-name">
            </td>
        </tr>
        <tr>
            <th><label for="id_form-1-age">Age:</label></th>
            <td>
                <input type="number" name="form-1-age" id="id_form-1-age">
                <input type="hidden" name="form-1-metadata" id="id_form-1-metadata">
            </td>
        </tr>
        """)


class UlLayoutTests(TestCase):
    def test_layout(self):
        form = RegistrationForm()
        with self.assertTemplateUsed('floppyforms/layouts/ul.html'):
            with self.assertTemplateUsed('floppyforms/rows/li.html'):
                layout = render('{% form form using "floppyforms/layouts/ul.html" %}', {'form': form})
        self.assertHTMLEqual(layout, """
        <li><label for="id_firstname">Your first name?</label> <input type="text" name="firstname" id="id_firstname" required /></li>
        <li><label for="id_lastname">Your last name:</label> <input type="text" name="lastname" id="id_lastname" required /></li>
        <li><label for="id_username">Username:</label> <input type="text" name="username" id="id_username" maxlength="30" required /></li>
        <li><label for="id_password">Password:</label> <input type="password" name="password" id="id_password" required />
            <span class="helptext">Make sure to use a secure password.</span></li>
        <li><label for="id_password2">Retype password:</label> <input type="password" name="password2" id="id_password2" required /></li>
        <li><label for="id_age">Age:</label> <input type="number" name="age" id="id_age" />
            <input type="hidden" name="honeypot" id="id_honeypot" /></li>
        """)

    def test_layout_with_errors(self):
        form = RegistrationForm({'non_field_errors': True})
        layout = render('{% form form using "floppyforms/layouts/ul.html" %}', {'form': form})
        self.assertHTMLEqual(layout, """
        <li><ul class="errorlist"><li>Please correct the errors below.</li></ul></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_firstname">Your first name?</label> <input type="text" name="firstname" id="id_firstname" required /></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_lastname">Your last name:</label> <input type="text" name="lastname" id="id_lastname" required /></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_username">Username:</label> <input type="text" name="username" id="id_username" maxlength="30" required /></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_password">Password:</label> <input type="password" name="password" id="id_password" required />
            <span class="helptext">Make sure to use a secure password.</span></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_password2">Retype password:</label> <input type="password" name="password2" id="id_password2" required /></li>
        <li><label for="id_age">Age:</label> <input type="number" name="age" id="id_age" />
            <input type="hidden" name="honeypot" id="id_honeypot" /></li>
        """)

        form = RegistrationForm({'non_field_errors': True, 'honeypot': 1})
        layout = render('{% form form using "floppyforms/layouts/ul.html" %}', {'form': form})
        self.assertHTMLEqual(layout, """
        <li><ul class="errorlist"><li>Please correct the errors below.</li><li>Haha, you trapped into the honeypot.</li></ul></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_firstname">Your first name?</label> <input type="text" name="firstname" id="id_firstname" required /></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_lastname">Your last name:</label> <input type="text" name="lastname" id="id_lastname" required /></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_username">Username:</label> <input type="text" name="username" id="id_username" maxlength="30" required /></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_password">Password:</label> <input type="password" name="password" id="id_password" required />
            <span class="helptext">Make sure to use a secure password.</span></li>
        <li><ul class="errorlist"><li>This field is required.</li></ul><label for="id_password2">Retype password:</label> <input type="password" name="password2" id="id_password2" required /></li>
        <li><label for="id_age">Age:</label> <input type="number" name="age" id="id_age" />
            <input type="hidden" name="honeypot" value="1" id="id_honeypot" /></li>
        """)

    def test_layout_with_custom_label(self):
        form = OneFieldForm()
        layout = render("""
            {% form form using %}
                {% formrow form.text using "floppyforms/rows/li.html" with label="Custom label" %}
            {% endform %}
        """, {'form': form})
        self.assertHTMLEqual(layout, """
        <li><label for="id_text">Custom label:</label><input type="text" name="text" id="id_text" required /></li>
        """)

    def test_layout_with_custom_help_text(self):
        form = OneFieldForm()
        layout = render("""
            {% form form using %}
                {% formrow form.text using "floppyforms/rows/li.html" with help_text="Would you mind entering text here?" %}
            {% endform %}
        """, {'form': form})
        self.assertHTMLEqual(layout, """
        <li>
            <label for="id_text">Text:</label>
            <input type="text" name="text" id="id_text" required />
            <span class="helptext">Would you mind entering text here?</span>
        </li>
        """)

    def test_hidden_only_fields(self):
        form = HiddenForm()
        rendered = render("""{% form form using "floppyforms/layouts/ul.html" %}""", {'form': form})
        self.assertHTMLEqual(rendered, """
        <input type="hidden" name="hide" id="id_hide" required>
        """)

    def test_formsets_with_hidden_fields(self):
        ShortFormset = formset_factory(form=ShortForm, extra=1)
        formset = ShortFormset(initial=[{'name': 'Johnson', 'age': 23, 'metadata': 'Hidden details'}])
        rendered = render("""{% form formset using "floppyforms/layouts/ul.html" %}""", {'formset': formset})
        self.assertHTMLEqual(rendered, """
        <li>
            <label for="id_form-0-name">Your first name?</label>
            <input type="text" name="form-0-name" value="Johnson" required id="id_form-0-name">
        </li>
        <li>
            <label for="id_form-0-age">Age:</label>
            <input type="number" name="form-0-age" value="23" id="id_form-0-age">
            <input type="hidden" name="form-0-metadata" value="Hidden details" id="id_form-0-metadata">

        </li>
        <li>
            <label for="id_form-1-name">Your first name?</label>
            <input type="text" name="form-1-name" required id="id_form-1-name">
        </li>
        <li>
            <label for="id_form-1-age">Age:</label>
            <input type="number" name="form-1-age" id="id_form-1-age">
            <input type="hidden" name="form-1-metadata" id="id_form-1-metadata">
        </li>
        """)


class TemplateStringIfInvalidTests(TestCase):
    '''
    Regression tests for issue #37.
    '''
    def setUp(self):
        self.original_TEMPLATE_STRING_IF_INVALID = settings.TEMPLATE_STRING_IF_INVALID

    def tearDown(self):
        settings.TEMPLATE_STRING_IF_INVALID = self.original_TEMPLATE_STRING_IF_INVALID

    def test_none(self):
        settings.TEMPLATE_STRING_IF_INVALID = None

        layout = OneFieldForm().as_p()
        self.assertHTMLEqual(layout, """
        <p><label for="id_text">Text:</label> <input type="text" name="text" id="id_text" required /></p>
        """)

    def test_non_empty(self):
        settings.TEMPLATE_STRING_IF_INVALID = InvalidVariable(u'INVALID')

        layout = OneFieldForm().as_p()
        self.assertHTMLEqual(layout, """
        <p><label for="id_text">Text:</label> <input type="text" name="text" id="id_text" required /></p>
        """)

########NEW FILE########
__FILENAME__ = modelforms
import django
from django.test import TestCase
from django.utils.unittest import skipIf

import floppyforms.__future__ as forms
from floppyforms.__future__.models import modelform_factory, modelformset_factory, inlineformset_factory

from .models import Registration, AllFields


class BaseModelFormFieldRewritingTests(object):
    '''
    A base class to mixin generic tests to check if the form fields on a
    modelform where set correctly to their floppyformic brother.

    A subclass must implement the ``get_test_object``, ``check_field`` and ``check_widget`` methods.
    '''

    def test_auto_boolean(self):
        form_obj = self.get_test_object('boolean')
        self.check_field(form_obj, 'boolean', forms.BooleanField)

    def test_auto_char(self):
        form_obj = self.get_test_object('char')
        self.check_field(form_obj, 'char', forms.CharField)

    def test_auto_comma_separated(self):
        form_obj = self.get_test_object('comma_separated')
        self.check_field(form_obj, 'comma_separated', forms.CharField)

    def test_auto_date(self):
        form_obj = self.get_test_object('date')
        self.check_field(form_obj, 'date', forms.DateField)

    def test_auto_datetime(self):
        form_obj = self.get_test_object('datetime')
        self.check_field(form_obj, 'datetime', forms.DateTimeField)

    def test_auto_decimal(self):
        form_obj = self.get_test_object('decimal')
        self.check_field(form_obj, 'decimal', forms.DecimalField)

    def test_auto_email(self):
        form_obj = self.get_test_object('email')
        self.check_field(form_obj, 'email', forms.EmailField)

    def test_auto_file_path(self):
        form_obj = self.get_test_object('file_path')
        self.check_field(form_obj, 'file_path', forms.FilePathField)

    def test_auto_float_field(self):
        form_obj = self.get_test_object('float_field')
        self.check_field(form_obj, 'float_field', forms.FloatField)

    def test_auto_integer(self):
        form_obj = self.get_test_object('integer')
        self.check_field(form_obj, 'integer', forms.IntegerField)

    def test_auto_big_integer(self):
        form_obj = self.get_test_object('big_integer')
        self.check_field(form_obj, 'big_integer', forms.IntegerField)

    def test_auto_ip_address(self):
        form_obj = self.get_test_object('ip_address')
        self.check_field(form_obj, 'ip_address', forms.IPAddressField)

    def test_auto_generic_ip_address(self):
        form_obj = self.get_test_object('generic_ip_address')
        self.check_field(form_obj, 'generic_ip_address', forms.GenericIPAddressField)

    def test_auto_null_boolean(self):
        form_obj = self.get_test_object('null_boolean')
        self.check_field(form_obj, 'null_boolean', forms.NullBooleanField)

    def test_auto_positive_integer(self):
        form_obj = self.get_test_object('positive_integer')
        self.check_field(form_obj, 'positive_integer', forms.IntegerField)

    def test_auto_positive_small_integer(self):
        form_obj = self.get_test_object('positive_small_integer')
        self.check_field(form_obj, 'positive_small_integer', forms.IntegerField)

    def test_auto_slug(self):
        form_obj = self.get_test_object('slug')
        self.check_field(form_obj, 'slug', forms.SlugField)

    def test_auto_small_integer(self):
        form_obj = self.get_test_object('small_integer')
        self.check_field(form_obj, 'small_integer', forms.IntegerField)

    def test_auto_text(self):
        form_obj = self.get_test_object('text')
        self.check_field(form_obj, 'text', forms.CharField)
        self.check_widget(form_obj, 'text', forms.Textarea)

    def test_auto_time(self):
        form_obj = self.get_test_object('time')
        self.check_field(form_obj, 'time', forms.TimeField)

    def test_auto_url(self):
        form_obj = self.get_test_object('url')
        self.check_field(form_obj, 'url', forms.URLField)

    def test_auto_file_field(self):
        form_obj = self.get_test_object('file_field')
        self.check_field(form_obj, 'file_field', forms.FileField)

    def test_auto_image(self):
        form_obj = self.get_test_object('image')
        self.check_field(form_obj, 'image', forms.ImageField)

    def test_auto_fk(self):
        form_obj = self.get_test_object('fk')
        self.check_field(form_obj, 'fk', forms.ModelChoiceField)

    def test_auto_m2m(self):
        form_obj = self.get_test_object('m2m')
        self.check_field(form_obj, 'm2m', forms.ModelMultipleChoiceField)

    def test_auto_one(self):
        form_obj = self.get_test_object('one')
        self.check_field(form_obj, 'one', forms.ModelChoiceField)

    def test_auto_choices(self):
        form_obj = self.get_test_object('choices')
        self.check_field(form_obj, 'choices', forms.TypedChoiceField)


@skipIf(django.VERSION < (1, 6), 'Only applies to Django >= 1.6')
class ModelFormTests(BaseModelFormFieldRewritingTests, TestCase):
    def get_test_object(self, field_name):
        class Form(forms.ModelForm):
            class Meta:
                model = AllFields
                fields = (field_name,)
        return Form

    def check_field(self, Form, field_name, field_class):
        self.assertIsInstance(Form.base_fields[field_name], field_class)

    def check_widget(self, Form, field_name, widget_class):
        self.assertIsInstance(Form.base_fields[field_name].widget, widget_class)


@skipIf(django.VERSION < (1, 6), 'Only applies to Django >= 1.6')
class ModelFormFactoryTests(BaseModelFormFieldRewritingTests, TestCase):
    def get_test_object(self, field_name):
        return modelform_factory(AllFields, form=forms.ModelForm,
            fields=(field_name,))

    def check_field(self, Form, field_name, field_class):
        self.assertIsInstance(Form.base_fields[field_name], field_class)

    def check_widget(self, Form, field_name, widget_class):
        self.assertIsInstance(Form.base_fields[field_name].widget, widget_class)


@skipIf(django.VERSION < (1, 6), 'Only applies to Django >= 1.6')
class ModelFormSetFactoryTests(BaseModelFormFieldRewritingTests, TestCase):
    def get_test_object(self, field_name):
        return modelformset_factory(
            AllFields,
            form=forms.ModelForm,
            fields=(field_name,))

    def check_field(self, Formset, field_name, field_class):
        self.assertIsInstance(Formset.form.base_fields[field_name], field_class)

    def check_widget(self, Formset, field_name, widget_class):
        self.assertIsInstance(Formset.form.base_fields[field_name].widget, widget_class)


@skipIf(django.VERSION < (1, 6), 'Only applies to Django >= 1.6')
class InlineFormSetFactoryTests(BaseModelFormFieldRewritingTests, TestCase):
    def get_test_object(self, field_name):
        return inlineformset_factory(
            Registration,
            AllFields,
            fk_name='fk',
            form=forms.ModelForm,
            fields=(field_name,))

    def check_field(self, Formset, field_name, field_class):
        self.assertIsInstance(Formset.form.base_fields[field_name], field_class)

    def check_widget(self, Formset, field_name, widget_class):
        self.assertIsInstance(Formset.form.base_fields[field_name].widget, widget_class)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Registration(models.Model):
    firstname = models.CharField(max_length=50)
    lastname = models.CharField(max_length=50)
    username = models.CharField(max_length=50)
    age = models.IntegerField()


class AllFields(models.Model):
    boolean = models.BooleanField(default=False)
    char = models.CharField(max_length=50)
    comma_separated = models.CommaSeparatedIntegerField(max_length=50)
    date = models.DateField()
    datetime = models.DateTimeField()
    decimal = models.DecimalField(decimal_places=2, max_digits=4)
    email = models.EmailField()
    file_path = models.FilePathField()
    float_field = models.FloatField()
    integer = models.IntegerField()
    big_integer = models.BigIntegerField()
    ip_address = models.IPAddressField()
    generic_ip_address = models.GenericIPAddressField()
    null_boolean = models.NullBooleanField()
    positive_integer = models.PositiveIntegerField()
    positive_small_integer = models.PositiveSmallIntegerField()
    slug = models.SlugField()
    small_integer = models.SmallIntegerField()
    text = models.TextField()
    time = models.TimeField()
    url = models.URLField()
    file_field = models.FileField(upload_to="test/")
    image = models.ImageField(upload_to="test/")
    fk = models.ForeignKey(Registration, related_name='all_fk')
    m2m = models.ManyToManyField(Registration, related_name='all_m2m')
    one = models.OneToOneField(Registration, related_name='all_one')
    choices = models.CharField(max_length=50, choices=(('a', 'a'),))

########NEW FILE########
__FILENAME__ = rendering
from django.test import TestCase

import floppyforms as forms

from floppyforms import widgets
from floppyforms.templatetags.floppyforms import ConfigFilter, FormConfig


class AgeField(forms.IntegerField):
    pass


class RegistrationForm(forms.Form):
    name = forms.CharField(label='First- and Lastname', max_length=50)
    email = forms.EmailField(max_length=50,
                             help_text='Please enter a valid email.')
    age = AgeField()
    short_biography = forms.CharField(max_length=200)
    comment = forms.CharField(widget=widgets.Textarea)


class FormConfigTests(TestCase):
    def test_default_retrieve(self):
        """
        Test if FormConfig returns the correct default values if no
        configuration was made.
        """
        form = RegistrationForm()
        config = FormConfig()

        # retrieve widget

        widget = config.retrieve('widget', bound_field=form['name'])
        self.assertTrue(isinstance(widget, widgets.TextInput))
        self.assertEqual(widget, form.fields['name'].widget)

        widget = config.retrieve('widget', bound_field=form['comment'])
        self.assertTrue(isinstance(widget, widgets.Textarea))
        self.assertEqual(widget, form.fields['comment'].widget)

        # retrieve widget template

        template_name = config.retrieve('widget_template', bound_field=form['name'])
        self.assertEqual(template_name, 'floppyforms/input.html')

        template_name = config.retrieve('widget_template', bound_field=form['comment'])
        self.assertEqual(template_name, 'floppyforms/textarea.html')

        # retrieve label

        label = config.retrieve('label', bound_field=form['email'])
        self.assertEqual(label, 'Email')

        label = config.retrieve('label', bound_field=form['name'])
        self.assertEqual(label, 'First- and Lastname')

        # retrieve help text

        help_text = config.retrieve('help_text', bound_field=form['name'])
        self.assertFalse(help_text)

        help_text = config.retrieve('help_text', bound_field=form['email'])
        self.assertEqual(help_text, 'Please enter a valid email.')

        # retrieve row template

        template = config.retrieve('row_template', fields=(form['name'], form['email'],))
        self.assertEqual(template, 'floppyforms/rows/default.html')

        # retrieve form layout

        template = config.retrieve('layout', forms=(form,))
        self.assertEqual(template, 'floppyforms/layouts/default.html')

    def test_configure_and_retrieve(self):
        form = RegistrationForm()

        config = FormConfig()
        widget = config.retrieve('widget', bound_field=form['comment'])
        self.assertEqual(widget.__class__, widgets.Textarea)

        config.configure('widget', widgets.TextInput(), filter=ConfigFilter('comment'))

        widget = config.retrieve('widget', bound_field=form['comment'])
        self.assertEqual(widget.__class__, widgets.TextInput)

        widget = config.retrieve('widget', bound_field=form['name'])
        self.assertEqual(widget.__class__, widgets.TextInput)

    def test_retrieve_for_multiple_valid_values(self):
        form = RegistrationForm()
        config = FormConfig()

        config.configure(
            'widget', widgets.Textarea(),
            filter=ConfigFilter('CharField'),
        )
        config.configure(
            'widget', widgets.HiddenInput(),
            filter=ConfigFilter('short_biography'),
        )

        widget = config.retrieve('widget', bound_field=form['name'])
        self.assertEqual(widget.__class__, widgets.Textarea)
        widget = config.retrieve('widget', bound_field=form['comment'])
        self.assertEqual(widget.__class__, widgets.Textarea)

        # we get HiddenInput since this was configured last, even the Textarea
        # config applies to ``short_biography``
        widget = config.retrieve('widget', bound_field=form['short_biography'])
        self.assertEqual(widget.__class__, widgets.HiddenInput)

    def test_filter_for_field_class_name(self):
        form = RegistrationForm()

        config = FormConfig()
        config.configure('widget', widgets.TextInput(), filter=ConfigFilter('CharField'))

        widget = config.retrieve('widget', bound_field=form['comment'])
        self.assertEqual(widget.__class__, widgets.TextInput)

        widget = config.retrieve('widget', bound_field=form['name'])
        self.assertEqual(widget.__class__, widgets.TextInput)

    def test_filter_for_widget_class_name(self):
        form = RegistrationForm()

        config = FormConfig()
        config.configure('widget', widgets.TextInput(), filter=ConfigFilter('Textarea'))

        widget = config.retrieve('widget', bound_field=form['comment'])
        self.assertEqual(widget.__class__, widgets.TextInput)

        widget = config.retrieve('widget', bound_field=form['name'])
        self.assertEqual(widget.__class__, widgets.TextInput)

        # swap widgets TextInput <> Textarea

        config = FormConfig()
        config.configure('widget', widgets.Textarea(), filter=ConfigFilter('TextInput'))
        config.configure('widget', widgets.TextInput(), filter=ConfigFilter('Textarea'))

        widget = config.retrieve('widget', bound_field=form['comment'])
        self.assertEqual(widget.__class__, widgets.TextInput)

        widget = config.retrieve('widget', bound_field=form['name'])
        self.assertEqual(widget.__class__, widgets.Textarea)

    def test_filter_for_name_object(self):
        form = RegistrationForm()

        config = FormConfig()
        config.configure('widget', widgets.Textarea(), filter=ConfigFilter('object'))

        widget = config.retrieve('widget', bound_field=form['email'])
        self.assertEqual(widget.__class__, widgets.EmailInput)

        widget = config.retrieve('widget', bound_field=form['name'])
        self.assertEqual(widget.__class__, widgets.TextInput)

        widget = config.retrieve('widget', bound_field=form['comment'])
        self.assertEqual(widget.__class__, widgets.Textarea)

    def test_stacked_config(self):
        form = RegistrationForm()
        config = FormConfig()

        config.push()
        config.configure(
            'widget', widgets.Textarea(),
            filter=ConfigFilter("CharField"),
        )

        config.push()
        config.configure(
            'widget', widgets.HiddenInput(),
            filter=ConfigFilter('short_biography'),
        )

        widget = config.retrieve('widget', bound_field=form['short_biography'])
        self.assertEqual(widget.__class__, widgets.HiddenInput)

        config.pop()
        widget = config.retrieve('widget', bound_field=form['short_biography'])
        self.assertEqual(widget.__class__, widgets.Textarea)

        config.pop()
        widget = config.retrieve('widget', bound_field=form['short_biography'])
        self.assertEqual(widget.__class__, widgets.TextInput)

    def test_field_filter_works_on_subclasses(self):
        form = RegistrationForm()
        config = FormConfig()

        config.configure(
            'widget', widgets.HiddenInput(),
            filter=ConfigFilter("IntegerField"),
        )

        widget = config.retrieve('widget', bound_field=form['age'])
        self.assertEqual(widget.__class__, widgets.HiddenInput)

    def test_retrieve_all(self):
        config = FormConfig()

        config.configure('number', 1)
        config.configure('number', 2)
        self.assertEqual(list(config.retrieve_all('number')), [2, 1])

        config.configure('number', 4, filter=lambda nr=None, **kwargs: nr == 'four')
        self.assertEqual(list(config.retrieve_all('number')), [2, 1])
        self.assertEqual(list(config.retrieve_all('number', nr='four')), [4, 2, 1])

        config.push()
        config.configure('number', 5, filter=lambda nr=None, **kwargs: nr == 'five')
        self.assertEqual(list(config.retrieve_all('number')), [2, 1])
        self.assertEqual(list(config.retrieve_all('number', nr='five')), [5, 2, 1])

        config.configure('number', -1)
        self.assertEqual(list(config.retrieve_all('number')), [-1, 2, 1])
        self.assertEqual(list(config.retrieve_all('number', nr='four')), [-1, 4, 2, 1])
        self.assertEqual(list(config.retrieve_all('number', nr='five')), [-1, 5, 2, 1])

        config.pop()
        self.assertEqual(list(config.retrieve_all('number')), [2, 1])
        self.assertEqual(list(config.retrieve_all('number', nr='four')), [4, 2, 1])
        self.assertEqual(list(config.retrieve_all('number', nr='five')), [2, 1])

########NEW FILE########
__FILENAME__ = settings
import warnings
warnings.simplefilter('always')

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'floppyforms.sqlite',
    },
}

USE_I18N = True
USE_L10N = True

INSTALLED_APPS = [
    'django.contrib.gis',
    'floppyforms',
    'tests',
]

STATIC_URL = '/static/'

SECRET_KEY = '0'

import django
if django.VERSION < (1, 6):
    TEST_RUNNER = 'discover_runner.DiscoverRunner'

########NEW FILE########
__FILENAME__ = templatetags
import django
from django.forms import TextInput
from django.forms.formsets import formset_factory
from django.template import Context, Template, TemplateSyntaxError
from django.test import TestCase

import floppyforms as forms
from floppyforms.templatetags.floppyforms import (FormConfig, ConfigFilter,
                                                  FormNode, RowModifier,
                                                  FieldModifier)


_TEMPLATE_PREAMBLE = '{% load floppyforms %}'
if django.VERSION >= (1, 6):
    _TEMPLATE_PREAMBLE += '{% load firstof from future %}'
    _TEMPLATE_PREAMBLE += '{% load cycle from future %}'


def render(template, context=None, config=None):
    if context is None:
        context = {}
    if not hasattr(context, 'dicts'):
        context = Context(context)
    if config is not None:
        setattr(context, FormNode.CONFIG_CONTEXT_ATTR, config)
    t = Template(_TEMPLATE_PREAMBLE + template)
    return t.render(context)


def render_in_form(template, context=None):
    template = '{% load floppyforms %}{% form myform using %}' + template + '{% endform %}'
    return render(template, context)


def compile_to_nodelist(template):
    rendered_template = Template(
        '{% load floppyforms %}{% form myform using %}' + template + '{% endform %}')
    form_node = rendered_template.nodelist[1]
    return form_node.options['nodelist'][0]


class SimpleForm(forms.Form):
    name = forms.CharField()


class PersonForm(forms.Form):
    firstname = forms.CharField()
    lastname = forms.CharField()
    age = forms.IntegerField()
    bio = forms.CharField(widget=forms.Textarea)


class HardcodedWidget(forms.Widget):
    def render(self, *args, **kwargs):
        return u'Hardcoded widget.'


class HardcodedForm(forms.Form):
    name = forms.CharField(widget=HardcodedWidget())


class FormConfigNodeTests(TestCase):
    def test_enforce_form_tag(self):
        render('{% form myform using %}{% formconfig row using "my_row_template.html" %}{% endform %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formconfig row using "my_row_template.html" %}')
        render('{% form myform using %}{% formconfig field using "my_row_template.html" %}{% endform %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formconfig field using "my_row_template.html" %}')

    def test_valid_syntax(self):
        render_in_form('{% formconfig row using "my_row_template.html" %}')
        render_in_form('{% formconfig row using "my_row_template.html" with myarg="bar" %}')
        render_in_form('{% formconfig row with myarg="bar" %}')

        render_in_form('{% formconfig field using "field.html" %}')
        render_in_form('{% formconfig field using "field.html" with myarg="bar" %}')
        render_in_form('{% formconfig field with myarg="bar" %}')
        render_in_form('{% formconfig field using "field.html" for "spam" %}')
        render_in_form('{% formconfig field using "field.html" for myvar %}')
        render_in_form('{% formconfig field using template %}')

    def test_invalid_syntax(self):
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig row %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig row myarg="bar" %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig row with %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig row with only %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig row using "my_row_template.html" for "spam" %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig field %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig field myarg="bar" %}')
        with self.assertRaises(TemplateSyntaxError):
            # wrong argument order
            render_in_form('{% formconfig field with myarg="bar" using "field.html" %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig non_existent_modifier %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig non_existent_modifier with option=1 %}')

        # only is not allowed in formconfig
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig row with myarg="bar" only %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig row using "my_row_template.html" only %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig field with myarg="bar" only %}')
        with self.assertRaises(TemplateSyntaxError):
            render_in_form('{% formconfig field using "field.html" only %}')

    def test_row_config(self):
        rowconfig = compile_to_nodelist('{% formconfig row using "my_row_template.html" %}')
        self.assertTrue(isinstance(rowconfig, RowModifier))

        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True})
        rowconfig.render(context)
        self.assertTrue(hasattr(context, '_form_config'))

    def test_row_config_using(self):
        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True})
        node = compile_to_nodelist(
            '{% formconfig row using "my_row_template.html" %}')
        node.render(context)
        config = node.get_config(context)
        self.assertEqual(config.retrieve('row_template'), 'my_row_template.html')

        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True})
        node = compile_to_nodelist('{% formconfig row using empty_var %}')
        node.render(context)
        config = node.get_config(context)
        self.assertEqual(config.retrieve('row_template'), 'floppyforms/rows/default.html')

    def test_row_config_with(self):
        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True})
        node = compile_to_nodelist('{% formconfig row with extra_class="fancy" %}')
        node.render(context)
        config = node.get_config(context)
        extra_context = config.retrieve('row_context')
        self.assertTrue(extra_context)
        self.assertTrue(extra_context['extra_class'], 'fancy')

    def test_field_config(self):
        rowconfig = compile_to_nodelist(
            '{% formconfig field with extra_class="fancy" %}')
        self.assertTrue(isinstance(rowconfig, FieldModifier))

        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True})
        rowconfig.render(context)
        self.assertTrue(hasattr(context, '_form_config'))

    def test_field_config_using(self):
        form = SimpleForm()

        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True})
        node = compile_to_nodelist('{% formconfig field using "field.html" %}')
        node.render(context)
        config = node.get_config(context)
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['name']),
            'field.html')

        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True})
        node = compile_to_nodelist('{% formconfig field using empty_var %}')
        node.render(context)
        config = node.get_config(context)
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['name']),
            'floppyforms/input.html')

    def test_field_config_with(self):
        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True})
        node = compile_to_nodelist('{% formconfig field with type="email" %}')
        node.render(context)
        config = node.get_config(context)
        extra_context = config.retrieve('widget_context')
        self.assertTrue(extra_context)
        self.assertTrue(extra_context['type'], 'email')

    def test_field_config_for_bound_field(self):
        form = PersonForm()
        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True, 'form': form})

        node = compile_to_nodelist('{% formconfig field using "field.html" for form.lastname %}')
        node.render(context)
        config = node.get_config(context)
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['firstname']),
            'floppyforms/input.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['lastname']),
            'field.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['age']),
            'floppyforms/input.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['bio']),
            'floppyforms/textarea.html')

    def test_field_config_for_field_name(self):
        form = PersonForm()
        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True, 'form': form})

        node = compile_to_nodelist('{% formconfig field using "field.html" for "firstname" %}')
        node.render(context)
        config = node.get_config(context)
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['firstname']),
            'field.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['lastname']),
            'floppyforms/input.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['age']),
            'floppyforms/input.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['bio']),
            'floppyforms/textarea.html')

    def test_field_config_for_field_type(self):
        form = PersonForm()
        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True, 'form': form})

        node = compile_to_nodelist('{% formconfig field using "field.html" for "IntegerField" %}')
        node.render(context)
        config = node.get_config(context)
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['firstname']),
            'floppyforms/input.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['lastname']),
            'floppyforms/input.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['age']),
            'field.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['bio']),
            'floppyforms/textarea.html')

    def test_field_config_for_widget_type(self):
        form = PersonForm()
        context = Context({FormNode.IN_FORM_CONTEXT_VAR: True, 'form': form})

        node = compile_to_nodelist('{% formconfig field using "field.html" for "Textarea" %}')
        node.render(context)
        config = node.get_config(context)
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['firstname']),
            'floppyforms/input.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['lastname']),
            'floppyforms/input.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['age']),
            'floppyforms/input.html')
        self.assertEqual(
            config.retrieve('widget_template', bound_field=form['bio']),
            'field.html')


class FormTagTests(TestCase):
    def test_valid_syntax(self):
        render('{% form myform %}')
        render('{% form myform using "myform_layout.html" %}')
        render('{% form myform secondform %}')
        render('{% form myform using %}{% endform %}')
        render('{% form myform secondform using %}{% endform %}')
        render('{% form myform secondform thirdform %}')
        render('{% form myform secondform thirdform using "myform_layout.html" with arg=value %}')
        render('{% form myform secondform thirdform using "myform_layout.html" only %}')
        render('{% form myform secondform thirdform using "myform_layout.html" with arg=value only %}')

    def test_invalid_syntax(self):
        with self.assertRaises(TemplateSyntaxError):
            render('{% form %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form using %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form myform using "myform_layout.html" with %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form myform using "myform_layout.html" with only %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form myform using "myform_layout.html" only with arg=value %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form using %}{% endform %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form myform using "myform_layout.html" too_many_arguments %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form myform %}{% endform %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form myform using "myform_layout.html" %}{% endform %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form myform using "myform_layout.html" only %}{% endform %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% form myform using "myform_layout.html" with arg=value %}{% endform %}')

    def test_inline_content(self):
        self.assertHTMLEqual(
            render('{% form myform using %}foo{% endform %}'), 'foo')
        self.assertHTMLEqual(render("""
            {% form myform using %}
                {% if 1 %}True{% else %}False{% endif %}
            {% endform %}
            """), 'True')
        # don't leak variables into outer scope
        self.assertHTMLEqual(render("""
            {% form myform using %}
                <ins>{% cycle "foo" "bar" as value %}</ins>
            {% endform %}
            <del>{% firstof value "NO VALUE" %}</del>
            """), '<ins>foo</ins><del>NO VALUE</del>')
        # form variable equals the first argument in form tag
        self.assertHTMLEqual(render("""
            {% form myform using %}{% if myform == form %}Equals!{% endif %}{% endform %}
            """, {'myform': SimpleForm()}), 'Equals!')
        self.assertHTMLEqual(render("""
            {% form f1 f2 using %}
                {% if f1 == forms.0 and f2 == forms.1 and f1 != f2 %}
                    Equals!
                {% endif %}
            {% endform %}
            """, {'f1': SimpleForm(), 'f2': SimpleForm()}), 'Equals!')

        # none forms are not included in form list
        self.assertHTMLEqual(
            render("""
            {% form f1 nothing f2 more_of_nothing using %}
                {% if f1 == forms.0 and f2 == forms.1 %}
                {% if forms.2 == None and more_of_nothing == None %}
                    Equals!
                {% endif %}
                {% endif %}
                Length: {{ forms|length }}
            {% endform %}""", {
                'f1': SimpleForm(),  # noqa
                'f2': SimpleForm()
            }), 'Equals! Length: 2')

    def test_include_content(self):
        with self.assertTemplateUsed('simple_form_tag.html'):
            self.assertHTMLEqual(
                render('{% form myform using "simple_form_tag.html" %}', {
                    'myform': PersonForm(),
                }), """
                Forms: 1
                1. Form Fields: firstname lastname age bio
                """)
        with self.assertTemplateUsed('simple_form_tag.html'):
            self.assertHTMLEqual(
                render('{% form f1 non f2 using "simple_form_tag.html" %}', {
                    'f1': SimpleForm(),
                    'f2': PersonForm(),
                }), """
                Forms: 2
                1. Form Fields: name
                2. Form Fields: firstname lastname age bio
                """)

    def test_include_content_with_extra_arguments(self):
        with self.assertTemplateUsed('simple_form_tag.html'):
            self.assertHTMLEqual(
                render('{% form myform using "simple_form_tag.html" with extra_argument="spam" %}', {
                    'myform': PersonForm(),
                }), """
                Forms: 1
                1. Form Fields: firstname lastname age bio
                Extra argument: spam
                """)
        with self.assertTemplateUsed('simple_form_tag.html'):
            self.assertHTMLEqual(
                render('{% form myform using "simple_form_tag.html" with extra_argument=0 %}', {
                    'myform': PersonForm(),
                }), """
                Forms: 1
                1. Form Fields: firstname lastname age bio
                """)
        with self.assertTemplateUsed('simple_form_tag.html'):
            self.assertHTMLEqual(
                render("""
                    {% with extra_argument="ham" %}
                        {% form myform using "simple_form_tag.html" %}
                    {% endwith %}
                    """, {'myform': PersonForm()}),
                """
                Forms: 1
                1. Form Fields: firstname lastname age bio
                Extra argument: ham
                """)
        with self.assertTemplateUsed('simple_form_tag.html'):
            self.assertHTMLEqual(
                render("""
                    {% with extra_argument="ham" %}
                        {% form myform using "simple_form_tag.html" only %}
                    {% endwith %}
                    """, {'myform': PersonForm()}),
                """
                Forms: 1
                1. Form Fields: firstname lastname age bio
                """)
        with self.assertTemplateUsed('simple_form_tag.html'):
            self.assertHTMLEqual(
                render("""
                    {% with extra_argument="spam" %}
                        {% form myform using "simple_form_tag.html" with extra_argument=0 %}
                    {% endwith %}
                    """, {'myform': PersonForm()}),
                """
                Forms: 1
                1. Form Fields: firstname lastname age bio
                """)

    def test_default_template(self):
        with self.assertTemplateUsed('floppyforms/layouts/default.html'):
            render('{% form myform %}')

    def test_form_list_as_argument(self):
        form1 = PersonForm()
        form2 = SimpleForm()
        form_list = [form1, form2, form2]
        self.assertHTMLEqual(
            render('{% form forms using "simple_form_tag.html" %}', {
                'forms': form_list,
            }), """
            Forms: 3
            1. Form Fields: firstname lastname age bio
            2. Form Fields: name
            3. Form Fields: name
            """)

    def test_formset_rendering(self):
        PersonFormSet = formset_factory(PersonForm, extra=3)
        formset = PersonFormSet()
        self.assertHTMLEqual(
            render('{% form formset using "simple_form_tag.html" %}', {
                'formset': formset,
            }), """
            Forms: 3
            1. Form Fields: firstname lastname age bio
            2. Form Fields: firstname lastname age bio
            3. Form Fields: firstname lastname age bio
            """)

        formset = PersonFormSet(initial=[{}, {}])
        self.assertHTMLEqual(
            render('{% form formset using "simple_form_tag.html" %}', {
                'formset': formset,
            }), """
            Forms: 5
            1. Form Fields: firstname lastname age bio
            2. Form Fields: firstname lastname age bio
            3. Form Fields: firstname lastname age bio
            4. Form Fields: firstname lastname age bio
            5. Form Fields: firstname lastname age bio
            """)

    def test_formconfig_gets_popped_after_form_tag(self):
        form = PersonForm()
        rendered = render('''{% form form using %}
            {% formconfig row with extra_argument="first argument" %}
            {% formrow form.firstname using "simple_formrow_tag.html" %}
            {% form form using %}
                {% formconfig row with extra_argument="pop me" %}
                {% formrow form.lastname using "simple_formrow_tag.html" %}
                {% formrow argument|if:forloop.last|else:None %}
            {% endform %}
            {% formrow form.lastname using "simple_formrow_tag.html" %}
        {% endform %}''', {'form': form})
        self.assertHTMLEqual(rendered, '''
        Fields: 1
        1. Field: firstname Extra argument: first argument

        Fields: 1
        1. Field: lastname Extra argument: pop me

        Fields: 1
        1. Field: lastname Extra argument: first argument
        ''')

    def test_formconfig_inside_only(self):
        form = PersonForm()
        rendered = render('''{% form form using "formconfig_inside_only.html" with form=form only  %}''', {'form': form})
        self.assertHTMLEqual(rendered, '''
        Fields: 1
        1. Field: firstname Extra argument: first argument
        ''')


class FormRowTagTests(TestCase):
    def test_valid_syntax(self):
        render('{% formrow myform.field %}')
        render('{% formrow myform.field using "myrow_layout.html" %}')
        render('{% formrow myform.field secondfield %}')
        render('{% formrow myform.field secondfield thirdfield %}')
        render('{% formrow myform.field secondfield thirdfield using "myform_layout.html" with arg=value %}')
        render('{% formrow myform.field secondfield thirdfield using "myform_layout.html" only %}')
        render('{% formrow myform.field secondfield thirdfield using "myform_layout.html" with arg=value only %}')

    def test_invalid_syntax(self):
        with self.assertRaises(TemplateSyntaxError):
            render('{% formrow %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formrow using %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formrow myform.name using %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formrow myform.name using "myform_layout.html" with %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formrow myform.name using "myform_layout.html" with only %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formrow myform.name using "myform_layout.html" only with arg=value %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formrow myform.name using "myform_layout.html" too_many_arguments %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formrow myform.name using %}{% endformrow %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formrow myform.name using %}{% endform %}')

    def test_include_content(self):
        with self.assertTemplateUsed('simple_formrow_tag.html'):
            self.assertHTMLEqual(
                render('{% formrow myform.lastname using "simple_formrow_tag.html" %}', {
                    'myform': PersonForm(),
                }), """
                Fields: 1
                1. Field: lastname
                """)
        with self.assertTemplateUsed('simple_formrow_tag.html'):
            self.assertHTMLEqual(
                render('{% formrow person.age simple.non simple.name using "simple_formrow_tag.html" %}', {
                    'simple': SimpleForm(),
                    'person': PersonForm(),
                }), """
                Fields: 2
                1. Field: age
                2. Field: name
                """)

    def test_include_content_with_extra_arguments(self):
        with self.assertTemplateUsed('simple_formrow_tag.html'):
            self.assertHTMLEqual(
                render('{% formrow myform.firstname using "simple_formrow_tag.html" with extra_argument="spam" %}', {
                    'myform': PersonForm(),
                }), """
                Fields: 1
                1. Field: firstname
                Extra argument: spam
                """)
        with self.assertTemplateUsed('simple_formrow_tag.html'):
            self.assertHTMLEqual(
                render('{% formrow myform.age using "simple_formrow_tag.html" with extra_argument=0 %}', {
                    'myform': PersonForm(),
                }), """
                Fields: 1
                1. Field: age
                """)
        with self.assertTemplateUsed('simple_formrow_tag.html'):
            self.assertHTMLEqual(
                render("""
                    {% with extra_argument="ham" %}
                        {% formrow myform.lastname using "simple_formrow_tag.html" %}
                    {% endwith %}
                    """, {'myform': PersonForm()}),
                """
                Fields: 1
                1. Field: lastname
                Extra argument: ham
                """)
        with self.assertTemplateUsed('simple_formrow_tag.html'):
            self.assertHTMLEqual(
                render("""
                    {% with extra_argument="ham" %}
                        {% formrow myform.firstname using "simple_formrow_tag.html" only %}
                    {% endwith %}
                    """, {'myform': PersonForm()}),
                """
                Fields: 1
                1. Field: firstname
                """)
        with self.assertTemplateUsed('simple_formrow_tag.html'):
            self.assertHTMLEqual(
                render("""
                    {% with extra_argument="spam" %}
                        {% formrow myform.firstname using "simple_formrow_tag.html" with extra_argument=0 %}
                    {% endwith %}
                    """, {'myform': PersonForm()}),
                """
                Fields: 1
                1. Field: firstname
                """)

    def test_default_template(self):
        with self.assertTemplateUsed('floppyforms/rows/default.html'):
            render('{% formrow myform.name %}')

    def test_configure_template(self):
        with self.assertTemplateUsed('simple_formrow_tag.html'):
            render("""{% form myform using %}
                {% formconfig row using "simple_formrow_tag.html" %}
                {% formrow form.name %}
            {% endform %}""")

    def test_configure_template_with_extra_context(self):
        with self.assertTemplateUsed('simple_formrow_tag.html'):
            self.assertHTMLEqual(render("""{% form myform using %}
                {% formconfig row using "simple_formrow_tag.html" %}
                {% formrow form.name with extra_argument="I want ham!" %}
            {% endform %}"""), "Fields: 0 Extra argument: I want ham!")

    def test_configure_extra_context(self):
        self.assertHTMLEqual(render("""{% form myform using %}
            {% formconfig row with extra_argument="I want spam!" %}
            {% formconfig row with extra_argument="I want ham!" %}
            {% formrow form.name using "simple_formrow_tag.html" %}
        {% endform %}"""), "Fields: 0 Extra argument: I want ham!")

        self.assertHTMLEqual(render("""{% form myform using %}
            {% formconfig row using "simple_formrow_tag.html" with extra_argument="I want ham!" %}
            {% formrow form.name %}
        {% endform %}"""), "Fields: 0 Extra argument: I want ham!")

    def test_field_list_as_argument(self):
        form = PersonForm()
        self.assertHTMLEqual(render("""{% form myform using %}
            {% formrow form using "simple_formrow_tag.html" %}
        {% endform %}""", {'myform': form}), """
            Fields: 4
            1. Field: firstname
            2. Field: lastname
            3. Field: age
            4. Field: bio
        """)

        form = PersonForm()
        self.assertHTMLEqual(render("""{% form myform using %}
            {% formrow form.lastname form None form.firstname using "simple_formrow_tag.html" %}
        {% endform %}""", {'myform': form}), """
            Fields: 6
            1. Field: lastname
            2. Field: firstname
            3. Field: lastname
            4. Field: age
            5. Field: bio
            6. Field: firstname
        """)

    def test_formconfig_gets_popped_after_formrow_tag(self):
        '''
        Tests that the form config will be reseted after being set in a
        ``formrow`` tag.
        '''
        form = SimpleForm()
        rendered = render('''{% form form using %}
            {% formconfig row with extra_argument="first argument" %}
            {% formrow form.name using "simple_formrow_tag_with_config.html" %}
            {% formrow form.name using "simple_formrow_tag.html" %}
        {% endform %}''', {'form': form})
        self.assertHTMLEqual(rendered, '''
        Fields: 1
        1. Field: name argument: defined inline
        Extra argument: first argument

        Fields: 1
        1. Field: name
        Extra argument: first argument
        ''')


class FormFieldTagTests(TestCase):
    def test_valid_syntax(self):
        render('{% formfield myform.name %}')

    def test_unvalid_syntax(self):
        with self.assertRaises(TemplateSyntaxError):
            render('{% formfield %}')
        with self.assertRaises(TemplateSyntaxError):
            render('{% formfield myform.firstname myform.lastname %}')

    def test_render_empty_value(self):
        self.assertEqual(render('{% formfield myform.name %}'), '')

    def test_widget_template(self):
        with self.assertTemplateUsed('floppyforms/input.html'):
            render('{% formfield myform.name %}', {'myform': SimpleForm()})
        with self.assertTemplateUsed('simple_formfield_tag.html'):
            render('{% formfield myform.name using "simple_formfield_tag.html" %}', {'myform': SimpleForm()})

    def test_outer_scope(self):
        self.assertHTMLEqual(render("""
            {% with "yepyep" as extra_argument %}
            {% formfield myform.name using "simple_formfield_tag.html" %}
            {% endwith %}
        """, {'myform': SimpleForm()}), 'Type: text Extra argument: yepyep')

    def test_only_option(self):
        self.assertHTMLEqual(render("""
            {% with "yepyep" as extra_argument %}
            {% formfield myform.name using "simple_formfield_tag.html" only %}
            {% endwith %}
        """, {'myform': SimpleForm()}), 'Type: text')

    def test_configure_template_with_extra_context(self):
        form = SimpleForm()
        with self.assertTemplateUsed('simple_formfield_tag.html'):
            self.assertHTMLEqual(
                render("""{% form myform using %}
                {% formconfig field using "simple_formfield_tag.html" %}
                {% formfield form.name with extra_argument="I want bacon!" %}
            {% endform %}""", {'myform': form}),
                "Type: text Extra argument: I want bacon!")

    def test_configure_extra_context(self):
        form = SimpleForm()
        self.assertHTMLEqual(
            render("""{% form myform using %}
            {% formconfig field with extra_argument="I want spam!" %}
            {% formconfig field with extra_argument="I want ham!" %}
            {% formfield form.name using "simple_formfield_tag.html" %}
        {% endform %}""", {'myform': form}),
            "Type: text Extra argument: I want ham!")

        context = Context({'myform': form})
        self.assertHTMLEqual(
            render("""{% form myform using %}
            {% formconfig field using "simple_formfield_tag.html" with extra_argument="I want ham!" %}
            {% formfield form.name %}
        {% endform %}""", context),
            "Type: text Extra argument: I want ham!")

    def test_change_widget(self):
        form = SimpleForm()
        config = FormConfig()
        config.configure('widget', forms.PasswordInput(), filter=ConfigFilter(form['name']))

        self.assertHTMLEqual(render("""{% form myform using %}
            {% formfield form.name %}
        {% endform %}""", {'myform': form}, config), """<input type="password" name="name" id="id_name" />""")

    def test_hardcoded_widget(self):
        form = HardcodedForm()
        self.assertHTMLEqual(render("""{% form myform using %}
            {% formfield form.name %}
        {% endform %}""", {'myform': form}), """Hardcoded widget.""")

    def test_formconfig_gets_popped_after_formfield_tag(self):
        '''
        Tests that the form config will be reseted after being set in a
        ``formfield`` tag.
        '''
        form = SimpleForm()
        rendered = render('''{% form form using %}
            {% formconfig field with extra_argument="first argument" %}
            {% formfield form.name using "extra_argument_with_config.html" with prefix="1." %}
            {% formfield form.name using "extra_argument.html" with prefix="2." %}
        {% endform %}''', {'form': form})
        self.assertHTMLEqual(rendered, '''
        1. argument: first argument
        2. argument: first argument
        ''')


class WidgetTagTest(TestCase):
    def test_widget_tag(self):
        class MediaWidget(forms.TextInput):
            template_name = 'media_widget.html'

        class TestForm(forms.Form):
            test = forms.CharField(widget=MediaWidget)
            test2 = forms.CharField(widget=TextInput)

        self.assertHTMLEqual(render("""
        {% for field in form %}
            {% widget field %}
        {% endfor %}""", {'form': TestForm(), 'STATIC_URL': '/static/'}), """
        <input type="text" name="test" id="id_test" required>
        <script type="text/javascript" src="/static/foo.js"></script>
        <input type="text" name="test2" id="id_test2">""")

        with self.assertRaises(TemplateSyntaxError):
            render("""{% widget %}""")

        with self.assertRaises(TemplateSyntaxError):
            render("""{% widget stuff 12 %}""")

########NEW FILE########
__FILENAME__ = tests
# flake8: noqa
from .deprecations import *
from .forms import *
from .gis import GisTests
from .modelforms import *
from .layouts import *
from .rendering import *
from .templatetags import *
from .widgets import *
from .fields import *

########NEW FILE########
__FILENAME__ = widgets
import datetime
import os

from django.core.files.uploadedfile import SimpleUploadedFile
from django.db import models
from django.template import Context, Template
from django.template.loader import render_to_string
from django.test import TestCase
from django.test.utils import override_settings
from django.utils.dates import MONTHS
from django.utils.encoding import python_2_unicode_compatible
from django.utils.timezone import now

import floppyforms as forms

from .base import InvalidVariable


@python_2_unicode_compatible
class SomeModel(models.Model):
    some_field = models.CharField(max_length=255)

    def __str__(self):
        return u'%s' % self.some_field


class WidgetRenderingTest(TestCase):
    """Testing the rendering of the different widgets."""
    maxDiff = None

    def test_text_input(self):
        """<input type="text">"""
        class TextForm(forms.Form):
            text = forms.CharField(label='My text field')

        rendered = TextForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_text">My text field:</label>
            <input type="text" name="text" id="id_text" required>
        </p>""")

        form = TextForm(data={'text': ''})
        self.assertFalse(form.is_valid())

        form = TextForm(data={'text': 'some text'})
        self.assertTrue(form.is_valid())

        class TextForm(forms.Form):
            text = forms.CharField(required=False)

        rendered = TextForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_text">Text:</label>
            <input type="text" name="text" id="id_text">
        </p>""")

        class TextForm(forms.Form):
            text = forms.CharField(
                widget=forms.TextInput(attrs={'placeholder': 'Heheheh'})
            )

        rendered = TextForm(initial={'text': 'some initial text'}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_text">Text:</label>
            <input type="text" name="text" id="id_text" value="some initial text" placeholder="Heheheh" required>
        </p>""")

        invalid = lambda: forms.CharField(max_length=5).clean('foo bar')
        self.assertRaises(forms.ValidationError, invalid)

        class TextForm(forms.Form):
            text = forms.CharField(max_length=2)

        self.assertFalse(TextForm(data={'text': 'foo'}).is_valid())

        # Bug #7 - values should be passed as unicode strings
        rendered = TextForm(data={'text': 0}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_text">Text:</label>
            <input type="text" name="text" id="id_text" value="0" required maxlength="2">
        </p>""")

    def test_password(self):
        """<input type="password">"""
        class PwForm(forms.Form):
            pw = forms.CharField(widget=forms.PasswordInput)

        rendered = PwForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_pw">Pw:</label>
            <input type="password" name="pw" id="id_pw" required>
        </p>""")

        class PwForm(forms.Form):
            text = forms.CharField()
            pw = forms.CharField(widget=forms.PasswordInput)

        form = PwForm(data={'pw': 'some-pwd'})
        self.assertFalse(form.is_valid())  # missing text
        rendered = form.as_p()
        self.assertHTMLEqual(rendered, """
        <ul class="errorlist">
            <li>This field is required.</li>
        </ul>
        <p>
            <label for="id_text">Text:</label>
            <input type="text" name="text" id="id_text" required>
        </p>
        <p>
            <label for="id_pw">Pw:</label>
            <input type="password" name="pw" id="id_pw" required>
        </p>""")

        class PwForm(forms.Form):
            text = forms.CharField()
            pw = forms.CharField(
                widget=forms.PasswordInput(render_value=True)
            )

        form = PwForm(data={'pw': 'some-pwd'})
        self.assertFalse(form.is_valid())  # missing text
        rendered = form.as_p()
        self.assertHTMLEqual(rendered, """
        <ul class="errorlist">
            <li>This field is required.</li>
        </ul>
        <p>
            <label for="id_text">Text:</label>
            <input type="text" name="text" id="id_text" required>
        </p>
        <p>
            <label for="id_pw">Pw:</label>
            <input type="password" name="pw" id="id_pw" required value="some-pwd">
        </p>""")

    def test_hidden(self):
        """<input type="hidden">"""
        class HiddenForm(forms.Form):
            hide = forms.CharField(widget=forms.HiddenInput())

        rendered = HiddenForm().as_p()
        self.assertHTMLEqual(rendered, """
        <input type="hidden" name="hide" id="id_hide" required>
        """)

        form = HiddenForm(data={'hide': 'what for?'})
        self.assertTrue(form.is_valid())
        rendered = form.as_p()
        self.assertHTMLEqual(rendered, """
        <input type="hidden" name="hide" id="id_hide" required value="what for?">
        """)

    def test_textarea(self):
        """<textarea>"""

        class TextForm(forms.Form):
            text = forms.CharField(widget=forms.Textarea)

        rendered = TextForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_text">Text:</label>
            <textarea name="text" id="id_text" cols="40" rows="10" required></textarea>
        </p>
        """)

        class TextForm(forms.Form):
            text = forms.CharField(
                widget=forms.Textarea(attrs={'rows': 42, 'cols': 55})
            )

        rendered = TextForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_text">Text:</label>
            <textarea name="text" id="id_text" rows="42" cols="55" required></textarea>
        </p>
        """)

    def test_file(self):
        """"<input type="file">"""
        class FileForm(forms.Form):
            file_ = forms.FileField()

        rendered = FileForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_file_">File :</label>
            <input type="file" name="file_" id="id_file_" required>
        </p>
        """)

        class FileForm(forms.Form):
            file_ = forms.FileField(required=False)

        rendered = FileForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_file_">File :</label>
            <input type="file" name="file_" id="id_file_">
        </p>
        """)

    def test_date(self):
        """<input type="date">"""
        class DateForm(forms.Form):
            date = forms.DateField()

        rendered = DateForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_date">Date:</label>
            <input type="date" name="date" id="id_date" required>
        </p>
        """)

    def test_datetime(self):
        """<input type="datetime">"""
        class DateTimeForm(forms.Form):
            date = forms.DateTimeField()

        rendered = DateTimeForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_date">Date:</label>
            <input type="datetime" name="date" id="id_date" required>
        </p>
        """)

    def test_time(self):
        """<input type="time">"""
        class TimeForm(forms.Form):
            date = forms.TimeField()

        rendered = TimeForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_date">Date:</label>
            <input type="time" name="date" id="id_date" required>
        </p>
        """)

    def test_search(self):
        """<input type="search">"""
        class SearchForm(forms.Form):
            query = forms.CharField(widget=forms.SearchInput)

        rendered = SearchForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_query">Query:</label>
            <input type="search" name="query" id="id_query" required>
        </p>
        """)

    def test_email(self):
        """<input type="email">"""
        class EmailForm(forms.Form):
            email = forms.EmailField()

        rendered = EmailForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_email">Email:</label>
            <input type="email" name="email" id="id_email" required>
        </p>
        """)

        form = EmailForm(data={'email': 'foo@bar.com'})
        self.assertTrue(form.is_valid())
        form = EmailForm(data={'email': 'lol'})
        self.assertFalse(form.is_valid())

    def test_url(self):
        """<input type="url">"""
        class URLForm(forms.Form):
            url = forms.URLField()

        rendered = URLForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_url">Url:</label>
            <input type="url" name="url" id="id_url" required>
        </p>
        """)

        form = URLForm(data={'url': 'http://example.com'})
        self.assertTrue(form.is_valid())
        form = URLForm(data={'url': 'com'})
        self.assertFalse(form.is_valid())

    def test_color(self):
        """<input type="color">"""
        class ColorForm(forms.Form):
            color = forms.CharField(widget=forms.ColorInput)

        rendered = ColorForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_color">Color:</label>
            <input type="color" name="color" id="id_color" required>
        </p>
        """)

    def test_number(self):
        """<input type="number">"""
        class NumberForm(forms.Form):
            num = forms.DecimalField()

        rendered = NumberForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_num">Num:</label>
            <input type="number" name="num" id="id_num" required>
        </p>
        """)

        form = NumberForm(data={'num': 10})
        self.assertTrue(form.is_valid())
        form = NumberForm(data={'num': 'meh'})
        self.assertFalse(form.is_valid())

        class NumberForm(forms.Form):
            num = forms.DecimalField(
                widget=forms.NumberInput(attrs={'min': 5, 'max': 10})
            )

        rendered = NumberForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_num">Num:</label>
            <input type="number" name="num" id="id_num" required min="5" max="10">
        </p>
        """)

        class NumInput(forms.NumberInput):
            min = 9
            max = 99
            step = 10

        class NumberForm(forms.Form):
            num = forms.DecimalField(widget=NumInput)

        rendered = NumberForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_num">Num:</label>
            <input type="number" name="num" id="id_num" required min="9" max="99" step="10">
        </p>
        """)

        class NumberForm(forms.Form):
            num = forms.DecimalField(widget=NumInput(attrs={'step': 12}))
        rendered = NumberForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_num">Num:</label>
            <input type="number" name="num" id="id_num" required min="9" max="99" step="12">
        </p>
        """)

    def test_range(self):
        """<input type="range">"""
        class RangeForm(forms.Form):
            range_ = forms.DecimalField(widget=forms.RangeInput)

        rendered = RangeForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_range_">Range :</label>
            <input type="range" name="range_" id="id_range_" required>
        </p>
        """)

    def test_phone(self):
        """<input type="tel">"""
        class PhoneForm(forms.Form):
            tel = forms.CharField(widget=forms.PhoneNumberInput)

        rendered = PhoneForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_tel">Tel:</label>
            <input type="tel" name="tel" id="id_tel" required>
        </p>
        """)

    def test_checkbox(self):
        """<input type="checkbox">"""
        class CBForm(forms.Form):
            cb = forms.BooleanField()

        rendered = CBForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_cb">Cb:</label>
            <input type="checkbox" name="cb" id="id_cb" required>
        </p>
        """)

        form = CBForm(data={'cb': False})
        self.assertFalse(form.is_valid())
        rendered = form.as_p()
        self.assertHTMLEqual(rendered, """
        <ul class="errorlist">
            <li>This field is required.</li>
        </ul>
        <p>
            <label for="id_cb">Cb:</label>
            <input type="checkbox" name="cb" id="id_cb" required>
        </p>
        """)

        form = CBForm(data={'cb': 1})
        self.assertTrue(form.is_valid())
        rendered = form.as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_cb">Cb:</label>
            <input type="checkbox" name="cb" id="id_cb" required checked>
        </p>
        """)

        form = CBForm(data={'cb': True})
        self.assertTrue(form.is_valid())
        rendered = form.as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_cb">Cb:</label>
            <input type="checkbox" name="cb" id="id_cb" required checked>
        </p>
        """)

        form = CBForm(data={'cb': 'foo'})
        self.assertTrue(form.is_valid())
        rendered = form.as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_cb">Cb:</label>
            <input type="checkbox" name="cb" id="id_cb" required checked value="foo">
        </p>
        """)

    def test_select(self):
        """<select>"""
        CHOICES = (
            ('en', 'English'),
            ('de', 'Deutsch'),
        )

        class SelectForm(forms.Form):
            select = forms.ChoiceField(choices=CHOICES)

        rendered = SelectForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_select">Select:</label>
            <select name="select" id="id_select" required>
                <option value="en">English</option>
                <option value="de">Deutsch</option>
            </select>
        </p>
        """)

        rendered = SelectForm(initial={'select': 'en'}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_select">Select:</label>
            <select name="select" id="id_select" required>
                <option value="en" selected>English</option>
                <option value="de">Deutsch</option>
            </select>
        </p>
        """)

    def test_nbselect(self):
        """NullBooleanSelect"""
        class NBForm(forms.Form):
            nb = forms.NullBooleanField()

        rendered = NBForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_nb">Nb:</label>
            <select name="nb" id="id_nb" required>
                <option value="1" selected>Unknown</option>
                <option value="2">Yes</option>
                <option value="3">No</option>
            </select>
        </p>
        """)

        rendered = NBForm(data={'nb': True}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_nb">Nb:</label>
            <select name="nb" id="id_nb" required>
                <option value="1">Unknown</option>
                <option value="2" selected>Yes</option>
                <option value="3">No</option>
            </select>
        </p>
        """)

    def test_select_multiple(self):
        """<select multiple>"""
        CHOICES = (
            ('en', 'English'),
            ('de', 'Deutsch'),
            ('fr', 'Francais'),
        )

        class MultiForm(forms.Form):
            multi = forms.MultipleChoiceField(choices=CHOICES)

        rendered = MultiForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_multi">Multi:</label>
            <select name="multi" id="id_multi" required multiple>
                <option value="en">English</option>
                <option value="de">Deutsch</option>
                <option value="fr">Francais</option>
            </select>
        </p>
        """)

        rendered = MultiForm(data={'multi': ['fr', 'en']}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_multi">Multi:</label>
            <select name="multi" id="id_multi" required multiple>
                <option value="en" selected>English</option>
                <option value="de">Deutsch</option>
                <option value="fr" selected>Francais</option>
            </select>
        </p>
        """)

    def test_select_multiple_values(self):
        """<select multiple>"""
        CHOICES = (
            ('1', 'English'),
            ('12', 'Deutsch'),
            ('123', 'Francais'),
        )

        class MultiForm(forms.Form):
            multi = forms.MultipleChoiceField(choices=CHOICES)

        rendered = MultiForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_multi">Multi:</label>
            <select name="multi" id="id_multi" required multiple>
                <option value="1">English</option>
                <option value="12">Deutsch</option>
                <option value="123">Francais</option>
            </select>
        </p>
        """)

        rendered = MultiForm(data={'multi': ['123']}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_multi">Multi:</label>
            <select name="multi" id="id_multi" required multiple>
                <option value="1">English</option>
                <option value="12">Deutsch</option>
                <option value="123" selected>Francais</option>
            </select>
        </p>
        """)

    def test_optgroup(self):
        """<optgroup> in select widgets"""
        CHOICES = (
            (None, (
                ('en', 'English'),
                ('de', 'Deutsch'),
                ('fr', 'Francais'),
            )),
            ("Asian", (
                ('jp', 'Japanese'),
                ('bn', 'Bengali'),
            )),
        )

        class LangForm(forms.Form):
            lang = forms.ChoiceField(choices=CHOICES)

        rendered = LangForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_lang">Lang:</label>
            <select name="lang" id="id_lang" required>
                <option value="en">English</option>
                <option value="de">Deutsch</option>
                <option value="fr">Francais</option>
                <optgroup label="Asian">
                    <option value="jp">Japanese</option>
                    <option value="bn">Bengali</option>
                </optgroup>
            </select>
        </p>""")

        rendered = LangForm(data={'lang': 'jp'}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_lang">Lang:</label>
            <select name="lang" id="id_lang" required>
                <option value="en">English</option>
                <option value="de">Deutsch</option>
                <option value="fr">Francais</option>
                <optgroup label="Asian">
                    <option value="jp" selected>Japanese</option>
                    <option value="bn">Bengali</option>
                </optgroup>
            </select>
        </p>""")

    def test_cb_multiple(self):
        """CheckboxSelectMultiple"""
        CHOICES = (
            ('en', 'English'),
            ('de', 'Deutsch'),
            ('fr', 'Francais'),
        )

        class MultiForm(forms.Form):
            multi = forms.MultipleChoiceField(
                choices=CHOICES,
                widget=forms.CheckboxSelectMultiple,
            )

        rendered = MultiForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_multi">Multi:</label>
            <ul>
                <li><label for="id_multi_1"><input type="checkbox" id="id_multi_1" name="multi" value="en">English</label></li>
                <li><label for="id_multi_2"><input type="checkbox" id="id_multi_2" name="multi" value="de">Deutsch</label></li>
                <li><label for="id_multi_3"><input type="checkbox" id="id_multi_3" name="multi" value="fr">Francais</label></li>
            </ul>
        </p>
        """)
        rendered = MultiForm(data={'multi': ['fr', 'en']}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_multi">Multi:</label>
            <ul>
                <li><label for="id_multi_1"><input type="checkbox" id="id_multi_1" name="multi" value="en" checked>English</label></li>
                <li><label for="id_multi_2"><input type="checkbox" id="id_multi_2" name="multi" value="de">Deutsch</label></li>
                <li><label for="id_multi_3"><input type="checkbox" id="id_multi_3" name="multi" value="fr" checked>Francais</label></li>
            </ul>
        </p>
        """)

    def test_checkbox_select_multiple_with_iterable_initial(self):
        """Passing iterable objects to initial data, not only lists or tuples.
        This is useful for ValuesQuerySet for instance."""
        choices = (
            ('en', 'En'),
            ('fr', 'Fr'),
            ('de', 'De'),
        )

        class iterable_choices(object):
            def __init__(self, choices):
                self.choices = choices

            def __iter__(self):
                for choice in self.choices:
                    yield choice

            def __len__(self):
                return len(self.choices)

        class Form(forms.Form):
            key = forms.MultipleChoiceField(
                widget=forms.CheckboxSelectMultiple,
                choices=choices,
            )

        form = Form(initial={'key': iterable_choices(['fr', 'en'])})
        self.assertHTMLEqual(form.as_p(), """
            <p><label for="id_key">Key:</label><ul>
                <li><label for="id_key_1"><input id="id_key_1" name="key" type="checkbox" value="en" checked="checked">En</label></li>
                <li><label for="id_key_2"><input id="id_key_2" name="key" type="checkbox" value="fr" checked="checked">Fr</label></li>
                <li><label for="id_key_3"><input id="id_key_3" name="key" type="checkbox" value="de">De</label></li>
            </ul></p>
        """)

    def test_radio_select(self):
        """<input type="radio">"""
        CHOICES = (
            ('en', 'English'),
            ('de', 'Deutsch'),
            ('fr', 'Francais'),
        )

        class RadioForm(forms.Form):
            radio = forms.ChoiceField(
                choices=CHOICES,
                widget=forms.RadioSelect,
            )

        rendered = RadioForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_radio">Radio:</label>
            <ul>
                <li><label for="id_radio_1"><input type="radio" name="radio" id="id_radio_1" value="en" required>English</label></li>
                <li><label for="id_radio_2"><input type="radio" name="radio" id="id_radio_2" value="de" required>Deutsch</label></li>
                <li><label for="id_radio_3"><input type="radio" name="radio" id="id_radio_3" value="fr" required>Francais</label></li>
            </ul>
        </p>""")

        rendered = RadioForm(data={'radio': 'fr'}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_radio">Radio:</label>
            <ul>
                <li><label for="id_radio_1"><input type="radio" name="radio" id="id_radio_1" value="en" required>English</label></li>
                <li><label for="id_radio_2"><input type="radio" name="radio" id="id_radio_2" value="de" required>Deutsch</label></li>
                <li><label for="id_radio_3"><input type="radio" name="radio" id="id_radio_3" value="fr" required checked>Francais</label></li>
            </ul>
        </p>""")

    def test_slug(self):
        """<input type="text" pattern="[-\w]+">"""
        class SlugForm(forms.Form):
            slug = forms.SlugField()

        rendered = SlugForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_slug">Slug:</label>
            <input type="text" name="slug" id="id_slug" pattern="[-\w]+" required>
        </p>""")
        self.assertFalse(SlugForm(data={'slug': '123 foo'}).is_valid())
        self.assertTrue(SlugForm(data={'slug': '123-foo'}).is_valid())

    def test_regex(self):
        """<input type="text" pattern="...">"""
        class RegexForm(forms.Form):
            re_field = forms.RegexField(r'^\d{3}-[a-z]+$',
                                        '\d{3}-[a-z]+')
            re_field_ = forms.RegexField(r'^[a-z]{2}$')

        rendered = RegexForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_re_field">Re field:</label>
            <input type="text" name="re_field" id="id_re_field" pattern="\d{3}-[a-z]+" required>
        </p><p>
            <label for="id_re_field_">Re field :</label>
            <input type="text" name="re_field_" id="id_re_field_" required>
        </p>""")

        self.assertFalse(RegexForm(data={'re_field': 'meh',
                                         're_field_': 'fr'}).is_valid())
        self.assertTrue(RegexForm(data={'re_field': '123-python',
                                        're_field_': 'fr'}).is_valid())

    def test_ip_address(self):
        """<input pattern="<IPv4 re>">"""
        class IPv4Form(forms.Form):
            ip = forms.IPAddressField()

        rendered = IPv4Form().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_ip">Ip:</label>
            <input type="text" name="ip" pattern="%s" id="id_ip" required>
        </p>""" % forms.IPAddressInput.ip_pattern)

        self.assertFalse(IPv4Form(data={'ip': '500.500.1.1'}).is_valid())
        self.assertTrue(IPv4Form(data={'ip': '250.100.1.8'}).is_valid())

    def test_generic_ip_address(self):
        """<input type=text>"""
        class GenericIPForm(forms.Form):
            ip = forms.GenericIPAddressField()

        with self.assertTemplateUsed('floppyforms/input.html'):
            rendered = GenericIPForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_ip">Ip:</label>
            <input type="text" name="ip" id="id_ip" required>
        </p>""")

    def test_typed_choice_field(self):
        """foo = forms.TypedChoiceField()"""
        TYPE_CHOICES = (
            (0, 'Some value'),
            (1, 'Other value'),
            (2, 'A third one'),
        )
        my_coerce = lambda val: bool(int(val))

        class TypedForm(forms.Form):
            typed = forms.TypedChoiceField(coerce=my_coerce,
                                           choices=TYPE_CHOICES)

        rendered = TypedForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_typed">Typed:</label>
            <select name="typed" id="id_typed" required>
                <option value="0">Some value</option>
                <option value="1">Other value</option>
                <option value="2">A third one</option>
            </select>
        </p>""")

        form = TypedForm(data={'typed': '0'})
        self.assertTrue(form.is_valid())
        self.assertEqual(form.cleaned_data['typed'], False)

    def test_file_path_field(self):
        """foo = forms.FilePathField()"""
        parent = os.path.dirname(os.path.abspath(__file__))

        class PathForm(forms.Form):
            path = forms.FilePathField(path=parent, recursive=True)

        rendered = PathForm().as_p()
        self.assertTrue('<select ' in rendered, rendered)
        self.assertTrue(len(PathForm().fields['path'].choices) > 10)

    def test_typed_multiple_choice(self):
        """foo = forms.TypedMultipleChoiceField()"""
        TYPE_CHOICES = (
            (0, 'Some value'),
            (1, 'Other value'),
            (2, 'A third one'),
        )
        my_coerce = lambda val: bool(int(val))

        class TypedMultiForm(forms.Form):
            thing = forms.TypedMultipleChoiceField(coerce=my_coerce,
                                                   choices=TYPE_CHOICES)

        rendered = TypedMultiForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_thing">Thing:</label>
            <select name="thing" id="id_thing" required multiple>
                <option value="0">Some value</option>
                <option value="1">Other value</option>
                <option value="2">A third one</option>
            </select>
        </p>""")

    def test_model_choice_field(self):
        """ModelChoiceField and ModelMultipleChoiceField"""
        SomeModel.objects.create(some_field='Meh')
        SomeModel.objects.create(some_field='Bah')

        class ModelChoiceForm(forms.Form):
            mod = forms.ModelChoiceField(queryset=SomeModel.objects.all())

        rendered = ModelChoiceForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_mod">Mod:</label>
            <select name="mod" id="id_mod" required>
                <option value="">---------</option>
                <option value="1">Meh</option>
                <option value="2">Bah</option>
            </select>
        </p>""")

        rendered = ModelChoiceForm(data={'mod': 1}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_mod">Mod:</label>
            <select name="mod" id="id_mod" required>
                <option value="">---------</option>
                <option value="1" selected>Meh</option>
                <option value="2">Bah</option>
            </select>
        </p>""")

        class MultiModelForm(forms.Form):
            mods = forms.ModelMultipleChoiceField(queryset=SomeModel.objects.all())

        rendered = MultiModelForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_mods">Mods:</label>
            <select name="mods" id="id_mods" required multiple>
                <option value="1">Meh</option>
                <option value="2">Bah</option>
            </select>
        </p>""")
        rendered = MultiModelForm(data={'mods': [1]}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_mods">Mods:</label>
            <select name="mods" id="id_mods" required multiple>
                <option value="1" selected>Meh</option>
                <option value="2">Bah</option>
            </select>
        </p>""")

    def test_combo_field(self):
        """Combo field"""
        class ComboForm(forms.Form):
            combo = forms.ComboField(fields=[forms.EmailField(),
                                             forms.CharField(max_length=10)])

        rendered = ComboForm().as_p()
        self.assertTrue(' required ' in rendered, rendered)
        self.assertFalse(ComboForm(data={'combo': 'bob@exmpl.com'}).is_valid())
        self.assertTrue(ComboForm(data={'combo': 'bob@ex.com'}).is_valid())

    def test_split_datetime(self):
        """Split date time widget"""
        class SplitForm(forms.Form):
            split = forms.SplitDateTimeField()

        rendered = SplitForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_split_0">Split:</label>
            <input type="date" name="split_0" required id="id_split_0">
            <input type="time" name="split_1" required id="id_split_1">
        </p>""")

        class SplitForm(forms.Form):
            split = forms.SplitDateTimeField(required=False)

        rendered = SplitForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_split_0">Split:</label>
            <input type="date" name="split_0" id="id_split_0">
            <input type="time" name="split_1" id="id_split_1">
        </p>""")

        valid = {'split_0': '2011-02-06', 'split_1': '12:12'}
        self.assertTrue(SplitForm(data=valid).is_valid())

        invalid = {'split_0': '2011-02-06', 'split_1': ''}
        self.assertFalse(SplitForm(data=invalid).is_valid())

        class SplitForm(forms.Form):
            split = forms.SplitDateTimeField(
                widget=forms.SplitHiddenDateTimeWidget,
            )

        rendered = SplitForm().as_p()
        self.assertHTMLEqual(rendered, """
        <input type="hidden" name="split_0" required id="id_split_0">
        <input type="hidden" name="split_1" required id="id_split_1">
        """)

    def test_multiple_hidden(self):
        """<input type="hidden"> for fields with a list of values"""

        some_choices = (
            ('foo', 'bar'),
            ('baz', 'meh'),
            ('heh', 'what?!'),
        )

        class MultiForm(forms.Form):
            multi = forms.MultipleChoiceField(widget=forms.MultipleHiddenInput,
                                              choices=some_choices)

        rendered = MultiForm(data={'multi': ['heh', 'foo']}).as_p()
        self.assertHTMLEqual(rendered, """
        <input type="hidden" name="multi" value="heh" required id="id_multi_0">
        <input type="hidden" name="multi" value="foo" required id="id_multi_1">
        """)

    def test_datetime_with_initial(self):
        """SplitDateTimeWidget with an initial value"""
        value = now()

        class DateTimeForm(forms.Form):
            dt = forms.DateTimeField(initial=value,
                                     widget=forms.SplitDateTimeWidget)

        rendered = DateTimeForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_dt_0">Dt:</label>
            <input type="date" name="dt_0" value="%s" id="id_dt_0">
            <input type="time" name="dt_1" value="%s" id="id_dt_1">
        </p>""" % (value.strftime("%Y-%m-%d"), value.strftime("%H:%M:%S")))

    def test_select_date_widget(self):
        """SelectDateWidget"""
        today = datetime.date.today()

        class SelectDateForm(forms.Form):
            dt = forms.DateField(initial=today,
                                 widget=forms.SelectDateWidget)

        rendered = SelectDateForm().as_p()
        option_year = (u'<option value="%(year)d" selected="selected">'
                       u'%(year)d</option>') % {'year': today.year}
        self.assertTrue(option_year in rendered, rendered)

        option_month = (u'<option value="%d" selected="selected">%s'
                        u'</option>') % (today.month, MONTHS[today.month])
        self.assertTrue(option_month in rendered, rendered)

        option_day = (u'<option value="%(day)d" selected="selected">%(day)d'
                      u'</option>') % {'day': today.day}
        self.assertTrue(option_day in rendered, rendered)

        self.assertFalse(' id="id_dt"' in rendered, rendered)

        self.assertTrue(' id="id_dt_year"' in rendered, rendered)
        self.assertTrue(' id="id_dt_month"' in rendered, rendered)
        self.assertTrue(' id="id_dt_day"' in rendered, rendered)
        self.assertEqual(rendered.count('<option value="0">---</option>'), 0)

        class SelectDateForm(forms.Form):
            dt = forms.DateField(initial='%s-09-09' % today.year,
                                 widget=forms.SelectDateWidget)
        rendered = SelectDateForm().as_p()
        self.assertTrue(str(today.year) in rendered, rendered)
        self.assertEqual(rendered.count('<option value="0">---</option>'), 0)

        class SelectDateForm(forms.Form):
            dt = forms.DateField(widget=forms.SelectDateWidget(required=False))
        rendered = SelectDateForm().as_p()
        self.assertEqual(rendered.count('<option value="0">---</option>'), 3)

    def test_no_attrs_rendering(self):
        widget = forms.TextInput()
        try:
            rendered = widget.render('name', 'value')
            self.assertEqual(
                rendered,
                '<input type="text" name="name" value="value">\n',
            )
        except AttributeError:
            self.fail("Rendering with no attrs should work")

    def test_required_select(self):
        """The 'required' attribute on the Select widget"""
        choices = (('foo', 'foo'),
                   ('bar', 'bar'))

        class SelectForm(forms.Form):
            foo = forms.CharField(widget=forms.Select(choices=choices))

        rendered = SelectForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_foo">Foo:</label>
            <select name="foo" required id="id_foo">
                <option value="foo">foo</option>
                <option value="bar">bar</option>
            </select>
        </p>""")

        class SelectForm(forms.Form):
            foo = forms.CharField(widget=forms.Select(choices=choices),
                                  required=False)

        rendered = SelectForm().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_foo">Foo:</label>
            <select name="foo" id="id_foo">
                <option value="foo">foo</option>
                <option value="bar">bar</option>
            </select>
        </p>""")

    def test_clearable_file_input(self):
        class Form(forms.Form):
            file_ = forms.FileField(required=False)

        fake_instance = {'url': 'test test'}
        rendered = Form(initial={'file_': fake_instance}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_file_">File :</label>
            Currently: <a target="_blank" href="test test">{&#39;url&#39;: &#39;test test&#39;}</a>
            <input type="checkbox" name="file_-clear" id="file_-clear_id">
            <label for="file_-clear_id">Clear</label><br>Change:
            <input type="file" name="file_" id="id_file_">
        </p>""")

        form = Form(initial={'file_': fake_instance},
                    data={'file_-clear': True})
        self.assertTrue(form.is_valid())
        # file_ has been cleared
        self.assertFalse(form.cleaned_data['file_'])

    def test_rendered_file_input(self):
        class Form(forms.Form):
            file_ = forms.FileField()

            def clean_file_(self):
                raise forms.ValidationError('Some error')

        file_ = SimpleUploadedFile('name', b'some contents')

        form = Form(files={'file_': file_})
        valid = form.is_valid()
        self.assertFalse(valid)
        rendered = form.as_p()
        self.assertHTMLEqual(rendered, """
        <ul class="errorlist">
            <li>Some error</li>
        </ul>
        <p>
            <label for="id_file_">File :</label>
            <input type="file" name="file_" id="id_file_" required>
        </p>""")

    def test_true_attr(self):
        """widgets with attrs={'foo': True} should render as <input foo>"""
        class Form(forms.Form):
            text = forms.CharField(widget=forms.TextInput(attrs={
                'foo': True,
                'bar': False,
            }))

        rendered = Form().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_text">Text:</label>
            <input type="text" foo bar="False" id="id_text" name="text" required>
        </p>""")

    def test_range_input(self):
        class Form(forms.Form):
            foo = forms.CharField(widget=forms.RangeInput(attrs={
                'min': 1, 'max': 10, 'step': 1, 'bar': 1.0
            }))

        rendered = Form(initial={'foo': 5}).as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_foo">Foo:</label>
            <input type="range" name="foo" value="5" required max="10" step="1" bar="1.0" id="id_foo" min="1">
        </p>""")

    def test_datalist(self):
        class Form(forms.Form):
            foo = forms.CharField(widget=forms.TextInput(
                datalist=['Foo', 'Bar', 'Baz'],
            ))

        rendered = Form().as_p()
        self.assertHTMLEqual(rendered, """
        <p>
            <label for="id_foo">Foo:</label>
            <input type="text" name="foo" required id="id_foo" list="id_foo_list">
            <datalist id="id_foo_list">
                <option value="Foo">
                <option value="Bar">
                <option value="Baz">
            </datalist>
        </p>""")

    def test_specify_template_at_init(self):
        """Can customize the template used when instantiating the widget."""
        widget = forms.TextInput(template_name='custom.html')

        rendered = widget.render('text', 'value')
        self.assertHTMLEqual(rendered, '<input type="custom" name="text" />')

    def test_specify_template_at_init_as_None(self):
        """Can give an explicit template_name=None without overriding."""
        widget = forms.TextInput(template_name=None)

        self.assertIsNot(widget.template_name, None)

    def test_specify_template_in_render(self):
        """Can customize the template used at render time."""
        widget = forms.TextInput()

        rendered = widget.render('text', 'value', template_name='custom.html')
        self.assertHTMLEqual(rendered, '<input type="custom" name="text" />')

        # Can explicitly give None and will not override
        rendered = widget.render('text', 'value', template_name=None)
        self.assertHTMLEqual(
            rendered, '<input type="text" name="text" value="value" />')


class WidgetRenderingTestWithTemplateStringIfInvalidSet(WidgetRenderingTest):
    pass

WidgetRenderingTestWithTemplateStringIfInvalidSet = override_settings(TEMPLATE_STRING_IF_INVALID=InvalidVariable(u'INVALID'))(WidgetRenderingTestWithTemplateStringIfInvalidSet)


class WidgetContextTests(TestCase):
    def test_widget_render_method_should_not_clutter_the_context(self):
        '''
        Make sure that the widget rendering pops the context as often as it
        pushed onto it. Otherwise this would lead to leaking variables into
        outer scopes.

        See issue #43 for more information.
        '''
        context = Context({
            'one': 1,
        })
        context_levels = len(context.dicts)
        widget = forms.TextInput()
        widget.context_instance = context
        widget.render('text', '')
        self.assertEqual(len(context.dicts), context_levels)

    def test_widget_should_not_clutter_the_context(self):
        class TextForm(forms.Form):
            text = forms.CharField(label='My text field')
        context = Context({
            'form': TextForm(),
        })
        context_levels = len(context.dicts)
        rendered = Template('''
            {% load floppyforms %}
            {% form form using %}
                {% formrow form.text with label="Textfield" %}
                {% formrow form.text %}
            {% endform %}
        ''').render(context)
        self.assertEqual(len(context.dicts), context_levels)
        self.assertHTMLEqual(rendered, '''
            <p>
                <label for="id_text">Textfield:</label>
                <input type="text" name="text" id="id_text" required />
            </p>
            <p>
                <label for="id_text">My text field:</label>
                <input type="text" name="text" id="id_text" required />
            </p>
        ''')


class AttrsTemplateTests(TestCase):
    def render_attrs(self, attrs):
        return render_to_string('floppyforms/attrs.html', {
            'attrs': attrs,
        })

    def test_attrs_with_one_item(self):
        rendered = self.render_attrs({
            'name': 'fieldname'
        })
        self.assertEqual(rendered, ' name="fieldname"')

    def test_attrs_with_value_is_true(self):
        rendered = self.render_attrs({
            'required': True
        })
        self.assertEqual(rendered, ' required')

    def test_attrs_with_value_is_one(self):
        '''
        Regression test for #88.
        '''
        rendered = self.render_attrs({
            'value': True
        })
        self.assertEqual(rendered, ' value')
        rendered = self.render_attrs({
            'value': 1
        })
        self.assertEqual(rendered, ' value="1"')
        rendered = self.render_attrs({
            'value': False
        })
        self.assertEqual(rendered, ' value="False"')

    def test_attrs_with_multiple_values(self):
        rendered = self.render_attrs({
            'required': True,
            'format': 'dd.mm.yyyy',
        })
        # We cannot predict the ordering...
        self.assertTrue(rendered in [
            ' required format="dd.mm.yyyy"',
            ' format="dd.mm.yyyy" required',
        ])

        rendered = self.render_attrs({
            'value': 'Hello World',
            'id': 'id_name',
            'name': 'name',
            'disabled': True,
        })
        self.assertTrue(' value="Hello World"' in rendered)
        self.assertTrue(' id="id_name"' in rendered)
        self.assertTrue(' name="name"' in rendered)

        # disabled shouldn't have a value
        self.assertTrue(' disabled' in rendered)
        self.assertTrue(' disabled=' not in rendered)

########NEW FILE########
