__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Steel documentation build configuration file, created by
# sphinx-quickstart on Tue Jan 11 22:01:13 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Steel'
copyright = u'2011, Marty Alchin'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1a'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# The name of the language Pygments should highlight.
highlight_language = 'python3'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Steeldoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Steel.tex', u'Steel: File Formats Made Easy',
   u'Marty Alchin', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'steel', u'Steel: File Formats Made Easy',
     [u'Marty Alchin'], 1)
]

########NEW FILE########
__FILENAME__ = basics
import os
import sys

import steel

GIF_VERSIONS = (
    ('87a', '87a'),
    ('89a', '89a'),
)


class BMP(steel.Structure, endianness=steel.LittleEndian):
    signature = steel.FixedString('BM')
    filesize = steel.Integer('Total file size', size=4)
    steel.Reserved(size=4)
    data_offset = steel.Integer('Offset of the actual image data', size=4)
    header_size = steel.Integer(size=4, default=40)
    width = steel.Integer(size=4)
    height = steel.Integer(size=4)


class GIF(steel.Structure, endianness=steel.LittleEndian, encoding='ascii'):
    tag = steel.FixedString('GIF')
    version = steel.String(size=3, choices=GIF_VERSIONS)
    width = steel.Integer(size=2)
    height = steel.Integer(size=2)


class PNG(steel.Structure):
    signature = steel.FixedString(b'\x89PNG\x0d\x0a\x1a\x0a')
    header_size = steel.Integer(size=4)
    header_id = steel.FixedString(b'IHDR')
    width = steel.Integer(size=4)
    height = steel.Integer(size=4)


if __name__ == '__main__':
    filename = sys.argv[1]
    ext = os.path.splitext(filename)[1]
    Image = {'.bmp': BMP, '.gif': GIF, '.png': PNG}[ext]
    image = Image(open(filename, 'rb'))
    print('%s x %s' % (image.width, image.height))

########NEW FILE########
__FILENAME__ = bmp
import steel

COMPRESSION_TYPES = (
    (0, 'No compression'),
    (1, '8-bit RLE'),
    (2, '4-bit RLE'),
    (3, 'Bit Field'),
    (4, 'JPEG'),  # Generally not supported for screen display
    (5, 'PNG'),   # Generally not supported for screen display
)


class PaletteColor(steel.Structure):
    blue = steel.Integer(size=1)
    green = steel.Integer(size=1)
    red = steel.Integer(size=1)
    alpha = steel.Integer(size=1)

    def __str__(self):
        return '#%x%x%x%x' % (self.red, self.green, self.blue, self.alpha)


class BMP(steel.Structure, endianness=steel.LittleEndian):
    signature = steel.FixedString('BM')
    filesize = steel.Integer('Total file size', size=4)
    steel.Reserved(size=4)
    data_offset = steel.Integer('Offset of the actual image data', size=4)
    header_size = steel.Integer(size=4, default=40)
    width = steel.Integer(size=4)
    height = steel.Integer(size=4)
    plane_count = steel.Integer(size=2, default=1)
    bit_depth = steel.Integer(size=2)
    compression_type = steel.Integer(size=4, choices=COMPRESSION_TYPES, default=0)
    data_size = steel.Integer('Size of the actual image data', size=4)
    ppm_x = steel.Integer('Pixels per meter (X axis)', size=4)
    ppm_y = steel.Integer('Pixels per meter (Y axis)', size=4)
    color_count = steel.Integer('Number of colors', size=4)
    important_color_count = steel.Integer('Number of important colors', size=4)
    palette = steel.List(PaletteColor, size=color_count)
    pixel_data = steel.Bytes(size=steel.Remainder)


if __name__ == '__main__':
    import sys
    bmp = BMP(open(sys.argv[1], 'rb'))
    print('%s x %s' % (bmp.width, bmp.height))

########NEW FILE########
__FILENAME__ = gif
import sys

import steel
from steel import bits

VERSIONS = (
    ('87a', '87a'),
    ('89a', '89a'),
)


class Color(steel.Structure):
    red = steel.Integer(size=1)
    green = steel.Integer(size=1)
    blue = steel.Integer(size=1)

    def __str__(self):
        return '#%x%x%x' % (self.red, self.green, self.blue)


class ScreenInfoBits(bits.Structure):
    has_color_map = bits.Flag()
    color_resolution = bits.Integer(size=3) + 1
    bits.Reserved(size=1)
    bits_per_pixel = bits.Integer(size=3) + 1


class ScreenDescriptor(steel.Structure, endianness=steel.LittleEndian):
    width = steel.Integer(size=2)
    height = steel.Integer(size=2)
    info = steel.SubStructure(ScreenInfoBits)
    background_color = steel.Integer(size=1)
    pixel_ratio = steel.Integer(size=1)

    with info.has_color_map == True:
        color_map = steel.List(steel.SubStructure(Color), size=2 ** info.bits_per_pixel)

    @property
    def aspect_ratio(self):
        if self.pixel_ratio == 0:
            return None
        return (self.pixel_ratio + 15) / 64


class ImageInfoBits(bits.Structure):
    has_color_map = bits.Flag()
    is_interlaced = bits.Flag()
    bits.Reserved(size=3)
    bits_per_pixel = bits.Integer(size=3) + 1


class ImageDescriptor(steel.Structure):
    separator = steel.FixedString(b',')
    left = steel.Integer(size=2)
    top = steel.Integer(size=2)
    width = steel.Integer(size=2)
    height = steel.Integer(size=2)
    info = steel.SubStructure(ImageInfoBits)

    with info.has_color_map == True:
        color_map = steel.List(steel.SubStructure(Color), size=2 ** info.bits_per_pixel)


class GIF(steel.Structure, endianness=steel.LittleEndian, encoding='ascii'):
    tag = steel.FixedString('GIF')
    version = steel.String(size=3, choices=VERSIONS)
    
#    with tag == 'GIF':
#        version = steel.String(size=3, choices=VERSIONS)

    screen = steel.SubStructure(ScreenDescriptor)

    @property
    def width(self):
        return self.screen.width

    @property
    def height(self):
        return self.screen.height


if __name__ == '__main__':
    gif = GIF(open(sys.argv[1], 'rb'))
    print('%s x %s' % (gif.width, gif.height))
    print(gif.screen.info.has_color_map)
    print(gif.screen.info.color_resolution)
    print(gif.screen.info.bits_per_pixel)
    print(gif.screen.color_map)
    print(len(gif.screen.color_map))

########NEW FILE########
__FILENAME__ = jpg
import sys

import steel
from steel import chunks

DENSITY_UNITS = (
    (0, 'Aspect ratio only'),
    (1, 'Pixels per inch'),
    (2, 'Pixels per centimeter'),
)


class EmptyChunk(chunks.Chunk):
    id = steel.Integer(size=2)
    size = steel.Bytes(size=0)
    payload = chunks.Payload(size=0)


class Chunk(chunks.Chunk):
    id = steel.Integer(size=2)
    size = steel.Integer(size=2)
    payload = chunks.Payload(size=size - 2)


class ScanChunk(chunks.Chunk):
    id = steel.Integer(size=2)
    size = steel.Integer(size=2)
    payload = chunks.Payload(size=size - 2)


@EmptyChunk(0xFFD8)
class Start(steel.Structure):
    pass


@Chunk(0xFFE0)
class Header(steel.Structure):
    marker = steel.FixedString(b'JFIF\x00')
    major_version = steel.Integer(size=1)
    minor_version = steel.Integer(size=1)
    density_units = steel.Integer(size=1, choicse=DENSITY_UNITS)
    x_density = steel.Integer(size=2)
    y_density = steel.Integer(size=2)
    thumb_width = steel.Integer(size=1)
    thumb_height = steel.Integer(size=1)
    thumb_data = steel.Bytes(size=3 * thumb_width * thumb_height)

    @property
    def version(self):
        return '%i.%02i' % (self.major_version, self.minor_version)


@Chunk(0xFFC0)
class StartFrame(steel.Structure):
    precision = steel.Integer(size=1)
    width = steel.Integer(size=2)
    height = steel.Integer(size=2)

# 0xFD96 is at offset 0xA8A

@Chunk(0xFFFE)
class Comment(steel.Structure):
    value = steel.String(encoding='utf8', size=steel.Remainder)

    def __str__(self):
        return self.value


@EmptyChunk(0xFFD9)
class End(steel.Structure):
    pass


class JFIF(steel.Structure):
    start = steel.SubStructure(Start)
    header = steel.SubStructure(Header)
    chunks = chunks.ChunkList(Chunk, (StartFrame, Comment), terminator=End)

    @property
    def width(self):
        return self.chunks.of_type(StartFrame)[0].width

    @property
    def height(self):
        return self.chunks.of_type(StartFrame)[0].height

    @property
    def comment(self):
        return self.chunks.of_type(Comment)[0].value


if __name__ == '__main__':
    jpg = JFIF(open(sys.argv[1], 'rb'))
    print(jpg.chunks)
    print('%s x %s' % (jpg.width, jpg.height))

########NEW FILE########
__FILENAME__ = png
import decimal
import sys

import steel
from steel import chunks

COMPRESSION_CHOICES = (
    (0, 'zlib/deflate'),
)
RENDERING_INTENT_CHOICES = (
    (0, 'Perceptual'),
    (1, 'Relative Colorimetric'),
    (2, 'Saturation'),
    (3, 'Absolute Colorimetric'),
)
PHYSICAL_UNIT_CHOICES = (
    (0, '<Unknown Unit>'),
    (1, 'Meters'),
)
FILTER_CHOICES = (
    (0, 'Adaptive Filtering'),
)
INTERLACE_CHOICES = (
    (0, '<No Interlacing>'),
    (1, 'Adam7'),
)


class Chunk(chunks.Chunk, encoding='ascii'):
    """
    A special chunk for PNG, which puts the size before the type
    and includes a CRC field for verifying data integrity.
    """
    size = steel.Integer(size=4)
    id = steel.String(size=4)
    payload = chunks.Payload(size=size)
    crc = steel.CRC32(first=id)

    @property
    def is_critical(self):
        # Critical chunks will always have an uppercase letter for the
        # first character in the type. Ancillary will always be lower.
        return self.type[0].upper() == self.type[0]

    @property
    def is_public(self):
        # Public chunks will always have an uppercase letter for the
        # second character in the type. Private will always be lower.
        return self.type[1].upper() == self.type[1]


@Chunk('IHDR')
class Header(steel.Structure):
    width = steel.Integer(size=4)
    height = steel.Integer(size=4)
    bit_depth = steel.Integer(size=1, choices=(1, 2, 4, 8, 16))
    color_type = steel.Integer(size=1, choices=(0, 2, 3, 4, 6))
    compression_method  = steel.Integer(size=1, choices=COMPRESSION_CHOICES)
    filter_method = steel.Integer(size=1, choices=FILTER_CHOICES)
    interlace_method = steel.Integer(size=1, choices=INTERLACE_CHOICES)


class HundredThousand(steel.Integer):
    """
    Value is usable as a Decimal in Python, but stored
    as an integer after multiplying the value by 100,000
    """
    def __init__(self):
        super(HundredThousand, self).__init__(size=4)

    def decode(self, value):
        value = super(HundredThousand, self).decode(value)
        return decimal.Decimal('0.%05s' % value)

    def encode(self, obj, value):
        return super(HundredThousand, self).encode(obj, int(value * 100000))


@Chunk('cHRM')
class Chromaticity(steel.Structure):
    white_x = HundredThousand()
    white_y = HundredThousand()
    red_x = HundredThousand()
    red_y = HundredThousand()
    green_x = HundredThousand()
    green_y = HundredThousand()
    blue_x = HundredThousand()
    blue_y = HundredThousand()


@Chunk('gAMA')
class Gamma(steel.Structure):
    value = HundredThousand()


@Chunk('iCCP')
class ICCProfile(steel.Structure):
    name = steel.String(encoding='latin-1')
    compression = steel.Integer(size=1, choices=COMPRESSION_CHOICES)
    profile = steel.Bytes(size=steel.Remainder)  # TODO: decompress


@Chunk('sBIT')
class SignificantBits(steel.Structure):
    data = steel.Bytes(size=steel.Remainder)

    # TODO: decode based on parent Header.color_type


@Chunk('sRGB')
class sRGB(steel.Structure):
    rendering_intent = steel.Integer(size=1, choices=RENDERING_INTENT_CHOICES)


class PaletteColor(steel.Structure):
    red = steel.Integer(size=1)
    green = steel.Integer(size=1)
    blue = steel.Integer(size=1)


@Chunk('PLTE')
class Palette(steel.Structure):
    colors = steel.List(steel.SubStructure(PaletteColor), size=steel.Remainder)

    def __iter__(self):
        return iter(self.colors)


@Chunk('bKGD')
class Background(steel.Structure):
    data = steel.Bytes(size=steel.Remainder)

    # TODO: decode based on parent Header.color_type


@Chunk('hIST')
class Histogram(steel.Structure):
    frequencies = steel.List(steel.Integer(size=2), size=steel.Remainder)


@Chunk('tRNS')
class Transparency(steel.Structure):
    data = steel.Bytes(size=steel.Remainder)

    # TODO: decode based on parent Header.color_type


@Chunk('IDAT', multiple=True)
class Data(steel.Structure):
    data = steel.Bytes(size=steel.Remainder)


@Chunk('pHYs')
class PhysicalDimentions(steel.Structure):
    x = steel.Integer(size=4)
    y = steel.Integer(size=4)
    unit = steel.Integer(size=1, choices=PHYSICAL_UNIT_CHOICES)


class SuggestedPaletteEntry(steel.Structure):
    red = steel.Integer(size=2)
    green = steel.Integer(size=2)
    blue = steel.Integer(size=2)
    alpha = steel.Integer(size=2)
    frequency = steel.Integer(size=2)

    # TODO: figure out a good way to handle size based on sample_depth below


@Chunk('sPLT')
class SuggestedPalette(steel.Structure):
    name = steel.String(encoding='latin-1')
    sample_depth = steel.Integer(size=1)
    colors = steel.List(steel.SubStructure(SuggestedPaletteEntry), size=steel.Remainder)


@Chunk('tIME')
class Timestamp(steel.Structure):
    year = steel.Integer(size=2)
    month = steel.Integer(size=1)
    day = steel.Integer(size=1)
    hour = steel.Integer(size=1)
    minute = steel.Integer(size=1)
    second = steel.Integer(size=1)

    # TODO: convert this into a datetime object


@Chunk('tEXt', multiple=True)
class Text(steel.Structure, encoding='latin-1'):
    keyword = steel.String()
    content = steel.String(size=steel.Remainder)


@Chunk('zTXt', multiple=True)
class CompressedText(steel.Structure, encoding='latin-1'):
    keyword = steel.String()
    compression = steel.Integer(size=1, choices=COMPRESSION_CHOICES)
    content = steel.Bytes(size=steel.Remainder)  # TODO: decompress


@Chunk('iTXt', multiple=True)
class InternationalText(steel.Structure, encoding='utf8'):
    keyword = steel.String()
    is_compressed = steel.Integer(size=1)
    compression = steel.Integer(size=1, choices=COMPRESSION_CHOICES)
    language = steel.String()
    translated_keyword = steel.String()
    content = steel.Bytes(size=steel.Remainder)  # TODO: decompress


@Chunk('IEND')
class End(steel.Structure):
    pass


class PNG(steel.Structure):
    signature = steel.FixedString(b'\x89PNG\x0d\x0a\x1a\x0a')
    header = steel.SubStructure(Header)
    chunks = chunks.ChunkList(Chunk, (Header, Chromaticity, Gamma, ICCProfile,
                                      SignificantBits, sRGB, Palette, Background,
                                      Histogram, Transparency, PhysicalDimentions,
                                      SuggestedPalette, Data, Timestamp, Text,
                                      CompressedText, InternationalText), terminator=End)

    @property
    def data_chunks(self):
        for chunk in self.chunks:
            if isinstance(chunk, Data):
                yield chunk

if __name__ == '__main__':
    png = PNG(open(sys.argv[1], 'rb'))
    print('%s x %s' % (png.header.width, png.header.height))
    print(list(png.data_chunks))

########NEW FILE########
__FILENAME__ = tga
import sys

import steel
from steel import bits

COLOR_MAP_TYPES = (
    (0, 'No color map included'),
    (1, 'Color map included'),
)
IMAGE_TYPES = (
    (0, 'No image data'),
    (1, 'Uncompressed color-mapped image'),
    (2, 'Uncompressed true-color image'),
    (3, 'Uncompressed grayscale image'),
    (9, 'Run-length encoded color-mapped image'),
    (10, 'Run-length encoded true-color image'),
    (11, 'Run-length encoded grayscale image'),
)
ORIGINS = (
    (0, 'Bottom Left'),
    (1, 'Bottom Right'),
    (2, 'Top Left'),
    (3, 'Top Right'),
)


class ColorMap(steel.Structure):
    first_entry_index = steel.Integer(size=2)
    length = steel.Integer(size=2)
    entry_size = steel.Integer(size=1)


class AlphaOrigin(bits.Structure):
    bits.Reserved(size=2)
    image_origin = bits.Integer(size=2, choices=ORIGINS)
    alpha_depth = bits.Integer(size=4)


class TGA(steel.Structure, endianness=steel.LittleEndian):
    id_size = steel.Integer(size=1)
    color_map_type = steel.Integer(size=1, choices=COLOR_MAP_TYPES)
    image_type = steel.Integer(size=1, choices=IMAGE_TYPES)
    color_map_info = steel.SubStructure(ColorMap)
    x_origin = steel.Integer(size=2)
    y_origin = steel.Integer(size=2)
    width = steel.Integer(size=2)
    height = steel.Integer(size=2)
    bit_depth = steel.Integer(size=1)
    alpha_origin = steel.SubStructure(AlphaOrigin)
    image_id = steel.Bytes(size=id_size)
    color_map_data = steel.List(steel.Integer(size=color_map_info.entry_size) / 8, size=color_map_info.length)
    image_data = steel.List(steel.Integer(size=1), size=width * height * bit_depth)


if __name__ == '__main__':
    tga = TGA(open(sys.argv[1], 'rb'))
    print('%s x %s' % (tga.width, tga.height))

########NEW FILE########
__FILENAME__ = mod
import steel
from steel import bits


class FineTune(bits.Structure):
    bits.Reserved(size=4)
    value = bits.Integer(size=4)


class SampleLength(bits.Integer):
    def encode(self, value):
        return int(value / 2)

    def decode(self, value):
        return value * 2
    

class Sample(steel.Structure):
    name = steel.String(size=22, encoding='ascii')
    size = SampleLength(size=2)
    finetune = steel.SubStructure(FineTune)
    volume = steel.Integer(size=1)
    loop_start = SampleLength(size=2, default=0)
    loop_length = SampleLength(size=2, default=0)
    
    @property
    def loop_end(self):
        return self.loop_start + self.loop_length
    
    @property
    def data(self):
        index = self.get_parent().samples.index(self)
        return self.get_parent().sample_data[index]
    
    def __unicode__(self):
        return self.name


class Note(bits.Structure):
    sample_hi = bits.Integer(size=4)
    period = bits.Integer(size=12)
    sample_lo = bits.Integer(size=4)
    effect = bits.Integer(size=12)
    
    @property
    def sample(self):
        index = self.sample_hi << 4 + self.sample_lo
        return self.get_parent().samples[index]
    
    @sample.setter
    def sample(self, sample):
        index = self.get_parent().samples.index(sample)
        self.sample_hi = index >> 4
        self.sample_lo = index & 0xF


class Row(steel.Structure):
    notes = steel.List(Note, size=lambda self: self.get_parent().channels)
    
    def __iter__(self):
        return iter(self.rows)


class Pattern(steel.Structure):
    rows = steel.List(Row, size=64)
    
    def __iter__(self):
        return iter(self.rows)


class MOD(steel.Structure, endianness=steel.BigEndian):
    channels = 4
    
    title = steel.String(size=20, encoding='ascii')
    samples = steel.List(Sample, size=15)
    order_count = steel.Integer(size=1)
    restart_position = steel.Integer(size=1)
    pattern_order = steel.List(steel.Integer(size=1), size=128)
    marker = steel.FixedString('M.K.')
    patterns = steel.List(Pattern, size=lambda self: max(self.pattern_order) + 1)
    sample_data = steel.Bytes(size=steel.Remainder)
    
    @property
    def pattern_count(self):
        return max(self.order) + 1
    
    @sample_data.getter
    def sample_data(self, data):
        offset = 0
        output = []
        for info in self.samples:
            output.append(data[offset:offset + info.size])
            offset += info.size
        return output
    
    @sample_data.setter
    def sample_data(self, data_list):
        return ''.join(data_list)
    
    def __iter__(self):
        for index in self.pattern_order:
            yield self.patterns[index]
    
    def __unicode__(self):
        return self.title
    

if __name__ == '__main__':
    for format in (MOD,):
        track = format(open(sys.argv[1], 'rb'))
        print('%s: %s' % (format.__name__, track.title))


########NEW FILE########
__FILENAME__ = _669
import steel
from steel import bits


class Sample(steel.Structure):
    title = steel.String(size=13, encoding='ascii')
    size = steel.Integer(size=4)
    loop_start = steel.Integer(size=4, default=0)
    loop_end = steel.Integer(size=4, default=0xFFFFF)
    
    @property
    def data(self):
        index = self.get_parent().samples.index(self)
        return self.get_parent().sample_data[index]
    
    def __unicode__(self):
        return self.title


class Note(bits.Structure):
    pitch = bits.Integer(size=6)
    sample = bits.Integer(size=6)
    volume = bits.Integer(size=4)
    command = bits.Integer(size=4)
    command_value = bits.Integer(size=4)
    
    @sample.getter
    def sample(self, index):
        return self.get_parent().samples[index]

    @sample.setter
    def sample(self, sample):
        return self.get_parent().samples.index(sample)


class Row(steel.Structure):
    notes = steel.List(Note, size=8)
    
    def __iter__(self):
        return iter(self.notes)


class Pattern(steel.Structure):
    rows = steel.List(Row, size=64)
    
    def __iter__(self):
        return iter(self.rows)


class _669(steel.Structure, endianness=steel.LittleEndian):
    marker = steel.FixedString('if')
    message = steel.List(steel.String(size=36, encoding='ascii', padding=' '), size=3)
    sample_count = steel.Integer(size=1, max_value=64)
    pattern_count = steel.Integer(size=1, max_value=128)
    restart_position = steel.Integer(size=1)
    pattern_order = steel.List(steel.Integer(size=1, max_value=128), size=128)
    pattern_tempos = steel.List(steel.Integer(size=1), size=128)
    pattern_breaks = steel.List(steel.Integer(size=1), size=128)
    samples = steel.List(Sample, size=sample_count)
    patterns = steel.List(Pattern, size=pattern_count)
    sample_data = steel.ByteString(size=steel.REMAINDER)
    
    @sample_data.getter
    def sample_data(self, data):
        offset = 0
        output = []
        for info in self.samples:
            output.append(data[offset:offset + info.size])
            offset += info.size
        return output
    
    @sample_data.setter
    def sample_data(self, data_list):
        return ''.join(data_list)
    
    def __iter__(self):
        for index in self.pattern_order:
            yield self.patterns[index]
    
    def __unicode__(self):
        return self.message[0]
    

if __name__ == '__main__':
    track = _669(open(sys.argv[1], 'rb'))
    for line in track.message:
        print(line)

########NEW FILE########
__FILENAME__ = base
import collections
import io

from steel.common import meta, fields

__all__ = ['Structure', 'StructureStreamer', 'StructureTuple']


class StructureBase:
    def __init__(self, *args, **kwargs):
        self._file = len(args) > 0 and args[0] or None
        self._mode = self._file and 'rb' or 'wb'
        self._position = 0
        self._write_buffer = b''
        self._raw_values = {}
        self._parent = None

        if self._file and kwargs:
            raise TypeError("Cannot supply a file and attributes together")

        for name, value in kwargs.items():
            setattr(self, name, value)

    def read(self, size=None):
        if self._mode != 'rb':
            raise IOError("not readable")
        if size is None:
            return self._file.read()
        value = self._file.read(size)
        self._position += len(value)
        return value

    def write(self, data):
        if self._mode != 'wb':
            raise IOError("not writable")
        file = EOFBytesIO(self._write_buffer + data)
        last_position = 0
        for name, field in self.__class__._fields.items():
            if name not in self.__dict__:
                try:
                    try:
                        bytes = field.read(file)
                        value = field.decode(bytes)
                    except fields.FullyDecoded as obj:
                        bytes = obj.bytes
                        value = obj.value
                    self._raw_values[name] = bytes
                    self.__dict__[name] = value
                    last_position = file.tell()
                except EOFError:
                    file.seek(last_position)
                    self._write_buffer = file.read()
                else:
                    self._write_buffer = b''
        self._position += last_position

    def tell(self):
        return self._position

    def _extract(self, field):
        if field.name not in self._raw_values:
            for name, other_field in self._fields.items():
                if name not in self._raw_values:
                    with other_field.for_instance(self):
                        try:
                            bytes = other_field.read(self)
                        except fields.FullyDecoded as obj:
                            bytes = obj.bytes
                            self.__dict__[name] = obj.value
                        self._raw_values[name] = bytes
                if name == field.name:
                    break
        return self._raw_values[field.name]

    def get_raw_bytes(self):
        output = b''
        for name, field in self.__class__._fields.items():
            value = getattr(self, name)
            if name not in self._raw_values:
                setattr(self, name, getattr(self, name))
            output += self._raw_values[name]
        return output

    def get_parent(self):
        if isinstance(self._parent, Structure):
            return self._parent
        raise TypeError('%s has no parent' % self.__class__.__name__)

    def save(self, file):
        file.write(self.get_raw_bytes())

    def dump(self, file):
        file.write(self.dumps())

    def dumps(self):
        return self.get_raw_bytes()

    def validate(self):
        errors = []
        for name, field in self._fields.items():
            try:
                field.validate(self, getattr(self, name))
            except ValueError as error:
                errors.append(str(error))
        return errors

    def __str__(self):
        return '<Binary Data>'

    def __repr__(self):
        return '<%s: %s>' % (type(self).__name__, self)


class Structure(StructureBase, metaclass=meta.DeclarativeMetaclass):
    pass


class EOFBytesIO(io.BytesIO):
    """
    A customized BytesIO that raises an EOFError if more data was requested
    than is available in the data stream.
    """
    def read(self, size=None):
        data = super(EOFBytesIO, self).read(size)
        if size is not None and len(data) < size:
            raise EOFError
        return data


class StructureStreamer:
    def __init__(self, structure):
        self.structure = structure

    def parse(self, file):
        while 1:
            position = file.tell()
            try:
                value = self.structure(file)
                for name, field in self.structure._fields.items():
                    getattr(value, name)
            except Exception as e:
                if file.tell() == position:
                    # The file didn't move, so it must be at the end
                    break
                # Otherwise, something else went wrong
                raise e
            yield value


class StructureTupleMetaclass(meta.DeclarativeMetaclass):
    def __init__(cls, name, bases, attrs, **options):
        super(StructureTupleMetaclass, cls).__init__(name, bases, attrs, **options)
        cls._namedtuple = collections.namedtuple(name, cls._fields.keys())


class StructureTuple(StructureBase, metaclass=StructureTupleMetaclass):
    def __new__(cls, *args, **kwargs):
        self._file = len(args) > 0 and args[0] or None
        self._mode = self._file and 'rb' or 'wb'
        self._position = 0
        self._write_buffer = b''
        self._raw_values = {}
        self._parent = None

        if self._file and kwargs:
            raise TypeError("Cannot supply a file and attributes together")

        data = (kwargs.get(name, None) for name in cls._fields)
        return cls._namedtuple(*data)

    def __init__(self, structure, *args, **kwargs):
        super(StructureTuple, self).__init__(structure, *args, **kwargs)
        self.names = [name for name in self.structure._fields if not name.startswith('_')]
        self.namedtuple = collections.namedtuple(structure.__name__, ' '.join(self.names))

    def read(self, file):
        try:
            raw_bytes = super(StructureTuple, self).read(file)
            value = self.decode(bytes)
        except FullyDecoded as obj:
            raw_bytes = obj.bytes
            value = obj.value
        values = []
        value = self.namedtuple(*(getattr(value, name) for name in self.names))

        raise FullyDecoded(raw_bytes, value)

########NEW FILE########
__FILENAME__ = base
import sys

from steel import base, fields

__all__ = ['Structure']


class Structure(base.Structure):
    def __init__(self, *args, **kwargs):
        super(Structure, self).__init__(*args, **kwargs)
        self._bits_left = 0
        self._bit_buffer = 0

    def read(self, size=None):
        bit_buffer = self._bit_buffer
        if size > self._bits_left:
            # Read more bytes from the file
            read_size = int(((size - self._bits_left) + 7) / 8)
            field = fields.Integer(size=read_size)
            bytes = self._file.read(read_size)
            value = field.decode(bytes)
            bit_buffer = (bit_buffer << (read_size * 8)) | value
            self._bits_left += read_size * 8
        self._bits_left -= size
        bits = bit_buffer >> self._bits_left
        self._bit_buffer = bit_buffer & (1 << self._bits_left) - 1
        return bits

    def get_raw_bytes(self):
        output = bytearray()
        bits_read = 0
        byte = 0
        for name, field in self.__class__._fields.items():
            if name not in self._raw_values:
                setattr(self, name, getattr(self, name))
            bits_read += field.size
            bits = self._raw_values[name]
            byte = (byte << field.size) + bits
            while bits_read >= 8:
                byte >>= 8
                output.append(byte & 0xFF)
                bits_read -= 8
        return bytes(output)



########NEW FILE########
__FILENAME__ = fields
from steel.common import args
from steel import fields
from steel.common.fields import *

__all__ = ['Field', 'Integer', 'FixedInteger', 'Flag', 'Reserved']


class Field(fields.Field):
    size = args.Argument(resolve_field=True)
    choices = args.Argument(default=())
    default = args.Argument(default=args.NotProvided)

    def __init__(self, label='', **kwargs):
        self.label = label

        for name, arg in self.arguments.items():
            if name in kwargs:
                value = kwargs.pop(name)
            elif arg.has_default:
                value = arg.default
            else:
                raise TypeError("The %s argument is required for %s fields" % (arg.name, self.__class__.__name__))
            setattr(self, name, value)
        if kwargs:
            raise TypeError("%s is not a valid argument for %s fields" % (list(kwargs.keys())[0], self.__class__.__name__))

        # Once the base values are all in place, arguments can be initialized properly
        for name, arg in self.arguments.items():
            setattr(self, name, arg.initialize(self, getattr(self, name)))


class Integer(fields.Integer):
    size = args.Override(resolve_field=False)
    signed = args.Override(default=False)

    def __init__(self, *args, **kwargs):
        super(Integer, self).__init__(*args, **kwargs)
        self.signing = self.signing.__class__(self.size)

    def encode(self, value):
        if self.signed:
            value = self.signing.encode(value)
        if value > (1 << self.size) - 1:
            raise ValueError("Value is too large for this field.")
        return value & ((1 << self.size) - 1)

    def decode(self, value):
        if value > (1 << self.size) - 1:
            raise ValueError("Value is too large for this field.")
        return self.signing.decode(value & ((1 << self.size) - 1))


class FixedInteger(Integer):
    def __init__(self, value, *args, **kwargs):
        super(FixedInteger, self).__init__(*args, signed=value < 0, **kwargs)
        self.decoded_value = value
        self.encoded_value = super(FixedInteger, self).encode(value)

    def encode(self, value):
        if value != self.decoded_value:
            raise ValueError('Expected %r, got %r.' % (self.decoded_value, value))
        return self.encoded_value

    def decode(self, value):
        if value != self.encoded_value:
            raise ValueError('Expected %r, got %r.' % (self.encoded_value, value))
        return self.decoded_value


class Flag(Integer):
    size = args.Override(default=1)

    def encode(self, value):
        return super(Flag, self).encode(value and 1 or 0)

    def decode(self, value):
        return bool(super(Flag, self).decode(value))


class Reserved(fields.Reserved):
    def encode(self, value):
        return 0



########NEW FILE########
__FILENAME__ = base
import io

from steel.common import meta, args, fields
from steel.fields import Field
from steel.base import Structure
from steel.fields.strings import Bytes

__all__ = ['Chunk', 'Payload', 'ChunkList', 'ChunkStreamer']


class ChunkMetaclass(meta.DeclarativeMetaclass):
    def __init__(cls, name, bases, attrs, **options):
        cls.structure = meta.DeclarativeMetaclass(name, (Structure,), attrs, **options)
        for name, attr in attrs.items():
            if isinstance(attr, Field):
                delattr(cls, name)


class Chunk(metaclass=ChunkMetaclass):
    def __init__(self, id, multiple=False):
        self.id = id
        self.multiple = multiple

    def __call__(self, cls):
        cls._chunk = self
        if not issubclass(cls, ChunkMixin):
            cls.__bases__ = (ChunkMixin,) + cls.__bases__
        return cls

    @classmethod
    def read(cls, file):
        value = cls.structure(file)
        # Force the evaluation of the entire structure in
        # order to make sure other fields work properly
        value_bytes = b''
        for name in cls.structure._fields:
            getattr(value, name)
            value_bytes += value._raw_values[name]

        return value_bytes, value

    def _extract(self, field):
        return self.structure._extract(field)


class ChunkMixin:
    def __init__(self, *args, process_chunk=True, **kwargs):
        if process_chunk and not args:
            process_chunk = False
        if process_chunk:
            chunk = self._chunk.structure(*args, **kwargs)
            for name in chunk._fields:
                getattr(chunk, name)
            id = chunk.id
            id = self._chunk.id
            if chunk.id != self._chunk.id:
                raise ValueError('Expected %r, got %r' % (self._chunk.id, chunk.id))
            super(ChunkMixin, self).__init__(chunk.payload)
            self._chunk_data = chunk
        else:
            super(ChunkMixin, self).__init__(*args, **kwargs)

    def save(self, file):
        payload = io.BytesIO()
        super(ChunkMixin, self).save(payload)
        chunk = self._chunk.structure(id=self._chunk.id)
        chunk.payload = payload.getvalue()
        chunk.size = len(chunk.payload)
        chunk.save(file)


class Payload(Bytes):
    def read(self, file):
        value_bytes = super(Payload, self).read(file)
        raise fields.FullyDecoded(value_bytes, io.BytesIO(value_bytes))


class ChunkList(Field):
    size = args.Override(default=None)

    def __init__(self, base_chunk, known_classes=(), terminator=None, **options):
        self.base_chunk = base_chunk
        self.terminator = terminator
        self.known_types = {cls._chunk.id: cls for cls in known_classes}
        super(ChunkList, self).__init__()

    def read(self, file):
        chunks_bytes = b''
        chunks = ChunkValueList()
        while 1:
            chunk_bytes, chunk = self.base_chunk.read(file)
            chunks_bytes += chunk_bytes
            if chunk.id in self.known_types:
                value = self.known_types[chunk.id](chunk.payload, process_chunk=False)
                if self.terminator and isinstance(chunk, self.terminator):
                    break
                chunks.append(value)
            elif chunk.id:
                # This is a valid chunk, just not a recognized type
                continue
            else:
                # This is not a valid chunk, which is probably the end of the file
                break
        raise fields.FullyDecoded(chunks_bytes, chunks)

    def encode(self, chunks):
        output = io.BytesIO()
        for chunk in chunks:
            if not isinstance(chunk, tuple(self.known_types.values())):
                raise TypeError("Unknown chunk type %r" % chunk._chunk.id)
            chunk.save(output)
        if self.terminator and not isinstance(chunk, self.terminator):
            # The last chunk wasn't a terminator, so add one automatically
            self.terminator().save(output)
        return output.getvalue()


class ChunkValueList(list):
    def of_type(self, type):
        return [chunk for chunk in self if isinstance(chunk, type)]


class ChunkStreamer:
    def __init__(self, base_chunk, terminator=None):
        self.base_chunk = base_chunk
        self.terminator = terminator
        self.parsers = {}

    def parser(self, *chunk_classes):
        def wrapper(func):
            for cls in chunk_classes:
                self.parsers[cls._chunk.id] = func
        return wrapper

    def parse(self, file):
        while 1:
            chunk = self.base_chunk.structure(file)
            if chunk.id in self.parsers:
                for name in chunk._fields:
                    getattr(chunk, name)
                value = self.parsers[chunk.id](chunk.payload, process_chunk=False)
                if self.terminator and isinstance(chunk, self.terminator):
                    break
                yield value
            elif chunk.id:
                # This is a valid chunk, just not a recognized type
                for name in chunk._fields:
                    getattr(chunk, name)
                yield chunk
            else:
                # This is not a valid chunk, which is probably the end of the file
                break


########NEW FILE########
__FILENAME__ = iff
import collections
import io

from steel.fields.numbers import BigEndian
from steel import fields
from steel.chunks import base

__all__ = ['Chunk', 'ChunkList', 'List', 'Form', 'Prop']


class Chunk(base.Chunk):
    id = fields.String(size=4, encoding='ascii')
    size = fields.Integer(size=4, endianness=BigEndian)
    payload = base.Payload(size=size)


class ChunkList(base.ChunkList):
    def __init__(self, *args, **kwargs):
        # Just a simple override to default to a list of IFF chunks
        return super(ChunkList, self).__init__(Chunk, *args, **kwargs)


class List(base.Chunk):
    tag = fields.FixedString(b'LIST')
    size = fields.Integer(size=4, endianness=BigEndian)
    id = fields.String(size=4, encoding='ascii')
    payload = base.Payload(size=size)


class Form(base.Chunk):
    tag = fields.FixedString(b'FORM')
    size = fields.Integer(size=4, endianness=BigEndian)
    id = fields.String(size=4, encoding='ascii')
    payload = base.Payload(size=size)


class Prop(base.Chunk):
    tag = fields.FixedString(b'PROP')
    size = fields.Integer(size=4, endianness=BigEndian)
    id = fields.String(size=4, encoding='ascii')
    payload = base.Payload(size=size)

########NEW FILE########
__FILENAME__ = args
import copy

from steel.common import data

NotProvided = object()

class Argument:
    def __init__(self, positional=False, resolve_field=False, **kwargs):
        self.resolve_field = resolve_field

        # Default can be None, so we have to do some extra work to
        # fall back in the event that no defualt value was provided
        if 'default' in kwargs:
            self.default = kwargs.pop('default')
        else:
            self.default = None
            self.has_default = False

        # Because of all that default mess, we need to make sure kwargs
        # doesn't have any arguments we don't know how to deal with
        if kwargs:
            # Just grab the first one to show in the error message
            raise TypeError('Unknown argument %r' % iter(kwargs).__next__())

    @property
    def default(self):
        return self.__dict__['default']

    @default.setter
    def default(self, value):
        self.__dict__['default'] = value
        self.has_default = True

    @default.deleter
    def default(self):
        self.__dict__['default'] = None
        self.has_default = False

    def set_name(self, name):
        self.name = name

    def attach_to_class(self, cls):
        cls.arguments[self.name] = self

    def init(self, func):
        # Decorator for setting an initialization function
        self.initialize = func
        return func

    def initialize(self, instance, value):
        # By default, initialization doesn't do anything
        return value

    def __get__(self, instance, owner):
        arg = instance.arguments[self.name]
        try:
            value = instance.__dict__[arg.name]
        except KeyError:
            raise AttributeError(self.name)
        key = hash(instance)
        if data.instance_stack[key]:
            instance = data.instance_stack[key][-1]
            if arg.resolve_field and hasattr(value, 'resolve'):
                value = value.resolve(instance)
            elif hasattr(value, '__call__'):
                value = value(instance)
        return value

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value


class Override(Argument):
    def __init__(self, **kwargs):
        # For now, just save the arguments for later
        self.overrides = kwargs.copy()

        # Default can be None, so we have to do some extra work to
        # fall back in the event that no defualt value was provided
        if 'default' in kwargs:
            self.default = kwargs.pop('default')
        else:
            self.default = None
            self.has_default = False

    def attach_to_class(self, cls):
        if self.name not in cls.arguments:
            raise TypeError("%r is not an argument, so it can't be overridden" % self.name)

        argument = copy.copy(cls.arguments[self.name])
        # Replace the original options with any replacements provided
        for name, value in self.overrides.items():
            if hasattr(argument, name):
                setattr(argument, name, value)
            else:
                raise TypeError("%r is not an attribute of %r, so it can't be overridden" % (name, self.name))

        cls.arguments[self.name] = argument

class Removed(Argument):
    def __init__(self):
        # Nothing to do for this part of the process, we just
        # need to prevent the normal behavior from taking place
        pass

    def attach_to_class(self, cls):
        # Remove the argument from the class
        try:
            del cls.arguments[self.name]
        except KeyError:
            raise TypeError("%r is not an argument, so it can't be removed" % self.name)



########NEW FILE########
__FILENAME__ = fields
import copy
import functools
import io
import sys

from steel.common import args, meta, data

__all__ = ['Field', 'FullyDecoded', 'Condition']


class Trigger:
    def __init__(self):
        self.cache = {}
        self.functions = set()

    def __call__(self, func):
        # Used as a decorator
        self.functions.add(func)

    def __get__(self, instance, owner):
        if owner is None:
            return self
        if instance not in self.cache:
            self.cache[instance] = BoundTrigger(instance, self.functions)
        return self.cache[instance]


class BoundTrigger:
    def __init__(self, field, functions):
        self.field = field
        self.functions = set(functools.partial(func, field) for func in functions)

    def __iter__(self):
        return iter(self.functions)

    def __call__(self, func):
        # Used as a decorator
        self.functions.add(func)

    def apply(self, *args, **kwargs):
        # Called from within the appropriate code
        for func in self.functions:
            func(*args, **kwargs)


class Field(metaclass=meta.DeclarativeFieldMetaclass):
    size = args.Argument(resolve_field=True)
    offset = args.Argument(default=None, resolve_field=True)
    choices = args.Argument(default=())
    default = args.Argument(default=args.NotProvided)

    after_encode = Trigger()
    after_decode = Trigger()

    def getter(self, func):
        # For compatibility with typical property usage
        self._getters.append(func)
        return self

    def setter(self, func):
        # For compatibility with typical property usage
        self._setters.append(func)
        return self

    @after_encode
    def update_size(self, obj, value):
        if isinstance(self.size, Field):
            setattr(obj, self.size.name, len(value))

    def __init__(self, label='', **kwargs):
        self.label = label
        self._parent = None
        self.instance = None
        self._getters = []
        self._setters = []

        for name, arg in self.arguments.items():
            if name in kwargs:
                value = kwargs.pop(name)
            elif arg.has_default:
                value = arg.default
            else:
                raise TypeError("The %s argument is required for %s fields" % (arg.name, self.__class__.__name__))
            setattr(self, name, value)
        if kwargs:
            raise TypeError("%s is not a valid argument for %s fields" % (list(kwargs.keys())[0], self.__class__.__name__))

        # Once the base values are all in place, arguments can be initialized properly
        for name, arg in self.arguments.items():
            if hasattr(self, name):
                value = getattr(self, name)
            else:
                value = None
            setattr(self, name, arg.initialize(self, value))

    def resolve(self, instance):
        if self._parent is not None:
            instance = self._parent.resolve(instance)
        return getattr(instance, self.name)

    def read(self, obj):
        # If the size can be determined easily, read
        # that number of bytes and return it directly.
        if self.size is not None:
            return obj.read(self.size)

        # Otherwise, the field needs to supply its own
        # technique for determining how much data to read.
        raise NotImplementedError()

    def write(self, obj, value):
        # By default, this doesn't do much, but individual
        # fields can/should override it if necessary
        obj.write(value)

    def set_name(self, name):
        self.name = name
        label = self.label or name.replace('_', ' ')
        self.label = label.title()

    def attach_to_class(self, cls):
        cls._fields[self.name] = self

    def validate(self, obj, value):
        # This should raise a ValueError if the value is invalid
        # It should simply return without an error if it's valid
        with self.for_instance(obj):
            # First, make sure the value can be encoded
            self.encode(value)
    
            # Then make sure it's a valid option, if applicable
            if self.choices and value not in set(v for v, desc in self.choices):
                raise ValueError("%r is not a valid choice" % value)

    def _extract(self, instance):
        with self.for_instance(instance):
            try:
                return self.read(instance), None
            except FullyDecoded as obj:
                return obj.bytes, obj.value

    def read_value(self, file):
        try:
            bytes = self.read(file)
            value = self.decode(bytes)
            return bytes, value
        except FullyDecoded as obj:
            return obj.bytes, obj.value

    def for_instance(self, instance):
        return meta.AttributeInstance(self, instance)

    def __get__(self, instance, owner):
        if not instance:
            return self

        # Customizes the field for this particular instance
        # Use field instead of self for the rest of the method
        with self.for_instance(instance):
            try:
                value = instance._extract(self)
            except IOError:
                if self.default is not args.NotProvided:
                    return self.default
                raise AttributeError("Attribute %r has no data" % self.name)
    
            if self.name not in instance.__dict__:
                value = self.decode(value)
                self.after_decode.apply(instance, value)

                for getter in self._getters:
                    value = getter(instance, value)

                instance.__dict__[self.name] = value
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        for setter in self._setters:
            value = setter(instance, value)

        with self.for_instance(instance):
            instance.__dict__[self.name] = value
            instance._raw_values[self.name] = self.encode(value)
        self.after_encode.apply(instance, value)

    def __repr__(self):
        return '<%s: %s>' % (self.name, type(self).__name__)

    def __hash__(self):
        return id(self)

    def __eq__(self, other):
        return Condition(self, other, lambda a, b: a == b)

    def __ne__(self, other):
        return Condition(self, other, lambda a, b: a != b)


class FullyDecoded(Exception):
    def __init__(self, bytes, value):
        self.bytes = bytes
        self.value = value


class Condition:
    def __init__(self, a, b, compare):
        self.a = a
        self.b = b
        self.compare = compare

    def __enter__(self):
        # Hack to add the condition to the class without
        # having to explicitly give it a (useless) name
        frame = sys._getframe(1)
        locals = frame.f_locals
        locals[self.get_available_name(locals.keys())] = self

        # This has to come after the frame hack, so that the condition gets
        # placed in the outer namespace, not in the inner 'with' block
        data.field_stack.append([])

        # Return it anyway, just to check if someone does try to give it a name
        return self

    def __exit__(self, 	exception_type, exception, traceback):
        self.fields = data.field_stack.pop()

        # Don't suppress the exception, if any
        return False

    def get_available_name(self, locals):
        i = 0
        while True:
            name = '_condition_%s' % i
            if name not in locals:
                return name
            i += 1

    def set_name(self, name):
        if hasattr(self, 'name'):
            raise TypeError('Field conditions must not use the "as" form')
        self.name = name

    def attach_to_class(self, cls):
        cls._fields[self.name] = self

    def for_instance(self, instance):
        if instance is None:
            return self
        field = copy.copy(self)
        if hasattr(field.a, 'for_instance'):
            field.a = field.a.for_instance(instance)
        if hasattr(field.b, 'for_instance'):
            field.b = field.b.for_instance(instance)
        return field

    def __get__(self, instance, owner):
        if not instance:
            return self
        
        if self.name in instance.__dict__:
            # This condition has already been processed, so don't try getting it again
            return None

        # Customizes the field for this particular instance
        # Use field instead of self for the rest of the method
        with self.for_instance(instance):

            a = self.a
            if hasattr(a, 'resolve'):
                a = a.resolve(instance)

            b = self.b
            if hasattr(b, 'resolve'):
                b = b.resolve(instance)

            if self.compare(a, b):
                # The comparison succeeded, so the fields should be processed

                raw_bytes = b''
                for f in self.fields:
                    with f.for_instance(instance):
                        bytes, value = f.read_value(instance)
                        raw_bytes += bytes
                        instance.__dict__[f.name] = value
                        f.after_decode.apply(instance, value)
                instance._raw_values[self.name] = raw_bytes

        return None


    def __set__(self, instance, value):
        instance.__dict__[self.name] = value
        instance._raw_values[self.name] = b''



########NEW FILE########
__FILENAME__ = meta
import collections

from steel.common import data


class NameAwareOrderedDict(collections.OrderedDict):
    """
    A custom namespace that not only orders its items, but can
    also make those items aware of their names immediately.
    It also helps maintain the list of fields in the stack.
    """

    def __setitem__(self, name, obj):
        if len(data.field_stack) == 1:
            # Only assign to the root namespace if it's not nested in a with block
            super(NameAwareOrderedDict, self).__setitem__(name, obj)

        if hasattr(obj, 'set_name'):
            obj.set_name(name)
            data.field_stack[-1].append(obj)


class DeclarativeMetaclass(type):
    @classmethod
    def __prepare__(cls, name, bases, **options):
        data.field_options = options
        data.field_stack = [[]]
        return NameAwareOrderedDict()

    def __new__(cls, name, bases, attrs, **options):
        # Nothing to do here, but we need to make sure options
        # don't get passed in to type.__new__() itself.
        return type.__new__(cls, name, bases, attrs)

    def __init__(cls, name, bases, attrs, **options):
        cls._fields = collections.OrderedDict()
        # Go backwards so that the left-most classes take priority
        for base in bases:
            if hasattr(base, '_fields'):
                cls._fields.update(base._fields)

        for name, attr in attrs.items():
            if name in cls._fields and attr is None:
                del cls._fields[name]
            if hasattr(attr, 'attach_to_class'):
                attr.attach_to_class(cls)

        data.field_options = {}
        data.field_stack = [[]]


class DeclarativeFieldMetaclass(type):
    @classmethod
    def __prepare__(cls, name, bases, **options):
        return NameAwareOrderedDict()

    def __init__(cls, name, bases, attrs, **options):
        cls.arguments = {}
        # Go backwards so that the left-most classes take priority
        for base in reversed(bases):
            if hasattr(base, 'arguments'):
                cls.arguments.update(base.arguments)

        for name, attr in attrs.items():
            if name in cls.arguments and attr is None:
                del cls.arguments[name]
            if hasattr(attr, 'attach_to_class'):
                attr.attach_to_class(cls)

    def __call__(cls, *args, **kwargs):
        if data.field_options:
            options = {}
            for name, value in data.field_options.items():
                if name in cls.arguments:
                    options[name] = value
            options.update(kwargs)
        else:
            options = kwargs
        return super(DeclarativeFieldMetaclass, cls).__call__(*args, **options)


class AttributeInstance:
    def __init__(self, field, instance):
        self.field = field
        self.instance = instance

    def __enter__(self):
        if self.instance is not None:
            data.instance_stack[hash(self.field)].append(self.instance)

    def __exit__(self, exception_type, exception, traceback):
        if self.instance is not None:
            data.instance_stack[hash(self.field)].pop()



########NEW FILE########
__FILENAME__ = compression
import functools
import zlib

__all__ = ['zlib']


def zlib(func=None, *, level=6):
    """Compress a block of data using the DEFLATE method, wrapped in zlib data"""

    def decorator(cls):
        cls._compressor = zlib.compressobj(level)
        if not issubclass(cls, ZlibMixin):
            cls.__bases__ = (ZlibMixin,) + cls.__bases__
        return cls

    if func is None:
        return decorator
    else:
        return decorator(func)


class ZlibMixin:
    def __init__(self, *args, decompress=True, **kwargs):
        if process_chunk:
            super(ChunkMixin, self).__init__(chunk.payload)
            payload = self._compressor.compress(data)
            for name in chunk._fields:
                getattr(chunk, name)
            id = chunk.id
            id = self._chunk.id
            if chunk.id != self._chunk.id:
                raise ValueError('Expected %r, got %r' % (self._chunk.id, chunk.id))
            super(ChunkMixin, self).__init__(chunk.payload)
        else:
            super(ChunkMixin, self).__init__(*args, **kwargs)

    def save(self, file):
        payload = io.BytesIO()
        super(ChunkMixin, self).save(payload)
        chunk = self._chunk.structure(id=self._chunk.id)
        chunk.payload = payload.getvalue()
        chunk.size = len(chunk.payload)
        chunk.save(file)



########NEW FILE########
__FILENAME__ = base
import sys

from steel.common import args, fields

__all__ = ['Field', 'Reserved']


class Field(fields.Field):
    offset = args.Argument(default=None, resolve_field=True)

    @fields.Field.after_encode
    def update_size(self, obj, value):
        if isinstance(self.size, Field):
            setattr(obj, self.size.name, len(value))

    def read(self, obj):
        # If the size can be determined easily, read
        # that number of bytes and return it directly.
        if self.size is not None:
            return obj.read(self.size)

        # Otherwise, the field needs to supply its own
        # technique for determining how much data to read.
        raise NotImplementedError()

    def write(self, obj, value):
        # By default, this doesn't do much, but individual
        # fields can/should override it if necessary
        obj.write(value)


class Reserved(Field):
    default = args.Override(default=None)

    def __init__(self, *args, **kwargs):
        super(Reserved, self).__init__(*args, **kwargs)

        # Hack to add the reserved field to the class without
        # having to explicitly give it a (likely useless) name
        frame = sys._getframe(2)
        locals = frame.f_locals
        locals[self.get_available_name(locals.keys())] = self

    def get_available_name(self, locals):
        i = 0
        while True:
            name = '_reserved_%s' % i
            if name not in locals:
                return name
            i += 1

    def set_name(self, name):
        if hasattr(self, 'name'):
            raise TypeError('Reserved fields must not be given an attribute name')
        super(Reserved, self).set_name(name)

    def encode(self, value):
        return b'\x00' * self.size

    def decode(self, value):
        return None



########NEW FILE########
__FILENAME__ = compound
import io

from steel.common import args, fields, Remainder

__all__ = ['List', 'Object']


class List(fields.Field):
    size = args.Override(default=None)

    def __init__(self, field, *args, **kwargs):
        super(List, self).__init__(*args, **kwargs)
        self.field = field

    def read(self, file):
        value_bytes = b''
        values = []
        with self.for_instance(self.instance):
            if self.size == -1:
                while True:
                    bytes, value = self.field.read_value(file)
                    if bytes:
                        values.append(value)
                        value_bytes += bytes
                    else:
                        break
            for i in range(self.size):
                bytes, value = self.field.read_value(file)
                value_bytes += bytes
                values.append(value)
        raise fields.FullyDecoded(value_bytes, values)

    def encode(self, values):
        encoded_values = []
        with self.for_instance(self.instance):
            for value in values:
                encoded_values.append(self.field.encode(value))
        return b''.join(encoded_values)


class Object(fields.Field):
    size = args.Override(default=None)

    def __init__(self, structure, *args, **kwargs):
        self.structure = structure
        super(Object, self).__init__(*args, **kwargs)

    def read(self, file):
        value = self.structure(file)
        value._parent = file

        # Force the evaluation of the entire structure in
        # order to make sure other fields work properly
        value_bytes = value.get_raw_bytes()

        raise fields.FullyDecoded(value_bytes, value)

    def encode(self, value):
        output = io.BytesIO()
        value.save(output)
        return output.getvalue()

    def __getattr__(self, name):
        if 'structure' in self.__dict__:
            field = getattr(self.structure, name)
            if field in self.structure._fields.values():
                field = copy.copy(field)
                field._parent = self
                return field
        raise AttributeError(name)

########NEW FILE########
__FILENAME__ = compression
import io
import zlib

from steel.fields import Field
from steel import common


class Zlib(Field):
    def __init__(self, field, *args, **kwargs):
        super(Zlib, self).__init__(*args, **kwargs)
        self.field = field

    def decode(self, value):
        data = zlib.decompress(value)
        with self.for_instance(self.instance):
            return self.field.decode(data)

    def encode(self, value):
        data = self.field.encode(value)
        return zlib.compress(data)


########NEW FILE########
__FILENAME__ = integrity
import collections
import functools
import zlib

from steel.fields.numbers import Integer
from steel.common import args, fields

__all__ = ['CheckSum', 'CRC32', 'Adler32', 'IntegrityError']


class IntegrityError(ValueError):
    pass


class CheckSum(Integer):
    first = args.Argument(default=None)
    last = args.Argument(default=None)

    def attach_to_class(self, cls):
        super(CheckSum, self).attach_to_class(cls)

        self.fields = []
        in_range = False
        for field in cls._fields.values():
            if field is self:
                # Can't go beyond the integrity field itself
                break

            if self.first is None:
                self.first = field

            if field is self.first:
                in_range = True

            if in_range:
                self.fields.append(field)
                field.after_encode(self.update_encoded_value)

            if field is self.last:
                # End of the line
                break

    def build_cache(self, instance):
        for field in self.fields:
            if field.name not in instance._raw_values:
                # Set the value to itself just to update the encoded value
                setattr(instance, field.name, getattr(instance, field.name))

    def read(self, file):
        try:
            given_bytes = super(CheckSum, self).read(file)
            given_value = super(CheckSum, self).decode(given_bytes)
        except fields.FullyDecoded as obj:
            given_bytes = obj.bytes
            given_value = obj.value
        self.build_cache(file)
        if given_value != self.get_calculated_value(file):
            raise IntegrityError('%s does not match calculated value' % self.name)
        raise fields.FullyDecoded(given_bytes, given_value)

    def get_calculated_value(self, instance):
        data = b''.join(instance._extract(field) for field in self.fields)
        return self.calculate(data) & ((1 << self.size * 8) - 1)

    def update_encoded_value(self, instance, value):
        setattr(instance, self.name, self.get_calculated_value(instance))

    def calculate(self, data):
        return sum(data)


class CRC32(CheckSum):
    size = args.Override(default=4)

    def calculate(self, data):
        return zlib.crc32(data)


class Adler32(CheckSum):
    size = args.Override(default=4)

    def calculate(self, data):
        return zlib.adler32(data)



########NEW FILE########
__FILENAME__ = numbers
import decimal

from steel.fields import Field
from steel.common import args, fields

__all__ = ['BigEndian', 'LittleEndian', 'SignMagnitude', 'OnesComplement',
           'TwosComplement', 'Integer', 'FixedInteger', 'FixedPoint',
           'CalculatedValue']


# Endianness options

class BigEndian:
    def __init__(self, size):
        self.size = size

    def encode(self, value):
        return bytes((value >> (self.size - i - 1) * 8) & 0xff for i in range(self.size))

    def decode(self, value):
        return sum(v * 0x100 ** (self.size - i - 1) for i, v in enumerate(value[:self.size]))


class LittleEndian:
    def __init__(self, size):
        self.size = size

    def encode(self, value):
        return bytes((value >> i * 8) & 0xff for i in range(self.size))

    def decode(self, value):
        return sum(v * 0x100 ** i for i, v in enumerate(value[:self.size]))


# Signed Number Representations

class SignMagnitude:
    def __init__(self, size):
        self.size = size

    def encode(self, value):
        if value > (1 << self.size) - 1:
            raise ValueError("Value is too large to encode.")
        if value < 0:
            # Set the sign to negative
            return -value | (1 << (self.size - 1))
        return value

    def decode(self, value):
        if value >> (self.size - 1):
            # The sign is negative
            return -(value ^ (2 ** (self.size - 1)))
        return value


class OnesComplement:
    def __init__(self, size):
        self.size = size

    def encode(self, value):
        if value > (1 << self.size) - 1:
            raise ValueError("Value is too large to encode.")
        if value < 0:
            # Value is negative
            return ~(-value) & (2 ** self.size - 1)
        return value

    def decode(self, value):
        if value >> (self.size - 1):
            # Value is negative
            return -(~value & (2 ** self.size - 1))
        return value


class TwosComplement:
    def __init__(self, size):
        self.size = size

    def encode(self, value):
        if value > (1 << (self.size - 1)) - 1:
            raise ValueError("Value is too large to encode.")
        if value < 0:
            # Value is negative
            return (~(-value) & (2 ** self.size - 1)) + 1
        return value

    def decode(self, value):
        if value > 2 ** (self.size - 1) - 1:
            # Value is negative
            return -(~value & (2 ** self.size - 1)) - 1
        return value


# Numeric types

class Integer(Field):
    size = args.Override(resolve_field=False)

    signed = args.Argument(default=False)
    endianness = args.Argument(default=BigEndian)
    signing = args.Argument(default=TwosComplement)

    @signing.init
    def init_signing(self, value):
        return value(self.size * 8)

    @endianness.init
    def init_endianness(self, value):
        return value(self.size)

    def encode(self, value):
        if self.signed:
            value = self.signing.encode(value)
        elif value < 0:
            raise ValueError("Value cannot be negative.")
        if value > (1 << (self.size * 8)) - 1:
            raise ValueError("Value is large for this field.")
        return self.endianness.encode(value)

    def decode(self, value):
        value = self.endianness.decode(value)
        if self.signed:
            value = self.signing.decode(value)
        return value

    def __add__(self, other):
        return CalculatedValue(self, other, lambda a, b: a + b)
    __radd__ = __add__

    def __sub__(self, other):
        return CalculatedValue(self, other, lambda a, b: a - b)

    def __rsub__(self, other):
        return CalculatedValue(self, other, lambda a, b: b - a)

    def __mul__(self, other):
        return CalculatedValue(self, other, lambda a, b: a * b)
    __rmul__ = __mul__

    def __pow__(self, other):
        return CalculatedValue(self, other, lambda a, b: a ** b)

    def __rpow__(self, other):
        return CalculatedValue(self, other, lambda a, b: b ** a)

    def __truediv__(self, other):
        return CalculatedValue(self, other, lambda a, b: a / b)

    def __rtruediv__(self, other):
        return CalculatedValue(self, other, lambda a, b: b / a)

    def __floordiv__(self, other):
        return CalculatedValue(self, other, lambda a, b: a // b)

    def __rfloordiv__(self, other):
        return CalculatedValue(self, other, lambda a, b: b // a)

    def __divmod__(self, other):
        return CalculatedValue(self, other, lambda a, b: divmod(a, b))

    def __rdivmod__(self, other):
        return CalculatedValue(self, other, lambda a, b: divmod(b, a))

    def __and__(self, other):
        return CalculatedValue(self, other, lambda a, b: a & b)
    __rand__ = __and__

    def __or__(self, other):
        return CalculatedValue(self, other, lambda a, b: a | b)
    __ror__ = __or__

    def __xor__(self, other):
        return CalculatedValue(self, other, lambda a, b: a ^ b)
    __rxor__ = __xor__

    def __lshift__(self, other):
        return CalculatedValue(self, other, lambda a, b: a << b)

    def __rlshift__(self, other):
        return CalculatedValue(self, other, lambda a, b: b << a)

    def __rshift__(self, other):
        return CalculatedValue(self, other, lambda a, b: a >> b)

    def __rrshift__(self, other):
        return CalculatedValue(self, other, lambda a, b: b >> a)

    def __lt__(self, other):
        return fields.Condition(self, other, lambda a, b: a < b)

    def __lte__(self, other):
        return fields.Condition(self, other, lambda a, b: a <= b)

    def __gte__(self, other):
        return fields.Condition(self, other, lambda a, b: a >= b)

    def __gt__(self, other):
        return fields.Condition(self, other, lambda a, b: a > b)


class FixedInteger(Integer):
    def __init__(self, value, *args, size=None, **kwargs):
        if size is None:
            size = int((value.bit_length() + 7) / 8) or 1
        super(FixedInteger, self).__init__(*args, size=size, signed=value < 0, **kwargs)
        self.decoded_value = value
        self.encoded_value = super(FixedInteger, self).encode(value)
        self.default = self.encoded_value

    def encode(self, value):
        if value != self.decoded_value:
            raise ValueError('Expected %r, got %r.' % (self.decoded_value, value))
        return self.encoded_value

    def decode(self, value):
        if value != self.encoded_value:
            raise ValueError('Expected %r, got %r.' % (self.encoded_value, value))
        return self.decoded_value


class FixedPoint(Integer):
    def __init__(self, *args, decimal_places, **kwargs):
        super(FixedPoint, self).__init__(*args, **kwargs)
        self.decimal_places = decimal_places

    def encode(self, value):
        factor = 10 ** self.decimal_places
        value = round(value * self._factor)
        return super(FixedPoint, self).encode(value)

    def decode(self, value):
        factor = 10 ** self.decimal_places
        value = super(FixedPoint, self).decode(value)
        return decimal.Decimal('%d.%d' % (value // factor, value % factor))


class CalculatedValue(Integer):
    def __init__(self, field, other, calculate, **kwargs):
        super(CalculatedValue, self).__init__(size=field.size, **kwargs)
        self.field = field
        self._parent = field._parent
        if isinstance(other, Field) and self.instance:
            other = getattr(self.instance, other.name)
        self.other = other
        self.calculate = calculate
        if hasattr(field, 'name'):
            self.set_name(field.name)

    def read(self, file):
        # Defer to the stored field in order to get a base value
        with self.for_instance(self.instance):
            return self.field.read(file)

    def encode(self, value):
        return self.field.encode(value)

    def decode(self, value):
        return self.calculate(self.field.decode(value), self.other)

    def resolve(self, value):
        if hasattr(self.field, 'name'):
            resolved_value = self.field.resolve(value)
        else:
            return super(CalculatedValue, self).resolve(value)

        resolved_other = self.other
        if hasattr(self.other, 'resolve'):
            resolved_other = self.other.resolve(value)

        return self.calculate(resolved_value, resolved_other)



########NEW FILE########
__FILENAME__ = strings
from steel.fields import Field
from steel.fields.numbers import Integer
from steel.common import args
from steel.common.fields import FullyDecoded


class String(Field):
    size = args.Override(default=None)
    encoding = args.Argument(resolve_field=True)
    padding = args.Argument(default=b'\x00')
    terminator = args.Argument(default=b'\x00')

    def read(self, file):
        if self.size is not None:
            return file.read(self.size)

        else:
            # TODO: There's gotta be a better way, but it works for now
            value = b''
            while True:
                data = file.read(1)
                if data:
                    value += data
                    if data == self.terminator:
                        break
                else:
                    break

        return value

    def decode(self, value):
        return value.rstrip(self.terminator).rstrip(self.padding).decode(self.encoding)

    def encode(self, value):
        value = value.encode(self.encoding)
        if self.size is not None:
            value = value.ljust(self.size, self.padding)
        else:
            value += self.terminator
        return value

    def validate(self, obj, value):
        value = value.encode(self.encoding)
        if self.size is not None:
            if len(value) > self.size:
                raise ValueError("String %r is longer than %r bytes." % (value, self.size))


class LengthIndexedString(String):
    def read(self, file):
        size_bytes, size = Integer(size=self.size).read_value(file)
        value_bytes = file.read(size)
        return size_bytes + value_bytes

    def decode(self, value):
        # Skip the length portion of the byte string before decoding
        return value[self.size:].decode(self.encoding)

    def encode(self, value):
        value_bytes = value.encode(self.encoding)
        size_bytes = Integer(size=self.size).encode(len(value_bytes))
        return size_bytes + value_bytes


class FixedString(String):
    size = args.Override(default=None)
    encoding = args.Override(default='ascii')
    padding = args.Override(default=b'')
    terminator = args.Override(default=b'')

    def __init__(self, value, *args, **kwargs):
        super(FixedString, self).__init__(*args, **kwargs)

        if isinstance(value, bytes):
            # If raw bytes are supplied, encoding is not used
            self.encoded_value = value
            self.decoded_value = value
            self.encoding = None
        elif isinstance(value, str):
            self.decoded_value = value
            self.encoded_value = super(FixedString, self).encode(value)
        self.size = len(self.encoded_value)
        self.default = self.encoded_value

    def read(self, file):
        value = file.read(self.size)

        # Make sure to validate the string, even if it's not explicitly accessed.
        # This will prevent invalid files from being read beyond the fixed string.
        if value != self.encoded_value:
            raise ValueError('Expected %r, got %r.' % (self.encoded_value, value))

        raise FullyDecoded(self.encoded_value, self.decoded_value)

    def decode(self, value):
        if value != self.encoded_value:
            raise ValueError('Expected %r, got %r.' % (self.encoded_value, value))
        return self.decoded_value

    def encode(self, value):
        if value != self.decoded_value:
            raise ValueError('Expected %r, got %r.' % (self.decoded_value, value))
        return self.encoded_value


class Bytes(Field):
    def encode(self, value):
        # Nothing to do here
        return value

    def decode(self, value):
        # Nothing to do here
        return value



########NEW FILE########
__FILENAME__ = fields
import io
import unittest

import steel


class IOTest(unittest.TestCase):
    data = b'\x2a\x42'

    def setUp(self):
        self.input = io.BytesIO(b'\x2a\x42')
        self.output = io.BytesIO()

    def test_read(self):
        field = steel.Field(size=2)
        data = field.read(self.input)
        self.assertEqual(data, self.data)

    def test_write(self):
        field = steel.Field(size=2)
        field.write(self.output, self.data)
        self.assertEqual(self.output.getvalue(), self.data)


class EndiannessTest(unittest.TestCase):
    decoded_value = 42
    
    def test_BigEndian(self):
        endianness = steel.BigEndian(size=2)
        encoded_value = b'\x00*'
        self.assertEqual(endianness.encode(self.decoded_value), encoded_value)
        self.assertEqual(endianness.decode(encoded_value), self.decoded_value)

    def test_LittleEndian(self):
        endianness = steel.LittleEndian(size=2)
        encoded_value = b'*\x00'
        self.assertEqual(endianness.encode(self.decoded_value), encoded_value)
        self.assertEqual(endianness.decode(encoded_value), self.decoded_value)


class SigningTest(unittest.TestCase):
    decoded_value = -42

    def test_SignMagnitude(self):
        signer = steel.SignMagnitude(size=8)
        encoded_value = 0b10101010
        self.assertEqual(bin(signer.encode(self.decoded_value)), bin(encoded_value))
        self.assertEqual(signer.decode(encoded_value), self.decoded_value)
        # Make sure it doesn't muck up positive values
        self.assertEqual(signer.encode(42), 42)
        self.assertEqual(signer.decode(42), 42)

    def test_OnesComplement(self):
        signer = steel.OnesComplement(size=8)
        encoded_value = 0b11010101
        self.assertEqual(bin(signer.encode(self.decoded_value)), bin(encoded_value))
        self.assertEqual(signer.decode(encoded_value), self.decoded_value)
        # Make sure it doesn't muck up positive values
        self.assertEqual(signer.encode(42), 42)
        self.assertEqual(signer.decode(42), 42)

    def test_TwosComplement(self):
        signer = steel.TwosComplement(size=8)
        encoded_value = 0b11010110
        self.assertEqual(bin(signer.encode(self.decoded_value)), bin(encoded_value))
        self.assertEqual(signer.decode(encoded_value), self.decoded_value)
        # Make sure it doesn't muck up positive values
        self.assertEqual(signer.encode(42), 42)
        self.assertEqual(signer.decode(42), 42)


class TestInteger(unittest.TestCase):
    def test_signed(self):
        field = steel.Integer(size=1, signed=True)
        self.assertEqual(field.encode(127), b'\x7f')
        self.assertEqual(field.encode(-127), b'\x81')

        # Values higher than 127 can't be encoded
        with self.assertRaises(ValueError):
            field.encode(128)

    def test_unsigned(self):
        field = steel.Integer(size=1, signed=False)
        self.assertEqual(field.encode(127), b'\x7f')
        self.assertEqual(field.encode(128), b'\x80')

        # Negative values can't be encoded
        with self.assertRaises(ValueError):
            field.encode(-127)

        # Values higher than 255 can't be encoded
        with self.assertRaises(ValueError):
            field.encode(256)


class TestFixedInteger(unittest.TestCase):
    def test(self):
        field = steel.FixedInteger(42, size=1)
        self.assertEqual(field.encode(42), b'\x2a')
        self.assertEqual(field.decode(b'\x2a'), 42)

        with self.assertRaises(ValueError):
            field.encode(43)

        with self.assertRaises(ValueError):
            field.decode(b'\x2b')


class CalculatedValueTest(unittest.TestCase):
    def setUp(self):
        self.field = steel.Integer(size=1)

    def test_add(self):
        calc_field = self.field + 2
        self.assertEqual(calc_field.decode(b'\x2a'), 44)
        calc_field = 2 + self.field
        self.assertEqual(calc_field.decode(b'\x2a'), 44)

    def test_subtract(self):
        calc_field = self.field - 2
        self.assertEqual(calc_field.decode(b'\x2a'), 40)
        calc_field = 42 - self.field
        self.assertEqual(calc_field.decode(b'\x02'), 40)

    def test_multiply(self):
        calc_field = self.field * 2
        self.assertEqual(calc_field.decode(b'\x2a'), 84)
        calc_field = 2 * self.field
        self.assertEqual(calc_field.decode(b'\x2a'), 84)

    def test_power(self):
        calc_field = self.field ** 2
        self.assertEqual(calc_field.decode(b'\x2a'), 1764)
        calc_field = 2 ** self.field
        self.assertEqual(calc_field.decode(b'\x10'), 65536)

    def test_true_divide(self):
        calc_field = self.field / 2
        self.assertEqual(calc_field.decode(b'\x2a'), 21)
        calc_field = 42 / self.field
        self.assertEqual(calc_field.decode(b'\x02'), 21)

    def test_floor_divide(self):
        calc_field = self.field // 2
        self.assertEqual(calc_field.decode(b'\x2a'), 21)
        calc_field = 42 // self.field
        self.assertEqual(calc_field.decode(b'\x02'), 21)

    def test_chaining(self):
        calc_field = self.field + 2 + 2
        self.assertEqual(calc_field.decode(b'\x2a'), 46)
        calc_field = (self.field + 2 - 2) * 5 // 4
        self.assertEqual(calc_field.decode(b'\x2a'), 52)


class StringTest(unittest.TestCase):
    def test_ascii(self):
        field = steel.String(encoding='ascii')
        self.assertEqual(field.encode('test'), b'test\x00')
        self.assertEqual(field.decode(b'test\x00'), 'test')
        
        # Most Unicode can't be encoded in ASCII
        with self.assertRaises(ValueError):
            field.encode('\u00fcber')

    def test_utf8(self):
        field = steel.String(encoding='utf8')
        self.assertEqual(field.encode('\u00fcber'), b'\xc3\xbcber\x00')
        self.assertEqual(field.decode(b'\xc3\xbcber\x00'), '\u00fcber')


class LengthIndexedString(unittest.TestCase):
    encoded_data = b'\x05valid'
    decoded_data = 'valid'

    def setUp(self):
        self.field = steel.LengthIndexedString(size=1, encoding='ascii')

    def test_encode(self):
        self.assertEqual(self.field.encode(self.decoded_data), self.encoded_data)

    def test_extract(self):
        self.assertEqual(self.field.decode(self.encoded_data), self.decoded_data)


class FixedStringTest(unittest.TestCase):
    def test_bytes(self):
        field = steel.FixedString(b'valid')
        field.encode(b'valid')
        field.decode(b'valid')

        with self.assertRaises(ValueError):
            field.decode(b'invalid')

        # Encoding a Unicode string isn't possible with a bytes FixedString
        with self.assertRaises(ValueError):
            field.decode('valid')

    def test_ascii(self):
        field = steel.FixedString('valid')
        field.encode('valid')
        field.decode(b'valid')

        with self.assertRaises(ValueError):
            field.encode('invalid')

        with self.assertRaises(ValueError):
            field.decode(b'invalid')

    def test_utf8(self):
        field = steel.FixedString('\u00fcber', encoding='utf8')
        field.encode('\u00fcber')
        field.decode(b'\xc3\xbcber')

        # If the value doesn't match what was specified, it's an error
        with self.assertRaises(ValueError):
            field.encode('uber')

        with self.assertRaises(ValueError):
            field.decode(b'uber')


class BytesTest(unittest.TestCase):
    data = b'\x42\x00\x2a'

    def test_encode(self):
        field = steel.Bytes(size=3)
        self.assertEqual(field.encode(self.data), self.data)

    def test_extract(self):
        field = steel.Bytes(size=3)
        self.assertEqual(field.decode(self.data), self.data)


class ListTest(unittest.TestCase):
    encoded_data = b'\x42\x52\x2a\x3a'
    decoded_data = [66, 82, 42, 58]

    def setUp(self):
        self.field = steel.List(steel.Integer(size=1), size=4)

    def test_encode(self):
        data = self.field.encode(self.decoded_data)
        self.assertEqual(data, self.encoded_data)

    def test_extract(self):
        bytes, data = self.field.read_value(io.BytesIO(self.encoded_data))
        self.assertSequenceEqual(data, self.decoded_data)


class ZlibTest(unittest.TestCase):
    encoded_data = b'x\x9c+I-.\x01\x00\x04]\x01\xc1'
    decoded_data = 'test'

    def setUp(self):
        self.field = steel.Zlib(steel.String(size=4, encoding='ascii'), size=steel.Remainder)

    def test_encode(self):
        data = self.field.encode(self.decoded_data)
        self.assertEqual(data, self.encoded_data)

    def test_extract(self):
        data = self.field.decode(self.encoded_data)
        self.assertSequenceEqual(data, self.decoded_data)


class CheckSumTest(unittest.TestCase):
    original_data = b'\x00\x01\x02\x03\x00\x04\x00\x00\x00\x05\x00\x0f'
    modified_data = b'\x00\x02\x02\x03\x00\x04\x00\x00\x00\x05\x00\x0f'
    modified_csum = b'\x00\x01\x02\x03\x00\x04\x00\x00\x00\x05\x00\x10'
    modified_both = b'\x00\x02\x02\x03\x00\x04\x00\x00\x00\x05\x00\x10'

    class IntegrityStructure(steel.Structure):
        a = steel.Integer(size=2)
        b = steel.Integer(size=1)
        c = steel.Integer(size=1)
        d = steel.Integer(size=2)
        e = steel.Integer(size=4)
        checksum = steel.CheckSum(size=2)

    def test_encode(self):
        pass
#        data = self.field.encode(self.decoded_data)
#        self.assertEqual(data, self.encoded_data)

    def test_extract(self):
        struct = self.IntegrityStructure(io.BytesIO(self.original_data))
        self.assertEqual(struct.a, 1)
        self.assertEqual(struct.b, 2)
        self.assertEqual(struct.c, 3)
        self.assertEqual(struct.d, 4)
        self.assertEqual(struct.e, 5)
        self.assertEqual(struct.checksum, 15)

    def test_modified_data(self):
        struct = self.IntegrityStructure(io.BytesIO(self.modified_data))
        with self.assertRaises(steel.IntegrityError):
            struct.checksum

    def test_modified_both(self):
        struct = self.IntegrityStructure(io.BytesIO(self.original_data))
        self.assertEqual(struct.a, 1)
        self.assertEqual(struct.b, 2)
        self.assertEqual(struct.c, 3)
        self.assertEqual(struct.d, 4)
        self.assertEqual(struct.e, 5)
        struct.a = 2
        data = io.BytesIO()
        struct.save(data)
        self.assertEqual(data.getvalue(), self.modified_both)

    def test_modified_checksum(self):
        struct = self.IntegrityStructure(io.BytesIO(self.modified_csum))
        with self.assertRaises(steel.IntegrityError):
            struct.checksum


class ReservedTest(unittest.TestCase):
    class ReservedStructure(steel.Structure):
        a = steel.Integer(size=1)
        steel.Reserved(size=1)
        b = steel.Integer(size=1)
    data = b'\x01\x00\x02'

    def test_assignment(self):
        # Giving no name is the correct approach
        class ReservedStructure(steel.Structure):
            steel.Reserved(size=1)

        with self.assertRaises(TypeError):
            class ReservedStructure(steel.Structure):
                name = steel.Reserved(size=1)

    def test_read(self):
        obj = self.ReservedStructure(io.BytesIO(self.data))
        self.assertEqual(obj.a, 1)
        self.assertEqual(obj.b, 2)

    def test_save(self):
        obj = self.ReservedStructure()
        obj.a = 1
        obj.b = 2
        data = io.BytesIO()
        obj.save(data)
        self.assertEqual(data.getvalue(), self.data)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = structures
import io
import unittest

import steel


class AttributeTest(unittest.TestCase):
    def setUp(self):
        class TestStructure(steel.Structure):
            integer = steel.Integer('number', size=1)
            string = steel.String(encoding='ascii')
            
        self.struct = TestStructure

    def test_order(self):
        f1, f2 = self.struct._fields.values()
        self.assertEqual(type(f1), steel.Integer)
        self.assertEqual(type(f2), steel.String)

    def test_names(self):
        f1, f2 = self.struct._fields.values()
        self.assertEqual(f1.name, 'integer')
        self.assertEqual(f2.name, 'string')

    def test_labels(self):
        f1, f2 = self.struct._fields.values()
        self.assertEqual(f1.label, 'Number')
        self.assertEqual(f2.label, 'String')

    def test_assignment(self):
        struct = self.struct()
        struct.integer = 37
        struct.string = 'still valid'
        self.assertEqual(struct.integer, 37)
        self.assertEqual(struct.string, 'still valid')

        struct = self.struct(integer=42, string='valid')
        self.assertEqual(struct.integer, 42)
        self.assertEqual(struct.string, 'valid')

        with self.assertRaises(TypeError):
            struct = self.struct(io.BytesIO(), integer=1, string='invalid')
            
    def test_related(self):
        class TestStructure(steel.Structure):
            length = steel.Integer('number', size=1)
            content = steel.String(encoding='ascii', size=length)
        
        struct = TestStructure(io.BytesIO(b'\x05validpadding'))
        self.assertEqual(struct.length, 5)
        self.assertEqual(struct.content, 'valid')
        
        struct.content = 'automatic'
        self.assertEqual(struct.content, 'automatic')
        self.assertEqual(struct.length, 9)

class IOTest(unittest.TestCase):
    data = b'\x2a\x00\x42valid\x00test\x00'

    def setUp(self):
        self.input = io.BytesIO(self.data)
        self.output = io.BytesIO()
        
        class TestStructure(steel.Structure):
            forty_two = steel.Integer(size=2, endianness=steel.LittleEndian)
            sixty_six = steel.Integer(size=1)
            valid = steel.String(encoding='ascii')
            test = steel.String(encoding='ascii')

        self.struct = TestStructure

    def test_mode(self):
        struct = self.struct(self.input)
        self.assertEqual(struct._mode, 'rb')

        struct = self.struct()
        self.assertEqual(struct._mode, 'wb')

    def test_read(self):
        struct = self.struct(self.input)
        self.assertEqual(struct.read(), self.data)

    def test_write(self):
        struct = self.struct()
        struct.write(self.data)
        self.assertEqual(struct.forty_two, 42)
        self.assertEqual(struct.sixty_six, 66)
        self.assertEqual(struct.valid, 'valid')
        self.assertEqual(struct.test, 'test')

        # Writing just part of the data populates some of the fields
        struct = self.struct()
        struct.write(self.data[:6])
        self.assertEqual(struct.forty_two, 42)
        self.assertEqual(struct.sixty_six, 66)
        with self.assertRaises(AttributeError):
            struct.valid

        # Writing more will populate more fields
        struct.write(self.data[6:12])
        self.assertEqual(struct.forty_two, 42)
        self.assertEqual(struct.sixty_six, 66)
        self.assertEqual(struct.valid, 'valid')
        with self.assertRaises(AttributeError):
            struct.test

        # Finishing up the data populates the rest of the fields
        struct.write(self.data[12:])
        self.assertEqual(struct.forty_two, 42)
        self.assertEqual(struct.sixty_six, 66)
        self.assertEqual(struct.valid, 'valid')
        self.assertEqual(struct.test, 'test')

    def test_attributes(self):
        struct = self.struct(io.BytesIO(self.data))
        self.assertEqual(struct.forty_two, 42)
        self.assertEqual(struct.sixty_six, 66)
        self.assertEqual(struct.valid, 'valid')
        self.assertEqual(struct.test, 'test')

        # Now test them again in a random order
        struct = self.struct(io.BytesIO(self.data))
        self.assertEqual(struct.valid, 'valid')
        self.assertEqual(struct.forty_two, 42)
        self.assertEqual(struct.test, 'test')
        self.assertEqual(struct.sixty_six, 66)

    def test_save(self):
        struct = self.struct()
        struct.forty_two = 42
        struct.sixty_six = 66
        struct.valid = 'valid'
        struct.test = 'test'

        output = io.BytesIO()
        struct.save(output)
        self.assertEqual(output.getvalue(), self.data)

    def test_read_and_save(self):
        struct = self.struct(io.BytesIO(self.data))

        output = io.BytesIO()
        struct.save(output)
        self.assertEqual(output.getvalue(), self.data)


class OptionsTest(unittest.TestCase):
    def test_arguments(self):
        class TestStructure(steel.Structure, attribute='test'):
            pass


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
