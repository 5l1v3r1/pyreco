__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# PyHamcrest documentation build configuration file, created by
# sphinx-quickstart on Sat Dec 25 21:13:30 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

from hamcrest import __version__

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

autodoc_default_flags = ['members', 'show-inheritance']
intersphinx_mapping = {'python': ('http://docs.python.org/2.6', None)}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'PyHamcrest'
copyright = u'2011, hamcrest.org'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
default_role = 'py:obj'

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = False

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'PyHamcrestdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'PyHamcrest.tex', u'PyHamcrest Documentation',
   u'hamcrest.org', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True

# PyHamcrest customization: Don't skip BaseMatcher's _matches method
def skip_member(app, what, name, obj, skip, options):
    if skip and str(obj).find('BaseMatcher._matches') >= 0:
        return False
    return skip

def setup(app):
    app.connect('autodoc-skip-member', skip_member)

# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pyhamcrest', u'PyHamcrest Documentation',
     [u'hamcrest.org'], 1)
]

########NEW FILE########
__FILENAME__ = CustomDateMatcher
import sys
sys.path.append('..')

from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod

from hamcrest import *
import unittest
import datetime


class IsGivenDayOfWeek(BaseMatcher):
    """Matches dates that fall on a given day of the week."""

    def __init__(self, day):
        self.day = day  # Monday is 0, Sunday is 6

    def _matches(self, item):
        """Test whether item matches."""
        if not hasmethod(item, 'weekday'):
            return False
        return item.weekday() == self.day

    def describe_to(self, description):
        """Describe the matcher."""
        day_as_string = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
                         'Friday', 'Saturday', 'Sunday']
        description.append_text('calendar date falling on ')    \
                   .append_text(day_as_string[self.day])


def on_a_saturday():
    """Factory function to generate Saturday matcher."""
    return IsGivenDayOfWeek(5)


class SampleTest(unittest.TestCase):
    def testDateIsOnASaturday(self):
        """Example of successful match."""
        d = datetime.date(2008, 04, 26)
        assert_that(d, is_(on_a_saturday()))

    def testFailsWithMismatchedDate(self):
        """Example of what happens with date that doesn't match."""
        d = datetime.date(2008, 04, 06)
        assert_that(d, is_(on_a_saturday()))

    def testFailsWithNonDate(self):
        """Example of what happens with object that isn't a date."""
        d = 'oops'
        assert_that(d, is_(on_a_saturday()))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = ExampleWithAssertThat
import sys
sys.path.append('..')

from hamcrest import *
import unittest


class ExampleWithAssertThat(unittest.TestCase):
    def testUsingAssertThat(self):
        assert_that('xx', is_('xx'))
        assert_that('yy', is_not('xx'))
        assert_that('i like cheese', contains_string('cheese'))

    def testCanAlsoSupplyDescriptiveReason(self):
        assert_that('xx', is_('xx'), 'description')

    def testCanAlsoAssertPlainBooleans(self):
        assert_that(True, 'This had better not fail')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = assert_that
from __future__ import absolute_import
from hamcrest.core.matcher import Matcher
from hamcrest.core.string_description import StringDescription

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"
# unittest integration; hide these frames from tracebacks
__unittest = True
# py.test integration; hide these frames from tracebacks
__tracebackhide__ = True

def assert_that(arg1, arg2=None, arg3=''):
    """Asserts that actual value satisfies matcher. (Can also assert plain
    boolean condition.)

    :param actual: The object to evaluate as the actual value.
    :param matcher: The matcher to satisfy as the expected condition.
    :param reason: Optional explanation to include in failure description.

    ``assert_that`` passes the actual value to the matcher for evaluation. If
    the matcher is not satisfied, an exception is thrown describing the
    mismatch.

    ``assert_that`` is designed to integrate well with PyUnit and other unit
    testing frameworks. The exception raised for an unmet assertion is an
    :py:exc:`AssertionError`, which PyUnit reports as a test failure.

    With a different set of parameters, ``assert_that`` can also verify a
    boolean condition:

    .. function:: assert_that(assertion[, reason])

    :param assertion:  Boolean condition to verify.
    :param reason:  Optional explanation to include in failure description.

    This is equivalent to the :py:meth:`~unittest.TestCase.assertTrue` method
    of :py:class:`unittest.TestCase`, but offers greater flexibility in test
    writing by being a standalone function.

    """
    if isinstance(arg2, Matcher):
        _assert_match(actual=arg1, matcher=arg2, reason=arg3)
    else:
        _assert_bool(assertion=arg1, reason=arg2)


def _assert_match(actual, matcher, reason):
    if not matcher.matches(actual):
        description = StringDescription()
        description.append_text(reason)             \
                   .append_text('\nExpected: ')     \
                   .append_description_of(matcher)  \
                   .append_text('\n     but: ')
        matcher.describe_mismatch(actual, description)
        description.append_text('\n')
        raise AssertionError(str(description))


def _assert_bool(assertion, reason=None):
    if not assertion:
        if not reason:
            reason = 'Assertion failed'
        raise AssertionError(reason)

########NEW FILE########
__FILENAME__ = base_description
from __future__ import absolute_import
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

import warnings
import six

from hamcrest.core.description import Description
from hamcrest.core.selfdescribingvalue import SelfDescribingValue
from hamcrest.core.helpers.hasmethod import hasmethod

class BaseDescription(Description):
    """Base class for all :py:class:`~hamcrest.core.description.Description`
    implementations.

    """

    def append_text(self, text):
        self.append(text)
        return self

    def append_description_of(self, value):
        if hasmethod(value, 'describe_to'):
            value.describe_to(self)
        elif six.PY3 and isinstance(value, six.text_type):
            self.append(repr(value))
        elif isinstance(value, six.binary_type):
            self.append_string_in_python_syntax(value)
        elif isinstance(value, six.text_type):
            self.append_string_in_python_syntax(value)
        else:
            description = str(value)
            if description[:1] == '<' and description[-1:] == '>':
                self.append(description)
            else:
                self.append('<')
                self.append(description)
                self.append('>')
        return self

    def append_value(self, value):
        warnings.warn('Call append_description_of instead of append_value',
                      DeprecationWarning)
        if isinstance(value, str):
            self.append_string_in_python_syntax(value)
        else:
            self.append('<')
            self.append(str(value))
            self.append('>')
        return self

    def append_value_list(self, start, separator, end, list):
        warnings.warn('Call append_list instead of append_value_list',
                      DeprecationWarning)
        return self.append_list(start, separator, end,
                                map(SelfDescribingValue, list))

    def append_list(self, start, separator, end, list):
        separate = False

        self.append(start)
        for item in list:
            if separate:
                self.append(separator)
            self.append_description_of(item)
            separate = True
        self.append(end)
        return self

    def append(self, string):
        """Append the string to the description."""
        raise NotImplementedError('append')

    def append_string_in_python_syntax(self, string):
        self.append("'")
        for ch in string:
            self.append(character_in_python_syntax(ch))
        self.append("'")


def character_in_python_syntax(ch):
    if ch == "'":
        return "\'"
    elif ch == '\n':
        return '\\n'
    elif ch == '\r':
        return '\\r'
    elif ch == '\t':
        return '\\t'
    else:
        return ch

########NEW FILE########
__FILENAME__ = base_matcher
from __future__ import absolute_import
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.matcher import Matcher
from hamcrest.core.string_description import tostring


class BaseMatcher(Matcher):
    """Base class for all :py:class:`~hamcrest.core.matcher.Matcher`
    implementations.

    Most implementations can just implement :py:obj:`_matches`, leaving the
    handling of any mismatch description to the ``matches`` method. But if it
    makes more sense to generate the mismatch description during the matching,
    override :py:meth:`~hamcrest.core.matcher.Matcher.matches` instead.

    """

    def __str__(self):
        return tostring(self)

    def _matches(self, item):
        raise NotImplementedError('_matches')

    def matches(self, item, mismatch_description=None):
        match_result = self._matches(item)
        if not match_result and mismatch_description:
            self.describe_mismatch(item, mismatch_description)
        return match_result

    def describe_mismatch(self, item, mismatch_description):
        mismatch_description.append_text('was ').append_description_of(item)

########NEW FILE########
__FILENAME__ = compat
__author__ = "Per Fagrell"
__copyright__ = "Copyright 2013 hamcrest.org"
__license__ = "BSD, see License.txt"

__all__ = ['is_callable']

import sys

# callable was not part of py3k until 3.2, so we create this
# generic is_callable to use callable if possible, otherwise
# we use generic homebrew.
if sys.version_info[0] == 3 and sys.version_info[1] < 2:
    def is_callable(function):
        """Return whether the object is callable (i.e., some kind of function)."""
        if function is None:
            return False
        return any("__call__" in klass.__dict__ for klass in type(function).__mro__)
else:
    is_callable = callable

########NEW FILE########
__FILENAME__ = allof
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class AllOf(BaseMatcher):

    def __init__(self, *matchers):
        self.matchers = matchers

    def matches(self, item, mismatch_description=None):
        for matcher in self.matchers:
            if not matcher.matches(item):
                if mismatch_description:
                    mismatch_description.append_description_of(matcher) \
                                        .append_text(' ')
                    matcher.describe_mismatch(item, mismatch_description)
                return False
        return True

    def describe_mismatch(self, item, mismatch_description):
        self.matches(item, mismatch_description)

    def describe_to(self, description):
        description.append_list('(', ' and ', ')', self.matchers)


def all_of(*items):
    """Matches if all of the given matchers evaluate to ``True``.

    :param matcher1,...:  A comma-separated list of matchers.

    The matchers are evaluated from left to right using short-circuit
    evaluation, so evaluation stops as soon as a matcher returns ``False``.

    Any argument that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    """
    return AllOf(*[wrap_matcher(item) for item in items])

########NEW FILE########
__FILENAME__ = anyof
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class AnyOf(BaseMatcher):

    def __init__(self, *matchers):
        self.matchers = matchers

    def _matches(self, item):
        for matcher in self.matchers:
            if matcher.matches(item):
                return True
        return False

    def describe_to(self, description):
        description.append_list('(', ' or ', ')', self.matchers)


def any_of(*items):
    """Matches if any of the given matchers evaluate to ``True``.

    :param matcher1,...:  A comma-separated list of matchers.

    The matchers are evaluated from left to right using short-circuit
    evaluation, so evaluation stops as soon as a matcher returns ``True``.

    Any argument that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    """
    return AnyOf(*[wrap_matcher(item) for item in items])

########NEW FILE########
__FILENAME__ = described_as
from hamcrest.core.base_matcher import BaseMatcher
import re

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


ARG_PATTERN = re.compile('%([0-9]+)')


class DescribedAs(BaseMatcher):

    def __init__(self, description_template, matcher, *values):
        self.template = description_template
        self.matcher = matcher
        self.values = values

    def matches(self, item, mismatch_description=None):
        return self.matcher.matches(item, mismatch_description)

    def describe_mismatch(self, item, mismatch_description):
        self.matcher.describe_mismatch(item, mismatch_description)

    def describe_to(self, description):
        text_start = 0
        for match in re.finditer(ARG_PATTERN, self.template):
            description.append_text(self.template[text_start:match.start()])
            arg_index = int(match.group()[1:])
            description.append_description_of(self.values[arg_index])
            text_start = match.end()

        if text_start < len(self.template):
            description.append_text(self.template[text_start:])


def described_as(description, matcher, *values):
    """Adds custom failure description to a given matcher.

    :param description: Overrides the matcher's description.
    :param matcher: The matcher to satisfy.
    :param value1,...: Optional comma-separated list of substitution values.

    The description may contain substitution placeholders %0, %1, etc. These
    will be replaced by any values that follow the matcher.

    """
    return DescribedAs(description, matcher, *values)

########NEW FILE########
__FILENAME__ = isanything
from hamcrest.core.base_matcher import BaseMatcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsAnything(BaseMatcher):

    def __init__(self, description):
        self.description = description
        if not description:
            self.description = 'ANYTHING'

    def _matches(self, item):
        return True

    def describe_to(self, description):
        description.append_text(self.description)


def anything(description=None):
    """Matches anything.

    :param description: Optional string used to describe this matcher.

    This matcher always evaluates to ``True``. Specify this in composite
    matchers when the value of a particular element is unimportant.

    """
    return IsAnything(description)

########NEW FILE########
__FILENAME__ = isequal
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.matcher import Matcher


class IsEqual(BaseMatcher):

    def __init__(self, equals):
        self.object = equals

    def _matches(self, item):
        return item == self.object

    def describe_to(self, description):
        nested_matcher = isinstance(self.object, Matcher)
        if nested_matcher:
            description.append_text('<')
        description.append_description_of(self.object)
        if nested_matcher:
            description.append_text('>')


def equal_to(obj):
    """Matches if object is equal to a given object.

    :param obj: The object to compare against as the expected value.

    This matcher compares the evaluated object to ``obj`` for equality."""
    return IsEqual(obj)

########NEW FILE########
__FILENAME__ = isinstanceof
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.wrap_matcher import is_matchable_type

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

import types

class IsInstanceOf(BaseMatcher):

    def __init__(self, expected_type):
        if not is_matchable_type(expected_type):
            raise TypeError('IsInstanceOf requires type')
        self.expected_type = expected_type

    def _matches(self, item):
        return isinstance(item, self.expected_type)

    def describe_to(self, description):
        description.append_text('an instance of ')              \
                    .append_text(self.expected_type.__name__)


def instance_of(atype):
    """Matches if object is an instance of, or inherits from, a given type.

    :param atype: The type to compare against as the expected type.

    This matcher checks whether the evaluated object is an instance of
    ``atype`` or an instance of any class that inherits from ``atype``.

    Example::

        instance_of(str)

    """
    return IsInstanceOf(atype)

########NEW FILE########
__FILENAME__ = isnone
from __future__ import absolute_import
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher
from .isnot import is_not


class IsNone(BaseMatcher):

    def _matches(self, item):
        return item is None

    def describe_to(self, description):
        description.append_text('None')


def none():
    """Matches if object is ``None``."""
    return IsNone()


def not_none():
    """Matches if object is not ``None``."""
    return is_not(none())

########NEW FILE########
__FILENAME__ = isnot
from __future__ import absolute_import
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher, Matcher
from hamcrest.core.helpers.wrap_matcher import wrap_matcher, is_matchable_type
from .isequal import equal_to
from .isinstanceof import instance_of


class IsNot(BaseMatcher):

    def __init__(self, matcher):
        self.matcher = matcher

    def _matches(self, item):
        return not self.matcher.matches(item)

    def describe_to(self, description):
        description.append_text('not ').append_description_of(self.matcher)


def wrap_value_or_type(x):
    if is_matchable_type(x):
        return instance_of(x)
    else:
        return wrap_matcher(x)


def is_not(match):
    """Inverts the given matcher to its logical negation.

    :param match: The matcher to negate.

    This matcher compares the evaluated object to the negation of the given
    matcher. If the ``match`` argument is not a matcher, it is implicitly
    wrapped in an :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to
    check for equality, and thus matches for inequality.

    Examples::

        assert_that(cheese, is_not(equal_to(smelly)))
        assert_that(cheese, is_not(smelly))

    """
    return IsNot(wrap_value_or_type(match))

def not_(match):
    """Alias of :py:func:`is_not` for better readability of negations.

    Examples::

        assert_that(alist, not_(has_item(item)))

    """
    return is_not(match)

########NEW FILE########
__FILENAME__ = issame
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher


class IsSame(BaseMatcher):

    def __init__(self, object):
        self.object = object

    def _matches(self, item):
        return item is self.object

    def describe_to(self, description):
        description.append_text('same instance as ')            \
                   .append_text(hex(id(self.object)))           \
                   .append_text(' ')                            \
                   .append_description_of(self.object)

    def describe_mismatch(self, item, mismatch_description):
        mismatch_description.append_text('was ')
        if item is not None:
            mismatch_description.append_text(hex(id(item)))         \
                                .append_text(' ')
        mismatch_description.append_description_of(item)


def same_instance(obj):
    """Matches if evaluated object is the same instance as a given object.

    :param obj: The object to compare against as the expected value.

    This matcher invokes the ``is`` identity operator to determine if the
    evaluated object is the the same object as ``obj``.

    """
    return IsSame(obj)

########NEW FILE########
__FILENAME__ = is_
from __future__ import absolute_import
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.wrap_matcher import wrap_matcher, is_matchable_type
from .isinstanceof import instance_of


class Is(BaseMatcher):

    def __init__(self, matcher):
        self.matcher = matcher

    def matches(self, item, mismatch_description=None):
        return self.matcher.matches(item, mismatch_description)

    def describe_mismatch(self, item, mismatch_description):
        return self.matcher.describe_mismatch(item, mismatch_description)

    def describe_to(self, description):
        description.append_description_of(self.matcher)


def wrap_value_or_type(x):
    if is_matchable_type(x):
        return instance_of(x)
    else:
        return wrap_matcher(x)


def is_(x):
    """Decorates another matcher, or provides shortcuts to the frequently used
    ``is(equal_to(x))`` and ``is(instance_of(x))``.

    :param x: The matcher to satisfy,  or a type for
        :py:func:`~hamcrest.core.core.isinstanceof.instance_of` matching, or an
        expected value for :py:func:`~hamcrest.core.core.isequal.equal_to`
        matching.

    This matcher compares the evaluated object to the given matcher.

    .. note::

        PyHamcrest's ``is_`` matcher is unrelated to Python's ``is`` operator.
        The matcher for object identity is
        :py:func:`~hamcrest.core.core.issame.same_instance`.

    If the ``x`` argument is a matcher, its behavior is retained, but the test
    may be more expressive. For example::

        assert_that(value, less_than(5))
        assert_that(value, is_(less_than(5)))

    If the ``x`` argument is a type, it is wrapped in an
    :py:func:`~hamcrest.core.core.isinstanceof.instance_of` matcher. This makes
    the following statements equivalent::

        assert_that(cheese, instance_of(Cheddar))
        assert_that(cheese, is_(instance_of(Cheddar)))
        assert_that(cheese, is_(Cheddar))

    Otherwise, if the ``x`` argument is not a matcher, it is wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher. This makes the
    following statements equivalent::

        assert_that(cheese, equal_to(smelly))
        assert_that(cheese, is_(equal_to(smelly)))
        assert_that(cheese, is_(smelly))

    Choose the style that makes your expression most readable. This will vary
    depending on context.

    """
    return Is(wrap_value_or_type(x))

########NEW FILE########
__FILENAME__ = raises
from weakref import ref
import re
import sys
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.wrap_matcher import wrap_matcher
from hamcrest.core.compat import is_callable

__author__ = "Per Fagrell"
__copyright__ = "Copyright 2013 hamcrest.org"
__license__ = "BSD, see License.txt"


class Raises(BaseMatcher):
    def __init__(self, expected, pattern=None):
        self.pattern = pattern
        self.expected = expected
        self.actual = None
        self.function = None

    def _matches(self, function):
        if not is_callable(function):
            return False

        self.function = ref(function)
        return self._call_function(function)

    def _call_function(self, function):
        self.actual = None
        try:
            function()
        except Exception:
            self.actual = sys.exc_info()[1]

            if isinstance(self.actual, self.expected):
                if self.pattern is not None:
                    return re.search(self.pattern, str(self.actual)) is not None
                return True
        return False

    def describe_to(self, description):
        description.append_text('Expected a callable raising %s' % self.expected)

    def describe_mismatch(self, item, description):
        if not is_callable(item):
            description.append_text('%s is not callable' % item)
            return

        function = None if self.function is None else self.function()
        if function is None or function is not item:
            self.function = ref(item)
            if not self._call_function(item):
                return

        if self.actual is None:
            description.append_text('No exception raised.')
        elif isinstance(self.actual, self.expected) and self.pattern is not None:
            description.append_text('Correct assertion type raised, but the expected pattern ("%s") not found.' % self.pattern)
            description.append_text('\n          message was: "%s"' % str(self.actual))
        else:
            description.append_text('%s was raised instead' % type(self.actual))


def raises(exception, pattern=None):
    """Matches if the called function raised the expected exception.

    :param exception:  The class of the expected exception
    :param pattern:    Optional regular expression to match exception message.

    Expects the actual to be wrapped by using :py:func:`~hamcrest.core.core.raises.calling`,
    or a callable taking no arguments.
    Optional argument pattern should be a string containing a regular expression.  If provided,
    the string representation of the actual exception - e.g. `str(actual)` - must match pattern.

    Examples::

        assert_that(calling(int).with_args('q'), raises(TypeError))
        assert_that(calling(parse, broken_input), raises(ValueError))
    """
    return Raises(exception, pattern)


class DeferredCallable(object):
    def __init__(self, func):
        self.func = func
        self.args = tuple()
        self.kwargs = {}

    def __call__(self):
        self.func(*self.args, **self.kwargs)

    def with_args(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs
        return self


def calling(func):
    """Wrapper for function call that delays the actual execution so that
    :py:func:`~hamcrest.core.core.raises.raises` matcher can catch any thrown exception.

    :param func: The function or method to be called

    The arguments can be provided with a call to the `with_args` function on the returned
    object::

           calling(my_method).with_args(arguments, and_='keywords')
    """
    return DeferredCallable(func)

########NEW FILE########
__FILENAME__ = description
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class Description(object):
    """A description of a :py:class:`~hamcrest.core.matcher.Matcher`.

    A :py:class:`~hamcrest.core.matcher.Matcher` will describe itself to a
    description which can later be used for reporting.

    """

    def append_text(self, text):
        """Appends some plain text to the description.

        :returns: ``self``, for chaining

        """
        raise NotImplementedError('append_text')

    def append_description_of(self, value):
        """Appends description of given value to this description.

        If the value implements
        :py:meth:`~hamcrest.core.selfdescribing.SelfDescribing.describe_to`,
        then it will be used.

        :returns: ``self``, for chaining

        """
        raise NotImplementedError('append_description_of')

    def append_value(self, value):
        """Appends an arbitary value to the description.

        **Deprecated:** Call
        :py:meth:`~hamcrest.core.description.Description.append_description_of`
        instead.

        :returns: ``self``, for chaining

        """
        raise NotImplementedError('append_value')

    def append_list(self, start, separator, end, list):
        """Appends a list of objects to the description.

        :param start: String that will begin the list description.
        :param separator: String that will separate each object in the
            description.
        :param end: String that will end the list description.
        :param list: List of objects to be described.

        :returns: ``self``, for chaining

        """
        raise NotImplementedError('append_list')

########NEW FILE########
__FILENAME__ = hasmethod
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


def hasmethod(obj, methodname):
    """Does ``obj`` have a method named ``methodname``?"""

    if not hasattr(obj, methodname):
        return False
    method = getattr(obj, methodname)
    return callable(method)

########NEW FILE########
__FILENAME__ = wrap_matcher
import six

from hamcrest.core.base_matcher import Matcher
from hamcrest.core.core.isequal import equal_to

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

import types

def wrap_matcher(x):
    """Wraps argument in a matcher, if necessary.

    :returns: the argument as-is if it is already a matcher, otherwise wrapped
        in an :py:func:`~hamcrest.core.core.isequal.equal_to` matcher.

    """
    if isinstance(x, Matcher):
        return x
    else:
        return equal_to(x)

def is_matchable_type(expected_type):
    if isinstance(expected_type, type):
        return True

    if isinstance(expected_type, six.class_types):
        return True

    return False

########NEW FILE########
__FILENAME__ = matcher
from __future__ import absolute_import
from .selfdescribing import SelfDescribing

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class Matcher(SelfDescribing):
    """A matcher over acceptable values.

    A matcher is able to describe itself to give feedback when it fails.

    Matcher implementations should *not* directly implement this protocol.
    Instead, *extend* the :py:class:`~hamcrest.core.base_matcher.BaseMatcher`
    class, which will ensure that the
    :py:class:`~hamcrest.core.matcher.Matcher` API can grow to support new
    features and remain compatible with all
    :py:class:`~hamcrest.core.matcher.Matcher` implementations.

    """

    def matches(self, item, mismatch_description=None):
        """Evaluates the matcher for argument item.

        If a mismatch is detected and argument ``mismatch_description`` is
        provided, it will generate a description of why the matcher has not
        accepted the item.

        :param item: The object against which the matcher is evaluated.
        :returns: ``True`` if ``item`` matches, otherwise ``False``.

        """
        raise NotImplementedError('matches')

    def describe_mismatch(self, item, mismatch_description):
        """Generates a description of why the matcher has not accepted the
        item.

        The description will be part of a larger description of why a matching
        failed, so it should be concise.

        This method assumes that ``matches(item)`` is ``False``, but will not
        check this.

        :param item: The item that the
            :py:class:`~hamcrest.core.matcher.Matcher` has rejected.
        :param mismatch_description: The description to be built or appended
            to.

        """
        raise NotImplementedError('describe_mismatch')

########NEW FILE########
__FILENAME__ = selfdescribing
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class SelfDescribing(object):
    """The ability of an object to describe itself."""

    def describe_to(self, description):
        """Generates a description of the object.

        The description may be part of a description of a larger object of
        which this is just a component, so it should be worded appropriately.

        :param description: The description to be built or appended to.

        """
        raise NotImplementedError('describe_to')

########NEW FILE########
__FILENAME__ = selfdescribingvalue
from hamcrest.core.selfdescribing import SelfDescribing

import warnings

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class SelfDescribingValue(SelfDescribing):
    """Wrap any value in a ``SelfDescribingValue`` to satisfy the
    :py:class:`~hamcrest.core.selfdescribing.SelfDescribing` interface.

    **Deprecated:** No need for this class now that
    :py:meth:`~hamcrest.core.description.Description.append_description_of`
    handles any type of value.

    """

    def __init__(self, value):
        warnings.warn('SelfDescribingValue no longer needed',
                      DeprecationWarning)
        self.value = value

    def describe_to(self, description):
        """Generates a description of the value."""
        description.append_value(self.value)

########NEW FILE########
__FILENAME__ = string_description
from __future__ import absolute_import
from .base_description import BaseDescription

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


def tostring(selfdescribing):
    """Returns the description of a
    :py:class:`~hamcrest.core.selfdescribing.SelfDescribing` object as a
    string.

    :param selfdescribing: The object to be described.
    :returns: The description of the object.
    """
    return str(StringDescription().append_description_of(selfdescribing))


class StringDescription(BaseDescription):
    """A :py:class:`~hamcrest.core.description.Description` that is stored as a
    string.

    """

    def __init__(self):
        self.out = ''

    def __str__(self):
        """Returns the description."""
        return self.out

    def append(self, string):
        self.out += string

########NEW FILE########
__FILENAME__ = isdict_containing
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsDictContaining(BaseMatcher):

    def __init__(self, key_matcher, value_matcher):
        self.key_matcher = key_matcher
        self.value_matcher = value_matcher

    def _matches(self, dictionary):
        if hasmethod(dictionary, 'items'):
            for key, value in dictionary.items():
                if self.key_matcher.matches(key) and self.value_matcher.matches(value):
                    return True
        return False

    def describe_to(self, description):
        description.append_text('a dictionary containing [')        \
                    .append_description_of(self.key_matcher)        \
                    .append_text(': ')                              \
                    .append_description_of(self.value_matcher)      \
                    .append_text(']')


def has_entry(key_match, value_match):
    """Matches if dictionary contains key-value entry satisfying a given pair
    of matchers.

    :param key_match: The matcher to satisfy for the key, or an expected value
        for :py:func:`~hamcrest.core.core.isequal.equal_to` matching.
    :param value_match: The matcher to satisfy for the value, or an expected
        value for :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    This matcher iterates the evaluated dictionary, searching for any key-value
    entry that satisfies ``key_match`` and ``value_match``. If a matching entry
    is found, ``has_entry`` is satisfied.

    Any argument that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    Examples::

        has_entry(equal_to('foo'), equal_to(1))
        has_entry('foo', 1)

    """
    return IsDictContaining(wrap_matcher(key_match), wrap_matcher(value_match))

########NEW FILE########
__FILENAME__ = isdict_containingentries
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsDictContainingEntries(BaseMatcher):

    def __init__(self, value_matchers):
        self.value_matchers = value_matchers

    def _not_a_dictionary(self, dictionary, mismatch_description):
        if mismatch_description:
            mismatch_description.append_description_of(dictionary) \
                                .append_text(' is not a mapping object')
        return False

    def matches(self, dictionary, mismatch_description=None):
        for key in self.value_matchers:

            try:
                if not key in dictionary:
                    if mismatch_description:
                        mismatch_description.append_text('no ')             \
                                            .append_description_of(key)     \
                                            .append_text(' key in ')        \
                                            .append_description_of(dictionary)
                    return False
            except TypeError:
                return self._not_a_dictionary(dictionary, mismatch_description)

            value_matcher = self.value_matchers[key]
            try:
                actual_value = dictionary[key]
            except TypeError:
                return self._not_a_dictionary(dictionary, mismatch_description)

            if not value_matcher.matches(actual_value):
                if mismatch_description:
                    mismatch_description.append_text('value for ')  \
                                        .append_description_of(key) \
                                        .append_text(' ')
                    value_matcher.describe_mismatch(actual_value, mismatch_description)
                return False

        return True

    def describe_mismatch(self, item, mismatch_description):
        self.matches(item, mismatch_description)

    def describe_keyvalue(self, index, description):
        """Describes key-value pair at given index."""
        description.append_description_of(index)                        \
                   .append_text(': ')                                   \
                   .append_description_of(self.value_matchers[index])

    def describe_to(self, description):
        description.append_text('a dictionary containing {')
        first = True
        for key in self.value_matchers:
            if not first:
                description.append_text(', ')
            self.describe_keyvalue(key, description)
            first = False
        description.append_text('}')


def has_entries(*keys_valuematchers, **kv_args):
    """Matches if dictionary contains entries satisfying a dictionary of keys
    and corresponding value matchers.

    :param matcher_dict: A dictionary mapping keys to associated value matchers,
        or to expected values for
        :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    Note that the keys must be actual keys, not matchers. Any value argument
    that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    Examples::

        has_entries({'foo':equal_to(1), 'bar':equal_to(2)})
        has_entries({'foo':1, 'bar':2})

    ``has_entries`` also accepts a list of keyword arguments:

    .. function:: has_entries(keyword1=value_matcher1[, keyword2=value_matcher2[, ...]])

    :param keyword1: A keyword to look up.
    :param valueMatcher1: The matcher to satisfy for the value, or an expected
        value for :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    Examples::

        has_entries(foo=equal_to(1), bar=equal_to(2))
        has_entries(foo=1, bar=2)

    Finally, ``has_entries`` also accepts a list of alternating keys and their
    value matchers:

    .. function:: has_entries(key1, value_matcher1[, ...])

    :param key1: A key (not a matcher) to look up.
    :param valueMatcher1: The matcher to satisfy for the value, or an expected
        value for :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    Examples::

        has_entries('foo', equal_to(1), 'bar', equal_to(2))
        has_entries('foo', 1, 'bar', 2)

    """
    if len(keys_valuematchers) == 1:
        try:
            base_dict = keys_valuematchers[0].copy()
            for key in base_dict:
                base_dict[key] = wrap_matcher(base_dict[key])
        except AttributeError:
            raise ValueError('single-argument calls to has_entries must pass a dict as the argument')
    else:
        if len(keys_valuematchers) % 2:
            raise ValueError('has_entries requires key-value pairs')
        base_dict = {}
        for index in range(int(len(keys_valuematchers) / 2)):
            base_dict[keys_valuematchers[2 * index]] = wrap_matcher(keys_valuematchers[2 * index + 1])

    for key, value in kv_args.items():
        base_dict[key] = wrap_matcher(value)

    return IsDictContainingEntries(base_dict)

########NEW FILE########
__FILENAME__ = isdict_containingkey
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsDictContainingKey(BaseMatcher):

    def __init__(self, key_matcher):
        self.key_matcher = key_matcher

    def _matches(self, dictionary):
        if hasmethod(dictionary, 'keys'):
            for key in dictionary.keys():
                if self.key_matcher.matches(key):
                    return True
        return False

    def describe_to(self, description):
        description.append_text('a dictionary containing key ')     \
                    .append_description_of(self.key_matcher)


def has_key(key_match):
    """Matches if dictionary contains an entry whose key satisfies a given
    matcher.

    :param key_match: The matcher to satisfy for the key, or an expected value
        for :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    This matcher iterates the evaluated dictionary, searching for any key-value
    entry whose key satisfies the given matcher. If a matching entry is found,
    ``has_key`` is satisfied.

    Any argument that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    Examples::

        has_key(equal_to('foo'))
        has_key('foo')

    """
    return IsDictContainingKey(wrap_matcher(key_match))

########NEW FILE########
__FILENAME__ = isdict_containingvalue
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsDictContainingValue(BaseMatcher):

    def __init__(self, value_matcher):
        self.value_matcher = value_matcher

    def _matches(self, dictionary):
        if hasmethod(dictionary, 'values'):
            for value in dictionary.values():
                if self.value_matcher.matches(value):
                    return True
        return False

    def describe_to(self, description):
        description.append_text('a dictionary containing value ')   \
                    .append_description_of(self.value_matcher)


def has_value(value):
    """Matches if dictionary contains an entry whose value satisfies a given
    matcher.

    :param value_match: The matcher to satisfy for the value, or an expected
        value for :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    This matcher iterates the evaluated dictionary, searching for any key-value
    entry whose value satisfies the given matcher. If a matching entry is
    found, ``has_value`` is satisfied.

    Any argument that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    Examples::

        has_value(equal_to('bar'))
        has_value('bar')

    """
    return IsDictContainingValue(wrap_matcher(value))

########NEW FILE########
__FILENAME__ = isin
from hamcrest.core.base_matcher import BaseMatcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsIn(BaseMatcher):

    def __init__(self, sequence):
        self.sequence = sequence

    def _matches(self, item):
        return item in self.sequence

    def describe_to(self, description):
        description.append_text('one of ')      \
                   .append_list('(', ', ', ')', self.sequence)


def is_in(sequence):
    """Matches if evaluated object is present in a given sequence.

    :param sequence: The sequence to search.

    This matcher invokes the ``in`` membership operator to determine if the
    evaluated object is a member of the sequence.

    """
    return IsIn(sequence)

########NEW FILE########
__FILENAME__ = issequence_containing
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.core.allof import all_of
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher


class IsSequenceContaining(BaseMatcher):

    def __init__(self, element_matcher):
        self.element_matcher = element_matcher

    def _matches(self, sequence):
        try:
            for item in sequence:
                if self.element_matcher.matches(item):
                    return True
        except TypeError: # not a sequence
            return False

    def describe_to(self, description):
        description.append_text('a sequence containing ')           \
                    .append_description_of(self.element_matcher)


# It'd be great to make use of all_of, but we can't be sure we won't
# be seeing a one-time sequence here (like a generator); see issue #20
# Instead, we wrap it inside a class that will convert the sequence into
# a concrete list and then hand it off to the all_of matcher.
class IsSequenceContainingEvery(BaseMatcher):

    def __init__(self, *element_matchers):
        delegates = [has_item(e) for e in element_matchers]
        self.matcher = all_of(*delegates)

    def _matches(self, sequence):
        try:
            return self.matcher.matches(list(sequence))
        except TypeError:
            return False

    def describe_mismatch(self, item, mismatch_description):
        self.matcher.describe_mismatch(item, mismatch_description)

    def describe_to(self, description):
        self.matcher.describe_to(description)



def has_item(match):
    """Matches if any element of sequence satisfies a given matcher.

    :param match: The matcher to satisfy, or an expected value for
        :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    This matcher iterates the evaluated sequence, searching for any element
    that satisfies a given matcher. If a matching element is found,
    ``has_item`` is satisfied.

    If the ``match`` argument is not a matcher, it is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    """
    return IsSequenceContaining(wrap_matcher(match))


def has_items(*items):
    """Matches if all of the given matchers are satisfied by any elements of
    the sequence.

    :param match1,...: A comma-separated list of matchers.

    This matcher iterates the given matchers, searching for any elements in the
    evaluated sequence that satisfy them. If each matcher is satisfied, then
    ``has_items`` is satisfied.

    Any argument that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    """
    matchers = []
    for item in items:
        matchers.append(wrap_matcher(item))
    return IsSequenceContainingEvery(*matchers)

########NEW FILE########
__FILENAME__ = issequence_containinginanyorder
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class MatchInAnyOrder(object):
    def __init__(self, matchers, mismatch_description):
        self.matchers = matchers[:]
        self.mismatch_description = mismatch_description

    def matches(self, item):
        return self.isnotsurplus(item) and self.ismatched(item)

    def isfinished(self, sequence):
        if not self.matchers:
            return True
        if self.mismatch_description:
            self.mismatch_description.append_text('no item matches: ')      \
                                .append_list('', ', ', '', self.matchers)   \
                                .append_text(' in ')                        \
                                .append_list('[', ', ', ']', sequence)
        return False

    def isnotsurplus(self, item):
        if not self.matchers:
            if self.mismatch_description:
                self.mismatch_description.append_text('not matched: ')  \
                                         .append_description_of(item)
            return False
        return True

    def ismatched(self, item):
        for index, matcher in enumerate(self.matchers):
            if matcher.matches(item):
                del self.matchers[index]
                return True

        if self.mismatch_description:
            self.mismatch_description.append_text('not matched: ')  \
                                     .append_description_of(item)
        return False


class IsSequenceContainingInAnyOrder(BaseMatcher):

    def __init__(self, matchers):
        self.matchers = matchers

    def matches(self, sequence, mismatch_description=None):
        try:
            sequence = list(sequence)
            matchsequence = MatchInAnyOrder(self.matchers, mismatch_description)
            for item in sequence:
                if not matchsequence.matches(item):
                    return False
            return matchsequence.isfinished(sequence)
        except TypeError:
            if mismatch_description:
                super(IsSequenceContainingInAnyOrder, self)             \
                    .describe_mismatch(sequence, mismatch_description)
            return False

    def describe_mismatch(self, item, mismatch_description):
        self.matches(item, mismatch_description)

    def describe_to(self, description):
        description.append_text('a sequence over ')             \
                   .append_list('[', ', ', ']', self.matchers)  \
                   .append_text(' in any order')


def contains_inanyorder(*items):
    """Matches if sequences's elements, in any order, satisfy a given list of
    matchers.

    :param match1,...: A comma-separated list of matchers.

    This matcher iterates the evaluated sequence, seeing if each element
    satisfies any of the given matchers. The matchers are tried from left to
    right, and when a satisfied matcher is found, it is no longer a candidate
    for the remaining elements. If a one-to-one correspondence is established
    between elements and matchers, ``contains_inanyorder`` is satisfied.

    Any argument that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    """

    matchers = []
    for item in items:
        matchers.append(wrap_matcher(item))
    return IsSequenceContainingInAnyOrder(matchers)

########NEW FILE########
__FILENAME__ = issequence_containinginorder
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher


class MatchingInOrder(object):
    def __init__(self, matchers, mismatch_description):
        self.matchers = matchers
        self.mismatch_description = mismatch_description
        self.next_match_index = 0

    def matches(self, item):
        return self.isnotsurplus(item) and self.ismatched(item)

    def isfinished(self):
        if self.next_match_index < len(self.matchers):
            if self.mismatch_description:
                self.mismatch_description.append_text('No item matched: ') \
                                 .append_description_of(self.matchers[self.next_match_index])
            return False
        return True

    def ismatched(self, item):
        matcher = self.matchers[self.next_match_index]
        if not matcher.matches(item):
            if self.mismatch_description:
                self.mismatch_description.append_text('item ' + str(self.next_match_index) + ': ')
                matcher.describe_mismatch(item, self.mismatch_description)
            return False
        self.next_match_index += 1
        return True

    def isnotsurplus(self, item):
        if len(self.matchers) <= self.next_match_index:
            if self.mismatch_description:
                self.mismatch_description.append_text('Not matched: ')  \
                                         .append_description_of(item)
            return False
        return True


class IsSequenceContainingInOrder(BaseMatcher):

    def __init__(self, matchers):
        self.matchers = matchers

    def matches(self, sequence, mismatch_description=None):
        try:
            matchsequence = MatchingInOrder(self.matchers, mismatch_description)
            for item in sequence:
                if not matchsequence.matches(item):
                    return False
            return matchsequence.isfinished()
        except TypeError:
            if mismatch_description:
                super(IsSequenceContainingInOrder, self)                \
                    .describe_mismatch(sequence, mismatch_description)
            return False

    def describe_mismatch(self, item, mismatch_description):
        self.matches(item, mismatch_description)

    def describe_to(self, description):
        description.append_text('a sequence containing ')   \
                   .append_list('[', ', ', ']', self.matchers)


def contains(*items):
    """Matches if sequence's elements satisfy a given list of matchers, in order.

    :param match1,...: A comma-separated list of matchers.

    This matcher iterates the evaluated sequence and a given list of matchers,
    seeing if each element satisfies its corresponding matcher.

    Any argument that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    """
    matchers = []
    for item in items:
        matchers.append(wrap_matcher(item))
    return IsSequenceContainingInOrder(matchers)

########NEW FILE########
__FILENAME__ = issequence_onlycontaining
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.core.anyof import any_of
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsSequenceOnlyContaining(BaseMatcher):

    def __init__(self, matcher):
        self.matcher = matcher

    def _matches(self, sequence):
        try:
            sequence = list(sequence)
            if len(sequence) == 0:
                return False
            for item in sequence:
                if not self.matcher.matches(item):
                    return False
            return True
        except TypeError:
            return False

    def describe_to(self, description):
        description.append_text('a sequence containing items matching ')    \
                    .append_description_of(self.matcher)


def only_contains(*items):
    """Matches if each element of sequence satisfies any of the given matchers.

    :param match1,...: A comma-separated list of matchers.

    This matcher iterates the evaluated sequence, confirming whether each
    element satisfies any of the given matchers.

    Example::

        only_contains(less_than(4))

    will match ``[3,1,2]``.

    Any argument that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    """
    matchers = []
    for item in items:
        matchers.append(wrap_matcher(item))
    return IsSequenceOnlyContaining(any_of(*matchers))

########NEW FILE########
__FILENAME__ = is_empty
from hamcrest.core.base_matcher import BaseMatcher

__author__ = "Chris Rose"
__copyright__ = "Copyright 2012 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsEmpty(BaseMatcher):

    def matches(self, item, mismatch_description=None):
        try:
            if len(item) == 0:
                return True

            if mismatch_description:
                mismatch_description \
                    .append_text('has %d item(s)' % len(item))

        except TypeError:
            if mismatch_description:
                mismatch_description \
                    .append_text('does not support length')

            return False

    def describe_to(self, description):
        description.append_text('an empty collection')


def empty():
    """
    This matcher matches any collection-like object that responds to the
    __len__ method, and has a length of 0.
    """
    return IsEmpty()

########NEW FILE########
__FILENAME__ = match_equality
from hamcrest.core.string_description import tostring
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Chris Rose"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"
__unittest = True


class EqualityWrapper(object):

    def __init__(self, matcher):
        self.matcher = matcher

    def __eq__(self, object):
        return self.matcher.matches(object)

    def __str__(self):
        return repr(self)

    def __repr__(self):
        return tostring(self.matcher)


def match_equality(matcher):
    """Wraps a matcher to define equality in terms of satisfying the matcher.

    ``match_equality`` allows Hamcrest matchers to be used in libraries that
    are not Hamcrest-aware. They might use the equality operator::

        assert match_equality(matcher) == object

    Or they might provide a method that uses equality for its test::

        library.method_that_tests_eq(match_equality(matcher))

    One concrete example is integrating with the ``assert_called_with`` methods
    in Michael Foord's `mock <http://www.voidspace.org.uk/python/mock/>`_
    library.

    """
    return EqualityWrapper(wrap_matcher(matcher))

########NEW FILE########
__FILENAME__ = iscloseto
import six
from hamcrest.core.base_matcher import BaseMatcher
from math import fabs

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


def isnumeric(value):
    """Confirm that 'value' can be treated numerically; duck-test accordingly
    """
    if isinstance(value, (float, complex) + six.integer_types):
        return True

    try:
        _ = (fabs(value) + 0 - 0) * 1
        return True
    except ArithmeticError:
        return True
    except:
        return False
    return False


class IsCloseTo(BaseMatcher):

    def __init__(self, value, delta):
        if not isnumeric(value):
            raise TypeError('IsCloseTo value must be numeric')
        if not isnumeric(delta):
            raise TypeError('IsCloseTo delta must be numeric')

        self.value = value
        self.delta = delta

    def _matches(self, item):
        if not isnumeric(item):
            return False
        return fabs(item - self.value) <= self.delta

    def describe_mismatch(self, item, mismatch_description):
        if not isnumeric(item):
            super(IsCloseTo, self).describe_mismatch(item, mismatch_description)
        else:
            actual_delta = fabs(item - self.value)
            mismatch_description.append_description_of(item)            \
                                .append_text(' differed by ')           \
                                .append_description_of(actual_delta)

    def describe_to(self, description):
        description.append_text('a numeric value within ')  \
                   .append_description_of(self.delta)       \
                   .append_text(' of ')                     \
                   .append_description_of(self.value)


def close_to(value, delta):
    """Matches if object is a number close to a given value, within a given
    delta.

    :param value: The value to compare against as the expected value.
    :param delta: The maximum delta between the values for which the numbers
        are considered close.

    This matcher compares the evaluated object against ``value`` to see if the
    difference is within a positive ``delta``.

    Example::

        close_to(3.0, 0.25)

    """
    return IsCloseTo(value, delta)

########NEW FILE########
__FILENAME__ = ordering_comparison
from hamcrest.core.base_matcher import BaseMatcher
import operator

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class OrderingComparison(BaseMatcher):

    def __init__(self, value, comparison_function, comparison_description):
        self.value = value
        self.comparison_function = comparison_function
        self.comparison_description = comparison_description

    def _matches(self, item):
        return self.comparison_function(item, self.value)

    def describe_to(self, description):
        description.append_text('a value ')                     \
                   .append_text(self.comparison_description)    \
                   .append_text(' ')                            \
                   .append_description_of(self.value)


def greater_than(value):
    """Matches if object is greater than a given value.

    :param value: The value to compare against.

    """
    return OrderingComparison(value, operator.gt, 'greater than')


def greater_than_or_equal_to(value):
    """Matches if object is greater than or equal to a given value.

    :param value: The value to compare against.

    """
    return OrderingComparison(value, operator.ge, 'greater than or equal to')


def less_than(value):
    """Matches if object is less than a given value.

    :param value: The value to compare against.

    """
    return OrderingComparison(value, operator.lt, 'less than')


def less_than_or_equal_to(value):
    """Matches if object is less than or equal to a given value.

    :param value: The value to compare against.

    """
    return OrderingComparison(value, operator.le, 'less than or equal to')

########NEW FILE########
__FILENAME__ = haslength
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class HasLength(BaseMatcher):

    def __init__(self, len_matcher):
        self.len_matcher = len_matcher

    def _matches(self, item):
        if not hasmethod(item, '__len__'):
            return False
        return self.len_matcher.matches(len(item))

    def describe_mismatch(self, item, mismatch_description):
        super(HasLength, self).describe_mismatch(item, mismatch_description)
        if hasmethod(item, '__len__'):
            mismatch_description.append_text(' with length of ')    \
                                .append_description_of(len(item))

    def describe_to(self, description):
        description.append_text('an object with length of ')    \
                    .append_description_of(self.len_matcher)


def has_length(match):
    """Matches if ``len(item)`` satisfies a given matcher.

    :param match: The matcher to satisfy, or an expected value for
        :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    This matcher invokes the :py:func:`len` function on the evaluated object to
    get its length, passing the result to a given matcher for evaluation.

    If the ``match`` argument is not a matcher, it is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    :equality.

    Examples::

        has_length(greater_than(6))
        has_length(5)

    """
    return HasLength(wrap_matcher(match))

########NEW FILE########
__FILENAME__ = hasproperty
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core import anything
from hamcrest.core.core.allof import all_of
from hamcrest.core.string_description import StringDescription
from hamcrest.core.helpers.hasmethod import hasmethod
from hamcrest.core.helpers.wrap_matcher import wrap_matcher as wrap_shortcut

__author__ = "Chris Rose"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsObjectWithProperty(BaseMatcher):

    def __init__(self, property_name, value_matcher):
        self.property_name = property_name
        self.value_matcher = value_matcher

    def _matches(self, o):
        if o is None:
            return False

        if not hasattr(o, self.property_name):
            return False

        value = getattr(o, self.property_name)
        return self.value_matcher.matches(value)

    def describe_to(self, description):
        description.append_text("an object with a property '") \
                                        .append_text(self.property_name) \
                                        .append_text("' matching ") \
                                        .append_description_of(self.value_matcher)

    def describe_mismatch(self, item, mismatch_description):
        if item is None:
            mismatch_description.append_text('was None')
            return

        if not hasattr(item, self.property_name):
            mismatch_description.append_value(item) \
                                                    .append_text(' did not have the ') \
                                                    .append_value(self.property_name) \
                                                    .append_text(' property')
            return

        mismatch_description.append_text('property ').append_value(self.property_name).append_text(' ')
        value = getattr(item, self.property_name)
        self.value_matcher.describe_mismatch(value, mismatch_description)

    def __str__(self):
        d = StringDescription()
        self.describe_to(d)
        return str(d)


def has_property(name, match=None):
    """Matches if object has a property with a given name whose value satisfies
    a given matcher.

    :param name: The name of the property.
    :param match: Optional matcher to satisfy.

    This matcher determines if the evaluated object has a property with a given
    name. If no such property is found, ``has_property`` is not satisfied.

    If the property is found, its value is passed to a given matcher for
    evaluation. If the ``match`` argument is not a matcher, it is implicitly
    wrapped in an :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to
    check for equality.

    If the ``match`` argument is not provided, the
    :py:func:`~hamcrest.core.core.isanything.anything` matcher is used so that
    ``has_property`` is satisfied if a matching property is found.

    Examples::

        has_property('name', starts_with('J'))
        has_property('name', 'Jon')
        has_property('name')

    """

    if match is None:
        match = anything()

    return IsObjectWithProperty(name, wrap_shortcut(match))


def has_properties(*keys_valuematchers, **kv_args):
    """Matches if an object has properties satisfying all of a dictionary
    of string property names and corresponding value matchers.

    :param matcher_dict: A dictionary mapping keys to associated value matchers,
        or to expected values for
        :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    Note that the keys must be actual keys, not matchers. Any value argument
    that is not a matcher is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    Examples::

        has_properties({'foo':equal_to(1), 'bar':equal_to(2)})
        has_properties({'foo':1, 'bar':2})

    ``has_properties`` also accepts a list of keyword arguments:

    .. function:: has_properties(keyword1=value_matcher1[, keyword2=value_matcher2[, ...]])

    :param keyword1: A keyword to look up.
    :param valueMatcher1: The matcher to satisfy for the value, or an expected
        value for :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    Examples::

        has_properties(foo=equal_to(1), bar=equal_to(2))
        has_properties(foo=1, bar=2)

    Finally, ``has_properties`` also accepts a list of alternating keys and their
    value matchers:

    .. function:: has_properties(key1, value_matcher1[, ...])

    :param key1: A key (not a matcher) to look up.
    :param valueMatcher1: The matcher to satisfy for the value, or an expected
        value for :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    Examples::

        has_properties('foo', equal_to(1), 'bar', equal_to(2))
        has_properties('foo', 1, 'bar', 2)

    """
    if len(keys_valuematchers) == 1:
        try:
            base_dict = keys_valuematchers[0].copy()
            for key in base_dict:
                base_dict[key] = wrap_shortcut(base_dict[key])
        except AttributeError:
            raise ValueError('single-argument calls to has_properties must pass a dict as the argument')
    else:
        if len(keys_valuematchers) % 2:
            raise ValueError('has_properties requires key-value pairs')
        base_dict = {}
        for index in range(int(len(keys_valuematchers) / 2)):
            base_dict[keys_valuematchers[2 * index]] = wrap_shortcut(keys_valuematchers[2 * index + 1])

    for key, value in kv_args.items():
        base_dict[key] = wrap_shortcut(value)

    return all_of(*[has_property(property_name, property_value_matcher) for \
                   property_name, property_value_matcher in base_dict.items()])

########NEW FILE########
__FILENAME__ = hasstring
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.wrap_matcher import wrap_matcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class HasString(BaseMatcher):

    def __init__(self, str_matcher):
        self.str_matcher = str_matcher

    def _matches(self, item):
        return self.str_matcher.matches(str(item))

    def describe_to(self, description):
        description.append_text('an object with str ')          \
                    .append_description_of(self.str_matcher)


def has_string(match):
    """Matches if ``str(item)`` satisfies a given matcher.

    :param match: The matcher to satisfy, or an expected value for
        :py:func:`~hamcrest.core.core.isequal.equal_to` matching.

    This matcher invokes the :py:func:`str` function on the evaluated object to
    get its length, passing the result to a given matcher for evaluation. If
    the ``match`` argument is not a matcher, it is implicitly wrapped in an
    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for
    equality.

    Examples::

        has_string(starts_with('foo'))
        has_string('bar')

    """
    return HasString(wrap_matcher(match))

########NEW FILE########
__FILENAME__ = isequal_ignoring_case
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher

import six

class IsEqualIgnoringCase(BaseMatcher):

    def __init__(self, string):
        if not isinstance(string, six.string_types):
            raise TypeError('IsEqualIgnoringCase requires string')
        self.original_string = string
        self.lowered_string = string.lower()

    def _matches(self, item):
        if not isinstance(item, six.string_types):
            return False
        return self.lowered_string == item.lower()

    def describe_to(self, description):
        description.append_description_of(self.original_string)    \
                   .append_text(' ignoring case')


def equal_to_ignoring_case(string):
    """Matches if object is a string equal to a given string, ignoring case
    differences.

    :param string: The string to compare against as the expected value.

    This matcher first checks whether the evaluated object is a string. If so,
    it compares it with ``string``, ignoring differences of case.

    Example::

        equal_to_ignoring_case("hello world")

    will match "heLLo WorlD".

    """
    return IsEqualIgnoringCase(string)

########NEW FILE########
__FILENAME__ = isequal_ignoring_whitespace
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher

import six

def stripspace(string):
    result = ''
    last_was_space = True
    for character in string:
        if character.isspace():
            if not last_was_space:
                result += ' '
            last_was_space = True
        else:
            result += character
            last_was_space = False
    return result.strip()


class IsEqualIgnoringWhiteSpace(BaseMatcher):

    def __init__(self, string):
        if not isinstance(string, six.string_types):
            raise TypeError('IsEqualIgnoringWhiteSpace requires string')
        self.original_string = string
        self.stripped_string = stripspace(string)

    def _matches(self, item):
        if not isinstance(item, six.string_types):
            return False
        return self.stripped_string == stripspace(item)

    def describe_to(self, description):
        description.append_description_of(self.original_string)    \
                   .append_text(' ignoring whitespace')


def equal_to_ignoring_whitespace(string):
    """Matches if object is a string equal to a given string, ignoring
    differences in whitespace.

    :param string: The string to compare against as the expected value.

    This matcher first checks whether the evaluated object is a string. If so,
    it compares it with ``string``, ignoring differences in runs of whitespace.

    Example::

        equal_to_ignoring_whitespace("hello world")

    will match ``"hello   world"``.

    """
    return IsEqualIgnoringWhiteSpace(string)

########NEW FILE########
__FILENAME__ = stringcontains
from hamcrest.library.text.substringmatcher import SubstringMatcher
from hamcrest.core.helpers.hasmethod import hasmethod

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class StringContains(SubstringMatcher):

    def __init__(self, substring):
        super(StringContains, self).__init__(substring)

    def _matches(self, item):
        if not hasmethod(item, 'find'):
            return False
        return item.find(self.substring) >= 0

    def relationship(self):
        return 'containing'


def contains_string(substring):
    """Matches if object is a string containing a given string.

    :param string: The string to search for.

    This matcher first checks whether the evaluated object is a string. If so,
    it checks whether it contains ``string``.

    Example::

        contains_string("def")

    will match "abcdefg".

    """
    return StringContains(substring)

########NEW FILE########
__FILENAME__ = stringcontainsinorder
__author__ = "Romilly Cocking"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod

import six

class StringContainsInOrder(BaseMatcher):

    def __init__(self, *substrings):
        for substring in substrings:
            if not isinstance(substring, six.string_types):
                raise TypeError(self.__class__.__name__
                                + ' requires string arguments')
        self.substrings = substrings

    def _matches(self, item):
        if not hasmethod(item, 'find'):
            return False
        from_index = 0
        for substring in self.substrings:
            from_index = item.find(substring, from_index)
            if from_index == -1:
                return False
        return True

    def describe_to(self, description):
        description.append_list('a string containing ', ', ', ' in order',
                                self.substrings)


def string_contains_in_order(*substrings):
    """Matches if object is a string containing a given list of substrings in
    relative order.

    :param string1,...:  A comma-separated list of strings.

    This matcher first checks whether the evaluated object is a string. If so,
    it checks whether it contains a given list of strings, in relative order to
    each other. The searches are performed starting from the beginning of the
    evaluated string.

    Example::

        string_contains_in_order("bc", "fg", "jkl")

    will match "abcdefghijklm".

    """
    return StringContainsInOrder(*substrings)

########NEW FILE########
__FILENAME__ = stringendswith
from hamcrest.library.text.substringmatcher import SubstringMatcher
from hamcrest.core.helpers.hasmethod import hasmethod

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class StringEndsWith(SubstringMatcher):

    def __init__(self, substring):
        super(StringEndsWith, self).__init__(substring)

    def _matches(self, item):
        if not hasmethod(item, 'endswith'):
            return False
        return item.endswith(self.substring)

    def relationship(self):
        return 'ending with'


def ends_with(string):
    """Matches if object is a string ending with a given string.

    :param string: The string to search for.

    This matcher first checks whether the evaluated object is a string. If so,
    it checks if ``string`` matches the ending characters of the evaluated
    object.

    Example::

        ends_with("bar")

    will match "foobar".

    """
    return StringEndsWith(string)

########NEW FILE########
__FILENAME__ = stringmatches
__author__ = "Chris Rose"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

import re

import six

from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.helpers.hasmethod import hasmethod

class StringMatchesPattern(BaseMatcher):

    def __init__(self, pattern):
        self.pattern = pattern

    def describe_to(self, description):
        description.append_text("a string matching '") \
                                   .append_text(self.pattern.pattern) \
                                   .append_text("'")

    def _matches(self, item):
        return self.pattern.search(item) is not None


def matches_regexp(pattern):
    """Matches if object is a string containing a match for a given regular
    expression.

    :param pattern: The regular expression to search for.

    This matcher first checks whether the evaluated object is a string. If so,
    it checks if the regular expression ``pattern`` matches anywhere within the
    evaluated object.

    """
    if isinstance(pattern, six.string_types):
        pattern = re.compile(pattern)

    return StringMatchesPattern(pattern)

########NEW FILE########
__FILENAME__ = stringstartswith
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.library.text.substringmatcher import SubstringMatcher
from hamcrest.core.helpers.hasmethod import hasmethod


class StringStartsWith(SubstringMatcher):

    def __init__(self, substring):
        super(StringStartsWith, self).__init__(substring)

    def _matches(self, item):
        if not hasmethod(item, 'startswith'):
            return False
        return item.startswith(self.substring)

    def relationship(self):
        return 'starting with'


def starts_with(substring):
    """Matches if object is a string starting with a given string.

    :param string: The string to search for.

    This matcher first checks whether the evaluated object is a string. If so,
    it checks if ``string`` matches the beginning characters of the evaluated
    object.

    Example::

        starts_with("foo")

    will match "foobar".

    """
    return StringStartsWith(substring)

########NEW FILE########
__FILENAME__ = substringmatcher
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

from hamcrest.core.base_matcher import BaseMatcher

import six

class SubstringMatcher(BaseMatcher):

    def __init__(self, substring):
        if not isinstance(substring, six.string_types):
            raise TypeError(self.__class__.__name__ + ' requires string')
        self.substring = substring

    def describe_to(self, description):
        description.append_text('a string ')                \
                   .append_text(self.relationship())        \
                   .append_text(' ')                        \
                   .append_description_of(self.substring)

########NEW FILE########
__FILENAME__ = assert_that_test
from __future__ import with_statement
from hamcrest.core.assert_that import assert_that
from hamcrest.core.core.isequal import equal_to
try:
    import unittest2 as unittest
except ImportError:
    import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class AssertThatTest(unittest.TestCase):

    def testShouldBeSilentOnSuccessfulMatch(self):
        assert_that(1, equal_to(1))

    def testAssertionErrorShouldDescribeExpectedAndActual(self):
        expected = 'EXPECTED'
        actual = 'ACTUAL'

        expectedMessage = "\nExpected: 'EXPECTED'\n     but: was 'ACTUAL'\n"

        with self.assertRaises(AssertionError) as e:
            assert_that(actual, equal_to(expected))

        self.assertEqual(expectedMessage, str(e.exception))

    def testAssertionErrorShouldIncludeOptionalReason(self):
        expected = 'EXPECTED'
        actual = 'ACTUAL'

        expectedMessage = "REASON\nExpected: 'EXPECTED'\n     but: was 'ACTUAL'\n"

        with self.assertRaises(AssertionError) as e:
            assert_that(actual, equal_to(expected), 'REASON')

        self.assertEqual(expectedMessage, str(e.exception))

    def testCanTestBoolDirectly(self):
        assert_that(True, 'should accept True')

        with self.assertRaises(AssertionError) as e:
            assert_that(False, 'FAILURE REASON')
        self.assertEqual('FAILURE REASON', str(e.exception))

    def testCanTestBoolDirectlyWithoutReason(self):
        assert_that(True)

        with self.assertRaises(AssertionError) as e:
            assert_that(False)
            
        self.assertEqual('Assertion failed', str(e.exception))


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = base_matcher_test
if __name__ == "__main__":
    import sys
    sys.path.insert(0, '..')

from hamcrest.core.base_matcher import *

import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class TestingBaseMatcher(BaseMatcher):

    def describe_to(self, description):
        description.append_text('SOME DESCRIPTION')


class BaseMatcherTest(unittest.TestCase):

    def testStrFunctionShouldDescribeMatcher(self):
        matcher = TestingBaseMatcher()
        self.assertEqual('SOME DESCRIPTION', str(matcher))


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = isdict_containingentries_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.library.collection.isdict_containingentries import *

import platform

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
try:
    from unittest import skipIf
    import unittest
except ImportError:
    import unittest2 as unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsDictContainingEntriesTest(MatcherTest):

    def testMatcherCreationRequiresEvenNumberOfPositionalArgs(self):
        self.assertRaises(ValueError, has_entries, 'a', 'b', 'c')

    def testDoesNotMatchNonDictionary(self):
        self.assert_does_not_match('non-dictionary',
                                    has_entries('a', equal_to(1)), object())

    def testMatchesDictLike(self):
        class DictLike(object):
            def __getitem__(self, key):
                return 'value: ' + str(key)
            def __contains__(self, key):
                return True
        self.assert_matches('matches a dictionary-like object',
                            has_entries('a', equal_to('value: a')),
                            DictLike())

    def testMatchesUsingSingleDictionaryArgument(self):
        target = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('has a & b',
                        has_entries({'a':equal_to(1), 'b':equal_to(2)}), target)
        self.assert_matches('has c & a',
                        has_entries({'c':equal_to(3), 'a':equal_to(1)}), target)
        self.assert_does_not_match('no d:3',
                        has_entries({'b':equal_to(2), 'd':equal_to(3)}), target)

    def testMatcheSingleDictionaryArgumentWithImplicitEqualTo(self):
        target = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('has a & b',
                        has_entries({'a':1, 'b':2}), target)
        self.assert_matches('has c & a',
                        has_entries({'c':3, 'a':1}), target)
        self.assert_does_not_match('no d:3',
                        has_entries({'b':2, 'd': 3}), target)

    def testMatchesUsingKwargs(self):
        target = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('has a & b',
                        has_entries(a=equal_to(1), b=equal_to(2)), target)
        self.assert_matches('has c & a',
                        has_entries(c=equal_to(3), a=equal_to(1)), target)
        self.assert_does_not_match('no d:3',
                        has_entries(b=equal_to(2), d=equal_to(3)), target)

    def testMatchesKwargsWithImplicitEqualTo(self):
        target = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('has a & b',
                        has_entries(a=1, b=2), target)
        self.assert_matches('has c & a',
                        has_entries(c=3, a=1), target)
        self.assert_does_not_match('no d:3',
                        has_entries(b=2, d=3), target)

    def testMatchesDictionaryContainingSingleKeyWithMatchingValue(self):
        target = {'a': 1, 'b': 2}
        self.assert_matches('has a:1', has_entries('a', equal_to(1)), target)
        self.assert_matches('has b:2', has_entries('b', equal_to(2)), target)
        self.assert_does_not_match('no b:3', has_entries('b', equal_to(3)), target)
        self.assert_does_not_match('no c:2', has_entries('c', equal_to(2)), target)

    def testMatchesDictionaryContainingMultipleKeysWithMatchingValues(self):
        target = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('has a & b',
                        has_entries('a', equal_to(1), 'b', equal_to(2)), target)
        self.assert_matches('has c & a',
                        has_entries('c', equal_to(3), 'a', equal_to(1)), target)
        self.assert_does_not_match('no d:3',
                        has_entries('b', equal_to(3), 'd', equal_to(3)), target)

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        target = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('has a & b', has_entries('a', 1, 'b', 2), target)
        self.assert_matches('has c & a', has_entries('c', 3, 'a', 1), target)
        self.assert_does_not_match('no d:4', has_entries('b', 3, 'd', 4), target)

    @unittest.skipIf('java' in platform.system().lower(), "Hash randomization makes this unpredictably fail")
    def testHasReadableDescription(self):
        self.assert_description("a dictionary containing {'a': <1>, 'b': <2>}",
                                has_entries('a', 1, 'b', 2))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(has_entries('a', 1), {'a': 1})

    def testMismatchDescriptionOfNonDictionaryShowsActualArgument(self):
        self.assert_mismatch_description("'bad' is not a mapping object", has_entries('a', 1), 'bad')

    def testMismatchDescriptionOfDictionaryWithNonMatchingValue(self):
        self.assert_mismatch_description("value for 'a' was <2>",
                                has_entries('a', 1), {'a': 2})

    def testDescribeMismatchOfNonDictionaryShowsActualArgument(self):
        self.assert_describe_mismatch("'bad' is not a mapping object", has_entries('a', 1), 'bad')

    @unittest.skipIf('java' in platform.system().lower(), "Hash randomization makes this unpredictably fail")
    def testDescribeMismatchOfDictionaryWithoutKey(self):
        self.assert_describe_mismatch("no 'b' key in <{'a': 1, 'c': 3}>",
                                has_entries('a', 1, 'b', 2), {'a': 1, 'c': 3})

    def testDescribeMismatchOfDictionaryWithNonMatchingValue(self):
        self.assert_describe_mismatch("value for 'a' was <2>",
                                has_entries('a', 1), {'a': 2})


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = isdict_containingkey_test
from __future__ import absolute_import

from hamcrest.library.collection.isdict_containingkey import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
from .quasidict import QuasiDictionary
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsDictContainingKeyTest(MatcherTest):

    def testMatchesSingletonDictionaryContainingKey(self):
        dict = {'a': 1}
        self.assert_matches('same single key', has_key(equal_to('a')), dict)

    def testMatchesDictionaryContainingKey(self):
        dict = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('Matches a', has_key(equal_to('a')), dict)
        self.assert_matches('Matches c', has_key(equal_to('c')), dict)

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        dict = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('Matches c', has_key('c'), dict)

    def testDoesNotMatchEmptyDictionary(self):
        self.assert_does_not_match('empty', has_key('foo'), {});

    def testDoesNotMatchDictionaryMissingKey(self):
        dict = {'a': 1, 'b': 2, 'c': 3}
        self.assert_does_not_match('no matching key', has_key('d'), dict)

    def testMatchesAnyConformingDictionary(self):
        self.assert_matches('quasi-dictionary', has_key(1), QuasiDictionary())
        self.assert_does_not_match('non-dictionary', has_key(1), object())

    def testHasReadableDescription(self):
        self.assert_description("a dictionary containing key 'a'", has_key('a'))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(has_key('a'), {'a': 1})

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was 'bad'", has_key('a'), 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", has_key('a'), 'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = isdict_containingvalue_test
from __future__ import absolute_import

from hamcrest.library.collection.isdict_containingvalue import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
from .quasidict import QuasiDictionary
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsDictContainingValueTest(MatcherTest):

    def testMatchesSingletonDictionaryContainingValue(self):
        dict = {'a': 1}
        self.assert_matches('same single value', has_value(equal_to(1)), dict)

    def testMatchesDictionaryContainingValue(self):
        dict = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('Matches 1', has_value(equal_to(1)), dict)
        self.assert_matches('Matches 3', has_value(equal_to(3)), dict)

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        dict = {'a': 1, 'b': 2, 'c': 3}
        self.assert_matches('Matches 3', has_value(3), dict)

    def testDoesNotMatchEmptyDictionary(self):
        self.assert_does_not_match('empty', has_value(1), {});

    def testDoesNotMatchDictionaryMissingValue(self):
        dict = {'a': 1, 'b': 2, 'c': 3}
        self.assert_does_not_match('no matching value', has_value(4), dict)

    def testMatchesAnyConformingDictionary(self):
        self.assert_matches('quasi-dictionary', has_value('1'), QuasiDictionary())
        self.assert_does_not_match('non-dictionary', has_value('1'), object())

    def testHasReadableDescription(self):
        self.assert_description("a dictionary containing value 'a'", has_value('a'))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(has_value(1), {'a': 1})

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was 'bad'", has_value(1), 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", has_value(1), 'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = isdict_containing_test
from __future__ import absolute_import

from hamcrest.library.collection.isdict_containing import *

from hamcrest.core.core.isequal import equal_to

from hamcrest_unit_test.matcher_test import MatcherTest
from .quasidict import QuasiDictionary
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsDictContainingTest(MatcherTest):

    def testMatchesDictionaryContainingMatchingKeyAndValue(self):
        dict = {'a': 1, 'b': 2}
        self.assert_matches('has a:1', has_entry(equal_to('a'), equal_to(1)), dict)
        self.assert_matches('has b:2', has_entry(equal_to('b'), equal_to(2)), dict)
        self.assert_does_not_match('no c:3', has_entry(equal_to('c'), equal_to(3)), dict)

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        dict = {'a': 1, 'b': 2}
        self.assert_matches('has a:1', has_entry('a', equal_to(1)), dict)
        self.assert_matches('has b:2', has_entry(equal_to('b'), 2), dict)
        self.assert_does_not_match('no c:3', has_entry('c', 3), dict)

    def testMatchesAnyConformingDictionary(self):
        self.assert_matches('quasi-dictionary', has_entry(1, '1'), QuasiDictionary())
        self.assert_does_not_match('non-dictionary', has_entry(1, '1'), object())

    def testHasReadableDescription(self):
        self.assert_description("a dictionary containing ['a': <1>]",
                                has_entry('a', 1))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(has_entry('a', 1), {'a': 1})

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was 'bad'", has_entry('a', 1), 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", has_entry('a', 1), 'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = isin_test
from __future__ import absolute_import

from hamcrest.library.collection.isin import *

from hamcrest_unit_test.matcher_test import MatcherTest
from .sequencemixin import GeneratorForm, SequenceForm
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


sequence = ('a', 'b', 'c')

class IsInTestBase(object):

    def testReturnsTrueIfArgumentIsInSequence(self):
        matcher = is_in(self._sequence(*sequence))

        self.assert_matches('has a', matcher, 'a')
        self.assert_matches('has b', matcher, 'b')
        self.assert_matches('has c', matcher, 'c')
        self.assert_does_not_match('no d', matcher, 'd')

    def testHasReadableDescription(self):
        self.assert_description("one of ('a', 'b', 'c')", is_in(self._sequence(*sequence)))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(is_in(self._sequence(*sequence)), 'a')

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was 'bad'", is_in(self._sequence(*sequence)), 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", is_in(self._sequence(*sequence)), 'bad')


class IsInConcreteSequenceTest(MatcherTest, IsInTestBase, SequenceForm):
    pass

class IsInGeneratorTest(MatcherTest, IsInTestBase, GeneratorForm):
    pass

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = issequence_containinginanyorder_test
from __future__ import absolute_import

from hamcrest.library.collection.issequence_containinginanyorder import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
from .quasisequence import QuasiSequence
from .sequencemixin import SequenceForm, GeneratorForm
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsSequenceContainingInAnyOrderBase(object):

    def testMatchingSingleItemSequence(self):
        self.assert_matches("Single item sequence",
                            contains_inanyorder(equal_to(1)), self._sequence(1))

    def testMatchesSequenceInOrder(self):
        self.assert_matches("In order",
                            contains_inanyorder(equal_to(1), equal_to(2)), self._sequence(1,2))

    def testMatchesSequenceOutOfOrder(self):
        self.assert_matches("Out of order",
                            contains_inanyorder(equal_to(1), equal_to(2)),
                            self._sequence(2,1))

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        self.assert_matches("Values automatically wrapped with equal_to",
                            contains_inanyorder(1,2), self._sequence(2,1))

    def testDoesNotMatchEmptySequence(self):
        self.assert_mismatch_description("no item matches: <1>, <2> in []",
                                         contains_inanyorder(1, 2), self._sequence())

    def testEmptySequenceMatchesEmptySequence(self):
        self.assert_matches("Empty sequence", contains_inanyorder(), self._sequence())

    def testDoesNotMatchIfOneOfMultipleItemsMismatch(self):
        self.assert_mismatch_description("not matched: <4>",
                                         contains_inanyorder(1,2,3), self._sequence(1,2,4))

    def testDoesNotMatchWithMoreElementsThanExpected(self):
        self.assert_mismatch_description("not matched: <2>",
                                         contains_inanyorder(1,3), self._sequence(1,2,3))

    def testDoesNotMatchWithFewerElementsThanExpected(self):
        self.assert_mismatch_description(
                            "no item matches: <4> in [<1>, <2>, <3>]",
                            contains_inanyorder(1,2,3,4), self._sequence(1,2,3))

    def testMatchesAnyConformingSequence(self):
        self.assert_matches('quasi-sequence', contains_inanyorder(1,2),
                            QuasiSequence())
        self.assert_does_not_match('non-sequence', contains_inanyorder(1,2),
                                   object())

    def testHasAReadableDescription(self):
        self.assert_description("a sequence over [<1>, <2>] in any order",
                                contains_inanyorder(1,2))

    def testDescribeMismatch(self):
        self.assert_describe_mismatch('not matched: <3>',
                                      contains_inanyorder(1,2), self._sequence(1,3))

    def testDescribeMismatchOfNonSequence(self):
        self.assert_describe_mismatch("was <3>", contains_inanyorder(1,2), 3)

    def testDescribeMismatchAfterMatch(self):
        matcher = contains_inanyorder(1, 2, 3)
        matcher.matches(self._sequence(3, 1))
        self.assert_describe_mismatch('no item matches: <2> in [<3>, <1>]',
                                      matcher, self._sequence(3, 1))


class IsConcreteSequenceContainingInAnyOrderTest(MatcherTest, IsSequenceContainingInAnyOrderBase, SequenceForm):
    pass

class IsGeneratorSequenceContainingInAnyOrderTest(MatcherTest, IsSequenceContainingInAnyOrderBase, GeneratorForm):
    pass

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = issequence_containinginorder_test
from __future__ import absolute_import

from hamcrest.library.collection.issequence_containinginorder import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
from .quasisequence import QuasiSequence
from .sequencemixin import SequenceForm, GeneratorForm
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsSequenceContainingInOrderTestBase(object):

    def testMatchingSingleItemSequence(self):
        self.assert_matches("Single item sequence", contains(equal_to(1)), self._sequence(1))

    def testMatchingMultipleItemSequence(self):
        self.assert_matches("Multiple item sequence",
                            contains(equal_to(1), equal_to(2), equal_to(3)),
                            self._sequence(1,2,3))

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        self.assert_matches("Values automatically wrapped with equal_to",
                            contains(1, 2, 3),
                            self._sequence(1,2,3))

    def testDoesNotMatchWithMoreElementsThanExpected(self):
        self.assert_mismatch_description("Not matched: <4>",
                            contains(1,2,3), self._sequence(1,2,3,4))

    def testDoesNotMatchWithFewerElementsThanExpected(self):
        self.assert_mismatch_description("No item matched: <3>",
                            contains(1,2,3), self._sequence(1,2))

    def testDoesNotMatchIfSingleItemMismatches(self):
        self.assert_mismatch_description("item 0: was <3>", contains(4), self._sequence(3))

    def testDoesNotMatchIfOneOfMultipleItemsMismatch(self):
        self.assert_mismatch_description("item 2: was <4>",
                            contains(1,2,3), self._sequence(1,2,4))

    def testDoesNotMatchEmptySequence(self):
        self.assert_mismatch_description("No item matched: <4>",
                            contains(4), self._sequence())

    def testEmptySequenceMatchesEmptySequence(self):
        self.assert_matches("Empty sequence", contains(), self._sequence())

    def testMatchesAnyConformingSequence(self):
        self.assert_matches('quasi-sequence', contains(1,2), QuasiSequence())
        self.assert_does_not_match('non-sequence', contains(1,2), object())

    def testHasAReadableDescription(self):
        self.assert_description("a sequence containing [<1>, <2>]", contains(1,2))

    def testDescribeMismatch(self):
        self.assert_describe_mismatch('item 1: was <3>', contains(1,2), self._sequence(1,3))

    def testDescribeMismatchOfNonSequence(self):
        self.assert_describe_mismatch("was <3>", contains(1,2), 3)


class IsConcreteSequenceContainingInOrderTest(MatcherTest, IsSequenceContainingInOrderTestBase, SequenceForm):
    pass

class IsGeneratorSequenceContainingInOrderTest(MatcherTest, IsSequenceContainingInOrderTestBase, GeneratorForm):
    pass

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = issequence_containing_test
from __future__ import absolute_import

from hamcrest.library.collection.issequence_containing import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
from .quasisequence import QuasiSequence
from .sequencemixin import GeneratorForm, SequenceForm
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsSequenceContainingTestBase(object):

    def testMatchesASequenceThatContainsAnElementMatchingTheGivenMatcher(self):
        self.assert_matches("sequence contains 'a'",
                            has_item(equal_to('a')), self._sequence('a', 'b', 'c'))

    def testNoMatchIfSequenceDoesntContainAnElementMatchingTheGivenMatcher(self):
        self.assert_does_not_match("sequence without 'a'",
                                    has_item(equal_to('a')), self._sequence('b', 'c'))
        self.assert_does_not_match('empty', has_item(equal_to('a')), [])

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        self.assert_matches("sequence contains 'a'",
                            has_item('a'), self._sequence('a', 'b', 'c'))
        self.assert_does_not_match("sequence without 'a'",
                                   has_item('a'), self._sequence('b', 'c'))

    def testMatchesAnyConformingSequence(self):
        self.assert_matches('quasi-sequence', has_item(1), QuasiSequence())
        self.assert_does_not_match('non-sequence', has_item(1), object())

    def testHasAReadableDescription(self):
        self.assert_description("a sequence containing 'a'", has_item('a'))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(has_item('a'), self._sequence('a', 'b'))

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was <42>", has_item('a'), 42)

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was <42>", has_item('a'), 42)


class IsConcreteSequenceContaining(MatcherTest, SequenceForm, IsSequenceContainingTestBase):
    pass

class IsGeneratorContaining(MatcherTest, GeneratorForm, IsSequenceContainingTestBase):
    pass


class IsSequenceContainingItemsTestBase(object):

    def testShouldMatchCollectionContainingAllItems(self):
        self.assert_matches('contains all items',
                            has_items(equal_to('a'), equal_to('b'), equal_to('c')),
                            self._sequence('a', 'b', 'c'))

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        self.assert_matches('Values automatically wrapped with equal_to',
                            has_items('a', 'b', 'c'),
                            self._sequence('a', 'b', 'c'))

    def testShouldMatchCollectionContainingAllItemsInDifferentOrder(self):
        self.assert_matches('all items in different order',
                            has_items('a', 'b', 'c'),
                            self._sequence('c', 'b', 'a'))

    def testShouldMatchCollectionContainingAllItemsPlusExtras(self):
        self.assert_matches('all items plus extras',
                            has_items('a', 'b', 'c'),
                            self._sequence('e', 'c', 'b', 'a', 'd'))

    def testNoMatchIfCollectionDoesntSatisfyAllMatchers(self):
        self.assert_does_not_match("missing 'a'",
                                   has_items('a', 'b', 'c'),
                                   self._sequence('e', 'c', 'b', 'd'))

    def testHasAReadableDescription(self):
        self.assert_description(
            "(a sequence containing 'a' and a sequence containing 'b')",
            has_items('a', 'b'))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(has_items('a', 'b'), self._sequence('a', 'b'))

    def testMismatchDescriptionShowsFirstUnmetMatcherAndActualArgument(self):
        self.assert_mismatch_description("a sequence containing 'a' was <42>",
                                         has_items('a', 'b'), 42)

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("a sequence containing 'a' was <42>",
                                      has_items('a', 'b'), 42)


class IsConcreteSequenceContainingItemsTest(MatcherTest, IsSequenceContainingItemsTestBase, SequenceForm):
    pass

class IsGeneratorSequenceContainingItemsTest(MatcherTest, IsSequenceContainingItemsTestBase, GeneratorForm):
    pass

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = issequence_onlycontaining_test
from __future__ import absolute_import

from hamcrest.library.collection.issequence_onlycontaining import *

from hamcrest.core.core.isequal import equal_to
from hamcrest.library.number.ordering_comparison import less_than
from hamcrest_unit_test.matcher_test import MatcherTest
from .quasisequence import QuasiSequence
from .sequencemixin import SequenceForm, GeneratorForm
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsSequenceOnlyContainingTestBase(object):

    def testMatchesSingletonList(self):
        self.assert_matches('singleton list', only_contains(equal_to(1)), self._sequence(1))

    def testMatchesAllItemsWithOneMatcher(self):
        self.assert_matches('one matcher',
                            only_contains(less_than(3)), self._sequence(0, 1, 2))

    def testMatchesAllItemsWithMultipleMatchers(self):
        self.assert_matches('multiple matchers',
                            only_contains(less_than(3), equal_to(7)),
                            self._sequence(0, 7, 1, 2))

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        self.assert_matches('Values automatically wrapped with equal_to',
                            only_contains(less_than(3), 7),
                            self._sequence(0, 7, 1, 2))

    def testDoesNotMatchListWithMismatchingItem(self):
        self.assert_does_not_match('3 is not less than 3',
                                   only_contains(less_than(3)), self._sequence(1, 2, 3))

    def testDoesNotMatchEmptyList(self):
        self.assert_does_not_match('empty', only_contains('foo'), self._sequence())

    def testMatchesAnyConformingSequence(self):
        class ObjectWithLenOnly(object):
            def __len__(self):
                return 20
            
        self.assert_matches('quasi-sequence',
                            only_contains(less_than(3)), QuasiSequence())
        self.assert_does_not_match('non-sequence', only_contains(1), object())
        self.assert_does_not_match('non-sequence with length',
                                   only_contains(1), ObjectWithLenOnly())

    def testHasAReadableDescription(self):
        self.assert_description('a sequence containing items matching (<1> or <2>)',
                                only_contains(1,2))

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", only_contains(1,2), 'bad')

    def testDescribeMismatchOfNonSequence(self):
        self.assert_describe_mismatch("was <3>", only_contains(1,2), 3)


class IsConcreteSequenceOnlyContainingTest(MatcherTest, IsSequenceOnlyContainingTestBase, SequenceForm):
    pass

class IsGeneratorSequenceOnlyContainingTest(MatcherTest, IsSequenceOnlyContainingTestBase, GeneratorForm):
    pass


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = is_empty_test
from __future__ import absolute_import

from hamcrest.library.collection.is_empty import *

from hamcrest_unit_test.matcher_test import MatcherTest
from .sequencemixin import GeneratorForm, SequenceForm

__author__ = "Chris Rose"
__copyright__ = "Copyright 2012 hamcrest.org"
__license__ = "BSD, see License.txt"

class LengthHaver(object):

    def __init__(self, len_):
        self._len = len_

    def __len__(self):
        return self._len

class EmptyCollectionTest(MatcherTest):

    def testReturnsTrueForEmptyStandardCollections(self):
        matcher = empty()
        self.assert_matches('empty tuple', matcher, ())
        self.assert_matches('empty list', matcher, [])
        self.assert_matches('emtpy dictionary', matcher, {})

    def testReturnsTrueForEmptyCollectionLike(self):
        matcher = empty()
        self.assert_matches('empty protocol object', matcher, LengthHaver(0))

    def testReturnsFalseForNonEmptyStandardCollections(self):
        matcher = empty()
        self.assert_does_not_match('non-empty tuple', matcher, (1,))
        self.assert_does_not_match('non-empty list', matcher, [1])
        self.assert_does_not_match('emtpy dictionary', matcher, {1:2})

    def testReturnsFalseForNonEmptyCollectionLike(self):
        matcher = empty()
        self.assert_does_not_match('non-empty protocol object', matcher, LengthHaver(1))

    def testHasReadableDescription(self):
        self.assert_description("an empty collection", empty())

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(empty(), [])

    def testDescribeMismatch(self):
        self.assert_mismatch_description("has 3 item(s)", empty(), [1,2,3])
        self.assert_mismatch_description("does not support length", empty(), 1)

########NEW FILE########
__FILENAME__ = quasidict
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

import six


class QuasiDictionary(object):
    def items(self):
        return QuasiDictionaryItemIterator()

    def keys(self):
        return QuasiDictionaryKeyIterator()

    def values(self):
        return QuasiDictionaryValueIterator()


class BaseQuasiDictionaryIterator(six.Iterator):
    def __init__(self):
        self.index = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= 3:
            raise StopIteration
        result = self.indexToResult()
        self.index += 1
        return result


class QuasiDictionaryItemIterator(BaseQuasiDictionaryIterator):
    def indexToResult(self):
        return (self.index, str(self.index))


class QuasiDictionaryKeyIterator(BaseQuasiDictionaryIterator):
    def indexToResult(self):
        return self.index


class QuasiDictionaryValueIterator(BaseQuasiDictionaryIterator):
    def indexToResult(self):
        return str(self.index)

########NEW FILE########
__FILENAME__ = quasisequence
__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

import six


class QuasiSequence(object):
    def __iter__(self):
        return QuasiSequenceIterator()

    def __len__(self):
        return 2


class QuasiSequenceIterator(six.Iterator):
    def __init__(self):
        self.index = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= 3:
            raise StopIteration
        result = self.index
        self.index += 1
        return result

########NEW FILE########
__FILENAME__ = sequencemixin
class GeneratorForm(object):

    def _sequence(self, *objects):
        for i in objects:
            yield i


class SequenceForm(object):

    def _sequence(self, *objects):
        return list(objects)

########NEW FILE########
__FILENAME__ = allof_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.core.core.allof import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class AllOfTest(MatcherTest):

    def testMatchesIfArgumentSatisfiesBothOfTwoOtherMatchers(self):
        self.assert_matches('both matchers',
                            all_of(equal_to('good'), equal_to('good')),
                            'good')

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        self.assert_matches('both matchers',
                            all_of('good', 'good'),
                            'good')

    def testNoMatchIfArgumentFailsToSatisfyEitherOfTwoOtherMatchers(self):
        self.assert_does_not_match('first matcher',
                                   all_of(equal_to('bad'), equal_to('good')),
                                   'good')
        self.assert_does_not_match('second matcher',
                                   all_of(equal_to('good'), equal_to('bad')),
                                   'good')
        self.assert_does_not_match('either matcher',
                                   all_of(equal_to('bad'), equal_to('bad')),
                                   'good')

    def testMatchesIfArgumentSatisfiesAllOfManyOtherMatchers(self):
        self.assert_matches('all matchers',
                            all_of(equal_to('good'),
                                   equal_to('good'),
                                   equal_to('good'),
                                   equal_to('good'),
                                   equal_to('good')),
                            'good')

    def testNoMatchIfArgumentFailsToSatisfyAllOfManyOtherMatchers(self):
        self.assert_does_not_match('matcher in the middle',
                                   all_of(equal_to('good'),
                                          equal_to('good'),
                                          equal_to('good'),
                                          equal_to('bad'),
                                          equal_to('good'),
                                          equal_to('good')),
                                   'good')

    def testHasAReadableDescription(self):
        self.assert_description("('good' and 'bad' and 'ugly')",
                    all_of(equal_to('good'), equal_to('bad'), equal_to('ugly')))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(
                                all_of(equal_to('good'), equal_to('good')),
                                'good')

    def testMismatchDescriptionDescribesFirstFailingMatch(self):
        self.assert_mismatch_description(
                                "'good' was 'bad'",
                                all_of(equal_to('bad'), equal_to('good')),
                                'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch(
                                "'good' was 'bad'",
                                all_of(equal_to('bad'), equal_to('good')),
                                'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = anyof_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.core.core.anyof import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class AnyOfTest(MatcherTest):

    def testMatchesIfArgumentSatisfiesEitherOrBothOfTwoOtherMatchers(self):
        self.assert_matches('first matcher',
                            any_of(equal_to('good'), equal_to('bad')),
                            'good')
        self.assert_matches('second matcher',
                            any_of(equal_to('bad'), equal_to('good')),
                            'good')
        self.assert_matches('both matchers',
                            any_of(equal_to('good'), equal_to('good')),
                            'good')

    def testProvidesConvenientShortcutForMatchingWithEqualTo(self):
        self.assert_matches('first matcher',
                            any_of('good', 'bad'),
                            'good')
        self.assert_matches('second matcher',
                            any_of('bad', 'good'),
                            'good')
        self.assert_matches('both matchers',
                            any_of('good', 'good'),
                            'good')

    def testNoMatchIfArgumentFailsToSatisfyEitherOfTwoOtherMatchers(self):
        self.assert_does_not_match('either matcher',
                                   any_of(equal_to('bad'), equal_to('bad')),
                                   'good')

    def testMatchesIfArgumentSatisfiesAnyOfManyOtherMatchers(self):
        self.assert_matches('matcher in the middle',
                            any_of(equal_to('bad'),
                                   equal_to('bad'),
                                   equal_to('good'),
                                   equal_to('bad'),
                                   equal_to('bad')),
                            'good')

    def testNoMatchIfArgumentFailsToSatisfyAnyOfManyOtherMatchers(self):
        self.assert_does_not_match('all matchers',
                                   any_of(equal_to('bad'),
                                          equal_to('bad'),
                                          equal_to('bad'),
                                          equal_to('bad'),
                                          equal_to('bad')),
                                  'good')

    def testHasAReadableDescription(self):
        self.assert_description("('good' or 'bad' or 'ugly')",
                    any_of(equal_to('good'), equal_to('bad'), equal_to('ugly')))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(
                                any_of(equal_to('good'), equal_to('bad')),
                                'good')

    def testMismatchDescriptionDescribesFirstFailingMatch(self):
        self.assert_mismatch_description(
                                "was 'ugly'",
                                any_of(equal_to('bad'), equal_to('good')),
                                'ugly')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch(
                                "was 'ugly'",
                                any_of(equal_to('bad'), equal_to('good')),
                                'ugly')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = described_as_test
from __future__ import absolute_import

from hamcrest.core.core.described_as import *

from hamcrest.core.core.isanything import anything
from hamcrest_unit_test.matcher_test import MatcherTest
from .nevermatch import NeverMatch
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class DescribedAsTest(MatcherTest):

    def testOverridesDescriptionOfNestedMatcherWithConstructorArgument(self):
        m1 = described_as('m1 description', anything())
        m2 = described_as('m2 description', NeverMatch())

        self.assert_description('m1 description', m1)
        self.assert_description('m2 description', m2)

    def testAppendsValuesToDescription(self):
        m = described_as('value 1 = %0, value 2 = %1', anything(), 33, 97)

        self.assert_description('value 1 = <33>, value 2 = <97>', m)

    def testDelegatesMatchingToNestedMatcher(self):
        m1 = described_as('irrelevant', anything())
        m2 = described_as('irrelevant', NeverMatch())

        self.assertTrue(m1.matches(object()))
        self.assertTrue(not m2.matches('hi'))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(
                                described_as('irrelevant', anything()),
                                object())

    def testDelegatesMismatchDescriptionToNestedMatcher(self):
        self.assert_mismatch_description(
                                NeverMatch.mismatch_description,
                                described_as('irrelevant', NeverMatch()),
                                'hi')

    def testDelegatesDescribeMismatchToNestedMatcher(self):
        self.assert_describe_mismatch(
                                NeverMatch.mismatch_description,
                                described_as('irrelevant', NeverMatch()),
                                'hi')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = isanything_test
if __name__ == "__main__":
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.core.core.isanything import *

from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsAnythingTest(MatcherTest):

    def testAlwaysEvaluatesToTrue(self):
        self.assert_matches('None', anything(), None)
        self.assert_matches('object', anything(), object())
        self.assert_matches('string', anything(), 'hi')

    def testHasUsefulDefaultDescription(self):
        self.assert_description('ANYTHING', anything())

    def testCanOverrideDescription(self):
        description = 'DESCRIPTION'
        self.assert_description(description, anything(description))

    def testMatchAlwaysSucceedsSoShouldNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(anything(), 'hi')


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = isequal_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.core.core.isequal import *

from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsEqualTest(MatcherTest):

    def testComparesObjectsUsingEquality(self):
        self.assert_matches('equal numbers', equal_to(1), 1)
        self.assert_does_not_match('unequal numbers', equal_to(1), 2)

    def testCanCompareNoneValues(self):
        self.assert_matches('None equals None', equal_to(None), None)

        self.assert_does_not_match('None as argument', equal_to('hi'), None)
        self.assert_does_not_match('None in equal_to', equal_to(None), 'hi')

    def testHonorsArgumentEqImplementationEvenWithNone(self):
        class AlwaysEqual:
            def __eq__(self, obj): return True
        class NeverEqual:
            def __eq__(self, obj): return False
        self.assert_matches("always equal", equal_to(None), AlwaysEqual())
        self.assert_does_not_match("never equal", equal_to(None), NeverEqual())

    def testIncludesTheResultOfCallingToStringOnItsArgumentInTheDescription(self):
        argument_description = 'ARGUMENT DESCRIPTION'
        class Argument:
            def __str__(self): return argument_description
        self.assert_description('<ARGUMENT DESCRIPTION>', equal_to(Argument()))

    def testReturnsAnObviousDescriptionIfCreatedWithANestedMatcherByMistake(self):
        inner_matcher = equal_to('NestedMatcher')
        self.assert_description("<'NestedMatcher'>", equal_to(inner_matcher))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(equal_to('hi'), 'hi')

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was 'bad'", equal_to('good'), 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", equal_to('good'), 'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = isinstanceof_test
import sys

if __name__ == '__main__':
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.core.core.isinstanceof import *

from hamcrest_unit_test.matcher_test import MatcherTest

try:
    import unittest2 as unittest
except ImportError:
    import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsInstanceOfTest(MatcherTest):

    def testEvaluatesToTrueIfArgumentIsInstanceOfASpecificClass(self):
        self.assert_matches('same class', instance_of(int), 1)

        self.assert_does_not_match('different class', instance_of(int), 'hi')
        self.assert_does_not_match('None', instance_of(int), None)

    def testMatcherCreationRequiresType(self):
        self.assertRaises(TypeError, instance_of, 'not a type')

    def testHasAReadableDescription(self):
        self.assert_description('an instance of int', instance_of(int));

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(instance_of(int), 3)

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was 'bad'", instance_of(int), 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", instance_of(int), 'bad')


if sys.version_info < (3,):
    class Parent():
        pass

    class Child(Parent):
        pass

class OldStyleIsInstanceTest(MatcherTest):

    @unittest.skipIf(sys.version_info >= (3,), "Old-style classes are not relevant under Python3+")
    def testMatchesOldStyleClass(self):
        self.assert_matches('same class', instance_of(Parent), Parent())

        self.assert_does_not_match('different class', instance_of(Parent), 'not a Parent')
        self.assert_does_not_match('None', instance_of(Parent), None)

    @unittest.skipIf(sys.version_info >= (3,), "Old-style classes are not relevant under Python3+")
    def testMatchesOldStyleSubclass(self):
        self.assert_matches('same class', instance_of(Parent), Child())

    @unittest.skipIf(sys.version_info >= (3,), "Old-style classes are not relevant under Python3+")
    def testHasAReadableDescription(self):
        self.assert_description('an instance of Parent', instance_of(Parent));

    @unittest.skipIf(sys.version_info >= (3,), "Old-style classes are not relevant under Python3+")
    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(instance_of(Parent), Parent())

    @unittest.skipIf(sys.version_info >= (3,), "Old-style classes are not relevant under Python3+")
    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was 'bad'", instance_of(Parent), 'bad')

    @unittest.skipIf(sys.version_info >= (3,), "Old-style classes are not relevant under Python3+")
    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", instance_of(Parent), 'bad')

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = isnone_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.core.core.isnone import *

from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsNoneTest(MatcherTest):

    def testEvaluatesToTrueIfArgumentIsNone(self):
        self.assert_matches('None', none(), None)

    def testEvaluatesToFalseIfArgumentIsNotNone(self):
        self.assert_does_not_match('not None', none(), object())

    def testHasAReadableDescription(self):
        self.assert_description('None', none());

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(none(), None)

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was 'bad'", none(), 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", none(), 'bad')


class NotNoneTest(MatcherTest):

    def testEvaluatesToTrueIfArgumentIsNotNone(self):
        self.assert_matches('not None', not_none(), object())

    def testEvaluatesToFalseIfArgumentIsNone(self):
        self.assert_does_not_match('None', not_none(), None)

    def testHasAReadableDescription(self):
        self.assert_description('not None', not_none());

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(not_none(), 'hi')

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was <None>", not_none(), None)

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was <None>", not_none(), None)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = isnot_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.core.core.isnot import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsNotTest(MatcherTest):

    def testEvaluatesToTheTheLogicalNegationOfAnotherMatcher(self):
        self.assert_matches('invert mismatch', is_not(equal_to('A')), 'B')
        self.assert_does_not_match('invert match', is_not(equal_to('A')), 'A')

    def testProvidesConvenientShortcutForNotEqualTo(self):
        self.assert_matches('invert mismatch', is_not('A'), 'B');
        self.assert_does_not_match('invert match', is_not('A'), 'A');

    def testProvidesConvenientShortcutForNotInstanceOf(self):
        self.assert_matches('invert mismatch', is_not(str), 1);
        self.assert_does_not_match('invert match', is_not(str), 'A');

    def testHasAReadableDescription(self):
        self.assert_description("not 'A'", is_not('A'));

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(is_not('A'), 'B')

    def testMismatchDescriptionShowsActualArgument(self):
        self.assert_mismatch_description("was 'A'", is_not('A'), 'A')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'A'", is_not('A'), 'A')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = issame_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.core.core.issame import *

from hamcrest.core.string_description import StringDescription
from hamcrest_unit_test.matcher_test import MatcherTest
import re
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

ADDRESS_FORMAT = r"-?0x[0-9a-fA-F]+L?"


class IsSameTest(MatcherTest):

    def testEvaluatesToTrueIfArgumentIsReferenceToASpecifiedObject(self):
        o1 = object()
        o2 = object()

        self.assert_matches('same', same_instance(o1), o1)
        self.assert_does_not_match('different', same_instance(o1), o2)

    def testDescriptionIncludesMemoryAddress(self):
        description = StringDescription()
        expected = re.compile("same instance as " + ADDRESS_FORMAT + " 'abc'")

        description.append_description_of(same_instance('abc'));
        self.assertTrue(expected.match(str(description)))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        o1 = object()
        self.assert_no_mismatch_description(same_instance(o1), o1)

    def testMismatchDescriptionShowsActualArgumentAddress(self):
        matcher = same_instance('foo')
        description = StringDescription()
        expected = re.compile("was " + ADDRESS_FORMAT + " 'hi'")

        result = matcher.matches('hi', description)
        self.assertFalse(result, 'Precondition: Matcher should not match item')
        self.assertTrue(expected.match(str(description)))

    def testMismatchDescriptionWithNilShouldNotIncludeAddress(self):
        self.assert_mismatch_description("was <None>", same_instance('foo'), None)

    def testDescribeMismatch(self):
        matcher = same_instance('foo')
        description = StringDescription()
        expected = re.compile("was " + ADDRESS_FORMAT + " 'hi'")

        matcher.describe_mismatch('hi', description)
        expected = re.compile("was " + ADDRESS_FORMAT + " 'hi'")
        self.assertTrue(expected.match(str(description)),
                        "Expected %s to match %s" % (str(matcher), str(description)))

    def testDescribeMismatchWithNilShouldNotIncludeAddress(self):
        self.assert_describe_mismatch("was <None>", same_instance('foo'), None)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = is_test
from __future__ import absolute_import

from hamcrest.core.core.is_ import *

import six
from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
from .nevermatch import NeverMatch

try:
    import unittest2 as unittest
except ImportError:
    import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

if six.PY2:
    class OldClass:
        pass

class IsTest(MatcherTest):

    def testDelegatesMatchingToNestedMatcher(self):
        self.assert_matches('should match', is_(equal_to(True)), True)
        self.assert_matches('should match', is_(equal_to(False)), False)
        self.assert_does_not_match('should not match', is_(equal_to(True)), False)
        self.assert_does_not_match('should not match', is_(equal_to(False)), True)

    def testDescriptionShouldPassThrough(self):
        self.assert_description('<True>', is_(equal_to(True)))

    def testProvidesConvenientShortcutForIsEqualTo(self):
        self.assert_matches('should match', is_('A'), 'A');
        self.assert_matches('should match', is_('B'), 'B');
        self.assert_does_not_match('should not match', is_('A'), 'B');
        self.assert_does_not_match('should not match', is_('B'), 'A');
        self.assert_description("'A'", is_('A'));

    def testProvidesConvenientShortcutForIsInstanceOf(self):
        self.assert_matches('should match', is_(str), 'A');
        self.assert_does_not_match('should not match', is_(int), 'A');

    @unittest.skipUnless(six.PY2, "Old-style classes are not relevant under Python3+")
    def testProvidesConvenientShortcutForIsInstanceOfOldStyleClass(self):
        self.assert_matches('should match', is_(OldClass), OldClass())

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(is_('A'), 'A')

    def testDelegatesMismatchDescriptionToNestedMatcher(self):
        self.assert_mismatch_description(
                                NeverMatch.mismatch_description,
                                is_(NeverMatch()),
                                'hi')

    def testDelegatesDescribeMismatchToNestedMatcher(self):
        self.assert_describe_mismatch(
                                NeverMatch.mismatch_description,
                                is_(NeverMatch()),
                                'hi')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = nevermatch
from hamcrest.core.base_matcher import BaseMatcher

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class NeverMatch(BaseMatcher):

    mismatch_description = 'NEVERMATCH'

    def matches(self, item, mismatch_description=None):
        if mismatch_description:
            self.describe_mismatch(item, mismatch_description)
        return False

    def describe_mismatch(self, item, mismatch_description):
        mismatch_description.append_text(NeverMatch.mismatch_description)

########NEW FILE########
__FILENAME__ = raises_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.core.core.raises import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Per Fagrell"
__copyright__ = "Copyright 2013 hamcrest.org"
__license__ = "BSD, see License.txt"


def no_exception(*args, **kwargs):
    return


def raise_exception(*args, **kwargs):
    raise AssertionError(str(args) + str(kwargs))


class RaisesTest(MatcherTest):
    def testMatchesIfFunctionRaisesTheExactExceptionExpected(self):
        self.assert_matches('Right exception',
                            raises(AssertionError),
                            calling(raise_exception))

    def testDoesNotMatchTypeErrorIfActualIsNotCallable(self):
        self.assert_does_not_match('Not callable',
                                   raises(TypeError),
                                   23)

    def testMatchesIfFunctionRaisesASubclassOfTheExpectedException(self):
        self.assert_matches('Subclassed Exception',
                            raises(Exception),
                            calling(raise_exception))

    def testDoesNotMatchIfFunctionDoesNotRaiseException(self):
        self.assert_does_not_match('No exception',
                            raises(ValueError),
                            calling(no_exception))

    def testDoesNotMatchExceptionIfRegularExpressionDoesNotMatch(self):
        self.assert_does_not_match('Bad regex',
                                   raises(AssertionError, "Phrase not found"),
                                   calling(raise_exception))

    def testMatchesRegularExpressionToStringifiedException(self):
        self.assert_matches('Regex',
                            raises(AssertionError, "(3, 1, 4)"),
                            calling(raise_exception).with_args(3,1,4))

        self.assert_matches('Regex',
                            raises(AssertionError, "([\d, ]+)"),
                            calling(raise_exception).with_args(3,1,4))

    def testDescribeMismatchWillCallItemIfNotTheOriginalMatch(self):
        function = Callable()
        matcher = raises(AssertionError)
        matcher.describe_mismatch(function, object())
        self.assertTrue(function.called)

class CallingTest(unittest.TestCase):
    def testCallingDoesNotImmediatelyExecuteFunction(self):
        try:
            calling(raise_exception)
        except AssertionError:
            self.fail()
        else:
            pass

    def testCallingObjectCallsProvidedFunction(self):
        method = Callable()
        calling(method)()
        self.assertTrue(method.called)

    def testCallingWithFunctionReturnsObject(self):
        method = Callable()
        callable = calling(method)
        returned = callable.with_args(3, 1, 4, keyword1="arg1")

        self.assertEqual(returned, callable)

    def testCallingWithFunctionSetsArgumentList(self):
        method = Callable()
        calling(method).with_args(3, 1, 4, keyword1="arg1")()

        self.assertEqual(method.args, (3, 1, 4))
        self.assertEqual(method.kwargs, {"keyword1": "arg1"})


class Callable(object):
    def __init__(self):
        self.called = False

    def __call__(self, *args, **kwargs):
        self.called = True
        self.args = args
        self.kwargs = kwargs

########NEW FILE########
__FILENAME__ = match_equality_test
if __name__ == "__main__":
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.library.integration.match_equality import *

from hamcrest.core.core.isequal import equal_to
from hamcrest.core.string_description import tostring
import unittest

__author__ = "Chris Rose"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class MatchEqualityWrapperTest(unittest.TestCase):

    def testMatcherIsEqualWhenMatchesIsTrue(self):
        matcher = equal_to('bar')
        assert match_equality(matcher) == 'bar'

    def testMatcherIsNotEqualWhenMatchesIsFalse(self):
        matcher = equal_to('bar')
        assert match_equality(matcher) != 'foo'

    def testMatcherStringIsMatcherDescription(self):
        matcher = equal_to('bar')
        assert str(match_equality(matcher)) == tostring(matcher)

    def testMatcherReprIsMatcher(self):
        matcher = equal_to('bar')
        assert repr(match_equality(matcher)) == tostring(matcher)

    def testMatchesWhenProvidedAnObject(self):
        assert match_equality('bar') == 'bar'


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = matcher_test
from hamcrest.core.string_description import StringDescription

try:
    from unittest import skipIf
    import unittest
except ImportError:
    import unittest2 as unittest

import logging

log = logging.getLogger(__name__)

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"
__tracebackhide__ = True


class MatcherTest(unittest.TestCase):

    def assert_matches(self, message, matcher, arg):
        assert_matches(matcher, arg, message)

    def assert_does_not_match(self, message, matcher, arg):
        assert_does_not_match(matcher, arg, message)

    def assert_description(self, expected, matcher):
        assert_description(expected, matcher)

    def assert_no_mismatch_description(self, matcher, arg):
        assert_no_mismatch_description(matcher, arg)

    def assert_mismatch_description(self, expected, matcher, arg):
        assert_mismatch_description(expected, matcher, arg)

    def assert_describe_mismatch(self, expected, matcher, arg):
        assert_describe_mismatch(expected, matcher, arg)


def assert_matches(matcher, arg, message):
    try:
        assert matcher.matches(arg), message
    except AssertionError:
        description = StringDescription()
        matcher.describe_mismatch(arg, description)
        log.error(str(description))
        raise


def assert_does_not_match(matcher, arg, message):
    assert not matcher.matches(arg), message


def assert_description(expected, matcher):
    description = StringDescription()
    description.append_description_of(matcher)
    assert expected == str(description)


def assert_no_mismatch_description(matcher, arg):
    description = StringDescription()
    result = matcher.matches(arg, description)
    assert result, 'Precondition: Matcher should match item'
    assert '' == str(description), 'Expected no mismatch description'


def assert_mismatch_description(expected, matcher, arg):
    description = StringDescription()
    result = matcher.matches(arg, description)
    assert not result, 'Precondition: Matcher should not match item'
    assert expected == str(description)


def assert_describe_mismatch(expected, matcher, arg):
    description = StringDescription()
    matcher.describe_mismatch(arg, description)
    assert expected == str(description)

########NEW FILE########
__FILENAME__ = iscloseto_test
import six
from hamcrest.library.number.iscloseto import *

from hamcrest_unit_test.matcher_test import MatcherTest
try:
    import unittest2 as unittest
except ImportError:
    import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class IsCloseToTest(MatcherTest):

    def testEvaluatesToTrueIfArgumentIsEqualToAValueWithinSomeError(self):
        matcher = close_to(1.0, 0.5)

        self.assert_matches('equal', matcher, 1.0)
        self.assert_matches('less but within delta', matcher, 0.5)
        self.assert_matches('greater but within delta', matcher, 1.5)

        self.assert_does_not_match('too small', matcher, 0.4)
        self.assert_does_not_match('too large', matcher, 1.6)

    def testMatcherCreationAcceptsOtherNumericTypes(self):
        for t in six.integer_types:
            close_to(t(5), t(1))

    def testMatcherCreationRequiresNumbers(self):
        self.assertRaises(TypeError, close_to, 'a', 0.5)
        self.assertRaises(TypeError, close_to, 1.0, 'a')

    def testFailsIfMatchingAgainstNonNumber(self):
        self.assert_does_not_match('not a number', close_to(1.0, 0.5), 'a')

    def testHasAReadableDescription(self):
        self.assert_description('a numeric value within <0.5> of <1.0>',
                                close_to(1.0, 0.5))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(close_to(1.0, 0.5), 1.0)

    def testMismatchDescriptionShowsActualDeltaIfArgumentIsNumeric(self):
        self.assert_mismatch_description('<1.7> differed by <0.7>',
                                         close_to(1.0, 0.5), 1.7)

    def testMismatchDescriptionShowsActualArgumentIfNotNumeric(self):
        self.assert_mismatch_description("was 'bad'", close_to(1.0, 0.5), 'bad')

    def testDescribeMismatchShowsActualDeltaIfArgumentIsNumeric(self):
        self.assert_describe_mismatch('<1.7> differed by <0.7>',
                                      close_to(1.0, 0.5), 1.7)

    def testDescribeMismatchShowsActualArgumentIfNotNumeric(self):
        self.assert_describe_mismatch("was 'bad'", close_to(1.0, 0.5), 'bad')

try:
    import numpy as np
    NUMPY_AVAILABLE = True
except ImportError:
    NUMPY_AVAILABLE = False

class IsNumericTest(unittest.TestCase):

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_int(self):
        self.assertTrue(isnumeric(np.int(1)), "Platform integer (normally either int32 or int64)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_int8(self):
        self.assertTrue(isnumeric(np.int8(1)), "Byte (-128 to 127)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_int16(self):
        self.assertTrue(isnumeric(np.int16(1)), "Integer (-32768 to 32767)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_int32(self):
        self.assertTrue(isnumeric(np.int32(1)), "Integer (-2147483648 to 2147483647)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_int64(self):
        self.assertTrue(isnumeric(np.int64(1)), "Integer (9223372036854775808 to 9223372036854775807)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_uint8(self):
        self.assertTrue(isnumeric(np.uint8(1)), "Unsigned integer (0 to 255)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_uint16(self):
        self.assertTrue(isnumeric(np.uint16(1)), "Unsigned integer (0 to 65535)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_uint32(self):
        self.assertTrue(isnumeric(np.uint32(1)), "Unsigned integer (0 to 4294967295)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_uint64(self):
        self.assertTrue(isnumeric(np.uint64(1)), "Unsigned integer (0 to 18446744073709551615)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_float(self):
        self.assertTrue(isnumeric(np.float(1)), "Shorthand for float64.")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_float16(self):
        self.assertTrue(isnumeric(np.float16(1)), "Half precision float: sign bit, 5 bits exponent, 10 bits mantissa")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_float32(self):
        self.assertTrue(isnumeric(np.float32(1)), "Single precision float: sign bit, 8 bits exponent, 23 bits mantissa")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_float64(self):
        self.assertTrue(isnumeric(np.float64(1)), "Double precision float: sign bit, 11 bits exponent, 52 bits mantissa")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_complex(self):
        self.assertTrue(isnumeric(np.complex(1)), "Shorthand for complex128.")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_complex64(self):
        self.assertTrue(isnumeric(np.complex64(1)), "Complex number, represented by two 32-bit floats (real and imaginary components)")

    @unittest.skipUnless(NUMPY_AVAILABLE, "Skipped because it needs NumPy")
    def test_numpy_numeric_type_complex128(self):
        self.assertTrue(isnumeric(np.complex128(1)), "Complex number, represented by two 64-bit floats (real and imaginary components)")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = ordering_comparison_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.library.number.ordering_comparison import *

from datetime import date
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class OrderingComparisonTest(MatcherTest):

    def testComparesObjectsForGreaterThan(self):
        self.assert_matches('match', greater_than(1), 2)
        self.assert_does_not_match('no match', greater_than(1), 1)

    def testComparesObjectsForLessThan(self):
        self.assert_matches('match', less_than(1), 0)
        self.assert_does_not_match('no match', less_than(1), 1)

    def testComparesObjectsForGreaterThanOrEqualTo(self):
        self.assert_matches('match', greater_than_or_equal_to(1), 2)
        self.assert_matches('match', greater_than_or_equal_to(1), 1)
        self.assert_does_not_match('no match', greater_than_or_equal_to(1), 0)

    def testComparesObjectsForLessThanOrEqualTo(self):
        self.assert_matches('match', less_than_or_equal_to(1), 0)
        self.assert_matches('match', less_than_or_equal_to(1), 1)
        self.assert_does_not_match('no match', less_than_or_equal_to(1), 2)

    def testSupportsDifferentTypesOfComparableObjects(self):
        self.assert_matches('strings', greater_than('bb'), 'cc')
        self.assert_matches('dates', less_than(date.today()), date.min)

    def testHasAReadableDescription(self):
        self.assert_description('a value greater than <1>', greater_than(1))
        self.assert_description('a value greater than or equal to <1>',
                                greater_than_or_equal_to(1))
        self.assert_description('a value less than <1>', less_than(1))
        self.assert_description('a value less than or equal to <1>',
                                less_than_or_equal_to(1))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(greater_than(1), 2)
        self.assert_no_mismatch_description(less_than(1), 0)
        self.assert_no_mismatch_description(greater_than_or_equal_to(1), 1)
        self.assert_no_mismatch_description(less_than_or_equal_to(1), 1)

    def testMismatchDescription(self):
        self.assert_mismatch_description("was <0>", greater_than(1), 0)
        self.assert_mismatch_description("was <2>", less_than(1), 2)
        self.assert_mismatch_description("was <0>",
                                         greater_than_or_equal_to(1), 0)
        self.assert_mismatch_description("was <2>",
                                         less_than_or_equal_to(1), 2)

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was <0>", greater_than(1), 0)
        self.assert_describe_mismatch("was <2>", less_than(1), 2)
        self.assert_describe_mismatch("was <0>",
                                      greater_than_or_equal_to(1), 0)
        self.assert_describe_mismatch("was <2>", less_than_or_equal_to(1), 2)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = haslength_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.library.object.haslength import *

from hamcrest.core.core.isequal import equal_to
from hamcrest.library.number.ordering_comparison import greater_than
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class FakeWithLen(object):

    def __init__(self, len):
        self.len = len

    def __len__(self):
        return self.len

    def __str__(self):
        return 'FakeWithLen'


class FakeWithoutLen(object):

    def __str__(self):
        return 'FakeWithoutLen'


class HasLengthTest(MatcherTest):

    def testPassesResultOfLenToNestedMatcher(self):
        self.assert_matches('equal', has_length(equal_to(42)), FakeWithLen(42))
        self.assert_does_not_match('unequal',
                                   has_length(equal_to(42)), FakeWithLen(1))

    def testProvidesConvenientShortcutForHasLengthEqualTo(self):
        self.assert_matches('equal', has_length(42), FakeWithLen(42))
        self.assert_does_not_match('unequal', has_length(42), FakeWithLen(1))

    def testDoesNotMatchObjectWithoutLen(self):
        self.assert_does_not_match('no length', has_length(42), object())

    def testHasReadableDescription(self):
        self.assert_description('an object with length of a value greater than <5>',
                                has_length(greater_than(5)))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(has_length(3), 'foo')

    def testMismatchDescriptionForItemWithWrongLength(self):
        self.assert_mismatch_description('was <FakeWithLen> with length of <4>',
                                         has_length(3), FakeWithLen(4))

    def testMismatchDescriptionForItemWithoutLength(self):
        self.assert_mismatch_description("was <FakeWithoutLen>",
                                         has_length(3), FakeWithoutLen())

    def testDescribeMismatchForItemWithWrongLength(self):
        self.assert_describe_mismatch('was <FakeWithLen> with length of <4>',
                                      has_length(3), FakeWithLen(4))

    def testDescribeMismatchForItemWithoutLength(self):
        self.assert_describe_mismatch("was <FakeWithoutLen>",
                                      has_length(3), FakeWithoutLen())



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = hasproperty_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.library.object.hasproperty import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Chris Rose"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

class OnePropertyOldStyle:

    field = 'value'
    field2 = 'value2'

class OnePropertyNewStyle(object):

    field = 'value'
    field2 = 'value2'

    def __repr__(self):
        return 'OnePropertyNewStyle'

    def __str__(self):
        return repr(self)

class OverridingOldStyle:

    def __getattr__(self, name):
        if name == 'field':
            return 'value'
        if name == 'field2':
            return 'value2'

        raise AttributeError(name)

class OverridingNewStyleGetAttr(object):

    def __getattr__(self, name):
        if name == 'field':
            return 'value'
        if name == 'field2':
            return 'value2'

        raise AttributeError(name)

class OverridingNewStyleGetAttribute(object):

    def __getattribute__(self, name):
        if name == 'field':
            return 'value'
        if name == 'field2':
            return 'value2'

        raise AttributeError(name)


class ObjectPropertyMatcher(object):

    match_sets = (
        ("old-style: %s", OnePropertyOldStyle),
        ('new-style: %s', OnePropertyNewStyle),
        ('old-style, overriding: %s', OverridingOldStyle),
        ('new-style, using getattr: %s', OverridingNewStyleGetAttr),
        ('new-style, using getattribute: %s', OverridingNewStyleGetAttribute),
        )

    def assert_matches_for_all_types(self, description, matcher):
        for description_fmt, target_class in self.match_sets:
            self.assert_matches(description_fmt % description,
                                matcher,
                                target_class())

    def assert_does_not_match_for_all_types(self, description, matcher):
        for description_fmt, target_class in self.match_sets:
            self.assert_does_not_match(description_fmt % description,
                                       matcher,
                                       target_class())

class HasPropertyTest(MatcherTest, ObjectPropertyMatcher):

    def testHasPropertyWithoutValueMatcher(self):
        self.assert_matches_for_all_types('has property with name',
                                          has_property('field'))

    def testHasPropertyWithoutValueMatcherNegative(self):
        self.assert_does_not_match_for_all_types('has property with name',
                                                 has_property('not_there'))

    def testHasPropertyWithValueMatcher(self):
        self.assert_matches_for_all_types('has property with name and value',
                                          has_property('field', 'value'))

    def testHasPropertyWithValueMatcherNegative(self):
        self.assert_does_not_match_for_all_types('has property with name',
                                                 has_property('field', 'not the value'))

    def testDescription(self):
        self.assert_description("an object with a property 'field' matching ANYTHING",
                                has_property('field'))
        self.assert_description("an object with a property 'field' matching 'value'",
                                has_property('field', 'value'))

    def testDescribeMissingProperty(self):
        self.assert_mismatch_description("<OnePropertyNewStyle> did not have the 'not_there' property",
                                         has_property('not_there'), OnePropertyNewStyle())

    def testDescribePropertyValueMismatch(self):
        self.assert_mismatch_description("property 'field' was 'value'",
                                         has_property('field', 'another_value'), OnePropertyNewStyle())

    def testMismatchDescription(self):
        self.assert_describe_mismatch("<OnePropertyNewStyle> did not have the 'not_there' property",
                                      has_property('not_there'),
                                      OnePropertyNewStyle())

    def testNoMismatchDescriptionOnMatch(self):
        self.assert_no_mismatch_description(has_property('field', 'value'), OnePropertyNewStyle())


class HasPropertiesTest(MatcherTest, ObjectPropertyMatcher):

    def testMatcherCreationRequiresEvenNumberOfPositionalArguments(self):
        self.assertRaises(ValueError, has_properties, 'a', 'b', 'c')

    def testMatchesUsingSingleDictionaryArgument(self):
        # import pdb; pdb.set_trace()
        self.assert_matches_for_all_types('matches using a single-argument dictionary',
                                          has_properties({'field':'value', 'field2': 'value2'}))

    def testMatchesUsingKeywordArguments(self):
        self.assert_matches_for_all_types('matches using a kwarg dict',
                                          has_properties(field='value', field2='value2'))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = hasstring_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.library.object.hasstring import *

from hamcrest.core.core.isequal import equal_to
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class FakeWithStr(object):

    def __str__(self):
        return 'FakeWithStr'


class HasStringTest(MatcherTest):

    def testPassesResultOfToStrToNestedMatcher(self):
        self.assert_matches('equal',
                            has_string(equal_to('FakeWithStr')), FakeWithStr())
        self.assert_does_not_match('unequal',
                                   has_string(equal_to('FakeWithStr')), 3)

    def testProvidesConvenientShortcutForHasStringEqualTo(self):
        self.assert_matches('equal', has_string('FakeWithStr'), FakeWithStr())
        self.assert_does_not_match('unequal', has_string('FakeWithStr'), 3)

    def testHasReadableDescription(self):
        self.assert_description("an object with str 'foo'", has_string('foo'))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(has_string('FakeWithStr'),
                                            FakeWithStr())

    def testMismatchDescription(self):
        self.assert_mismatch_description("was <FakeWithStr>",
                                         has_string('foo'), FakeWithStr())

    def testDescribeMismatchDescription(self):
        self.assert_describe_mismatch("was <FakeWithStr>",
                                      has_string('foo'), FakeWithStr())


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = string_description_test
import six
from hamcrest.core.string_description import *

from hamcrest.core.selfdescribing import SelfDescribing
import re
try:
    import unittest2 as unittest
except ImportError:
    import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


class FakeSelfDescribing(SelfDescribing):

    def describe_to(self, description):
        description.append_text('DESCRIPTION')


class StringDescriptionTest(unittest.TestCase):

    def setUp(self):
        self.description = StringDescription()

    def testLetsSelfDescribingObjectDescribeItself(self):
        self.description.append_description_of(FakeSelfDescribing())
        self.assertEqual('DESCRIPTION', str(self.description))

    def testDescribesStringInQuotes(self):
        self.description.append_description_of('FOO')
        self.assertEqual("'FOO'", str(self.description))

    def testWrapsNonSelfDescribingObjectInAngleBrackets(self):
        self.description.append_description_of(42)
        self.assertEqual('<42>', str(self.description))

    def testShouldNotAddAngleBracketsIfObjectDescriptionAlreadyHasThem(self):
        self.description.append_description_of(object())
        expected = re.compile("<object object at 0x[0-9a-fA-F]+>")
        self.assertTrue(expected.match(str(self.description)))

    @unittest.skip("Describe unicode strings doesn't malform in Python 3. Six makes this go away anyway :/")
    def testDescribeUnicodeStringAsBytes(self):
        self.description.append_description_of(six.u('\u05d0'))
        self.assertEqual(six.u('\\u05d0'), str(self.description))

    @unittest.skipUnless(six.PY3, "Describe unicode strings only malforms in Python 2")
    def testDescribeUnicodeStringAsUnicode(self):
        self.description.append_description_of(six.u('\u05d0'))
        self.assertEqual(six.u("'\u05d0'"), str(self.description))

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = isequal_ignoring_case_test
import six
from hamcrest.library.text.isequal_ignoring_case import equal_to_ignoring_case

from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


matcher = equal_to_ignoring_case('heLLo')

class IsEqualIgnoringCaseTest(MatcherTest):

    def testIgnoresCaseOfCharsInString(self):
        self.assert_matches('all upper', matcher, 'HELLO')
        self.assert_matches('all lower', matcher, 'hello')
        self.assert_matches('mixed up', matcher, 'HelLo')

        self.assert_does_not_match('no match', matcher, 'bye')

    def testFailsIfAdditionalWhitespaceIsPresent(self):
        self.assert_does_not_match('whitespace suffix', matcher, 'heLLo ')
        self.assert_does_not_match('whitespace prefix', matcher, ' heLLo')

    def testMatcherCreationRequiresString(self):
        self.assertRaises(TypeError, equal_to_ignoring_case, 3)

    def testFailsIfMatchingAgainstNonString(self):
        self.assert_does_not_match('non-string', matcher, object())

    def testCanApplyUnicodeStringToUnicodeMatcher(self):
        self.assert_matches('unicode-unicode',
                            equal_to_ignoring_case(six.u('heLLo')), six.u('HelLo'))

    def testCanApplyPlainStringToUnicodeMatcher(self):
        self.assert_matches('unicode-ascii',
                            equal_to_ignoring_case(six.u('heLLo')), 'HelLo')

    def testCanApplyUnicodeStringToPlainMatcher(self):
        self.assert_matches('ascii-unicode',
                            equal_to_ignoring_case('heLLo'), six.u('HelLo'))

    def testHasAReadableDescription(self):
        self.assert_description("'heLLo' ignoring case", matcher)

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(matcher, 'hello')

    def testMismatchDescription(self):
        self.assert_mismatch_description("was 'bad'", matcher, 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", matcher, 'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = isequal_ignoring_whitespace_test
import six
from hamcrest.library.text.isequal_ignoring_whitespace import *

from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


matcher = equal_to_ignoring_whitespace('Hello World   how\n are we? ')

class IsEqualIgnoringWhiteSpaceTest(MatcherTest):

    def testPassesIfWordsAreSameButWhitespaceDiffers(self):
        self.assert_matches('less whitespace',
                            matcher, 'Hello World how are we?')
        self.assert_matches('more whitespace',
                            matcher, '   Hello World   how are \n\n\twe?')

    def testFailsIfTextOtherThanWhitespaceDiffers(self):
        self.assert_does_not_match('wrong word',
                                   matcher, 'Hello PLANET how are we?')
        self.assert_does_not_match('incomplete',
                                   matcher, 'Hello World how are we')

    def testFailsIfWhitespaceIsAddedOrRemovedInMidWord(self):
        self.assert_does_not_match('need whitespace between Hello and World',
                                   matcher, 'HelloWorld how are we?')
        self.assert_does_not_match('wrong whitespace within World',
                                   matcher, 'Hello Wo rld how are we?')

    def testMatcherCreationRequiresString(self):
        self.assertRaises(TypeError, equal_to_ignoring_whitespace, 3)

    def testFailsIfMatchingAgainstNonString(self):
        self.assert_does_not_match('non-string', matcher, object())

    def testCanApplyUnicodeStringToUnicodeMatcher(self):
        self.assert_matches('unicode-unicode',
                            equal_to_ignoring_whitespace(six.u('foo\nbar')),
                            six.u('foo bar'))

    def testCanApplyPlainStringToUnicodeMatcher(self):
        self.assert_matches('unicode-ascii',
                            equal_to_ignoring_whitespace(six.u('foo\nbar')),
                            'foo bar')

    def testCanApplyUnicodeStringToPlainMatcher(self):
        self.assert_matches('ascii-unicode',
                            equal_to_ignoring_whitespace('foo\n bar'),
                            six.u('foo bar'))

    def testDescribesItselfAsIgnoringWhiteSpace(self):
        self.assert_description("'foo\\nbar' ignoring whitespace",
                                equal_to_ignoring_whitespace('foo\nbar'))

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(
                        equal_to_ignoring_whitespace('foo\nbar'), 'foo bar')

    def testMismatchDescription(self):
        self.assert_mismatch_description("was 'bad'", matcher, 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", matcher, 'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = stringcontainsinorder_test
if __name__ == '__main__':
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.library.text import string_contains_in_order

from hamcrest.core.string_description import StringDescription
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Romilly Cocking"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


matcher = string_contains_in_order('string one', 'string two', 'string three')

class StringContainsInOrderTest(MatcherTest):

    def testMatchesIfOrderIsCorrect(self):
        self.assert_matches('correct order', matcher,
                            'string one then string two followed by string three')

    def testDoesNotMatchIfOrderIsIncorrect(self):
        self.assert_does_not_match('incorrect order', matcher,
                                    'string two then string one followed by string three')

    def testDoesNotMatchIfExpectedSubstringsAreMissing(self):
        self.assert_does_not_match('missing string one', matcher, 'string two then string three')
        self.assert_does_not_match('missing string two', matcher, 'string one then string three')
        self.assert_does_not_match('missing string three', matcher, 'string one then string two')

    def testMatcherCreationRequiresString(self):
        self.assertRaises(TypeError, string_contains_in_order, 3)

    def testFailsIfMatchingAgainstNonString(self):
        self.assert_does_not_match('non-string', matcher, object())

    def testHasAReadableDescription(self):
        self.assert_description("a string containing 'string one', 'string two', 'string three' in order", matcher)

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(matcher, 'string one then string two followed by string three')

    def testMismatchDescription(self):
        self.assert_mismatch_description("was 'bad'", matcher, 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", matcher, 'bad')

########NEW FILE########
__FILENAME__ = stringcontains_test
from __future__ import with_statement
import six
from hamcrest.library.text.stringcontains import contains_string
from hamcrest_unit_test.matcher_test import *
import unittest
import pytest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


if six.PY2:
    matcher_args = ("EXCERPT", six.u("EXCERPT"))
else:
    matcher_args = ("EXCERPT",)

    
@pytest.fixture(scope="module",
                params=matcher_args)
def matcher(request):
    return contains_string(request.param)

TEST_MATCHING_STRINGS = (
    ("EXCERPTEND",),
    ("STARTEXCERPTEND",),
    ("STARTEXCERPT",),
    ("EXCERPTEXCERPT",),
    ("EXCERPT",),
)
if six.PY2:
    TEST_MATCHING_STRINGS += (
        (six.u("EXCERPTEND"),),
        (six.u("STARTEXCERPTEND"),),
        (six.u("STARTEXCERPT"),),
        (six.u("EXCERPTEXCERPT"),),
        (six.u("EXCERPT"),),
    )

TEST_MISMATCHING_STRINGS = (
    ("whatever",),
    ("EXCERP",),
    (object(),),
)


@pytest.mark.parametrize(['text'], TEST_MATCHING_STRINGS)
def test_evaluates_true_if_argument_contains_substring(text, matcher):
    assert_matches(matcher, text, "assert that %s matches %s" % (text, matcher))


@pytest.mark.parametrize(['text'], TEST_MISMATCHING_STRINGS)
def test_evaluates_false_with_mismatch(text, matcher):
    assert_does_not_match(matcher, text, "%s was not in string %s" % (matcher, text))


def testMatcherCreationRequiresString():
    with pytest.raises(TypeError):
        contains_string(3)


def test_description(matcher):
    assert_description("a string containing 'EXCERPT'", matcher)


def test_successful_match_does_not_have_mismatch_description(matcher):
    assert_no_mismatch_description(matcher, "EXCERPT")


@pytest.mark.parametrize(['text'], TEST_MISMATCHING_STRINGS)
def test_mismatch_description(matcher, text):
    if isinstance(text, six.string_types):
        check_str = "'%s'" % text
    else:
        check_str = "%s" % text
    assert_mismatch_description("was %s" % check_str, matcher, text)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = stringendswith_test
import six

from hamcrest.library.text.stringendswith import *

from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


EXCERPT = 'EXCERPT'
matcher = ends_with(EXCERPT)

class StringEndsWithTest(MatcherTest):

    def testEvaluatesToTrueIfArgumentContainsSpecifiedSubstring(self):
        self.assert_does_not_match('excerpt at beginning',
                                   matcher, EXCERPT + 'END')
        self.assert_matches('excerpt at end', matcher, 'START' + EXCERPT)
        self.assert_does_not_match('excerpt in middle',
                                   matcher, 'START' + EXCERPT + 'END')
        self.assert_matches('excerpt repeated', matcher, EXCERPT + EXCERPT)

        self.assert_does_not_match('excerpt not in string',
                                   matcher, 'whatever')
        self.assert_does_not_match('only part of excerpt is at end of string',
                                   matcher, EXCERPT[1:])

    def testEvaluatesToTrueIfArgumentIsEqualToSubstring(self):
        self.assert_matches('excerpt is entire string', matcher, EXCERPT)

    def testMatcherCreationRequiresString(self):
        self.assertRaises(TypeError, ends_with, 3)

    def testFailsIfMatchingAgainstNonString(self):
        self.assert_does_not_match('non-string', matcher, object())

    def testCanApplyUnicodeStringToUnicodeMatcher(self):
        self.assert_matches('unicode-unicode',
                            ends_with(six.u('baz')), six.u('foo bar baz'))

    def testCanApplyPlainStringToUnicodeMatcher(self):
        self.assert_matches('unicode-ascii',
                            ends_with(six.u('baz')), 'foo bar baz')

    def testCanApplyUnicodeStringToPlainMatcher(self):
        self.assert_matches('ascii-unicode',
                            ends_with(six.u('baz')), six.u('foo bar baz'))

    def testHasAReadableDescription(self):
        self.assert_description("a string ending with 'EXCERPT'", matcher)

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(matcher, EXCERPT)

    def testMismatchDescription(self):
        self.assert_mismatch_description("was 'bad'", matcher, 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", matcher, 'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = stringmatches_test
if __name__ == "__main__":
    import sys
    sys.path.insert(0, '..')
    sys.path.insert(0, '../..')

from hamcrest.library.text.stringmatches import *
from hamcrest_unit_test.matcher_test import MatcherTest

import re
try:
    import unittest2 as unittest
except ImportError:
    import unittest

__author__ = "Chris Rose"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"

string_matcher = matches_regexp(r'--[a-z]+--')
compiled_matcher = matches_regexp(re.compile(r'--[a-z]+--'))

class StringMatchesTest(MatcherTest):

    def testMatchesWhenPatternIsFoundAtBeginning(self):
        self.assert_matches('pattern at beginning', string_matcher, "--a-----")

    def testMatchesWhenPatternIsFoundAtEnd(self):
        self.assert_matches('pattern at end', string_matcher, "-----a--")

    def testMatchesWhenPatternIsFoundInMiddle(self):
        self.assert_matches('pattern in the middle', string_matcher, "-----a-----")

    def testMismatchesWhenPatternIsNotPresent(self):
        self.assert_does_not_match('pattern nowhere', string_matcher, "--0--")

    def testMatchesUsingCompiledExpressions(self):
        self.assert_matches('pattern nowhere', compiled_matcher, "--a--")

    def testMismatchesUsingCompiledExpressions(self):
        self.assert_does_not_match('pattern nowhere', compiled_matcher, "--0--")

    def testStringHasAReadableDescription(self):
        self.assert_description("a string matching '--[a-z]+--'", string_matcher)

    def testPatternHasAReadableDescription(self):
        self.assert_description("a string matching '--[a-z]+--'", compiled_matcher)

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(string_matcher, '--a--')

    def testStringMismatchDescription(self):
        self.assert_mismatch_description("was 'bad'", string_matcher, 'bad')

    def testCompiledMismatchDescription(self):
        self.assert_mismatch_description("was 'bad'", compiled_matcher, 'bad')

    def testStringDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", string_matcher, 'bad')

    def testCompiledDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", compiled_matcher, 'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = stringstartswith_test
import six

from hamcrest.library.text.stringstartswith import *

from hamcrest.core.assert_that import assert_that
from hamcrest.core.core.isnot import is_not
from hamcrest_unit_test.matcher_test import MatcherTest
import unittest

__author__ = "Jon Reid"
__copyright__ = "Copyright 2011 hamcrest.org"
__license__ = "BSD, see License.txt"


EXCERPT = 'EXCERPT'
matcher = starts_with(EXCERPT)
stringstartswith = starts_with(EXCERPT)

class StringStartsWithTest(MatcherTest):

    def testEvaluatesToTrueIfArgumentContainsSpecifiedSubstring(self):
        self.assert_matches('excerpt at beginning', matcher, EXCERPT + 'END')
        self.assert_does_not_match('excerpt at end',
                                   matcher, 'START' + EXCERPT)
        self.assert_does_not_match('excerpt in middle',
                                   matcher, 'START' + EXCERPT + 'END')
        self.assert_matches('excerpt repeated', matcher, EXCERPT + EXCERPT)

        self.assert_does_not_match('excerpt not in string',matcher, 'whatever')
        self.assert_does_not_match('only part of excerpt',matcher, EXCERPT[1:])

    def testEvaluatesToTrueIfArgumentIsEqualToSubstring(self):
        self.assert_matches('excerpt is entire string', matcher, EXCERPT)

    def testMatcherCreationRequiresString(self):
        self.assertRaises(TypeError, starts_with, 3)

    def testFailsIfMatchingAgainstNonString(self):
        self.assert_does_not_match('non-string', matcher, object())

    def testCanApplyUnicodeStringToUnicodeMatcher(self):
        self.assert_matches('unicode-unicode',
                            starts_with(six.u('foo')), six.u('foo bar baz'))

    def testCanApplyPlainStringToUnicodeMatcher(self):
        self.assert_matches('unicode-ascii',
                            starts_with(six.u('foo')), 'foo bar baz')

    def testCanApplyUnicodeStringToPlainMatcher(self):
        self.assert_matches('ascii-unicode',
                            starts_with(six.u('foo')), six.u('foo bar baz'))

    def testHasAReadableDescription(self):
        self.assert_description("a string starting with 'EXCERPT'", matcher)

    def testSuccessfulMatchDoesNotGenerateMismatchDescription(self):
        self.assert_no_mismatch_description(matcher, EXCERPT)

    def testMismatchDescription(self):
        self.assert_mismatch_description("was 'bad'", matcher, 'bad')

    def testDescribeMismatch(self):
        self.assert_describe_mismatch("was 'bad'", matcher, 'bad')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = object_import
from __future__ import print_function
from hamcrest import *

try:
    class MyTest(object):
        pass
except TypeError:
    print('Object class defined at {0}'.format(getattr(object, '__file__', 'NOWHERE')))
    raise

########NEW FILE########
