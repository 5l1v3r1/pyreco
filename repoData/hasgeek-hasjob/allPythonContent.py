__FILENAME__ = env
from __future__ import with_statement
from alembic import context
from alembic.config import Config
from sqlalchemy import engine_from_config, pool
from logging.config import fileConfig
from flask.ext.alembic import FlaskAlembicConfig

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = FlaskAlembicConfig("alembic.ini")

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
from flask import current_app
with current_app.app_context():
    # set the database url
    config.set_main_option('sqlalchemy.url', current_app.config.get('SQLALCHEMY_DATABASE_URI'))
    flask_app = __import__('%s' % (current_app.name), fromlist=[current_app.name])

db_obj_name = config.get_main_option("flask_sqlalchemy")
db_obj = getattr(flask_app, db_obj_name)
target_metadata = db_obj.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.

def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(url=url)

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    engine = engine_from_config(
                config.get_section(config.config_ini_section),
                prefix='sqlalchemy.',
                poolclass=pool.NullPool)

    connection = engine.connect()
    context.configure(
                connection=connection,
                target_metadata=target_metadata
                )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


########NEW FILE########
__FILENAME__ = 1bcc4e025b04_fullname
"""fullname

Revision ID: 1bcc4e025b04
Revises: 30828b49527
Create Date: 2013-08-30 12:08:23.561163

"""

# revision identifiers, used by Alembic.
revision = '1bcc4e025b04'
down_revision = '30828b49527'

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.add_column('jobpost', sa.Column('fullname', sa.Unicode(length=80), nullable=True))
    ### end Alembic commands ###


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('jobpost', 'fullname')
    ### end Alembic commands ###

########NEW FILE########
__FILENAME__ = 1feef782ef45_jobpost_language
"""JobPost language

Revision ID: 1feef782ef45
Revises: ec6faeb2eec
Create Date: 2014-04-02 02:35:53.483588

"""

# revision identifiers, used by Alembic.
revision = '1feef782ef45'
down_revision = 'ec6faeb2eec'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('jobpost', sa.Column('language', sa.CHAR(length=2), nullable=True))


def downgrade():
    op.drop_column('jobpost', 'language')

########NEW FILE########
__FILENAME__ = 2420dd9c9949_employer_response_me
"""Employer response message

Revision ID: 2420dd9c9949
Revises: 3e27bf9706ee
Create Date: 2013-11-25 15:06:46.015614

"""

# revision identifiers, used by Alembic.
revision = '2420dd9c9949'
down_revision = '3e27bf9706ee'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('job_application', sa.Column('response_message', sa.UnicodeText(), nullable=True))


def downgrade():
    op.drop_column('job_application', 'response_message')

########NEW FILE########
__FILENAME__ = 30828b49527_start
"""start

Revision ID: 30828b49527
Revises: None
Create Date: 2013-01-31 00:01:25.298994

"""

# revision identifiers, used by Alembic.
revision = '30828b49527'
down_revision = None

from alembic import op
import sqlalchemy as sa


def upgrade():
    pass


def downgrade():
    pass

########NEW FILE########
__FILENAME__ = 34e1d4b2f636_payscale_info
"""Payscale info

Revision ID: 34e1d4b2f636
Revises: 472ca8e93765
Create Date: 2014-03-22 05:15:43.496558

"""

# revision identifiers, used by Alembic.
revision = '34e1d4b2f636'
down_revision = '472ca8e93765'

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.add_column('jobpost', sa.Column('pay_cash_max', sa.Integer(), nullable=True))
    op.add_column('jobpost', sa.Column('pay_cash_min', sa.Integer(), nullable=True))
    op.add_column('jobpost', sa.Column('pay_currency', sa.CHAR(length=3), nullable=True))
    op.add_column('jobpost', sa.Column('pay_equity_max', sa.Numeric(), nullable=True))
    op.add_column('jobpost', sa.Column('pay_equity_min', sa.Numeric(), nullable=True))
    op.add_column('jobpost', sa.Column('pay_type', sa.SmallInteger(), nullable=True))
    ### end Alembic commands ###


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('jobpost', 'pay_type')
    op.drop_column('jobpost', 'pay_equity_min')
    op.drop_column('jobpost', 'pay_equity_max')
    op.drop_column('jobpost', 'pay_currency')
    op.drop_column('jobpost', 'pay_cash_min')
    op.drop_column('jobpost', 'pay_cash_max')
    ### end Alembic commands ###

########NEW FILE########
__FILENAME__ = 3e27bf9706ee_reports_track_users_
"""Reports track users now

Revision ID: 3e27bf9706ee
Revises: 4c8265da3caa
Create Date: 2013-11-22 01:20:09.514748

"""

# revision identifiers, used by Alembic.
revision = '3e27bf9706ee'
down_revision = '4c8265da3caa'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('jobpostreport', sa.Column('user_id', sa.Integer(), nullable=True))
    op.create_foreign_key('jobpostreport_user_id_fkey', 'jobpostreport', 'user', ['user_id'], ['id'])


def downgrade():
    op.drop_constraint('jobpostreport_user_id_fkey', 'jobpostreport', 'foreignkey')
    op.drop_column('jobpostreport', 'user_id')

########NEW FILE########
__FILENAME__ = 41d839fcecb4_colnames
"""jobapps

Revision ID: 41d839fcecb4
Revises: 1bcc4e025b04
Create Date: 2013-09-12 19:53:07.423190

"""

# revision identifiers, used by Alembic.
revision = '41d839fcecb4'
down_revision = '1bcc4e025b04'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('jobcategory', sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.func.now()))
    op.add_column('jobcategory', sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.func.now()))
    op.alter_column('jobcategory', 'slug', new_column_name='name')

    op.add_column('jobtype', sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.func.now()))
    op.add_column('jobtype', sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.func.now()))
    op.alter_column('jobtype', 'slug', new_column_name='name')

    op.add_column('reportcode', sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.func.now()))
    op.add_column('reportcode', sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.func.now()))
    op.alter_column('reportcode', 'slug', new_column_name='name')

    op.alter_column('jobpost', 'created_datetime', new_column_name='created_at')
    op.add_column('jobpost', sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.func.now()))
    op.add_column('jobpost', sa.Column('user_id', sa.Integer(), sa.ForeignKey('user.id'), nullable=True))
    op.drop_column('jobpost', 'reviewer')


def downgrade():
    op.add_column('jobpost', sa.Column('reviewer', sa.INTEGER(), nullable=True))
    op.drop_column('jobpost', 'user_id')
    op.drop_column('jobpost', 'updated_at')
    op.alter_column('jobpost', 'created_at', new_column_name='created_datetime')

    op.alter_column('reportcode', 'name', new_column_name='slug')
    op.drop_column('reportcode', 'updated_at')
    op.drop_column('reportcode', 'created_at')

    op.alter_column('jobtype', 'name', new_column_name='slug')
    op.drop_column('jobtype', 'updated_at')
    op.drop_column('jobtype', 'created_at')

    op.alter_column('jobcategory', 'name', new_column_name='slug')
    op.drop_column('jobcategory', 'updated_at')
    op.drop_column('jobcategory', 'created_at')
    ### end Alembic commands ###

########NEW FILE########
__FILENAME__ = 441fd49059e3_preserve_user_s_name
"""Preserve user's name when they apply for a job

Revision ID: 441fd49059e3
Revises: 1feef782ef45
Create Date: 2014-05-16 03:38:52.778752

"""

# revision identifiers, used by Alembic.
revision = '441fd49059e3'
down_revision = '1feef782ef45'

from sqlalchemy.sql import table, column

from alembic import op
import sqlalchemy as sa


def upgrade():
    user = table('user',
        column('id', sa.Integer),
        column('fullname', sa.Unicode(250)))

    job_application = table('job_application',
        column('user_id', sa.Integer),
        column('fullname', sa.Unicode(250)))

    op.add_column('job_application', sa.Column('fullname', sa.Unicode(length=250), nullable=False, server_default=sa.text("''")))
    op.execute(job_application.update().where(job_application.c.user_id == user.c.id).values(fullname=user.c.fullname))
    op.alter_column('job_application', 'fullname', server_default=None)

def downgrade():
    op.drop_column('job_application', 'fullname')

########NEW FILE########
__FILENAME__ = 449914911f93_post_admins
"""Post admins

Revision ID: 449914911f93
Revises: 2420dd9c9949
Create Date: 2013-12-03 23:03:02.404457

"""

# revision identifiers, used by Alembic.
revision = '449914911f93'
down_revision = '2420dd9c9949'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.create_table('jobpost_admin',
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=False),
        sa.Column('user_id', sa.Integer(), nullable=False),
        sa.Column('jobpost_id', sa.Integer(), nullable=False),
        sa.ForeignKeyConstraint(['jobpost_id'], ['jobpost.id'], ),
        sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
        sa.PrimaryKeyConstraint('user_id', 'jobpost_id')
        )


def downgrade():
    op.drop_table('jobpost_admin')

########NEW FILE########
__FILENAME__ = 465e724941d3_userblocked
"""userblocked

Revision ID: 465e724941d3
Revises: 95eacca1a9d
Create Date: 2013-09-12 22:13:57.647552

"""

# revision identifiers, used by Alembic.
revision = '465e724941d3'
down_revision = '95eacca1a9d'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('user', sa.Column('blocked', sa.Boolean(), nullable=False, server_default=sa.sql.false()))
    op.alter_column('user', 'blocked', server_default=None)


def downgrade():
    op.drop_column('user', 'blocked')

########NEW FILE########
__FILENAME__ = 470c8feb73cc_jobapplication_repli
"""JobApplication.replied_by

Revision ID: 470c8feb73cc
Revises: 449914911f93
Create Date: 2013-12-14 22:32:49.982184

"""

# revision identifiers, used by Alembic.
revision = '470c8feb73cc'
down_revision = '449914911f93'

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.add_column('job_application', sa.Column('replied_by_id', sa.Integer(), nullable=True))
    ### end Alembic commands ###


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('job_application', 'replied_by_id')
    ### end Alembic commands ###

########NEW FILE########
__FILENAME__ = 472ca8e93765_boards
"""Boards

Revision ID: 472ca8e93765
Revises: 470c8feb73cc
Create Date: 2014-02-13 02:40:42.772517

"""

# revision identifiers, used by Alembic.
revision = '472ca8e93765'
down_revision = '470c8feb73cc'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.create_table('board',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('userid', sa.Unicode(length=22), nullable=False),
    sa.Column('description', sa.UnicodeText(), nullable=False),
    sa.Column('name', sa.Unicode(length=250), nullable=False),
    sa.Column('title', sa.Unicode(length=250), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name'),
    sa.UniqueConstraint('userid')
    )
    op.create_table('board_jobpost',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('jobpost_id', sa.Integer(), nullable=False),
    sa.Column('board_id', sa.Integer(), nullable=False),
    sa.Column('pinned', sa.Boolean(), nullable=False),
    sa.ForeignKeyConstraint(['board_id'], ['board.id'], ),
    sa.ForeignKeyConstraint(['jobpost_id'], ['jobpost.id'], ),
    sa.PrimaryKeyConstraint('id')
    )


def downgrade():
    op.drop_table('board_jobpost')
    op.drop_table('board')

########NEW FILE########
__FILENAME__ = 499df876f3f2_apply_message
"""apply_message

Revision ID: 499df876f3f2
Revises: 465e724941d3
Create Date: 2013-09-12 23:44:30.028135

"""

# revision identifiers, used by Alembic.
revision = '499df876f3f2'
down_revision = '465e724941d3'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.alter_column('job_application', 'message_html', new_column_name='message')
    op.drop_column('job_application', 'message_text')
    op.alter_column('job_application', 'email',
               existing_type=sa.VARCHAR(length=80),
               nullable=False)
    op.alter_column('job_application', 'phone',
               existing_type=sa.VARCHAR(length=80),
               nullable=False)


def downgrade():
    op.alter_column('job_application', 'phone',
               existing_type=sa.VARCHAR(length=80),
               nullable=True)
    op.alter_column('job_application', 'email',
               existing_type=sa.VARCHAR(length=80),
               nullable=True)
    op.alter_column('job_application', 'message', new_column_name='message_html')
    op.add_column('job_application', sa.Column('message_text', sa.TEXT(), nullable=True))

########NEW FILE########
__FILENAME__ = 4c8265da3caa_appwords
"""appwords

Revision ID: 4c8265da3caa
Revises: 4f639a4a5fc3
Create Date: 2013-09-15 02:34:56.728020

"""

# revision identifiers, used by Alembic.
revision = '4c8265da3caa'
down_revision = '4f639a4a5fc3'

from alembic import op
import sqlalchemy as sa
from hasjob.utils import get_word_bag


def upgrade():
    op.add_column('job_application', sa.Column('words', sa.UnicodeText(), nullable=True))
    

def downgrade():
    op.drop_column('job_application', 'words')

########NEW FILE########
__FILENAME__ = 4f639a4a5fc3_apphash
"""apphash

Revision ID: 4f639a4a5fc3
Revises: 499df876f3f2
Create Date: 2013-09-13 03:47:23.300046

"""

# revision identifiers, used by Alembic.
revision = '4f639a4a5fc3'
down_revision = '499df876f3f2'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('job_application', sa.Column('hashid', sa.String(length=40), nullable=False))
    op.create_unique_constraint('uq_job_application_hashid', 'job_application', ['hashid'])
    op.alter_column('job_application', 'message',
               existing_type=sa.TEXT(),
               nullable=False)


def downgrade():
    op.alter_column('job_application', 'message',
               existing_type=sa.TEXT(),
               nullable=True)
    op.drop_column('job_application', 'hashid')

########NEW FILE########
__FILENAME__ = 95eacca1a9d_jobapps
"""jobapps

Revision ID: 95eacca1a9d
Revises: d286e09aee1
Create Date: 2013-09-12 21:06:06.501249

"""

# revision identifiers, used by Alembic.
revision = '95eacca1a9d'
down_revision = 'd286e09aee1'

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.create_table('job_application',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('jobpost_id', sa.Integer(), nullable=True),
    sa.Column('email', sa.Unicode(length=80), nullable=True),
    sa.Column('phone', sa.Unicode(length=80), nullable=True),
    sa.Column('message_text', sa.UnicodeText(), nullable=True),
    sa.Column('message_html', sa.UnicodeText(), nullable=True),
    sa.Column('response', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['jobpost_id'], ['jobpost.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    ### end Alembic commands ###


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('job_application')
    ### end Alembic commands ###

########NEW FILE########
__FILENAME__ = d286e09aee1_created_updated_serv
"""created_updated_serverdefaults

Revision ID: d286e09aee1
Revises: 41d839fcecb4
Create Date: 2013-09-12 20:26:55.258656

"""

# revision identifiers, used by Alembic.
revision = 'd286e09aee1'
down_revision = '41d839fcecb4'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.alter_column('jobcategory', 'created_at', server_default=None)
    op.alter_column('jobcategory', 'updated_at', server_default=None)
    op.alter_column('jobtype', 'created_at', server_default=None)
    op.alter_column('jobtype', 'updated_at', server_default=None)
    op.alter_column('reportcode', 'created_at', server_default=None)
    op.alter_column('reportcode', 'updated_at', server_default=None)
    op.alter_column('jobpost', 'updated_at', server_default=None)


def downgrade():
    op.alter_column('jobpost', 'updated_at', server_default=sa.func.now())
    op.alter_column('reportcode', 'updated_at', server_default=sa.func.now())
    op.alter_column('reportcode', 'created_at', server_default=sa.func.now())
    op.alter_column('jobtype', 'updated_at', server_default=sa.func.now())
    op.alter_column('jobtype', 'created_at', server_default=sa.func.now())
    op.alter_column('jobcategory', 'updated_at', server_default=sa.func.now())
    op.alter_column('jobcategory', 'created_at', server_default=sa.func.now())

########NEW FILE########
__FILENAME__ = ec6faeb2eec_boards_de_linked_fro
"""Boards de-linked from organizations

Revision ID: ec6faeb2eec
Revises: 34e1d4b2f636
Create Date: 2014-03-28 19:59:52.118155

"""

# revision identifiers, used by Alembic.
revision = 'ec6faeb2eec'
down_revision = '34e1d4b2f636'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.drop_constraint('board_userid_key', 'board')
    op.create_index('ix_board_userid', 'board', ['userid'])

def downgrade():
    op.drop_index('ix_board_userid', 'board')
    op.create_unique_constraint('board_userid_key', 'board', ['userid'])

########NEW FILE########
__FILENAME__ = get-twitter
#!/usr/bin/env python

"""
Get Twitter access key and secret.
"""

import tweepy
from hasjob import app, init_for

init_for('dev')
auth = tweepy.OAuthHandler(app.config['TWITTER_CONSUMER_KEY'], app.config['TWITTER_CONSUMER_SECRET'])
auth_url = auth.get_authorization_url()
print 'Please authorize: ' + auth_url
verifier = raw_input('PIN: ').strip()
auth.get_access_token(verifier)
print "TWITTER_ACCESS_KEY = '%s'" % auth.access_token.key
print "TWITTER_ACCESS_SECRET = '%s'" % auth.access_token.secret

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-

import re
from decimal import Decimal, InvalidOperation
from difflib import SequenceMatcher

from flask import g, request, Markup
from baseframe.forms import Form, ValidEmailDomain, AllUrlsValid, TinyMce4Field, HiddenMultiField
from wtforms import (TextField, TextAreaField, RadioField, FileField, BooleanField,
    ValidationError, validators)
from wtforms.fields.html5 import EmailField
from coaster.utils import getbool

from .models import JobApplication, EMPLOYER_RESPONSE, PAY_TYPE
from .uploads import process_image, UploadNotAllowed

from . import app, lastuser
from .utils import simplify_text, EMAIL_RE, URL_RE, PHONE_DETECT_RE, get_word_bag

QUOTES_RE = re.compile(ur'[\'"`‘’“”′″‴]+')

CAPS_RE = re.compile('[A-Z]')
SMALL_RE = re.compile('[a-z]')


def content_css():
    return app.assets['css_editor'].urls()[0]


def optional_url(form, field):
    """
    Validate URL only if present.
    """
    if not field.data:
        return
    else:
        if ':' not in field.data:
            field.data = 'http://' + field.data
        validator = validators.URL(message="Invalid URL. URLs must begin with http:// or https://")
        return validator(form, field)


class ListingPayCurrencyField(RadioField):
    """
    A custom field to get around the annoying pre-validator.
    """
    def pre_validate(self, form):
        if form.job_pay_type.data in (PAY_TYPE.ONETIME, PAY_TYPE.RECURRING):
            if not self.data:
                raise ValueError("Pick one")
            else:
                return super(ListingPayCurrencyField, self).pre_validate(form)
        else:
            self.data = None


class ListingForm(Form):
    """Form for new job posts"""
    job_headline = TextField("Headline",
        description="A single-line summary. This goes to the front page and across the network",
        validators=[validators.Required("A headline is required"),
            validators.Length(min=1, max=100, message="%(max)d characters maximum")])
    job_type = RadioField("Type", coerce=int, validators=[validators.Required("The job type must be specified")])
    job_category = RadioField("Category", coerce=int, validators=[validators.Required("Select a category")])
    job_location = TextField("Location",
        description=u'“Bangalore”, “Chennai”, “Pune”, etc or “Anywhere” (without quotes)',
        validators=[validators.Required(u"If this job doesn’t have a fixed location, use “Anywhere”"),
            validators.Length(min=3, max=80, message="%(max)d characters maximum")])
    job_relocation_assist = BooleanField("Relocation assistance available")
    job_description = TinyMce4Field("Description",
        content_css=content_css,
        description=u"Don’t just describe the job, tell a compelling story for why someone should work for you",
        validators=[validators.Required("A description of the job is required"),
            AllUrlsValid()],
        tinymce_options={'convert_urls': True})
    job_perks = BooleanField("Job perks are available")
    job_perks_description = TinyMce4Field("Describe job perks",
        content_css=content_css,
        description=u"Stock options, free lunch, free conference passes, etc",
        validators=[AllUrlsValid()])
    job_pay_type = RadioField("What does this job pay?", coerce=int,
        choices=PAY_TYPE.items())
    job_pay_currency = ListingPayCurrencyField("Currency", choices=[("INR", "INR"), ("USD", "USD"), ("EUR", "EUR")])
    job_pay_cash_min = TextField("Minimum")
    job_pay_cash_max = TextField("Maximum")
    job_pay_equity = BooleanField("Equity compensation is available")
    job_pay_equity_min = TextField("Minimum")
    job_pay_equity_max = TextField("Maximum")
    job_how_to_apply = TextAreaField("What should a candidate submit when applying for this job?",
         description=u"Example: “Include your LinkedIn and GitHub profiles.” "
                     u"We now require candidates to apply through the job board only. "
                     u"Do not include any contact information here. Candidates CANNOT "
                     u"attach resumes or other documents, so do not ask for that",
         validators=[validators.Required(u"HasGeek does not offer screening services. "
                                         u"Please specify what candidates should submit")])
    company_name = TextField("Name",
        description=u"The name of the organization where the position is. "
                    u"No intermediaries or unnamed stealth startups. Use your own real name if the company isn’t named "
                    u"yet. We do not accept listings from third parties such as recruitment consultants. Such listings "
                    u"may be removed without notice",
        validators=[validators.Required(u"This is required. Posting any name other than that of the actual organization is a violation of the ToS"),
            validators.Length(min=4, max=80, message="The name must be within %(min)d to %(max)d characters")])
    company_logo = FileField("Logo",
        description=u"Optional — Your company logo will appear at the top of your listing.",
        )  # validators=[file_allowed(uploaded_logos, "That image type is not supported")])
    company_logo_remove = BooleanField("Remove existing logo")
    company_url = TextField("URL",
        description=u"Example: http://www.google.com",
        validators=[optional_url, AllUrlsValid()])
    hr_contact = RadioField(u"Is it okay for recruiters and other "
        u"intermediaries to contact you about this listing?", coerce=getbool,
        description=u"We’ll display a notice to this effect on the listing",
        default=0,
        choices=[(0, u"No, it is NOT OK"), (1, u"Yes, recruiters may contact me")])
    # Deprecated 2013-11-20
    # poster_name = TextField("Name",
    #     description=u"This is your name, for our records. Will not be revealed to applicants",
    #     validators=[validators.Required("We need your name")])
    poster_email = EmailField("Email",
        description=Markup(u"This is where we’ll send your confirmation email and all job applications. "
                    u"We recommend using a shared email address such as jobs@your-company.com. "
                    u"<strong>Listings are classified by your email domain,</strong> "
                    u"so use a work email address. "
                    u"Your email address will not be revealed to applicants until you respond"),
        validators=[validators.Required("We need to confirm your email address before the job can be listed"),
            validators.Length(min=5, max=80, message="%(max)d characters maximum"),
            validators.Email("That does not appear to be a valid email address"),
            ValidEmailDomain()])
    collaborators = HiddenMultiField(u"Collaborators",
        description=u"If someone is helping you evaluate candidates, type their names here. "
                    u"They must have a HasGeek account. They will not receive email notifications "
                    u"— use a shared email address above for that — but they will be able to respond "
                    u"to candidates who apply")


    def validate_company_name(form, field):
        if len(field.data) > 5:
            caps = len(CAPS_RE.findall(field.data))
            small = len(SMALL_RE.findall(field.data))
            if small == 0 or caps / float(small) > 0.8:
                raise ValidationError("Surely your company isn't named in uppercase?")

    def validate_company_logo(form, field):
        if not request.files['company_logo']:
            return
        try:
            g.company_logo = process_image(request.files['company_logo'])
        except IOError, e:
            raise ValidationError(e.message)
        except KeyError, e:
            raise ValidationError("Unknown file format")
        except UploadNotAllowed:
            raise ValidationError("Unsupported file format. We accept JPEG, PNG and GIF")

    def validate_job_headline(form, field):
        if EMAIL_RE.search(field.data) is not None:
            raise ValidationError(u"Do not include contact information in the listing")
        if simplify_text(field.data) in (
                'awesome coder wanted at awesome company',
                'pragmatic programmer wanted at outstanding organisation',
                'pragmatic programmer wanted at outstanding organization'):
            raise ValidationError(u"Come on, write your own headline. You aren’t just another run-of-the-mill company, right?")
        caps = len(CAPS_RE.findall(field.data))
        small = len(SMALL_RE.findall(field.data))
        if small == 0 or caps / float(small) > 0.5:
            raise ValidationError("No shouting, please. Reduce the number of capital letters in your headline")
        for word_list, message in app.config.get('BANNED_WORDS', []):
            for word in word_list:
                if word in field.data.lower():
                    raise ValidationError(message)

    def validate_job_location(form, field):
        if QUOTES_RE.search(field.data) is not None:
            raise ValidationError(u"Don’t use quotes in the location name")

        caps = len(CAPS_RE.findall(field.data))
        small = len(SMALL_RE.findall(field.data))
        if small == 0 or caps / float(small) > 0.5:
            raise ValidationError("Surely this location isn't named in uppercase?")

    def validate_job_description(form, field):
        if EMAIL_RE.search(field.data) is not None:
            raise ValidationError(u"Do not include contact information in the listing")

    def validate_job_perks_description(form, field):
        if EMAIL_RE.search(field.data) is not None:
            raise ValidationError(u"Do not include contact information in the listing")

    def validate_job_how_to_apply(form, field):
        if EMAIL_RE.search(field.data) is not None or URL_RE.search(field.data) is not None:
            raise ValidationError(u"Do not include contact information in the listing")

    def validate_job_pay_cash_min(form, field):
        if form.job_pay_type.data != PAY_TYPE.NOCASH:
            if not field.data:
                raise ValidationError("Please specify what this job pays")
            data = field.data.strip()
            if not data[0].isdigit():
                data = data[1:]  # Remove currency symbol
            data = data.replace(',', '').strip()  # Remove thousands separator
            if data.isdigit():
                field.data = int(data)
            else:
                raise ValidationError("Unrecognised value %s" % field.data)
        else:
            field.data = None

    def validate_job_pay_cash_max(form, field):
        if form.job_pay_type.data != PAY_TYPE.NOCASH:
            data = field.data.strip()
            if data:
                if not data[0].isdigit():
                    data = data[1:]  # Remove currency symbol
                data = data.replace(',', '').strip()  # Remove thousands separator
            if data and data.isdigit():
                field.data = int(data)
            else:
                raise ValidationError("Unrecognised value %s" % field.data)
        else:
            field.data = None

    def validate_job_pay_equity_min(form, field):
        if form.job_pay_equity.data:
            data = field.data.strip()
            if data:
                if not data[-1].isdigit():
                    data = field.data[:-1]  # Remove % symbol
                data = data.replace(',', '').strip()  # Remove thousands separator
                try:
                    field.data = Decimal(data)
                except InvalidOperation:
                    raise ValidationError("Please enter a percentage between 0% and 100%")
            else:
                raise ValidationError("Unrecognised value %s" % field.data)
        else:
            # Discard submission if equity checkbox is unchecked
            field.data = None

    def validate_job_pay_equity_max(form, field):
        if form.job_pay_equity.data:
            data = field.data.strip()
            if data:
                if not data[-1].isdigit():
                    data = field.data[:-1]  # Remove % symbol
                data = data.replace(',', '').strip()  # Remove thousands separator
                try:
                    field.data = Decimal(data)
                except InvalidOperation:
                    raise ValidationError("Please enter a percentage between 0% and 100%")
            else:
                raise ValidationError("Unrecognised value %s" % field.data)
        else:
            # Discard submission if equity checkbox is unchecked
            field.data = None

    def validate(self, extra_validators=None):
        success = super(ListingForm, self).validate(extra_validators)
        if success:
            # Check for cash pay range
            if self.job_pay_type.data in (PAY_TYPE.ONETIME, PAY_TYPE.RECURRING):
                if self.job_pay_cash_min.data == 0:
                    if self.job_pay_cash_max.data == 10000000:
                        self.job_pay_cash_max.errors.append(u"Please select a range")
                        success = False
                    else:
                        self.job_pay_cash_min.errors.append(u"Please specify a minimum non-zero pay")
                        success = False
                else:
                    if self.job_pay_cash_max.data == 10000000:
                        self.job_pay_cash_max.errors.append(
                            u"You don’t pay that much. Please provide a realistic figure")
                        success = False
                    elif (self.job_pay_type.data == PAY_TYPE.RECURRING
                            and self.job_pay_currency.data == 'INR'
                            and self.job_pay_cash_min.data < 60000):
                        self.job_pay_cash_min.errors.append(
                            u"That’s rather low. Did you specify monthly pay instead of annual pay? Multiply by 12")
                        success = False
                    elif self.job_pay_cash_max.data > self.job_pay_cash_min.data * 4:
                        self.job_pay_cash_max.errors.append(u"Please select a narrower range")
                        success = False
            if self.job_pay_equity.data:
                if self.job_pay_equity_min.data == 0:
                    if self.job_pay_equity_max.data == 100:
                        self.job_pay_equity_max.errors.append(u"Please select a range")
                        success = False
                else:
                    if self.job_pay_equity_min.data <= Decimal('1.0'):
                        multiplier = 10
                    elif self.job_pay_equity_min.data <= Decimal('2.0'):
                        multiplier = 8
                    elif self.job_pay_equity_min.data <= Decimal('3.0'):
                        multiplier = 6
                    else:
                        multiplier = 4

                    if self.job_pay_equity_max.data > self.job_pay_equity_min.data * multiplier:
                        self.job_pay_equity_max.errors.append(u"Please select a narrower range")
                        success = False
        return success


class ApplicationForm(Form):
    apply_email = RadioField("Email", validators=[validators.Required("Pick an email address")],
        description="Add new email addresses from your profile")
    apply_phone = TextField("Phone",
        validators=[validators.Required("Specify a phone number"),
            validators.Length(min=1, max=15, message="%(max)d characters maximum")],
        description="A phone number the employer can reach you at")
    apply_message = TinyMce4Field("Job application",
        content_css=content_css,
        validators=[validators.Required("You need to say something about yourself"),
            AllUrlsValid()],
        description=u"Please provide all details the employer has requested. To add a resume, "
            u"post it on LinkedIn or host the file on Dropbox and insert the link here")

    def __init__(self, *args, **kwargs):
        super(ApplicationForm, self).__init__(*args, **kwargs)
        self.apply_email.choices = []
        if g.user:
            self.apply_email.description = Markup(
                u'Add new email addresses from <a href="{}" target="_blank">your profile</a>'.format(
                    g.user.profile_url))
            self.apply_email.choices = [(e, e) for e in lastuser.user_emails(g.user)]
            if not self.apply_email.choices:
                self.apply_email.choices = [
                    ('', Markup('<em>You have not verified your email address</em>'))
                ]

    def validate_apply_message(form, field):
        words = get_word_bag(field.data)
        form.words = words
        similar = False
        for oldapp in JobApplication.query.filter_by(response=EMPLOYER_RESPONSE.SPAM).all():
            if oldapp.words:
                s = SequenceMatcher(None, words, oldapp.words)
                if s.ratio() > 0.8:
                    similar = True
                    break

        if similar:
            raise ValidationError("Your application is very similar to one previously identified as spam")

        # Check for email and phone numbers in the message

        # Prepare text by replacing non-breaking spaces with spaces (for phone numbers) and removing URLs.
        # URLs may contain numbers that are not phone numbers.
        phone_search_text = URL_RE.sub('', field.data.replace('&nbsp;', ' ').replace('&#160;', ' ').replace(u'\xa0', ' '))
        if EMAIL_RE.search(field.data) is not None or PHONE_DETECT_RE.search(phone_search_text) is not None:
            raise ValidationError("Do not include your email address or phone number in the application")


class KioskApplicationForm(Form):
    apply_fullname = TextField("Fullname", validators=[validators.Required("Specify your name")],
        description="Your full name")
    apply_email = TextField("Email", validators=[validators.Required("Specify an email address")],
        description="Your email address")
    apply_phone = TextField("Phone",
        validators=[validators.Required("Specify a phone number"),
            validators.Length(min=1, max=15, message="%(max)d characters maximum")],
        description="A phone number the employer can reach you at")
    apply_message = TinyMce4Field("Job application",
        content_css=content_css,
        validators=[validators.Required("You need to say something about yourself"),
            AllUrlsValid()],
        description=u"Please provide all details the employer has requested. To add a resume, "
            u"post it on LinkedIn or host the file on Dropbox and insert the link here")

    def validate_email(form, field):
        oldapp = JobApplication.query.filter_by(jobpost=self.post, user=None, email=field.data).count()
        if oldapp:
            raise ValidationError("You have already applied for this position")


class ApplicationResponseForm(Form):
    response_message = TinyMce4Field("",
        content_css=content_css)


class ConfirmForm(Form):
    terms_accepted = BooleanField("I accept the terms of service",
        validators=[validators.Required("You must accept the terms of service to publish this listing")])


class WithdrawForm(Form):
    really_withdraw = BooleanField("Yes, I really want to withdraw the job listing",
        validators=[validators.Required(u"If you don’t want to withdraw the listing, just close this page")])


class ReportForm(Form):
    report_code = RadioField("Code", coerce=int, validators=[validators.Required(u"Pick one")])


class RejectForm(Form):
    reason = TextField('Reason', validators=[validators.Required(u"Give a reason")])


class ModerateForm(Form):
    reason = TextAreaField('Reason',
        validators=[validators.Required(u"Give a reason"), validators.Length(max=250)])


class StickyForm(Form):
    sticky = BooleanField("Make this sticky?")


class BoardForm(Form):
    """
    Edit board settings.
    """
    title = TextField(u"Title", validators=[validators.Required("The board needs a name")])
    name = TextField(u"URL Name", description=u"Optional — Will be autogenerated if blank")
    description = TinyMce4Field(u"Description",
        content_css=content_css,
        validators=[validators.Required("A description of the job board is required"),
            AllUrlsValid()])
    userid = RadioField(u"Owner", validators=[validators.Required("Select an owner")],
        description=u"Select the user or organization who owns this board. "
            "Owners can add jobs to the board and edit settings")

########NEW FILE########
__FILENAME__ = board
# -*- coding: utf-8 -*-

from pytz import timezone
from werkzeug import cached_property
from flask import url_for
from sqlalchemy.orm import defer
from . import db, BaseMixin, BaseNameMixin
from .user import User
from .jobpost import JobPost

__all__ = ['Board', 'BoardJobPost']


class Board(BaseNameMixin, db.Model):
    """
    Boards show a filtered set of jobs at board-specific URLs.
    """
    __tablename__ = 'board'
    #: Lastuser organization userid that owns this
    userid = db.Column(db.Unicode(22), nullable=False, index=True)
    #: Welcome text
    description = db.Column(db.UnicodeText, nullable=False, default=u'')

    def __repr__(self):
        return '<Board %s "%s">' % (self.name, self.title)

    @cached_property
    def tz(self):
        return timezone(self.timezone)

    def owner_is(self, user):
        if user is None:
            return False
        if user.userid == self.userid or self.userid in user.organizations_owned_ids():
            return True
        return False

    def link_to_jobpost(self, jobpost):
        return BoardJobPost.query.filter_by(board=self, jobpost=jobpost).one_or_none()

    def add(self, jobpost):
        link = self.link_to_jobpost(jobpost)
        if not link:
            link = BoardJobPost(board=self, jobpost=jobpost)
            db.session.add(link)
        return link

    def permissions(self, user, inherited=None):
        perms = super(Board, self).permissions(user, inherited)
        perms.add('view')
        if user is not None and user.userid == self.userid or self.userid in user.organizations_owned_ids():
            perms.add('edit')
            perms.add('delete')
            perms.add('add')
        return perms

    def url_for(self, action='view', _external=False):
        if action == 'view':
            return url_for('board_view', board=self.name, _external=_external)
        elif action == 'edit':
            return url_for('board_edit', board=self.name, _external=_external)
        elif action == 'delete':
            return url_for('board_delete', board=self.name, _external=_external)


def _user_boards(self):
    return Board.query.filter(
        Board.userid.in_(self.user_organizations_owned_ids())).options(
        defer(Board.description)).all()

User.boards = _user_boards


class BoardJobPost(BaseMixin, db.Model):
    """
    Link job posts to boards.
    """
    __tablename__ = 'board_jobpost'
    #: Linked JobPost
    jobpost_id = db.Column(None, db.ForeignKey('jobpost.id'), nullable=False)
    jobpost = db.relationship(JobPost, backref=db.backref('postboards',
        lazy='dynamic', cascade='all, delete-orphan'))
    #: Linked Board
    board_id = db.Column(None, db.ForeignKey('board.id'), nullable=False)
    board = db.relationship(Board, backref=db.backref('boardposts',
        lazy='dynamic', cascade='all, delete-orphan'))
    #: Is this listing pinned on this board?
    pinned = db.Column(db.Boolean, default=False, nullable=False)

    # TODO: Make proxies to link Board and JobPost directly to each other


def _jobpost_link_to_board(self, board):
    return BoardJobPost.query.filter_by(jobpost=self, board=board).one_or_none()

JobPost.link_to_board = _jobpost_link_to_board


def _jobpost_add_to(self, board):
    link = self.link_to_board(board)
    if not link:
        link = BoardJobPost(board=board, jobpost=self)
        db.session.add(link)
    return link

JobPost.add_to = _jobpost_add_to

########NEW FILE########
__FILENAME__ = jobcategory
from hasjob.models import BaseNameMixin, db


class JobCategory(BaseNameMixin, db.Model):
    __tablename__ = 'jobcategory'
    idref = 'category'

    seq = db.Column(db.Integer, nullable=False, default=0)
    public = db.Column(db.Boolean, nullable=False, default=True)

    def __call__(self):
        return self.title

    def search_mapping(self):
        """
        Returns a dictionary suitable for search indexing.
        """
        return {'title': self.title,
                'content': self.title,
                'public': self.public,
                'idref': u'%s/%s' % (self.idref, self.id),
                }

########NEW FILE########
__FILENAME__ = jobpost
# -*- coding: utf-8 -*-

from datetime import datetime
from werkzeug import cached_property
from flask import url_for
from coaster.sqlalchemy import timestamp_columns
from baseframe import cache
from . import agelimit, db, POSTSTATUS, EMPLOYER_RESPONSE, PAY_TYPE, BaseMixin, TimestampMixin, webmail_domains
from .jobtype import JobType
from .jobcategory import JobCategory
from .user import User
from ..utils import random_long_key, random_hash_key


class JobPost(BaseMixin, db.Model):
    __tablename__ = 'jobpost'
    idref = 'post'

    # Metadata
    user_id = db.Column(None, db.ForeignKey('user.id'), nullable=True)
    user = db.relationship(User, primaryjoin=user_id == User.id, backref='jobposts')
    hashid = db.Column(db.String(5), nullable=False, unique=True)
    datetime = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)  # Published
    closed_datetime = db.Column(db.DateTime, nullable=True)  # If withdrawn or rejected
    sticky = db.Column(db.Boolean, nullable=False, default=False)
    pinned = db.synonym('sticky')

    # Job description
    headline = db.Column(db.Unicode(100), nullable=False)
    type_id = db.Column(None, db.ForeignKey('jobtype.id'), nullable=False)
    type = db.relation(JobType, primaryjoin=type_id == JobType.id)
    category_id = db.Column(None, db.ForeignKey('jobcategory.id'), nullable=False)
    category = db.relation(JobCategory, primaryjoin=category_id == JobCategory.id)
    location = db.Column(db.Unicode(80), nullable=False)
    relocation_assist = db.Column(db.Boolean, default=False, nullable=False)
    description = db.Column(db.UnicodeText, nullable=False)
    perks = db.Column(db.UnicodeText, nullable=False)
    how_to_apply = db.Column(db.UnicodeText, nullable=False)
    hr_contact = db.Column(db.Boolean, nullable=True)

    # Compensation details
    pay_type = db.Column(db.SmallInteger, nullable=True)  # Value in models.PAY_TYPE
    pay_currency = db.Column(db.CHAR(3), nullable=True)
    pay_cash_min = db.Column(db.Integer, nullable=True)
    pay_cash_max = db.Column(db.Integer, nullable=True)
    pay_equity_min = db.Column(db.Numeric, nullable=True)
    pay_equity_max = db.Column(db.Numeric, nullable=True)

    # Company details
    company_name = db.Column(db.Unicode(80), nullable=False)
    company_logo = db.Column(db.Unicode(255), nullable=True)
    company_url = db.Column(db.Unicode(255), nullable=False, default=u'')
    fullname = db.Column(db.Unicode(80), nullable=True)
    email = db.Column(db.Unicode(80), nullable=False)
    email_domain = db.Column(db.Unicode(80), nullable=False, index=True)
    md5sum = db.Column(db.String(32), nullable=False, index=True)

    # Payment, audit and workflow fields
    words = db.Column(db.UnicodeText, nullable=True)  # All words in description, perks and how_to_apply
    promocode = db.Column(db.String(40), nullable=True)
    status = db.Column(db.Integer, nullable=False, default=POSTSTATUS.DRAFT)
    ipaddr = db.Column(db.String(45), nullable=False)
    useragent = db.Column(db.Unicode(250), nullable=True)
    edit_key = db.Column(db.String(40), nullable=False, default=random_long_key)
    email_verify_key = db.Column(db.String(40), nullable=False, default=random_long_key)
    email_sent = db.Column(db.Boolean, nullable=False, default=False)
    email_verified = db.Column(db.Boolean, nullable=False, default=False)
    payment_value = db.Column(db.Integer, nullable=False, default=0)
    payment_received = db.Column(db.Boolean, nullable=False, default=False)
    reviewer_id = db.Column(None, db.ForeignKey('user.id'), nullable=True)
    reviewer = db.relationship(User, primaryjoin=reviewer_id == User.id, backref="reviewed_posts")
    review_datetime = db.Column(db.DateTime, nullable=True)
    review_comments = db.Column(db.Unicode(250), nullable=True)

    # Metadata for classification
    language = db.Column(db.CHAR(2), nullable=True)

    admins = db.relationship(User, secondary=lambda: jobpost_admin_table)

    @classmethod
    def get(cls, hashid):
        return cls.query.filter_by(hashid=hashid).one_or_none()

    def admin_is(self, user):
        if user is None:
            return False
        return user == self.user or user in self.admins

    def is_draft(self):
        return self.status == POSTSTATUS.DRAFT

    def is_pending(self):
        return self.status == POSTSTATUS.PENDING

    def is_unpublished(self):
        return self.status in (POSTSTATUS.DRAFT, POSTSTATUS.PENDING)

    def is_listed(self):
        now = datetime.utcnow()
        return (self.status in [POSTSTATUS.CONFIRMED, POSTSTATUS.REVIEWED]) and (
            self.datetime > now - agelimit)

    def is_flagged(self):
        return self.status == POSTSTATUS.FLAGGED

    def is_moderated(self):
        return self.status == POSTSTATUS.MODERATED

    def is_old(self):
        return self.datetime <= datetime.utcnow() - agelimit

    def pay_type_label(self):
        return PAY_TYPE.get(self.pay_type)

    def url_for(self, action='view', _external=False):
        if action == 'view':
            return url_for('jobdetail', hashid=self.hashid, _external=_external)
        elif action == 'edit':
            return url_for('editjob', hashid=self.hashid, _external=_external)
        elif action == 'confirm':
            return url_for('confirm', hashid=self.hashid, _external=_external)
        elif action == 'browse':
            if self.email_domain in webmail_domains:
                return url_for('browse_by_email', md5sum=self.md5sum, _external=_external)
            else:
                return url_for('browse_by_domain', domain=self.email_domain, _external=_external)

    @property
    def pays_cash(self):
        if self.pay_type is None:
            return True
        return self.pay_type != PAY_TYPE.NOCASH and self.pay_cash_min is not None and self.pay_cash_max is not None

    @property
    def pays_equity(self):
        return self.pay_equity_min is not None and self.pay_equity_max is not None

    def pay_label(self):
        format = lambda number, suffix: str(int(number)) + suffix if int(number) == number else str(round(number, 2)) + suffix
        def abbreviate(number, indian=False):
            if indian:
                if number < 100000:  # < 1 lakh
                    return format(number / 1000.0, 'k')
                elif number < 10000000:  # < 1 crore
                    return format(number / 100000.0, 'L')
                else:  # >= 1 crore
                    return format(number / 10000000.0, 'C')
            else:
                if number < 1000000:  # < 1 million
                    return format(number / 1000.0, 'k')
                elif number < 100000000:  # < 1 billion
                    return format(number / 1000000.0, 'm')
                else:  # >= 1 billion
                    return format(number / 100000000.0, 'b')

        if self.pay_type is None:
            return u"NA"
        elif self.pay_type == PAY_TYPE.NOCASH:
            cash = None
            suffix = ""
        else:
            if self.pay_type == PAY_TYPE.RECURRING:
                suffix = "pa"
            else:
                suffix = ""

            indian = False
            if self.pay_currency == "INR":
                indian = True
                symbol = u"₹"
            elif self.pay_currency == "USD":
                symbol = u"$"
            elif self.pay_currency == "EUR":
                symbol = u"€"
            elif self.pay_currency == "GBP":
                symbol = u"£"
            else:
                symbol = u"¤"

            if self.pay_cash_min == self.pay_cash_max:
                cash = symbol + abbreviate(self.pay_cash_min, indian)
            else:
                cash = symbol + abbreviate(self.pay_cash_min, indian) + "-" + abbreviate(self.pay_cash_max, indian)

            if suffix:
                cash = cash + " " + suffix

        if self.pay_equity_min and self.pay_equity_max:
            if self.pay_equity_min == self.pay_equity_max:
                equity = str(self.pay_equity_min) + "%"
            else:
                equity = str(self.pay_equity_min) + "-" + str(self.pay_equity_max) + "%"
        else:
            equity = None

        if cash:
            if equity:
                return ", ".join([cash, equity])
            else:
                return cash
        else:
            if equity:
                return equity
            else:
                return "No pay"

    def search_mapping(self):
        """
        Returns a dictionary suitable for search indexing.
        """
        content = '\n'.join((self.headline,
                            self.location,
                            self.company_name,
                            self.company_url,
                            self.description,
                            self.perks))

        return {'title': self.headline,
                'content': content,
                'public': self.is_listed(),
                'idref': u'%s/%s' % (self.idref, self.id),
                }

    @cached_property  # For multiple accesses in a single request
    def viewcounts(self):
        return viewcounts_by_id(self.id)

    @cached_property  # For multiple accesses in a single request
    def viewstats(self):
        now = datetime.utcnow()
        delta = now - self.datetime
        if delta.days < 2:  # Less than two days
            if delta.seconds < 21600:  # Less than 6 hours
                return 'q', viewstats_by_id_qhour(self.id)
            else:
                return 'h', viewstats_by_id_hour(self.id)
        else:
            return 'd', viewstats_by_id_day(self.id)

    def reports(self):
        if not self.flags:
            return []
        counts = {}
        for flag in self.flags:
            counts[flag.reportcode] = counts.setdefault(flag.reportcode, 0) + 1
        return [{'count': i[2], 'title': i[1]} for i in sorted([(k.seq, k.title, v) for k, v in counts.items()])]


@cache.memoize(timeout=86400)
def viewcounts_by_id(jobpost_id):
    return {
        'viewed': UserJobView.query.filter_by(jobpost_id=jobpost_id).count(),
        'opened': UserJobView.query.filter_by(jobpost_id=jobpost_id, applied=True).count(),
        'applied': JobApplication.query.filter_by(jobpost_id=jobpost_id).count()
        }


def viewstats_helper(jobpost_id, interval, limit, daybatch=False):
    post = JobPost.query.get(jobpost_id)
    if not post.datetime:
        return {}
    viewed = UserJobView.query.filter_by(jobpost_id=jobpost_id).all()
    opened = [v for v in viewed if v.applied == True]
    applied = db.session.query(JobApplication.created_at).filter_by(jobpost_id=jobpost_id).all()

    # Now batch them by size
    now = datetime.utcnow()
    delta = now - post.datetime
    if daybatch:
        batches, remainder = divmod(delta.days, interval)
        if delta.seconds:
            remainder = True
    else:
        batches, remainder = divmod(int(delta.total_seconds()), interval)

    if remainder or batches == 0:
        batches += 1

    cviewed = batches * [0]
    copened = batches * [0]
    capplied = batches * [0]

    for clist, source, attr in [
            (cviewed, viewed, 'created_at'),
            (copened, opened, 'updated_at'),
            (capplied, applied, 'created_at')]:
        for item in source:
            sourcedate = getattr(item, attr)
            if sourcedate < post.datetime:
                # This happens when the user creates a listing when logged in. Their 'viewed' date will be
                # for the draft, whereas the confirmed listing's datetime will be later. There should
                # be just one instance of this.
                sourcedate = post.datetime
            itemdelta = sourcedate - post.datetime
            try:
                if daybatch:
                    clist[int(itemdelta.days // interval)] += 1
                else:
                    clist[int(int(itemdelta.total_seconds()) // interval)] += 1
            except IndexError:
                # Server time got messed up. Ouch! Ignore for now.
                pass

    if limit and batches > limit:
        cviewed = cviewed[:limit]
        copened = copened[:limit]
        capplied = capplied[:limit]

    return {
        'max': max([
            max(cviewed) if cviewed else 0,
            max(copened) if copened else 0,
            max(capplied) if capplied else 0,
            ]),
        'length': max([len(cviewed), len(copened), len(capplied)]),
        'viewed': cviewed,
        'opened': copened,
        'applied': capplied,
        }


@cache.memoize(timeout=900)
def viewstats_by_id_qhour(jobpost_id):
    return viewstats_helper(jobpost_id, 900, 24)


@cache.memoize(timeout=3600)
def viewstats_by_id_hour(jobpost_id):
    return viewstats_helper(jobpost_id, 3600, 48)


@cache.memoize(timeout=86400)
def viewstats_by_id_day(jobpost_id):
    return viewstats_helper(jobpost_id, 1, 30, daybatch=True)


jobpost_admin_table = db.Table('jobpost_admin', db.Model.metadata,
    *(timestamp_columns + (
    db.Column('user_id', None, db.ForeignKey('user.id'), primary_key=True),
    db.Column('jobpost_id', None, db.ForeignKey('jobpost.id'), primary_key=True)
    )))


class UserJobView(TimestampMixin, db.Model):
    __tablename__ = 'userjobview'
    #: User who saw a listing
    user_id = db.Column(None, db.ForeignKey('user.id'), primary_key=True)
    user = db.relationship(User)
    #: Job listing they saw
    jobpost_id = db.Column(None, db.ForeignKey('jobpost.id'), primary_key=True)
    jobpost = db.relationship(JobPost)
    #: Has the user viewed apply instructions?
    applied = db.Column(db.Boolean, default=False, nullable=False)


class JobApplication(BaseMixin, db.Model):
    __tablename__ = 'job_application'
    #: Hash id (to hide database ids)
    hashid = db.Column(db.String(40), nullable=False, unique=True)
    #: User who applied for this listing
    user_id = db.Column(None, db.ForeignKey('user.id'), nullable=True)  # TODO: add unique=True
    user = db.relationship(User, foreign_keys=user_id)
    #: Full name of the user (as it was at the time of the application)
    fullname = db.Column(db.Unicode(250), nullable=False)
    #: Job listing they applied to
    jobpost_id = db.Column(None, db.ForeignKey('jobpost.id'))
    #: User's email address
    email = db.Column(db.Unicode(80), nullable=False)
    #: User's phone number
    phone = db.Column(db.Unicode(80), nullable=False)
    #: User's message
    message = db.Column(db.UnicodeText, nullable=False)
    #: Employer's response code
    response = db.Column(db.Integer, nullable=False, default=EMPLOYER_RESPONSE.NEW)
    #: Employer's response message
    response_message = db.Column(db.UnicodeText, nullable=True)
    #: Bag of words, for spam analysis
    words = db.Column(db.UnicodeText, nullable=True)
    #: Admin who replied for this listing
    replied_by_id = db.Column(None, db.ForeignKey('user.id'), nullable=True)
    replied_by = db.relationship(User, foreign_keys=replied_by_id)

    # candidate_feedback = db.Column(db.Integer, nullable=True)

    def __init__(self, **kwargs):
        super(JobApplication, self).__init__(**kwargs)
        if self.hashid is None:
            self.hashid = unique_long_hash()

    @property
    def status(self):
        return EMPLOYER_RESPONSE[self.response]

    def is_new(self):
        return self.response == EMPLOYER_RESPONSE.NEW

    def is_pending(self):
        return self.response == EMPLOYER_RESPONSE.PENDING

    def is_ignored(self):
        return self.response == EMPLOYER_RESPONSE.IGNORED

    def is_replied(self):
        return self.response == EMPLOYER_RESPONSE.REPLIED

    def is_flagged(self):
        return self.response == EMPLOYER_RESPONSE.FLAGGED

    def is_spam(self):
        return self.response == EMPLOYER_RESPONSE.SPAM

    def is_rejected(self):
        return self.response == EMPLOYER_RESPONSE.REJECTED

    def can_reply(self):
        return self.response in (EMPLOYER_RESPONSE.NEW, EMPLOYER_RESPONSE.PENDING, EMPLOYER_RESPONSE.IGNORED)

    def can_reject(self):
        return self.response in (EMPLOYER_RESPONSE.NEW, EMPLOYER_RESPONSE.PENDING, EMPLOYER_RESPONSE.IGNORED)

    def can_ignore(self):
        return self.response in (EMPLOYER_RESPONSE.NEW, EMPLOYER_RESPONSE.PENDING)

    def can_report(self):
        return self.response in (EMPLOYER_RESPONSE.NEW, EMPLOYER_RESPONSE.PENDING,
            EMPLOYER_RESPONSE.IGNORED, EMPLOYER_RESPONSE.REJECTED)


JobApplication.jobpost = db.relationship(JobPost,
    backref=db.backref('applications', order_by=(
        db.case(value=JobApplication.response, whens={
            EMPLOYER_RESPONSE.NEW: 0,
            EMPLOYER_RESPONSE.PENDING: 1,
            EMPLOYER_RESPONSE.IGNORED: 2,
            EMPLOYER_RESPONSE.REPLIED: 3,
            EMPLOYER_RESPONSE.REJECTED: 4,
            EMPLOYER_RESPONSE.FLAGGED: 5,
            EMPLOYER_RESPONSE.SPAM: 6
            }),
        db.desc(JobApplication.created_at)), cascade='all, delete-orphan'))


def unique_hash(model=JobPost):
    """
    Returns a unique hash for a given model
    """
    while 1:
        hashid = random_hash_key()
        if model.query.filter_by(hashid=hashid).count() == 0:
            break
    return hashid


def unique_long_hash(model=JobApplication):
    """
    Returns a long unique hash for a given model
    """
    while 1:
        hashid = random_long_key()
        if model.query.filter_by(hashid=hashid).count() == 0:
            break
    return hashid

########NEW FILE########
__FILENAME__ = jobpostreport
from datetime import datetime
from hasjob.models import db
from hasjob.models.user import User
from hasjob.models.jobpost import JobPost
from hasjob.models.reportcode import ReportCode


class JobPostReport(db.Model):
    __tablename__ = 'jobpostreport'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(None, db.ForeignKey('user.id'), nullable=True)
    user = db.relationship(User)
    datetime = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    post_id = db.Column(db.Integer, db.ForeignKey('jobpost.id'), nullable=False)
    post = db.relation(JobPost, primaryjoin=post_id == JobPost.id,
        backref=db.backref('flags', cascade='all, delete-orphan'))
    reportcode_id = db.Column(db.Integer, db.ForeignKey('reportcode.id'), nullable=False)
    reportcode = db.relation(ReportCode, primaryjoin=reportcode_id == ReportCode.id)
    report_code = db.synonym('reportcode_id')

    ipaddr = db.Column(db.String(45), nullable=False)
    useragent = db.Column(db.Unicode(250), nullable=True)

########NEW FILE########
__FILENAME__ = jobtype
from hasjob.models import db, BaseNameMixin


class JobType(BaseNameMixin, db.Model):
    __tablename__ = 'jobtype'
    idref = 'type'

    seq = db.Column(db.Integer, nullable=False, default=0)
    public = db.Column(db.Boolean, nullable=False, default=True)

    def __call__(self):
        return self.title

    def search_mapping(self):
        """
        Returns a dictionary suitable for search indexing.
        """
        return {'title': self.title,
                'content': self.title,
                'public': self.public,
                'idref': u'%s/%s' % (self.idref, self.id),
                }

########NEW FILE########
__FILENAME__ = reportcode
from hasjob.models import db, BaseNameMixin


class ReportCode(BaseNameMixin, db.Model):
    __tablename__ = 'reportcode'

    seq = db.Column(db.Integer, nullable=False, default=0)
    public = db.Column(db.Boolean, nullable=False, default=True)

########NEW FILE########
__FILENAME__ = user
# -*- coding: utf-8 -*-

from flask.ext.lastuser.sqlalchemy import UserBase
from . import db

__all__ = ['User']


class User(UserBase, db.Model):
    __tablename__ = 'user'

    blocked = db.Column(db.Boolean, nullable=False, default=False)

########NEW FILE########
__FILENAME__ = nlp
# -*- coding: utf-8 -*-

"""
Natural language processing helpers.
"""

import langid
import bleach

def identify_language(post):
    return langid.classify(u'\n'.join([post.headline, bleach.clean(post.description, tags=[], strip=True)]))[0]

########NEW FILE########
__FILENAME__ = search
# -*- coding: utf-8 -*-

import os.path
from flask.ext.sqlalchemy import models_committed
from flask.ext.rq import job
import time
from sqlalchemy.exc import ProgrammingError
from whoosh import fields, index
from whoosh.index import LockError
from whoosh.qparser import QueryParser
from whoosh.analysis import StemmingAnalyzer

from hasjob import models, app


INDEXABLE = (models.JobType, models.JobCategory, models.JobPost)
search_schema = fields.Schema(title=fields.TEXT(stored=True),
                              content=fields.TEXT(analyzer=StemmingAnalyzer()),
                              idref=fields.ID(stored=True, unique=True))


# For search results
def ob_from_idref(idref):
    ref, objid = idref.split('/')
    if ref == 'post':
        return models.JobPost.query.get(int(objid))
    elif ref == 'type':
        return models.JobType.query.get(int(objid))
    elif ref == 'category':
        return models.JobCategory.query.get(int(objid))


def do_search(query, expand=False):
    """
    Returns search results
    """
    ix = index.open_dir(app.config['SEARCH_INDEX_PATH'])
    hits = []

    if query:
        parser = QueryParser("content", schema=ix.schema)
        try:
            qry = parser.parse(query)
        except:
            # query couldn't be parsed
            qry = None
        if qry is not None:
            searcher = ix.searcher()
            hits = searcher.search(qry, limit=1000)

    if expand:
        return (ob_from_idref(hit['idref']) for hit in hits)
    else:
        return hits


@job("hasjob-search")
def update_index(data):
    ix = index.open_dir(app.config['SEARCH_INDEX_PATH'])
    try:
        writer = ix.writer()
    except LockError:
        time.sleep(1)
        try:
            writer = ix.writer()
        except LockError:
            time.sleep(5)
            writer = ix.writer()
    for change, mapping in data:
        public = mapping.pop('public')
        if public:
            if change == 'insert':
                writer.add_document(**mapping)
            elif change == 'update':
                writer.update_document(**mapping)
            elif change == 'delete':
                writer.delete_by_term('idref', mapping['idref'])
        else:
            writer.delete_by_term('idref', mapping['idref'])
    writer.commit()


def on_models_committed(sender, changes):
    data = []
    for model, change in changes:
        if isinstance(model, INDEXABLE):
            data.append([change, model.search_mapping()])
    if data:
        update_index.delay(data)


@job("hasjob-search")
def delete_from_index(oblist):
    ix = index.open_dir(app.config['SEARCH_INDEX_PATH'])
    writer = ix.writer()
    for item in oblist:
        mapping = item.search_mapping()
        writer.delete_by_term('idref', mapping['idref'])
    writer.commit()


def configure_once():
    index_path = app.config['SEARCH_INDEX_PATH']
    if not os.path.exists(index_path):
        os.mkdir(index_path)
        ix = index.create_in(index_path, search_schema)
        writer = ix.writer()
        # Index everything since this is the first time
        for model in [models.JobType, models.JobCategory, models.JobPost]:
            try:
                for ob in model.query.all():
                    mapping = ob.search_mapping()
                    public = mapping.pop('public')
                    if public:
                        writer.add_document(**mapping)
            except ProgrammingError:
                pass  # The table doesn't exist yet. This is really a new installation.
        writer.commit()

def configure():
    models_committed.connect(on_models_committed, sender=app)

########NEW FILE########
__FILENAME__ = signals
# -*- coding: utf-8 -*-

from blinker import Namespace

signals = Namespace()

signal_login = signals.signal('login')
signal_logout = signals.signal('logout')
signal_post_confirmed = signals.signal('post-confirmed')

########NEW FILE########
__FILENAME__ = twitter
# -*- coding: utf-8 -*-

from flask.ext.rq import job
from tweepy import OAuthHandler, API
import bitlyapi
import urllib2
import json
import re
from hasjob import app


@job('hasjob')
def tweet(title, url, location=None):
    auth = OAuthHandler(app.config['TWITTER_CONSUMER_KEY'], app.config['TWITTER_CONSUMER_SECRET'])
    auth.set_access_token(app.config['TWITTER_ACCESS_KEY'], app.config['TWITTER_ACCESS_SECRET'])
    api = API(auth)
    maxlength = 120 # 120 chars plus URL = 140 max for Twitter
    if location:
        # Make a hashtag from the first word in the location
        locationtag = '#'+re.split('\W+', location)[0]
        maxlength -= len(locationtag)+1
    else:
        locationtag = None
    if len(title) > maxlength:
        text = title[:maxlength-3] + '...'
    else:
        text = title[:maxlength]
    text = text + ' ' + shorten(url)
    if locationtag:
        text = text + ' ' + locationtag
    api.update_status(text)


def shorten(url):
    if app.config['BITLY_KEY']:
        b = bitlyapi.BitLy(app.config['BITLY_USER'], app.config['BITLY_KEY'])
        res = b.shorten(longUrl=url)
        return res['url']
    else:
        req = urllib2.Request("https://www.googleapis.com/urlshortener/v1/url",
            headers = {"Content-Type": "application/json",},
            data = json.dumps({'longUrl' : url}))
        request_result = urllib2.urlopen(req)
        result = request_result.read()
        result_json = json.loads(result)
        return result_json['id']

########NEW FILE########
__FILENAME__ = uploads
# -*- coding: utf-8 -*-

from PIL import Image
from StringIO import StringIO
from os.path import splitext
from werkzeug import FileStorage

from flask.ext.uploads import UploadSet, configure_uploads, IMAGES, UploadNotAllowed

from hasjob import app

uploaded_logos = UploadSet('logos', IMAGES)


def configure():
    configure_uploads(app, uploaded_logos)


def process_image(requestfile, maxsize=(170, 130)):
    fileext = splitext(requestfile.filename)[1].lower()
    if fileext not in ['.jpg', '.jpeg', '.png', '.gif']:
        raise UploadNotAllowed("Unsupported file format")
    img = Image.open(requestfile)
    img.load()
    if img.size[0] > maxsize[0] or img.size[1] > maxsize[1]:
        img.thumbnail(maxsize, Image.ANTIALIAS)
    boximg = Image.new('RGBA', maxsize, (255, 255, 255, 0))
    boximg.paste(img, ((boximg.size[0] - img.size[0]) / 2, (boximg.size[1] - img.size[1]) / 2))
    savefile = StringIO()
    savefile.name = requestfile.filename
    boximg.save(savefile)
    savefile.seek(0)
    return FileStorage(savefile,
        filename=requestfile.filename,
        content_type=requestfile.content_type)

########NEW FILE########
__FILENAME__ = utils
import re
from random import randint
from uuid import uuid4
from base64 import b64encode
from coaster import simplify_text


#: This code adapted from http://en.wikipedia.org/wiki/Base_36#Python%5FConversion%5FCode
def base36encode(number, alphabet='0123456789abcdefghijklmnopqrstuvwxyz'):
    """
    Convert positive integer to a base36 string.

    >>> base36encode(0)
    '0'
    >>> base36encode(60466175)
    'zzzzz'
    >>> base36encode(60466176)
    '100000'
    """
    if not isinstance(number, (int, long)):
        raise TypeError('number must be an integer')
    # Special case for zero
    if number == 0:
        return '0'
    base36 = ''
    sign = ''
    if number < 0:
        sign = '-'
        number = - number
    while number != 0:
        number, i = divmod(number, len(alphabet))
        base36 = alphabet[i] + base36
    return sign + base36


def base36decode(number):
    return int(number, 36)


def random_long_key():
    return base36encode(randint(1000000000000000,
                                10000000000000000))


def random_hash_key():
    """
    Returns a random key that is exactly five letters long.

    >>> for attempt in range(1000):
    ...     if len(random_hash_key()) != 5:
    ...         print "Length is not 5!"
    """
    return ('0000' + base36encode(randint(0, 60466175)))[-5:]  # 60466175 is 'zzzzz'


def newid():
    """
    Return a new random id that is exactly 22 characters long.
    """
    return b64encode(uuid4().bytes, altchars=',-').replace('=', '')


EMAIL_RE = re.compile(r'\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b', re.I)
# From http://www.codinghorror.com/blog/2008/10/the-problem-with-urls.html
URL_RE = re.compile(r'\(?\bhttps?://[-A-Za-z0-9+&@#/%?=~_()|!:,.;]*[-A-Za-z0-9+&@#/%=~_()|]')
PHONE_DETECT_RE = re.compile('(^|[^0-9])([0-9][ .()_-]*){10}($|[^0-9])')


def redactemail(data, message=u'[redacted]'):
    """
    Remove email addresses from the given text, replacing with a redacted message.

    >>> redactemail(u"Send email to test@example.com and you are all set.")
    u'Send email to [redacted] and you are all set.'
    >>> redactemail(u"Send email to test@example.com and you are all set.", '[hidden]')
    u'Send email to [hidden] and you are all set.'
    """
    return EMAIL_RE.sub(message, data)


def scrubemail(data, rot13=False, css_junk=None):
    """
    Convert email addresses in text into HTML links,
    and optionally obfuscate them with ROT13 and empty CSS classes,
    to hide from spambots.

    >>> scrubemail(u"Send email to test@example.com and you are all set.")
    u'Send email to <a href="mailto:test@example.com">test@example.com</a> and you are all set.'
    >>> scrubemail(u"Send email to test@example.com and you are all set.", rot13=True)
    u'Send email to <a class="rot13" data-href="znvygb:grfg@rknzcyr.pbz">test@example.com</a> and you are all set.'
    >>> scrubemail(u"Send email to test@example.com and you are all set.", rot13=True, css_junk='z')
    u'Send email to <a class="rot13" data-href="znvygb:grfg@rknzcyr.pbz">test&#64;<span class="z">no</span>examp<span class="z">spam</span>le.com</a> and you are all set.'
    >>> scrubemail(u"Send email to test@example.com and you are all set.", rot13=False, css_junk=('z', 'y'))
    u'Send email to <a href="mailto:test@example.com"><span class="y">test&#64;</span><span class="z">no</span><span class="y">examp</span><span class="z">spam</span><span class="y">le.com</span></a> and you are all set.'
    """
    def convertemail(m):
        aclass = ' class="rot13"' if rot13 else ''
        email = m.group(0)
        link = 'mailto:' + email
        if rot13:
            link = link.decode('rot13')
        if css_junk and len(email) > 3:
            third = int(len(email) / 3)
            parts = (email[:third], email[third:third*2], email[third*2:])
            if isinstance(css_junk, (tuple, list)):
                css_dirty, css_clean = css_junk
                email = '<span class="%s">%s</span><span class="%s">no</span>'\
                    '<span class="%s">%s</span><span class="%s">spam</span>'\
                    '<span class="%s">%s</span>' % (
                    css_clean, parts[0], css_dirty, css_clean, parts[1],
                    css_dirty, css_clean, parts[2])
            else:
                email = '%s<span class="%s">no</span>%s<span class="%s">spam</span>%s' % (
                    parts[0], css_junk, parts[1], css_junk, parts[2])
            email = email.replace('@', '&#64;')
        if rot13:
            return '<a%s data-href="%s">%s</a>' % (aclass, link, email)
        else:
            return '<a%s href="%s">%s</a>' % (aclass, link, email)
    data = EMAIL_RE.sub(convertemail, data)
    return data


WORDSPLIT_RE = re.compile('\W+')
TAGSPLIT_RE = re.compile('<.*?>')


def striptags(text):
    """
    Remove HTML/XML tags from text, inserting spaces in their place:

    >>> striptags('<h1>title</h1>')
    ' title '
    >>> striptags('plain text')
    'plain text'
    >>> striptags(u'word<br>break')
    u'word break'
    """
    return TAGSPLIT_RE.sub(' ', text)


def getwords(text):
    """
    Get words in text by splitting text along punctuation
    and stripping out the punctuation:

    >>> getwords('this is some text.')
    ['this', 'is', 'some', 'text']
    >>> getwords('and/or')
    ['and', 'or']
    >>> getwords('one||two')
    ['one', 'two']
    >>> getwords("does not is doesn't")
    ['does', 'not', 'is', 'doesn', 't']
    >>> getwords(u'hola unicode!')
    [u'hola', u'unicode']
    """
    result = WORDSPLIT_RE.split(text)
    # Blank tokens will only be at beginning or end of text.
    if result[0] == '':
        result.pop(0)
    if result and result[-1] == '':
        result.pop(-1)
    return result


def get_word_bag(text):
    """
    Return a string containing all unique words in the given text, in alphabetical order.

    >>> get_word_bag("This is a piece\tof text with this extra bit!")
    'a bit extra is of piece text this with'
    """
    words = list(set(simplify_text(striptags(text)).split(' ')))
    words.sort()
    return " ".join(words)


if __name__ == '__main__':
    import doctest
    doctest.testmod()

########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-
# Admin views

from datetime import datetime, timedelta
from flask import abort, Response

from hasjob import app
from hasjob.search import delete_from_index
from hasjob.models import JobPost, agelimit


@app.route('/admin/update-search/<key>')
def delete_index(key):
    if key == app.config['PERIODIC_KEY']:
        now = datetime.utcnow()
        upper_age_limit = timedelta(days=agelimit.days * 2)  # Reasonably large window to clear backlog
        items = JobPost.query.filter(JobPost.datetime > now - upper_age_limit).filter(JobPost.datetime < now - agelimit).all()
        delete_from_index.delay(items)
        return Response("Removed %d items.\n" % len(items),
                        content_type='text/plain; charset=utf-8')
    else:
        abort(403)

# --- Admin views ------------------------------------------------------------
# Work pending

########NEW FILE########
__FILENAME__ = board
# -*- coding: utf-8 -*-

from flask import g, abort, flash, url_for, redirect, request
from coaster.views import load_model, load_models
from baseframe.forms import render_form, render_delete_sqla, render_redirect
from .. import app, lastuser
from ..models import db, Board, JobPost
from ..forms import BoardForm


@app.url_value_preprocessor
def remove_subdomain_parameter(endpoint, values):
    if values:
        subdomain = values.pop('subdomain', None)
    else:
        subdomain = None

    if subdomain and subdomain == app.config.get('STATIC_SUBDOMAIN', 'static'):
        g.board = None
        return  # Don't bother processing for static domain

    g.board = Board.query.filter_by(name=subdomain or u'www').first()
    if subdomain and g.board is None:
        abort(404)


@app.url_defaults
def add_subdomain_parameter(endpoint, values):
    if app.url_map.is_endpoint_expecting(endpoint, 'subdomain'):
        if 'subdomain' not in values:
            values['subdomain'] = g.board.name if g.board else None


@app.route('/board', methods=['GET', 'POST'])
@lastuser.requires_login
def board_new():
    form = BoardForm()
    form.userid.choices = [(g.user.userid, g.user.fullname)] + [(o['userid'], o['title']) for o in g.user.organizations_owned()]
    if form.validate_on_submit():
        board = Board()
        form.populate_obj(board)
        if not board.name:
            board.make_name()
        db.session.add(board)
        if 'add' in request.args:
            post = JobPost.get(request.args['add'])
            if post:
                board.add(post)
        db.session.commit()
        flash(u"Created a job board named %s" % board.title, 'success')
        return render_redirect(url_for('board_view', board=board.name), code=303)
    return render_form(form=form, title=u"Create a job board…", submit="Next",
        message=u"Make your own job board with just the jobs you want to showcase. "
            "Your board will appear as a subdomain",
        formid="board_new", cancel_url=url_for('index'), ajax=False)


@app.route('/board/<board>/edit', methods=['GET', 'POST'])
@lastuser.requires_login
@load_model(Board, {'name': 'board'}, 'board', permission='edit')
def board_edit(board):
    form = BoardForm(obj=board)
    form.userid.choices = [(g.user.userid, g.user.fullname)] + [(o['userid'], o['title']) for o in g.user.organizations_owned()]
    if form.validate_on_submit():
        form.populate_obj(board)
        if not board.name:
            board.make_name()
        db.session.commit()
        flash(u"Edited board settings.", 'success')
        return render_redirect(url_for('index', subdomain=board.name), code=303)

    return render_form(form=form, title=u"Edit board settings", submit="Save",
        formid="board_edit", cancel_url=url_for('index', subdomain=board.name), ajax=False)


@app.route('/board/<board>/delete', methods=['GET', 'POST'])
@lastuser.requires_login
@load_model(Board, {'name': 'board'}, 'board', permission='delete')
def board_delete(board):
    return render_delete_sqla(board, db, title=u"Confirm delete",
        message=u"Delete board '%s'?" % board.title,
        success=u"You have deleted board '%s'." % board.title,
        next=url_for('index'))


@app.route('/board/<board>')
def board_view(board):
    return redirect(url_for('index', subdomain=board))


@app.route('/board/<board>/add/<hashid>')
@lastuser.requires_login
@load_models(
    (Board, {'name': 'board'}, 'board'),
    (JobPost, {'hashid': 'hashid'}, 'jobpost'),
    permission='add')
# FIXME: Should be a POST request
def board_add(board, jobpost):
    board.add(jobpost)
    db.session.commit()
    flash(u"You’ve added this job to %s" % board.title, 'interactive')
    return redirect(url_for('jobdetail', hashid=jobpost.hashid, subdomain=board.name))

########NEW FILE########
__FILENAME__ = error_handling
from flask import render_template
from hasjob import app


@app.errorhandler(403)
def error_403(e):
    return render_template('403.html'), 403


@app.errorhandler(404)
def error_404(e):
    return render_template('404.html'), 404


@app.errorhandler(410)
def error_410(e):
    return render_template('410.html'), 410


@app.errorhandler(500)
def error_500(e):
    return render_template('500.html'), 500

########NEW FILE########
__FILENAME__ = helper
from datetime import datetime
from os import path
import bleach
from pytz import utc, timezone
from urllib import quote, quote_plus
from flask import Markup, request, url_for, g

from .. import app
from ..models import agelimit, newlimit, db, JobCategory, JobPost, JobType, POSTSTATUS, BoardJobPost
from ..utils import scrubemail, redactemail


def getposts(basequery=None, sticky=False, showall=False):
    if showall:
        useagelimit = agelimit
    else:
        useagelimit = newlimit

    if basequery is None:
        basequery = JobPost.query

    query = basequery.filter(
        JobPost.status.in_([POSTSTATUS.CONFIRMED, POSTSTATUS.REVIEWED])).filter(
            db.or_(
                db.and_(JobPost.sticky == True, JobPost.datetime > datetime.utcnow() - agelimit),
                db.and_(JobPost.sticky == False, JobPost.datetime > datetime.utcnow() - useagelimit)))

    if g.board:
        query = query.join(JobPost.postboards).filter(BoardJobPost.board == g.board)

    if sticky:
        query = query.order_by(db.desc(JobPost.sticky))
    return query.order_by(db.desc(JobPost.datetime))


def getallposts(order_by=None, desc=False, start=None, limit=None):
    if order_by is None:
        order_by = JobPost.datetime
    filt = JobPost.query.filter(JobPost.status.in_([POSTSTATUS.CONFIRMED, POSTSTATUS.REVIEWED]))
    count = filt.count()
    if desc:
        filt = filt.order_by(db.desc(order_by))
    else:
        filt = filt.order_by(order_by)
    if start is not None:
        filt = filt.offset(start)
    if limit is not None:
        filt = filt.limit(limit)
    return count, filt


@app.template_filter('urlfor')
def url_from_ob(ob):
    if isinstance(ob, JobPost):
        return url_for('jobdetail', hashid=ob.hashid)
    elif isinstance(ob, JobType):
        return url_for('browse_by_type', name=ob.name)
    elif isinstance(ob, JobCategory):
        return url_for('browse_by_category', name=ob.name)


@app.template_filter('shortdate')
def shortdate(date):
    tz = timezone(app.config['TIMEZONE'])
    return utc.localize(date).astimezone(tz).strftime('%b %e')


@app.template_filter('longdate')
def longdate(date):
    tz = timezone(app.config['TIMEZONE'])
    return utc.localize(date).astimezone(tz).strftime('%B %e, %Y')


@app.template_filter('cleanurl')
def cleanurl(url):
    if url.startswith('http://'):
        url = url[7:]
    elif url.startswith('https://'):
        url = url[8:]
    if url.endswith('/') and url.count('/') == 1:
        # Remove trailing slash if applied to end of domain name
        # but leave it in if it's a path
        url = url[:-1]
    return url


@app.template_filter('urlquote')
def urlquote(data):
    if isinstance(data, unicode):
        return quote(data.encode('utf-8'))
    else:
        return quote(data)


@app.template_filter('urlquoteplus')
def urlquoteplus(data):
    if isinstance(data, unicode):
        return quote_plus(data.encode('utf-8'))
    else:
        return quote_plus(data)


@app.template_filter('scrubemail')
def scrubemail_filter(data, css_junk=''):
    return Markup(scrubemail(unicode(bleach.linkify(bleach.clean(data))), rot13=True, css_junk=css_junk))


@app.template_filter('hideemail')
def hideemail_filter(data, message='[redacted]'):
    return redactemail(data, message)


@app.template_filter('usessl')
def usessl(url):
    """
    Convert a URL to https:// if SSL is enabled in site config
    """
    if not app.config.get('USE_SSL'):
        return url
    if url.startswith('//'): # //www.example.com/path
        return 'https:' + url
    if url.startswith('/'): # /path
        url = path.join(request.url_root, url[1:])
    if url.startswith('http:'): # http://www.example.com
        url = 'https:' + url[5:]
    return url

########NEW FILE########
__FILENAME__ = index
# -*- coding: utf-8 -*-

from datetime import datetime
try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict
from flask import (
    abort,
    redirect,
    render_template,
    request,
    Response,
    url_for,
    g
    )

from hasjob import app, lastuser
from hasjob.models import webmail_domains, JobCategory, JobPost, JobType, POSTSTATUS, newlimit
from hasjob.search import do_search
from hasjob.views.helper import getposts, getallposts
from hasjob.uploads import uploaded_logos


@app.route('/', subdomain='<subdomain>')
@app.route('/')
def index(basequery=None, type=None, category=None, md5sum=None, domain=None, title=None, showall=False):
    now = datetime.utcnow()
    if g.user or g.kiosk or g.board:
        showall = True
    posts = list(getposts(basequery, sticky=True, showall=showall))
    if posts:
        employer_name = posts[0].company_name
    else:
        employer_name = u'a single employer'

    if basequery is None and posts and not g.kiosk:
        # Group posts by email_domain on index page only, when not in kiosk mode
        grouped = OrderedDict()
        for post in posts:
            if post.sticky:
                # Make sticky posts appear in a group of one
                grouped.setdefault(('s', post.hashid), []).append(post)
                # if post.email_domain in webmail_domains:
                #     grouped.setdefault(('se', post.md5sum), []).append(post)
                # else:
                #     grouped.setdefault(('sd', post.email_domain), []).append(post)
            elif post.email_domain in webmail_domains:
                grouped.setdefault(('ne', post.md5sum), []).append(post)
            else:
                grouped.setdefault(('nd', post.email_domain), []).append(post)
    else:
        grouped = None

    return render_template('index.html', posts=posts, grouped=grouped, now=now,
                           newlimit=newlimit, jobtype=type, jobcategory=category, title=title,
                           md5sum=md5sum, domain=domain, employer_name=employer_name,
                           showall=showall,
                           siteadmin=lastuser.has_permission('siteadmin'))


@app.route('/type/<name>', subdomain='<subdomain>')
@app.route('/type/<name>')
def browse_by_type(name):
    if name == 'all':
        return redirect(url_for('index'))
    ob = JobType.query.filter_by(name=name).first_or_404()
    basequery = JobPost.query.filter_by(type_id=ob.id)
    return index(basequery=basequery, type=ob, title=ob.title)


@app.route('/at/<domain>', subdomain='<subdomain>')
@app.route('/at/<domain>')
def browse_by_domain(domain):
    if not domain:
        abort(404)
    basequery = JobPost.query.filter_by(email_domain=domain)
    return index(basequery=basequery, domain=domain, title=domain, showall=True)


@app.route('/category/<name>', subdomain='<subdomain>')
@app.route('/category/<name>')
def browse_by_category(name):
    if name == 'all':
        return redirect(url_for('index'))
    ob = JobCategory.query.filter_by(name=name).first_or_404()
    basequery = JobPost.query.filter_by(category_id=ob.id)
    return index(basequery=basequery, category=ob, title=ob.title)


@app.route('/by/<md5sum>', subdomain='<subdomain>')
@app.route('/by/<md5sum>')
def browse_by_email(md5sum):
    if not md5sum:
        abort(404)
    basequery = JobPost.query.filter_by(md5sum=md5sum)
    return index(basequery=basequery, md5sum=md5sum, showall=True)


@app.route('/feed', subdomain='<subdomain>')
@app.route('/feed')
def feed(basequery=None, type=None, category=None, md5sum=None, domain=None):
    title = "All jobs"
    if type:
        title = type.title
    elif category:
        title = category.title
    elif md5sum or domain:
        title = u"Jobs at a single employer"
    posts = list(getposts(basequery, showall=True))
    if posts:  # Can't do this unless posts is a list
        updated = posts[0].datetime.isoformat() + 'Z'
        if md5sum:
            title = posts[0].company_name
    else:
        updated = datetime.utcnow().isoformat() + 'Z'
    return Response(render_template('feed.xml', posts=posts, updated=updated, title=title),
        content_type='application/atom+xml; charset=utf-8')


@app.route('/type/<name>/feed', subdomain='<subdomain>')
@app.route('/type/<name>/feed')
def feed_by_type(name):
    if name == 'all':
        return redirect(url_for('feed'))
    ob = JobType.query.filter_by(name=name).first_or_404()
    basequery = JobPost.query.filter_by(type_id=ob.id)
    return feed(basequery=basequery, type=ob)


@app.route('/category/<name>/feed', subdomain='<subdomain>')
@app.route('/category/<name>/feed')
def feed_by_category(name):
    if name == 'all':
        return redirect(url_for('feed'))
    ob = JobCategory.query.filter_by(name=name).first_or_404()
    basequery = JobPost.query.filter_by(category_id=ob.id)
    return feed(basequery=basequery, category=ob)


@app.route('/by/<md5sum>/feed', subdomain='<subdomain>')
@app.route('/by/<md5sum>/feed')
def feed_by_email(md5sum):
    if not md5sum:
        abort(404)
    basequery = JobPost.query.filter_by(md5sum=md5sum)
    return feed(basequery=basequery, md5sum=md5sum)


@app.route('/at/<domain>/feed', subdomain='<subdomain>')
@app.route('/at/<domain>/feed')
def feed_by_domain(domain):
    if not domain:
        abort(404)
    basequery = JobPost.query.filter_by(email_domain=domain)
    return feed(basequery=basequery, domain=domain)


@app.route('/archive')
def archive():
    def sortarchive(order_by):
        current_order_by = request.args.get('order_by')
        reverse = request.args.get('reverse')
        if order_by == current_order_by:
            if reverse is None:
                reverse = False
            try:
                reverse = bool(int(reverse))
            except ValueError:
                reverse = False
            reverse = int(not reverse)
        return url_for('archive', order_by=order_by,
            reverse=reverse,
            start=request.args.get('start'),
            limit=request.args.get('limit'))

    order_by = {
        'date': JobPost.datetime,
        'headline': JobPost.headline,
        'company': JobPost.company_name,
        'location': JobPost.location,
        }.get(request.args.get('order_by'))
    reverse = request.args.get('reverse')
    start = request.args.get('start', 0)
    limit = request.args.get('limit', 100)
    if order_by is None and reverse is None:
        order_by = JobPost.datetime
        reverse = True
    try:
        if reverse is not None:
            reverse = bool(int(reverse))
    except ValueError:
        reverse = None
    try:
        if start is not None:
            start = int(start)
    except ValueError:
        start = 0
    try:
        if limit is not None:
            limit = int(limit)
    except ValueError:
        limit = 100
    count, posts = getallposts(order_by=order_by, desc=reverse, start=start, limit=limit)

    if request.is_xhr:
        tmpl = 'archive_inner.html'
    else:
        tmpl = 'archive.html'
    return render_template(tmpl, order_by=request.args.get('order_by'),
        posts=posts, start=start, limit=limit, count=count,
        # Pass some functions
        min=min, max=max, sortarchive=sortarchive)


@app.route('/sitemap.xml', subdomain='<subdomain>')
@app.route('/sitemap.xml')
def sitemap():
    sitemapxml = '<?xml version="1.0" encoding="UTF-8"?>\n'\
                 '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n'
    # Add job type pages to sitemap
    for item in JobType.query.all():
        sitemapxml += '  <url>\n'\
                      '    <loc>%s</loc>\n' % url_for('browse_by_type', name=item.name, _external=True) + \
                      '  </url>\n'
    # Add job category pages to sitemap
    for item in JobCategory.query.all():
        sitemapxml += '  <url>\n'\
                      '    <loc>%s</loc>\n' % url_for('browse_by_category', name=item.name, _external=True) + \
                      '  </url>\n'
    # Add live posts to sitemap
    for post in getposts(showall=True):
        sitemapxml += '  <url>\n'\
                      '    <loc>%s</loc>\n' % url_for('jobdetail', hashid=post.hashid, _external=True) + \
                      '    <lastmod>%s</lastmod>\n' % (post.datetime.isoformat() + 'Z') + \
                      '    <changefreq>monthly</changefreq>\n'\
                      '  </url>\n'
    sitemapxml += '</urlset>'
    return Response(sitemapxml, content_type='text/xml; charset=utf-8')


@app.route('/logo/<hashid>', subdomain='<subdomain>')
@app.route('/logo/<hashid>')
def logoimage(hashid):
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if not post.company_logo:
        # If there's no logo (perhaps it was deleted), don't try to show one
        abort(404)
    if post.status in [POSTSTATUS.REJECTED, POSTSTATUS.SPAM]:
        # Don't show logo if post has been rejected. Could be spam
        abort(410)
    return redirect(uploaded_logos.url(post.company_logo))


@app.route('/search', subdomain='<subdomain>')
@app.route('/search')
def search():
    now = datetime.utcnow()
    results = sorted(do_search(request.args.get('q', u''), expand=True),
        key=lambda r: getattr(r, 'datetime', now))
    results.reverse()
    return render_template('search.html', results=results, now=now, newlimit=newlimit)

########NEW FILE########
__FILENAME__ = kiosk
# -*- coding: utf-8 -*-

from flask import g, session, request, redirect, url_for, flash, Response, abort
from coaster.utils import getbool
from .. import app
from ..models import JobType, JobCategory
from .helper import getposts


@app.before_request
def kiosk_mode_flag():
    if session.get('kiosk'):
        g.kiosk = True
    else:
        g.kiosk = False
    g.peopleflow_url = session.get('peopleflow')


@app.route('/admin/kiosk')
def kiosk_mode():
    if getbool(request.args.get('enable')):
        session['kiosk'] = True
        session['peopleflow'] = request.args.get('url')
        session.permanent = True
        flash("Kiosk mode has been enabled", 'success')
    else:
        session.pop('kiosk', None)
        session.pop('peopleflow', None)
        session.permanent = False
        flash("Kiosk mode has been disabled", 'success')
    return redirect(url_for('index'))


@app.route('/kiosk.appcache', subdomain='<subdomain>')
@app.route('/kiosk.appcache')
def kiosk_manifest():

    if g.kiosk:
        lines = []
        lines.append('CACHE MANIFEST')

        lines.append('CACHE:')
        # Home page
        lines.append('/')

        # Type/category pages
        for item in JobType.query.all():
            lines.append(url_for('browse_by_type', name=item.name))

        for item in JobCategory.query.all():
            lines.append(url_for('browse_by_category', name=item.name))

        # Posts
        for post in getposts(None, showall=True):
            lines.append(url_for('jobdetail', hashid=post.hashid))

        # Static resources
        lines.append(url_for('static', filename='favicon.ico'))
        lines.append(url_for('static', filename='img/favicon.ico'))
        lines.append(url_for('static', filename='img/logo-star.png'))
        lines.append(url_for('static', filename='opensearch.xml'))
        lines.append(url_for('static', filename='css/editor.css'))

        lines.append(url_for('baseframe.static', filename='js/modernizr.min.js'))

        # Assets
        lines.extend(app.assets['js_all'].urls())
        lines.extend(app.assets['css_all'].urls())

        # External resources
        lines.append('//fonts.googleapis.com/css?family=Walter+Turncoat|McLaren|Source+Sans+Pro:400,600')
        if app.config.get('TYPEKIT_CODE'):
            lines.append('//use.typekit.com/' + app.config['TYPEKIT_CODE'] + '.js')

        # Exclude everything else
        lines.append('NETWORK:')
        lines.append('*')

        return Response(u'\r\n'.join(lines),
            content_type='text/cache-manifest')
    else:
        abort(410)

########NEW FILE########
__FILENAME__ = listing
import bleach
from datetime import datetime, timedelta
from markdown import markdown  # FIXME: coaster.gfm is breaking links, so can't use it
from difflib import SequenceMatcher
from html2text import html2text
from premailer import transform as email_transform

from sqlalchemy.exc import IntegrityError
from flask import (
    abort,
    flash,
    g,
    redirect,
    render_template,
    request,
    url_for,
    session,
    Markup,
    )
from flask.ext.mail import Message
from baseframe import cache
from coaster import get_email_domain, md5sum
from hasjob import app, forms, mail, lastuser
from hasjob.models import (
    agelimit,
    db,
    User,
    JobCategory,
    JobType,
    JobPost,
    JobPostReport,
    POSTSTATUS,
    EMPLOYER_RESPONSE,
    PAY_TYPE,
    ReportCode,
    UserJobView,
    JobApplication,
    unique_hash,
    viewcounts_by_id,
    viewstats_by_id_qhour,
    viewstats_by_id_hour,
    viewstats_by_id_day,
    )
from hasjob.twitter import tweet
from hasjob.uploads import uploaded_logos
from hasjob.utils import get_word_bag, redactemail, random_long_key
from hasjob.views import ALLOWED_TAGS
from hasjob.nlp import identify_language


@app.route('/view/<hashid>', methods=('GET', 'POST'), subdomain='<subdomain>')
@app.route('/view/<hashid>', methods=('GET', 'POST'))
def jobdetail(hashid):
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if post.status in [POSTSTATUS.DRAFT, POSTSTATUS.PENDING]:
        if post.edit_key not in session.get('userkeys', []) or (g.user and not post.admin_is(g.user)):
            abort(403)
    if post.status in [POSTSTATUS.REJECTED, POSTSTATUS.WITHDRAWN, POSTSTATUS.SPAM]:
        abort(410)
    if g.user:
        jobview = UserJobView.query.get((g.user.id, post.id))
        if jobview is None:
            jobview = UserJobView(user=g.user, jobpost=post)
            cache.delete_memoized(viewcounts_by_id, post.id)
            cache.delete_memoized(viewstats_by_id_qhour, post.id)
            cache.delete_memoized(viewstats_by_id_hour, post.id)
            cache.delete_memoized(viewstats_by_id_day, post.id)
            db.session.add(jobview)
            try:
                db.session.commit()
            except IntegrityError:
                db.session.rollback()
                pass  # User opened two tabs at once? We don't really know
            viewcounts_by_id(post.id)  # Re-populate cache
    else:
        jobview = None
    
    if g.user:
        report = JobPostReport.query.filter_by(post=post, user=g.user).first()
    else:
        report = None

    reportform = forms.ReportForm(obj=report)
    reportform.report_code.choices = [(ob.id, ob.title) for ob in ReportCode.query.filter_by(public=True).order_by('seq')]
    rejectform = forms.RejectForm()
    moderateform = forms.ModerateForm()
    if request.method == 'GET':
        moderateform.reason.data = post.review_comments
    stickyform = forms.StickyForm(obj=post)
    applyform = None  # User isn't allowed to apply unless non-None
    if g.user:
        job_application = JobApplication.query.filter_by(user=g.user, jobpost=post).first()
        if not job_application:
            applyform = forms.ApplicationForm()
            applyform.apply_phone.data = g.user.phone
    elif g.kiosk and g.peopleflow_url:
        applyform = forms.KioskApplicationForm()
        job_application = None
    else:
        job_application = None
    if reportform.validate_on_submit():
        if g.user:
            if report is None:
                report = JobPostReport(post=post, user=g.user)
            report.reportcode_id = reportform.report_code.data
            report.ipaddr = request.environ['REMOTE_ADDR']
            report.useragent = request.user_agent.string
            db.session.add(report)
            db.session.commit()
            if request.is_xhr:
                return "<p>Thanks! This listing has been flagged for review</p>"  # FIXME: Ugh!
            else:
                flash("Thanks! This listing has been flagged for review", "interactive")
        else:
            if request.is_xhr:
                return "<p>You need to be logged in to report a listing</p>"  # FIXME: Ugh!
            else:
                flash("You need to be logged in to report a listing", "interactive")
    elif request.method == 'POST' and request.is_xhr:
        return render_template('inc/reportform.html', reportform=reportform)
    return render_template('detail.html', post=post, reportform=reportform, rejectform=rejectform,
        stickyform=stickyform, applyform=applyform, job_application=job_application,
        jobview=jobview, report=report, moderateform=moderateform,
        siteadmin=lastuser.has_permission('siteadmin')
        )


@app.route('/reveal/<hashid>', subdomain='<subdomain>')
@app.route('/reveal/<hashid>')
@lastuser.requires_login
def revealjob(hashid):
    """
    This view is a GET request and that is intentional.
    """
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if post.status in [POSTSTATUS.REJECTED, POSTSTATUS.WITHDRAWN, POSTSTATUS.SPAM]:
        abort(410)
    jobview = UserJobView.query.get((g.user.id, post.id))
    if jobview is None:
        jobview = UserJobView(user=g.user, jobpost=post, applied=True)
        cache.delete_memoized(viewcounts_by_id, post.id)
        cache.delete_memoized(viewstats_by_id_qhour, post.id)
        cache.delete_memoized(viewstats_by_id_hour, post.id)
        cache.delete_memoized(viewstats_by_id_day, post.id)
        db.session.add(jobview)
        try:
            db.session.commit()
        except IntegrityError:
            db.session.rollback()
            pass  # User double-clicked. Ignore.
        viewcounts_by_id(post.id)  # Re-populate cache
    elif not jobview.applied:
        jobview.applied = True
        cache.delete_memoized(viewcounts_by_id, post.id)
        cache.delete_memoized(viewstats_by_id_qhour, post.id)
        cache.delete_memoized(viewstats_by_id_hour, post.id)
        cache.delete_memoized(viewstats_by_id_day, post.id)
        db.session.commit()
        viewcounts_by_id(post.id) # Re-populate cache
    if request.is_xhr:
        return redactemail(post.how_to_apply)
    else:
        return redirect(url_for('jobdetail', hashid=post.hashid), 303)


@app.route('/apply/<hashid>', methods=['POST'], subdomain='<subdomain>')
@app.route('/apply/<hashid>', methods=['POST'])
def applyjob(hashid):
    """
    Apply to a job (including in kiosk mode)
    """
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if g.user:
        job_application = JobApplication.query.filter_by(user=g.user, jobpost=post).first()
    else:
        job_application = None
    if job_application:
        flashmsg = "You have already applied to this job. You may not apply again"
        if request.is_xhr:
            return u'<p><strong>{}</strong></p>'.format(flashmsg)
        else:
            flash(flashmsg, 'interactive')
            return redirect(url_for('jobdetail', hashid=post.hashid), 303)
    else:
        if g.kiosk:
            applyform = forms.KioskApplicationForm()
        else:
            applyform = forms.ApplicationForm()
        applyform.post = post
        if applyform.validate_on_submit():
            if g.user and g.user.blocked:
                flashmsg = "Your account has been blocked from applying to jobs"
            else:
                if g.kiosk:
                    job_application = JobApplication(user=None, jobpost=post,
                        fullname=applyform.apply_fullname.data,
                        email=applyform.apply_email.data,
                        phone=applyform.apply_phone.data,
                        message=applyform.apply_message.data,
                        words=None)
                else:
                    job_application = JobApplication(user=g.user, jobpost=post,
                        fullname=g.user.fullname,
                        email=applyform.apply_email.data,
                        phone=applyform.apply_phone.data,
                        message=applyform.apply_message.data,
                        words=applyform.words)
                db.session.add(job_application)
                db.session.commit()
                email_html = email_transform(
                    render_template('apply_email.html',
                        post=post, job_application=job_application,
                        archive_url=url_for('view_application',
                            hashid=post.hashid, application=job_application.hashid,
                            _external=True)),
                    base_url=request.url_root)
                email_text = html2text(email_html)
                flashmsg = "Your application has been sent to the employer"

                msg = Message(subject=u"Job application: {fullname}".format(fullname=job_application.fullname),
                    recipients=[post.email])
                if not job_application.user:
                    # Also BCC the candidate
                    msg.bcc = [job_application.email]
                msg.body = email_text
                msg.html = email_html
                mail.send(msg)

            if request.is_xhr:
                return u'<p><strong>{}</strong></p>'.format(flashmsg)
            else:
                flash(flashmsg, 'interactive')
                return redirect(url_for('jobdetail', hashid=post.hashid), 303)

        if request.is_xhr:
            return render_template('inc/applyform.html', post=post, applyform=applyform)
        else:
            return redirect(url_for('jobdetail', hashid=post.hashid), 303)


@app.route('/manage/<hashid>', methods=('GET', 'POST'), defaults={'key': None}, subdomain='<subdomain>')
@app.route('/manage/<hashid>/<key>', methods=('GET', 'POST'), subdomain='<subdomain>')
@app.route('/manage/<hashid>', methods=('GET', 'POST'), defaults={'key': None})
@app.route('/manage/<hashid>/<key>', methods=('GET', 'POST'))
def managejob(hashid, key):
    # Candidate management interface
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if not ((key is None and post.admin_is(g.user)) or (key == post.edit_key)):
        abort(403)
    # TODO: Landing page for candidate management
    pass


@app.route('/view/<hashid>/<application>', subdomain='<subdomain>')
@app.route('/view/<hashid>/<application>')
def view_application(hashid, application):
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    # Transition code until we force all employers to login before posting
    if post.user and not (post.admin_is(g.user) or lastuser.has_permission('siteadmin')):
        if not g.user:
            return redirect(url_for('login', message=u"You need to be logged in to view candidate applications on Hasjob."))
        else:
            abort(403)
    job_application = JobApplication.query.filter_by(hashid=application, jobpost=post).first_or_404()
    if job_application.response == EMPLOYER_RESPONSE.NEW:
        # If the application is pending, mark it as opened.
        # However, don't do this if the user is a siteadmin, unless they also own the post.
        if post.admin_is(g.user) or not lastuser.has_permission('siteadmin'):
            job_application.response = EMPLOYER_RESPONSE.PENDING
            db.session.commit()
    response_form = forms.ApplicationResponseForm()

    statuses = set([app.status for app in post.applications])

    return render_template('application.html', post=post, job_application=job_application,
        response_form=response_form, statuses=statuses)


@app.route('/apply/<hashid>/<application>', methods=['POST'], subdomain='<subdomain>')
@app.route('/apply/<hashid>/<application>', methods=['POST'])
def process_application(hashid, application):
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if post.user and not post.admin_is(g.user):
        if not g.user:
            return redirect(url_for('login'))
        else:
            abort(403)
    job_application = JobApplication.query.filter_by(hashid=application, jobpost=post).first_or_404()
    response_form = forms.ApplicationResponseForm()
    flashmsg = ''

    if response_form.validate_on_submit():
        if (request.form.get('action') == 'reply' and job_application.can_reply()) or (
            request.form.get('action') == 'reject' and job_application.can_reject()):
            if not response_form.response_message.data:
                flashmsg = "You need to write a message to the candidate."
            else:
                if request.form.get('action') == 'reply':
                    job_application.response = EMPLOYER_RESPONSE.REPLIED
                else:
                    job_application.response = EMPLOYER_RESPONSE.REJECTED
                job_application.response_message = response_form.response_message.data

                email_html = email_transform(
                    render_template('respond_email.html',
                        post=post, job_application=job_application,
                        archive_url=url_for('view_application',
                            hashid=post.hashid, application=job_application.hashid,
                            _external=True)),
                    base_url=request.url_root)
                email_text = html2text(email_html)

                sender_name = g.user.fullname if post.admin_is(g.user) else post.fullname or post.company_name
                sender_formatted = u'{sender} (via {site})'.format(
                    sender=sender_name,
                    site=app.config['SITE_TITLE'])

                if job_application.is_replied():
                    msg = Message(subject=u"Regarding your job application for {headline}".format(headline=post.headline),
                        sender=(sender_formatted, app.config['MAIL_SENDER']),
                        reply_to=(sender_name, post.email),
                        recipients=[job_application.email],
                        bcc=[post.email])
                    flashmsg = "We sent your message to the candidate and copied you. Their email and phone number are below"
                else:
                    msg = Message(subject=u"Regarding your job application for {headline}".format(headline=post.headline),
                        sender=(sender_formatted, app.config['MAIL_SENDER']),
                        bcc=[job_application.email, post.email])
                    flashmsg = "We sent your message to the candidate and copied you"
                msg.body = email_text
                msg.html = email_html
                mail.send(msg)
                job_application.replied_by = g.user
                db.session.commit()
        elif request.form.get('action') == 'ignore' and job_application.can_ignore():
            job_application.response = EMPLOYER_RESPONSE.IGNORED
            db.session.commit()
        elif request.form.get('action') == 'flag' and job_application.can_report():
            job_application.response = EMPLOYER_RESPONSE.FLAGGED
            db.session.commit()
        elif request.form.get('action') == 'unflag' and job_application.is_flagged():
            job_application.response = EMPLOYER_RESPONSE.NEW
            db.session.commit()

    if flashmsg:
        if request.is_xhr:
            return u'<p><strong>{}</strong></p>'.format(flashmsg)
        else:
            flash(flashmsg, 'interactive')

    return redirect(url_for('view_application', hashid=post.hashid, application=job_application.hashid), 303)


@app.route('/sticky/<hashid>', methods=['POST'], subdomain='<subdomain>')
@app.route('/sticky/<hashid>', methods=['POST'])
@lastuser.requires_permission('siteadmin')
def stickyjob(hashid):
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    stickyform = forms.StickyForm(obj=post)
    if stickyform.validate_on_submit():
        post.sticky = stickyform.sticky.data
        db.session.commit()
        if post.sticky:
            msg = "This listing has been made sticky."
        else:
            msg = "This listing is no longer sticky."
    else:
        msg = "Invalid submission"
    if request.is_xhr:
        return Markup('<p>' + msg + '</p>')
    else:
        flash(msg)
        return redirect(url_for('jobdetail', hashid=post.hashid), 303)


@app.route('/reject/<hashid>', methods=('GET', 'POST'), subdomain='<subdomain>')
@app.route('/reject/<hashid>', methods=('GET', 'POST'))
@lastuser.requires_permission('siteadmin')
def rejectjob(hashid):
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if post.status in [POSTSTATUS.DRAFT, POSTSTATUS.PENDING]:
        if post.edit_key not in session.get('userkeys', []):
            abort(403)
    if post.status in [POSTSTATUS.REJECTED, POSTSTATUS.WITHDRAWN, POSTSTATUS.SPAM]:
        abort(410)
    rejectform = forms.RejectForm()
    if rejectform.validate_on_submit():
        post.closed_datetime = datetime.utcnow()
        post.review_comments = rejectform.reason.data
        post.review_datetime = datetime.utcnow()
        post.reviewer = g.user

        if request.form.get('submit') == 'spam':
            flashmsg = "This job listing has been marked as spam."
            post.status = POSTSTATUS.SPAM
        else:
            flashmsg = "This job listing has been rejected."
            post.status = POSTSTATUS.REJECTED
            msg = Message(subject="About your job listing on Hasjob",
                recipients=[post.email])
            msg.body = render_template("reject_email.md", post=post)
            msg.html = markdown(msg.body)
            mail.send(msg)
        db.session.commit()
        if request.is_xhr:
            return "<p>%s</p>" % flashmsg
        else:
            flash(flashmsg, "interactive")
    elif request.method == 'POST' and request.is_xhr:
        return render_template('inc/rejectform.html', post=post, rejectform=rejectform)
    return redirect(url_for('jobdetail', hashid=post.hashid))


@app.route('/moderate/<hashid>', methods=('GET', 'POST'), subdomain='<subdomain>')
@app.route('/moderate/<hashid>', methods=('GET', 'POST'))
@lastuser.requires_permission('siteadmin')
def moderatejob(hashid):
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if post.status in [POSTSTATUS.DRAFT, POSTSTATUS.PENDING]:
        if post.edit_key not in session.get('userkeys', []):
            abort(403)
    if post.status in [POSTSTATUS.REJECTED, POSTSTATUS.WITHDRAWN, POSTSTATUS.SPAM]:
        abort(410)
    moderateform = forms.ModerateForm()
    if moderateform.validate_on_submit():
        post.closed_datetime = datetime.utcnow()
        post.review_comments = moderateform.reason.data
        post.review_datetime = datetime.utcnow()
        post.reviewer = g.user
        flashmsg = "This job listing has been moderated."
        post.status = POSTSTATUS.MODERATED
        msg = Message(subject="About your job listing on Hasjob",
            recipients=[post.email])
        msg.body = render_template("moderate_email.md", post=post)
        msg.html = markdown(msg.body)
        mail.send(msg)
        db.session.commit()
        if request.is_xhr:
            return "<p>%s</p>" % flashmsg
    elif request.method == 'POST' and request.is_xhr:
        return render_template('inc/moderateform.html', post=post, moderateform=moderateform)
    return redirect(url_for('jobdetail', hashid=post.hashid))


@app.route('/confirm/<hashid>', methods=('GET', 'POST'), subdomain='<subdomain>')
@app.route('/confirm/<hashid>', methods=('GET', 'POST'))
def confirm(hashid):
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    form = forms.ConfirmForm()
    if post.status in [POSTSTATUS.REJECTED, POSTSTATUS.SPAM]:
        abort(410)
    elif post.status in [POSTSTATUS.DRAFT, POSTSTATUS.PENDING]:
        if not (post.edit_key in session.get('userkeys', []) or post.admin_is(g.user)):
            abort(403)
    else:
        # Any other status: no confirmation required (via this handler)
        return redirect(url_for('jobdetail', hashid=post.hashid), code=302)
    if 'form.id' in request.form and form.validate_on_submit():
        # User has accepted terms of service. Now send email and/or wait for payment
        # Also (re-)set the verify key, just in case they changed their email
        # address and are re-verifying
        post.email_verify_key = random_long_key()
        msg = Message(subject="Confirmation of your job listing at Hasjob",
            recipients=[post.email])
        msg.body = render_template("confirm_email.md", post=post)
        msg.html = markdown(msg.body)
        mail.send(msg)
        post.email_sent = True
        post.status = POSTSTATUS.PENDING
        db.session.commit()

        try:
            session.get('userkeys', []).remove(post.edit_key)
            session.modified = True  # Since it won't detect changes to lists
        except ValueError:
            pass
        return render_template('mailsent.html', post=post)
    return render_template('confirm.html', post=post, form=form)


@app.route('/confirm/<hashid>/<key>', subdomain='<subdomain>')
@app.route('/confirm/<hashid>/<key>')
def confirm_email(hashid, key):
    # If post is in pending state and email key is correct, convert to published
    # and update post.datetime to utcnow() so it'll show on top of the stack
    # This function expects key to be email_verify_key, not edit_key like the others
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if post.status in [POSTSTATUS.REJECTED, POSTSTATUS.SPAM]:
        abort(410)
    elif post.status in [POSTSTATUS.CONFIRMED, POSTSTATUS.REVIEWED]:
        flash("This job listing has already been confirmed and published", "interactive")
        return redirect(url_for('jobdetail', hashid=post.hashid), code=302)
    elif post.status == POSTSTATUS.DRAFT:
        # This should not happen. The user doesn't have this URL until they
        # pass the confirm form
        return redirect(url_for('confirm', hashid=post.hashid), code=302)
    elif post.status == POSTSTATUS.PENDING:
        if key != post.email_verify_key:
            abort(403)
        else:
            if app.config.get('THROTTLE_LIMIT', 0) > 0:
                post_count = JobPost.query.filter(JobPost.email_domain == post.email_domain).filter(
                    JobPost.status > POSTSTATUS.PENDING).filter(
                        JobPost.datetime > datetime.utcnow() - timedelta(days=1)).count()
                if post_count > app.config['THROTTLE_LIMIT']:
                    flash(u"We have received too many listings with %s addresses in the last 24 hours. "
                        u"Listings are rate-limited per domain, so yours was not confirmed for now. "
                        u"Please try confirming again in a few hours."
                        % post.email_domain, category='info')
                    return redirect(url_for('index'))
            post.email_verified = True
            post.status = POSTSTATUS.CONFIRMED
            post.datetime = datetime.utcnow()
            if g.board:
                post.add_to(g.board)
            db.session.commit()
            if app.config['TWITTER_ENABLED']:
                try:
                    tweet.delay(post.headline, url_for('jobdetail', hashid=post.hashid,
                        _external=True), post.location)
                    flash("Congratulations! Your job listing has been published and tweeted",
                          "interactive")
                except:  # FIXME: Catch-all
                    flash("Congratulations! Your job listing has been published "
                          "(Twitter was not reachable for tweeting)", "interactive")
            else:
                flash("Congratulations! Your job listing has been published", "interactive")
    return redirect(url_for('jobdetail', hashid=post.hashid), code=302)


@app.route('/withdraw/<hashid>', methods=('GET', 'POST'), defaults={'key': None}, subdomain='<subdomain>')
@app.route('/withdraw/<hashid>/<key>', methods=('GET', 'POST'), subdomain='<subdomain>')
@app.route('/withdraw/<hashid>', methods=('GET', 'POST'), defaults={'key': None})
@app.route('/withdraw/<hashid>/<key>', methods=('GET', 'POST'))
def withdraw(hashid, key):
    post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    form = forms.WithdrawForm()
    if not ((key is None and g.user is not None and post.admin_is(g.user)) or (key == post.edit_key)):
        abort(403)
    if post.status == POSTSTATUS.WITHDRAWN:
        flash("Your job listing has already been withdrawn", "info")
        return redirect(url_for('index'), code=303)
    if post.status not in [POSTSTATUS.CONFIRMED, POSTSTATUS.REVIEWED]:
        flash("Your post cannot be withdrawn because it is not public", "info")
        return redirect(url_for('index'), code=303)
    if form.validate_on_submit():
        post.status = POSTSTATUS.WITHDRAWN
        post.closed_datetime = datetime.utcnow()
        db.session.commit()
        flash("Your job listing has been withdrawn and is no longer available", "info")
        return redirect(url_for('index'), code=303)
    return render_template("withdraw.html", post=post, form=form)


@app.route('/edit/<hashid>', methods=('GET', 'POST'), defaults={'key': None}, subdomain='<subdomain>')
@app.route('/edit/<hashid>/<key>', methods=('GET', 'POST'), subdomain='<subdomain>')
@app.route('/edit/<hashid>', methods=('GET', 'POST'), defaults={'key': None})
@app.route('/edit/<hashid>/<key>', methods=('GET', 'POST'))
def editjob(hashid, key, form=None, post=None, validated=False):
    if form is None:
        form = forms.ListingForm(request.form)
        form.job_type.choices = [(ob.id, ob.title) for ob in JobType.query.filter_by(public=True).order_by('seq')]
        form.job_category.choices = [(ob.id, ob.title) for ob in JobCategory.query.filter_by(public=True).order_by('seq')]
    if post is None:
        post = JobPost.query.filter_by(hashid=hashid).first_or_404()
    if not ((key is None and g.user is not None and post.admin_is(g.user)) or (key == post.edit_key)):
        abort(403)

    # Don't allow email address to be changed once its confirmed
    if post.status > POSTSTATUS.PENDING:
        no_email = True
    else:
        no_email = False

    if request.method == 'POST' and post.status > POSTSTATUS.PENDING:
        # del form.poster_name  # Deprecated 2013-11-20
        form.poster_email.data = post.email
    if request.method == 'POST' and (validated or form.validate()):
        form_description = bleach.linkify(bleach.clean(form.job_description.data, tags=ALLOWED_TAGS))
        form_perks = bleach.linkify(bleach.clean(form.job_perks_description.data, tags=ALLOWED_TAGS)) if form.job_perks.data else ''
        form_how_to_apply = form.job_how_to_apply.data
        form_email_domain = get_email_domain(form.poster_email.data)
        form_words = get_word_bag(u' '.join((form_description, form_perks, form_how_to_apply)))

        similar = False
        for oldpost in JobPost.query.filter(db.or_(
            db.and_(
                JobPost.email_domain == form_email_domain,
                JobPost.status.in_([POSTSTATUS.CONFIRMED, POSTSTATUS.REVIEWED,
                    POSTSTATUS.WITHDRAWN, POSTSTATUS.REJECTED])),
            JobPost.status == POSTSTATUS.SPAM)).filter(
                JobPost.datetime > datetime.utcnow() - agelimit).all():
            if oldpost.id != post.id:
                if oldpost.words:
                    s = SequenceMatcher(None, form_words, oldpost.words)
                    if s.ratio() > 0.6:
                        similar = True
                        break

        if similar:
            flash("This listing is very similar to an earlier listing. You may not relist the same job "
                "in less than %d days." % agelimit.days, category='interactive')
        else:
            post.headline = form.job_headline.data
            post.type_id = form.job_type.data
            post.category_id = form.job_category.data
            post.location = form.job_location.data
            post.relocation_assist = form.job_relocation_assist.data
            post.description = form_description
            post.perks = form_perks
            post.how_to_apply = form_how_to_apply
            post.company_name = form.company_name.data
            post.company_url = form.company_url.data
            post.hr_contact = form.hr_contact.data

            post.pay_type = form.job_pay_type.data
            if post.pay_type != PAY_TYPE.NOCASH:
                post.pay_currency = form.job_pay_currency.data
                post.pay_cash_min = form.job_pay_cash_min.data  # TODO: Sanitize
                post.pay_cash_max = form.job_pay_cash_max.data  # TODO: Sanitize
            else:
                post.pay_currency = None
                post.pay_cash_min = None
                post.pay_cash_max = None
            if form.job_pay_equity.data:
                post.pay_equity_min = form.job_pay_equity_min.data  # TODO: Sanitize
                post.pay_equity_max = form.job_pay_equity_max.data  # TODO: Sanitize
            else:
                post.pay_equity_min = None
                post.pay_equity_max = None

            if form.collaborators.data:
                post.admins = []
                userdata = lastuser.getuser_by_userids(form.collaborators.data)
                for userinfo in userdata:
                    if userinfo['type'] == 'user':
                        user = User.query.filter_by(userid=userinfo['buid']).first()
                        if not user:
                            # New user on Hasjob. Don't set username right now. It's not relevant
                            # until first login and we don't want to deal with conflicts
                            user = User(userid=userinfo['buid'], fullname=userinfo['title'])
                            db.session.add(user)
                        post.admins.append(user)

            # Allow name and email to be set only on non-confirmed posts
            if not no_email:
                # post.fullname = form.poster_name.data  # Deprecated 2013-11-20
                post.email = form.poster_email.data
                post.email_domain = form_email_domain
                post.md5sum = md5sum(post.email)
            # To protect from gaming, don't allow words to be removed in edited listings once the post
            # has been confirmed. Just add the new words.
            if post.status >= POSTSTATUS.CONFIRMED:
                prev_words = post.words or u''
            else:
                prev_words = u''
            post.words = get_word_bag(u' '.join((prev_words, form_description, form_perks, form_how_to_apply)))

            post.language = identify_language(post)

            if post.status == POSTSTATUS.MODERATED:
                post.status = POSTSTATUS.CONFIRMED

            if request.files['company_logo']:
                # The form's validator saved the processed logo in g.company_logo.
                thumbnail = g.company_logo
                logofilename = uploaded_logos.save(thumbnail, name='%s.' % post.hashid)
                post.company_logo = logofilename
            else:
                if form.company_logo_remove.data:
                    post.company_logo = None

            db.session.commit()
            userkeys = session.get('userkeys', [])
            userkeys.append(post.edit_key)
            session['userkeys'] = userkeys
            session.permanent = True
            return redirect(url_for('jobdetail', hashid=post.hashid), code=303)
    elif request.method == 'POST':
        flash("Please correct the indicated errors", category='interactive')
    elif request.method == 'GET':
        # Populate form from model
        form.job_headline.data = post.headline
        form.job_type.data = post.type_id
        form.job_category.data = post.category_id
        form.job_location.data = post.location
        form.job_relocation_assist.data = post.relocation_assist
        form.job_description.data = post.description
        form.job_perks.data = True if post.perks else False
        form.job_perks_description.data = post.perks
        form.job_how_to_apply.data = post.how_to_apply
        form.company_name.data = post.company_name
        form.company_url.data = post.company_url
        # form.poster_name.data = post.fullname  # Deprecated 2013-11-20
        form.poster_email.data = post.email
        form.hr_contact.data = int(post.hr_contact or False)
        form.collaborators.data = [u.userid for u in post.admins]

        form.job_pay_type.data = post.pay_type
        form.job_pay_currency.data = post.pay_currency
        form.job_pay_cash_min.data = post.pay_cash_min
        form.job_pay_cash_max.data = post.pay_cash_max
        form.job_pay_equity.data = bool(post.pay_equity_min and post.pay_equity_max)
        form.job_pay_equity_min.data = post.pay_equity_min
        form.job_pay_equity_max.data = post.pay_equity_max

    return render_template('postjob.html', form=form, no_email=no_email,
        getuser_autocomplete=lastuser.endpoint_url(lastuser.getuser_autocomplete_endpoint),
        getuser_userids=lastuser.endpoint_url(lastuser.getuser_userids_endpoint))


@app.route('/new', methods=('GET', 'POST'), subdomain='<subdomain>')
@app.route('/new', methods=('GET', 'POST'))
def newjob():
    form = forms.ListingForm()
    if not g.user:
        if request.method == 'POST' and request.form.get('form.id') == 'newheadline':
            session['headline'] = form.job_headline.data
        return redirect(url_for('login', next=url_for('newjob'),
            message=u"Hasjob now requires you to login before listing a job. Please login as yourself."
                u" We'll add details about your company later"))
    else:
        if g.user.blocked:
            flash("Your account has been blocked from listing jobs", category='info')
            return redirect(url_for('index'), code=303)
        if 'headline' in session:
            if request.method == 'GET':
                form.job_headline.data = session.pop('headline')
            else:
                session.pop('headline')

    form.job_type.choices = [(ob.id, ob.title) for ob in JobType.query.filter_by(public=True).order_by('seq')]
    form.job_category.choices = [(ob.id, ob.title) for ob in JobCategory.query.filter_by(public=True).order_by('seq')]
    if request.method == 'GET' or (request.method == 'POST' and request.form.get('form.id') == 'newheadline'):
        if g.user:
            # form.poster_name.data = g.user.fullname  # Deprecated 2013-11-20
            form.poster_email.data = g.user.email
    if request.method == 'POST' and request.form.get('form.id') != 'newheadline' and form.validate():
        # POST request from new job page, with successful validation
        # Move it to the editjob page for handling here forward
        post = JobPost(hashid=unique_hash(JobPost),
                       ipaddr=request.environ['REMOTE_ADDR'],
                       useragent=request.user_agent.string,
                       user=g.user)
        db.session.add(post)
        return editjob(post.hashid, post.edit_key, form, post, validated=True)
    elif request.method == 'POST' and request.form.get('form.id') != 'newheadline':
        # POST request from new job page, with errors
        flash("Please correct the indicated errors", category='interactive')

    # Render page. Execution reaches here under three conditions:
    # 1. GET request, page loaded for the first time
    # 2. POST request from main page's Post a Job box
    # 3. POST request from this page, with errors
    return render_template('postjob.html', form=form, no_removelogo=True,
        getuser_autocomplete=lastuser.endpoint_url(lastuser.getuser_autocomplete_endpoint),
        getuser_userids=lastuser.endpoint_url(lastuser.getuser_userids_endpoint))

########NEW FILE########
__FILENAME__ = login
# -*- coding: utf-8 -*-

from flask import g, Response, redirect, flash
from coaster.views import get_next_url

from .. import app, lastuser
from ..signals import signal_login, signal_logout
from ..models import db


@app.route('/login')
@lastuser.login_handler
def login():
    return {'scope': 'id email phone organizations'}


@app.route('/logout')
@lastuser.logout_handler
def logout():
    flash(u"You are now logged out", category='info')
    signal_logout.send(app, user=g.user)
    return get_next_url()


@app.route('/login/redirect')
@lastuser.auth_handler
def lastuserauth():
    # Board.update_from_user(g.user, db.session, make_user_profiles=False, make_org_profiles=False)
    signal_login.send(app, user=g.user)
    db.session.commit()
    return redirect(get_next_url())


@app.route('/login/notify', methods=['POST'])
@lastuser.notification_handler
def lastusernotify(user):
    # Board.update_from_user(user, db.session, make_user_profiles=False, make_org_profiles=False)
    db.session.commit()


@lastuser.auth_error_handler
def lastuser_error(error, error_description=None, error_uri=None):
    if error == 'access_denied':
        flash("You denied the request to login", category='error')
        return redirect(get_next_url())
    return Response(u"Error: %s\n"
                    u"Description: %s\n"
                    u"URI: %s" % (error, error_description, error_uri),
                    mimetype="text/plain")

########NEW FILE########
__FILENAME__ = static
from flask import render_template
from hasjob import app


@app.route('/tos', subdomain='<subdomain>')
@app.route('/tos')
def terms_of_service():
    return render_template('tos.html')

########NEW FILE########
__FILENAME__ = _version
__all__ = ['__version__', '__version_info__']

__version__ = '0.3.0'
__version_info__ = tuple([int(num) if num.isdigit() else num for num in __version__.replace('-', '.', 1).split('.')])

########NEW FILE########
__FILENAME__ = settings-sample
#: The title of this site
SITE_TITLE = 'Job Board'
#: TypeKit code for fonts
TYPEKIT_CODE = ''
#: Google Analytics code UA-XXXXXX-X
GA_CODE = ''
#: Asset server (optional)
ASSET_SERVER = ''
#: LogNormal API key for page load performance metrics
LOGNORMAL_API_KEY = ''
#: Database backend
SQLALCHEMY_DATABASE_URI = 'sqlite:///test.db'
#: Secret key
SECRET_KEY = 'make this something random'
#: Timezone
TIMEZONE = 'Asia/Kolkata'
#: Server host name (and port if not 80/443)
SERVER_NAME = 'hasjob.local'
#: Static resource subdomain (defaults to 'static')
STATIC_SUBDOMAIN = 'static'
#: Upload path
UPLOADED_LOGOS_DEST = '/tmp/uploads'
#: Search index path
SEARCH_INDEX_PATH = '/tmp/search'
#: Mail settings
#: MAIL_FAIL_SILENTLY : default True
#: MAIL_SERVER : default 'localhost'
#: MAIL_PORT : default 25
#: MAIL_USE_TLS : default False
#: MAIL_USE_SSL : default False
#: MAIL_USERNAME : default None
#: MAIL_PASSWORD : default None
#: DEFAULT_MAIL_SENDER : default None
MAIL_FAIL_SILENTLY = False
MAIL_SERVER = 'localhost'
# Mail sender for crash reports and other automated mail
DEFAULT_MAIL_SENDER = 'Hasjob <test@example.com>'
MAIL_DEFAULT_SENDER = DEFAULT_MAIL_SENDER
# Mail sender for job application responses (email address only)
MAIL_SENDER = 'test@example.com'
#: Logging: recipients of error emails
ADMINS = []
#: Log file
LOGFILE = 'error.log'
#: Use SSL for some URLs
USE_SSL = False
#: Twitter integration (register as a "client" app)
TWITTER_ENABLED = False
TWITTER_CONSUMER_KEY = ''
TWITTER_CONSUMER_SECRET = ''
TWITTER_ACCESS_KEY = ''
TWITTER_ACCESS_SECRET = ''
#: Bit.ly integration for short URLs
BITLY_USER = ''
BITLY_KEY = ''
#: Access key for periodic server-only tasks
PERIODIC_KEY = ''
#: Throttle limit for email domain
THROTTLE_LIMIT = 5
SUPPORT_EMAIL = 'person@example.com'

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-
#: The title of this site
SITE_TITLE = 'Job Board'
#: TypeKit code for fonts
TYPEKIT_CODE = ''
#: Google Analytics code UA-XXXXXX-X
GA_CODE = ''
#: Database backend
SQLALCHEMY_DATABASE_URI = 'sqlite:///'
#: Secret key
SECRET_KEY = 'make this something random'
#: Timezone
TIMEZONE = 'Asia/Kolkata'
#: Static resource subdomain (defaults to 'static')
STATIC_SUBDOMAIN = 'static'
#: Upload path
UPLOADED_LOGOS_DEST = '/tmp/uploads'
#: Search index path
SEARCH_INDEX_PATH = '/tmp/search'
#: Mail settings
#: MAIL_FAIL_SILENTLY : default True
#: MAIL_SERVER : default 'localhost'
#: MAIL_PORT : default 25
#: MAIL_USE_TLS : default False
#: MAIL_USE_SSL : default False
#: MAIL_USERNAME : default None
#: MAIL_PASSWORD : default None
#: DEFAULT_MAIL_SENDER : default None
MAIL_FAIL_SILENTLY = False
MAIL_SERVER = 'localhost'
# Mail sender for crash reports and other automated mail
DEFAULT_MAIL_SENDER = 'Hasjob <test@example.com>'
MAIL_DEFAULT_SENDER = DEFAULT_MAIL_SENDER
# Mail sender for job application responses (email address only)
MAIL_SENDER = 'test@example.com'
#: Logging: recipients of error emails
ADMINS = []
#: Log file
LOGFILE = 'error.log'
#: Use SSL for some URLs
USE_SSL = False
#: Twitter integration (register as a "client" app)
TWITTER_ENABLED = False
TWITTER_CONSUMER_KEY = ''
TWITTER_CONSUMER_SECRET = ''
TWITTER_ACCESS_KEY = ''
TWITTER_ACCESS_SECRET = ''
#: Bit.ly integration for short URLs
BITLY_USER = ''
BITLY_KEY = ''
#: Access key for periodic server-only tasks
PERIODIC_KEY = ''
#: Throttle limit for email domain
THROTTLE_LIMIT = 5
SUPPORT_EMAIL = 'support@hasgeek.com'
#: Words banned in the title and their error messages
BANNED_WORDS = [
    [['awesome'], u'We’ve had a bit too much awesome around here lately. Got another adjective?'],
    [['rockstar', 'rock star', 'rock-star'], u'You are not rich enough to hire a rockstar. Got another adjective?'],
    [['superstar', 'super star'], u'Everyone around here is a superstar. The term is redundant.'],
    [['kickass', 'kick ass', 'kick-ass', 'kicka$$', 'kick-a$$', 'kick a$$'], u'We don’t condone kicking asses around here. Got another adjective?'],
    [['ninja'], u'Ninjas kill people. We can’t allow that. Got another adjective?'],
    [['urgent', 'immediate', 'emergency'], u'Sorry, we can’t help with urgent or immediate requirements. Geeks don’t grow on trees'],
    [['passionate'], u'Passion is implicit. Why even ask? Try another adjective?'],
    [['amazing'], u'Everybody’s amazing around here. The adjective is redundant.'],
    [['fodu'], u'We don’t know what you mean, but that sounds like a dirty word. Got another adjective?'],
    [['sick'], u'Need an ambulance? Call 102, 108, 112 or 1298. One of those should work.'],
    [['killer'], u'Murder is illegal. Don’t make us call the cops.'],
    [['iit', 'iitian', 'iit-ian', 'iim'], u'Q: How do you know someone is from IIT/IIM? A: They remind you all the time. Don’t be that person.'],
]

#: LastUser server
LASTUSER_SERVER = 'https://auth.hasgeek.com/'
#: LastUser client id
LASTUSER_CLIENT_ID = ''
#: LastUser client secret
LASTUSER_CLIENT_SECRET = ''

########NEW FILE########
__FILENAME__ = testing
SQLALCHEMY_DATABASE_URI = 'sqlite://'
PERIODIC_KEY = '12345'

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python

from coaster.manage import init_manager

from hasjob.models import db
from hasjob import app, init_for
from hasjob.search import configure_once as search_configure


def configure(env='dev'):
    """Configure Hasjob's search indexing"""
    init_for(env)
    search_configure()


if __name__ == '__main__':
    db.init_app(app)
    manager = init_manager(app, db, init_for)
    manager.command(configure)

    manager.run()

########NEW FILE########
__FILENAME__ = rqdev
from urlparse import urlparse

from hasjob import init_for, app

init_for('dev')

REDIS_URL = app.config.get('REDIS_URL', 'redis://localhost:6379/0')

# REDIS_URL is not taken by setup_default_arguments function of rq/scripts/__init__.py
# so, parse it into pieces and give it

r = urlparse(REDIS_URL)
REDIS_HOST = r.hostname
REDIS_PORT = r.port
REDIS_PASSWORD = r.password
REDIS_DB = 0

########NEW FILE########
__FILENAME__ = rqinit
from urlparse import urlparse

from hasjob import init_for, app

init_for('production')
REDIS_URL = app.config.get('REDIS_URL', 'redis://localhost:6379/0')

# REDIS_URL is not taken by setup_default_arguments function of rq/scripts/__init__.py
# so, parse that into pieces and give it

r = urlparse(REDIS_URL)
REDIS_HOST = r.hostname
REDIS_PORT = r.port
REDIS_PASSWORD = r.password
REDIS_DB = 0

########NEW FILE########
__FILENAME__ = runserver
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from hasjob import app, init_for, models
from hasjob.models import db
from hasjob.search import configure as search_configure
from hasjob.uploads import configure as uploads_configure

if __name__ == '__main__':

    import sys
    init_for('dev')
    # Seed with sample data
    with app.test_request_context():
        if models.JobType.query.count() == 0:
            print >> sys.stderr, "Adding some job types"
            db.session.add(models.JobType(seq=10, name=u'fulltime', title=u'Full-time employment'))
            db.session.add(models.JobType(seq=20, name=u'contract', title=u'Short-term contract'))
            db.session.add(models.JobType(seq=30, name=u'freelance', title=u'Freelance or consulting'))
            db.session.add(models.JobType(seq=40, name=u'volunteer', title=u'Volunteer contributor'))
            db.session.add(models.JobType(seq=50, name=u'partner', title=u'Partner for a venture'))
            db.session.commit()
        if models.JobCategory.query.count() == 0:
            print >> sys.stderr, "Adding some job categories"
            db.session.add(models.JobCategory(seq=10, name=u'programming', title=u'Programming'))
            db.session.add(models.JobCategory(seq=20, name=u'ux', title=u'Interaction Design'))
            db.session.add(models.JobCategory(seq=30, name=u'design', title=u'Graphic Design'))
            db.session.add(models.JobCategory(seq=40, name=u'testing', title=u'Testing'))
            db.session.add(models.JobCategory(seq=50, name=u'sysadmin', title=u'Systems Administration'))
            db.session.add(models.JobCategory(seq=60, name=u'business', title=u'Business/Management'))
            db.session.add(models.JobCategory(seq=70, name=u'edit', title=u'Writer/Editor'))
            db.session.add(models.JobCategory(seq=80, name=u'support', title=u'Customer Support'))
            db.session.add(models.JobCategory(seq=90, name=u'mobile', title=u'Mobile (iPhone, Android, other)'))
            db.session.commit()
        if models.ReportCode.query.count() == 0:
            print >> sys.stderr, "Adding some report codes"
            db.session.add(models.ReportCode(seq=10, name=u'spam', title=u'Spam, not a job listing'))
            db.session.add(models.ReportCode(seq=20, name=u'fake', title=u'Appears to be a fake listing'))
            db.session.add(models.ReportCode(seq=30, name=u'anon', title=u'Organization is not clearly identified'))
            db.session.add(models.ReportCode(seq=40, name=u'unclear', title=u'Job position is not properly described'))
            db.session.commit()
    app.run('0.0.0.0', debug=True)

########NEW FILE########
__FILENAME__ = shell
#!/usr/bin/env python
import os
import readline
from pprint import pprint

from flask import *
from hasjob import *

os.environ['PYTHONINSPECT'] = 'True'

########NEW FILE########
__FILENAME__ = metarefresh
import magic
import mimetypes
import requests
from lxml import html


def test_for_meta_redirections(r):
    mime = magic.from_buffer(r.content, mime=True)
    extension = mimetypes.guess_extension(mime)
    if extension == '.html':
        html_tree = html.fromstring(r.text)
        try:
            attr = html_tree.xpath("//meta[translate(@http-equiv, 'REFSH', 'refsh') = 'refresh']/@content")[0]
            wait, text = attr.split(";")
            if text.lower().startswith("url="):
                url = text[4:].strip()
            else:
                url = text.strip()
            return True, url
        except IndexError:
            return False, None
    else:
        return False, None


def follow_redirections(r, s):
    """
    Recursive function that follows meta refresh redirections if they exist.
    """
    redirected, url = test_for_meta_redirections(r)
    if redirected:
        r = follow_redirections(s.get(url), s)
    return r


def final_url(url):
    s = requests.session()
    r = s.get(url)
    # test for and follow meta redirects
    return follow_redirections(r, s).url


if __name__ == '__main__':
    print final_url('http://localhost:8000/')

########NEW FILE########
__FILENAME__ = website
import sys
import os.path
sys.path.insert(0, os.path.dirname(__file__))

from coaster import logging
from hasjob import init_for, app as application
init_for('prod')

########NEW FILE########
