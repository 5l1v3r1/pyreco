Here is a little sample GPU program that flashes the OK or status light.

# Installation:

It runs in place of bootcode.bin.  

Download the blinker01.bin here and replace the usual bootcode.bin file on
the SD card you use to boot your pi.  Don't forget to keep a backup of your old bootcode.bin so you can set it back to
normal operation!

Now when the GPU starts up, it looks for a program called bootcode.bin - so you'll have to rename blinker01.bin to bootcode.bin.

# How it works:

The boot routine in the GPU doesn't use the first 0x200 bytes as code, so we fill it with padding:

<pre>
00000000: 0000 0000 0000 0000: ..     :0000           ; zero bit instruction
00000002: 0000 0000 0000 0000: ..     :0000           ; zero bit instruction
...
000001fe: 0000 0000 0000 0000: ..     :0000           ; zero bit instruction
</pre>

Now we configure the GPIO so that the pin driving the status led is configured as an output signal by writing to GPFSEL1.
(see page 90 of http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf).  Notice how the GPU
uses bus addresses starting at 0x7e000000.

<pre>
00000200: 1110 1000 0000 0001: .... ~ :e801 0004 7e20 ; mov r1, #0x7e200004
00000206: 0010 0000 0001 0000: .      :2010           ; ld  r0, 0x00(r1)
00000208: 1110 1000 1110 0000: ...... :e8e0 ffff ffe3 ; and r0, #0xffe3ffff
0000020e: 1110 1001 1010 0000: ...... :e9a0 0000 0004 ; or r0, r0, #0x00040000
00000214: 0011 0000 0001 0000: .0     :3010           ; st  r0, 0x00(r1)
</pre>

Set up some registers ready for the main loop:
<pre>
00000216: 1110 1000 0000 0001: .... ~ :e801 001c 7e20 ; mov r1, #0x7e20001c
0000021c: 1110 1000 0000 0010: ..(. ~ :e802 0028 7e20 ; mov r2, r0, #0x7e200028
00000222: 1110 1000 0000 0011: ...... :e803 0000 0001 ; mov r3, r0, #0x00010000
</pre>

Now lets begin the main loop.  First we turn the led off (or on depending on active high/low - I forget :) ) by writing to GPSET0 (0x7E20001C) to set the output high.

<pre>
00000228: 0011 0000 0001 0011: .0     :3013           ; st  r3, 0x00(r1)
</pre>

Loop to delay for a while:
<pre>
0000022a: 1110 1000 0000 0000: ...... :e800 0000 0000 ; mov r0, #0x00000000
00000230: 1110 1000 0100 0000: @..... :e840 0001 0000 ; add r0, r0, #0x00000001
00000236: 1110 1001 0100 0000: @..... :e940 0000 0010 ; cmp r0, r0, #0x00100000
0000023c: 0001 1000 1111 1010: ..     :18fa           ; bne 0x00000230
</pre>

Turn the led on (or off depending on active high/low - I forget :) ) by writing to GPCLR0 (0x7e200028) to clear the output low.
<pre>
0000023e: 0011 0000 0010 0011: #0     :3023           ; st  r3, 0x00(r2)
</pre>

Loop to delay for a while:
<pre>
00000240: 1110 1000 0000 0000: ...... :e800 0000 0000 ; mov r0, #0x00000000
00000246: 1110 1000 0100 0000: @..... :e840 0001 0000 ; add r0, r0, #0x00000001
0000024c: 1110 1001 0100 0000: @..... :e940 0000 0010 ; cmp r0, r0, #0x00100000
00000252: 0001 1000 1111 1010: ..     :18fa           ; bne 0x00000246
</pre>

Loop back to do it all again:
<pre>
00000254: 0001 1111 0110 1010: j.     :1f6a           ; b 0x00000228
</pre>

# Show Boot Environment

This little program shows the values of the general purpose registers after the internal bootrom has loaded and
jumped into bootcode.bin.

## bootcode.bin

The values are:

    r0:  80000200
    r1:  ffffffff
    r2:  7ee02000
    r3:  20000008
    r4:  00000000
    r5:  7e200080
    r6:  00000000
    r7:  00000000
    r8:  00000000
    r9:  00000000
    r10: 00000000
    r11: 00000000
    r12: 00000001
    r13: 00000000
    r14: 000010c0
    r15: 00000000
    r16: 7e000080
    r17: 0001ef40
    r18: 80000000
    r19: 60008124
    r20: 00000000
    r21: 00000000
    r22: 00000000
    r23: 00000000
    r24: 60008000 ; cb - base pointer
    r25: 6000865c ; sp - stack pointer
    r26: 60003602 ; lr - link register
    r27: 00000000
    r28: 00000000 ; ssp
    r29: 00000000
    r30: 2000000a ; sr - status register
    r31: 80000200 ; pc - program counter

According to the BCM2835 ARM Peripherals manual, address ranges are:

    00000000 - 3fffffff  ; L1 and L2 cached
    40000000 - 7fffffff  ; L2 cache coherent (non allocating)
    80000000 - bfffffff  ; L2 cached only
    c0000000 - ffffffff  ; Direct uncached

Therefore bootcode.bin is loaded and executing from the L2 cache at 0x80000000.

## loader.bin

When used in place of the old loader.bin (for the old boot chain that used bootcode.bin to load loader.bin and
then start.elf), the values are:

    r0:  c7400200
    r1:  00000000
    r2:  7ee02000
    r3:  00000002
    r4:  ffffb001
    r5:  7ee02000
    r6:  00000000
    r7:  00000001
    r8:  00000000
    r9:  c7400200
    r10: 00000000
    r11: 00000000
    r12: 00000001
    r13: 00000000
    r14: 000010c0
    r15: 00000000
    r16: 7e000080
    r17: 0001ef40
    r18: 80000000
    r19: 60008124
    r20: 00000000
    r21: 00000000
    r22: 00000000
    r23: 00000000
    r24: 80004000 ; bp
    r25: 8000418c ; sp
    r26: 80000d96 ; lr
    r27: 00000000
    r28: 00000000 ; ssp
    r29: 00000000
    r30: 2000000a ; sr
    r31: c7400200 ; pc

Here is a little sample GPU program that dumps the internal bootrom.  The bootrom is the code executed by the GPU on reset.
As usual, this information is provided for those interested in interoperability.  Neither the dump nor a disassembly are provided here as the original binary is subject to copyright.  Please use this tool responsibily and respect the rights of the owner.  In territories where DMCA or similar acts are in force you should avoid any circumvention activities.

# Installation:

It runs in place of bootcode.bin.  

1. Download dumpbootrom.bin
2. Rename it bootcode.bin
3. Rename your existing bootcode.bin on your SD card, say _bootcode.bin.
4. Copy the replacement bootcode.bin (dumpbootrom.bin) onto your SD card.
5. Boot up your Pi and use a terminal at 115200,n,8 to grab the hex dump.
6. Cut and paste the output into a tool to convert it to raw bytes (eg. dump2bin < bootrom.txt).
7. Subject to the territory you are in, you may which to disassemble it using http://hermanhermitage.github.com/videocore-disjs/dis.html

Note: It dumps the rom as little endian 32 bit words, and this may not be in the order you are expecting.  Eg:

As little endian 32 bit words:

  60000000: 00010203 04050607 08090a0b 0c0d0e0f
  ...

As bytes:

  60000000: 03 02 01 00 07 06 05 04 0b 0a 09 08 0f 0e 0d 0c
  ...


IDA Pro plugin for Videocore IV, by Jan Nordholz.

<pre>
Disclaimer:

This is a independent documentation project based on a combination of static analysis
and trial and error on real hardware.  This work is 100% independent from and not
sanctioned by or connected with Broadcom or its agents.

No Broadcom documents or materials were used beyond those publically available 
(see Referenced Materials).

This work was undertaken and the information provided for non commercial use on the 
expectation that hobbyists of all ages will find the details useful for understanding 
and working with their Raspberry Pi hardware.

The hope is that Broadcom will be flattered by the interest in the device and
understand the benefits of opening up understanding to a larger audience of 
potential customers and developers.

Broadcom should be commended with making their SoC available for a project as 
exciting as the Raspberry Pi.

The intent is that no copyrighted materials are contained in this repository.  
</pre>

Introduction
==
Documentation and samples on the VideoCore IV instruction set as used in the BCM SoC used in the Raspberry Pi.

For more information on the Raspberry Pi, see the foundation's site at http://raspberrypi.org,
or the embedded linux wiki at http://elinux.org/R-Pi_Hub.

Active discussions take place on IRC (freenode) on #raspberrypi-internals, #raspberrypi-osdev, #raspberrypi-dev, 
and #raspberrypi.

There is a raspberrypi-internals mailing list, you can subscribe at <a href="http://www.freelists.org/list/raspi-internals">mailing list page at
freelists.org</a>.

We are in a very early stage of understanding of the device.  At this stage we only have Serial IO and GPIO for
flashing things like the status led.  You will need to attach a terminal to the Mini UART on the GPIO connector.
For more details see "Getting started" below.  

It is now possibly to use VideoCore Kernels from Userland / Linux, 
see https://github.com/hermanhermitage/videocoreiv/wiki/VideoCore-IV-Kernels-under-Linux.  Our understanding of the
Videocore Processor is nearing completion, and it is an excellent target for integer SIMD and DSP kernels.  Essentially,
it can be used for 16 way SIMD processing of 8, 16 and 32 bit integer values.
 
**Breaking News** Work has begun documenting the RaspberryPi's QPU (Shader processor) at https://github.com/hermanhermitage/videocoreiv-qpu.
This has the potential to unleash the full 24 GFLOPS power of the RaspberryPi for computation.

#### Videocore IV Community and Resources:

- Volker Barthelmann has been adding Videocore IV to his tool chain and has a preliminary preview of his vasm assembler at http://www.ibaug.de/vasm/vasm.tar.gz, and vcc compiler at http://www.ibaug.de/vbcc/vbcc_vc4.tar.gz.

- David Given is adding Videocore IV support to ACK compiler & tool chain at http://tack.hg.sourceforge.net:8000/hgroot/tack/tack
in the dtrg-videocore branch.

- phire's https://github.com/phire/llvm repo contains some early work on porting llvm to videocore, and is ripe for
someone to grab and continue.  Phire has recently restarted work on this project.

- mm120's https://github.com/mm120/binutils-vc4/tree/vc4 repo is a work in progress adding videocore support to
gnu binutils.  It seems to be coming along nicely, and I will add some prebuilt binaries for Linux, OSX, Windows and
RPi/Linux to github soon.

- thubble's https://github.com/thubble/vcdevtools, https://github.com/thubble/videocore-elf-dis and 
https://github.com/thubble/binutils-vc4/tree/vc4 repos cover a videocore disassembler (C#), a preliminary assembler (C)
and a bootloader (asm) that can receive code via UART.  thubble is particularly focussed on documenting the instructions of
the integer vector processing unit (PPU).

- mgottschlag's https://github.com/mgottschlag/resim and https://github.com/mgottschlag/vctools repos are focussed
on tools and information for reverse engineering the bcm2835's hardware registers and functional blocks.  mgottschlag
is generating register access traces by simulating code sequencies on a remote computer running a videocore emulator and
forwarding them to a real bcm2835 running a small monitor.

- dwelch67's https://github.com/dwelch67/rpigpu repo is focussed on bare metal samples written in C.  dwelch67 has two
experimental binary translators targeting the videocore instruction set.  one translates mips to videocore and the
other translates arm thumb to videocore.

Documentation:
==
1. Getting started:    https://github.com/hermanhermitage/videocoreiv/wiki/Getting-Started
2. Instruction set:    https://github.com/hermanhermitage/videocoreiv/wiki/VideoCore-IV-Programmers-Manual
3. Hardware regs:      
  * https://github.com/hermanhermitage/videocoreiv/wiki/Register-Documentation and 
  * https://github.com/hermanhermitage/videocoreiv/wiki/MMIO-Register-map.
4. Kernels from Linux: https://github.com/hermanhermitage/videocoreiv/wiki/VideoCore-IV-Kernels-under-Linux
5. Performance Issues: https://github.com/hermanhermitage/videocoreiv/wiki/VideoCore-IV-Performance-Considerations
6. 3d Pipeline Overview:        https://github.com/hermanhermitage/videocoreiv/wiki/VideoCore-IV-3d-Graphics-Pipeline
7. QPU Shader Processors (24 GFLOPS):    https://github.com/hermanhermitage/videocoreiv-qpu

Methodology:
==
All information here has been obtained solely by a combination of:

1. Static analysis.
2. Experimentation on a Raspberry Pi.
3. Discussions on #raspberrypi-osdev and #raspberrypi-internals.

All activities were undertaken on a Raspberry Pi running Debian.

Those interested in the legal issues involved with reverse engineering activities, please review:

1. https://www.eff.org/issues/coders/reverse-engineering-faq
2. http://www.chillingeffects.org/reverse/faq.cgi
3. http://en.wikipedia.org/wiki/Reverse_engineering

We do not accept materials nor publish materials relating to DRM or its circumvention.

Referenced Materials
==
## Software and Binaries
### Official RasPi firmware and blobs
Available at https://github.com/raspberrypi/firmware/tree/master/boot.  Releases after May the 10th 2012 are
accompanied by a LICENSE.broadcom readme file containing copyright notice, a disclaimer and guidelines for use.
Prior to this date the readme was not present.

### Debian "Squeeze" Distribution
The distribution debian6-19-04-2012.zip from http://www.raspberrypi.org/downloads was used a development platform for
the majority of the work you find here.

## Data Sheets
2. BCM2835 ARM Peripherals data sheet at http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf

## Patents and Patent Applications

The original Alphamosaic patents and patent applications provide a wealth of information for understanding the
structure of the VideoCore instruction set and architecture.  Whilst the instruction encodings are different, and
only a limited range of instructions are indicated they prove an invaluable reference for understanding
the design space the engineers were exploring.

The newer Broadcom SoC patents and applications provide detailed information on how the VideoCore has been been
integrated into a broader platform setting.  They are invaluable for gaining a deeper insight into the additional
function units present in the BCM2835 and how they fit together.

### Patent Applications on Broadcom SoC Method and Systems
  * [US20060184987](http://www.google.com/patents/US20060184987)  Intelligent Dma in a Mobile Multimedia Processor Supporting Multiple Display Formats
  * [US20080291208](http://www.google.com/patents/US20080291208)	Method and System for Processing Data Via a 3d Pipeline Coupled to a Generic Video Processing Unit
  * [US20080292216](http://www.google.com/patents/US20080292216)	Method and System for Processing Images using Variable Sized Tiles
  * [US20080292219](http://www.google.com/patents/US20080292219)	Method and System for an Image Sensor Pipeline on a Mobile Imaging Device
  * [US20090232347](http://www.google.com/patents/US20090232347)	Method and System for Inserting Software Processing In a Hardware Image Sensor Pipeline
  * [US20110148901](http://www.google.com/patents/US20110148901)	Method and System for Tile Mode Renderer With Coordinate Shader
  * [US20110154307](http://www.google.com/patents/US20110154307)	Method and System for Utilizing Data Flow Graphs to Compile Shaders
  * [US20110154377](http://www.google.com/patents/US20110154377)	Method and System for Reducing Communication During Video Processing Utilizing Merge Buffering
  * [US20110216069](http://www.google.com/patents/US20110216069)	Method and System for Compressing Tile Lists Used for 3d Rendering
  * [US20110221743](http://www.google.com/patents/US20110221743)	Method and System for Controlling a 3d Processor Using a Control List in Memory
  * [US20110227920](http://www.google.com/patents/US20110227920)	Method and System for a Shader Processor With Closely Couple Peripherals
  * [US20110242113](http://www.google.com/patents/US20110242113)	Method and System for Processing Pixels Utilizing Scoreboarding
  * [US20110242344](http://www.google.com/patents/US20110242344)	Method and System for Determining How to Handle Processing of an Image Based Motion
  * [US20110242427](http://www.google.com/patents/US20110242427)	Method and System for Providing 1080P Video with 32 Bit Mobile DDR Memory
  * [US20110249744](http://www.google.com/patents/US20110249744)	Method and System for Video Processing Utilizing Scalar Cores and a Single Vector Core
  * [US20110254995](http://www.google.com/patents/US20110254995)	Method and System for Mitigating Seesawing Effect During Autofocus
  * [US20110261059](http://www.google.com/patents/US20110261059)	Method and System for Decomposing Complex Shapes Into Curvy RHTS For Rasterization
  * [US20110261061](http://www.google.com/patents/US20110261061)	Method and System for Processing Image Data on a Per Tile Basis in an Image Sensor Pipeline
  * [US20110264902](http://www.google.com/patents/US20110264902)      Method and System For Suspending Video Processor and Saving Processor State in SDRAM Utilizing a Core Processor 
  * [US20110279702](http://www.google.com/patents/US20110279702)	Method and System for Providing A Programmable and Flexible Image Sensor Pipeline For Multiple Input Patterns

### Patents on the baseline Alphamosaic processor
  * [US7028143](http://www.google.com/patents/US7028143)  Narrow/Wide Cache
  * [US7036001](http://www.google.com/patents/US7036001)	Vector Processing System
  * [US7457941](http://www.google.com/patents/US7457941)	Vector Processing System
  * [US7043618](http://www.google.com/patents/US7043618)	System for Memory Access in a Data Processor
  * [US7107429](http://www.google.com/patents/US7107429)	Data Access in a Processor
  * [US7069417](http://www.google.com/patents/US7069417)	Vector Processing System, 
  * [US7818540](http://www.google.com/patents/US7818540)	Vector Processing System
  * [US7080216](http://www.google.com/patents/US7080216)	Data Access in a Processor
  * [US7130985](http://www.google.com/patents/US7130985)	Parallel Processor Executing an Instruction Specifying Any Location First Operand Register and Group Configuration in Two Dimensional Register File
  * [US7167972](http://www.google.com/patents/US7167972)	Vector/Scalar System With Vector Unit Producing Scalar Result from Vector Results According to Modifier in Vector Instruction
  * [US7350057](http://www.google.com/patents/US7350057)	Scalar Result Producing Method in Vector/Scalar System by Vector Unit from Vector Results According to Modifier in Vector Instruction
  * [US7200724](http://www.google.com/patents/US7200724)	Two Dimentional Access in a Data Processor
  * [US7203800](http://www.google.com/patents/US7203800)	Narrow/Wide Cache

### Patents Applications on the baseline Alphamosaic processor:
  * [US20030154361](http://www.google.com/patents/US20030154361) Instruction Execution in a Processor
  * [US20030159016](http://www.google.com/patents/US20030159016)	Data Access in a Processor
  * [US20030159017](http://www.google.com/patents/US20030159017)	Data Access in a Processor
  * [US20030159023](http://www.google.com/patents/US20030159023)	Repeated Instruction Execution
  * [US20030163667](http://www.google.com/patents/US20030163667)	Vector Processing System
  * [US20030159023](http://www.google.com/patents/US20030159023)	Application Registers
  * [US20040015682](http://www.google.com/patents/US20040015682)	Application Registers
  * [US20040019747](http://www.google.com/patents/US20040019747)	Narrow/Wide Cache
  * [US20040088521](http://www.google.com/patents/US20040088521)	Vector Processing System
  * [US20070061550](http://www.google.com/patents/US20070061550)	Instruction Execution in a Processor
  * [EP1320029](http://worldwide.espacenet.com/publicationDetails/originalDocument?CC=EP&NR=1320029A2&FT=D) Data processor with vector register file
  * [GB2382675](http://worldwide.espacenet.com/publicationDetails/originalDocument?CC=GB&NR=2382675A&FT=D)	Data access in a processor
  * [GB2382676](http://worldwide.espacenet.com/publicationDetails/originalDocument?CC=GB&NR=2382676A&FT=D)	Data access in a processor
  * [GB2382677](http://worldwide.espacenet.com/publicationDetails/originalDocument?CC=GB&NR=2382677A&FT=D)	Data access in a processor bitlines
  * [GB2382706](http://worldwide.espacenet.com/publicationDetails/originalDocument?CC=GB&NR=2382706A&FT=D)	Two dimensional memory structure with diagonal
  * [GB2382886](http://worldwide.espacenet.com/publicationDetails/originalDocument?CC=GB&NR=2382886A&FT=D)	Vector processing system
  * [GB2382887](http://worldwide.espacenet.com/publicationDetails/originalDocument?CC=GB&NR=2382887A&FT=D)	Instruction execution in a processor
  * [GB2383145](http://worldwide.espacenet.com/publicationDetails/originalDocument?CC=GB&NR=2383145A&FT=D)	Data access in a processor using a memory array accessed by coordinate instructions
  * [GB2390443](http://worldwide.espacenet.com/publicationDetails/originalDocument?CC=GB&NR=2390443A&FT=D)	A processor where some registers are not available to compiler generated code

## Third Party Documents and Links

Some snippets of information appear in third party documents.

* [ARC Product Brochure - see screenshots showing registers/instructions](http://web.archive.org/web/20030915135553/http://www.arc.com/downloads/success_stories/C12260_Alphamosiac.pdf)
* [VideoCore 01 used for Automated Fingerprint Identification System - see powerpoint for sample of code.](http://itvsystems.com.ua/ru/soft/afis_mod.htm)

