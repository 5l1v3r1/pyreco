__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Django OAuth 2.0 App documentation build configuration file, created by
# sphinx-quickstart on Sun Jun 26 16:34:34 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

sys.path.insert(0, os.path.abspath('../'))
sys.path.insert(0, os.path.abspath('../examples'))
from django.conf import settings
settings.configure(DEBUG=True)

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode', 'sphinx.ext.todo']

todo_include_todos = True

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django OAuth 2.0 Server App'
copyright = u'2011, John Wehr'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1.0'
# The full version, including alpha/beta/rc tags.
release = '0.1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
if on_rtd:
    html_theme = 'default'
else:
    html_theme = 'hiidef'
# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {

}


# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['.']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'DjangoOAuth20Appdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'DjangoOAuth20App.tex', u'Django OAuth 2.0 App Documentation',
   u'John Wehr', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'djangooauth20app', u'Django OAuth 2.0 App Documentation',
     [u'John Wehr'], 1)
]

########NEW FILE########
__FILENAME__ = forms
#-*- coding: utf-8 -*-

from django import forms
from django.contrib.auth import authenticate
from django.contrib.auth.forms import UserCreationForm
from uni_form.helpers import FormHelper, Submit, Reset
from oauth2app.models import AccessRange

class CreateClientForm(forms.Form):
    
    name = forms.CharField(label="Name", max_length=30)
    
    @property
    def helper(self):
        form = CreateClientForm()
        helper = FormHelper()
        reset = Reset('','Reset')
        helper.add_input(reset)
        submit = Submit('','Create Client')
        helper.add_input(submit)
        helper.form_action = '/account/clients'
        helper.form_method = 'POST'
        return helper


class ClientRemoveForm(forms.Form):

    client_id = forms.IntegerField()


class SignupForm(UserCreationForm):
    
    email = forms.EmailField(label="Email")
    
    @property
    def helper(self):
        form = SignupForm()
        helper = FormHelper()
        reset = Reset('','Reset')
        helper.add_input(reset)
        submit = Submit('','Sign Up')
        helper.add_input(submit)
        helper.form_action = '/account/signup'
        helper.form_method = 'POST'
        return helper


class LoginForm(forms.Form):
    
    username = forms.CharField(label="Username", max_length=30)
    password = forms.CharField(label="Password", widget=forms.PasswordInput)
    
    @property
    def helper(self):
        form = LoginForm()
        helper = FormHelper()
        reset = Reset('','Reset')
        helper.add_input(reset)
        submit = Submit('','Log In')
        helper.add_input(submit)
        helper.form_action = '/account/login'
        helper.form_method = 'POST'
        return helper

    def clean(self):
        username = self.cleaned_data.get('username')
        password = self.cleaned_data.get('password')

        if username and password:
            self.user_cache = authenticate(username=username, password=password)
            if self.user_cache is None:
                raise forms.ValidationError("Please enter a correct username and password. Note that both fields are case-sensitive.")
            elif not self.user_cache.is_active:
                raise forms.ValidationError("This account is inactive.")
        return self.cleaned_data
########NEW FILE########
__FILENAME__ = urls
#-*- coding: utf-8 -*-
from django.conf.urls.defaults import patterns, url

urlpatterns = patterns('mysite.apps.account.views',
    (r'^login/?$',                  'login'),
    (r'^logout/?$',                 'logout'),
    (r'^signup/?$',                 'signup'),
    (r'^clients/?$',                'clients'),
)
########NEW FILE########
__FILENAME__ = views
#-*- coding: utf-8 -*-


from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.contrib import auth
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from oauth2app.models import Client, AccessRange
from .forms import SignupForm, LoginForm, CreateClientForm, ClientRemoveForm

@login_required
def clients(request):
    if request.method == "POST":
        form = CreateClientForm(request.POST)
        remove_form = ClientRemoveForm(request.POST)
        if form.is_valid():
            Client.objects.create(
                name=form.cleaned_data["name"],
                user=request.user)
        elif remove_form.is_valid():
            Client.objects.filter(
                id=remove_form.cleaned_data["client_id"]).delete()
            form = CreateClientForm()           
    else:
        form = CreateClientForm()
    template = {
        "form":form, 
        "clients":Client.objects.filter(user=request.user)}
    return render_to_response(
        'account/clients.html', 
        template, 
        RequestContext(request))    


def login(request):
    if request.method == "POST":
        form = LoginForm(request.POST)
        if form.is_valid():
            user = auth.authenticate(
                    username=form.cleaned_data["username"],
                    password=form.cleaned_data["password"])
            auth.login(request, user)
            return HttpResponseRedirect("/")
    else:
        form = LoginForm()
    template = {"form":form}
    return render_to_response(
        'account/login.html', 
        template, 
        RequestContext(request))
 
    
@login_required    
def logout(request):
    auth.logout(request)
    return render_to_response(
        'account/logout.html', 
        {}, 
        RequestContext(request))


def signup(request):
    if request.method == "POST":
        form = SignupForm(request.POST)
        if form.is_valid():
            user = User.objects.create_user(
                    form.cleaned_data["username"],
                    form.cleaned_data["email"],
                    form.cleaned_data["password1"],)
            user = auth.authenticate(
                    username=form.cleaned_data["username"],
                    password=form.cleaned_data["password1"])
            auth.login(request, user)
            return HttpResponseRedirect("/")
    else:
        form = SignupForm()
    template = {"form":form}
    return render_to_response(
        'account/signup.html', 
        template, 
        RequestContext(request))

########NEW FILE########
__FILENAME__ = urls
#-*- coding: utf-8 -*-
from django.conf.urls.defaults import patterns, url

urlpatterns = patterns('mysite.apps.api.views',
    (r'^date_joined/?$',           'date_joined'),
    (r'^last_login/?$',            'last_login'),
    (r'^email/?$',                 'email')
)
########NEW FILE########
__FILENAME__ = views
#-*- coding: utf-8 -*-


from oauth2app.authenticate import JSONAuthenticator, AuthenticationException
from oauth2app.models import AccessRange

def date_joined(request):
    scope = AccessRange.objects.get(key="date_joined")
    authenticator = JSONAuthenticator(scope=scope)
    try:
        authenticator.validate(request)
    except AuthenticationException:
        return authenticator.error_response()
    return authenticator.response({
        "date_joined":str(authenticator.user.date_joined)})
    
    
def last_login(request):
    scope = AccessRange.objects.get(key="last_login")
    authenticator = JSONAuthenticator(scope=scope)
    try:
        authenticator.validate(request)
    except AuthenticationException:
        return authenticator.error_response()
    data = {"date_joined":str(request.user.date_joined)}
    return authenticator.response({
        "last_login":str(authenticator.user.last_login)})


def email(request):
    authenticator = JSONAuthenticator()
    try:
        authenticator.validate(request)
    except AuthenticationException:
        return authenticator.error_response()
    return authenticator.response({"email":authenticator.user.email})    

########NEW FILE########
__FILENAME__ = urls
#-*- coding: utf-8 -*-
from django.conf.urls.defaults import patterns, url

urlpatterns = patterns('mysite.apps.base.views',
    (r'^/?$',                      'homepage'),
)
########NEW FILE########
__FILENAME__ = views
#-*- coding: utf-8 -*-


from django.shortcuts import render_to_response
from django.template import RequestContext
from oauth2app.models import Client, AccessToken


def homepage(request):
    template = {}
    if request.user.is_authenticated():
        clients = Client.objects.filter(user=request.user)
        access_tokens = AccessToken.objects.filter(user=request.user)
        access_tokens = access_tokens.select_related()
        template["access_tokens"] = access_tokens
        template["clients"] = clients
    return render_to_response(
        'base/homepage.html', 
        template, 
        RequestContext(request))
########NEW FILE########
__FILENAME__ = urls
#-*- coding: utf-8 -*-
from django.conf.urls.defaults import patterns, url

urlpatterns = patterns('',)#-*- coding: utf-8 -*-


from django.conf.urls.defaults import patterns, url


urlpatterns = patterns('mysite.apps.client.views',
    (r'^(?P<client_id>\w+)/?$',            'client'),
)# Create your views here.

########NEW FILE########
__FILENAME__ = views
#-*- coding: utf-8 -*-


from django.shortcuts import render_to_response
from django.template import RequestContext
from oauth2app.models import Client, AccessToken, Code
from base64 import b64encode

def client(request, client_id):
    client = Client.objects.get(key=client_id)
    template = {
        "client":client,
        "basic_auth":"Basic %s" % b64encode(client.key + ":" + client.secret),
        "codes":Code.objects.filter(client=client).select_related(),
        "access_tokens":AccessToken.objects.filter(client=client).select_related()}
    template["error_description"] = request.GET.get("error_description")
    return render_to_response(
        'client/client.html', 
        template, 
        RequestContext(request))
########NEW FILE########
__FILENAME__ = forms
#-*- coding: utf-8 -*-

from django import forms


class AuthorizeForm(forms.Form):
    pass
########NEW FILE########
__FILENAME__ = urls
#-*- coding: utf-8 -*-
from django.conf.urls.defaults import patterns, url

urlpatterns = patterns('',
        (r'^missing_redirect_uri/?$',   'mysite.apps.oauth2.views.missing_redirect_uri'),
        (r'^authorize/?$',              'mysite.apps.oauth2.views.authorize'),
        (r'^token/?$',                  'oauth2app.token.handler'),
)
########NEW FILE########
__FILENAME__ = views
#-*- coding: utf-8 -*-


from django.shortcuts import render_to_response
from django.http import HttpResponseRedirect
from django.template import RequestContext
from uni_form.helpers import FormHelper, Submit, Reset
from django.contrib.auth.decorators import login_required
from oauth2app.authorize import Authorizer, MissingRedirectURI, AuthorizationException
from oauth2app.authorize import UnvalidatedRequest, UnauthenticatedUser
from .forms import AuthorizeForm


@login_required
def missing_redirect_uri(request):
    return render_to_response(
        'oauth2/missing_redirect_uri.html', 
        {}, 
        RequestContext(request))


@login_required
def authorize(request):
    authorizer = Authorizer()
    try:
        authorizer.validate(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")
    except AuthorizationException, e:
        # The request is malformed or invalid. Automatically 
        # redirects to the provided redirect URL.
        return authorizer.error_redirect()
    if request.method == 'GET':
        # Make sure the authorizer has validated before requesting the client
        # or access_ranges as otherwise they will be None.
        template = {
            "client":authorizer.client, 
            "access_ranges":authorizer.access_ranges}
        template["form"] = AuthorizeForm()
        helper = FormHelper()
        no_submit = Submit('connect','No')
        helper.add_input(no_submit)
        yes_submit = Submit('connect', 'Yes')
        helper.add_input(yes_submit)
        helper.form_action = '/oauth2/authorize?%s' % authorizer.query_string
        helper.form_method = 'POST'
        template["helper"] = helper
        return render_to_response(
            'oauth2/authorize.html', 
            template, 
            RequestContext(request))
    elif request.method == 'POST':
        form = AuthorizeForm(request.POST)
        if form.is_valid():
            if request.POST.get("connect") == "Yes":
                return authorizer.grant_redirect()
            else:
                return authorizer.error_redirect()
    return HttpResponseRedirect("/")

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for oauth2app example mysite project.

import os


DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = ()

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'mysite.sqlite',
        'USER': '',
        'PASSWORD': '',
        'HOST': '',
        'PORT': '',
    }
}

FIXTURE_DIRS = (
   os.path.join(os.path.dirname(__file__), 'apps/account/fixtures'),
)

TIME_ZONE = 'America/Chicago'

LANGUAGE_CODE = 'en-us'

SITE_ID = 1

USE_I18N = True

USE_L10N = True

LOGIN_URL = "/account/login"

MEDIA_ROOT = ''

MEDIA_URL = ''

STATIC_ROOT = ''

STATIC_URL = '/static/'

ADMIN_MEDIA_PREFIX = '/static/admin/'

STATICFILES_DIRS = (os.path.join(os.path.dirname(__file__), 'static'),)

STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

SECRET_KEY = '=hf03e+08xlolbb$!-s01m-n_4xn*5mdsd!pm@$+ms!pe08f-7'

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.core.context_processors.request',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'mysite.urls'

TEMPLATE_DIRS = (os.path.join(os.path.dirname(__file__), 'templates'),)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'mysite.apps.base',
    'mysite.apps.client',
    'mysite.apps.account',
    'mysite.apps.oauth2',
    'mysite.apps.api',
    'uni_form',
    'oauth2app')

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url
from django.conf import settings

urlpatterns = patterns('',
    (r'^', include('mysite.apps.base.urls')),
    (r'^account/', include('mysite.apps.account.urls')),
    (r'^client/', include('mysite.apps.client.urls')),
    (r'^oauth2/', include('mysite.apps.oauth2.urls')),
    (r'^api/', include('mysite.apps.api.urls')),
)

########NEW FILE########
__FILENAME__ = authenticate
#-*- coding: utf-8 -*-


"""OAuth 2.0 Authentication"""


try: import simplejson as json
except ImportError: import json
from hashlib import sha256
from urlparse import parse_qsl
from django.conf import settings
from django.http import HttpResponse
from .exceptions import OAuth2Exception
from .models import AccessToken, AccessRange, TimestampGenerator
from .consts import REALM, AUTHENTICATION_METHOD, MAC, BEARER

class AuthenticationException(OAuth2Exception):
    """Authentication exception base class."""
    pass


class InvalidRequest(AuthenticationException):
    """The request is missing a required parameter, includes an
    unsupported parameter or parameter value, repeats the same
    parameter, uses more than one method for including an access
    token, or is otherwise malformed."""
    error = 'invalid_request'


class InvalidToken(AuthenticationException):
    """The access token provided is expired, revoked, malformed, or
    invalid for other reasons."""
    error = 'invalid_token'


class InsufficientScope(AuthenticationException):
    """The request requires higher privileges than provided by the
    access token."""
    error = 'insufficient_scope'

class UnvalidatedRequest(OAuth2Exception):
    """The method requested requires a validated request to continue."""
    pass

class Authenticator(object):
    """Django HttpRequest authenticator. Checks a request for valid
    credentials and scope.

    **Kwargs:**

    * *scope:* An iterable of oauth2app.models.AccessRange objects representing
      the scope the authenticator will authenticate.
      *Default None*
    * *authentication_method:* Accepted authentication methods. Possible
      values are: oauth2app.consts.MAC, oauth2app.consts.BEARER,
      oauth2app.consts.MAC | oauth2app.consts.BEARER,
      *Default oauth2app.consts.BEARER*

    """

    valid = False
    access_token = None
    auth_type = None
    auth_value = None
    error = None
    attempted_validation = False

    def __init__(
            self,
            scope=None,
            authentication_method=AUTHENTICATION_METHOD):
        if authentication_method not in [BEARER, MAC, BEARER | MAC]:
            raise OAuth2Exception("Possible values for authentication_method"
                " are oauth2app.consts.MAC, oauth2app.consts.BEARER, "
                "oauth2app.consts.MAC | oauth2app.consts.BEARER")
        self.authentication_method = authentication_method
        if scope is None:
            self.authorized_scope = None
        elif isinstance(scope, AccessRange):
            self.authorized_scope = set([scope.key])
        else:
            self.authorized_scope = set([x.key for x in scope])

    def validate(self, request):
        """Validate the request. Raises an AuthenticationException if the
        request fails authentication.

        **Args:**

        * *request:* Django HttpRequest object.

        *Returns None*"""
        self.request = request
        self.bearer_token = request.REQUEST.get('bearer_token')
        if "HTTP_AUTHORIZATION" in self.request.META:
            auth = self.request.META["HTTP_AUTHORIZATION"].split()
            self.auth_type = auth[0].lower()
            self.auth_value = " ".join(auth[1:]).strip()
        self.request_hostname = self.request.META.get("REMOTE_HOST")
        self.request_port = self.request.META.get("SERVER_PORT")
        try:
            self._validate()
        except AuthenticationException, e:
            self.error = e
            raise e
        self.valid = True

    def _validate(self):
        """Validate the request."""
        # Check for Bearer or Mac authorization
        if self.auth_type in ["bearer", "mac"]:
            self.attempted_validation = True
            if self.auth_type == "bearer":
                self._validate_bearer(self.auth_value)
            elif self.auth_type == "mac":
                self._validate_mac(self.auth_value)
            self.valid = True
        # Check for posted/paramaterized bearer token.
        elif self.bearer_token is not None:
            self.attempted_validation = True
            self._validate_bearer(self.bearer_token)
            self.valid = True
        else:
            raise InvalidRequest("Request authentication failed, no "
                "authentication credentials provided.")
        if self.authorized_scope is not None:
            token_scope = set([x.key for x in self.access_token.scope.all()])
            new_scope = self.authorized_scope - token_scope
            if len(new_scope) > 0:
                raise InsufficientScope(("Access token has insufficient "
                    "scope: %s") % ','.join(self.authorized_scope))
        now = TimestampGenerator()()
        if self.access_token.expire < now:
            raise InvalidToken("Token is expired")

    def _validate_bearer(self, token):
        """Validate Bearer token."""
        if self.authentication_method & BEARER == 0:
            raise InvalidToken("Bearer authentication is not supported.")
        try:
            self.access_token = AccessToken.objects.get(token=token)
        except AccessToken.DoesNotExist:
            raise InvalidToken("Token doesn't exist")

    def _validate_mac(self, mac_header):
        """Validate MAC authentication. Not implemented."""
        if self.authentication_method & MAC == 0:
            raise InvalidToken("MAC authentication is not supported.")
        mac_header = parse_qsl(mac_header.replace(",","&").replace('"', ''))
        mac_header = dict([(x[0].strip(), x[1].strip()) for x in mac_header])
        for parameter in ["id", "nonce", "mac"]:
            if "parameter" not in mac_header:
                raise InvalidToken("MAC Authorization header does not contain"
                    " required parameter '%s'" % parameter)
        if "bodyhash" in mac_header:
            bodyhash = mac_header["bodyhash"]
        else:
            bodyhash = ""
        if "ext" in mac_header:
            ext = mac_header["ext"]
        else:
            ext = ""
        if self.request_hostname is None:
            raise InvalidRequest("Request does not contain a hostname.")
        if self.request_port is None:
            raise InvalidRequest("Request does not contain a port.")
        nonce_timestamp, nonce_string = mac_header["nonce"].split(":")
        mac = sha256("\n".join([
            mac_header["nonce"], # The nonce value generated for the request
            self.request.method.upper(), # The HTTP request method
            "XXX", # The HTTP request-URI
            self.request_hostname, # The hostname included in the HTTP request
            self.request_port, # The port as included in the HTTP request
            bodyhash,
            ext])).hexdigest()
        raise NotImplementedError()

        # Todo:
        # 1.  Recalculate the request body hash (if included in the request) as
        # described in Section 3.2 and request MAC as described in
        # Section 3.3 and compare the request MAC to the value received
        # from the client via the "mac" attribute.
        # 2.  Ensure that the combination of nonce and MAC key identifier
        # received from the client has not been used before in a previous
        # request (the server MAY reject requests with stale timestamps;
        # the determination of staleness is left up to the server to
        # define).
        # 3.  Verify the scope and validity of the MAC credentials.


    def _get_user(self):
        """The user associated with the valid access token.

        *django.auth.User object*"""
        if not self.valid:
            raise UnvalidatedRequest("This request is invalid or has not "
                "been validated.")
        return self.access_token.user

    user = property(_get_user)

    def _get_scope(self):
        """The client scope associated with the valid access token.

        *QuerySet of AccessRange objects.*"""
        if not self.valid:
            raise UnvalidatedRequest("This request is invalid or has not "
                "been validated.")
        return self.access_token.scope.all()

    scope = property(_get_scope)

    def _get_client(self):
        """The client associated with the valid access token.

        *oauth2app.models.Client object*"""
        if not self.valid:
            raise UnvalidatedRequest("This request is invalid or has not "
                "been validated.")
        return self.access_token.client

    client = property(_get_client)

    def error_response(self,
            content='',
            mimetype=None,
            content_type=settings.DEFAULT_CONTENT_TYPE):
        """Error response generator. Returns a Django HttpResponse with status
        401 and the approproate headers set. See Django documentation for details.
        https://docs.djangoproject.com/en/dev/ref/request-response/#django.http.HttpResponse.__init__

        **Kwargs:**

        * *content:* See Django docs. *Default ''*
        * *mimetype:* See Django docs. *Default None*
        * *content_type:* See Django docs. *Default DEFAULT_CONTENT_TYPE*

        """
        response = HttpResponse(
            content=content,
            mimetype=mimetype,
            content_type=content_type)
        if not self.attempted_validation:
            response['WWW-Authenticate'] = 'Bearer realm="%s"' % REALM
            response.status_code = 401
            return response
        else:
            if self.error is not None:
                error = getattr(self.error, "error", "invalid_request")
                error_description = self.error.message
            else:
                error = "invalid_request"
                error_description = "Invalid Request."
            header = [
                'Bearer realm="%s"' % REALM,
                'error="%s"' % error,
                'error_description="%s"' % error_description]
            if isinstance(self.error, InsufficientScope):
                header.append('scope=%s' % ' '.join(self.authorized_scope))
                response.status_code = 403
            elif isinstance(self.error, InvalidToken):
                response.status_code = 401
            elif isinstance(self.error, InvalidRequest):
                response.status_code = 400
            else:
                response.status_code = 401
            response['WWW-Authenticate'] = ', '.join(header)
            return response


class JSONAuthenticator(Authenticator):
    """Wraps Authenticator, adds support for a callback parameter and
    JSON related. convenience methods.

    **Args:**

    * *request:* Django HttpRequest object.

    **Kwargs:**

    * *scope:* A iterable of oauth2app.models.AccessRange objects.
    """

    callback = None

    def __init__(self, scope=None):
        Authenticator.__init__(self, scope=scope)

    def validate(self, request):
        self.callback = request.REQUEST.get('callback')
        return Authenticator.validate(self, request)

    def response(self, data):
        """Returns a HttpResponse object of JSON serialized data.

        **Args:**

        * *data:* Object to be JSON serialized and returned.
        """
        json_data = json.dumps(data)
        if self.callback is not None:
            json_data = "%s(%s);" % (self.callback, json_data)
        response = HttpResponse(
            content=json_data,
            content_type='application/json')
        return response

    def error_response(self):
        """Returns a HttpResponse object of JSON error data."""
        if self.error is not None:
            content = json.dumps({
                "error":getattr(self.error, "error", "invalid_request"),
                "error_description":self.error.message})
        else:
            content = ({
                "error":"invalid_request",
                "error_description":"Invalid Request."})
        if self.callback is not None:
            content = "%s(%s);" % (self.callback, content)
        response = Authenticator.error_response(
            self,
            content=content,
            content_type='application/json')
        if self.callback is not None:
            response.status_code = 200
        return response

########NEW FILE########
__FILENAME__ = authorize
#-*- coding: utf-8 -*-


"""OAuth 2.0 Authorization"""


try: import simplejson as json
except ImportError: import json
from django.http import absolute_http_url_re, HttpResponseRedirect
from urllib import urlencode
from .consts import ACCESS_TOKEN_EXPIRATION, REFRESHABLE
from .consts import CODE, TOKEN, CODE_AND_TOKEN
from .consts import AUTHENTICATION_METHOD, MAC, BEARER, MAC_KEY_LENGTH
from .exceptions import OAuth2Exception
from .lib.uri import add_parameters, add_fragments, normalize
from .models import Client, AccessRange, Code, AccessToken, KeyGenerator


class AuthorizationException(OAuth2Exception):
    """Authorization exception base class."""
    pass


class MissingRedirectURI(OAuth2Exception):
    """Neither the request nor the client specify a redirect_url."""
    pass


class UnauthenticatedUser(OAuth2Exception):
    """The provided user is not internally authenticated, via
    user.is_authenticated()"""
    pass


class UnvalidatedRequest(OAuth2Exception):
    """The method requested requires a validated request to continue."""
    pass


class InvalidRequest(AuthorizationException):
    """The request is missing a required parameter, includes an
    unsupported parameter or parameter value, or is otherwise
    malformed."""
    error = 'invalid_request'


class InvalidClient(AuthorizationException):
    """Client authentication failed (e.g. unknown client, no
    client credentials included, multiple client credentials
    included, or unsupported credentials type)."""
    error = 'invalid_client'


class UnauthorizedClient(AuthorizationException):
    """The client is not authorized to request an authorization
    code using this method."""
    error = 'unauthorized_client'


class AccessDenied(AuthorizationException):
    """The resource owner or authorization server denied the
    request."""
    error = 'access_denied'


class UnsupportedResponseType(AuthorizationException):
    """The authorization server does not support obtaining an
    authorization code using this method."""
    error = 'unsupported_response_type'


class InvalidScope(AuthorizationException):
    """The requested scope is invalid, unknown, or malformed."""
    error = 'invalid_scope'


RESPONSE_TYPES = {
    "code":CODE,
    "token":TOKEN}


class Authorizer(object):
    """Access authorizer. Validates access credentials and generates
    a response with an authorization code passed as a parameter to the
    redirect URI, an access token passed as a URI fragment to the redirect
    URI, or both.

    **Kwargs:**

    * *scope:* An iterable of oauth2app.models.AccessRange objects representing
      the scope the authorizer can grant. *Default None*
    * *authentication_method:* Type of token to generate. Possible
      values are: oauth2app.consts.MAC and oauth2app.consts.BEARER
      *Default oauth2app.consts.BEARER*
    * *refreshable:* Boolean value indicating whether issued tokens are
      refreshable. *Default True*
    """
    client = None
    access_ranges = None
    valid = False
    error = None

    def __init__(
            self,
            scope=None,
            authentication_method=AUTHENTICATION_METHOD,
            refreshable=REFRESHABLE,
            response_type=CODE):
        if response_type not in [CODE, TOKEN, CODE_AND_TOKEN]:
            raise OAuth2Exception("Possible values for response_type"
                " are oauth2app.consts.CODE, oauth2app.consts.TOKEN, "
                "oauth2app.consts.CODE_AND_TOKEN")
        self.authorized_response_type = response_type
        self.refreshable = refreshable
        if authentication_method not in [BEARER, MAC]:
            raise OAuth2Exception("Possible values for authentication_method"
                " are oauth2app.consts.MAC and oauth2app.consts.BEARER")
        self.authentication_method = authentication_method
        if scope is None:
            self.authorized_scope = None
        elif isinstance(scope, AccessRange):
            self.authorized_scope = set([scope.key])
        else:
            self.authorized_scope = set([x.key for x in scope])

    def __call__(self, request):
        """Validate the request. Returns an error redirect if the
        request fails authorization, or a MissingRedirectURI if no
        redirect_uri is available.

        **Args:**

        * *request:* Django HttpRequest object.

        *Returns HTTP Response redirect*"""
        try:
            self.validate(request)
        except AuthorizationException, e:
            # The request is malformed or invalid. Automatically
            # redirects to the provided redirect URL.
            return self.error_redirect()
        return self.grant_redirect()

    def validate(self, request):
        """Validate the request. Raises an AuthorizationException if the
        request fails authorization, or a MissingRedirectURI if no
        redirect_uri is available.

        **Args:**

        * *request:* Django HttpRequest object.

        *Returns None*"""
        self.response_type = request.REQUEST.get('response_type')
        self.client_id = request.REQUEST.get('client_id')
        self.redirect_uri = request.REQUEST.get('redirect_uri')
        self.scope = request.REQUEST.get('scope')
        if self.scope is not None:
            self.scope = set(self.scope.split())
        self.state = request.REQUEST.get('state')
        self.user = request.user
        self.request = request
        try:
            self._validate()
        except AuthorizationException, e:
            self._check_redirect_uri()
            self.error = e
            raise e
        self.valid = True

    def _validate(self):
        """Validate the request."""
        if self.client_id is None:
            raise InvalidRequest('No client_id')
        try:
            self.client = Client.objects.get(key=self.client_id)
        except Client.DoesNotExist:
            raise InvalidClient("client_id %s doesn't exist" % self.client_id)
        # Redirect URI
        if self.redirect_uri is None:
            if self.client.redirect_uri is None:
                raise MissingRedirectURI("No redirect_uri"
                    "provided or registered.")
        elif self.client.redirect_uri is not None:
            if normalize(self.redirect_uri) != normalize(self.client.redirect_uri):
                self.redirect_uri = self.client.redirect_uri
                raise InvalidRequest("Registered redirect_uri doesn't "
                    "match provided redirect_uri.")
        self.redirect_uri = self.redirect_uri or self.client.redirect_uri
        # Check response type
        if self.response_type is None:
            raise InvalidRequest('response_type is a required parameter.')
        if self.response_type not in ["code", "token"]:
            raise InvalidRequest("No such response type %s" % self.response_type)
        # Response type
        if self.authorized_response_type & RESPONSE_TYPES[self.response_type] == 0:
            raise UnauthorizedClient("Response type %s not allowed." %
                self.response_type)
        if not absolute_http_url_re.match(self.redirect_uri):
            raise InvalidRequest('Absolute URI required for redirect_uri')
        # Scope
        if self.authorized_scope is not None and self.scope is None:
            self.scope = self.authorized_scope
        if self.scope is not None:
            self.access_ranges = AccessRange.objects.filter(key__in=self.scope)
            access_ranges = set(self.access_ranges.values_list('key', flat=True))
            difference = access_ranges.symmetric_difference(self.scope)
            if len(difference) != 0:
                raise InvalidScope("Following access ranges do not "
                    "exist: %s" % ', '.join(difference))
            if self.authorized_scope is not None:
                new_scope = self.scope - self.authorized_scope
                if len(new_scope) > 0:
                    raise InvalidScope("Invalid scope: %s" % ','.join(new_scope))

    def _check_redirect_uri(self):
        """Raise MissingRedirectURI if no redirect_uri is available."""
        if self.redirect_uri is None:
            raise MissingRedirectURI('No redirect_uri to send response.')
        if not absolute_http_url_re.match(self.redirect_uri):
            raise MissingRedirectURI('Absolute redirect_uri required.')

    def error_redirect(self):
        """In the event of an error, return a Django HttpResponseRedirect
        with the appropriate error parameters.

        Raises MissingRedirectURI if no redirect_uri is available.

        *Returns HttpResponseRedirect*"""
        self._check_redirect_uri()
        if self.error is not None:
            e = self.error
        else:
            e = AccessDenied("Access Denied.")
        parameters = {'error': e.error, 'error_description': u'%s' % e.message}
        if self.state is not None:
            parameters['state'] = self.state
        redirect_uri = self.redirect_uri
        if self.authorized_response_type & CODE != 0:
            redirect_uri = add_parameters(redirect_uri, parameters)
        if self.authorized_response_type & TOKEN != 0:
            redirect_uri = add_fragments(redirect_uri, parameters)
        return HttpResponseRedirect(redirect_uri)

    def _query_string(self):
        """Returns the a url encoded query string useful for resending request
        parameters when a user authorizes the request via a form POST.

        Raises UnvalidatedRequest if the request has not been validated.

        *Returns str*"""
        if not self.valid:
            raise UnvalidatedRequest("This request is invalid or has not"
                "been validated.")
        parameters = {
            "response_type":self.response_type,
            "client_id":self.client_id}
        if self.redirect_uri is not None:
            parameters["redirect_uri"] = self.redirect_uri
        if self.state is not None:
            parameters["state"] = self.state
        if self.scope is not None:
            parameters["scope"] = ' '.join(self.scope)
        return urlencode(parameters)

    query_string = property(_query_string)

    def grant_redirect(self):
        """On successful authorization of the request, return a Django
        HttpResponseRedirect with the appropriate authorization code parameters
        or access token URI fragments..

        Raises UnvalidatedRequest if the request has not been validated.

        *Returns HttpResponseRedirect*"""
        if not self.valid:
            raise UnvalidatedRequest("This request is invalid or has not "
                "been validated.")
        if self.user.is_authenticated():
            parameters = {}
            fragments = {}
            if self.scope is not None:
                access_ranges = list(AccessRange.objects.filter(key__in=self.scope))
            else:
                access_ranges = []
            if RESPONSE_TYPES[self.response_type] & CODE != 0:
                code = Code.objects.create(
                    user=self.user,
                    client=self.client,
                    redirect_uri=self.redirect_uri)
                code.scope.add(*access_ranges)
                code.save()
                parameters['code'] = code.key
            if RESPONSE_TYPES[self.response_type] & TOKEN != 0:
                access_token = AccessToken.objects.create(
                    user=self.user,
                    client=self.client)
                access_token.scope = access_ranges
                fragments['access_token'] = access_token.token
                if access_token.refreshable:
                    fragments['refresh_token'] = access_token.refresh_token
                fragments['expires_in'] = ACCESS_TOKEN_EXPIRATION
                if self.scope is not None:
                    fragments['scope'] = ' '.join(self.scope)
                if self.authentication_method == MAC:
                    access_token.mac_key = KeyGenerator(MAC_KEY_LENGTH)()
                    fragments["mac_key"] = access_token.mac_key
                    fragments["mac_algorithm"] = "hmac-sha-256"
                    fragments["token_type"] = "mac"
                elif self.authentication_method == BEARER:
                    fragments["token_type"] = "bearer"
                access_token.save()
            if self.state is not None:
                parameters['state'] = self.state
            redirect_uri = add_parameters(self.redirect_uri, parameters)
            redirect_uri = add_fragments(redirect_uri, fragments)
            return HttpResponseRedirect(redirect_uri)
        else:
            raise UnauthenticatedUser("Django user object associated with the "
                "request is not authenticated.")

########NEW FILE########
__FILENAME__ = consts
#-*- coding: utf-8 -*-


"""OAuth 2.0 Default Values."""


from django.conf import settings
from .exceptions import OAuth2Exception


# Length of the client key.
CLIENT_KEY_LENGTH = getattr(settings, "OAUTH2_CLIENT_KEY_LENGTH", 30)
# Length of the client secret.
CLIENT_SECRET_LENGTH = getattr(settings, "OAUTH2_CLIENT_SECRET_LENGTH", 30)
# Length of the scope key.
SCOPE_LENGTH = getattr(settings, "OAUTH2_SCOPE_LENGTH", 255)
# Length of the code key.
CODE_KEY_LENGTH = getattr(settings, "OAUTH2_CODE_KEY_LENGTH", 30)
# Length of the MAC authentication key.
MAC_KEY_LENGTH = getattr(settings, "OAUTH2_MAC_KEY_LENGTH", 20)
# Length of the access token.
ACCESS_TOKEN_LENGTH = getattr(settings, "OAUTH2_ACCESS_TOKEN_LENGTH", 10)
# Length of the refresh token.
REFRESH_TOKEN_LENGTH = getattr(settings, "OAUTH2_REFRESH_TOKEN_LENGTH", 10)
# Issue refreshable tokens.
REFRESHABLE = getattr(settings, "OAUTH2_REFRESHABLE", True)
# Number of seconds in which an authorization code should expire.
CODE_EXPIRATION = getattr(settings, "OAUTH2_CODE_EXPIRATION", 120)
# Number of seconds in which an access token should expire.
ACCESS_TOKEN_EXPIRATION = getattr(
    settings, 
    "OAUTH2_ACCESS_TOKEN_EXPIRATION", 
    3600)
# Sends and accepts Bearer style authentication parameters 
# See http://tools.ietf.org/html/draft-ietf-oauth-saml2-bearer-03
# and http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-04
BEARER = 1
# Sends and accepts MAC style authentication parameters 
# See http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-00
MAC = 2 
# Type of authentication to use. Bearer or MAC.
AUTHENTICATION_METHOD = getattr(
    settings, 
    "OAUTH2_AUTHENTICATION_METHOD", 
    BEARER)
if AUTHENTICATION_METHOD not in [BEARER, MAC]:
    raise OAuth2Exception("Possible values for OAUTH2_AUTHENTICATION_METHOD "
        "are oauth2app.consts.MAC and oauth2app.consts.BEARER")
# Authentication realm
REALM = getattr(settings, "OAUTH2_REALM", "")
# Grants token style fragments.
TOKEN = 1
# Grants code style parameters.
CODE = 2
# Grants both style parameters.
CODE_AND_TOKEN = CODE | TOKEN

########NEW FILE########
__FILENAME__ = decorators
#-*- coding: utf-8 -*-

import functools, inspect


def decorator(func):
    """ Allow to use decorator either with arguments or not. 
    See http://wiki.python.org/moin/PythonDecoratorLibrary#Creating_decorator_with_optional_arguments
    """

    def isFuncArg(*args, **kw):
        return len(args) == 1 and len(kw) == 0 and (
            inspect.isfunction(args[0]) or isinstance(args[0], type))

    if isinstance(func, type):
        def class_wrapper(*args, **kw):
            if isFuncArg(*args, **kw):
                return func()(*args, **kw) # create class before usage
            return func(*args, **kw)
        class_wrapper.__name__ = func.__name__
        class_wrapper.__module__ = func.__module__
        return class_wrapper

    @functools.wraps(func)
    def func_wrapper(*args, **kw):
        if isFuncArg(*args, **kw):
            return func(*args, **kw)

        def functor(userFunc):
            return func(userFunc, *args, **kw)

        return functor

    return func_wrapper


@decorator
def authenticate(func, *args, **kw):
    """Authenticate a request with no scope."""
    raise NotImplementedError()
    return func(*args, **kw)


@decorator
class authenticate(object):
    """Authenticate a request with scope."""
    def __init__(self, *args, **kw):
        self.args = args
        self.kw   = kw

    def __call__(self, func):
        raise NotImplementedError()
        return func(*self.args, **self.kw)

########NEW FILE########
__FILENAME__ = exceptions
#-*- coding: utf-8 -*-


"""OAuth 2.0 Base Exceptions"""


class OAuth2Exception(Exception):
    """OAuth 2.0 Base Exception"""
    pass

########NEW FILE########
__FILENAME__ = uri
#-*- coding: utf-8 -*-


"""OAuth 2.0 URI Helper Functions"""


from urlparse import urlparse, urlunparse, parse_qsl
from urllib import urlencode
from url_normalize import url_normalize
 
 
def add_parameters(url, parameters):
    """Parses URL and appends parameters. 

    **Args:**

    * *url:* URL string.
    * *parameters:* Dict of parameters

    *Returns str*"""
    parts = list(urlparse(url))
    parts[4] = urlencode(parse_qsl(parts[4]) + parameters.items())
    return urlunparse(parts)
    

def add_fragments(url, fragments):
    """Parses URL and appends fragments. 

    **Args:**

    * *url:* URL string.
    * *fragments:* Dict of fragments

    *Returns str*"""
    parts = list(urlparse(url))
    parts[5] = urlencode(parse_qsl(parts[5]) + fragments.items())
    return urlunparse(parts)
    
    
def normalize(url):
    """Normalizes URL.

    **Args:**

    * *url:* URL string.

    *Returns str*"""
    return url_normalize(url)
    
########NEW FILE########
__FILENAME__ = url_normalize
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
URI Normalization function:
 * Take care of IDN domains.
 * Always provide the URI scheme in lowercase characters.
 * Always provide the host, if any, in lowercase characters.
 * Only perform percent-encoding where it is essential.
 * Always use uppercase A-through-F characters when percent-encoding.
 * Prevent dot-segments appearing in non-relative URI paths.
 * For schemes that define a default authority, use an empty authority if the
   default is desired.
 * For schemes that define an empty path to be equivalent to a path of "/",
   use "/".
 * For schemes that define a port, use an empty port if the default is desired
 * All portions of the URI must be utf-8 encoded NFC from Unicode strings

Inspired by Sam Ruby's urlnorm.py: http://intertwingly.net/blog/2004/08/04/Urlnorm
This fork author: Nikolay Panov (<pythoneer@niksite.ru>)

History:
 * 10 Feb 2010: support for shebang (#!) urls
 * 28 Feb 2010: using 'http' schema by default when appropriate
 * 28 Feb 2010: added handling of IDN domains
 * 28 Feb 2010: code pep8-zation
 * 27 Feb 2010: forked from Sam Ruby's urlnorm.py
"""

__license__ = "Python"
__version__ = 1.1

import re
import unicodedata
import urlparse
from urllib import quote, unquote


def url_normalize(url, charset='utf-8'):
    """Sometimes you get an URL by a user that just isn't a real
    URL because it contains unsafe characters like ' ' and so on.  This
    function can fix some of the problems in a similar way browsers
    handle data entered by the user:

    >>> url_fix(u'http://de.wikipedia.org/wiki/Elf (Begriffsklärung)')
    'http://de.wikipedia.org/wiki/Elf%20%28Begriffskl%C3%A4rung%29'

    :param charset: The target charset for the URL if the url was
                    given as unicode string.
    """

    def _clean(string):
        string = unicode(unquote(string), 'utf-8', 'replace')
        return unicodedata.normalize('NFC', string).encode('utf-8')

    default_port = {
        'ftp': 21,
        'telnet': 23,
        'http': 80,
        'gopher': 70,
        'news': 119,
        'nntp': 119,
        'prospero': 191,
        'https': 443,
        'snews': 563,
        'snntp': 563,
    }
    if isinstance(url, unicode):
        url = url.encode(charset, 'ignore')

    # if there is no scheme use http as default scheme
    if url[0] not in ['/', '-'] and ':' not in url[:7]:
        url = 'http://' + url

    # shebang urls support
    url = url.replace('#!', '?_escaped_fragment_=')

    # splitting url to useful parts
    scheme, auth, path, query, fragment = urlparse.urlsplit(url.strip())
    (userinfo, host, port) = re.search('([^@]*@)?([^:]*):?(.*)', auth).groups()

    # Always provide the URI scheme in lowercase characters.
    scheme = scheme.lower()

    # Always provide the host, if any, in lowercase characters.
    host = host.lower()
    if host and host[-1] == '.':
        host = host[:-1]
    # take care about IDN domains
    host = host.decode(charset).encode('idna')  # IDN -> ACE

    # Only perform percent-encoding where it is essential.
    # Always use uppercase A-through-F characters when percent-encoding.
    # All portions of the URI must be utf-8 encoded NFC from Unicode strings
    path = quote(_clean(path), "~:/?#[]@!$&'()*+,;=")
    fragment = quote(_clean(fragment), "~")

    # note care must be taken to only encode & and = characters as values
    query = "&".join(["=".join([quote(_clean(t), "~:/?#[]@!$'()*+,;=") for t in q.split("=", 1)]) for q in query.split("&")])

    # Prevent dot-segments appearing in non-relative URI paths.
    if scheme in ["", "http", "https", "ftp", "file"]:
        output = []
        for part in path.split('/'):
            if part == "":
                if not output:
                    output.append(part)
            elif part == ".":
                pass
            elif part == "..":
                if len(output) > 1:
                    output.pop()
            else:
                output.append(part)
        if part in ["", ".", ".."]:
            output.append("")
        path = '/'.join(output)

    # For schemes that define a default authority, use an empty authority if
    # the default is desired.
    if userinfo in ["@", ":@"]:
        userinfo = ""

    # For schemes that define an empty path to be equivalent to a path of "/",
    # use "/".
    if path == "" and scheme in ["http", "https", "ftp", "file"]:
        path = "/"

    # For schemes that define a port, use an empty port if the default is
    # desired
    if port and scheme in default_port.keys():
        if port.isdigit():
            port = str(int(port))
            if int(port) == default_port[scheme]:
                port = ''

    # Put it all back together again
    auth = (userinfo or "") + host
    if port:
        auth += ":" + port
    if url.endswith("#") and query == "" and fragment == "":
        path += "#"
    return urlparse.urlunsplit((scheme, auth, path, query, fragment))

if __name__ == "__main__":
    import unittest
    suite = unittest.TestSuite()

    """ from http://www.intertwingly.net/wiki/pie/PaceCanonicalIds """
    tests1 = [
        (False, "http://:@example.com/"),
        (False, "http://@example.com/"),
        (False, "http://example.com"),
        (False, "HTTP://example.com/"),
        (False, "http://EXAMPLE.COM/"),
        (False, "http://example.com/%7Ejane"),
        (False, "http://example.com/?q=%C7"),
        (False, "http://example.com/?q=%5c"),
        (False, "http://example.com/?q=C%CC%A7"),
        (False, "http://example.com/a/../a/b"),
        (False, "http://example.com/a/./b"),
        (False, "http://example.com:80/"),
        (True, "http://example.com/"),
        (True, "http://example.com/?q=%C3%87"),
        (True, "http://example.com/?q=%E2%85%A0"),
        (True, "http://example.com/?q=%5C"),
        (True, "http://example.com/~jane"),
        (True, "http://example.com/a/b"),
        (True, "http://example.com:8080/"),
        (True, "http://user:password@example.com/"),

        # from rfc2396bis
        (True, "ftp://ftp.is.co.za/rfc/rfc1808.txt"),
        (True, "http://www.ietf.org/rfc/rfc2396.txt"),
        (True, "ldap://[2001:db8::7]/c=GB?objectClass?one"),
        (True, "mailto:John.Doe@example.com"),
        (True, "news:comp.infosystems.www.servers.unix"),
        (True, "tel:+1-816-555-1212"),
        (True, "telnet://192.0.2.16:80/"),
        (True, "urn:oasis:names:specification:docbook:dtd:xml:4.1.2"),

        # other
        (True, "http://127.0.0.1/"),
        (False, "http://127.0.0.1:80/"),
        (True, "http://www.w3.org/2000/01/rdf-schema#"),
        (False, "http://example.com:081/"),
    ]

    def testcase1(expected, value):

        class test(unittest.TestCase):

            def runTest(self):
                assert (url_normalize(value) == value) == expected, (expected, value, url_normalize(value))
        return test()

    for (expected, value) in tests1:
        suite.addTest(testcase1(expected, value))

    """ mnot test suite; three tests updated for rfc2396bis. """
    tests2 = {
        '/foo/bar/.':
            '/foo/bar/',
        '/foo/bar/./':
            '/foo/bar/',
        '/foo/bar/..':
            '/foo/',
        '/foo/bar/../':
            '/foo/',
        '/foo/bar/../baz':
            '/foo/baz',
        '/foo/bar/../..':
            '/',
        '/foo/bar/../../':
            '/',
        '/foo/bar/../../baz':
            '/baz',
        '/foo/bar/../../../baz':
            '/baz', #was: '/../baz',
        '/foo/bar/../../../../baz':
            '/baz',
        '/./foo':
            '/foo',
        '/../foo':
            '/foo', #was: '/../foo',
        '/foo.':
            '/foo.',
        '/.foo':
            '/.foo',
        '/foo..':
            '/foo..',
        '/..foo':
            '/..foo',
        '/./../foo':
            '/foo', #was: '/../foo',
        '/./foo/.':
            '/foo/',
        '/foo/./bar':
            '/foo/bar',
        '/foo/../bar':
            '/bar',
        '/foo//':
            '/foo/',
        '/foo///bar//':
            '/foo/bar/',
        'http://www.foo.com:80/foo':
            'http://www.foo.com/foo',
        'http://www.foo.com:8000/foo':
            'http://www.foo.com:8000/foo',
        'http://www.foo.com./foo/bar.html':
            'http://www.foo.com/foo/bar.html',
        'http://www.foo.com.:81/foo':
            'http://www.foo.com:81/foo',
        'http://www.foo.com/%7ebar':
            'http://www.foo.com/~bar',
        'http://www.foo.com/%7Ebar':
            'http://www.foo.com/~bar',
        'ftp://user:pass@ftp.foo.net/foo/bar':
             'ftp://user:pass@ftp.foo.net/foo/bar',
        'http://USER:pass@www.Example.COM/foo/bar':
             'http://USER:pass@www.example.com/foo/bar',
        'http://www.example.com./':
            'http://www.example.com/',
        '-':
            '-',
        'пример.испытание/Служебная:Search/Test':
            'http://xn--e1afmkfd.xn--80akhbyknj4f/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:Search/Test',
        'http://lifehacker.com/#!5753509/hello-world-this-is-the-new-lifehacker':
            'http://lifehacker.com/?_escaped_fragment_=5753509/hello-world-this-is-the-new-lifehacker',
    }

    def testcase2(original, normalized):

        class test(unittest.TestCase):

            def runTest(self):
                assert url_normalize(original) == normalized, (original, normalized, url_normalize(original))
        return test()

    for (original, normalized) in tests2.items():
        suite.addTest(testcase2(original, normalized))

    """ execute tests """
    unittest.TextTestRunner().run(suite)

########NEW FILE########
__FILENAME__ = models
#-*- coding: utf-8 -*-


"""OAuth 2.0 Django Models"""


import time
from hashlib import sha512
from uuid import uuid4
from django.db import models
from django.contrib.auth.models import User
from .consts import CLIENT_KEY_LENGTH, CLIENT_SECRET_LENGTH
from .consts import SCOPE_LENGTH
from .consts import ACCESS_TOKEN_LENGTH, REFRESH_TOKEN_LENGTH
from .consts import ACCESS_TOKEN_EXPIRATION, MAC_KEY_LENGTH, REFRESHABLE
from .consts import CODE_KEY_LENGTH, CODE_EXPIRATION


class TimestampGenerator(object):
    """Callable Timestamp Generator that returns a UNIX time integer.

    **Kwargs:**

    * *seconds:* A integer indicating how many seconds in the future the
      timestamp should be. *Default 0*

    *Returns int*
    """
    def __init__(self, seconds=0):
        self.seconds = seconds

    def __call__(self):
        return int(time.time()) + self.seconds


class KeyGenerator(object):
    """Callable Key Generator that returns a random keystring.

    **Args:**

    * *length:* A integer indicating how long the key should be.

    *Returns str*
    """
    def __init__(self, length):
        self.length = length

    def __call__(self):
        return sha512(uuid4().hex).hexdigest()[0:self.length]


class Client(models.Model):
    """Stores client authentication data.

    **Args:**

    * *name:* A string representing the client name.
    * *user:* A django.contrib.auth.models.User object representing the client
       owner.

    **Kwargs:**

    * *description:* A string representing the client description.
      *Default None*
    * *key:* A string representing the client key. *Default 30 character
      random string*
    * *secret:* A string representing the client secret. *Default 30 character
      random string*
    * *redirect_uri:* A string representing the client redirect_uri.
      *Default None*

    """
    name = models.CharField(max_length=256)
    user = models.ForeignKey(User)
    description = models.TextField(null=True, blank=True)
    key = models.CharField(
        unique=True,
        max_length=CLIENT_KEY_LENGTH,
        default=KeyGenerator(CLIENT_KEY_LENGTH),
        db_index=True)
    secret = models.CharField(
        unique=True,
        max_length=CLIENT_SECRET_LENGTH,
        default=KeyGenerator(CLIENT_SECRET_LENGTH))
    redirect_uri = models.URLField(null=True)


class AccessRange(models.Model):
    """Stores access range data, also known as scope.

    **Args:**

    * *key:* A string representing the access range scope. Used in access
      token requests.

    **Kwargs:**

    * *description:* A string representing the access range description.
      *Default None*

    """
    key = models.CharField(unique=True, max_length=SCOPE_LENGTH, db_index=True)
    description = models.TextField(blank=True)


class AccessToken(models.Model):
    """Stores access token data.

    **Args:**

    * *client:* A oauth2app.models.Client object
    * *user:* A django.contrib.auth.models.User object

    **Kwargs:**

    * *token:* A string representing the access key token. *Default 10
      character random string*
    * *refresh_token:* A string representing the access key token. *Default 10
      character random string*
    * *mac_key:* A string representing the MAC key. *Default None*
    * *expire:* A positive integer timestamp representing the access token's
      expiration time.
    * *scope:* A list of oauth2app.models.AccessRange objects. *Default None*
    * *refreshable:* A boolean that indicates whether this access token is
      refreshable. *Default False*

    """
    client = models.ForeignKey(Client)
    user = models.ForeignKey(User)
    token = models.CharField(
        unique=True,
        max_length=ACCESS_TOKEN_LENGTH,
        default=KeyGenerator(ACCESS_TOKEN_LENGTH),
        db_index=True)
    refresh_token = models.CharField(
        unique=True,
        blank=True,
        null=True,
        max_length=REFRESH_TOKEN_LENGTH,
        default=KeyGenerator(REFRESH_TOKEN_LENGTH),
        db_index=True)
    mac_key = models.CharField(
        unique=True,
        blank=True,
        null=True,
        max_length=MAC_KEY_LENGTH,
        default=None)
    issue = models.PositiveIntegerField(
        editable=False,
        default=TimestampGenerator())
    expire = models.PositiveIntegerField(
        default=TimestampGenerator(ACCESS_TOKEN_EXPIRATION))
    scope = models.ManyToManyField(AccessRange)
    refreshable = models.BooleanField(default=REFRESHABLE)


class Code(models.Model):
    """Stores authorization code data.

    **Args:**

    * *client:* A oauth2app.models.Client object
    * *user:* A django.contrib.auth.models.User object

    **Kwargs:**

    * *key:* A string representing the authorization code. *Default 30
      character random string*
    * *expire:* A positive integer timestamp representing the access token's
      expiration time.
    * *redirect_uri:* A string representing the redirect_uri provided by the
      requesting client when the code was issued. *Default None*
    * *scope:* A list of oauth2app.models.AccessRange objects. *Default None*

    """
    client = models.ForeignKey(Client)
    user = models.ForeignKey(User)
    key = models.CharField(
        unique=True,
        max_length=CODE_KEY_LENGTH,
        default=KeyGenerator(CODE_KEY_LENGTH),
        db_index=True)
    issue = models.PositiveIntegerField(
        editable=False,
        default=TimestampGenerator())
    expire = models.PositiveIntegerField(
        default=TimestampGenerator(CODE_EXPIRATION))
    redirect_uri = models.URLField(null=True)
    scope = models.ManyToManyField(AccessRange)


class MACNonce(models.Model):
    """Stores Nonce strings for use with MAC Authentication.

    **Args:**

    * *access_token:* A oauth2app.models.AccessToken object
    * *nonce:* A unique nonce string.

    """
    access_token = models.ForeignKey(AccessToken)
    nonce = models.CharField(max_length=30, db_index=True)

########NEW FILE########
__FILENAME__ = token
#-*- coding: utf-8 -*-


"""OAuth 2.0 Token Generation"""


try: import simplejson as json
except ImportError: import json
from base64 import b64encode
from django.http import HttpResponse
from django.contrib.auth import authenticate
from django.views.decorators.csrf import csrf_exempt
from .exceptions import OAuth2Exception
from .consts import ACCESS_TOKEN_EXPIRATION, REFRESH_TOKEN_LENGTH
from .consts import AUTHENTICATION_METHOD, MAC, BEARER, MAC_KEY_LENGTH
from .consts import REFRESHABLE
from .lib.uri import normalize
from .models import Client, AccessRange, Code, AccessToken, TimestampGenerator
from .models import KeyGenerator


class AccessTokenException(OAuth2Exception):
    """Access Token exception base class."""
    pass


class UnvalidatedRequest(OAuth2Exception):
    """The method requested requires a validated request to continue."""
    pass


class InvalidRequest(AccessTokenException):
    """The request is missing a required parameter, includes an
    unsupported parameter or parameter value, repeats a
    parameter, includes multiple credentials, utilizes more
    than one mechanism for authenticating the client, or is
    otherwise malformed."""
    error = 'invalid_request'


class InvalidClient(AccessTokenException):
    """Client authentication failed (e.g. unknown client, no
    client credentials included, multiple client credentials
    included, or unsupported credentials type)."""
    error = 'invalid_client'


class UnauthorizedClient(AccessTokenException):
    """The client is not authorized to request an authorization
    code using this method."""
    error = 'unauthorized_client'


class InvalidGrant(AccessTokenException):
    """The provided authorization grant is invalid, expired,
    revoked, does not match the redirection URI used in the
    authorization request, or was issued to another client."""
    error = 'invalid_grant'


class UnsupportedGrantType(AccessTokenException):
    """The authorization grant type is not supported by the
    authorization server."""
    error = 'unsupported_grant_type'


class InvalidScope(AccessTokenException):
    """The requested scope is invalid, unknown, malformed, or
    exceeds the scope granted by the resource owner."""
    error = 'invalid_scope'


@csrf_exempt
def handler(request):
    """Token access handler. Conveneince function that wraps the Handler()
    callable.

    **Args:**

    * *request:* Django HttpRequest object.
    """
    return TokenGenerator()(request)


class TokenGenerator(object):
    """Token access handler. Validates authorization codes, refresh tokens,
    username/password pairs, and generates a JSON formatted authorization code.

    **Args:**

    * *request:* Django HttpRequest object.

    **Kwargs:**

    * *scope:* An iterable of oauth2app.models.AccessRange objects representing
      the scope the token generator will grant. *Default None*
    * *authentication_method:* Type of token to generate. Possible
      values are: oauth2app.consts.MAC and oauth2app.consts.BEARER
      *Default oauth2app.consts.BEARER*
    * *refreshable:* Boolean value indicating whether issued tokens are
      refreshable. *Default True*
    """

    valid = False
    code = None
    client = None
    access_token = None
    user = None
    error = None
    request = None

    def __init__(
            self,
            scope=None,
            authentication_method=AUTHENTICATION_METHOD,
            refreshable=REFRESHABLE):
        self.refreshable = refreshable
        if authentication_method not in [BEARER, MAC]:
            raise OAuth2Exception("Possible values for authentication_method"
                " are oauth2app.consts.MAC and oauth2app.consts.BEARER")
        self.authentication_method = authentication_method
        if scope is None:
            self.authorized_scope = None
        elif isinstance(scope, AccessRange):
            self.authorized_scope = set([scope.key])
        else:
            self.authorized_scope = set([x.key for x in scope])

    @csrf_exempt
    def __call__(self, request):
        """Django view that handles the token endpoint. Returns a JSON formatted
        authorization code.

        **Args:**

        * *request:* Django HttpRequest object.

        """
        self.grant_type = request.REQUEST.get('grant_type')
        self.client_id = request.REQUEST.get('client_id')
        self.client_secret = request.POST.get('client_secret')
        self.scope = request.REQUEST.get('scope')
        if self.scope is not None:
            self.scope = set(self.scope.split())
        # authorization_code, see 4.1.3.  Access Token Request
        self.code_key = request.REQUEST.get('code')
        self.redirect_uri = request.REQUEST.get('redirect_uri')
        # refresh_token, see 6.  Refreshing an Access Token
        self.refresh_token = request.REQUEST.get('refresh_token')
        # password, see 4.3.2. Access Token Request
        self.email = request.REQUEST.get('email')
        self.username = request.REQUEST.get('username')
        self.password = request.REQUEST.get('password')
        # Optional json callback
        self.callback = request.REQUEST.get('callback')
        self.request = request
        try:
            self.validate()
        except AccessTokenException, e:
            return self.error_response()
        return self.grant_response()

    def validate(self):
        """Validate the request. Raises an AccessTokenException if the
        request fails authorization.

        *Returns None*"""
        try:
            self._validate()
        except AccessTokenException, e:
            self.error = e
            raise e
        self.valid = True

    def _validate(self):
        """Validate the request."""
        # Check response type
        if self.grant_type is None:
            raise InvalidRequest('No grant_type provided.')
        if self.grant_type not in [
                "authorization_code",
                "refresh_token",
                "password",
                "client_credentials"]:
            raise UnsupportedGrantType('No grant type: %s' % self.grant_type)
        if self.client_id is None:
            raise InvalidRequest('No client_id')
        try:
            self.client = Client.objects.get(key=self.client_id)
        except Client.DoesNotExist:
            raise InvalidClient("client_id %s doesn't exist" % self.client_id)
        # Scope
        if self.scope is not None:
            access_ranges = AccessRange.objects.filter(key__in=self.scope)
            access_ranges = set(access_ranges.values_list('key', flat=True))
            difference = access_ranges.symmetric_difference(self.scope)
            if len(difference) != 0:
                raise InvalidScope("Following access ranges doesn't exist: "
                    "%s" % ', '.join(difference))
        if self.grant_type == "authorization_code":
            self._validate_authorization_code()
        elif self.grant_type == "refresh_token":
            self._validate_refresh_token()
        elif self.grant_type == "password":
            self._validate_password()
        elif self.grant_type == "client_credentials":
            self._validate_client_credentials()
        else:
            raise UnsupportedGrantType('Unable to validate grant type.')

    def _validate_access_credentials(self):
        """Validate the request's access credentials."""
        if self.client_secret is None and "HTTP_AUTHORIZATION" in self.request.META:
            authorization = self.request.META["HTTP_AUTHORIZATION"]
            auth_type, auth_value = authorization.split()[0:2]
            if auth_type.lower() == "basic":
                credentials = "%s:%s" % (self.client.key, self.client.secret)
                if auth_value != b64encode(credentials):
                    raise InvalidClient('Client authentication failed.')
            else:
                raise InvalidClient('Client authentication failed.')
        elif self.client_secret != self.client.secret:
            raise InvalidClient('Client authentication failed.')

    def _validate_client_credentials(self):
        """Validate a client_credentials request."""
        self._validate_access_credentials()

    def _validate_authorization_code(self):
        """Validate an authorization_code request."""
        if self.code_key is None:
            raise InvalidRequest('No code_key provided')
        self._validate_access_credentials()
        try:
            self.code = Code.objects.get(key=self.code_key)
        except Code.DoesNotExist:
            raise InvalidRequest('No such code: %s' % self.code_key)
        now = TimestampGenerator()()
        if self.code.expire < now:
            raise InvalidGrant("Provided code is expired")
        self.scope = set([x.key for x in self.code.scope.all()])
        if self.redirect_uri is None:
            raise InvalidRequest('No redirect_uri')
        if normalize(self.redirect_uri) != normalize(self.code.redirect_uri):
            raise InvalidRequest("redirect_uri doesn't match")

    def _validate_password(self):
        """Validate a password request."""
        if self.username is None and self.email is None:
            raise InvalidRequest('No username')
        if self.password is None:
            raise InvalidRequest('No password')
        if self.scope is not None:
            access_ranges = AccessRange.objects.filter(key__in=self.scope)
            access_ranges = set(access_ranges.values_list('key', flat=True))
            difference = access_ranges.symmetric_difference(self.scope)
            if len(difference) != 0:
                raise InvalidScope("""Following access ranges do not
                    exist: %s""" % ', '.join(difference))
            if self.authorized_scope is not None:
                new_scope = self.scope - self.authorized_scope
                if len(new_scope) > 0:
                    raise InvalidScope(
                        "Invalid scope request: %s" % ', '.join(new_scope))
        if "HTTP_AUTHORIZATION" in self.request.META:
            authorization = self.request.META["HTTP_AUTHORIZATION"]
            auth_type, auth_value = authorization.split()[0:2]
            if auth_type.lower() == "basic":
                credentials = "%s:%s" % (self.client.key, self.client.secret)
                if auth_value != b64encode(credentials):
                    raise InvalidClient('Client authentication failed.')
            else:
                raise InvalidClient('Client authentication failed.')
        else:
            raise InvalidClient('Client authentication failed.')
        if self.username is not None:
            user = authenticate(username=self.username, password=self.password)
        else:
            user = authenticate(email=self.email, password=self.password)
        if user is not None:
            if not user.is_active:
                raise InvalidRequest('Inactive user.')
        else:
            raise InvalidRequest('User authentication failed.')
        self.user = user

    def _validate_refresh_token(self):
        """Validate a refresh token request."""
        if self.refresh_token is None:
            raise InvalidRequest('No refresh_token')
        try:
            self.access_token = AccessToken.objects.get(
                refresh_token=self.refresh_token)
        except AccessToken.DoesNotExist:
            raise InvalidRequest(
                'No such refresh token: %s' % self.refresh_token)
        self._validate_access_credentials()
        if not self.access_token.refreshable:
            raise InvalidGrant("Access token is not refreshable.")
        if self.scope is not None:
            access_ranges = set([x.key for x in self.access_token.scope.all()])
            new_scope = self.scope - access_ranges
            if len(new_scope) > 0:
                raise InvalidScope("Refresh request requested scopes beyond"
                "initial grant: %s" % new_scope)

    def error_response(self):
        """In the event of an error, return a Django HttpResponse
        with the appropriate JSON encoded error parameters.

        *Returns HttpResponse*"""
        if self.error is not None:
            e = self.error
        else:
            e = InvalidRequest("Access Denied.")
        data = {'error': e.error, 'error_description': u'%s' % e.message}
        json_data = json.dumps(data)
        if self.callback is not None:
            json_data = "%s(%s);" % (self.callback, json_data)
            return HttpResponse(
                content=json_data,
                content_type='application/json')
        else:
            response = HttpResponse(
                content=json_data,
                content_type='application/json')
            if isinstance(self.error, InvalidClient):
                response.status_code = 401
            else:
                response.status_code = 400
            return response

    def grant_response(self):
        """Returns a JSON formatted authorization code."""
        if not self.valid:
            raise UnvalidatedRequest("This request is invalid or has not been"
                " validated.")
        if self.grant_type == "authorization_code":
            access_token = self._get_authorization_code_token()
        elif self.grant_type == "refresh_token":
            access_token = self._get_refresh_token()
        elif self.grant_type == "password":
            access_token = self._get_password_token()
        elif self.grant_type == "client_credentials":
            access_token = self._get_client_credentials_token()
        data = {
            'access_token': access_token.token,
            'expires_in': ACCESS_TOKEN_EXPIRATION}
        if self.authentication_method == MAC:
            data["token_type"] = "mac"
            data["mac_key"] = access_token.mac_key
            data["mac_algorithm"] = "hmac-sha-256"
        elif self.authentication_method == BEARER:
            data["token_type"] = "bearer"
        if access_token.refreshable:
            data['refresh_token'] = access_token.refresh_token
        if self.scope is not None:
            data['scope'] = ' '.join(self.scope)
        json_data = json.dumps(data)
        if self.callback is not None:
            json_data = "%s(%s);" % (self.callback, json_data)
        response = HttpResponse(
            content=json_data,
            content_type='application/json')
        response['Cache-Control'] = 'no-store'
        return response

    def _get_authorization_code_token(self):
        """Generate an access token after authorization_code authorization."""
        access_token = AccessToken.objects.create(
            user=self.code.user,
            client=self.client,
            refreshable=self.refreshable)
        if self.authentication_method == MAC:
            access_token.mac_key = KeyGenerator(MAC_KEY_LENGTH)()
        access_ranges = AccessRange.objects.filter(key__in=self.scope) if self.scope else []
        access_token.scope = access_ranges
        access_token.save()
        self.code.delete()
        return access_token

    def _get_password_token(self):
        """Generate an access token after password authorization."""
        access_token = AccessToken.objects.create(
            user=self.user,
            client=self.client,
            refreshable=self.refreshable)
        if self.authentication_method == MAC:
            access_token.mac_key = KeyGenerator(MAC_KEY_LENGTH)()
        access_ranges = AccessRange.objects.filter(key__in=self.scope) if self.scope else []
        access_token.scope = access_ranges
        access_token.save()
        return access_token

    def _get_refresh_token(self):
        """Generate an access token after refresh authorization."""
        self.access_token.refresh_token = KeyGenerator(REFRESH_TOKEN_LENGTH)()
        self.access_token.expire = TimestampGenerator(ACCESS_TOKEN_EXPIRATION)()
        if self.scope:
            self.access_token.scope = AccessRange.objects.filter(key__in=self.scope)
        elif not self.access_token.scope.exists():
            self.access_token.scope = []
        self.access_token.save()
        return self.access_token

    def _get_client_credentials_token(self):
        """Generate an access token after client_credentials authorization."""
        access_token = AccessToken.objects.create(
            user=self.client.user,
            client=self.client,
            refreshable=self.refreshable)
        if self.authentication_method == MAC:
            access_token.mac_key = KeyGenerator(MAC_KEY_LENGTH)()
        access_ranges = AccessRange.objects.filter(key__in=self.scope) if self.scope else []
        access_token.scope = access_ranges
        access_token.save()
        return access_token

########NEW FILE########
__FILENAME__ = models
#-*- coding: utf-8 -*-
########NEW FILE########
__FILENAME__ = base
#-*- coding: utf-8 -*-

try: import simplejson as json
except ImportError: import json
from django.contrib.auth.models import User
from oauth2app.models import Client
from django.test.client import Client as DjangoTestClient
from django.utils import unittest
from base64 import b64encode
from urlparse import urlparse, parse_qs
from urllib import urlencode

USER_USERNAME = "testuser"
USER_PASSWORD = "testpassword"
USER_EMAIL = "user@example.com"
USER_FIRSTNAME = "Foo"
USER_LASTNAME = "Bar"
CLIENT_USERNAME = "client"
CLIENT_EMAIL = "client@example.com"
REDIRECT_URI = "http://example.com/callback"


class BaseTestCase(unittest.TestCase):

    user = None
    client_holder = None
    client_application = None

    def setUp(self):
        self.user = User.objects.create_user(
            USER_USERNAME,
            USER_EMAIL,
            USER_PASSWORD)
        self.user.first_name = USER_FIRSTNAME
        self.user.last_name = USER_LASTNAME
        self.user.save()
        self.client = User.objects.create_user(CLIENT_USERNAME, CLIENT_EMAIL)
        self.client_application = Client.objects.create(
            name="TestApplication",
            user=self.client)

    def tearDown(self):
        self.user.delete()
        self.client.delete()
        self.client_application.delete()

    def get_token(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"code"}
        response = user.get("/oauth2/authorize_no_scope?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        code = qs['code']
        client = DjangoTestClient()
        parameters = {
            "client_id":self.client_application.key,
            "grant_type":"authorization_code",
            "code":code,
            "redirect_uri":REDIRECT_URI}
        basic_auth = b64encode("%s:%s" % (self.client_application.key, self.client_application.secret))
        response = client.get(
            "/oauth2/token",
            parameters,
            HTTP_AUTHORIZATION="Basic %s" % basic_auth)
        return json.loads(response.content)["access_token"]

########NEW FILE########
__FILENAME__ = bearer
#-*- coding: utf-8 -*-

try: import simplejson as json
except ImportError: import json
from .base import *


class BearerTestCase(BaseTestCase):

    def test_00_bearer(self):
        client = DjangoTestClient()
        token = self.get_token()
        response = client.get(
            "/api/email_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 200)
        response = client.get(
            "/api/email_str",
            {},
            HTTP_AUTHORIZATION="Bearer2 %s" % token)
        self.assertEqual(response.status_code, 401)
        response = client.get(
            "/api/email_str",
            {},
            HTTP_AUTHORIZATION="Bearer !!!%s" % token)
        self.assertEqual(response.status_code, 401)

    def test_01_json_bearer(self):
        client = DjangoTestClient()
        token = self.get_token()
        response = client.get(
            "/api/email_json",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 200)
        self.assertTrue("email" in json.loads(response.content))
        response = client.get(
            "/api/email_json",
            {},
            HTTP_AUTHORIZATION="Bearer2 %s" % token)
        self.assertEqual(response.status_code, 401)
        self.assertTrue("error" in json.loads(response.content))
        response = client.get(
            "/api/email_json",
            {},
            HTTP_AUTHORIZATION="Bearer !!!%s" % token)
        self.assertEqual(response.status_code, 401)
        self.assertTrue("error" in json.loads(response.content))

    def test_02_automatic_fail(self):
        client = DjangoTestClient()
        token = self.get_token()
        response = client.get(
            "/api/automatic_error_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 401)
        response = client.get(
            "/api/automatic_error_json",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 401)

########NEW FILE########
__FILENAME__ = config
#-*- coding: utf-8 -*-

from django.utils import unittest
from oauth2app.exceptions import OAuth2Exception
from oauth2app.authorize import Authorizer
from oauth2app.authenticate import Authenticator

class ConfigTestCase(unittest.TestCase):
    
    def test_00_authorize(self):
        self.assertRaises(OAuth2Exception, Authorizer, response_type=-1)
        self.assertRaises(OAuth2Exception, Authorizer, authentication_method=-1)

    def test_01_authenticate(self):
        self.assertRaises(OAuth2Exception, Authenticator, authentication_method=-1)
    
########NEW FILE########
__FILENAME__ = granttype
#-*- coding: utf-8 -*-

try: import simplejson as json
except ImportError: import json
from base64 import b64encode
from django.utils import unittest
from django.contrib.auth.models import User
from oauth2app.models import Client
from django.test.client import Client as DjangoTestClient


USER_USERNAME = "testuser"
USER_PASSWORD = "testpassword"
USER_EMAIL = "user@example.com"
USER_FIRSTNAME = "Foo"
USER_LASTNAME = "Bar"
CLIENT_USERNAME = "client"
CLIENT_EMAIL = "client@example.com"
REDIRECT_URI = "http://example.com/callback"


class GrantTypeTestCase(unittest.TestCase):

    user = None
    client_holder = None
    client_application = None

    def setUp(self):
        self.user = User.objects.create_user(
            USER_USERNAME,
            USER_EMAIL,
            USER_PASSWORD)
        self.user.first_name = USER_FIRSTNAME
        self.user.last_name = USER_LASTNAME
        self.user.save()
        self.client = User.objects.create_user(CLIENT_USERNAME, CLIENT_EMAIL)
        self.client_application = Client.objects.create(
            name="TestApplication",
            user=self.client)

    def tearDown(self):
        self.user.delete()
        self.client.delete()
        self.client_application.delete()

    def test_00_grant_type_client_credentials(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        client = DjangoTestClient()
        parameters = {
            "client_id": self.client_application.key,
            "grant_type": "client_credentials",
            "redirect_uri": REDIRECT_URI}
        basic_auth = b64encode("%s:%s" % (self.client_application.key,
            self.client_application.secret))
        response = client.get(
            "/oauth2/token",
            parameters,
            HTTP_AUTHORIZATION="Basic %s" % basic_auth)
        token = json.loads(response.content)

########NEW FILE########
__FILENAME__ = json
#-*- coding: utf-8 -*-

try: import simplejson as json
except ImportError: import json
from .base import *

class JSONTestCase(BaseTestCase):

    def test_00_email(self):
        client = DjangoTestClient()
        token = self.get_token()
        # Sufficient scope.
        response = client.get(
            "/api/email_json",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(json.loads(response.content)["email"], USER_EMAIL)
        response = client.get(
            "/api/email_json?callback=foo",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 200)
        # Remove the JSON callback.
        content = response.content.replace("foo(", "").replace(");", "")
        self.assertEqual(json.loads(content)["email"], USER_EMAIL)
        response = client.get(
            "/api/email_json?callback=foo",
            {},
            HTTP_AUTHORIZATION="Bearer !!!%s" % token)
        content = response.content.replace("foo(", "").replace(");", "")
        self.assertEqual(response.status_code, 200)
        self.assertTrue("error" in json.loads(content))

########NEW FILE########
__FILENAME__ = mac
#-*- coding: utf-8 -*-

try: import simplejson as json
except ImportError: import json
from base64 import b64encode
from urlparse import urlparse, parse_qs
from urllib import urlencode
from django.utils import unittest
from django.contrib.auth.models import User
from oauth2app.models import Client
from django.test.client import Client as DjangoTestClient


USER_USERNAME = "testuser"
USER_PASSWORD = "testpassword"
USER_EMAIL = "user@example.com"
USER_FIRSTNAME = "Foo"
USER_LASTNAME = "Bar"
CLIENT_USERNAME = "client"
CLIENT_EMAIL = "client@example.com"
REDIRECT_URI = "http://example.com/callback"


class MACTestCase(unittest.TestCase):

    user = None
    client_holder = None
    client_application = None

    def setUp(self):
        self.user = User.objects.create_user(
            USER_USERNAME,
            USER_EMAIL,
            USER_PASSWORD)
        self.user.first_name = USER_FIRSTNAME
        self.user.last_name = USER_LASTNAME
        self.user.save()
        self.client = User.objects.create_user(CLIENT_USERNAME, CLIENT_EMAIL)
        self.client_application = Client.objects.create(
            name="TestApplication",
            user=self.client)

    def tearDown(self):
        self.user.delete()
        self.client.delete()
        self.client_application.delete()

    def test_00_mac(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"code"}
        response = user.get("/oauth2/authorize_mac?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        code = qs['code']
        client = DjangoTestClient()
        parameters = {
            "client_id":self.client_application.key,
            "grant_type":"authorization_code",
            "code":code,
            "redirect_uri":REDIRECT_URI}
        basic_auth = b64encode("%s:%s" % (self.client_application.key, self.client_application.secret))
        response = client.get(
            "/oauth2/token_mac",
            parameters,
            HTTP_AUTHORIZATION="Basic %s" % basic_auth)
        token = json.loads(response.content)


########NEW FILE########
__FILENAME__ = responsetype
#-*- coding: utf-8 -*-

from urlparse import urlparse, parse_qs
from urllib import urlencode
from django.utils import unittest
from django.test.client import Client as DjangoTestClient
from django.contrib.auth.models import User
from oauth2app.models import Client


USER_USERNAME = "testuser"
USER_PASSWORD = "testpassword"
USER_EMAIL = "user@example.com"
USER_FIRSTNAME = "Foo"
USER_LASTNAME = "Bar"
CLIENT_USERNAME = "client"
CLIENT_EMAIL = "client@example.com"
REDIRECT_URI = "http://example.com/callback"


class ResponseTypeTestCase(unittest.TestCase):

    user = None
    client_holder = None
    client_application = None

    def setUp(self):
        self.user = User.objects.create_user(
            USER_USERNAME,
            USER_EMAIL,
            USER_PASSWORD)
        self.user.first_name = USER_FIRSTNAME
        self.user.last_name = USER_LASTNAME
        self.user.save()
        self.client = User.objects.create_user(CLIENT_USERNAME, CLIENT_EMAIL)
        self.client_application = Client.objects.create(
            name="TestApplication",
            user=self.client)

    def tearDown(self):
        self.user.delete()
        self.client.delete()
        self.client_application.delete()

    def test_00_code(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"code"}
        response = user.get("/oauth2/authorize_code?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        self.assertTrue("code" in qs)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"token"}
        response = user.get("/oauth2/authorize_code?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        self.assertTrue("error" in qs)

    def test_01_token(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"token"}
        response = user.get("/oauth2/authorize_token?%s" % urlencode(parameters))
        fs = parse_qs(urlparse(response['location']).fragment)
        self.assertTrue("access_token" in fs)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"code"}
        response = user.get("/oauth2/authorize_token?%s" % urlencode(parameters))
        fs = parse_qs(urlparse(response['location']).fragment)
        self.assertTrue("error" in fs)

    def test_02_token_mac(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"token"}
        response = user.get("/oauth2/authorize_token_mac?%s" % urlencode(parameters))
        fs = parse_qs(urlparse(response['location']).fragment)
        self.assertTrue("mac_key" in fs)

    def test_03_code_and_token(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"code"}
        response = user.get("/oauth2/authorize_code_and_token?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        self.assertTrue("code" in qs)
        fs = parse_qs(urlparse(response['location']).fragment)
        self.assertTrue("access_token" not in fs)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"token"}
        response = user.get("/oauth2/authorize_code_and_token?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        self.assertTrue("code" not in qs)
        fs = parse_qs(urlparse(response['location']).fragment)
        self.assertTrue("access_token" in fs)

    def test_04_invalid_response_type(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"blah"}
        response = user.get("/oauth2/authorize_code_and_token?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        self.assertTrue("error" in qs)

########NEW FILE########
__FILENAME__ = scope
#-*- coding: utf-8 -*-

try: import simplejson as json
except ImportError: import json
from base64 import b64encode
from urlparse import urlparse, parse_qs
from urllib import urlencode
from django.utils import unittest
from django.test.client import Client as DjangoTestClient
from django.contrib.auth.models import User
from oauth2app.models import Client


USER_USERNAME = "testuser"
USER_PASSWORD = "testpassword"
USER_EMAIL = "user@example.com"
USER_FIRSTNAME = "Foo"
USER_LASTNAME = "Bar"
CLIENT_USERNAME = "client"
CLIENT_EMAIL = "client@example.com"
REDIRECT_URI = "http://example.com/callback"


class ScopeTestCase(unittest.TestCase):

    user = None
    client_holder = None
    client_application = None

    def setUp(self):
        self.user = User.objects.create_user(
            USER_USERNAME,
            USER_EMAIL,
            USER_PASSWORD)
        self.user.first_name = USER_FIRSTNAME
        self.user.last_name = USER_LASTNAME
        self.user.save()
        self.client = User.objects.create_user(CLIENT_USERNAME, CLIENT_EMAIL)
        self.client_application = Client.objects.create(
            name="TestApplication",
            user=self.client)

    def tearDown(self):
        self.user.delete()
        self.client.delete()
        self.client_application.delete()

    def test_00_first_name_scope(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "scope":"first_name",
            "redirect_uri":REDIRECT_URI,
            "response_type":"code"}
        response = user.get("/oauth2/authorize_first_name?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        code = qs['code']
        client = DjangoTestClient()
        parameters = {
            "client_id":self.client_application.key,
            "grant_type":"authorization_code",
            "code":code,
            "redirect_uri":REDIRECT_URI,
            "scope":"first_name"}
        basic_auth = b64encode("%s:%s" % (self.client_application.key, self.client_application.secret))
        response = client.get(
            "/oauth2/token",
            parameters,
            HTTP_AUTHORIZATION="Basic %s" % basic_auth)
        token = json.loads(response.content)["access_token"]
        # Sufficient scope.
        response = client.get(
            "/api/first_name_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, USER_FIRSTNAME)
        # Insufficient scope for last_name
        response = client.get(
            "/api/last_name_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 403)
        self.assertTrue("insufficient_scope" in str(response))
        # Insufficient scope for first_name, last_name
        response = client.get(
            "/api/first_and_last_name_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 403)
        self.assertTrue("insufficient_scope" in str(response))

    def test_01_no_scope(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "redirect_uri":REDIRECT_URI,
            "response_type":"code"}
        response = user.get("/oauth2/authorize_no_scope?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        code = qs['code']
        client = DjangoTestClient()
        parameters = {
            "client_id":self.client_application.key,
            "grant_type":"authorization_code",
            "code":code,
            "redirect_uri":REDIRECT_URI}
        basic_auth = b64encode("%s:%s" % (self.client_application.key, self.client_application.secret))
        response = client.get(
            "/oauth2/token",
            parameters,
            HTTP_AUTHORIZATION="Basic %s" % basic_auth)
        token = json.loads(response.content)["access_token"]
        # Sufficient scope.
        response = client.get(
            "/api/email_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, USER_EMAIL)
        # Insufficient scope for first_name, last_name
        response = client.get(
            "/api/first_and_last_name_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 403)
        self.assertTrue("insufficient_scope" in str(response))
        # Insufficient scope for last_name
        response = client.get(
            "/api/last_name_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 403)
        self.assertTrue("insufficient_scope" in str(response))

    def test_02_dual_scope(self):
        user = DjangoTestClient()
        user.login(username=USER_USERNAME, password=USER_PASSWORD)
        parameters = {
            "client_id":self.client_application.key,
            "scope":"first_name last_name",
            "redirect_uri":REDIRECT_URI,
            "response_type":"code"}
        response = user.get("/oauth2/authorize_first_and_last_name?%s" % urlencode(parameters))
        qs = parse_qs(urlparse(response['location']).query)
        code = qs['code']
        client = DjangoTestClient()
        parameters = {
            "client_id":self.client_application.key,
            "grant_type":"authorization_code",
            "code":code,
            "redirect_uri":REDIRECT_URI,
            "scope":"first_name last_name"}
        basic_auth = b64encode("%s:%s" % (self.client_application.key, self.client_application.secret))
        response = client.get(
            "/oauth2/token",
            parameters,
            HTTP_AUTHORIZATION="Basic %s" % basic_auth)
        token = json.loads(response.content)["access_token"]
        # Sufficient scope.
        response = client.get(
            "/api/first_and_last_name_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, USER_FIRSTNAME + " " + USER_LASTNAME)
        # Sufficient scope.
        response = client.get(
            "/api/first_name_str",
            {},
            HTTP_AUTHORIZATION="Bearer %s" % token)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, USER_FIRSTNAME)


########NEW FILE########
__FILENAME__ = urls
#-*- coding: utf-8 -*-
from django.conf.urls.defaults import patterns, url

urlpatterns = patterns('testsite.apps.api.views',
    (r'^automatic_error_str/?$',        'automatic_error_str'),
    (r'^automatic_error_json/?$',       'automatic_error_json'),
    (r'^first_name_str/?$',             'first_name_str'),
    (r'^first_and_last_name_str/?$',    'first_and_last_name_str'),
    (r'^last_name_str/?$',              'last_name_str'),
    (r'^email_str/?$',                  'email_str'),
    (r'^email_json/?$',                 'email_json'))
    
########NEW FILE########
__FILENAME__ = views
#-*- coding: utf-8 -*-


from oauth2app.authenticate import Authenticator, JSONAuthenticator
from oauth2app.authenticate import AuthenticationException
from oauth2app.models import AccessRange
from django.http import HttpResponse

def automatic_error_str(request):
    authenticator = Authenticator()
    return authenticator.error_response()

def automatic_error_json(request):
    authenticator = JSONAuthenticator()
    return authenticator.error_response()

def first_name_str(request):
    scope = AccessRange.objects.get(key="first_name")
    authenticator = Authenticator(scope=scope)
    try:
        authenticator.validate(request)
    except AuthenticationException:
        return authenticator.error_response()
    return HttpResponse(authenticator.user.first_name)


def last_name_str(request):
    scope = AccessRange.objects.get(key="last_name")
    authenticator = Authenticator(scope=scope)
    try:
        authenticator.validate(request)
    except AuthenticationException:
        return authenticator.error_response()
    return HttpResponse(authenticator.user.last_name)

def first_and_last_name_str(request):
    scope = AccessRange.objects.filter(key__in=["first_name", "last_name"])
    authenticator = Authenticator(scope=scope)
    try:
        authenticator.validate(request)
    except AuthenticationException:
        return authenticator.error_response()
    return HttpResponse(authenticator.user.first_name +  " " + authenticator.user.last_name)

def email_str(request):
    authenticator = Authenticator()
    try:
        authenticator.validate(request)
    except AuthenticationException:
        return authenticator.error_response()
    return HttpResponse(authenticator.user.email)


def email_json(request):
    authenticator = JSONAuthenticator()
    try:
        authenticator.validate(request)
    except AuthenticationException:
        return authenticator.error_response()
    return authenticator.response({"email":authenticator.user.email})



########NEW FILE########
__FILENAME__ = urls
#-*- coding: utf-8 -*-
from django.conf.urls.defaults import patterns, url
from oauth2app.token import TokenGenerator
from oauth2app.consts import MAC

urlpatterns = patterns('',
        (r'^missing_redirect_uri/?$',           'testsite.apps.oauth2.views.missing_redirect_uri'),
        (r'^authorize_not_refreshable/?$',      'testsite.apps.oauth2.views.authorize_not_refreshable'),     
        (r'^authorize_mac/?$',                  'testsite.apps.oauth2.views.authorize_mac'),        
        (r'^authorize_first_name/?$',           'testsite.apps.oauth2.views.authorize_first_name'),
        (r'^authorize_first_name/?$',           'testsite.apps.oauth2.views.authorize_last_name'),
        (r'^authorize_first_and_last_name/?$',  'testsite.apps.oauth2.views.authorize_first_and_last_name'),
        (r'^authorize_no_scope/?$',             'testsite.apps.oauth2.views.authorize_no_scope'),
        (r'^authorize_code/?$',                 'testsite.apps.oauth2.views.authorize_code'),
        (r'^authorize_token/?$',                'testsite.apps.oauth2.views.authorize_token'),
        (r'^authorize_token_mac/?$',            'testsite.apps.oauth2.views.authorize_token_mac'),
        (r'^authorize_code_and_token/?$',       'testsite.apps.oauth2.views.authorize_code_and_token'),
        (r'^token/?$',                          'oauth2app.token.handler'),
        (r'^token_mac/?$',                      TokenGenerator(authentication_method=MAC))
)


########NEW FILE########
__FILENAME__ = views
#-*- coding: utf-8 -*-


from django.http import HttpResponseRedirect, HttpResponse
from django.contrib.auth.decorators import login_required
from oauth2app.authorize import Authorizer, MissingRedirectURI, AuthorizationException
from oauth2app.authorize import UnvalidatedRequest, UnauthenticatedUser
from oauth2app.models import AccessRange
from oauth2app.consts import MAC, CODE, TOKEN, CODE_AND_TOKEN


@login_required
def missing_redirect_uri(request):
    return HttpResponse("Missing Redirect URI")


@login_required
def authorize_not_refreshable(request):
    authorizer = Authorizer(refreshable=False)
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")

@login_required
def authorize_mac(request):
    authorizer = Authorizer(authentication_method=MAC)
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")


@login_required
def authorize_first_name(request):
    scope = AccessRange.objects.get(key="first_name")
    authorizer = Authorizer(scope=scope)
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")


@login_required
def authorize_first_and_last_name(request):
    scope = AccessRange.objects.filter(key__in=["first_name", "last_name"])
    authorizer = Authorizer(scope=scope)
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")


@login_required
def authorize_last_name(request):
    scope = AccessRange.objects.get(key="last_name")
    authorizer = Authorizer(scope=scope)
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")


@login_required
def authorize_no_scope(request):
    authorizer = Authorizer()
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")


@login_required
def authorize_code(request):
    authorizer = Authorizer(response_type=CODE)
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")

@login_required
def authorize_token_mac(request):
    authorizer = Authorizer(response_type=TOKEN, authentication_method=MAC)
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")

@login_required
def authorize_token(request):
    authorizer = Authorizer(response_type=TOKEN)
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")

@login_required
def authorize_code_and_token(request):
    authorizer = Authorizer(response_type=CODE_AND_TOKEN)
    try:
        return authorizer(request)
    except MissingRedirectURI, e:
        return HttpResponseRedirect("/oauth2/missing_redirect_uri")

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for oauth2app example mysite project.

import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = ()

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': 'testsite.sqlite',      
        'USER': '',      
        'PASSWORD': '',  
        'HOST': '',      
        'PORT': '',      
    }
}

FIXTURE_DIRS = (
   os.path.join(os.path.dirname(__file__), 'apps/account/fixtures'),
)

TIME_ZONE = 'America/Chicago'

LANGUAGE_CODE = 'en-us'

SITE_ID = 1

USE_I18N = True

USE_L10N = True

LOGIN_URL = "/account/login"

MEDIA_ROOT = ''

MEDIA_URL = ''

STATIC_ROOT = ''

STATIC_URL = '/static/'

ADMIN_MEDIA_PREFIX = '/static/admin/'

STATICFILES_DIRS = (os.path.join(os.path.dirname(__file__), 'static'),)

STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

SECRET_KEY = '=hf03e+08xlolbb$!-s01m-n_4xn*5mdsd!pm@$+ms!pe08f-7'

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.core.context_processors.request',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'testsite.urls'

TEMPLATE_DIRS = (os.path.join(os.path.dirname(__file__), 'templates'),)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'testsite.apps.api',
    'testsite.apps.oauth2',
    'oauth2app')

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

TEST_RUNNER = 'django-test-coverage.runner.run_tests'
COVERAGE_MODULES = (
    'oauth2app.authenticate', 
    'oauth2app.authorize', 
    'oauth2app.models', 
    'oauth2app.token',
    'oauth2app.lib.uri',)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url
from django.conf import settings

urlpatterns = patterns('',
    (r'^oauth2/', include('testsite.apps.oauth2.urls')),
    (r'^api/', include('testsite.apps.api.urls')),
    (r'^account/', include('testsite.apps.account.urls')),
)

########NEW FILE########
