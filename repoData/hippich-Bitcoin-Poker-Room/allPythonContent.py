__FILENAME__ = pokercards
#
# Copyright (C) 2006 - 2010 Loic Dachary <loic@dachary.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep
#
# Mekensleep
# 26 rue des rosiers
# 75004 Paris
#       licensing@mekensleep.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Henry Precheur <henry@precheur.org> (2004)
#

from types import *
from pokereval import PokerEval

def visible_card(card):
    return (card & PokerCards.VALUE_CARD_MASK)

def not_visible_card(card):
    return (card | PokerCards.NOT_VISIBLE_CARD)

def is_visible(card):
    return (card & PokerCards.VISIBLE_CARD_MASK) == PokerCards.VISIBLE_CARD

def card_value(card):
    return (card & PokerCards.VALUE_CARD_MASK)

letter2name = {
    'A': 'Ace',
    'K': 'King',
    'Q': 'Queen',
    'J': 'Jack',
    'T': 'Ten',
    '9': 'Nine',
    '8': 'Eight',
    '7': 'Seven',
    '6': 'Six',
    '5': 'Five',
    '4': 'Four',
    '3': 'Trey',
    '2': 'Deuce'
    }

letter2names = {
    'A': 'Aces',
    'K': 'Kings',
    'Q': 'Queens',
    'J': 'Jacks',
    'T': 'Tens',
    '9': 'Nines',
    '8': 'Eights',
    '7': 'Sevens',
    '6': 'Sixes',
    '5': 'Fives',
    '4': 'Fours',
    '3': 'Treys',
    '2': 'Deuces'
    }

class PokerCards:
    NOCARD = 255
    MAX_CARD = 64 # 64 > 52 cards 0x0100 0000
    NB_CARD = 52
    
    VALUE_CARD_MASK = MAX_CARD - 1 # 0x0011 1111

    VISIBLE_CARD_MASK = 0xC0 # ~(VALUE_CARD_MASK) # ~(0x0011 1111) = 0x1100 0000
    VISIBLE_CARD = 0
    NOT_VISIBLE_CARD = VISIBLE_CARD_MASK
    
    def __init__(self, cards = []):
        self.set(cards)

    def __eq__(self, other):
        if type(self) != type(other): return False
        
        cards = self.cards[:]
        cards.sort()
        other_cards = other.cards[:]
        other_cards.sort()
        return cards == other_cards

    def __ne__(self, other):
        return type(self) != type(other) or not self.__eq__(other)

    def __str__(self):
        return str([ "Card(%d, %s)" %
                     (x & PokerCards.VALUE_CARD_MASK,
                      (x & PokerCards.VISIBLE_CARD_MASK and "not visible") or "visible")
                     for x in self.cards ])
            
    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.cards)

    def nocard(self):
        return PokerCards.NOCARD

    def copy(self):
        other = PokerCards()
        other.cards = [ x for x in self.cards ]
        return other
        
    def getValue(self, card):
        value = None
        if type(card) is StringType:
            eval = PokerEval()
            try:
                value = eval.string2card(card)
            except RuntimeError:
                raise UserWarning, "Invalid card %s" %(card)
        else:
            if card != PokerCards.NOCARD:
                value = card & PokerCards.VALUE_CARD_MASK
                if (value < 0) or (value >= PokerCards.NB_CARD):
                    raise UserWarning, "Invalid card %s" %(card)
                
            value = card
                
        return value
        
    def set(self, cards):
        self.cards = []
        
        if isinstance(cards,PokerCards):
            self.cards = cards.cards[:]
            return
                
        if not type(cards) is ListType:
            cards = [cards]
            
        self.cards = map(self.getValue,cards)
            
    def add(self, card, visible):
        card_value = self.getValue(card)
        self.cards.append(card_value | ((not visible and PokerCards.NOT_VISIBLE_CARD) or PokerCards.VISIBLE_CARD))
        
    def allVisible(self):
        for i in xrange(len(self.cards)):
            self.cards[i] = visible_card(self.cards[i])
        
    def allHidden(self):
        for i in xrange(len(self.cards)):
            self.cards[i] = not_visible_card(self.cards[i])

    def hasCard(self, value):
        for card in self.cards:
            if value == self.nocard():
               if card == self.nocard():
                   return True
            elif card & PokerCards.VALUE_CARD_MASK == value:
                return True
        return False

    def areVisible(self):
        for card in self.cards:
            if card & PokerCards.NOT_VISIBLE_CARD:
                return False
        return True
        
    def areHidden(self):
        for card in self.cards:
            if is_visible(card):
                return False
        return True

    def areAllNocard(self):
        for card in self.cards:
            if card != PokerCards.NOCARD:
                return False
        return True
        
    def setVisible(self, value, visible):
        if value == self.nocard():
            return
            
        for i in xrange(len(self.cards)):
            if self.cards[i] & PokerCards.VALUE_CARD_MASK == value:
                if visible:
                    self.cards[i] = visible_card(value)
                else:
                    self.cards[i] = not_visible_card(value)

    def tolist(self, show_all):
        result = []
        for card in self.cards:
            if is_visible(card) or show_all and card != PokerCards.NOCARD:
                result.append(card_value(card))
            else:
                result.append(self.nocard())
        return result

    def toRawList(self):
        return self.cards[:]

    def getVisible(self):
        return filter(lambda card: is_visible(card), self.cards)
    
    def isEmpty(self):
        return len(self.cards) == 0

    def len(self):
        return len(self.cards)

    def loseNotVisible(self):
        self.cards = map(lambda card: card & PokerCards.NOT_VISIBLE_CARD and PokerCards.NOCARD or card, self.cards)

########NEW FILE########
__FILENAME__ = pokerchips
#
# Copyright (C) 2006 - 2010 Loic Dachary <loic@dachary.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep
#
# Mekensleep
# 26 rue des rosiers
# 75004 Paris
#       licensing@mekensleep.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Henry Precheur <henry@precheur.org> (2004)
#
import sys
from types import *

MAX_CHIPS_PER_STACK = 23
INT2CHIPS_FACTOR = 0.3

class PokerChips:

    def __init__(self, values, what = False):
        self.remainder = 0
        self.values = values
        self.size = len(self.values)
        if what == False:
            self.reset()
            return
        
        if type(what) is IntType or type(what) is LongType:
            ( self.chips, self.remainder ) = PokerChips.int2chips(values, INT2CHIPS_FACTOR, what)
            self.limitChips()
        elif type(what) is ListType:
            self.chips = what[:]
            self.remainder = 0
            self.limitChips()
        else:
            self.chips = what.chips[:]
            self.remainder = what.remainder

    def __eq__(self, other):
        if isinstance(other, PokerChips):
            return self.chips == other.chips and self.remainder == other.remainder
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, PokerChips):
            return self.chips != other.chips or self.remainder != other.remainder
        else:
            return True

    def __str__(self):
        return "PokerChips(%s) = %d (-%d)" % (self.chips, self.toint(), self.remainder)

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.chips)

    def copy(self):
        return PokerChips(self.values, self)
    
    def reset(self):
        self.chips = [ 0 ] * self.size
        self.remainder = 0

    def set(self, chips):
        #
        # Must copy because if chips is a PokerChips object it
        # will be a reference to a chips data member used in another
        # object.
        #
        converted = PokerChips.convert(self.values, chips)
        self.chips = converted.chips
        self.remainder = converted.remainder
        self.limitChips()

    def convert(values, what):
        remainder = 0
        if type(what) is IntType or type(what) is LongType:
            ( what, remainder ) = PokerChips.int2chips(values, INT2CHIPS_FACTOR, what)
        if type(what) is ListType:
            chips = PokerChips(values, what)
            chips.remainder += remainder
            return chips
        else:
            return what
        
    convert = staticmethod(convert)

    def add(self, other):
        other = PokerChips.convert(self.values, other)
        self.chips = [ self.chips[i] + other.chips[i] for i in xrange(self.size) ]
        self.remainder += other.remainder
        self.limitChips()

    def subtract(self, other):
        other = PokerChips.convert(self.values, other)
        chips = [ self.chips[i] - other.chips[i] for i in xrange(self.size) ]
        self.remainder -= other.remainder
        if len(filter(lambda x: x < 0, chips)) != 0 or self.remainder < 0:
            res = self.toint() - other.toint()
            if res < 0:
                self.reset()
            else:
                self.set(res)
        else:
            self.chips = chips

    def toint(self):
        return int(sum([ self.chips[i] * self.values[i] for i in xrange(self.size) ])) + self.remainder

    def tolist(self):
        chips = self.chips[:]
        list = []
        for value in self.values:
            count = chips.pop(0)
            if count > 0:
                list.append(value)
                list.append(count)

        if self.remainder > 0:
            if list:
                if list[0] == 1:                
                    # Can not be tested
                    # If the first value is equal to 1, the remainder can not be different than 0
                    raise UserWarning, "pokerchips.py:tolist unexpected remainder > 0 when first chip value is 1 : " + str(self) #pragma: no cover
                else:
                    list.insert(0, self.remainder)
                    list.insert(0, 1)
            else:
                list = [ 1, self.remainder ]
        
        return list

    def tostring(value):
        string = str(value)
        if value == 0:
            return string
        elif value < 10:
            return "0.0" + string
        elif value < 100:
            return "0." + string
        elif value % 100 == 0:
            return string[:-2]
        else:
            return string[:-2] + '.' + string[-2:]

    tostring = staticmethod(tostring)
                     
    def tofloat(value):
        return value / 100.0

    tofloat = staticmethod(tofloat)
    
    def int2chips(values, factor, money):

        if len(values) > 0:
            chips = [0] * len(values)

            for i in range(len(values) - 1, -1, -1):
                if i == 0:
                    to_distribute = money
                else:
                    to_distribute = money - int(values[i] / factor)
                if to_distribute > 0:
                    chips[i] = to_distribute / values[i]
                    money -= to_distribute - to_distribute % values[i]
        else:
            chips = []

        return ( chips, money )

    int2chips = staticmethod(int2chips)

    def limitChips(self):
        def lcm(a, b):
            def gcm(x, y):
                if y == 0:
                    return x
                else:
                    return gcm(y, x % y)
            return (a * b) / gcm(a, b)
        for i in xrange(len(self.chips) - 1):
            if self.chips[i] > MAX_CHIPS_PER_STACK:
                _lcm = lcm(self.values[i], self.values[i + 1])
                too_many = ( self.chips[i] - MAX_CHIPS_PER_STACK ) * self.values[i]
                moving = too_many - too_many % _lcm
                if moving > 0:
                    self.chips[i] -= moving / self.values[i]
                    self.chips[i + 1] += moving / self.values[i + 1]

########NEW FILE########
__FILENAME__ = pokerengineconfig
#
# Copyright (C) 2006 - 2010 Loic Dachary <loic@dachary.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep
#
# Mekensleep
# 26 rue des rosiers
# 75004 Paris
#       licensing@mekensleep.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
import os
from os.path import exists, expanduser, abspath, isfile
from pokerengine.version import Version, version
import re

import libxml2
import libxslt

class Config:

    upgrades_repository = None
    upgrade_dry_run = False
    verbose = 0

    def __init__(self, dirs):
        self.path = None
        self.header = None
        self.doc = None
        self.dirs = [ expanduser(dir) for dir in dirs ]
        self.version = version

    def __del__(self):
        self.free()

    def free(self):
        if self.doc: self.doc.freeDoc()
        self.doc = None
        if self.header: self.header.xpathFreeContext()
        self.header = None

    def reload(self):
        if self.path is None or self.path == "<string>"\
           or not os.path.exists(self.path):
            return
        self.free()
        self.doc = libxml2.parseFile(self.path)
        self.header = self.doc.xpathNewContext()

    def load(self, path):
        for dir in self.dirs:
            tmppath = abspath(expanduser(dir and (dir + "/" + path) or path ))
            if exists(tmppath):
                self.path = tmppath
                break
        self.free()
        if self.path:
            self.doc = libxml2.parseFile(self.path)
            self.header = self.doc.xpathNewContext()
            if Config.upgrades_repository:
                self.checkVersion("poker_engine_version", version, Config.upgrades_repository)
            return True
        else:
            if self.verbose >= 0: print "Config::load: unable to find %s in directories %s" % ( path, self.dirs )
            return False

    def checkVersion(self, version_attribute, software_version, upgrades_repository, default_version = "1.0.5"):
        version_node = self.header.xpathEval("/child::*/@" + version_attribute)
        if not version_node:
            root_node = self.doc.getRootElement()
            root_node.newProp(version_attribute, default_version)
            if not self.upgrade_dry_run:
                self.save()
            file_version = Version(default_version)
            if self.verbose > 0: print "Config::checkVersion: " + self.path + ": set default version to " + default_version
        else:
            file_version = Version(version_node[0].content)

        if software_version != file_version:
            if software_version > file_version:
                if self.verbose > 0: print "Config::checkVersion: " + str(self.path) + ": launch upgrade from  " + str(file_version) + " to " + str(software_version) + " using repository " + str(upgrades_repository)
                self.upgrade(version_attribute, file_version, software_version, upgrades_repository)
                return False
            else:
                raise Exception, "Config: %s requires an upgrade to software version %s or better" % ( self.path, str(file_version) )
        else:
            if self.verbose > 0: print "Config::checkVersion: " + self.path + ": up to date"
            return True

    def upgrade(self, version_attribute, file_version, software_version, upgrades_repository):
        if upgrades_repository and os.path.exists(upgrades_repository):
            files = map(lambda file: upgrades_repository + "/" + file, os.listdir(upgrades_repository))
            files = filter(lambda file: isfile(file) and ".xsl" in file, files)
            for file in file_version.upgradeChain(software_version, files):
                if self.verbose > 0: print "Config::upgrade: " + self.path + " with " + file
                styledoc = libxml2.parseFile(file)
                style = libxslt.parseStylesheetDoc(styledoc)
                result = style.applyStylesheet(self.doc, None)
                if not self.upgrade_dry_run:
                    style.saveResultToFilename(self.path, result, compression = 0)
                result.freeDoc()
                # apparently deallocated by freeStylesheet
                # styledoc.freeDoc()
                style.freeStylesheet()
                if not self.upgrade_dry_run:
                    self.reload()
        else:
            if self.verbose > 0: print "Config::upgrade: %s is not a directory, ignored" % str(upgrades_repository)
        if not self.upgrade_dry_run:
            self.headerSet("/child::*/@" + version_attribute, str(software_version))
            self.save()

    def save(self):
        if not self.path:
            if self.verbose >= 0: print "unable to write back, invalid path"
            return
        self.doc.saveFile(self.path)

    def headerGetList(self, name):
        result = self.header.xpathEval(name)
        return [o.content for o in result]

    def headerGetInt(self, name):
        string = self.headerGet(name)
        if re.match("[0-9]+$", string):
            return int(string)
        else:
            return 0

    def headerGet(self, name):
        results = self.header.xpathEval(name)
        return results and results[0].content or ""

    def headerSet(self, name, value):
        results = self.header.xpathEval(name)
        results[0].setContent(value)

    def headerGetProperties(self, name):
        results = []
        for node in self.header.xpathEval(name):
            results.append(self.headerNodeProperties(node))
        return results

    def headerNodeProperties(self, node):
        result = {}
        property = node.properties
        while property != None:
            result[property.name] = property.content
            property = property.next
        return result

########NEW FILE########
__FILENAME__ = pokergame
#
# Copyright (C) 2006 - 2010 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep
#
# Mekensleep
# 26 rue des rosiers
# 75004 Paris
# licensing@mekensleep.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>
#  Henry Precheur <henry@precheur.org> (2004)
#
from string import split, join, lower
from pprint import pformat
from datetime import datetime, timedelta
import sys
import re
import struct
import random
import platform
import math

from pokereval import PokerEval

from pokerengine.pokercards import *
from pokerengine.pokerengineconfig import Config
from pokerengine.pokerchips import PokerChips
from pokerengine import pokerrake

from bitstring import BitStream

import locale
import gettext

if float(sys.version[0:3]) > 2.3:
  gettext.bind_textdomain_codeset('poker-engine','UTF-8')

def init_i18n(locale_dir, overrideTranslationFunction = None):

  global _

  # If we've been fed the function that we know will work to translate
  # text, then we just set _() to that.  This is to support the scenario
  # where users of this library want to provide their own setup for
  # gettext() (i.e., to switch languages on the fly, as
  # pokernetwork.pokeravatar does).

  # Note that we return the _() that is being replaced.  This is done so
  # that the function can be restored by the caller, should it chose to do
  # so.

  # First, if our _() has never been defined, we simply set it to None
  try:
    oldTranslationFunction = _
  except NameError:
    oldTranslationFunction = None

  if callable(overrideTranslationFunction):
    _ = overrideTranslationFunction
    return oldTranslationFunction

  lang = ''

  if platform.system() == "Windows":
    lang = locale.getdefaultlocale()[0][:2]
    if locale_dir == None:
      locale_dir = './../../locale'

  try:
    t = gettext.translation('poker-engine', localedir=locale_dir, languages=[lang])
    _ = t.gettext
  except IOError:
    _ = lambda text:text

    return oldTranslationFunction

init_i18n(None)

ABSOLUTE_MAX_PLAYERS = 10

LEVELS_CACHE = {}

def uniq(elements):
  temp = {}
  for element in elements:
    temp[element] = None
  return temp.keys()
 
class PokerRandom(random.Random):
  def __init__(self):
    self._stream = None
    self.seed(None)

  def seed(self, stream):
    if stream != None:
        self._stream = stream
        return
    
    with open('/dev/random', 'r') as rand:
        if self._stream == None:
            self._stream = BitStream(bytes=rand.read(33))
        else:
            self._stream = self._stream.read('bits') + BitStream(bytes=rand.read(33))
        return
    

  def getstate(self):
    return None

  def setstate(self, ignore=0):
    pass

  def jumpahead(self, ignore=0):
    pass

  def randint(self, a, b):
    randRange = abs(b - a)
    randBits = math.floor(math.log(randRange, 2))+1

    while True:
        if (self._stream.len - self._stream.pos < randBits):
            self.seed(None)
        
        result = self._stream.read('uint:%d' % randBits)
        if result > randRange: continue

        if (b - a >= 0):
            return a + result
        else:
            return a - result


  def shuffle(self, arr, ignore=0):
    for i in range (len(arr)-1, 1, -1):
        j = self.randint(0, i)
        arr[i], arr[j] = arr[j], arr[i]


  def random(self):
    if (self._stream.len - self._stream.pos < 32):
        self.seed(None)
    
    return abs(self._stream.read('float:32'))

shuffler = PokerRandom()

# muck constants
AUTO_MUCK_NEVER  = 0x00
AUTO_MUCK_WIN    = 0x01
AUTO_MUCK_LOSE   = 0x02
AUTO_MUCK_ALWAYS = AUTO_MUCK_WIN + AUTO_MUCK_LOSE

class PokerPlayer:
    def __init__(self, serial, game):
        self.serial = serial
        self.name = "noname"
        self.game = game
        self.fold = False
        self.remove_next_turn = False ##
        self.sit_out = True ##
        self.sit_out_next_turn = False ##
        self.sit_requested = False ##
        self.bot = False
        self.auto = False ##
        self.auto_blind_ante = False ##
        self.auto_muck = AUTO_MUCK_ALWAYS # AUTO_MUCK_NEVER, AUTO_MUCK_WIN, AUTO_MUCK_LOSE, AUTO_MUCK_ALWAYS
        self.wait_for = False # True, False, "late", "big", "first_round" ##
        self.missed_blind = "n/a" # None, "n/a", "big", "small"
        self.missed_big_blind_count = 0
        self.blind = "late" # True, None, "late", "big", "small", "big_and_dead" ##
        self.buy_in_payed = False ##
        self.ante = False
        self.side_pot_index = 0
        self.all_in = False
        self.seat = -1 ##
        self.hand = PokerCards()
        self.money = 0
        self.rebuy = 0
        self.bet = 0
        self.dead = 0
        self.talked_once = False
        self.user_data = None

    def copy(self):
        other = PokerPlayer(self.serial, self.game)
        other.name = self.name
        other.fold = self.fold
        other.remove_next_turn = self.remove_next_turn
        other.sit_out = self.sit_out
        other.sit_out_next_turn = self.sit_out_next_turn
        other.sit_requested = self.sit_requested
        other.bot = self.bot
        other.auto = self.auto
        other.auto_blind_ante = self.auto_blind_ante
        other.auto_muck = self.auto_muck
        other.wait_for = self.wait_for
        other.missed_blind = self.missed_blind
        other.missed_big_blind_count = self.missed_big_blind_count
        other.blind = self.blind
        other.buy_in_payed = self.buy_in_payed
        other.ante = self.ante
        other.side_pot_index = self.side_pot_index
        other.all_in = self.all_in
        other.seat = self.seat
        other.hand = self.hand.copy()
        other.money = self.money
        other.rebuy = self.rebuy
        other.bet = self.bet
        other.dead = self.dead
        other.talked_once = self.talked_once
        other.user_data = self.user_data
        return other

    def __str__(self):
        return "serial = %d, name = %s, fold = %s, remove_next_turn = %s, sit_out = %s, sit_out_next_turn = %s, sit_requested = %s, bot = %s, auto = %s, auto_blind_ante = %s, wait_for = %s, auto_muck = %d, missed_blind = %s, missed_big_blind_count = %d, blind = %s, buy_in_payed = %s, ante = %s, all_in = %s, side_pot_index = %d, seat = %d, hand = %s, money = %d, rebuy = %d, bet = %d, dead = %d, talked_once = %s, user_data = %s" % (self.serial, self.name, self.fold, self.remove_next_turn, self.sit_out, self.sit_out_next_turn, self.sit_requested, self.bot, self.auto, self.auto_blind_ante, self.wait_for, self.auto_muck, self.missed_blind, self.missed_big_blind_count, self.blind, self.buy_in_payed, self.ante, self.all_in, self.side_pot_index, self.seat, self.hand, self.money, self.rebuy, self.bet, self.dead, self.talked_once, self.user_data)

    def setUserData(self, user_data):
        self.user_data = user_data

    def getUserData(self):
        return self.user_data

    def beginTurn(self):
        self.bet = 0
        self.dead = 0
        self.fold = False
        self.hand = PokerCards()
        self.side_pot_index = 0
        self.all_in = False
        self.blind = None
        self.ante = False

    def isInGame(self):
        return not self.isAllIn() and not self.isFold()

    def isAllIn(self):
        return self.all_in
    
    def isFold(self):
        return self.fold

    def isNotFold(self):
        return not self.fold

    def isConnected(self):
        return not self.remove_next_turn

    def isDisconnected(self):
        return self.remove_next_turn

    def isSitOut(self):
        return self.sit_out

    def isSit(self):
        return not self.sit_out

    def isSitRequested(self):
        return self.sit_requested

    def isBot(self):
        return self.bot

    def isAuto(self):
        return self.auto

    def isAutoBlindAnte(self):
        return self.auto_blind_ante

    def isWaitForBlind(self):
        return self.wait_for

    def isMissedBlind(self):
        return self.missed_blind and self.missed_blind != "n/a"

    def isBlind(self):
        return self.blind

    def isBuyInPayed(self):
        return self.buy_in_payed

    def getMissedRoundCount(self):
      return self.missed_big_blind_count

    def resetMissedBlinds(self):
      self.missed_blind = None
      self.missed_big_blind_count = 0

def __historyResolve2messages(game, hands, serial2name, serial2displayed, frame):
    messages = []
    best = { 'hi': 0,
             'low': 0x0FFFFFFF }
    for serial in frame['serials']:
        for side in ('hi', 'low'):
            if not hands.has_key(serial):
                continue
            hand = hands[serial]
            if not hand.has_key(side):
                continue
            if hand[side][1][0] == 'Nothing':
                continue

            hand = hand[side]
            show = False
            if ( ( side == 'hi' and best['hi'] <= hand[0] ) or
                 ( side == 'low' and best['low'] >= hand[0] ) ):
                best[side] = hand[0]
                show = True

            if serial2displayed.has_key(serial) and not serial in frame[side]:
                #
                # If the player already exposed the hand and is not going
                # to win this side of the pot, there is no need to issue
                # a message.
                #
                continue

            if show:
                serial2displayed[serial] = True
                value = game.readableHandValueLong(side, hand[1][0], hand[1][1:])
                messages.append( _("%(name)s shows %(value)s for %(side)s ") % { 'name' : serial2name(serial), 'value' : value, 'side' : _(side) })
            else:
                messages.append( _("%(name)s mucks losing hand") % { 'name' : serial2name(serial) })

    for side in ('hi', 'low'):
        if not frame.has_key(side):
            continue
        if frame[side] == None:
            message += " (no qualifying %(side)s) " % { 'side' : _(side) }
        else:
            message = join([ serial2name(serial) for serial in frame[side] ])
            if len(frame[side]) > 1:
                message += " tie for %(side)s " % { 'side' : _(side) }
            else:
                message += _(" wins %(side)s ") % { 'side' : _(side) }

        messages.append(message)

    if len(frame['serial2share']) > 1:
        message = _("winners share a pot of %(pot)s") % { 'pot' : PokerChips.tostring(frame['pot']) }
        if frame.has_key('chips_left'):
            message += _(" (minus %(chips_left)d odd chips)") % { 'chips_left' : frame['chips_left'] }
        messages.append(message)

    for (serial, share) in frame['serial2share'].iteritems():
        messages.append( _("%(name)s receives %(amount)s") % { 'name' : serial2name(serial), 'amount' : PokerChips.tostring(share) })

    return messages


def history2messages(game, history, serial2name = str, pocket_messages = False, verbose = 0):
    messages = []
    subject = ''
    for event in history:
        type = event[0]
        if type == "game":
            (type, level, hand_serial, hands_count, time, variant, betting_structure, player_list, dealer, serial2chips) = event
            subject = _("hand #%(hand_serial)d, %(variant)s, %(betting_structure)s") % { 'hand_serial' : hand_serial, 'variant' : _(variant), 'betting_structure' : _(betting_structure) }

        elif type == "wait_for":
            (type, serial, reason) = event
            messages.append( _("%(serial)s waiting for ") % { 'serial' : serial2name(serial) } +
                            "%s" % ( reason == "late" and "late blind" or "big blind"))

        elif type == "player_list":
            pass

        elif type == "round":
            (type, name, board, pockets) = event
            if pockets:
              messages.append( _("%(name)s, %(len_pockets)d players") % { 'name' : name, 'len_pockets' : len(pockets) })
            else:
              messages.append(name)
            if board and not board.isEmpty():
                messages.append( _("Board: %(board)s") % { 'board' : game.cards2string(board) } )
            if pockets and pocket_messages:
              for (serial, pocket) in pockets.iteritems():
                if not pocket.areAllNocard():
                  messages.append( _("Cards player %(name)s: %(card)s") % { 'name' : serial2name(serial), 'card' : game.cards2string(pocket) })

        elif type == "showdown":
            (type, board, pockets) = event
            if board and not board.isEmpty():
                messages.append( _("Board: %(cards)s") % { 'cards' : game.cards2string(board) })

            if pockets and pocket_messages:
              for (serial, pocket) in pockets.iteritems():
                if not pocket.areAllNocard():
                  messages.append( _("Cards player %(name)s: %(cards)s") % { 'name' : serial2name(serial), 'cards' : game.cards2string(pocket) })

        elif type == "rake":
            (type, amount, serial2rake) = event
            messages.append( _("Rake %(amount)s") % { 'amount' : PokerChips.tostring(amount) } )

        elif type == "position":
            pass

        elif type == "blind_request":
            pass

        elif type == "wait_blind":
            pass
            
        elif type == "rebuy":
            pass

        elif type == "blind":
            (type, serial, amount, dead) = event
            if dead > 0:
                dead_message = _(" and %(dead)s dead") % { 'dead' : PokerChips.tostring(dead) }
            else:
                dead_message = ""
            messages.append( _("%(name)s pays %(amount)s blind%(deadmsg)s") % { 'name' : serial2name(serial), 'amount' : PokerChips.tostring(amount), 'deadmsg' : dead_message })

        elif type == "ante_request":
            pass

        elif type == "ante":
            (type, serial, amount) = event
            messages.append( _("%(name)s pays %(amount)s ante") % { 'name' : serial2name(serial), 'amount' : PokerChips.tostring(amount) })

        elif type == "all-in":
            (type, serial) = event
            messages.append( _("%(name)s is all in") % { 'name' : serial2name(serial) })

        elif type == "call":
            (type, serial, amount) = event
            messages.append( _("%(name)s calls %(amount)s") % { 'name' : serial2name(serial), 'amount' : PokerChips.tostring(amount) })

        elif type == "check":
            (type, serial) = event
            messages.append( _("%(name)s checks") % { 'name' : serial2name(serial)} )

        elif type == "fold":
            (type, serial) = event
            messages.append( _("%(name)s folds") % { 'name' : serial2name(serial)} )

        elif type == "raise":
            (type, serial, raiseTo, payAmount, raiseAmount) = event
            if raiseAmount == raiseTo:
                messages.append( _("%(name)s bets %(raiseTo)s") % { 'name' : serial2name(serial), 'raiseTo' : PokerChips.tostring(raiseTo) } )
            else:
                messages.append( _("%(name)s raises %(raiseAmount)s to %(raiseTo)s") % { 'name' : serial2name(serial), 'raiseAmount' : PokerChips.tostring(raiseAmount), 'raiseTo' : PokerChips.tostring(raiseTo) } )

        elif type == "canceled":
            (type, serial, amount) = event
            if serial > 0 and amount > 0:
                returned_message = _(" (%(amount)s returned to %(name)s)") % { 'amount' : PokerChips.tostring(amount), 'name' : serial2name(serial) }
            else:
                returned_message = ""
            messages.append( _("turn canceled%(message)s") % { 'message' : returned_message} )

        elif type == "end":
            (type, winners, showdown_stack) = event
            if showdown_stack:
              game_state = showdown_stack[0]
              if not game_state.has_key('serial2best'):
                  serial = winners[0]
                  messages.append( _("%(name)s receives %(amount)s (everyone else folded)") % { 'name' : serial2name(serial), 'amount' : PokerChips.tostring(game_state['serial2share'][serial]) })
              else:
                  serial2displayed = {}
                  hands = showdown_stack[0]['serial2best']
                  for frame in showdown_stack[1:]:
                      message = None
                      if frame['type'] == 'left_over':
                          message = _("%(name)s receives %(amount)d odd chips") % { 'name' :  serial2name(frame['serial']), 'amount' : frame['chips_left']}
                      elif frame['type'] == 'uncalled':
                          message = _("returning uncalled bet %(amount)s to %(name)s") % { 'amount' : PokerChips.tostring(frame['uncalled']), 'name' : serial2name(frame['serial']) }
                      elif frame['type'] == 'resolve':
                          messages.extend(__historyResolve2messages(game, hands, serial2name, serial2displayed, frame))
                      else:
                          if verbose >= 0: print "ERROR history2messages unexpected showdown_stack frame type %s" % frame['type']
                      if message:
                          messages.append(message)
            else:
              print "ERROR history2messages ignored empty showdown_stack"
        elif type == "sitOut":
            (type, serial) = event
            messages.append( _("%(name)s sits out") % { 'name' : serial2name(serial) })

        elif type == "leave":
            pass

        elif type == "finish":
            pass

        elif type == "muck":
            pass

        else:
            if verbose >= 0: print "ERROR history2messages: unknown history type %s " % type

    return (subject, messages)


# poker game states
GAME_STATE_NULL       = "null"
GAME_STATE_BLIND_ANTE = "blindAnte"
GAME_STATE_PRE_FLOP   = "pre-flop"
GAME_STATE_FLOP       = "flop"
GAME_STATE_THIRD      = "third"
GAME_STATE_TURN       = "turn"
GAME_STATE_FOURTH     = "fourth"
GAME_STATE_RIVER      = "river"
GAME_STATE_FIFTH      = "fifth"
GAME_STATE_MUCK       = "muck"
GAME_STATE_END        = "end"

# winning helper states
WON_NULL        = -1 # turn not ended yet
WON_ALLIN_BLIND = 0 # turn ended on allin in blind phase
WON_ALLIN       = 1 # turn ended on allin
WON_FOLD        = 2 # turn ended on fold
WON_REGULAR     = 3 # turn ended normally

class PokerGame:
    def __init__(self, url, is_directing, dirs):
        self.id = 0
        self.name = "noname"
        self.__variant = Config(dirs)
        self.__betting_structure = Config(dirs)
        self.dirs = dirs
        self.url = url

        self.variant = False
        self.variant_name = "unknown"
        self.round_info = False
        self.round_info_backup = False
        self.win_orders = False

        self.betting_structure = False
        self.betting_structure_name = "unknown"
        self.blind_info = False
        self.ante_info = False
        self.bet_info = False
        self.unit = 1
        self.buy_in = 0
        self.max_buy_in = 100000000
        self.ratholes = {} # serial => (amount, time)

        self.max_players = ABSOLUTE_MAX_PLAYERS
        self.is_open = True

        self.hand_serial = 1
        self.time = -1
        self.time_of_first_hand = -1
        self.hands_count = 0
        self.stats = {
            "flops": [],
            "flops_count": 20,
            "percent_flop": 0,
            "pots": [],
            "pots_count": 20,
            "average_pot": 0,
            "hands_per_hour": 0,
            "time": -1,
            "hands_count": 0,
            "frequency": 180 # seconds
            }
        
        self.is_directing = is_directing
        
        self.prefix = ""
        self.verbose = 0
        self.callbacks = []

        self.first_turn = True
        
        self.level_skin = ""
        
        self.eval = PokerEval()
        if self.is_directing:
          self.shuffler = shuffler
        self.reset()
        self.rake = None
        self.raked_amount = 0
        self.forced_dealer_seat = -1
#        print "__init__ PokerGame %s" % self

    def reset(self):
        self.state = GAME_STATE_NULL
        self.win_condition = WON_NULL 
        self.current_round = -2
        self.serial2player = {}
        self.player_list = []
        self.resetSeatsLeft()
        self.dealer = -1
        self.dealer_seat = -1
        self.position = 0
        self.last_to_talk = -1
        self.raked_amount = 0
        self.pot = False
        self.board = PokerCards()
        self.round_cap_left = sys.maxint
        self.last_bet = 0
        self.uncalled = 0
        self.uncalled_serial = 0
        self.winners = []
        self.muckable_serials = []        
        self.side2winners = {}
        self.serial2best = {}
        self.showdown_stack = []
        self.side_pots = {}
        self.first_betting_pass = True
        self.turn_history = []
        self.level = 0

    def open(self):
        self.is_open = True

    def close(self):
        self.is_open = False
        
    def setMaxPlayers(self, max_players):
        self.max_players = max_players
        if (self.max_players < 2) or (self.max_players > ABSOLUTE_MAX_PLAYERS):
            self.error("The number of players must be between %d and %d" % (2, ABSOLUTE_MAX_PLAYERS))
            self.max_players = 0
        self.resetSeatsLeft()
        self.serial2player = {}

    def seatsLeftCount(self):
        return len(self.seats_left)
    
    def resetSeatsLeft(self):
        if self.max_players == 2:
            self.seats_left = [2, 7]
        elif self.max_players == 3:
            self.seats_left = [2, 7, 5]
        elif self.max_players == 4:
            self.seats_left = [1, 6, 3, 8]
        elif self.max_players == 5:
            self.seats_left = [0, 2, 4, 6, 8]
        elif self.max_players == 6:
            self.seats_left = [0, 2, 4, 5, 7, 9]
        elif self.max_players == 7:
            self.seats_left = [0, 2, 3, 5, 6, 8, 9]
        elif self.max_players == 8:
            self.seats_left = [1, 2, 3, 4, 5, 6, 7, 8]
        elif self.max_players == 9:
            self.seats_left = [0, 1, 2, 3, 4, 5, 6, 7, 8]
        elif self.max_players == 10:
            self.seats_left = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        else:
            self.seats_left = []
            
        self.seats_all = self.seats_left[:]

    def seatsCount(self):
        return len(self.seats_all)
    
    def canComeBack(self, serial):
        return ( self.serial2player.has_key(serial) and
                 ( self.serial2player[serial].isDisconnected() or
                   self.serial2player[serial].isAuto() ) )
        
    def canAddPlayer(self, serial):
        if len(self.seats_left) < 1:
            self.error("no seats left for player %d" % serial)
            return False
        else:
            return self.is_open

    def isInPosition(self, serial):
        return self.isPlaying(serial) and self.getSerialInPosition() == serial
      
    def isInTurn(self, serial):
        return ( not self.isEndOrNull() and
                 self.serial2player.has_key(serial) and
                 serial in self.player_list )

    def isPlaying(self, serial):
        return ( self.isRunning() and
                 self.serial2player.has_key(serial) and
                 serial in self.player_list )

    def isInGame(self, serial):
        return ( self.isRunning() and
                 self.serial2player.has_key(serial) and
                 serial in self.serialsInGame() )

    def isSeated(self, serial):
        return serial in self.serial2player.keys()

    def isSit(self, serial):
        return ( self.serial2player.has_key(serial) and
                 self.serial2player[serial].isSit() )
        
    def isSitOut(self, serial):
        return ( self.serial2player.has_key(serial) and
                 self.serial2player[serial].isSitOut() )
        
    def sitOutNextTurn(self, serial):
        player = self.serial2player[serial]
        if ( self.isInTurn(serial) and
             not ( self.isBlindAnteRound() and
                   self.getSerialInPosition() == serial ) ):
            player.sit_out_next_turn = True
            player.sit_requested = False
            return False
        elif not self.is_directing:
            player.sit_out_next_turn = True
            player.sit_requested = False
            player.wait_for = False
            return False
        else:
            return self.sitOut(serial)
        
    def sitOut(self, serial):
        player = self.serial2player[serial]
        if player.isSitOut():
            if self.verbose > 0: self.message("sitOut: refuse to sitOut player %d because player.isSitOut() return True" % ( serial ))
            return False
        if self.is_directing and self.isBlindAnteRound() and self.getSerialInPosition() != serial:
            self.error("sitOut for player %d while paying the blinds although not in position" % serial)
            return False
        if self.isPlaying(serial):
            self.historyAdd("sitOut", serial)
        player.sit_out = True
        player.sit_out_next_turn = False
        player.sit_requested = False
        player.wait_for = False
        if self.is_directing and self.isBlindAnteRound():
            player.blind = None
            self.updateBlinds()
            if self.getSerialInPosition() == serial:
                self.__talkedBlindAnte()
            # the else is impossible because checked above
        return True

    def sit(self, serial):
        player = self.serial2player[serial]
        if player.isSit():
            self.comeBack(serial)
            if self.verbose > 0: self.message("sit: refuse to sit player %d because player.isSit() return True" % ( serial ))
            return False
        if not player.isBuyInPayed() or self.isBroke(serial):
            if self.verbose > 0: self.error("sit: refuse to sit player %d because buy in == %s instead of True or broke == %s instead of False" % ( serial, player.buy_in_payed, self.isBroke(serial) ))
            return False
        player.sit_requested = False
        player.sit_out = False
        if player.wait_for == "big":
            player.wait_for = False
        #
        # Rationale of player.sit_out_next_turn == False
        # This condition happens when the player sitout + sit
        # while not having the position during the blind/ante round it.
        # In this particular case, instead of instructing her to wait
        # for the first round, she sits back. This is important because
        # she was included in the player list at the begining of the turn.
        # If she is marked wait_for = "first_round", she will be removed 
        # from the player list at the end of the blind/ante round, which
        # is exactly the opposite of what we want.
        #
        if self.isRunning() and self.isBlindAnteRound() and player.sit_out_next_turn == False:
            player.wait_for = "first_round"
        player.sit_out_next_turn = False
        player.auto = False
        if self.sitCount() < 2:
            self.first_turn = True
            self.dealer_seat = player.seat
        return True

    def sitRequested(self, serial):
        player = self.getPlayer(serial)
        if player:
          player.sit_out_next_turn = False
          player.sit_requested = True
          player.wait_for = False

    def canceled(self, serial, amount):
        if self.isBlindAnteRound():
            self.acceptPlayersWaitingForFirstRound()
            self.cancelState()
            if self.sitCount() != 1:
                self.error("%d players sit, expected exactly one" % self.sitCount())
            elif amount > 0:
                self.bet2pot()
                if self.pot != amount:
                    self.error("pot contains %d, expected %d" % ( self.pot, amount ))
                else:
                    self.pot2money(serial)
        else:
            self.error("canceled unexpected while in state %s (ignored)" % self.state)
        
    def returnBlindAnte(self):
        serial = 0
        pot = 0
        for player in self.playersPlaying():
            if player.bet > 0:
                self.bet2pot()
                pot = self.pot
                serial = player.serial
                self.pot2money(serial)
        self.acceptPlayersWaitingForFirstRound()
        self.historyAdd("canceled", serial, pot)
            
    def getSerialByNameNoCase(self, name):
        name = lower(name)
        for player in self.playersAll():
            if lower(player.name) == name:
                return player.serial
        return 0

    def setPosition(self, position):
        if not self.isRunning():
            self.error("changing position while the game is not running has no effect")
        else:
            self.position = position
        
    def setDealer(self, seat):
        if self.isRunning():
            self.error("cannot change the dealer during the turn")
        else:
            self.dealer_seat = seat
        
    def getPlayer(self, serial):
        return self.serial2player.get(serial, None)

    def getPlayerMoney(self, serial):
        player = self.getPlayer(serial)
        if player:
            return player.money + player.rebuy
        
    def getSitOut(self, serial):
        return self.serial2player[serial].sit_out

    def comeBack(self, serial):
        if self.canComeBack(serial):
            player = self.serial2player[serial]
            player.remove_next_turn = False
            player.sit_out_next_turn = False
            player.sit_requested = False
            player.auto = False
            return True
        else:
            return False
        
    def addPlayer(self, serial, seat = -1):
        
        if self.serial2player.has_key(serial):
            player = self.serial2player[serial]
            if seat == player.seat:
                # Player already added on this seat
                return True
            else:
                # Player already added on another seat
                return False
        
        if self.canAddPlayer(serial):
            player = PokerPlayer(serial, self)
            if self.is_directing:
                if seat != -1:
                    if seat in self.seats_left:
                        player.seat = seat
                        self.seats_left.remove(seat)
                    else:
                        self.error("the seat %d is not among the remaining seats %s" % ( seat, self.seats_left ))
                        return False
                else:
                    player.seat = self.seats_left.pop(0)
            else:
                if seat not in self.seats_left:
                    self.error("the seat %d is not among the remaining seats %s" % ( seat, self.seats_left ))
                    return False
                    
                player.seat = seat
                self.seats_left.remove(seat)
            
            if self.verbose >= 1: self.message("player %d get seat %d" % (serial, player.seat))
            
            self.serial2player[serial] = player
            return True
        else:
            return False

    def botPlayer(self, serial):
        self.serial2player[serial].bot = True
        self.autoBlindAnte(serial)
        self.autoMuck(serial, AUTO_MUCK_ALWAYS)
        self.autoPlayer(serial)

    def interactivePlayer(self, serial):
        self.serial2player[serial].bot = False
        self.noAutoBlindAnte(serial)
        self.autoMuck(serial, AUTO_MUCK_ALWAYS)
        self.noAutoPlayer(serial)
        
    def autoPlayer(self, serial):
        if self.verbose >= 2: self.message("autoPlayer: player %d" % serial)
        player = self.getPlayer(serial)
        player.auto = True
        if not self.is_directing:
          return
        if self.isBlindAnteRound():
            # note that we can never get here on tournament tables
            # because blind / antes are payed automatically
            if player.isBot():
                if self.getSerialInPosition() == serial: self.autoPayBlindAnte()
            else:
                self.sitOut(serial)
        elif self.isPlaying(serial):
            self.__autoPlay()

    def noAutoPlayer(self, serial):
        if self.verbose >= 2: self.message("noAutoPlayer: player %d" % serial)
        player = self.getPlayer(serial)
        if player:
            player.auto = False
            return True
        else:
            return False

    def removePlayer(self, serial):
        if self.isInTurn(serial):
            self.serial2player[serial].remove_next_turn = True
            if self.isBlindAnteRound():
                self.sitOut(serial)
            else:
                self.__autoPlay()
            return False
        else:
            self.__removePlayer(serial)
            return True

    def seats(self):
        seats = [ 0 ] * ABSOLUTE_MAX_PLAYERS
        for (serial, player) in self.serial2player.iteritems():
            seats[player.seat] = serial
        return seats

    def setSeats(self, seats):
        self.resetSeatsLeft()
        seat = 0
        for serial in seats:
            if serial != 0:
                self.serial2player[serial].seat = seat
                if seat in self.seats_left:
                    self.seats_left.remove(seat)
                else:
                    self.error("setSeats: seat %d not in seats_left %s" % ( seat, self.seats_left ))
                    self.serial2player[serial].seat = -1
            seat += 1
        if self.seats() != seats:
            self.error("seatSeats: wanted %s but got %s" % ( seats, self.seats() ))
    
    def beginTurn(self, hand_serial):
        if not self.isEndOrNull():
            self.error("beginTurn: turn is not over yet")
            return

        self.hand_serial = hand_serial
        if self.verbose >= 1: self.message("Dealing %s hand number %d" % ( self.getVariantName(), self.hand_serial ) )
        self.pot = 0
        self.raked_amount = 0
        self.board = PokerCards()
        self.winners = []
        if self.muckable_serials:
           self.error("beginTurn: muckable_serials not empty %s" % self.muckable_serials)
        self.muckable_serials = []
        self.win_condition = WON_NULL
        self.serial2best = {}
        self.showdown_stack = []
        self.turn_history = []

        if self.levelUp():
            self.setLevel(self.getLevel() + 1)
        
        self.resetRoundInfo()
        self.playersBeginTurn()
        if not self.buildPlayerList(True):
            return

        self.changeState(GAME_STATE_BLIND_ANTE)
        if self.blind_info and self.is_directing and not self.first_turn:
            self.moveDealerLeft()
        elif self.forced_dealer_seat >= 0:
            self.dealer_seat = self.forced_dealer_seat
        self.dealerFromDealerSeat()

        self.historyAdd("game", self.getLevel(), self.hand_serial,
                        self.hands_count, (self.time - self.time_of_first_hand),
                        self.variant, self.betting_structure,
                        self.player_list[:], self.dealer_seat,
                        self.moneyMap())
        self.resetRound()
        self.side_pots = {
          'contributions': { 'total': {} },
          'pots': [[0, 0]],
          'building': 0,
          'last_round': self.current_round,
          }
        self.initBlindAnte()
        if self.is_directing:
            self.deck = self.eval.deck()
            self.shuffler.shuffle(self.deck)
            self.updateBlinds()
            self.autoPayBlindAnte()
        
        if self.verbose >= 2: self.message("initialisation turn %d ... finished" % self.hand_serial)

    def dealerFromDealerSeat(self):
        self.dealer = -1
        seat2player = [None] * ABSOLUTE_MAX_PLAYERS
        for player in self.playersAll():
            seat2player[player.seat] = player
        previous_player = None
        for seat in range(self.dealer_seat + 1, ABSOLUTE_MAX_PLAYERS) + range(0, self.dealer_seat + 1):
            player = seat2player[seat]
            if player and player.serial in self.player_list:
                if seat == self.dealer_seat:
                    self.dealer = self.player_list.index(player.serial)
                    break
                previous_player = player
            elif seat == self.dealer_seat:
                if previous_player:
                    self.dealer = self.player_list.index(previous_player.serial)
                else:
                    # the impossible has happened
                    self.dealer = len(self.player_list) - 1
                break
        if self.dealer < 0:
            self.error("dealer seat %d cannot be translated in player position among the %d players willing to join the game" % ( self.dealer_seat, self.playingCount() ))
        
    def moveDealerLeft(self):
        if not self.blind_info:
            return

        seat2player = [None] * ABSOLUTE_MAX_PLAYERS
        for player in self.playersAll():
            seat2player[player.seat] = player

        for seat in range(self.dealer_seat + 1, ABSOLUTE_MAX_PLAYERS) + range(0, self.dealer_seat + 1):
            player = seat2player[seat]
            if ( player and player.isSit() and not player.isWaitForBlind() ):
                if self.seatsCount() <= 2:
                    self.dealer_seat = seat
                    break
                elif player.missed_blind == None:
                    self.dealer_seat = seat
                    break

    def isBlindRequested(self, serial):
        return ( self.getSerialInPosition() == serial and
                 self.isBlindAnteRound() and
                 self.blind_info and
                 not self.getPlayer(serial).isAutoBlindAnte() )
          
    def isAnteRequested(self, serial):
        return ( self.getSerialInPosition() == serial and
                 self.isBlindAnteRound() and
                 self.ante_info and
                 not self.getPlayer(serial).isAutoBlindAnte() )
          
    def sitCountBlindAnteRound(self):
        sit_count = 0
        for player in self.playersSit():
          if player.wait_for != "first_round":
            sit_count += 1
        return sit_count
      
    def updateBlinds(self):

        if not self.blind_info:
            return

        sit_count = self.sitCountBlindAnteRound()
        
        if sit_count <= 1:
            #
            # Forget the missed blinds and all when there is less than
            # two players willing to join the game.
            #
            for player in self.playersAll():
                player.resetMissedBlinds()
                player.blind = None
                if player.wait_for != 'first_round':
                    player.wait_for = False
            return

        seat2player = [None] * ABSOLUTE_MAX_PLAYERS
        blind_ok_count = 0
        for player in self.playersAll():
            seat2player[player.seat] = player
            if player.isSit() and player.wait_for != 'first_round' and player.missed_blind == None:
                blind_ok_count += 1

        if sit_count == 2:
            first = self.dealer_seat
        else:
            first = self.dealer_seat + 1

        players = seat2player[first:] + seat2player[:first]

        #
        # If less than two players did not miss the blind, declare
        # that all missed blinds are forgotten. That solves a special
        # case that would lead to the unability to assign the big blind
        # to someone despite the fact that there would be players willing
        # to pay for it. For instance, if all players are
        # new (missed_blind == "n/a") and only one player is ok with his
        # blind AND is on the button. Another case is when all players
        # save one are waiting for the late blind. This player would have to pay the
        # small blind but then, there would be a need to walk the list
        # of players, starting from the dealer, once more to figure out
        # who has to pay the big blind. Furthermore, this case leads to
        # the awkward result that the person next to the dealer pays the
        # big blind and the dealer pays the small blind.
        #
        if blind_ok_count < 2:
            if self.verbose > 2: self.message("Forbid missed blinds")
            for player in players:
                if player and player.isSit():
                    player.resetMissedBlinds()
                    if player.wait_for == "late":
                      player.wait_for = False
                
        def updateMissed(players, index, what):
            while ( ( index < ABSOLUTE_MAX_PLAYERS ) and
                    ( not players[index] or
                      not players[index].isSit() or
                      players[index].wait_for == 'first_round' ) ):
                player = players[index]
                if player and player.wait_for != 'first_round':
                  if player.missed_blind == None:
                    player.missed_blind = what
                  if what == "big":
                    player.missed_big_blind_count += 1
                    if self.verbose > 5: self.message("%d big blind count is now %d because of %s" % (player.serial, player.missed_big_blind_count, what))
                index += 1
            return index

        #
        # Small blind
        #
        done = False
        index = 0
        while index < ABSOLUTE_MAX_PLAYERS and not done:
            index = updateMissed(players, index, "small")
            if index >= ABSOLUTE_MAX_PLAYERS:
                continue
            player = players[index]
            if player.blind == True:
                done = True
            elif ( ( not player.wait_for and
                     player.missed_blind == None ) or
                   sit_count == 2 ):
                player.blind = "small"
                done = True
            elif player.missed_blind != None:
                player.wait_for = "late"
            index += 1

        if not done:
            self.error("updateBlinds cannot assign the small blind")

        #
        # Big blind
        #
        index = updateMissed(players, index, "big")
        if index < ABSOLUTE_MAX_PLAYERS:
            player = players[index]
            if player.wait_for:
                player.wait_for = False
            if player.blind == True:
                pass
            else:
                player.blind = "big"
            index += 1
        else:
            self.error("updateBlinds cannot assign big blind")
        #
        #
        # Late blind
        #
        while index < ABSOLUTE_MAX_PLAYERS:
            player = players[index]
            if player:
                if not player.sit_out:
                    if ( player.wait_for == "big" or
                         player.missed_blind == None ):
                        player.blind = None
                    elif ( player.missed_blind == "big" or
                           player.missed_blind == "small" ):
                        if sit_count > 5:
                            player.blind = "big_and_dead"
                        else:
                            player.blind = "late"
                        player.wait_for = False
                    elif ( player.missed_blind == "n/a" and player.wait_for != "first_round" ):
                        player.blind = "late"
                        player.wait_for = False
                    else: #pragma: no cover
                        self.error("updateBlinds statement unexpectedly reached while evaluating late blind") #pragma: no cover
                else:
                    player.blind = None
            index += 1
        if self.verbose > 2:
            showblinds = lambda player: "%02d:%s:%s:%d:%s" % ( player.serial, player.blind, player.missed_blind, player.missed_big_blind_count, player.wait_for )
            self.message("updateBlinds: in game (blind:missed:num:wait) " + join(map(showblinds, self.playersInGame())))
            players = self.playersAll()
            players.sort(lambda a,b: int(a.seat - b.seat))
            self.message("updateBlinds: all     (blind:missed:num:wait) " + join(map(showblinds, players)))
        
    def handsMap(self):
        pockets = {}
        for player in self.playersNotFold():
            pockets[player.serial] = player.hand.copy()
        return pockets

    def moneyMap(self):
        money = {}
        for player in self.playersNotFold():
            money[player.serial] = player.money
        return money

    def isTournament(self):
        return self.hasLevel()
    
    def hasLevel(self):
        return ( (self.blind_info and self.blind_info["change"]) or
                 (self.ante_info and self.ante_info["change"]) )

    def delayToLevelUp(self):
        for what in (self.blind_info, self.ante_info): 
            if not what or not what["change"]:
                continue

            if self.level == 0:
                return (0, what["unit"])

            if what["unit"] == "minute" or what["unit"] == "minutes":
                return ( ( what["frequency"] * 60 ) - ( self.time - what["time"] ), "second" )

            elif what["unit"] == "hand" or what["unit"] == "hands":
                return ( what["frequency"] - ( self.hands_count - what["hands"] ), "hand" )

            else:
                self.error("delayToLevelUp: unknown unit %s " % what["unit"])

        return False

    def levelUp(self):
        if not self.is_directing:
            return False
        
        delay = self.delayToLevelUp()
        if delay:
            return delay[0] <= 0
        else:
            return False

    def updateStatsFlop(self, fold_before_flop):
        info = self.stats
        if fold_before_flop:
            flop = 0
        else:
            flop = (self.inGameCount() * 100) / self.sitCount();
        info["flops"].append(flop)
        if len(info["flops"]) > info["flops_count"]:
            info["flops"].pop(0)
        info["percent_flop"] = sum(info["flops"]) / min(info["flops_count"], len(info["flops"]))
        
    def updateStatsEndTurn(self):
        info = self.stats

        #
        # First time thru
        #
        if info["time"] == -1:
            info["hands_count"] = self.hands_count
            info["time"] = self.time
            return 

        info["pots"].append(self.getSidePotTotal())
        if len(info["pots"]) > info["pots_count"]:
            info["pots"].pop(0)
        delta = self.time - info["time"]
        if delta > info["frequency"]:
            info["average_pot"] = sum(info["pots"]) / min(info["pots_count"], len(info["pots"]))
            info["hands_per_hour"] = (self.hands_count - info["hands_count"]) * (3600 / info["frequency"])
            info["hands_count"] = self.hands_count
            info["time"] = self.time
            
    def setHandsCount(self, hands_count):
        self.hands_count = hands_count
        
    def setTime(self, time):
        if self.time_of_first_hand == -1:
            self.time_of_first_hand = time # first turn, so we get initial time
        self.time = time

    def initBlindAnte(self):
        self.side_pots['contributions'][self.current_round] = {}

        is_tournament = self.isTournament()

        if is_tournament:
            for player in self.playersAll():
                player.auto_blind_ante = True
                
        if not self.is_directing:
            return
        
        if self.blind_info and ( self.first_turn or is_tournament ):
            for player in self.playersAll():
                player.resetMissedBlinds()

        if self.blind_info:
            if self.sitCountBlindAnteRound() == 2:
                self.position = self.dealer
            else:
                self.position = self.indexInGameAdd(self.dealer, 1)
        else:
            self.position = self.dealer

    def isBlindAntePayed(self):
        if self.blind_info:
            for player in self.playersPlaying():
                if player.isSitOut():
                    continue
                if ( player.blind != True and player.blind != None ):
                    return False
        if self.ante_info:
            for player in self.playersPlaying():
                if player.isSitOut():
                    continue
                if not player.ante:
                    return False
        return True

    def blindAmount(self, serial):
        if self.blind_info:
            player = self.getPlayer(serial)
            big = self.blind_info["big"]
            small = self.blind_info["small"]
            if player.blind == "big":
                return (big, 0, player.blind)
            elif player.blind == "late":
                return (big, 0, player.blind)
            elif player.blind == "small":
                return (small, 0, player.blind)
            elif player.blind == "big_and_dead":
                return (big, small, player.blind)
            elif ( player.blind == None or player.blind == True ):
                return (0, 0, player.blind)
            else:
                self.error("blindAmount unexpected condition for player %d" % player.serial)
        else:
            return (0, 0, False)

    def smallBlind(self):
        if self.blind_info:
            return self.blind_info["small"]
        else:
            return None
          
    def bigBlind(self):
        if self.blind_info:
            return self.blind_info["big"]
        else:
            return None
          
    def autoPayBlindAnte(self):
        if not self.is_directing:
            return

        if not self.blind_info and not self.ante_info:
            self.__talkedBlindAnte()
            return
            
        auto_payed = False
        for self.position in range(self.position, len(self.player_list)) + range(0, self.position):
            serial = self.player_list[self.position]
            player = self.serial2player[serial]
            if player.isSitOut():
                #
                # This case happens when a player refuses to pay the blind/ante
                # He is sit out but will only be removed from the player list when
                # the blind/ante round is over.
                #
                continue
            if self.blind_info:
                (amount, dead, state) = self.blindAmount(serial)
                if amount > 0:
                    self.historyAddNoDuplicate("position", self.position)
                    if player.isAutoBlindAnte():
                        self.payBlind(serial, amount, dead)
                        auto_payed = True
                    else:
                        self.historyAdd("blind_request", serial, amount, dead, state)
                        auto_payed = False
                        break
            if self.ante_info and player.ante == False:
                self.historyAddNoDuplicate("position", self.position)
                if player.isAutoBlindAnte():
                    self.payAnte(serial, self.ante_info["value"])
                    auto_payed = True
                else:
                    self.historyAdd("ante_request", serial, self.ante_info["value"])
                    auto_payed = False
                    break
            if self.isBlindAntePayed():
                break

        if auto_payed:
            self.__talkedBlindAnte()

    def acceptPlayersWaitingForFirstRound(self):
        #
        # Players who sit while others are paying the blinds are
        # waiting for the first round so that buildPlayerList
        # does not include them. When the first round starts, this
        # mark can be removed.
        #
        for player in self.playersSit():
          if player.wait_for == "first_round":
            player.wait_for = False
      
    def initRound(self):
        info = self.roundInfo()
        if self.verbose >= 2: self.message("new round %s" % info["name"])
        if self.isFirstRound():
          if not self.is_directing:
            self.buildPlayerList(False)
            self.dealerFromDealerSeat()
          self.acceptPlayersWaitingForFirstRound()
        self.round_cap_left = self.roundCap()
        if self.verbose > 2:
          self.message("round cap reset to %d" % self.round_cap_left)
        self.first_betting_pass = True
        if info["position"] == "under-the-gun":
            #
            # The player under the gun is the first to talk
            #
            count = self.inGameCount()
            if count < 2 and self.betsEqual():
                raise UserWarning, "initialization but less than two players in game"
            if self.sitCount() == 2:
                if self.isFirstRound():
                    self.position = self.dealer
                else:
                    self.position = self.indexInGameAdd(self.dealer, 1)
            else:
                big_blind = self.indexNotFoldAdd(self.dealer, 2)
                self.position = self.indexInGameAdd(big_blind, 1)
        elif info["position"] == "next-to-dealer":
            #
            # The player left to the dealer is first to talk
            #
            self.position = self.indexInGameAdd(self.dealer, 1)
            #
            # The dealer is last to talk. However, if the dealer folded,
            # the player before him is last to talk.
            #
            next_to_dealer = self.indexInGameAdd(self.dealer, 1)
            dealer_or_before_him = self.indexInGameAdd(next_to_dealer, -1)
        elif info["position"] == "low" or info["position"] == "high":
            values = []
            for player in self.playersInGame():
                values.append(self.eval.evaln(player.hand.getVisible()))
                if self.verbose > 2: self.message("%s : %d" % ( player.hand.getVisible(), values[-1] ))
            if info["position"] == "low":
                value = min(values)
            else:
                value = max(values)
            index = values.index(value)
            serial = self.serialsInGame()[index]
            self.position = self.player_list.index(serial)
        else:
            raise UserWarning, "unknown position info %s" % info["position"]
        self.last_bet = 0

        if self.isFirstRound():
            #
            # The first round takes the live blinds/antes
            # (is there any game with live antes ?)
            #
            self.blindAnteMoveToFirstRound()
            if self.blind_info:
                self.last_bet = self.blind_info["big"]

        else:
            self.side_pots['contributions'][self.current_round] = {}
            self.uncalled = 0
            self.uncalled_serial = 0
        self.side_pots['last_round'] = self.current_round

        if self.isSecondRound():
            self.updateStatsFlop(False)

        if info["position"] == "under-the-gun":
            self.last_to_talk = self.indexInGameAdd(self.position, -1)
        elif info["position"] == "next-to-dealer":
            self.last_to_talk = dealer_or_before_him
        elif info["position"] == "low" or info["position"] == "high":
            self.last_to_talk = self.indexInGameAdd(self.position, -1)
        else:
            # Impossible case
            # The position value has already been tested at the beginning of the method
            raise UserWarning, "unknow position info %s" % info["position"] #pragma: no cover

        for player in self.playersInGame():
            player.talked_once = False
            
        if self.verbose >= 2: self.message("dealer %d, in position %d, last to talk %d" % (self.dealer, self.position, self.last_to_talk))
        self.historyAdd("round", self.state, self.board.copy(), self.handsMap())
        self.historyAdd("position", self.position)
        self.__autoPlay()

    def sortPlayerList(self):
        self.player_list.sort(lambda a,b: int(self.serial2player[a].seat - self.serial2player[b].seat))

    def playersBeginTurn(self):
        map(PokerPlayer.beginTurn, self.playersAll())
        if not self.is_directing:
            for player in self.playersAll():
              if player.wait_for != "first_round":
                player.wait_for = False
        
    def buildPlayerList(self, with_wait_for):
        if self.sitCount() < 2:
            self.error("cannot make a consistent player list with less than two players willing to join the game")
            return False
        #
        # The player list is the list of players seated, sorted by seat
        #
        if with_wait_for:
            self.player_list = filter(lambda x: self.serial2player[x].wait_for != "first_round", self.serialsSit())
        else:
            self.player_list = filter(lambda x: self.serial2player[x].isSit() and not self.serial2player[x].isWaitForBlind(), self.serial2player.keys())
        self.sortPlayerList()
        if self.verbose >= 2: self.message("player list: %s" % self.player_list)
        return True

    def getLevel(self):
        return self.level

    def getLevelValues(self, level):
        info = self.blind_info
        blind_info = None
        if info and info["change"]:
            blind_info = {}
            if info["change"] == "double":
                blind_info["small"] = info["small_reference"] * pow(2, level - 1)
                blind_info["big"] = info["big_reference"] * pow(2, level - 1)
            elif info["change"] == "levels" or info["change"] == "level":
                level_info = info["levels"][level - 1]
                blind_info["small"] = level_info["small"]
                blind_info["big"] = level_info["big"]
            else:
                blind_info = None
                if self.verbose >= 1: self.message("unexpected blind change method %s " % info["change"])

        info = self.ante_info
        ante_info = None
        if info and info["change"]:
            ante_info = {}
            if info["change"] == "double":
                ante_info["value"] = info["value_reference"] * pow(2, level - 1)
                ante_info["bring-in"] = info["bring-in_reference"] * pow(2, level - 1)
            elif info["change"] == "levels":
                level_info = info["levels"][level - 1]
                ante_info["value"] = level_info["value"]
                ante_info["bring-in"] = level_info["bring-in"]
            else:
                ante_info = None
                if self.verbose >= 1: self.message("unexpected ante change method %s " % info["change"])

        return ( blind_info, ante_info )
        
    def setLevel(self, level):
        if level == self.level:
            return
        
        (blind_info, ante_info) = self.getLevelValues(level)
        info = self.blind_info
        if blind_info:
            info["hands"] = self.hands_count
            info["time"] = self.time
            info["small"] = blind_info["small"]
            info["big"] = blind_info["big"]

        info = self.ante_info
        if ante_info:
            info["hands"] = self.hands_count
            info["time"] = self.time
            info["value"] = ante_info["value"]
            info["bring-in"] = ante_info["bring-in"]

        self.level = level

    def minMoney(self):
        if self.isTournament():
          return 0
        elif self.blind_info:
          return self.blind_info["big"] + self.blind_info["small"]
        elif self.ante_info:
          return self.ante_info["value"] + self.ante_info["bring-in"]
        else:
          return 0
          
    def isBroke(self, serial):
        player = self.getPlayer(serial)
        if player:
          money = player.money
          return ( money <= 0 or
                   ( not self.isTournament() and
                     money < self.minMoney() ) )
        else:
          return False
        
    def endTurn(self):
        if self.verbose >= 2: self.message("---end turn--")

        self.hands_count += 1
        self.updateStatsEndTurn()

        self.dealer_seat = self.getPlayerDealer().seat
        
        self.historyAdd("end", self.winners[:], self.showdown_stack)

        for player in self.playersAll():
            if player.rebuy > 0:
                player.money += player.rebuy
                self.historyAdd("rebuy", player.serial, player.rebuy)
                player.rebuy = 0

        #
        # Players who are broke automatically sit out.
        # In live games, one cannot play with less than one big blind + dead.
        #
        for player in self.playersSit():
            if self.isBroke(player.serial):
                player.sit_out_next_turn = True

        #
        # Compute sit_out for all players so that it accurately
        # reflects the players that will not be playing next turn
        # (regardless of the fact that a new player may join later)
        #
        sitting_out = []
        for player in self.playersAll():
            if player.sit_out_next_turn:
                self.historyAdd("sitOut", player.serial)
                self.sitOut(player.serial)
                sitting_out.append(player.serial)
            if player.remove_next_turn:
                if player.serial not in sitting_out:
                    self.historyAdd("sitOut", player.serial)
                    self.sitOut(player.serial)
                    sitting_out.append(player.serial)

        disconnected = self.playersDisconnected()
        if len(disconnected) > 0:
          self.historyAdd("leave", map(lambda player: (player.serial, player.seat), disconnected))
        for player in disconnected:
            self.__removePlayer(player.serial)
        self.historyAdd("finish", self.hand_serial)

    def __removePlayer(self, serial):
        #
        # Get his seat back
        #
        player = self.serial2player[serial]

        if self.verbose >= 1: self.message("removing player %d from game" % (serial))
        if not player.seat in self.seats_left:
            self.seats_left.insert(0, player.seat)
        else:
            self.error("%d already in seats_left" % player.seat)
        # Record ratholing
        if player.money > 0:
            self.ratholes[serial] = (player.money, datetime.now())
        #
        # Forget about him
        #
        del self.serial2player[serial]

    def isBlindAnteRound(self):
        return self.current_round == -1
        
    def isFirstRound(self):
        return self.current_round == 0
    
    def isSecondRound(self):
        return self.current_round == 1
    
    def isLastRound(self):
        return self.current_round == len(self.round_info) - 1

    def resetRound(self):
        self.current_round = -1
        
    def nextRound(self):
        self.current_round += 1
        if self.position != -1:
          self.historyAdd("position", -1)
        self.position = -1
        self.changeState(self.roundInfo()["name"])

    def muckState(self, win_condition):        
        self.current_round = -2
        if self.position != -1:
          self.historyAdd("position", -1)
        self.position = -1
        
        self.win_condition = win_condition
        self.changeState(GAME_STATE_MUCK)
        
        if self.is_directing:
           self.setRakedAmount(self.rake.getRake(self))
           self.distributeMoney()
           to_show, muckable_candidates_serials = self.dispatchMuck()
           
           if self.verbose > 2:
              self.message("muckState: to_show = %s muckable_candidates = %s " % ( to_show, muckable_candidates_serials ))
           
           muckable_serials = []
           for serial in to_show:
              self.serial2player[serial].hand.allVisible()
           for serial in muckable_candidates_serials:
              auto_muck = self.serial2player[serial].auto_muck
              if auto_muck == AUTO_MUCK_ALWAYS:
                pass
              elif auto_muck == AUTO_MUCK_WIN and self.isWinnerBecauseFold():
                pass
              elif auto_muck == AUTO_MUCK_LOSE and not self.isWinnerBecauseFold():
                pass
              else:
                muckable_serials.append(serial)                
           self.setMuckableSerials(muckable_serials)
           self.__talked_muck()
        else:
           if self.verbose >= 2: self.message("muckState: not directing...")

    def setRakedAmount(self, rake):
      if rake > 0:
        self.raked_amount = rake
        self.historyAdd("rake", rake, self.getRakeContributions())

    def getRakedAmount(self):
        return self.raked_amount
      
    def getRakeContributions(self):
        rake = self.getRakedAmount()

        total = self.getPotAmount() - self.getUncalled()
        uncalled_serial = self.getUncalledSerial()
        side_pots = self.getPots()

        #
        # Uncalled bet is not raked
        # 
        serial2share = side_pots['contributions']['total'].copy()
        if uncalled_serial > 0:
          serial2share[uncalled_serial] -= self.getUncalled()
        
        return self.distributeRake(rake, total, serial2share)

    def distributeRake(self, rake, total, serial2share):
        #
        # Each player contributes to the rake in direct proportion
        # of their contribution to the global pot (uncalled bet does
        # not count).
        #
        total_rake = rake
        distributed_rake = 0
        serial2rake = {}
        if len(serial2share) == 1:
          #
          # Special case to avoid rounding errors
          #
          serial2rake[serial2share.keys()[0]] = rake
          rake = 0
        else:
          for (serial, contribution) in serial2share.iteritems():
            contribution += self.getPlayer(serial).dead
            player_rake = (total_rake * contribution) / total
            serial2rake[serial] = player_rake
            rake -= player_rake

        if rake > 0:
          keys = serial2rake.keys()
          keys.sort(lambda a,b: cmp(serial2rake[a], serial2rake[b]) or cmp(a,b))
          #
          # rake distribution rounding error benefit the player with the
          # lowest rake participation (with the idea that a player with
          # very little rake participation has a chance to not be raked
          # at all instead of being raked for 1 unit).
          #
          # Note: the rake rounding error can't be greater than the number
          #       of players. But the above distribution is slightly flawed
          #       because the dead blind is not accounted as a contribution
          #       of the player to the pot, therefore the total is not 100%.
          #
          while rake > 0:
            for serial in keys:
              serial2rake[serial] += 1
              rake -= 1
              if rake <= 0: break
        return serial2rake

    def setMuckableSerials(self, muckable_serials):
        self.muckable_serials = list(muckable_serials)
        if muckable_serials:
            self.historyAdd("muck", self.muckable_serials[:])
        if self.verbose > 2:
            self.message("setMuckableSerials: muckable = %s " % self.muckable_serials)

    def cancelState(self):
        self.current_round = -2
        if self.position != -1:
          self.historyAdd("position", -1)
        self.position = -1
        self.changeState(GAME_STATE_END)
        self.runCallbacks("end_round_last")

    def endState(self):
        self.current_round = -2
        self.changeState(GAME_STATE_END)
        self.runCallbacks("end_round_last")
        self.endTurn()
        
    def roundInfo(self):
        return self.round_info[self.current_round]

    def betInfo(self):
        return self.bet_info[self.current_round]

    def getChipUnit(self):
        return self.unit
      
    def willAct(self, serial):
        if ( self.isRunning() and
             serial in self.serialsInGame() ):
          player = self.getPlayer(serial)
          return not player.talked_once or self.canCall(serial)
        else:
          return False
        
    def canAct(self, serial):
        return ( self.isRunning() and
                 self.getSerialInPosition() == serial and
                 self.cardsDealt() )

    def canCall(self, serial):
        """
        Can call if the highest bet is greater than the player bet.
        """
        if self.isBlindAnteRound():
            return False
        player = self.serial2player[serial]
        return self.highestBetNotFold() > player.bet

    def canRaise(self, serial):
        """
        Can raise if round cap not reached and the player can at
        least match the highest bet.
        """
        if self.isBlindAnteRound():
            return False
        player = self.getPlayer(serial)
        highest_bet = self.highestBetNotFold()
        money = player.money
        bet = player.bet
        #
        # Can raise if the round is not capped and the player has enough money to
        # raise. The player will be given an opportunity to raise if his bet is
        # lower than the highest bet on the table or if he did not yet talk in this
        # betting round (for instance if he payed the big blind or a late blind).
        #
        return ( self.round_cap_left != 0 and
                 money > highest_bet - bet and
                 ( player.talked_once == False or
                   bet < highest_bet )
                 )

    def canCheck(self, serial):
        """
        Can check if all bets are equal
        """
        if self.isBlindAnteRound():
            return False
        return self.highestBetNotFold() <= self.getPlayer(serial).bet

    def canFold(self, serial):
        """
        Can fold if in game and not in blind round
        """
        if self.isBlindAnteRound():
            return False
        player = self.getPlayer(serial)
        if not player.isInGame():
            return False
        return True

    def setPlayerBlind(self, serial, blind):
        if self.isBlindAnteRound() and self.isInPosition(serial):
            self.getPlayer(serial).blind = blind
        
    def getRequestedAction(self, serial):
        if self.isInPosition(serial):
            if self.isBlindAnteRound():
                return "blind_ante"
            else:
                return "play"
        else:
            player = self.getPlayer(serial)
            if not self.isTournament() and player:
                if not player.isBuyInPayed():
                    return "buy-in"
                elif self.isBroke(serial):
                    return "rebuy"
                else:
                    return None
            else:
                return None
                
    def possibleActions(self, serial):
        actions = []
        if self.canAct(serial) and not self.isBlindAnteRound():
            if self.canCall(serial):
                actions.append("call")
            if self.canRaise(serial):
                actions.append("raise")
            if self.canCheck(serial):
                actions.append("check")
            else:
                actions.append("fold")
        return actions
        
    def call(self, serial):
        if self.isBlindAnteRound() or not self.canAct(serial):
            self.error("player %d cannot call. state = %s" %
                       (serial, self.state))
            return False

        player = self.serial2player[serial]
        amount = min(self.highestBetNotFold() - player.bet, player.money)
        if self.verbose >= 2: self.message("player %d calls %d" % (serial, amount))
        self.historyAdd("call", serial, amount)
        self.bet(serial, amount)
        return True

    def callNraise(self, serial, raiseTo):
        if self.isBlindAnteRound() or not self.canAct(serial):
            self.error("player %d cannot raise. state = %s" %
                       (serial, self.state))
            return False

        if self.round_cap_left <= 0:
            self.error("round capped, can't raise (ignored)")
            if self.round_cap_left < 0:
              self.error("round cap below zero")
            return False

        (min_bet, max_bet, to_call) = self.betLimits(serial)

        player = self.getPlayer(serial)

        highest_bet = self.highestBetNotFold()
        payAmount = raiseTo - player.bet
        if payAmount > player.money:
            if self.verbose >= 2: self.message("player %d tried to pay more (%d) than their stack (%d)" % (serial, payAmount, player.money))
            return False
        elif payAmount < 0:
            if self.verbose >= 2: self.message("player %d tried to pay a negative amount (%d)" % (serial, payAmount))
            return False
        raiseAmount = payAmount - to_call
        
        if raiseAmount < min_bet and payAmount < player.money:
            if self.verbose >= 2: self.message("player %d raised less than min bet %d (bet %d)" % (serial, min_bet, raiseAmount))
            return False
        elif raiseAmount > max_bet:
            if self.verbose >= 2: self.message("player %d raised more than max bet %d (bet %d)" % (serial, max_bet, raiseAmount))
            return False

        if self.verbose >= 1: self.message("player %d raises %d to %d" % (serial, raiseAmount, raiseTo))
        self.historyAdd("raise", serial, raiseTo, payAmount, raiseAmount)
        self.money2bet(serial, payAmount)
        if self.isRunning():
            self.last_bet = max(self.last_bet, raiseAmount)
            self.round_cap_left -= 1
            if self.verbose > 2: self.message("round cap left %d" % self.round_cap_left)
            self.runCallbacks("round_cap_decrease", self.round_cap_left)
        self.__talked(serial)
        return True

    def bet(self, serial, amount):
        if self.verbose >= 1: self.message("player %d bets %s" % ( serial, amount ))
        #
        # Transfert the player money from his stack to the bet stack
        #
        self.money2bet(serial, amount)
        self.__talked(serial)

    def check(self, serial):
        if self.isBlindAnteRound() or not self.canAct(serial):
            self.error("player %d cannot check. state = %s (ignored)" % (serial, self.state))
            return False

        if not self.canCheck(serial):
            self.error("player %d tries to check but should call or raise (ignored)" % serial)
            return False

        if self.verbose >= 1: self.message("player %d checks" % serial)
        self.historyAdd("check", serial)
        #
        # Nothing done: that's what "check" stands for
        #
        self.__talked(serial)
        return True

    def fold(self, serial):
        if self.isBlindAnteRound() or not self.canAct(serial):
            self.error("player %d cannot fold. state = %s (ignored)" % (serial, self.state))
            return False

        if self.serial2player[serial].fold == True:
            if self.verbose >= 1: self.message("player %d already folded (presumably autoplay)" % serial)
            return True
        
        if self.verbose >= 1: self.message("player %d folds" % serial)
        self.historyAdd("fold", serial)
        self.serial2player[serial].fold = True
        #
        # His money goes to the pot
        #
        self.bet2pot(serial)
        self.__talked(serial)
        return True

    def waitBigBlind(self, serial):
        if not self.blind_info:
            self.error("no blind due")
            return False
        if not self.isBlindAnteRound():
            self.error("player %d cannot pay blind while in state %s" % ( serial, self.state ))
            return False
        if not self.canAct(serial):
            self.error("player %d cannot wait for blind. state = %s, serial in position = %d (ignored)" % (serial, self.state, self.getSerialInPosition()))
            return False
        player = self.serial2player[serial]
        player.wait_for = "big"
        if self.is_directing:
            self.updateBlinds()
            self.historyAdd("wait_blind", serial)
            self.__talkedBlindAnte()
        return True
        
    def blind(self, serial, amount = 0, dead = 0):
        if not self.blind_info:
            self.error("no blind due")
            return False
        if not self.isBlindAnteRound():
            self.error("player %d cannot pay blind while in state %s" % ( serial, self.state ))
            return False
        if not self.canAct(serial):
            self.error("player %d cannot pay blind. state = %s, serial in position = %d (ignored)" % (serial, self.state, self.getSerialInPosition()))
            return False
        if self.is_directing and amount == 0:
            (amount, dead, state) = self.blindAmount(serial)
        self.payBlind(serial, amount, dead)
        if self.is_directing:
            self.__talkedBlindAnte()

    def payBlind(self, serial, amount, dead):
        player = self.serial2player[serial]
        money = player.money
        if money < amount + dead:
            #
            # If the player does not have enough money to pay the blind,
            # make sure the live blind is payed before puting money into
            # the dead blind.
            #
            if money < amount:
                dead = 0
                amount = money
            else:
                dead = money - amount
        if self.verbose >= 2: self.message("player %d pays blind %d/%d" % (serial, amount, dead))
        self.historyAdd("blind", serial, amount, dead)
        if dead > 0:
            #
            # There is enough money to pay the amount, pay the dead, if any
            #
            # Note about uncalled amounts : the dead is always lower than the
            # blind, therefore if self.uncalled is updated (indirectly thru
            # the self.money2bet in the line immediately following this comment)
            # it will *always* be overriden by the self.uncalled
            # self.money2bet of the blind.
            #
            self.money2bet(serial, dead, dead_money = True)
            self.bet2pot(serial = serial, dead_money = True)

        self.money2bet(serial, amount)
        player.blind = True
        player.resetMissedBlinds()
        player.wait_for = False

    def ante(self, serial, amount = 0):
        if not self.ante_info:
            self.error("no ante due")
            return False
        if not self.isBlindAnteRound():
            self.error("player %d cannot pay ante while in state %s" % ( serial, self.state ))
            return False
        if not self.canAct(serial):
            self.error("player %d cannot pay ante. state = %s, serial in position = %d (ignored)" % (serial, self.state, self.getSerialInPosition()))
            return False
        if self.is_directing and amount == 0:
            amount = self.ante_info['value']
        self.payAnte(serial, amount)
        if self.is_directing:
            self.__talkedBlindAnte()
        return True

    def payAnte(self, serial, amount):
        player = self.serial2player[serial]
        amount = min(amount, player.money)
        if self.verbose >= 2: self.message("player %d pays ante %d" % (serial, amount))
        self.historyAdd("ante", serial, amount)
        self.money2bet(serial, amount)
        #self.bet2pot(serial)
        self.getPlayer(serial).ante = True

    def blindAnteMoveToFirstRound(self):
      self.side_pots['contributions'][self.current_round] = self.side_pots['contributions'][self.current_round - 1]
      del self.side_pots['contributions'][self.current_round - 1]
      # self.uncalled is kept to what it was set during the blind/ante round with live bets
      
    def blindAnteRoundEnd(self):
        if self.is_directing:
            return

        if self.ante_info:
            self.bet2pot()

        if self.inGameCount() < 2 and self.betsEqual():
            #
            # All players are all-in except one, distribute all
            # cards and figure out who wins.
            #
            if self.verbose >= 2: self.message("less than two players not all-in")
            self.nextRound()
            self.blindAnteMoveToFirstRound()
            self.__makeSidePots()
            self.bet2pot()

            if self.verbose >= 2: self.message("money not yet distributed, assuming information is missing ...")
        else:
            self.nextRound()
    
    def muck(self, serial, want_to_muck):
        if not self.is_directing:
            if self.verbose > 0: self.message("muck action ignored...")
            return
        if not self.state == GAME_STATE_MUCK:
            self.error("muck: game state muck expected, found %s" % self.state)            
            return
        if serial not in self.muckable_serials:
            self.error("muck: serial %s not found in muckable_serials" % serial) 
            return
            
        self.muckable_serials.remove(serial)
        if not want_to_muck:
            self.serial2player[serial].hand.allVisible()  
        self.__talked_muck()
      
    def __talkedBlindAnte(self):
        if self.sitCountBlindAnteRound() < 2:
            self.returnBlindAnte()
            self.cancelState()
            return
        
        if self.isBlindAntePayed():
            #
            # Once the blind and antes are payed, it may be necessary to
            # recompute the list of players willing to participate in the
            # turn. Some of them may have declined to pay the blind/ante
            # and thus excluded themselves from the turn.
            #
            player_list = self.player_list[:]
            self.buildPlayerList(False)
            if player_list != self.player_list:
                for serial in player_list:
                    player = self.getPlayer(serial)
                    if player.wait_for:
                        self.historyAdd("wait_for", serial, player.wait_for)
                self.historyAdd("player_list", self.player_list)
            self.dealerFromDealerSeat()
            self.first_turn = False
            if self.inGameCount() < 2 and self.betsEqual():
                #
                # All players are all-in (except one, maybe), distribute all
                # cards and figure out who wins.
                #
                if self.verbose >= 2: self.message("less than two players not all-in")
                self.nextRound()
                self.blindAnteMoveToFirstRound()
                self.__makeSidePots()
                self.bet2pot()
                self.dealCards()
                
                while not self.isLastRound():
                    self.nextRound()
                    self.dealCards()

                self.muckState(WON_ALLIN_BLIND)
            else:
                self.nextRound()
                self.dealCards()
                if self.is_directing:
                    self.initRound()
        else:
            self.updateBlinds()
            self.position = self.indexInGameAdd(self.position, 1)
            self.historyAdd("position", self.position)
            self.autoPayBlindAnte()

    def __talked(self, serial):
        self.getPlayer(serial).talked_once = True
        if self.__roundFinished(serial):
            if self.verbose >= 2: self.message("round finished")

            self.__makeSidePots()
            self.bet2pot()

            if self.notFoldCount() < 2:
                self.position = self.indexNotFoldAdd(self.position, 1)
                self.historyAdd("position", self.position)
                if self.verbose >= 2: self.message("last player in game %d" % self.getSerialInPosition())
                if self.isFirstRound():
                    self.updateStatsFlop(True)

                self.muckState(WON_FOLD)

            elif self.inGameCount() < 2:
                #
                # All players are all-in except one, distribute all
                # cards and figure out who wins.
                #
                if self.verbose >= 2: self.message("less than two players not all-in")
                while not self.isLastRound():
                    self.nextRound()
                    self.dealCards()
                    
                self.muckState(WON_ALLIN)
            else:
                #
                # All bets equal, go to next round
                #
                if self.verbose >= 2: self.message("next state")
                if self.isLastRound():
                    self.muckState(WON_REGULAR)
                else:
                    self.nextRound()
                    if self.is_directing:
                        self.dealCards()
                        self.initRound()
                    else:
                      self.runCallbacks("end_round")
                      if self.verbose >= 2: self.message("round not initialized, waiting for more information ... ")
                    
        else:
            self.position = self.indexInGameAdd(self.position, 1)
            self.historyAdd("position", self.position)
            if self.verbose >= 2: self.message("new position (%d)" % self.position)
            self.__autoPlay()

    def __talked_muck(self):
        if not self.is_directing:
            # Test impossible, at this point the game can not be a client game
            # This method is called from muckstate and muck functions where this test is already done
            return #pragma: no cover
            
        if not self.state == GAME_STATE_MUCK:
            # Test impossible, at this point the game state can not be something else than GAME_STATE_MUCK
            # This method is called from :
            # - muckstate where the game state is set to the right state
            # - muck where this test is already done
            self.error("muck: game state muck expected, found %s" % self.state) #pragma: no cover
            return #pragma: no cover
        if not self.muckable_serials:          
            self.showdown()
            self.endState()

    def __botEval(self, serial):
        ev = self.handEV(serial, 10000, True)

        if self.state == GAME_STATE_PRE_FLOP:
            if ev < 100:
                action = "check"
            elif ev < 500:
                action = "call"
            else:
                action = "raise"
        elif self.state == GAME_STATE_FLOP or self.state == GAME_STATE_THIRD:
            if ev < 200:
                action = "check"
            elif ev < 600:
                action = "call"
            else:
                action = "raise"
        elif self.state == GAME_STATE_TURN or self.state == GAME_STATE_FOURTH:
            if ev < 300:
                action = "check"
            elif ev < 700:
                action = "call"
            else:
                action = "raise"
        else:
            if ev < 400:
                action = "check"
            elif ev < 800:
                action = "call"
            else:
                action = "raise"

        return (action, ev)

    def __autoPlay(self):
        if not self.is_directing:
            return
        player = self.getPlayerInPosition()
        serial = player.serial

        if player.isBot():
            (desired_action, ev) = self.__botEval(serial)
            actions = self.possibleActions(serial)
            if actions:
              while not desired_action in actions:
                  if desired_action == "check":
                      desired_action = "fold"
                  elif desired_action == "call":
                      desired_action = "check"
                  elif desired_action == "raise":
                      desired_action = "call"

              if desired_action == "fold":
                  self.fold(serial)
              elif desired_action == "check":
                  self.check(serial)
              elif desired_action == "call":
                  self.call(serial)
              elif desired_action == "raise":
                  self.callNraise(serial, 0)
              else:
                  # Test impossible
                  # The actions returned by the possibleActions method can not be somethin else than fold, chack, call or raise
                  self.error("__autoPlay: unexpected actions = %s" % actions) #pragma: no cover

            else:
                self.error("__autoPlay: no possible action")
        elif ( player.isSitOut() or player.isAuto() ):
            #
            # A player who is sitting but not playing (sitOut) automatically
            # folds.
            #
            self.fold(serial)

    def hasLow(self):
        return "low" in self.win_orders

    def hasHigh(self):
        return "hi" in self.win_orders

    def isLow(self):
        return self.win_orders == [ "low" ]

    def isHigh(self):
        return self.win_orders == [ "hi" ]
    
    def isHighLow(self):
        return self.win_orders == [ "hi", "low" ]

    def getVariantName(self):
        return self.variant_name
    
    def setVariant(self, variant):
        self.__variant.load(self.url % variant)
        self.variant = variant
        self.variant_name = self.getParam("/poker/variant/@name")
        self.round_info = []
        self.round_info_backup = []
        self.win_orders = []
        for win_order in self.getParamList("/poker/variant/wins/winner/@order"):
            if win_order == "low8":
                self.win_orders.append("low")
            elif win_order == "high":
                self.win_orders.append("hi")
            else:
                self.error("unexpected win order: %s for variant %s" % ( win_order, variant ))
        if not self.win_orders:
            raise UserWarning, "failed to read win orders from %s" % self.__variant.path

        board_size = 0
        hand_size = 0
        for name in self.getParamList("/poker/variant/round/@name"):
            board = self.getParamList("/poker/variant/round[@name='" + name + "']/deal[@card='board']")
            board_size += len(board)
            cards = self.getParamList("/poker/variant/round[@name='" + name + "']/deal[@card='up' or @card='down']/@card")
            hand_size += len(cards)
            position = self.getParam("/poker/variant/round[@name='" + name + "']/position/@type")
            info = {
                "name": name,
                "position": position,
                "board": board,
                "board_size": board_size,
                "hand_size": hand_size,
                "cards": cards,
                }
            self.round_info.append(info)
            self.round_info_backup.append(info.copy())
        self.rake = pokerrake.get_rake_instance(self)

    def resetRoundInfo(self):
        """
        The roundInfo() data structure may be altered during the round, for
        instance to cope with a lack of cards in stud7. resetRoundInfo() reset
        the roundInfo structure to match the information that was initialy
        read from the betting structure description file.
        """
        for i in xrange(len(self.round_info)):
            self.round_info[i] = self.round_info_backup[i].copy()

    def getBettingStructureName(self):
        return self.betting_structure_name
    
    def setBettingStructure(self, betting_structure):
        self.__betting_structure.load(self.url % betting_structure)
        self.betting_structure = betting_structure
        self.betting_structure_name = self.getParam("/bet/description")
        self.buy_in = int(self.getParam('/bet/@buy-in') or "0")
        self.max_buy_in = int(self.getParam('/bet/@max-buy-in') or 4294967295) 
        self.best_buy_in = int(self.getParam('/bet/@best-buy-in') or "0")
        self.unit = int(self.getParam('/bet/@unit'))

        self.bet_info = self.getParamProperties('/bet/variants[contains(@ids,"' + self.variant + '")]/round')
        for bet_info in self.bet_info:
          if not bet_info.has_key("cap"):
            bet_info["cap"] = sys.maxint
          else:
            bet_info["cap"] = int(bet_info["cap"])
          if bet_info["cap"] < 0:
            bet_info["cap"] = sys.maxint
            
        self.blind_info = False
        blind_info = self.getParamProperties("/bet/blind");
        if len(blind_info) > 0:
            blinds = blind_info[0]
            self.blind_info = {
                "change": blinds.has_key("change") and blinds["change"]
                }

            if self.blind_info["change"] != False:
                self.blind_info["frequency"] = int(blinds["frequency"])
                self.blind_info["unit"] = blinds["unit"]
                if self.blind_info["change"] == "levels":
                  self.blind_info["levels"] = self.loadTournamentLevels(self.getParam('/bet/blind/@levels'))
                elif self.blind_info["change"] == "double":
                  self.blind_info["small"] = int(blinds["small"])
                  self.blind_info["small_reference"] = self.blind_info["small"]
                  self.blind_info["big"] = int(blinds["big"])
                  self.blind_info["big_reference"] = self.blind_info["big"]
            else:
              self.blind_info["small"] = int(blinds["small"])
              self.blind_info["big"] = int(blinds["big"])

        self.ante_info = False
        ante_info = self.getParamProperties("/bet/ante");
        if len(ante_info) > 0:
            antes = ante_info[0]
            self.ante_info = {
                "change": antes.has_key("change") and antes["change"]
                }

            if self.ante_info["change"]:
                self.ante_info["frequency"] = int(antes["frequency"])
                self.ante_info["unit"] = antes["unit"]
                if self.ante_info["change"] == "levels":
                  self.ante_info["levels"] = self.loadTournamentLevels(self.getParam('/bet/ante/@levels'))
                elif self.ante_info["change"] == "double":
                  self.ante_info["value"] = int(antes["value"])
                  self.ante_info["value_reference"] = self.ante_info["value"]
                  self.ante_info["bring-in"] = int(antes["bring-in"])
                  self.ante_info["bring-in_reference"] = self.ante_info["bring-in"]
            else:
              self.ante_info["value"] = int(antes["value"])
              self.ante_info["bring-in"] = int(antes["bring-in"])

        self.limit_type = self.getParam("/bet/@limit_type" or "")
        if self.limit_type == "":
          # Try to guess limit type from betting_structure name 
          if self.betting_structure.find("no-limit") > -1:
            self.limit_type = "no-limit"
          elif self.betting_structure.find("pot-limit") > -1:
            self.limit_type = "pot-limit"
          else:
            self.limit_type = "limit"

        self.rake = pokerrake.get_rake_instance(self)

    def loadTournamentLevels(self, file):
        if not LEVELS_CACHE.has_key(file):
          config = Config(self.dirs)
          config.load(file)
          levels = []
          nodes = config.header.xpathEval('/levels/level')
          for node in nodes:
            level = map(lambda (key, value): ( key, int(value) ), config.headerNodeProperties(node).iteritems())
            levels.append(dict(level))
          config.free()
          LEVELS_CACHE[file] = levels
        return LEVELS_CACHE[file]
        
    def getBoardLength(self):
        return len(self.board.tolist(True))

    def cardsDealtThisRoundCount(self, criterion = lambda x: True):
        if not self.isRunning():
            return -1
        
        if self.isBlindAnteRound():
            return 0
        
        round_info = self.roundInfo()
        return len(filter(criterion, round_info["cards"]))
        
    def upCardsDealtThisRoundCount(self):
        return self.cardsDealtThisRoundCount(lambda x: x == "up")
        
    def downCardsDealtThisRoundCount(self):
        return self.cardsDealtThisRoundCount(lambda x: x == "down")

    def getMaxHandSize(self):
        return len(self.getParamList("/poker/variant/hand/position"))

    def getMaxBoardSize(self):
        if self.getParam("/poker/variant/@type") == "community":
            return len(self.getParamList("/poker/variant/community/position"))
        else:
            return 0

    def cardsDealt(self):
        if self.isBlindAnteRound():
            return True
        hand_size = self.roundInfo()["hand_size"]
        for player in self.playersInGame():
            if player.hand.len() != hand_size:
                return False
        return self.getBoardLength() == self.roundInfo()["board_size"]
    
    def dealCards(self):
        if not self.is_directing:
            return
        
        info = self.roundInfo()

        number_of_players = len(self.playersNotFold())

        def number_to_deal():
            return len(info["board"]) + len(info["cards"]) * number_of_players

        if number_to_deal() > len(self.deck):
            cards = info["cards"]
            cards.reverse()
            while number_to_deal() > len(self.deck):
                if "up" in cards:
                    cards.remove("up")
                elif "down" in cards:
                    cards.remove("down")
                else:
                    raise UserWarning, "unable to deal %d cards" % number_to_deal()
                info["hand_size"] -= 1

                info["board"].append("board")
                info["board_size"] += 1
            cards.reverse()
            
        for card in info["board"]:
            self.board.add(self.deck.pop(), True)
        for card in info["cards"]:
            for player in self.playersNotFold():
                player.hand.add(self.deck.pop(), card == "up")
        if self.verbose >= 1:
          if len(info["cards"]) > 0:
            for serial in self.serialsNotFold():
              self.message("player %d cards: " % serial + self.getHandAsString(serial))
          if len(info["board"]) > 0:
            self.message("board: " + self.getBoardAsString())
          
        
    def __roundFinished(self, serial):
        #
        # The round finishes when there is only one player not fold ...
        #
        if self.notFoldCount() < 2:
            if self.verbose >= 2: self.message("only one player left in the game")
            return True

        #
        # ... or when all players are all-in.
        #
        if self.inGameCount() < 1:
            if self.verbose >= 2: self.message("all players are all-in")
            return True
        
        if self.first_betting_pass:
            if serial != self.getSerialLastToTalk():
              if self.inGameCount() < 2:
                #
                # If there is only one player left to talk, it is
                # meaningless to ask for his action, unless he has
                # something to call. 
                #
                return self.betsEqual()
              else:
                return False
            else:
                self.first_betting_pass = False
        return self.betsEqual()

    def moneyDistributed(self):
        return len(self.showdown_stack) > 0

    def isWinnerBecauseFold(self):
        return ( self.win_condition == WON_FOLD )

    #
    # Split the pots
    #
    def distributeMoney(self):
        if self.moneyDistributed():
            self.error("distributeMoney must be called only once per turn")
            return

        pot_backup = self.pot
        side_pots = self.getPots()

        serial2delta = {}
        for (serial, share) in side_pots['contributions']['total'].iteritems():
          player_dead = self.getPlayer(serial).dead
          serial2delta[serial] = - ( share + player_dead )
          
        if self.isWinnerBecauseFold():
            serial2rake = {}
            #
            # Special and simplest case : the winner has it because 
            # everyone folded. Don't bother to evaluate.
            #
            (serial,) = self.serialsNotFold()
            self.pot -= self.getRakedAmount()
            serial2rake[serial] = self.getRakedAmount()
            serial2delta[serial] += self.pot
            self.showdown_stack = [ { 'type': 'game_state',
                                      'player_list': self.player_list,
                                      'side_pots': side_pots,
                                      'pot': pot_backup,
                                      'foldwin': True,
                                      'serial2share': { serial: self.pot },
                                      'serial2delta': serial2delta,
                                      'serial2rake': serial2rake },
                                    { 'type': 'resolve',
                                      'serial2share': { serial: pot_backup },
                                      'serials': [serial],
                                      'pot': pot_backup } ]
            if self.verbose > 2: self.message(pformat(self.showdown_stack))
            self.pot2money(serial)
            self.setWinners([serial])
            if not self.is_directing: self.updateHistoryEnd(self.winners, self.showdown_stack)
            return

        serial2side_pot = {}
        for player in self.playersNotFold():
            serial2side_pot[player.serial] = side_pots['pots'][player.side_pot_index][1]
        if self.verbose >= 2: self.message("distribute a pot of %d" % self.pot)
        #
        # Keep track of the best hands (high and low) for information
        # and for the showdown.
        #
        self.serial2best = self.bestHands(self.serialsNotFold())
        #
        # Every player that received a share of the pot and the
        # amount.
        #
        serial2share = {}
        #
        # List of winners for each side of the pot (hi or low),
        # regardless of the fact that low hands matter for this
        # particular variant. Warning: a winner may show more
        # than once in these lists (when he is tie for two side pots,
        # for instance).
        #
        self.side2winners = { 'hi': [], 'low': [] }
        #
        # Complete showdown information, starting with the lowest side pot.
        #
        showdown_stack = []
        #
        # The chips that can't be divided evenly among winners
        #
        chips_left = 0
        #
        # While there is some money left at the table
        #
        while True:
            potential_winners = filter(lambda player: serial2side_pot[player.serial] > 0, self.playersNotFoldShowdownSorted())
            #
            # Loop ends when there is no more money, i.e. no more
            # players with a side_pot greater than 0
            #
            if len(potential_winners) == 0:
                break
            #
            # All information relevant to this distribution round
            #
            frame = {}
            #
            # This happens only for the potential winner that has the
            # highest pot (all other players are all-in but none matched
            # his bet).
            #
            # This last potential winner reaches this stage and wins not
            # because of his hand but because of the size of his stacks.
            # He only wins back what he bet.
            #
            # Let him have his money back and don't register him as a
            # winner (winners are registered in self.side2winners).
            #
            if len(potential_winners) == 1:
                winner = potential_winners[0]
                frame['type'] = 'uncalled'
                frame['serial'] = winner.serial
                frame['uncalled'] = serial2side_pot[winner.serial]
                #
                # Special case : a player folds on the turn and the only other player left in the game
                # did not bet. There is no reason for the player to fold : he forfeits a pot that
                # he may win. Nevertheless, it can happen. In this case, and only if there is at least
                # one player allin, the only other player left is awarded what looks like an uncalled
                # bet.
                # In this case the uncalled_serial is zero.
                #
                if self.uncalled_serial != 0 and winner.serial != self.uncalled_serial:
                    self.error(pformat(self.showdown_stack)) #pragma: no cover
                    raise UserWarning, "distributeMoney: unexpected winner.serial != uncalled_serial / %d != %d" % ( winner.serial, self.uncalled_serial ) #pragma: no cover
                showdown_stack.insert(0, frame)
                serial2share.setdefault(winner.serial, 0)
                if self.verbose >= 2 and self.uncalled_serial != 0 and side_pots and side_pots.has_key('last_round') and side_pots['last_round'] >= 0:
                  if serial2side_pot[winner.serial] < self.uncalled:
                    self.error(pformat(self.showdown_stack)) #pragma: no cover
                    raise UserWarning, "serial2side_pot[winner.serial] < self.uncalled (%d != %d)" % ( serial2side_pot[winner.serial], self.uncalled ) #pragma: no cover
                serial2share[winner.serial] += serial2side_pot[winner.serial]
                serial2delta[winner.serial] += serial2side_pot[winner.serial]
                serial2side_pot[winner.serial] = 0
                break
            
            for key in (self.win_orders + [ 'pot', 'chips_left' ]):
              frame[key] = None
            frame['type'] = 'resolve'
            frame['serial2share'] = {}
            frame['serials'] = [ player.serial for player in potential_winners ]

            if self.verbose >= 2:
              self.message("looking for winners with board %s" % self.getBoardAsString())
              for player in potential_winners:
                self.message("  => hand for player %d %s" % ( player.serial, self.getHandAsString(player.serial)))
            #
            #
            # Ask poker-eval to figure out who the winners actually are
            #
            eval = self.eval.winners(game = self.variant,
                                     pockets = [ player.hand.tolist(True) for player in potential_winners ],
                                     board = self.board.tolist(True))
            #
            # Feed local variables with eval results sorted in various
            # forms to ease computing the results.
            #
            winners = [ ]
            if self.verbose >= 1: self.message("winners:")
            for (side, indices) in eval.iteritems():
                side_winners = [ potential_winners[i] for i in indices ]
                for winner in side_winners:
                    if self.verbose >= 1: self.message(" => player %d %s (%s)" % ( winner.serial, self.bestCardsAsString(self.serial2best, winner.serial, side), side ))
                    serial2share.setdefault(winner.serial, 0)
                    frame['serial2share'][winner.serial] = 0
                frame[side] = [ winner.serial for winner in side_winners ]
                self.side2winners[side] += frame[side]
                winners += side_winners
                
            #
            # The pot to be considered is the lowest side_pot of all
            # the winners. In other words, we must share the pot that
            # was on the table for the winner that was all-in first.
            #
            pot = min([ serial2side_pot[player.serial] for player in winners ])
            frame['pot'] = pot
            if self.verbose >= 2: self.message("  and share a pot of %d" % pot)
            #
            # If there are no winners for the low hand (either because the
            # game is not hi/low or because there is no qualifying low
            # hand), the pot goes to the high side winner. Otherwise
            # the pot is divided equaly between hi and low winners.
            #
            # A player who scoops (wins high and low) will show twice
            # in the winners_indices list and will therefore get two shares.
            # This is why the following does not take in account the side
            # for which the winner wins.
            #
            (global_share, remainder) = self.divideChips(pot, len(eval.keys()))
            chips_left += remainder
            frame['chips_left'] = remainder
            for winners_indices in eval.values():
                winners = [ potential_winners[i] for i in winners_indices ]
                (share, remainder) = self.divideChips(global_share, len(winners))
                chips_left += remainder
                frame['chips_left'] += remainder
                for winner in winners:
                    serial2share[winner.serial] += share
                    serial2delta[winner.serial] += share
                    frame['serial2share'][winner.serial] += share
            #
            # The side pot of each winner is lowered by the amount
            # that was shared among winners. It will reduce the number
            # of potential winners (to the very least, the winner(s)
            # with the smallest side pot will be discarded).
            #
            for player in potential_winners:
                serial2side_pot[player.serial] -= pot

            showdown_stack.append(frame)

        #
        # Do not rake the chips that were uncalled
        #
        serial2rakeable = serial2share.copy()
        if showdown_stack[0]['type'] == 'uncalled':
          uncalled = showdown_stack[0]
          serial2rakeable[uncalled['serial']] -= uncalled['uncalled']
          if serial2rakeable[uncalled['serial']] <= 0:
            del serial2rakeable[uncalled['serial']]
        serial2rake = self.distributeRake(self.getRakedAmount(), pot_backup, serial2rakeable)

        for serial in serial2rake.keys():
          serial2share[serial] -= serial2rake[serial]
          serial2delta[serial] -= serial2rake[serial]
          if 'serial2share' in frame and serial in frame['serial2share']:
            frame['serial2share'][serial] -= serial2rake[serial]

        for (serial, share) in serial2share.iteritems():
            self.getPlayer(serial).money += share

        #
        # The chips left go to the player next to the dealer,
        # regardless of the fact that this player folded.
        #
        if chips_left > 0:
            next_to_dealer = self.indexAdd(self.dealer, 1)
            player = self.serial2player[self.player_list[next_to_dealer]]
            player.money += chips_left
            serial2share.setdefault(player.serial, 0)
            serial2share[player.serial] += chips_left
            serial2delta[player.serial] += chips_left
            showdown_stack.insert(0, { 'type': 'left_over',
                                       'chips_left': chips_left,
                                       'serial': player.serial })

        self.pot = 0
        #
        # For convenience, build a single list of all winners, regardless
        # of the side of the pot they won. Remove duplicates in all lists.
        #
        winners_serials = []
        for side in self.side2winners.keys():
            self.side2winners[side] = uniq(self.side2winners[side])
            winners_serials += self.side2winners[side]
        self.setWinners(uniq(winners_serials))
        showdown_stack.insert(0, { 'type': 'game_state',
                                   'serial2best': self.serial2best,
                                   'player_list': self.player_list,
                                   'side_pots': side_pots,
                                   'pot': pot_backup,
                                   'serial2share': serial2share,
                                   'serial2rake': serial2rake,
                                   'serial2delta': serial2delta
                                   })
        self.showdown_stack = showdown_stack
        if not self.is_directing: self.updateHistoryEnd(self.winners, showdown_stack)
        if self.verbose > 2: self.message(pformat(self.showdown_stack))

    def divideChips(self, amount, divider):
        return ( amount / divider, amount % divider )
    
    def dispatchMuck(self):
        if not self.is_directing:
            self.error("dispatchMuck: not supposed to be called by client")
            return None
        
        if self.isWinnerBecauseFold():
            return ( (), tuple(self.winners) )
        
        # Get the last bettor on the river
        def triggerFunc(x,y):
            if x == None:
                if y[0] == "round" and y[1] == GAME_STATE_RIVER:
                    return self.indexNotFoldAdd(self.dealer, 1)
            elif y[0] == "bet" or y[0] == "raise":
                return self.player_list.index(y[1])
            return x

        showing = reduce(triggerFunc, self.turn_history, None)
        if showing is None:
            showing = self.indexNotFoldAdd(self.dealer, 1)
        last_to_show = self.indexNotFoldAdd(showing, -1)

        has_low = len(self.side2winners["low"])
        best_low_value = 0x0FFFFFFF
        has_high = len(self.side2winners["hi"])
        best_hi_value = 0
        
        muckable = []
        to_show  = []
        
        while True:
            player = self.serial2player[self.player_list[showing]]
            show = False 

            if has_low:
                low_value = self.bestHandValue("low", player.serial)
                if low_value < best_low_value:
                    best_low_value = low_value
                    show = True

            if has_high:
                hi_value = self.bestHandValue("hi", player.serial)
                if hi_value > best_hi_value:
                    best_hi_value = hi_value
                    show = True

            #
            # This is deemed necessary because this simplistic but intuitive
            # way to show or muck cards does not take in account the recursive
            # nature of splitting a side pot. A player with a hand lower than
            # a previous hand may need to show his cards if the previous hand
            # belonged to someone who was all-in. Example: player 1 has trips,
            # player 2 has two pairs, player 3 has nothing. Player 1 is left
            # of dealer, shows and win. But player 1 was all-in, therefore
            # player 2 and player 3 compete for the remaining chips. Player 2
            # shows and win. In the end player 1 showed his hand and player 2
            # also showed his hand although he was after player 1 with a
            # weaker hand.
            #            
            if player.serial in self.winners:
                show = True

            if show:
                to_show.append(player.serial)
            else:
                muckable.append(player.serial)
                
            if showing == last_to_show:
                break
            
            showing = self.indexNotFoldAdd(showing, 1)
        
        return ( to_show, muckable )
         
    
    def showdown(self):
        self.historyAdd("showdown", self.board.copy(), self.handsMap())

    def handEV(self, serial, iterations, self_only = False):
        pocket_size = self.getMaxHandSize()
        pockets = []
        serials = self.serialsNotFold()
        if self_only:
            #
            # Pretend that the pocket cards of other players are unknown
            # 
            pockets = [[PokerCards.NOCARD] * pocket_size] * len(serials)
            if serial in serials:
              my_cards = self.getPlayer(serial).hand.tolist(True)
              pockets[serials.index(serial)] = my_cards
        else:
            for pocket in [ player.hand.tolist(True) for player in self.playersNotFold() ]:
                if len(pocket) < pocket_size:
                    pocket.extend([PokerCards.NOCARD] * (pocket_size - len(pocket)))
                pockets.append(pocket)
        board = self.board.tolist(True)
        board_size = self.getMaxBoardSize()
        if len(board) < board_size:
            board.extend([PokerCards.NOCARD] * (board_size - len(board)))
        eval = self.eval.poker_eval(game = self.variant,
                                    pockets = pockets,
                                    board = board,
                                    fill_pockets = 1,
                                    iterations = iterations)
        if serial in serials:
          player_index = serials.index(serial)
          return eval["eval"][player_index]["ev"]
        else:
          self.error("handEV: player %d is not holding cards in the hand" % serial)
          return None

    def readableHandValueLong(self, side, value, cards):
        cards = self.eval.card2string(cards)
        if value == "NoPair":
            if side == "low":
                if cards[0][0] == '5':
                    return _("The wheel")
                else:
                    return join(map(lambda card: card[0], cards), ", ")
            else:
                return _("High card %(card)s") % { 'card' : _(letter2name[cards[0][0]]) }
        elif value == "OnePair":
            return _("A pair of %(card)s") % { 'card' : _(letter2names[cards[0][0]]) } + _(", %(card)s kicker") % { 'card' : _(letter2name[cards[2][0]]) }
        elif value == "TwoPair":
            return _("Two pairs %(card1)s and %(card2)s") % { 'card1' : _(letter2names[cards[0][0]]), 'card2' : _(letter2names[cards[2][0]]) } + _(", %(card)s kicker") % { 'card' : _(letter2name[cards[4][0]]) }
        elif value == "Trips":
            return _("Three of a kind %(card)s") % { 'card' : _(letter2names[cards[0][0]]) } + _(", %(card)s kicker") % { 'card' : _(letter2name[cards[3][0]]) }
        elif value == "Straight":
            return _("Straight %(card1)s to %(card2)s") % { 'card1' : _(letter2name[cards[0][0]]), 'card2' : _(letter2name[cards[4][0]]) }
        elif value == "Flush":
            return _("Flush %(card)s high") % { 'card' : _(letter2name[cards[0][0]]) }
        elif value == "FlHouse":
            return _("%(card1)ss full of %(card2)ss") % { 'card1' : _(letter2name[cards[0][0]]), 'card2' : _(letter2name[cards[3][0]]) }
        elif value == "Quads":
            return _("Four of a kind %(card)s") % { 'card' : _(letter2names[cards[0][0]]) } + _(", %(card)s kicker") % { 'card' : _(letter2name[cards[4][0]]) }
        elif value == "StFlush":
            if letter2name[cards[0][0]] == 'Ace':
                return _("Royal flush")
            else:
                return _("Straight flush %(card)s high") % { 'card' : _(letter2name[cards[0][0]]) }
        return value
        
    def readableHandValueShort(self, side, value, cards):
        cards = self.eval.card2string(cards)
        if value == "NoPair":
            if side == "low":
                if cards[0][0] == '5':
                    return _("The wheel")
                else:
                    return join(map(lambda card: card[0], cards), ", ")
            else:
                return _("High card %(card)s") % { 'card' : _(letter2name[cards[0][0]]) }
        elif value == "OnePair":
            return _("Pair of %(card)s") % { 'card' : _(letter2names[cards[0][0]]) }
        elif value == "TwoPair":
            return _("Pairs of %(card1)s and %(card2)s") % { 'card1' : _(letter2names[cards[0][0]]), 'card2' : _(letter2names[cards[2][0]]) }
        elif value == "Trips":
            return _("Trips %(card)s") % { 'card' : _(letter2names[cards[0][0]]) }
        elif value == "Straight":
            return _("Straight %(card)s high") % { 'card' : _(letter2name[cards[0][0]]) }
        elif value == "Flush":
            return _("Flush %(card)s high") % { 'card' : _(letter2name[cards[0][0]]) }
        elif value == "FlHouse":
            return _("%(card1)ss full of %(card2)ss") % { 'card1' : _(letter2name[cards[0][0]]), 'card2' : _(letter2name[cards[3][0]]) }
        elif value == "Quads":
            return _("Quads %(card)s") % { 'card' : _(letter2names[cards[0][0]]) } + ", %(card)s kicker" % { 'card' : _(letter2name[cards[4][0]]) }
        elif value == "StFlush":
            if letter2name[cards[0][0]] == 'Ace':
                return _("Royal flush")
            else:
                return _("Straight flush")
        return value
        
    def bestHands(self, serials):
        results = {}
        for serial in serials:
            #
            # Cannot figure out the best hand for a player with
            # a placeholder.
            #
            if self.serial2player[serial].hand.hasCard(PokerCards.NOCARD):
                continue
            result = {}
            for side in self.win_orders:
                result[side] = self.bestHand(side, serial)
            results[serial] = result
#        print "bestHands: %s" % self.win_orders
#        pprint(results)
        return results

    def bestCardsAsString(self, bests, serial, side):
        return join(self.eval.card2string(bests[serial][side][1][1:]))
        
    def bestHand(self, side, serial):
        if self.variant == "omaha" or self.variant == "omaha8":
            hand = self.serial2player[serial].hand.tolist(True)
            board = self.board.tolist(True)
        else:
            hand = self.serial2player[serial].hand.tolist(True) + self.board.tolist(True)
            board = []
        return self.eval.best(side, hand, board)

    def bestHandValue(self, side, serial):
        (value, cards) = self.bestHand(side, serial)
        return value

    def bestHandCards(self, side, serial):
        (value, cards) = self.bestHand(side, serial)
        return cards

    def readablePlayerBestHands(self, serial):
        results = []
        if self.hasHigh(): results.append(self.readablePlayerBestHand('hi', serial))
        if self.hasLow(): results.append(self.readablePlayerBestHand('low', serial))
        return "\n".join(results)
        
    def readablePlayerBestHand(self, side, serial):
        cards = self.bestHandCards(side, serial)
        result = self.readableHandValueLong(side, cards[0], cards[1:])
        result += ": " + ", ".join(self.eval.card2string(cards[1:]))
        return result
        
    def cards2string(self, cards):
        return join(self.eval.card2string(cards.tolist(True)))
    
    def getHandAsString(self, serial):
        return self.cards2string(self.serial2player[serial].hand)

    def getBoardAsString(self):
        return self.cards2string(self.board)
                    
    def betsNull(self):
        if self.isRunning():
            return sum([ player.bet for player in self.playersNotFold()]) == 0
        else:
            return False
        
    def setWinners(self, serials):
        if self.verbose >= 2: self.message("player(s) %s win" % serials)
        self.winners = serials

    def bet2pot(self, serial = 0, dead_money = False):
        if serial == 0:
            serials = self.player_list
        else:
            serials = [serial]

        for serial in serials:
            player = self.serial2player[serial]
            bet = player.bet
            self.pot += bet
            if dead_money:
                player.dead += bet
            player.bet = 0
            self.runCallbacks("bet2pot", serial, bet)

    def money2bet(self, serial, amount, dead_money = False):
        player = self.serial2player[serial]

        if amount > player.money:
            self.error("money2bet: %d > %d" % (amount, player.money))
            raise ValueError("money2bet: requested amount %d more than %d stack (%d)" % (amount, player.money. serial))
        player.money -= amount
        player.bet += amount
        self.runCallbacks("money2bet", serial, amount)
        if dead_money:
          pot_index = len(self.side_pots['pots']) - 1
          self.side_pots['building'] += amount
        else:
          self.__updateUncalled()
          self.updatePots(serial, amount)
        if player.money == 0:
            self.historyAdd("all-in", serial)
            player.all_in = True

    def __updateUncalled(self):
      highest_bet = 0
      highest_bet_players_count = 0
      for player in self.playersNotFold():
        if player.bet > highest_bet:
          highest_bet = player.bet
          highest_bet_players_count = 1
        elif player.bet == highest_bet:
          highest_bet_players_count += 1

      if highest_bet_players_count == 0: raise UserWarning, "there should be at least one player in the game" #pragma: no cover
      
      if highest_bet_players_count > 1:
        self.uncalled = 0
        self.uncalled_serial = 0
        return 

      self.uncalled = highest_bet
      for player in self.playersNotFold():
        if player.bet != highest_bet and highest_bet - player.bet < self.uncalled:
          self.uncalled = highest_bet - player.bet
        if player.bet == highest_bet:
          self.uncalled_serial = player.serial
      
    def updatePots(self, serial, amount):
        pot_index = len(self.side_pots['pots']) - 1
        self.side_pots['building'] += amount
        contributions = self.side_pots['contributions']
        contributions['total'].setdefault(serial, 0)
        contributions['total'][serial] += amount
        round_contributions = contributions[self.current_round]
        round_contributions.setdefault(pot_index, {})
        pot_contributions = round_contributions[pot_index]
        pot_contributions.setdefault(serial, 0)
        pot_contributions[serial] += amount

    def playersInPotCount(self, side_pots):
        pot_index = len(side_pots['pots']) - 1
        
        if not side_pots['contributions'].has_key(side_pots['last_round']): return 0
        contributions = side_pots['contributions'][side_pots['last_round']]
        if not contributions.has_key(pot_index): return 0
        return len(contributions[pot_index])

    def isSingleUncalledBet(self, side_pots):
        return self.playersInPotCount(side_pots) == 1

    def getUncalled(self):
        return self.uncalled

    def getUncalledSerial(self):
        return self.uncalled_serial

    def getPotAmount(self):
        if self.isRunning():
          return self.pot
        else:
          if self.moneyDistributed():
            return self.showdown_stack[0]['pot']
          else:
            return self.pot
          
    def pot2money(self, serial):
        player = self.serial2player[serial]
        player.money += self.pot
        self.pot = 0

    def highestBetNotFold(self):
        return max([ player.bet for player in self.playersNotFold() ])

    def highestBetInGame(self):
        return max([ player.bet for player in self.playersInGame() ])

    def betsEqual(self):
        if self.notFoldCount() > 1 and self.inGameCount() > 0:
            #
            # If a player that is all-in placed a bet that is higher
            # than any of the bets of the players still in game, the
            # bets are not equal.
            #
            if self.highestBetNotFold() > self.highestBetInGame():
                return False
            #
            # If one of the players still in game placed a bet that
            # is different from the others, the bets are not equal.
            #
            players = self.playersInGame()
            bet = players[0].bet
            for player in players:
                player_bet = player.bet
                if bet != player_bet:
                    return False
        return True

    def __makeSidePots(self):
        amount_index = 0
        total_index = 1
        last_pot_index = -1
        round_contributions = self.side_pots['contributions'][self.current_round]
        pots = self.side_pots['pots']
        pots[last_pot_index][amount_index] += self.side_pots['building'] # amount
        pots[last_pot_index][total_index] += self.side_pots['building'] # total
        self.side_pots['building'] = 0
        current_pot_index = len(pots) - 1
        players = filter(lambda player: player.side_pot_index == current_pot_index, self.playersAllIn())
        if not players:
            return
        players.sort(lambda a,b: int(a.bet - b.bet))
        for player in players:
            pot_contributions = round_contributions[len(pots) - 1]
            if not pot_contributions.has_key(player.serial):
                #
                # This may happen if two players are all in for exactly
                # the same amount.
                #
                continue
            if len(pot_contributions) == 1:
                #
                # This may happen when a player goes all in and
                # has more chips than all other players
                #
                break
            new_pot_contributions = {}
            pot = pots[last_pot_index]
            new_pot = [0, 0]
            new_pot_index = len(pots)
            contribution = pot_contributions[player.serial]
            for serial in pot_contributions.keys():
                other_contribution = pot_contributions[serial]
                pot_contributions[serial] = min(contribution, other_contribution)
                remainder = other_contribution - pot_contributions[serial]
                pot[amount_index] -= remainder
                pot[total_index] -= remainder
                other_player = self.getPlayer(serial)
                if other_contribution > contribution:
                    new_pot_contributions[serial] = remainder
                    new_pot[amount_index] += remainder
                    other_player.side_pot_index = new_pot_index
                elif ( other_contribution == contribution and
                       not other_player.isAllIn() ):
                    other_player.side_pot_index = new_pot_index
            round_contributions[new_pot_index] = new_pot_contributions
            new_pot[total_index] = new_pot[amount_index] + pot[total_index]
            pots.append(new_pot)

    def getPots(self):
        return self.side_pots

    def getSidePotTotal(self):
        return self.side_pots['pots'][-1][1]

    def getLatestPotContributions(self):
        contributions = self.side_pots['contributions']
        last_round = max(filter(lambda x: x != 'total', contributions.keys()))
        return contributions[last_round]
        
    def indexInGameAdd(self, position, increment):
        return self.playerListIndexAdd(position, increment, PokerPlayer.isInGame)

    def indexNotFoldAdd(self, position, increment):
        return self.playerListIndexAdd(position, increment, PokerPlayer.isNotFold)

    def indexAdd(self, position, increment):
        return self.playerListIndexAdd(position, increment, lambda x: True)

    #
    # Increment the "index" (relative to self.player_list knowing
    # that self.player_list is not modified during a turn) for a
    # total of "increment", skipping the players for which "predicate"
    # is false.
    #
    def playerListIndexAdd(self, index, increment, predicate):
        if increment > 0:
            step = 1
        else:
            step = -1
        while increment:
            index = (index + step) % len(self.player_list)
            increment -= step
            while not predicate(self.serial2player[self.player_list[index]]):
                index = (index + step) % len(self.player_list)
        return index
        
    def getSerialDealer(self):
        return self.player_list[self.dealer]

    def getSerialInPosition(self):
        if self.position >= 0:
            return self.player_list[self.position]
        else:
            return 0

    def getSerialLastToTalk(self):
        return self.player_list[self.last_to_talk]

    def getPlayerDealer(self):
        return self.serial2player[self.player_list[self.dealer]]

    def getPlayerInPosition(self):
        return self.serial2player[self.player_list[self.position]]

    def getPlayerLastToTalk(self):
        return self.serial2player[self.player_list[self.last_to_talk]]

    def disconnectedCount(self):
        return len(self.serialsDisconnected())

    def serialsDisconnected(self):
        return filter(lambda x: self.serial2player[x].isDisconnected(), self.serial2player.keys())

    def playersDisconnected(self):
        return [ self.serial2player[serial] for serial in self.serialsDisconnected() ]

    def connectedCount(self):
        return len(self.serialsConnected())

    def serialsConnected(self):
        return filter(lambda x: self.serial2player[x].isConnected(), self.serial2player.keys())

    def playersConnected(self):
        return [ self.serial2player[serial] for serial in self.serialsConnected() ]

    def sitOutCount(self):
        return len(self.serialsSitOut())

    def serialsSitOut(self):
        return filter(lambda x: self.serial2player[x].isSitOut(), self.serial2player.keys())

    def playersSitOut(self):
        return [ self.serial2player[serial] for serial in self.serialsSitOut() ]

    def brokeCount(self):
        return len(self.serialsBroke())

    def serialsBroke(self):
        return filter(lambda serial: self.isBroke(serial), self.serial2player.keys())

    def playersBroke(self):
        return [ self.serial2player[serial] for serial in self.serialsBroke() ]

    def sitCount(self):
        return len(self.serialsSit())

    def serialsSit(self):
        return filter(lambda x: self.serial2player[x].isSit(), self.serial2player.keys())

    def playersSit(self):
        return [ self.serial2player[serial] for serial in self.serialsSit() ]

    def notPlayingCount(self):
        return len(self.serialsNotPlaying())

    def serialsNotPlaying(self):
        if self.isRunning():
            return filter(lambda x: not x in self.player_list, self.serial2player.keys())
        else:
            return self.serial2player.keys()

    def playersNotPlaying(self):
        return [ self.serial2player[serial] for serial in self.serialsNotPlaying() ]

    def playingCount(self):
        return len(self.serialsPlaying())

    def serialsPlaying(self):
        if self.isRunning():
            return self.player_list
        else:
            return []

    def playersPlaying(self):
        return [ self.serial2player[serial] for serial in self.serialsPlaying() ]

    def allCount(self):
        return len(self.serial2player)

    def serialsAllSorted(self):
        if self.dealer < 0 or self.dealer >= len(self.player_list):
            player_list = self.serial2player.keys()
            player_list.sort()
            return player_list
        else:
            #
            # The list of serials, sort from worst position to best
            # position (i.e. the dealer)
            #
            player_list = self.serial2player.keys()
            player_list.sort(lambda a,b: int(self.serial2player[a].seat - self.serial2player[b].seat))
            #
            # The dealer is at the beginning of the list, followed by
            # all the players that would be dealers if he left, in order.
            #
            dealers = self.player_list[self.dealer:] + self.player_list[:self.dealer]
            #
            # If the dealer left, switch to the next one
            #
            while len(dealers) > 0 and dealers[0] not in player_list:
                dealers.pop(0)
            #
            # If at least one player that participated in the last
            # hand is still registered in the game, it is the dealer.
            # We use him as a reference point of the best position in
            # game.
            #
            if len(dealers) > 0:
                dealer_index = player_list.index(dealers[0])
                player_list = player_list[dealer_index:] + player_list[:dealer_index]
                player_list.append(player_list.pop(0))
            return player_list

    def serialsAll(self):
            return self.serial2player.keys()

    def playersAll(self):
        return self.serial2player.values()

    def inGameCount(self):
        return len(self.serialsInGame())

    def serialsInGame(self):
        return filter(lambda x: self.serial2player[x].isInGame(), self.player_list)

    def playersInGame(self):
        return [ self.serial2player[serial] for serial in self.serialsInGame() ]

    def allInCount(self):
        return len(self.serialsAllIn())

    def serialsAllIn(self):
        return filter(lambda x: self.serial2player[x].isAllIn(), self.player_list)

    def playersAllIn(self):
        return [ self.serial2player[serial] for serial in self.serialsAllIn() ]

    def serialsNotFoldShowdownSorted(self):
        next_to_dealer = self.indexAdd(self.dealer, 1)
        player_list = self.player_list[next_to_dealer:] + self.player_list[:next_to_dealer]
        return filter(lambda x: not self.serial2player[x].isFold(), player_list)
    
    def playersNotFoldShowdownSorted(self):
        return [ self.serial2player[serial] for serial in self.serialsNotFoldShowdownSorted() ]
        
    def notFoldCount(self):
        return len(self.serialsNotFold())

    def serialsNotFold(self):
        return filter(lambda x: not self.serial2player[x].isFold(), self.player_list)

    def playersNotFold(self):
        return [ self.serial2player[serial] for serial in self.serialsNotFold() ]

    def playersWinner(self):
        return map(lambda serial: self.serial2player[serial], self.winners)
        
    def isGameEndInformationValid(self):
        #
        # Only relevant for a game that has ended and for which we want to know
        # if all players involved in the last hand are still seated.
        #
        if self.state != GAME_STATE_END or len(self.winners) <= 0:
          return False
        if filter(lambda serial: not self.serial2player.has_key(serial), self.winners):
          return False
        return True

    #
    # Game Parameters.
    #
    def roundCap(self):
        if self.isRunning():
          return self.betInfo()["cap"]
        return 0

    def betLimits(self, serial):
        if not self.isRunning():
            return 0
        info = self.betInfo()
        highest_bet = self.highestBetNotFold()
        player = self.getPlayer(serial)
        money = player.money
        bet = player.bet
        to_call = highest_bet - bet
        if self.round_cap_left <= 0:
            return (0, 0, to_call)
        #
        # Figure out the theorical max/min bet, regarless of the
        # player[serial] bet/money status
        #
        if info.has_key("fixed"):
            fixed = int(info["fixed"])
            (min_bet, max_bet) = (fixed, fixed)
        elif info.has_key("pow_level"):
            fixed = int(info["pow_level"]) * pow(2, self.getLevel() - 1)
            (min_bet, max_bet) = (fixed, fixed)
        else:
            if info.has_key("min"):
              if info["min"] == "big":
                min_bet = self.bigBlind()
              else:
                min_bet = int(info["min"])
            elif info.has_key("min_pow_level"):
                min_bet = int(info["min_pow_level"]) * pow(2, self.getLevel() - 1)
            else:
                min_bet = 0

            min_bet = max(min_bet, self.last_bet)
            
            if info.has_key("max"):
                if re.match("[0-9]+$", info["max"]):
                    max_bet = int(info["max"])
                elif info["max"] == "pot":
                    max_bet = max(self.potAndBetsAmount() + (to_call * 2), min_bet)
            else:
                max_bet = money
        #
        # A player can't bet more than he has
        #
        min_bet = min(money, min_bet)
        max_bet = min(money, max_bet)
        retval = (min_bet, max_bet, to_call)
        return retval

    def potAndBetsAmount(self):
        pot = self.pot
        for player in self.playersPlaying():
            pot += player.bet
        return pot

    def autoBlindAnte(self, serial):
        self.getPlayer(serial).auto_blind_ante = True
        if self.isBlindAnteRound() and self.getSerialInPosition() == serial:
          self.autoPayBlindAnte()
        
    def noAutoBlindAnte(self, serial):
        self.getPlayer(serial).auto_blind_ante = False
        
    def autoMuck(self, serial, auto_muck):
        self.getPlayer(serial).auto_muck = auto_muck
        
    def payBuyIn(self, serial, amount):
        if not self.isTournament() and amount > self.maxBuyIn(serial):
          if self.verbose > 0: self.error("payBuyIn: maximum buy in is %d and %d is too much" % ( self.maxBuyIn(serial), amount ))
          return False
        player = self.getPlayer(serial)
        player.money = amount
        if self.isTournament() or player.money >= self.buyIn(serial):
          if serial in self.ratholes:
            del self.ratholes[serial]          
          player.buy_in_payed = True
          return True
        else:
          if self.verbose > 0: self.error("payBuyIn: minimum buy in is %d but %d is not enough" % ( self.buyIn(serial), player.money ))
          return False

    def rebuy(self, serial, amount):
        player = self.getPlayer(serial)
        if not player:
          return False
        if player.money + amount + player.rebuy > self.maxBuyIn(serial):
          return False
        if self.isPlaying(serial):
          player.rebuy += amount
        else:
          player.money += amount
        return True
        

    def buyIn(self, serial = -1):
        if serial not in self.ratholes:
            return self.buy_in

        (amount, time) = self.ratholes[serial]
        if (datetime.now() - time).seconds > 15*60 or amount < self.buy_in:
            return self.buy_in

        return amount


    def maxBuyIn(self, serial = -1):
        if serial not in self.ratholes:
            if self.verbose >= 6: self.message("maxBuyIn: serial not in ratholes - %d" % ( self.max_buy_in )) 
            return self.max_buy_in

        (amount, time) = self.ratholes[serial]
        if (datetime.now() - time).seconds > 15*60 or amount < self.max_buy_in:
            if self.verbose >= 6: self.message("maxBuyIn: from self.max_buy_in - %d" % ( amount )) 
            return self.max_buy_in

        if self.verbose >= 6: self.message("maxBuyIn: from ratholes - %d" % ( amount )) 
        return amount

    def bestBuyIn(self, serial = -1):
        if self.buyIn(serial) > self.best_buy_in:
            return self.buyIn(serial)

        return self.best_buy_in

    def getParamList(self, name):
        if name[:4] == "/bet":
            return self.__betting_structure.headerGetList(name)
        else:
            return self.__variant.headerGetList(name)

    def getParam(self, name):
        if name[:4] == "/bet":
            return self.__betting_structure.headerGet(name)
        else:
            return self.__variant.headerGet(name)

    def getParamProperties(self, name):
        if name[:4] == "/bet":
            return self.__betting_structure.headerGetProperties(name)
        else:
            return self.__variant.headerGetProperties(name)

    def full(self):
        return self.allCount() == self.max_players

    def empty(self):
        return self.allCount() == 0

    def changeState(self, state):
        if self.verbose >= 1: self.message("changing state %s => %s" % (self.state, state))
        self.state = state

    def isRunning(self):
        return not ( self.isEndOrNull() or self.state == GAME_STATE_MUCK )

    def isEndOrNull(self):
        return self.state == GAME_STATE_NULL or self.state == GAME_STATE_END

    def registerCallback(self, callback):
        if not callback in self.callbacks:
            self.callbacks.append(callback)

    def unregisterCallback(self, callback):
        self.callbacks.remove(callback)

    def runCallbacks(self, *args):
        for callback in self.callbacks:
            callback(self.id, *args)
      
    def historyAddNoDuplicate(self, *args):
        if len(self.turn_history) < 1 or self.turn_history[-1] != args:
          self.historyAdd(*args)
        elif self.verbose >= 2:
          self.message("ignore duplicate history event " + str(args))

    def historyAdd(self, *args):
        self.runCallbacks(*args)
        self.turn_history.append(args)

    def updateHistoryEnd(self, winners, showdown_stack):
        for index in range(-1, - len(self.turn_history), -1):
          if self.turn_history and self.turn_history[index][0] == "end":
            self.turn_history[index] = ( "end", winners, showdown_stack )
            break

    def historyGet(self):
        return self.turn_history

    def historyReduce(self):
        index = 0
        game_event = None
        player_list_index = 7
        serial2chips_index = 9
        position2serial = {}
        while index < len(self.turn_history):
            event = self.turn_history[index]
            type = event[0]
            if ( type == "showdown" or type == "muck" or
                 ( type == "round" and event[1] != GAME_STATE_BLIND_ANTE ) ):
                break
            elif type == "game":
                game_event = self.turn_history[index]
                position = 0
                for serial in game_event[player_list_index]:
                    position2serial[position] = serial
                    position += 1
                index += 1
            elif ( type == "sitOut" or type == "wait_blind" ):
                (type, serial) = event
                #
                # del position + sitOut/wait_blind
                #
                if index < 1 or self.turn_history[index-1][0] != "position":
                    if self.verbose >= 0: self.message(pformat(self.turn_history))
                    self.error("unable to update sitOut or wait_blind")
                    #
                    # help unit test : it is not meaningful to do anything on a corrupted
                    # history. Therefore the following line is not doing anything (or
                    # repair anything). It only helps run unit tests.
                    #
                    del self.turn_history[index]
                else:
                    del self.turn_history[index]
                    del self.turn_history[index - 1]
                    index -= 1
                    
                #
                # remove references to the player who finally
                # decided to not be part of the turn, either because
                # he sits out or because he waits for the big blind
                #
                game_event[player_list_index].remove(serial)
                del game_event[serial2chips_index][serial]
            elif ( type == "blind_request" or
                   type == "ante_request" or
                   type == "player_list" ):
                #
                # del, if not the last event
                #
                if index < len(self.turn_history) - 1:
                    if type == "player_list":
                        game_event[player_list_index][:] = event[1]
                    del self.turn_history[index]
                else:
                    index += 1
            elif ( type == "wait_for" ):
                (type, serial, wait_for) = event
                del self.turn_history[index]
                #
                # remove references to the player who is
                # not in the turn because he must wait for
                # the late blind
                #
                if serial in game_event[player_list_index]:
                    game_event[player_list_index].remove(serial)
                    del game_event[serial2chips_index][serial]
            else:
                index += 1
        #
        # Reset the positions of the players to take in account the removed players
        #
        for index in xrange(0, min(index, len(self.turn_history))):
            event = self.turn_history[index]
            if event[0] == "position" and event[1] >= 0:
                try:
                    self.turn_history[index] = ( event[0], game_event[player_list_index].index(position2serial[event[1]]) )
                except:
                    if self.verbose >= 0: self.message(pformat(self.turn_history))
                    self.error("unable to update position")

    def error(self, string):
      if self.verbose >= 0: self.message("ERROR: " + string)
      
    def message(self, string):
      print self.prefix + "[PokerGame " + str(self.id) + "] " + string
      
class PokerGameServer(PokerGame):
    def __init__(self, url, dirs):
        PokerGame.__init__(self, url, True, dirs) # is_directing == True

class PokerGameClient(PokerGame):
    def __init__(self, url, dirs):
        PokerGame.__init__(self, url, False, dirs) # is_directing == False
        

########NEW FILE########
__FILENAME__ = pokerprizes
#
# Copyright (C) 2006 - 2010 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                26 rue des rosiers, 75004 Paris
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>
#
from pokerengine.pokerengineconfig import Config

class PokerPrizes:
    """PokerPrizesVirtual base class for PokerPrizes"""
    def __init__(self, buy_in_amount, player_count = 0, guarantee_amount = 0, config_dirs = None):
        self.buy_in = buy_in_amount
        self.player_count = player_count
        self.guarantee_amount = guarantee_amount

    def error(self, string):
        self.message("ERROR " + string)

    def message(self, string):
        print "[PokerPrizes] " + string

    def addPlayer(self):
        self.player_count += 1

    def removePlayer(self):
        self.player_count -= 1

    def getPrizes(self):
        errStr = "getPrizes NOT IMPLEMENTED IN ABSTRACT BASE CLASS"
        self.error(errStr)
        raise NotImplementedError(errStr)

class PokerPrizesAlgorithm(PokerPrizes):
    def getPrizes(self):
        buy_in = self.buy_in
        candidates_count = self.player_count 
        if candidates_count < 5:
            winners = 1
        elif candidates_count < 10:
            winners = 2
        elif candidates_count < 20:
            winners = 3
        elif candidates_count < 30:
            winners = 4
        elif candidates_count < 40:
            winners = 6
        elif candidates_count < 50:
            winners = int(candidates_count * 0.2)
        elif candidates_count < 200:
            winners = int(candidates_count * 0.15)
        else:
            winners = int(candidates_count * 0.1)

        prizes = []
        prize_pool = max(self.guarantee_amount, buy_in * candidates_count)
        money_left = prize_pool
        while winners > 0:
            if money_left / winners < max(1, prize_pool / 100, int(buy_in * 2.5)):
                prizes.extend([ money_left / winners ] * winners)
                winners = 0
            else:
                money_left /= 2
                winners -= 1
                prizes.append(money_left)
        rest = prize_pool - sum(prizes)
        prizes[0] += rest
        return prizes

class PokerPrizesTable(PokerPrizes):
    def __init__(self, buy_in_amount, player_count = 0, guarantee_amount = 0, config_dirs = ['.'],
                 config_file_name = "poker.payouts.xml"):
        self._loadPayouts(config_dirs, config_file_name)

        PokerPrizes.__init__(self, buy_in_amount = buy_in_amount, player_count = player_count,
                             guarantee_amount = guarantee_amount)

    def _loadPayouts(self, dirs, config_file_name):
        config = Config(dirs)
        config.load(config_file_name)
        self.payouts = []
        for node in config.header.xpathEval("/payouts/payout"):
            properties = config.headerNodeProperties(node)
            self.payouts.append(( int(properties['max']), map(lambda percent: float(percent) / 100, node.content.split())))

    def getPrizes(self):
        buy_in = self.buy_in
        for ( maximum, payouts ) in self.payouts:
            if self.player_count <= maximum:
                break

        total = max(self.guarantee_amount, self.player_count * buy_in)
        prizes = map(lambda percent: int(total * percent), payouts)
        #
        # What's left because of rounding errors goes to the tournament winner
        #
        prizes[0] += total - sum(prizes)
        return prizes

########NEW FILE########
__FILENAME__ = pokerrake
#
# Copyright (C) 2006 - 2010 Loic Dachary <loic@dachary.org>
# Copyright (C) 2006 Mekensleep
#
# Mekensleep
# 26 rue des rosiers
# 75004 Paris
#       licensing@mekensleep.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
from os import path
from decimal import *
import imp

class PokerRake:
    def __init__(self, game):
        self.change = Decimal('0')

    def getRake(self, game):
        """ implementation constraint of compute is as follows :
        for any game1.pot greater than game2.pot
        compute(game1.pot) MUST be greater or equal to compute(game2.pot) """
        if game.isTournament():
            return 0
        
        if game.getMaxBoardSize() > 0 and len(game.board.tolist(True)) == 0:
            if game.verbose >= 2: game.message("Rake: No Flop No Drop")
            return 0 # No Flop No Drop
        
        # TODO: Stud needs to handle 3rd street folds the same way

        if game.sitCount() == 2:
            absRakeCap = 500
            bbRakeCap = 5
        else:
            absRakeCap = 2500
            bbRakeCap = 10

        if game.blind_info:
            rakeCap = min(absRakeCap, game.blind_info["big"]*bbRakeCap)
        else:
            rakeCap = absRakeCap

        if game.verbose >= 2: game.message("Rake: calculated rake cap as %d units" % rakeCap)
        
        rakeablePot = (game.getPotAmount() - game.getUncalled())
        decimalRake = min(rakeCap, rakeablePot * Decimal('0.01')) + self.change


        if game.verbose >= 2: game.message("Rake: calculated rake from %d pot as %2.2f (%0.2f from change)" % (rakeablePot, decimalRake, self.change))

        self.change = decimalRake - decimalRake.to_integral_value(ROUND_DOWN)
        rake = int(decimalRake.to_integral_value(ROUND_DOWN))

        if game.verbose >= 2: game.message("Rake: taking %d rake" % rake)

        return max(0, rake)

_get_rake_instance = None

def get_rake_instance(game):
    global _get_rake_instance
    if _get_rake_instance == None:
        verbose = game.verbose
        for dir in game.dirs:
            file = dir + "/pokerrake.py"
            if path.exists(file):
                if verbose > 0: game.message("get_rake_instance: trying to load " + file)
                module = imp.load_source("user_defined_pokerrake", file)
                get_instance = getattr(module, "get_rake_instance")
                _get_rake_instance = get_instance
                break
            else:
                if verbose > 0: game.message("get_rake_instance: " + file + " does not exist")
        if _get_rake_instance == None:
            if verbose > 0: game.message("get_rake_instance: no pokerrake.py found in directories " + str(game.dirs))
            _get_rake_instance = lambda game: PokerRake(game)
        else:
            if verbose > 0: game.message("get_rake_instance: using custom implementation of get_rake_instance")
    return apply(_get_rake_instance, [game])

########NEW FILE########
__FILENAME__ = pokertournament
#
# Copyright (C) 2006 - 2010 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008, 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                26 rue des rosiers, 75004 Paris
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>
#
from math import ceil
from types import StringType
from pprint import pformat
import time, sys, random

def tournament_seconds():
    return time.time()

shuffler = random

from pokerengine.pokergame import PokerGameServer
from pokerengine import pokerprizes

TOURNAMENT_STATE_ANNOUNCED = "announced"
TOURNAMENT_STATE_REGISTERING = "registering"
TOURNAMENT_STATE_RUNNING = "running"
TOURNAMENT_STATE_BREAK_WAIT = "breakwait"
TOURNAMENT_STATE_BREAK = "break"
TOURNAMENT_STATE_COMPLETE = "complete"
TOURNAMENT_STATE_CANCELED = "canceled"
            
def equalizeCandidates(games):
    #
    # Games less than 70% full are willing to steal players from other
    # games. Games that are more than 70% full and that are not
    # running are willing to provide players to others.
    #
    want_players = []
    provide_players = []
    for game in games:
        threshold = int(game.max_players * .7)
        count = game.allCount()
        if count < threshold:
            want_players.append([ game.id, game.max_players - count ])
        elif game.isEndOrNull():
            serials = game.serialsAllSorted()
            provide_players.append((game.id, serials[:count - threshold]))
    return ( want_players, provide_players )

def equalizeGames(games, verbose = 0, log_message = None):
    ( want_players, provide_players ) = equalizeCandidates(games)

    results = []

    if len(want_players) <= 0:
        return results

    consumer_index = 0
    for (id, serials) in provide_players:
        want_players.sort(lambda a,b: int(a[1] - b[1]))
        if want_players[0][1] == 0:
            #
            # All satisfied, stop looping
            #
            break

        while len(serials) > 0:
            distributed = False
            for i in xrange(len(want_players)):
                consumer = want_players[consumer_index]
                consumer_index = ( consumer_index + 1 ) % len(want_players)
                if consumer[1] > 0:
                    consumer[1] -= 1
                    serial = serials.pop(0)
                    results.append(( id, consumer[0], serial ))
                    distributed = True
                    if len(serials) <= 0:
                        break
            if not distributed:
                break

    if log_message and verbose > 0 and len(results) > 0:
        log_message("balanceGames equalizeGames: " + pformat(results))

    return results

def breakGames(games, verbose = 0, log_message = None):
    if len(games) < 2:
        return []

    games = games[:]
    #
    # Games not running first, then games running.
    # Each is sorted with games that have least players first.
    #
    games.sort(lambda a,b: b.isEndOrNull() - a.isEndOrNull() or int(a.allCount() - b.allCount()) )

    to_break = [ {
        "id": game.id,
        "seats_left": game.max_players - game.allCount(),
        "serials": game.serialsAll(),
        "to_add": [],
        "running": not game.isEndOrNull() } for game in games ]

    if verbose > 2: log_message("balanceGames breakGames: %s" % to_break)
    results = []
    while True:
        result = breakGame(to_break[0], to_break[1:], verbose, log_message)
        to_break = filter(lambda game: game["seats_left"] > 0, to_break[1:])
        if result == False:
            break
        results.extend(result)
        if len(to_break) < 2:
            break

    if log_message and verbose > 0 and len(results) > 0:
        log_message("balanceGames breakGames: " + pformat(results))

    return results

def breakGame(to_break, to_fill, verbose = 0, log_message = None):
    #
    # Can't break a game in which players were moved or
    # that are running.
    #
    if len(to_break["to_add"]) > 0 or to_break["running"]:
        return False
    
    seats_left = sum([ game["seats_left"] for game in to_fill ])
    serials = to_break["serials"]
    id = to_break["id"]
    #
    # Don't break a game if there is not enough seats at the
    # other games
    #
    if seats_left < len(serials):
        return False

    #
    # Fill the largest games first, in the hope that the smallest
    # games can be broken later.
    #
    to_fill.reverse()
    result = []
    for game in to_fill:
        if game["seats_left"] > 0:
            count = min(game["seats_left"], len(serials))
            game["to_add"].extend(serials[:count])
            game["seats_left"] -= count
            result.append((id, game["id"], serials[:count]))
            serials = serials[count:]
            if len(serials) <= 0:
                break;

    return result

class PokerTournament:

    def __init__(self, *args, **kwargs):
        self.name = kwargs.get('name', 'no name')
        self.description_short = kwargs.get('description_short', 'nodescription_short')
        self.description_long = kwargs.get('description_long', 'nodescription_long')
        self.serial = kwargs.get('serial', 1)
        self.verbose = kwargs.get('verbose', 0)
        self.players_quota = kwargs.get('players_quota', 10)
        self.players_min = kwargs.get('players_min', 2)
        self.variant = kwargs.get('variant', 'holdem')
        self.betting_structure = kwargs.get('betting_structure', 'level-15-30-no-limit')
        self.dirs = kwargs.get('dirs', [])
        self.seats_per_game = kwargs.get('seats_per_game', 10)
        self.sit_n_go = kwargs.get('sit_n_go', 'y')
        self.register_time = kwargs.get('register_time', 0)
        self.start_time = kwargs.get('start_time', 0)
        self.breaks_first = kwargs.get('breaks_first', 7200)
        self.breaks_interval = kwargs.get('breaks_interval', 3600)
        self.breaks_duration = kwargs.get('breaks_duration', 300)
        self.breaks_running_since = -1
        self.breaks_since = -1
        self.breaks_count = 0
        self.buy_in = int(kwargs.get('buy_in', 0))
        self.rake = int(kwargs.get('rake', 0))
        self.rebuy_delay = kwargs.get('rebuy_delay', 0)
        self.add_on = kwargs.get('add_on', 0)
        self.add_on_delay = kwargs.get('add_on_delay', 60)
        self.prize_min = kwargs.get('prize_min', 0)
        self.prizes_specs = kwargs.get('prizes_specs', "table")
        self.rank2prize = None
        self.finish_time = -1
        if type(self.start_time) is StringType:
            self.start_time = int(time.mktime(time.strptime(self.start_time, "%Y/%m/%d %H:%M")))
        self.prefix = ""
        
        self.players = []
        self.need_balance = False
        self.registered = 0
        self.winners = []
        self.state = TOURNAMENT_STATE_ANNOUNCED
        self.can_register = False
        self.games = []
        self.id2game = {}
        
        self.callback_new_state = lambda tournament, old_state, new_state: True
        self.callback_create_game = lambda tournament: PokerGameServer("poker.%s.xml", tournament.dirs)
        # I think callback_game_filled() is a misnomer because it's not
        # about the table being "filled" (i.e., the table could have less
        # than the max seated at it).  What really happens is that the
        # callback_game_filled() is made when the table is deemed to have
        # the number of players at it the tourney manager has decided
        # belong there (which may or may not be "filled").
        self.callback_game_filled = lambda tournament, game: True
        self.callback_destroy_game = lambda tournament, game: True
        self.callback_move_player = lambda tournament, from_game_id, to_game_id, serial: self.movePlayer(from_game_id, to_game_id, serial)
        self.callback_remove_player = lambda tournament, game_id, serial: self.removePlayer(game_id, serial)
        self.callback_cancel = lambda tournament: True
        
        self.loadPayouts()
        self.updateRegistering()

    def finalize(self):
        # Force save ANNOUNCED state into DB
        if self.state == TOURNAMENT_STATE_ANNOUNCED:
          self.callback_new_state(self, TOURNAMENT_STATE_ANNOUNCED, TOURNAMENT_STATE_ANNOUNCED)

    def loadPayouts(self):
        if self.sit_n_go == 'y':
            player_count = self.players_quota
        else:
            player_count = self.registered
        self.prizes_object =  pokerprizes.__dict__['PokerPrizes' + self.prizes_specs.capitalize()](buy_in_amount = self.buy_in, player_count = player_count, guarantee_amount = self.prize_min, config_dirs = self.dirs)

    def message(self, message):
        print self.prefix + "[PokerTournament %s] " % self.name + message
        
    def canRun(self):
        if self.start_time < tournament_seconds():
            if self.sit_n_go == 'y' and self.registered >= self.players_quota:
                return True
            elif self.sit_n_go == 'n':
                if self.registered >= self.players_min:
                    return True
                else:
                    return None
            else:
                return False
        else:
            return False

    def getRank(self, serial):
        try:
            winners_count = len(self.winners)
            rank_first = self.registered - winners_count
            return self.winners.index(serial) + rank_first + 1
        except:
            return -1
        
    def updateRegistering(self):
        if self.state == TOURNAMENT_STATE_ANNOUNCED:
            now = tournament_seconds()
            if now - self.register_time > 0.0:
                self.changeState(TOURNAMENT_STATE_REGISTERING)
                return -1
            else:
                return self.register_time - now
        else:
            if self.verbose > 0: self.message("updateRegistering: should not be called while tournament is not in announced state")
            return -1

    def updateRunning(self):
        if self.state == TOURNAMENT_STATE_REGISTERING:
            ready = self.canRun()
            if ready == True:
                self.changeState(TOURNAMENT_STATE_RUNNING)
            elif ready == None:
                self.changeState(TOURNAMENT_STATE_CANCELED)
            elif ready == False:
                pass

    def remainingBreakSeconds(self):
        if self.breaks_since > 0:
            return self.breaks_duration - ( tournament_seconds() - self.breaks_since )
        else:
            return None
        
    def updateBreak(self, game_id = None):
        if self.breaks_duration <= 0:
            return False

        if self.state == TOURNAMENT_STATE_RUNNING:
            running_duration = tournament_seconds() - self.breaks_running_since
            if self.breaks_count > 0:
                running_max = self.breaks_interval
            else:
                running_max = self.breaks_first
            if running_duration >= running_max:
                self.breaks_games_id = []
                self.changeState(TOURNAMENT_STATE_BREAK_WAIT)
                
        if self.state == TOURNAMENT_STATE_BREAK_WAIT:
            #
            # game_id is 0 when updateBreak is called after a table was destroyed
            # as a side effect of balanceGames
            #
            if game_id > 0:
                self.breaks_games_id.append(game_id)
            on_break = True
            for game in self.games:
                #
                # games with a single player must not be taken into account because
                # nothing happens on them. Either it is the last game with a single
                # player and must be considered ready to enter the break. Or there
                # are still other tables playing and the game with a single player
                # may be broken and the player moved to another table when the hand
                # finishes at one of the other tables.
                #
                # If the games with a single player are not ignored, a two game
                # tournament would enter a deadlock in the following situation:
		#        1) table T1 finishes its hand and only has one player left
		#           tournament is not on BREAK_WAIT
		#        2) tournament break time is reached
		#        3) table T2 finishes its hand, no player is busted.
		#           endTurn is called and tournament enters BREAK_WAIT
		#           T2 is added to the list of tables for which there
		#           is not need to wait before declaring the tournament
		#           on break. Because T1 has only one player left and
		#           all other tables are expecting the break (i.e. no
		#           hand will be played), it can be added to the list
		#           of tables ready for the break.
		#                
                #
                if game.id not in self.breaks_games_id and len(game.playersAll()) > 1:
                    on_break = False
                    break
            if on_break:
                del self.breaks_games_id
                self.changeState(TOURNAMENT_STATE_BREAK)

        if self.state == TOURNAMENT_STATE_BREAK:
            if self.remainingBreakSeconds() <= 0:
                self.changeState(TOURNAMENT_STATE_RUNNING)

        if self.state not in (TOURNAMENT_STATE_RUNNING, TOURNAMENT_STATE_BREAK_WAIT, TOURNAMENT_STATE_BREAK):
            if self.verbose >= 0: print "PokerTournament:updateBreak: is not supposed to be called while in state %s" % self.state
            return None
        
        return True
        
    def changeState(self, state):
        if self.state == TOURNAMENT_STATE_ANNOUNCED and state == TOURNAMENT_STATE_REGISTERING:
            self.can_register = True
        elif self.state == TOURNAMENT_STATE_RUNNING and state == TOURNAMENT_STATE_BREAK_WAIT:
            pass
        elif self.state == TOURNAMENT_STATE_BREAK_WAIT and state == TOURNAMENT_STATE_BREAK:
            self.breaks_since = tournament_seconds()
        elif self.state == TOURNAMENT_STATE_BREAK and state == TOURNAMENT_STATE_RUNNING:
            self.breaks_since = -1
            self.breaks_running_since = tournament_seconds()
        elif self.state == TOURNAMENT_STATE_REGISTERING and state == TOURNAMENT_STATE_RUNNING:
            self.start_time = tournament_seconds()
            self.breaks_running_since = self.start_time
            self.createGames()
            self.can_register = False
        elif self.state == TOURNAMENT_STATE_REGISTERING and state == TOURNAMENT_STATE_CANCELED:
            self.can_register = False
            self.cancel()
            self.finish_time = tournament_seconds()
        elif ( self.state in ( TOURNAMENT_STATE_RUNNING, TOURNAMENT_STATE_BREAK_WAIT ) and
               state == TOURNAMENT_STATE_COMPLETE ):
            self.finish_time = tournament_seconds()
        else:
            if self.verbose >= 0: print "PokerTournament:changeState: cannot change from state %s to state %s" % ( self.state, state )
            return
        if self.verbose > 2: self.message("state change %s => %s" % ( self.state, state ))
        old_state = self.state
        self.state = state
        self.callback_new_state(self, old_state, self.state)

    def isRegistered(self, serial):
        return serial in self.players
        
    def canRegister(self, serial):
        if self.can_register and self.registered < self.players_quota:
            return not self.isRegistered(serial)
        else:
            return False

    def canUnregister(self, serial):
        return self.isRegistered(serial) and self.state == TOURNAMENT_STATE_REGISTERING
        
    def register(self, serial):
        if self.can_register:
            self.players.append(serial)
            self.registered += 1
            if self.sit_n_go != 'y':
                self.prizes_object.addPlayer()
                self.rank2prize = None
            if self.state == TOURNAMENT_STATE_REGISTERING:
                self.updateRunning()
            elif self.state == TOURNAMENT_STATE_RUNNING:
                self.sitPlayer(serial)
            return True
        else:
            return False

    def unregister(self, serial):
        if self.state == TOURNAMENT_STATE_REGISTERING:
            self.players.remove(serial)
            self.registered -= 1
            if self.sit_n_go != 'y':
                self.prizes_object.removePlayer()
                self.rank2prize = None
            return True
        else:
            return False

    def cancel(self):
        if self.state == TOURNAMENT_STATE_REGISTERING:
            self.callback_cancel(self)
            self.players = []
            self.registered = 0
            return True
        else:
            return False
        
    def sitPlayer(self, serial):
        pass

    def removePlayer(self, game_id, serial):
        game = self.id2game[game_id]
        game.removePlayer(serial)

    def movePlayer(self, from_game_id, to_game_id, serial):
        from_game = self.id2game[from_game_id]
        to_game = self.id2game[to_game_id]
        from_game.open()
        to_game.open()
        from_player = from_game.getPlayer(serial)
        to_game.addPlayer(serial)
        to_player = to_game.getPlayer(serial)
        to_game.payBuyIn(serial, from_player.money)
        to_game.sit(serial)
        to_game.autoBlindAnte(serial)
        to_player.name = from_player.name
        to_player.setUserData(from_player.getUserData())
        if(from_player.isSitOut()): to_game.sitOut(serial)
        if(from_player.isBot()): to_game.botPlayer(serial)
        from_game.removePlayer(serial)
        from_game.close()
        to_game.close()
    
    def createGames(self):
        games_count = int(ceil(self.registered / float(self.seats_per_game)))
        self.players_quota = games_count * self.seats_per_game
        players = self.players[:]
        shuffler.shuffle(players)
        for id in xrange(1, games_count + 1):
            game = self.callback_create_game(self)
            game.verbose = self.verbose
            game.setTime(0)
            game.setVariant(self.variant)
            game.setBettingStructure(self.betting_structure)
            game.setMaxPlayers(self.seats_per_game)
            if game.id == 0: game.id = id

            buy_in = game.buyIn()
            for seat in xrange(self.seats_per_game):
                if not players: break
                    
                player = players.pop()
                game.addPlayer(player)
                game.payBuyIn(player, buy_in)
                game.sit(player)
                game.autoBlindAnte(player)
                
            self.games.append(game)
        self.id2game = dict(zip([ game.id for game in self.games ], self.games))
        # Next, need to call balance games, because the table assignment
        # algorithm above does not account for scenarios where the last
        # few people end up a table too small.
        self.balanceGames()
        # Next, we can now notify via callback that all the games in
        # self.games have been "filled".
        for game in self.games:
            self.callback_game_filled(self, game)
            game.close()

    def endTurn(self, game_id):
        game = self.id2game[game_id]
        loosers = game.serialsBroke()
        loosers_count = len(loosers)

        for serial in loosers:
            self.winners.insert(0, serial)
            self.callback_remove_player(self, game_id, serial)
        if self.verbose > 2: self.message("winners %s" % self.winners)
        
        if len(self.winners) + 1 == self.registered:
            game = self.games[0]
            player = game.playersAll()[0]
            self.winners.insert(0, player.serial)
            self.callback_remove_player(self, game.id, player.serial)
            money = player.money
            player.money = 0
            expected = game.buyIn() * self.registered
            if money != expected and self.verbose >= 0:
                self.message("ERROR winner has %d chips and should have %d chips" % ( money, expected ))
            if self.verbose > 0: self.message("winners %s" % self.winners)
            self.callback_destroy_game(self, game)
            self.games = []
            self.id2game = {}
            self.changeState(TOURNAMENT_STATE_COMPLETE)
            return False
        else:
            if loosers_count > 0 or self.need_balance:
                self.balanceGames()
            if self.id2game.has_key(game_id):
                self.updateBreak(game_id)
            else:
                #
                # This happens if game_id was destroyed by the call to balanceGames above
                #
                self.updateBreak(0)
            return True
        
    def balanceGames(self):
        self.need_balance = False
        if len(self.games) < 2: return
        if self.verbose > 2: self.message("balanceGames")
        to_break = breakGames(self.games, self.verbose, self.message)
        games_broken = {}
        for (from_id, to_id, serials) in to_break:
            for serial in serials:
                if self.verbose > 2: self.message("balanceGames: player %d moved from %d to %d" % ( serial, from_id, to_id ))
                if self.state == TOURNAMENT_STATE_REGISTERING:
                    self.movePlayer(from_id, to_id, serial)
                else:
                    self.callback_move_player(self, from_id, to_id, serial)
            games_broken[from_id] = True

        if len(to_break) > 0:
            for game_id in games_broken.keys():
                game = self.id2game[game_id]
                self.callback_destroy_game(self, game)
                self.games.remove(game)
                del self.id2game[game.id]
            if self.verbose > 0: self.message("balanceGames: broke tables %s" % to_break)
            return True
        
        to_equalize = equalizeGames(self.games, self.verbose, self.message)
        for (from_id, to_id, serial) in to_equalize:
            if self.verbose > 2: self.message("balanceGames: player %d moved from %d to %d" % ( serial, from_id, to_id ))
            if self.state == TOURNAMENT_STATE_REGISTERING:
                self.movePlayer(from_id, to_id, serial)
            else:
                self.callback_move_player(self, from_id, to_id, serial)

        ( want_players, provide_players ) = equalizeCandidates(self.games)
        self.need_balance = want_players and not provide_players
        if self.need_balance and self.verbose > 2: self.message("balanceGames: postponed game equalization")
        
        return len(to_equalize) > 0

    def prizes(self):
        if not self.rank2prize:
            self.rank2prize = self.prizes_object.getPrizes()
        return self.rank2prize

########NEW FILE########
__FILENAME__ = version
# -*- python -*-
#
# Copyright (C) 2006 - 2010 Loic Dachary <loic@dachary.org>
# Copyright (C) 2005, 2006 Mekensleep
#
# Mekensleep
# 26 rue des rosiers
# 75004 Paris
#       licensing@mekensleep.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
# 
from types import StringType
import re
from pokerengine import version_number

class Version:

    verbose = 0
    
    version_re = re.compile(r'^(\d+)\.(\d+)\.(\d+)$',
                            re.VERBOSE)


    upgrade_re = re.compile(r'.*?(\d+\.\d+\.\d+)-(\d+\.\d+\.\d+)',
                            re.VERBOSE)

    def __init__ (self, vstring=None):
        if vstring:
            self.parse(vstring)

    def __repr__ (self):
        return "%s ('%s')" % (self.__class__.__name__, str(self))

    def __str__ (self):
        return "%d.%d.%d" % self.version

    def __hash__(self):
        return hash(str(self))

    def __cmp__ (self, other):
        if isinstance(other, StringType):
            other = Version(other)

        return cmp(self.version, other.version)

    def __add__(self, num):
        ver = Version()
        ver.version = (self.version[0], self.version[1], self.version[2] + num)
        return ver
        
    def __iadd__(self, num):
        self.version = (self.version[0], self.version[1], self.version[2] + num)
        return self
        
    def sub(ver, num):
        version = list(ver.version)
        if version[2] - num < 0:
            if version[1] - num < 0:
                if version[0] - num < 0:
                    raise UserWarning, "cannot subtract %d from version %s" % ( num, str(ver) )
                else:
                    version[0] -= num
            else:
                version[1] -= num
        else:
            version[2] -= num
        ver.version = tuple(version)
        return ver

    sub = staticmethod(sub)

    def __isub__(self, num):
        return Version.sub(self, num)
        
    def __sub__(self, num):
        return Version.sub(Version(str(self)), num)

    def major(self):
        return self.version[0]
    
    def medium(self):
        return self.version[1]
    
    def minor(self):
        return self.version[2]

    def parse(self, vstring):
        match = Version.version_re.match(vstring)
        if not match:
            raise ValueError, "invalid version number '%s'" % vstring

        (major, medium, minor) = match.groups()

        self.version = tuple(map(int, [major, medium, minor]))

    def upgradeChain(self, desired_version, strings):
        current_version = self
        upgrade_matrix = {}
        for string in strings:
            match = Version.upgrade_re.match(string)
            if match:
                ( version_from, version_to ) = map(Version, match.groups())
                if ( ( version_from >= current_version and version_from < desired_version )
                     and ( version_to > current_version and version_to <= desired_version ) ):
                    upgrade_matrix.setdefault(version_from, {})
                    if upgrade_matrix[version_from].has_key(version_to):
                        if Version.verbose >= 0: print "Version: duplicate upgrade string (%s => %s) keep %s, ignore %s" % ( version_from, version_to, upgrade_matrix[version_from][version_to], string)
                    else:
                        upgrade_matrix[version_from][version_to] = string
        #
        # Each time a version requires an upgrade (presumably for database or configuration
        # file changes), a string of the kind upgrade-1.0.1-1.0.2 indicates
        # the availability of an upgrade from version 1.0.1 to version 1.0.2.
        #
        # When switching from version 1.0.0 to version 1.0.6,
        # upgradeChain return upgrade-1.0.1-1.0.2 meaning that this
        # upgrade must be applied. If there also is an
        # upgrade-1.0.3-1.0.5, upgradeChain will return ( upgrade-1.0.1-1.0.2, upgrade-1.0.3-1.0.5 )
        # meaning that both upgrades must be applied in that order.
        #
        # If there was a string upgrade-0.9.0-1.0.0 or
        # upgrade-3.0.0-3.1.0 in the list of available upgrades, they
        # would be ignored.
        #
        # If there are more than one upgrade from a given version (for instance
        # upgrade-1.0.0-1.0.1 and upgrade-1.0.0-1.0.4), the one that allows to
        # upgrade to the highest version is preferred.
        #
        chain = []
        while current_version != desired_version:
            candidate_versions = filter(lambda version: version >= current_version, upgrade_matrix.keys())
            if candidate_versions:
                candidate_version = min(candidate_versions)
                upgrades = upgrade_matrix[candidate_version]
                current_version = max(upgrades.keys())
                chain.append(upgrades[current_version])
            else:
                #
                # There is not necessarily an upgrade file reaching the desired version,
                # for instance if there was no change.
                #
                break
        return chain

version = Version(version_number)

########NEW FILE########
__FILENAME__ = apiclient
#!/usr/bin/env python
# coding: utf-8

import BaseHTTPServer
import optparse
import sys
import time
import urllib2

import oauth2


def build_request(url, key, secret, body=''):
    """Returns a signed HMAC_SHA1 oauth2.Request object."""
    consumer = oauth2.Consumer(key=key, secret=secret)
    params = {
        'oauth_version': "1.0",
        'oauth_nonce': oauth2.generate_nonce(),
        'oauth_timestamp': int(time.time()),
        'oauth_consumer_key': consumer.key
    }

    method = 'GET'
    if body is not '':
        method = 'POST'

    req = oauth2.Request(method=method, url=url, body=body,
                         parameters=params)
    signature_method = oauth2.SignatureMethod_HMAC_SHA1()
    req.sign_request(signature_method, consumer, None)
    return req


def __perform_api_request(request):
    url = request.to_url()
    body = request.body

    response_code = None
    response_data = ''
    response_headers = {}
    try:
        request = urllib2.Request(url)
        if body is not '':
            headers = {'Content-Type': 'application/json',
                       'Content-Length': str(len(body))}
            request = urllib2.Request(url, body, headers)
        response = urllib2.urlopen(request)
        response_code = response.code
        response_headers = response.info()
        response_data = response.read()
    except urllib2.URLError, e:
        if hasattr(e, 'reason'):
            print 'Failed to perform request: ', e.reason
            return
        elif hasattr(e, 'code'):
            response_code = e.code
            response_headers = e.info()
            response_data = e.read()

    status = BaseHTTPServer.BaseHTTPRequestHandler.responses[response_code][0]
    print 'Status:', response_code, status
    for header in response_headers:
        print header, ':', response_headers[header]
    print
    print response_data


if __name__ == '__main__':
    usage = '%prog [--sign] [-k|--key <API_KEY>] [-s|--secret <SECRET>] '\
            '[-b|--body <BODY>] <URL>'
    parser = optparse.OptionParser(usage=usage)
    parser.add_option('-k', '--key', dest='key', metavar='API_KEY',
                      help='Required')
    parser.add_option('-s', '--secret', dest='secret', metavar='SECRET',
                      help='Required')
    parser.add_option('-b', '--body', dest='body', default='', metavar='BODY',
                      help='If specified, a POST request will be '
                           'performed with BODY as the request body.')
    parser.add_option('--sign', action='store_true', dest='sign',
                      help='Generates a signed request URL. Does not perform '
                           'the request.')
    options, args = parser.parse_args()

    key = options.key
    secret = options.secret
    body = options.body

    if len(args) < 1 or key is None or secret is None:
        parser.print_help()
        sys.exit(1)

    url = args[0]

    request = build_request(url, key, secret, body)

    print '\n', urllib2.unquote(request.to_url()), '\n'

    if not options.sign:
        __perform_api_request(request)

########NEW FILE########
__FILENAME__ = apikeygen
#!/usr/bin/env python
# coding: utf-8


import sys
sys.path.insert(0, ".")
sys.path.insert(0, "..")

import optparse
import random
import string

from pokernetwork import apiserver, pokerdatabase, pokernetworkconfig

API_KEY_LENGTH = 50
API_SECRET_LENGTH = 50
ALPHABET = string.ascii_uppercase + string.ascii_lowercase + string.digits


def _generate_random_string(length, alphabet):
    return ''.join(random.choice(alphabet) for x in range(length))


def _load_config(configpath):
    config = pokernetworkconfig.Config([''])
    config.load(configpath)
    if not config.header:
        raise RuntimeError('Could not load config: %s' % configpath)
    return config


def generate_key_secret_pair():
    key = _generate_random_string(API_KEY_LENGTH, ALPHABET)
    secret = _generate_random_string(API_SECRET_LENGTH, ALPHABET)
    return key, secret


if __name__ == '__main__':
    usage = """%prog [OPTIONS] EMAIL SERVER_CONFIG
    Generates an API key and secret for a given user EMAIL, and saves the result
    to the pokerserver database as specified in SERVER_CONFIG"""
    parser = optparse.OptionParser(usage=usage)
    options, args = parser.parse_args()
    try:
        email = args[0]
        configpath = args[1]
    except Exception, e:
        parser.print_help()
        sys.exit(1)

    config = _load_config(configpath)
    db = pokerdatabase.PokerDatabase(config)

    api_user_store = apiserver.APIUserStore(db)

    key, secret = generate_key_secret_pair()
    api_user_store.add_user(email, key, secret)

    print """\
    The following API user has been added:

    email: %s
    key: %s
    secret: %s

    Please store this information in a safe location.""" % (email, key, secret)

########NEW FILE########
__FILENAME__ = apiserver
#!/usr/bin/env python
# coding: utf-8

from contextlib import closing
from functools import wraps
import json
import warnings

import oauth2

from twisted.python import log
from twisted.web import http, resource


class APIUserStore(object):
    SCHEMA = """CREATE TABLE IF NOT EXISTS `api_users` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `email` varchar(255) NOT NULL,
      `api_key` varchar(255) NOT NULL,
      `secret` varchar(255) NOT NULL,
      PRIMARY KEY (`id`),
      UNIQUE KEY `key_secret` (`api_key`,`secret`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;"""

    def __init__(self, db):
        self.db = db
        self.__create_table_if_not_exists()

    def __create_table_if_not_exists(self):
        with closing(self.db.cursor()) as cursor:
            # MySQLdb raises a warning when api_users already exists:
            # "Warning: Table 'api_users' already exists
            # cursor.execute(self.SCHEMA)"
            with warnings.catch_warnings():
                warnings.filterwarnings('ignore', "Table '\w+' already exists")
                cursor.execute(self.SCHEMA)
                self.db.commit()

    def get_secret(self, api_key):
        """
        Returns the secret corresponding to `key` or None if `key` is not found.
        """
        with closing(self.db.cursor()) as cursor:
            cursor.execute('SELECT secret FROM api_users WHERE api_key=%s',
                           (api_key,))
            row = cursor.fetchone()
            if row:
                return row[0]
            return None

    def get_users(self):
        """
        Returns a list of dictionaries containing the following keys: id,
        email, key, secret.
        """
        with closing(self.db.cursor()) as cursor:
            cursor.execute('SELECT id, email, api_key, secret FROM api_users')
            return cursor.fetchall()

    def add_user(self, email, api_key, secret):
        with closing(self.db.cursor()) as cursor:
            cursor.execute('INSERT INTO api_users (email, api_key, secret) '
                           'VALUES (%s, %s, %s)', (email, api_key, secret))
            self.db.commit()

    def remove_users_by_email(self, email):
        with closing(self.db.cursor()) as cursor:
            cursor.execute('DELETE FROM api_users WHERE email=%s', (email,))
            self.db.commit()

    def remove_user_by_key(self, api_key):
        with closing(self.db.cursor()) as cursor:
            cursor.execute('DELETE FROM api_users WHERE api_key=%s',
                           (api_key,))
            self.db.commit()


def _JSON_response(request, status_code=http.OK, response_dict={}):
    request.setResponseCode(status_code)
    result_string = json.dumps(response_dict, separators=(',', ':'))
    request.setHeader('Content-Type', 'application/json; charset=UTF-8')
    request.setHeader('Cache-Control', 'no-store')
    request.setHeader('Pragma', 'no-cache')
    return result_string


class OAuthResource(resource.Resource):
    """
    Represents a 2-legged OAuth 1.0 protected Resource. When using 2-legged
    OAuth, you do not need to provide an OAuth access token to access
    a resource.

    Each request must be properly signed using the `HMAC-SHA1` signature method.

    See the OAuth 1.0 Protocol spec: http://tools.ietf.org/html/rfc5849
    """
    oauth_server = oauth2.Server(
        signature_methods={'HMAC-SHA1': oauth2.SignatureMethod_HMAC_SHA1()})


    def __init__(self, secret_store):
        resource.Resource.__init__(self)
        self.secret_store = secret_store

    def _validate_request(self, request):
        """
        Validates a 2-legged OAuth 1.0 twisted.web.http.Request object.

        Parameters are accepeted as GET/POST arguments, or in the Authorization
        header.
        """
        url = str(request.URLPath())
        headers = dict(request.requestHeaders.getAllRawHeaders())

        args = {}
        for key, values in request.args.iteritems():
            if len(values) > 1:
                # error: argument keys cannot be repeated!
                raise KeyError('request argument %s cannot be repeated' % key)
            args[key] = values[0]

        oauth_request = oauth2.Request.from_request(request.method, url,
                                                    headers=headers,
                                                    parameters=args)

        key = args['oauth_consumer_key']
        secret = self.secret_store.get_secret(key)
        if secret is None:
            raise oauth2.Error('Invalid Consumer Key')

        consumer = oauth2.Consumer(key=key, secret=secret)
        self.oauth_server.verify_request(oauth_request, consumer, None)

    def _oauth_protect(render_method):
        """Decorates this Resource's render method to protect against
        unauthorized access."""
        @wraps(render_method)
        def wrapper(self, request):
            try:
                self._validate_request(request)
                return render_method(self, request)
            except (oauth2.MissingSignature, ValueError, KeyError):
                status = http.BAD_REQUEST
                return _JSON_response(request, status, {'error': 'bad_request'})
            except oauth2.Error:
                status = http.UNAUTHORIZED
                return _JSON_response(request, status, {'error':
                                                        'unauthorized'})
            except:
                log.err()
                status = http.INTERNAL_SERVER_ERROR
                return _JSON_response(request, status,
                                      {'error': 'internal_server_error'})
        return wrapper

    @_oauth_protect
    def render(self, request):
        """Render code used from
        http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.0.0/twisted/web/resource.py
        """
        m = getattr(self, 'render_' + request.method, None)
        if not m:
            allowedMethods = (getattr(self, 'allowedMethods', 0) or
                              resource._computeAllowedMethods(self))

            status = http.NOT_ALLOWED
            description = 'Unsupported method. Allowed methods: %s' \
                              % str(allowedMethods)
            json = {'error': 'method_not_allowed',
                    'error_description': description}
            request.setHeader('Allow', ', '.join(allowedMethods))
            return _JSON_response(request, status, json)
        return m(request)


def get_json_request_body(request):
    """
    Deserializes the request's body into a Python object. See the documentation
    for json.loads: http://docs.python.org/library/json.html
    """
    return json.loads(request.content.read())


class RefreshTableConfig(OAuthResource):
    isLeaf = True

    def __init__(self, api_service, secret_store):
        OAuthResource.__init__(self, secret_store)
        self.api_service = api_service

    def render_GET(self, request):
        self.api_service.refresh_table_config()
        return _JSON_response(request)


class BroadcastMessageToPlayerSerial(OAuthResource):
    def __init__(self, player_serial, api_service, secret_store):
        OAuthResource.__init__(self, secret_store)
        self.api_service = api_service
        self.player_serial = player_serial

    def render_POST(self, request):
        json_request_body = get_json_request_body(request)
        message = json_request_body['message']
        success = self.api_service.broadcast_to_player(message,
                                                       self.player_serial)
        if success:
            return _JSON_response(request)
        description = 'Could not broadcast message to player with serial %s'\
                            % self.player_serial
        response = {'error': 'bad_request', 'error_description': description}
        return _JSON_response(request, http.BAD_REQUEST, response)


class BroadcastMessageToPlayer(OAuthResource):
    def __init__(self, api_service, secret_store):
        OAuthResource.__init__(self, secret_store)
        self.api_service = api_service

    def getChild(self, name, request):
        player_serial = int(name)
        return BroadcastMessageToPlayerSerial(player_serial, self.api_service,
                                              self.secret_store)


class BroadcastMessage(OAuthResource):
    def __init__(self, api_service, secret_store):
        OAuthResource.__init__(self, secret_store)
        self.api_service = api_service
        self.putChild('player', BroadcastMessageToPlayer(api_service,
                                                         secret_store))

    def render_POST(self, request):
        json_request_body = get_json_request_body(request)
        message = json_request_body['message']
        self.api_service.broadcast_to_all(message)
        return _JSON_response(request)


class Root(resource.Resource):
    def __init__(self, api_service, secret_store):
        resource.Resource.__init__(self)
        self.putChild('refresh_table_config',
                      RefreshTableConfig(api_service, secret_store))
        self.putChild('broadcast',
                      BroadcastMessage(api_service, secret_store))


########NEW FILE########
__FILENAME__ = apiservice
#!/usr/bin/env python
# coding: utf-8

import pokerpackets


class Error(RuntimeError):
    pass


class APIService(object):
    """A wrapper around pokernetwork.pokerservice.PokerService for
    pokernetwork.apiserver.APIServer to use."""

    def __init__(self, poker_service):
        self.poker_service = poker_service

    def broadcast_to_all(self, message):
        """
        Broadcasts a PacketPokerMessage packet to all clients.
        """
        packet = pokerpackets.PacketPokerMessage(string=message)
        self.poker_service.broadcast_to_all(packet)

    def broadcast_to_player(self, message, player_serial):
        """
        Broadcasts a PacketPokerMessage packet to a specific player.
        """
        packet = pokerpackets.PacketPokerMessage(string=message)
        return self.poker_service.broadcast_to_player(packet, player_serial)

    def get_active_tables(self):
        """Returns a list of pokernetwork.pokertable.PokerTable objects
        corresponding to tables that currently have players seated."""
        active_tables = []
        for _, table in self.poker_service.tables.iteritems():
            if len(table.listPlayers()) > 0:
                active_tables.append(table)
        return active_tables

    def add_table(self, table_settings):
        pass

    def remove_table(self, table_name):
        pass

    def refresh_table_config(self):
        """
        Create/modify/delete tables at runtime, by loading table descriptions
        (XML <table /> nodes) from the server config and table configs.

        Gets table descriptions from the server config and table configs, then
        performs the following algorithm:

            For each active table that has NO seated players:
                - If the table has no associated table description, then delete
                  it.
                - Otherwise, modify the table's attributes to match its
                  associated table description.

            For each table description, d:
                - If a table with name d['name'] is not running on the server,
                  then create it.
        """
        config_tables = {}
        for table in self.poker_service.get_table_descriptions():
            config_tables[table['name']] = table

        active_table_names = set()
        tables_to_delete = []
        for table_id, table in self.poker_service.tables.iteritems():
            table_name = table.game.name
            if len(table.listPlayers()) > 0:
                active_table_names.add(table_name)
            elif table_name not in config_tables:
                tables_to_delete.append(table_id)

        for table_id in tables_to_delete:
            self.poker_service.deleteTable(self.poker_service.tables[table_id])

        for table_name, table_description in config_tables.iteritems():
            if table_name not in active_table_names:
                self.poker_service.createTable(0, table_description)

########NEW FILE########
__FILENAME__ = client
#
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
# 
from twisted.internet import reactor, protocol, error, defer
from struct import pack, unpack

from pokernetwork.packets import *
from pokernetwork.protocol import UGAMEProtocol
from pokernetwork.user import User

class UGAMEClientProtocol(UGAMEProtocol):
    """ """
    def __init__(self):
        self._ping_timer = None
        self.user = User()
        self.bufferized_packets = []
        UGAMEProtocol.__init__(self)
        self._ping_delay = 5
        self.connection_lost_deferred = defer.Deferred()

    def getSerial(self):
        return self.user.serial

    def getName(self):
        return self.user.name

    def getUrl(self):
        return self.user.url

    def getOutfit(self):
        return self.user.outfit

    def isLogged(self):
        return self.user.isLogged()
    
    def sendPacket(self, packet):
        if self.established != 0:
            self.ping()
            if self.factory.verbose > 2:
                self.message("%ssendPacket(%d) %s " % ( self._prefix, self.user.serial, packet ))
            self.dataWrite(packet.pack())
        else:
            if self.factory.verbose > 2:
                self.message("%ssendPacket bufferized %s " % ( self._prefix, packet ))
            self.bufferized_packets.append(packet)

    def ping(self):
        if not hasattr(self, "_ping_timer") or not self._ping_timer:
            return

        if self._ping_timer.active():
            self._ping_timer.reset(self._ping_delay)
        else:
            if self.factory.verbose > 6:
                self.message("%ssend ping" % self._prefix)
            self.dataWrite(PacketPing().pack())
            self._ping_timer = reactor.callLater(self._ping_delay, self.ping)
        
    def protocolEstablished(self):
        self._ping_timer = reactor.callLater(self._ping_delay, self.ping)
        d = self.factory.established_deferred
        self.factory.established_deferred = None
        d.callback(self)
        for packet in self.bufferized_packets:
            self.sendPacket(packet)
        self.bufferized_packets = []
        self.factory.established_deferred = defer.Deferred()

    def protocolInvalid(self, server, client):
        # FIXME: I am not completely sure this method makes sense.  You'll
        # note in ClientServer.test09 in test-clientserver.py.in where I
        # cover this code, it seems that 'server' and 'client' arguments
        # are something different entirely.  This is because the code that
        # calls protocolInvalid() in protocol.connectionLost() and
        # protocol._handleVersion() send strings as 'server' and 'client'.
        # The test assumes this is the case, but I think someone should
        # reexamine this code at some point and make sure it is doing what
        # we really expect. -- bkuhn, 2008-10-13
        if not self.factory.established_deferred.called:
            self.factory.established_deferred.errback((self, server, client),)
            
    def connectionLost(self, reason):
        if hasattr(self, "_ping_timer") and self._ping_timer and self._ping_timer.active():
            self._ping_timer.cancel()
        self._ping_timer = None
        self.factory.protocol_instance = None
        UGAMEProtocol.connectionLost(self, reason)
        if not reason.check(error.ConnectionDone) and self.factory.verbose > 3:
            self.message("UGAMEClient.connectionLost %s" % reason)
        d = self.connection_lost_deferred
        self.connection_lost_deferred = None
        d.callback(self)
        self.connection_lost_deferred = defer.Deferred()

class UGAMEClientFactory(protocol.ClientFactory):

    def __init__(self, *args, **kwargs):
        self.protocol = UGAMEClientProtocol
        self.protocol_instance = None
        self.verbose = 0
        self.established_deferred = defer.Deferred()

    def error(self, string):
        self.message("ERROR " + string)
        
    def message(self, string):
        print string
        
    def buildProtocol(self, addr):
        instance = self.protocol()
        instance.factory = self
        self.protocol_instance = instance
        return instance

    def clientConnectionLost(self, connector, reason):
        pass

########NEW FILE########
__FILENAME__ = currencyclient
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2006             Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
from types import *
from twisted.web import client
from twisted.internet import defer, reactor

class RealCurrencyClient:

    def __init__(self):
        self.verbose = 0
        self.getPage = client.getPage

    def request(self, *args, **kwargs):
        base = kwargs['url']
        if "?" in base:
            base += '&'
        else:
            base += '?'
            
        args = [ base + "command=" + kwargs.get('command', 'get_note') ]
        for key in ('name', 'serial', 'value', 'transaction_id'):
            if kwargs.has_key(key): 
                arg = kwargs[key]
                args.append("%s=%s" % ( key, arg ))

        if kwargs.has_key('notes'):
            index = 0
            for (url, serial, name, value) in kwargs['notes']:
                args.append("name[%d]=%s" % ( index, name ) )
                args.append("serial[%d]=%s" % ( index, serial ) )
                args.append("value[%d]=%s" % ( index, value ) )
                index += 1
                
        if kwargs.has_key('note'):
            (url, serial, name, value) = kwargs['note']
            args.append("name=%s" % name )
            args.append("serial=%s" % serial )
            args.append("value=%s" % value )
                
        if kwargs.has_key('values'):
            index = 0
            for value in kwargs['values']:
                args.append("values[%d]=%d" % ( index, value ))
                index += 1
        url = "&".join(args)
        #print "RealCurrencyClient: " + url
        return self.getPage(url)

    def parseResultNote(self, result):
	has_error = False
        notes = []
        for line in result.split("\n"):
            note = line.split("\t")
            if len(note) == 4:
                notes.append(( note[0], int(note[1]), note[2], int(note[3]) ),)
            else:
                print "RealCurrencyClient::parseResultNote ignore line: " + line
		has_error = True
	if has_error:
		raise Exception("expected notes got something else")
        return notes

    def mergeNotes(self, *args):
        deferred = self.request(url = args[0][0], command = 'merge_notes', notes = args)
        deferred.addCallback(self.parseResultNote)
        return deferred

    def meltNotes(self, *notes):
        values = sum(map(lambda note: note[3], notes))
        deferred = self.request(url = notes[0][0], command = 'merge_notes', notes = notes, values = [ values ])
        deferred.addCallback(self.parseResultNote)
        return deferred

    def changeNote(self, note):
        deferred = self.request(url = note[0], command = 'change_note', note = note)
        deferred.addCallback(self.parseResultNote)
        return deferred

    def getNote(self, url, value):
        deferred = self.request(url = url, command = 'get_note', value = value)
        deferred.addCallback(self.parseResultNote)
        return deferred

    def checkNote(self, note):
        deferred = self.request(url = note[0], command = 'check_note', note = note)
        deferred.addCallback(self.parseResultNote)
        return deferred

    def breakNote(self, note, *values):
        deferred = False
        if len(values) == 2:
            numeric_values = map(int, values)
            numeric_values.sort()
            if numeric_values[0] == 0:
                notes = [ note, [ note[0], 0, '', 0 ] ]
                deferred = defer.Deferred()
                reactor.callLater(0, lambda: deferred.callback(notes))
        if not deferred:
            deferred = self.request(url = note[0], command = 'break_note', note = note, values = values)
            deferred.addCallback(self.parseResultNote)
        return deferred

    def commit(self, url, transaction_id):
	def validate(result):
            if self.verbose > 2: print "CurrencyClient::commit " + str(result)
            if len(result.split("\n")) > 1:
                raise Exception("expected a single line got " + str(result) + " instead")
            return result
        deferred = self.request(url = url, command = 'commit', transaction_id = transaction_id)
	deferred.addCallback(validate)
	return deferred
        
from twisted.python import failure
from twisted.web import error

CurrencyClient = RealCurrencyClient

FakeCurrencyFailure = False

Verbose = False

class FakeCurrencyClient:

    def __init__(self):
        self.serial = 1
        self.check_note_result = True
        self.commit_result = True
        
    def message(self, string):
        print "FakeCurrencyClient: " + string
        
    def breakNote(self, (url, serial, name, value), *values):
        if Verbose: self.message("breakNote vaues %s" % str(values))
        if values: 
            values = map(int, values)
            values.sort()
            values.reverse()

        notes = []
        if values[-1] == 0:
            notes.append((url, serial, name, value))
            notes.append((url, 0, '', 0))
        else:
            for note_value in values:
                if value < note_value: continue
                count = value / note_value
                value %= note_value
                for i in xrange(count):
                    notes.append((url, self.serial, "%040d" % self.serial, note_value))
                    self.serial += 1
                if value <= 0: break
            if value > 0:
                notes.append((url, self.serial, "%040d" % self.serial, note_value))
                self.serial += 1
        d = defer.Deferred()
        if FakeCurrencyFailure:
            reactor.callLater(0, lambda: d.errback(failure.Failure(error.Error(500, "breakNote: fake error", "(page content)"))))
        else:
            reactor.callLater(0, lambda: d.callback(notes))
        return d

    def mergeNotes(self, *notes):
        if Verbose: self.message("mergeNotes")
        self.serial += 1
        result = list(notes[0])
        result[1] = self.serial
        result[2] = "%040d" % self.serial
        result[3] = sum(map(lambda x: x[3], notes))
        d = defer.Deferred()
        reactor.callLater(0, lambda: d.callback([result]))
        return d

    meltNotes = mergeNotes

    def changeNote(self, note):
        if Verbose: self.message("changeNote")
        self.serial += 1
        result = note.copy()
        result[1] = self.serial
        result[2] = "%040d" % self.serial
        d = defer.Deferred()
        reactor.callLater(0, lambda: d.callback(result))
        return d

    def _buildNote(self, url, value):
        if Verbose: self.message("_buildNote")
        self.serial += 1
        name = "%040d" % self.serial
        return ( url, self.serial, name, value )

    def getNote(self, url, value):
        if Verbose: self.message("getNote")
        note = self._buildNote(url, value)
        d = defer.Deferred()
        reactor.callLater(0, lambda: d.callback(note))
        return d

    def checkNote(self, note):
        if Verbose: self.message("checkNote")
        if self.check_note_result:
            result = note
        else:
            result = failure.Failure()
        d = defer.Deferred()
        reactor.callLater(0, lambda: d.callback(result))
        return d

    def commit(self, url, transaction_id):
        if Verbose: self.message("commit")
        if self.commit_result:
            result = "OK"
        else:
            result = failure.Failure()
        d = defer.Deferred()
        reactor.callLater(0, lambda: d.callback(result))
        return d


########NEW FILE########
__FILENAME__ = nullfilter
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

#
# return a value if all actions were complete
#
def rest_filter(site, request, packet):
    return True

#
# return a deferred if there is a pending action
#

#from twisted.internet import defer

#def rest_filter(site, request, packet):
#    return defer.Deferred()

########NEW FILE########
__FILENAME__ = OLDpokerclientpackets
#
# HISTORICAL FILE FOR BACKWARD COMPATIBILITY
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
from pokernetwork.pokerpackets import *

PacketNames = {}
PacketFactory = {}

def chips2amount(chips):
    amount = 0
    for i in xrange(len(chips) / 2):
        amount += chips[i*2] * chips[i*2 + 1]
    return amount

########################################

PACKET_POKER_BEST_CARDS = 170 # 0xaa # %SEQ%
PacketNames[PACKET_POKER_BEST_CARDS] = "POKER_BEST_CARDS"

class PacketPokerBestCards(PacketPokerCards):
    """\
Semantics: ordered list  of five "bestcards" hand for
player "serial" in game "game_id" that won the "side"
side of the pot. The "board", if not empty, is the list
of community cards at showdown. Also provides the
"cards" of the player.

Direction: client <=> client

cards: list of integers describing the player cards:

       2h/00  2d/13  2c/26  2s/39
       3h/01  3d/14  3c/27  3s/40
       4h/02  4d/15  4c/28  4s/41
       5h/03  5d/16  5c/29  5s/42
       6h/04  6d/17  6c/30  6s/43
       7h/05  7d/18  7c/31  7s/44
       8h/06  8d/19  8c/32  8s/45
       9h/07  9d/20  9c/33  9s/46
       Th/08  Td/21  Tc/34  Ts/47
       Jh/09  Jd/22  Jc/35  Js/48
       Qh/10  Qd/23  Qc/36  Qs/49
       Kh/11  Kd/24  Kc/37  Ks/50
       Ah/12  Ad/25  Ac/38  As/51
       
bestcards: list of integers describing the winning combination cards:
board: list of integers describing the community cards:
hand: readable string of the name best hand
besthand: 0 if it's not the best hand and 1 if it's the best hand
         best hand is the hand that win the most money
       
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_BEST_CARDS

    def __init__(self, *args, **kwargs):
        self.side = kwargs.get("side", "")
        self.hand = kwargs.get("hand", "")
        self.bestcards = kwargs.get("bestcards", [])
        self.board = kwargs.get("board", [])
        self.besthand = kwargs.get("besthand", 0)
        PacketPokerCards.__init__(self, *args, **kwargs)
        
    def __str__(self):
        return PacketPokerCards.__str__(self) + " side = %s, hand = %s, bestcards = %s, board = %s , besthand %s" % ( self.side, self.hand, str(self.bestcards), str(self.board), str(self.besthand) )

PacketFactory[PACKET_POKER_BEST_CARDS] = PacketPokerBestCards

########################################

PACKET_POKER_POT_CHIPS = 171 # 0xab # %SEQ%
PacketNames[PACKET_POKER_POT_CHIPS] = "POKER_POT_CHIPS"

class PacketPokerPotChips(Packet):
    """\
Semantics: the "bet" put in the "index" pot of the "game_id" game.

Direction: client <=> client

Context: this packet is sent at least each time the pot "index" is
updated.

bet: list of pairs ( chip_value, chip_count ).
index: integer uniquely identifying a side pot in the range [0,10[
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_POT_CHIPS

    def __init__(self, **kwargs):
        self.game_id = kwargs.get("game_id", 0)
        self.index = kwargs.get("index", 0)
        self.bet = kwargs.get("bet", [])

    def __str__(self):
        return Packet.__str__(self) + " game_id = %d, pot = %s, index = %d" % ( self.game_id, self.bet, self.index )

PacketFactory[PACKET_POKER_POT_CHIPS] = PacketPokerPotChips

########################################

PACKET_POKER_CLIENT_ACTION = 172 # 0xac # %SEQ%
PacketNames[PACKET_POKER_CLIENT_ACTION] = "POKER_CLIENT_ACTION"

class PacketPokerClientAction(PacketPokerId):
    """

    The action available/not available to the player
    
    """

    type = PACKET_POKER_CLIENT_ACTION

    format = "!B"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.display = kwargs.get("display",0)
        self.action = kwargs.get("action","")
        PacketPokerId.__init__(self, *args, **kwargs)
        
    def pack(self):
        return PacketPokerId.pack(self) + pack(PacketPokerClientAction.format, self.display) + self.packstring(self.action)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.display,) = unpack(PacketPokerClientAction.format, block[:PacketPokerClientAction.format_size])
        block = block[PacketPokerClientAction.format_size:]
        (block, self.action) = self.unpackstring(block)
        return block

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerClientAction.format_size + self.calcsizestring(self.action)

    def __str__(self):
        return PacketPokerId.__str__(self) + " display = %d, action = %s" % ( self.display, self.action )

PacketFactory[PACKET_POKER_CLIENT_ACTION] = PacketPokerClientAction

########################################

PACKET_POKER_BET_LIMIT = 173 # 0xad # %SEQ%
PacketNames[PACKET_POKER_BET_LIMIT] = "POKER_BET_LIMIT"

class PacketPokerBetLimit(PacketPokerId):
    """\
Semantics: a raise must be at least "min" and most "max".
A call means wagering an amount of "call". The suggested
step to slide between "min" and "max" is "step". The step
is guaranteed to be an integral divisor of "call". The
player would be allin for the amount "allin". The player
would match the pot if betting "pot".

Context: this packet is issued each time a position change
occurs.

Direction: client <=> client

min: the minimum amount of a raise.
max: the maximum amount of a raise.
step: a hint for sliding in the [min, max] interval.
call: the amount of a call.
allin: the amount for which the player goes allin.
pot: the amount in the pot.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_BET_LIMIT

    format = "!IIIIII"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.min = kwargs.get("min",0)
        self.max = kwargs.get("max",0)
        self.step = kwargs.get("step",0)
        self.call = kwargs.get("call",0)
        self.allin = kwargs.get("allin",0)
        self.pot = kwargs.get("pot",0)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + pack(PacketPokerBetLimit.format, self.min, self.max, self.step, self.call, self.allin, self.pot)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.min, self.max, self.step, self.call, self.allin, self.pot) = unpack(PacketPokerBetLimit.format, block[:PacketPokerBetLimit.format_size])
        return block[PacketPokerBetLimit.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerBetLimit.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + " min = %d, max = %d, step = %s, call = %s, allin = %s, pot = %s" % (self.min, self.max, self.step, self.call, self.allin, self.pot)

PacketFactory[PACKET_POKER_BET_LIMIT] = PacketPokerBetLimit

########################################

PACKET_POKER_SIT_REQUEST = 174 # 0xae # %SEQ%
PacketNames[PACKET_POKER_SIT_REQUEST] = "POKER_SIT_REQUEST"

class PacketPokerSitRequest(PacketPokerSit):

    type = PACKET_POKER_SIT_REQUEST

PacketFactory[PACKET_POKER_SIT_REQUEST] = PacketPokerSitRequest

########################################

PACKET_POKER_PLAYER_NO_CARDS = 175 # 0xaf # %SEQ%
PacketNames[PACKET_POKER_PLAYER_NO_CARDS] = "POKER_PLAYER_NO_CARDS"

class PacketPokerPlayerNoCards(PacketPokerId):
    """\
Semantics: the player "serial" has no cards in game "game_id".

Direction: client <=> client

Context: inferred at showdown.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""
    
    type = PACKET_POKER_PLAYER_NO_CARDS

PacketFactory[PACKET_POKER_PLAYER_NO_CARDS] = PacketPokerPlayerNoCards

######################################## 

PACKET_POKER_CHIPS_PLAYER2BET = 176 # 0xb0 # %SEQ%
PacketNames[PACKET_POKER_CHIPS_PLAYER2BET] = "POKER_CHIPS_PLAYER2BET"

class PacketPokerChipsPlayer2Bet(PacketPokerId):
    """\
Semantics: move "chips" from the player "serial" money chip stack
to the bet chip stack.

Direction: client <=> client

chips: 
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_CHIPS_PLAYER2BET

    def __init__(self, *args, **kwargs):
        PacketPokerId.__init__(self, *args, **kwargs)
        self.chips = kwargs.get("chips", [])
        
    def __str__(self):
        return PacketPokerId.__str__(self) + " chips = %s" % ( self.chips )

PacketFactory[PACKET_POKER_CHIPS_PLAYER2BET] = PacketPokerChipsPlayer2Bet

######################################## 

PACKET_POKER_CHIPS_BET2POT = 177 # 0xb1 # %SEQ%
PacketNames[PACKET_POKER_CHIPS_BET2POT] = "POKER_CHIPS_BET2POT"

class PacketPokerChipsBet2Pot(PacketPokerId):
    """\
Semantics: move "chips" from the player "serial" bet chip stack
to the "pot" pot.

Direction: client <=> client

Context: the pot index is by definition in the range [0,9] because
it starts at 0 and because there cannot be more pots than players.
The creation of side pots is inferred by the client when a player
is all-in and it is guaranteed that pots are numbered sequentially.

pot: the pot index in the range [0,9].
chips: list of integers counting the number of chips to move.
     The value of each chip is, respectively:
     1 2 5 10 20 25 50 100 250 500 1000 2000 5000.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_CHIPS_BET2POT

    def __init__(self, *args, **kwargs):
        PacketPokerId.__init__(self, *args, **kwargs)
        self.chips = kwargs.get("chips", [])
        self.pot = kwargs.get("pot", -1)
        
    def __str__(self):
        return PacketPokerId.__str__(self) + " chips = %s, pot = %d" % ( self.chips, self.pot )
    
PacketFactory[PACKET_POKER_CHIPS_BET2POT] = PacketPokerChipsBet2Pot

######################################## Display packet

PACKET_POKER_CHIPS_POT2PLAYER = 178 # 0xb2 # %SEQ%
PacketNames[PACKET_POKER_CHIPS_POT2PLAYER] = "POKER_CHIPS_POT2PLAYER"

class PacketPokerChipsPot2Player(PacketPokerId):
    """\
Semantics: move "chips" from the pot "pot" to the player "serial"
money chip stack. The string "reason" explains why these chips 
are granted to the player. If reason is "win", it means the player
won the chips either because all other players folded or because
he had the best hand at showdown. If reason is "uncalled", it means
the chips are returned to him because no other player was will or
able to call his wager. If reason is "left-over", it means the chips
are granted to him because there was an odd chip while splitting the pot.

Direction: client <=> client

Context: the pot index is by definition in the range [0,9] because
it starts at 0 and because there cannot be more pots than players.
The creation of side pots is inferred by the client when a player
is all-in and it is guaranteed that pots are numbered sequentially.

reason: may be one of "win", "uncalled", "left-over"
pot: the pot index in the range [0,9].
chips: list of integers counting the number of chips to move.
     The value of each chip is, respectively:
     1 2 5 10 20 25 50 100 250 500 1000 2000 5000.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_CHIPS_POT2PLAYER

    def __init__(self, *args, **kwargs):
        PacketPokerId.__init__(self, *args, **kwargs)
        self.chips = kwargs.get("chips", [])
        self.pot = kwargs.get("pot", -1)
        self.reason = kwargs.get("reason", "")
        
    def __str__(self):
        return PacketPokerId.__str__(self) + " chips = %s, pot = %d, reason = %s" % ( self.chips, self.pot, self.reason )
    
PacketFactory[PACKET_POKER_CHIPS_POT2PLAYER] = PacketPokerChipsPot2Player

######################################## Display packet

PACKET_POKER_CHIPS_POT_MERGE = 179 # 0xb3 # %SEQ%
PacketNames[PACKET_POKER_CHIPS_POT_MERGE] = "POKER_CHIPS_POT_MERGE"

class PacketPokerChipsPotMerge(PacketPokerId):
    """\
Semantics: merge the pots whose indexes are listed in
"sources" into a single pot at index "destination" in game "game_id".

Direction: client <=> client

Context: when generating PACKET_POKER_CHIPS_POT2PLAYER packets, if
multiple packet can be avoided by merging pots (e.g. when one player
wins all the pots).

destination: a pot index in the range [0,9].
sources: list of pot indexes in the range [0,9].
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_CHIPS_POT_MERGE

    def __init__(self, *args, **kwargs):
        PacketPokerId.__init__(self, *args, **kwargs)
        self.sources = kwargs.get("sources", [])
        self.destination = kwargs.get("destination", 0)
        
    def __str__(self):
        return PacketPokerId.__str__(self) + " sources = %s, destination = %d" % ( self.sources, self.destination )

PacketFactory[PACKET_POKER_CHIPS_POT_MERGE] = PacketPokerChipsPotMerge

######################################## Display packet

PACKET_POKER_CHIPS_POT_RESET = 180 # 0xb4 # %SEQ%
PacketNames[PACKET_POKER_CHIPS_POT_RESET] = "POKER_CHIPS_POT_RESET"

class PacketPokerChipsPotReset(PacketPokerId):
    """\
Semantics: all pots for game "game_id" are set to zero.

Direction: client <=> client

Context: it is inferred after a PACKET_POKER_TABLE or a
 PACKET_POKER_START packet is sent by the server. It is inferred
after the pot is distributed (i.e. after the game terminates
because a PACKET_POKER_WIN or PACKET_POKER_CANCELED is received).

game_id: integer uniquely identifying a game.
"""
    
    type = PACKET_POKER_CHIPS_POT_RESET

PacketFactory[PACKET_POKER_CHIPS_POT_RESET] = PacketPokerChipsPotReset

######################################## Display packet

PACKET_POKER_CHIPS_BET2PLAYER = 181 # 0xb5 # %SEQ%
PacketNames[PACKET_POKER_CHIPS_BET2PLAYER] = "POKER_CHIPS_BET2PLAYER"

class PacketPokerChipsBet2player(PacketPokerChipsPlayer2Bet):
    """chips move from bet to player"""

    type = PACKET_POKER_CHIPS_BET2PLAYER

PacketFactory[PACKET_POKER_CHIPS_BET2PLAYER] = PacketPokerChipsBet2player

######################################## Display packet

PACKET_POKER_END_ROUND = 182 # 0xb6 # %SEQ%
PacketNames[PACKET_POKER_END_ROUND] = "POKER_END_ROUND"

class PacketPokerEndRound(PacketPokerId):
    """\
Semantics: closes a betting round for game "game_id".

Direction: client <=> client

Context: inferred at the end of a sequence of packet related to
a betting round. Paying the blind / ante is not considered a
betting round. This packet is sent when the client side
knows that the round is finished but before the corresponding
packet (PACKET_POKER_STATE) has been received from the server.
It will be followed by the POKER_BEGIN_ROUND packet, either
immediatly if the server has no delay between betting rounds
or later if the server waits a few seconds between two betting
rounds.
It is not inferred at the end of the last betting round.

game_id: integer uniquely identifying a game.
"""
    
    type = PACKET_POKER_END_ROUND

PacketFactory[PACKET_POKER_END_ROUND] = PacketPokerEndRound

########################################

PACKET_POKER_DISPLAY_NODE = 183 # 0xb7 # %SEQ%
PacketNames[PACKET_POKER_DISPLAY_NODE] = "POKER_DISPLAY_NODE"

class PacketPokerDisplayNode(Packet):
    """request POKER_DISPLAY_NODE packet"""
    
    type = PACKET_POKER_DISPLAY_NODE

    def __init__(self, **kwargs):
        self.game_id = kwargs.get("game_id", 0)
        self.name = kwargs.get("name", "")
        self.state = kwargs.get("state", 0)
        self.style = kwargs.get("style", "")
        self.selection = kwargs.get("selection", None)

    def __str__(self):
        return Packet.__str__(self) + "game_id = %s, name = %s, state = %d, style = %s, selection = %s " % ( str(self.game_id), self.name, self.state, self.style, self.selection )

PacketFactory[PACKET_POKER_DISPLAY_NODE] = PacketPokerDisplayNode

######################################## Display packet

PACKET_POKER_DEAL_CARDS = 184 # 0xb8 # %SEQ%
PacketNames[PACKET_POKER_DEAL_CARDS] = "POKER_DEAL_CARDS"

class PacketPokerDealCards(PacketPokerId):
    """\
Semantics: deal "numberOfCards" down cards for each player listed
in "serials" in game "game_id".

Direction: client <=> client

Context: inferred after the beginning of a betting round (i.e.
after the PACKET_POKER_STATE packet is received) and after
the chips involved in the previous betting round have been
sorted (i.e. after PACKET_POKER_CHIPS_BET2POT packets are
inferred). Contrary to the PACKET_POKER_PLAYER_CARDS,
this packet is only sent if cards must be dealt. It
is guaranteed that this packet will always occur before
the PACKET_POKER_PLAYER_CARDS that specify the cards to
be dealt and that these packets will follow immediately
after it (no other packet will be inserted between this packet
and the first PACKET_POKER_PLAYER_CARDS). It is also guaranteed
that exactly one PACKET_POKER_PLAYER_CARDS will occur for each
serial listed in "serials".

numberOfCards: number of cards to be dealt.
serials: integers uniquely identifying players.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_DEAL_CARDS
    numberOfCards = 0
    serials = []

    def __init__(self, *args, **kwargs):
        self.numberOfCards = kwargs.get("numberOfCards", 2)
        self.serials = kwargs.get("serials", [])
        PacketPokerId.__init__(self, *args, **kwargs)

    def __str__(self):
        return PacketPokerId.__str__(self) + " number of cards = %d, serials = %s" % ( self.numberOfCards, self.serials )

PacketFactory[PACKET_POKER_DEAL_CARDS] = PacketPokerDealCards

########################################

PACKET_POKER_CHAT_HISTORY = 185 # 0xb9 # %SEQ%
PacketNames[PACKET_POKER_CHAT_HISTORY] = "POKER_CHAT_HISTORY"

class PacketPokerChatHistory(Packet):
    """chat history show"""

    type = PACKET_POKER_CHAT_HISTORY

    def __init__(self, **kwargs):
        self.show = kwargs.get("show", "no")

PacketFactory[PACKET_POKER_CHAT_HISTORY] = PacketPokerChatHistory


########################################

PACKET_POKER_DISPLAY_CARD = 186 # 0xba # %SEQ%
PacketNames[PACKET_POKER_DISPLAY_CARD] = "POKER_DISPLAY_CARD"

class PacketPokerDisplayCard(PacketPokerId):
    """Hide a player card"""

    type = PACKET_POKER_DISPLAY_CARD
    index = []
    display = 0

    def __init__(self, *args, **kwargs):
        PacketPokerId.__init__(self, *args, **kwargs)
        self.index = kwargs.get("index", [] )
        self.display = kwargs.get("display", 0 )

PacketFactory[PACKET_POKER_DISPLAY_CARD] = PacketPokerDisplayCard

########################################

PACKET_POKER_SELF_IN_POSITION = 187 # 0xbb # %SEQ%
PacketNames[PACKET_POKER_SELF_IN_POSITION] = "POKER_SELF_IN_POSITION"

class PacketPokerSelfInPosition(PacketPokerPosition):
    """\
Semantics: the player authenticated for this connection
is in position. Otherwise identical to PACKET_POKER_POSITION.

"""

    type = PACKET_POKER_SELF_IN_POSITION

PacketFactory[PACKET_POKER_SELF_IN_POSITION] = PacketPokerSelfInPosition

########################################

PACKET_POKER_SELF_LOST_POSITION = 188 # 0xbc # %SEQ%
PacketNames[PACKET_POKER_SELF_LOST_POSITION] = "POKER_SELF_LOST_POSITION"

class PacketPokerSelfLostPosition(PacketPokerPosition):
    """\
Semantics: the player authenticated for this connection
is in position. Otherwise identical to PACKET_POKER_POSITION.

"""

    type = PACKET_POKER_SELF_LOST_POSITION

PacketFactory[PACKET_POKER_SELF_LOST_POSITION] = PacketPokerSelfLostPosition

########################################

PACKET_POKER_HIGHEST_BET_INCREASE = 189 # 0xbd # %SEQ%
PacketNames[PACKET_POKER_HIGHEST_BET_INCREASE] = "POKER_HIGHEST_BET_INCREASE"

class PacketPokerHighestBetIncrease(PacketPokerId):
    """\
Semantics: a wager was made in game "game_id" that increases
the highest bet amount. 

Direction: client <=> client

Context: inferred whenever a wager is made that changes
the highest bet (live blinds are considered a wager, antes are not).
Inferred once per blindAnte round: when the
first big blind is posted. It is therefore guaranteed not to be posted
if a game is canceled because noone wanted to pay the big blind, even
if someone already posted the small blind. In all other betting rounds it
is inferred for each raise.

game_id: integer uniquely identifying a game.
"""
    
    type = PACKET_POKER_HIGHEST_BET_INCREASE

PacketFactory[PACKET_POKER_HIGHEST_BET_INCREASE] = PacketPokerHighestBetIncrease

########################################

PACKET_POKER_PLAYER_WIN = 190 # 0xbe # %SEQ%
PacketNames[PACKET_POKER_PLAYER_WIN] = "POKER_PLAYER_WIN"

class PacketPokerPlayerWin(PacketPokerId):
    """\
Semantics: the player "serial" win.

Direction: client <=> client

Context: when a PacketPokerWin arrive from server. The packet is generated
from PACKET_PLAYER_WIN. For each player that wins something a packet
PlayerWin is generated.

serial: integer uniquely identifying a player.
"""
    type = PACKET_POKER_PLAYER_WIN

PacketFactory[PACKET_POKER_PLAYER_WIN] = PacketPokerPlayerWin

########################################
PACKET_POKER_ANIMATION_PLAYER_NOISE = 191 # 0xbf # %SEQ%
PacketNames[PACKET_POKER_ANIMATION_PLAYER_NOISE] = "POKER_ANIMATION_PLAYER_NOISE"

class PacketPokerAnimationPlayerNoise(PacketPokerId):
    """\
Semantics: the player "serial" play or stop noise animation.

Direction: client <=> client

Context: a PacketPokerPlayerNoise is send to the client c++ to stop or start
player's noise animation.

serial: integer uniquely identifying a player.
action: string that contain "start" or "stop".
"""
    type = PACKET_POKER_ANIMATION_PLAYER_NOISE

    def __init__(self, *args, **kwargs):
        self.action = kwargs.get("action", 'start')
        PacketPokerId.__init__(self, *args, **kwargs)

    def __str__(self):
        return Packet.__str__(self) + " serial = %d, action = %s" % ( self.serial, self.action )
    
PacketFactory[PACKET_POKER_ANIMATION_PLAYER_NOISE] = PacketPokerAnimationPlayerNoise

########################################

PACKET_POKER_ANIMATION_PLAYER_FOLD = 192 # 0xc0 # %SEQ%
PacketNames[PACKET_POKER_ANIMATION_PLAYER_FOLD] = "POKER_ANIMATION_PLAYER_FOLD"

class PacketPokerAnimationPlayerFold(PacketPokerId):
    """\
Semantics: the player "serial" play an animation fold.

Direction: client <=> client

Context: a PacketPokerPlayerNoise is send to the client c++ to stop or start
player's noise animation.

serial: integer uniquely identifying a player.
animation: string used to select an animation fold.
"""
    type = PACKET_POKER_ANIMATION_PLAYER_FOLD

    def __init__(self, *args, **kwargs):
        self.animation = kwargs.get("animation","UNKNOWN")
        PacketPokerId.__init__(self, *args, **kwargs)

    def __str__(self):
        return PacketPokerId.__str__(self) + " serial = %d, animation fold = %s" % ( self.serial, self.animation )
    
PacketFactory[PACKET_POKER_ANIMATION_PLAYER_FOLD] = PacketPokerAnimationPlayerFold

########################################

PACKET_POKER_ANIMATION_PLAYER_BET = 193 # 0xc1 # %SEQ%
PacketNames[PACKET_POKER_ANIMATION_PLAYER_BET] = "POKER_ANIMATION_PLAYER_BET"

class PacketPokerAnimationPlayerBet(PacketPokerId):
    """\
"""
    type = PACKET_POKER_ANIMATION_PLAYER_BET

    def __init__(self, *args, **kwargs):
        self.animation = kwargs.get("animation", "")
        self.chips = kwargs.get("chips", [])
        self.amount = chips2amount(self.chips)
        PacketPokerId.__init__(self, *args, **kwargs)

    def __str__(self):
        return PacketPokerId.__str__(self) + " serial = %d, chips %s , animation %s" % ( self.serial ,self.animation, self.chips )
    
PacketFactory[PACKET_POKER_ANIMATION_PLAYER_BET] = PacketPokerAnimationPlayerBet

########################################

PACKET_POKER_ANIMATION_PLAYER_CHIPS = 194 # 0xc2 # %SEQ%
PacketNames[PACKET_POKER_ANIMATION_PLAYER_CHIPS] = "POKER_ANIMATION_PLAYER_CHIPS"

class PacketPokerAnimationPlayerChips(PacketPokerId):
    """\
"""
    type = PACKET_POKER_ANIMATION_PLAYER_CHIPS

    def __init__(self, *args, **kwargs):
        self.animation = kwargs.get("animation", "")
        self.chips = kwargs.get("chips", [])
        self.state = kwargs.get("state", "")
        self.amount = chips2amount(self.chips)
        PacketPokerId.__init__(self, *args, **kwargs)

    def __str__(self):
        return PacketPokerId.__str__(self) + " serial = %d, chips %s , animation %s" % ( self.serial ,self.animation, self.chips )
    
PacketFactory[PACKET_POKER_ANIMATION_PLAYER_CHIPS] = PacketPokerAnimationPlayerChips

########################################

PACKET_POKER_ANIMATION_DEALER_CHANGE = 195 # 0xc3 # %SEQ%
PacketNames[PACKET_POKER_ANIMATION_DEALER_CHANGE] = "POKER_ANIMATION_DEALER_CHANGE"

class PacketPokerAnimationDealerChange(PacketPokerId):
    """\
"""
    type = PACKET_POKER_ANIMATION_DEALER_CHANGE

    def __init__(self, *args, **kwargs):
        self.state = kwargs.get("state","UNKNOWN")
        
        PacketPokerId.__init__(self, *args, **kwargs)

    def __str__(self):
        return PacketPokerId.__str__(self) + " serial = %d, state %s" % ( self.serial , self.state )
    
PacketFactory[PACKET_POKER_ANIMATION_DEALER_CHANGE] = PacketPokerAnimationDealerChange

########################################

PACKET_POKER_ANIMATION_DEALER_BUTTON = 196 # 0xc4 # %SEQ%
PacketNames[PACKET_POKER_ANIMATION_DEALER_BUTTON] = "POKER_ANIMATION_DEALER_BUTTON"

class PacketPokerAnimationDealerButton(PacketPokerId):
    """\
"""
    type = PACKET_POKER_ANIMATION_DEALER_BUTTON

    def __init__(self, *args, **kwargs):
        self.state = kwargs.get("state","UNKNOWN")
        
        PacketPokerId.__init__(self, *args, **kwargs)

    def __str__(self):
        return PacketPokerId.__str__(self) + " serial = %d, state %s" % ( self.serial , self.state )
    
PacketFactory[PACKET_POKER_ANIMATION_DEALER_BUTTON] = PacketPokerAnimationDealerButton

########################################

PACKET_POKER_BEGIN_ROUND = 197 # 0xc5 # %SEQ%
PacketNames[PACKET_POKER_BEGIN_ROUND] = "POKER_BEGIN_ROUND"

class PacketPokerBeginRound(PacketPokerId):
    """\
Semantics: opens a betting round for game "game_id".

Direction: client <=> client

Context: inferred when the client knows that a betting round will
begin although it does not yet received information from the server to
initialize it. Paying the blind / ante is not considered a betting
round. It follows the POKER_END_ROUND packet, either
immediatly if the server has no delay between betting rounds
or later if the server waits a few seconds between two betting
rounds.

Example applied to holdem:

         state

         blind     END
BEGIN    preflop   END
BEGIN    flop      END
BEGIN    turn      END
BEGIN    river
         end

game_id: integer uniquely identifying a game.
"""
    
    type = PACKET_POKER_BEGIN_ROUND

PacketFactory[PACKET_POKER_BEGIN_ROUND] = PacketPokerBeginRound

########################################

PACKET_POKER_CURRENT_GAMES = 198 # 0xc6 # %SEQ%
PacketNames[PACKET_POKER_CURRENT_GAMES] = "POKER_CURRENT_GAMES"

class PacketPokerCurrentGames(Packet):

    type = PACKET_POKER_CURRENT_GAMES

    format = "!B"
    format_size = calcsize(format)
    format_element = "!I"

    def __init__(self, **kwargs):
        self.game_ids = kwargs.get("game_ids", [])
        self.count = kwargs.get("count", 0)

    def pack(self):
        return Packet.pack(self) + self.packlist(self.game_ids, PacketPokerCurrentGames.format_element) + pack(PacketPokerCurrentGames.format, self.count)
        
    def unpack(self, block):
        block = Packet.unpack(self, block)
        (block, self.game_ids) = self.unpacklist(block, PacketPokerCurrentGames.format_element)
        (self.count,) = unpack(PacketPokerCurrentGames.format, block[:PacketPokerCurrentGames.format_size])
        return block[PacketPokerCurrentGames.format_size:]

    def calcsize(self):
        return Packet.calcsize(self) + self.calcsizelist(self.game_ids, PacketPokerCurrentGames.format_element) + PacketPokerCurrentGames.format_size

    def __str__(self):
        return Packet.__str__(self) + " count = %d, game_ids = %s" % ( self.count, self.game_ids )

PacketFactory[PACKET_POKER_CURRENT_GAMES] = PacketPokerCurrentGames

######################################## Display packet

PACKET_POKER_END_ROUND_LAST = 199 # 0xc7 # %SEQ%
PacketNames[PACKET_POKER_END_ROUND_LAST] = "POKER_END_ROUND_LAST"

class PacketPokerEndRoundLast(PacketPokerId):
    
    type = PACKET_POKER_END_ROUND_LAST

PacketFactory[PACKET_POKER_END_ROUND_LAST] = PacketPokerEndRoundLast

######################################## Stop or Start animation

PACKET_POKER_PYTHON_ANIMATION = 200 # 0xc8 # %SEQ%
PacketNames[PACKET_POKER_PYTHON_ANIMATION] = "POKER_PYTHON_ANIMATION"

class PacketPokerPythonAnimation(PacketPokerId):
    
    type = PACKET_POKER_PYTHON_ANIMATION

    def __init__(self, *args, **kwargs):
        self.animation =  kwargs.get("animation", "none")
        
        PacketPokerId.__init__(self, *args, **kwargs)

PacketFactory[PACKET_POKER_PYTHON_ANIMATION] = PacketPokerPythonAnimation

########################################

PACKET_POKER_SIT_OUT_NEXT_TURN = 201 # 0xc9 # %SEQ%
PacketNames[PACKET_POKER_SIT_OUT_NEXT_TURN] = "POKER_SIT_OUT_NEXT_TURN"

class PacketPokerSitOutNextTurn(PacketPokerSitOut):

    type = PACKET_POKER_SIT_OUT_NEXT_TURN

PacketFactory[PACKET_POKER_SIT_OUT_NEXT_TURN] = PacketPokerSitOutNextTurn

########################################

PACKET_POKER_RENDERER_STATE = 202 # 0xca # %SEQ%
PacketNames[PACKET_POKER_RENDERER_STATE] = "POKER_RENDERER_STATE"

class PacketPokerRendererState(Packet):

    type = PACKET_POKER_RENDERER_STATE

    def __init__(self, **kwargs):
        self.state =  kwargs.get("state", "idle")

PacketFactory[PACKET_POKER_RENDERER_STATE] = PacketPokerRendererState

########################################

PACKET_POKER_CHAT_WORD = 203 # 0xcb # %SEQ%
PacketNames[PACKET_POKER_CHAT_WORD] = "POKER_CHAT_WORD"

class PacketPokerChatWord(PacketPokerId):
    type = PACKET_POKER_CHAT_WORD

    def __init__(self, *args, **kwargs):
        self.word = kwargs.get("word", "no word")
        PacketPokerId.__init__(self, *args, **kwargs)

PacketFactory[PACKET_POKER_CHAT_WORD] = PacketPokerChatWord

########################################

PACKET_POKER_SHOWDOWN = 204 # 0xcc # %SEQ%
PacketNames[PACKET_POKER_SHOWDOWN] = "POKER_SHOWDOWN"

class PacketPokerShowdown(PacketPokerId):
    type = PACKET_POKER_SHOWDOWN

    def __init__(self, *args, **kwargs):
        self.showdown_stack = kwargs.get("showdown_stack", {})
        PacketPokerId.__init__(self, *args, **kwargs)

    def __str__(self):
        return PacketPokerId.__str__(self) + " showdown_stack = %s" % self.showdown_stack

PacketFactory[PACKET_POKER_SHOWDOWN] = PacketPokerShowdown

########################################

PACKET_POKER_CLIENT_PLAYER_CHIPS = 205 # 0xcd # %SEQ%
PacketNames[PACKET_POKER_CLIENT_PLAYER_CHIPS] = "POKER_CLIENT_PLAYER_CHIPS"

class PacketPokerClientPlayerChips(Packet):
    type = PACKET_POKER_CLIENT_PLAYER_CHIPS

    def __init__(self, **kwargs):
        self.game_id = kwargs.get("game_id", 0)
        self.serial = kwargs.get("serial", 0)
        self.bet = kwargs.get("bet", [])
        self.money = kwargs.get("money", [])

    def __str__(self):
        return Packet.__str__(self) + " game_id = %d, serial = %d, bet = %s, money = %s" % ( self.game_id, self.serial, self.bet, self.money )

PacketFactory[PACKET_POKER_CLIENT_PLAYER_CHIPS] = PacketPokerClientPlayerChips

########################################

PACKET_POKER_INTERFACE_COMMAND = 206 # 0xce # %SEQ%
PacketNames[PACKET_POKER_INTERFACE_COMMAND] = "POKER_INTERFACE_COMMAND"

class PacketPokerInterfaceCommand(Packet):
    type = PACKET_POKER_INTERFACE_COMMAND

    def __init__(self, **kwargs):
        self.window = kwargs.get("window", None)
        self.command = kwargs.get("command", None)

    def __str__(self):
        return Packet.__str__(self) + " window = %s, command = %s" % ( self.window, self.command )

PacketFactory[PACKET_POKER_INTERFACE_COMMAND] = PacketPokerInterfaceCommand


########################################
PACKET_POKER_PLAYER_ME_LOOK_CARDS = 207 # 0xcf # %SEQ%
PacketNames[PACKET_POKER_PLAYER_ME_LOOK_CARDS] = "POKER_PLAYER_ME_LOOK_CARDS"

class PacketPokerPlayerMeLookCards(PacketPokerId):
    """\
Semantics: the player "serial" is looking at his cards
in game "game_id".

Direction: client <=> client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    def __init__(self, *args, **kwargs):
        self.state = kwargs.get("state","UNKNOWN")
        self.when = kwargs.get("when", "now")
        PacketPokerId.__init__(self, *args, **kwargs)

    type = PACKET_POKER_PLAYER_ME_LOOK_CARDS

    def __str__(self):
        return PacketPokerId.__str__(self) + " state = %s" % ( self.state )

PacketFactory[PACKET_POKER_PLAYER_ME_LOOK_CARDS] = PacketPokerPlayerMeLookCards

########################################

PACKET_POKER_PLAYER_ME_IN_FIRST_PERSON = 208 # 0xd0 # %SEQ%
PacketNames[PACKET_POKER_PLAYER_ME_IN_FIRST_PERSON] = "POKER_PLAYER_ME_IN_FIRST_PERSON"

class PacketPokerPlayerMeInFirstPerson(PacketPokerId):
    def __init__(self, *args, **kwargs):
        self.state = kwargs.get("state","UNKNOWN")
        PacketPokerId.__init__(self, *args, **kwargs)

    type = PACKET_POKER_PLAYER_ME_IN_FIRST_PERSON

    def __str__(self):
        return PacketPokerId.__str__(self) + " state = %s" % ( self.state )

PacketFactory[PACKET_POKER_PLAYER_ME_IN_FIRST_PERSON] = PacketPokerPlayerMeInFirstPerson

_TYPES = range(170,254)

# Interpreted by emacs
# Local Variables:
# compile-command: "perl -pi -e 'if(/%SEQ%/) { $s = 169 if(!defined($s)); $s++; $h = sprintf(q/0x%x/, $s); s/\\d+[ \\w#]+#/$s # $h #/; }' pokerclientpackets.py"
# End:

########NEW FILE########
__FILENAME__ = packets
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Henry Precheur <henry@precheur.org> (2004)
#
from struct import pack, unpack, calcsize
import simplejson
from string import join

PacketFactory = {}
PacketNames = {}

PACKET_NONE = 0
PacketNames[PACKET_NONE] = "NONE"

def json_encode_decimal(obj):
    if isinstance(obj, decimal.Decimal):
        return str(obj)
    raise TypeError(repr(obj) + " is not JSON serializable")

class Packet:
    """

     Packet base class
    
    """
    JSON = simplejson.JSONEncoder(default=json_encode_decimal)
    
    type = PACKET_NONE
    length = -1
    format = "!BH"
    format_size = calcsize(format)

    format_list_length = "!B"

    def infoInit(self, **kwargs):
        info = self.info
        for (field, default, format) in self.info:
            if field == 'type':
                self.type = self.type # type is now in __dict__, for serialization 
            if not self.__dict__.has_key(field):
                self.__dict__[field] = kwargs.get(field, default)
        self.length = self.infoCalcsize()
        return None
            
    def pack(self):
        return pack(Packet.format, self.type, self.calcsize())

        
              
    def infoPack(self):
        blocks = []
        info = self.info
        self.length = self.infoCalcsize()
        for (field, default, format) in self.info:
            if format != 'no net':
                packer = self.format_info[format]['pack']
                blocks.append(packer(self.__dict__[field]))
        return "".join(blocks)
            
    def unpack(self, block):
        (self.type,self.length) = unpack(Packet.format, block[:Packet.format_size])
        return block[Packet.format_size:]

    def infoUnpack(self, block):
        blocks = []
        info = self.info
        for (field, default, format) in self.info:
            if format != 'no net':
                unpacker = self.format_info[format]['unpack']
                ( block, self.__dict__[field] ) = unpacker(block)
        return block

    @staticmethod
    def infoUnpackerb(block):
        value = unpack('B', block[0])[0]
        if value == 255: value = -1
        return ( block[1:], value )
    
    @staticmethod
    def infoPackerb(data):
        if data == -1: data = 255
        return pack('B', data)
    
    @staticmethod
    def infoUnpackerBnone(block):
        value = unpack('B', block[0])[0]
        if value == 255: value = None
        return ( block[1:], value )
    
    @staticmethod
    def infoPackerBnone(data):
        if data == None: data = 255
        return pack('B', data)
    
    @staticmethod
    def infoUnpackerBool(block):
        value = unpack('B', block[0])[0]
        if value != 0: value = True
        else: value = False
        return ( block[1:], value )
    
    @staticmethod
    def infoPackerBool(data):
        if data: data = 1
        else: data = 0
        return pack('B', data)
    
    @staticmethod
    def infoUnpackerCBool(block):
        value = unpack('B', block[0])[0]
        if value != 0: value = 'y'
        else: value = 'n'
        return ( block[1:], value )
    
    @staticmethod
    def infoPackerCBool(data):
        if data == 'y': data = 1
        else: data = 0
        return pack('B', data)
    
    def calcsize(self):
        return Packet.format_size

    def infoCalcsize(self):
        size = 0
        for (field, default, format) in self.info:
            if format != 'no net':
                calcsize = self.format_info[format]['calcsize']
                size += calcsize(self.__dict__[field])
        return size

    @staticmethod
    def packlist(l, format):
        block = pack(Packet.format_list_length, len(l))
        for value in l:
            block += pack(format, value)
        return block

    @staticmethod
    def unpacklist(block, format):
        (length,) = unpack(Packet.format_list_length, block[:calcsize(Packet.format_list_length)])
        format_size = calcsize(format)
        block = block[calcsize(Packet.format_list_length):]
        l = []
        for i in xrange(length):
            l.append(unpack(format, block[:format_size])[0])
            block = block[format_size:]
        return (block, l)

    @staticmethod
    def calcsizelist(l, format):
        return calcsize(Packet.format_list_length) + len(l) * calcsize(format)

    @staticmethod
    def packstring(string):
        return pack("!H", len(string)) + string

    @staticmethod
    def unpackstring(block):
        offset = calcsize("!H")
        (length,) = unpack("!H", block[:offset])
        string = block[offset:offset + length]
        return (block[offset + length:], string)

    @staticmethod
    def calcsizestring(string):
        return calcsize("!H") + len(string)

    @staticmethod
    def packjson(object):
        return Packet.packstring(Packet.JSON.encode(object))

    @staticmethod
    def unpackjson(block):
        ( block, string ) = Packet.unpackstring(block)
        object = simplejson.loads(string)
        if hasattr(Packet.JSON, 'decode_objects'):
            return ( block, Packet.JSON.decode_objects(object) )
        else:
            return ( block, object )

    @staticmethod
    def calcsizejson(object):
        return len(Packet.packjson(object))

    @staticmethod
    def packpackets(packets):
        block = pack('!H', len(packets))
        for packet in packets:
            block += packet.pack()
        return block

    @staticmethod
    def unpackpackets(block):
        (length,) = unpack('!H', block[0:2])
        block = block[2:]
        t = Packet()
        count = 0
        packets = []
        while len(block) > 0 and count < length:
            t.unpack(block)
            if not PacketFactory.has_key(t.type):
                print " *ERROR* unknown packet type %d (known types are %s)" % ( t.type, PacketNames)
                return None
            packet = PacketFactory[t.type]()
            block = packet.unpack(block)
            count += 1
            packets.append(packet)
        if count != length:
            print " *ERROR* expected a list of %d packets but found only %d" % ( length, count)
            return None
        return ( block, packets )

    @staticmethod
    def calcsizepackets(packets):
        return 2 + sum([ packet.calcsize() for packet in packets ])
    
    def __str__(self):
        return "type = %s(%d)" % ( PacketNames[self.type], self.type )

    def infoStr(self):
        strings = [ PacketNames[self.type] + " " ]
        for (field, default, format) in self.info:
            strings.append(field + " = " + str(self.__dict__[field]))
        return " ".join(strings)

    def __repr__(self):
        return self.__str__()

    def __eq__(self, other):
        return isinstance(other, Packet) and self.type == other.type

    @staticmethod
    def infoDeclare(dictionary, type, base_type, name, index):
        dictionary['PacketNames'][index] = name
        dictionary['PacketFactory'][index] = type
        dictionary['PACKET_' + name] = index
        type.type = index
        type.__init__ = Packet.infoInit
        type.pack = Packet.infoPack
        type.unpack = Packet.infoUnpack
        type.calcsize = Packet.infoCalcsize
        type.__str__ = Packet.infoStr

Packet.info = (
    ('type', PACKET_NONE, 'B'),
    ('length', -1, 'H'),
    )
    
Packet.format_info = {
    #
    # Not transfered over the network.
    #
    'no net': None,
    #
    # Unsigned integer, int, 4 bytes, network order (big endian).
    # Example: 1 <=> \x00\x00\x00\x01
    #
    'I': {'pack': lambda data: pack('!I', data),
          'unpack': lambda block: ( block[4:], int(unpack('!I', block[:4])[0]) ),
          'calcsize': lambda data: 4,
          },
    #
    # Unsigned integer, char, 1 byte
    # Example: 1 <=> \x01
    #
    'B': {'pack': lambda data: pack('B', data),
          'unpack': lambda block: ( block[1:], unpack('B', block[0])[0] ),
          'calcsize': lambda data: 1,
          },
    #
    # Integer range [-1..254], char, 1 byte
    # -1 is 255
    # Example: 1 <=> \x01, -1 <=> \xff, 254 <=> \xfe
    #
    'b': {'pack': Packet.infoPackerb,
          'unpack': Packet.infoUnpackerb,
          'calcsize': lambda data: 1,
          },
    #
    # Integer range [0..254, None], char, 1 byte
    # None is 255
    # Example: 1 <=> \x01, None <=> \xff, 254 <=> \xfe
    #
    'Bnone': {'pack': Packet.infoPackerBnone,
              'unpack': Packet.infoUnpackerBnone,
              'calcsize': lambda data: 1,
          },
    #
    # Integer range [0,1], char, 1 byte
    # True is 1, False is 0
    # Example: True <=> \x01, False <=> \x00
    #
    'bool': {'pack': Packet.infoPackerBool,
             'unpack': Packet.infoUnpackerBool,
             'calcsize': lambda data: 1,
          },
    #
    # Integer range ['n','y'], char, 1 byte
    # 'y' is 1, 'n' is 0
    # Example: 'y' <=> \x01, 'n' <=> \x00
    #
    'cbool': {'pack': Packet.infoPackerCBool,
              'unpack': Packet.infoUnpackerCBool,
              'calcsize': lambda data: 1,
              },
    #
    # Unsigned integer, short, 2 bytes, network order (big endian).
    # Example: 1 <=> \x00\x01
    #
    'H': {'pack': lambda data: pack('!H', data),
          'unpack': lambda block: ( block[2:], unpack('!H', block[:2])[0] ),
          'calcsize': lambda data: 2,
          },
    #
    # Character string, length as a 2 bytes integer, network order (big endian)
    #   followed by the content of the string.
    # Example: "abc" <=> \x00\x03abc
    #          "a" <=> \x00\x01a
    #          "" <=> \x00\x00
    #
    's': {'pack': Packet.packstring,
          'unpack': Packet.unpackstring,
          'calcsize': Packet.calcsizestring,
          },
    #
    # JSon.org encoded string, length as a 2 bytes integer, network order (big endian)
    #   followed by the content of the string.
    # Example: "{'a':1}" <=> \x00\x07{'a':1}
    #
    'j': {'pack': Packet.packjson,
          'unpack': Packet.unpackjson,
          'calcsize': Packet.calcsizejson,
          },
    #
    # List of integer, length of the list as a 1 byte unsigned integer in the range [0-255]
    # Each integer is a 1 byte unsigned value in the range [0-255]
    # Example: [] <=> \x00
    #          [5] <=> \x01\x05
    #          [5, 255] <=> \x02\x05\xff
    #
    'Bl': {'pack': lambda data: Packet.packlist(data, 'B'),
           'unpack': lambda block: Packet.unpacklist(block, 'B'),
           'calcsize': lambda data: Packet.calcsizelist(data, 'B'),
           },
    #
    # List of integer, length of the list as a 1 byte unsigned integer in the range [0-255]
    # Each integer is a 2 bytes unsigned value in network order (big endian)
    # Example: [] <=> \x00
    #          [5] <=> \x01\x00\x05
    #          [5, 255] <=> \x02\x00\x05\x00\xff
    #
    'Hl': {'pack': lambda data: Packet.packlist(data, '!H'),
           'unpack': lambda block: Packet.unpacklist(block, '!H'),
           'calcsize': lambda data: Packet.calcsizelist(data, '!H'),
           },
    #
    # List of integer, length of the list as a 1 byte unsigned integer in the range [0-255]
    # Each integer is a 4 bytes unsigned value in network order (big endian)
    # Example: [] <=> \x00
    #          [5] <=> \x01\x00\x00\x00\x05
    #          [5, 255] <=> \x02\x00\x00\x00\x05\x00\x00\x00\xff
    #
    'Il': {'pack': lambda data: Packet.packlist(data, '!I'),
           'unpack': lambda block: Packet.unpacklist(block, '!I'),
           'calcsize': lambda data: Packet.calcsizelist(data, '!I'),
           },

    #
    # List of packets, length of the list as a short unsigned integer in the range [0-65535]
    # Each packet is a derived from Packet
    # Example: [] <=> \x00\x00
    #          [PacketPing()] <=> \x00\x01\x05\x00\x03
    #          [PacketPing(), PacketPing()] <=> \x00\x02\x05\x00\x03\x05\x00\x03
    #
    'pl': {'pack': Packet.packpackets,
           'unpack': Packet.unpackpackets,
           'calcsize': Packet.calcsizepackets,
           },
    }

PacketFactory[PACKET_NONE] = Packet

########################################

PACKET_STRING = 1
PacketNames[PACKET_STRING] = "STRING"

class PacketString(Packet):
    """

    Packet containing a single string
    
    """

    type = PACKET_STRING

    info = Packet.info + ( ( 'string', '', 's' ), )
                           
    def __init__(self, **kwargs):
        self.string = kwargs.get("string", "")

    def pack(self):
        return Packet.pack(self) + self.packstring(self.string)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (block, self.string) = self.unpackstring(block)
        return block

    def calcsize(self):
        return Packet.calcsize(self) + self.calcsizestring(self.string)

    def __str__(self):
        return Packet.__str__(self) + " string = %s" % self.string

PacketFactory[PACKET_STRING] = PacketString

########################################

PACKET_INT = 2
PacketNames[PACKET_INT] = "INT"

class PacketInt(Packet):
    """

    Packet containing an unsigned integer value
    
    """

    type = PACKET_INT

    info = Packet.info + ( ( 'value', 0, 'I' ), )
    
    format = "!I"
    format_size = calcsize(format)
    
    def __init__(self, **kwargs):
        self.value = kwargs.get("value", 0)

    def pack(self):
        return Packet.pack(self) + pack(PacketInt.format, self.value)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (self.value,) = unpack(PacketInt.format, block[:PacketInt.format_size])
        return block[PacketInt.format_size:]

    def calcsize(self):
        return Packet.calcsize(self) + PacketInt.format_size

    def __str__(self):
        return Packet.__str__(self) + " value = %d" % self.value

PacketFactory[PACKET_INT] = PacketInt

########################################

PACKET_ERROR = 3
PacketNames[PACKET_ERROR] = "ERROR"

class PacketError(Packet, Exception):
    """

    Packet describing an error
    
    """
    
    type = PACKET_ERROR

    info = Packet.info + ( ('message', 'no message', 's'),
                           ('code', 0, 'I' ),
                           ('other_type', PACKET_ERROR, 'B'),
                           )
    
    format = "!IB"
    format_size = calcsize(format)

    def __init__(self, **kwargs):
        self.message = kwargs.get("message", "no message")
        self.code = kwargs.get("code", 0)
        self.other_type = kwargs.get("other_type", PACKET_ERROR)
        Exception.__init__(self)

    def pack(self):
        return Packet.pack(self) + self.packstring(self.message) + pack(PacketError.format, self.code, self.other_type)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (block, self.message) = self.unpackstring(block)
        (self.code, self.other_type) = unpack(PacketError.format, block[:PacketError.format_size])
        return block[PacketError.format_size:]

    def calcsize(self):
        return Packet.calcsize(self) + self.calcsizestring(self.message) + PacketError.format_size

    def __str__(self):
        return Packet.__str__(self) + " message = %s, code = %d, other_type = %s" % (self.message, self.code, PacketNames[self.other_type])

PacketFactory[PACKET_ERROR] = PacketError

########################################

PACKET_ACK = 4
PacketNames[PACKET_ACK] = "ACK"

class PacketAck(Packet):
    ""

    type = PACKET_ACK

PacketFactory[PACKET_ACK] = PacketAck

########################################

PACKET_PING = 5
PacketNames[PACKET_PING] = "PING"

class PacketPing(Packet):
    ""

    type = PACKET_PING

PacketFactory[PACKET_PING] = PacketPing

########################################

PACKET_SERIAL = 6
PacketNames[PACKET_SERIAL] = "SERIAL"

class PacketSerial(Packet):
    """\
Semantics: the serial number of the authenticated user
           associated to the client after a PacketLogin
           was sent. This packet is sent to the client
           after the PacketAuthOk acknowledging the success
           of the authentication.

Direction: server => client

serial: the unique number associated to the user.
    """

    type = PACKET_SERIAL

    info = Packet.info + ( ('serial', 0, 'I'),
                           ('cookie', '', 'no net') )
    
    format = "!I"
    format_size = calcsize(format)
    
    def __init__(self, **kwargs):
        self.serial = kwargs.get("serial", 0)
        self.cookie = kwargs.get("cookie", "") # not present in client/server dialog

    def pack(self):
        return Packet.pack(self) + pack(PacketSerial.format, self.serial)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        self.serial = int(unpack(PacketSerial.format, block[:PacketSerial.format_size])[0])
        return block[PacketSerial.format_size:]

    def calcsize(self):
        return Packet.calcsize(self) + PacketSerial.format_size

    def __str__(self):
        return Packet.__str__(self) + " serial = %d" % self.serial
        
PacketFactory[PACKET_SERIAL] = PacketSerial

########################################

PACKET_QUIT = 7
PacketNames[PACKET_QUIT] = "QUIT"

class PacketQuit(Packet):
    """
    Client tells the server it will leave
    """

    type = PACKET_QUIT

PacketFactory[PACKET_QUIT] = PacketQuit

########################################

PACKET_AUTH_OK = 8
PacketNames[PACKET_AUTH_OK] = "AUTH_OK"

class PacketAuthOk(Packet):
    """\
Semantics: authentication request succeeded.

Direction: server => client
    """

    type = PACKET_AUTH_OK

PacketFactory[PACKET_AUTH_OK] = PacketAuthOk

########################################

PACKET_AUTH_REFUSED = 9
PacketNames[PACKET_AUTH_REFUSED] = "AUTH_REFUSED"

class PacketAuthRefused(PacketError):
    """\
Semantics: authentication request was refused by the server.

Direction: server => client

message: human readable reason for the authentication failure
code: machine readable code matching the human readable message
      the list of which can be found in the PacketPokerSetAccount
      packet definition
other_type: the type of the packet that triggered the authentication
            error, i.e. PACKET_LOGIN
    """

    type = PACKET_AUTH_REFUSED

PacketFactory[PACKET_AUTH_REFUSED] = PacketAuthRefused

########################################

PACKET_LOGIN = 10
PacketNames[PACKET_LOGIN] = "LOGIN"

class PacketLogin(Packet):
    """\
Semantics: authentify user "name" with "password".

Direction: server <= client

If the user/password combination is valid, the
PacketAuthOk packet will be sent back to the client,
immediately followed by the PacketSerial packet that
holds the serial number of the user.

If the user/password combination is invalid, the
PacketAuthRefused packet will be sent back to the client.
If the user is already logged in, a PacketError is sent
with code set to PacketLogin.LOGGED.

name: valid user name as a string
password: matching password string
    """

    LOGGED = 1
    
    type = PACKET_LOGIN

    info = Packet.info + ( ('name', 'unknown', 's'),
                           ('password', 'unknown', 's') )
    
    def __init__(self, **kwargs):
        self.name = kwargs.get("name", "unknown")
        self.password = kwargs.get("password", "unknown")

    def pack(self):
        return Packet.pack(self) + self.packstring(self.name) + self.packstring(self.password)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (block, self.name) = self.unpackstring(block)
        (block, self.password) = self.unpackstring(block)
        return block

    def calcsize(self):
        return Packet.calcsize(self) + self.calcsizestring(self.name) + self.calcsizestring(self.password)

    def __str__(self):
        return Packet.__str__(self) + " name = %s, password = %s" % (self.name, self.password)

PacketFactory[PACKET_LOGIN] = PacketLogin

########################################

PACKET_AUTH_REQUEST = 11
PacketNames[PACKET_AUTH_REQUEST] = "AUTH_REQUEST"

class PacketAuthRequest(Packet):
    """
    Packet to ask authentification from the client
    """

    type = PACKET_AUTH_REQUEST

PacketFactory[PACKET_AUTH_REQUEST] = PacketAuthRequest

########################################

PACKET_LIST = 12
PacketNames[PACKET_LIST] = "LIST"

class PacketList(Packet):
    """

    Packet containing a list of packets
    
    """

    type = PACKET_LIST

    info = Packet.info + ( ('packets', [], 'pl'), )
    
    packets = []
    format = "!H"
    format_size = calcsize(format)

    def __init__(self, **kwargs):
        self.packets = kwargs.get("packets", [])

    def pack(self):
        block = Packet.pack(self) + pack(PacketList.format, len(self.packets))
        for packet in self.packets:
            block += packet.pack()
        return block

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (length,) = unpack(PacketList.format, block[:PacketList.format_size])
        block = block[PacketList.format_size:]
        t = Packet()
        count = 0
        self.packets = []
        while len(block) > 0 and count < length:
            t.unpack(block)
            if not PacketFactory.has_key(t.type):
                print " *ERROR* unknown packet type %d (known types are %s)" % ( t.type, PacketNames)
                return
            packet = PacketFactory[t.type]()
            block = packet.unpack(block)
            count += 1
            self.packets.append(packet)
        if count != length:
            print " *ERROR* expected a list of %d packets but found only %d" % ( length, count)
        return block

    def calcsize(self):
        return Packet.calcsize(self) + PacketList.format_size + sum([ packet.calcsize() for packet in self.packets ])

    def __str__(self):
        return Packet.__str__(self) + join([packet.__str__() for packet in self.packets ])

PacketFactory[PACKET_LIST] = PacketList

########################################

PACKET_LOGOUT = 13
PacketNames[PACKET_LOGOUT] = "LOGOUT"

class PacketLogout(Packet):
    """
    Login out
    """

    NOT_LOGGED_IN = 1
    
    type = PACKET_LOGOUT

PacketFactory[PACKET_LOGOUT] = PacketLogout

########################################

PACKET_BOOTSTRAP = 14
PacketNames[PACKET_BOOTSTRAP] = "BOOTSTRAP"

class PacketBootstrap(Packet):
    ""

    type = PACKET_BOOTSTRAP

PacketFactory[PACKET_BOOTSTRAP] = PacketBootstrap

########################################

PACKET_PROTOCOL_ERROR = 15
PacketNames[PACKET_PROTOCOL_ERROR] = "PROTOCOL_ERROR"

class PacketProtocolError(PacketError):
    """
    Client protocol version does not match server protocol version.
    """

    type = PACKET_PROTOCOL_ERROR

PacketFactory[PACKET_PROTOCOL_ERROR] = PacketProtocolError

########################################

PACKET_MESSAGE = 16
PacketNames[PACKET_MESSAGE] = "MESSAGE"

class PacketMessage(PacketString):
    """
    server => client
    Informative messages
    """

    type = PACKET_MESSAGE

PacketFactory[PACKET_MESSAGE] = PacketMessage

_TYPES = range(0,39)

### !!!!!! NO SERIAL >= 50 !!!!!! ####

########NEW FILE########
__FILENAME__ = pokerauth
#
# -*- py-indent-offset: 4; coding: iso-8859-1 -*-
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008             Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Johan Euphrosine <proppy@aminche.com>
#  Henry Precheur <henry@precheur.org> (2004)
#  Cedric Pinson <mornifle@plopbyte.net> (2004-2006)

from pokernetwork.user import User
from twisted.python.runtime import seconds

def message(string):
    print "PokerAuth: " + string
    
class PokerAuth:

    def __init__(self, db, settings):
        self.db = db
        self.type2auth = {}
        self.verbose = settings.headerGetInt("/server/@verbose")
        self.auto_create_account = settings.headerGet("/server/@auto_create_account") != 'no'

    def message(self, string):
        print "PokerAuth: " + string

    def error(self, string):
        self.message("*ERROR* " + string)
            
    def SetLevel(self, type, level):
        self.type2auth[type] = level

    def GetLevel(self, type):
        return self.type2auth.has_key(type) and self.type2auth[type]

    def auth(self, name, password):
        cursor = self.db.cursor()
        cursor.execute("SELECT serial, password, privilege FROM users "
                       "WHERE name = '%s'" % name)
        numrows = int(cursor.rowcount)
        serial = 0
        privilege = User.REGULAR
        if numrows <= 0:
            if self.auto_create_account:
                if self.verbose > 1:
                    self.message("user %s does not exist, create it" % name)
                serial = self.userCreate(name, password)
                cursor.close()
            else:
                if self.verbose > 1:
                    self.message("user %s does not exist" % name)
                cursor.close()
                return ( False, "Invalid login or password" )
        elif numrows > 1:
            self.error("more than one row for %s" % name)
            cursor.close()
            return ( False, "Invalid login or password" )
        else:
            (serial, password_sql, privilege) = cursor.fetchone()
            cursor.close()
            if password_sql != password:
                self.message("password mismatch for %s" % name)
                return ( False, "Invalid login or password" )

        return ( (serial, name, privilege), None )

    def userCreate(self, name, password):
        if self.verbose:
            self.message("creating user %s" % name)
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO users (created, name, password) values (%d, '%s', '%s')" %
                       (seconds(), name, password))
        #
        # Accomodate for MySQLdb versions < 1.1
        #
        if hasattr(cursor, "lastrowid"):
            serial = cursor.lastrowid
        else:
            serial = cursor.insert_id()
        if self.verbose:
            self.message("create user with serial %s" % serial)
        cursor.execute("INSERT INTO users_private (serial) values ('%d')" % serial)
        cursor.close()
        return int(serial)

_get_auth_instance = None
def get_auth_instance(db, settings):
    global _get_auth_instance
    if _get_auth_instance == None:
        verbose = settings.headerGetInt("/server/@verbose")
        import imp
        script = settings.headerGet("/server/auth/@script")
        try:
            if verbose > 1:
                message("get_auth_instance: trying to load: '%s'" % script)
            module = imp.load_source("user_defined_pokerauth", script)
            get_instance = getattr(module, "get_auth_instance")
            if verbose > 1:
                message("get_auth_instance: using custom implementation of get_auth_instance: %s" % script)
            _get_auth_instance = get_instance
        except:
            if verbose > 1:
                message("get_auth_instance: falling back on pokerauth.get_auth_instance, script not found: '%s'" % script)
            _get_auth_instance = lambda db, settings: PokerAuth(db, settings)
    return apply(_get_auth_instance, [db, settings])

########NEW FILE########
__FILENAME__ = pokerauthmysql
#
# -*- py-indent-offset: 4; coding: iso-8859-1 -*-
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008             Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Johan Euphrosine <proppy@aminche.com>
#  Henry Precheur <henry@precheur.org> (2004)
#  Cedric Pinson <mornifle@plopbyte.net> (2004-2006)

from pokernetwork.user import User
from twisted.python.runtime import seconds
import MySQLdb

class PokerAuth:

    def __init__(self, db, settings):
        self.db = db
        self.type2auth = {}
        self.verbose = settings.headerGetInt("/server/@verbose")
        self.settings = settings
        self.parameters = self.settings.headerGetProperties("/server/auth")[0]
        self.auth_db = MySQLdb.connect(host = self.parameters["host"],
                                  port = int(self.parameters.get("port", '3306')),
                                  user = self.parameters["user"],
                                  passwd = self.parameters["password"],
                                  db = self.parameters["db"])

    def message(self, string):
        print "PokerAuthMysql: " + string

    def error(self, string):
        self.message("*ERROR* " + string)
            
    def SetLevel(self, type, level):
        self.type2auth[type] = level

    def GetLevel(self, type):
        return self.type2auth.has_key(type) and self.type2auth[type]

    def auth(self, name, password):
        cursor = self.auth_db.cursor()
        cursor.execute("SELECT username, password, privilege FROM %s " % self.parameters["table"] +
                       "WHERE username = '%s'" % name)
        numrows = int(cursor.rowcount)
        serial = 0
        privilege = User.REGULAR
        if numrows <= 0:
                if self.verbose > 1:
                    self.message("user %s does not exist" % name)
                cursor.close()
                return ( False, "Invalid login or password" )
        elif numrows > 1:
            self.error("more than one row for %s" % name)
            cursor.close()
            return ( False, "Invalid login or password" )
        else:
            (serial, password_sql, privilege) = cursor.fetchone()
            cursor.close()
            if password_sql != password:
                self.message("password mismatch for %s" % name)
                return ( False, "Invalid login or password" )

        return ( (serial, name, privilege), None )

def get_auth_instance(db, settings):
    return PokerAuth(db, settings)

########NEW FILE########
__FILENAME__ = pokeravatar
#
# -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)       2008, 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C)             2008 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2004, 2005, 2006 Mekensleep
#                                24 rue vieille du temple 75004 Paris
#                                <licensing@mekensleep.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@gnu.org>
#  Bradley M. Kuhn <bkuhn@ebb.org> (2008)
#  Johan Euphrosine <proppy@aminche.com> (2008)
#  Henry Precheur <henry@precheur.org> (2004)

from string import join
import sets
import re

from twisted.internet import defer

from types import *
from traceback import format_exc

from pokerengine import pokergame
from pokernetwork.user import User, checkNameAndPassword
from pokernetwork.pokerpackets import *
from pokernetwork.pokerexplain import PokerExplain
from pokernetwork.pokerrestclient import PokerRestClient
from twisted.internet import protocol, reactor, defer

DEFAULT_PLAYER_USER_DATA = { 'ready': True }

class PokerAvatar:

    def __init__(self, service):
        self.protocol = None
        self.packet_id = 0
        self.localeFunc = None
        self.roles = sets.Set()
        self.service = service
        self.tables = {}
        self.user = User()
        self._packets_queue = []
        self.warnedPacketExcess = False
        self.tourneys = []
        self.setExplain(0)
        self.has_session = False
        self.bugous_processing_hand = False
        self.noqueuePackets()
        self._block_longpoll_deferred = False
        self._longpoll_deferred = None
        self.game_id2rest_client = {}
        self.distributed_args = '?explain=no'
        self.longPollTimer = None
        self._flush_next_longpoll = False

    def setDistributedArgs(self, uid, auth):
        self.distributed_args = '?explain=no&uid=%s&auth=%s' % ( uid, auth )
        
    def __str__(self):
        return "PokerAvatar serial = %s, name = %s" % ( self.getSerial(), self.getName() )

    def setExplain(self, what):
        if what:
            if self.explain == None:
                if self.tables:
                    self.error("setExplain must be called when not connected to any table")
                    return False

                self.explain = PokerExplain(dirs = self.service.dirs,
                                            verbose = self.service.verbose,
                                            explain = what)
        else:
            self.explain = None
        return True

    def _setDefaultLocale(self, locale):
        """Set self.localFunc using locale iff. it is not already set.
        Typically, this method is only used for a locale found for the
        user in the database.  If the client sends a
        PacketPokerSetLocale(), that will always take precedent and should
        not use this method, but self.setLocale() instead."""
        if not self.localeFunc:
            return self.setLocale(locale)
        else:
            return None
            
    def setLocale(self, locale):
        if locale:
            # 'ISO-8859-1' is currently enforced for all setLocale()
            # requests.  This is primarily because the JSON interface
            # implemented in pokersite.py *assumes* that all strings must
            # be 'ISO-8859-1' and encodes them to unicode.  We should
            # actually find a way to be knowledgeable about the needed
            # encoding, because there is probably pointless conversion
            # between ISO and UTF-8 happening in this process.  Also, we
            # cannot currently support any languages that are non
            # 'ISO-8859-1', so that's a huge FIXME!  --bkuhn, 2008-10-28
            self.localeFunc = self.service.locale2translationFunc(locale, 'ISO-8859-1')
        return self.localeFunc

    def setProtocol(self, protocol):
        self.protocol = protocol

#    def __del__(self):
#       self.message("instance deleted")

    def error(self, string):
        self.message("ERROR " + str(string))
        
    def message(self, string):
        print "PokerAvatar: " + str(string)
        
    def isAuthorized(self, type):
        return self.user.hasPrivilege(self.service.poker_auth.GetLevel(type))

    def relogin(self, serial):
        player_info = self.service.getPlayerInfo(serial)
        self.user.serial = serial
        self.user.name = player_info.name
        self.user.privilege = User.REGULAR
        self.user.url = player_info.url
        self.user.outfit = player_info.outfit
        self._setDefaultLocale(player_info.locale)

        if self.explain:
            self.explain.handleSerial(PacketSerial(serial = serial))
        self.service.avatar_collection.add(serial, self)
        self.tourneyUpdates(serial)
        self.loginTableUpdates(serial)
    
    def login(self, info):
        (serial, name, privilege) = info
        self.user.serial = serial
        self.user.name = name
        self.user.privilege = privilege

        player_info = self.service.getPlayerInfo(serial)
        self.user.url = player_info.url
        self.user.outfit = player_info.outfit
        self._setDefaultLocale(player_info.locale)

        self.sendPacketVerbose(PacketSerial(serial = self.user.serial))
        if PacketPokerRoles.PLAY in self.roles:
            self.service.avatar_collection.add(serial, self)
        if self.service.verbose:
            self.message("user %s/%d logged in" % ( self.user.name, self.user.serial ))
        if self.protocol:
            self.has_session = self.service.sessionStart(self.getSerial(), str(self.protocol.transport.client[0]))
        self.tourneyUpdates(serial)
        self.loginTableUpdates(serial)

    def tourneyUpdates(self, serial):
        places = self.service.getPlayerPlaces(serial)
        self.tourneys = places.tourneys

    def loginTableUpdates(self, serial):
        #
        # Send player updates if it turns out that the player was already
        # seated at a known table.
        #
        for table in self.tables.values():
            if table.possibleObserverLoggedIn(self, serial):
                game = table.game
                self.sendPacketVerbose(PacketPokerPlayerCards(game_id = game.id,
                                                              serial = serial,
                                                              cards = game.getPlayer(serial).hand.toRawList()))
                self.sendPacketVerbose(PacketPokerPlayerSelf(game_id = game.id,
                                                             serial = serial))
                pending_blind_request = game.isBlindRequested(serial)
                pending_ante_request = game.isAnteRequested(serial)
                if pending_blind_request or pending_ante_request:
                    if pending_blind_request:
                        (amount, dead, state) = game.blindAmount(serial)
                        self.sendPacketVerbose(PacketPokerBlindRequest(game_id = game.id,
                                                                       serial = serial,
                                                                       amount = amount,
                                                                       dead = dead,
                                                                       state = state))
                    if pending_ante_request:
                        self.sendPacketVerbose(PacketPokerAnteRequest(game_id = game.id,
                                                                      serial = serial,
                                                                      amount = game.ante_info["value"]))

    def logout(self):
        if self.user.serial:
            if PacketPokerRoles.PLAY in self.roles:
                self.service.avatar_collection.remove(self.user.serial, self)
            if self.has_session:
                self.service.sessionEnd(self.getSerial())
            self.user.logout()
        
    def auth(self, packet):
        status = checkNameAndPassword(packet.name, packet.password)
        if status[0]:
            ( info, reason ) = self.service.auth(packet.name, packet.password, self.roles)
            code = 0
        else:
            self.message("auth: failure " + str(status))
            reason = status[2]
            code = status[1]
            info = False
        if info:
            self.sendPacketVerbose(PacketAuthOk())
            self.login(info)
        else:
            self.sendPacketVerbose(PacketAuthRefused(message = reason,
                                                     code = code,
                                                     other_type = PACKET_LOGIN))

    def getSerial(self):
        return self.user.serial

    def getName(self):
        return self.user.name

    def getUrl(self):
        return self.user.url

    def getOutfit(self):
        return self.user.outfit
    
    def isLogged(self):
        return self.user.isLogged()

    def queuePackets(self):
        self._queue_packets = True

    def noqueuePackets(self):
        self._queue_packets = False

    def extendPacketsQueue(self, newPackets):
        """takes PokerAvatar object and a newPackets as arguments, and
        extends the self._queue_packets variable by that packet.  Checking
        is done to make sure we haven't exceeded server-wide limits on
        packet queue length.  PokerAvatar will be force-disconnected if
        the packets exceed the value of
        self.service.getClientQueuedPacketMax().  A warning will be
        printed when the packet queue reaches 75% of the limit imposed by
        self.service.getClientQueuedPacketMax()"""
        # This method was introduced when we added the force-disconnect as
        # the stop-gap.
        self._packets_queue.extend(newPackets)
        self.flushLongPollDeferred()
        warnVal = int(.75 * self.service.getClientQueuedPacketMax())
        if len(self._packets_queue) >= warnVal:
            # If we have not warned yet that packet queue is getting long, warn now.
            if not self.warnedPacketExcess:
                self.warnedPacketExcess = True
                self.error("WARNING: user %d has more than %d packets queued; will force-disconnect when %d are queued" % (self.getSerial(), warnVal, self.service.getClientQueuedPacketMax()))
            if len(self._packets_queue) >= self.service.getClientQueuedPacketMax():
                self.service.forceAvatarDestroy(self)

    def resetPacketsQueue(self):
        self.warnedPacketExcess = False
        queue = self._packets_queue
        self._packets_queue = []
        return queue

    def removeGamePacketsQueue(self, game_id):
        self._packets_queue = filter(lambda packet: not hasattr(packet, "game_id") or packet.game_id != game_id, self._packets_queue)

    def sendPacket(self, packet):
        self.packet_id += 1
        if self.packet_id > 4000000000:
          self.packet_id = 1
        packet.packet_id = self.packet_id

        from pokerengine.pokergame import init_i18n as pokergame_init_i18n
        # Note on special processing of locales on packet send:
        #    Ideally, clients would do their own locale work.  However, in
        #    particular when PokerExplain is in effect, some clients are
        #    requiring explanation strings coming from the server about
        #    what is happening in the game.  (Indeed, PokerExplain exists
        #    for precisely that scenario.)  Therefore, every time we send a
        #    packet via PokerAvatar, we need to make sure the local in
        #    poker-engine's pokergame localization is set properly to the
        #    localization requested by the client (iff. they have
        #    requested one via PacketPokerSetLocale).  Note that because
        #    global variables are effectively only file-wide, the _() that
        #    we create here propagates only as wide as this file.  the
        #    call to pokergame_init_i18n() is what actually changes the
        #    _() defined in pokergame.py.
        #
        #    It is in some ways overkill to redefine our own _() here,
        #    particularly because at the time of writing, we don't
        #    actually have localization strings in the functions in this
        #    file.  However, should we have them later, we'd obviously
        #    want those strings to be localized for the client, at least
        #    during packet sending.
        #
        #    Note that _ default value depends of locale installation
        #    by pokerservice, as
        #    http://docs.python.org/library/gettext.html point out,
        #    gettext.install installs the function _() in Python’s
        #    builtins namespace. Assigning it to self.localeFunc
        #    convert it to a global that is file wise (as pointed
        #    above).

        global _
        if self.localeFunc:
            # First, if our _() has never been defined, we simply set it to None
            try:
                self._avatarSavedUnder = _
            except NameError:
                self._avatarSavedUnder = None
            _ = self.localeFunc
            pokergameSavedUnder = pokergame_init_i18n('', self.localeFunc)
	if self.explain and not isinstance(packet, defer.Deferred) and packet.type != PACKET_ERROR:
            try:
                self.explain.explain(packet)
                packets = self.explain.forward_packets
            except:
                packets = [ PacketError(other_type = PACKET_NONE, message = format_exc()) ]
                if self.service.verbose >= 0:
                    self.message(packets[0].message)
                self.explain = None # disabling the explain instance
                                    # that issued the exception, as it
                                    # may be in an inconsistent state,
                                    # and used before the avatar
                                    # destruction
                self.service.forceAvatarDestroy(self)
	else:
	    packets = [ packet ]
        if self._queue_packets:
            self.extendPacketsQueue(packets)
        else:
	    for packet in packets:
                self.protocol.sendPacket(packet)
        if self.localeFunc:
            _ = self._avatarSavedUnder
            pokergame_init_i18n('', pokergameSavedUnder)

    # Below, we assign the method queueDeferred() is the same as
    # sendPacket().  Be careful not to indent the line below; if you
    # aren't paying attention, you might think it belongs inside the
    # previous function.  It doesn't. ...  Ok, so I never got over the
    # "whitespace indentation matters" thing in Python, and I get careless
    # sometimes, then after I do I proceed to write warning comments that
    # normal Python programmers probably don't need. :-p -- bkuhn
    queueDeferred = sendPacket
    
    def sendPacketVerbose(self, packet):
        if self.service.verbose > 1 and hasattr(packet, 'type') and packet.type != PACKET_PING or self.service.verbose > 5:
            self.message("sendPacket(%d): %s" % ( self.getSerial(), str(packet) ))
        self.sendPacket(packet)
        
    def packet2table(self, packet):
        if hasattr(packet, "game_id") and self.tables.has_key(packet.game_id):
            return self.tables[packet.game_id]
        else:
            return False

    def longpollDeferred(self):
        self._longpoll_deferred = defer.Deferred()
        d = self.flushLongPollDeferred()
        if not d.called:
            def longPollDeferredTimeout():
                self.longPollTimer = None
                self._longpoll_deferred = None
                packets = self.resetPacketsQueue()
                if self.service.verbose > 3:
                    self.message("longPollDeferredTimeout(%s): " % str(packets))
                d.callback(packets)
            self.longPollTimer = reactor.callLater(self.service.long_poll_timeout, longPollDeferredTimeout)
        return d

    def blockLongPollDeferred(self):
        self._block_longpoll_deferred = True
        
    def unblockLongPollDeferred(self):
        self._block_longpoll_deferred = False
        self.flushLongPollDeferred()

    def flushLongPollDeferred(self):
        if self._block_longpoll_deferred == False and self._longpoll_deferred and (len(self._packets_queue) > 0 or self._flush_next_longpoll):
            self._flush_next_longpoll = False
            packets = self.resetPacketsQueue()
            if self.service.verbose > 3:
                self.message("flushLongPollDeferred(%s): " % str(packets))
            d = self._longpoll_deferred
            self._longpoll_deferred = None
            d.callback(packets)
            if self.longPollTimer and self.longPollTimer.active():
                self.longPollTimer.cancel()
            return d
        return self._longpoll_deferred

    def longPollReturn(self):
        if self._longpoll_deferred:
            packets = self.resetPacketsQueue()
            if self.service.verbose > 3:
                self.message("longPollReturn(%s): " % str(packets))
            d = self._longpoll_deferred
            self._longpoll_deferred = None
            d.callback(packets)
            if self.longPollTimer and self.longPollTimer.active():
                self.longPollTimer.cancel()
        else:
            self._flush_next_longpoll = True
            
    def handleDistributedPacket(self, request, packet, data):
        resthost, game_id = self.service.packet2resthost(packet)
        if resthost:
            return self.distributePacket(packet, data, resthost, game_id)
        else:
            return self.handlePacketDefer(packet)

    def getOrCreateRestClient(self, resthost, game_id):
        #
        # no game_id means the request must be delegated for tournament
        # registration or creation. Not for table interaction.
        #
        ( host, port, path ) = resthost
        path += self.distributed_args
        if self.service.verbose > 3:
            self.message("getOrCreateRestClient(%s, %d, %s, %s)" % ( host, port, path, str(game_id) ))
        if game_id:
            if not self.game_id2rest_client.has_key(game_id):
                if self.service.verbose > 1:
                    self.message("getOrCreateRestClient(%s, %d, %s, %s): create" % ( host, port, path, str(game_id) ))
                self.game_id2rest_client[game_id] = PokerRestClient(host, port, path, longPollCallback = lambda packets: self.incomingDistributedPackets(packets, game_id), verbose = self.service.verbose)
            client = self.game_id2rest_client[game_id]
        else:
            client = PokerRestClient(host, port, path, longPollCallback = None, verbose = self.service.verbose)
        return client
            
    def distributePacket(self, packet, data, resthost, game_id):
        ( host, port, path ) = resthost
        client = self.getOrCreateRestClient(resthost, game_id)
        d = client.sendPacket(packet, data)
        d.addCallback(lambda packets: self.incomingDistributedPackets(packets, game_id))
        d.addCallback(lambda x: self.resetPacketsQueue())
        return d
            
    def incomingDistributedPackets(self, packets, game_id):
        if self.service.verbose > 3:
            self.message("incomingDistributedPackets(%s, %s)" % ( str(packets), str(game_id) ))
        self.blockLongPollDeferred()
        for packet in packets:
            self.sendPacket(packet)
        self.unblockLongPollDeferred()
        if game_id:
            if game_id not in self.tables and (not(self.explain) or not(self.explain.games.gameExists(game_id))):
                #
                # discard client if nothing pending and not in the list
                # of active tables
                #
                client = self.game_id2rest_client[game_id]
                if ( len(client.queue.callbacks) <= 0 or
                     client.pendingLongPoll ):
                    if self.service.verbose > 1:
                        self.message("incomingDistributedPackets: del %d" % game_id)
                    self.game_id2rest_client[game_id].clearTimeout()
                    del self.game_id2rest_client[game_id]

    def handlePacketDefer(self, packet):
        if self.service.verbose > 2:
            self.message("handlePacketDefer(%d): " % self.getSerial() + str(packet))

        self.queuePackets()

        if packet.type == PACKET_POKER_LONG_POLL:
            return self.longpollDeferred()

        self.handlePacketLogic(packet)
        packets = self.resetPacketsQueue()
        if len(packets) == 1 and isinstance(packets[0], defer.Deferred):
            d = packets[0]
            #
            # turn the return value into an List if it is not
            #
            def packetList(result):
                if type(result) == ListType:
                    return result
                else:
                    return [ result ]
            d.addCallback(packetList)
            return d
        else:
            return packets

    def handlePacket(self, packet):
        self.queuePackets()
        self.handlePacketLogic(packet)
        self.noqueuePackets()
        return self.resetPacketsQueue()

    def handlePacketLogic(self, packet):
        if self.service.verbose > 2 and packet.type != PACKET_PING:
            self.message("handlePacketLogic(%d): " % self.getSerial() + str(packet))

        if packet.type == PACKET_POKER_LONG_POLL_RETURN:
            self.longPollReturn()
            return

        if packet.type == PACKET_POKER_EXPLAIN:
            if self.setExplain(packet.value):
                self.sendPacketVerbose(PacketAck())
            else:
                self.sendPacketVerbose(PacketError(other_type = PACKET_POKER_EXPLAIN))
            return
        
        if packet.type == PACKET_POKER_SET_LOCALE:
            if self.setLocale(packet.locale):
                self.sendPacketVerbose(PacketAck())
            else:
                self.sendPacketVerbose(PacketPokerError(serial = self.getSerial(),
                                                        other_type = PACKET_POKER_SET_LOCALE))
            return

        if packet.type == PACKET_POKER_STATS_QUERY:
            self.sendPacketVerbose(self.service.stats(packet.string))
            return
        
        if packet.type == PACKET_POKER_MONITOR:
            self.sendPacketVerbose(self.service.monitor(self))
            return
        
        if packet.type == PACKET_PING:
            return
        
        if packet.type == PACKET_POKER_POLL:
            if packet.tourney_serial != 0 and not (packet.tourney_serial in self.tourneys):
                self.sendPacketVerbose(PacketPokerTourneyFinish(tourney_serial = packet.tourney_serial))
            return
        
        if not self.isAuthorized(packet.type):
            self.sendPacketVerbose(PacketAuthRequest())
            return

        if packet.type == PACKET_LOGIN:
            if self.isLogged():
                self.sendPacketVerbose(PacketError(other_type = PACKET_LOGIN,
                                                   code = PacketLogin.LOGGED,
                                                   message = "already logged in"))
            else:
                self.auth(packet)
            return

        if packet.type == PACKET_POKER_GET_PLAYER_PLACES:
            if packet.serial != 0:
                self.sendPacketVerbose(self.service.getPlayerPlaces(packet.serial))
            else:
                self.sendPacketVerbose(self.service.getPlayerPlacesByName(packet.name))
            return

        if packet.type == PACKET_POKER_GET_PLAYER_INFO:
            self.sendPacketVerbose(self.getPlayerInfo())
            return

        if packet.type == PACKET_POKER_GET_PLAYER_IMAGE:
            self.sendPacketVerbose(self.service.getPlayerImage(packet.serial))
            return

        if packet.type == PACKET_POKER_GET_USER_INFO:
            if self.getSerial() == packet.serial:
                self.getUserInfo(packet.serial)
            else:
                self.message("attempt to get user info for user %d by user %d" % ( packet.serial, self.getSerial() ))
            return

        elif packet.type == PACKET_POKER_GET_PERSONAL_INFO:
            if self.getSerial() == packet.serial:
                self.getPersonalInfo(packet.serial)
            else:
                self.message("attempt to get personal info for user %d by user %d" % ( packet.serial, self.getSerial() ))
                self.sendPacketVerbose(PacketAuthRequest())
            return

        elif packet.type == PACKET_POKER_PLAYER_INFO:
            if self.getSerial() == packet.serial:
                if self.setPlayerInfo(packet):
                    self.sendPacketVerbose(packet)
                else:
                    self.sendPacketVerbose(PacketError(other_type = PACKET_POKER_PLAYER_INFO,
                                                       code = PACKET_POKER_PLAYER_INFO,
                                                       message = "Failed to save set player information"))
            else:
                self.message("attempt to set player info for player %d by player %d" % ( packet.serial, self.getSerial() ))
            return
                
        elif packet.type == PACKET_POKER_PLAYER_IMAGE:
            if self.getSerial() == packet.serial:
                if self.service.setPlayerImage(packet):
                    self.sendPacketVerbose(PacketAck())
                else:
                    self.sendPacketVerbose(PacketError(other_type = PACKET_POKER_PLAYER_IMAGE,
                                                       code = PACKET_POKER_PLAYER_IMAGE,
                                                       message = "Failed to save set player image"))
            else:
                self.message("attempt to set player image for player %d by player %d" % ( packet.serial, self.getSerial() ))
            return
                
        elif packet.type == PACKET_POKER_PERSONAL_INFO:
            if self.getSerial() == packet.serial:
                self.setPersonalInfo(packet)
            else:
                self.message("attempt to set player info for player %d by player %d" % ( packet.serial, self.getSerial() ))
            return

        elif packet.type == PACKET_POKER_CASH_IN:
            if self.getSerial() == packet.serial:
                self.queueDeferred(self.service.cashIn(packet))
            else:
                self.message("attempt to cash in for user %d by user %d" % ( packet.serial, self.getSerial() ))
                self.sendPacketVerbose(PacketPokerError(serial = self.getSerial(),
                                                        other_type = PACKET_POKER_CASH_IN))
            return

        elif packet.type == PACKET_POKER_CASH_OUT:
            if self.getSerial() == packet.serial:
                self.sendPacketVerbose(self.service.cashOut(packet))
            else:
                self.message("attempt to cash out for user %d by user %d" % ( packet.serial, self.getSerial() ))
                self.sendPacketVerbose(PacketPokerError(serial = self.getSerial(),
                                                        other_type = PACKET_POKER_CASH_OUT))
            return

        elif packet.type == PACKET_POKER_CASH_QUERY:
            self.sendPacketVerbose(self.service.cashQuery(packet))
            return

        elif packet.type == PACKET_POKER_CASH_OUT_COMMIT:
            self.sendPacketVerbose(self.service.cashOutCommit(packet))
            return

        elif packet.type == PACKET_POKER_SET_ROLE:
            self.sendPacketVerbose(self.setRole(packet))
            return 

        elif ( packet.type == PACKET_POKER_SET_ACCOUNT or
               packet.type == PACKET_POKER_CREATE_ACCOUNT ):
            if self.getSerial() != packet.serial:
                packet.serial = 0
            self.sendPacketVerbose(self.service.setAccount(packet))
            return

        elif packet.type == PACKET_POKER_CREATE_TOURNEY:
            if self.getSerial() == packet.serial:
                self.sendPacketVerbose(self.service.tourneyCreate(packet))
            else:
                self.message("attempt to create tourney for player %d by player %d" % ( packet.serial, self.getSerial() ))
                self.sendPacketVerbose(PacketAuthRequest())
            return

        if packet.type == PACKET_POKER_TOURNEY_SELECT:
            ( playerCount, tourneyCount ) = self.service.tourneyStats()
            tourneyList = PacketPokerTourneyList(players = playerCount,
                                              tourneys = tourneyCount)
            tourneys = self.service.tourneySelect(packet.string)
            for tourney in tourneys:
                tourneyList.packets.append(PacketPokerTourney(**tourney))
            self.sendPacketVerbose(tourneyList)
            tourneyInfo = self.service.tourneySelectInfo(packet, tourneys)
            if tourneyInfo:
                self.sendPacketVerbose(tourneyInfo)
            return
        
        elif packet.type == PACKET_POKER_TOURNEY_REQUEST_PLAYERS_LIST:
            self.sendPacketVerbose(self.service.tourneyPlayersList(packet.game_id))
            return

        elif packet.type == PACKET_POKER_GET_TOURNEY_MANAGER:
            self.sendPacketVerbose(self.service.tourneyManager(packet.tourney_serial))
            return

        elif packet.type == PACKET_POKER_TOURNEY_REGISTER:
            if self.getSerial() == packet.serial:
                self.service.autorefill(packet.serial)
                self.service.tourneyRegister(packet)
                self.tourneyUpdates(packet.serial)
            else:
                self.message("attempt to register in tournament %d for player %d by player %d" % ( packet.game_id, packet.serial, self.getSerial() ))
            return
            
        elif packet.type == PACKET_POKER_TOURNEY_UNREGISTER:
            if self.getSerial() == packet.serial:
                self.sendPacketVerbose(self.service.tourneyUnregister(packet))
                self.tourneyUpdates(packet.serial)
            else:
                self.message("attempt to unregister from tournament %d for player %d by player %d" % ( packet.game_id, packet.serial, self.getSerial() ))
            return
            
        elif packet.type == PACKET_POKER_TABLE_REQUEST_PLAYERS_LIST:
            self.listPlayers(packet)
            return

        elif packet.type == PACKET_POKER_TABLE_SELECT:
            self.listTables(packet)
            return

        elif packet.type == PACKET_POKER_HAND_SELECT:
            self.listHands(packet, self.getSerial())
            return

        elif packet.type == PACKET_POKER_HAND_HISTORY:
            if self.getSerial() == packet.serial:
                self.sendPacketVerbose(self.service.getHandHistory(packet.game_id, packet.serial))
            else:
                self.message("attempt to get history of player %d by player %d" % ( packet.serial, self.getSerial() ))
            return

        elif packet.type == PACKET_POKER_HAND_SELECT_ALL:
            self.listHands(packet, None)
            return

        elif packet.type == PACKET_POKER_TABLE_JOIN:
            self.performPacketPokerTableJoin(packet)

            return

        elif packet.type == PACKET_POKER_TABLE_PICKER:
            self.performPacketPokerTablePicker(packet)
            return

        table = self.packet2table(packet)
            
        if table:
            if self.service.verbose > 2:
                self.message("packet for table " + str(table.game.id))
            game = table.game

            if packet.type == PACKET_POKER_READY_TO_PLAY:
                if self.getSerial() == packet.serial:
                    self.sendPacketVerbose(table.readyToPlay(packet.serial))
                else:
                    self.message("attempt to set ready to play for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_PROCESSING_HAND:
                if self.getSerial() == packet.serial:
                    if not self.bugous_processing_hand:
                        self.sendPacketVerbose(table.processingHand(packet.serial))
                    else:
                        self.sendPacketVerbose(PacketPokerError(game_id = game.id,
                                                                serial = self.getSerial(),
                                                                other_type = PACKET_POKER_PROCESSING_HAND))
                else:
                    self.message("attempt to set processing hand for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_START:
                if not game.isEndOrNull():
                    self.message("player %d tried to start a new game while in game " % self.getSerial())
                    self.sendPacketVerbose(PacketPokerStart(game_id = game.id))
                elif self.service.shutting_down:
                    self.message("server shutting down")
                elif table.owner != 0:
                    if self.getSerial() != table.owner:
                        self.message("player %d tried to start a new game but is not the owner of the table" % self.getSerial())
                        self.sendPacketVerbose(PacketPokerStart(game_id = game.id))
                    else:
                        table.beginTurn()
                else:
                    self.message("player %d tried to start a new game but is not the owner of the table" % self.getSerial())

            elif packet.type == PACKET_POKER_SEAT:
                self.performPacketPokerSeat(packet, table, game)

            elif packet.type == PACKET_POKER_BUY_IN:
                self.performPacketPokerBuyIn(packet, table, game)

            elif packet.type == PACKET_POKER_REBUY:
                if self.getSerial() == packet.serial:
                    self.service.autorefill(packet.serial)
                    if not table.rebuyPlayerRequest(self, packet.amount):
                        self.sendPacketVerbose(PacketPokerError(game_id = game.id,
                                                                serial = packet.serial,
                                                                other_type = PACKET_POKER_REBUY))
                else:
                    self.message("attempt to rebuy for player %d by player %d" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_CHAT:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    table.chatPlayer(self, packet.serial, packet.message[:128])
                else:
                    self.message("attempt chat for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_PLAYER_LEAVE:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    table.leavePlayer(self, packet.serial)
                else:
                    self.message("attempt to leave for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_SIT:
                self.performPacketPokerSit(packet, table)
                
            elif packet.type == PACKET_POKER_SIT_OUT:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:

                    table.sitOutPlayer(self, packet.serial)
                else:
                    self.message("attempt to sit out for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))
                
            elif packet.type == PACKET_POKER_AUTO_BLIND_ANTE:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    table.autoBlindAnte(self, packet.serial, True)
                else:
                    self.message("attempt to set auto blind/ante for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))
                
            elif packet.type == PACKET_POKER_NOAUTO_BLIND_ANTE:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    table.autoBlindAnte(self, packet.serial, False)
                else:
                    self.message("attempt to set auto blind/ante for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))
            
            elif packet.type == PACKET_POKER_AUTO_MUCK:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    if table.game.getPlayer(packet.serial):
                        table.game.autoMuck(packet.serial, packet.auto_muck)
                else:
                    self.message("attempt to set auto muck for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() )             )
                
            elif packet.type == PACKET_POKER_MUCK_ACCEPT:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    table.muckAccept(self, packet.serial)
                else:
                    self.message("attempt to accept muck for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))
                    
            elif packet.type == PACKET_POKER_MUCK_DENY:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    table.muckDeny(self, packet.serial)
                else:
                    self.message("attempt to deny muck for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))
                
            elif packet.type == PACKET_POKER_BLIND:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    game.blind(packet.serial)
                else:
                    self.message("attempt to pay the blind of player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_WAIT_BIG_BLIND:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    game.waitBigBlind(packet.serial)
                else:
                    self.message("attempt to wait for big blind of player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_ANTE:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    game.ante(packet.serial)
                else:
                    self.message("attempt to pay the ante of player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_LOOK_CARDS:
                table.broadcast(packet)
                
            elif packet.type == PACKET_POKER_FOLD:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    
                    game.fold(packet.serial)
                else:
                    self.message("attempt to fold player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_CALL:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    
                    game.call(packet.serial)
                else:
                    self.message("attempt to call for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_RAISE:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    
                    game.callNraise(packet.serial, packet.amount)
                else:
                    self.message("attempt to raise for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_CHECK:
                if self.getSerial() == packet.serial or self.getSerial() == table.owner:
                    
                    game.check(packet.serial)
                else:
                    self.message("attempt to check for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))

            elif packet.type == PACKET_POKER_TABLE_QUIT:
                table.quitPlayer(self, self.getSerial())

            elif packet.type == PACKET_POKER_HAND_REPLAY:
                table.handReplay(self, packet.serial)

            table.update()

        elif not table and packet.type == PACKET_POKER_HAND_REPLAY:
            table = self.createTable(PacketPokerTable(
                        reason = PacketPokerTable.REASON_HAND_REPLAY))
            if table:
                table.handReplay(self, packet.serial)

        elif packet.type == PACKET_POKER_TABLE:
            packet.reason = PacketPokerTable.REASON_TABLE_CREATE
            table = self.createTable(packet)
            if table:
                table.joinPlayer(self, self.getSerial(),
                                 reason = PacketPokerTable.REASON_TABLE_CREATE)
            
        elif packet.type == PACKET_QUIT:
            for table in self.tables.values():
                table.quitPlayer(self, self.getSerial())

        elif packet.type == PACKET_LOGOUT:
            if self.isLogged():
                for table in self.tables.values():
                    table.quitPlayer(self, self.getSerial())
                self.logout()
            else:
                self.sendPacketVerbose(PacketError(code = PacketLogout.NOT_LOGGED_IN,
                                                   message = "Not logged in",
                                                   other_type = PACKET_LOGOUT))

    # The "perform" methods below are designed so that the a minimal
    # amount of code related to receiving a packet that appears in the
    # handlePacketLogic() giant if statement above.  The primary motive
    # for this is for things like PacketTablePicker(), that need to
    # perform operations *as if* the client has sent additional packets.
    # The desire is to keep completely parity between what the individual
    # packets do by themselves, and what "super-packets" like
    # PacketTablePicker() do.  A secondary benefit is that it makes that
    # giant if statement in handlePacketLogic() above a bit smaller.
    # -------------------------------------------------------------------------
    def performPacketPokerTableJoin(self, packet, table = None,
                                    deprecatedEmptyTableBehavior = True,
                                    requestorPacketType = PACKET_POKER_TABLE_JOIN,
                                    reason = PacketPokerTable.REASON_TABLE_JOIN):
        """Perform the operations that must occur when a
        PACKET_POKER_TABLE_JOIN is received."""
        
        if not table:
            table = self.service.getTable(packet.game_id)
        if table:
            self.removeGamePacketsQueue(packet.game_id)
            if not table.joinPlayer(self, self.getSerial(),
                                    reason = reason):
                if deprecatedEmptyTableBehavior:
                    self.sendPacketVerbose(PacketPokerTable(reason = reason))
                self.sendPacketVerbose(
                  PacketPokerError(code = PacketPokerTableJoin.GENERAL_FAILURE,
                                   message = "Unable to join table for unknown reason",
                                   other_type = requestorPacketType,
                                   serial     = self.getSerial(),
                                   game_id    = 0))
        return table
    # -------------------------------------------------------------------------
    def performPacketPokerSeat(self, packet, table, game):
        """Perform the operations that must occur when a PACKET_POKER_SEAT
        is received."""

        if PacketPokerRoles.PLAY not in self.roles:
            self.sendPacketVerbose(PacketPokerError(game_id = game.id,
                                                    serial = packet.serial,
                                                    code = PacketPokerSeat.ROLE_PLAY,
                                                    message = "PACKET_POKER_ROLES must set the role to PLAY before chosing a seat",
                                                    other_type = PACKET_POKER_SEAT))
            return False
        elif ( self.getSerial() == packet.serial or self.getSerial() == table.owner ):
            if not table.seatPlayer(self, packet.serial, packet.seat):
                packet.seat = -1
            else:
                packet.seat = game.getPlayer(packet.serial).seat
            self.getUserInfo(packet.serial)
            self.sendPacketVerbose(packet)
            return (packet.seat != -1)
        else:
            self.message("attempt to get seat for player '%s' by player '%s' that is not the owner of the game" % ( str(packet.serial), str(self.getSerial()) ))
            return False
    # -------------------------------------------------------------------------
    def performPacketPokerBuyIn(self, packet, table, game):
        if self.getSerial() == packet.serial:
            self.service.autorefill(packet.serial)
            if not table.buyInPlayer(self, packet.amount):
                self.sendPacketVerbose(PacketPokerError(game_id = game.id,
                                                        serial = packet.serial,
                                                        other_type = PACKET_POKER_BUY_IN))
                return False
            else:
                self.updateBuyinLimits(game)
                return True
        else:
            self.message("attempt to bring money for player %d by player %d" % ( packet.serial, self.getSerial() ))
            return False
    # -------------------------------------------------------------------------
    def performPacketPokerSit(self, packet, table):
        if self.getSerial() == packet.serial or self.getSerial() == table.owner:
            table.sitPlayer(self, packet.serial)
            return True
        else:
            self.message("attempt to sit back for player %d by player %d that is not the owner of the game" % ( packet.serial, self.getSerial() ))
            return False
    # -------------------------------------------------------------------------
    def performPacketPokerTablePicker(self, packet):
        mySerial = self.getSerial()
        if mySerial != packet.serial:
            errMsg = "attempt to run table picker for player %d by player %d" % ( packet.serial, mySerial )
            self.message(errMsg)
            self.sendPacketVerbose(
                PacketPokerError(code       = PacketPokerTableJoin.GENERAL_FAILURE,
                                 message    = errMsg,
                                 other_type = PACKET_POKER_TABLE_PICKER,
                                 serial     = mySerial,
                                 game_id    = 0))
        else:
            # Call autorefill() first before checking for a table,
            # since the amount of money we have left will impact the
            # table selection, and in a play-money scenario, we want
            # to have whatever play-money we can get before picking.
            self.service.autorefill(packet.serial)

            table = self.service.getTableBestByCriteria(mySerial,
                      min_players = packet.min_players, currency_serial = packet.currency_serial,
                      variant = packet.variant, betting_structure = packet.betting_structure)

            if not table:
                # If we cannot find a table, tell user we were unable to
                # find a table matching their criteria
                self.sendPacketVerbose(
                  PacketPokerError(code       = PacketPokerTableJoin.GENERAL_FAILURE,
                                   message    = "No table found matching given criteria",
                                   other_type = PACKET_POKER_TABLE_PICKER,
                                   serial     = mySerial,
                                   game_id    = 0))
            elif not table.game.canAddPlayer(mySerial):
                # If the table we found just can't take us, tell user we
                # could not add them.
                self.sendPacketVerbose(
                  PacketPokerError(code      = PacketPokerTableJoin.GENERAL_FAILURE,
                                   message   = "Found matching table, but unable to join it.",
                                   other_type = PACKET_POKER_TABLE_PICKER,
                                   serial     = mySerial,
                                   game_id    = table.game.id))
            else:
                # Otherwise, we perform the sequence of operations
                # that is defined by the semantics of this packet in
                # pokerpacket.py.  Basically, we perform:
                #   PacketTableJoin(), and if it succeeds,
                #   PacketPokerSeat(), and if it succeeds,
                #   We figure out our best buy-in choice, buyIn, then perform:
                #   PacketPokerBuyIn(amount = buyIn), and if it succeeds, 
                #   PacketPokerSit()
                if self.performPacketPokerTableJoin(
                     PacketPokerTableJoin(serial = mySerial,
                                          game_id = table.game.id), table,
                       deprecatedEmptyTableBehavior = False,
                       reason = PacketPokerTable.REASON_TABLE_PICKER):

                    # Giving no seat argument at all for the packet should cause
                    # us to get any available seat.
                    if self.performPacketPokerSeat(
                        PacketPokerSeat(serial = mySerial, game_id = table.game.id),
                        table, table.game):

                        # Next, determine if player can afford the "best"
                        # buy in.  If the player can't, give them the
                        # minimum buyin.

                        buyIn = table.game.bestBuyIn()
                        if self.service.getMoney(mySerial, table.currency_serial) < buyIn:
                            buyIn = table.game.buyIn(mySerial)
                            # No need to check above if we have that,
                            # since our answer on this table came from
                            # self.service.getTableByBestCriteria(), which
                            # promises us that we have at least minimum.
                        if self.performPacketPokerBuyIn(
                            PacketPokerBuyIn(serial = mySerial, amount = buyIn,
                                 game_id = table.game.id), table, table.game):
                            if packet.auto_blind_ante:
                                table.autoBlindAnte(self, packet.serial, True)
                            self.performPacketPokerSit(
                               PacketPokerSit(serial = mySerial, game_id = table.game.id),
                               table)
                            table.update()

    # -------------------------------------------------------------------------
    def setPlayerInfo(self, packet):
        self.user.url = packet.url
        self.user.outfit = packet.outfit
        return self.service.setPlayerInfo(packet)

    def setPersonalInfo(self, packet):
        self.personal_info = packet
        self.service.setPersonalInfo(packet)

    def setRole(self, packet):
        if packet.roles not in PacketPokerRoles.ROLES:
            return PacketError(code = PacketPokerSetRole.UNKNOWN_ROLE,
                               message = "role %s is unknown (roles = %s)" % ( packet.roles, PacketPokerRoles.ROLES),
                               other_type = PACKET_POKER_SET_ROLE)

        if packet.roles in self.roles:
            return PacketError(code = PacketPokerSetRole.NOT_AVAILABLE,
                               message = "another client already has role %s" % packet.roles,
                               other_type = PACKET_POKER_SET_ROLE)
        self.roles.add(packet.roles)
        return PacketPokerRoles(serial = packet.serial,
                                roles = join(self.roles, " "))
            
    def getPlayerInfo(self):
        if self.user.isLogged():
            return PacketPokerPlayerInfo(serial = self.getSerial(),
                                         name = self.getName(),
                                         url = self.user.url,
                                         outfit = self.user.outfit)
        else:
            return PacketError(code = PacketPokerGetPlayerInfo.NOT_LOGGED,
                               message = "Not logged in",
                               other_type = PACKET_POKER_GET_PLAYER_INFO)
    
    def listPlayers(self, packet):
        table = self.service.getTable(packet.game_id)
        if table:
            players = table.listPlayers()
            self.sendPacketVerbose(PacketPokerPlayersList(game_id = packet.game_id,
                                                          players = players))
        
    def listTables(self, packet):
        packets = []
        for table in self.service.listTables(packet.string, self.getSerial()):
            packet = PacketPokerTable(id = int(table['serial']),
                                      name = table['name'],
                                      variant = table['variant'],
                                      betting_structure = table['betting_structure'],
                                      seats = int(table['seats']),
                                      players = int(table['players']),
                                      hands_per_hour = int(table['hands_per_hour']),
                                      average_pot = int(table['average_pot']),
                                      percent_flop = int(table['percent_flop']),
                                      player_timeout = int(table['player_timeout']),
                                      muck_timeout = int(table['muck_timeout']),
                                      observers = int(table['observers']),
                                      waiting = int(table['waiting']),
                                      skin = table['skin'],
                                      currency_serial = int(table['currency_serial']),
                                      reason = PacketPokerTable.REASON_TABLE_LIST,
                                      )
            packet.tourney_serial = int(table['tourney_serial'])
            packets.append(packet)
        ( players, tables ) = self.service.statsTables()
        self.sendPacketVerbose(PacketPokerTableList(players = players,
                                                    tables = tables,
                                                    packets = packets))

    def listHands(self, packet, serial):
        if packet.type != PACKET_POKER_HAND_SELECT_ALL:
            start = packet.start
            count = min(packet.count, 200)
        if serial != None:
            select_list = "select distinct hands.serial from hands,user2hand "
            select_total = "select count(distinct hands.serial) from hands,user2hand "
            where  = " where user2hand.hand_serial = hands.serial "
            where += " and user2hand.user_serial = %d " % serial
            if packet.string:
                where += " and " + packet.string
        else:
            select_list = "select serial from hands "
            select_total = "select count(serial) from hands "
            where = ""
            if packet.string:
                where = "where " + packet.string
        where += " order by hands.serial desc"
        if packet.type != PACKET_POKER_HAND_SELECT_ALL:
            limit = " limit %d,%d " % ( start, count )
        else:
            limit = '';
        (total, hands) = self.service.listHands(select_list + where + limit, select_total + where)
        if packet.type == PACKET_POKER_HAND_SELECT_ALL:
            start = 0
            count = total
        self.sendPacketVerbose(PacketPokerHandList(string = packet.string,
                                                   start = start,
                                                   count = count,
                                                   hands = hands,
                                                   total = total))

    def createTable(self, packet):
        table = self.service.createTable(self.getSerial(), {
            "seats": packet.seats,
            "name": packet.name,
            "variant": packet.variant,
            "betting_structure": packet.betting_structure,
            "player_timeout": packet.player_timeout,
            "muck_timeout": packet.muck_timeout,
            "currency_serial": packet.currency_serial,
            "skin": packet.skin,
            "reason" : packet.reason})
        if not table:
            self.sendPacket(PacketPokerTable(reason = packet.reason))
        return table            

    def updateBuyinLimits(self, game):
        serial = self.getSerial()
        self.sendPacketVerbose(PacketPokerBuyInLimits(game_id = game.id,
                                                      min = game.buyIn(serial),
                                                      max = game.maxBuyIn(serial),
                                                      best = game.bestBuyIn(serial),
                                                      rebuy_min = game.minMoney()))

    def join(self, table, reason = ""):
        game = table.game
        
        self.tables[game.id] = table

        packet = table.toPacket()
        packet.reason = reason
        self.sendPacketVerbose(packet)
        self.updateBuyinLimits(game)
        self.sendPacketVerbose(PacketPokerBatchMode(game_id = game.id))
        nochips = 0
        for player in game.serial2player.values():
            player_info = table.getPlayerInfo(player.serial)
            self.sendPacketVerbose(PacketPokerPlayerArrive(game_id = game.id,
                                                           serial = player.serial,
                                                           name = player_info.name,
                                                           url = player_info.url,
                                                           outfit = player_info.outfit,
                                                           blind = player.blind,
                                                           remove_next_turn = player.remove_next_turn,
                                                           sit_out = player.sit_out,
                                                           sit_out_next_turn = player.sit_out_next_turn,
                                                           auto = player.auto,
                                                           auto_blind_ante = player.auto_blind_ante,
                                                           wait_for = player.wait_for,
                                                           seat = player.seat))
            if self.service.has_ladder:
                packet = self.service.getLadder(game.id, table.currency_serial, player.serial)
                if packet.type == PACKET_POKER_PLAYER_STATS:
                    self.sendPacketVerbose(packet)
            if not game.isPlaying(player.serial):
                self.sendPacketVerbose(PacketPokerPlayerChips(game_id = game.id,
                                                              serial = player.serial,
                                                              bet = nochips,
                                                              money = player.money))
                if game.isSit(player.serial):
                    self.sendPacketVerbose(PacketPokerSit(game_id = game.id,
                                                          serial = player.serial))
                if player.isAuto():
                    self.sendPacketVerbose(PacketPokerAutoFold(game_id = game.id,
                                                          serial = player.serial))                    

        self.sendPacketVerbose(PacketPokerSeats(game_id = game.id,
                                                seats = game.seats()))
        if not game.isEndOrNull():
            #
            # If a game is running, replay it.
            #
            # If a player reconnects, his serial number will match
            # the serial of some packets, for instance the cards
            # of his hand. We rely on private2public to turn the
            # packet containing cards custom cards into placeholders
            # in this case.
            #
            for past_packet in table.history2packets(game.historyGet(), game.id, table.createCache()):
                self.sendPacketVerbose(table.private2public(past_packet, self.getSerial()))
        self.sendPacketVerbose(PacketPokerStreamMode(game_id = game.id))

    def addPlayer(self, table, seat):
        serial = self.getSerial()
        game = table.game
        if game.addPlayer(serial, seat):
            player = game.getPlayer(serial)
            player.setUserData(DEFAULT_PLAYER_USER_DATA.copy())
        table.sendNewPlayerInformation(serial)
        
    def connectionLost(self, reason):
        if self.service.verbose > 3:
            self.message("connection lost for %s/%d: %s" % ( self.getName(), self.getSerial(), reason ))
        for table in self.tables.values():
            table.disconnectPlayer(self, self.getSerial())
        self.logout()

    def getUserInfo(self, serial):
        self.service.autorefill(serial)
        self.sendPacketVerbose(self.service.getUserInfo(serial))

    def getPersonalInfo(self, serial):
        self.service.autorefill(serial)
        self.sendPacketVerbose(self.service.getPersonalInfo(serial))

    def removePlayer(self, table, serial):
        game = table.game
        player = game.getPlayer(serial)
        seat = player and player.seat
        avatars = table.avatar_collection.get(serial)
        self_is_last_avatar = len(avatars) == 1 and avatars[0] == self
        if self_is_last_avatar and game.removePlayer(serial):
            #
            # If the player is not in a game, the removal will be effective
            # immediately and can be announced to all players, including
            # the one that will be removed.
            #
            packet = PacketPokerPlayerLeave(game_id = game.id, serial = serial, seat = seat)
            self.sendPacketVerbose(packet)
            table.broadcast(packet)
            return True
        else:
            return False

    def sitPlayer(self, table, serial):
        game = table.game

        if table.isOpen():
            #
            # It does not harm to sit if already sit and it
            # resets the autoPlayer/wait_for flag.
            #
            if game.sit(serial):
                self.message("game.sit success - game_id: %d, serial: %d" % (game.id, serial))
                table.broadcast(PacketPokerSit(game_id = game.id,
                                               serial = serial))
            else:
                self.message("game.sit NOT success - game_id: %d, serial: %d" % (game.id, serial))
        else:
            game.comeBack(serial)
            table.broadcast(PacketPokerSit(game_id = game.id,
                                           serial = serial))


    def sitOutPlayer(self, table, serial):
        game = table.game
        if table.isOpen():
            if game.sitOutNextTurn(serial):
                table.broadcast(PacketPokerSitOut(game_id = game.id,
                                                  serial = serial))
        else:
            game.autoPlayer(serial)
            table.broadcast(PacketPokerAutoFold(game_id = game.id,
                                                serial = serial))

    def autoBlindAnte(self, table, serial, auto):
        game = table.game
        if game.isTournament():
            return
        game.getPlayer(serial).auto_blind_ante = auto
        if auto:
            self.sendPacketVerbose(PacketPokerAutoBlindAnte(game_id = game.id,
                                                            serial = serial))
        else:
            self.sendPacketVerbose(PacketPokerNoautoBlindAnte(game_id = game.id,
                                                              serial = serial))
                                                              
    def setMoney(self, table, amount):
        game = table.game

        if game.payBuyIn(self.getSerial(), amount):
            player = game.getPlayer(self.getSerial())
            nochips = 0
            table.broadcast(PacketPokerPlayerChips(game_id = game.id,
                                                   serial = self.getSerial(),
                                                   bet = nochips,
                                                   money = player.money))
            return True
        else:
            return False
        

########NEW FILE########
__FILENAME__ = pokerbonus
#
# Copyright (C) 2011 Pavel Karoukin <pavel@karoukin.us>
#                1st May str., Borisov, Belarus, 222518
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Pavel Karoukin <pavel@karoukin.us>
#
# 

import math

class PokerBonus:

    def __init__(self):

        self.position_rules = {
            2: { 0: 120, 1: 10 },
            3: { 0: 100, 1: 20, 2: 10 },
            4: { 0: 80, 1: 40, 2: 20, 3: 10 },
            5: { 0: 80, 1: 60, 2: 40, 3: 20, 4: 10 },
            6: { 0: 100, 1: 80, 2: 60, 3: 40, 4: 20, 5: 10 },
            7: { 0: 120, 1: 100, 2: 80, 3: 60, 4: 40, 5: 20, 6: 10 },
            8: { 0: 120, 1: 100, 2: 80, 3: 60, 4: 40, 5: 20, 6: 10, 7: 10 },
            9: { 0: 120, 1: 100, 2: 80, 3: 60, 4: 40, 5: 20, 6: 10, 7: 10, 8: 10 },
            10: { 0: 120, 1: 100, 2: 80, 3: 60, 4: 40, 5: 20, 6: 10, 7: 10, 8: 10, 9: 10 }
        }
        
    
    def message(self, string):
        print "PokerBonus: " + string

    def getPoints(self, serial, game, rake):

        points = 0
        
        # Position-based bonus points calculation.
        player_position = game.player_list.index(serial)
        total_players = len(game.player_list)

        position_bonus = self.position_rules[total_players][player_position]
        position_points = float(rake) / 100 * position_bonus

        self.message(
            "Serial: %d in position %d/%d, game: %d, rake: %d, position points awarded: %d with %.4f%% bonus" % 
            ( serial, player_position, total_players, game.id, rake, position_points, position_bonus )
        )

        points += position_points
        
        return points

########NEW FILE########
__FILENAME__ = pokerbot
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#       
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Henry Precheur <henry@precheur.org> (2004)
#
import sys
sys.path.insert(0, "..")

from os import popen
from os.path import exists
from string import split, rstrip
from random import randint
from traceback import print_exc

from twisted.application import internet, service, app
from twisted.internet import pollreactor
if not sys.modules.has_key('twisted.internet.reactor'):
    print "installing poll reactor"
    pollreactor.install()
else:
    print "poll reactor already installed"
from twisted.internet import reactor
from twisted.python import components
from twisted.persisted import sob
from twisted.internet import error

from pokerengine.pokertournament import *

from pokernetwork import pokernetworkconfig
from pokernetwork.pokerclientpackets import *
from pokernetwork.pokerclient import PokerClientFactory, PokerClientProtocol
from pokernetwork.user import checkName
from pokernetwork.pokerbotlogic import StringGenerator, NoteGenerator, PokerBot

class PokerBotProtocol(PokerClientProtocol):

    def protocolEstablished(self):
        PokerClientProtocol.protocolEstablished(self)
        self.setPrefix(self.user.name + " ")
        if self.factory.disconnect_delay:
            delay = randint(*self.factory.disconnect_delay)
            print self.user.name + ": will disconnect in %d seconds (for kicks)" % delay
            reactor.callLater(delay, lambda: self.disconnectMyself(self.user.name))

    def disconnectMyself(self, name):
        if name == self.user.name:
            if self.factory.can_disconnect:
                self.factory.disconnected_volontarily = True
                print self.user.name + ": disconnecting (for kicks)"
                self.transport.loseConnection()
            else:
                delay = randint(*self.factory.disconnect_delay)
                print self.user.name + ": scheduled disconnection not allowed, will try again in %d seconds (for kicks)" % delay
                reactor.callLater(delay, lambda: self.disconnectMyself(self.user.name))
        
class PokerBotFactory(PokerClientFactory):

    string_generator = None

    def __init__(self, *args, **kwargs):
        PokerClientFactory.__init__(self, *args, **kwargs)
        self.protocol = PokerBotProtocol
        self.join_info = kwargs["join_info"]
        self.serial = kwargs["serial"]
        settings = kwargs["settings"]
        self.level = settings.headerGetInt("/settings/@level")
        self.reconnect = settings.headerGet("/settings/@reconnect") == "yes"
        self.rebuy = settings.headerGet("/settings/@rebuy") == "yes"
        self.watch = settings.headerGet("/settings/@watch") == "yes"
        self.cash_in = settings.headerGet("/settings/@cash_in") != "no"
        self.wait = settings.headerGetInt("/settings/@wait")
        self.disconnect_delay = settings.headerGet("/settings/@disconnect_delay")
        if self.disconnect_delay:
            self.disconnect_delay = tuple(map(lambda x: int(x), split(self.disconnect_delay, ",")))
        self.reconnect_delay = settings.headerGet("/settings/@reconnect_delay")
        if self.reconnect_delay:
            self.reconnect_delay = tuple(map(lambda x: int(x), split(self.reconnect_delay, ",")))
        self.currency = settings.headerGetInt("/settings/currency")
        self.currency_id = settings.headerGet("/settings/currency/@id")
        self.verbose = settings.headerGetInt("/settings/@verbose")
        self.bot = None
        self.went_broke = False
        self.disconnected_volontarily = False
        self.can_disconnect = True
        self.name = PokerBotFactory.string_generator.getName()
        self.password = PokerBotFactory.string_generator.getPassword()
        
    def buildProtocol(self, addr):
        protocol = PokerClientFactory.buildProtocol(self, addr)
        pokerbot = PokerBot(self)
        protocol._poll = False
        protocol.registerHandler(True, PACKET_BOOTSTRAP, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_ERROR, pokerbot._handleConnection)
        protocol.registerHandler('outbound', PACKET_SERIAL, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_BATCH_MODE, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_STREAM_MODE, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_ERROR, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_TABLE_LIST, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_TOURNEY_LIST, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_WIN, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_PLAYER_LEAVE, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_SEAT, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_BLIND_REQUEST, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_SELF_IN_POSITION, pokerbot._handleConnection)
        protocol.registerHandler(True, PACKET_POKER_SELF_LOST_POSITION, pokerbot._handleConnection)
        return protocol

    def clientConnectionFailed(self, connector, reason):
        print "Failed to establish connection to table %s" % self.join_info["name"]
        print reason
        self.bot.parent.removeService(self.bot)
        
    def clientConnectionLost(self, connector, reason):
        reconnect = False
        if self.reconnect:
            if self.went_broke:
                self.name = PokerBotFactory.string_generator.getName()
                print "Re-establishing (get more money)."
                self.went_broke = False
                reactor.callLater(self.wait, connector.connect)
            elif self.disconnected_volontarily:
                delay = randint(*self.reconnect_delay)
                print self.name + " Re-establishing in %d seconds." % delay
                self.disconnected_volontarily = False
                reactor.callLater(delay, connector.connect)
                reconnect = True
        else:
            print "The bot server connection to %s was closed" % self.join_info["name"]
            if not reason.check(error.ConnectionDone):
                print reason
        if not reconnect:
            self.bot.parent.removeService(self.bot)

class Bots(service.MultiService):

    def setSettings(self, settings):
        self.count = 0
        self.settings = settings
        self.verbose = settings.headerGetInt("/settings/@verbose")

    def addService(self, _service):
        service.MultiService.addService(self, _service)
        self.check()

    def removeService(self, _service):
        service.MultiService.removeService(self, _service)
        self.check()

    def check(self):
        if self.verbose > 1:
            print "%d bots currently active" % len(self.services)
        if len(self.services) <= 0 and reactor.running:
            reactor.callLater(0, reactor.stop)

def Application(name, uid=None, gid=None):
    """Return a compound class.

    Return an object supporting the C{IService}, C{IServiceCollection},
    C{IProcess} and C{sob.IPersistable} interfaces, with the given
    parameters. Always access the return value by explicit casting to
    one of the interfaces.
    """
    ret = components.Componentized()
    for comp in (Bots(), sob.Persistent(ret, name), service.Process(uid, gid)):
        ret.addComponent(comp, ignoreClass=1)
    service.IService(ret).setName(name)
    return ret

class Bot(internet.TCPClient):

    def stopService(self):
        #
        # If the connection is still available (i.e. the bots
        # were stopped because of a SIGINT signal), properly
        # close it before exiting.
        #
        if(hasattr(self._connection.transport, "protocol")):
            protocol = self._connection.transport.protocol
            #
            # If the connection fails, the transport exists but
            # the protocol is not set
            #
            if protocol:
                self._connection.transport.protocol.sendPacket(PacketQuit())
        return internet.TCPClient.stopService(self)

def makeApplication(argv):
    default_path = "/etc/poker-network" + sys.version[:3] + "/poker.bot.xml"
    if not exists(default_path):
        default_path = "/etc/poker-network/poker.bot.xml"
    configuration = sys.argv[-1][-4:] == ".xml" and sys.argv[-1] or default_path

    settings = pokernetworkconfig.Config([''])
    settings.load(configuration)

    PokerBotFactory.string_generator = StringGenerator(settings.headerGet("/settings/@name_prefix"))
    PokerBot.note_generator = NoteGenerator(settings.headerGet("/settings/currency"))

    ( host, port ) = split(settings.headerGet("/settings/servers"), ":")
    port = int(port)

    bots = Application('pokerbot')
    bots.verbose = settings.headerGetInt("/settings/@verbose")
    services = service.IServiceCollection(bots)
    services.setSettings(settings)

    bots_count = 0
    for table in settings.headerGetProperties("/settings/table"):
        for i in range(0, int(table["count"])):
            bots_count += 1
            table['tournament'] = False
            factory = PokerBotFactory(settings = settings,
                                      join_info = table,
                                      serial = bots_count)
            bot = Bot(host, port, factory)
            factory.bot = bot
            bot.setServiceParent(services)
    for tournament in settings.headerGetProperties("/settings/tournament"):
        for i in range(0, int(tournament["count"])):
            bots_count += 1
            tournament['tournament'] = True
            factory = PokerBotFactory(settings = settings,
                                      join_info = tournament,
                                      serial = bots_count)
            bot = Bot(host, port, factory)
            factory.bot = bot
            bot.setServiceParent(services)
    return bots

application = makeApplication(sys.argv[1:])

def run():
    app.startApplication(application, None)
    reactor.run()

if __name__ == '__main__':
    run()

########NEW FILE########
__FILENAME__ = pokerbotlogic
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
import sys
sys.path.insert(0, "..")

from os import popen
from string import rstrip
from random import randint

from twisted.internet import reactor

from pokerengine.pokertournament import *

from pokernetwork.user import checkName
from pokernetwork.pokerpackets import *
from pokernetwork.pokerclientpackets import *

LEVEL2ITERATIONS = {
    0: 10,
    1: 1000,
    2: 10000,
    3: 50000,
    4: 100000,
    5: 200000
    }

STATE_RUNNING = 0
STATE_RECONNECTING = 1
STATE_SEARCHING = 2
STATE_BATCH = 3

#
# If name generation is slow use /dev/urandom instead of
# /dev/random. apg will switch to /dev/urandom if it cannot
# open it for reading. chmod go-rw /dev/random will do this
# trick if not running the bots as root.
#

class Pool:

    def __init__(self, command):
        self.command = command
        self.pool = []
        self.max_tries = 5

    lines2pool = None
    
    def getLine(self):
        tries = 0
        while len(self.pool) == 0 and tries < self.max_tries:
            fd = popen(self.command)
            self.pool = self.lines2pool(fd.readlines())
            fd.close()
            tries += 1
        if tries >= self.max_tries:
            raise UserWarning, "pokerbotlogic:Pool too many failures running " + self.command
        return self.pool.pop()
    
class StringGenerator(Pool):

    def __init__(self, name_prefix):
        self.name_prefix = name_prefix
        Pool.__init__(self, "/usr/bin/apg -m 5 -x 10 -M ncl -q -n 500")

    def getName(self):
        return self.name_prefix + self.getLine()

    def lines2pool(self, lines):
        return filter(lambda string: checkName(string)[0], map(lambda string: string[:-1], lines))
    getPassword = Pool.getLine

class NoteGenerator(Pool):

    def lines2pool(self, lines):
        return map(lambda string: rstrip(string).split('\t'), lines)

    getNote = Pool.getLine
    
class PokerBot:

    note_generator = NoteGenerator("exit 1")
    
    def __init__(self, factory):
        self.factory = factory
        self.state = STATE_RUNNING
        self.batch_end_action = None

    def lookForGame(self, protocol):
            join_info = self.factory.join_info
            if join_info['tournament']:
                protocol.sendPacket(PacketPokerTourneySelect(string = join_info["name"]))
            else:
                protocol.sendPacket(PacketPokerTableSelect(string = join_info["name"]))
            self.state = STATE_SEARCHING
            self.factory.can_disconnect = True

    def bootstrap(self, protocol):
        user = protocol.user
        protocol.sendPacket(PacketPokerSetRole(roles = PacketPokerRoles.PLAY))
        protocol.sendPacket(PacketLogin(name = user.name,
                                        password = user.password))
        protocol.sendPacket(PacketPokerTableSelect(string = "my"))
        self.state = STATE_RECONNECTING
        
    def _handleConnection(self, protocol, packet):

        if packet.type == PACKET_BOOTSTRAP:
            reactor.callLater(self.factory.serial * 0.1, lambda: self.bootstrap(protocol))
            
        elif packet.type == PACKET_POKER_BATCH_MODE:
            self.state = STATE_BATCH
            
        elif packet.type == PACKET_SERIAL:
            if self.factory.cash_in:
                note = PokerBot.note_generator.getNote()
                if self.factory.currency_id:
                    note[0] += "?id=" + self.factory.currency_id
                protocol.sendPacket(PacketPokerCashIn(serial = packet.serial,
                                                      note = note))
            
        elif packet.type == PACKET_POKER_STREAM_MODE:
            self.state = STATE_RUNNING
            if self.batch_end_action:
                self.batch_end_action()
                self.batch_end_action = None
            
        elif packet.type == PACKET_POKER_TABLE_LIST:
            if self.state == STATE_SEARCHING:
                found = False
                table_info = self.factory.join_info
                for table in packet.packets:
                    if table.name == table_info["name"]:
                        found = True
                        protocol.sendPacket(PacketPokerTableJoin(game_id = table.id,
                                                                 serial = protocol.getSerial()))
                        if not self.factory.watch:
                            protocol.sendPacket(PacketPokerSeat(game_id = table.id,
                                                                serial = protocol.getSerial()))
                            protocol.sendPacket(PacketPokerBuyIn(game_id = table.id,
                                                                 serial = protocol.getSerial()))
                            protocol.sendPacket(PacketPokerAutoBlindAnte(game_id = table.id,
                                                                         serial = protocol.getSerial()))
                            protocol.sendPacket(PacketPokerSit(game_id = table.id,
                                                               serial = protocol.getSerial()))
                        break

                if not found:
                    print "Unable to find table %s " % table_info["name"]
                    protocol.transport.loseConnection()

            elif self.state == STATE_RECONNECTING:
                tables = packet.packets
                if len(tables) == 0:
                    self.lookForGame(protocol)
                elif len(tables) == 1:
                    table = tables[0]
                    protocol.sendPacket(PacketPokerTableJoin(game_id = table.id,
                                                             serial = protocol.getSerial()))
                    protocol.sendPacket(PacketPokerSit(game_id = table.id,
                                                       serial = protocol.getSerial()))
                    self.state = STATE_RUNNING
                else:
                    print "Unexpected number of tables %d " % len(tables)
                    protocol.transport.loseConnection()

            else:
                print "Unexpected state %d" % self.state
                protocol.transport.loseConnection()

        elif packet.type == PACKET_POKER_TOURNEY_LIST:
            name = self.factory.join_info['name']
            if len(packet.packets) <= 0:
                print "Unable to find tournament %s " % name
            found = None
            for tourney in packet.packets:
                if tourney.state == TOURNAMENT_STATE_REGISTERING:
                    found = tourney.serial
                    break
            if not found:
                print "No %s tournament allows registration, try later " % name
                self.factory.can_disconnect = False
                reactor.callLater(10, lambda: self.lookForGame(protocol))
            else:
                protocol.sendPacket(PacketPokerTourneyRegister(serial = protocol.getSerial(),
                                                               game_id = found))
            self.state = STATE_RUNNING
            
        elif packet.type == PACKET_POKER_SEAT:
            if packet.seat == -1:
                print "Not allowed to get a seat, give up"
                protocol.transport.loseConnection()

        elif packet.type == PACKET_POKER_ERROR or packet.type == PACKET_ERROR:
            giveup = True
            if packet.other_type == PACKET_POKER_TOURNEY_REGISTER:
                if packet.code == PacketPokerTourneyRegister.NOT_ENOUGH_MONEY:
                    self.factory.went_broke = True
                elif packet.code == PacketPokerTourneyRegister.ALREADY_REGISTERED:
                    giveup = False
                else:
                    name = self.factory.join_info['name']
                    print "Registration refused for tournament %s, try later" % name
                    self.factory.can_disconnect = False
                    reactor.callLater(60, lambda: self.lookForGame(protocol))
                    giveup = False
            elif packet.other_type == PACKET_POKER_REBUY or packet.other_type == PACKET_POKER_BUY_IN:
                self.factory.went_broke = True

            if self.factory.verbose or giveup: print "ERROR: %s" % packet
            if giveup:
                protocol.transport.loseConnection()
            
        elif packet.type == PACKET_POKER_BLIND_REQUEST:
            if packet.serial == protocol.getSerial():
                protocol.sendPacket(PacketPokerBlind(game_id = packet.game_id,
                                                     serial = packet.serial))

        elif packet.type == PACKET_POKER_PLAYER_LEAVE:
            if packet.serial == protocol.getSerial():
                if self.factory.join_info['tournament']:
                    self.lookForGame(protocol)

        elif packet.type == PACKET_POKER_WIN:
            if self.factory.rebuy and self.state == STATE_RUNNING:
                #
                # Rebuy if necessary
                #
                if not self.factory.join_info['tournament'] and not self.factory.watch:
                    game = self.factory.packet2game(packet)
                    serial = protocol.getSerial()
                    if ( game and game.isBroke(serial) ):
                        protocol.sendPacket(PacketPokerRebuy(game_id = game.id,
                                                             serial = serial))
                        protocol.sendPacket(PacketPokerSit(game_id = game.id,
                                                           serial = serial))
            
        elif packet.type == PACKET_POKER_SELF_IN_POSITION:
            game = self.factory.packet2game(packet)
            if self.state == STATE_RUNNING:
                self.inPosition(protocol, game)
            elif self.state == STATE_BATCH:
                self.batch_end_action = lambda: self.inPosition(protocol, game)

        elif packet.type == PACKET_POKER_SELF_LOST_POSITION:
            if self.state == STATE_BATCH:
                self.batch_end_action = None
                
    def inPosition(self, protocol, game):
        if not game.isBlindAnteRound():
            if self.factory.wait > 0:
                self.factory.can_disconnect = False
                reactor.callLater(self.factory.wait, lambda: self.play(protocol, game))
            else:
                self.play(protocol, game)

    def eval(self, game, serial):
        if self.factory.level == 0:
            actions = ("check", "call", "raise")
            return (actions[randint(0, 2)], -1)

        ev = game.handEV(serial, LEVEL2ITERATIONS[self.factory.level])
        
        if game.state == "pre-flop":
            if ev < 100:
                action = "check"
            elif ev < 500:
                action = "call"
            else:
                action = "raise"
        elif game.state == "flop" or game.state == "third":
            if ev < 200:
                action = "check"
            elif ev < 600:
                action = "call"
            else:
                action = "raise"
        elif game.state == "turn" or game.state == "fourth":
            if ev < 300:
                action = "check"
            elif ev < 700:
                action = "call"
            else:
                action = "raise"
        else:
            if ev < 400:
                action = "check"
            elif ev < 800:
                action = "call"
            else:
                action = "raise"
            
        return (action, ev)
        
    def play(self, protocol, game):
        serial = protocol.getSerial()
        name = protocol.getName()
        if serial not in game.serialsNotFold():
            print name + ": the server must have decided to play on our behalf before we had a chance to decide (TIMEOUT happening at the exact same time we reconnected), most likely"
            return
        
        (desired_action, ev) = self.eval(game, serial)
        actions = game.possibleActions(serial)
        if self.factory.verbose:
            print "%s serial = %d, hand = %s, board = %s" % (name, serial, game.getHandAsString(serial), game.getBoardAsString())
            print "%s wants to %s (ev = %d)" % (name, desired_action, ev)
        while not desired_action in actions:
            if desired_action == "check":
                desired_action = "fold"
            elif desired_action == "call":
                desired_action = "check"
            elif desired_action == "raise":
                desired_action = "call"

        if desired_action == "fold":
            protocol.sendPacket(PacketPokerFold(game_id = game.id,
                                                serial = serial))
        elif desired_action == "check":
            protocol.sendPacket(PacketPokerCheck(game_id = game.id,
                                                 serial = serial))
        elif desired_action == "call":
            protocol.sendPacket(PacketPokerCall(game_id = game.id,
                                                serial = serial))
        elif desired_action == "raise":
            (min_bet, max_bet, to_call) = game.betLimits(serial)
            
            player = game.serial2player[serial]
            raiseAmount = min_bet * 2

            raiseTo = min(max_bet, raiseAmount) + player.bet + to_call

            if raiseTo > (player.money + player.bet): raiseTo = (player.money + player.bet)

            protocol.sendPacket(PacketPokerRaise(game_id = game.id,
                                                 serial = serial,
                                                 amount = raiseTo))
        else:
            print "=> unexpected actions = %s" % actions
        self.factory.can_disconnect = True


########NEW FILE########
__FILENAME__ = pokercashier
#
# -*- py-indent-offset: 4; coding: iso-8859-1 -*-
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008             Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2006 Mekensleep <licensing@mekensleep.com>
#                    24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#

from MySQLdb.constants import ER
from string import lower

from twisted.internet import reactor

from pokernetwork import currencyclient
from pokernetwork import pokerlock
from pokernetwork.pokerpackets import *

PokerLock = pokerlock.PokerLock

class PokerCashier:

    def __init__(self, settings):
        self.settings = settings
        self.verbose = self.settings.headerGetInt("/server/@verbose")
        self.currency_client = currencyclient.CurrencyClient()
        self.parameters = settings.headerGetProperties("/server/cashier")[0]
        if self.parameters.has_key('pokerlock_queue_timeout'):
            PokerLock.queue_timeout = int(self.parameters['pokerlock_queue_timeout'])
        self.db = None
        self.db_parameters = settings.headerGetProperties("/server/database")[0]
        self.locks = {}
        reactor.callLater(0, self.resumeCommits)

    def message(self, string):
        print "PokerCashier: " + string

    def error(self, string):
        self.message("*ERROR* " + string)
        
    def close(self):
        for lock in self.locks.values():
            lock.close()
        del self.db
        
    def setDb(self, db):
        self.db = db

    def resumeCommits(self):
        pass
    
    def getCurrencySerial(self, url, reentrant = True):
        cursor = self.db.cursor()
        #
        # Figure out the currency_serial matching the URL
        #
        sql = "SELECT serial FROM currencies WHERE url = %s"
        if self.verbose > 2: self.message(sql % self.db.db.literal(url))
        cursor.execute(sql, url)
        if cursor.rowcount == 0:
            user_create = lower(self.parameters.get('user_create', 'no'))
            if user_create not in ('yes', 'on'):
                raise PacketError(other_type = PACKET_POKER_CASH_IN,
                                  code = PacketPokerCashIn.REFUSED,
                                  message = "Invalid currency " + url + " and user_create = " + user_create + " in settings.")
            sql = "INSERT INTO currencies (url) VALUES (%s)"
            if self.verbose > 2: self.message(sql % self.db.db.literal(url))
            try:
                cursor.execute(sql, url)
                if cursor.rowcount == 1:
                    currency_serial = cursor.lastrowid
                else:
                    raise Exception("SQL command '%s' failed without raising exception.  Underlying DB may be severely hosed" % sql)
            except Exception, e:
                cursor.close()
                if e[0] == ER.DUP_ENTRY and reentrant:
                    #
                    # Insertion failed, assume it's because another
                    # process already inserted it.
                    #
                    return self.getCurrencySerial(url, False)
                else:
                    raise
        else:
            (currency_serial,) = cursor.fetchone()

        cursor.close()
        return currency_serial

    def cashGeneralFailure(self, reason, packet):
        if self.verbose > 2: 
            self.message("cashGeneralFailure: " + str(reason) + " packet = " + str(packet))
            from twisted.python import failure
            from twisted.web import error
            if isinstance(reason, failure.Failure) and isinstance(reason.value, error.Error):
                self.message("cashGeneralFailure: response = %s" % reason.value.response)
        if hasattr(packet, "currency_serial"):
            self.unlock(packet.currency_serial)
            del packet.currency_serial
        return reason

    def cashInUpdateSafe(self, result, transaction_id, packet):
        if self.verbose > 2: self.message("cashInUpdateSafe: " + str(packet))
        cursor = self.db.cursor()
        cursor.execute("START TRANSACTION")
        try:
            sqls = []
            sqls.append( ( "INSERT INTO safe SELECT currency_serial, serial, name, value FROM counter "  +
                           "       WHERE transaction_id = '" + transaction_id + "' AND " +
                           "             status = 'n' ", 1 ) )
            sqls.append( ( "DELETE FROM counter,safe USING counter,safe WHERE " +
                           " counter.currency_serial = safe.currency_serial AND " +
                           " counter.serial = safe.serial AND " +
                           " counter.value = safe.value AND " +
                           " counter.status = 'y' ", 0 ) )
            sqls.append( ( "DELETE FROM counter WHERE transaction_id = '" + transaction_id + "'", 1 ) )
            sqls.append( ( "INSERT INTO user2money (user_serial, currency_serial, amount) VALUES (" +
                           str(packet.serial) + ", " + str(packet.currency_serial) + ", " + str(packet.value) + ") " +
                           " ON DUPLICATE KEY UPDATE amount = amount + " + str(packet.value), 0 ) )

            for ( sql, rowcount ) in sqls:
                if cursor.execute(sql) < rowcount:
                    message = sql + " affected " + str(cursor.rowcount) + " records instead >= " + str(rowcount)
                    self.error(message)
                    raise PacketError(other_type = PACKET_POKER_CASH_IN,
                                      code = PacketPokerCashIn.SAFE,
                                      message = message)
                if self.verbose > 2: self.message("cashInUpdateSafe: %d: %s" % ( cursor.rowcount, sql ))
            cursor.execute("COMMIT")
            cursor.close()
        except:
            cursor.execute("ROLLBACK")
            cursor.close()
            raise

        self.unlock(packet.currency_serial);
        return PacketAck()

    def cashInUpdateCounter(self, new_notes, packet, old_notes):
        if self.verbose > 2: self.message("cashInUpdateCounter: new_notes = " + str(new_notes) + " old_notes = " + str(old_notes))
        #
        # The currency server gives us new notes to replace the
        # old ones. These new notes are not valid yet, the
        # currency server is waiting for our commit. Store all
        # the notes involved in the transaction on the counter.
        #
        cursor = self.db.cursor()
        cursor.execute("START TRANSACTION")
        transaction_id = new_notes[0][2]
        try:
            def notes_on_counter(notes, transaction_id, status):
                for ( url, serial, name, value ) in notes:
                    sql = ( "INSERT INTO counter ( transaction_id, user_serial, currency_serial, serial, name, value, status, application_data) VALUES " +
                            "                    ( %s,             %s,          %s,              %s,     %s,   %s,    %s,     %s )" )
                    cursor.execute(sql, ( transaction_id, packet.serial, packet.currency_serial, serial, name, value, status, packet.application_data ));
            notes_on_counter(new_notes, transaction_id, 'n')
            notes_on_counter(old_notes, transaction_id, 'y')
            cursor.execute("COMMIT")
            cursor.close()
        except:
            cursor.execute("ROLLBACK")
            cursor.close()
            raise

        return self.cashInCurrencyCommit(transaction_id, packet)

    def cashInCurrencyCommit(self, transaction_id, packet):
        if self.verbose > 2: self.message("cashInCurrencyCommit")
        deferred = self.currency_client.commit(packet.url, transaction_id)
        deferred.addCallback(self.cashInUpdateSafe, transaction_id, packet)
        return deferred
        
    def cashInValidateNote(self, lock_name, packet):
        #
        # Ask the currency server for change
        #
        cursor = self.db.cursor()
        try:
            sql = ( "SELECT transaction_id FROM counter WHERE " + #pragma: no cover
                    " currency_serial = " + str(packet.currency_serial) + " AND " + #pragma: no cover
                    " serial = " + str(packet.bserial) ) #pragma: no cover
            if self.verbose > 2: self.message(sql)
            cursor.execute(sql)
            if cursor.rowcount > 0:
                (transaction_id, ) = cursor.fetchone()
                deferred = self.cashInCurrencyCommit(transaction_id, packet)
            else:
                #
                # Get the currency note from the safe
                #
                sql = "SELECT name, serial, value FROM safe WHERE currency_serial = " + str(packet.currency_serial)
                if self.verbose > 2: self.message(sql)
                cursor.execute(sql)
                if cursor.rowcount not in (0, 1):
                    message = sql + " found " + str(cursor.rowcount) + " records instead of 0 or 1"
                    self.error(message)
                    raise PacketError(other_type = PACKET_POKER_CASH_IN,
                                      code = PacketPokerCashIn.SAFE,
                                      message = message)
                notes = [ (packet.url, packet.bserial, packet.name, packet.value) ]
                if cursor.rowcount == 1:
                    #
                    # A note already exists in the safe, merge it
                    # with the provided note
                    #
                    (name, serial, value) = cursor.fetchone()
                    notes.append((packet.url, serial, name, value))
                deferred = self.currency_client.meltNotes(*notes)
                deferred.addCallback(self.cashInUpdateCounter, packet, notes)
        finally:
            cursor.close()
        return deferred

    def cashOutCollect(self, currency_serial, transaction_id):
        cursor = self.db.cursor()
        if transaction_id:
            transaction = "counter.transaction_id = '" + str(transaction_id) + "' AND "
        else:
            transaction = ""

        sql = ( "SELECT counter.user_serial, currencies.url, counter.serial, counter.name, counter.value, counter.application_data FROM counter,currencies " + #pragma: no cover
                "       WHERE currencies.serial = " + str(currency_serial) + " AND " + #pragma: no cover
                "             counter.currency_serial = " + str(currency_serial) + " AND " + #pragma: no cover
                transaction + #pragma: no cover
                "             counter.status = 'c' " ) #pragma: no cover
        if self.verbose > 2: self.message(sql)
        cursor.execute(sql)
        if cursor.rowcount == 0:
            return None
        ( serial, url, bserial, name, value, application_data ) = cursor.fetchone()
        cursor.close()
        packet = PacketPokerCashOut(serial = serial,
                                    url = url,
                                    bserial = bserial,
                                    name = name,
                                    value = value,
                                    application_data = application_data)
        if self.verbose > 2: self.message("cashOutCollect " + str(packet))
        return packet
        
    def cashOutUpdateSafe(self, result, currency_serial, transaction_id):
        if self.verbose > 2: self.message("cashOutUpdateSafe: " + str(currency_serial) + " " + str(transaction_id))
        packet = self.cashOutCollect(currency_serial, transaction_id)
        if not packet:
            cursor = self.db.cursor()
            cursor.execute("START TRANSACTION")
            try:
                zero_or_one = lambda numrows: (numrows == 0 or numrows == 1)
                one = lambda numrows: numrows == 1
                sqls = []
                sqls.append(( "DELETE FROM safe WHERE currency_serial = %s" % currency_serial, one))
                sqls.append(( "INSERT INTO safe SELECT currency_serial, serial, name, value FROM counter " +
                              "       WHERE currency_serial = " + str(currency_serial) + " AND " +
                              "             status = 'r' ", zero_or_one))
                sqls.append(( "DELETE FROM counter WHERE currency_serial = %s and status = 'r'" % currency_serial, zero_or_one))
                sqls.append(( "UPDATE counter SET status = 'c' WHERE currency_serial = %s " % currency_serial , one))
                for ( sql, numrowsp ) in sqls:
                    if self.verbose > 2: self.message(sql)
                    if not numrowsp(cursor.execute(sql)):
                        message = sql + " affected " + str(cursor.rowcount) + " records "
                        self.error(message)
                        raise PacketError(other_type = PACKET_POKER_CASH_OUT,
                                          code = PacketPokerCashOut.SAFE,
                                          message = message)

                packet = self.cashOutCollect(currency_serial, transaction_id)
                sql = ( "UPDATE user2money SET amount = amount - " + str(packet.value) + #pragma: no cover
                        "       WHERE user_serial = " + str(packet.serial) + " AND " + #pragma: no cover
                        "             currency_serial = " + str(currency_serial) ) #pragma: no cover
                if cursor.execute(sql) != 1:
                    message = sql + " affected " + str(cursor.rowcount) + " records instead of 1 "
                    self.error(message)
                    raise PacketError(other_type = PACKET_POKER_CASH_OUT,
                                      code = PacketPokerCashOut.SAFE,
                                      message = message)
                cursor.execute("COMMIT")
                cursor.close()
            except:
                cursor.execute("ROLLBACK")
                cursor.close()
                raise
            if not packet:
                packet = PacketError(other_type = PACKET_POKER_CASH_OUT,
                                     code = PacketPokerCashOut.EMPTY,
                                     message = "no currency note to be collected for currency %d" % currency_serial)                
        self.unlock(currency_serial);
        return packet

    def cashOutCurrencyCommit(self, transaction_id, url):
        if self.verbose > 2: self.message("cashOutCurrencyCommit")
        currency_serial = self.getCurrencySerial(url)
        deferred = self.currency_client.commit(url, transaction_id)
        deferred.addCallback(self.cashOutUpdateSafe, currency_serial, transaction_id)
        return deferred
        
    def cashOutUpdateCounter(self, new_notes, packet):
        if self.verbose > 2: self.message("cashOutUpdateCounter: new_notes = " + str(new_notes) + " packet = " + str(packet))
        cursor = self.db.cursor()
        if len(new_notes) != 2:
            raise PacketError(other_type = PACKET_POKER_CASH_OUT,
                              code = PacketPokerCashOut.BREAK_NOTE,
                              message = "breaking %s resulted in %d notes (%s) instead of 2" % ( packet, len(new_notes), str(new_notes) ) )
        if new_notes[0][3] == packet.value:
            user_note = new_notes[0]
            server_note = new_notes[1]
        elif new_notes[1][3] == packet.value:
            user_note = new_notes[1]
            server_note = new_notes[0]
        else:
            raise PacketError(other_type = PACKET_POKER_CASH_OUT,
                              code = PacketPokerCashOut.BREAK_NOTE,
                              message = "breaking %s did not provide a note with the proper value (notes are %s)" % ( packet, str(new_notes) ) )
        transaction_id = new_notes[0][2]
        url = new_notes[0][0]
        cursor.execute("START TRANSACTION")
        try:
            sql = ( "INSERT INTO counter ( transaction_id, user_serial, currency_serial, serial, name, value, status, application_data ) VALUES " +
                    "                    ( %s,             %s,          %s,              %s,     %s,   %s,    %s,     %s )" )
            #
            # Just forget about a zero value note that is provided by
            # the currencyclient for the sake of code consistency
            #
            if int(server_note[3]) > 0:
                cursor.execute(sql, ( transaction_id, packet.serial, packet.currency_serial, server_note[1], server_note[2], server_note[3], 'r', packet.application_data ))
            cursor.execute(sql, ( transaction_id, packet.serial, packet.currency_serial, user_note[1], user_note[2], user_note[3], 'u', packet.application_data ))
            cursor.execute("COMMIT")
            cursor.close()
        except:
            cursor.execute("ROLLBACK")
            cursor.close()
            raise

        return transaction_id

    def cashOutBreakNote(self, lock_name, packet):
        #
        # Ask the currency server to split the note in two
        #
        cursor = self.db.cursor()
        try:
            sql = ( "SELECT transaction_id FROM counter WHERE " +
                    " currency_serial = " + str(packet.currency_serial) )
            if self.verbose > 2: self.message(sql)
            cursor.execute(sql)
            if cursor.rowcount > 0:
                (transaction_id, ) = cursor.fetchone()
                deferred = self.cashOutCurrencyCommit(transaction_id, packet.url)
            else:
                #
                # Get the currency note from the safe
                #
                sql = "SELECT name, serial, value FROM safe WHERE currency_serial = " + str(packet.currency_serial)
                if self.verbose > 2: self.message(sql)
                cursor.execute(sql)
                if cursor.rowcount != 1:
                    message = sql + " found " + str(cursor.rowcount) + " records instead of exactly 1"
                    self.error(message)
                    raise PacketError(other_type = PACKET_POKER_CASH_OUT,
                                      code = PacketPokerCashOut.SAFE,
                                      message = message)
                (name, serial, value) = cursor.fetchone()
                note = (packet.url, serial, name, value)
                remainder = value - packet.value
                #
                # Break the note in two
                #
                deferred = self.currency_client.breakNote(note, remainder, packet.value)
                deferred.addCallback(self.cashOutUpdateCounter, packet)
                deferred.addCallback(self.cashOutCurrencyCommit, packet.url)
        finally:
            cursor.close()
        return deferred

    def getLockName(self, serial):
        return "cash_%d" % serial

    def unlock(self, currency_serial):
        name = self.getLockName(currency_serial)
        if not self.locks.has_key(name):
            if self.verbose: self.error("cashInUnlock: unexpected missing " + name + " in locks (ignored)")
            return
        if not self.locks[name].isAlive():
            if self.verbose: self.error("cashInUnlock: unexpected dead " + name + " pokerlock (ignored)")
            return
        self.locks[name].release(name)

    def lock(self, currency_serial):
        name = self.getLockName(currency_serial)

        if self.verbose > 2: self.message("get lock " + name)
        if self.locks.has_key(name):
            lock = self.locks[name]
            if lock.isAlive():
                create_lock = False
            else:
                lock.close()
                create_lock = True
        else:
            create_lock = True
        if create_lock:
            self.locks[name] = PokerLock(self.db_parameters)
            self.locks[name].verbose = self.verbose
            self.locks[name].start()

        return self.locks[name].acquire(name, int(self.parameters.get('acquire_timeout', 60)))
        
    def cashIn(self, packet):
        if self.verbose > 2: self.message("cashIn: " + str(packet))
        currency_serial = self.getCurrencySerial(packet.url)
        packet.currency_serial = currency_serial
        d = self.lock(currency_serial)
        d.addCallback(self.cashInValidateNote, packet)
        d.addErrback(self.cashGeneralFailure, packet)
        return d
    
    def cashOut(self, packet):
        if self.verbose > 2: self.message("cashOut: " + str(packet))
        currency_serial = self.getCurrencySerial(packet.url)
        packet.currency_serial = currency_serial
        d = self.lock(currency_serial)
        d.addCallback(self.cashOutBreakNote, packet)
        d.addErrback(self.cashGeneralFailure, packet)
        return d

    def cashOutCommit(self, packet):
        if self.verbose > 2: self.message("cashOutCommit: " + str(packet))
        cursor = self.db.cursor()
        cursor.execute("DELETE FROM counter WHERE name = %s AND status = 'c'", packet.transaction_id)
        cursor.close()
        return cursor.rowcount

    def cashQuery(self, packet):
        if self.verbose > 2: self.message("cashQuery: " + str(packet))
        cursor = self.db.cursor()
        sql = ( "SELECT COUNT(*) FROM counter WHERE " +
                " application_data = '" + str(packet.application_data) + "'" )
        if self.verbose > 2: self.message(sql)
        cursor.execute(sql)
        (count,) = cursor.fetchone()
        cursor.close()
        if count > 0:
            return PacketAck()
        else:
            return PacketError(other_type = PACKET_POKER_CASH_QUERY,
                               code = PacketPokerCashQuery.DOES_NOT_EXIST,
                               message = "No record with application_data = '%s'" % packet.application_data)
    

########NEW FILE########
__FILENAME__ = pokerclient
# -*- py-indent-offset: 4; coding: iso-8859-1; mode: python -*-
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Henry Precheur <henry@precheur.org> (2004)
#

from string import split, lower
from re import match
import platform

from twisted.internet import reactor, defer
from twisted.python.runtime import seconds

from pokereval import PokerEval
from pokerengine.pokergame import PokerGameClient, PokerPlayer, history2messages
from pokerengine.pokercards import PokerCards
from pokerengine.pokerchips import PokerChips

from pokerengine.pokerengineconfig import Config
from pokernetwork.client import UGAMEClientProtocol, UGAMEClientFactory
from pokernetwork.pokerclientpackets import *
from pokernetwork.pokergameclient import PokerNetworkGameClient
from pokernetwork.pokerexplain import PokerGames, PokerExplain

DEFAULT_PLAYER_USER_DATA = { 'delay': 0, 'timeout': None }

class PokerSkin:
    """Poker Skin"""

    def __init__(self, *args, **kwargs):
        self.settings = kwargs['settings']
        ( self.url, self.outfit ) = self.interpret("random", "random")

    def destroy(self):
        pass

    def interpret(self, url, outfit):
        return (url, outfit)
    
    def getUrl(self):
        return self.url

    def setUrl(self, url):
        self.url = url

    def getOutfit(self):
        return self.outfit

    def setOutfit(self, outfit):
        self.outfit = outfit

    def hideOutfitEditor(self):
        pass

    def showOutfitEditor(self, select_callback):
        pass

#
# Set a flag when an error is logged
#
from twisted.python import log

log.error_occurred = False
log_err = log.err

def err(*args, **kwargs):
    global log_err
    log_err(*args, **kwargs)
    log.error_occurred = True

log.err = err
log.deferr = err

class PokerClientFactory(UGAMEClientFactory):
    "client factory"

    def __init__(self, *args, **kwargs):
        UGAMEClientFactory.__init__(self, *args, **kwargs)
        self.settings = kwargs["settings"]
        self.config = kwargs.get("config", None)
        #
        # Make sure the attributes exists, should an exception occur before
        # it is initialized. This is done
        # so that the caller does not have to check the existence of the
        # attribute when catching an exception.
        #
        self.crashing = False

        settings = self.settings
        self.ping_delay = settings.headerGetInt("/settings/@ping")
        self.no_display_packets = settings.headerGet("/settings/@no_display_packets")
        self.name = settings.headerGet("/settings/name")
        self.password = settings.headerGet("/settings/passwd")
        if self.config:
            chips_values = self.config.headerGet("/sequence/chips")
            if not chips_values:
                raise UserWarning, "PokerClientFactory: no /sequence/chips found in %s" % self.config.path
            self.chips_values = map(int, chips_values.split())
        else:
            self.chips_values = [1]
        self.host = "unknown"
        self.port = 0
        self.remember = settings.headerGet("/settings/remember") == "yes"
        self.chat_config = settings.headerGetProperties("/settings/chat")
        if self.chat_config:
            self.chat_config = self.chat_config[0]
            for (key, value) in self.chat_config.iteritems():
                self.chat_config[key] = int(value)
        else:
            self.chat_config = {}
        self.dirs = split(self.settings.headerGet("/settings/path"))
        self.verbose = self.settings.headerGetInt("/settings/@verbose")
        self.delays = self.settings.headerGetProperties("/settings/delays")
        if self.delays:
            self.delays = self.delays[0]
            for (key, value) in self.delays.iteritems():
                self.delays[key] = float(value)
            if self.delays.has_key("round"):
                self.delays["end_round"] = self.delays["round"]
                self.delays["begin_round"] = self.delays["round"]
                del self.delays["round"]
            if not self.delays.has_key("blind_ante_position"):
                self.delays["blind_ante_position"] = self.delays["position"]
        else:
            self.delays = {}
        if self.verbose > 2:
            self.message("PokerClient: delays %s" % self.delays)
        self.delays_enable = self.settings.headerGet("/settings/@delays") == "true"
        self.skin = PokerSkin(settings = self.settings)
        self.protocol = PokerClientProtocol
        self.games = PokerGames(dirs = self.dirs, verbose = self.verbose)
        self.file2name = {}
        self.first_time = self.settings.headerGet("/settings/name") == "username"
        self.played_time = self.settings.headerGet("/settings/played_time")

    def __del__(self):
        if hasattr(self, "games"):
            del self.games

    def buildProtocol(self, addr):
        protocol = UGAMEClientFactory.buildProtocol(self, addr)
        protocol.explain.chips_values = self.chips_values
        protocol.explain.games = self.games
        protocol.explain.setVerbose(self.verbose)
        return protocol

    def resolve(self, url):
        return reactor.resolve(url,(1,1))

    def checkNetwork(self, url):
        d = self.resolve(url)
        d.addCallback(self.hostResolved).addErrback(self.hostNotResolved)
        return d
    
    def hostNotResolved(self, d):
        self.networkNotAvailable()
        
    def hostResolved(self, d):
        self.networkAvailable()

    def networkNotAvailable(self):
        pass #pragma: no cover
    
    def networkAvailable(self):
        pass #pragma: no cover
        
    def restart(self):
        reactor.disconnectAll()
        import sys
        import os
        argv = [ sys.executable ]
        argv.extend(sys.argv)
        os.execv(sys.executable, argv)

    def quit(self):
        #
        # !!! The order MATTERS here !!! the renderer must be notified last
        # otherwise leak detection won't be happy. Inverting the two
        # is not fatal and the data will be freed eventually. However,
        # debugging is made much harder because leak detection can't
        # check as much as it could.
        #        
        self.skin.destroy()

    def getSkin(self):
        return self.skin
    
    def getUrl(self):
        return self.skin.getUrl()

    def setUrl(self,url):
        return self.skin.setUrl(url)

    def getOutfit(self):
        return self.skin.getOutfit()
    
    def setOutfit(self,outfit):
        return self.skin.setOutfit(outfit)
    
    def translateFile2Name(self, file):
        if not self.file2name.has_key(file):
            config = Config(self.dirs)
            config.load("poker.%s.xml" % file)
            name = config.headerGet("/bet/description")
            if not name:
                name = config.headerGet("/poker/variant/@name")
                if not name:
                    self.error("*CRITICAL* can't find readable name for %s" % file)
                    name = file
            self.file2name[file] = name
        return self.file2name[file]

    def saveAuthToFile(self, name, password, remember):
        settings = self.settings
        self.name = name
        self.password = password
        self.remember = remember
        if remember:
            remember = "yes"
        else:
            remember = "no"
            name = ""
            password = ""
        settings.headerSet("/settings/remember", remember)
        settings.headerSet("/settings/name", name)
        settings.headerSet("/settings/passwd", password)
        settings.save()
        settings.headerSet("/settings/name", self.name)
        settings.headerSet("/settings/passwd", self.password)

    def isOutbound(self, packet):
        return ( packet.type == PACKET_ERROR or
                 packet.type == PACKET_MESSAGE or
                 packet.type == PACKET_POKER_HAND_LIST or
                 packet.type == PACKET_POKER_PLAYER_INFO or
                 packet.type == PACKET_POKER_USER_INFO or
                 packet.type == PACKET_POKER_HAND_HISTORY or
                 packet.type == PACKET_POKER_PLAYERS_LIST or
                 packet.type == PACKET_POKER_TOURNEY_PLAYERS_LIST or
                 packet.type == PACKET_POKER_TOURNEY_UNREGISTER or
                 packet.type == PACKET_POKER_TOURNEY_REGISTER )

    def isAlwaysHandled(self, packet):
        return ( packet.type == PACKET_POKER_PLAYER_CHIPS or
                 packet.type == PACKET_POKER_CHAT )
    
    def isConnectionLess(self, packet):
        return ( packet.type == PACKET_PROTOCOL_ERROR or
                 packet.type == PACKET_QUIT )

    def getGame(self, game_id):
        return self.games.getGame(game_id)

    def getGameByNameNoCase(self, name):
        return self.games.getGameByNameNoCase(name)
    
    def getOrCreateGame(self, game_id):
        return self.games.getOrCreateGame(game_id)

    def getGameIds(self):
        return self.games.getGameIds()
    
    def deleteGame(self, game_id):
        return self.games.deleteGame(game_id)

    def packet2game(self, packet):
        if not self.isOutbound(packet):
            return self.games.packet2game(packet)
        else:
            return False

    def gameExists(self, game_id):
        return self.games.gameExists(game_id)

ABSOLUTE_LAGMAX = 120
DEFAULT_LAGMAX = 15

class PokerClientProtocol(UGAMEClientProtocol):
    """Poker client"""

    def __init__(self):
        UGAMEClientProtocol.__init__(self)
        self.callbacks = {
            'current': {},
            'not_current': {},
            'outbound': {}
            }
        self.setCurrentGameId(None)
        self.pending_auth_request = False
        self.publish_packets = []
        self.input_packets = []
        self.publish_timer = None
        self.publish_time = 0
        self.publishPackets()
        self.lag = DEFAULT_LAGMAX
        self.lagmax_callbacks = []
        self.explain = PokerExplain()

    def setPrefix(self, prefix):
        self._prefix = prefix
        self.explain.setPrefix(prefix)
        
    def setCurrentGameId(self, game_id):
        if hasattr(self.factory, 'verbose') and self.factory.verbose > 2: self.message("setCurrentGameId(%s)" % game_id)
        self.hold(0)
        self.currentGameId = game_id

    def getCurrentGameId(self):
        return self.currentGameId
    
    def connectionMade(self):
        "connectionMade"
        if self.factory.delays_enable:
            self._lagmax = ABSOLUTE_LAGMAX
            self.lag = self.factory.delays.get("lag", DEFAULT_LAGMAX)
        self.no_display_packets = self.factory.no_display_packets
        UGAMEClientProtocol.connectionMade(self)

    def packetDeferred(self, what, name):
        d = defer.Deferred()
        def fire(client, packet):
            d.callback((client, packet))
        self.registerHandler(what, name, fire)
        def unregister(arg):
            self.unregisterHandler(what, name, fire)
            return  arg
        d.addCallback(unregister)
        return d
        
    def registerHandler(self, what, name, meth):
        if name:
            names = [ name ]
        else:
            names = PacketNames.keys()
        if what != True:
            whats = [ what ]
        else:
            whats = [ 'current', 'not_current', 'outbound' ]
        for what in whats:
            callbacks = self.callbacks[what]
            for name in names:
                callbacks.setdefault(name, []).append(meth)
        
    def unregisterHandler(self, what, name, meth):
        if name:
            names = [ name ]
        else:
            names = PacketNames.keys()
        if what != True:
            whats = [ what ]
        else:
            whats = [ 'current', 'not_current', 'outbound' ]
        for what in whats:
            callbacks = self.callbacks[what]
            for name in names:
                callbacks[name].remove(meth)
        
    def normalizeChips(self, game, chips):
        if game.unit in self.factory.chips_values:
            values = self.factory.chips_values[self.factory.chips_values.index(game.unit):]
        else:
            values = []
        list = PokerChips(values, chips).tolist()
        if self.factory.verbose > 4:
            self.message("normalizeChips: " + str(list) + " " + str(values))
        return list
            
    def updatePlayerChips(self, game, player):
        packet = PacketPokerPlayerChips(game_id = game.id,
                                        serial = player.serial,
                                        bet = player.bet,
                                        money = player.money)
        return packet

    def updatePotsChips(self, game, side_pots):
        packets = []
        
        if not side_pots:
            packet = PacketPokerChipsPotReset(game_id = game.id)
            return [ packet ]
        
        index = 0
        for (amount, total) in side_pots['pots']:
            chips = amount
            bet = self.normalizeChips(game, chips)
            pot = PacketPokerPotChips(game_id = game.id,
                                      index = index,
                                      bet = bet)
            packets.append(pot)
            index += 1
        return packets

    def chipsPlayer2Bet(self, game, player, chips):
        packets = []
        packet = PacketPokerChipsPlayer2Bet(game_id = game.id,
                                            serial = player.serial,
                                            chips = self.normalizeChips(game, chips))
        packets.append(packet)
        packets.append(self.updatePlayerChips(game, player))
        return packets

    def chipsBet2Pot(self, game, player, bet, pot_index):
        packets = []
        if ( pot_index == 0 and
             player.dead > 0 and
             game.isSecondRound() ):
            #
            # The ante or the dead are already in the pot
            #
            bet -= player.dead
        packet = PacketPokerChipsBet2Pot(game_id = game.id,
                                         serial = player.serial,
                                         chips = self.normalizeChips(game, bet),
                                         pot = pot_index)
        packets.append(packet)
        packets.append(self.updatePlayerChips(game, player))
        return packets
        
    def chipsPot2Player(self, game, player, bet, pot_index, reason):
        packet = PacketPokerChipsPot2Player(game_id = game.id,
                                            serial = player.serial,
                                            chips = self.normalizeChips(game, bet),
                                            pot = pot_index,
                                            reason = reason)
        return packet
        
    def handleUserInfo(self, packet):
        if self.factory.verbose > 2:
            self.message("handleUserInfo: " + str(packet))
        self.user_info = packet

    def handlePersonalInfo(self, packet):
        self.handleUserInfo(packet)
        self.personal_info = packet

    def handleSerial(self, packet):
        self.user.serial = packet.serial
        self.sendPacket(PacketPokerGetUserInfo(serial = packet.serial))

    def handlePlayerInfo(self, packet):
        skin = self.factory.getSkin()
        #
        # Check that the implementation of the outfit is still valid. If it
        # needs upgrade, send it back to the server.
        #
        ( url, outfit ) = skin.interpret(packet.url, packet.outfit)
        if url != packet.url or outfit != packet.outfit:
            ( url_check, outfit_check ) = self.factory.getSkin().interpret(url, outfit)
            #
            # Make sure that we wont loop indefinitely because of an instability of the interpret
            # function. In normal operation the url and outfit returned by interpret must be
            # returned as is when fed to interpret again. If the implementation of interpret
            # fails to implement this stability, don't enter a loop because sending PokerPlayerInfo
            # will return us a PokerPlayerInfo for confirmation of the success.
            #
            if url_check != url or outfit_check != outfit:
                self.error("*CRITICAL*: PACKET_POKER_PLAYER_INFO: may enter loop packet.url = %s\n url = %s\n url_check = %s\npacket.outfit = %s\n outfit = %s\n outfit_check = %s" % ( packet.url, url, url_check, packet.outfit, outfit, outfit_check ))
            else:
                packet.url = url
                packet.outfit = outfit
                self.sendPacket(packet)
        skin.setUrl(url)
        skin.setOutfit(outfit)

    def logout(self):
        self.sendPacket(PacketLogout())
        self.user.logout()

    def setPlayerDelay(self, game, serial, value):
        player = game.getPlayer(serial)
        if player == None:
            self.message("WARNING setPlayerDelay for a non-existing player %d" % serial)
        else:
            player.getUserData()['delay'] = seconds() + value

    def getPlayerDelay(self, game, serial):
        if not game: return 0
        player = game.getPlayer(serial)
        if not player: return 0
        user_data = player.getUserData()
        if not user_data or not user_data.has_key('delay'): return 0
        return user_data['delay']

    def canHandlePacket(self, packet):
        if not self.factory.isAlwaysHandled(packet) and hasattr(packet, "game_id") and hasattr(packet, "serial"):
            delay = self.getPlayerDelay(self.factory.packet2game(packet), packet.serial)
            if delay <= seconds():
                return ( True, 0 )
            else:
                return ( False, delay )
        else:
            return ( True, 0 )

    def resendPlayerTimeoutWarning(self, game):
        if game.isRunning() and game.getSerialInPosition() == self.getSerial():
            player = game.getPlayer(self.getSerial())
            if player.user_data['timeout']:
                ( when, timeout ) = player.user_data['timeout']
                now = seconds()
                timeout = timeout - ( now - when )
                if timeout > 0:
                    return ( PacketPokerTimeoutWarning(game_id = game.id,
                                                       serial = self.getSerial(),
                                                       timeout = int(timeout),
                                                       when = int(now) ), )
        return ()
        
    def setPlayerTimeout(self, game, packet):
        packet.timeout -= int(self.getLag())
        if packet.timeout > 0:
            packet.when = int(seconds())
            player = game.getPlayer(packet.serial)
            player.getUserData()['timeout'] = ( packet.when, packet.timeout )
            return True
        else:
            return False
        
    def unsetPlayerTimeout(self, game, serial):
        player = game.getPlayer(serial)
        player.getUserData()['timeout'] = None
    
    def postMuck(self, game, want_to_muck):
        if game:            
            packet_type = want_to_muck and PacketPokerMuckAccept or PacketPokerMuckDeny
            self.sendPacket(packet_type(game_id = game.id, 
                                        serial  = self.getSerial()) )
    
    def _handleConnection(self, packet):
        if self.factory.verbose > 3: self.message("PokerClientProtocol:handleConnection: %s" % packet )

        if packet.type == PACKET_POKER_TIMEOUT_WARNING:
            packet.timeout -= int(self.getLag())

        elif packet.type == PACKET_POKER_USER_INFO:
            self.handleUserInfo(packet)

        elif packet.type == PACKET_POKER_PERSONAL_INFO:
            self.handlePersonalInfo(packet)

        elif packet.type == PACKET_POKER_TABLE:
            self.setCurrentGameId(packet.id)

        elif packet.type == PACKET_SERIAL:
            self.handleSerial(packet)
            self.sendPacket(PacketPokerGetPlayerInfo())

        elif packet.type == PACKET_POKER_PLAYER_INFO:
            self.handlePlayerInfo(packet)

        game = self.factory.packet2game(packet)

        if game and packet.type == PACKET_POKER_TABLE_DESTROY:
            self.scheduleTableQuit(game)
            game = None

        #
        # It is possible to receive packets related to a game that we know nothing
        # about after quitting a table. When quitting a table the client deletes
        # all information related to the game without waiting confirmation from
        # the server. Therefore the server may keep sending packets related to
        # the game before noticing TABLE_QUIT packet.
        #
        if game:
            if packet.type == PACKET_POKER_SEAT:
                if packet.seat == -1:
                    self.error("This seat is busy")
                else:
                    if game.isTournament():
                        self.sendPacket(PacketPokerSit(serial = self.getSerial(),
                                                       game_id = game.id))

            elif packet.type == PACKET_POKER_MUCK_REQUEST:                
                if packet.game_id != self.getCurrentGameId():
                   self.postMuck(game, True)

        self.explain.explain(packet)

        if game:
            if packet.type == PACKET_POKER_PLAYER_ARRIVE:
                player = game.getPlayer(packet.serial)
                player.setUserData(DEFAULT_PLAYER_USER_DATA.copy())
        
        for forward_packet in self.explain.forward_packets:
            self.schedulePacket(forward_packet)
        self.explain.forward_packets = None

    def currentGames(self, exclude = None):
        games = self.factory.getGameIds()
        if exclude:
            games.remove(exclude)
        return PacketPokerCurrentGames(game_ids = games,
                                       count = len(games))
    
    def connectionLost(self, reason):
        if self.factory.crashing:
            self.message("connectionLost: crashing, just return.")
            return
        if self.factory.verbose:
            self.message("connectionLost: noticed, aborting all tables.")
        self.abortAllTables()
        UGAMEClientProtocol.connectionLost(self, reason)
        
    def abortAllTables(self):
        for game in self.factory.games.getAll():
            self.scheduleTableAbort(game)

    def scheduleTableAbort(self, game):
        game_id = game.id
        def thisgame(packet):
            return hasattr(packet, "game_id") and packet.game_id == game_id
        self.unschedulePackets(thisgame)
        self.discardPackets(game_id)
        self.scheduleTableQuit(game)

    def scheduleTableQuit(self, game):
        self.schedulePacket(PacketPokerBatchMode(game_id = game.id))
        for player in game.playersAll():
            packet = PacketPokerPlayerLeave(game_id = game.id,
                                            serial = player.serial,
                                            seat = player.seat)
            self.schedulePacket(packet)
        self.schedulePacket(PacketPokerStreamMode(game_id = game.id))
        self.schedulePacket(PacketPokerTableQuit(game_id = game.id,
                                                serial = self.getSerial()))
        self.schedulePacket(self.currentGames(game.id))
        self.publishAllPackets()

    def resendPackets(self, game_id):
        self.publishAllPackets()
        game = self.getGame(game_id)
        self.setCurrentGameId(game.id)
        packets = []
        packet = PacketPokerTable(id = game.id,
                                  name = game.name,
                                  variant = game.variant,
                                  seats = game.max_players,
                                  betting_structure = game.betting_structure,
                                  players = game.allCount(),
                                  # observers ?
                                  # waiting ?
                                  # player_timeout ?
                                  # muck_timeout ?
                                  hands_per_hour = game.stats["hands_per_hour"],                                  
                                  average_pot = game.stats["average_pot"],
                                  percent_flop = game.stats["percent_flop"],
                                  skin = game.level_skin
                                  )
        packets.append(PacketPokerBatchMode(game_id = game.id))
        packet.seats_all = game.seats_all
        packets.append(packet)
        packets.append(PacketPokerBuyInLimits(game_id = game.id,
                                              min = game.buyIn(self.getSerial()),
                                              max = game.maxBuyIn(self.getSerial()),
                                              best = game.bestBuyIn(self.getSerial()),
                                              rebuy_min = game.minMoney()))
        packets.append(PacketPokerDealer(game_id = game.id, dealer = game.dealer_seat))
        for player in game.playersAll():
            packets.append(PacketPokerPlayerArrive(game_id = game.id,
                                                   serial = player.serial,
                                                   name = player.name,
                                                   url = player.url,
                                                   outfit = player.outfit,
                                                   blind = player.blind,
                                                   remove_next_turn = player.remove_next_turn,
                                                   sit_out = player.sit_out,
                                                   sit_out_next_turn = player.sit_out_next_turn,
                                                   auto = player.auto,
                                                   auto_blind_ante = player.auto_blind_ante,
                                                   wait_for = player.wait_for,
                                                   seat = player.seat))
            # FIXME: Should a PokerPlayerStats() packet be sent here?
            if player.isSit():
                packets.append(PacketPokerSit(game_id = game.id,
                                              serial = player.serial))
            else:
                packets.append(PacketPokerSitOut(game_id = game.id,
                                                 serial = player.serial))
            packets.append(self.updatePlayerChips(game, player))
        packets.append(PacketPokerSeats(game_id = game.id,
                                        seats = game.seats()))
        packets.append(PacketPokerStart(game_id = game.id,
                                        hand_serial = game.hand_serial))
        if game.isRunning():
            players_with_cards = game.playersNotFold()
        elif  game.isGameEndInformationValid():
            players_with_cards = game.playersWinner()
        else:
            players_with_cards = []

        if players_with_cards:
            for player in players_with_cards:
                packet = PacketPokerPlayerCards(game_id = game.id,
                                                serial = player.serial,
                                                cards = player.hand.toRawList())
                packets.append(packet)
            packets.append(PacketPokerBoardCards(game_id = game.id,
                                                 cards = game.board.tolist(False)))
        if game.isRunning():
            if not self.no_display_packets:
                packets.extend(self.updatePotsChips(game, game.getPots()))
            packets.append(PacketPokerPosition(game_id = game.id,
                                               serial = game.getSerialInPosition()))
            if not self.no_display_packets:
                packets.extend(self.updateBetLimit(game))
        else:
            if not self.no_display_packets and game.isGameEndInformationValid():
                packets.extend(self.packetsShowdown(game))
                packets.append(PacketPokerShowdown(game_id = game.id, showdown_stack = game.showdown_stack))
        packets.append(PacketPokerStreamMode(game_id = game.id))
        packets.extend(self.resendPlayerTimeoutWarning(game))
        
        for packet in packets:
            self.schedulePacket(packet)

    def deleteGames(self):
        self.setCurrentGameId(None)
        for game_id in self.factory.getGameIds():
            self.deleteGame(game_id)
        
    def deleteGame(self, game_id):
        if self.factory.verbose > 2: self.message("deleteGame: %d" % game_id)
        self.factory.deleteGame(game_id)
        def thisgame(packet):
            return hasattr(packet, "game_id") and packet.game_id == game_id
        self.unschedulePackets(thisgame)
        self.discardPackets(game_id)

    def getGame(self, game_id):
        return self.factory.getGame(game_id)

    def sendPacket(self, packet):
        if packet.type == PACKET_POKER_TABLE_QUIT:
            self.scheduleTableAbort(self.getGame(packet.game_id))
        elif packet.type == PACKET_POKER_SIT_OUT:
            game = self.getGame(packet.game_id)
            if game:
                game.sitOutNextTurn(packet.serial)
            self.schedulePacket(PacketPokerSitOutNextTurn(game_id = packet.game_id,
                                                          serial = packet.serial))
        elif packet.type == PACKET_POKER_SIT:
            game = self.getGame(packet.game_id)
            if game:
                game.sitRequested(packet.serial)
            self.schedulePacket(PacketPokerSitRequest(game_id = packet.game_id,
                                                      serial = packet.serial))
        elif packet.type == PACKET_QUIT:
            self.ignoreIncomingData()
            self.abortAllTables()

        UGAMEClientProtocol.sendPacket(self, packet)

    def protocolEstablished(self):
        self.setPingDelay(self.factory.ping_delay)
        poll_frequency = self.factory.settings.headerGet("/settings/@poll_frequency")
        if poll_frequency:
            self._poll_frequency = float(poll_frequency)
        self.user.name = self.factory.name
        self.user.password = self.factory.password
        self._packet2id = self.packet2id
        self._packet2front = self.packet2front
        self.schedulePacket(PacketBootstrap())
        UGAMEClientProtocol.protocolEstablished(self)

    def packet2front(self, packet):
        if ( hasattr(packet, "game_id") and
             self.getGame(packet.game_id) ):
            if ( packet.type == PACKET_POKER_CHAT ):
                return True

            elif packet.type == PACKET_POKER_MESSAGE:
                return True

            elif ( packet.type == PACKET_POKER_PLAYER_ARRIVE and
                   packet.serial == self.getSerial() ):
                return True

        return False

    def registerLagmax(self, method):
        self.lagmax_callbacks.append(method)

    def unregisterLagmax(self, method):
        self.lagmax_callbacks.remove(method)
        
    def triggerLagmax(self, packet):
        for method in self.lagmax_callbacks:
            method(packet)
    
    def packet2id(self, packet):
        self.triggerLagmax(packet)
        if not self.factory.isOutbound(packet) and hasattr(packet, "game_id"):
            return packet.game_id
        elif packet.type == PACKET_POKER_TABLE:
            return packet.id
        else:
            return 0
        
    def protocolInvalid(self, server, client):
        self.schedulePacket(PacketProtocolError(message = "Upgrade the client from\nhttp://mekensleep.org/\nServer version is %s\nClient version is %s" % ( server, client ) ))
        self.publishAllPackets()
        UGAMEClientProtocol.protocolInvalid(self, server, client)

    def publishDelay(self, delay):
        if self.factory.verbose > 2: self.message("publishDelay: %f delay" % delay)
        publish_time = seconds() + delay
        if publish_time > self.publish_time:
            self.publish_time = publish_time
            
    def schedulePacket(self, packet):
        if not self.factory.isOutbound(packet) and hasattr(packet, "game_id") and not self.factory.gameExists(packet.game_id):
            return
        self.publish_packets.append(packet)
        if not self._poll:
            self.publishPacket()
        else:
            self.publishPacketTriggerTimer()
            
    def unschedulePackets(self, predicate):
        self.publish_packets = filter(lambda packet: not predicate(packet), self.publish_packets)
        if self._poll:
            self.publishPacketTriggerTimer()
        
    def publishPackets(self):
        if not self._poll:
            return

        delay = 0.01
        if len(self.publish_packets) > 0:
            #
            # If time has not come, make sure we are called at a later time
            # to reconsider the situation
            #
            wait_for = self.publish_time - seconds()
            if wait_for > 0:
                if self.factory.verbose > 2:
                    self.message("publishPackets: %f before next packet is sent" % wait_for)
                delay = wait_for
                self.block()
            else:
                self.publishPacket()
                if len(self.publish_packets) > 0:
                    self.block()
                else:
                    self.unblock()
        else:
            self.unblock()
            
        self.publishPacketTriggerTimer(delay)

    def publishPacketTriggerTimer(self, delay = 0.01):
        if not self.publish_timer or not self.publish_timer.active():
            if len(self.publish_packets) > 0:
                self.publish_timer = reactor.callLater(delay, self.publishPackets)

    def publishPacket(self):
        packet = self.publish_packets[0]
        if not self.established and not self.factory.isConnectionLess(packet):
            if self.factory.verbose > 5:
                self.message("publishPacket: skip because connection not established")
            return
        self.publish_packets.pop(0)
        what = 'outbound'
        if hasattr(packet, "game_id"):
            if self.factory.isOutbound(packet):
                what = 'outbound'
            else:
                if packet.game_id == self.getCurrentGameId():
                    what = 'current'
                else:
                    what = 'not_current'
        elif ( packet.type == PACKET_POKER_TABLE or
               packet.type == PACKET_POKER_TABLE_QUIT ):
            what = 'current'
        else:
            what = 'outbound'

        if self.factory.verbose > 2: self.message("publishPacket(%d): %s: %s" % ( self.getSerial(), what, packet ) )
        if self.callbacks[what].has_key(packet.type):
            callbacks = self.callbacks[what][packet.type]
            for callback in callbacks:
                callback(self, packet)
        
    def publishAllPackets(self):
        while len(self.publish_packets) > 0:
            self.publishPacket()

########NEW FILE########
__FILENAME__ = pokerclientpackets
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Which packets describe where the chips go ?
#
# PACKET_POKER_CHIPS_PLAYER2BET
# PACKET_POKER_CHIPS_BET2POT
# PACKET_POKER_CHIPS_POT2PLAYER
# PACKET_POKER_CHIPS_BET2PLAYER
# PACKET_POKER_CHIPS_POT_MERGE
#
from struct import pack, unpack
import simplejson
import types
import decimal

from pokerengine.pokercards import PokerCards
from pokerengine.pokerchips import PokerChips

from pokernetwork.packets import Packet
from pokernetwork.pokerpackets import *

def chips2amount(chips):
    amount = 0
    for i in xrange(len(chips) / 2):
        amount += chips[i*2] * chips[i*2 + 1]
    return amount

class PokerClientPacketJSON(simplejson.JSONEncoder):

    def default(self, object):
        if isinstance(object, PokerCards):
            return ['Cards'] + [255] * len(object.cards)
        elif isinstance(object, PokerChips):
            return ['Chips', object.toint()]
        elif isinstance(object, decimal.Decimal):
            return str(object)
        else:
            return simplejson.JSONEncoder.default(self, object)

    @staticmethod
    def decode_objects(something):
        if type(something) is types.ListType:
            if something[0] in ('Cards', 'Chips'):
                if something[0] == 'Cards':
                    return PokerCards(something[1:])
                elif something[0] == 'Chips':
                    return PokerChips([1],[something[1]])
            else:
                return map(PokerClientPacketJSON.decode_objects, something)
        elif type(something) is types.DictType:
            return dict(map(lambda (k, v): [k, PokerClientPacketJSON.decode_objects(v)], something.iteritems()))
        else:
            return something
    
Packet.JSON = PokerClientPacketJSON()

class PokerClientPackets:
    @staticmethod
    def unpackchips(block):
        amount = int(unpack('!I', block[:4])[0])
        if amount > 0:
            chips = (1, amount)
        else:
            chips = []
        return ( block[4:], chips )
    
Packet.format_info['c'] = {
    'pack': lambda data: pack('!I', chips2amount(data)),
    'unpack': PokerClientPackets.unpackchips,
    'calcsize': lambda data: 4,
    }

########################################

class PacketPokerBestCards(PacketPokerCards):
    """\
Semantics: ordered list  of five "bestcards" hand for
player "serial" in game "game_id" that won the "side"
side of the pot. The "board", if not empty, is the list
of community cards at showdown. Also provides the
"cards" of the player.

Direction: client <=> client

cards: list of integers describing the player cards:

       2h/00  2d/13  2c/26  2s/39
       3h/01  3d/14  3c/27  3s/40
       4h/02  4d/15  4c/28  4s/41
       5h/03  5d/16  5c/29  5s/42
       6h/04  6d/17  6c/30  6s/43
       7h/05  7d/18  7c/31  7s/44
       8h/06  8d/19  8c/32  8s/45
       9h/07  9d/20  9c/33  9s/46
       Th/08  Td/21  Tc/34  Ts/47
       Jh/09  Jd/22  Jc/35  Js/48
       Qh/10  Qd/23  Qc/36  Qs/49
       Kh/11  Kd/24  Kc/37  Ks/50
       Ah/12  Ad/25  Ac/38  As/51
       
bestcards: list of integers describing the winning combination cards:
board: list of integers describing the community cards:
hand: readable string of the name best hand
besthand: 0 if it's not the best hand and 1 if it's the best hand
         best hand is the hand that win the most money
       
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    info = PacketPokerCards.info + ( ("side", "", 's'),
                                     ("hand", "", 's'),
                                     ("bestcards", [], 'Bl'),
                                     ("board", [], 'Bl'),
                                     ("besthand", 0, 'B'),
                                     )

Packet.infoDeclare(globals(), PacketPokerBestCards, PacketPokerCards, 'POKER_BEST_CARDS', 170) # 0xaa # %SEQ%

########################################

class PacketPokerPotChips(Packet):
    """\
Semantics: the "bet" put in the "index" pot of the "game_id" game.

Direction: client <=> client

context: this packet is sent at least each time the pot index is
updated.

bet: list of pairs ( chip_value, chip_count ).
index: integer uniquely identifying a side pot in the range [0,10[
game_id: integer uniquely identifying a game.
"""

    info = Packet.info + ( ("game_id", 0, 'I'),
                           ("index", 0, 'B'),
                           ("bet", [], 'c'),
                           )

Packet.infoDeclare(globals(), PacketPokerPotChips, Packet, 'POKER_POT_CHIPS', 171) # 0xab # %SEQ%

########################################

class PacketPokerClientAction(PacketPokerId):
    """

    The action available/not available to the player
    
    """

    info = PacketPokerId.info + ( ("display", 0, 'B'),
                                  ("action", "", 's'),
                                  )

Packet.infoDeclare(globals(), PacketPokerClientAction, PacketPokerId, 'POKER_CLIENT_ACTION', 172) # 0xac # %SEQ%

########################################

class PacketPokerBetLimit(PacketPokerId):
    """\
Semantics: a raise must be at least "min" and most "max".
A call means wagering an amount of "call". The suggested
step to slide between "min" and "max" is "step". The step
is guaranteed to be an integral divisor of "call". The
player would be allin for the amount "allin". The player
would match the pot if betting "pot".

Context: this packet is issued each time a position change
occurs.

Direction: client <=> client

min: the minimum amount of a raise.
max: the maximum amount of a raise.
step: a hint for sliding in the [min, max] interval.
call: the amount of a call.
allin: the amount for which the player goes allin.
pot: the amount in the pot.
game_id: integer uniquely identifying a game.
"""

    info = PacketPokerId.info + ( ("min", 0, 'I'),
                                  ("max", 0, 'I'),
                                  ("step", 0, 'I'),
                                  ("call", 0, 'I'),
                                  ("allin", 0, 'I'),
                                  ("pot", 0, 'I'),
                                  )

Packet.infoDeclare(globals(), PacketPokerBetLimit, PacketPokerId, 'POKER_BET_LIMIT', 173) # 0xad # %SEQ%

########################################

class PacketPokerSitRequest(PacketPokerSit):
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerSitRequest, PacketPokerId, "POKER_SIT_REQUEST", 174) # 0xae # %SEQ%

########################################

class PacketPokerPlayerNoCards(PacketPokerId):
    """\
Semantics: the player "serial" has no cards in game "game_id".

Direction: client <=> client

Context: inferred at showdown.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerPlayerNoCards, PacketPokerId, "POKER_PLAYER_NO_CARDS", 175) # 0xaf # %SEQ%

######################################## 

class PacketPokerChipsPlayer2Bet(PacketPokerId):
    """\
Semantics: move "chips" from the player "serial" money chip stack
to the bet chip stack.

Direction: client <=> client

chips: list of pairs ( chip_value, chip_count ).
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    info = PacketPokerId.info + (
        ('chips', [], 'c' ),
        )
    
Packet.infoDeclare(globals(), PacketPokerChipsPlayer2Bet, PacketPokerId, 'POKER_CHIPS_PLAYER2BET', 176) # 0xb0 # %SEQ%

######################################## 

class PacketPokerChipsBet2Pot(PacketPokerId):
    """\
Semantics: move "chips" from the player "serial" bet chip stack
to the "pot" pot.

Direction: client <=> client

Context: the pot index is by definition in the range [0,9] because
it starts at 0 and because there cannot be more pots than players.
The creation of side pots is inferred by the client when a player
is all-in and it is guaranteed that pots are numbered sequentially.

pot: the pot index in the range [0,9].
chips: list of integers counting the number of chips to move.
     The value of each chip is, respectively:
     1 2 5 10 20 25 50 100 250 500 1000 2000 5000.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""
    info = PacketPokerId.info + (
        ('chips', [], 'c' ),
        ('pot', -1, 'b' ),
        )
    
Packet.infoDeclare(globals(), PacketPokerChipsBet2Pot, PacketPokerId, 'POKER_CHIPS_BET2POT', 177) # 0xb1 # %SEQ%

######################################## Display packet

class PacketPokerChipsPot2Player(PacketPokerId):
    """\
Semantics: move "chips" from the pot "pot" to the player "serial"
money chip stack. The string "reason" explains why these chips 
are granted to the player. If reason is "win", it means the player
won the chips either because all other players folded or because
he had the best hand at showdown. If reason is "uncalled", it means
the chips are returned to him because no other player was will or
able to call his wager. If reason is "left-over", it means the chips
are granted to him because there was an odd chip while splitting the pot.

Direction: client <=> client

Context: the pot index is by definition in the range [0,9] because
it starts at 0 and because there cannot be more pots than players.
The creation of side pots is inferred by the client when a player
is all-in and it is guaranteed that pots are numbered sequentially.

reason: may be one of "win", "uncalled", "left-over"
pot: the pot index in the range [0,9].
chips: list of integers counting the number of chips to move.
     The value of each chip is, respectively:
     1 2 5 10 20 25 50 100 250 500 1000 2000 5000.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    info = PacketPokerId.info + (
        ('chips', [], 'c' ),
        ('pot', -1, 'b' ),
        ('reason', '', 's' ),
        )

Packet.infoDeclare(globals(), PacketPokerChipsPot2Player, PacketPokerId, 'POKER_CHIPS_POT2PLAYER', 178) # 0xb2 # %SEQ%

######################################## Display packet

class PacketPokerChipsPotMerge(PacketPokerId):
    """\
Semantics: merge the pots whose indexes are listed in
"sources" into a single pot at index "destination" in game "game_id".

Direction: client <=> client

Context: when generating PACKET_POKER_CHIPS_POT2PLAYER packets, if
multiple packet can be avoided by merging pots (e.g. when one player
wins all the pots).

destination: a pot index in the range [0,9].
sources: list of pot indexes in the range [0,9].
game_id: integer uniquely identifying a game.
"""

    info = PacketPokerId.info + (
        ('sources', [], 'Bl' ),
        ('destination', 0, 'B' ),
        )

Packet.infoDeclare(globals(), PacketPokerChipsPotMerge, PacketPokerId, 'POKER_CHIPS_POT_MERGE', 179) # 0xb3 # %SEQ%

######################################## Display packet

class PacketPokerChipsPotReset(PacketPokerId):
    """\
Semantics: all pots for game "game_id" are set to zero.

Direction: client <=> client

Context: it is inferred after a PACKET_POKER_TABLE or a
 PACKET_POKER_START packet is sent by the server. It is inferred
after the pot is distributed (i.e. after the game terminates
because a PACKET_POKER_WIN or PACKET_POKER_CANCELED is received).

game_id: integer uniquely identifying a game.
"""
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerChipsPotReset, PacketPokerId, "POKER_CHIPS_POT_RESET", 180) # 0xb4 # %SEQ%

######################################## Display packet

class PacketPokerChipsBet2player(PacketPokerChipsPlayer2Bet):
    """chips move from bet to player"""
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerChipsBet2player, PacketPokerChipsPlayer2Bet, "POKER_CHIPS_BET2PLAYER", 181) # 0xb5 # %SEQ%

######################################## Display packet

class PacketPokerEndRound(PacketPokerId):
    """\
Semantics: closes a betting round for game "game_id".

Direction: client <=> client

Context: inferred at the end of a sequence of packet related to
a betting round. Paying the blind / ante is not considered a
betting round. This packet is sent when the client side
knows that the round is finished but before the corresponding
packet (PACKET_POKER_STATE) has been received from the server.
It will be followed by the POKER_BEGIN_ROUND packet, either
immediatly if the server has no delay between betting rounds
or later if the server waits a few seconds between two betting
rounds.
It is not inferred at the end of the last betting round.

game_id: integer uniquely identifying a game.
"""
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerEndRound, PacketPokerId, "POKER_END_ROUND", 182) # 0xb6 # %SEQ%

########################################

class PacketPokerDisplayNode(Packet):
    """request POKER_DISPLAY_NODE packet"""

    info = Packet.info + (
        ('game_id', 0, 'I'),
        ('name', '', 's'),
        ('state', 0, 'I'),
        ('style', '', 's'),
        ('selection', None, 'no net'),
        )
    
Packet.infoDeclare(globals(), PacketPokerDisplayNode, Packet, 'POKER_DISPLAY_NODE', 183) # 0xb7 # %SEQ%

######################################## Display packet

class PacketPokerDealCards(PacketPokerId):
    """\
Semantics: deal "numberOfCards" down cards for each player listed
in "serials" in game "game_id".

Direction: client <=> client

Context: inferred after the beginning of a betting round (i.e.
after the PACKET_POKER_STATE packet is received) and after
the chips involved in the previous betting round have been
sorted (i.e. after PACKET_POKER_CHIPS_BET2POT packets are
inferred). Contrary to the PACKET_POKER_PLAYER_CARDS,
this packet is only sent if cards must be dealt. It
is guaranteed that this packet will always occur before
the PACKET_POKER_PLAYER_CARDS that specify the cards to
be dealt and that these packets will follow immediately
after it (no other packet will be inserted between this packet
and the first PACKET_POKER_PLAYER_CARDS). It is also guaranteed
that exactly one PACKET_POKER_PLAYER_CARDS will occur for each
serial listed in "serials".

numberOfCards: number of cards to be dealt.
serials: integers uniquely identifying players.
game_id: integer uniquely identifying a game.
"""
    info = PacketPokerId.info + (
        ('numberOfCards', 2, 'B'),
        ('serials', [], 'Il'),
        )

Packet.infoDeclare(globals(), PacketPokerDealCards, PacketPokerId, 'POKER_DEAL_CARDS', 184) # 0xb8 # %SEQ%

########################################

class PacketPokerChatHistory(Packet):
    """chat history show"""

    info = Packet.info + (
        ('show', 'no', 's'),
        )

Packet.infoDeclare(globals(), PacketPokerChatHistory, Packet, "POKER_CHAT_HISTORY", 185) # 0xb9 # %SEQ%
    
########################################

class PacketPokerDisplayCard(PacketPokerId):
    """Hide a player card"""

    info = PacketPokerId.info + (
        ('index', [], 'Bl'),
        ('display', 0, 'B'),
        )

Packet.infoDeclare(globals(), PacketPokerDisplayCard, PacketPokerId, "POKER_DISPLAY_CARD", 186) # 0xba # %SEQ%

########################################

class PacketPokerSelfInPosition(PacketPokerPosition):
    """\
Semantics: the player authenticated for this connection
is in position. Otherwise identical to PACKET_POKER_POSITION.

"""
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerSelfInPosition, PacketPokerPosition, "POKER_SELF_IN_POSITION", 187) # 0xbb # %SEQ%

########################################

class PacketPokerSelfLostPosition(PacketPokerPosition):
    """\
Semantics: the player authenticated for this connection
is in position. Otherwise identical to PACKET_POKER_POSITION.

"""
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerSelfLostPosition, PacketPokerPosition, "POKER_SELF_LOST_POSITION", 188) # 0xbc # %SEQ%

########################################

class PacketPokerHighestBetIncrease(PacketPokerId):
    """\
Semantics: a wager was made in game "game_id" that increases
the highest bet amount. 

Direction: client <=> client

Context: inferred whenever a wager is made that changes
the highest bet (live blinds are considered a wager, antes are not).
Inferred once per blindAnte round: when the
first big blind is posted. It is therefore guaranteed not to be posted
if a game is canceled because noone wanted to pay the big blind, even
if someone already posted the small blind. In all other betting rounds it
is inferred for each raise.

game_id: integer uniquely identifying a game.
"""
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerHighestBetIncrease, PacketPokerId, "POKER_HIGHEST_BET_INCREASE", 189) # 0xbd # %SEQ%

########################################

class PacketPokerPlayerWin(PacketPokerId):
    """\
Semantics: the player "serial" win.

Direction: client <=> client

Context: when a PacketPokerWin arrive from server. The packet is generated
from PACKET_PLAYER_WIN. For each player that wins something a packet
PlayerWin is generated.

serial: integer uniquely identifying a player.
"""
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerPlayerWin, PacketPokerId, "POKER_PLAYER_WIN", 190) # 0xbe # %SEQ%

########################################

class PacketPokerAnimationPlayerNoise(PacketPokerId):
    """\
Semantics: the player "serial" play or stop noise animation.

Direction: client <=> client

Context: a PacketPokerPlayerNoise is send to the client c++ to stop or start
player's noise animation.

serial: integer uniquely identifying a player.
action: string that contain "start" or "stop".
"""

    info = PacketPokerId.info + (
        ('action', 'start', 's'),
        )
    
Packet.infoDeclare(globals(), PacketPokerAnimationPlayerNoise, PacketPokerId, "POKER_ANIMATION_PLAYER_NOISE", 191) # 0xbf # %SEQ%

########################################

class PacketPokerAnimationPlayerFold(PacketPokerId):
    """\
Semantics: the player "serial" play an animation fold.

Direction: client <=> client

Context: a PacketPokerPlayerNoise is send to the client c++ to stop or start
player's noise animation.

serial: integer uniquely identifying a player.
animation: string used to select an animation fold.
"""

    info = PacketPokerId.info + (
        ('animation', 'UNKNOWN', 's'),
        )

Packet.infoDeclare(globals(), PacketPokerAnimationPlayerFold, PacketPokerId, "POKER_ANIMATION_PLAYER_FOLD", 192) # 0xc0 # %SEQ%

########################################

class PacketPokerAnimationPlayerBet(PacketPokerId):
    """\
"""

    info = PacketPokerId.info + (
        ('animation', '', 's'),
        ('chips', [], 'c'),
        ('amount', 0, 'I'),
        )

    def infoInit(self, **kwargs):
        Packet.infoInit(self, **kwargs)
        self.amount = chips2amount(self.chips)
        
Packet.infoDeclare(globals(), PacketPokerAnimationPlayerBet, PacketPokerId, "POKER_ANIMATION_PLAYER_BET", 193) # 0xc1 # %SEQ%

########################################

class PacketPokerAnimationPlayerChips(PacketPokerId):
    """\
"""
    info = PacketPokerId.info + (
        ('animation', '', 's'),
        ('chips', [], 'c'),
        ('state', '', 's'),
        ('amount', 0, 'I'),
        )

    def infoInit(self, **kwargs):
        Packet.infoInit(self, **kwargs)
        self.amount = chips2amount(self.chips)
        
Packet.infoDeclare(globals(), PacketPokerAnimationPlayerChips, PacketPokerId, "POKER_ANIMATION_PLAYER_CHIPS", 194) # 0xc2 # %SEQ%

########################################

class PacketPokerAnimationDealerChange(PacketPokerId):
    """\
"""

    info = PacketPokerId.info + (
        ('state', 'UNKNOWN', 's'),
        )

Packet.infoDeclare(globals(), PacketPokerAnimationDealerChange, PacketPokerId, "POKER_ANIMATION_DEALER_CHANGE", 195) # 0xc3 # %SEQ%

########################################

class PacketPokerAnimationDealerButton(PacketPokerId):
    """\
"""

    info = PacketPokerId.info + (
        ('state', 'UNKNOWN', 's'),
        )

Packet.infoDeclare(globals(), PacketPokerAnimationDealerButton, PacketPokerId, "POKER_ANIMATION_DEALER_BUTTON", 196) # 0xc4 # %SEQ%

########################################

class PacketPokerBeginRound(PacketPokerId):
    """\
Semantics: opens a betting round for game "game_id".

Direction: client <=> client

Context: inferred when the client knows that a betting round will
begin although it does not yet received information from the server to
initialize it. Paying the blind / ante is not considered a betting
round. It follows the POKER_END_ROUND packet, either
immediatly if the server has no delay between betting rounds
or later if the server waits a few seconds between two betting
rounds.

Example applied to holdem:

         state

         blind     END
BEGIN    preflop   END
BEGIN    flop      END
BEGIN    turn      END
BEGIN    river
         end

game_id: integer uniquely identifying a game.
"""
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerBeginRound, PacketPokerId, "POKER_BEGIN_ROUND", 197) # 0xc5 # %SEQ%

########################################

class PacketPokerCurrentGames(Packet):
    """\
Semantics: "game_ids" contains the the list of games to 
which the client is connected. "count" is the length of
the "game_ids" list.

Direction: client <=> client

Context: inferred when the client receives a POKER_TABLE packet (for
instance, a POKER_TABLE packet is sent to the client when a
POKER_TABLE_JOIN was sent to the server).  The list of game ids
contains the id matching the POKER_TABLE packet that was just
received.

Note to applications embedding the poker-network python library:
When not in the context of a POKER_EXPLAIN server mode,
the packet is also inferred as a side effect of the 
PokerExplain.packetsTableQuit method that is called by the application 
when the user decides to leave the table.

game_ids: integers uniquely identifying a game.
count: length of game_ids.
"""

    info = Packet.info + (
        ('game_ids', [], 'Il'),
        ('count', 0, 'B'),
        )

Packet.infoDeclare(globals(), PacketPokerCurrentGames, Packet, "POKER_CURRENT_GAMES", 198) # 0xc6 # %SEQ%

######################################## Display packet

class PacketPokerEndRoundLast(PacketPokerId):
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerEndRoundLast, PacketPokerId, "POKER_END_ROUND_LAST", 199) # 0xc7 # %SEQ%

######################################## Stop or Start animation

class PacketPokerPythonAnimation(PacketPokerId):

    info = PacketPokerId.info + (
        ('animation', 'none', 's'),
        )
    
Packet.infoDeclare(globals(), PacketPokerPythonAnimation, PacketPokerId, "POKER_PYTHON_ANIMATION", 200) # 0xc8 # %SEQ%

########################################

class PacketPokerSitOutNextTurn(PacketPokerSitOut):
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerSitOutNextTurn, PacketPokerId, "POKER_SIT_OUT_NEXT_TURN", 201) # 0xc9 # %SEQ%

########################################

class PacketPokerRendererState(Packet):

    info = Packet.info + (
        ('state', 'idle', 's'),
        )
    
Packet.infoDeclare(globals(), PacketPokerRendererState, Packet, "POKER_RENDERER_STATE", 202) # 0xca # %SEQ%

########################################

class PacketPokerChatWord(PacketPokerId):

    info = PacketPokerId.info + (
        ('word', 'no word', 's'),
        )
    
Packet.infoDeclare(globals(), PacketPokerChatWord, PacketPokerId, "POKER_CHAT_WORD", 203) # 0xcb # %SEQ%

########################################

class PacketPokerShowdown(PacketPokerId):

    info = PacketPokerId.info + (
        ('showdown_stack', {}, 'j'),
        )

Packet.infoDeclare(globals(), PacketPokerShowdown, PacketPokerId, "POKER_SHOWDOWN", 204) # 0xcc # %SEQ%

########################################

class PacketPokerClientPlayerChips(Packet):

    info = Packet.info + (
        ('game_id', 0, 'I'),
        ('serial', 0, 'I'),
        ('bet', [], 'c'),
        ('money', [], 'c'),
        )

Packet.infoDeclare(globals(), PacketPokerClientPlayerChips, Packet, "POKER_CLIENT_PLAYER_CHIPS", 205) # 0xcd # %SEQ%

########################################

class PacketPokerInterfaceCommand(Packet):

    info = Packet.info + (
        ('window', None, 'no net'),
        ('command', None, 'no net'),
        )

Packet.infoDeclare(globals(), PacketPokerInterfaceCommand, Packet, "POKER_INTERFACE_COMMAND", 206) # 0xce # %SEQ%

########################################

class PacketPokerPlayerMeLookCards(PacketPokerId):
    """\
Semantics: the player "serial" is looking at his cards
in game "game_id".

Direction: client <=> client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""
    info = PacketPokerId.info + (
        ('state', 'UNKNOWN', 's'),
        ('when', 'now', 's'),
        )

Packet.infoDeclare(globals(), PacketPokerPlayerMeLookCards, PacketPokerId, "POKER_PLAYER_ME_LOOK_CARDS", 207) # 0xcf # %SEQ%

########################################

class PacketPokerPlayerMeInFirstPerson(PacketPokerId):

    info = PacketPokerId.info + (
        ('state', 'UNKNOWN', 's'),
        )

Packet.infoDeclare(globals(), PacketPokerPlayerMeInFirstPerson, PacketPokerId, "POKER_PLAYER_ME_IN_FIRST_PERSON", 208) # 0xd0 # %SEQ%

########################################

class PacketPokerAllinShowdown(Packet):
    """\
Semantics: the game "game_id" will automatically go to showdown

Direction: client <=> client

Context: when all players are all-in, the board cards will be
dealt automatically. The POKER_ALLIN_SHOWDOWN packet is created
as soon as such a situation is detected. The client can chose
to behave differently, for instance to postpone the display of
the board cards until after the muck phase of the game.

game_id: integer uniquely identifying a game.
"""
    info = Packet.info + ( ( 'game_id', 0, 'I'), )

Packet.infoDeclare(globals(), PacketPokerAllinShowdown, Packet, "POKER_ALLIN_SHOWDOWN", 209) # 0xd1 # %SEQ%

########################################

class PacketPokerPlayerHandStrength(PacketPokerId):
    """\
Semantics: "hand" is the human-readable description of the best
possible poker hand the player (represented by "serial") can currently
make in current hand being played in game, "game_id".  This
description includes only 'made' poker hands, not draws or potential
hands.  This description will be sent in the the language of the
players currently set locale (see PacketPokerSetLocale()), or "en.US"
if no translation is available.

Direction: client <=> client

Context: inferred on each street.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
hand: readable player best hand.
"""

    info = PacketPokerId.info + (
        ('hand', '', 's'),
        )

Packet.infoDeclare(globals(), PacketPokerPlayerHandStrength, PacketPokerId, "POKER_PLAYER_HAND_STRENGTH", 210) # 0xd2 # %SEQ%

_TYPES = range(170,254)

# Interpreted by emacs
# Local Variables:
# compile-command: "perl -pi -e 'if(/%SEQ%/) { $s = 169 if(!defined($s)); $s++; $h = sprintf(q/0x%x/, $s); s/\\d+[) \\w#]+#/$s) # $h #/; }' pokerclientpackets.py"
# End:

########NEW FILE########
__FILENAME__ = pokerdatabase
#
# -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
import os
from os.path import exists
import re
from traceback import format_exc, print_stack
import MySQLdb
from MySQLdb.cursors import DictCursor

class ExceptionDatabaseTooOld(Exception): pass
class ExceptionSoftwareTooOld(Exception): pass
class ExceptionUpgradeMissing(Exception): pass
class ExceptionUpgradeFailed(Exception): pass

from pokernetwork.version import Version, version

class PokerDatabase:

    def __init__(self, settings):
        self.verbose = settings.headerGetInt("/server/@verbose")
        self.parameters = settings.headerGetProperties("/server/database")[0]
        self.mysql_command = settings.headerGet("/server/database/@command")
        try:
            self.db = MySQLdb.connect(host = self.parameters["host"],
                                      port = int(self.parameters.get("port", '3306')),
                                      user = self.parameters["user"],
                                      passwd = self.parameters["password"],
                                      db = self.parameters["name"],
                                      reconnect = 1)
            if self.verbose > 2:
                self.message("MySQL server version is " + self.db.get_server_info())
        except:
            if self.parameters.has_key('root_user'):
                if self.verbose:
                    self.message("connecting as root user '" + self.parameters["root_user"] + "'")
                db = MySQLdb.connect(host = self.parameters["host"],
                                     port = int(self.parameters.get("port", '3306')),
                                     user = self.parameters["root_user"],
                                     passwd = self.parameters["root_password"],
                                     reconnect = 1)
                if self.verbose:
                    self.message("MySQL server version is " + db.get_server_info())
                if int(db.get_server_info().split('.')[0]) < 5:
                    raise UserWarning, "PokerDatabase: MySQL server version is " + db.get_server_info() + " but version >= 5.0 is required"
                db.query("SHOW DATABASES LIKE '" + self.parameters["name"] + "'")
                result = db.store_result()
                #
                # It may be because the database does not exist
                #
                if result.num_rows() <= 0:
                    if self.verbose:
                        self.message("creating database " + self.parameters["name"])
                    if not exists(self.parameters["schema"]):
                        db.close()
                        raise UserWarning, "PokerDatabase: schema " + self.parameters["schema"] + " file not found"
                    del result
                    db.query("CREATE DATABASE " + self.parameters["name"])
                    if self.verbose:
                        self.message("populating database from " + self.parameters["schema"])
                    cmd = self.mysql_command + " --host='" + self.parameters["host"] + "' --user='" + self.parameters["root_user"] + "' --password='" + self.parameters["root_password"] + "' '" + self.parameters["name"] + "' < " + self.parameters["schema"]
                    if self.verbose:
                        self.message(cmd)
                    os.system(cmd)
                db.select_db("mysql")
                #
                # Or because the user does not exist
                #
                try:
                    sql = "CREATE USER '" + self.parameters['user'] + "'@'%' IDENTIFIED BY '" + self.parameters['password'] + "'"
                    if self.verbose > 2:
                        self.message(sql)
                    db.query(sql)
                    sql = "CREATE USER '" + self.parameters['user'] + "'@'localhost' IDENTIFIED BY '" + self.parameters['password'] + "'"
                    if self.verbose > 2:
                        self.message(sql)
                    db.query(sql)
                    db.query("FLUSH PRIVILEGES")
                    if self.verbose:
                        self.message("created database user " + self.parameters["user"])
                except:
                    if self.verbose > 3: self.message(format_exc())
                    if self.verbose:
                        self.message("poker user '" + self.parameters["user"] + "' already exists")
                #
                # Or because the user does not have permission
                #
                db.query("GRANT ALL ON `" + self.parameters['name'] + "`.* TO '" + self.parameters['user'] + "'@'%'")
                db.query("FLUSH PRIVILEGES")
                db.close()
                if self.verbose:
                    self.message("granted privilege to " + self.parameters["user"] + "' for database '" + self.parameters['name'] + "'")
            else:
                if self.verbose:
                    self.message("root_user is not defined in the self.parameters, cannot create schema database")
            self.db = MySQLdb.connect(host = self.parameters["host"],
                                      port = int(self.parameters.get("port", '3306')),
                                      user = self.parameters["user"],
                                      passwd = self.parameters["password"],
                                      db = self.parameters["name"],
                                      reconnect = 1)

        if self.verbose:
            self.message("PokerDatabase: Database connection to %s/%s open" % ( self.parameters["host"], self.parameters["name"] ))
        self.db.query("SET AUTOCOMMIT = 1")
        self.version = Version(self.getVersionFromDatabase())
        if self.verbose:
            self.message("PokerDatabase: database version %s" % self.version)

    def message(self, string):
        print "PokerDatabase: " + string

    def error(self, string):
        self.message("*ERROR* " + string)

    def close(self):
        if hasattr(self, 'db'):
            self.db.close()

    def getVersionFromDatabase(self):
        try:
            cursor = self.cursor(DictCursor)
            cursor.execute("SELECT * FROM server")
            row = cursor.fetchone()
            version = row['version']
            cursor.close()
            return version
        except:
            if self.verbose:
                self.message("PokerDatabase: no server table, assuming version 1.0.5")
            return "1.0.5"

    def setVersionInDatabase(self, version):
        cursor = self.cursor()
        sql = "update server set version = '%s'" % version
        cursor.execute(sql)
        if cursor.rowcount not in (0, 1):
            raise ExceptionUpgradeFailed, "%s: changed %d rows, expected one or zero" % ( sql, cursor.rowcount )
        cursor.close()

    def checkVersion(self):
        if version != self.version:
            self.message("database version %s must be the same as the poker-network version %s" % ( self.version, version ))
            if version > self.version:
                self.message("upgrade the database with pokerdatabaseupgrade")
                raise ExceptionDatabaseTooOld
            else:
                self.error("upgrade poker-network to version %s or better" % self.version)
                raise ExceptionSoftwareTooOld

    def upgrade(self, directory, dry_run):
        try:
            self.checkVersion()
        except ExceptionDatabaseTooOld:
            files = filter(lambda file: ".sql" == file[-4:], os.listdir(directory))
            files = map(lambda file: directory + "/" + file, files)
            parameters = self.parameters
            mysql = self.mysql_command + " -h '" + parameters['host'] + "' -u '" + parameters['user'] + "' --password='" + parameters['password'] + "' '" + parameters['name'] + "'"
            for file in self.version.upgradeChain(version, files):
                self.message("apply " + file)
                if not dry_run:
                    if os.system(mysql + " < " + file):
                        raise ExceptionUpgradeFailed, "upgrade failed"
            self.message("upgraded database to version %s" % version)
            if not dry_run:
                self.setVersionInDatabase(version)
                self.version = Version(self.getVersionFromDatabase())

    def getVersion(self):
        return self.version

    def commit(self):
        """If the database and the tables support transactions, this commits the
        current transaction; otherwise it does nothing."""
        return self.db.commit()

    def cursor(self, *args, **kwargs):
        return self.db.cursor(*args, **kwargs)

    def literal(self, args):
        return self.db.literal(args)


########NEW FILE########
__FILENAME__ = pokerexplain
# -*- py-indent-offset: 4; coding: iso-8859-1; mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
from string import lower

from twisted.python.runtime import seconds

from pokerengine.pokerchips import PokerChips
from pokerengine.pokergame import history2messages

from pokernetwork.pokergameclient import PokerNetworkGameClient
from pokernetwork.pokerpackets import *
from pokernetwork.pokerclientpackets import *

DEFAULT_PLAYER_USER_DATA = { 'timeout': None }

class PokerGames:

    def __init__(self, **kwargs):
        self.games = {}
        self.dirs = kwargs.get("dirs", [])
        self.verbose = kwargs.get("verbose", 0)
        self.prefix = kwargs.get("prefix", "")
    
    def getGame(self, game_id):
        if not hasattr(self, "games") or not self.games.has_key(game_id):
            return False
        else:
            return self.games[game_id]

    def getGameByNameNoCase(self, name):
        name = lower(name)
        for (serial, game) in self.games.iteritems():
            if lower(game.name) == name:
                return game
        return None
    
    def getOrCreateGame(self, game_id):
        if not self.games.has_key(game_id):
            game = PokerNetworkGameClient("poker.%s.xml", self.dirs)
            game.prefix = self.prefix
            game.verbose = self.verbose
            game.id = game_id
            self.games[game_id] = game

        return self.games[game_id]

    def getGameIds(self):
        return self.games.keys()
    
    def deleteGame(self, game_id):
        del self.games[game_id]

    def packet2game(self, packet):
        if hasattr(packet, "game_id") and self.games.has_key(packet.game_id):
            return self.games[packet.game_id]
        else:
            return False

    def gameExists(self, game_id):
        return self.games.has_key(game_id)

    def getAll(self):
        return self.games.values()

class ListHintSubset(Exception):
    pass

class PokerExplain:
    """Expand poker packets for the caller when they know nothing about poker """

    def __init__(self, *args, **kwargs):
        self.serial = 0
        self.no_display_packets = False
        self.pending_auth_request = False
        self.forward_packets = []
        self.chips_values = [1, 2, 5, 10, 20, 25, 50, 100, 200, 500, 1000, 2000, 2500, 5000, 10000, 25000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000, 10000000]
        self._prefix = ""
        self.games = PokerGames(**kwargs)
        self.setVerbose(kwargs.get('verbose', 0))
        self.what = kwargs.get("explain", PacketPokerExplain.ALL)

    def error(self, string):
        self.message("ERROR " + string)
        
    def message(self, string):
        print self._prefix + string
        
    def setPrefix(self, prefix):
        self._prefix = prefix
        self.games.prefix = prefix

    def setVerbose(self, verbose):
        self.verbose = verbose
        self.games.verbose = verbose
        for game in self.games.getAll():
            game.verbose = verbose

    def normalizeChips(self, game, chips):
        if game.unit in self.chips_values:
            values = self.chips_values[self.chips_values.index(game.unit):]
        else:
            values = []
        list = PokerChips(values, chips).tolist()
        if self.verbose > 4: self.message("normalizeChips: " + str(list) + " " + str(values))
        return list
            
    def updatePlayerChips(self, game, player):
        packet = PacketPokerPlayerChips(game_id = game.id,
                                        serial = player.serial,
                                        bet = player.bet,
                                        money = player.money)
        return packet

    def updatePotsChips(self, game, side_pots):
        packets = []
        
        if not side_pots:
            packet = PacketPokerChipsPotReset(game_id = game.id)
            return [ packet ]
        
        index = 0
        for (amount, total) in side_pots['pots']:
            chips = amount

            if chips == 0:
                chips = game.getPotAmount()

            bet = self.normalizeChips(game, chips)
            pot = PacketPokerPotChips(game_id = game.id,
                                      index = index,
                                      bet = bet)
            packets.append(pot)
            index += 1

        return packets

    def chipsPlayer2Bet(self, game, player, chips):
        packets = []
        packet = PacketPokerChipsPlayer2Bet(game_id = game.id,
                                            serial = player.serial,
                                            chips = self.normalizeChips(game, chips))
        packets.append(packet)
        packets.append(self.updatePlayerChips(game, player))
        if self.what & PacketPokerExplain.CHIPSTACKS:
            packets.append(self.explainPlayerChips(game, player))
        return packets

    def chipsBet2Pot(self, game, player, bet, pot_index):
        packets = []
        if ( pot_index == 0 and
             player.dead > 0 and
             game.isSecondRound() ):
            #
            # The ante or the dead are already in the pot
            #
            bet -= player.dead

        packet = PacketPokerChipsBet2Pot(game_id = game.id,
                                         serial = player.serial,
                                         chips = self.normalizeChips(game, bet),
                                         pot = pot_index)
        packets.append(packet)
        packets.append(self.updatePlayerChips(game, player))
        if self.what & PacketPokerExplain.CHIPSTACKS:
            packets.append(self.explainPlayerChips(game, player))
        return packets
        
    def chipsPot2Player(self, game, player, bet, pot_index, reason):
        packet = PacketPokerChipsPot2Player(game_id = game.id,
                                            serial = player.serial,
                                            chips = self.normalizeChips(game, bet),
                                            pot = pot_index,
                                            reason = reason)
        return packet
        
    def gameEvent(self, game_id, type, *args):
        if self.verbose > 4:
            self.message("gameEvent: game_id = %d, type = %s, args = %s" % ( game_id, type, str(args) ))

        forward_packets = self.forward_packets
        if not forward_packets:
            if self.verbose > 3:
                self.message("gameEvent: called outside _handleConnection for game %d, ignored" % game_id)
            return False

        game = self.games.getGame(game_id)
        if not game:
            if self.verbose > 3:
                self.message("gameEvent: called for unknown game %d, ignored" % game_id)
            return False

        if type == "end_round":
            forward_packets.append(PacketPokerEndRound(game_id = game_id))

        elif type == "end_round_last":
            forward_packets.append(PacketPokerEndRoundLast(game_id = game_id))

        elif type == "money2bet":
            ( serial, amount ) = args
            player = game.getPlayer(serial)
            last_action = game.historyGet()[-1][0]
            if ( last_action == "raise" or last_action == "call" ) :
                if not self.no_display_packets:
                    forward_packets.extend(self.updateBetLimit(game))
                if last_action == "raise":
                    forward_packets.append(PacketPokerHighestBetIncrease(game_id = game.id))
            if not self.no_display_packets:
                forward_packets.extend(self.chipsPlayer2Bet(game, player, amount))

        elif type == "bet2pot":
            ( serial, amount ) = args
            if not self.no_display_packets and game.isBlindAnteRound():
                player = game.getPlayer(serial)
                forward_packets.extend(self.chipsBet2Pot(game, player, amount, 0))

        elif type == "round_cap_decrease":
            if not self.no_display_packets:
                forward_packets.extend(self.updateBetLimit(game))

        elif type == "position":
            if game.inGameCount() < 2:
                forward_packets.append(PacketPokerAllinShowdown(game_id = game.id))
                
        return True

    def handleSerial(self, packet):
        self.serial = packet.serial
        if self._prefix == '':
            self.setPrefix('[%i]' % packet.serial)

    def getSerial(self):
        return self.serial

    def resendPlayerTimeoutWarning(self, game):
        if game.isRunning() and game.getSerialInPosition() == self.getSerial():
            player = game.getPlayer(self.getSerial())
            if player.user_data['timeout']:
                ( when, timeout ) = player.user_data['timeout']
                now = seconds()
                timeout = timeout - ( now - when )
                if timeout > 0:
                    return ( PacketPokerTimeoutWarning(game_id = game.id,
                                                       serial = self.getSerial(),
                                                       timeout = int(timeout),
                                                       when = int(now) ), )
        return ()
        
    def setPlayerTimeout(self, game, packet):
        if packet.timeout > 0:
            packet.when = int(seconds())
            player = game.getPlayer(packet.serial)
            player.getUserData()['timeout'] = ( packet.when, packet.timeout )
            return True
        else:
            return False
        
    def unsetPlayerTimeout(self, game, serial):
        player = game.getPlayer(serial)
        player.getUserData()['timeout'] = None
    
    def explain(self, packet):
        if self.verbose > 3: self.message("PokerExplain:explain: %s" % packet )
        
        self.forward_packets = [ packet ]
        forward_packets = self.forward_packets
        
        if packet.type == PACKET_POKER_TABLE:
            if packet.id == 0:
                self.error("Too many open tables")
            else:
                if self.games.getGame(packet.id):
                    self.games.deleteGame(packet.id)
                new_game = self.games.getOrCreateGame(packet.id)
                new_game.prefix = self._prefix
                new_game.name = packet.name
                new_game.setTime(0)
                new_game.setVariant(packet.variant)
                new_game.setBettingStructure(packet.betting_structure)
                new_game.setMaxPlayers(packet.seats)
                new_game.registerCallback(self.gameEvent)
                new_game.level_skin = packet.skin
                new_game.currency_serial = packet.currency_serial
                new_game.history_index = 0
                self.updatePotsChips(new_game, [])
                new_game.position_info = [ 0, 0 ]
                self.forward_packets.append(self.currentGames())

        elif packet.type == PACKET_SERIAL:
            self.handleSerial(packet)

        elif packet.type == PACKET_ERROR:
            self.error("Server reported error : %s" % packet)
            return False

        game = self.games.packet2game(packet)

        if game and packet.type == PACKET_POKER_TABLE_DESTROY:
            game = None

        if game:
            if packet.type == PACKET_POKER_START:
                if packet.hand_serial == 0:
                    self.error("game start was refused")
                    forward_packets.remove(packet)
                elif not game.isEndOrNull():
                    raise UserWarning, "you should not be here (state: %s)" % game.state
                else:
                    game.history_index = 0
                    game.setTime(packet.time)
                    game.setHandsCount(packet.hands_count)
                    game.setLevel(packet.level)
                    game.beginTurn(packet.hand_serial)
                    game.position_info[PokerNetworkGameClient.POSITION_OBSOLETE] = True
                    if not self.no_display_packets:
                        forward_packets.append(PacketPokerBoardCards(game_id = game.id, serial = self.getSerial()))
                        for serial in game.player_list:
                            forward_packets.append(self.updatePlayerChips(game, game.serial2player[serial]))
                            if self.what & PacketPokerExplain.CHIPSTACKS:
                                forward_packets.append(self.explainPlayerChips(game, game.serial2player[serial]))
                        forward_packets.extend(self.updatePotsChips(game, []))

            elif packet.type == PACKET_POKER_CANCELED:
                if not self.no_display_packets and packet.amount > 0:
                    player = game.getPlayer(packet.serial)
                    if player.bet > 0:
                        forward_packets.extend(self.chipsBet2Pot(game, player, player.bet, 0))
                    if packet.amount > 0:
                        forward_packets.append(self.chipsPot2Player(game, player, packet.amount, 0, "canceled"))
                game.canceled(packet.serial, packet.amount)
                forward_packets.append(PacketPokerPosition(game_id = game.id))

            elif packet.type == PACKET_POKER_PLAYER_ARRIVE:
                game.addPlayer(packet.serial, packet.seat)
                player = game.getPlayer(packet.serial)
                player.setUserData(DEFAULT_PLAYER_USER_DATA.copy())
                player.name = packet.name
                player.url = packet.url
                player.outfit = packet.outfit
                player.auto_blind_ante = packet.auto_blind_ante
                player.wait_for = packet.wait_for
                player.auto = packet.auto
                if not self.no_display_packets:
                    self.forward_packets.append(PacketPokerSeats(game_id = game.id,
                                                                 seats = game.seats()))

            elif ( packet.type == PACKET_POKER_PLAYER_LEAVE or
                   packet.type == PACKET_POKER_TABLE_MOVE ) :
                game.removePlayer(packet.serial)
                if packet.serial == self.getSerial():
                    self.games.deleteGame(game.id)
                if packet.type == PACKET_POKER_TABLE_MOVE:
                    forward_packets.append(PacketPokerPlayerLeave(game_id = packet.game_id,
                                                                  serial = packet.serial,
                                                                  seat = packet.seat))
                if not self.no_display_packets:
                    self.forward_packets.append(PacketPokerSeats(game_id = game.id,
                                                                 seats = game.seats()))

            elif packet.type == PACKET_POKER_PLAYER_SELF:
                ( serial_in_position, position_is_obsolete ) = game.position_info
                if serial_in_position == self.getSerial():
                    game.position_info = [ 0, True ]
                forward_packets.extend(self.updateBetLimit(game))

            elif packet.type == PACKET_POKER_POSITION:
                if game.isBlindAnteRound():
                    game.setPosition(packet.position)
                forward_packets.remove(packet)

            elif packet.type == PACKET_POKER_SEATS:
                forward_packets.remove(packet)

            elif packet.type == PACKET_POKER_PLAYER_CARDS:
                player = game.getPlayer(packet.serial)
                player.hand.set(packet.cards)

            elif packet.type == PACKET_POKER_BOARD_CARDS:
                game.board.set(packet.cards)

            elif packet.type == PACKET_POKER_DEALER:
                game.setDealer(packet.dealer)

            elif packet.type == PACKET_POKER_SIT_OUT:
                game.sitOut(packet.serial)

            elif packet.type == PACKET_POKER_AUTO_FOLD:
                game.autoPlayer(packet.serial)

            elif packet.type == PACKET_POKER_AUTO_BLIND_ANTE:
                game.autoBlindAnte(packet.serial)

            elif packet.type == PACKET_POKER_NOAUTO_BLIND_ANTE:
                game.noAutoBlindAnte(packet.serial)

            elif packet.type == PACKET_POKER_MUCK_REQUEST:                
                game.setMuckableSerials(packet.muckable_serials)
                
            elif packet.type == PACKET_POKER_SIT:
                game.sit(packet.serial)

            elif packet.type == PACKET_POKER_TIMEOUT_WARNING:
                if not self.setPlayerTimeout(game, packet):
                    forward_packets.remove(packet)
            
            elif packet.type == PACKET_POKER_TIMEOUT_NOTICE:
                self.unsetPlayerTimeout(game, packet.serial)

            elif packet.type == PACKET_POKER_WAIT_FOR:
                game.getPlayer(packet.serial).wait_for = packet.reason
                forward_packets.remove(packet)

            elif packet.type == PACKET_POKER_IN_GAME:
                game.setStaticPlayerList(packet.players)
                for serial in game.serialsAll():
                    player = game.getPlayer(serial)
                    wait_for = player.wait_for
                    in_game = serial in packet.players 
                    if in_game or wait_for:
                        auto = player.isAuto()
                        if not game.isSit(serial):
                            game.sit(serial)
                            forward_packets.append(PacketPokerSit(game_id = game.id,
                                                                  serial = serial))
                        if auto:
                            game.autoPlayer(serial)
                            forward_packets.append(PacketPokerAutoFold(game_id = game.id,
                                                                       serial = player.serial))

                        if wait_for:
                            if wait_for == True and not in_game and not game.isRunning():
                                #
                                # A player is waiting for the blind (big, late...)
                                # and the server says it will not participate to the
                                # blindAnte round. This only happens when the anteRound
                                # is already finished on the server (i.e. when connecting
                                # to a table in the middle of a game). 
                                #
                                player.wait_for = "first_round"
                            else:
                                player.wait_for = wait_for
                            forward_packets.append(PacketPokerWaitFor(game_id = game.id,
                                                                      serial = serial,
                                                                      reason = wait_for))
                    else:
                        if game.isSit(serial):
                            game.sitOut(serial)                            
                            forward_packets.append(PacketPokerSitOut(game_id = game.id,
                                                                     serial = serial))

            elif packet.type == PACKET_POKER_RAKE:
                game.setRakedAmount(packet.value)
                
            elif packet.type == PACKET_POKER_WIN:
                if not self.no_display_packets:
                    for serial in packet.serials:
                        forward_packets.append(PacketPokerPlayerWin(serial = serial, game_id = game.id))

                if game.winners:
                    #
                    # If we know the winners before an explicit call to the distributeMoney
                    # method, it means that there is no showdown.
                    #
                    if not self.no_display_packets:
                        if game.isGameEndInformationValid():
                            forward_packets.append(PacketPokerShowdown(game_id = game.id, showdown_stack = game.showdown_stack))
                        forward_packets.extend(self.packetsPot2Player(game))
                else:
                    game.distributeMoney()

                    winners = game.winners[:]
                    winners.sort()
                    packet.serials.sort()
                    if winners != packet.serials:
                        raise UserWarning, "game.winners %s != packet.serials %s" % (winners, packet.serials)
                    if not self.no_display_packets:
                        if game.isGameEndInformationValid():
                            forward_packets.extend(self.packetsShowdown(game))
                            forward_packets.append(PacketPokerShowdown(game_id = game.id, showdown_stack = game.showdown_stack))

                        forward_packets.extend(self.packetsPot2Player(game))
                    game.endTurn()
                forward_packets.append(PacketPokerPosition(game_id = game.id))

            elif packet.type == PACKET_POKER_REBUY:
                forward_packets.remove(packet)
                if game.rebuy(packet.serial, packet.amount):
                    #
                    # If the server says the player rebuys, assume he knows
                    # that the player can rightfully do so and therefore
                    # that the buy_in has already been paid. The client fail
                    # to notice that a player already paid the buy_in 
                    # when it connects to a table on which said player has
                    # no chips in front of him.
                    #
                    player = game.getPlayer(packet.serial)
                    player.buy_in_payed = True
                    forward_packets.append(self.updatePlayerChips(game, player))
                    if self.what & PacketPokerExplain.CHIPSTACKS:
                        forward_packets.append(self.explainPlayerChips(game, player))

            elif packet.type == PACKET_POKER_PLAYER_CHIPS:
                player = game.getPlayer(packet.serial)
                if player.buy_in_payed:
                    if player.bet != packet.bet:
                        if self.verbose > 1:
                            self.error("server says player %d has a bet of %d chips and client thinks it has %d" % ( packet.serial, packet.bet, player.bet))
                        player.bet = packet.bet
                    if player.money != packet.money:
                        if self.verbose > 1:
                            self.error("server says player %d has a money of %d chips and client thinks it has %d" % ( packet.serial, packet.money, player.money))
                        player.money = packet.money
                else:
                    #
                    # If server sends chips amount for a player that did not yet pay the buy in
                    # 
                    player.bet = packet.bet
                    player.money = packet.money
                    if player.money > 0:
                        player.buy_in_payed = True
                if self.what & PacketPokerExplain.CHIPSTACKS:
                    forward_packets.append(self.explainPlayerChips(game, player))

            elif packet.type == PACKET_POKER_FOLD:
                game.fold(packet.serial)
                if game.isSitOut(packet.serial):
                    forward_packets.append(PacketPokerSitOut(game_id = game.id,
                                                             serial = packet.serial))

            elif packet.type == PACKET_POKER_CALL:
                game.call(packet.serial)

            elif packet.type == PACKET_POKER_RAISE:
                game.callNraise(packet.serial, packet.amount)

            elif packet.type == PACKET_POKER_CHECK:
                game.check(packet.serial)

            elif packet.type == PACKET_POKER_BLIND:
                game.blind(packet.serial, packet.amount, packet.dead)

            elif packet.type == PACKET_POKER_BLIND_REQUEST:
                game.setPlayerBlind(packet.serial, packet.state)

            elif packet.type == PACKET_POKER_ANTE:
                game.ante(packet.serial, packet.amount)

            elif packet.type == PACKET_POKER_STATE:
                game.position_info[PokerNetworkGameClient.POSITION_OBSOLETE] = True

                if game.isBlindAnteRound():
                    game.blindAnteRoundEnd()
                    forward_packets.extend(self.updatePotsChips(game, game.getPots()))

                if packet.string == "end" and game.state != "null":
                    game.endState()

                #
                # A state change is received at the begining of each
                # betting round. No state change is received when
                # reaching showdown or otherwise terminating the hand.
                #
                if game.isFirstRound():
                    game.initRound()
                else:
                    if not self.no_display_packets:
                        if ( packet.string == "end" and
                             game.isSingleUncalledBet(game.side_pots) ):
                            forward_packets.extend(self.moveBet2Player(game))
                        else:
                            forward_packets.extend(self.moveBet2Pot(game))

                    if packet.string != "end":
                        game.initRound()

                if not self.no_display_packets:
                    if game.isRunning() and game.cardsDealt() and game.downCardsDealtThisRoundCount() > 0:
                        forward_packets.append(PacketPokerDealCards(game_id = game.id,
                                                                    numberOfCards = game.downCardsDealtThisRoundCount(),
                                                                    serials = game.serialsNotFold()))

                if game.isRunning() and game.cardsDealt() and game.cardsDealtThisRoundCount() :
                    for player in game.playersNotFold():
                        cards = player.hand.toRawList()
                        forward_packets.append(PacketPokerPlayerCards(game_id = game.id,
                                                                      serial = player.serial,
                                                                      cards = cards))

                if not self.no_display_packets:
                    if game.isRunning() and game.cardsDealt() and self.getSerial() != 0 and game.isPlaying(self.getSerial()) and (packet.string == "flop" or packet.string == "turn" or packet.string == "river"):
                        forward_packets.append(PacketPokerPlayerHandStrength(game_id = game.id,
                                                                             serial = self.getSerial(),
                                                                             hand = game.readablePlayerBestHands(self.getSerial())))

                if ( packet.string != "end" and not game.isBlindAnteRound() ):
                    if not self.no_display_packets:
                        forward_packets.extend(self.updateBetLimit(game))
                    forward_packets.append(PacketPokerBeginRound(game_id = game.id))

                if game.state != packet.string:
                    self.error("state = %s, expected %s instead " % ( game.state, packet.string ))


            ( serial_in_position, position_is_obsolete ) = game.position_info
            if game.isRunning():
                #
                # Build position related packets
                #
                position_changed = serial_in_position != game.getSerialInPosition()
                if position_is_obsolete or position_changed:
                    self_was_in_position = self.getSerial() != 0 and serial_in_position == self.getSerial()
                    serial_in_position = game.getSerialInPosition()
                    self_in_position = serial_in_position == self.getSerial()
                    if serial_in_position > 0:
                        if position_changed:
                            forward_packets.append(PacketPokerPosition(game_id = game.id,
                                                                       position = game.position,
                                                                       serial = serial_in_position))
                        if ( self_was_in_position and not self_in_position ):
                            self.unsetPlayerTimeout(game, self.getSerial())
                            if not game.isBlindAnteRound() or not game.getPlayer(self.getSerial()).isAutoBlindAnte():
                                forward_packets.append(PacketPokerSelfLostPosition(game_id = game.id,
                                                                                   serial = serial_in_position))
                        if ( ( not self_was_in_position or position_is_obsolete ) and self_in_position ):
                            if not game.isBlindAnteRound() or not game.getPlayer(self.getSerial()).isAutoBlindAnte():
                                forward_packets.append(PacketPokerSelfInPosition(game_id = game.id,
                                                                                 serial = serial_in_position))
                    elif self_was_in_position:
                        self.unsetPlayerTimeout(game, self.getSerial())
                        if not game.isBlindAnteRound() or not game.getPlayer(self.getSerial()).isAutoBlindAnte():
                            forward_packets.append(PacketPokerSelfLostPosition(game_id = game.id,
                                                                               serial = self.getSerial()))
            else:
                if serial_in_position > 0:
                    if not game.isBlindAnteRound() or not game.getPlayer(self.getSerial()).isAutoBlindAnte():
                        forward_packets.append(PacketPokerSelfLostPosition(game_id = game.id,
                                                                           serial = self.getSerial()))
                    serial_in_position = 0
            position_is_obsolete = False
            game.position_info = [ serial_in_position, position_is_obsolete ]
            #
            # Build dealer messages
            # Skip state = end because information is missing and will be received by the next packet (WIN)
            #
            if not ( packet.type == PACKET_POKER_STATE and packet.string == "end" ):
                (subject, messages) = history2messages(game, game.historyGet()[game.history_index:], serial2name = lambda serial: self.serial2name(game, serial))
                if messages or subject:
                    if messages:
                        message = "".join(map(lambda line: "Dealer: " + line + "\n", list(set(messages))))
                        forward_packets.append(PacketPokerChat(game_id = game.id,
                                                               message = message))
                game.history_index = len(game.historyGet())

        return True

    def serial2name(self, game, serial):
        player = game.getPlayer(serial)
        if player:
            return player.name
        else:
            if self.verbose >= 0:
                self.error("no player found for serial %d in game %d" % ( serial, game.id ))
            return "<unknown>"

    def moveBet2Pot(self, game):
        packets = []
        round_contributions = game.getLatestPotContributions()
        for (pot_index, pot_contribution) in round_contributions.iteritems():
            for (serial, amount) in pot_contribution.iteritems():
                player = game.getPlayer(serial)
                packets.extend(self.chipsBet2Pot(game, player, amount, pot_index))

        packets.extend(self.updatePotsChips(game, game.getPots()))
        return packets

    #
    # Should be move all bets back to players (for uncalled bets)
    # This is a border case we don't want to handle right now
    #
    moveBet2Player = moveBet2Pot
        
    def updateBetLimit(self, game):
        if ( self.getSerial() not in game.serialsPlaying() or
             game.isBlindAnteRound() ):
            return []
            
        packets = []
        serial = self.getSerial()
        (min_bet, max_bet, to_call) = game.betLimits(serial)
        found = None
        steps = self.chips_values[:]
        steps.reverse()
        #
        # Search for the lowest chip value by which all amounts can be divided
        #
        for step in steps:
            if min_bet % step == 0 and max_bet % step == 0 and to_call % step == 0:
                found = step
        if found:
            if self.verbose:
                self.message(" => bet min=%d, max=%d, step=%d, to_call=%d" % ( min_bet, max_bet, found, to_call))
            player = game.getPlayer(serial)
            bet = player.bet
            packets.append(PacketPokerBetLimit(game_id = game.id,
                                               min = min_bet + bet + to_call,
                                               max = max_bet + bet,
                                               step = game.getChipUnit(),
                                               call = to_call,
                                               allin = player.money + bet,
                                               pot = game.potAndBetsAmount() + to_call * 2))
        else:
            self.error("no chip value (%s) is suitable to step from min_bet = %d to max_bet = %d" % ( self.chips_values, min_bet, max_bet ))
        return packets

    def currentGames(self, exclude = None):
        games = self.games.getGameIds()
        if exclude:
            games.remove(exclude)
        return PacketPokerCurrentGames(game_ids = games,
                                       count = len(games))

    def explainPlayerChips(self, game, player):
        packet = PacketPokerClientPlayerChips(game_id = game.id,
                                              serial = player.serial,
                                              bet = self.normalizeChips(game, player.bet),
                                              money = self.normalizeChips(game, player.money) )
        return packet
                
        
    
    def packetsPot2Player(self, game):
        packets = []
        current_pot = 0
        game_state = game.showdown_stack[0]
        pots = game_state['side_pots']['pots']
        frame_count = len(game.showdown_stack) - 1
        for frame in game.showdown_stack:
            if frame['type'] == 'left_over':
                player = game.getPlayer(frame['serial'])
                packets.append(self.chipsPot2Player(game, player, frame['chips_left'], len(pots) - 1, "left_over"))
            elif frame['type'] == 'uncalled':
                player = game.getPlayer(frame['serial'])
                packets.append(self.chipsPot2Player(game, player, frame['uncalled'], len(pots) - 1, "uncalled"))
            elif frame['type'] == 'resolve':
                cumulated_pot_size = 0
                next_pot = current_pot
                for (pot_size, pot_total) in pots[current_pot:]:
                    cumulated_pot_size += pot_size
                    next_pot += 1
                    if cumulated_pot_size >= frame['pot']:
                        break
                if cumulated_pot_size != frame['pot']:
                    self.error("pot %d, total size = %d, expected %d" % ( current_pot, cumulated_pot_size, frame['pot'] )) #pragma: no cover
                merged_pot = next_pot - 1
                if merged_pot > current_pot:
                    merge = PacketPokerChipsPotMerge(game_id = game.id,
                                                     sources = range(current_pot, merged_pot),
                                                     destination = merged_pot)
                    if self.verbose > 2:
                        self.message("packetsPot2Player: %s" % merge)
                    packets.append(merge)
                if frame_count == 1 and len(frame['serial2share']) == 1:
                    #
                    # Happens quite often : single winner. Special case where
                    # we use the exact chips layout saved in game_state.
                    #
                    serial = frame['serial2share'].keys()[0]
                    packets.append(self.chipsPot2Player(game, game.getPlayer(serial), game_state['pot'], merged_pot, "win"))
                else:
                    #
                    # Possibly complex showdown, cannot avoid breaking chip stacks
                    #
                    for (serial, share) in frame['serial2share'].iteritems():
                        packets.append(self.chipsPot2Player(game, game.getPlayer(serial), share, merged_pot, "win"))
                current_pot = next_pot
            else:
                pass
                
        for player in game.serial2player.itervalues():
            packets.append(self.updatePlayerChips(game, player))
            if self.what & PacketPokerExplain.CHIPSTACKS:
                packets.append(self.explainPlayerChips(game, player))
        packets.extend(self.updatePotsChips(game, []))
        return packets
        
    def packetsShowdown(self, game):
        if not game.isGameEndInformationValid():
            return []

        game_state = game.showdown_stack[0]
        delta_max = -1
        serial_delta_max = -1
        for (serial, delta) in game_state['serial2delta'].iteritems():
            if delta_max < delta:
                delta_max = delta
                serial_delta_max = serial
        
        packets = []
        if game.variant == "7stud":
            for player in game.playersAll():
                packets.append(PacketPokerPlayerNoCards(game_id = game.id,
                                                        serial = player.serial))
                if player.hand.areVisible():
                    packet = PacketPokerPlayerCards(game_id = game.id,
                                                    serial = player.serial,
                                                    cards = player.hand.tolist(True))
                    packet.visibles = "hole"
                    packets.append(packet)

        for (serial, best) in game.serial2best.iteritems():
            for (side, (value, bestcards)) in best.iteritems():
                if serial in game.side2winners[side]:
                    if len(bestcards) > 1:
                        side = game.isHighLow() and side or ""
                        if side == "low":
                            hand = ""
                        else:
                            hand = game.readableHandValueShort(side, bestcards[0], bestcards[1:])
                        cards = game.getPlayer(serial).hand.toRawList()
                        best_hand = 0
                        if serial == serial_delta_max:
                            best_hand = 1
                        packets.append(PacketPokerBestCards(game_id = game.id,
                                                            serial = serial,
                                                            side = side,
                                                            cards = cards,
                                                            bestcards = bestcards[1:],
                                                            board = game.board.tolist(True),
                                                            hand = hand,
                                                            besthand = best_hand))
        return packets

    def packetsTableQuit(self, game):
        packets = []
        packets.append(PacketPokerBatchMode(game_id = game.id))
        for player in game.playersAll():
            packets.append(PacketPokerPlayerLeave(game_id = game.id,
                                                  serial = player.serial,
                                                  seat = player.seat))
        packets.append(PacketPokerStreamMode(game_id = game.id))
        packets.append(PacketPokerTableQuit(game_id = game.id,
                                            serial = self.getSerial()))
        packets.append(self.currentGames(game.id))
        return packets


########NEW FILE########
__FILENAME__ = pokergameclient
# -*- py-indent-offset: 4; coding: iso-8859-1; mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
from pokerengine.pokergame import PokerGameClient

class PokerNetworkGameClient(PokerGameClient):
    SERIAL_IN_POSITION = 0
    POSITION_OBSOLETE = 1

    def __init__(self, url, dirs):
        PokerGameClient.__init__(self, url, dirs)
        self.level_skin = ""
        self.currency_serial = 0
        self.history_index = 0
        self.position_info = [ 0, 0 ]

    def reset(self):
        PokerGameClient.reset(self)
        self.resetStaticPlayerList()

    def cancelState(self):
        self.resetStaticPlayerList()
        return PokerGameClient.cancelState(self)

    def endState(self):
        self.resetStaticPlayerList()
        return PokerGameClient.endState(self)

    def resetStaticPlayerList(self):
        self.static_player_list = None

    def setStaticPlayerList(self, player_list):
        self.static_player_list = player_list[:]

    def getStaticPlayerList(self):
        return self.static_player_list
      
    def buildPlayerList(self, with_wait_for):
        self.player_list = self.getStaticPlayerList()
        if self.verbose >= 3:
            self.message("buildPlayerList " + str(self.player_list))
        assert self.player_list == filter(lambda x: self.serial2player[x].isSit(), self.player_list)
        return True

########NEW FILE########
__FILENAME__ = pokerlock
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2006 Mekensleep <licensing@mekensleep.com>
#                    24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#

from twisted.internet import reactor, defer
from twisted.python import failure
from traceback import format_exc
import threading
import thread
import MySQLdb
import Queue
import time

class PokerLock(threading.Thread):

    TIMED_OUT	= 1
    DEAD	= 2
    RELEASE	= 3

    acquire_timeout = 60
    queue_timeout = 2 * 60
    acquire_sleep = 0.1
    
    def __init__(self, parameters):
        self.verbose = 0
        self.q = Queue.Queue()
        self.lock = threading.Lock()
        self.db = None
        self.running = True
        self.connect(parameters)
        threading.Thread.__init__(self, target = self.main)

    def message(self, string):
        print "PokerLock::(" + str(thread.get_ident()) + ") "  + string
        
    def close(self):
        if self.isAlive():
            self.q.put((None, None, None, None))
            self.join()

        if self.db:
            self.db.close()
            self.db = None
        
    def stopping(self):
        if self.verbose > 2: self.message("stopping")
        self.running = False

    def main(self):
        try:
            reactor.addSystemEventTrigger('during', 'shutdown', self.stopping)
            while 1:
                if self.verbose > 2:
                    self.message("loop, queue size " + str(self.q.qsize()))
                if not self.running and self.q.empty():
                    self.message("stopped")
                    break

                try:
                    ( name, function, timeout, deferred ) = self.q.get(timeout = PokerLock.queue_timeout)
                except Queue.Empty:
                    #
                    # When timeout, silently terminate the thread
                    #
                    self.message("timeout")
                    break
                except:
                    raise

                if not name:
                    #
                    # Stop the thread
                    #
                    if self.verbose > 2: self.message("stop ")
                    break

                try:
                    function(name, timeout)
                    if self.running:
                        reactor.callFromThread(deferred.callback, name)
                    else:
                        if self.verbose > 2: self.message("release because not running")
                        self.lock.release()
                except:
                    if self.verbose >= 0:
                        self.message("exception in function " + format_exc())
                    if self.verbose > 2: self.message("release because exception")
                    try:
                        self.lock.release()
                    except:
                        if self.verbose > 2: self.message(format_exc())
                    reactor.callFromThread(deferred.errback, failure.Failure())
            self.db.close()
            self.db = None
        except:
            if self.verbose > 2: self.message("exception " + format_exc())
            raise

    def connect(self, parameters):
        self.db = MySQLdb.connect(host = parameters["host"],
                                  user = parameters["user"],
                                  passwd = parameters["password"])

    def acquire(self, name, timeout = acquire_timeout):
        if self.verbose > 2: self.message("acquire")
        if not self.isAlive():
            raise Exception(PokerLock.DEAD, "this PokerLock instance is dead, create a new one")
        d = defer.Deferred()
        self.q.put((name, self.__acquire, timeout, d))
        return d
        
    def __acquire(self, name, timeout):
        if self.verbose > 2: self.message("__acquire %s %d" % ( name, timeout ))
        tick = timeout
        while 1:
            if self.lock.acquire(0):
                if self.verbose > 2: self.message("acquired")
                break
            tick -= PokerLock.acquire_sleep
            if tick <= 0:
                if self.verbose > 2: self.message("__acquire TIMED OUT")
                raise Exception(PokerLock.TIMED_OUT, name)
            if self.verbose > 2: self.message("__acquire sleep %f" % PokerLock.acquire_sleep)
            time.sleep(PokerLock.acquire_sleep)
        self.db.query("SELECT GET_LOCK('%s', %d)" % ( name, timeout))
        result = self.db.store_result()
        if result.fetch_row()[0][0] != 1:
            raise Exception(PokerLock.TIMED_OUT, name)
        if self.verbose > 2: self.message("__acquire got MySQL lock")

    def release(self, name):
        if self.verbose > 2: self.message("release " + name)
        self.db.query("SELECT RELEASE_LOCK('%s')" % name)
        result = self.db.store_result()
        if result.fetch_row()[0][0] != 1:
            raise Exception(PokerLock.RELEASE, name)
        self.lock.release()

########NEW FILE########
__FILENAME__ = pokermemcache
#
# -*- py-indent-offset: 4; coding: iso-8859-1 -*-
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

# borrowed from memcache.py
import types

class MemcachedStringEncodingError(Exception):
    pass

def check_key(key, key_extra_len=0):
    """Checks sanity of key.  Fails if:
        Key length is > SERVER_MAX_KEY_LENGTH (Raises MemcachedKeyLength).
        Contains control characters  (Raises MemcachedKeyCharacterError).
        Is not a string (Raises MemcachedStringEncodingError)
    """
    if type(key) == types.TupleType: key = key[1]
    if not isinstance(key, str):
        raise MemcachedStringEncodingError, ("Keys must be str()'s, not"
                "unicode.  Convert your unicode strings using "
                "mystring.encode(charset)!")

memcache_singleton = {}
memcache_expiration_singleton = {}

class MemcacheMockup:
    class Client:
        def __init__(self, addresses, *args, **kwargs):
            self.addresses = addresses
            self.cache = memcache_singleton
            self.expiration = memcache_expiration_singleton

        def get(self, key):
            check_key(key)
            if self.cache.has_key(key):
                return self.cache[key]
            else:
                return None

        def get_multi(self, keys):
            r = {}
            for key in keys:
                if self.cache.has_key(key):
                    r[key] = self.cache[key]
            return r
        
        def set(self, key, value, time = 0):
            check_key(key)
            self.cache[key] = value
            self.expiration[key] = time

        def set_multi(self, kwargs, time = 0):
            self.cache.update(kwargs)
            for k in kwargs: self.expiration[k] = time
            return []

        def add(self, key, value, time = 0):
            if self.cache.has_key(key):
                return 0
            else:
                self.cache[key] = value
                self.expiration[key] = time                
                return 1

        def replace(self, key, value, time = 0):
            if self.cache.has_key(key):
                self.cache[key] = value
                self.expiration[key] = time
                return 1
            else:
                return 0
            
        def delete(self, key):
            check_key(key)
            try:
                del self.cache[key]
                return 1
            except:
                return 0

        def delete_multi(self, keys):
            for key in keys:
                if self.cache.has_key(key):
                    del self.cache[key]
            return 1

try:
    import memcache #pragma: no cover
except:
    memcache = MemcacheMockup #pragma: no cover


########NEW FILE########
__FILENAME__ = pokernetworkconfig
#
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
from pokerengine import pokerengineconfig
from pokernetwork.version import version
import libxml2

class Config(pokerengineconfig.Config):

    upgrades_repository = None
    verbose = 0

    def __init__(self, *args, **kwargs):
        pokerengineconfig.Config.__init__(self, *args, **kwargs)
        self.version = version
        self.notify_updates = []

    def loadFromString(self, string):
        self.path = "<string>"
        self.doc = libxml2.parseMemory(string, len(string))
        self.header = self.doc.xpathNewContext()

    def load(self, path):
        status = pokerengineconfig.Config.load(self, path)
        if Config.upgrades_repository:
            if self.checkVersion("poker_network_version", version, Config.upgrades_repository):
                return status
            else:
                return False
        else:
            return status

    def notifyUpdates(self, method):
        if method not in self.notify_updates:
            self.notify_updates.append(method)

    def denotifyUpdates(self, method):
        if method in self.notify_updates:
            self.notify_updates.remove(method)
        
    def headerSet(self, name, value):
        result = pokerengineconfig.Config.headerSet(self, name, value)
        for method in self.notify_updates:
            method(self)
        return result

########NEW FILE########
__FILENAME__ = pokerpackets
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)             2008, 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2004, 2005, 2006       Mekensleep <licensing@mekensleep.com>
#                                      24 rue vieille du temple 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@gnu.org>
#  Bradley M. Kuhn <bkuhn@ebb.org> (2008-)
#  Cedric Pinson <cpinson@freesheep.org> (2004-2006)
#  Henry Precheur <henry@precheur.org> (2004)
#
#     Theory of operations.
#
#     When the client send packets, the reply packets sent by the
#     server are listed in the packet documentation.
#     
#     How to tell the server that the client is alive every 10 seconds ?
#        If and only if the client does not send any packet during
#        more than 10 sec, you must send a PACKET_PING
#
#     PACKET_PING
#
#     How to cash in ?
#
#     POKER_CASH_IN
#
#     How to sit at a cash game table ?
#     
#     PACKET_POKER_TABLE_JOIN
#     PACKET_POKER_SEAT
#     PACKET_POKER_BUY_IN
#     PACKET_POKER_AUTO_BLIND_ANTE
#     PACKET_POKER_SIT
#
#     How to quickly get to a cash game table that fits certain criteria?
#
#     PACKET_POKER_TABLE_PICKER
#
#     How to leave a cash game table ?
#
#     PACKET_POKER_TABLE_QUIT
#
#     What to expect when watching a table ? 
#     
#     PACKET_POKER_PLAYER_ARRIVE
#     PACKET_POKER_PLAYER_STATS
#     PACKET_POKER_PLAYER_CHIPS
#     PACKET_POKER_PLAYER_SIT
#     PACKET_POKER_PLAYER_SIT_OUT
#     PACKET_POKER_CHAT
#     PACKET_POKER_PLAYER_LEAVE
#
#     What to expect at all times ?
#
#     PACKET_POKER_MESSAGE
#
#     How do I get the list of tournaments ?
#
#     PACKET_POKER_TOURNEY_SELECT
#
#     How do I get the list of players registered in a tournament ?
#
#     PACKET_POKER_TOURNEY_REQUEST_PLAYERS_LIST
#
#     What to expect while a hand is being played ?
#
#     PACKET_POKER_IN_GAME
#     PACKET_POKER_DEALER
#     PACKET_POKER_START
#     PACKET_POKER_CANCELED
#     PACKET_POKER_STATE
#     PACKET_POKER_POSITION
#     PACKET_POKER_BLIND
#     PACKET_POKER_ANTE
#     PACKET_POKER_CALL
#     PACKET_POKER_RAISE
#     PACKET_POKER_FOLD
#     PACKET_POKER_CHECK
#     PACKET_POKER_RAKE
#     PACKET_POKER_WIN
#
#     What to expect while participating in a hand ?
#
#     PACKET_POKER_BLIND_REQUEST
#     PACKET_POKER_ANTE_REQUEST
#     PACKET_POKER_MUCK_REQUEST
#     PACKET_POKER_SELF_IN_POSITION
#     PACKET_POKER_SELF_LOST_POSITION
#
#     What to send after receiving PACKET_POKER_SELF_IN_POSITION ?
#
#     PACKET_POKER_CALL
#     PACKET_POKER_RAISE
#     PACKET_POKER_FOLD
#     PACKET_POKER_CHECK
#
#     What to send after receiving PACKET_POKER_MUCK_REQUEST ?
#
#     PACKET_POKER_MUCK_ACCEPT or
#     PACKET_POKER_MUCK_DENY
#     
#     How to list tournaments ?
#     
#     PACKET_POKER_TOURNEY_SELECT
#
#     What to expect in response to PACKET_POKER_TOURNEY_SELECT ? 
#
#     PACKET_POKER_TOURNEY_LIST containing
#       PACKET_POKER_TOURNEY packets
#
#     How to list players registered in a tournament ? 
#
#     PACKET_POKER_TOURNEY_REQUEST_PLAYERS_LIST
#
#     What to expect in response to PACKET_POKER_TOURNEY_REQUEST_PLAYERS_LIST ? 
#
#     PACKET_POKER_TOURNEY_PLAYERS_LIST
#  
#     How to register to a tournament ?
#
#     PACKET_POKER_TOURNEY_REGISTER
#
#     What to expect in response to PACKET_POKER_TOURNEY_REGISTER ? 
#
#     PACKET_POKER_TOURNEY_REGISTER if success (the same that was sent)
#     PACKET_ERROR if failure
#
#     How to unregister to a tournament ?
#
#     PACKET_POKER_TOURNEY_UNREGISTER
#
#     What to expect in response to PACKET_POKER_TOURNEY_UNREGISTER ? 
#
#     PACKET_POKER_TOURNEY_UNREGISTER if success (the same that was sent)
#     PACKET_ERROR if failure
#
#     What is sent to the tournament player that was busted out of a 
#     tournament (or is the winner) ?  
# 
#     PACKET_POKER_TOURNEY_RANK
#
#     What is sent to the player when the tournament starts ? 
#
#     What should the client expect when moved to another
#       table during a tournament ?
#
#     PACKET_POKER_TABLE_MOVE (or PACKET_POKER_PLAYER_LEAVE if explain mode)
#     (and PACKET_POKER_SEATS if explain mode)
#     
#     How to instruct the server to wait for the client before dealing
#     the next hand ? 
# 
#     PACKET_POKER_PROCESSING_HAND
#
#     How to tell the server that the client has finished displaying the
#     current hand and can deal the next one ?
#
#     PACKET_POKER_READY_TO_PLAY
# 
#     What should the client expect when a tournament break begins/ends?
#
#     POKER_TABLE_TOURNEY_BREAK_BEGIN
#     POKER_TABLE_TOURNEY_BREAK_END

import sys
from time import strftime, gmtime

"""\
Packets exchanged between the poker server and a poker client.

When a packet is said to be "inferred" by the client, it means
that it is not sent by the server because the
client can deduce the corresponding event from the previous packets.
The pokerclient protocol hide this difference by creating events as if they
were received from the server. The distinction should only matter for
a program willing to talk directly to the server, in wich case it is safe
to assume that all packet marked as being "inferred" will not actually be received by the server. In order to keep the
complexity of writing the client to a reasonable level, the server
provides exhaustive information about the game before the beginning of
every turn.

The "Direction:" field for each packet shows wether it travels from
the client to the server (server <= client), from the server to the
client (server => client) or both ways (server <=> client). Packets
that are never used for client / server dialog, i.e. which are
infered by the client and used internally are noted with
client <=> client.

The main pot is never refered as such and is considered to be the
pot with the largest index. If there are three pots (index 0, 1, 2),
it is safe to assume that the pot with index 2 is the main pot.

The terms table/game are used interchangeably depending on the context.

The documentation is kept terse and emphasizes the non-intuitive
behaviour associated to each packet.
""" #pragma: no cover

from struct import pack, unpack, calcsize
from types import IntType, LongType
from pokernetwork.packets import *

########################################

class PacketPokerTourneyFinish(Packet):
    """\
Semantics: notify the client that the tournament is over

Direction: server => client

tourney_serial: integer uniquely identifying a tournament.
"""
    info = Packet.info + (
        ('tourney_serial', 0, 'I'),
        )

Packet.infoDeclare(globals(), PacketPokerTourneyFinish, Packet, "POKER_TOURNEY_FINISH", 49) # 49 # 0x31 # %SEQ%

########################################

PACKET_POKER_SEATS = 50 # 0x32 # %SEQ%
PacketNames[PACKET_POKER_SEATS] = "POKER_SEATS"

class PacketPokerSeats(Packet):
    """\
Semantics: attribution of the seats of a game to the players.

Context: packet sent at least once per turn. It is guaranteed
that no player engaged in a turn (i.e. who shows in a
 PACKET_POKER_IN_GAME packet) will leave their seat before
the turn is over (i.e. before packet  PACKET_POKER_STATE packet
with string == "end" is received).
It is guaranteed that all PACKET_PLAYER_ARRIVE packets for
all players listed in the "seats" have already been sent
by the server.

Notes: The list is 10 seats long even when a game only allows 5
players to seat.

seats: list of serials of players. The list contains exactly 10 integers.
       The position of the serial of a given player is the seat number.
       A serial of 0 means the seat is empty.
       Example: [ 0, 0, 201, 0, 0, 0, 0, 0, 305, 0 ]
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_SEATS

    info = Packet.info + ( ('seats', [], 'Il'),
                           ('game_id', 0, 'I'),
                           )
    
    format = "!I"
    format_size = calcsize(format)
    format_element = "!I"

    def __init__(self, **kwargs):
        self.seats = kwargs.get("seats",[])
        self.game_id = kwargs.get("game_id",0)

    def pack(self):
        return Packet.pack(self) + self.packlist(self.seats, PacketPokerSeats.format_element) + pack(PacketPokerSeats.format, self.game_id)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (block, self.seats) = self.unpacklist(block, PacketPokerSeats.format_element)
        (self.game_id,) = unpack(PacketPokerSeats.format, block[:PacketPokerSeats.format_size])
        return block[PacketPokerSeats.format_size:]

    def calcsize(self):
        return Packet.calcsize(self) + self.calcsizelist(self.seats, PacketPokerSeats.format_element) + PacketPokerSeats.format_size

    def __str__(self):
        return Packet.__str__(self) + " game_id = %d, seats = %s" % ( self.game_id, self.seats )

PacketFactory[PACKET_POKER_SEATS] = PacketPokerSeats

########################################

PACKET_POKER_ID = 51 # 0x33 # %SEQ%
PacketNames[PACKET_POKER_ID] = "POKER_ID"

class PacketPokerId(PacketSerial):
    """abstract packet with game id and serial"""

    type = PACKET_POKER_ID

    info = PacketSerial.info + ( ( 'game_id', 0, 'I'), )
        
    game_id = 0

    format = "!I"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.game_id = kwargs.get("game_id", 0)
        PacketSerial.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketSerial.pack(self) + pack(PacketPokerId.format, self.game_id)

    def unpack(self, block):
        block = PacketSerial.unpack(self, block)
        self.game_id = int(unpack(PacketPokerId.format, block[:PacketPokerId.format_size])[0])
        return block[PacketPokerId.format_size:]

    def calcsize(self):
        return PacketSerial.calcsize(self) + PacketPokerId.format_size

    def __str__(self):
        return PacketSerial.__str__(self) + " game_id = %d" % self.game_id

PacketFactory[PACKET_POKER_ID] = PacketPokerId

########################################

PACKET_POKER_MESSAGE = 52 # 0x34 # %SEQ%
PacketNames[PACKET_POKER_MESSAGE] = "POKER_MESSAGE"

class PacketPokerMessage(PacketPokerId):
    """
    server => client
    Informative messages
    """

    type = PACKET_POKER_MESSAGE

    info = PacketPokerId.info + ( ( 'string', '', 's' ), )
        
    def __init__(self, *args, **kwargs):
        self.string = kwargs.get("string", "")
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + self.packstring(self.string)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (block, self.string) = self.unpackstring(block)
        return block

    def calcsize(self):
        return PacketPokerId.calcsize(self) + self.calcsizestring(self.string)

    def __str__(self):
        return PacketPokerId.__str__(self) + " string = %s" % self.string

PacketFactory[PACKET_POKER_MESSAGE] = PacketPokerMessage

########################################

PACKET_POKER_ERROR = 53 # 0x35 # %SEQ%
PacketNames[PACKET_POKER_ERROR] = "ERROR"

class PacketPokerError(PacketPokerId):
    """

    Packet describing an error

    """

    type = PACKET_POKER_ERROR

    info = PacketPokerId.info + ( ('message', 'no message', 's'),
                                  ('code', 0, 'I'),
                                  ('other_type', PACKET_POKER_ERROR, 'B'),
                                  )
    other_type = 0
    code = 0
    message = ""

    format = "!IB"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.message = kwargs.get("message", "no message")
        self.code = kwargs.get("code", 0)
        self.other_type = kwargs.get("other_type", PACKET_POKER_ERROR)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + self.packstring(self.message) + pack(PacketPokerError.format, self.code, self.other_type)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (block, self.message) = self.unpackstring(block)
        (self.code, self.other_type) = unpack(PacketPokerError.format, block[:PacketPokerError.format_size])
        return block[PacketPokerError.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + self.calcsizestring(self.message) + PacketPokerError.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + " message = %s, code = %d, other_type = %s" % (self.message, self.code, PacketNames[self.other_type] )

PacketFactory[PACKET_POKER_ERROR] = PacketPokerError

########################################

PACKET_POKER_POSITION = 54 # 0x36 # %SEQ%
PacketNames[PACKET_POKER_POSITION] = "POKER_POSITION"

class PacketPokerPosition(Packet):
    """\
Semantics: the player "serial" is now in position for game
"game_id" and should act. If "serial" is 0, no player is
in position.

Direction: server  => client

Context: emitted by the server when paying blinds or antes,
in which case the "serial" field does not contain a
serial number but a position. This packet is discarded
when other packets are inferred. Inferred by the client
during all other betting rounds.
A PACKET_POKER_POSITION with serial 0 is inferred by the
client at the end of each turn.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_POSITION

    info = Packet.info + ( ('game_id', 0, 'I'),
                           ('position', -1, 'b'),
                           ('serial', 0, 'no net') )
    
    format = "!IB"
    format_size = calcsize(format)

    def __init__(self, **kwargs):
        self.game_id = kwargs.get("game_id", 0)
        self.position = kwargs.get("position", -1)
        self.serial = kwargs.get("serial", 0) # accepted by constructor but otherwise ignored

    def pack(self):
        position = self.position == -1 and 255 or self.position
        return Packet.pack(self) + pack(PacketPokerPosition.format, self.game_id, position)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (self.game_id, self.position) = unpack(PacketPokerPosition.format, block[:PacketPokerPosition.format_size])
        if self.position == 255: self.position = -1
        return block[PacketPokerPosition.format_size:]

    def calcsize(self):
        return Packet.calcsize(self) + PacketPokerPosition.format_size

    def __str__(self):
        return Packet.__str__(self) + " game_id = %d, position = %d, serial = %d" % ( self.game_id, self.position, self.serial )

PacketFactory[PACKET_POKER_POSITION] = PacketPokerPosition

########################################

PACKET_POKER_INT = 55 # 0x37 # %SEQ%
PacketNames[PACKET_POKER_INT] = "POKER_INT"

class PacketPokerInt(PacketPokerId):
    """base class for a int coded amount"""

    type = PACKET_POKER_INT

    info = PacketPokerId.info + ( ('amount', 0, 'I'), )
    
    format = "!I"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.amount = kwargs.get("amount", 0)
        if not ( type(self.amount) == IntType or type(self.amount) == LongType ): raise UserWarning, "not an int" + str(self.amount)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + pack(PacketPokerInt.format, self.amount)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.amount,) = unpack(PacketPokerInt.format, block[:PacketPokerInt.format_size])
        return block[PacketPokerInt.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerInt.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + " amount = %d" % self.amount

PacketFactory[PACKET_POKER_INT] = PacketPokerInt

########################################

PACKET_POKER_BET = 56 # 0x38 # %SEQ%
PacketNames[PACKET_POKER_BET] = "POKER_BET"

class PacketPokerBet(PacketPokerInt):
    """base class for raise. It is not used. To bet use PokerRaise instead."""

    type = PACKET_POKER_BET

PacketFactory[PACKET_POKER_BET] = PacketPokerBet

########################################

PACKET_POKER_FOLD = 57 # 0x39 # %SEQ%
PacketNames[PACKET_POKER_FOLD] = "POKER_FOLD"

class PacketPokerFold(PacketPokerId):
    """\
Semantics: the "serial" player folded.

Direction: server <=> client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_FOLD

PacketFactory[PACKET_POKER_FOLD] = PacketPokerFold

########################################

PACKET_POKER_STATE = 58 # 0x3a # %SEQ%
PacketNames[PACKET_POKER_STATE] = "POKER_STATE"

class PacketPokerState(PacketPokerId):
    """\
Semantics: the state of the game "game_id" changed to
"string". The common game states are:

 null : new game.
 end : a game just ended.
 blindAnte : players are paying blinds and/or antes.

The other game states are not pre-determined and depend on the content
of the variant file. For instance, the states matching the
poker.holdem.xml variant file are : pre-flop, flop, turn and river.

Direction: server  => client

Context: the sequence of states is guaranteed, i.e. "turn" will never be
sent before "flop". However, there is no guarantee that the next state
will ever be sent. For instance, if a holdem game is canceled
(i.e. PACKET_POKER_CANCELED is sent) because no player is willing to pay
the blinds, the client must know that it will never receive the
packet announcing the "pre-flop" state. The "end" state is not
sent when a game is canceled (i.e. PACKET_POKER_CANCELED is sent).

game_id: integer uniquely identifying a game.
string: state of the game.
"""

    type = PACKET_POKER_STATE

    info = PacketPokerId.info + ( ('string', '', 's'), )
    
    def __init__(self, *args, **kwargs):
        self.string = kwargs.get("string","")
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + self.packstring(self.string)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (block, self.string) = self.unpackstring(block)
        return block

    def calcsize(self):
        return PacketPokerId.calcsize(self) + self.calcsizestring(self.string)

    def __str__(self):
        return PacketPokerId.__str__(self) + " string = %s" % self.string


PacketFactory[PACKET_POKER_STATE] = PacketPokerState

########################################

PACKET_POKER_WIN = 59 # 0x3b # %SEQ%
PacketNames[PACKET_POKER_WIN] = "POKER_WIN"

class PacketPokerWin(PacketPokerId):
    """\
Semantics: the "serials" of the players who won
the turn for game "game_id" to display the showdown.

Context: this packet is sent even when there is no showdown, i.e. when all
other players folded. However, it is not sent if the game is canceled
(i.e. PACKET_POKER_CANCELED is sent). It is sent after
the PACKET_POKER_STATE packet announcing the "end" state and after all
necessary information is sent to explain the
showdown (i.e. the value of the losing cards). The client may deduce
the serials of players who won from previous packets and use the
packet information for checking purposes only.

The client infers the following packets from PACKET_POKER_WIN:

 PACKET_POKER_PLAYER_NO_CARDS
 PACKET_POKER_BEST_CARDS
 PACKET_POKER_CHIPS_POT_MERGE
 PACKET_POKER_CHIPS_POT2PLAYER
 PACKET_POKER_POT_CHIPS
 PACKET_POKER_PLAYER_CHIPS

They roughly match the following logic. Some players mucked their
losing cards (PACKET_POKER_PLAYER_NO_CARDS). The winners show their
best five card combination (high and/or low)
 PACKET_POKER_BEST_CARDS. If there are split pots and a player wins
more than one pot, merge the chips together before giving them to the
winner (PACKET_POKER_CHIPS_POT_MERGE). Give each player the part of
the pot they won (PACKET_POKER_CHIPS_POT2PLAYER): there may be more
than one packet for each player if more than one pot is involved. When
the distribution is finished all pots are empty
(PACKET_POKER_POT_CHIPS) and each player has a new amount of chips in
their stack (PACKET_POKER_PLAYER_CHIPS). These last two packets make
it possible for the client to ignore the chips movements and only deal
with the final chips amounts.

The PACKET_POKER_BEST_CARDS is only infered for actual winners. Not
for players who participated in the showdown but lost. The cards of
these losers are known from a PACKET_POKER_CARDS sent before the
 PACKET_POKER_WIN.

Direction: server  => client

serials: list of serials of players who won.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_WIN

    info = PacketPokerId.info + ( ('serials', [], 'Il'), )
    
    format_element = "!I"

    def __init__(self, *args, **kwargs):
        self.serials = kwargs.get("serials",[])
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        block = PacketPokerId.pack(self)
        block += self.packlist(self.serials, PacketPokerWin.format_element)
        return block

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (block, self.serials) = self.unpacklist(block, PacketPokerWin.format_element)
        return block

    def calcsize(self):
        return PacketPokerId.calcsize(self) + self.calcsizelist(self.serials, PacketPokerWin.format_element)

    def __str__(self):
        return PacketPokerId.__str__(self) + " serials = %s" % self.serials

PacketFactory[PACKET_POKER_WIN] = PacketPokerWin

########################################

PACKET_POKER_CARDS = 60 # 0x3c # %SEQ%
PacketNames[PACKET_POKER_CARDS] = "POKER_CARDS"

class PacketPokerCards(PacketPokerId):
    """base class for player / board / best cards"""
    type = PACKET_POKER_CARDS

    info = PacketPokerId.info + ( ('cards', [], 'Bl'), )
    
    format_element = "!B"

    def __init__(self, *args, **kwargs):
        self.cards = kwargs.get("cards",[])
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        block = PacketPokerId.pack(self)
        block += self.packlist(self.cards, PacketPokerCards.format_element)
        return block

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (block, self.cards) = self.unpacklist(block, PacketPokerCards.format_element)
        return block

    def calcsize(self):
        return PacketPokerId.calcsize(self) + self.calcsizelist(self.cards, PacketPokerCards.format_element)

    def __str__(self):
        return PacketPokerId.__str__(self) + " cards = %s" % self.cards

PacketFactory[PACKET_POKER_CARDS] = PacketPokerCards

########################################

PACKET_POKER_PLAYER_CARDS = 61 # 0x3d # %SEQ%
PacketNames[PACKET_POKER_PLAYER_CARDS] = "POKER_PLAYER_CARDS"

class PacketPokerPlayerCards(PacketPokerCards):
    """\
Semantics: the ordered list of "cards" for player "serial"
in game "game_id".

Direction: server  => client

cards: list of integers describing cards.
       255 == placeholder, i.e. down card with unknown value
       bit 7 and bit 8 set == down card
       bit 7 and bit 8 not set == up card
       bits 1 to 6 == card value as follows:

       2h/00  2d/13  2c/26  2s/39
       3h/01  3d/14  3c/27  3s/40
       4h/02  4d/15  4c/28  4s/41
       5h/03  5d/16  5c/29  5s/42
       6h/04  6d/17  6c/30  6s/43
       7h/05  7d/18  7c/31  7s/44
       8h/06  8d/19  8c/32  8s/45
       9h/07  9d/20  9c/33  9s/46
       Th/08  Td/21  Tc/34  Ts/47
       Jh/09  Jd/22  Jc/35  Js/48
       Qh/10  Qd/23  Qc/36  Qs/49
       Kh/11  Kd/24  Kc/37  Ks/50
       Ah/12  Ad/25  Ac/38  As/51

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_PLAYER_CARDS

PacketFactory[PACKET_POKER_PLAYER_CARDS] = PacketPokerPlayerCards

########################################

PACKET_POKER_BOARD_CARDS = 62 # 0x3e # %SEQ%
PacketNames[PACKET_POKER_BOARD_CARDS] = "POKER_BOARD_CARDS"

class PacketPokerBoardCards(PacketPokerCards):
    """\
Semantics: the ordered list of community "cards"
for game "game_id".

Direction: server  => client

cards: list of integers describing cards.
       255 == placeholder, i.e. down card with unknown value
       bit 7 and bit 8 set == down card
       bit 7 and bit 8 not set == up card
       bits 1 to 6 == card value as follows:

       2h/00  2d/13  2c/26  2s/39
       3h/01  3d/14  3c/27  3s/40
       4h/02  4d/15  4c/28  4s/41
       5h/03  5d/16  5c/29  5s/42
       6h/04  6d/17  6c/30  6s/43
       7h/05  7d/18  7c/31  7s/44
       8h/06  8d/19  8c/32  8s/45
       9h/07  9d/20  9c/33  9s/46
       Th/08  Td/21  Tc/34  Ts/47
       Jh/09  Jd/22  Jc/35  Js/48
       Qh/10  Qd/23  Qc/36  Qs/49
       Kh/11  Kd/24  Kc/37  Ks/50
       Ah/12  Ad/25  Ac/38  As/51

game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_BOARD_CARDS

PacketFactory[PACKET_POKER_BOARD_CARDS] = PacketPokerBoardCards

########################################

PACKET_POKER_CHIPS = 63 # 0x3f # %SEQ%
PacketNames[PACKET_POKER_CHIPS] = "POKER_CHIPS"

class PacketPokerChips(PacketPokerId):
    """base class"""

    type = PACKET_POKER_CHIPS

    info = PacketPokerId.info + ( ('bet', 0, 'I'), )
    
    format = "!I"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.bet = kwargs.get("bet", 0)
        if not ( type(self.bet) == IntType or type(self.bet) == LongType ): raise UserWarning, "not an int" + str(self.bet)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + pack(PacketPokerChips.format, self.bet)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.bet,) = unpack(PacketPokerChips.format, block[:PacketPokerChips.format_size])
        return block[PacketPokerChips.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerChips.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + " bet = %d" % self.bet

PacketFactory[PACKET_POKER_CHIPS] = PacketPokerChips

########################################

PACKET_POKER_PLAYER_CHIPS = 64 # 0x40 # %SEQ%
PacketNames[PACKET_POKER_PLAYER_CHIPS] = "POKER_PLAYER_CHIPS"

class PacketPokerPlayerChips(PacketPokerChips):
    """\
Semantics: the "money" of the player "serial" engaged in
game "game_id" and the "bet" currently wagered by the player, if any.

Direction: server  => client

Context: this packet is infered each time the bet or the chip
stack of a player is modified.

bet: the number of chips wagered by the player for the current betting round.
money: the number of chips available to the player for this game.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_PLAYER_CHIPS

    info = PacketPokerChips.info + ( ('money', 0, 'I'), )

    format = "!I"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.money = kwargs.get("money", 0)
        if not ( type(self.money) == IntType or type(self.money) == LongType ): raise UserWarning, "not an int" + str(self.money)
        PacketPokerChips.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerChips.pack(self) + pack(PacketPokerPlayerChips.format, self.money)

    def unpack(self, block):
        block = PacketPokerChips.unpack(self, block)
        (self.money,) = unpack(PacketPokerPlayerChips.format, block[:PacketPokerPlayerChips.format_size])
        return block[PacketPokerPlayerChips.format_size:]

    def calcsize(self):
        return PacketPokerChips.calcsize(self) + PacketPokerPlayerChips.format_size

    def __str__(self):
        return PacketPokerChips.__str__(self) + " money = %d" % self.money

PacketFactory[PACKET_POKER_PLAYER_CHIPS] = PacketPokerPlayerChips

########################################

PACKET_POKER_CHECK = 65 # 0x41 # %SEQ%
PacketNames[PACKET_POKER_CHECK] = "POKER_CHECK"

class PacketPokerCheck(PacketPokerId):
    """\
Semantics: the "serial" player checked in game
"game_id".

Direction: server <=> client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_CHECK

PacketFactory[PACKET_POKER_CHECK] = PacketPokerCheck

########################################

PACKET_POKER_START = 66 # 0x42 # %SEQ%
PacketNames[PACKET_POKER_START] = "POKER_START"

class PacketPokerStart(PacketPokerId):
    """\
Semantics: start the hand "hand_serial" for game "game_id". If
"level" is greater than zero, play at tournament level "level".
If "level" is greater than zero, meaning that the hand is part
of a tournament, the fields "hands_count" is set to the number
of hands since the beginning of the tournament and "time" is set to
the number of seconds since the beginning of the
tournament.

Direction: server  => client

Context: this packet is sent exactly once per turn, after the
 PACKET_POKER_DEALER and PACKET_POKER_IN_GAME packets relevant to
the hand to come.
A PACKET_POKER_CHIPS_POT_RESET packet is inferred after this packet.
A PACKET_POKER_PLAYER_CHIPS packet is inferred for each player sit after
this packet.

hands_count: total number of hands dealt for this game.
time: number of seconds since the first hand dealt for this game.
hand_serial: server wide unique identifier of this hand.
level: integer indicating the tournament level at which the current
       hand is played.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_START

    info = PacketPokerId.info + ( ('hands_count', 0, 'I'),
                                  ('time', 0, 'I'),
                                  ('hand_serial', 0, 'I'),
                                  ('level', 0, 'B'),
                                  )

    format = "!IIIB"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.hands_count = kwargs.get("hands_count",0)
        self.time = int(kwargs.get("time",0))
        self.hand_serial = kwargs.get("hand_serial",0)
        self.level = kwargs.get("level",0)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + pack(PacketPokerStart.format, self.hands_count, self.time, self.hand_serial, self.level)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.hands_count, self.time, self.hand_serial, self.level) = unpack(PacketPokerStart.format, block[:PacketPokerStart.format_size])
        return block[PacketPokerStart.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerStart.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + " hands_count = %d, time = %d, hand_serial = %d, level = %d" % (self.hands_count, self.time, self.hand_serial, self.level)

PacketFactory[PACKET_POKER_START] = PacketPokerStart

########################################

PACKET_POKER_IN_GAME = 67 # 0x43 # %SEQ%
PacketNames[PACKET_POKER_IN_GAME] = "POKER_IN_GAME"

class PacketPokerInGame(PacketPokerId):
    """\
Semantics: the list of "players" serials who are participating
in the hand to come or the current hand for the game "game_id".

Context: this packet is sent before the hand starts (i.e. before
the PACKET_POKER_START packet is sent). It may also be sent before
the end of the "blindAnte" round (i.e. before a PACKET_POKER_STATE
packet changing the state "blindAnte" to something else is sent).
The later case happen when a player refuses to pay the blind or
the ante. When the hand is running and is past the "blindAnte" round,
no PACKET_POKER_IN_GAME packet is sent.

Direction: server => client

players: list of serials of players participating in the hand.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_IN_GAME

    info = PacketPokerId.info + ( ('players', [], 'Il'), )
    
    format_element = "!I"

    def __init__(self, *args, **kwargs):
        self.players = kwargs.get("players",[])
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + self.packlist(self.players, PacketPokerInGame.format_element)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (block, self.players) = self.unpacklist(block, PacketPokerInGame.format_element)
        return block

    def calcsize(self):
        return PacketPokerId.calcsize(self) + self.calcsizelist(self.players, PacketPokerInGame.format_element)

    def __str__(self):
        return PacketPokerId.__str__(self) + " players = %s" % self.players

PacketFactory[PACKET_POKER_IN_GAME] = PacketPokerInGame

########################################

PACKET_POKER_CALL = 68 # 0x44 # %SEQ%
PacketNames[PACKET_POKER_CALL] = "POKER_CALL"

class PacketPokerCall(PacketPokerId):
    """\
Semantics: the "serial" player called in game "game_id".

Direction: server <=> client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_CALL

PacketFactory[PACKET_POKER_CALL] = PacketPokerCall

########################################

PACKET_POKER_RAISE = 69 # 0x45 # %SEQ%
PacketNames[PACKET_POKER_RAISE] = "POKER_RAISE"

class PacketPokerRaise(PacketPokerBet):
    """\
Semantics: the "serial" player raised "amount" chips in
game "game_id".

Direction: server <=> client

Context: the client infers a PACKET_POKER_BET_LIMIT packet each
time the position changes.

amount: the number of chips for the raise. A value of all 0 means the lowest possible raise.
     A value larger than the maximum raise will be clamped by
     the server.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_RAISE

PacketFactory[PACKET_POKER_RAISE] = PacketPokerRaise

########################################

PACKET_POKER_DEALER = 70 # 0x46 # %SEQ%
PacketNames[PACKET_POKER_DEALER] = "POKER_DEALER"

class PacketPokerDealer(Packet):
    """\
Semantics: the dealer button for game "game_id" is at seat "dealer".
and the previous dealer was at seat "previous_dealer"

Direction: server  => client

Context: this packet is guaranteed to be sent when the game is not
running. The dealer is never altered while the game is running.
It is never sent for non button games such as stud 7.

dealer: the seat number on wich the dealer button is located [0-9].
previous_dealer: the seat number on wich the previous dealer button is located [0-9].
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_DEALER

    info = Packet.info + ( ('game_id', 0, 'I'),
                           ('dealer', -1, 'b'),
                           ('previous_dealer', -1, 'b'),
                           )

    format = "!IBB"
    format_size = calcsize(format)

    def __init__(self, **kwargs):
        self.game_id = kwargs.get("game_id", 0)
        self.dealer = kwargs.get("dealer", -1)
        self.previous_dealer = kwargs.get("previous_dealer", -1)

    def pack(self):
        dealer = self.dealer == -1 and 255 or self.dealer
        previous_dealer = self.previous_dealer == -1 and 255 or self.previous_dealer
        return Packet.pack(self) + pack(PacketPokerDealer.format, self.game_id, dealer, previous_dealer)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (self.game_id, self.dealer, self.previous_dealer) = unpack(PacketPokerDealer.format, block[:PacketPokerDealer.format_size])
        if self.dealer == 255: self.dealer = -1
        if self.previous_dealer == 255: self.previous_dealer = -1
        return block[PacketPokerDealer.format_size:]

    def calcsize(self):
        return Packet.calcsize(self) + PacketPokerDealer.format_size

    def __str__(self):
        return Packet.__str__(self) + " game_id = %d, dealer = %d, previous_dealer = %d" % ( self.game_id, self.dealer, self.previous_dealer )

PacketFactory[PACKET_POKER_DEALER] = PacketPokerDealer

########################################

PACKET_POKER_TABLE_JOIN = 71 # 0x47 # %SEQ%
PacketNames[PACKET_POKER_TABLE_JOIN] = "POKER_TABLE_JOIN"

class PacketPokerTableJoin(PacketPokerId):
    """\
Semantics: player "serial" wants to become an observer
of the game "game_id".

There are three possible outcomes for the client in response to a
PacketPokerTableJoin():

  (0) In the case that the join is completely successful, or if the player
      had already joined the table, the following packets are sent:

          PACKET_POKER_TABLE
          PACKET_POKER_BATCH_MODE
          for each player in the game:
               PACKET_POKER_PLAYER_ARRIVE
          if the player is playing:
                PACKET_POKER_PLAYER_CHIPS
          if the player is sit:
                PACKET_POKER_SIT
          PACKET_POKER_SEATS
          if the game is running:
                the exact packet sequence that lead to the current state
                of the game. Varies according to the game.
          PACKET_POKER_STREAM_MODE

      Note clearly that if the player had already previously joined the
      table, the packets above will be sent as if the player just joined.
      However, in that case, the packet will have no side effect.


   (1) If the the player was unable to join the table specifically that
       the server has reached the maximum number of joined players, two
       packets will be sent to the client, the second of which is
       deprecated:

        (a) the following packet (recommended way of testing for failure):
            PacketPokerError(code      = PacketPokerTableJoin.FULL,
                            message   = "This server has too many seated players and observers.",
                           other_type = PACKET_POKER_TABLE_JOIN,
                           serial     = <player's serial id>,
                           game_id    = <id of the table>)

        (b) a packet, PACKET_POKER_TABLE, with serial 0 will be sent.  It
            will contain no meaningful information.  (THIS BEHAVIOR IS
            DEPRECATED, and is left only for older clients.
            New clients should not rely on this behavior.)

  (2) If the player cannot join the table for any reason (other than the
      table is FULL (as per (1) above), two packets will be sent to the
      client, one of which is deprecated:

       (a) the following packet (recommended way of testing for failure):
           PacketPokerError(code      = PacketPokerTableJoin.GENERAL_FAILURE,
                            message   = <some string of non-zero length, for use
                                        in displaying to the user>,
                           other_type = PACKET_POKER_TABLE_JOIN,
                           serial     = <player's serial id>,
                           game_id    = 0)

       (b) a packet, PACKET_POKER_TABLE, with serial 0 will be sent.  It
           will contain no meaningful information.  (THIS BEHAVIOR IS
           DEPRECATED, and is left only for older clients.
           New clients should not rely on this behavior.)

Direction: server <= client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    FULL = 1
    GENERAL_FAILURE = 2
    type = PACKET_POKER_TABLE_JOIN

PacketFactory[PACKET_POKER_TABLE_JOIN] = PacketPokerTableJoin

########################################

PACKET_POKER_TABLE_SELECT = 72 # 0x48 # %SEQ%
PacketNames[PACKET_POKER_TABLE_SELECT] = "POKER_TABLE_SELECT"

class PacketPokerTableSelect(PacketString):
    """\
Semantics: request the list of tables matching the "string" constraint.
The answer is a possibly empty PACKET_POKER_TABLE_LIST packet.

Direction: server <=  client

string: currency<tabulation>variant
        Examples: 1 holdem selects all holdem tables using this currency
        The specials value "my" restricts the search to the tables
        in which the player id attached to the connection is playing.
"""

    type = PACKET_POKER_TABLE_SELECT

PacketFactory[PACKET_POKER_TABLE_SELECT] = PacketPokerTableSelect

########################################
PACKET_POKER_TABLE = 73 # 0x49 # %SEQ%
PacketNames[PACKET_POKER_TABLE] = "POKER_TABLE"

class PacketPokerTable(Packet):
    """\
Semantics: the full description of a poker game. When sent
to the server, act as a request to create the corresponding
game. When sent by the server, describes an existing poker
game.

The answer sent to the client will be the same as the answer
sent when receiving a PacketPokerTableJoin packet.

Direction: server <=> client

Display information:
# 10 seats (P01 to P10)
# a dealer button (D)
# each player has two chip stacks displayed on the table
## the chips that are not engaged in the game (M)
## the chips that were bet during this betting round (B)
# each player two places for cards
## up to 5 cards hidden in his hand (H)
## up to 7 cards on the table in front of him (some up some down) (V)
# 5 community cards are displayed face up in the middle (C)
# up to 9 pots are in the middle, each for a player who is allin (P1 to P9)
# at showdown the winning hands are
## two hands for high / low variants (colors on H, V or C)
## as many winning hands per allin player
{{{
        HHHHH   HHHHH    HHHHH   HHHHH
         P09     P10      P01     P02
       VVVVVVV VVVVVVV  VVVVVVV VVVVVVV
         B M     B M      B M     B M
  HHHHH                               HHHHH
   P08 M B        CCCCC            B M P03
 VVVVVVV P1 P2 P3 P4 P5 P6 P7 P8 P9  VVVVVVV

         B M     B M      B M     B M D
       VVVVVVV VVVVVVV   VVVVVVV VVVVVVV
         P07     P06       P05     P04
        HHHHH   HHHHH     HHHHH   HHHHH
}}}

name: symbolic name of the game.
variant: base name of the variant that must match a poker.<variant>.xml
         file containing a full description of the variant.
betting_structure: base name of the betting structure that must
                   match a poker.<betting_structure>.xml file containing
                   a full description of the betting structure.
id: integer used as the unique id of the game and referred to
    with the "game_id" field in all other packets.
seats: maximum number of seats in this game.
average_pot: the average amount put in the pot in the past few minutes.
percent_flop: the average percentage of players after the flop in the past
              few minutes.
players: the number of players who joined the table and are seated
observers: the number of players who joined (as in PACKET_POKER_TABLE_JOIN)
           the table but are not seated.
waiting: the number of players in the waiting list.
player_timeout: the number of seconds after which a player in position is forced to
         play (by folding).
muck_timeout: the number of seconds after which a player is forced to muck.
currency_serial: int currency id
skin: name of the level model to use
reason: string representing the reason that this packet is being sent to
        the client.  Possible values are ("", "TableList", "TablePicker",
        "TourneyMove", "TourneyStart", "TableJoin", "TableCreate", "HandReplay")
"""

    REASON_TABLE_LIST    = "TableList"
    REASON_TABLE_PICKER  = "TablePicker"
    REASON_TOURNEY_MOVE  = "TourneyMove"
    REASON_TOURNEY_START = "TourneyStart"
    REASON_TABLE_JOIN    = "TableJoin"
    REASON_TABLE_CREATE  = "TableCreate"
    REASON_HAND_REPLAY   = "HandReplay"
    REASON_NONE          = ""

    type = PACKET_POKER_TABLE

    info = Packet.info + ( ('id', 0, 'I'),
                           ('seats', 10, 'B'),
                           ('average_pot', 0, 'I'),
                           ('hands_per_hour', 0, 'H'),
                           ('percent_flop', 0, 'B'),
                           ('players', 0, 'B'),
                           ('observers', 0, 'H'),
                           ('waiting', 0, 'B'),
                           ('player_timeout', 0, 'H'),
                           ('muck_timeout', 0, 'H'),
                           ('currency_serial', 0, 'I'),
                           ('name', 'noname', 's'),
                           ('variant', 'holdem', 's'),
                           ('betting_structure', '2-4-limit', 's'),
                           ('skin', 'default', 's'),
                           ('reason', '', 's'),
                           ('tourney_serial', 0, 'no net')
                           )
    
    format = "!IBIHBBHBHHI"
    format_size = calcsize(format)

    def __init__(self, **kwargs):
        self.name = kwargs.get("name", "noname")
        self.variant = kwargs.get("variant", "holdem")
        self.betting_structure = kwargs.get("betting_structure", "2-4-limit")
        self.id = kwargs.get("id", 0)
        self.seats = kwargs.get("seats", 10)
        self.average_pot = kwargs.get("average_pot", 0)
        self.hands_per_hour = kwargs.get("hands_per_hour", 0)
        self.percent_flop = kwargs.get("percent_flop", 0)
        self.players = kwargs.get("players", 0)
        self.observers = kwargs.get("observers", 0)
        self.waiting = kwargs.get("waiting", 0)
        self.player_timeout = kwargs.get("player_timeout", 0)
        self.muck_timeout = kwargs.get("muck_timeout", 0)
        self.skin = kwargs.get("skin", "default")
        self.reason = kwargs.get("reason", "")
        self.currency_serial = kwargs.get("currency_serial", 0)
        self.tourney_serial = kwargs.get("tourney_serial", 0)

    def pack(self):
        block = Packet.pack(self)
        block += pack(PacketPokerTable.format, self.id, self.seats, self.average_pot, self.hands_per_hour, self.percent_flop, self.players, self.observers, self.waiting, self.player_timeout, self.muck_timeout, self.currency_serial)
        block += self.packstring(self.name)
        block += self.packstring(self.variant)
        block += self.packstring(self.betting_structure)
        block += self.packstring(self.skin)
        block += self.packstring(self.reason)
        return block

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (self.id, self.seats, self.average_pot, self.hands_per_hour, self.percent_flop, self.players, self.observers, self.waiting, self.player_timeout, self.muck_timeout, self.currency_serial) = unpack(PacketPokerTable.format, block[:PacketPokerTable.format_size])
        block = block[PacketPokerTable.format_size:]
        (block, self.name) = self.unpackstring(block)
        (block, self.variant) = self.unpackstring(block)
        (block, self.betting_structure) = self.unpackstring(block)
        (block, self.skin) = self.unpackstring(block)
        (block, self.reason) = self.unpackstring(block)
        return block

    def calcsize(self):
        return Packet.calcsize(self) + PacketPokerTable.format_size + self.calcsizestring(self.name) + self.calcsizestring(self.variant) + self.calcsizestring(self.betting_structure) + self.calcsizestring(self.skin) + self.calcsizestring(self.reason)

    def __str__(self):
        return Packet.__str__(self) + "\n\tid = %d, name = %s, variant = %s, betting_structure = %s, seats = %d, average_pot = %d, hands_per_hour = %d, percent_flop = %d, players = %d, observers = %d, waiting = %d, player_timeout = %d, muck_timeout = %d, currency_serial = %d, skin = %s, tourney_serial = %i, reason = %s" % ( self.id, self.name, self.variant, self.betting_structure, self.seats, self.average_pot, self.hands_per_hour, self.percent_flop, self.players, self.observers, self.waiting, self.player_timeout, self.muck_timeout, self.currency_serial, self.skin, self.tourney_serial, self.reason )

PacketFactory[PACKET_POKER_TABLE] = PacketPokerTable

########################################

PACKET_POKER_TABLE_LIST = 74 # 0x4a # %SEQ%
PacketNames[PACKET_POKER_TABLE_LIST] = "POKER_TABLE_LIST"

class PacketPokerTableList(PacketList):
    """\
Semantics: a list of PACKET_POKER_TABLE packets sent as a
response to a PACKET_POKER_SELECT request.

Direction: server  => client

packets: a list of PACKET_POKER_TABLE packets.
"""

    type = PACKET_POKER_TABLE_LIST

    info = PacketList.info + ( ('players', 0, 'I'),
                               ('tables', 0, 'I'),
                               )
    
    format = "!II"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.players = kwargs.get("players", 0)
        self.tables = kwargs.get("tables", 0)
        PacketList.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketList.pack(self) + pack(PacketPokerTableList.format, self.players, self.tables)

    def unpack(self, block):
        block = PacketList.unpack(self, block)
        (self.players, self.tables) = unpack(PacketPokerTableList.format, block[:PacketPokerTableList.format_size])
        return block[PacketPokerTableList.format_size:]

    def calcsize(self):
        return PacketList.calcsize(self) + PacketPokerTableList.format_size

    def __str__(self):
        return PacketList.__str__(self) + "\n\tplayers = %d, tables = %d" % ( self.players, self.tables )

PacketFactory[PACKET_POKER_TABLE_LIST] = PacketPokerTableList

########################################

PACKET_POKER_SIT = 75 # 0x4b # %SEQ%
PacketNames[PACKET_POKER_SIT] = "POKER_SIT"

class PacketPokerSit(PacketPokerId):
    """\
Semantics: the player "serial" is willing to participate in
the game "game_id".

Direction: server <=> client

Context: this packet must occur after getting a seat for the
game (i.e. a PACKET_POKER_SEAT is honored by the server). A
number of PACKET_POKER_SIT packets are inferred from the
 PACKET_POKER_IN_GAME packet. The server will broadcast to
all players and observers the PACKET_POKER_SIT in case of
success. The server will not send anything back if an error
occurs.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_SIT

PacketFactory[PACKET_POKER_SIT] = PacketPokerSit

########################################

PACKET_POKER_TABLE_DESTROY = 76 # 0x4c # %SEQ%
PacketNames[PACKET_POKER_TABLE_DESTROY] = "POKER_TABLE_DESTROY"

class PacketPokerTableDestroy(PacketPokerId):
    """destroy"""

    type = PACKET_POKER_TABLE_DESTROY

PacketFactory[PACKET_POKER_TABLE_DESTROY] = PacketPokerTableDestroy

########################################

PACKET_POKER_TIMEOUT_WARNING = 77 # 0x4d # %SEQ%
PacketNames[PACKET_POKER_TIMEOUT_WARNING] = "POKER_TIMEOUT_WARNING"

class PacketPokerTimeoutWarning(PacketPokerId):
    """\
Semantics: the player "serial" is taking too long to play and will
be folded automatically shortly in the game "game_id".

Direction: server  => client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_TIMEOUT_WARNING

    info = PacketPokerId.info + ( ('timeout', sys.maxint, 'I'),
                                  ('when', -1, 'no net'),
                                  )

    format = "!I"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.timeout = kwargs.get("timeout", sys.maxint)
        self.when = kwargs.get("when", -1)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + pack(PacketPokerTimeoutWarning.format, self.timeout)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.timeout,) = unpack(PacketPokerTimeoutWarning.format, block[:PacketPokerTimeoutWarning.format_size])
        return block[PacketPokerTimeoutWarning.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerTimeoutWarning.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + " timeout = %d" % self.timeout

PacketFactory[PACKET_POKER_TIMEOUT_WARNING] = PacketPokerTimeoutWarning

########################################

PACKET_POKER_TIMEOUT_NOTICE = 78 # 0x4e # %SEQ%
PacketNames[PACKET_POKER_TIMEOUT_NOTICE] = "POKER_TIMEOUT_NOTICE"

class PacketPokerTimeoutNotice(PacketPokerId):
    """\
Semantics: the player "serial" is took too long to play and has
been folded in the game "game_id".

Direction: server  => client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_TIMEOUT_NOTICE

PacketFactory[PACKET_POKER_TIMEOUT_NOTICE] = PacketPokerTimeoutNotice

########################################

PACKET_POKER_SEAT = 79 # 0x4f # %SEQ%
PacketNames[PACKET_POKER_SEAT] = "POKER_SEAT"

class PacketPokerSeat(PacketPokerId):
    """\
Semantics: the player "serial" is seated on the seat "seat"
in the game "game_id". When a client asks for seat 255,
it instructs the server to chose the first seat available.
If the server refuses a request, it answers to the
requestor with a PACKET_POKER_SEAT packet with a seat field
set to 255.

Direction: server <=> client

Context: the player must join the game (PACKET_POKER_TABLE_JOIN)
before issuing a request for a seat. If the request is a success,
the server will send a PACKET_POKER_PLAYER_ARRIVE and a
 PACKET_POKER_TABLE_SEATS packet.

seat: a seat number in the interval [0,9] or 255 for an invalid seat.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""
    ROLE_PLAY = 1

    type = PACKET_POKER_SEAT

    info = PacketPokerId.info + ( ('seat', -1, 'b'), )

    format = "!B"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.seat = kwargs.get("seat", -1)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        seat = self.seat == -1 and 255 or self.seat
        return PacketPokerId.pack(self) + pack(PacketPokerSeat.format, seat)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.seat,) = unpack(PacketPokerSeat.format, block[:PacketPokerSeat.format_size])
        if self.seat == 255: self.seat = -1
        return block[PacketPokerSeat.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerSeat.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + " seat = %d" % self.seat

PacketFactory[PACKET_POKER_SEAT] = PacketPokerSeat

########################################

PACKET_POKER_TABLE_MOVE = 80 # 0x50 # %SEQ%
PacketNames[PACKET_POKER_TABLE_MOVE] = "POKER_TABLE_MOVE"

class PacketPokerTableMove(PacketPokerSeat):
    """\
Semantics: move player "serial" from game "game_id" to
game "to_game_id". Special operation meant to reseat a player
from a tournament game to another. The player is automatically
seated at sit-in in the new game.

Direction: server  => client

Context: this packet is equivalent to a PACKET_POKER_LEAVE immediately
followed by a PACKET_POKER_JOIN, a PACKET_POKER_SEAT and a PACKET_POKER_SIT
without the race conditions that would occur if using multiple packets.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
to_game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_TABLE_MOVE

    info = PacketPokerSeat.info + ( ('to_game_id', sys.maxint, 'I'), )

    format = "!I"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.to_game_id = kwargs.get("to_game_id", sys.maxint)
        PacketPokerSeat.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerSeat.pack(self) + pack(PacketPokerTableMove.format, self.to_game_id)

    def unpack(self, block):
        block = PacketPokerSeat.unpack(self, block)
        (self.to_game_id,) = unpack(PacketPokerTableMove.format, block[:PacketPokerTableMove.format_size])
        return block[PacketPokerTableMove.format_size:]

    def calcsize(self):
        return PacketPokerSeat.calcsize(self) + PacketPokerTableMove.format_size

    def __str__(self):
        return PacketPokerSeat.__str__(self) + " to_game_id = %d" % self.to_game_id

PacketFactory[PACKET_POKER_TABLE_MOVE] = PacketPokerTableMove

########################################

PACKET_POKER_PLAYER_LEAVE = 81 # 0x51 # %SEQ%
PacketNames[PACKET_POKER_PLAYER_LEAVE] = "POKER_PLAYER_LEAVE"

class PacketPokerPlayerLeave(PacketPokerSeat):
    """\
Semantics: the player "serial" leaves the seat "seat" at game "game_id".

Direction: server <=> client

Context: ineffective in tournament games. If the player is playing a
hand the server will wait until the end of the turn to relay the
packet to other players involved in the same hand. A player is allowed
to leave in the middle of the game but the server hides this to the
other players.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
seat: the seat left in the range [0,9]
"""

    TOURNEY = 1

    type = PACKET_POKER_PLAYER_LEAVE

PacketFactory[PACKET_POKER_PLAYER_LEAVE] = PacketPokerPlayerLeave

########################################

PACKET_POKER_SIT_OUT = 82 # 0x52 # %SEQ%
PacketNames[PACKET_POKER_SIT_OUT] = "POKER_SIT_OUT"

class PacketPokerSitOut(PacketPokerId):
    """\
Semantics: the player "serial" seated at the game "game_id"
is now sit out, i.e. not willing to participate in the game.

Direction: server <=> client

Context: if the game is not running (i.e. not between PACKET_POKER_START
packet and a PACKET_POKER_STATE with state == "end" or a PACKET_POKER_CANCELED )
or still in the blind / ante phase (i.e. the last PACKET_POKER_STATE was
state == "blindAnte"), the server honors the request immediately and broadcasts the packet
to all the players watching or participating in the game. If the game
is running and is not in the blind / ante phase, the request is
interpreted as a will to fold (equivalent to PACKET_POKER_FOLD) when
the player comes in position and to sit out when the game ends
(i.e. the PACKET_POKER_SIT_OUT is postponed to the end of the game).

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_SIT_OUT

PacketFactory[PACKET_POKER_SIT_OUT] = PacketPokerSitOut

########################################

PACKET_POKER_TABLE_QUIT = 83 # 0x53 # %SEQ%
PacketNames[PACKET_POKER_TABLE_QUIT] = "POKER_TABLE_QUIT"

class PacketPokerTableQuit(PacketPokerId):
    """\
Semantics: the player "serial" is will to be disconnected from
game "game_id".

Direction: server <=  client / client <=> client

Context: inferred when sent to the server because no answer
is expected from the server.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_TABLE_QUIT

PacketFactory[PACKET_POKER_TABLE_QUIT] = PacketPokerTableQuit

########################################

PACKET_POKER_BUY_IN = 84 # 0x54 # %SEQ%
PacketNames[PACKET_POKER_BUY_IN] = "POKER_BUY_IN"

class PacketPokerBuyIn(PacketPokerId):
    """\
Semantics: the player "serial" is willing to participate in
the game "game_id" with an amount equal to "amount". The server
will ensure that the "amount" fits the game constraints (i.e.
player bankroll or betting structure limits).

Direction: server <=  client.

Context: this packet must occur after a successfull PACKET_POKER_SEAT
and before a PACKET_POKER_SIT for the same player. The minimum/maximum
buy in are determined by the betting structure of the game, as
specified in the PACKET_POKER_TABLE packet.

amount: integer specifying the amount to bring to the game.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_BUY_IN

    info = PacketPokerId.info + ( ('amount', 0, 'I'), )

    format = "!I"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.amount = kwargs.get("amount",0)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + pack(PacketPokerBuyIn.format, self.amount)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.amount,) = unpack(PacketPokerBuyIn.format, block[:PacketPokerBuyIn.format_size])
        return block[PacketPokerBuyIn.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerBuyIn.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + " amount = %d" % self.amount

PacketFactory[PACKET_POKER_BUY_IN] = PacketPokerBuyIn

########################################

PACKET_POKER_REBUY = 85 # 0x55 # %SEQ%
PacketNames[PACKET_POKER_REBUY] = "POKER_REBUY"

class PacketPokerRebuy(PacketPokerBuyIn):
    """\
Semantics: the player "serial" is willing to participate in
the game "game_id" with an amount equal to "amount". The server
will ensure that the "amount" fits the game constraints (i.e.
player bankroll or betting structure limits).

Direction: server <=  client.

Context: this packet must occur after a successfull PACKET_POKER_BUY_IN
The minimum/maximum rebuy are determined by the betting structure of
the game, as specified in the PACKET_POKER_TABLE packet. The player
may rebuy at any moment if he has less than the maximum amount of money
allowed by the betting structure.

amount: integer specifying the amount to bring to the game.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_REBUY

PacketFactory[PACKET_POKER_REBUY] = PacketPokerRebuy

########################################

PACKET_POKER_CHAT = 86 # 0x56 # %SEQ%
PacketNames[PACKET_POKER_CHAT] = "POKER_CHAT"

class PacketPokerChat(PacketPokerId):
   """\
Semantics: a text "message" sent to all players seated
at the poker table "game_id".

Direction: server  <=> client

message: a text message string (2^16 long max)
game_id: integer uniquely identifying a game.
"""

   type = PACKET_POKER_CHAT

   info = PacketPokerId.info + ( ('message', '', 's'), )
   
   def __init__(self, *args, **kwargs):
       self.message = kwargs.get("message", "")
       PacketPokerId.__init__(self, *args, **kwargs)

   def pack(self):
       return PacketPokerId.pack(self) + self.packstring(self.message)

   def unpack(self, block):
       block = PacketPokerId.unpack(self, block)
       (block, self.message) = self.unpackstring(block)
       return block

   def calcsize(self):
       return PacketPokerId.calcsize(self) + self.calcsizestring(self.message)

   def __str__(self):
       return PacketPokerId.__str__(self) + " message = %s" % self.message

PacketFactory[PACKET_POKER_CHAT] = PacketPokerChat

########################################

PACKET_POKER_PLAYER_INFO = 87 # 0x57 # %SEQ%
PacketNames[PACKET_POKER_PLAYER_INFO] = "POKER_PLAYER_INFO"

class PacketPokerPlayerInfo(PacketPokerId):
   """\
Semantics: the player "serial" descriptive informations. When
sent to the server, sets the information and broadcast them
to other players. When sent from the server, notify the client
of a change in the player descriptive informations.

Direction: server <=> client

name: login name of the player.
url: outfit url to load from
outfit: name of the player outfit.
serial: integer uniquely identifying a player.
"""

   NOT_LOGGED = 1

   type = PACKET_POKER_PLAYER_INFO

   info = PacketPokerId.info + ( ('name', 'noname', 's'),
                                 ('outfit', 'random', 's'),
                                 ('url', 'random', 's'),
                                 # FIXME_PokerPlayerInfoLocale: 
                                 # (see also sr #2262 )
                                 # should "locale" be here?  It's
                                 #  referenced in
                                 #  PokerService.getPlayerInfo().  I'm the
                                 #  one who probably added that, but I am
                                 #  unclear as to why right now, but
                                 #  wanted to note I notced. -- bkuhn
                                 )
   
   def __init__(self, *args, **kwargs):
       self.name = kwargs.get('name', "noname")
       self.url = kwargs.get('url', "random")
       self.outfit = kwargs.get('outfit',"random")
       PacketPokerId.__init__(self, *args, **kwargs)

   def pack(self):
       return PacketPokerId.pack(self) + self.packstring(self.name) + self.packstring(self.outfit) + self.packstring(self.url)

   def unpack(self, block):
       block = PacketPokerId.unpack(self, block)
       (block, self.name) = self.unpackstring(block)
       (block, self.outfit) = self.unpackstring(block)
       (block, self.url) = self.unpackstring(block)
       return block

   def calcsize(self):
       return PacketPokerId.calcsize(self) + self.calcsizestring(self.name) + self.calcsizestring(self.outfit) + self.calcsizestring(self.url)

   def __str__(self):
       return PacketPokerId.__str__(self) + " name = %s, url = %s, outfit = %s " % ( self.name , self.url, self.outfit )

PacketFactory[PACKET_POKER_PLAYER_INFO] = PacketPokerPlayerInfo

########################################

PACKET_POKER_PLAYER_ARRIVE = 88 # 0x58 # %SEQ%
PacketNames[PACKET_POKER_PLAYER_ARRIVE] = "POKER_PLAYER_ARRIVE"

class PacketPokerPlayerArrive(PacketPokerPlayerInfo):
    """\
Semantics: the player "serial" is seated at the game "game_id".
Descriptive information for the player such as "name" and "outfit"
is provided.

Direction: server  => client

Context: this packet is the server answer to successfull
 PACKET_POKER_SEAT request. The actual seat allocated to the player
will be specified in the next PACKET_POKER_SEATS packet.

name: login name of the player.
outfit: unique name of the player outfit.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_PLAYER_ARRIVE

    info = PacketPokerPlayerInfo.info + ( ('blind', 'late', 's'),
                                          ('remove_next_turn', False, 'bool'),
                                          ('sit_out', True, 'bool'),
                                          ('sit_out_next_turn', False, 'bool'),
                                          ('auto', False, 'bool'),
                                          ('auto_blind_ante', False, 'bool'),
                                          ('wait_for', False, 'bool'),
                                          ('buy_in_payed', False, 'bool'),
                                          ('seat', None, 'Bnone'),
                                  )
    
    format = "!BBBBBBBB"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.blind = kwargs.get("blind", "late")
        self.remove_next_turn = kwargs.get("remove_next_turn", False)
        self.sit_out = kwargs.get("sit_out", True)
        self.sit_out_next_turn = kwargs.get("sit_out_next_turn", False)
        self.auto = kwargs.get("auto", False)
        self.auto_blind_ante = kwargs.get("auto_blind_ante", False)
        self.wait_for = kwargs.get("wait_for", False)
        self.buy_in_payed = kwargs.get("buy_in_payed", False)
        self.seat = kwargs.get("seat", None)
        PacketPokerPlayerInfo.__init__(self, *args, **kwargs)

    def pack(self):
        blind = str(self.blind)
        remove_next_turn = self.remove_next_turn and 1 or 0
        sit_out = self.sit_out and 1 or 0
        sit_out_next_turn = self.sit_out_next_turn and 1 or 0
        auto = self.auto and 1 or 0
        auto_blind_ante = self.auto_blind_ante and 1 or 0
        wait_for = self.wait_for and 1 or 0
        buy_in_payed = self.buy_in_payed and 1 or 0
        if self.seat == None:
            seat = 255
        else:
            seat = self.seat
        return PacketPokerPlayerInfo.pack(self) + self.packstring(blind) + pack(PacketPokerPlayerArrive.format, remove_next_turn, sit_out, sit_out_next_turn, auto, auto_blind_ante, wait_for, buy_in_payed, seat)

    def unpack(self, block):
        block = PacketPokerPlayerInfo.unpack(self, block)
        (block, blind) = self.unpackstring(block)
        if blind == 'None':
            self.blind = None
        elif blind == 'False':
            self.blind = False
        else:
            self.blind = blind
        ( remove_next_turn, sit_out, sit_out_next_turn, auto, auto_blind_ante, wait_for, buy_in_payed, seat ) = unpack(PacketPokerPlayerArrive.format, block[:PacketPokerPlayerArrive.format_size])
        self.remove_next_turn = remove_next_turn == 1
        self.sit_out = sit_out == 1
        self.sit_out_next_turn = sit_out_next_turn == 1
        self.auto = auto == 1
        self.auto_blind_ante = auto_blind_ante == 1
        self.wait_for = wait_for == 1
        self.buy_in_payed = buy_in_payed == 1
        if seat == 255:
            self.seat = None
        else:
            self.seat = seat
        return block[PacketPokerPlayerArrive.format_size:]

    def calcsize(self):
        return PacketPokerPlayerInfo.calcsize(self) + self.calcsizestring(str(self.blind)) + PacketPokerPlayerArrive.format_size

    def __str__(self):
        return PacketPokerPlayerInfo.__str__(self) + "blind = %s, remove_next_turn = %s, sit_out = %s, sit_out_next_turn = %s, auto = %s, auto_blind_ante = %s, wait_for = %s, buy_in_payed = %s, seat = %s " % ( self.blind, self.remove_next_turn, self.sit_out, self.sit_out_next_turn, self.auto, self.auto_blind_ante, self.wait_for, self.buy_in_payed, self.seat )

PacketFactory[PACKET_POKER_PLAYER_ARRIVE] = PacketPokerPlayerArrive

########################################

PACKET_POKER_HAND_SELECT = 89 # 0x59 # %SEQ%
PacketNames[PACKET_POKER_HAND_SELECT] = "POKER_HAND_SELECT"

class PacketPokerHandSelect(PacketString):
    """\
Semantics: query the hand history for player "serial"
and filter them according to the "string" boolean expression.
Return slice of the matching hands that are in the range
["start", "start" + "count"[

Direction: server <=  client

Context: the answer of the server to this query is a
 PACKET_POKER_HAND_LIST packet.

string: a valid SQL WHERE expression on the hands table. The
available fields are "name" for the symbolic name of the hand,
"description" for the python expression describing the hand, "serial"
for the unique identifier of the hand also known as the hand_serial
in the PACKET_POKER_START packet.
start: index of the first matching hand
count: number of matching hands to return starting from start
serial: integer uniquely identifying a player.
"""

    type = PACKET_POKER_HAND_SELECT

    info = PacketString.info + ( ('start', 0, 'I'),
                                 ('count', 50, 'B'),
                                 )
    
    format = "!IB"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.start = kwargs.get("start", 0)
        self.count = kwargs.get("count", 50)
        PacketString.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketString.pack(self) + pack(PacketPokerHandSelect.format, self.start, self.count)

    def unpack(self, block):
        block = PacketString.unpack(self, block)
        (self.start, self.count) = unpack(PacketPokerHandSelect.format, block[:PacketPokerHandSelect.format_size])
        return block[PacketPokerHandSelect.format_size:]

    def calcsize(self):
        return PacketString.calcsize(self) + PacketPokerHandSelect.format_size

    def __str__(self):
        return PacketString.__str__(self) + " start = %d, count = %d" % ( self.start, self.count )

PacketFactory[PACKET_POKER_HAND_SELECT] = PacketPokerHandSelect

########################################

PACKET_POKER_HAND_LIST = 90 # 0x5a # %SEQ%
PacketNames[PACKET_POKER_HAND_LIST] = "POKER_HAND_LIST"

class PacketPokerHandList(PacketPokerHandSelect):
    """\
Semantics: a list of hand serials known to the server.

Direction: server  => client

Context: reply to the PACKET_POKER_HAND_SELECT packet.

hands: list of integers uniquely identifying a hand to the server.
"""

    type = PACKET_POKER_HAND_LIST

    info = PacketPokerHandSelect.info + ( ('hands', [], 'Il'),
                                          ('total', sys.maxint, 'I'),
                                          )

    format = "!I"
    format_size = calcsize(format)
    format_element = "!I"

    def __init__(self, *args, **kwargs):
        self.hands = kwargs.get("hands", [])
        self.total = kwargs.get("total", sys.maxint)
        PacketPokerHandSelect.__init__(self, *args, **kwargs)

    def pack(self):
        block = PacketPokerHandSelect.pack(self)
        block += self.packlist(self.hands, PacketPokerHandList.format_element)
        return block + pack(PacketPokerHandList.format, self.total)

    def unpack(self, block):
        block = PacketPokerHandSelect.unpack(self, block)
        (block, self.hands) = self.unpacklist(block, PacketPokerHandList.format_element)
        (self.total,) = unpack(PacketPokerHandList.format, block[:PacketPokerHandList.format_size])
        return block[PacketPokerHandList.format_size:]

    def calcsize(self):
        return PacketPokerHandSelect.calcsize(self) + self.calcsizelist(self.hands, PacketPokerHandList.format_element) + PacketPokerHandList.format_size

    def __str__(self):
        return PacketPokerHandSelect.__str__(self) + " hands = %s, total = %d" % ( self.hands, self.total )

PacketFactory[PACKET_POKER_HAND_LIST] = PacketPokerHandList

########################################

PACKET_POKER_HAND_SELECT_ALL = 91 # 0x5b # %SEQ%
PacketNames[PACKET_POKER_HAND_SELECT_ALL] = "POKER_HAND_SELECT_ALL"

class PacketPokerHandSelectAll(PacketString):
    """
Semantics: query the hand history for all players
and filter them according to the "string" boolean expression.
The user must be logged in and have administrative permissions
for this query to succeed.

Direction: server <=  client

Context: the answer of the server to this query is a
 PACKET_POKER_HAND_LIST packet.

string: a valid SQL WHERE expression on the hands table. The
available fields are "name" for the symbolic name of the hand,
"description" for the python expression describing the hand, "serial"
for the unique identifier of the hand also known as the hand_serial
in the PACKET_POKER_START packet.
"""

    type = PACKET_POKER_HAND_SELECT_ALL

PacketFactory[PACKET_POKER_HAND_SELECT_ALL] = PacketPokerHandSelectAll

########################################

PACKET_POKER_USER_INFO = 92 # 0x5c # %SEQ%
PacketNames[PACKET_POKER_USER_INFO] = "POKER_USER_INFO"

class PacketPokerUserInfo(PacketSerial):
    """\
Semantics: read only user descritpive information, complement
of PACKET_POKER_PLAYER_INFO.

Direction: server  => client

Context: answer to the PACKET_POKER_GET_USER_INFO packet.

rating: server wide ELO rating.
serial: integer uniquely identifying a player.
"""

    NOT_LOGGED = 1

    # self.money index constants
    cashier = 0
    in_game = 1

    type = PACKET_POKER_USER_INFO

    info = PacketSerial.info + ( ('rating', 1500, 'I'),
                                 ('affiliate', 0, 'I'),
                                 ('name', 'unknown', 's'),
                                 ('password', '', 's'),
                                 ('email', '', 's'),
                                 ('money', {}, 'money'),
                                 )

    rating = 1500

    format = "!II"
    format_size = calcsize(format)
    format_item = "!IIII"
    format_item_size = calcsize(format_item)

    def __init__(self, *args, **kwargs):
        self.name = kwargs.get("name", "unknown")
        self.password = kwargs.get("password", "")
        self.email = kwargs.get("email", "")
        self.rating = kwargs.get("rating", 1500)
        self.affiliate = int(kwargs.get("affiliate", 0))
        #
        # currency 5, bankroll 200, in_game 3, points 20
        # {5: (200, 3, 20), ...}
        #
        self.money = kwargs.get("money", {})
        PacketSerial.__init__(self, *args, **kwargs)

    def pack(self):
        block = PacketSerial.pack(self) + pack(PacketPokerUserInfo.format, self.rating, self.affiliate) + self.packstring(self.name) + self.packstring(self.password) + self.packstring(self.email)
        block += pack('!H', len(self.money))
        for (currency, (bankroll, in_game, points)) in self.money.iteritems():
            block += pack(PacketPokerUserInfo.format_item, currency, bankroll, in_game, points)
        return block

    def unpack(self, block):
        block = PacketSerial.unpack(self, block)
        (self.rating, self.affiliate) = unpack(PacketPokerUserInfo.format, block[:PacketPokerUserInfo.format_size])
        block = block[PacketPokerUserInfo.format_size:]
        (block, self.name) = self.unpackstring(block)
        (block, self.password) = self.unpackstring(block)
        (block, self.email) = self.unpackstring(block)
        ( length, ) = unpack('!H', block[:calcsize('!H')])
        block = block[calcsize('!H'):]
        self.money = {}
        for i in xrange(length):
            (currency, bankroll, in_game, points) = unpack(PacketPokerUserInfo.format_item, block[:PacketPokerUserInfo.format_item_size])
            block = block[PacketPokerUserInfo.format_item_size:]
            self.money[currency] = (bankroll, in_game, points)
        return block

    def calcsize(self):
        size = PacketSerial.calcsize(self) + PacketPokerUserInfo.format_size + self.calcsizestring(self.name) + self.calcsizestring(self.password) + self.calcsizestring(self.email)
        size += calcsize('!H')
        size += len(self.money) * PacketPokerUserInfo.format_item_size
        return size

    def __str__(self):
        string = PacketSerial.__str__(self) + " name = %s, password = %s, email = %s, rating = %d, affiliate = %d, " % ( self.name, self.password, self.email, self.rating, self.affiliate )
        for (currency, (bankroll, in_game, points)) in self.money.iteritems():
            string += str(currency) + "=" + str(bankroll) + "/" + str(in_game) + "/" + str(points) + " "
        return string

    @staticmethod
    def packmoney(object):
        block = pack('!H', len(object))
        for (currency, money) in object.iteritems():
            fields = (currency,) + money
            block += pack('!IIII', *fields)
        return block

    @staticmethod
    def unpackmoney(block):
        (length,) = unpack('!H', block[:calcsize('!H')])
        block = block[calcsize('!H'):]
        format = '!IIII'
        format_size = calcsize(format)
        object = {}
        for i in xrange(length):
            fields = unpack(format, block[:format_size])
            object[fields[0]] = fields[1:]
            block = block[format_size:]
        return (block, object)

    @staticmethod
    def calcsizemoney(object):
        return calcsize('!H') + len(object) * calcsize('!IIII')

Packet.format_info['money'] = {
    #
    # List of user money status, length of the list as a 2 byte unsigned integer in the range [0-65535]
    # Each money status is a list of 4 unsigned integers
    #  currency
    #  bankroll
    #  in_game
    #  points
    # Example: {} <=> \x00
    #          {5: (2, 3, 4)} <=> \x01\x05\x02\x03\x04
    #          {5: (2, 3, 4), 10: (1, 1, 1)} <=> \x02\x05\x02\x03\x04\x0a\x01\x01\x01
    #
    'pack': PacketPokerUserInfo.packmoney,
    'unpack': PacketPokerUserInfo.unpackmoney,
    'calcsize': PacketPokerUserInfo.calcsizemoney,
    }

PacketFactory[PACKET_POKER_USER_INFO] = PacketPokerUserInfo

########################################

PACKET_POKER_GET_USER_INFO = 93 # 0x5d # %SEQ%
PacketNames[PACKET_POKER_GET_USER_INFO] = "POKER_GET_USER_INFO"

class PacketPokerGetUserInfo(PacketSerial):
    """\
Semantics: request the read only descriptive information
for player "serial".

Direction: server <=  client

Context: a user must first login (PACKET_LOGIN) successfully
before sending this packet.

serial: integer uniquely identifying a player.
"""

    type = PACKET_POKER_GET_USER_INFO

PacketFactory[PACKET_POKER_GET_USER_INFO] = PacketPokerGetUserInfo

########################################

PACKET_POKER_ANTE = 94 # 0x5e # %SEQ%
PacketNames[PACKET_POKER_ANTE] = "POKER_ANTE"

class PacketPokerAnte(PacketPokerInt):
    """\
Semantics: the player "serial" paid an amount of
"amount" for the ante in game "game_id".

Direction: server <=> client

Context: the server always sends a PACKET_POKER_POSITION before
sending this packet. The client may send this packet after
receiving a PACKET_POKER_ANTE_REQUEST.

Note: the amount may be lower than requested by the betting structure
when in tournament. Ring games will refuse a player to enter the with
less than the required amount for blind or/and antes.

amount: amount paid for the ante.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_ANTE

PacketFactory[PACKET_POKER_ANTE] = PacketPokerAnte

########################################

PACKET_POKER_BLIND = 95 # 0x5f # %SEQ%
PacketNames[PACKET_POKER_BLIND] = "POKER_BLIND"

class PacketPokerBlind(PacketPokerInt):
    """\
Semantics: the player "serial" paid an amount of
"amount" for the blind and "dead" for the dead
in game "game_id".

Direction: server <=> client

Context: the server always sends a PACKET_POKER_POSITION before
sending this packet. The client may send this packet after
receiving a PACKET_POKER_BLIND_REQUEST.

Note: the dead and amount fields are ignored in packets sent
to the server. They are calculated by the server according to
the state of the game.

Note: the amount may be lower than requested by the betting structure
when in tournament. Ring games will refuse a player to enter the with
less than the required amount for blind or/and antes.

dead: amount paid for the dead (goes to the pot).
amount: amount paid for the blind (live for the next betting round).
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_BLIND

    info = PacketPokerInt.info + ( ('dead', 0, 'I'), )

    dead = 0
    format = "!I"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.dead = kwargs.get("dead", 0)
        PacketPokerInt.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerInt.pack(self) + pack(PacketPokerBlind.format, self.dead)

    def unpack(self, block):
        block = PacketPokerInt.unpack(self, block)
        (self.dead,) = unpack(PacketPokerBlind.format, block[:PacketPokerBlind.format_size])
        return block[PacketPokerBlind.format_size:]

    def calcsize(self):
        return PacketPokerInt.calcsize(self) + PacketPokerBlind.format_size

    def __str__(self):
        return PacketPokerInt.__str__(self) + " dead = %d" % self.dead

PacketFactory[PACKET_POKER_BLIND] = PacketPokerBlind

########################################

PACKET_POKER_WAIT_BIG_BLIND = 96 # 0x60 # %SEQ%
PacketNames[PACKET_POKER_WAIT_BIG_BLIND] = "POKER_WAIT_BIG_BLIND"

class PacketPokerWaitBigBlind(PacketPokerId):
    """\
Semantics: the player "serial" wants to wait for the big blind
to reach his seat in game "game_id" before entering the game.

Direction: server <=  client

Context: answer to a PACKET_POKER_BLIND_REQUEST. The server
will implicitly sit out the player by not including him in
the PACKET_POKER_IN_GAME packet sent at the end of the "blindAnte"
round. The PACKET_POKER_WAIT_FOR packet is inferred to avoid complex
interpretation of PACKET_POKER_IN_GAME and can be considered
equivalent to a PACKET_POKER_SIT_OUT packet if the distinction is
not important to the client.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_WAIT_BIG_BLIND

PacketFactory[PACKET_POKER_WAIT_BIG_BLIND] = PacketPokerWaitBigBlind

########################################

PACKET_POKER_AUTO_BLIND_ANTE = 97 # 0x61 # %SEQ%
PacketNames[PACKET_POKER_AUTO_BLIND_ANTE] = "POKER_AUTO_BLIND_ANTE"

class PacketPokerAutoBlindAnte(PacketPokerId):
    """\

Semantics: the player "serial" asks the server to automatically post the
           blinds or/and antes for game "game_id".  In response to this
           packet, the server sends PacketPokerAutoBlindAnte() if
           AutoBlindAnte has been successfully turned on, otherwise, it
           sends PacketPokerNoautoBlindAnte().

Direction: server <=  client

Context: by default the server will not automatically post the blinds
or/and antes. 

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_AUTO_BLIND_ANTE

PacketFactory[PACKET_POKER_AUTO_BLIND_ANTE] = PacketPokerAutoBlindAnte

########################################

PACKET_POKER_NOAUTO_BLIND_ANTE = 98 # 0x62 # %SEQ%
PacketNames[PACKET_POKER_NOAUTO_BLIND_ANTE] = "POKER_NOAUTO_BLIND_ANTE"

class PacketPokerNoautoBlindAnte(PacketPokerId):
    """\
Semantics: the player "serial" asks the server to send a
           PACKET_POKER_BLIND_REQUEST or/and PACKET_POKER_ANTE_REQUEST
           when a blind or/and ante for game "game_id" must be paid.

           In response ot this packet, the server sends
           PacketPokerNoautoBlindAnte() if AutoBlindAnte has been
           successfully turned off, otherwise, it sends
           PacketPokerAautoBlindAnte().

Direction: server <=  client

Context: by default the server behaves in this way.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_NOAUTO_BLIND_ANTE

PacketFactory[PACKET_POKER_NOAUTO_BLIND_ANTE] = PacketPokerNoautoBlindAnte

########################################

PACKET_POKER_CANCELED = 99 # 0x63 # %SEQ%
PacketNames[PACKET_POKER_CANCELED] = "POKER_CANCELED"

class PacketPokerCanceled(PacketPokerInt):
    """\
Semantics: the game is canceled because only the player
"serial" is willing to pay the blinds or/and antes.
The "amount" paid by the player is returned to him. If
no player is willing to pay the blinds or/and antes, the
serial is zero.

Direction: server  => client

amount: the amount to return to the player.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_CANCELED

PacketFactory[PACKET_POKER_CANCELED] = PacketPokerCanceled

########################################

PACKET_POKER_BLIND_REQUEST = 100 # 0x64 # %SEQ%
PacketNames[PACKET_POKER_BLIND_REQUEST] = "POKER_BLIND_REQUEST"

class PacketPokerBlindRequest(PacketPokerBlind):
    """\
Semantics: the player "serial" is required to pay the a blind
of "amount" and a dead of "dead" for game "game_id". The logical
state of the blind is given in "state".

Direction: server  => client

Context: a PACKET_POKER_POSITION packet is sent by the server before
this packet. The answer may be a PACKET_POKER_SIT_OUT (to refuse to
pay the blind), PACKET_POKER_BLIND (to pay the blind),
 PACKET_POKER_WAIT_BIG_BLIND (if not willing to pay a late blind but
willing to pay the big blind when due).

state: "small", "big", "late", "big_and_dead".
dead: amount to pay for the dead (goes to the pot).
amount: amount to pay for the blind (live for the next betting round).
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_BLIND_REQUEST

    info = PacketPokerBlind.info + ( ('state', 'unknown', 's'), )
    
    state = "unknown"

    def __init__(self, *args, **kwargs):
        self.state = kwargs.get("state", "unknown")
        PacketPokerBlind.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerBlind.pack(self) + self.packstring(self.state)

    def unpack(self, block):
        block = PacketPokerBlind.unpack(self, block)
        (block, self.state) = self.unpackstring(block)
        return block

    def calcsize(self):
        return PacketPokerBlind.calcsize(self) + self.calcsizestring(self.state)

    def __str__(self):
        return PacketPokerBlind.__str__(self) + " state = %s" % self.state

PacketFactory[PACKET_POKER_BLIND_REQUEST] = PacketPokerBlindRequest

########################################

PACKET_POKER_ANTE_REQUEST = 101 # 0x65 # %SEQ%
PacketNames[PACKET_POKER_ANTE_REQUEST] = "POKER_ANTE_REQUEST"

class PacketPokerAnteRequest(PacketPokerAnte):
    """\
Semantics: the player "serial" is required to pay the an ante
of "amount" for game"game_id".

Direction: server  => client

Context: a PACKET_POKER_POSITION packet is sent by the server before
this packet. The answer may be a PACKET_POKER_SIT_OUT (to refuse to
pay the ante), PACKET_POKER_ANTE (to pay the ante).

amount: amount to pay for the ante.
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_ANTE_REQUEST

PacketFactory[PACKET_POKER_ANTE_REQUEST] = PacketPokerAnteRequest

########################################

PACKET_POKER_AUTO_FOLD = 102 # 0x66 # %SEQ%
PacketNames[PACKET_POKER_AUTO_FOLD] = "POKER_AUTO_FOLD"

class PacketPokerAutoFold(PacketPokerId):
    """\
Semantics: the player "serial" will be folded by the server
when in position for tournament game "game_id".

Direction: server  => client

Context: this packet informs the players at the table about
a change of state for a player in tournament games. This
state can be canceled by a PACKET_POKER_SIT packet for the same
player.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_AUTO_FOLD

PacketFactory[PACKET_POKER_AUTO_FOLD] = PacketPokerAutoFold

########################################

PACKET_POKER_WAIT_FOR = 103 # 0x67 # %SEQ%
PacketNames[PACKET_POKER_WAIT_FOR] = "POKER_WAIT_FOR"

class PacketPokerWaitFor(PacketPokerId):
    """\
Semantics: the player "serial" waits for the late
blind (if "reason" == "late") or the big blind (if
"reason" == "big") in game "game_id". Otherwise equivalent
to PACKET_POKER_SIT_OUT.

Direction: server  => client / client <=> client

Context: when sent by the server, it means that the answer of a client
to a PACKET_POKER_BLIND_REQUEST or a PACKET_POKER_ANTE_REQUEST was to
wait for something (i.e.  PACKET_POKER_WAIT_BIG_BLIND) or that the
server denied him the right to play this hand because he was on the
small blind or on the button. When inferred, this packet can be
handled as if it was a PACKET_POKER_SIT_OUT.

reason: either "big" or "late".
serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_WAIT_FOR

    info = PacketPokerId.info + ( ('reason', '', 's'), )
    
    def __init__(self, *args, **kwargs):
        self.reason = kwargs.get("reason","")
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + self.packstring(self.reason)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (block, self.reason) = self.unpackstring(block)
        return block

    def calcsize(self):
        return PacketPokerId.calcsize(self) + self.calcsizestring(self.reason)

    def __str__(self):
        return PacketPokerId.__str__(self) + " reason = %s" % self.reason

PacketFactory[PACKET_POKER_WAIT_FOR] = PacketPokerWaitFor

########################################

PACKET_POKER_STREAM_MODE = 104 # 0x68 # %SEQ%
PacketNames[PACKET_POKER_STREAM_MODE] = "POKER_STREAM_MODE"

class PacketPokerStreamMode(PacketPokerId):
    """
Semantics: the packets received after this one are
a stream describing poker games changing as time passes.

Direction: server  => client

Context: this is the default mode in which the packets
are to be interpreted by the client. This packet is
only needed after a PACKET_POKER_BATCH_MODE packet was sent,
to come back to the default mode.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_STREAM_MODE

PacketFactory[PACKET_POKER_STREAM_MODE] = PacketPokerStreamMode

########################################

PACKET_POKER_BATCH_MODE = 105 # 0x69 # %SEQ%
PacketNames[PACKET_POKER_BATCH_MODE] = "POKER_BATCH_MODE"

class PacketPokerBatchMode(PacketPokerId):
    """
Semantics: the packets received after this one are
a batch describing a poker game state at a given point
in time.

Direction: server  => client / client <=> client

Context: the server will send this packet before sending
a batch of packets describing the current state of a game,
such as when joining a table. That may involve a long set
of packets describing the whole action of the game until
showdown. The client is free to replay it (in accelerated
mode or as a play back) or to merely use these packets to
rebuild the state of the game. It is produced by the client
when the resendPacket method is called in order to send a
sequence of packets describing a game for which the client
already knows everything (this is handy when switching tables,
for instance).

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_BATCH_MODE

PacketFactory[PACKET_POKER_BATCH_MODE] = PacketPokerBatchMode

########################################

PACKET_POKER_LOOK_CARDS = 106 # 0x6a # %SEQ%
PacketNames[PACKET_POKER_LOOK_CARDS] = "POKER_LOOK_CARDS"

class PacketPokerLookCards(PacketPokerId):
    """\
Semantics: the player "serial" is looking at his cards
in game "game_id".

Direction: server <=> client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_LOOK_CARDS

    info = PacketPokerId.info + ( ('state', 'on', 'no net'), )

    def __init__(self, *args, **kwargs):
        self.state = kwargs.get("state","on")
        PacketPokerId.__init__(self, *args, **kwargs)

PacketFactory[PACKET_POKER_LOOK_CARDS] = PacketPokerLookCards

########################################

PACKET_POKER_TABLE_REQUEST_PLAYERS_LIST = 107 # 0x6b # %SEQ%
PacketNames[PACKET_POKER_TABLE_REQUEST_PLAYERS_LIST] = "POKER_TABLE_REQUEST_PLAYERS_LIST"

class PacketPokerTableRequestPlayersList(PacketPokerId):
    """\
Semantics: client request the player list of the game "game_id".

Direction: server <= client

game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_TABLE_REQUEST_PLAYERS_LIST

PacketFactory[PACKET_POKER_TABLE_REQUEST_PLAYERS_LIST] = PacketPokerTableRequestPlayersList

########################################

PACKET_POKER_PLAYERS_LIST = 108 # 0x6c # %SEQ%
PacketNames[PACKET_POKER_PLAYERS_LIST] = "POKER_PLAYERS_LIST"

class PacketPokerPlayersList(PacketPokerId):
    """
Semantics: List of players participating in "game_id". 

Direction: server => client

game_id: integer uniquely identifying a game.
players: list of player serials participating in "game_id"
 for each player, a list of two numbers:
     name: name of the player
     chips: integer player chips in cent
     flag: byte 0
    """

    format = "!H"
    format_size = calcsize(format)
    format_item = "!IB"
    format_item_size = calcsize(format_item)

    type = PACKET_POKER_PLAYERS_LIST

    info = PacketPokerId.info + ( ('players', [], 'players'), )

    def __init__(self, *args, **kwargs):
        PacketPokerId.__init__(self, *args, **kwargs)
        self.players = kwargs.get("players", [])

    def pack(self):
        block = PacketPokerId.pack(self) + pack(PacketPokerPlayersList.format, len(self.players))
        for (name, chips, flag) in self.players:
            block += self.packstring(name) + pack(PacketPokerPlayersList.format_item, chips, flag)
        return block

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (length,) = unpack(PacketPokerPlayersList.format, block[:PacketPokerPlayersList.format_size])
        block = block[PacketPokerPlayersList.format_size:]
        self.players = []
        for i in xrange(length):
            (block, name) = self.unpackstring(block)
            (chips, flag) = unpack(PacketPokerPlayersList.format_item, block[:PacketPokerPlayersList.format_item_size])
            block = block[PacketPokerPlayersList.format_item_size:]
            self.players.append((name, chips, flag))
        return block

    def calcsize(self):
        size = PacketPokerId.calcsize(self) + PacketPokerPlayersList.format_size
        for (name, chips, flag) in self.players:
            size += self.calcsizestring(name) + PacketPokerPlayersList.format_item_size
        return size

    def __str__(self):
        string = PacketPokerId.__str__(self) + " player|chips|flag : "
        for (name, chips, flag) in self.players:
            string += " %s|%d|%d " % ( name, chips, flag )
        return string

    @staticmethod
    def packplayers(object):
        block = pack('!H', len(object))
        for (name, chips, flags) in object:
            block += Packet.packstring(name)
            block += pack('!IB', chips, flags)
        return block

    @staticmethod
    def unpackplayers(block):
        (length,) = unpack('!H', block[:calcsize('!H')])
        block = block[calcsize('!H'):]
        format = '!IB'
        format_size = calcsize(format)
        object = []
        for i in xrange(length):
            (block, name) = Packet.unpackstring(block)
            (chips, flags) = unpack(format, block[:format_size])
            object.append((name, chips, flags))
            block = block[format_size:]
        return (block, object)

    @staticmethod
    def calcsizeplayers(object):
        size = calcsize('!H')
        for (name, chips, flags) in object:
            size += Packet.calcsizestring(name) + calcsize('!IB')
        return size

Packet.format_info['players'] = {
    'pack': PacketPokerPlayersList.packplayers,
    'unpack': PacketPokerPlayersList.unpackplayers,
    'calcsize': PacketPokerPlayersList.calcsizeplayers,
    }

PacketFactory[PACKET_POKER_PLAYERS_LIST] = PacketPokerPlayersList

########################################

PACKET_POKER_PERSONAL_INFO = 109 # 0x6d # %SEQ%
PacketNames[PACKET_POKER_PERSONAL_INFO] = "POKER_PERSONAL_INFO"

class PacketPokerPersonalInfo(PacketPokerUserInfo):
    """\
"""

    NOT_LOGGED = 1

    type = PACKET_POKER_PERSONAL_INFO

    info = PacketPokerUserInfo.info + ( ('firstname', '', 's'),
                                        ('lastname', '', 's'),
                                        ('addr_street', '', 's'),
                                        ('addr_street2', '', 's'),
                                        ('addr_zip', '', 's'),
                                        ('addr_town', '', 's'),
                                        ('addr_state', '', 's'),
                                        ('addr_country', '', 's'),
                                        ('phone', '', 's'),
                                        ('gender', '', 's'),
                                        ('birthdate', '', 's'),
                                        )
    
    def __init__(self, *args, **kwargs):
        self.firstname = kwargs.get("firstname", "")
        self.lastname = kwargs.get("lastname", "")
        self.addr_street = kwargs.get("addr_street", "")
        self.addr_street2 = kwargs.get("addr_street2", "")
        self.addr_zip = kwargs.get("addr_zip", "")
        self.addr_town = kwargs.get("addr_town", "")
        self.addr_state = kwargs.get("addr_state", "")
        self.addr_country = kwargs.get("addr_country", "")
        self.phone = kwargs.get("phone", "")
        self.gender = kwargs.get("gender", "")
        self.birthdate = str(kwargs.get("birthdate", ""))
        PacketPokerUserInfo.__init__(self, *args, **kwargs)

    def pack(self):
        packet = PacketPokerUserInfo.pack(self)
        packet += self.packstring(self.firstname)
        packet += self.packstring(self.lastname)
        packet += self.packstring(self.addr_street)
        packet += self.packstring(self.addr_street2)
        packet += self.packstring(self.addr_zip)
        packet += self.packstring(self.addr_town)
        packet += self.packstring(self.addr_state)
        packet += self.packstring(self.addr_country)
        packet += self.packstring(self.phone)
        packet += self.packstring(self.gender)
        packet += self.packstring(self.birthdate)
        return packet

    def unpack(self, block):
        block = PacketPokerUserInfo.unpack(self, block)
        (block, self.firstname) = self.unpackstring(block)
        (block, self.lastname) = self.unpackstring(block)
        (block, self.addr_street) = self.unpackstring(block)
        (block, self.addr_street2) = self.unpackstring(block)
        (block, self.addr_zip) = self.unpackstring(block)
        (block, self.addr_town) = self.unpackstring(block)
        (block, self.addr_state) = self.unpackstring(block)
        (block, self.addr_country) = self.unpackstring(block)
        (block, self.phone) = self.unpackstring(block)
        (block, self.gender) = self.unpackstring(block)
        (block, self.birthdate) = self.unpackstring(block)
        return block

    def calcsize(self):
        return ( PacketPokerUserInfo.calcsize(self) +
                 self.calcsizestring(self.firstname) +
                 self.calcsizestring(self.lastname) +
                 self.calcsizestring(self.addr_street) +
                 self.calcsizestring(self.addr_street2) +
                 self.calcsizestring(self.addr_zip) +
                 self.calcsizestring(self.addr_town) +
                 self.calcsizestring(self.addr_state) +
                 self.calcsizestring(self.addr_country) +
                 self.calcsizestring(self.phone) +
                 self.calcsizestring(self.gender) +
                 self.calcsizestring(str(self.birthdate))
                 )

    def __str__(self):
        return PacketPokerUserInfo.__str__(self) + " firstname = %s, lastname = %s, addr_street = %s, addr_street2 = %s, addr_zip = %s, addr_town = %s, addr_state = %s, addr_country = %s, phone = %s, gender = %s, birthdate = %s" % ( self.firstname, self.lastname, self.addr_street, self.addr_street2, self.addr_zip, self.addr_town, self.addr_state, self.addr_country, self.phone, self.gender, self.birthdate )

PacketFactory[PACKET_POKER_PERSONAL_INFO] = PacketPokerPersonalInfo

########################################

PACKET_POKER_GET_PERSONAL_INFO = 110 # 0x6e # %SEQ%
PacketNames[PACKET_POKER_GET_PERSONAL_INFO] = "POKER_GET_PERSONAL_INFO"

class PacketPokerGetPersonalInfo(PacketSerial):
    """\
Semantics: request the read only descriptive information
for player "serial".

Direction: server <=  client

Context: a personal must first login (PACKET_LOGIN) successfully
before sending this packet.

serial: integer uniquely identifying a player.
"""

    NOT_LOGGED = 1

    type = PACKET_POKER_GET_PERSONAL_INFO

PacketFactory[PACKET_POKER_GET_PERSONAL_INFO] = PacketPokerGetPersonalInfo

########################################
PACKET_POKER_TOURNEY_SELECT = 111 # 0x6f # %SEQ%
PacketNames[PACKET_POKER_TOURNEY_SELECT] = "POKER_TOURNEY_SELECT"

class PacketPokerTourneySelect(PacketString):
    """\
Semantics: request the list of tourneys matching the "string" constraint.
The answer is a PACKET_POKER_TOURNEY_LIST packet. If no tournament matches
the constraint, the list will be empty.

Direction: server <=  client

string: 1) empty string selects all tournaments
        2) a string that contains no tabulation selects
           the tournament with the same name
        3) a string with a tabulation selects all tournaments
           of a given type (sit&go or regular) that can be played
           using a given currency. The string before the tabulation
           is the name of the currency, the string after the tabulation
           distinguishes between sit&go and regular.

        Examples: 1<tabulation>sit_n_go selects all sit&go tournaments
                  using currency 1.
                  2<tabulation>regular selects all regular tournaments
                  using currency 2
"""

    type = PACKET_POKER_TOURNEY_SELECT

PacketFactory[PACKET_POKER_TOURNEY_SELECT] = PacketPokerTourneySelect

########################################
PACKET_POKER_TOURNEY = 112 # 0x70 # %SEQ%
PacketNames[PACKET_POKER_TOURNEY] = "POKER_TOURNEY"

class PacketPokerTourney(Packet):

    type = PACKET_POKER_TOURNEY

    info = Packet.info + ( ('serial', 0, 'I'),
                           ('schedule_serial', 0, 'no net'),
                           ('buy_in', 10, 'I'),
                           ('start_time', 0, 'I'),
                           ('sit_n_go', 'y', 'cbool'),
                           ('players_quota', 0, 'H'),
                           ('registered', 0, 'H'),
                           ('currency_serial', 0, 'I'),
                           ('breaks_first', 0, 'H'),
                           ('breaks_interval', 0, 'H'),
                           ('breaks_duration', 0, 'H'),
                           ('description_short', 'nodescription_short', 's'),
                           ('variant', 'holdem', 's'),
                           ('state', 'announced', 's'),
                           ('name', 'noname', 's'),
                           )
    
    format = "!IIIBHHIHHH"
    format_size = calcsize(format)

    def __init__(self, **kwargs):
        self.name = kwargs.get("name", "noname")
        self.description_short = kwargs.get("description_short", "nodescription_short")
        self.variant = kwargs.get("variant", "holdem")
        self.state = kwargs.get("state", "announced")
        self.serial = kwargs.get("serial", 0)
        self.schedule_serial = kwargs.get("schedule_serial", 0)
        self.buy_in = kwargs.get("buy_in", 10)
        self.start_time = int(kwargs.get("start_time", 0))
        self.sit_n_go = kwargs.get("sit_n_go", 'y')
        self.players_quota = kwargs.get("players_quota", 0)
        self.registered = kwargs.get("registered", 0)
        self.currency_serial = kwargs.get("currency_serial", 0)
        self.breaks_first = kwargs.get("breaks_first", 0)
        self.breaks_interval = kwargs.get("breaks_interval", 0)
        self.breaks_duration = kwargs.get("breaks_duration", 0)

    def pack(self):
        block = Packet.pack(self)
        block += pack(PacketPokerTourney.format, self.serial, self.buy_in, self.start_time, (self.sit_n_go == 'y' and 1 or 0), self.players_quota, self.registered, self.currency_serial, self.breaks_first, self.breaks_interval, self.breaks_duration)
        block += self.packstring(self.description_short)
        block += self.packstring(self.variant)
        block += self.packstring(self.state)
        block += self.packstring(self.name)
        return block

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (self.serial, self.buy_in, self.start_time, self.sit_n_go, self.players_quota, self.registered, self.currency_serial, self.breaks_first, self.breaks_interval, self.breaks_duration) = unpack(PacketPokerTourney.format, block[:PacketPokerTourney.format_size])
        self.sit_n_go = self.sit_n_go and 'y' or 'n'
        block = block[PacketPokerTourney.format_size:]
        (block, self.description_short) = self.unpackstring(block)
        (block, self.variant) = self.unpackstring(block)
        (block, self.state) = self.unpackstring(block)
        (block, self.name) = self.unpackstring(block)
        return block

    def calcsize(self):
        return Packet.calcsize(self) + PacketPokerTourney.format_size + self.calcsizestring(self.description_short) + self.calcsizestring(self.variant) + self.calcsizestring(self.state) + self.calcsizestring(self.name)

    def __str__(self):
        return Packet.__str__(self) + "\n\tserial = %s, schedule_serial = %s, name = %s, description_short = %s, variant = %s, state = %s, buy_in = %s, start_time = %s, sit_n_go = %s, players_quota = %s, registered = %s, currency_serial = %d, breaks_first = %d, breaks_interval = %d, breaks_duration = %d " % ( self.serial, self.schedule_serial, self.name, self.description_short, self.variant, self.state, self.buy_in, strftime("%Y/%m/%d %H:%M", gmtime(self.start_time)), self.sit_n_go, self.players_quota, self.registered, self.currency_serial, self.breaks_first, self.breaks_interval, self.breaks_duration )

PacketFactory[PACKET_POKER_TOURNEY] = PacketPokerTourney

########################################

PACKET_POKER_TOURNEY_INFO = 113 # 0x71 # %SEQ%
PacketNames[PACKET_POKER_TOURNEY_INFO] = "POKER_TOURNEY_INFO"

class PacketPokerTourneyInfo(PacketPokerTourney):

    type = PACKET_POKER_TOURNEY_INFO

    info = PacketPokerTourney.info + ( ('description_long', 'no long description', 's'), )

    reason = ""

    def __init__(self, *args, **kwargs):
        self.description_long = kwargs.get("description_long", "no long description")
        PacketPokerTourney.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerTourney.pack(self) + self.packstring(self.description_long)

    def unpack(self, block):
        block = PacketPokerTourney.unpack(self, block)
        (block, self.description_long) = self.unpackstring(block)
        return block

    def calcsize(self):
        return PacketPokerTourney.calcsize(self) + self.calcsizestring(self.description_long)

    def __str__(self):
        return PacketPokerTourney.__str__(self) + " description_long = %s" % self.description_long

PacketFactory[PACKET_POKER_TOURNEY_INFO] = PacketPokerTourneyInfo

########################################

PACKET_POKER_TOURNEY_LIST = 114 # 0x72 # %SEQ%
PacketNames[PACKET_POKER_TOURNEY_LIST] = "POKER_TOURNEY_LIST"

class PacketPokerTourneyList(PacketList):
    """\
Semantics: a list of PACKET_POKER_TOURNEY packets sent as a
response to a PACKET_POKER_SELECT request.

Direction: server  => client

packets: a list of PACKET_POKER_TOURNEY packets.
"""

    type = PACKET_POKER_TOURNEY_LIST

    info = PacketList.info + ( ('players', 0, 'I'),
                               ('tourneys', 0, 'I') )

    format = "!II"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.players = kwargs.get("players", 0)
        self.tourneys = kwargs.get("tourneys", 0)
        PacketList.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketList.pack(self) + pack(PacketPokerTourneyList.format, self.players, self.tourneys)

    def unpack(self, block):
        block = PacketList.unpack(self, block)
        (self.players, self.tourneys) = unpack(PacketPokerTourneyList.format, block[:PacketPokerTourneyList.format_size])
        return block[PacketPokerTourneyList.format_size:]

    def calcsize(self):
        return PacketList.calcsize(self) + PacketPokerTourneyList.format_size

    def __str__(self):
        return PacketList.__str__(self) + "\n\tplayers = %d, tourneys = %d" % ( self.players, self.tourneys )

PacketFactory[PACKET_POKER_TOURNEY_LIST] = PacketPokerTourneyList

########################################

PACKET_POKER_TOURNEY_REQUEST_PLAYERS_LIST = 115 # 0x73 # %SEQ%
PacketNames[PACKET_POKER_TOURNEY_REQUEST_PLAYERS_LIST] = "POKER_TOURNEY_REQUEST_PLAYERS_LIST"

class PacketPokerTourneyRequestPlayersList(PacketPokerId):
    """\
Semantics: client request the player list of the tourney "game_id".

Direction: server <= client

Context: If the tournament "game_id" is among the list of known tournamens,
a PacketPokerTourneyPlayersList is returned by the server. Otherwise,
a PacketError is returned with the code set to
PacketPokerTourneyRegister.DOES_NOT_EXIST.

game_id: integer uniquely identifying a tournament.
"""

    type = PACKET_POKER_TOURNEY_REQUEST_PLAYERS_LIST

PacketFactory[PACKET_POKER_TOURNEY_REQUEST_PLAYERS_LIST] = PacketPokerTourneyRequestPlayersList

########################################

PACKET_POKER_TOURNEY_REGISTER = 116 # 0x74 # %SEQ%
PacketNames[PACKET_POKER_TOURNEY_REGISTER] = "POKER_TOURNEY_REGISTER"

class PacketPokerTourneyRegister(PacketPokerId):
    """\
Semantics: register player "serial" to tournament "game_id".

Direction: server <= client

If the player is registered successfully, the server will send
back the packet to the client.

If an error occurs during the tournament registration, the server
will send back

  PacketError(other_type = PACKET_POKER_TOURNEY_REGISTER)

with the "code" field name set as follows:

DOES_NOT_EXIST : the "game_id" field does not match any existing
                 tournaments.
ALREADY_REGISTERED : the "serial" player is already listed as
                 a registered player in the "game_id" tournament.
REGISTRATION_REFUSED : the "serial" player registration was refused
                 because the "game_id" tournament is no longer in
                 the registration phase or because the players
                 quota was exceeded.
NOT_ENOUGH_MONEY : the "serial" player does not have enough money
                 to pay the "game_id" tournament.
SERVER_ERROR : the server failed to register the player because the
               database is inconsistent.
VIA_SATELLITE : registration is only allowed by playing a satellite

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a tournament.
"""
    DOES_NOT_EXIST = 1
    ALREADY_REGISTERED = 2
    REGISTRATION_REFUSED = 3
    NOT_ENOUGH_MONEY = 4
    SERVER_ERROR = 5
    VIA_SATELLITE = 6

    type = PACKET_POKER_TOURNEY_REGISTER

PacketFactory[PACKET_POKER_TOURNEY_REGISTER] = PacketPokerTourneyRegister

########################################

PACKET_POKER_TOURNEY_UNREGISTER = 117 # 0x75 # %SEQ%
PacketNames[PACKET_POKER_TOURNEY_UNREGISTER] = "POKER_TOURNEY_UNREGISTER"

class PacketPokerTourneyUnregister(PacketPokerId):
    """\
Semantics: unregister player "serial" from tournament "game_id".

Direction: server <= client

If the player is successfully unregistered, the server will send
back the packet to the client.

If an error occurs during the tournament registration, the server
will send back

  PacketError(other_type = PACKET_POKER_TOURNEY_UNREGISTER)

with the "code" field name set as follows:

DOES_NOT_EXIST : the "game_id" field does not match any existing
                 tournaments.
NOT_REGISTERED : the "serial" player is not listed as
                 a registered player in the "game_id" tournament.
TOO_LATE : the "serial" player cannot unregister from the tournament
           because it already started.
SERVER_ERROR : the server failed to unregister the player because the
               database is inconsistent.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a tournament.
"""

    DOES_NOT_EXIST = 1
    NOT_REGISTERED = 2
    TOO_LATE = 3
    SERVER_ERROR = 4

    type = PACKET_POKER_TOURNEY_UNREGISTER

PacketFactory[PACKET_POKER_TOURNEY_UNREGISTER] = PacketPokerTourneyUnregister

########################################

PACKET_POKER_TOURNEY_PLAYERS_LIST = 118 # 0x76 # %SEQ%
PacketNames[PACKET_POKER_TOURNEY_PLAYERS_LIST] = "POKER_TOURNEY_PLAYERS_LIST"

class PacketPokerTourneyPlayersList(PacketPokerPlayersList):
    """
Semantics: List of players participating in tourney "serial". 

Direction: server => client

serial: integer uniquely identifying a tourney.
players: list of player serials participating in "game_id"
 for each player, a list of two numbers:
     name: name of the player
     chips: integer -1
     flag: byte 0
    """

    type = PACKET_POKER_TOURNEY_PLAYERS_LIST

PacketFactory[PACKET_POKER_TOURNEY_PLAYERS_LIST] = PacketPokerTourneyPlayersList

########################################

PACKET_POKER_HAND_HISTORY = 119 # 0x77 # %SEQ%
PacketNames[PACKET_POKER_HAND_HISTORY] = "POKER_HAND_HISTORY"

class PacketPokerHandHistory(PacketPokerId):

    type = PACKET_POKER_HAND_HISTORY

    info = PacketPokerId.info + ( ('history', '', 's'),
                                  ('serial2name', '', 's'),
                                  )

    NOT_FOUND = 1
    FORBIDDEN = 2

    def __init__(self, *args, **kwargs):
        self.history = kwargs.get("history", "")
        self.serial2name = kwargs.get("serial2name", "")
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + self.packstring(self.history) + self.packstring(self.serial2name)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (block, self.history) = self.unpackstring(block)
        (block, self.serial2name) = self.unpackstring(block)
        return block

    def calcsize(self):
        return PacketPokerId.calcsize(self) + self.calcsizestring(self.history) + self.calcsizestring(self.serial2name)

    def __str__(self):
        return PacketPokerId.__str__(self) + " history = %s, serial2name = %s" % ( self.history, self.serial2name )

PacketFactory[PACKET_POKER_HAND_HISTORY] = PacketPokerHandHistory

########################################

PACKET_POKER_SET_ACCOUNT = 120 # 0x78 # %SEQ%
PacketNames[PACKET_POKER_SET_ACCOUNT] = "POKER_SET_ACCOUNT"

class PacketPokerSetAccount(PacketPokerPersonalInfo):

    NAME_TOO_SHORT = 1
    NAME_TOO_LONG = 2
    NAME_MUST_START_WITH_LETTER = 3
    NAME_NOT_ALNUM = 4
    PASSWORD_TOO_SHORT = 5
    PASSWORD_TOO_LONG = 6
    PASSWORD_NOT_ALNUM = 7
    INVALID_EMAIL = 8
    NAME_ALREADY_EXISTS = 9
    EMAIL_ALREADY_EXISTS = 10
    SERVER_ERROR = 11

    type = PACKET_POKER_SET_ACCOUNT

PacketFactory[PACKET_POKER_SET_ACCOUNT] = PacketPokerSetAccount

########################################

PACKET_POKER_CREATE_ACCOUNT = 121 # 0x79 # %SEQ%
PacketNames[PACKET_POKER_CREATE_ACCOUNT] = "POKER_CREATE_ACCOUNT"

class PacketPokerCreateAccount(PacketPokerSetAccount):

    type = PACKET_POKER_CREATE_ACCOUNT

PacketFactory[PACKET_POKER_CREATE_ACCOUNT] = PacketPokerCreateAccount

########################################

PACKET_POKER_PLAYER_SELF = 122 # 0x7a # %SEQ%
PacketNames[PACKET_POKER_PLAYER_SELF] = "POKER_PLAYER_SELF"

class PacketPokerPlayerSelf(PacketPokerId):
    type = PACKET_POKER_PLAYER_SELF

    def __init__(self, *args, **kwargs):
        PacketPokerId.__init__(self, *args, **kwargs)

PacketFactory[PACKET_POKER_PLAYER_SELF] = PacketPokerPlayerSelf

########################################

PACKET_POKER_GET_PLAYER_INFO = 123 # 0x7b # %SEQ%
PacketNames[PACKET_POKER_GET_PLAYER_INFO] = "POKER_GET_PLAYER_INFO"

class PacketPokerGetPlayerInfo(Packet):
    """
Semantics: ask the server for a PacketPokerPlayerInfo packet
describing the player that is logged in with this connection.

If the user is not logged in the following packet is returned

PacketError(code = PacketPokerGetPlayerInfo.NOT_LOGGED,
            message = "Not logged in",
            other_type = PACKET_POKER_GET_PLAYER_INFO)

If the user is logged in a PacketPokerPlayerInfo packet is sent
to the client.

Direction: server <= client
"""

    NOT_LOGGED = 1

    type = PACKET_POKER_GET_PLAYER_INFO

PacketFactory[PACKET_POKER_GET_PLAYER_INFO] = PacketPokerGetPlayerInfo

########################################

PACKET_POKER_ROLES = 124 # 0x7c # %SEQ%
PacketNames[PACKET_POKER_ROLES] = "POKER_ROLES"

class PacketPokerRoles(PacketSerial):

    PLAY = "PLAY"
    EDIT = "EDIT"
    ROLES = [ PLAY, EDIT ]

    type = PACKET_POKER_ROLES

    info = PacketSerial.info + ( ('roles', '', 's'), )

    def __init__(self, *args, **kwargs):
        self.roles = kwargs.get("roles","")
        PacketSerial.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketSerial.pack(self) + self.packstring(self.roles)

    def unpack(self, block):
        block = PacketSerial.unpack(self, block)
        (block, self.roles) = self.unpackstring(block)
        return block

    def calcsize(self):
        return PacketSerial.calcsize(self) + self.calcsizestring(self.roles)

    def __str__(self):
        return PacketSerial.__str__(self) + " roles = %s" % self.roles

PacketFactory[PACKET_POKER_ROLES] = PacketPokerRoles

########################################

PACKET_POKER_SET_ROLE = 125 # 0x7d # %SEQ%
PacketNames[PACKET_POKER_SET_ROLE] = "POKER_SET_ROLE"

class PacketPokerSetRole(PacketPokerRoles):
    """
Semantics: tell the server the purpose of the connection.
There are two possible roles : PLAY for a regular client
that plays poker, EDIT for a connection used to edit the
player properties but not play. There can only be one
active role per user at a given time.

The user must not be not logged in when this packet is
sent or undefined results will occur.

Direction: server <= client

roles: string PLAY or EDIT
"""

    UNKNOWN_ROLE = 1
    NOT_AVAILABLE = 2

    type = PACKET_POKER_SET_ROLE

PacketFactory[PACKET_POKER_SET_ROLE] = PacketPokerSetRole

########################################

PACKET_POKER_READY_TO_PLAY = 126 # 0x7e # %SEQ%
PacketNames[PACKET_POKER_READY_TO_PLAY] = "POKER_READY_TO_PLAY"

class PacketPokerReadyToPlay(PacketPokerId):
    """\
Semantics: the "serial" player is ready to begin a new
hand at table "game_id".

Direction: server <= client

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    type = PACKET_POKER_READY_TO_PLAY

PacketFactory[PACKET_POKER_READY_TO_PLAY] = PacketPokerReadyToPlay

########################################

PACKET_POKER_PROCESSING_HAND = 127 # 0x7f # %SEQ%
PacketNames[PACKET_POKER_PROCESSING_HAND] = "POKER_PROCESSING_HAND"

class PacketPokerProcessingHand(PacketPokerId):
    """\
Semantics: the "serial" player is not ready to begin a new
hand at table "game_id" because the client is still processing
the data related to the previous hand.

Direction: server <= client

Context: should be sent by the client immediately after receiving
the POKER_START packet.

Note: the packet is ignored if the "serial" player is not at the table.

Note: because of a race condition, it will not work as expected
if the game plays too fast. For instance, if the hand finishes
before the packet POKER_PROCESSING_HAND is received by the server.
This will typically happen the first time a player gets a seat at the 
table.

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game.
"""

    BUGOUS = 0

    type = PACKET_POKER_PROCESSING_HAND

PacketFactory[PACKET_POKER_PROCESSING_HAND] = PacketPokerProcessingHand

########################################

PACKET_POKER_MUCK_REQUEST = 128 # 0x80 # %SEQ%
PacketNames[PACKET_POKER_MUCK_REQUEST] = "POKER_MUCK_REQUEST"

class PacketPokerMuckRequest(PacketPokerId):
    """\
Semantics: server is announcing a muck request to muckable players
in game "game_id". The packet is sent to all players at the table.
If a player in the list does not respond in time (the actual timeout
value depends on the server configuration and is usualy 5 seconds),
her hand will be mucked.

Direction: server <=> client
game_id: integer uniquely identifying a game.
muckable_serials: list of serials of players that are given a the choice to muck.
    """
    type = PACKET_POKER_MUCK_REQUEST

    info = PacketPokerId.info + ( ('muckable_serials', [], 'Il'), )
    
    format_element = "!I"

    def __init__(self, *args, **kwargs):
        self.muckable_serials = kwargs.get("muckable_serials", [])
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        block = PacketPokerId.pack(self)
        block += self.packlist(self.muckable_serials, PacketPokerMuckRequest.format_element)
        return block

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (block, self.muckable_serials) = self.unpacklist(block, PacketPokerMuckRequest.format_element)
        return block

    def calcsize(self):
        return PacketPokerId.calcsize(self) + self.calcsizelist(self.muckable_serials, PacketPokerMuckRequest.format_element)

    def __str__(self):
        return PacketPokerId.__str__(self) + " muckable_serials = " + str(self.muckable_serials)

PacketFactory[PACKET_POKER_MUCK_REQUEST] = PacketPokerMuckRequest

########################################

PACKET_POKER_AUTO_MUCK = 129 # 0x81 # %SEQ%
PacketNames[PACKET_POKER_AUTO_MUCK] = "POKER_AUTO_MUCK"

class PacketPokerAutoMuck(PacketPokerId):
    """\
Semantics: By default the client will not be proposed to muck : the
server will always muck for him.
The client may send the PacketPokerAutoMuck to inform the server of its
muck preferences for "game_id". The "info" field must be set to one
of the following:

AUTO_MUCK_NEVER  0x00
AUTO_MUCK_WIN    0x01
AUTO_MUCK_LOSE   0x02
AUTO_MUCK_ALWAYS AUTO_MUCK_WIN + AUTO_MUCK_LOSE

When "info" is set to AUTO_MUCK_NEVER, the server will always send
a PacketPokerMuckRequest including the serial of the player for
this "game_id" when mucking is an option. If "info" is set to
AUTO_MUCK_WIN the server will
not include the serial of the player in the PacketPokerMuckRequest packet
for this "game_id" if the player wins but is not forced to
how its cards (i.e. when the opponent folded to him).
If "info" is set to AUTO_MUCK_LOSE the server will not include the serial
of the player in the PacketPokerMuckRequest packet for this "game_id"
when the player loses the hand but is not forced to show his cards.
AUTO_MUCK_ALWAYS is the equivalent of requesting AUTO_MUCK_LOSE and
AUTO_MUCK_WIN at the same time and is the default.

Direction: server <= client
game_id: integer uniquely identifying a game.
info: bitfield indicating what muck situations are of interest.
    """

    type = PACKET_POKER_AUTO_MUCK

    info = PacketPokerId.info + ( ('auto_muck', 0xFF, 'B'), )

    format = "!B"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.auto_muck = kwargs.get("auto_muck", 0xFF)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + pack(PacketPokerAutoMuck.format, self.auto_muck)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.auto_muck,) = unpack(PacketPokerAutoMuck.format, block[:PacketPokerAutoMuck.format_size])
        return block[PacketPokerAutoMuck.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerAutoMuck.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + " auto_muck = %x" % self.auto_muck

PacketFactory[PACKET_POKER_AUTO_MUCK] = PacketPokerAutoMuck

########################################

PACKET_POKER_MUCK_ACCEPT = 130 # 0x82 # %SEQ%
PacketNames[PACKET_POKER_MUCK_ACCEPT] = "POKER_MUCK_ACCEPT"

class PacketPokerMuckAccept(PacketPokerId):
    type = PACKET_POKER_MUCK_ACCEPT

PacketFactory[PACKET_POKER_MUCK_ACCEPT] = PacketPokerMuckAccept

########################################

PACKET_POKER_MUCK_DENY = 131 # 0x83 # %SEQ%
PacketNames[PACKET_POKER_MUCK_DENY] = "POKER_MUCK_DENY"

class PacketPokerMuckDeny(PacketPokerId):
    type = PACKET_POKER_MUCK_DENY

PacketFactory[PACKET_POKER_MUCK_DENY] = PacketPokerMuckDeny

########################################

class PacketPokerMoneyTransfert(PacketSerial):

    info = PacketSerial.info + ( ('url', 'UNKNOWN', 's'),
                                 ('name', 'UNKNOWN', 's'),
                                 ('application_data', '', 's'),
                                 ('bserial', 0, 'I'),
                                 ('value', 0, 'I'),
                                 )

    format = "!II"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.url = kwargs.get("url", "UNKNOWN")
        self.name = kwargs.get("name", "UNKNOWN")
        self.application_data = kwargs.get("application_data", '')
        self.bserial = int(kwargs.get("bserial", 0))
        self.value = int(kwargs.get("value", 0))
        if kwargs.has_key('note'):
            note = kwargs['note']
            self.url = note[0]
            self.bserial = int(note[1])
            self.name = note[2]
            self.value = int(note[3])
        PacketSerial.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketSerial.pack(self) + self.packstring(self.url) + self.packstring(self.name) + self.packstring(self.application_data) + pack(PacketPokerMoneyTransfert.format, self.bserial, self.value)

    def unpack(self, block):
        block = PacketSerial.unpack(self, block)
        (block, self.url) = self.unpackstring(block)
        (block, self.name) = self.unpackstring(block)
        (block, self.application_data) = self.unpackstring(block)
        (self.bserial, self.value) = unpack(PacketPokerMoneyTransfert.format, block[:PacketPokerMoneyTransfert.format_size])
        return block[PacketPokerMoneyTransfert.format_size:]

    def calcsize(self):
        return PacketSerial.calcsize(self) + self.calcsizestring(self.url) + self.calcsizestring(self.name) + self.calcsizestring(self.application_data) + PacketPokerMoneyTransfert.format_size

    def __str__(self):
        return PacketSerial.__str__(self) + ", url = %s, name = %s, bserial = %d, value = %d, application_data = %s" % (self.url, self.name, self.bserial, self.value, self.application_data )


########################################

PACKET_POKER_CASH_IN = 132 # 0x84 # %SEQ%
PacketNames[PACKET_POKER_CASH_IN] = "POKER_CASH_IN"

class PacketPokerCashIn(PacketPokerMoneyTransfert):
    """\
Semantics: add "value" cents of currency "url" to the
"serial" player account using the "name"/"bserial" note.

Context: If the CASH_IN is successfull, PacketAck is returned.
Otherwise PacketError is returned with the "message" field set
to a human readable error explanation. The poker server must
be able to check the validity of the note provided
by accessing the currency server at "url".

The url, bserial, name, value fields content are filled from
the result of a request to a currency web service. For instance:

http://localhost/poker-web/currency_one.php?command=get_note&value=100&autocommit=yes

will return the following content

http://localhost/poker-web/currency_one.php     22      cfae906e9d7d6f6321b04d659059f4d6f8b86a34      100

that can be used to build a packet by setting:

url = http://localhost/poker-web/currency_one.php
bserial = 22
name = cfae906e9d7d6f6321b04d659059f4d6f8b86a34
value = 100

When the poker server honors the PacketPokerCashIn packet, it will
contact the currency server to change the note. It means the note sent
will become invalid and be replaced by a new one, known only to the
poker server.

Direction: server <= client

value: integer value of the note in cent
currency: url string of the currency server
bserial: integer value of the serial of the note
name: string cryptographic name of the note
note: tuple of (url, bserial, name, value) that overrides the parameters
      of the same name
serial: integer uniquely identifying a player.
"""
    type = PACKET_POKER_CASH_IN

    DUPLICATE_CURRENCIES	= 1
    REFUSED			= 2
    SAFE			= 3
    UNKNOWN			= 4
    RETRY			= 5

PacketFactory[PACKET_POKER_CASH_IN] = PacketPokerCashIn

########################################

PACKET_POKER_CASH_OUT = 133 # 0x85 # %SEQ%
PacketNames[PACKET_POKER_CASH_OUT] = "POKER_CASH_OUT"

class PacketPokerCashOut(PacketPokerMoneyTransfert):
    type = PACKET_POKER_CASH_OUT

    SAFE			= 1
    BREAK_NOTE			= 2
    EMPTY			= 3

PacketFactory[PACKET_POKER_CASH_OUT] = PacketPokerCashOut

########################################

PACKET_POKER_CASH_OUT_COMMIT = 134 # 0x86 # %SEQ%
PacketNames[PACKET_POKER_CASH_OUT_COMMIT] = "POKER_CASH_OUT_COMMIT"

class PacketPokerCashOutCommit(Packet):

    type = PACKET_POKER_CASH_OUT_COMMIT

    info = Packet.info + ( ('transaction_id', '', 's'), )

    INVALID_TRANSACTION = 1

    def __init__(self, **kwargs):
        self.transaction_id = kwargs.get("transaction_id", "")

    def pack(self):
        return Packet.pack(self) + self.packstring(self.transaction_id)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (block, self.transaction_id) = self.unpackstring(block)
        return block

    def calcsize(self):
        return Packet.calcsize(self) + self.calcsizestring(self.transaction_id)

    def __str__(self):
        return Packet.__str__(self) + " transaction_id = %s" % self.transaction_id

PacketFactory[PACKET_POKER_CASH_OUT_COMMIT] = PacketPokerCashOutCommit

########################################

PACKET_POKER_CASH_QUERY = 135 # 0x87 # %SEQ%
PacketNames[PACKET_POKER_CASH_QUERY] = "POKER_CASH_QUERY"

class PacketPokerCashQuery(Packet):

    type = PACKET_POKER_CASH_QUERY

    info = Packet.info + ( ('application_data', '', 's'), )
    
    DOES_NOT_EXIST = 1

    def __init__(self, **kwargs):
        self.application_data = kwargs.get("application_data", "")

    def pack(self):
        return Packet.pack(self) + self.packstring(self.application_data)

    def unpack(self, block):
        block = Packet.unpack(self, block)
        (block, self.application_data) = self.unpackstring(block)
        return block

    def calcsize(self):
        return Packet.calcsize(self) + self.calcsizestring(self.application_data)

    def __str__(self):
        return Packet.__str__(self) + " application_data = %s" % self.application_data

PacketFactory[PACKET_POKER_CASH_QUERY] = PacketPokerCashQuery

########################################

PACKET_POKER_RAKE = 136 # 0x88 # %SEQ%
PacketNames[PACKET_POKER_RAKE] = "POKER_RAKE"

class PacketPokerRake(PacketInt):

    type = PACKET_POKER_RAKE

    info = PacketInt.info + ( ('game_id', 0, 'I'), )

    game_id = 0

    format = "!I"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.game_id = kwargs.get("game_id", 0)
        PacketInt.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketInt.pack(self) + pack(PacketPokerRake.format, self.game_id)

    def unpack(self, block):
        block = PacketInt.unpack(self, block)
        (self.game_id,) = unpack(PacketPokerRake.format, block[:PacketPokerRake.format_size])
        return block[PacketPokerRake.format_size:]

    def calcsize(self):
        return PacketInt.calcsize(self) + PacketPokerRake.format_size

    def __str__(self):
        return PacketInt.__str__(self) + " game_id = %d" % self.game_id

PacketFactory[PACKET_POKER_RAKE] = PacketPokerRake

########################################

PACKET_POKER_TOURNEY_RANK = 137 # 0x89 # %SEQ%
PacketNames[PACKET_POKER_TOURNEY_RANK] = "POKER_TOURNEY_RANK"

class PacketPokerTourneyRank(PacketPokerId):
    """\
Semantics: a PACKET_POKER_TOURNEY_RANK sent to the player who leaves the tournament

Direction: server  => client

serial: serial of the tourney

rank: the rank.

players: the number of players in this tourney

money: the money won
"""

    type = PACKET_POKER_TOURNEY_RANK

    info = PacketPokerId.info + ( ('players', 0, 'I'),
                                  ('money', 0, 'I'),
                                  ('rank', sys.maxint, 'I'),
                                  )

    format = "!III"
    format_size = calcsize(format)

    def __init__(self, *args, **kwargs):
        self.players = kwargs.get("players", 0)
        self.money = kwargs.get("money", 0)
        self.rank = kwargs.get("rank", sys.maxint)
        PacketPokerId.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketPokerId.pack(self) + pack(PacketPokerTourneyRank.format, self.players, self.money, self.rank)

    def unpack(self, block):
        block = PacketPokerId.unpack(self, block)
        (self.players, self.money, self.rank) = unpack(PacketPokerTourneyRank.format, block[:PacketPokerTourneyRank.format_size])
        return block[PacketPokerTourneyRank.format_size:]

    def calcsize(self):
        return PacketPokerId.calcsize(self) + PacketPokerTourneyRank.format_size

    def __str__(self):
        return PacketPokerId.__str__(self) + "\n\tplayers = %d, tourney = %d, rank %d, won %d" % ( self.players, self.serial, self.rank, self.money )


PacketFactory[PACKET_POKER_TOURNEY_RANK] = PacketPokerTourneyRank

########################################

PACKET_POKER_PLAYER_IMAGE = 138 # 0x8a # %SEQ%
PacketNames[PACKET_POKER_PLAYER_IMAGE] = "POKER_PLAYER_IMAGE"

class PacketPokerPlayerImage(PacketSerial):
    """ """

    type = PACKET_POKER_PLAYER_IMAGE

    info = PacketSerial.info + ( ('image', '', 's'),
                                 ('image_type', 'image/png', 's'),
                                 )

    def __init__(self, *args, **kwargs):
        self.image = kwargs.get("image", '')
        self.image_type = kwargs.get("image_type", 'image/png')
        PacketSerial.__init__(self, *args, **kwargs)

    def pack(self):
        return PacketSerial.pack(self) + self.packstring(self.image) + self.packstring(self.image_type)

    def unpack(self, block):
        block = PacketSerial.unpack(self, block)
        (block, self.image) = self.unpackstring(block)
        (block, self.image_type) = self.unpackstring(block)
        return block

    def calcsize(self):
        return PacketSerial.calcsize(self) + self.calcsizestring(self.image) + self.calcsizestring(self.image_type)

    def __str__(self):
        return PacketSerial.__str__(self) + " image = %s, image_type = %s" % ( self.image, self.image_type )


PacketFactory[PACKET_POKER_PLAYER_IMAGE] = PacketPokerPlayerImage

########################################

PACKET_POKER_GET_PLAYER_IMAGE = 139 # 0x8b # %SEQ%
PacketNames[PACKET_POKER_GET_PLAYER_IMAGE] = "POKER_GET_PLAYER_IMAGE"

class PacketPokerGetPlayerImage(PacketSerial):

    type = PACKET_POKER_GET_PLAYER_IMAGE

PacketFactory[PACKET_POKER_GET_PLAYER_IMAGE] = PacketPokerGetPlayerImage

########################################

PACKET_POKER_HAND_REPLAY = 140 # 0x8c # %SEQ%
PacketNames[PACKET_POKER_HAND_REPLAY] = "POKER_HAND_REPLAY"

class PacketPokerHandReplay(PacketPokerId):
    """ """

    type = PACKET_POKER_HAND_REPLAY

PacketFactory[PACKET_POKER_HAND_REPLAY] = PacketPokerHandReplay

########################################

PACKET_POKER_GAME_MESSAGE = 141 # 0x8d # %SEQ%
PacketNames[PACKET_POKER_GAME_MESSAGE] = "POKER_GAME_MESSAGE"

class PacketPokerGameMessage(PacketPokerMessage):
    """ """

    type = PACKET_POKER_GAME_MESSAGE

PacketFactory[PACKET_POKER_GAME_MESSAGE] = PacketPokerGameMessage

########################################

class PacketPokerExplain(PacketInt):
    """\
Semantics: control the level of verbosity of the server
according to the "value" bit field as follows:

Context: If the server accepts the request, a PacketAck is
returned. Otherwise a PacketError is returned with
other_type set to PACKET_POKER_EXPLAIN.

Note: in order to produce the desired behaviour, the
PACKET_POKER_EXPLAIN must be sent before starting to
observe the action at a table (i.e. before sending PACKET_POKER_JOIN)
and before any PACKET_POKER_LOGIN is sent.

value == NONE
  The server assumes the client knows the poker rules, presumably
  by using poker-engine.

value == ALL
  The server assumes the client does not know poker and will
  explain every game event in great detail.

Direction: server <= client
"""
    pass #pragma: no cover

    NONE       = 0x0000
    REST       = 0x0001
    CHIPSTACKS = 0x0004
    ALL        = REST | CHIPSTACKS

Packet.infoDeclare(globals(), PacketPokerExplain, PacketInt, "POKER_EXPLAIN", 142) # 142 # 0x8e # %SEQ%

########################################

class PacketPokerStatsQuery(PacketString):
    """ """
    
    pass #pragma: no cover
    
Packet.infoDeclare(globals(), PacketPokerStatsQuery, PacketString, "POKER_STATS_QUERY", 143) # 143 # 0x8f # %SEQ%

########################################

class PacketPokerStats(Packet):
    """ """
    
    info = Packet.info + (
        ('players', 0, 'I'),
        ('hands', 0, 'I'),
        ('bytesin', 0, 'I'),
        ('bytesout', 0, 'I'),
        )

Packet.infoDeclare(globals(), PacketPokerStats, Packet, "POKER_STATS", 144) # 144 # 0x90 # %SEQ%

########################################

class PacketPokerBuyInLimits(Packet):
    """\
Semantics: the buy-in boundaries for "game_id" in the range
["min","max"]. An optimal buy-in is suggested in "best". A
player is considered broke unless he has at least "rebuy_min"
at the table.

Direction: server => client

Context: sent immediately after the PacketPokerTable packet.

min: minimum buy-in in cent.
max: minimum buy-in in cent.
best: optimal buy-in in cent.
rebuy_min: the minimum amount to play a hand.
game_id: integer uniquely identifying a game.
    """
    
    info = Packet.info + (
        ('game_id', 0, 'I'),
        ('min', 0, 'I'),
        ('max', 0, 'I'),
        ('best', 0, 'I'),
        ('rebuy_min', 0, 'I'),
        )

Packet.infoDeclare(globals(), PacketPokerBuyInLimits, Packet, "POKER_BUY_IN_LIMITS", 145) # 145 # 0x91 # %SEQ%

########################################

class PacketPokerMonitor(Packet):
    """ """
    
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerMonitor, Packet, "POKER_MONITOR", 146) # 146 # 0x92 # %SEQ%

########################################

class PacketPokerMonitorEvent(Packet):
    """ """
    ####
    # A hand is finished and has been archived in the hands table.
    # param1 = index in the hands table
    # param2 = 0 if cash game, 1 if tournament
    # 
    #
    HAND	= 1

    ####
    # A tournament is complete and prizes were distributed.
    # param1 = tourney serial in the tourneys table
    #
    TOURNEY	= 2

    ####
    # A player buys in at a cash game table.
    # param1 = user serial
    # param2 = table serial
    # param3 = buy in amount
    #
    BUY_IN	= 3

    ####
    # A player was granted money by auto refill.
    # param1 = user serial
    # param2 = currency serial
    # param3 = total amount for this currency
    #
    REFILL	= 4

    ###
    # A player won a prize at the end of a tournament.
    # param1 = user serial
    # param2 = currency serial
    # param3 = prize amount
    #
    PRIZE	= 5

    ####
    # A player registered in a tournament.
    # param1 = user serial
    # param2 = currency serial
    # param3 = registration fees
    #
    REGISTER	= 6

    ####
    # A player unregistered from a tournament.
    # param1 = user serial
    # param2 = currency serial
    # param3 = registration fees
    # 
    UNREGISTER	= 7

    ####
    # A player left a poker table.
    # param1 = user serial
    # param2 = table serial
    #
    LEAVE	= 8

    ####
    # A player got a seat at a poker table.
    # param1 = user serial
    # param2 = table serial
    #
    SEAT	= 9
    
    info = Packet.info + (
        ('event', 0, 'I'),
        ('param1', 0, 'I'),
        ('param2', 0, 'I'),
        ('param3', 0, 'I')
        )

Packet.infoDeclare(globals(), PacketPokerMonitorEvent, Packet, "POKER_MONITOR_EVENT", 147) # 147 # 0x93 # %SEQ%

########################################

class PacketPokerGetTourneyManager(Packet):
    """
Semantics: Get tournement manager packet for tourney_serial

Direction: server <= client

If the tourney_serial is not found occurs, the server will send back

  PacketError(other_type = PACKET_POKER_GET_TOURNEY_MANAGER)

with the "code" field name set as follows:

DOES_NOT_EXIST : the "tourney_serial" field does not match any existing
                 tournaments.
"""
    info = Packet.info + (
        ('tourney_serial', 0, 'I'),
        )

    DOES_NOT_EXIST = 1

Packet.infoDeclare(globals(), PacketPokerGetTourneyManager, Packet, "POKER_GET_TOURNEY_MANAGER", 148) # 148 # 0x94 # %SEQ%

########################################

class PacketPokerTourneyManager(Packet):
    """ """
    
    pass #pragma: no cover

Packet.infoDeclare(globals(), PacketPokerTourneyManager, Packet, "POKER_TOURNEY_MANAGER", 149) # 149 # 0x95 # %SEQ%

########################################

class PacketPokerPoll(Packet):
    """ """
    
    info = Packet.info + (
        ('game_id', 0, 'I'),
        ('tourney_serial', 0, 'I'),
        )

Packet.infoDeclare(globals(), PacketPokerPoll, Packet, "POKER_POLL", 150) # 150 # 0x96 # %SEQ%

########################################

class PacketPokerGetPlayerPlaces(Packet):
    """ """
    
    info = Packet.info + (
        ('serial', 0, 'I'),
        ('name', '', 's'),
        )

Packet.infoDeclare(globals(), PacketPokerGetPlayerPlaces, Packet, "POKER_GET_PLAYER_PLACES", 151) # 151 # 0x97 # %SEQ%

########################################

class PacketPokerPlayerPlaces(Packet):
    """ """
    
    info = Packet.info + (
        ('serial', 0, 'I'),
        ('tables', [], 'Il'),
        ('tourneys', [], 'Il'),
        )

Packet.infoDeclare(globals(), PacketPokerPlayerPlaces, Packet, "POKER_PLAYER_PLACES", 152) # 152 # 0x98 # %SEQ%

########################################

class PacketPokerSetLocale(PacketPokerId):
    """\

Semantics: the player "serial" is required to set the "locale" string,
which must be a locale supported by the server.  If the locale is
supported by the server, it will be made the locale used for strings sent
by PokerExplain packets.

Direction: server  <= client

Context: If the locale is supported by the server, a PacketAck is
returned, and future PokerExplain strings will be localized to the
requested language.  Otherwise a PacketError is returned with other_type
set to PACKET_POKER_SET_LOCALE.

locale: string representing a valid locale supported by the server configuration (e.g.,  "fr_FR" or "fr")
serial: integer uniquely identifying a player.
"""
# locale: string representing fully qualified locale and encoding, such as "fr_FR.UTF-8"

    info = PacketPokerId.info + ( ('locale', 'en_US', 's'), )

Packet.infoDeclare(globals(), PacketPokerSetLocale, PacketSerial, "POKER_SET_LOCALE", 153) # 153 # 0x99 # %SEQ%

########################################
class PacketPokerTableTourneyBreakBegin(Packet):
    """\

Semantics: Players at table "game_id" will receive this packet when a
tournament break offically begins.

Direction: server  => client

Context: 

game_id: integer uniquely identifying a game.
resume_time: time that the tourney will resume, in seconds since 1970-01-01 00:00:00 UTC.
"""
    info = Packet.info + (
        ('game_id', 0, 'I'),
        ('resume_time', 0, 'I'),
        )

Packet.infoDeclare(globals(), PacketPokerTableTourneyBreakBegin, Packet, "POKER_TABLE_TOURNEY_BREAK_BEGIN", 154) # 154 # 0x9a # %SEQ%

# infoDeclare would clobber our custom __str__ if we set it in the lass, so replace it here.
def PacketPokerTableTourneyBreakBegin__str__(self):
        return Packet.__str__(self) + "game_id = %d, resume_time = %s" % ( self.game_id,strftime("%Y/%m/%d %H:%M", gmtime(self.resume_time)))
PacketPokerTableTourneyBreakBegin.__str__ = PacketPokerTableTourneyBreakBegin__str__
########################################
class PacketPokerTableTourneyBreakDone(Packet):
    """\

Semantics: Players at table "game_id" will receive this packet when a
tournament break offically ends.

Direction: server  => client

Context: 

game_id: integer uniquely identifying a game.
"""
    info = Packet.info + (
        ('game_id', 0, 'I'),
        )


Packet.infoDeclare(globals(), PacketPokerTableTourneyBreakDone, Packet, "POKER_TABLE_TOURNEY_BREAK_DONE", 155) # 155 # 0x9b # %SEQ%

########################################

class PacketPokerTourneyStart(Packet):
    """\

Semantics: the "tourney_serial" tournament started and
the player is seated at table "table_serial".

Direction: server  => client

Context: this packet is sent to the client when it is
logged in. The player seated at the table "table_serial"
is implicitly the logged in player.

tourney_serial: integer uniquely identifying a tournament.
table_serial: integer uniquely identifying a game.
"""
    
    info = Packet.info + (
            ('tourney_serial', 0, 'I'),
            ('table_serial', 0, 'I')
            )

Packet.infoDeclare(globals(), PacketPokerTourneyStart, Packet, "POKER_TOURNEY_START", 156) # 0x9c # %SEQ%

########################################
class PacketPokerPlayerStats(PacketPokerId):
    """\

Semantics: the "rank" and "percentile" of the player "serial"
for the "currency_serial" currency. The player with the largest
amount of "currency_serial" money has "rank" 1. The "rank" is therefore
in the range [1..n] where n is the total number of players registered
on the poker server. The players are divided in G groups and the "percentile" is
the number of the player group. For instance, if the players are divided in 4 groups
the top 25% players will be in "percentile" 0, the next
25% will be in "percentile" 1 and the last
25% will be in "percentile" 3. The player with "rank" is always in
"percentile" 0 and the player with least chips in the "currency_serial"
money is always in the last "percentile".

Direction: server  => client

Context: 

serial: integer uniquely identifying a player.
game_id: integer uniquely identifying a game. (optional)
currency_serial: int currency id
rank: rank of the player 
percentile: percentile of the player
"""
    NOT_FOUND = 1

    info = PacketPokerId.info + (
        ('currency_serial', 0, 'I'),
        ('rank', 0, 'I'),
        ('percentile', 0, 'I')
        )

Packet.infoDeclare(globals(), PacketPokerPlayerStats, Packet, "POKER_PLAYER_STATS", 161) # 161 # 0xa1 # %SEQ%

########################################
class PacketPokerTourneyInfo(Packet):
    """\

Semantics: defined by tourney_select_info module as loaded from poker.server.xml

Direction: server =>  client
"""
    pass
    
Packet.infoDeclare(globals(), PacketPokerTourneyInfo, Packet, "POKER_TOURNEY_INFO", 164) # 164 # 0xa4 # %SEQ%

########################################
class PacketPokerTablePicker(PacketPokerId):
    """\

Semantics: The player "serial" wishes to join a table that matches the
           criteria sent.  Empty or non existing entries in criteria means
           "match any".  The table that matches the given criteria, and
           has the most players already seated (but with a seat available
           for the requesting player) will be returned.  An error is
           returned if such a table cannot be found.  If multiple tables
           are equally appropriate, the one with the smallest serial is
           returned.

           Note that the player has to be logged in order to pick a table,
           the "serial" field is mandatory.

           An additional criterion that is *not* sent by the user (but
           rather inferred by the server) is as follows: cash game tables
           whose minimum buy-in is less than the amount of money available
           to the player in a given currency are eliminated from
           consideration.

           If a table matching the criteria is available, it will be as if
           the client had sent the following sequence of packets (plus
           performed the pseudo-code logic below on client side):

               Send: PacketPokerTableJoin()
               Send: PacketPokerSeat()
               if auto_blind_ante: # in original packet
                    Send: PacketPokerAutoBlindAnte()
               Receive: PacketPokerBuyInLimits() [ returning "best", "min" ]
               if player.money_available < best:
                    Send: PacketPokerBuyIn(amount = min)
               else:
                    Send: PacketPokerBuyIn(amount = best)
               Send: PacketPokerSit()

           In the case of failure, an error packet as follows will be sent
           to the client:
             PacketPokerError(code      = PacketPokerTableJoin.GENERAL_FAILURE,
                              message   = <some string of non-zero length, for use
                                          in displaying to the user>,
                             other_type = PACKET_POKER_TABLE_PICKER,
                             serial     = <player's serial id>,
                             game_id    = <if failure occured before table matching criteria was identified: 0
                                           else: game.id for table where join was attempted>)

           In this case of success, the client can expect to receive all
           the packets that it would expect to receive in response to any
           of the packets listed in "Send" above.  These include:
                  PacketPokerTable()        # info about the table joined
                  PacketPokerBuyInLimits()  # still sent despite mention in pseudo-code above
                  PacketPokerPlayerArrive() # for client.serial
                  PacketPokerPlayerChips()  # for client.serial
                  if auto_blind_ante:
                    PacketPokerAutoBlindAnte()
                  PacketPokerSit()          # for client.serial
                  PacketPokerSeats()
              
           Note even if a valid PacketPokerTable() is received, it's
           possible, although unlikely, that the intervening operations --
           PacketPokerSeat(), PacketPokerBuyIn() and PacketPokerSit() --
           might fail.  If one of them fails, the client should expect to
           receive the normal errors it would receive if such an operation
           failed.  Clients are advised, upon receiving a valid
           PacketPokerTable() in response, to use the same handling
           routines that it uses for PacketPokerSeat(), PacketPokerBuyIn()
           and PacketPokerSit() to keep parity with the operations the
           server is performing on the client's behalf.

Direction: server <=  client

Context:

serial: integer uniquely identifying a player.
currency_serial: int currency id (criteria for search)
variant: base name of the variant sought.
betting_structure: base name of the betting structure.
auto_blind_ante: boolean, if True server will act as if
                PacketPokerAutoBlindAnte() were also sent by client.
                Defaults to False.
"""
    info = PacketPokerId.info + (
        ('currency_serial', 0, 'I'),
        ('min_players', 0, 'I'),
        ('variant', '', 's'),
        ('betting_structure', '', 's'),
        ('auto_blind_ante', False, 'bool'),
        )

Packet.infoDeclare(globals(), PacketPokerTablePicker, Packet, "POKER_TABLE_PICKER", 165) # 165 # 0xa5 # %SEQ%

########################################
class PacketPokerCreateTourney(PacketSerial):
    """\

Semantics: The authorized player represented by "serial",
           seeks to create a new sit-n-go tournament for the players in
           the "players" list of serials. Each player in the list will
           be registered for the new tournament.

           The fields "name", "description_short", "description_long", "variant",
           "betting_structure", "seats_per_game", "player_timeout", "currency_serial"
           and "buy_in" have the same semantics as described in the database schema.

           Upon success, the response will be PacketAck() for the new sit-n-go tournament.
           If the request is issued by a user that is not authentified, the response will be:
                 PacketAuthRequest()
           If at least on user cannot be registered, the response will be:
                 PacketPokerError(
                   other_type = PACKET_POKER_CREATE_TOURNEY,
                   code       = REGISTRATION_FAILED 
                   serial     = the serial of the tournament for which registration failed

                   Note: the list of players for which registration has failed is included
                   in the message. An error message will be sent to each players for which
                   registration failed, if they have an active session.

Direction: server <=  client

Context:

serial:            integer uniquely identifying the administrative-level player.
name:              name for tournament
description_short: Short description of tournament
description_long:  Long description of tournament
variant:           base name of the variant for the new sit-n-go
betting_structure: base name of the betting structure that must
                   match a poker.<betting_structure>.xml file containing
                   a full description of the betting structure.
seats_per_game:     Maximum number of seats for each table in this tournament.
player_timeout:    the number of seconds after which a player in position is forced to
                   play (by folding).
currency_serial:   int currency id
buy_in:            Amount, in currency_serial, for buying into this tournament.
players:	   Serials of the players participating in the tournament.
"""
    REGISTRATION_FAILED = 1
    
    info = PacketSerial.info + (
        ('name', 'noname', 's'),
        ('description_short', 'nodescription_short', 's'),
        ('description_long', 'nodescription_long', 's'),
        ('variant', 'holdem', 's'),
        ('betting_structure', 'level-001', 's'),
        ('seats_per_game', 10, 'I'),
        ('player_timeout', 60, 'I'),
        ('currency_serial', 0, 'I'),
        ('buy_in', 0, 'I'),
        ('players', [], 'Il')
        )

Packet.infoDeclare(globals(), PacketPokerCreateTourney, Packet, "POKER_CREATE_TOURNEY", 166) # 166 # 0xa6 # %SEQ%
########################################
class PacketPokerLongPoll(Packet):
    """ """
    
    info = Packet.info

Packet.infoDeclare(globals(), PacketPokerLongPoll, Packet, "POKER_LONG_POLL", 167) # 167 # 0xa7 # %SEQ%
########################################
class PacketPokerLongPollReturn(Packet):
    """ """
    
    info = Packet.info

Packet.infoDeclare(globals(), PacketPokerLongPollReturn, Packet, "POKER_LONG_POLL_RETURN", 168) # 168 # 0xa8 # %SEQ%


_TYPES = range(50,169)

# Interpreted by emacs
# Local Variables:
# compile-command: "perl -pi -e 'if(/%SEQ%/) { $s = 49 if(!defined($s)); $s++; $h = sprintf(q/0x%x/, $s); s/\\d+[ \\w#]+#/$s # $h #/; }' pokerpackets.py"
# End:

########NEW FILE########
__FILENAME__ = pokerrestclient
#
# Copyright (C) 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2009 Johan Euphrosine <proppy@aminche.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

from twisted.internet import defer, protocol, reactor, error
from twisted.web import http, client
from twisted.python.util import InsensitiveDict
from twisted.python.runtime import seconds
from pokernetwork.pokerpackets import *

import pokersite

class RestClientFactory(protocol.ClientFactory):

    protocol = client.HTTPPageGetter
    
    def __init__(self, host, port, path, data, timeout = 60):
        self.timeout = timeout
        self.agent = "RestClient"
        self.headers = InsensitiveDict()
        self.headers.setdefault('Content-Length', len(data))
        self.headers.setdefault("connection", "close")
        self.method = 'POST'
        self.url = 'http://' + host + ':' + str(port) + path
        self.postdata = data
        self.host = host
        self.port = port
        self.path = path
        self.waiting = 1
        self.deferred = defer.Deferred()
        self.response_headers = None
        self.cookies = {}

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__, self.url)

    def buildProtocol(self, addr):
        p = protocol.ClientFactory.buildProtocol(self, addr)
        if self.timeout:
            timeoutCall = reactor.callLater(self.timeout, p.timeout)
            self.deferred.addBoth(self._cancelTimeout, timeoutCall)
        return p

    def _cancelTimeout(self, result, timeoutCall):
        if timeoutCall.active():
            timeoutCall.cancel()
        return result

    def gotHeaders(self, headers):
        self.response_headers = headers
        
    def gotStatus(self, version, status, message):
        self.version, self.status, self.message = version, status, message

    def page(self, page):
        if self.waiting:
            self.waiting = 0
            self.deferred.callback(page)

    def noPage(self, reason):
        if self.waiting:
            self.waiting = 0
            self.deferred.errback(reason)

    def clientConnectionFailed(self, _, reason):
        if self.waiting:
            self.waiting = 0
            self.deferred.errback(reason)

class PokerRestClient:
    DEFAULT_LONG_POLL_FREQUENCY = 0.1
    
    def __init__(self, host, port, path, longPollCallback, verbose = 0, timeout = 60):
        self.verbose = verbose
        self.queue = defer.succeed(True)
        self.pendingLongPoll = False
        self.minLongPollFrequency = 0.01
        self.sentTime = 0
        self.host = host
        self.port = port
        self.path = path
        self.timer = None
        self.timeout = timeout
        self.longPollCallback = longPollCallback
        if longPollCallback:
            self.longPollFrequency = PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY
            self.scheduleLongPoll(0)
        else:
            self.longPollFrequency = -1

    def message(self, string):
        print 'PokerRestClient(%s) %s' % ( self.host + ':' + str(self.port), string )

    def sendPacket(self, packet, data):
        if self.pendingLongPoll:
            self.sendPacketData('{ "type": "PacketPokerLongPollReturn" }')
        d = defer.Deferred()
        d.addCallbacks(self.receivePacket, self.receiveError)
        self.queue.addCallback(lambda status: self.sendPacketData(data))
        self.queue.chainDeferred(d)
        if packet.type == PACKET_POKER_LONG_POLL:
            self.pendingLongPoll = True
        return d

    def receivePacket(self, data):
        if self.verbose > 3:
            self.message('receivePacket ' + data)
        if self.pendingLongPoll:
            self.scheduleLongPoll(0)
        self.pendingLongPoll = False
        args = simplejson.loads(data, encoding = 'UTF-8')
        args = pokersite.fromutf8(args)
        packets = pokersite.args2packets(args)
        return packets

    def receiveError(self, data):
        return [ PacketError(message = str(data)) ]
    
    def sendPacketData(self, data):
        if self.verbose > 3:
            self.message('sendPacketData ' + data)
        factory = RestClientFactory(self.host, self.port, self.path, data, self.timeout)
        reactor.connectTCP(self.host, self.port, factory)
        self.sentTime = seconds()
        return factory.deferred

    def clearTimeout(self):
        if self.timer and self.timer.active():
            self.timer.cancel()
        self.timer = None
        
    def scheduleLongPoll(self, delta):
        self.clearTimeout()
        self.timer = reactor.callLater(max(self.minLongPollFrequency, self.longPollFrequency - delta), self.longPoll)

    def longPoll(self):
        if self.longPollFrequency > 0:
            delta = seconds() - self.sentTime
            in_line = len(self.queue.callbacks)
            if in_line <= 0 and delta > self.longPollFrequency:
                self.clearTimeout()
                d = self.sendPacket(PacketPokerLongPoll(),'{ "type": "PacketPokerLongPoll" }')
                d.addCallback(self.longPollCallback)
            else:
                self.scheduleLongPoll(delta)
        
class PokerProxyClient(http.HTTPClient):
    """
    Used by PokerProxyClientFactory to implement a simple web proxy.
    """

    def __init__(self, command, rest, version, headers, data, father):
        self.father = father
        self.command = command
        self.rest = rest
        if "proxy-connection" in headers:
            del headers["proxy-connection"]
        headers["connection"] = "close"
        self.headers = headers
        self.data = data

    def connectionMade(self):
        self.sendCommand(self.command, self.rest)
        for header, value in self.headers.items():
            self.sendHeader(header, value)
        self.endHeaders()
        self.transport.write(self.data)

    def handleStatus(self, version, code, message):
        self.father.setResponseCode(int(code), message)

    def handleHeader(self, key, value):
        self.father.setHeader(key, value)

    def handleResponse(self, buffer):
        self.father.write(buffer)
        
    def connectionLost(self, reason):
        self.father.finish()

class PokerProxyClientFactory(protocol.ClientFactory):

    serial = 0
    
    protocol = PokerProxyClient

    def __init__(self, command, rest, version, headers, data, father, verbose, destination):
        self.father = father
        self.command = command
        self.rest = rest
        self.headers = headers
        self.data = data
        self.version = version
        self.deferred = defer.Deferred()
        self.verbose = verbose
        self.noisy = False
        self.destination = destination
        PokerProxyClientFactory.serial += 1
        self.serial = PokerProxyClientFactory.serial

    def message(self, string):
        print 'PokerProxyRestClient(%d) %s' % ( self.serial, string )

    def doStart(self):
        if self.verbose >= 3:
            self.message('START %s => %s' % ( self.data, self.destination ))
        protocol.ClientFactory.doStart(self)

    def doStop(self):
        if self.verbose >= 3:
            self.message('STOP')
        protocol.ClientFactory.doStop(self)

#    def error(self, string):
#	self.message("*ERROR* " + str(string))

    def buildProtocol(self, addr):
        return self.protocol(self.command, self.rest, self.version,
                             self.headers, self.data, self.father)

    def clientConnectionFailed(self, connector, reason):
        if not self.deferred.called:
            self.deferred.errback(reason)

    def clientConnectionLost(self, connector, reason):
        if not self.deferred.called:
            if reason.check(error.ConnectionDone):
                self.deferred.callback(True)
            else:
                self.deferred.errback(reason)

########NEW FILE########
__FILENAME__ = pokerserver
#
# -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Henry Precheur <henry@precheur.org> (2004)
#

import sys
sys.path.insert(0, ".")
sys.path.insert(0, "..")

import platform
from os.path import exists
from types import *

try:
        from OpenSSL import SSL
        from pokernetwork.pokerservice import SSLContextFactory
        HAS_OPENSSL=True
except:
        print "openSSL not available."
        HAS_OPENSSL=False


from twisted.application import internet, service, app
from twisted.web import resource,server

from pokernetwork import pokerdatabase
from pokernetwork.pokernetworkconfig import Config
from pokernetwork.pokerservice import PokerTree, PokerRestTree, PokerService, IPokerFactory
from pokernetwork.pokersite import PokerSite
from twisted.manhole import telnet

DEFAULT_CONFIG_PATH = '/etc/poker-network/poker.server.xml'

def makeService(configuration):
    settings = Config([''])
    settings.load(configuration)
    if not settings.header:
        sys.exit(1)

    serviceCollection = service.MultiService()

    poker_service = PokerService(settings)
    poker_service.setServiceParent(serviceCollection)

    poker_factory = IPokerFactory(poker_service)

    #
    # Poker protocol (with or without SSL)
    #
    tcp_port = settings.headerGetInt("/server/listen/@tcp")
    internet.TCPServer(tcp_port, poker_factory
                       ).setServiceParent(serviceCollection)

    tcp_ssl_port = settings.headerGetInt("/server/listen/@tcp_ssl")
    if HAS_OPENSSL and tcp_ssl_port:
            internet.SSLServer(tcp_ssl_port, poker_factory, SSLContextFactory(settings)
                           ).setServiceParent(serviceCollection)

    rest_site = PokerSite(settings, PokerRestTree(poker_service))

    #
    # HTTP (with or without SLL) that implements REST
    #
    rest_port = settings.headerGetInt("/server/listen/@rest")
    if rest_port:
            internet.TCPServer(rest_port, rest_site
                               ).setServiceParent(serviceCollection)

    rest_ssl_port = settings.headerGetInt("/server/listen/@rest_ssl")
    if HAS_OPENSSL and rest_ssl_port:
            internet.SSLServer(rest_ssl_port, rest_site, SSLContextFactory(settings)
                               ).setServiceParent(serviceCollection)

    http_site = server.Site(PokerTree(poker_service))

    #
    # HTTP (with or without SLL) that implements XML-RPC and SOAP
    #
    http_port = settings.headerGetInt("/server/listen/@http")
    if http_port:
            internet.TCPServer(http_port, http_site
                               ).setServiceParent(serviceCollection)

    http_ssl_port = settings.headerGetInt("/server/listen/@http_ssl")
    if HAS_OPENSSL and http_ssl_port:
            internet.SSLServer(http_ssl_port, http_site, SSLContextFactory(settings)
                               ).setServiceParent(serviceCollection)

    # API
    api_ssl_port = settings.headerGetInt("/server/listen/@api_ssl")
    if HAS_OPENSSL and api_ssl_port:
        from pokernetwork import apiserver, apiservice
        poker_database = pokerdatabase.PokerDatabase(settings)
        secret_store = apiserver.APIUserStore(poker_database)
        api_service = apiservice.APIService(poker_service)
        api_site = server.Site(apiserver.Root(api_service, secret_store))
        internet.SSLServer(api_ssl_port, api_site, SSLContextFactory(settings)
                          ).setServiceParent(serviceCollection)
    else:
        print 'Could not create API service!'

    #
    # TELNET twisted.manhole (without SSL)
    #
    manhole_port = settings.headerGetInt("/server/listen/@manhole")
    if manhole_port:
	    manhole_factory = telnet.ShellFactory()
	    manhole_factory.namespace['poker_service'] = poker_service
	    manhole_factory.namespace['poker_site'] = rest_site
	    manhole_service = internet.TCPServer(manhole_port, manhole_factory, interface = '127.0.0.1')
	    manhole_service.setName("manhole")
	    manhole_service.setServiceParent(serviceCollection)
	    if settings.headerGetInt("/server/@verbose") > 0:
		    print  "PokerManhole: manhole is useful for debugging, use with telnet admin/admin, however, it can be a security risk and should be used only during debugging"

    return serviceCollection


def makeApplication(argv):
    default_path = "/etc/poker-network" + sys.version[:3] + "/poker.server.xml"
    if not exists(default_path):
        default_path = DEFAULT_CONFIG_PATH
    configuration = argv[-1][-4:] == ".xml" and argv[-1] or default_path
    application = service.Application('poker')
    serviceCollection = service.IServiceCollection(application)
    poker_service = makeService(configuration)
    poker_service.setServiceParent(serviceCollection)
    return application


def run():
    if platform.system() != "Windows":
        if not sys.modules.has_key('twisted.internet.reactor'):
                print "installing poll reactor"
                from twisted.internet import pollreactor
                pollreactor.install()
        else:
                print "poll reactor already installed"
    from twisted.internet import reactor
    application = makeApplication(sys.argv)
    app.startApplication(application, None)
    reactor.run()

if __name__ == '__main__':
    run() # pragma: no cover
          # Do not need coverage since we call run directly in the tests.

########NEW FILE########
__FILENAME__ = pokerservice
#
# -*- py-indent-offset: 4; coding: iso-8859-1 -*-
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)       2008, 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C)             2009 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org> (2008-)
#  Henry Precheur <henry@precheur.org> (2004)
#  Cedric Pinson <cpinson@freesheep.org> (2004-2006)

from os.path import exists
from types import *
from string import split, join
import os
import copy
import operator
import re
import locale
import gettext
import libxml2
import simplejson
import imp
from traceback import print_exc


from twisted.application import service
from twisted.internet import protocol, reactor, defer
from twisted.web.client import getPage
from twisted.python.runtime import seconds

try:
    from OpenSSL import SSL
    HAS_OPENSSL=True
except:
    print "openSSL not available."
    HAS_OPENSSL=False

try:
    # twisted-2.0
    from zope.interface import Interface
    from zope.interface import implements
except ImportError:
    # twisted-1.3 forwards compatibility
    def implements(interface):
        frame = sys._getframe(1)
        locals = frame.f_locals

        # Try to make sure we were called from a class def
        if (locals is frame.f_globals) or ('__module__' not in locals):
            raise TypeError(" can be used only from a class definition.")

        if '__implements__' in locals:
            raise TypeError(" can be used only once in a class definition.")

        locals['__implements__'] = interface

    from twisted.python.components import Interface

from MySQLdb.cursors import DictCursor
from MySQLdb.constants import ER

from twisted.python import components

from pokerengine.pokertournament import *
from pokerengine.pokercards import PokerCards
from pokerengine import pokerprizes

from pokernetwork.protocol import UGAMEProtocol
from pokernetwork.server import PokerServerProtocol
from pokernetwork.user import checkName, checkPassword
from pokernetwork.pokerdatabase import PokerDatabase
from pokernetwork.pokerpackets import *
from pokernetwork.pokersite import PokerTourneyStartResource, PokerImageUpload, PokerAvatarResource, PokerResource, packets2maps, args2packets, fromutf8, toutf8
from pokernetwork.pokertable import PokerTable, PokerAvatarCollection
from pokernetwork import pokeravatar
from pokernetwork.user import User
from pokernetwork import pokercashier
from pokernetwork import pokernetworkconfig
from pokernetwork import tableconfigutils
from pokerauth import get_auth_instance
from datetime import date

UPDATE_TOURNEYS_SCHEDULE_DELAY = 10 * 60
CHECK_TOURNEYS_SCHEDULE_DELAY = 60
DELETE_OLD_TOURNEYS_DELAY = 1 * 60 * 60

class IPokerService(Interface):

    def createAvatar(self):
        """ """

    def destroyAvatar(self, avatar):
        """ """

class IPokerFactory(Interface):

    def createAvatar(self):
        """ """

    def destroyAvatar(self, avatar):
        """ """

    def buildProtocol(self, addr):
        """ """

class PokerFactoryFromPokerService(protocol.ServerFactory):

    implements(IPokerFactory)

    protocol = PokerServerProtocol

    def __init__(self, service):
        self.service = service
        self.verbose = service.verbose

    def createAvatar(self):
        """ """
        return self.service.createAvatar()

    def destroyAvatar(self, avatar):
        """ """
        return self.service.destroyAvatar(avatar)

components.registerAdapter(PokerFactoryFromPokerService,
                           IPokerService,
                           IPokerFactory)

class PokerService(service.Service):

    implements(IPokerService)

    def __init__(self, settings):
        if type(settings) is StringType:
            settings_object = pokernetworkconfig.Config(['.'])
            settings_object.doc = libxml2.parseMemory(settings, len(settings))
            settings_object.header = settings_object.doc.xpathNewContext()
            settings = settings_object
        self.settings = settings
        self.verbose = self.settings.headerGetInt("/server/@verbose")
        self.joined_max = self.settings.headerGetInt("/server/@max_joined")
        if self.joined_max <= 0:
            # dachary picked this maximum as a default on 2008-08-16
            # <dachary> because the last stress test show 4000 is the upper limit
            # <dachary> http://pokersource.info/stress-test/2007-08/
            self.joined_max = 4000
        self.sng_timeout = self.settings.headerGetInt("/server/@sng_timeout")
        if self.sng_timeout <= 0:
            self.sng_timeout = 3600
        self.missed_round_max = self.settings.headerGetInt("/server/@max_missed_round")
        if self.missed_round_max <= 0:
            # This default for missed_round_max below (for when it is not
            # set in config file) is completely arbitrary and made up by
            # bkuhn.  dachary suggested 3 in #pokersource on 2008-08-24,
            # but bkuhn argued that if someone leaves it out of the config
            # file, it should be somewhat high since they wouldn't be
            # expecting a pick-up if they hadn't configed their server to
            # do it.
            #
            # bkuhn also pointed out that there is some arugment for
            # making the default infinity when it is left out of the
            # config file.  However, this complicates code to test for,
            # say, a negative value every time to see if you should ignore
            # the feature entirely, and it's probably not the case that
            # the user would ever want to configure a server on purpose to
            # have infinite sit-out time.
            #
            # Note that the config file example defaults this to 5, which
            # is probably a much more reasonable default.
            #
            # Finally, note that this is the server-wide default.  In the
            # config file, <table> entries can override this.
            self.missed_round_max = 10
        self.client_queued_packet_max = self.settings.headerGetInt("/server/@max_queued_client_packets")
        if self.client_queued_packet_max <= 0:
            self.client_queued_packet_max = 500

        self.delays = settings.headerGetProperties("/server/delays")[0]

        refill = settings.headerGetProperties("/server/refill")
        if len(refill) > 0:
            self.refill = refill[0]
        else:
            self.refill = None
        self.db = None
        self.cashier = None
        self.poker_auth = None
        self.timer = {}
        self.down = True
        self.shutdown_deferred = None
        self.resthost_serial = 0
        self.has_ladder = None
        self.monitor_plugins = []
        for monitor in settings.header.xpathEval("/server/monitor"):
            module = imp.load_source("monitor", monitor.content)
            self.monitor_plugins.append(getattr(module, "handle_event"))
        self.remove_completed = self.settings.headerGetInt("/server/@remove_completed")
        self.getPage = getPage
        self.long_poll_timeout = settings.headerGetInt("/server/@long_poll_timeout")
        if self.long_poll_timeout <= 0:
            self.long_poll_timeout = 20

    def setupLadder(self):
        cursor = self.db.cursor()
        cursor.execute("SHOW TABLES LIKE 'rank'")
        self.has_ladder = cursor.rowcount == 1
        cursor.close()
        return self.has_ladder

    def getLadder(self, game_id, currency_serial, user_serial):
        cursor = self.db.cursor()
        cursor.execute("SELECT rank,percentile FROM rank WHERE currency_serial = %s AND user_serial = %s", ( currency_serial, user_serial ))
        if cursor.rowcount == 1:
            row = cursor.fetchone()
            packet = PacketPokerPlayerStats(currency_serial = currency_serial,
                                            serial = user_serial,
                                            rank = row[0],
                                            percentile = row[1])
        else:
            packet = PacketPokerError(serial = user_serial,
                                      other_type = PACKET_POKER_PLAYER_STATS,
                                      code = PacketPokerPlayerStats.NOT_FOUND,
                                      message = "no ladder entry for player %d and currency %d" % ( user_serial, currency_serial ))
        if game_id:
            packet.game_id = game_id
        else:
            packet.game_id = 0
        cursor.close()
        return packet

    def setupTourneySelectInfo(self):
        #
        # load module that provides additional tourney information
        #
        self.tourney_select_info = None
        settings = self.settings
        for path in settings.header.xpathEval("/server/tourney_select_info"):
            if self.verbose > 0:
                self.message("trying to load " + path.content)
            module = imp.load_source("tourney_select_info", path.content)
            path = settings.headerGet("/server/tourney_select_info/@settings")
            if path:
                s = pokernetworkconfig.Config(settings.dirs)
                s.load(path)
            else:
                s = None
            self.tourney_select_info = module.Handle(self, s)
            getattr(self.tourney_select_info, '__call__')

    def get_table_descriptions(self):
        return tableconfigutils.get_table_descriptions(self.settings)

    def startService(self):
        self.monitors = []
        self.db = PokerDatabase(self.settings)
        self.setupTourneySelectInfo()
        self.setupLadder()
        self.setupResthost()
        self.cleanupCrashedTables()
        cleanup = self.settings.headerGet("/server/@cleanup")
        if cleanup != 'no':
            self.cleanUp(temporary_users = self.settings.headerGet("/server/users/@temporary"))
        self.cashier = pokercashier.PokerCashier(self.settings)
        self.cashier.setDb(self.db)
        self.poker_auth = get_auth_instance(self.db, self.settings)
        self.dirs = split(self.settings.headerGet("/server/path"))
        self.avatar_collection = PokerAvatarCollection("service", self.verbose)
        self.avatars = []
        self.tables = {}
        self.joined_count = 0
        self.tourney_table_serial = 1
        self.shutting_down = False
        self.simultaneous = self.settings.headerGetInt("/server/@simultaneous")
        self._ping_delay = self.settings.headerGetInt("/server/@ping")
        self.chat = self.settings.headerGet("/server/@chat") == "yes"

        # gettextFuncs is a dict that is indexed by full locale strings,
        # such as fr_FR.UTF-8, and returns a translation function.  If you
        # wanted to apply it directly, you'd do something like:
        # but usually, you will do something like this to change your locale on the fly:
        #   global _
        #   _ = self.gettextFuncs{'fr_FR.UTF-8'}
        #   _("Hello!  I am speaking in French now.")
        #   _ = self.gettextFuncs{'en_US.UTF-8'}
        #   _("Hello!  I am speaking in US-English now.")

        self.gettextFuncs = {}
        langsSupported = self.settings.headerGetProperties("/server/language")
        if (len(langsSupported) > 0):
            # Note, after calling _lookupTranslationFunc() a bunch of
            # times, we must restore the *actual* locale being used by the
            # server itself for strings locally on its machine.  That's
            # why we save it here.
            localLocale = locale.getlocale(locale.LC_ALL)

            for lang in langsSupported:
                self.gettextFuncs[lang['value']] = self._lookupTranslationFunc(lang['value'])
            try:
                locale.setlocale(locale.LC_ALL, localLocale)
            except locale.Error, le:
                self.error('Unable to restore original locale: %s' % le)

        table_descriptions = self.get_table_descriptions()
        for table_description in table_descriptions:
            self.createTable(0, table_description)

        self.cleanupTourneys()
        self.updateTourneysSchedule()
        self.messageCheck()
        self.poker_auth.SetLevel(PACKET_POKER_SEAT, User.REGULAR)
        self.poker_auth.SetLevel(PACKET_POKER_GET_USER_INFO, User.REGULAR)
        self.poker_auth.SetLevel(PACKET_POKER_GET_PERSONAL_INFO, User.REGULAR)
        self.poker_auth.SetLevel(PACKET_POKER_PLAYER_INFO, User.REGULAR)
        self.poker_auth.SetLevel(PACKET_POKER_TOURNEY_REGISTER, User.REGULAR)
        self.poker_auth.SetLevel(PACKET_POKER_HAND_SELECT_ALL, User.ADMIN)
        service.Service.startService(self)
        self.down = False

    def message(self, string):
        print "PokerService: " + str(string)

    def error(self, string):
        self.message("*ERROR* " + str(string))

    def stopServiceFinish(self, x):
        self.monitors = []
        if self.cashier: self.cashier.close()
        if self.db:
            self.cleanupCrashedTables()
            if self.resthost_serial: self.cleanupResthost()
            self.db.close()
            self.db = None
        if self.poker_auth: self.poker_auth.db = None
        service.Service.stopService(self)

    def disconnectAll(self):
        reactor.disconnectAll()

    def stopService(self):
        deferred = self.shutdown()
        deferred.addCallback(lambda x: self.disconnectAll())
        deferred.addCallback(self.stopServiceFinish)
        return deferred

    def cancelTimer(self, key):
        if self.timer.has_key(key):
           if self.verbose > 3:
               self.message("cancelTimer " + key)
           timer = self.timer[key]
           if timer.active():
              timer.cancel()
           del self.timer[key]

    def cancelTimers(self, what):
        for key in self.timer.keys():
            if what in key:
                self.cancelTimer(key)

    def joinedCountReachedMax(self):
        """Returns True iff. the number of joins to tables has exceeded
        the maximum allowed by the server configuration"""
        return self.joined_count >= self.joined_max

    def joinedCountIncrease(self, num = 1):
        """Increases the number of currently joins to tables by num, which
        defaults to 1."""
        self.joined_count += num
        return self.joined_count

    def joinedCountDecrease(self, num = 1):
        """Decreases the number of currently joins to tables by num, which
        defaults to 1."""
        self.joined_count -= num
        return self.joined_count

    def getMissedRoundMax(self):
        return self.missed_round_max

    def getClientQueuedPacketMax(self):
        return self.client_queued_packet_max

    def _separateCodesetFromLocale(self, lang_with_codeset):
        lang = lang_with_codeset
        codeset = ""
        dotLoc = lang.find('.')
        if dotLoc > 0:
            lang = lang_with_codeset[:dotLoc]
            codeset = lang_with_codeset[dotLoc+1:]

        if len(codeset) <= 0:
            self.error('Unable to find codeset string in language value: %s' % lang_with_codeset)
        if len(lang) <= 0:
            self.error('Unable to find locale string in language value: %s' % lang_with_codeset)
        return (lang, codeset)

    def _lookupTranslationFunc(self, lang_with_codeset):
        # Start by defaulting to just returning the string...
        myGetTextFunc = lambda text:text

        (lang, codeset) = self._separateCodesetFromLocale(lang_with_codeset)

# I now believe that changing the locale in this way for each language is
# completely uneeded given the set of features we are looking for.
# Ultimately, we aren't currently doing localization operations other than
# gettext() string lookup, so the need to actually switch locales does not
# exist.  Long term, we may want to format numbers properly for remote
# users, and then we'll need more involved locale changes, probably
# handled by avatar and stored in the server object.  In the meantime,
# this can be commented out and makes testing easier.  --bkuhn, 2008-11-28

#         try:
#             locale.setlocale(locale.LC_ALL, lang)
#         except locale.Error, le:
#             self.error('Unable to support locale, "%s", due to locale error: %s'
#                        % (lang_with_codeset, le))
#             return myGetTextFunc

        outputStr = "Aces"
        try:
            # I am not completely sure poker-engine should be hardcoded here like this...
            transObj = gettext.translation('poker-engine',
                                                languages=[lang], codeset=codeset)
            transObj.install()
            myGetTextFunc = transObj.gettext
            # This test call of the function *must* be a string in the
            # poker-engine domain.  The idea is to force a throw of
            # LookupError, which will be thrown if the codeset doesn't
            # exist.  Unfortunately, gettext doesn't throw it until you
            # call it with a string that it can translate (gibberish
            # doesn't work!).  We want to fail to support this
            # language/encoding pair here so the server can send the error
            # early and still support clients with this codec, albeit by
            # sending untranslated strings.
            outputStr = myGetTextFunc("Aces")
        except IOError, e:
            self.error("No translation for language %s for %s in poker-engine; locale ignored: %s"
                       % (lang, lang_with_codeset, e))
            myGetTextFunc = lambda text:text
        except LookupError, l:
            self.error("Unsupported codeset %s for %s in poker-engine; locale ignored: %s"
                       % (codeset, lang_with_codeset, l))
            myGetTextFunc = lambda text:text

        if outputStr == "Aces" and lang[0:2] != "en":
            self.error("Translation setup for %s failed.  Strings for clients requesting %s will likely always be in English" % (lang_with_codeset, lang))
        return myGetTextFunc

    def locale2translationFunc(self, locale, codeset = ""):
        if len(codeset) > 0:
            locale += "." + codeset
        if self.gettextFuncs.has_key(locale):
            return self.gettextFuncs[locale]
        else:
            if self.verbose > 2:
                self.message("Locale, \"%s\" not available.  %s must not have been provide via <language/> tag in settings, or errors occured during loading." % (locale, locale))
            return None

    def shutdown(self):
        self.shutting_down = True
        self.cancelTimer('checkTourney')
        self.cancelTimer('updateTourney')
        self.cancelTimer('messages')
        self.cancelTimers('tourney_breaks')
        self.cancelTimers('tourney_delete_route')
        self.shutdown_deferred = defer.Deferred()
        reactor.callLater(0.01, self.shutdownCheck)
        return self.shutdown_deferred

    def shutdownCheck(self):
        if self.down:
            if self.shutdown_deferred:
                self.shutdown_deferred.callback(True)
            return

        playing = 0
        for table in self.tables.values():
            if not table.game.isEndOrNull():
                playing += 1
        if self.verbose and playing > 0:
            self.message("Shutting down, waiting for %d games to finish" % playing)
        if playing <= 0:
            if self.verbose:
                self.message("Shutdown immediately")
            self.down = True
            self.shutdown_deferred.callback(True)
            self.shutdown_deferred = False
        else:
            reactor.callLater(10, self.shutdownCheck)

    def isShuttingDown(self):
        return self.shutting_down

    def stopFactory(self):
        pass

    def monitor(self, avatar):
        if avatar not in self.monitors:
            self.monitors.append(avatar)
        return PacketAck()

    def databaseEvent(self, **kwargs):
        event = PacketPokerMonitorEvent(**kwargs)
        sql = "INSERT INTO monitor (event, param1, param2, param3) VALUES (%d, %d, %d, %d)" % ( kwargs['event'], kwargs.get('param1', 0), kwargs.get('param2', 0), kwargs.get('param3', 0) )
        if self.verbose > 3:
            self.message(sql)
        self.db.db.query(sql)
        for avatar in self.monitors:
            if hasattr(avatar, "protocol") and avatar.protocol:
                avatar.sendPacketVerbose(event)
        for plugin in self.monitor_plugins:
            plugin(self, event)

    def stats(self, query):
        cursor = self.db.cursor()
        cursor.execute("SELECT MAX(serial) FROM hands")
        (hands,) = cursor.fetchone()
        if hands == None:
            hands = 0
        else:
            hands = int(hands)
        cursor.close()
        return PacketPokerStats(
            players = len(self.avatars),
            hands = hands,
            bytesin = UGAMEProtocol._stats_read,
            bytesout = UGAMEProtocol._stats_write,
            )

    def createAvatar(self):
        avatar = pokeravatar.PokerAvatar(self)
        self.avatars.append(avatar)
        return avatar

    def forceAvatarDestroy(self, avatar):
        reactor.callLater(1, self.destroyAvatar, avatar)

    def destroyAvatar(self, avatar):
        if avatar in self.avatars:
            self.avatars.remove(avatar)
        else:
            self.error("avatar %s is not in the list of known avatars" % str(avatar))
        if avatar in self.monitors:
            self.monitors.remove(avatar)
        avatar.connectionLost("Disconnected")

    def sessionStart(self, serial, ip):
        if self.verbose > 2:
            self.message("sessionStart(%d, %s): " % ( serial, ip ))
        cursor = self.db.cursor()
        sql = "insert into session ( user_serial, started, ip ) values ( %d, %d, '%s')" % ( serial, seconds(), ip )
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("modified %d rows (expected 1): %s" % ( cursor.rowcount, sql ))
        cursor.close()
        return True

    def sessionEnd(self, serial):
        if self.verbose > 2:
            self.message("sessionEnd(%d): " % ( serial ))
        cursor = self.db.cursor()
        sql = "insert into session_history ( user_serial, started, ended, ip ) select user_serial, started, %d, ip from session where user_serial = %d" % ( seconds(), serial )
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("a) modified %d rows (expected 1): %s" % ( cursor.rowcount, sql ))
        sql = "delete from session where user_serial = %d" % serial
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("b) modified %d rows (expected 1): %s" % ( cursor.rowcount, sql ))
        cursor.close()
        return True

    def auth(self, name, password, roles):
        ( info, reason ) = self.poker_auth.auth(name, password)
        if info:
            self.autorefill(info[0])
        return ( info, reason )

    def autorefill(self, serial):
        if not self.refill:
            return
        user_info = self.getUserInfo(serial)
        if user_info.money.has_key(int(self.refill['serial'])):
            money = user_info.money[int(self.refill['serial'])]
            missing = int(self.refill['amount']) - ( int(money[0]) + int(money[1]) )
            if missing > 0:
                refill = int(money[0]) + missing
            else:
                refill = 0
        else:
            refill = int(self.refill['amount'])
        if refill > 0:
            self.db.db.query("REPLACE INTO user2money (user_serial, currency_serial, amount) values (%d, %s, %s)" % ( serial, self.refill['serial'], refill))
            self.databaseEvent(event = PacketPokerMonitorEvent.REFILL, param1 = serial, param2 = int(self.refill['serial']), param3 = refill)

        return refill

    def updateTourneysSchedule(self):
        if self.verbose > 3:
            self.message("updateTourneysSchedule")
        cursor = self.db.cursor(DictCursor)

        sql = ( " SELECT * FROM tourneys_schedule WHERE " +
                "          active = 'y' AND " +
                "          resthost_serial = %s") % self.db.literal(self.resthost_serial)

        cursor.execute(sql)
        result = cursor.fetchall()
        self.tourneys_schedule = dict(zip(map(lambda schedule: schedule['serial'], result), result))
        cursor.close()
        self.checkTourneysSchedule()
        self.cancelTimer('updateTourney')
        self.timer['updateTourney'] = reactor.callLater(UPDATE_TOURNEYS_SCHEDULE_DELAY, self.updateTourneysSchedule)

    def checkTourneysSchedule(self):
        if self.verbose > 3:
            self.message("checkTourneysSchedule")
        now = seconds()
        #
        # Cancel sng that stayed in registering state for too long
        #
        for tourney in filter(lambda tourney: tourney.sit_n_go == 'y', self.tourneys.values()):
            if now - tourney.register_time > self.sng_timeout:
                tourney.changeState(TOURNAMENT_STATE_CANCELED)
        #
        # Respawning tournaments
        #
        # (re)spawn tournaments that are not currently in play.
        #
        for schedule in filter(lambda schedule: schedule['respawn'] == 'y', self.tourneys_schedule.values()):
            schedule_serial = schedule['serial']
            if (not self.schedule2tourneys.has_key(schedule_serial)
                or all((tourney.state == TOURNAMENT_STATE_COMPLETE or
                       tourney.state == TOURNAMENT_STATE_CANCELED for tourney in
                       self.schedule2tourneys[schedule_serial]))):
                current_timestamp = int(seconds())
                respawn_interval = int(schedule['respawn_interval'])
                old_register_time = int(schedule['register_time'])
                old_start_time = int(schedule['start_time'])
                if respawn_interval == 0:
                    new_register_time = current_timestamp
                else:
                    new_register_time = old_register_time
                    while new_register_time < current_timestamp:
                        new_register_time += respawn_interval
                schedule['start_time'] = (new_register_time +
                                          (old_start_time - old_register_time))
                schedule['register_time'] = new_register_time
                self.spawnTourney(schedule)
        #
        # One time tournaments
        #
        for schedule in filter(lambda schedule: schedule['respawn'] == 'n', self.tourneys_schedule.values()):
            del self.tourneys_schedule[ schedule['serial'] ]
            self.spawnTourney(schedule)

        #
        # Update tournaments with time clock
        #
        for tourney in filter(lambda tourney: tourney.sit_n_go == 'n', self.tourneys.values()):
            tourney.updateRunning()
        #
        # Update announced tournaments to registering
        #
        for tourney in filter(lambda tourney:
                              tourney.state == TOURNAMENT_STATE_ANNOUNCED,
                              self.tourneys.values()):
            tourney.updateRegistering()
        #
        # Forget about old tournaments
        #
        for tourney in filter(lambda tourney: tourney.state in ( TOURNAMENT_STATE_COMPLETE,  TOURNAMENT_STATE_CANCELED ), self.tourneys.values()):
            if now - tourney.finish_time > DELETE_OLD_TOURNEYS_DELAY:
                self.deleteTourney(tourney)

        self.cancelTimer('checkTourney')
        self.timer['checkTourney'] = reactor.callLater(CHECK_TOURNEYS_SCHEDULE_DELAY, self.checkTourneysSchedule)

    def today(self):
        return date.today()

    def spawnTourney(self, schedule):
        currency_from_date_format_regexp = '(%[dHIjmMSUwWyY])+'
        #
        # buy-in currency
        #
        currency_serial = schedule['currency_serial']
        currency_serial_from_date_format = schedule['currency_serial_from_date_format']
        if currency_serial_from_date_format:
            if not re.match(currency_from_date_format_regexp, currency_serial_from_date_format):
                raise UserWarning, "tourney_schedule.currency_serial_from_date_format format string %s does not match %s" % ( currency_serial_from_date_format, currency_from_date_format_regexp )
            currency_serial = long(self.today().strftime(currency_serial_from_date_format))
        #
        # prize pool currency
        #
        prize_currency = schedule['prize_currency']
        prize_currency_from_date_format = schedule['prize_currency_from_date_format']
        if prize_currency_from_date_format:
            if not re.match(currency_from_date_format_regexp, prize_currency_from_date_format):
                raise UserWarning, "tourney_schedule.prize_currency_from_date_format format string %s does not match %s" % ( prize_currency_from_date_format, currency_from_date_format_regexp )
            prize_currency = long(self.today().strftime(prize_currency_from_date_format))
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO tourneys "
                       " (resthost_serial, schedule_serial, name, description_short, description_long, players_quota, players_min, variant, betting_structure, seats_per_game, player_timeout, currency_serial, prize_currency, prize_min, bailor_serial, buy_in, rake, sit_n_go, breaks_first, breaks_interval, breaks_duration, rebuy_delay, add_on, add_on_delay, start_time, via_satellite, satellite_of, satellite_player_count)"
                       " VALUES "
                       " (%s,              %s,              %s,   %s,                %s,               %s,            %s,          %s,      %s,                %s,             %s,             %s,              %s,             %s,        %s,            %s,     %s,   %s,       %s,           %s,              %s,              %s,          %s,     %s,           %s,         %s,            %s,           %s )",
                       ( schedule['resthost_serial'],
                         schedule['serial'],
                         schedule['name'],
                         schedule['description_short'],
                         schedule['description_long'],
                         schedule['players_quota'],
                         schedule['players_min'],
                         schedule['variant'],
                         schedule['betting_structure'],
                         schedule['seats_per_game'],
                         schedule['player_timeout'],
                         currency_serial,
                         prize_currency,
                         schedule['prize_min'],
                         schedule['bailor_serial'],
                         schedule['buy_in'],
                         schedule['rake'],
                         schedule['sit_n_go'],
                         schedule['breaks_first'],
                         schedule['breaks_interval'],
                         schedule['breaks_duration'],
                         schedule['rebuy_delay'],
                         schedule['add_on'],
                         schedule['add_on_delay'],
                         schedule['start_time'],
                         schedule['via_satellite'],
                         schedule['satellite_of'],
                         schedule['satellite_player_count']) )
        if self.verbose > 2:
            self.message("spawnTourney: " + str(schedule))
        #
        # Accomodate with MySQLdb versions < 1.1
        #
        if hasattr(cursor, "lastrowid"):
            tourney_serial = cursor.lastrowid
        else:
            tourney_serial = cursor.insert_id()
        if schedule['respawn'] == 'n':
            cursor.execute("UPDATE tourneys_schedule SET active = 'n' WHERE serial = %s" % schedule['serial'])
        else:
            cursor.execute("UPDATE tourneys_schedule SET register_time = %s, "
                           "start_time = %s WHERE serial = %s",
                           (schedule['register_time'], schedule['start_time'],
                            schedule['serial']))
        cursor.execute("REPLACE INTO route VALUES (0,%s,%s,%s)", ( tourney_serial, int(seconds()), self.resthost_serial))
        cursor.close()
        self.spawnTourneyInCore(schedule, tourney_serial, schedule['serial'], currency_serial, prize_currency)

    def spawnTourneyInCore(self, tourney_map, tourney_serial, schedule_serial, currency_serial, prize_currency):
        tourney_map['start_time'] = int(tourney_map['start_time'])
        tourney_map['register_time'] = int(tourney_map.get('register_time',
                                                           int(seconds()) - 1))
        tourney = PokerTournament(dirs = self.dirs, **tourney_map)
        tourney.serial = tourney_serial
        tourney.verbose = self.verbose
        tourney.schedule_serial = schedule_serial
        tourney.currency_serial = currency_serial
        tourney.prize_currency = prize_currency
        tourney.bailor_serial = tourney_map['bailor_serial']
        tourney.player_timeout = int(tourney_map['player_timeout'])
        tourney.via_satellite = int(tourney_map['via_satellite'])
        tourney.satellite_of = int(tourney_map['satellite_of'])
        tourney.satellite_of, reason = self.tourneySatelliteLookup(tourney)
        tourney.satellite_player_count = int(tourney_map['satellite_player_count'])
        tourney.satellite_registrations = []
        tourney.callback_new_state = self.tourneyNewState
        tourney.callback_create_game = self.tourneyCreateTable
        tourney.callback_game_filled = self.tourneyGameFilled
        tourney.callback_destroy_game = self.tourneyDestroyGame
        tourney.callback_move_player = self.tourneyMovePlayer
        tourney.callback_remove_player = self.tourneyRemovePlayer
        tourney.callback_cancel = self.tourneyCancel
        if not self.schedule2tourneys.has_key(schedule_serial):
            self.schedule2tourneys[schedule_serial] = []
        self.schedule2tourneys[schedule_serial].append(tourney)
        self.tourneys[tourney.serial] = tourney

        # Allow PokerTournament finalize init procedure.
        tourney.finalize()

        return tourney

    def deleteTourney(self, tourney):
        if self.verbose > 2:
            self.message("deleteTourney: %d" % tourney.serial)
        self.schedule2tourneys[tourney.schedule_serial].remove(tourney)
        if len(self.schedule2tourneys[tourney.schedule_serial]) <= 0:
            del self.schedule2tourneys[tourney.schedule_serial]
        del self.tourneys[tourney.serial]

    def tourneyResumeAndDeal(self, tourney):
        self.tourneyBreakResume(tourney)
        self.tourneyDeal(tourney)

    def tourneyNewState(self, tourney, old_state, new_state):
        cursor = self.db.cursor()
        updates = [ "state = '" + new_state + "'" ]
        if old_state != TOURNAMENT_STATE_BREAK and new_state == TOURNAMENT_STATE_RUNNING:
            updates.append("start_time = %d" % tourney.start_time)
        sql = "update tourneys set " + ", ".join(updates) + " where serial = " + str(tourney.serial)
        if self.verbose > 2:
            self.message("tourneyNewState: " + sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
        cursor.close()
        if new_state == TOURNAMENT_STATE_BREAK:
            # When we are entering BREAK state for the first time, which
            # should only occur here in the state change operation, we
            # send the PacketPokerTableTourneyBreakBegin.  Note that this
            # code is here and not in tourneyBreakCheck() because that
            # function is called over and over again, until the break
            # finishes.  Note that tourneyBreakCheck() also sends a
            # PacketPokerGameMessage() with the time remaining, too.
            secsLeft = tourney.remainingBreakSeconds()
            if secsLeft == None:
                # eek, should I really be digging down into tourney's
                # member variables in this next assignment?
                secsLeft = tourney.breaks_duration
            resumeTime = seconds() + secsLeft
            for gameId in map(lambda game: game.id, tourney.games):
                table = self.getTable(gameId)
                table.broadcast(PacketPokerTableTourneyBreakBegin(game_id = gameId, resume_time = resumeTime))
            self.tourneyBreakCheck(tourney)
        elif old_state == TOURNAMENT_STATE_BREAK and new_state == TOURNAMENT_STATE_RUNNING:
            wait = int(self.delays.get('extra_wait_tourney_break', 0))
            if wait > 0:
                reactor.callLater(wait, self.tourneyResumeAndDeal, tourney)
            else:
                self.tourneyResumeAndDeal(tourney)
        elif old_state == TOURNAMENT_STATE_REGISTERING and new_state == TOURNAMENT_STATE_RUNNING:
            reactor.callLater(0.01, self.tourneyBroadcastStart, tourney.serial)
            # Only obey extra_wait_tourney_start if we had been registering and are now running,
            # since we only want this behavior before the first deal.
            wait = int(self.delays.get('extra_wait_tourney_start', 0))
            if wait > 0:
                reactor.callLater(wait, self.tourneyDeal, tourney)
            else:
                self.tourneyDeal(tourney)
        elif new_state == TOURNAMENT_STATE_RUNNING:
            self.tourneyDeal(tourney)
        elif new_state == TOURNAMENT_STATE_BREAK_WAIT:
            self.tourneyBreakWait(tourney)

    def tourneyBreakCheck(self, tourney):
        key = 'tourney_breaks_%d' % id(tourney)
        self.cancelTimer(key)
        tourney.updateBreak()
        if tourney.state == TOURNAMENT_STATE_BREAK:
            remaining = tourney.remainingBreakSeconds()
            if remaining < 60:
                remaining = "less than a minute"
            elif remaining < 120:
                remaining = "one minute"
            else:
                remaining = "%d minutes" % int(remaining / 60)
            for game_id in map(lambda game: game.id, tourney.games):
                table = self.getTable(game_id)
                table.broadcastMessage(PacketPokerGameMessage, "Tournament is now on break for " + remaining)

            self.timer[key] = reactor.callLater(int(self.delays.get('breaks_check', 30)), self.tourneyBreakCheck, tourney)

    def tourneyDeal(self, tourney):
        for game_id in map(lambda game: game.id, tourney.games):
            table = self.getTable(game_id)
            table.scheduleAutoDeal()

    def tourneyBreakWait(self, tourney):
        for game_id in map(lambda game: game.id, tourney.games):
            table = self.getTable(game_id)
            if table.game.isRunning():
                table.broadcastMessage(PacketPokerGameMessage, "Tournament break at the end of the hand")
            else:
                table.broadcastMessage(PacketPokerGameMessage, "Tournament break will start when the other tables finish their hand")

    def tourneyBreakResume(self, tourney):
        for gameId in map(lambda game: game.id, tourney.games):
            table = self.getTable(gameId)
            table.broadcastMessage(PacketPokerGameMessage, "Tournament resumes")
            table.broadcast(PacketPokerTableTourneyBreakDone(game_id = gameId))

    def tourneyEndTurn(self, tourney, game_id):
        if not tourney.endTurn(game_id):
            self.tourneyFinished(tourney)
            self.tourneySatelliteWaitingList(tourney)


    def tourneyFinished(self, tourney):
        prizes = tourney.prizes()
        winners = tourney.winners[:len(prizes)]
        cursor = self.db.cursor()
        #
        # If prize_currency is non zero, use it instead of currency_serial
        #
        if tourney.prize_currency > 0:
            prize_currency = tourney.prize_currency
        else:
            prize_currency = tourney.currency_serial
        #
        # Guaranteed prize pool is withdrawn from a given account if and only if
        # the buy in of the players is not enough.
        #
        bail = tourney.prize_min - ( tourney.buy_in * tourney.registered )
        if bail > 0 and tourney.bailor_serial > 0:
            sql = ( "UPDATE user2money SET amount = amount - " + str(bail) + " WHERE " +
                    "       user_serial = " + str(tourney.bailor_serial) + " AND " +
                    "       currency_serial = " + str(prize_currency) + " AND " +
                    "       amount >= " + str(bail) )
            if self.verbose > 2:
                self.message("tourneyFinished: bailor pays " + sql)
            cursor.execute(sql)
            if cursor.rowcount != 1:
                self.error("tourneyFinished: bailor failed to provide requested money modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
                cursor.close()
                return False

        while prizes:
            prize = prizes.pop(0)
            serial = winners.pop(0)
            if prize <= 0:
                continue
            sql = "UPDATE user2money SET amount = amount + " + str(prize) + " WHERE user_serial = " + str(serial) + " AND currency_serial = " + str(prize_currency)
            if self.verbose > 2:
                self.message("tourneyFinished: " + sql)
            cursor.execute(sql)
            if cursor.rowcount == 0:
                sql = ( "INSERT INTO user2money (user_serial, currency_serial, amount) VALUES (%d, %d, %d)" %
                        ( serial, prize_currency, prize ) )
                if self.verbose > 2:
                    self.message("tourneyFinished: " + sql)
                cursor.execute(sql)
            self.databaseEvent(event = PacketPokerMonitorEvent.PRIZE, param1 = serial, param2 = prize_currency, param3 = prize)

        #added the following so that it wont break tests where the tournament mockup doesn't contain a finish_time
        if not hasattr(tourney, "finish_time"):
            tourney.finish_time = seconds()
        cursor.execute("UPDATE tourneys SET finish_time = %d WHERE serial = %s" % (tourney.finish_time, tourney.serial))
        cursor.close()
        self.databaseEvent(event = PacketPokerMonitorEvent.TOURNEY, param1 = tourney.serial)
        self.tourneyDeleteRoute(tourney)
        return True

    def tourneyDeleteRoute(self, tourney):
        key = 'tourney_delete_route_%d' % id(tourney)
        wait = int(self.delays.get('extra_wait_tourney_finish', 0))
        def doTourneyDeleteRoute():
            self.cancelTimer(key)
            for serial in tourney.players:
                for player in self.avatar_collection.get(serial):
                    if tourney.serial in player.tourneys:
                        player.tourneys.remove(tourney.serial)
            self.tourneyDeleteRouteActual(tourney.serial)
        self.timer[key] = reactor.callLater(max(self._ping_delay*2, wait*2), doTourneyDeleteRoute)

    def tourneyDeleteRouteActual(self, tourney_serial):
        cursor = self.db.cursor()
        cursor.execute("DELETE FROM route WHERE tourney_serial = %s", tourney_serial)
        cursor.close()

    def tourneyGameFilled(self, tourney, game):
        table = self.getTable(game.id)
        cursor = self.db.cursor()
        for player in game.playersAll():
            serial = player.serial
            player.setUserData(pokeravatar.DEFAULT_PLAYER_USER_DATA.copy())
            avatars = self.avatar_collection.get(serial)
            if avatars:
                if self.verbose > 2:
                    self.message("tourneyGameFilled: player %d connected" % serial)
                table.avatar_collection.set(serial, avatars)
            else:
                if self.verbose > 2:
                    self.message("tourneyGameFilled: player %d disconnected" % serial)
            self.seatPlayer(serial, game.id, game.buyIn(serial))

            for avatar in avatars:
                # First, force a count increase, since this player will
                # now be at the table, but table.joinPlayer() was never
                # called (which is where the increase usually happens).
                self.joinedCountIncrease()
                avatar.join(table, reason = PacketPokerTable.REASON_TOURNEY_START)
            sql = "update user2tourney set table_serial = %d where user_serial = %d and tourney_serial = %d" % ( game.id, serial, tourney.serial )
            if self.verbose > 4:
                self.message("tourneyGameFilled: " + sql)
            cursor.execute(sql)
            if cursor.rowcount != 1:
                self.error("modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
        cursor.close()
        table.update()

    def tourneyCreateTable(self, tourney):
        table = self.createTable(0, { 'name': tourney.name + str(self.tourney_table_serial),
                                      'variant': tourney.variant,
                                      'betting_structure': tourney.betting_structure,
                                      'seats': tourney.seats_per_game,
                                      'currency_serial': 0,
                                      'player_timeout': tourney.player_timeout,
                                      'transient': True,
                                      'tourney': tourney,
                                      })
        self.tourney_table_serial += 1
        table.timeout_policy = "fold"
        return table.game

    def tourneyDestroyGameActual(self, game):
        table = self.getTable(game.id)
        table.destroy()

    def tourneyDestroyGame(self, tourney, game):
        wait = int(self.delays.get('extra_wait_tourney_finish', 0))
        if wait > 0:
            reactor.callLater(wait, self.tourneyDestroyGameActual, game)
        else:
            self.tourneyDestroyGameActual(game)

    def tourneyMovePlayer(self, tourney, from_game_id, to_game_id, serial):
        from_table = self.getTable(from_game_id)
        from_table.movePlayer(from_table.avatar_collection.get(serial), serial,
                        to_game_id, reason = PacketPokerTable.REASON_TOURNEY_MOVE)
        cursor = self.db.cursor()
        sql = "UPDATE user2tourney SET table_serial = %d WHERE user_serial = %d AND tourney_serial = %d" % ( to_game_id, serial, tourney.serial )
        if self.verbose > 4:
            self.message("tourneyMovePlayer: " + sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.message("modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
            return False
        cursor.close()
        return True

    def tourneyRemovePlayer(self, tourney, game_id, serial):
        #
        # Inform the player about its position and prize
        #
        prizes = tourney.prizes()
        rank = tourney.getRank(serial)
        money = 0
        players = len(tourney.players)
        if rank-1 < len(prizes):
            money = prizes[rank-1]

        avatars = self.avatar_collection.get(serial)
        if avatars:
            packet = PacketPokerTourneyRank(serial = tourney.serial,
                                            game_id = game_id,
                                            players = players,
                                            rank = rank,
                                            money = money)
            for avatar in avatars:
                avatar.sendPacketVerbose(packet)
        table = self.getTable(game_id)
        table.kickPlayer(serial)
        cursor = self.db.cursor()
        sql = "UPDATE user2tourney SET rank = %d, table_serial = -1 WHERE user_serial = %d AND tourney_serial = %d" % ( rank, serial, tourney.serial )
        if self.verbose > 4:
            self.message("tourneyRemovePlayer: " + sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
        cursor.close()
        self.tourneySatelliteSelectPlayer(tourney, serial, rank)

    def tourneySatelliteLookup(self, tourney):
        if tourney.satellite_of == 0:
            return ( 0, None )
        found = None
        for candidate in self.tourneys.values():
            if candidate.schedule_serial == tourney.satellite_of:
                found = candidate
                break
        if found:
            if found.state != TOURNAMENT_STATE_REGISTERING:
                self.error("tourney %d is a satellite of %d but %d is in state %s instead of the expected state %s" %
                           ( tourney.serial, found.schedule_serial, found.schedule_serial, found.state, TOURNAMENT_STATE_REGISTERING) )
                return ( 0, TOURNAMENT_STATE_REGISTERING )
            return ( found.serial, None )
        else:
            return ( 0, False )

    def tourneySatelliteSelectPlayer(self, tourney, serial, rank):
        if tourney.satellite_of == 0:
            return False
        if rank <= tourney.satellite_player_count:
            packet = PacketPokerTourneyRegister(serial = serial, game_id = tourney.satellite_of)
            if self.tourneyRegister(packet = packet, via_satellite = True):
                tourney.satellite_registrations.append(serial)
        return True

    def tourneySatelliteWaitingList(self, tourney):
        """If the satellite did not register enough players, presumably because of a registration error
         for some of the winners (for instance if they were already registered), register the remaining
         players with winners that are not in the top satellite_player_count."""
        if tourney.satellite_of == 0:
            return False
        registrations = tourney.satellite_player_count - len(tourney.satellite_registrations)
        if registrations <= 0:
            return False
        serials = filter(lambda serial: serial not in tourney.satellite_registrations, tourney.winners)
        for serial in serials:
            packet = PacketPokerTourneyRegister(serial = serial, game_id = tourney.satellite_of)
            if self.tourneyRegister(packet = packet, via_satellite = True):
                tourney.satellite_registrations.append(serial)
                registrations -= 1
                if registrations <= 0:
                    break
        return True

    def tourneyCreate(self, packet):
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO tourneys_schedule " +
                       " (resthost_serial, currency_serial, variant, betting_structure, seats_per_game, player_timeout, name, description_short, description_long, buy_in, players_quota) VALUES " +
                       " (%s             , %s             , %s     , %s               , %s            , %s            , %s  , %s               , %s             , %s    , %s)",
                       ( self.resthost_serial,
                         packet.currency_serial,
                         packet.variant,
                         packet.betting_structure,
                         packet.seats_per_game,
                         packet.player_timeout,
                         packet.name,
                         packet.description_short,
                         packet.description_long,
                         packet.buy_in,
                         len(packet.players)
                         ))
        schedule_serial = cursor.lastrowid
        cursor.close()
        self.updateTourneysSchedule()
        #
        # There can be only one tourney for this tourney_schedule because they are in
        # not respawned
        #
        tourney_serial = self.schedule2tourneys[schedule_serial][0].serial
        register_packet = PacketPokerTourneyRegister(game_id = tourney_serial)
        serial_failed = []
        for serial in packet.players:
            register_packet.serial = serial
            if not self.tourneyRegister(register_packet):
                serial_failed.append(serial)
        if len(serial_failed) > 0:
            return PacketPokerError(game_id = schedule_serial,
                                    serial = tourney_serial,
                                    other_type = PACKET_POKER_CREATE_TOURNEY,
                                    code = PacketPokerCreateTourney.REGISTRATION_FAILED,
                                    message = "registration failed for players %s in tourney %d" % ( str(serial_failed), tourney_serial ))
        else:
            return PacketAck()

    def tourneyBroadcastStart(self, tourney_serial):
        tourney_serial = str(tourney_serial)
        cursor = self.db.cursor(DictCursor)
        cursor.execute("SELECT * FROM resthost")
        for row in cursor.fetchall():
            self.getPage('http://' + row['host'] + ':' + str(row['port']) + '/TOURNEY_START?tourney_serial=' + tourney_serial)
        cursor.close()

    def tourneyNotifyStart(self, tourney_serial):
        manager = self.tourneyManager(tourney_serial)
        if manager.type != PACKET_POKER_TOURNEY_MANAGER:
            raise UserWarning, str(manager)
        user2properties = manager.user2properties
        def send(avatar):
            #
            # check again because the call is delayed and the user may have logged out
            # or the avatar may have been destroyed in the meantime
            #
            if avatar.isLogged() and avatar.explain:
                avatar.sendPacket(PacketPokerTourneyStart(tourney_serial = tourney_serial, table_serial = user2properties[str(avatar.getSerial())]['table_serial']))
        calls = []
        for avatars in self.avatar_collection.values():
            for avatar in avatars:
                if user2properties.has_key(str(avatar.getSerial())) and avatar.explain:
                    calls.append(reactor.callLater(0.01, send, avatar))
        return calls

    def tourneyManager(self, tourney_serial):
        packet = PacketPokerTourneyManager()
        packet.tourney_serial = tourney_serial
        cursor = self.db.cursor(DictCursor)
        cursor.execute("SELECT user_serial, table_serial, rank FROM user2tourney WHERE tourney_serial = %d" % tourney_serial)
        user2tourney = cursor.fetchall()

        table2serials = {}
        for row in user2tourney:
            table_serial = row['table_serial']
            if table_serial == None or table_serial == -1:
                continue
            if not table2serials.has_key(table_serial):
                table2serials[table_serial] = []
            table2serials[table_serial].append(row['user_serial'])
        packet.table2serials = table2serials
        user2money = {}
        if len(table2serials) > 0:
            cursor.execute("SELECT user_serial, money FROM user2table WHERE table_serial IN ( " + ",".join(map(lambda x: str(x), table2serials.keys())) + " )")
            for row in cursor.fetchall():
                user2money[row['user_serial']] = row['money']

        cursor.execute("SELECT user_serial, name FROM user2tourney, users WHERE user2tourney.tourney_serial = " + str(tourney_serial) + " AND user2tourney.user_serial = users.serial")
        user2name = dict((entry["user_serial"], entry["name"]) for entry in cursor.fetchall())

        cursor.execute("SELECT * FROM tourneys WHERE serial = " + str(tourney_serial));
        if cursor.rowcount > 1:
            # This would be a bizarre case; unlikely to happen, but worth
            # logging if it happens.
            self.message("tourneyManager: tourney_serial(%d) has more than one row in tourneys table, using first row returned" % tourney_serial)
        elif cursor.rowcount <= 0:
            # More likely to happen, so don't log it unless some verbosity
            # is requested.
            if self.verbose > 2:
                self.message("tourneyManager: tourney_serial(%d) requested not found in database, returning error packet" % tourney_serial)
                # Construct and return an error packet at this point.  I
                # considered whether it made more sense to return "None"
                # here and have avatar construct the Error packet, but it
                # seems other methods in pokerservice also construct error
                # packets already, so it seemed somewhat fitting.
                return PacketError(other_type = PACKET_POKER_GET_TOURNEY_MANAGER,
                                      code = PacketPokerGetTourneyManager.DOES_NOT_EXIST,
                                   message = "Tournament %d does not exist" % tourney_serial)
        # Now we know we can proceed with taking the first row returned in
        # the cursor; there is at least one there.
        packet.tourney = cursor.fetchone()
        packet.tourney["registered"] = len(user2tourney)
        packet.tourney["rank2prize"] = None
        if self.tourneys.has_key(tourney_serial):
            packet.tourney["rank2prize"] = self.tourneys[tourney_serial].prizes()
        else:
            if packet.tourney["sit_n_go"] == 'y':
                player_count = packet.tourney["players_quota"]
            else:
                player_count = packet.tourney["registered"]
            packet.tourney["rank2prize"] = pokerprizes.PokerPrizesTable(
                        buy_in_amount = packet.tourney['buy_in'],
                        guarantee_amount = packet.tourney['prize_min'],
                        player_count = player_count,
                        config_dirs = self.dirs).getPrizes()
        cursor.close()

        user2properties = {}
        for row in user2tourney:
            user_serial = row["user_serial"]
            money = user2money.has_key(user_serial) and user2money[user_serial] or -1
            user2properties[str(user_serial)] = {"name": user2name[user_serial],
                                                 "money": money,
                                                 "rank": row["rank"],
                                                 "table_serial": row["table_serial"]}
        packet.user2properties = user2properties

        return packet

    def tourneyPlayersList(self, tourney_serial):
        if not self.tourneys.has_key(tourney_serial):
            return PacketError(other_type = PACKET_POKER_TOURNEY_REGISTER,
                               code = PacketPokerTourneyRegister.DOES_NOT_EXIST,
                               message = "Tournament %d does not exist" % tourney_serial)
        tourney = self.tourneys[tourney_serial]
        players = map(lambda serial: ( self.getName(serial), -1, 0 ), tourney.players)
        return PacketPokerTourneyPlayersList(serial = tourney_serial,
                                             players = players)

    def tourneyStats(self):
        cursor = self.db.cursor()
        cursor.execute("SELECT COUNT(*) FROM tourneys WHERE state in ( %s, %s )", ( TOURNAMENT_STATE_RUNNING, TOURNAMENT_STATE_REGISTERING ))
        tourneys = int(cursor.fetchone()[0])
        cursor.execute("SELECT COUNT(*) FROM user2tourney WHERE rank = -1")
        players = int(cursor.fetchone()[0])
        cursor.close()
        return ( players, tourneys )

    def tourneySelect(self, string):
        cursor = self.db.cursor(DictCursor)
        criterion = split(string, "\t")
        tourney_sql = "SELECT tourneys.*,COUNT(user2tourney.user_serial) AS registered FROM tourneys LEFT JOIN(user2tourney) ON(tourneys.serial = user2tourney.tourney_serial) "
        tourney_sql += "WHERE (state != 'complete' OR (state = 'complete' AND finish_time > UNIX_TIMESTAMP(NOW() - INTERVAL %d HOUR))) " % self.remove_completed
        schedule_sql = "SELECT * FROM tourneys_schedule AS tourneys WHERE respawn = 'n' AND active = 'y'"
        sql = ''
        if len(criterion) > 1:
            ( currency_serial, type ) = criterion
            sit_n_go = type == 'sit_n_go' and 'y' or 'n'
            if currency_serial:
                sql += " AND tourneys.currency_serial = %s AND sit_n_go = '%s'" % (currency_serial, sit_n_go)
            else:
                sql += " AND sit_n_go = '%s'" % sit_n_go
        elif string != '':
            sql = " AND name = '%s'" % string
        tourney_sql += sql
        schedule_sql += sql
        tourney_sql += " GROUP BY tourneys.serial"
        cursor.execute(tourney_sql)
        result = cursor.fetchall()
        cursor.execute(schedule_sql)
        result += cursor.fetchall()
        cursor.close()
        return result

    def tourneySelectInfo(self, packet, tourneys):
        if self.tourney_select_info:
            return self.tourney_select_info(self, packet, tourneys)
        else:
            return None

    def tourneyRegister(self, packet, via_satellite = False):
        serial = packet.serial
        tourney_serial = packet.game_id
        avatars = self.avatar_collection.get(serial)

        if not self.tourneys.has_key(tourney_serial):
            error = PacketError(other_type = PACKET_POKER_TOURNEY_REGISTER,
                                code = PacketPokerTourneyRegister.DOES_NOT_EXIST,
                                message = "Tournament %d does not exist" % tourney_serial)
            if not via_satellite or self.verbose > 0:
                self.error(error)
            for avatar in avatars:
                avatar.sendPacketVerbose(error)
            return False
        tourney = self.tourneys[tourney_serial]

        if tourney.via_satellite and not via_satellite:
            error = PacketError(other_type = PACKET_POKER_TOURNEY_REGISTER,
                                code = PacketPokerTourneyRegister.VIA_SATELLITE,
                                message = "Player %d must register to %d via a satellite" % ( serial, tourney_serial ) )
            self.error(error)
            for avatar in avatars:
                avatar.sendPacketVerbose(error)
            return False

        if tourney.isRegistered(serial):
            error = PacketError(other_type = PACKET_POKER_TOURNEY_REGISTER,
                                code = PacketPokerTourneyRegister.ALREADY_REGISTERED,
                                message = "Player %d already registered in tournament %d " % ( serial, tourney_serial ) )
            self.error(error)
            for avatar in avatars:
                avatar.sendPacketVerbose(error)
            return False

        if not tourney.canRegister(serial):
            error = PacketError(other_type = PACKET_POKER_TOURNEY_REGISTER,
                                code = PacketPokerTourneyRegister.REGISTRATION_REFUSED,
                                message = "Registration refused in tournament %d " % tourney_serial)
            self.error(error)
            for avatar in avatars:
                avatar.sendPacketVerbose(error)
            return False

        cursor = self.db.cursor()
        #
        # Buy in
        #
        currency_serial = tourney.currency_serial or 0
        withdraw = tourney.buy_in + tourney.rake
        if withdraw > 0:
            sql = ( "UPDATE user2money SET amount = amount - " + str(withdraw) +
                    " WHERE user_serial = " + str(serial) + " AND " +
                    "       currency_serial = " + str(currency_serial) + " AND " +
                    "       amount >= " + str(withdraw)
                    )
            if self.verbose > 1:
                self.message("tourneyRegister: %s" % sql)
            cursor.execute(sql)
            if cursor.rowcount == 0:
                error = PacketError(other_type = PACKET_POKER_TOURNEY_REGISTER,
                                    code = PacketPokerTourneyRegister.NOT_ENOUGH_MONEY,
                                    message = "Not enough money to enter the tournament %d" % tourney_serial)
                for avatar in avatars:
                    avatar.sendPacketVerbose(error)
                self.error(error)
                return False
            if cursor.rowcount != 1:
                self.error("modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
                for avatar in avatars:
                    avatar.sendPacketVerbose(PacketError(other_type = PACKET_POKER_TOURNEY_REGISTER,
                                                         code = PacketPokerTourneyRegister.SERVER_ERROR,
                                                         message = "Server error"))
                return False
        self.databaseEvent(event = PacketPokerMonitorEvent.REGISTER, param1 = serial, param2 = currency_serial, param3 = withdraw)
        #
        # Register
        #
        sql = "INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, %d, %d)" % ( serial, currency_serial, tourney_serial )
        if self.verbose > 4:
            self.message("tourneyRegister: " + sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("insert %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
            cursor.close()
            for avatar in avatars:
                avatar.sendPacketVerbose(PacketError(other_type = PACKET_POKER_TOURNEY_REGISTER,
                                                     code = PacketPokerTourneyRegister.SERVER_ERROR,
                                                     message = "Server error"))
            return False
        cursor.close()

        # notify success
        for avatar in avatars:
            avatar.sendPacketVerbose(packet)
        tourney.register(serial)
        return True

    def tourneyUnregister(self, packet):
        serial = packet.serial
        tourney_serial = packet.game_id
        if not self.tourneys.has_key(tourney_serial):
            return PacketError(other_type = PACKET_POKER_TOURNEY_UNREGISTER,
                               code = PacketPokerTourneyUnregister.DOES_NOT_EXIST,
                               message = "Tournament %d does not exist" % tourney_serial)
        tourney = self.tourneys[tourney_serial]

        if not tourney.isRegistered(serial):
            return PacketError(other_type = PACKET_POKER_TOURNEY_UNREGISTER,
                               code = PacketPokerTourneyUnregister.NOT_REGISTERED,
                               message = "Player %d is not registered in tournament %d " % ( serial, tourney_serial ) )

        if not tourney.canUnregister(serial):
            return PacketError(other_type = PACKET_POKER_TOURNEY_UNREGISTER,
                               code = PacketPokerTourneyUnregister.TOO_LATE,
                               message = "It is too late to unregister player %d from tournament %d " % ( serial, tourney_serial ) )

        cursor = self.db.cursor()
        #
        # Refund registration fees
        #
        currency_serial = tourney.currency_serial
        withdraw = tourney.buy_in + tourney.rake
        if withdraw > 0:
            sql = ( "UPDATE user2money SET amount = amount + " + str(withdraw) +
                    " WHERE user_serial = " + str(serial) + " AND " +
                    "       currency_serial = " + str(currency_serial) )
            if self.verbose > 1:
                self.message("tourneyUnregister: %s" % sql)
            cursor.execute(sql)
            if cursor.rowcount != 1:
                self.error("modified no rows (expected 1): %s " % sql)
                return PacketError(other_type = PACKET_POKER_TOURNEY_UNREGISTER,
                                   code = PacketPokerTourneyUnregister.SERVER_ERROR,
                                   message = "Server error : user_serial = %d and currency_serial = %d was not in user2money" % ( serial, currency_serial ))
            self.databaseEvent(event = PacketPokerMonitorEvent.UNREGISTER, param1 = serial, param2 = currency_serial, param3 = withdraw)
        #
        # Unregister
        #
        sql = "DELETE FROM user2tourney WHERE user_serial = %d AND tourney_serial = %d" % ( serial, tourney_serial )
        if self.verbose > 4:
            self.message("tourneyUnregister: " + sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("delete no rows (expected 1): %s " % sql)
            cursor.close()
            return PacketError(other_type = PACKET_POKER_TOURNEY_UNREGISTER,
                               code = PacketPokerTourneyUnregister.SERVER_ERROR,
                               message = "Server error : user_serial = %d and tourney_serial = %d was not in user2tourney" % ( serial, tourney_serial ))
        cursor.close()

        tourney.unregister(serial)

        return packet

    def tourneyCancel(self, tourney):
        if self.verbose > 1:
            self.message("tourneyCancel " + str(tourney.players))
        for serial in tourney.players:
            packet = self.tourneyUnregister(PacketPokerTourneyUnregister(game_id = tourney.serial,
                                                                         serial = serial))
            if packet.type == PACKET_ERROR:
                self.message("tourneyCancel: " + str(packet))

    def getHandSerial(self):
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO hands (description) VALUES ('[]')")
        #
        # Accomodate with MySQLdb versions < 1.1
        #
        if hasattr(cursor, "lastrowid"):
            serial = cursor.lastrowid
        else:
            serial = cursor.insert_id()
        cursor.close()
        return int(serial)

    def getHandHistory(self, hand_serial, serial):
        history = self.loadHand(hand_serial)

        if not history:
            return PacketPokerError(game_id = hand_serial,
                                    serial = serial,
                                    other_type = PACKET_POKER_HAND_HISTORY,
                                    code = PacketPokerHandHistory.NOT_FOUND,
                                    message = "Hand %d was not found in history of player %d" % ( hand_serial, serial ) )

        (type, level, hand_serial, hands_count, time, variant, betting_structure, player_list, dealer, serial2chips) = history[0]

        if serial not in player_list:
            return PacketPokerError(game_id = hand_serial,
                                    serial = serial,
                                    other_type = PACKET_POKER_HAND_HISTORY,
                                    code = PacketPokerHandHistory.FORBIDDEN,
                                    message = "Player %d did not participate in hand %d" % ( serial, hand_serial ) )

        serial2name = {}
        for player_serial in player_list:
            serial2name[player_serial] = self.getName(player_serial)
        #
        # Filter out the pocket cards that do not belong to player "serial"
        #
        for event in history:
            if event[0] == "round":
                (type, name, board, pockets) = event
                if pockets:
                    for (player_serial, pocket) in pockets.iteritems():
                        if player_serial != serial:
                            pocket.loseNotVisible()
            elif event[0] == "showdown":
                (type, board, pockets) = event
                if pockets:
                    for (player_serial, pocket) in pockets.iteritems():
                        if player_serial != serial:
                            pocket.loseNotVisible()

        return PacketPokerHandHistory(game_id = hand_serial,
                                      serial = serial,
                                      history = str(history),
                                      serial2name = str(serial2name))

    def loadHand(self, hand_serial):
        cursor = self.db.cursor()
        sql = ( "select description from hands where serial = " + str(hand_serial) )
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("loadHand(%d) expected one row got %d" % ( hand_serial, cursor.rowcount ))
            cursor.close()
            return None
        (description,) = cursor.fetchone()
        cursor.close()
        try:
            history = eval(description.replace("\r",""))
            return history
        except:
            self.error("loadHand(%d) eval failed for %s" % ( hand_serial, description ))
            print_exc()
            return None

    def saveHand(self, description, hand_serial):
        (type, level, hand_serial, hands_count, time, variant, betting_structure, player_list, dealer, serial2chips) = description[0]
        cursor = self.db.cursor()

        sql = ( "update hands set " +
                " description = %s "
                " where serial = " + str(hand_serial) )
        if self.verbose > 1:
            self.message("saveHand: %s" % ( sql % description ))
        cursor.execute(sql, str(description))
        if cursor.rowcount != 1 and cursor.rowcount != 0:
            self.error("modified %d rows (expected 1 or 0): %s " % ( cursor.rowcount, sql ))
            cursor.close()
            return

        sql = "insert into user2hand (user_serial, hand_serial) values "
        sql += ", ".join(map(lambda player_serial: "(%d, %d)" % ( player_serial, hand_serial ), player_list))
        if self.verbose > 1:
            self.message("saveHand: %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != len(player_list):
            self.error("inserted %d rows (expected exactly %d): %s " % ( cursor.rowcount, len(player_list), sql ))


        cursor.close()

    def listHands(self, sql_list, sql_total):
        cursor = self.db.cursor()
        if self.verbose > 1:
            self.message("listHands: " + sql_list + " " + sql_total)
        cursor.execute(sql_list)
        hands = cursor.fetchall()
        cursor.execute(sql_total)
        total = cursor.fetchone()[0]
        cursor.close()
        return (total, map(lambda x: x[0], hands))

    def eventTable(self, table):
        table_serial = table.game.id
        if table.tourney:
            tourney_serial = table.tourney.serial
        else:
            tourney_serial = 0
        cursor = self.db.cursor()
        cursor.execute("REPLACE INTO route VALUES (%s,%s,%s,%s)", ( table_serial, tourney_serial, int(seconds()), self.resthost_serial))
        cursor.close()

    def statsTables(self):
        cursor = self.db.cursor()
        cursor.execute("SELECT COUNT(*) FROM pokertables")
        tables = cursor.fetchone()[0]
        cursor.execute("SELECT COUNT(*) FROM user2table")
        players = cursor.fetchone()[0]
        cursor.close()
        return ( players, tables )

    def listTables(self, string, serial):
        """listTables() takes two arguments:

                 string : which is the ad-hoc query string for the tables
                          sought (described in detail below), and
                 serial : which is the user serial, used only when string == "my"

           The ad-hoc format of the query string deserves special
           documentation.  It works as follows:

               0. If string is the empty string, or excatly 'all', then
                  all tables in the system are returned.

               1. If string is 'my', then all tables that player identified
                  by the argument, 'serial', has joined are returned.

               2. If string (a) contains *no* TAB (\t) characters AND (b)
                  contains any non-numeric characters (aka is a string of
                  letters, optionally with numbers, with no tabs), then it
                  assumed to be a specific table name, and only table(s)
                  with the specific name exactly equal to the string are
                  returned.

               3. Otherwise, the string is interpreted as a tab-separated
                  group of criteria for selecting which tables to be
                  returned, which mimics the 'string' input given in a
                  PacketPokerTableSelect() (this method was written
                  primarily to service that packet).  Two rules to keep in
                  mind when constructing the string:

                     (a) If any field is the empty string (i.e., nothing
                         between the tab characters for that field), then
                         the given criterion is not used for table
                         selection.

                     (b) If the second field is left completely off (by
                         simply having fewer than the maximum tab
                         characters) are treated as if they were present
                         but empty strings (i.e., they are not used as a
                         criterion for table selection).

                     (c) Any additional fields are ignored, but an error
                         message is generated.

                  The tab-separated query string currently accepts two fields:
                         "currency_serial\tvariant"
           """
        # It appears to me that the original motivation for this \t
        # seperated format for string was that the string would front-load
        # with more commonly used criteria, and put less frequently used
        # ones further to the back.  Thus, the query string can be
        # effeciently constructed by callers.  During implementation of
        # the table-picker feature, I wrote the documentation above and I
        # heavily extended this method to account for additional criteria
        # that table-picker wanted to use.  dachary and I discussed a bit
        # whether it was better not to expand this method, but I felt it
        # was close enough that it was.  Our discussion happened on IRC
        # circa 2009-06-20 and following. -- bkuhn, 2009-06-20

        #  However, after additional debate and looking at the final
        #  implementation and tests, we discovered this whole approach was
        #  a mess, yielding the refactoring out of listTables() into its
        #  helper function, searchTables() -- bkuhn, 2009-07-03

        orderBy = " ORDER BY players desc, serial"
        criteria = split(string, "\t")
        cursor = self.db.cursor(DictCursor)
        if string == '' or string == 'all':
            cursor.execute("SELECT * FROM pokertables" + orderBy)
        elif string == 'my':
            cursor.execute("SELECT pokertables.* FROM pokertables,user2table WHERE pokertables.serial = user2table.table_serial AND user2table.user_serial = %s" + orderBy, serial)
        elif re.match("^[0-9]+$", string):
            cursor.execute("SELECT * FROM pokertables WHERE currency_serial = %s" + orderBy, string)
        elif len(criteria) > 1:
            # Next, unpack the various possibilities in the tab-separated
            # criteria, starting with everything set to None.  This is to
            # setup the defaults to be None when we call the helper
            # function.
            whereValues = { 'currency_serial' : None, 'variant' : None }
            if len(criteria) == 2:
                ( whereValues['currency_serial'], whereValues['variant'] ) = criteria
            else:
                self.error("Following listTables() criteria string has more parameters than expected, ignoring third one and beyond in: " + string)
                ( whereValues['currency_serial'], whereValues['variant'] ) = criteria[:2]
            # Next, do some minor format verification for those values that are
            # supposed to be integers.
            if whereValues['currency_serial'] != None and whereValues['currency_serial'] != '':
                if not re.match("^[0-9]+$", whereValues['currency_serial']):
                    self.error("listTables(): currency_serial parameter must be an integer, instead was: %s"
                               % whereValues['currency_serial'])
                    cursor.close()
                    return []
                else:
                    whereValues['currency_serial'] = int(whereValues['currency_serial'])
            cursor.close()
            return self.searchTables(whereValues['currency_serial'], whereValues['variant'], None, None)
        else:
            cursor.execute("SELECT * FROM pokertables WHERE name = %s", string)

        result = cursor.fetchall()
        cursor.close()
        return result

    def searchTables(self, currency_serial = None, variant = None, betting_structure = None, min_players = 0):
        """searchTables() returns a list of tables that match the criteria
        specified in the parameters.  Parameter requirements are:
            currency_serial:    must be a positive integer or None
            variant:            must be a string or None
            betting_structure:  must be a string or None
            min_players:        must be a non-negative integer

        Note that the 'min_players' criterion is a >= setting.  The rest
        are exactly = to setting.

        Note further that min_players and currency_serial *must be*
        integer values in decimal greater than 0.  (Also, if sent in equal
        to 0, no error will be generated, but it will be as if you didn't
        send them at all).

        Finally, the query is sorted such that tables with the most
        players are at the top of the list.  Note that other methods rely
        on this, so don't change it.  The secondary sorting key is the
        ascending table serial.
        """
        orderBy = " ORDER BY players desc, serial"
        whereValues = { 'currency_serial' : currency_serial, 'variant' : variant,
                        'betting_structure' : betting_structure, 'min_players' : min_players }
        cursor = self.db.cursor(DictCursor)
        # Now build the SQL statement we need.
        sql = "SELECT * FROM pokertables"
        sqlQuestionMarkParameterList = []
        startLen = len(sql)
        for (kk, vv) in whereValues.iteritems():
            if vv == None or vv == '' or (kk == 'currency_serial' and int(vv) == 0):
                # We skip any value that is was not given to us (is still
                # None), was entirely empty when it came in, or, in the
                # case of currency_serial, is 0, since a 0 currency_serial
                # is not valid.
                continue
            # Next, if we have an sql statement already from previous
            # iteration of this loop, add an "AND", otherwise, initialze
            # the sql string with the beginning of the SELECT statement.
            if len(sql) > startLen:
                sql += " AND "
            else:
                sql += " WHERE "
            # Next, we handle the fact that min_players is a >= parameter,
            # unlike the others which are = parameters.  Also, note here
            # that currency_serial and min_players are integer values.
            if kk == 'min_players':
                sql += " players >= " + "%s"
            else:
                sql += kk + " = " + "%s"
            sqlQuestionMarkParameterList.append(vv)

        sql += orderBy
        cursor.execute(sql, sqlQuestionMarkParameterList)
        result = cursor.fetchall()
        cursor.close()
        return result

    def setupResthost(self):
        resthost = self.settings.headerGetProperties("/server/resthost")
        if resthost:
            resthost = resthost[0]
            cursor = self.db.cursor()
            values = ( resthost['name'], resthost['host'], resthost['port'], resthost['path'] )
            cursor.execute("SELECT serial FROM resthost WHERE name = %s AND host = %s AND port = %s AND path = %s", values)
            if cursor.rowcount > 0:
                self.resthost_serial = cursor.fetchone()[0]
            else:
                cursor.execute("INSERT INTO resthost (name, host, port, path) VALUES (%s, %s, %s, %s)", values)
                self.resthost_serial = cursor.lastrowid
            cursor.execute("DELETE FROM route WHERE resthost_serial = %s", self.resthost_serial)
            cursor.close()

    def cleanupResthost(self):
        if self.resthost_serial:
            cursor = self.db.cursor()
            cursor.execute("DELETE FROM route WHERE resthost_serial = %s", self.resthost_serial)
            cursor.close()

    def packet2resthost(self, packet):
        #
        # game_id is only set for packets related to a table and not for
        # packets that are delegated but related to tournaments.
        #
        game_id = None
        cursor = self.db.cursor()
        if packet.type == PACKET_POKER_CREATE_TOURNEY:
            #
            # Look for the server with the less routes going to it
            #
            sql = "SELECT host, port, path FROM route,resthost WHERE route.resthost_serial = resthost.serial GROUP BY route.resthost_serial ORDER BY count(*) ASC LIMIT 1"
            if self.verbose > 2:
                self.message("packet2resthost: create tourney " + sql)
            cursor.execute(sql)
        else:
            if packet.type in ( PACKET_POKER_TOURNEY_REQUEST_PLAYERS_LIST, PACKET_POKER_TOURNEY_REGISTER, PACKET_POKER_TOURNEY_UNREGISTER ):
                where = "tourney_serial = " + str(packet.game_id)
            elif packet.type in ( PACKET_POKER_GET_TOURNEY_MANAGER, ):
                where = "tourney_serial = " + str(packet.tourney_serial)
            elif hasattr(packet, "game_id"):
                where = "table_serial = " + str(packet.game_id)
                game_id = packet.game_id
            else:
                cursor.close()
                return (None, None)

            cursor.execute("SELECT host, port, path FROM route,resthost " +
                           " WHERE route.resthost_serial = resthost.serial " +
                           #
                           # exclude the routes that go to this server
                           #
                           " AND resthost.serial != " + str(self.resthost_serial) +
                           " AND " + where)
        if cursor.rowcount > 0:
            result = cursor.fetchone()
        else:
            result = None
        cursor.close()
        return ( result, game_id )

    def cleanUp(self, temporary_users = ''):
        cursor = self.db.cursor()

        if len(temporary_users) > 2:
            sql = "delete session_history from session_history, users where session_history.user_serial = users.serial and users.name like '" + temporary_users + "%'"
            cursor.execute(sql)
            sql = "delete session from session, users where session.user_serial = users.serial and users.name like '" + temporary_users + "%'"
            cursor.execute(sql)
            sql = "DELETE FROM user2tourney USING user2tourney, users WHERE users.name like '" + temporary_users + "%' AND users.serial = user2tourney.user_serial"
            cursor.execute(sql)
            sql = "delete from users where name like '" + temporary_users + "%'"
            cursor.execute(sql)

        sql = "insert into session_history ( user_serial, started, ended, ip ) select user_serial, started, %d, ip from session" % seconds()
        cursor.execute(sql)
        sql = "delete from session"
        cursor.execute(sql)

        cursor.close()

    def cleanupTourneys(self):
        self.tourneys = {}
        self.schedule2tourneys = {}
        self.tourneys_schedule = {}

        cursor = self.db.cursor(DictCursor)
        #
        # Trash uncompleted tournaments and refund the buyin but keep the
        # tournaments that are 'complete' or 'registering'n.
        # Tournaments in the 'registering' state for which the start time
        # is in the past are trashed.
        # Sit and go tournaments in the 'registering' state are trashed.
        #
        sql = ( "SELECT * FROM tourneys WHERE " +
                " ( state NOT IN ( 'registering', 'complete' ) OR " +
                "   ( state = 'registering' AND " +
                "     ( sit_n_go = 'y' OR start_time < (%d + 60) ) " +
                "   ) " +
                " ) " +
                " AND resthost_serial = %d" ) % ( seconds(), self.resthost_serial )
        if self.verbose > 2:
            self.message("cleanupTourneys: " + sql)
        cursor.execute(sql)
        for x in xrange(cursor.rowcount):
            row = cursor.fetchone()
            withdraw = row['buy_in']
            cursor1 = self.db.cursor()
            if row['buy_in'] > 0:
                sql = ( "UPDATE user2money,user2tourney SET amount = amount + " + str(row['buy_in']) +
                        " WHERE user2tourney.user_serial = user2money.user_serial AND " +
                        "       user2money.currency_serial = " + str(row['currency_serial']) + " AND " +
                        "       user2tourney.tourney_serial = " + str(row['serial']) )
                if self.verbose > 1:
                    self.message("cleanupTourneys: %s" % sql)
                cursor1.execute(sql)
            sql = "DELETE FROM tourneys WHERE serial = %d" % row['serial']
            if self.verbose > 1:
                self.message("cleanupTourneys: %s" % sql)
            cursor1.execute(sql)
            sql = "DELETE FROM user2tourney WHERE tourney_serial = %d" % row['serial']
            if self.verbose > 1:
                self.message("cleanupTourneys: %s" % sql)
            cursor1.execute(sql)
            cursor1.close()
        #
        # Restore tourney registrations after reboot
        #
        sql = ( "SELECT * FROM tourneys " +
                " WHERE " +
                "  state = 'registering' AND " +
                "  start_time > (%d + 60) AND " +
                "  resthost_serial = %d " ) % ( seconds(), self.resthost_serial )
        if self.verbose > 2:
            self.message("cleanupTourneys: " + sql)
        cursor.execute(sql)
        for x in xrange(cursor.rowcount):
            row = cursor.fetchone()
            if self.verbose >= 0: message = "cleanupTourneys: restoring %s(%s) with players" % ( row['name'], row['serial'],  )
            tourney = self.spawnTourneyInCore(row, row['serial'], row['schedule_serial'], row['currency_serial'], row['prize_currency'])
            cursor1 = self.db.cursor()
            sql = "SELECT user_serial FROM user2tourney WHERE tourney_serial = " + str(row['serial'])
            if self.verbose > 2:
                self.message("cleanupTourneys: " + sql)
            cursor1.execute(sql)
            for y in xrange(cursor1.rowcount):
                (serial,) = cursor1.fetchone()
                if self.verbose >= 0: message += " " + str(serial)
                tourney.register(serial)

            cursor1.execute(sql)
            cursor1.close()
            if self.verbose >= 0:
                self.message(message)
            cursor2 = self.db.cursor()
            cursor2.execute("REPLACE INTO route VALUES (0,%s,%s,%s)", ( row['serial'], int(seconds()), self.resthost_serial))
            cursor2.close()
        cursor.close()

    def getMoney(self, serial, currency_serial):
        cursor = self.db.cursor()
        sql = ( "SELECT amount FROM user2money " +
                "       WHERE user_serial = " + str(serial) + " AND " +
                "             currency_serial = "  + str(currency_serial) )
        if self.verbose:
            self.message(sql)
        cursor.execute(sql)
        if cursor.rowcount > 1:
            self.error("getMoney(%d) expected one row got %d" % ( serial, cursor.rowcount ))
            cursor.close()
            return 0
        elif cursor.rowcount == 1:
            (money,) = cursor.fetchone()
        else:
            money = 0
        cursor.close()
        return money

    def cashIn(self, packet):
        return self.cashier.cashIn(packet)

    def cashOut(self, packet):
        return self.cashier.cashOut(packet)

    def cashQuery(self, packet):
        return self.cashier.cashQuery(packet)

    def cashOutCommit(self, packet):
        count = self.cashier.cashOutCommit(packet)
        if count in (0, 1):
            return PacketAck()
        else:
            return PacketError(code = PacketPokerCashOutCommit.INVALID_TRANSACTION,
                               message = "transaction " + packet.transaction_id + " affected " + str(count) + " rows instead of zero or one",
                               other_type = PACKET_POKER_CASH_OUT_COMMIT)

    def getPlayerInfo(self, serial):
        placeholder = PacketPokerPlayerInfo(serial = serial,
                                            name = "anonymous",
                                            url= "random",
                                            outfit = "random",
                                            # FIXME_PokerPlayerInfoLocale:
                                            # (see also sr #2262 )
                                            # this sets locale but
                                            # PacketPokerPlayerInfo()
                                            # doesn't currently use locale
                                            # argument.  I am unsure why I
                                            # added this here (it was
                                            # probably me that added it).
                                            # It needs investigation.
                                            #  -- bkuhn
                                            locale = "en_US")
        if serial == 0:
            return placeholder

        cursor = self.db.cursor()
        sql = ( "select locale,name,skin_url,skin_outfit from users where serial = " + str(serial) )
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("getPlayerInfo(%d) expected one row got %d" % ( serial, cursor.rowcount ))
            return placeholder
        (locale,name,skin_url,skin_outfit) = cursor.fetchone()
        if skin_outfit == None:
            skin_outfit = "random"
        cursor.close()
        packet = PacketPokerPlayerInfo(serial = serial,
                                       name = name,
                                       url = skin_url,
                                       outfit = skin_outfit)
        # pokerservice generally provides playerInfo() internally to
        # methods like pokeravatar.(re)?login.  Since this is the central
        # internal location where the query occurs, we hack in the locale
        # returned from the DB.
        packet.locale = locale
        return packet

    def getPlayerPlaces(self, serial):
        cursor = self.db.cursor()
        cursor.execute("SELECT table_serial FROM user2table WHERE user_serial = %s", serial)
        tables = map(lambda x: x[0], cursor.fetchall())
        cursor.execute("SELECT user2tourney.tourney_serial FROM user2tourney,tourneys WHERE user2tourney.user_serial = %s AND user2tourney.tourney_serial = tourneys.serial AND (tourneys.state = 'registering' OR tourneys.state = 'running' OR tourneys.state = 'break' OR  tourneys.state = 'breakwait')", serial)
        tourneys = map(lambda x: x[0], cursor.fetchall())
        cursor.close()
        return PacketPokerPlayerPlaces(serial = serial,
                                       tables = tables,
                                       tourneys = tourneys)

    def getPlayerPlacesByName(self, name):
        cursor = self.db.cursor()
        cursor.execute("SELECT serial FROM users WHERE name = %s", name)
        serial = cursor.fetchone()
        if serial == None:
            return PacketError(other_type = PACKET_POKER_PLAYER_PLACES)
        else:
            serial = serial[0]
        return self.getPlayerPlaces(serial)

    def getUserInfo(self, serial):
        cursor = self.db.cursor(DictCursor)

        sql = ( "SELECT rating,affiliate,email,name FROM users WHERE serial = " + str(serial) )
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("getUserInfo(%d) expected one row got %d" % ( serial, cursor.rowcount ))
            return PacketPokerUserInfo(serial = serial)
        row = cursor.fetchone()
        if row['email'] == None: row['email'] = ""

        packet = PacketPokerUserInfo(serial = serial,
                                     name = row['name'],
                                     email = row['email'],
                                     rating = row['rating'],
                                     affiliate = row['affiliate'])
        sql = ( " SELECT user2money.currency_serial,user2money.amount,user2money.points,CAST(SUM(user2table.bet) + SUM(user2table.money) AS UNSIGNED) AS in_game "
                "        FROM user2money LEFT JOIN (pokertables,user2table) "
                "        ON (user2table.user_serial = user2money.user_serial  AND "
                "            user2table.table_serial = pokertables.serial AND  "
                "            user2money.currency_serial = pokertables.currency_serial)  "
                "        WHERE user2money.user_serial = " + str(serial) + " GROUP BY user2money.currency_serial " )
        if self.verbose:
            self.message(sql)
        cursor.execute(sql)
        for row in cursor:
            if not row['in_game']: row['in_game'] = 0
            if not row['points']: row['points'] = 0
            packet.money[row['currency_serial']] = ( row['amount'], row['in_game'], row['points'] )
        if self.verbose > 2:
            self.message("getUserInfo: " + str(packet))
        return packet

    def getPersonalInfo(self, serial):
        user_info = self.getUserInfo(serial)
        self.message("getPersonalInfo %s" % str(user_info))
        packet = PacketPokerPersonalInfo(serial = user_info.serial,
                                         name = user_info.name,
                                         email = user_info.email,
                                         rating = user_info.rating,
                                         affiliate = user_info.affiliate,
                                         money = user_info.money)
        cursor = self.db.cursor()
        sql = ( "SELECT firstname,lastname,addr_street,addr_street2,addr_zip,addr_town,addr_state,addr_country,phone,gender,birthdate FROM users_private WHERE serial = " + str(serial) )
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("getPersonalInfo(%d) expected one row got %d" % ( serial, cursor.rowcount ))
            return PacketPokerPersonalInfo(serial = serial)
        (packet.firstname, packet.lastname, packet.addr_street, packet.addr_street2, packet.addr_zip, packet.addr_town, packet.addr_state, packet.addr_country, packet.phone, packet.gender, packet.birthdate) = cursor.fetchone()
        cursor.close()
        if not packet.gender: packet.gender = ''
        if not packet.birthdate: packet.birthdate = ''
        packet.birthdate = str(packet.birthdate)
        return packet

    def setPersonalInfo(self, personal_info):
        cursor = self.db.cursor()
        sql = ( "UPDATE users_private SET "
                " firstname = '" + personal_info.firstname + "', "
                " lastname = '" + personal_info.lastname + "', "
                " addr_street = '" + personal_info.addr_street + "', "
                " addr_street2 = '" + personal_info.addr_street2 + "', "
                " addr_zip = '" + personal_info.addr_zip + "', "
                " addr_town = '" + personal_info.addr_town + "', "
                " addr_state = '" + personal_info.addr_state + "', "
                " addr_country = '" + personal_info.addr_country + "', "
                " phone = '" + personal_info.phone + "', "
                " gender = '" + personal_info.gender + "', "
                " birthdate = '" + personal_info.birthdate + "' "
                " WHERE serial = " + str(personal_info.serial) )
        if self.verbose > 1:
            self.message("setPersonalInfo: %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != 1 and cursor.rowcount != 0:
            self.error("setPersonalInfo: modified %d rows (expected 1 or 0): %s " % ( cursor.rowcount, sql ))
            return False
        else:
            return True

    def setAccount(self, packet):
        #
        # name constraints check
        #
        status = checkName(packet.name)
        if not status[0]:
            return PacketError(code = status[1],
                               message = status[2],
                               other_type = packet.type)
        #
        # Look for user
        #
        cursor = self.db.cursor()
        cursor.execute("SELECT serial FROM users WHERE name = '%s'" % packet.name)
        numrows = int(cursor.rowcount)
        #
        # password constraints check
        #
        if ( numrows == 0 or ( numrows > 0 and packet.password != "" )):
            status = checkPassword(packet.password)
            if not status[0]:
                return PacketError(code = status[1],
                                   message = status[2],
                                   other_type = packet.type)
        #
        # email constraints check
        #
        email_regexp = ".*.@.*\..*$"
        if not re.match(email_regexp, packet.email):
            return PacketError(code = PacketPokerSetAccount.INVALID_EMAIL,
                               message = "email %s does not match %s " % ( packet.email, email_regexp ),
                               other_type = packet.type)
        if numrows == 0:
            cursor.execute("SELECT serial FROM users WHERE email = '%s' " % packet.email)
            numrows = int(cursor.rowcount)
            if numrows > 0:
                return PacketError(code = PacketPokerSetAccount.EMAIL_ALREADY_EXISTS,
                                   message = "there already is another account with the email %s" % packet.email,
                                   other_type = packet.type)
            #
            # User does not exists, create it
            #
            sql = "INSERT INTO users (created, name, password, email, affiliate) values (%d, '%s', '%s', '%s', '%d')" % (seconds(), packet.name, packet.password, packet.email, packet.affiliate)
            cursor.execute(sql)
            if cursor.rowcount != 1:
                #
                # Impossible except for a sudden database corruption, because of the
                # above SQL statements
                #
                self.error("setAccount: insert %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
                return PacketError(code = PacketPokerSetAccount.SERVER_ERROR,
                                   message = "inserted %d rows (expected 1)" % cursor.rowcount,
                                   other_type = packet.type)
            #
            # Accomodate for MySQLdb versions < 1.1
            #
            if hasattr(cursor, "lastrowid"):
                packet.serial = cursor.lastrowid
            else:
                packet.serial = cursor.insert_id()
            cursor.execute("INSERT INTO users_private (serial) VALUES ('%d')" % packet.serial)
        else:
            #
            # User exists, update name, password and email
            #
            (serial,) = cursor.fetchone()
            if serial != packet.serial:
                return PacketError(code = PacketPokerSetAccount.NAME_ALREADY_EXISTS,
                                   message = "user name %s already exists" % packet.name,
                                   other_type = packet.type)
            cursor.execute("SELECT serial FROM users WHERE email = '%s' and serial != %d" % ( packet.email, serial ))
            numrows = int(cursor.rowcount)
            if numrows > 0:
                return PacketError(code = PacketPokerSetAccount.EMAIL_ALREADY_EXISTS,
                                   message = "there already is another account with the email %s" % packet.email,
                                   other_type = packet.type)
            set_password = packet.password and ", password = '" + packet.password + "' " or ""
            sql = ( "UPDATE users SET "
                    " name = '" + packet.name + "', "
                    " email = '" + packet.email + "' " +
                    set_password +
                    " WHERE serial = " + str(packet.serial) )
            if self.verbose > 1:
                self.message("setAccount: %s" % sql)
            cursor.execute(sql)
            if cursor.rowcount != 1 and cursor.rowcount != 0:
                self.error("setAccount: modified %d rows (expected 1 or 0): %s " % ( cursor.rowcount, sql ))
                return PacketError(code = PacketPokerSetAccount.SERVER_ERROR,
                                   message = "modified %d rows (expected 1 or 0)" % cursor.rowcount,
                                   other_type = packet.type)
        #
        # Set personal information
        #
        if not self.setPersonalInfo(packet):
                return PacketError(code = PacketPokerSetAccount.SERVER_ERROR,
                                   message = "unable to set personal information",
                                   other_type = packet.type)
        return self.getPersonalInfo(packet.serial)

    def setPlayerInfo(self, player_info):
        cursor = self.db.cursor()
        sql = ( "update users set "
                " name = '" + player_info.name + "', "
                " skin_url = '" + player_info.url + "', "
                " skin_outfit = '" + player_info.outfit + "' "
                " where serial = " + str(player_info.serial) )
        if self.verbose > 1:
            self.message("setPlayerInfo: %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != 1 and cursor.rowcount != 0:
            self.error("setPlayerInfo: modified %d rows (expected 1 or 0): %s " % ( cursor.rowcount, sql ))
            return False
        return True


    def getPlayerImage(self, serial):
        placeholder = PacketPokerPlayerImage(serial = serial)

        if serial == 0:
            return placeholder

        cursor = self.db.cursor()
        sql = ( "select skin_image,skin_image_type from users where serial = " + str(serial) )
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("getPlayerImage(%d) expected one row got %d" % ( serial, cursor.rowcount ))
            return placeholder
        (skin_image, skin_image_type) = cursor.fetchone()
        if skin_image == None:
            skin_image = ""
        cursor.close()
        return PacketPokerPlayerImage(serial = serial,
                                      image = skin_image,
                                      image_type = skin_image_type)

    def setPlayerImage(self, player_image):
        cursor = self.db.cursor()
        sql = ( "update users set "
                " skin_image = '" + player_image.image + "', "
                " skin_image_type = '" + player_image.image_type + "' "
                " where serial = " + str(player_image.serial) )
        if self.verbose > 1:
            self.message("setPlayerInfo: %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != 1 and cursor.rowcount != 0:
            self.error("setPlayerImage: modified %d rows (expected 1 or 0): %s " % ( cursor.rowcount, sql ))
            return False
        return True

    def getName(self, serial):
        if serial == 0:
            return "anonymous"

        cursor = self.db.cursor()
        sql = ( "select name from users where serial = " + str(serial) )
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("getName(%d) expected one row got %d" % ( serial, cursor.rowcount ))
            return "UNKNOWN"
        (name,) = cursor.fetchone()
        cursor.close()
        return name

    def buyInPlayer(self, serial, table_id, currency_serial, amount):
        if amount == None:
            self.error("called buyInPlayer with None amount (expected > 0); denying buyin")
            return 0
        # unaccounted money is delivered regardless
        if not currency_serial: return amount

        withdraw = min(self.getMoney(serial, currency_serial), amount)
        cursor = self.db.cursor()
        sql = ( "UPDATE user2money,user2table SET "
                " user2table.money = user2table.money + " + str(withdraw) + ", "
                " user2money.amount = user2money.amount - " + str(withdraw) + " "
                " WHERE user2money.user_serial = " + str(serial) + " AND "
                "       user2money.currency_serial = " + str(currency_serial) + " AND "
                "       user2table.user_serial = " + str(serial) + " AND "
                "       user2table.table_serial = " + str(table_id) )
        if self.verbose > 1:
            self.message("buyInPlayer: %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != 0 and cursor.rowcount != 2:
            self.error("modified %d rows (expected 0 or 2): %s " % ( cursor.rowcount, sql ))
        self.databaseEvent(event = PacketPokerMonitorEvent.BUY_IN, param1 = serial, param2 = table_id, param3 = withdraw)
        return withdraw

    def seatPlayer(self, serial, table_id, amount):
        status = True
        cursor = self.db.cursor()
        sql = ( "INSERT INTO user2table ( user_serial, table_serial, money) VALUES "
                " ( " + str(serial) + ", " + str(table_id) + ", " + str(amount) + " )" )
        if self.verbose > 1:
            self.message("seatPlayer: %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("inserted %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
            status = False
        cursor.close()
        self.databaseEvent(event = PacketPokerMonitorEvent.SEAT, param1 = serial, param2 = table_id)
        return status

    def movePlayer(self, serial, from_table_id, to_table_id):
        money = -1
        cursor = self.db.cursor()
        sql = ( "SELECT money FROM user2table "
                "  WHERE user_serial = " + str(serial) + " AND "
                "        table_serial = " + str(from_table_id) )
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.message("movePlayer(%d) expected one row got %d" % ( serial, cursor.rowcount ))
        (money,) = cursor.fetchone()
        cursor.close()

        if money > 0:
            cursor = self.db.cursor()
            sql = ( "UPDATE user2table "
                    "  SET table_serial = " + str(to_table_id) +
                    "  WHERE user_serial = " + str(serial) + " and"
                    "        table_serial = " + str(from_table_id) )
            if self.verbose > 1:
                self.message("movePlayer: %s" % sql)
            cursor.execute(sql)
            if cursor.rowcount != 1:
                self.error("modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
                money = -1
            cursor.close()

        # HACK CHECK
#        cursor = self.db.cursor()
#        sql = ( "select sum(money), sum(bet) from user2table" )
#        cursor.execute(sql)
#        (total_money,bet) = cursor.fetchone()
#        if total_money + bet != 120000:
#            self.message("BUG(6) %d" % (total_money + bet))
#            os.abort()
#        cursor.close()
        # END HACK CHECK

        return money

    def leavePlayer(self, serial, table_id, currency_serial):
        status = True
        cursor = self.db.cursor()
        if currency_serial != '':
           sql = ( "UPDATE user2money,user2table,pokertables SET " +
                   " user2money.amount = user2money.amount + user2table.money + user2table.bet " +
                   " WHERE user2money.user_serial = user2table.user_serial AND " +
                   "       user2money.currency_serial = pokertables.currency_serial AND " +
                   "       pokertables.serial = " + str(table_id) + " AND " +
                   "       user2table.table_serial = " + str(table_id) + " AND " +
                   "       user2table.user_serial = " + str(serial) )
           if self.verbose > 1:
               self.message("leavePlayer %s" % sql)
           cursor.execute(sql)
           if cursor.rowcount > 1:
                self.error("modified %d rows (expected 0 or 1): %s " % ( cursor.rowcount, sql ))
                status = False
        sql = ( "DELETE from user2table "
                " WHERE user_serial = " + str(serial) + " AND "
                "       table_serial = " + str(table_id) )
        if self.verbose > 1:
            self.message("leavePlayer %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
            status = False
        cursor.close()
        self.databaseEvent(event = PacketPokerMonitorEvent.LEAVE, param1 = serial, param2 = table_id)
        return status

    def updatePlayerRake(self, currency_serial, serial, rake_amount, points_amount):
        if rake_amount == 0:
            return True
        status = True
        cursor = self.db.cursor()
        sql = ( "UPDATE user2money SET "
                " rake = rake + " + str(rake_amount) + ", "
                " points = points + " + str(points_amount) + " "
                " WHERE user_serial = " + str(serial) + " AND "
                "       currency_serial = " + str(currency_serial) )
        if self.verbose > 1:
            self.message("updatePlayerRake: %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
            status = False
        cursor.close()
        return status

    def updatePlayerMoney(self, serial, table_id, amount):
        if amount == 0:
            return True
        status = True
        cursor = self.db.cursor()
        sql = ( "UPDATE user2table SET "
                " money = money + " + str(amount) + ", "
                " bet = bet - " + str(amount) +
                " WHERE user_serial = " + str(serial) + " AND "
                "       table_serial = " + str(table_id) )
        if self.verbose > 1:
            self.message("updatePlayerMoney: %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("modified %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
            status = False
        cursor.close()

#         # HACK CHECK
#         cursor = self.db.cursor()
#         sql = ( "select sum(money), sum(bet) from user2table" )
#         cursor.execute(sql)
#         (money,bet) = cursor.fetchone()
#         if money + bet != 120000:
#             self.message("BUG(4) %d" % (money + bet))
#             os.abort()
#         cursor.close()

#         cursor = self.db.cursor()
#         sql = ( "select user_serial,table_serial,money from user2table where money < 0" )
#         cursor.execute(sql)
#         if cursor.rowcount >= 1:
#             (user_serial, table_serial, money) = cursor.fetchone()
#             self.message("BUG(11) %d/%d/%d" % (user_serial, table_serial, money))
#             os.abort()
#         cursor.close()
#         # END HACK CHECK

        return status

    def updateTableStats(self, game, observers, waiting):
        cursor = self.db.cursor()
        cursor.execute("UPDATE pokertables SET " +
                       " average_pot = %s, " +
                       " hands_per_hour = %s, " +
                       " percent_flop = %s, " +
                       " players = %s, " +
                       " observers = %s, " +
                       " waiting = %s " +
                       " WHERE serial = %s ", (
            game.stats['average_pot'],
            game.stats['hands_per_hour'],
            game.stats['percent_flop'],
            game.allCount(),
            observers,
            waiting,
            game.id
            ))
        cursor.close()

    def tableMoneyAndBet(self, table_id):
        cursor = self.db.cursor()
        sql = ( "SELECT sum(money), sum(bet) FROM user2table WHERE table_serial = " + str(table_id) )
        cursor.execute(sql)
        (money, bet) = cursor.fetchone()
        cursor.close()
        if not money: money = 0
        elif type(money) == StringType: money = int(money)
        if not bet: bet = 0
        elif type(bet) == StringType: bet = int(bet)
        return  (money, bet)

    def destroyTable(self, table_id):

#         # HACK CHECK
#         cursor = self.db.cursor()
#         sql = ( "select * from user2table where money != 0 and bet != 0 and table_serial = " + str(table_id) )
#         cursor.execute(sql)
#         if cursor.rowcount != 0:
#             self.message("BUG(10)")
#             os.abort()
#         cursor.close()
#         # END HACK CHECK

        cursor = self.db.cursor()
        sql = ( "delete from user2table "
                "  where table_serial = " + str(table_id) )
        if self.verbose > 1:
            self.message("destroy: %s" % sql)
        cursor.execute(sql)
        cursor.execute("DELETE FROM route WHERE table_serial = %s", table_id)

#     def setRating(self, winners, serials):
#         url = self.settings.headerGet("/server/@rating")
#         if url == "":
#             return

#         params = []
#         for first in range(0, len(serials) - 1):
#             for second in range(first + 1, len(serials)):
#                 first_wins = serials[first] in winners
#                 second_wins = serials[second] in winners
#                 if first_wins or second_wins:
#                     param = "a=%d&b=%d&c=" % ( serials[first], serials[second] )
#                     if first_wins and second_wins:
#                         param += "2"
#                     elif first_wins:
#                         param += "0"
#                     else:
#                         param += "1"
#                     params.append(param)

#         params = join(params, '&')
#         if self.verbose > 2:
#             self.message("setRating: url = %s" % url + params)
#         content = loadURL(url + params)
#         if self.verbose > 2:
#             self.message("setRating: %s" % content)

    def resetBet(self, table_id):
        status = True
        cursor = self.db.cursor()
        sql = ( "update user2table set bet = 0 "
                " where table_serial = " + str(table_id) )
        if self.verbose > 1:
            self.message("resetBet: %s" % sql)
        cursor.execute(sql)
        cursor.close()

#         # HACK CHECK
#         cursor = self.db.cursor()
#         sql = ( "select sum(money), sum(bet) from user2table" )
#         cursor.execute(sql)
#         (money,bet) = cursor.fetchone()
#         if money + bet != 120000:
#             self.message("BUG(2) %d" % (money + bet))
#             os.abort()
#         cursor.close()
#         # END HACK CHECK

        return status

    def getTable(self, game_id):
        return self.tables.get(game_id, False)

    def getTableBestByCriteria(self, serial, currency_serial = None, variant = None,
                               betting_structure = None, min_players = 0):
        """Return a PokerTable object optimal table based on the given
        criteria in list_table_query_str plus the amount of currency the
        user represented by serial has.  The caller is assured that the
        user represented by serial can afford at least the minimum buy-in
        for the table returned (if one is returned).

        Arguments in order:

             serial:            a user_serial for the user who
                                wants a good table.
            currency_serial:    must be a positive integer or None
            variant:            must be a string or None
            betting_structure:  must be a string or None
            min_players:        must be a positive integer or None

        General algorithm used by this method:

          First, a list of tables is requested from
          self.searchTables(currency_serial, variant, betting_structure,
          min_players).  If an empty list is returned by searchTables(),
          then None is returned here.

          Second, this method iterates across the tables returned from
          searchTables() and eliminates any tables for which the user
          represented by serial has less than the minimum buy-in, and
          those that have too many users sitting out such that the
          criteria from the user is effectively not met.

          If there are multiple tables found, the first one from the list
          coming from searchTables() that the user can buy into is
          returned.

          Methods of interest used by this method:

            self.getMoney() :       used to find out how much money the
                                    serial has.

            table.game.sitCount() : used to find out how many users are
                                    sitting out.

            table.game.all() :      used to shortcut away from tables that
                                    are full and should not be considered.
        """
        bestTable = None

        # money_results dict is used to store lookups made to self.getMoney()
        money_results = {}

        # A bit of a cheat, listTables() caches the value for min_players
        # when it does parsing so that we can use it here.
        for rr in self.searchTables(currency_serial, variant, betting_structure, min_players):
            table = self.getTable(rr['serial'])
            # Skip considering table entirely if it is full.
            if table.game.full():
                continue

            # Check to see that the players sitting out don't effecitvely
            # cause the user to fail to meet the number of players
            # criteria.
            if table.game.sitCount() < min_players:
                continue

            buy_in = table.game.buyIn(serial)
            currency_serial = rr['currency_serial']
            if not money_results.has_key(currency_serial):
                money_results[currency_serial] = self.getMoney(serial, currency_serial)

            if money_results[currency_serial] > buy_in:
                # If the user can afford the buy_in, we've found a table for them!
                bestTable = table
                break

        return bestTable

    def createTable(self, owner, description):

        tourney_serial = 0
        if description.has_key('tourney'):
            tourney_serial = description['tourney'].serial

        cursor = self.db.cursor()

        sql = """INSERT INTO pokertables \
        (resthost_serial, seats, player_timeout, muck_timeout, currency_serial,
         name, variant, betting_structure, skin, tourney_serial)
         VALUES (%s, %s, %s, %s, %s, %s,  %s, %s, %s, %s)
         ON DUPLICATE KEY UPDATE
            serial=LAST_INSERT_ID(serial),
            resthost_serial=VALUES(resthost_serial),
            seats=VALUES(seats),
            player_timeout=VALUES(player_timeout),
            muck_timeout=VALUES(muck_timeout),
            currency_serial=VALUES(currency_serial),
            name=VALUES(name),
            variant=VALUES(variant),
            betting_structure=VALUES(betting_structure),
            skin=VALUES(skin),
            tourney_serial=VALUES(tourney_serial)
        """ % self.db.literal((
            self.resthost_serial,
            description['seats'],
            description.get('player_timeout', 60),
            description.get('muck_timeout', 5),
            description['currency_serial'],
            description['name'],
            description['variant'],
            description['betting_structure'],
            description.get('skin', 'default'),
            tourney_serial ))

        if self.verbose > 1:
            self.message("createTable: %s" % sql)

        cursor.execute(sql)

        # From: http://dev.mysql.com/doc/refman/5.1/en/insert-on-duplicate.html
        # With ON DUPLICATE KEY UPDATE, the affected-rows value per row is 1 if
        # the row is inserted as a new row and 2 if an existing row is updated.
        #
        # cursor.rowcount represents the number of inserted rows, which will be
        # 0 when a row is updated (the table already exists), or 1 when a new
        # row is inserted (the table does not exist).
        if cursor.rowcount == 0:
            self.message('updated row in pokertables for table %s'
                         % description['name'])
        elif cursor.rowcount == 1:
            self.message('inserted row into pokertables for table %s'
                         % description['name'])

        if hasattr(cursor, "lastrowid"):
            id = cursor.lastrowid
        else:
            id = cursor.insert_id()
        cursor.execute("REPLACE INTO route VALUES (%s,%s,%s,%s)", ( id, tourney_serial, int(seconds()), self.resthost_serial))
        cursor.close()

        table = PokerTable(self, id, description)
        table.owner = owner

        self.tables[id] = table

        # Add betting structure info 
        cursor = self.db.cursor()

        small_blind = 0
        big_blind = 0
        ante_value = 0
        ante_bring_in = 0
    
        try:
          small_blind = table.game.blind_info["small"]
          big_blind = table.game.blind_info["big"]
        except:
          pass

        try:
          ante_value = table.game.ante_info["value"]
          ante_bring_in = table.game.ante_info["bring_in"]
        except:
          pass


        sql = """UPDATE pokertables \
            SET
              small_blind = %s,
              big_blind = %s,
              ante_value = %s,
              ante_bring_in = %s,
              limit_type = %s,
              betting_description = %s 
            WHERE 
              serial = %s
        """ % self.db.literal((
            small_blind,
            big_blind,
            ante_value,
            ante_bring_in,
            table.game.limit_type,
            table.game.betting_structure_name,
            id ))

        if self.verbose > 1:
            self.message("createTable: %s" % sql)

        cursor.execute(sql)

        if self.verbose:
            self.message("table created : %s" % table.game.name)

        return table

    def cleanupCrashedTables(self):
        for description in self.get_table_descriptions():
            self.cleanupCrashedTable("pokertables.name = %s" % self.db.literal((description['name'],)))
        self.cleanupCrashedTable("pokertables.resthost_serial = %d" % self.resthost_serial)

    def cleanupCrashedTable(self, pokertables_where):
        cursor = self.db.cursor()

        sql = ( "SELECT user_serial,table_serial,currency_serial FROM pokertables,user2table WHERE user2table.table_serial = pokertables.serial AND " + pokertables_where )
        cursor.execute(sql)
        if cursor.rowcount > 0:
            if self.verbose > 1:
                self.message("cleanupCrashedTable found %d players on table %s" % ( cursor.rowcount, pokertables_where ))
            for i in xrange(cursor.rowcount):
                (user_serial, table_serial, currency_serial) = cursor.fetchone()
                self.leavePlayer(user_serial, table_serial, currency_serial)
        cursor.execute("DELETE FROM pokertables WHERE " + pokertables_where)

        cursor.close()

    def deleteTable(self, table):
        if self.verbose:
            self.message("table %s/%d removed from server" % ( table.game.name, table.game.id ))
        del self.tables[table.game.id]
        cursor = self.db.cursor()
        sql = ( "delete from  pokertables where serial = " + str(table.game.id) )
        if self.verbose > 1:
            self.message("deleteTable: %s" % sql)
        cursor.execute(sql)
        if cursor.rowcount != 1:
            self.error("deleted %d rows (expected 1): %s " % ( cursor.rowcount, sql ))
        cursor.close()

    def broadcast_to_all(self, packet):
        """
        Broadcasts a packet to all clients.
        """
        for avatar in self.avatars:
            avatar.sendPacketVerbose(packet)

    def broadcast_to_player(self, packet, player_serial):
        """
        Broadcasts a packet to a specific player.

        Returns True if the message was sent successfully (i.e. a player with
        serial `player_serial` is currently logged in).
        """
        for avatar in self.avatars:
            if avatar.getSerial() == player_serial:
                avatar.sendPacketVerbose(packet)
                return True
        return False

    def messageCheck(self):
        cursor = self.db.cursor()
        cursor.execute("SELECT serial,message FROM messages WHERE " +
                       "       sent = 'n' AND send_date < FROM_UNIXTIME(" + str(int(seconds())) + ")")
        rows = cursor.fetchall()
        for (serial, message) in rows:
            self.broadcast_to_all(PacketMessage(string = message))
            cursor.execute("UPDATE messages SET sent = 'y' WHERE serial = %d" % serial)
        cursor.close()
        self.cancelTimer('messages')
        delay = int(self.delays.get('messages', 60))
        self.timer['messages'] = reactor.callLater(delay, self.messageCheck)

    def chatMessageArchive(self, player_serial, game_id, message):
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO chat_messages (player_serial, game_id, message) VALUES (%s, %s, %s)", (player_serial, game_id, message))

if HAS_OPENSSL:
    class SSLContextFactory:

        def __init__(self, settings):
            self.pem_file = None
            for dir in split(settings.headerGet("/server/path")):
                if exists(dir + "/poker.pem"):
                    self.pem_file = dir + "/poker.pem"

        def getContext(self):
            ctx = SSL.Context(SSL.SSLv23_METHOD)
            ctx.use_certificate_file(self.pem_file)
            ctx.use_privatekey_file(self.pem_file)
            return ctx

from twisted.web import resource, server

class PokerTree(resource.Resource):

    def __init__(self, service):
        resource.Resource.__init__(self)
        self.service = service
        self.putChild("RPC2", PokerXMLRPC(self.service))
        try:
            self.putChild("SOAP", PokerSOAP(self.service))
        except:
            print "SOAP service not available"
        self.putChild("", self)

    def render_GET(self, request):
        return "Use /RPC2 or /SOAP"

components.registerAdapter(PokerTree, IPokerService, resource.IResource)

class PokerRestTree(resource.Resource):

    def __init__(self, service):
        resource.Resource.__init__(self)
        self.service = service
        self.verbose = service.verbose
        self.putChild("POKER_REST", PokerResource(self.service))
        self.putChild("UPLOAD", PokerImageUpload(self.service))
        self.putChild("TOURNEY_START", PokerTourneyStartResource(self.service))
        self.putChild("AVATAR", PokerAvatarResource(self.service))
        self.putChild("", self)

    def render_GET(self, request):
        return "Use /POKER_REST or /UPLOAD or /AVATAR or /TOURNEY_START"

def _getRequestCookie(request):
    if request.cookies:
        return request.cookies[0]
    else:
        return request.getCookie(join(['TWISTED_SESSION'] + request.sitepath, '_'))

#
# When connecting to the poker server with REST, SOAP or XMLRPC
# the client must chose to use sessions or not. If using session,
# the server will issue a cookie and keep track of it during
# (X == default twisted timeout) minutes.
#
# The session cookie is returned as a regular HTTP cookie and
# the library of the client in charge of the HTTP dialog should
# handle it transparently. To help the developer using a library
# that does a poor job at handling the cookies, it is also sent
# back as the "cookie" field of the PacketSerial packet in response
# to a successfull authentication request. This cookie may then
# be used to manually set the cookie header, for instance:
#
# Cookie: TWISTED_SESSION=a0bb35083c1ed3bef068d39bd29fad52; Path=/
#
# Because this cookie is only sent back in the SERIAL packet following
# an authentication request, it will not help clients observing the
# tables. These clients will have to find a way to properly handle the
# HTTP headers sent by the server.
#
# When the client sends a packet to the server using sessions, it must
# be prepared to receive the backlog of packets accumulated since the
# last request. For instance,
#
#   A client connects in REST session mode
#   The client sends POKER_TABLE_JOIN and the server replies with
#   packets describing the state of the table.
#   A player sitting at the table sends POKER_FOLD.
#   The server broadcasts the action to all players and observers.
#   Because the client does not maintain a persistent connection
#    and is in session mode, the server keeps the POKER_FOLD packet
#    for later.
#   The client sends PING to tell the server that it is still alive.
#   In response the server sends it the cached POKER_FOLD packet and
#    the client is informed of the action.
#
# The tests/test-webservice.py.in tests contain code that will help
# understand the usage of the REST, SOAP and XMLRPC protocols.
#
class PokerXML(resource.Resource):

    encoding = "ISO-8859-1"

    def __init__(self, service):
        resource.Resource.__init__(self)
        self.service = service
        self.verbose = service.verbose

    def message(self, string):
        print "PokerXML: " + string

    def error(self, string):
        self.message("*ERROR* " + string)

    def sessionExpires(self, session):
        self.service.destroyAvatar(session.avatar)
        del session.avatar

    def render(self, request):
        if self.verbose > 2:
            self.message("render " + request.content.read())
        request.content.seek(0, 0)
        if self.encoding is not None:
            mimeType = 'text/xml; charset="%s"' % self.encoding
        else:
            mimeType = "text/xml"
        request.setHeader("Content-type", mimeType)
        args = self.getArguments(request)
        if self.verbose > 2:
            self.message("args = " + str(args))
        session = None
        use_sessions = args[0]
        args = args[1:]
        if use_sessions == "use sessions":
            if self.verbose > 2:
                self.message("receive session cookie %s " % _getRequestCookie(request))
            session = request.getSession()
            if not hasattr(session, "avatar"):
                session.avatar = self.service.createAvatar()
                session.notifyOnExpire(lambda: self.sessionExpires(session))
# For test : trigger session expiration in the next 4 seconds
# see http://twistedmatrix.com/bugs/issue1090
#                session.lastModified -= 900
#                reactor.callLater(4, session.checkExpired)
            avatar = session.avatar
        else:
            avatar = self.service.createAvatar()

        logout = False
        result_packets = []
        for packet in args2packets(args):
            if isinstance(packet, PacketError):
                result_packets.append(packet)
                break
            else:
                results = avatar.handlePacket(packet)
                if use_sessions == "use sessions" and len(results) > 1:
                    for result in results:
                        if isinstance(result, PacketSerial):
                            result.cookie = _getRequestCookie(request)
                            if self.verbose > 2:
                                self.message("send session cookie " + result.cookie)
                            break
                result_packets.extend(results)
                if isinstance(packet, PacketLogout):
                    logout = True

        #
        # If the result is a single packet, it means the requested
        # action is using sessions (non session packet streams all
        # start with an auth packet). It may be a Deferred but may never
        # be a logout (because logout is not supposed to return a deferred).
        #
        if len(result_packets) == 1 and isinstance(result_packets[0], defer.Deferred):
            def renderLater(packet):
                result_maps = packets2maps([packet])

                result_string = self.maps2result(request, result_maps)
                request.setHeader("Content-length", str(len(result_string)))
                request.write(result_string)
                request.finish()
                return
            d = result_packets[0]
            d.addCallback(renderLater)
            return server.NOT_DONE_YET
        else:
            if use_sessions != "use sessions":
                self.service.destroyAvatar(avatar)
            elif use_sessions == "use sessions":
                if logout:
                    session.expire()
                else:
                    avatar.queuePackets()

            result_maps = packets2maps(result_packets)

            result_string = self.maps2result(request, result_maps)
            if self.verbose > 2:
                self.message("result_string " + str(result_string))
            request.setHeader("Content-length", str(len(result_string)))
            return result_string

    def getArguments(self, request):
        raise NotImplementedError("PokerXML is pure base class, subclass an implement getArguments")

    def maps2result(self, request, maps):
        raise NotImplementedError("PokerXML is pure base class, subclass an implement maps2result")

import xmlrpclib

class PokerXMLRPC(PokerXML):

    def getArguments(self, request):
        ( args, functionPath ) = xmlrpclib.loads(request.content.read())
        return fromutf8(args, self.encoding)

    def maps2result(self, request, maps):
        return xmlrpclib.dumps((maps, ), methodresponse = 1)

class PokerREST(PokerXML):

    def getArguments(self, request):
        use_sessions = request.args.get('session', ['no'])[0]
        session_name = request.args.get('name', [None])[0]
        if session_name:
            request.sitepath = [ session_name ]
        else:
            request.sitepath = [ ]

        if use_sessions == 'no':
            use_sessions = 'no sessions'
        elif use_sessions in ( 'clear', 'new' ):
            #
            # Force session expiration.
            #
            # NOTE 1: that request.getSession() will create a session
            # if no session exists. However, since it is a light
            # weight operation that will be canceled by
            # session.expire(), it is ok.
            #
            # NOTE 2: the avatar attached to the session will be destroyed
            # as a side effect, because a callback was attached to the
            # session expiration.
            #
            request.getSession().expire()
            request.session = None
            request.cookies = []
            if use_sessions == 'clear':
                use_sessions = 'no sessions'
            elif use_sessions == 'new':
                use_sessions = 'use sessions'
        elif use_sessions == 'yes':
            use_sessions = 'use sessions'

        jsonp = request.args.get('jsonp', [''])[0]
        if jsonp:
            data = request.args.get('packet', [''])[0]
        else:
            data = request.content.read()
        args = simplejson.loads(data, encoding = 'latin-1')
        if hasattr(Packet.JSON, 'decode_objects'):
            args = Packet.JSON.decode_objects(args)
        return [ use_sessions, fromutf8(args, self.encoding) ]

    def maps2result(self, request, maps):
        jsonp = request.args.get('jsonp', [''])[0]
        if jsonp:
            return jsonp + '(' + str(Packet.JSON.encode(maps)) + ')'
        else:
            return str(Packet.JSON.encode(maps))

try:
    import SOAPpy

    class PokerSOAP(PokerXML):

        def getArguments(self, request):
            data = request.content.read()

            p, header, body, attrs = SOAPpy.parseSOAPRPC(data, 1, 1, 1)

            methodName, args, kwargs, ns = p._name, p._aslist, p._asdict, p._ns

            # deal with changes in SOAPpy 0.11
            if callable(args):
                args = args()
            if callable(kwargs):
                kwargs = kwargs()

            return fromutf8(SOAPpy.simplify(args), self.encoding)

        def maps2result(self, request, maps):
            return SOAPpy.buildSOAP(kw = {'Result': toutf8(maps, self.encoding)},
                                    method = 'returnPacket',
                                    encoding = self.encoding)
except:
    print "Python SOAP module not available"

########NEW FILE########
__FILENAME__ = pokersite
#
# -*- py-indent-offset: 4; coding: iso-8859-1 -*-
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2009 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2008 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import simplejson
import re
import imp
import time
import base64
from types import *

from traceback import format_exc

from twisted.web import server, resource, util, http
from twisted.internet import defer
from twisted.python import log
from twisted.python.runtime import seconds

from pokernetwork.pokerpackets import *
from pokernetwork import pokermemcache

# FIXME: I don't think these next two functions should assume 'ISO-8859-1'
# like they do.  This is related to another FIXME about this issue you'll
# find in pokeravatar.py -- bkuhn, 2008-11-28
def fromutf8(tree, encoding = 'ISO-8859-1'):
    return __walk(tree, lambda x: x.encode(encoding))

def toutf8(tree, encoding = 'ISO-8859-1'):
    # make sure we do not decode a string that is already Unicode, otherwise
    # we'll get a "TypeError: decoding Unicode is not supported"
    def convert(s):
        if isinstance(s, unicode):
            return s
        return unicode(s, encoding)
    return __walk(tree, convert)

def __walk(tree, convert):
    if type(tree) is TupleType or type(tree) is ListType:
        result = map(lambda x: __walk(x, convert), tree)
        if type(tree) is TupleType:
            return tuple(result)
        else:
            return result
    elif type(tree) is DictionaryType:
        new_tree = {}
        for (key, value) in tree.iteritems():
            converted_key = convert(str(key))
            new_tree[converted_key] = __walk(value, convert)
        return new_tree
    elif ( type(tree) is UnicodeType or type(tree) is StringType ):
        return convert(tree)
    else:
        return tree

def packets2maps(packets):
    maps = []
    for packet in packets:
        attributes = packet.__dict__.copy()
        if isinstance(packet, PacketList):
            attributes['packets'] = packets2maps(attributes['packets'])
        if 'message' in dir(packet):
            attributes['message'] = getattr(packet, 'message')
        #
        # It is forbiden to set a map key to a numeric (native
        # numeric or string made of digits). Taint the map entries
        # that are numeric and hope the client will figure it out.
        #
        for (key, value) in packet.__dict__.iteritems():
            if type(value) == DictType:
                    for ( subkey, subvalue ) in value.items():
                            del value[subkey]
                            new_subkey = str(subkey)
                            if new_subkey.isdigit():
                                    new_subkey = "X" + new_subkey
                            value[new_subkey] = subvalue
        attributes['type'] = packet.__class__.__name__
        maps.append(attributes)
    return maps

def args2packets(args):
    packets = []
    for arg in args:
        if re.match("^[a-zA-Z]+$", arg['type']):
            try:
                fun_args = len(arg) > 1 and '(**arg)' or '()'
                packets.append(eval(arg['type'] + fun_args))
            except:
                packets.append(PacketError(message = "Unable to instantiate %s(%s): %s" % ( arg['type'], arg, format_exc() )))
        else:
            packets.append(PacketError(message = "Invalid type name %s" % arg['type']))
    return packets

class Request(server.Request):

    def getSession(self):
        uid = self.args.get('uid', [None])[0]
        auth = self.args.get('auth', [None])[0]
        explain = self.args.get('explain', ['yes'])[0] == 'yes'

        if uid == None: uid = self.site._mkuid()
        if auth == None: auth = self.site._mkuid()

        try:
            self.session = self.site.getSession(uid, auth, explain)
        except KeyError:
            self.session = self.site.makeSession(0, auth, explain)
        self.session.touch()
        return self.session

    def findProxiedIP(self):
        """Return the IP address of the client who submitted this request,
        making an attempt to determine the actual IP through the proxy.
        Returns	the client IP address (type: str )"""

        # FIXME: we shouldn't trust these headers so completely because
        # they can be easily forged.  Loic had the idea that we should
        # have a list of trusted proxies.  bkuhn was thinking we should
        # figure a way to log both the real IP and proxier IP.  Anyway,
        # sr#2157 remains open for this reason.

        if self.getHeader('x-forwarded-for'):
            return ('x-forwarded-for', self.getHeader('x-forwarded-for'))
        elif self.getHeader('x-cluster-client-ip'):
            return ('x-cluster-client-ip', self.getHeader('x-cluster-client-ip'))
        else:
            return ('client-ip', server.Request.getClientIP(self))

class Session(server.Session):

    def __init__(self, site, uid, auth, explain):
        server.Session.__init__(self, site, uid)
        self.auth = auth
        self.avatar = site.resource.service.createAvatar()
        self.explain_default = explain
        self.avatar.queuePackets()
        self.avatar.setDistributedArgs(uid, auth)
        if self.explain_default:
            self.avatar.setExplain(PacketPokerExplain.ALL)
        self.avatar.roles.add(PacketPokerRoles.PLAY)
        self.expired = False

    def expire(self):
        server.Session.expire(self)
        self.site.resource.service.destroyAvatar(self.avatar)
        del self.avatar
        self.expired = True

    def checkExpired(self):
        try:
            #
            # The session may expire as a side effect of the
            # verifications made by getSession against memcache.
            # When this happens an exception is thrown and checkExpire
            # is not called : this is intended because the
            # session already expired.
            #
            self.site.getSession(self.uid, self.auth, self.explain_default)
            server.Session.checkExpired(self)
            return True
        except KeyError:
            return False

class PokerResource(resource.Resource):

    def __init__(self, service):
        resource.Resource.__init__(self)
        self.service = service
        self.verbose = service.verbose
        self.isLeaf = True

    def message(self, string):
        print "PokerResource: " + string

    def error(self, string):
        self.message("*ERROR* " + string)

    def render(self, request):
        request.content.seek(0, 0)
        jsonp = request.args.get('jsonp', [''])[0]
        if jsonp:
            data = request.args.get('packet', [''])[0]
        elif request.args.has_key('packet'):
            data = request.args['packet'][0];
        else:
            data = request.content.read()
        if self.verbose >= 3:
            if "PacketPing" not in data or self.verbose > 3:
                self.message("(%s:%s) " % request.findProxiedIP() + "render " + data)

        try:
            args = simplejson.loads(data, encoding = 'UTF-8')
        except:
            return "Unable to decode JSON."

        if hasattr(Packet.JSON, 'decode_objects'): # backward compatibility
            args = Packet.JSON.decode_objects(args)
        args = fromutf8(args)
        packet = args2packets([args])[0]

        deferred = defer.succeed(None)

        if request.site.pipes:
            request.site.pipe(deferred, request, packet)

        def pipesFailed(reason):
            #
            # Report only if the request has not been finished already.
            # It is the responsibility of each filter to handle errors
            # either by passing them on the errback chain or by filling
            # the request with a proper report.
            #
            body = reason.getTraceback()
            if not request.finished:
                request.setResponseCode(http.INTERNAL_SERVER_ERROR)
                request.setHeader('content-type',"text/html")
                request.setHeader('content-length', str(len(body)))
                request.write(body)
            if self.verbose >= 0 and request.code != 200:
                self.error("(%s:%s) " % request.findProxiedIP() + str(body))
            if not request.finished:
                request.finish()
                return twisted.web.server.NOT_DONE_YET

            #
            # Return a value that is not a Failure so that the next
            # incoming request is accepted (otherwise the server keeps
            # returning error on every request)
            #
            return True

        deferred.addCallback(lambda result: self.deferRender(request, jsonp, packet, data))
        deferred.addErrback(pipesFailed)
        return server.NOT_DONE_YET

    def deferRender(self, request, jsonp, packet, data):
        if request.finished:
            #
            # For instance : the request was reverse-proxied to a server.
            #
            return True
        session = request.getSession()
        d = defer.maybeDeferred(session.avatar.handleDistributedPacket, request, packet, data)
        def render(packets):
            if self.verbose > 3:
                self.message("(%s:%s) " % request.findProxiedIP() + "render " + data + " returns " + str(packets))
            #
            # update the session information if the avatar changed
            #
            # *do not* update/expire/persist session if handling
            # PacketPokerLongPollReturn
            #
            if packet.type != PACKET_POKER_LONG_POLL_RETURN:
                session.site.updateSession(session)
                #session.site.persistSession(session)
            #
            # Format answer
            #
            maps = toutf8(packets2maps(packets))
            if jsonp:
                result_string = jsonp + '(' + str(Packet.JSON.encode(maps)) + ')'
            else:
                result_string = str(Packet.JSON.encode(maps))
            request.setHeader("content-length", str(len(result_string)))
            request.setHeader("content-type", 'text/plain; charset="UTF-8"')
            request.write(result_string)
            request.finish()
            return True
        def processingFailed(reason):
            body = reason.getTraceback()
            request.setResponseCode(http.INTERNAL_SERVER_ERROR)
            request.setHeader('content-length', str(len(body)))
            request.setHeader('content-type',"text/html")
            request.write(body)
            request.finish()
            session.expire()
            if self.verbose >= 0:
                self.error("(%s:%s) " % request.findProxiedIP() + str(body))
            return True
        d.addCallbacks(render, processingFailed)
        return d

class PokerImageUpload(resource.Resource):

    def __init__(self, service):
        resource.Resource.__init__(self)
        self.service = service
        self.verbose = service.verbose
        self.deferred = defer.succeed(None)
        self.isLeaf = True

    def message(self, string):
        print "PokerImageUpload: " + string

    def error(self, string):
        self.message("*ERROR* " + string)

    def render(self, request):
        if self.verbose > 3:
            self.message("render " + request.content.read())
        request.content.seek(0, 0)
        self.deferred.addCallback(lambda result: self.deferRender(request))
        def failed(reason):
            body = reason.getTraceback()
            request.setResponseCode(http.INTERNAL_SERVER_ERROR)
            request.setHeader('content-type',"text/html")
            request.setHeader('content-length', str(len(body)))
            request.write(body)
            request.connectionLost(reason)
            if self.verbose >= 0:
                self.error(str(body))
            return True
        self.deferred.addErrback(failed)
        return server.NOT_DONE_YET

    def deferRender(self, request):
        session = request.getSession()
        if session.avatar.isLogged():
            serial = request.getSession().avatar.getSerial()
            data = request.args['filename'][0]
            packet = PacketPokerPlayerImage(image = base64.b64encode(data), serial = serial)
            self.service.setPlayerImage(packet)
            result_string = 'image uploaded'
            request.setHeader("Content-length", str(len(result_string)))
            request.setHeader("Content-type", 'text/plain; charset="UTF-8"')
            request.write(result_string)
            request.finish()
            return
        else:
            session.expire()
            body = 'not logged'
            request.setResponseCode(http.UNAUTHORIZED)
            request.setHeader('content-type',"text/html")
            request.setHeader('content-length', str(len(body)))
            request.write(body)
            request.finish()
            return

class PokerTourneyStartResource(resource.Resource):

    def __init__(self, service):
        resource.Resource.__init__(self)
        self.service = service
        self.verbose = service.verbose
        self.deferred = defer.succeed(None)
        self.isLeaf = True

    def message(self, string):
        print "PokerTourneyStart: " + string

    def render(self, request):
        if self.verbose > 3:
            self.message("render " + str(request))

        try:
            tourney_serial = request.args['tourney_serial'][0]
            self.service.tourneyNotifyStart(int(tourney_serial))
        except:
            return "not found"

        body = 'OK'
        request.setHeader('content-type',"text/html")
        request.setHeader('content-length', str(len(body)))
        request.write(body)
        return True

class PokerAvatarResource(resource.Resource):

    def __init__(self, service):
        resource.Resource.__init__(self)
        self.service = service
        self.verbose = service.verbose
        self.deferred = defer.succeed(None)
        self.isLeaf = True

    def message(self, string):
        print "PokerAvatarResource: " + string

    def error(self, string):
        self.message("*ERROR* " + string)

    def render(self, request):
        if self.verbose > 3:
            self.message("render " + request.content.read())
        request.content.seek(0, 0)

        try:
            serial = int(request.path.split('/')[-1])
        except:
            return "not found"

        self.deferred.addCallback(lambda result: self.deferRender(request, serial))
        def failed(reason):
            body = reason.getTraceback()
            request.setResponseCode(http.INTERNAL_SERVER_ERROR)
            request.setHeader('content-type',"text/html")
            request.setHeader('content-length', str(len(body)))
            request.write(body)
            request.connectionLost(reason)
            if self.verbose >= 0:
                self.error(str(body))
            return True
        self.deferred.addErrback(failed)
        return server.NOT_DONE_YET

    def deferRender(self, request, serial):
        packet  = self.service.getPlayerImage(serial)
        if len(packet.image):
            result_string = base64.b64decode(packet.image)
            request.setHeader("Content-length", str(len(result_string)))
            request.setHeader("Content-type", packet.image_type)
            request.write(result_string)
            request.finish()
            return
        else:
            body = 'not found'
            request.setResponseCode(http.NOT_FOUND)
            request.setHeader('content-type',"text/html")
            request.setHeader('content-length', str(len(body)))
            request.write(body)
            request.finish()
            return

class PokerSite(server.Site):

    requestFactory = Request
    sessionFactory = Session

    def __init__(self, settings, resource, **kwargs):
        server.Site.__init__(self, resource, **kwargs)
        self.verbose = self.resource.verbose
        cookieTimeout = settings.headerGetInt("/server/@cookie_timeout")
        if cookieTimeout > 0:
            self.cookieTimeout = cookieTimeout
        else:
            self.cookieTimeout = 1200
        sessionTimeout = settings.headerGetInt("/server/@session_timeout")
        if sessionTimeout > 0:
            self.sessionFactory.sessionTimeout = sessionTimeout
        sessionCheckTime = settings.headerGetInt("/server/@session_check")
        if sessionCheckTime > 0:
            self.sessionCheckTime = sessionCheckTime
        memcache_address = settings.headerGet("/server/@memcached")
        if memcache_address:
            self.memcache = pokermemcache.memcache.Client([memcache_address])
        else:
            self.memcache = pokermemcache.MemcacheMockup.Client([])
        self.pipes = []
        for path in settings.header.xpathEval("/server/rest_filter"):
            module = imp.load_source("poker_pipe", path.content)
            self.pipes.append(getattr(module, "rest_filter"))
        resthost = settings.headerGetProperties("/server/resthost")
        if resthost:
            resthost = resthost[0]
            self.resthost = ( resthost['name'], resthost['host'], int(resthost['port']), resthost['path'] )
        else:
            self.resthost = None

    def message(self, string):
        print "PokerSite: " + string

    def error(self, string):
        self.message("*ERROR* " + string)

    def pipe(self, d, request, packet):
        if self.pipes:
            for pipe in self.pipes:
                d.addCallback(lambda x: defer.maybeDeferred(pipe, self, request, packet))

    #
    # prevent calling the startFactory method of site.Server
    # to disable loging.
    #
    def startFactory(self):
        pass

    def stopFactory(self):
        for key in self.sessions.keys():
            self.sessions[key].expire()

    def persistSession(self, session):
        try:
            if len(session.avatar.tables) <= 0 and len(session.avatar.tourneys) <= 0 and (not session.avatar.explain or len(session.avatar.explain.games.getAll()) <= 0):
                session.expire()
                if self.resthost:
                    self.memcache.delete(session.uid)
                return False
        except AttributeError:
            return False

        if self.resthost:
            self.memcache.set(session.uid, self.resthost, time = self.cookieTimeout)
        return True

    def updateSession(self, session):
        try:
          serial = session.avatar.getSerial()
        except AttributeError:
          serial = 0
        #
        # There is no need to consider the case where session.memcache_serial is
        # zero because nothing needs updating in memcache.
        #
        if session.memcache_serial > 0:
            if serial == 0:
                #
                # if the user has logged out, unbind the serial that was in memcache
                #
                self.memcache.replace(session.auth, '0', time = self.cookieTimeout)
            #
            # for consistency, so that updateSession can be called multiple times without
            # side effects
            #
            session.memcache_serial = serial

        if serial > 0:
            #
            # refresh the memcache entry each time a request is handled
            # because it is how each poker server is informed that
            # a given user is logged in
            #
            self.memcache.set(session.auth, str(serial), time = self.cookieTimeout)

    def getSession(self, uid, auth, explain):
        if not isinstance(uid, str):
            raise Exception("uid is not str: '%s' %s" % (uid, type(uid)))
        if not isinstance(auth, str):
            raise Exception("auth is not str: '%s' %s" % (auth, type(auth)))
        memcache_serial = self.memcache.get(auth)
        if memcache_serial == None:
            #
            # If the memcache session is gone, trash the current session
            # if it exists.
            #
            self.message("Memcached returned None for auth: %s, uid: %s" % (auth, uid))
            if self.sessions.has_key(uid):
                self.sessions[uid].expire()
        else:
            memcache_serial = int(memcache_serial)
            #
            # If a session exists, make sure it is in sync with the memcache
            # serial.
            #
            if self.sessions.has_key(uid):
                session = self.sessions[uid]
                session.memcache_serial = memcache_serial
                if session.avatar.getSerial() == 0:
                    #
                    # If the user has been authed by an external application
                    # (i.e. another poker server or a third party program)
                    # act as if a login was just sent and was successfully
                    # authed.
                    #
                    if memcache_serial > 0:
                        session.avatar.relogin(memcache_serial)
                else:
                    #
                    # If the avatar logout or logged into another serial,
                    # expire the session
                    #
                    if session.avatar.getSerial() != memcache_serial:
                        session.expire()
            if not self.sessions.has_key(uid):
                #
                # Create a session with an uid that matches the memcache
                # key
                #
                self.makeSessionFromUidAuth(uid, auth, explain).memcache_serial = memcache_serial
                if memcache_serial > 0:
                    self.sessions[uid].avatar.relogin(memcache_serial)

        return self.sessions[uid]

    def makeSessionFromUidAuth(self, uid, auth, explain):
        session = self.sessions[uid] = self.sessionFactory(self, uid, auth, explain)
        session.startCheckingExpiration(self.sessionCheckTime)
        return session

    def makeSession(self, uid, auth, explain):
        session = self.makeSessionFromUidAuth(uid, auth, explain)
        session.memcache_serial = 0
        self.memcache.add(auth, str(session.memcache_serial))
        return session

########NEW FILE########
__FILENAME__ = pokersql
#
# -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys
import cgi
import cgitb
from MySQLdb.cursors import DictCursor
try:
        import json # native in python-2.6
except:
        import simplejson as json
sys.path.insert(0, ".")
sys.path.insert(0, "..")

from pokernetwork.pokernetworkconfig import Config
from pokernetwork.pokerdatabase import PokerDatabase

def getPath(argv):
    default_path = "/etc/poker-network/poker.server.xml"
    return argv[-1][-4:] == ".xml" and argv[-1] or default_path    
        
def getSettings(path):
    settings = Config([''])
    settings.load(path)
    assert settings.headerGet("/server/@admin") in ( "yes", "true" ), "set <server admin='yes'> in %s to enable this CGI. It means anyone with access to the CGI will be able to inject arbitrary SQL code in the MySQL server" % path
    return settings

def runQuery(settings):
    if not settings.headerGet('/server/database/@name'):
            return "Content-type: text/plain\n\n"
    settings.headerSet('/server/@verbose', '0')
    db = PokerDatabase(settings)
    cgitb.enable()
    form = cgi.FieldStorage()
    cursor = db.cursor(DictCursor)
    cursor.execute(form["query"].value)
    if not form.has_key('output'):
            result = cursor.rowcount
    elif form["output"].value == "rows":
            result = cursor.fetchall()
    elif form["output"].value == "lastrowid":
            result = cursor.lastrowid
    else:
            result = cursor.rowcount
    cursor.close()
    return "Content-type: text/plain\n\n" + json.dumps(result)

def run(argv):
    settings = getSettings(getPath(argv))
    return runQuery(settings)

if __name__ == '__main__': print run(sys.argv)

########NEW FILE########
__FILENAME__ = pokertable
#
# -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)             2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C)             2009 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org> (2008-)
#  Henry Precheur <henry@precheur.org> (2004)
#

from twisted.internet import reactor
from twisted.python.runtime import seconds

from re import match
from types import *
from string import split, join
import time
import traceback

from pokerengine.pokergame import PokerGameServer, history2messages
from pokerengine import pokergame, pokertournament
from pokerengine.pokercards import PokerCards

from pokernetwork.pokerpackets import *
from pokernetwork import pokeravatar
from pokernetwork.pokerbonus import  *

class PokerAvatarCollection:

    def __init__(self, prefix = '', verbose = 0):
        self.serial2avatars = {}
        self.verbose = verbose
        self.prefix = prefix

    def message(self, string):
        print "PokerAvatarCollection:%s:" % self.prefix + string

    def get(self, serial):
        return self.serial2avatars.get(serial, [])

    def set(self, serial, avatars):
        if self.verbose > 3:
            self.message("set %d %s" % ( serial, str(avatars) ))
        assert not self.serial2avatars.has_key(serial), "setting %d with %s would override %s" % ( serial, str(avatars), str(self.serial2avatars[serial]) )
        self.serial2avatars[serial] = avatars[:]

    def add(self, serial, avatar):
        if self.verbose > 3:
            self.message("add %d %s" % ( serial, str(avatar) ))
        if not self.serial2avatars.has_key(serial):
            self.serial2avatars[serial] = []
        if avatar not in self.serial2avatars[serial]:
            self.serial2avatars[serial].append(avatar)

    def remove(self, serial, avatar):
        if self.verbose > 3:
            self.message("remove %d %s" % ( serial, str(avatar) ))
        assert avatar in self.serial2avatars[serial], "expected %d avatar in %s" % ( serial, str(self.serial2avatars[serial]) )
        self.serial2avatars[serial].remove(avatar)
        if len(self.serial2avatars[serial]) <= 0:
            del self.serial2avatars[serial]

    def values(self):
        return self.serial2avatars.values()

class PokerPredefinedDecks:
    def __init__(self, decks):
        self.decks = decks
        self.index = 0

    def shuffle(self, deck):
        deck[:] = self.decks[self.index][:]
        self.index += 1
        if self.index >= len(self.decks):
            self.index = 0

class PokerTable:

    def __init__(self, factory, id = 0, description = None):
        self.factory = factory
        settings = self.factory.settings
        self.game = PokerGameServer("poker.%s.xml", factory.dirs)
        self.game.prefix = "[Server]"
        self.game.verbose = factory.verbose
        self.history_index = 0
        predefined_decks = settings.headerGetList("/server/decks/deck")
        if predefined_decks:
            self.game.shuffler = PokerPredefinedDecks(map(lambda deck: self.game.eval.string2card(split(deck)), predefined_decks))
        self.observers = []
        self.waiting = []
        game = self.game
        game.id = id
        game.name = description["name"]
        game.setVariant(description["variant"])
        game.setBettingStructure(description["betting_structure"])
        game.setMaxPlayers(int(description["seats"]))
        game.forced_dealer_seat = int(description.get("forced_dealer_seat", -1))
        self.skin = description.get("skin", "default")
        self.currency_serial = int(description.get("currency_serial", 0))
        self.playerTimeout = int(description.get("player_timeout", 60))
        self.muckTimeout = int(description.get("muck_timeout", 5))
        self.transient = description.has_key("transient")
        self.tourney = description.get("tourney", None)

        # max_missed_round can be configured on a per table basis, which
        # overrides the server-wide default
        self.max_missed_round = int(description.get("max_missed_round",
                                                    factory.getMissedRoundMax()))

        self.delays = settings.headerGetProperties("/server/delays")[0]
        self.autodeal = settings.headerGet("/server/@autodeal") == "yes"
        self.temporaryPlayersPattern = settings.headerGet("/server/users/@temporary")
        self.cache = self.createCache()
        self.owner = 0
        self.avatar_collection = PokerAvatarCollection("Table%d" % id, factory.verbose)
        self.timer_info = {
            "playerTimeout": None,
            "playerTimeoutSerial": 0,
            "muckTimeout": None,
            }
        self.timeout_policy = "sitOut"
        self.previous_dealer = -1
        self.game_delay = {
            "start": 0,
            "delay": 0
            }
        self.update_recursion = False
        self.bonus = PokerBonus()

    def message(self, string):
        print "PokerTable: " + string

    def error(self, string):
        self.message("*ERROR* " + string)

    def isValid(self):
        return hasattr(self, "factory")

    def destroy(self):
        if self.factory.verbose > 1:
            self.message("destroy table %d" % self.game.id)
        if self.transient:
            self.factory.destroyTable(self.game.id)

        self.broadcast(PacketPokerTableDestroy(game_id = self.game.id))
        for avatars in self.avatar_collection.values():
            for avatar in avatars:
                del avatar.tables[self.game.id]
        for avatar in self.observers:
            del avatar.tables[self.game.id]
            
        self.cancelDealTimeout()
        self.cancelMuckTimer()
        self.cancelPlayerTimers()

        self.factory.deleteTable(self)
        del self.factory

    def getName(self, serial):
        avatars = self.avatar_collection.get(serial)
        if len(avatars) > 0:
            name = avatars[0].getName()
        else:
            name = self.factory.getName(serial)
        return name

    def getPlayerInfo(self, serial):
        avatars = self.avatar_collection.get(serial)
        if len(avatars) > 0 and avatars[0].user.isLogged():
            info = avatars[0].getPlayerInfo()
        else:
            info = self.factory.getPlayerInfo(serial)
        return info

    def listPlayers(self):
        players = []
        game = self.game
        for serial in game.serialsAll():
            players.append((self.getName(serial), game.getPlayerMoney(serial), 0))
        return players

    def createCache(self):
        return { "board": PokerCards(), "pockets": {} }

    def cancelDealTimeout(self):
        info = self.timer_info
        if info.has_key("dealTimeout"):
            if info["dealTimeout"].active():
                info["dealTimeout"].cancel()
            del info["dealTimeout"]

    def beginTurn(self):
        self.cancelDealTimeout()
        if self.game.isEndOrNull():
            self.historyReset()
            hand_serial = self.factory.getHandSerial()
            game = self.game
            self.message("Dealing hand %s/%d" % ( game.name, hand_serial ))
            game.setTime(seconds())
            game.beginTurn(hand_serial)
            for player in game.playersAll():
                player.getUserData()['ready'] = True

    def historyReset(self):
        self.history_index = 0
        self.cache = self.createCache()

    def toPacket(self):
        game = self.game
        return PacketPokerTable(id = game.id,
                                name = game.name,
                                variant = game.variant,
                                betting_structure = game.betting_structure,
                                seats = game.max_players,
                                players = game.allCount(),
                                hands_per_hour = game.stats["hands_per_hour"],
                                average_pot = game.stats["average_pot"],
                                percent_flop = game.stats["percent_flop"],
                                player_timeout = self.playerTimeout,
                                muck_timeout = self.muckTimeout,
                                observers = len(self.observers),
                                waiting = len(self.waiting),
                                skin = self.skin,
                                currency_serial = self.currency_serial,
                                tourney_serial = self.tourney and self.tourney.serial or 0)

    def cards2packets(self, game_id, board, pockets, cache):
        packets = []
        #
        # If no pockets or board specified (different from empty pockets),
        # ignore and keep the cached values
        #
        if board != None:
            if board != cache["board"]:
                packets.append(PacketPokerBoardCards(game_id = game_id,
                                                     cards = board.tolist(False)))
                cache["board"] = board.copy()

        if pockets != None:
            #
            # Send new pockets or pockets that changed
            #
            for (serial, pocket) in pockets.iteritems():
                if not cache["pockets"].has_key(serial) or cache["pockets"][serial] != pocket:
                    packets.append(PacketPokerPlayerCards(game_id = game_id,
                                                          serial = serial,
                                                          cards = pocket.toRawList()))
                if not cache["pockets"].has_key(serial):
                    cache["pockets"][serial] = pocket.copy()
        return packets

    def broadcast(self, packets):
        game = self.game

        if not type(packets) is ListType:
            packets = ( packets, )

        for packet in packets:
            keys = game.serial2player.keys()
            if self.factory.verbose > 1:
                self.message("broadcast%s %s " % ( keys, packet ))
            for serial in keys:
                #
                # Player may be in game but disconnected.
                #
                for avatar in self.avatar_collection.get(serial):
                    avatar.sendPacket(self.private2public(packet, serial))
            for avatar in self.observers:
                avatar.sendPacket(self.private2public(packet, 0))

        self.factory.eventTable(self)

    def private2public(self, packet, serial):
        game = self.game
        #
        # Cards private to each player are shown only to the player
        #
        if packet.type == PACKET_POKER_PLAYER_CARDS and packet.serial != serial:
            private = PacketPokerPlayerCards(game_id = packet.game_id,
                                             serial = packet.serial,
                                             cards = PokerCards(packet.cards).tolist(False))
            return private
        else:
            return packet

    def history2packets(self, history, game_id, cache):
        game_index = 0
        player_list_index = 7
        packets = []
        for event in history:
            type = event[0]
            if type == "game":
                (type, level, hand_serial, hands_count, time, variant, betting_structure, player_list, dealer, serial2chips) = event
                if len(serial2chips) > 1:
                    nochips = 0
                    for (serial, chips) in serial2chips.iteritems():
                        if serial == 'values':
                            continue
                        packets.append(PacketPokerPlayerChips(game_id = game_id,
                                                              serial = serial,
                                                              bet = nochips,
                                                              money = chips))
                packets.append(PacketPokerInGame(game_id = game_id,
                                                 players = player_list))
                #
                # This may happen, for instance, if a turn is canceled
                #
                if self.previous_dealer == dealer:
                    previous_dealer = -1
                else:
                    previous_dealer = self.previous_dealer
                packets.append(PacketPokerDealer(game_id = game_id,
                                                 dealer = dealer,
                                                 previous_dealer = previous_dealer))
                self.previous_dealer = dealer
                packets.append(PacketPokerStart(game_id = game_id,
                                                hand_serial = hand_serial,
                                                hands_count = hands_count,
                                                time = time,
                                                level = level))

            elif type == "wait_for":
                (type, serial, reason) = event
                packets.append(PacketPokerWaitFor(game_id = game_id,
                                                  serial = serial,
                                                  reason = reason))

            elif type == "player_list":
                (type, player_list) = event
                packets.append(PacketPokerInGame(game_id = game_id,
                                                 players = player_list))

            elif type == "round":
                (type, name, board, pockets) = event
                packets.extend(self.cards2packets(game_id, board, pockets, cache))
                packets.append(PacketPokerState(game_id = game_id,
                                                string = name))

            elif type == "position":
                (type, position) = event
                packets.append(PacketPokerPosition(game_id = game_id,
                                                   position = position))

            elif type == "showdown":
                (type, board, pockets) = event
                packets.extend(self.cards2packets(game_id, board, pockets, cache))

            elif type == "blind_request":
                (type, serial, amount, dead, state) = event
                packets.append(PacketPokerBlindRequest(game_id = game_id,
                                                       serial = serial,
                                                       amount = amount,
                                                       dead = dead,
                                                       state = state))

            elif type == "wait_blind":
                (type, serial) = event
                pass

            elif type == "blind":
                (type, serial, amount, dead) = event
                packets.append(PacketPokerBlind(game_id = game_id,
                                                serial = serial,
                                                amount = amount,
                                                dead = dead))

            elif type == "ante_request":
                (type, serial, amount) = event
                packets.append(PacketPokerAnteRequest(game_id = game_id,
                                                      serial = serial,
                                                      amount = amount))

            elif type == "ante":
                (type, serial, amount) = event
                packets.append(PacketPokerAnte(game_id = game_id,
                                               serial = serial,
                                               amount = amount))

            elif type == "all-in":
                pass

            elif type == "call":
                (type, serial, amount) = event
                packets.append(PacketPokerCall(game_id = game_id,
                                               serial = serial))

            elif type == "check":
                (type, serial) = event
                packets.append(PacketPokerCheck(game_id = game_id,
                                                serial = serial))

            elif type == "fold":
                (type, serial) = event
                packets.append(PacketPokerFold(game_id = game_id,
                                               serial = serial))

            elif type == "raise":
                (type, serial, amount, payAmount, raiseAmount) = event
                packets.append(PacketPokerRaise(game_id = game_id,
                                                serial = serial,
                                                amount = amount))

            elif type == "canceled":
                (type, serial, amount) = event
                packets.append(PacketPokerCanceled(game_id = game_id,
                                                   serial = serial,
                                                   amount = amount))

            elif type == "muck":
                (type, muckable_serials) = event
                packets.append(PacketPokerMuckRequest(game_id = game_id,
                                                      muckable_serials = muckable_serials))

            elif type == "rake":
                (type, amount, serial2rake) = event
                packets.append(PacketPokerRake(game_id = game_id,
                                               value = amount))

            elif type == "end":
                (type, winners, showdown_stack) = event
                packets.append(PacketPokerState(game_id = game_id,
                                                string = "end"))
                packets.append(PacketPokerWin(game_id = game_id,
                                              serials = winners))

            elif type == "sitOut":
                (type, serial) = event
                packets.append(PacketPokerSitOut(game_id = game_id,
                                                 serial = serial))

            elif type == "rebuy":
                (type, serial, amount) = event
                packets.append(PacketPokerRebuy(game_id = game_id,
                                                serial = serial,
                                                amount = amount))

            elif type == "leave":
                (type, quitters) = event
                for (serial, seat) in quitters:
                    packets.append(PacketPokerPlayerLeave(game_id = game_id,
                                                          serial = serial,
                                                          seat = seat))

            elif type == "finish":
                pass

            else:
                self.error("history2packets: unknown history type %s " % type)
        return packets

    def syncDatabase(self):
        game = self.game
        updates = {}
        serial2rake = {}
        reset_bet = False
        for event in game.historyGet()[self.history_index:]:
            type = event[0]
            if type == "game":
                pass

            elif type == "wait_for":
                pass

            elif type == "rebuy":
                pass

            elif type == "player_list":
                pass

            elif type == "round":
                pass

            elif type == "showdown":
                pass

            elif type == "rake":
                (type, amount, serial2rake) = event

            elif type == "muck":
                pass

            elif type == "position":
                pass

            elif type == "blind_request":
                pass

            elif type == "wait_blind":
                pass

            elif type == "blind":
                (type, serial, amount, dead) = event
                if not updates.has_key(serial):
                    updates[serial] = 0
                updates[serial] -= amount + dead

            elif type == "ante_request":
                pass

            elif type == "ante":
                (type, serial, amount) = event
                if not updates.has_key(serial):
                    updates[serial] = 0
                updates[serial] -= amount

            elif type == "all-in":
                pass

            elif type == "call":
                (type, serial, amount) = event
                if not updates.has_key(serial):
                    updates[serial] = 0
                updates[serial] -= amount

            elif type == "check":
                pass

            elif type == "fold":
                pass

            elif type == "raise":
                (type, serial, raiseTo, payAmount, raiseAmount) = event
                if not updates.has_key(serial):
                    updates[serial] = 0
                updates[serial] -= payAmount

            elif type == "canceled":
                (type, serial, amount) = event
                if serial > 0 and amount > 0:
                    if not updates.has_key(serial):
                        updates[serial] = 0
                    updates[serial] += amount

            elif type == "end":
                (type, winners, showdown_stack) = event
                game_state = showdown_stack[0]
                for (serial, share) in game_state['serial2share'].iteritems():
                    if not updates.has_key(serial):
                        updates[serial] = 0
                    updates[serial] += share
                reset_bet = True

            elif type == "sitOut":
                pass

            elif type == "leave":
                pass

            elif type == "finish":
                (type, hand_serial) = event
                self.factory.saveHand(self.compressedHistory(game.historyGet()), hand_serial)
                self.factory.updateTableStats(game, len(self.observers), len(self.waiting))
                transient = self.transient and 1 or 0
                self.factory.databaseEvent(event = PacketPokerMonitorEvent.HAND, param1 = hand_serial, param2 = transient)

            else:
                self.error("syncDatabase: unknown history type %s " % type)

        for (serial, amount) in updates.iteritems():
            self.factory.updatePlayerMoney(serial, game.id, amount)

        for (serial, rake) in serial2rake.iteritems():
            points = self.bonus.getPoints(serial, game, rake)
            self.factory.updatePlayerRake(self.currency_serial, serial, rake, points)

        if reset_bet:
            self.factory.resetBet(game.id)
        elif hasattr(self, "factory") and self.factory.verbose > 2:
            (money, bet) = self.factory.tableMoneyAndBet(game.id)
            if bet and game.potAndBetsAmount() != bet:
                self.error("table %d bet mismatch %d in memory versus %d in database" % ( game.id, game.potAndBetsAmount(), bet))

    def historyReduce(self):
        game = self.game
        if self.history_index < len(game.historyGet()):
            game.historyReduce()
            self.history_index = len(game.historyGet())

    def compressedHistory(self, history):
        new_history = []
        cached_pockets = None
        cached_board = None
        for event in history:
            type = event[0]
            if ( type == "all-in" or
                 type == "wait_for" ) :
                pass

            elif type == "game":
                new_history.append(event)

            elif type == "round":
                (type, name, board, pockets) = event

                if pockets != cached_pockets:
                    cached_pockets = pockets
                else:
                    pockets = None

                if board != cached_board:
                    cached_board = board
                else:
                    board = None

                new_history.append((type, name, board, pockets))

            elif type == "showdown":
                (type, board, pockets) = event
                if pockets != cached_pockets:
                    cached_pockets = pockets
                else:
                    pockets = None

                if board != cached_board:
                    cached_board = board
                else:
                    board = None

                new_history.append((type, board, pockets))

            elif ( type == "call" or
                   type == "check" or
                   type == "fold" or
                   type == "raise" or
                   type == "canceled" or
                   type == "position" or
                   type == "blind" or
                   type == "ante" or
                   type == "player_list" ):
                new_history.append(event)

            elif type == "rake":
                new_history.append(event)

            elif type == "end":
                (type, winners, showdown_stack) = event
                new_history.append(event)

            elif type == "sitOut":
                new_history.append(event)

            elif type == "muck":
                pass

            elif type == "leave":
                pass

            elif type == "finish":
                pass

            elif type == "rebuy":
                pass

            else:
                self.error("compressedHistory: unknown history type %s " % type)

        return new_history

    def delayedActions(self):
        game = self.game
        for event in game.historyGet()[self.history_index:]:
            type = event[0]
            if type == "game":
                self.game_delay = {
                    "start": seconds(),
                    "delay": float(self.delays["autodeal"])
                    }
            elif ( type == "round" or
                   type == "position" or
                   type == "showdown" or
                   type == "finish" ):
                self.game_delay["delay"] += float(self.delays[type])
                if self.factory.verbose > 2:
                    self.message("delayedActions: game estimated duration is now " + str(self.game_delay["delay"]) + " and is running since %.02f " % (seconds() - self.game_delay["start"] ) + " seconds")

            elif type == "leave":
                (type, quitters) = event
                for (serial, seat) in quitters:
                    self.factory.leavePlayer(serial, game.id, self.currency_serial)
                    for avatar in self.avatar_collection.get(serial)[:]:
                        self.seated2observer(avatar)

    def cashGame_kickPlayerSittingOutTooLong(self, historyToSearch):
        if self.tourney: return
        handIsFinished = False
        # Go through the history backwards, stopping at
        # self.history_index, since we expect finish to be at the end if
        # it is there, and we don't want to consider previously reduced
        # history.
        for event in historyToSearch[::-1]:
            if event[0] == "finish":
                handIsFinished = True
                break
        if handIsFinished:
            for player in self.game.playersAll():
                if player.getMissedRoundCount() >= self.max_missed_round:
                    self.kickPlayer(player.serial)

    def tourneyEndTurn(self):
        if not self.tourney:
            return
        game = self.game
        for event in game.historyGet()[self.history_index:]:
            type = event[0]
            if type == "end":
                self.factory.tourneyEndTurn(self.tourney, game.id)

    def autoDeal(self):
        self.cancelDealTimeout()
        if not self.allReadyToPlay():
            #
            # All avatars that fail to send a PokerReadyToPlay packet
            # within imposed delays after sending a PokerProcessingHand
            # are marked as bugous and their next PokerProcessingHand
            # request will be ignored.
            #
            for player in self.game.playersAll():
                if player.getUserData()['ready'] == False:
                    for avatar in self.avatar_collection.get(player.serial):
                        if self.factory.verbose > 1:
                            self.message("Player %d marked as having a bugous PokerProcessingHand protocol" %  player.serial)
                            avatar.bugous_processing_hand = True

        self.beginTurn()
        self.update()

    def autoDealCheck(self, autodeal_check, delta):
        if self.factory.verbose > 2:
            self.message("autoDealCheck")
        self.cancelDealTimeout()
        if autodeal_check > delta:
            if self.factory.verbose > 2:
                self.message("Autodeal for %d scheduled in %f seconds" % ( self.game.id, delta ))
            # Add a delay for clients to view showdown information
            if not self.game.isWinnerBecauseFold():
                delta += int(self.delays.get("showdown", 5))
            self.timer_info["dealTimeout"] = reactor.callLater(delta, self.autoDeal)
            return
        game = self.game
        #
        # Issue a poker message to all players that are ready
        # to play.
        #
        serials = []
        for player in game.playersAll():
            if player.getUserData()['ready'] == True:
                serials.append(player.serial)
        if serials:
            self.broadcastMessage(PacketPokerMessage, "Waiting for players.\nNext hand will be dealt shortly.\n(maximum %d seconds)" % int(delta), serials)
        if self.factory.verbose > 2:
            self.message("AutodealCheck(2) for %d scheduled in %f seconds" % ( self.game.id, delta ))
        self.timer_info["dealTimeout"] = reactor.callLater(autodeal_check, self.autoDealCheck, autodeal_check, delta - autodeal_check)

    def broadcastMessage(self, message_type, message, serials = None):
        if serials == None:
            serials =  self.game.serialsAll()
        connected_serials = []
        for serial in serials:
            if self.avatar_collection.get(serial):
                connected_serials.append(serial)
        if connected_serials:
            packet = message_type(game_id = self.game.id, string = message)
            for serial in connected_serials:
                for avatar in self.avatar_collection.get(serial):
                    avatar.sendPacket(packet)
            return True
        return False

    def scheduleAutoDeal(self):
        self.cancelDealTimeout()
        if self.factory.shutting_down:
            if self.factory.verbose > 2:
                self.message("Not autodealing because server is shutting down")
            return
        if not self.autodeal:
            if self.factory.verbose > 3:
                self.message("No autodeal")
            return
        if self.isRunning():
            if self.factory.verbose > 3:
                self.message("Not autodealing %d because game is running" % self.game.id)
            return
        if self.game.state == pokergame.GAME_STATE_MUCK:
            if self.factory.verbose > 3:
                self.message("Not autodealing %d because game is in muck state" % self.game.id)
            return
        game = self.game
        if game.sitCount() < 2:
            if self.factory.verbose > 2:
                self.message("Not autodealing %d because less than 2 players willing to play" % self.game.id)
            return
        if game.isTournament():
            if self.tourney:
                if self.tourney.state != pokertournament.TOURNAMENT_STATE_RUNNING:
                    if self.factory.verbose > 2:
                        self.message("Not autodealing %d because in tournament state %s" % ( self.game.id, self.tourney.state ))
                    if self.tourney.state == pokertournament.TOURNAMENT_STATE_BREAK_WAIT:
                        self.broadcastMessage(PacketPokerGameMessage, "Tournament will break when the other tables finish their hand")
                    return
        else:
            #
            # Do not auto deal a table where there are only temporary
            # users (i.e. bots)
            #
            onlyTemporaryPlayers = True
            for serial in game.serialsSit():
                if not match("^" + self.temporaryPlayersPattern, self.getName(serial)):
                    onlyTemporaryPlayers = False
                    break
            if onlyTemporaryPlayers:
                if self.factory.verbose > 2:
                    self.message("Not autodealing because player names sit in match %s" % self.temporaryPlayersPattern)
                return

        delay = self.game_delay["delay"]
        if not self.allReadyToPlay() and delay > 0:
            delta = ( self.game_delay["start"] + delay ) - seconds()
            if delta < 0: delta = 0
            autodeal_max = float(self.delays.get("autodeal_max", 120))
            if delta > autodeal_max: delta = autodeal_max
            self.game_delay["delay"] = ( seconds() - self.game_delay["start"] ) + delta
        elif self.transient:
            delta = int(self.delays.get("autodeal_tournament_min", 15))
            if seconds() - self.game_delay["start"] > delta:
                delta = 0
        else:
            delta = 0
        if self.factory.verbose > 2:
            self.message("AutodealCheck scheduled in %f seconds" % delta)
        autodeal_check = max(0.01, float(self.delays.get("autodeal_check", 15)))
        self.timer_info["dealTimeout"] = reactor.callLater(min(autodeal_check, delta), self.autoDealCheck, autodeal_check, delta)

    def updatePlayerUserData(self, serial, key, value):
        game = self.game
        player = game.getPlayer(serial)
        if player:
            user_data = player.getUserData()
            if user_data[key] != value:
                user_data[key] = value
                self.update()
        return True

    def allReadyToPlay(self):
        game = self.game
        status = True
        notready = []
        for player in game.playersAll():
            if player.getUserData()['ready'] == False:
                notready.append(str(player.serial))
                status = False
        if notready and self.factory.verbose > 3:
            self.message("allReadyToPlay: waiting for " + join(notready, ","))
        return status

    def readyToPlay(self, serial):
        self.updatePlayerUserData(serial, 'ready', True)
        return PacketAck()

    def processingHand(self, serial):
        self.updatePlayerUserData(serial, 'ready', False)
        return PacketAck()

    def update(self):
        if self.update_recursion:
            if self.factory.verbose >= 0:
                self.error("unexpected recursion (ignored)\n" + "".join(traceback.format_list(traceback.extract_stack())))
            return "recurse"
        self.update_recursion = True
        if not self.isValid():
            return "not valid"

        game = self.game
        history_tail = game.historyGet()[self.history_index:]

        try:
            self.updateTimers(history_tail)
            packets = self.history2packets(history_tail, game.id, self.cache);
            self.syncDatabase()
            self.delayedActions()
            if len(packets) > 0:
                self.broadcast(packets)
            self.tourneyEndTurn()
            if self.isValid():
                self.cashGame_kickPlayerSittingOutTooLong(history_tail)
                self.scheduleAutoDeal()
        finally:
            self.historyReduce()
            self.update_recursion = False
        return "ok"

    def handReplay(self, avatar, hand):
        history = self.factory.loadHand(hand)
        if not history:
            return
        #self.message("handReplay")
        (type, level, hand_serial, hands_count, time, variant, betting_structure, player_list, dealer, serial2chips) = history[0]
        game = self.game
        for player in game.playersAll():
            avatar.sendPacketVerbose(PacketPokerPlayerLeave(game_id = game.id,
                                                            serial = player.serial,
                                                            seat = player.seat))
        game.reset()
        game.name = "*REPLAY*"
        game.setVariant(variant)
        game.setBettingStructure(betting_structure)
        game.setTime(time)
        game.setHandsCount(hands_count)
        game.setLevel(level)
        game.hand_serial = hand
        for serial in player_list:
            game.addPlayer(serial)
            game.getPlayer(serial).money = serial2chips[serial]
            game.sit(serial)
        if self.isJoined(avatar):
            avatar.join(self, reason = PacketPokerTable.REASON_HAND_REPLAY)
        else:
            self.joinPlayer(avatar, avatar.getSerial(),
                            reason = PacketPokerTable.REASON_HAND_REPLAY)
        serial = avatar.getSerial()
        cache = self.createCache()
        for packet in self.history2packets(history, game.id, cache):
            if packet.type == PACKET_POKER_PLAYER_CARDS and packet.serial == serial:
                packet.cards = cache["pockets"][serial].toRawList()
            if packet.type == PACKET_POKER_PLAYER_LEAVE:
                continue
            avatar.sendPacketVerbose(packet)

    def isJoined(self, avatar):
        serial = avatar.getSerial()
        return avatar in self.observers or avatar in self.avatar_collection.get(serial)

    def isSeated(self, avatar):
        return self.isJoined(avatar) and self.game.isSeated(avatar.getSerial())

    def isSit(self, avatar):
        return self.isSeated(avatar) and self.game.isSit(avatar.getSerial())

    def isSerialObserver(self, serial):
        return serial in [ avatar.getSerial() for avatar in self.observers ]

    def isOpen(self):
        return self.game.is_open

    def isRunning(self):
        return self.game.isRunning()

    def seated2observer(self, avatar):
        self.avatar_collection.remove(avatar.getSerial(), avatar)
        self.observers.append(avatar)

    def observer2seated(self, avatar):
        self.observers.remove(avatar)
        self.avatar_collection.add(avatar.getSerial(), avatar)

    def quitPlayer(self, avatar, serial):
        game = self.game
        if self.isSit(avatar):
            if self.isOpen():
                game.sitOutNextTurn(serial)
            game.autoPlayer(serial)
        self.update()
        if self.isSeated(avatar):
            #
            # If not on a closed table, stand up
            #
            if self.isOpen():
                if avatar.removePlayer(self, serial):
                    self.seated2observer(avatar)
                    self.factory.leavePlayer(serial, game.id, self.currency_serial)
                    self.factory.updateTableStats(game, len(self.observers), len(self.waiting))
                else:
                    self.update()
            else:
                avatar.message("cannot quit a closed table, request ignored")
                return False

        if self.isJoined(avatar):
            #
            # The player is no longer connected to the table
            #
            self.destroyPlayer(avatar, serial)

        return True

    def kickPlayer(self, serial):
        game = self.game

        player = game.getPlayer(serial)
        seat = player and player.seat

        if not game.removePlayer(serial):
            self.error("kickPlayer did not succeed in removing player %d from game %d" % ( serial, game.id ))
            return

        self.factory.leavePlayer(serial, game.id, self.currency_serial)
        self.factory.updateTableStats(game, len(self.observers), len(self.waiting))

        for avatar in self.avatar_collection.get(serial)[:]:
            self.seated2observer(avatar)

        self.broadcast(PacketPokerPlayerLeave(game_id = game.id,
                                              serial = serial,
                                              seat = seat))

    def disconnectPlayer(self, avatar, serial):
        game = self.game

        if self.isSeated(avatar):
            game.getPlayer(serial).getUserData()['ready'] = True
            if self.isOpen():
                #
                # If not on a closed table, stand up.
                #
                if avatar.removePlayer(self, serial):
                    self.seated2observer(avatar)
                    self.factory.leavePlayer(serial, game.id, self.currency_serial)
                    self.factory.updateTableStats(game, len(self.observers), len(self.waiting))
                else:
                    self.update()
            else:
                #
                # If on a closed table, the player
                # will stay at the table, he does not
                # have the option to leave.
                #
                pass

        if self.isJoined(avatar):
            #
            # The player is no longer connected to the table
            #
            self.destroyPlayer(avatar, serial)

        return True

    def leavePlayer(self, avatar, serial):
        game = self.game
        if self.isSit(avatar):
            if self.isOpen():
                game.sitOutNextTurn(serial)
            game.autoPlayer(serial)
        self.update()
        if self.isSeated(avatar):
            #
            # If not on a closed table, stand up
            #
            if self.isOpen():
                if avatar.removePlayer(self, serial):
                    self.seated2observer(avatar)
                    self.factory.leavePlayer(serial, game.id, self.currency_serial)
                    self.factory.updateTableStats(game, len(self.observers), len(self.waiting))
                else:
                    self.update()
            else:
                self.error("cannot leave a closed table")
                avatar.sendPacketVerbose(PacketPokerError(game_id = game.id,
                                                          serial = serial,
                                                          other_type = PACKET_POKER_PLAYER_LEAVE,
                                                          code = PacketPokerPlayerLeave.TOURNEY,
                                                          message = "Cannot leave tournament table"))
                return False

        return True

    def movePlayer(self, avatars, serial, to_game_id, reason = ""):
        game = self.game
        #
        # We are safe because called from within the server under
        # controlled circumstances.
        #

        money = game.serial2player[serial].money

        sit_out = self.movePlayerFrom(serial, to_game_id)

        for avatar in avatars:
            self.destroyPlayer(avatar, serial)

        other_table = self.factory.getTable(to_game_id)
        for avatar in avatars:
            other_table.observers.append(avatar)
            other_table.observer2seated(avatar)

        money_check = self.factory.movePlayer(serial, game.id, to_game_id)
        if money_check != money:
            self.error("movePlayer: player %d money %d in database, %d in memory" % ( serial, money_check, money ))

        for avatar in avatars:
            avatar.join(other_table, reason = reason)
        other_table.movePlayerTo(serial, money, sit_out)
        other_table.sendNewPlayerInformation(serial)
        if not other_table.update_recursion:
            other_table.scheduleAutoDeal()
        if self.factory.verbose:
            self.message("player %d moved from table %d to table %d" % ( serial, game.id, to_game_id ))

    def sendNewPlayerInformation(self, serial):
        packets = self.newPlayerInformation(serial)
        self.broadcast(packets)

    def newPlayerInformation(self, serial):
        player_info = self.getPlayerInfo(serial)
        game = self.game
        player = game.getPlayer(serial)
        if self.factory.verbose > 1:
            self.message("about player %d" % serial)
        nochips = 0
        packets = []
        packets.append(
            PacketPokerPlayerArrive(game_id = game.id,
                                    serial = serial,
                                    name = player_info.name,
                                    url = player_info.url,
                                    outfit = player_info.outfit,
                                    blind = player.blind,
                                    remove_next_turn = player.remove_next_turn,
                                    sit_out = player.sit_out,
                                    sit_out_next_turn = player.sit_out_next_turn,
                                    auto = player.auto,
                                    auto_blind_ante = player.auto_blind_ante,
                                    wait_for = player.wait_for,
                                    seat = player.seat)
            )
        if self.factory.has_ladder:
            packet = self.factory.getLadder(game.id, self.currency_serial, player.serial)
            if packet.type == PACKET_POKER_PLAYER_STATS:
                packets.append(packet)
        packets.append(PacketPokerSeats(game_id = game.id, seats = game.seats()))
        packets.append(PacketPokerPlayerChips(game_id = game.id,
                                              serial = serial,
                                              bet = nochips,
                                              money = game.getPlayer(serial).money))
        return packets

    def movePlayerTo(self, serial, money, sit_out):
        game = self.game
        game.open()
        game.addPlayer(serial)
        player = game.getPlayer(serial)
        player.setUserData(pokeravatar.DEFAULT_PLAYER_USER_DATA.copy())
        player.money = money
        player.buy_in_payed = True
        game.sit(serial)
        game.autoBlindAnte(serial)
        if sit_out: game.sitOut(serial)
        game.close()

    def movePlayerFrom(self, serial, to_game_id):
        game = self.game
        player = game.getPlayer(serial)
        self.broadcast(PacketPokerTableMove(game_id = game.id,
                                            serial = serial,
                                            to_game_id = to_game_id,
                                            seat = player.seat))
        sit_out = game.isSitOut(serial)
        game.removePlayer(serial)
        return sit_out

    def possibleObserverLoggedIn(self, avatar, serial):
        game = self.game
        if not game.getPlayer(serial):
            return False
        self.observer2seated(avatar)
        game.comeBack(serial)
        return True

    def joinPlayer(self, avatar, serial, reason = ""):
        game = self.game
        #
        # Nothing to be done except sending all packets
        # Useful in disconnected mode to resume a session.
        #
        if self.isJoined(avatar):
            avatar.join(self, reason = reason);
            return True

        # Next, test to see if we have reached the server-wide maximum for
        # seated/observing players.
        if not self.game.isSeated(avatar.getSerial()) and self.factory.joinedCountReachedMax():
            self.error("joinPlayer: %d cannot join game %d because the server is full" %
                       (serial, game.id))
            avatar.sendPacketVerbose(PacketPokerError(game_id = game.id,
                                                      serial = serial,
                                                      other_type = PACKET_POKER_TABLE_JOIN,
                                                      code = PacketPokerTableJoin.FULL,
                                                      message = "This server has too many seated players and observers."))
            return False

        # Next, test to see if joining this table will cause the avatar to
        # exceed the maximum permitted by the server.
        if len(avatar.tables) >= self.factory.simultaneous:
            if self.factory.verbose:
                self.error("joinPlayer: %d seated at %d tables (max %d)" % ( serial, len(avatar.tables), self.factory.simultaneous ))
            return False

        #
        # Player is now an observer, unless he is seated
        # at the table.
        #
        self.factory.joinedCountIncrease()
        if not self.game.isSeated(avatar.getSerial()):
            self.observers.append(avatar)
        else:
            self.avatar_collection.add(serial, avatar)
        #
        # If it turns out that the player is seated
        # at the table already, presumably because he
        # was previously disconnected from a tournament
        # or an ongoing game.
        #
        if self.isSeated(avatar):
            #
            # Sit back immediately, as if we just seated
            #
            game.comeBack(serial)
        
        avatar.join(self, reason = reason)

        return True

    def seatPlayer(self, avatar, serial, seat):
        game = self.game
        if not self.isJoined(avatar):
            self.error("player %d can't seat before joining" % serial)
            return False
        #
        # Do nothing if already seated
        #
        if self.isSeated(avatar):
            self.message("player %d is already seated" % serial)
            return False

        if not game.canAddPlayer(serial):
            self.error("table refuses to seat player %d" % serial)
            return False

        if seat != -1 and seat not in game.seats_left:
            self.error("table refuses to seat player %d at seat %d" % ( serial, seat ))
            return False

        amount = 0
        if self.transient:
            amount = game.buyIn(serial)

        if not self.factory.seatPlayer(serial, game.id, amount):
            return False

        self.observer2seated(avatar)

        avatar.addPlayer(self, seat)
        if amount > 0:
            avatar.setMoney(self, amount)

        self.factory.updateTableStats(game, len(self.observers), len(self.waiting))
        return True

    def sitOutPlayer(self, avatar, serial):
        game = self.game
        if not self.isSeated(avatar):
            self.error("player %d can't sit out before getting a seat" % serial)
            return False
        #
        # Silently do nothing if already sit out
        #
        if not self.isSit(avatar):
            return True

        avatar.sitOutPlayer(self, serial)
        return True

    def chatPlayer(self, avatar, serial, message):
        self.broadcast(PacketPokerChat(game_id = self.game.id,
                                       serial = serial,
                                       message = message + "\n"))
        self.factory.chatMessageArchive(serial, self.game.id, message)

    def autoBlindAnte(self, avatar, serial, auto):
        game = self.game
        if not self.isSeated(avatar):
            self.error("player %d can't set auto blind/ante before getting a seat" % serial)
            return False
        return avatar.autoBlindAnte(self, serial, auto)

    def muckAccept(self, avatar, serial):
        game = self.game
        if not self.isSeated(avatar):
            self.error("player %d can't accept muck before getting a seat" % serial)
            return False
        return game.muck(serial, want_to_muck = True)

    def muckDeny(self, avatar, serial):
        game = self.game
        if not self.isSeated(avatar):
            self.error("player %d can't deny muck before getting a seat" % serial)
            return False
        return game.muck(serial, want_to_muck = False)

    def sitPlayer(self, avatar, serial):
        game = self.game
        if not self.isSeated(avatar):
            self.error("player %d can't sit before getting a seat" % serial)
            return False

        return avatar.sitPlayer(self, serial)

    def destroyPlayer(self, avatar, serial):
        self.factory.joinedCountDecrease()
        if avatar in self.observers:
            self.observers.remove(avatar)
        else:
            self.avatar_collection.remove(serial, avatar)
        del avatar.tables[self.game.id]

    def buyInPlayer(self, avatar, amount):
        game = self.game
        if not self.isSeated(avatar):
            self.error("player %d can't bring money to a table before getting a seat" % avatar.getSerial())
            return False

        if avatar.getSerial() in game.serialsPlaying():
            self.error("player %d can't bring money while participating in a hand" % avatar.getSerial())
            return False

        if self.transient:
            self.error("player %d can't bring money to a transient table" % avatar.getSerial())
            return False

        player = game.getPlayer(avatar.getSerial())
        if player and player.isBuyInPayed():
            self.error("player %d already payed the buy-in" % avatar.getSerial())
            return False

        amount = self.factory.buyInPlayer(avatar.getSerial(), game.id, self.currency_serial, max(amount, game.buyIn(avatar.getSerial())))
        return avatar.setMoney(self, amount)

    def rebuyPlayerRequest(self, avatar, amount):
        game = self.game
        if not self.isSeated(avatar):
            self.error("player %d can't rebuy to a table before getting a seat" % avatar.getSerial())
            return False

        serial = avatar.getSerial()
        player = game.getPlayer(serial)
        if not player.isBuyInPayed():
            self.error("player %d can't rebuy before paying the buy in" % serial)
            return False

        if self.transient:
            self.error("player %d can't rebuy on a transient table" % serial)
            return False

        maximum = game.maxBuyIn(serial) - game.getPlayerMoney(serial)
        if maximum <= 0:
            self.error("player %d can't bring more money to the table" % serial)
            return False

        if amount == 0:
            amount = game.buyIn(serial)

        amount = self.factory.buyInPlayer(serial, game.id, self.currency_serial, min(amount, maximum))

        if amount == 0:
            self.error("player %d is broke and cannot rebuy" % serial)
            return False

        if not game.rebuy(serial, amount):
            self.error("player %d rebuy denied" % serial)
            return False

        self.broadcast(PacketPokerRebuy(game_id = game.id,
                                        serial = serial,
                                        amount = amount))
        return True

    def playerWarningTimer(self, serial):
        game = self.game
        info = self.timer_info
        if game.isRunning() and serial == game.getSerialInPosition():
            timeout = self.playerTimeout / 2;
            #
            # Compensate the communication lag by always giving the avatar
            # an extra 2 seconds to react. The warning says that there only is
            # N seconds left but the server will actually timeout after N + 2
            # seconds.
            #
            if timeout > 2:
                self.broadcast(PacketPokerTimeoutWarning(game_id = game.id,
                                                         serial = serial,
                                                         timeout = timeout - 2))
            info["playerTimeout"] = reactor.callLater(timeout, self.playerTimeoutTimer, serial)
        else:
            self.updatePlayerTimers()

    def playerTimeoutTimer(self, serial):
        if self.factory.verbose:
            self.message("player %d times out" % serial)
        game = self.game
        if game.isRunning() and serial == game.getSerialInPosition():
            if self.timeout_policy == "sitOut":
                game.sitOutNextTurn(serial)
                game.autoPlayer(serial)
            elif self.timeout_policy == "fold":
                game.autoPlayer(serial)
                self.broadcast(PacketPokerAutoFold(game_id = game.id,
                                                   serial = serial))
            else:
                self.error("unknown timeout_policy %s" % self.timeout_policy)
            self.broadcast(PacketPokerTimeoutNotice(game_id = game.id,
                                                    serial = serial))
            self.update()
        else:
            self.updatePlayerTimers()

    def muckTimeoutTimer(self):
        if self.factory.verbose:
            self.message("muck timed out")
        # timer expires, force muck on muckables not responding
        for serial in self.game.muckable_serials[:]:
            self.game.muck(serial, want_to_muck = True)
        self.cancelMuckTimer()
        self.update()

    def cancelMuckTimer(self):
        info = self.timer_info
        timer = info["muckTimeout"]
        if timer != None:
            if timer.active():
                timer.cancel()
            info["muckTimeout"] = None

    def cancelPlayerTimers(self):
        info = self.timer_info

        timer = info["playerTimeout"]
        if timer != None:
            if timer.active():
                timer.cancel()
            info["playerTimeout"] = None
        info["playerTimeoutSerial"] = 0

    def updateTimers(self, history = ()):
        self.updateMuckTimer(history)
        self.updatePlayerTimers()

    def updateMuckTimer(self, history):
        for event in history:
            type = event[0]
            if type == "muck":
                self.cancelMuckTimer()
                self.timer_info["muckTimeout"] = reactor.callLater(self.muckTimeout, self.muckTimeoutTimer)

    def updatePlayerTimers(self):
        game = self.game
        info = self.timer_info

        timer = info["playerTimeout"]
        if game.isRunning():
            serial = game.getSerialInPosition()
            #
            # Any event in the game resets the player timeout
            #
            if ( info["playerTimeoutSerial"] != serial or
                 len(game.historyGet()) > self.history_index ):
                if timer != None and timer.active():
                    timer.cancel()

                timer = reactor.callLater(self.playerTimeout / 2, self.playerWarningTimer, serial)
                info["playerTimeout"] = timer
                info["playerTimeoutSerial"] = serial
        else:
            #
            # If the game is not running, cancel the previous timeout
            #
            self.cancelPlayerTimers()


########NEW FILE########
__FILENAME__ = protocol
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
# 
from twisted.internet import reactor, protocol
from twisted.python.runtime import seconds

from pokernetwork.packets import Packet, PacketFactory, PacketNames
from pokernetwork import protocol_number
from pokernetwork.version import Version

protocol_version = Version(protocol_number)

PROTOCOL_MAJOR = "%03d" % protocol_version.major()
PROTOCOL_MINOR = "%d%02d" % ( protocol_version.medium(), protocol_version.minor() )

class Queue:
    def __init__(self):
        self.delay = 0
        self.packets = []
        
class UGAMEProtocol(protocol.Protocol):
    """UGAMEProtocol"""

    _stats_read = 0
    _stats_write = 0
    
    def __init__(self):
        self._packet = []
        self._packet_len = 0
        self._timer = None
        self._packet2id = lambda x: 0
        self._packet2front = lambda x: False
        self._handler = self._handleConnection
        self._queues = {}
        self._lagmax = 0
        self._lag = 0
        self._prefix = ""
        self._blocked = False
        self.established = 0
        self._protocol_ok = False
        self._poll = True
        self._poll_frequency = 0.01
        self._ping_delay = 5
        if not hasattr(self, 'factory'): self.factory = None

    def error(self, string):
        self.message("ERROR " + string)
        
    def message(self, string):
        print self._prefix + string
        
    def setPingDelay(self, ping_delay):
        self._ping_delay = ping_delay

    def getPingDelay(self):
        return self._ping_delay

    def getLag(self):
        return self._lag
    
    def getOrCreateQueue(self, id):
        if not self._queues.has_key(id):
            self._queues[id] = Queue()
        return self._queues[id]
            
    def connectionMade(self):
        "connectionMade"
        self._sendVersion()

    def connectionLost(self, reason):
        self.established = 0
        if self.factory and self.factory.verbose > 5:
            self.message("connectionLost: reason = " + str(reason))
        if not self._protocol_ok:
            if self.factory and self.factory.verbose > 1:
                self.message("connectionLost: reason = " + str(reason))
            self.protocolInvalid("different", PROTOCOL_MAJOR + "." + PROTOCOL_MINOR)
        
    def _sendVersion(self):
        self.transport.write('CGI %s.%s\n' % ( PROTOCOL_MAJOR, PROTOCOL_MINOR ) )

    def _handleConnection(self, packet):
        pass

    def ignoreIncomingData(self):
        if self._timer and self._timer.active():
            self._timer.cancel()

    def _handleVersion(self):
        buf = ''.join(self._packet)
        if '\n' in buf:
            if buf[:3] == 'CGI':
                major, minor = buf[4:11].split('.')
                if (major, minor) != ( PROTOCOL_MAJOR, PROTOCOL_MINOR ):
                    self.protocolInvalid(major + "." + minor, PROTOCOL_MAJOR + "." + PROTOCOL_MINOR)
                    self.transport.loseConnection()
                    return
                else:
                    self._protocol_ok = True
            else:
                self.protocolInvalid("UNKNOWN", PROTOCOL_MAJOR + "." + PROTOCOL_MINOR)
                self.transport.loseConnection()
                return
            buf = buf[12:]
            self.established = 1
            self._packet[:] = [buf]
            self._packet_len = len(buf)
            self._expected_len = Packet.format_size
            if self.factory and self.factory.verbose > 1:
                self.message("protocol established")
            self.protocolEstablished()
            if self._packet_len > 0:
                self.dataReceived("")
            self._processQueues()
        else:
            self._packet[:] = [buf]
            self._packet_len = len(buf)

    def protocolEstablished(self):
        pass

    def protocolInvalid(self, server, client):
        pass
    
    def hold(self, delay, id = None):
        if delay > 0:
            delay = seconds() + delay
        if id == None:
            for (id, queue) in self._queues.iteritems():
                queue.delay = delay
        else:
            self.getOrCreateQueue(id).delay = delay

    def block(self):
        self._blocked = True

    def unblock(self):
        self._blocked = False
        self.triggerTimer()
        
    def discardPackets(self, id):
        if self._queues.has_key(id):
            self._queues[id] = Queue()
            del self._queues[id]

    def canHandlePacket(self, packet):
        return (True, 0)
    
    def _processQueues(self):
        if not self._blocked:
            now = seconds()
            to_delete = []
            #
            # Shallow copy the queues list so that 
            # self.discardPacket can remove an entry
            # without compromising the for loop on queues
            #
            queues = self._queues.copy()
            lags = [0]
            #
            # Process exactly one packet in each queue
            #
            for (id, queue) in queues.iteritems():
                #
                # Keep an empty queue if it contains a delay, otherwise get
                # rid of it.
                #
                if len(queue.packets) <= 0:
                    if queue.delay <= now:
                        to_delete.append(id)
                    continue #pragma: no cover
                #
                # If lagging behind too much, ignore the imposed delay
                #
                lag = now - queue.packets[0].time__
                lags.append(lag)
                if queue.delay > now and lag > self._lagmax:
                    if self.factory and self.factory.verbose > 0:
		        self.message(" => queue %d delay canceled because lag too high" % id)
                    queue.delay = 0
                #
                # If time has come, process one packet
                #
                if queue.delay <= now:
                    if queue.packets[0].nodelay__:
                        ( can_handle, delay ) = ( True, 0 )
                    else:
                        ( can_handle, delay ) = self.canHandlePacket(queue.packets[0])
                    if can_handle:
                        packet = queue.packets.pop(0)
                        del packet.time__
                        del packet.nodelay__
                        self._handler(packet)
                    elif delay > now:
                        queue.delay = delay
                        self._queues[id].delay = delay
                else:
                    if self.factory and self.factory.verbose > 5:
                        self.message("wait %s seconds before handling the next packet in queue %s" % ( str(queue.delay - now), str(id) ))
            #
            # remember the worst lag
            #
            self._lag = max(lags)
            #
            # Remove empty queues for which there is no delay
            #
            for id in to_delete:
                del self._queues[id]

        self.triggerTimer()

    def triggerTimer(self):
        if not self._timer or not self._timer.active():
            if self._poll and len(self._queues) > 0:
                self._timer = reactor.callLater(self._poll_frequency, self._processQueues)            

    def pushPacket(self, packet):
        id = self._packet2id(packet)
        if id != None:
            packet.time__ = seconds()
            front = self._packet2front(packet)
            if front and self._queues.has_key(id):
                packet.nodelay__ = True
                self._queues[id].packets.insert(0, packet)
            else:
                packet.nodelay__ = False
                self.getOrCreateQueue(id).packets.append(packet)
            self.triggerTimer()
        
    def handleData(self):
        if self._packet_len >= self._expected_len:
            type = Packet()
            buf = ''.join(self._packet)
            while len(buf) >= self._expected_len:
                type.unpack(buf)
                if type.length <= len(buf):

                    if PacketFactory.has_key(type.type):
                        packet = PacketFactory[type.type]()
                        buf = packet.unpack(buf)
                        if self.factory and self.factory.verbose > 4:
                            self.message("%s(%d bytes) => %s" % ( self._prefix, type.length, packet ))
                        if self._poll:
                            self.pushPacket(packet)
                        else:
                            self._handler(packet)
                    else:
                        if self.factory and self.factory.verbose >= 0:                        
                            self.message("%s: unknown message received (id %d, length %d)\n" % ( self._prefix, type.type, type.length ))
                        if self.factory and self.factory.verbose > 4:
                            self.message("known types are %s " % PacketNames)
                        buf = buf[1:]
                    self._expected_len = Packet.format_size
                else:
                    self._expected_len = type.length
            self._packet[:] = [buf]
            self._packet_len = len(buf)
        
    def dataReceived(self, data):
        UGAMEProtocol._stats_read += len(data)
        self._packet.append(data)
        self._packet_len += len(data)

        if self.established:
            self.handleData()
        else:
            self._handleVersion()

    def dataWrite(self, data):
        UGAMEProtocol._stats_write += len(data)
        self.transport.write(data)

########NEW FILE########
__FILENAME__ = proxy
#
# Copyright (C) 2006 Mekensleep
#
# Mekensleep
# 24 rue vieille du temple
# 75004 Paris
#       licensing@mekensleep.com
#
# MIT License
# 
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Authors:
#  Loic Dachary <loic@gnu.org>
#
from twisted.internet import base, tcp, ssl, interfaces, protocol, address
from re import match

#
# implements draft-luotonen-web-proxy-tunneling-01.txt
#
class ConnectProtocol(protocol.Protocol):

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.buffer = ""

    def connectionMade(self):
        self.transport.write('CONNECT %s:%d HTTP/1.0\n\n' % ( self.host, self.port ) )
        self.bufferSize = self.transport.bufferSize
        #
        # Read bytes one by one because we don't want to read
        # ONE too many byte from the input (this extra byte will
        # be the first of the protocol being proxied).
        #
        self.transport.bufferSize = 1

    def dataReceived(self, data):
        self.buffer += data
        buffer = self.buffer.replace('\r','')
        if '\n\n' in buffer:
            if not match("^HTTP/\d\.\d\s+2\d\d", buffer):
                raise Exception, buffer
            self.transport.bufferSize = self.bufferSize
            self.transport._proxyConnectDone()

class Client(ssl.Client):

    def __init__(self, host, port, bindAddress, contextFactory, connector, proxy, reactor=None):
        self.contextFactory = contextFactory
        self.proxy = proxy
        ssl.Client.__init__(self, host, port, bindAddress, contextFactory, connector, reactor)

    def getHost(self):
        h, p = self.socket.getsockname()
        bwHack = self.contextFactory and 'SSL' or 'INET'
        return address.IPv4Address('TCP', h, p, bwHack)

    def getPeer(self):
        bwHack = self.contextFactory and 'SSL' or 'INET'
        return address.IPv4Address('TCP', self.addr[0], self.addr[1], bwHack)

    def _connectDone(self):
        if self.proxy:
            self.protocol = ConnectProtocol(*self.proxy)
            self.connected = 1
            self.protocol.makeConnection(self)
            self.logstr = self.protocol.__class__.__name__+",client"
            self.startReading()
        else:
            self._proxyConnectDone()
            
    def _proxyConnectDone(self):
        #
        # Will be reset by Client._connecDone but do it anyway to 
        # remind ourselves that the proxy protocol is to be discarded
        #
        self.protocol = None
        if self.contextFactory:
            self.startTLS(self.contextFactory)
            self.startWriting()
        tcp.Client._connectDone(self)

class Connector(ssl.Connector):
    """
    TCP Connector (with or without SSL) that is able to connect thru a transparent proxy.
    Example usage:

    c = Connector(host = "foo.com", port = 25, factory = client_factory,
                  contextFactory = ssl.ClientContextFactory(),
                  timeout = 60, bindAddress = None, reactor = reactor)
    c.setProxyHost("myproxy.com:80")
    c.connect()

    The connector will connect to myproxy.com and send it a request to connect to foo.com:25.
    When myproxy.com acknoledges that the connection to foo.com:25 is established, the
    connector behaves exactly as if a direct connection to foo.com:25 was made. Except that
    foo.com:25 will see a connection from myproxy.com instead.

    This transparent proxy method is documented in draft-luotonen-web-proxy-tunneling-01.txt
    and implemented in the mod_proxy apache module (look for the AllowCONNECT directive in
    the documentation).

    """
    def __init__(self, host, port, factory, contextFactory, timeout, bindAddress, reactor=None):
        self.host = host
        self.port = port
        self.proxy = None
        ssl.Connector.__init__(self, host, port, factory, contextFactory, timeout, bindAddress, reactor)

    def setProxyHost(self, host):
        host = host.split(':')
        self.proxy = ( host[0], int(host[1]) )
                     
    def _makeTransport(self):
        return Client(self.host, self.port, self.bindAddress, self.contextFactory, self, self.proxy, self.reactor)

    def getDestination(self):
        bwHack = self.contextFactory and 'SSL' or 'INET'
        return address.IPv4Address('TCP', self.host, self.port, bwHack)

########NEW FILE########
__FILENAME__ = proxyfilter
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

from twisted.internet import defer, protocol, reactor, error
from twisted.web import http

from pokernetwork.pokerpackets import PacketPokerTableJoin

local_reactor = reactor

class ProxyClient(http.HTTPClient):
    """
    Used by ProxyClientFactory to implement a simple web proxy.
    """

    def __init__(self, command, rest, version, headers, data, father):
        self.father = father
        self.command = command
        self.rest = rest
        if "proxy-connection" in headers:
            del headers["proxy-connection"]
        headers["connection"] = "close"
        self.headers = headers
        self.data = data

    def connectionMade(self):
        self.sendCommand(self.command, self.rest)
        for header, value in self.headers.items():
            self.sendHeader(header, value)
        self.endHeaders()
        self.transport.write(self.data)

    def handleStatus(self, version, code, message):
        self.father.setResponseCode(int(code), message)

    def handleHeader(self, key, value):
        self.father.setHeader(key, value)

    def handleResponse(self, buffer):
        self.father.write(buffer)
        
    def connectionLost(self, reason):
        self.father.finish()

class ProxyClientFactory(protocol.ClientFactory):

    serial = 0
    
    protocol = ProxyClient

    def __init__(self, command, rest, version, headers, data, father, verbose, destination):
        self.father = father
        self.command = command
        self.rest = rest
        self.headers = headers
        self.data = data
        self.version = version
        self.deferred = defer.Deferred()
        self.verbose = verbose
        self.noisy = False
        self.destination = destination
        ProxyClientFactory.serial += 1
        self.serial = ProxyClientFactory.serial

    def message(self, string):
        print 'Proxy(%d) %s' % ( self.serial, string )

    def doStart(self):
        if self.verbose >= 3:
            self.message('START %s => %s' % ( self.data, self.destination ))
        protocol.ClientFactory.doStart(self)

    def doStop(self):
        if self.verbose >= 3:
            self.message('STOP')
        protocol.ClientFactory.doStop(self)

#    def error(self, string):
#	self.message("*ERROR* " + str(string))

    def buildProtocol(self, addr):
        return self.protocol(self.command, self.rest, self.version,
                             self.headers, self.data, self.father)

    def clientConnectionFailed(self, connector, reason):
        if not self.deferred.called:
            self.deferred.errback(reason)

    def clientConnectionLost(self, connector, reason):
        if not self.deferred.called:
            if reason.check(error.ConnectionDone):
                self.deferred.callback(True)
            else:
                self.deferred.errback(reason)
        
#
# return a value if all actions were complete
#
def rest_filter(site, request, packet):
    if request.finished:
        #
        # the request has been answered by a filter earlier in the chain
        #
        return True
    service = site.resource.service
    resthost, game_id = service.packet2resthost(packet)
    if resthost:
        ( host, port, path ) = resthost
        parts = request.uri.split('?', 1)
        if len(parts) > 1:
            path += '?' + parts[1]
        request.content.seek(0, 0)
        clientFactory = ProxyClientFactory(
            request.method, path, request.clientproto,
            request.getAllHeaders(), request.content.read(), request,
            service.verbose, host + ':' + str(port) + path)
        local_reactor.connectTCP(host, int(port), clientFactory)
        return clientFactory.deferred
    return True

########NEW FILE########
__FILENAME__ = server
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Henry Precheur <henry@precheur.org> (2004)
#
#
import sys
from twisted.internet import reactor, protocol, defer

from pokernetwork.protocol import UGAMEProtocol
from pokernetwork.packets import PacketError

class PokerServerProtocol(UGAMEProtocol):
    """UGAMEServerProtocol"""

    def __init__(self):
        self._ping_timer = None
        self.bufferized_packets = []
        self.avatar = None
        UGAMEProtocol.__init__(self)
        self._ping_delay = 10

    def _handleConnection(self, packet):
        try:
            self.ping()
            self.block()
            self.sendPackets(self.avatar.handlePacket(packet))
        except:
            if hasattr(self, 'exception'):
                #
                # For test purposes : if the instance has an exception member
                # store the exception instead of raising it and lose the connection.
                # It's not trivial to catch / control the twisted behavior when
                # a protocol exits because of a stack trace. 
                #
                self.exception = sys.exc_info()
                self.unblock()
                self.transport.loseConnection()
            else:
                self.unblock()
                raise

    def sendPackets(self, packets):
        self.unblock()
        if not hasattr(self, 'transport') or not self.transport:
            if self.factory.verbose:
                self.message("server: packets " + str(packets) + " bufferized because the protocol has no usuable transport")
            self.bufferized_packets.extend(packets)
            return
        while len(packets) > 0:
            packet = packets.pop(0)
            if isinstance(packet, defer.Deferred):
                packet.addCallback(self.unshiftPacket, packets)
                packet.addErrback(self.deferredError, packets)
                #
                # No packet may be received while sending the answer to
                # a previous packet.
                #
                self.block()
                break
            else:
                self.sendPacket(packet)

    def deferredError(self, reason, packets):
        packet = PacketError(message = str(reason))
        packets.insert(0, packet)
        self.sendPackets(packets)

    def unshiftPacket(self, packet, packets):
        packets.insert(0, packet)
        self.sendPackets(packets)

    def sendPacket(self, packet):
        self.dataWrite(packet.pack())

    def protocolEstablished(self):
        self.transport.setTcpKeepAlive(True)
        self._ping_delay = self.factory.service._ping_delay
        self.avatar = self.factory.createAvatar()
        self.avatar.setProtocol(self)
        self._ping_timer = reactor.callLater(self._ping_delay, self.ping)
        for packet in self.bufferized_packets:
            self.sendPacket(packet)
        self.bufferized_packets = []

    def connectionLost(self, reason):
        if hasattr(self, "_ping_timer") and self._ping_timer and self._ping_timer.active():
            self._ping_timer.cancel()
        self._ping_timer = None
        if self.avatar:
            while len(self._queues) > 0:
                self._processQueues()
            self.factory.destroyAvatar(self.avatar)
        del self.avatar
        self.ignoreIncomingData()
        UGAMEProtocol.connectionLost(self, reason)

    def protocolInvalid(self, client, server):
        if self.factory.verbose:
            self.message("client with protocol %s rejected (need %s)" % ( client, server ))

    def ping(self):
        if not hasattr(self, "_ping_timer") or not self._ping_timer:
            return

        if self._ping_timer.active():
            if self.factory.verbose > 6 and hasattr(self, "user") and self.user:
                self.message("ping: renew %s/%s" % ( self.user.name, self.user.serial ))
            self._ping_timer.reset(self._ping_delay)
        else:
            self._ping_timer = None
            if self.factory.verbose and hasattr(self, "user") and self.user:
                self.message("ping: timeout %s/%s" % ( self.user.name, self.user.serial ))
            self.transport.loseConnection()

########NEW FILE########
__FILENAME__ = sessionproxyfilter
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2009 Johan Euphrosine <proppy@aminche.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

from twisted.internet import reactor
from pokernetwork.pokerrestclient import PokerProxyClientFactory

local_reactor = reactor
        
#                                                                               
# return a value if all actions were complete
#
def rest_filter(site, request, packet):
    if request.finished:                                                        #pragma: no cover
        #
        # the request has been answered by a filter earlier in the chain
        #
        return True                                                             #pragma: no cover
    service = site.resource.service                                             #pragma: no cover
    uid = request.args.get('uid', [''])[0]                                      #pragma: no cover

    if uid:                                                                     #pragma: no cover
        resthost = site.memcache.get(uid)                                       #pragma: no cover
        if resthost:                                                            #pragma: no cover
            (host, port, path) = [str(s) for s in resthost]                     #pragma: no cover
            parts = request.uri.split('?', 1)                                   #pragma: no cover
            if len(parts) > 1:                                                  #pragma: no cover
                path += '?' + parts[1]                                          #pragma: no cover
            request.content.seek(0, 0)                                          #pragma: no cover
            header = request.getAllHeaders()                                    #pragma: no cover
            data = request.content.read()                                       #pragma: no cover
            clientFactory = PokerProxyClientFactory(                            #pragma: no cover
                request.method, path, request.clientproto,                      #pragma: no cover
                header, data, request,                                          #pragma: no cover
                service.verbose, host + ':' + str(port) + path)                 #pragma: no cover
            local_reactor.connectTCP(host, int(port), clientFactory)            #pragma: no cover
            return clientFactory.deferred                                       #pragma: no cover
    return True                                                                 #pragma: no cover

########NEW FILE########
__FILENAME__ = tableconfigutils
#!/usr/bin/env python
# coding: utf-8

import glob
import os

from pokernetwork import pokernetworkconfig


DEFAULT_TABLE_CONFIGS_DIR = '/etc/poker-network/tables.d'
DEFAULT_TABLE_NODE_XPATH = '/*/table'


def __get_tables(config, table_node_xpath=DEFAULT_TABLE_NODE_XPATH):
    return config.headerGetProperties(table_node_xpath)


def parse_table_config(table_config_path,
                       table_node_xpath=DEFAULT_TABLE_NODE_XPATH):
    """
    Parses table properties from the XML config specified by
    `table_config_path`. Tables are represented as XML nodes and specified by
    the XPath expression, `table_node_xpath`. Table properties are XML
    attributes. nodes specified by the XPath expression, `table_node_xpath`.

    Here is an example of a table config consisting of 2 table nodes, with
    table_node_xpath of '/tables/table':

        <?xml version="1.0" encoding="UTF-8"?>
        <tables>
            <table name="Table1" variant="holdem" betting_structure=".05-.10-no-limit" seats="6" />
            <table name="Table2" variant="omaha8" betting_structure="10-20-limit" seats="10" />
        </tables>

    Returns a list of dicts with keys corresponding to table properties (name,
    variant, betting_structure, seats, etc.).
    """
    config = pokernetworkconfig.Config([''])
    config.load(table_config_path)
    return config.headerGetProperties(table_node_xpath)


def parse_table_configs(table_configs_dir=DEFAULT_TABLE_CONFIGS_DIR,
                        table_node_xpath=DEFAULT_TABLE_NODE_XPATH):
    """
    Parses table configs found in `table_configs_dir`.

    Returns a list of dicts with keys corresponding to table properties (name,
    variant, betting_structure, seats, etc.).

    `table_configs_dir`: directory containing table configuration files
    `table_node_xpath`: the XPath expression used to find table nodes in each
                        config file
    """
    tables = []
    table_config_paths = glob.glob(os.path.join(table_configs_dir, '*.xml'))
    for table_config_path in table_config_paths:
        tables.extend(parse_table_config(table_config_path))
    return tables


def merge_tables(server_config_tables, table_config_tables):
    """
    Merges server_config_tables with table_config_tables.

    When a table with the same name is found in both the server config and
    a table config, we use the table settings from the table config. In
    other words, table entries in table configs take precedence over table
    entries in the server config.

    Returns a list of dictionaries with keys corresponding to table
    properties (name, variant, seats, etc.).

    `server_config_tables`: a list of dictionaries with keys corresponding
                            to table properties (name, variant, seats,
                            etc.)
    `table_config_tables`: a list of dictionaries with keys corresponding
                           to table properties (name, variant, seats,
                           etc.)
    """
    tables = []
    table_names = set()

    def try_add_table(table):
        table_name = table['name']
        if table_name not in table_names:
            table_names.add(table_name)
            tables.append(table)

    for table in table_config_tables:
        try_add_table(table)
    for table in server_config_tables:
        try_add_table(table)
    return tables


def get_table_descriptions(server_config,
                           table_configs_dir=DEFAULT_TABLE_CONFIGS_DIR,
                           table_node_xpath=DEFAULT_TABLE_NODE_XPATH):
    """
    Combines table descriptions in `server_config` with table config files
    located in `table_configs_dir`. Table descriptions in table config files
    take precedence over table descriptions in the server config.

    Returns a list of dicts with keys corresponding to table properties (name,
    variant, betting_structure, seats, etc.).

    `server_config`: a pokernetwork.pokernetworkconfig.Config object
    `table_configs_dir`: directory containing XML table configuration files
    `table_node_xpath`: the XPath expression used to find table nodes in each
                        config file
    """
    server_config.reload()

    server_config_tables = __get_tables(server_config)
    table_config_tables = parse_table_configs(table_configs_dir)
    return merge_tables(server_config_tables, table_config_tables)

########NEW FILE########
__FILENAME__ = user
#
# Copyright (C) 2008 Loic Dachary
# Copyright (C) 2004, 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Henry Precheur <henry@precheur.org>
#  Loic Dachary <loic@dachary.org>
#
from re import match

from pokernetwork.pokerpackets import PacketPokerSetAccount

NAME_LENGTH_MAX = 50
NAME_LENGTH_MIN = 5

PASSWORD_LENGTH_MAX = 15
PASSWORD_LENGTH_MIN = 5

def checkName(name):
    if not match("^[a-zA-Z][a-zA-Z0-9_]{" + str(NAME_LENGTH_MIN - 1) + "," + str(NAME_LENGTH_MAX - 1) + "}$", name):
        if len(name) > NAME_LENGTH_MAX:
            return (False, PacketPokerSetAccount.NAME_TOO_LONG, "login name must be at most %d characters long" % NAME_LENGTH_MAX)
        elif len(name) < NAME_LENGTH_MIN:
            return (False, PacketPokerSetAccount.NAME_TOO_SHORT, "login name must be at least %d characters long" % NAME_LENGTH_MIN)
        elif not match("^[a-zA-Z]", name):
            return (False, PacketPokerSetAccount.NAME_MUST_START_WITH_LETTER, "login name must start with a letter")
        else:
            return (False, PacketPokerSetAccount.NAME_NOT_ALNUM, "login name must be all letters, digits or underscore ")

    return (True, None, None)

def checkPassword(password):
    if not match("^[a-zA-Z0-9]{" + str(PASSWORD_LENGTH_MIN) + "," + str(PASSWORD_LENGTH_MAX) + "}$", password):
        if len(password) > PASSWORD_LENGTH_MAX:
            return (False, PacketPokerSetAccount.PASSWORD_TOO_LONG, "password must be at most %d characters long" % PASSWORD_LENGTH_MAX)
        elif len(password) < PASSWORD_LENGTH_MIN:
            return (False, PacketPokerSetAccount.PASSWORD_TOO_SHORT, "password must be at least %d characters long" % PASSWORD_LENGTH_MIN)
        else:
            return (False, PacketPokerSetAccount.PASSWORD_NOT_ALNUM, "password must be all letters and digits")

    return (True, None, None)

def checkNameAndPassword(name, password):
    status = checkName(name)
    if status[0]:
        return checkPassword(password)
    else:
        return status

class User:
    REGULAR = 1
    ADMIN = 2

    def __init__(self, serial = 0):
        self.serial = serial
        self.name = "anonymous"
        self.url = "random"
        self.outfit = "random"
        self.privilege = None

    def logout(self):
        self.serial = 0
        self.name = "anonymous"
        self.url = "random"
        self.outfit = "random"
        self.privilege = None
        
    def isLogged(self):
        return not self.serial == 0

    def hasPrivilege(self, privilege):
        if not privilege:
            return True
        
        return self.privilege >= privilege

    def __str__(self):
        return "serial = %d, name = %s, url = %s, outfit = %s, privilege = %d" % ( self.serial, self.name, self.url, self.outfit, self.privilege )

########NEW FILE########
__FILENAME__ = version
# -*- python -*-
#
# Copyright (C) 2005, 2006 Mekensleep <licensing@mekensleep.com>
#                          24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
# 
from pokerengine.version import Version
from pokernetwork import version_number

version = Version(version_number)

########NEW FILE########
__FILENAME__ = coverage
#!/usr/bin/python
#
#             Perforce Defect Tracking Integration Project
#              <http://www.ravenbrook.com/project/p4dti/>
#
#                   COVERAGE.PY -- COVERAGE TESTING
#
#             Gareth Rees, Ravenbrook Limited, 2001-12-04
#                     Ned Batchelder, 2004-12-12
#         http://nedbatchelder.com/code/modules/coverage.html
#
#
# 1. INTRODUCTION
#
# This module provides coverage testing for Python code.
#
# The intended readership is all Python developers.
#
# This document is not confidential.
#
# See [GDR 2001-12-04a] for the command-line interface, programmatic
# interface and limitations.  See [GDR 2001-12-04b] for requirements and
# design.

r"""Usage:

coverage.py -x [-p] MODULE.py [ARG1 ARG2 ...]
    Execute module, passing the given command-line arguments, collecting
    coverage data. With the -p option, write to a temporary file containing
    the machine name and process ID.

coverage.py -e
    Erase collected coverage data.

coverage.py -c
    Collect data from multiple coverage files (as created by -p option above)
    and store it into a single file representing the union of the coverage.

coverage.py -r [-m] [-o dir1,dir2,...] FILE1 FILE2 ...
    Report on the statement coverage for the given files.  With the -m
    option, show line numbers of the statements that weren't executed.

coverage.py -a [-d dir] [-o dir1,dir2,...] FILE1 FILE2 ...
    Make annotated copies of the given files, marking statements that
    are executed with > and statements that are missed with !.  With
    the -d option, make the copies in that directory.  Without the -d
    option, make each copy in the same directory as the original.

-o dir,dir2,...
  Omit reporting or annotating files when their filename path starts with
  a directory listed in the omit list.
  e.g. python coverage.py -i -r -o c:\python23,lib\enthought\traits

Coverage data is saved in the file .coverage by default.  Set the
COVERAGE_FILE environment variable to save it somewhere else."""

__version__ = "2.78.20070930"    # see detailed history at the end of this file.

import compiler
import compiler.visitor
import glob
import os
import re
import string
import symbol
import sys
import threading
import token
import types
from socket import gethostname

# Python version compatibility
try:
    strclass = basestring   # new to 2.3
except:
    strclass = str

# 2. IMPLEMENTATION
#
# This uses the "singleton" pattern.
#
# The word "morf" means a module object (from which the source file can
# be deduced by suitable manipulation of the __file__ attribute) or a
# filename.
#
# When we generate a coverage report we have to canonicalize every
# filename in the coverage dictionary just in case it refers to the
# module we are reporting on.  It seems a shame to throw away this
# information so the data in the coverage dictionary is transferred to
# the 'cexecuted' dictionary under the canonical filenames.
#
# The coverage dictionary is called "c" and the trace function "t".  The
# reason for these short names is that Python looks up variables by name
# at runtime and so execution time depends on the length of variables!
# In the bottleneck of this application it's appropriate to abbreviate
# names to increase speed.

class StatementFindingAstVisitor(compiler.visitor.ASTVisitor):
    """ A visitor for a parsed Abstract Syntax Tree which finds executable
        statements.
    """
    def __init__(self, statements, excluded, suite_spots):
        compiler.visitor.ASTVisitor.__init__(self)
        self.statements = statements
        self.excluded = excluded
        self.suite_spots = suite_spots
        self.excluding_suite = 0
        
    def doRecursive(self, node):
        for n in node.getChildNodes():
            self.dispatch(n)

    visitStmt = visitModule = doRecursive
    
    def doCode(self, node):
        if hasattr(node, 'decorators') and node.decorators:
            self.dispatch(node.decorators)
            self.recordAndDispatch(node.code)
        else:
            self.doSuite(node, node.code)
            
    visitFunction = visitClass = doCode

    def getFirstLine(self, node):
        # Find the first line in the tree node.
        lineno = node.lineno
        for n in node.getChildNodes():
            f = self.getFirstLine(n)
            if lineno and f:
                lineno = min(lineno, f)
            else:
                lineno = lineno or f
        return lineno

    def getLastLine(self, node):
        # Find the first line in the tree node.
        lineno = node.lineno
        for n in node.getChildNodes():
            lineno = max(lineno, self.getLastLine(n))
        return lineno
    
    def doStatement(self, node):
        self.recordLine(self.getFirstLine(node))

    visitAssert = visitAssign = visitAssTuple = visitPrint = \
        visitPrintnl = visitRaise = visitSubscript = visitDecorators = \
        doStatement
    
    def visitPass(self, node):
        # Pass statements have weird interactions with docstrings.  If this
        # pass statement is part of one of those pairs, claim that the statement
        # is on the later of the two lines.
        l = node.lineno
        if l:
            lines = self.suite_spots.get(l, [l,l])
            self.statements[lines[1]] = 1
        
    def visitDiscard(self, node):
        # Discard nodes are statements that execute an expression, but then
        # discard the results.  This includes function calls, so we can't 
        # ignore them all.  But if the expression is a constant, the statement
        # won't be "executed", so don't count it now.
        if node.expr.__class__.__name__ != 'Const':
            self.doStatement(node)

    def recordNodeLine(self, node):
        # Stmt nodes often have None, but shouldn't claim the first line of
        # their children (because the first child might be an ignorable line
        # like "global a").
        if node.__class__.__name__ != 'Stmt':
            return self.recordLine(self.getFirstLine(node))
        else:
            return 0
    
    def recordLine(self, lineno):
        # Returns a bool, whether the line is included or excluded.
        if lineno:
            # Multi-line tests introducing suites have to get charged to their
            # keyword.
            if lineno in self.suite_spots:
                lineno = self.suite_spots[lineno][0]
            # If we're inside an excluded suite, record that this line was
            # excluded.
            if self.excluding_suite:
                self.excluded[lineno] = 1
                return 0
            # If this line is excluded, or suite_spots maps this line to
            # another line that is exlcuded, then we're excluded.
            elif self.excluded.has_key(lineno) or \
                 self.suite_spots.has_key(lineno) and \
                 self.excluded.has_key(self.suite_spots[lineno][1]):
                return 0
            # Otherwise, this is an executable line.
            else:
                self.statements[lineno] = 1
                return 1
        return 0
    
    default = recordNodeLine
    
    def recordAndDispatch(self, node):
        self.recordNodeLine(node)
        self.dispatch(node)

    def doSuite(self, intro, body, exclude=0):
        exsuite = self.excluding_suite
        if exclude or (intro and not self.recordNodeLine(intro)):
            self.excluding_suite = 1
        self.recordAndDispatch(body)
        self.excluding_suite = exsuite
        
    def doPlainWordSuite(self, prevsuite, suite):
        # Finding the exclude lines for else's is tricky, because they aren't
        # present in the compiler parse tree.  Look at the previous suite,
        # and find its last line.  If any line between there and the else's
        # first line are excluded, then we exclude the else.
        lastprev = self.getLastLine(prevsuite)
        firstelse = self.getFirstLine(suite)
        for l in range(lastprev+1, firstelse):
            if self.suite_spots.has_key(l):
                self.doSuite(None, suite, exclude=self.excluded.has_key(l))
                break
        else:
            self.doSuite(None, suite)
        
    def doElse(self, prevsuite, node):
        if node.else_:
            self.doPlainWordSuite(prevsuite, node.else_)
    
    def visitFor(self, node):
        self.doSuite(node, node.body)
        self.doElse(node.body, node)

    visitWhile = visitFor

    def visitIf(self, node):
        # The first test has to be handled separately from the rest.
        # The first test is credited to the line with the "if", but the others
        # are credited to the line with the test for the elif.
        self.doSuite(node, node.tests[0][1])
        for t, n in node.tests[1:]:
            self.doSuite(t, n)
        self.doElse(node.tests[-1][1], node)

    def visitTryExcept(self, node):
        self.doSuite(node, node.body)
        for i in range(len(node.handlers)):
            a, b, h = node.handlers[i]
            if not a:
                # It's a plain "except:".  Find the previous suite.
                if i > 0:
                    prev = node.handlers[i-1][2]
                else:
                    prev = node.body
                self.doPlainWordSuite(prev, h)
            else:
                self.doSuite(a, h)
        self.doElse(node.handlers[-1][2], node)
    
    def visitTryFinally(self, node):
        self.doSuite(node, node.body)
        self.doPlainWordSuite(node.body, node.final)
        
    def visitWith(self, node):
        self.doSuite(node, node.body)
        
    def visitGlobal(self, node):
        # "global" statements don't execute like others (they don't call the
        # trace function), so don't record their line numbers.
        pass

the_coverage = None

class CoverageException(Exception): pass

class coverage:
    # Name of the cache file (unless environment variable is set).
    cache_default = ".coverage"

    # Environment variable naming the cache file.
    cache_env = "COVERAGE_FILE"

    # A dictionary with an entry for (Python source file name, line number
    # in that file) if that line has been executed.
    c = {}
    
    # A map from canonical Python source file name to a dictionary in
    # which there's an entry for each line number that has been
    # executed.
    cexecuted = {}

    # Cache of results of calling the analysis2() method, so that you can
    # specify both -r and -a without doing double work.
    analysis_cache = {}

    # Cache of results of calling the canonical_filename() method, to
    # avoid duplicating work.
    canonical_filename_cache = {}

    def __init__(self):
        global the_coverage
        if the_coverage:
            raise CoverageException("Only one coverage object allowed.")
        self.usecache = 1
        self.cache = None
        self.parallel_mode = False
        self.exclude_re = ''
        self.nesting = 0
        self.cstack = []
        self.xstack = []
        self.relative_dir = os.path.normcase(os.path.abspath(os.curdir)+os.sep)
        self.exclude('# *pragma[: ]*[nN][oO] *[cC][oO][vV][eE][rR]')

    # t(f, x, y).  This method is passed to sys.settrace as a trace function.  
    # See [van Rossum 2001-07-20b, 9.2] for an explanation of sys.settrace and 
    # the arguments and return value of the trace function.
    # See [van Rossum 2001-07-20a, 3.2] for a description of frame and code
    # objects.
    
    def t(self, f, w, unused):                                 #pragma: no cover
        if w == 'line':
            #print "Executing %s @ %d" % (f.f_code.co_filename, f.f_lineno)
            self.c[(f.f_code.co_filename, f.f_lineno)] = 1
            for c in self.cstack:
                c[(f.f_code.co_filename, f.f_lineno)] = 1
        return self.t
    
    def help(self, error=None):     #pragma: no cover
        if error:
            print error
            print
        print __doc__
        sys.exit(1)

    def command_line(self, argv, help_fn=None):
        import getopt
        help_fn = help_fn or self.help
        settings = {}
        optmap = {
            '-a': 'annotate',
            '-c': 'collect',
            '-d:': 'directory=',
            '-e': 'erase',
            '-h': 'help',
            '-i': 'ignore-errors',
            '-m': 'show-missing',
            '-p': 'parallel-mode',
            '-r': 'report',
            '-x': 'execute',
            '-o:': 'omit=',
            }
        short_opts = string.join(map(lambda o: o[1:], optmap.keys()), '')
        long_opts = optmap.values()
        options, args = getopt.getopt(argv, short_opts, long_opts)
        for o, a in options:
            if optmap.has_key(o):
                settings[optmap[o]] = 1
            elif optmap.has_key(o + ':'):
                settings[optmap[o + ':']] = a
            elif o[2:] in long_opts:
                settings[o[2:]] = 1
            elif o[2:] + '=' in long_opts:
                settings[o[2:]+'='] = a
            else:       #pragma: no cover
                pass    # Can't get here, because getopt won't return anything unknown.

        if settings.get('help'):
            help_fn()

        for i in ['erase', 'execute']:
            for j in ['annotate', 'report', 'collect']:
                if settings.get(i) and settings.get(j):
                    help_fn("You can't specify the '%s' and '%s' "
                              "options at the same time." % (i, j))

        args_needed = (settings.get('execute')
                       or settings.get('annotate')
                       or settings.get('report'))
        action = (settings.get('erase') 
                  or settings.get('collect')
                  or args_needed)
        if not action:
            help_fn("You must specify at least one of -e, -x, -c, -r, or -a.")
        if not args_needed and args:
            help_fn("Unexpected arguments: %s" % " ".join(args))
        
        self.parallel_mode = settings.get('parallel-mode')
        self.get_ready()

        if settings.get('erase'):
            self.erase()
        if settings.get('execute'):
            if not args:
                help_fn("Nothing to do.")
            sys.argv = args
            self.start()
            import __main__
            sys.path[0] = os.path.dirname(sys.argv[0])
            execfile(sys.argv[0], __main__.__dict__)
        if settings.get('collect'):
            self.collect()
        if not args:
            args = self.cexecuted.keys()
        
        ignore_errors = settings.get('ignore-errors')
        show_missing = settings.get('show-missing')
        directory = settings.get('directory=')

        omit = settings.get('omit=')
        if omit is not None:
            omit = omit.split(',')
        else:
            omit = []

        if settings.get('report'):
            self.report(args, show_missing, ignore_errors, omit_prefixes=omit)
        if settings.get('annotate'):
            self.annotate(args, directory, ignore_errors, omit_prefixes=omit)

    def use_cache(self, usecache, cache_file=None):
        self.usecache = usecache
        if cache_file and not self.cache:
            self.cache_default = cache_file
        
    def get_ready(self, parallel_mode=False):
        if self.usecache and not self.cache:
            self.cache = os.environ.get(self.cache_env, self.cache_default)
            if self.parallel_mode:
                self.cache += "." + gethostname() + "." + str(os.getpid())
            self.restore()
        self.analysis_cache = {}
        
    def start(self, parallel_mode=False):
        self.get_ready()
        if self.nesting == 0:                               #pragma: no cover
            sys.settrace(self.t)
            if hasattr(threading, 'settrace'):
                threading.settrace(self.t)
        self.nesting += 1
        
    def stop(self):
        self.nesting -= 1
        if self.nesting == 0:                               #pragma: no cover
            sys.settrace(None)
            if hasattr(threading, 'settrace'):
                threading.settrace(None)

    def erase(self):
        self.get_ready()
        self.c = {}
        self.analysis_cache = {}
        self.cexecuted = {}
        if self.cache and os.path.exists(self.cache):
            os.remove(self.cache)

    def exclude(self, re):
        if self.exclude_re:
            self.exclude_re += "|"
        self.exclude_re += "(" + re + ")"

    def begin_recursive(self):
        self.cstack.append(self.c)
        self.xstack.append(self.exclude_re)
        
    def end_recursive(self):
        self.c = self.cstack.pop()
        self.exclude_re = self.xstack.pop()

    # save().  Save coverage data to the coverage cache.

    def save(self):
        if self.usecache and self.cache:
            self.canonicalize_filenames()
            cache = open(self.cache, 'wb')
            import marshal
            marshal.dump(self.cexecuted, cache)
            cache.close()

    # restore().  Restore coverage data from the coverage cache (if it exists).

    def restore(self):
        self.c = {}
        self.cexecuted = {}
        assert self.usecache
        if os.path.exists(self.cache):
            self.cexecuted = self.restore_file(self.cache)

    def restore_file(self, file_name):
        try:
            cache = open(file_name, 'rb')
            import marshal
            cexecuted = marshal.load(cache)
            cache.close()
            if isinstance(cexecuted, types.DictType):
                return cexecuted
            else:
                return {}
        except:
            return {}

    # collect(). Collect data in multiple files produced by parallel mode

    def collect(self):
        cache_dir, local = os.path.split(self.cache)
        for f in os.listdir(cache_dir or '.'):
            if not f.startswith(local):
                continue

            full_path = os.path.join(cache_dir, f)
            cexecuted = self.restore_file(full_path)
            self.merge_data(cexecuted)

    def merge_data(self, new_data):
        for file_name, file_data in new_data.items():
            if self.cexecuted.has_key(file_name):
                self.merge_file_data(self.cexecuted[file_name], file_data)
            else:
                self.cexecuted[file_name] = file_data

    def merge_file_data(self, cache_data, new_data):
        for line_number in new_data.keys():
            if not cache_data.has_key(line_number):
                cache_data[line_number] = new_data[line_number]

    # canonical_filename(filename).  Return a canonical filename for the
    # file (that is, an absolute path with no redundant components and
    # normalized case).  See [GDR 2001-12-04b, 3.3].

    def canonical_filename(self, filename):
        if not self.canonical_filename_cache.has_key(filename):
            f = filename
            if os.path.isabs(f) and not os.path.exists(f):
                f = os.path.basename(f)
            if not os.path.isabs(f):
                for path in [os.curdir] + sys.path:
                    g = os.path.join(path, f)
                    if os.path.exists(g):
                        f = g
                        break
            cf = os.path.normcase(os.path.abspath(f))
            self.canonical_filename_cache[filename] = cf
        return self.canonical_filename_cache[filename]

    # canonicalize_filenames().  Copy results from "c" to "cexecuted", 
    # canonicalizing filenames on the way.  Clear the "c" map.

    def canonicalize_filenames(self):
        for filename, lineno in self.c.keys():
            if filename == '<string>':
                # Can't do anything useful with exec'd strings, so skip them.
                continue
            f = self.canonical_filename(filename)
            if not self.cexecuted.has_key(f):
                self.cexecuted[f] = {}
            self.cexecuted[f][lineno] = 1
        self.c = {}

    # morf_filename(morf).  Return the filename for a module or file.

    def morf_filename(self, morf):
        if isinstance(morf, types.ModuleType):
            if not hasattr(morf, '__file__'):
                raise CoverageException("Module has no __file__ attribute.")
            f = morf.__file__
        else:
            f = morf
        return self.canonical_filename(f)

    # analyze_morf(morf).  Analyze the module or filename passed as
    # the argument.  If the source code can't be found, raise an error.
    # Otherwise, return a tuple of (1) the canonical filename of the
    # source code for the module, (2) a list of lines of statements
    # in the source code, (3) a list of lines of excluded statements,
    # and (4), a map of line numbers to multi-line line number ranges, for
    # statements that cross lines.
    
    def analyze_morf(self, morf):
        if self.analysis_cache.has_key(morf):
            return self.analysis_cache[morf]
        filename = self.morf_filename(morf)
        ext = os.path.splitext(filename)[1]
        if ext == '.pyc':
            if not os.path.exists(filename[:-1]):
                raise CoverageException(
                    "No source for compiled code '%s'." % filename
                    )
            filename = filename[:-1]
        source = open(filename, 'r')
        try:
            lines, excluded_lines, line_map = self.find_executable_statements(
                source.read(), exclude=self.exclude_re
                )
        except SyntaxError, synerr:
            raise CoverageException(
                "Couldn't parse '%s' as Python source: '%s' at line %d" %
                    (filename, synerr.msg, synerr.lineno)
                )            
        source.close()
        result = filename, lines, excluded_lines, line_map
        self.analysis_cache[morf] = result
        return result

    def first_line_of_tree(self, tree):
        while True:
            if len(tree) == 3 and type(tree[2]) == type(1):
                return tree[2]
            tree = tree[1]
    
    def last_line_of_tree(self, tree):
        while True:
            if len(tree) == 3 and type(tree[2]) == type(1):
                return tree[2]
            tree = tree[-1]
    
    def find_docstring_pass_pair(self, tree, spots):
        for i in range(1, len(tree)):
            if self.is_string_constant(tree[i]) and self.is_pass_stmt(tree[i+1]):
                first_line = self.first_line_of_tree(tree[i])
                last_line = self.last_line_of_tree(tree[i+1])
                self.record_multiline(spots, first_line, last_line)
        
    def is_string_constant(self, tree):
        try:
            return tree[0] == symbol.stmt and tree[1][1][1][0] == symbol.expr_stmt
        except:
            return False
        
    def is_pass_stmt(self, tree):
        try:
            return tree[0] == symbol.stmt and tree[1][1][1][0] == symbol.pass_stmt
        except:
            return False

    def record_multiline(self, spots, i, j):
        for l in range(i, j+1):
            spots[l] = (i, j)
            
    def get_suite_spots(self, tree, spots):
        """ Analyze a parse tree to find suite introducers which span a number
            of lines.
        """
        for i in range(1, len(tree)):
            if type(tree[i]) == type(()):
                if tree[i][0] == symbol.suite:
                    # Found a suite, look back for the colon and keyword.
                    lineno_colon = lineno_word = None
                    for j in range(i-1, 0, -1):
                        if tree[j][0] == token.COLON:
                            # Colons are never executed themselves: we want the
                            # line number of the last token before the colon.
                            lineno_colon = self.last_line_of_tree(tree[j-1])
                        elif tree[j][0] == token.NAME:
                            if tree[j][1] == 'elif':
                                # Find the line number of the first non-terminal
                                # after the keyword.
                                t = tree[j+1]
                                while t and token.ISNONTERMINAL(t[0]):
                                    t = t[1]
                                if t:
                                    lineno_word = t[2]
                            else:
                                lineno_word = tree[j][2]
                            break
                        elif tree[j][0] == symbol.except_clause:
                            # "except" clauses look like:
                            # ('except_clause', ('NAME', 'except', lineno), ...)
                            if tree[j][1][0] == token.NAME:
                                lineno_word = tree[j][1][2]
                                break
                    if lineno_colon and lineno_word:
                        # Found colon and keyword, mark all the lines
                        # between the two with the two line numbers.
                        self.record_multiline(spots, lineno_word, lineno_colon)

                    # "pass" statements are tricky: different versions of Python
                    # treat them differently, especially in the common case of a
                    # function with a doc string and a single pass statement.
                    self.find_docstring_pass_pair(tree[i], spots)
                    
                elif tree[i][0] == symbol.simple_stmt:
                    first_line = self.first_line_of_tree(tree[i])
                    last_line = self.last_line_of_tree(tree[i])
                    if first_line != last_line:
                        self.record_multiline(spots, first_line, last_line)
                self.get_suite_spots(tree[i], spots)

    def find_executable_statements(self, text, exclude=None):
        # Find lines which match an exclusion pattern.
        excluded = {}
        suite_spots = {}
        if exclude:
            reExclude = re.compile(exclude)
            lines = text.split('\n')
            for i in range(len(lines)):
                if reExclude.search(lines[i]):
                    excluded[i+1] = 1

        # Parse the code and analyze the parse tree to find out which statements
        # are multiline, and where suites begin and end.
        import parser
        tree = parser.suite(text+'\n\n').totuple(1)
        self.get_suite_spots(tree, suite_spots)
        #print "Suite spots:", suite_spots
        
        # Use the compiler module to parse the text and find the executable
        # statements.  We add newlines to be impervious to final partial lines.
        statements = {}
        ast = compiler.parse(text+'\n\n')
        visitor = StatementFindingAstVisitor(statements, excluded, suite_spots)
        compiler.walk(ast, visitor, walker=visitor)

        lines = statements.keys()
        lines.sort()
        excluded_lines = excluded.keys()
        excluded_lines.sort()
        return lines, excluded_lines, suite_spots

    # format_lines(statements, lines).  Format a list of line numbers
    # for printing by coalescing groups of lines as long as the lines
    # represent consecutive statements.  This will coalesce even if
    # there are gaps between statements, so if statements =
    # [1,2,3,4,5,10,11,12,13,14] and lines = [1,2,5,10,11,13,14] then
    # format_lines will return "1-2, 5-11, 13-14".

    def format_lines(self, statements, lines):
        pairs = []
        i = 0
        j = 0
        start = None
        pairs = []
        while i < len(statements) and j < len(lines):
            if statements[i] == lines[j]:
                if start == None:
                    start = lines[j]
                end = lines[j]
                j = j + 1
            elif start:
                pairs.append((start, end))
                start = None
            i = i + 1
        if start:
            pairs.append((start, end))
        def stringify(pair):
            start, end = pair
            if start == end:
                return "%d" % start
            else:
                return "%d-%d" % (start, end)
        ret = string.join(map(stringify, pairs), ", ")
        return ret

    # Backward compatibility with version 1.
    def analysis(self, morf):
        f, s, _, m, mf = self.analysis2(morf)
        return f, s, m, mf

    def analysis2(self, morf):
        filename, statements, excluded, line_map = self.analyze_morf(morf)
        self.canonicalize_filenames()
        if not self.cexecuted.has_key(filename):
            self.cexecuted[filename] = {}
        missing = []
        for line in statements:
            lines = line_map.get(line, [line, line])
            for l in range(lines[0], lines[1]+1):
                if self.cexecuted[filename].has_key(l):
                    break
            else:
                missing.append(line)
        return (filename, statements, excluded, missing,
                self.format_lines(statements, missing))

    def relative_filename(self, filename):
        """ Convert filename to relative filename from self.relative_dir.
        """
        return filename.replace(self.relative_dir, "")

    def morf_name(self, morf):
        """ Return the name of morf as used in report.
        """
        if isinstance(morf, types.ModuleType):
            return morf.__name__
        else:
            return self.relative_filename(os.path.splitext(morf)[0])

    def filter_by_prefix(self, morfs, omit_prefixes):
        """ Return list of morfs where the morf name does not begin
            with any one of the omit_prefixes.
        """
        filtered_morfs = []
        for morf in morfs:
            for prefix in omit_prefixes:
                if self.morf_name(morf).startswith(prefix):
                    break
            else:
                filtered_morfs.append(morf)

        return filtered_morfs

    def morf_name_compare(self, x, y):
        return cmp(self.morf_name(x), self.morf_name(y))

    def report(self, morfs, show_missing=1, ignore_errors=0, file=None, omit_prefixes=[]):
        if not isinstance(morfs, types.ListType):
            morfs = [morfs]
        # On windows, the shell doesn't expand wildcards.  Do it here.
        globbed = []
        for morf in morfs:
            if isinstance(morf, strclass):
                globbed.extend(glob.glob(morf))
            else:
                globbed.append(morf)
        morfs = globbed
        
        morfs = self.filter_by_prefix(morfs, omit_prefixes)
        morfs.sort(self.morf_name_compare)

        max_name = max([5,] + map(len, map(self.morf_name, morfs)))
        fmt_name = "%%- %ds  " % max_name
        fmt_err = fmt_name + "%s: %s"
        header = fmt_name % "Name" + " Stmts   Exec  Cover"
        fmt_coverage = fmt_name + "% 6d % 6d % 5d%%"
        if show_missing:
            header = header + "   Missing"
            fmt_coverage = fmt_coverage + "   %s"
        if not file:
            file = sys.stdout
        print >>file, header
        print >>file, "-" * len(header)
        total_statements = 0
        total_executed = 0
        for morf in morfs:
            name = self.morf_name(morf)
            try:
                _, statements, _, missing, readable  = self.analysis2(morf)
                n = len(statements)
                m = n - len(missing)
                if n > 0:
                    pc = 100.0 * m / n
                else:
                    pc = 100.0
                args = (name, n, m, pc)
                if show_missing:
                    args = args + (readable,)
                print >>file, fmt_coverage % args
                total_statements = total_statements + n
                total_executed = total_executed + m
            except KeyboardInterrupt:                       #pragma: no cover
                raise
            except:
                if not ignore_errors:
                    typ, msg = sys.exc_info()[:2]
                    print >>file, fmt_err % (name, typ, msg)
        if len(morfs) > 1:
            print >>file, "-" * len(header)
            if total_statements > 0:
                pc = 100.0 * total_executed / total_statements
            else:
                pc = 100.0
            args = ("TOTAL", total_statements, total_executed, pc)
            if show_missing:
                args = args + ("",)
            print >>file, fmt_coverage % args

    # annotate(morfs, ignore_errors).

    blank_re = re.compile(r"\s*(#|$)")
    else_re = re.compile(r"\s*else\s*:\s*(#|$)")

    def annotate(self, morfs, directory=None, ignore_errors=0, omit_prefixes=[]):
        morfs = self.filter_by_prefix(morfs, omit_prefixes)
        for morf in morfs:
            try:
                filename, statements, excluded, missing, _ = self.analysis2(morf)
                self.annotate_file(filename, statements, excluded, missing, directory)
            except KeyboardInterrupt:
                raise
            except:
                if not ignore_errors:
                    raise
                
    def annotate_file(self, filename, statements, excluded, missing, directory=None):
        source = open(filename, 'r')
        if directory:
            dest_file = os.path.join(directory,
                                     os.path.basename(filename)
                                     + ',cover')
        else:
            dest_file = filename + ',cover'
        dest = open(dest_file, 'w')
        lineno = 0
        i = 0
        j = 0
        covered = 1
        while 1:
            line = source.readline()
            if line == '':
                break
            lineno = lineno + 1
            while i < len(statements) and statements[i] < lineno:
                i = i + 1
            while j < len(missing) and missing[j] < lineno:
                j = j + 1
            if i < len(statements) and statements[i] == lineno:
                covered = j >= len(missing) or missing[j] > lineno
            if self.blank_re.match(line):
                dest.write('  ')
            elif self.else_re.match(line):
                # Special logic for lines containing only 'else:'.  
                # See [GDR 2001-12-04b, 3.2].
                if i >= len(statements) and j >= len(missing):
                    dest.write('! ')
                elif i >= len(statements) or j >= len(missing):
                    dest.write('> ')
                elif statements[i] == missing[j]:
                    dest.write('! ')
                else:
                    dest.write('> ')
            elif lineno in excluded:
                dest.write('- ')
            elif covered:
                dest.write('> ')
            else:
                dest.write('! ')
            dest.write(line)
        source.close()
        dest.close()

# Singleton object.
the_coverage = coverage()

# Module functions call methods in the singleton object.
def use_cache(*args, **kw): 
    return the_coverage.use_cache(*args, **kw)

def start(*args, **kw): 
    return the_coverage.start(*args, **kw)

def stop(*args, **kw): 
    return the_coverage.stop(*args, **kw)

def erase(*args, **kw): 
    return the_coverage.erase(*args, **kw)

def begin_recursive(*args, **kw): 
    return the_coverage.begin_recursive(*args, **kw)

def end_recursive(*args, **kw): 
    return the_coverage.end_recursive(*args, **kw)

def exclude(*args, **kw): 
    return the_coverage.exclude(*args, **kw)

def analysis(*args, **kw): 
    return the_coverage.analysis(*args, **kw)

def analysis2(*args, **kw): 
    return the_coverage.analysis2(*args, **kw)

def report(*args, **kw): 
    return the_coverage.report(*args, **kw)

def annotate(*args, **kw): 
    return the_coverage.annotate(*args, **kw)

def annotate_file(*args, **kw): 
    return the_coverage.annotate_file(*args, **kw)

# Save coverage data when Python exits.  (The atexit module wasn't
# introduced until Python 2.0, so use sys.exitfunc when it's not
# available.)
try:
    import atexit
    atexit.register(the_coverage.save)
except ImportError:
    sys.exitfunc = the_coverage.save

# Command-line interface.
if __name__ == '__main__':
    the_coverage.command_line(sys.argv[1:])


# A. REFERENCES
#
# [GDR 2001-12-04a] "Statement coverage for Python"; Gareth Rees;
# Ravenbrook Limited; 2001-12-04;
# <http://www.nedbatchelder.com/code/modules/rees-coverage.html>.
#
# [GDR 2001-12-04b] "Statement coverage for Python: design and
# analysis"; Gareth Rees; Ravenbrook Limited; 2001-12-04;
# <http://www.nedbatchelder.com/code/modules/rees-design.html>.
#
# [van Rossum 2001-07-20a] "Python Reference Manual (releae 2.1.1)";
# Guide van Rossum; 2001-07-20;
# <http://www.python.org/doc/2.1.1/ref/ref.html>.
#
# [van Rossum 2001-07-20b] "Python Library Reference"; Guido van Rossum;
# 2001-07-20; <http://www.python.org/doc/2.1.1/lib/lib.html>.
#
#
# B. DOCUMENT HISTORY
#
# 2001-12-04 GDR Created.
#
# 2001-12-06 GDR Added command-line interface and source code
# annotation.
#
# 2001-12-09 GDR Moved design and interface to separate documents.
#
# 2001-12-10 GDR Open cache file as binary on Windows.  Allow
# simultaneous -e and -x, or -a and -r.
#
# 2001-12-12 GDR Added command-line help.  Cache analysis so that it
# only needs to be done once when you specify -a and -r.
#
# 2001-12-13 GDR Improved speed while recording.  Portable between
# Python 1.5.2 and 2.1.1.
#
# 2002-01-03 GDR Module-level functions work correctly.
#
# 2002-01-07 GDR Update sys.path when running a file with the -x option,
# so that it matches the value the program would get if it were run on
# its own.
#
# 2004-12-12 NMB Significant code changes.
# - Finding executable statements has been rewritten so that docstrings and
#   other quirks of Python execution aren't mistakenly identified as missing
#   lines.
# - Lines can be excluded from consideration, even entire suites of lines.
# - The filesystem cache of covered lines can be disabled programmatically.
# - Modernized the code.
#
# 2004-12-14 NMB Minor tweaks.  Return 'analysis' to its original behavior
# and add 'analysis2'.  Add a global for 'annotate', and factor it, adding
# 'annotate_file'.
#
# 2004-12-31 NMB Allow for keyword arguments in the module global functions.
# Thanks, Allen.
#
# 2005-12-02 NMB Call threading.settrace so that all threads are measured.
# Thanks Martin Fuzzey. Add a file argument to report so that reports can be 
# captured to a different destination.
#
# 2005-12-03 NMB coverage.py can now measure itself.
#
# 2005-12-04 NMB Adapted Greg Rogers' patch for using relative filenames,
# and sorting and omitting files to report on.
#
# 2006-07-23 NMB Applied Joseph Tate's patch for function decorators.
#
# 2006-08-21 NMB Applied Sigve Tjora and Mark van der Wal's fixes for argument
# handling.
#
# 2006-08-22 NMB Applied Geoff Bache's parallel mode patch.
#
# 2006-08-23 NMB Refactorings to improve testability.  Fixes to command-line
# logic for parallel mode and collect.
#
# 2006-08-25 NMB "#pragma: nocover" is excluded by default.
#
# 2006-09-10 NMB Properly ignore docstrings and other constant expressions that
# appear in the middle of a function, a problem reported by Tim Leslie.
# Minor changes to avoid lint warnings.
#
# 2006-09-17 NMB coverage.erase() shouldn't clobber the exclude regex.
# Change how parallel mode is invoked, and fix erase() so that it erases the
# cache when called programmatically.
#
# 2007-07-21 NMB In reports, ignore code executed from strings, since we can't
# do anything useful with it anyway.
# Better file handling on Linux, thanks Guillaume Chazarain.
# Better shell support on Windows, thanks Noel O'Boyle.
# Python 2.2 support maintained, thanks Catherine Proulx.
#
# 2007-07-22 NMB Python 2.5 now fully supported. The method of dealing with
# multi-line statements is now less sensitive to the exact line that Python
# reports during execution. Pass statements are handled specially so that their
# disappearance during execution won't throw off the measurement.
#
# 2007-07-23 NMB Now Python 2.5 is *really* fully supported: the body of the
# new with statement is counted as executable.
#
# 2007-07-29 NMB Better packaging.
#
# 2007-09-30 NMB Don't try to predict whether a file is Python source based on
# the extension. Extensionless files are often Pythons scripts. Instead, simply
# parse the file and catch the syntax errors.  Hat tip to Ben Finney.

# C. COPYRIGHT AND LICENCE
#
# Copyright 2001 Gareth Rees.  All rights reserved.
# Copyright 2004-2007 Ned Batchelder.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.
#
# $Id: coverage.py 3934 2008-05-19 10:39:08Z loic $

########NEW FILE########
__FILENAME__ = finishedfilter
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

from twisted.web import http

def rest_filter(site, request, packet):
    request.setResponseCode(http.OK)
    request.write("FINISHED")
    request.finish()
    return True


########NEW FILE########
__FILENAME__ = monitorplugin
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

def handle_event(service, event):
    service.HERE = True
    return True

########NEW FILE########
__FILENAME__ = test-actionscript
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os
sys.path.insert(0, "..")
sys.path.insert(0, "..")

import unittest
import simplejson
from struct import pack, unpack, calcsize

from pokernetwork import pokerclientpackets

class ActionScriptGenerator:
    def __init__(self, type):
        self.type = type

    @staticmethod
    def pack_type2as_type(pack_type):
        if pack_type in ('I', 'B', 'b', 'H', 'c', 'bool', 'cbool', 'Bnone'):
            return 'int'
        elif pack_type in ('s', 'j'):
            return 'String'
        elif pack_type in ('Bl', 'Hl', 'Il', 'pl', 'players'):
            return 'Array'
        elif pack_type in ('money'):
            return 'Dictionary'
        else:
            raise UserWarning, "unknown type " + pack_type

    @staticmethod
    def field2as_unpack(field):
        (variable, default, pack_type) = field
        code = []
        if pack_type in ('I', 'c'):
            code.append('this.' + variable + " = bytes.readUnsignedInt();")
        elif pack_type == 'H':
            code.append('this.' + variable + " = bytes.readUnsignedShort();")
        elif pack_type in ('B', 'bool', 'cbool', 'Bnone'):
            code.append('this.' + variable + " = bytes.readUnsignedByte();")
        elif pack_type == 'b':
            code.append('this.' + variable + " = bytes.readUnsignedByte();")
            code.append('if(this.' + variable + " == 255) this." + variable + " = -1")
        elif pack_type in ('s', 'j'):
            code.append('{')
            code.append('\tvar size:int = bytes.readUnsignedShort();')
            code.append('\tthis.' + variable + ' = bytes.readUTFBytes(size);')
            code.append('}')
        elif pack_type in ('Il', 'Hl', 'Bl'):
            code.append('{')
            code.append('\tvar size:int = bytes.readUnsignedByte();')
            code.append('\tfor(var i:int = 0; i < size; i++)')
            code.append('\t{')
            if pack_type == 'Il':
                code.append('\t\tthis.' + variable + ".push(bytes.readUnsignedInt());")
            elif pack_type == 'Hl':
                code.append('\t\tthis.' + variable + ".push(bytes.readUnsignedShort());")
            elif pack_type == 'Bl':
                code.append('\t\tthis.' + variable + ".push(bytes.readUnsignedByte());")
            code.append('\t}')
            code.append('}')
        elif pack_type in ('players',):
            code.append('{')
            code.append('\tvar nplayers:int = bytes.readUnsignedShort();')
            code.append('\tthis.' + variable + ' = new Array();')
            code.append('\tfor(var i:int = 0; i < nplayers; i++)')
            code.append('\t{')
            code.append('\t\tvar size:int = bytes.readUnsignedByte();')
            code.append('\t\tvar player:Array = new Array();')
            code.append('\t\tplayer.push(bytes.readUTFBytes(size));')
            code.append('\t\tplayer.push(bytes.readUnsignedInt());')
            code.append('\t\tplayer.push(bytes.readUnsignedByte());')
            code.append('\t\tthis.' + variable + ".push(player);")
            code.append('\t}')
            code.append('}')
        elif pack_type in ('money',):
            code.append('{')
            code.append('\tvar ncurrencies:int = bytes.readUnsignedShort();')
            code.append('\tthis.' + variable + ' = new Dictionary();')
            code.append('\tfor(var i:int = 0; i < ncurrencies; i++)')
            code.append('\t{')
            code.append('\t\tvar currency:Array = new Array();')
            code.append('\t\tvar id:int = bytes.readUnsignedInt();')
            code.append('\t\tcurrency.push(bytes.readUnsignedInt()); // bankroll')
            code.append('\t\tcurrency.push(bytes.readUnsignedInt()); // ingame')
            code.append('\t\tcurrency.push(bytes.readUnsignedInt()); // points')
            code.append('\t\tthis.' + variable + "[id] = currency;")
            code.append('\t}')
            code.append('}')
        elif pack_type in ('pl',):
            code.append('{')
            code.append('\tvar npackets:int = bytes.readUnsignedByte();')
            code.append('\tthis.' + variable + ' = new Array();')
            code.append('\tfor(var i:int = 0; i < npackets; i++)')
            code.append('\t{')
            code.append('\t\tvar type:int = bytes.readUnsignedByte();')
            code.append('\t\tvar length:int = bytes.readUnsignedShort();')
            code.append('\t\tvar packet:Packet = new Packet.types[type]();')
            code.append('\t\tbytes.position -= 3; // rewind to the beginning of packet')
            code.append('\t\tpacket.bytes = new ByteArray(bytes.readUnsignedBytes(length));')
            code.append('\t\tpacket.unpack();')
            code.append('\t\tthis.' + variable + ".push(packet);")
            code.append('\t}')
            code.append('}')
        else:
            code.append("// implement " + variable + " of type " + pack_type)
        return code
            
    @staticmethod
    def field2as_pack(field):
        (variable, default, pack_type) = field
        code = []
        if pack_type in ('I', 'c'):
            code.append('bytes.writeUnsignedInt(this.' + variable + ');')
        elif pack_type == 'H':
            code.append('bytes.writeUnsignedShort(this.' + variable + ');')
        elif pack_type in ('B', 'bool', 'cbool', 'Bnone'):
            code.append('bytes.writeUnsignedByte(this.' + variable + ');')
        elif pack_type == 'b':
            code.append('if(this.' + variable + ' == -1)')
            code.append('\tbytes.writeUnsignedByte(255);')
            code.append('else')
            code.append('\tbytes.writeUnsignedByte(this.' + variable + ');')
        elif pack_type in ('s', 'j'):
            code.append('bytes.writeUnsignedShort(this.' + variable + '.length);')
            code.append('bytes.writeUTFBytes(this.' + variable + ', this.' + variable + '.length)')
        elif pack_type in ('Il', 'Hl', 'Bl'):
            code.append('bytes.writeUnsignedByte(this.' + variable + '.length);')
            code.append('for(var i:int = 0; i < this.' + variable + '.length; i++)')
            code.append('{')
            if pack_type == 'Il':
                code.append('\tbytes.writeUnsignedInt(this.' + variable + ');')
            elif pack_type == 'Hl':
                code.append('\tbytes.writeUnsignedShort(this.' + variable + ');')
            elif pack_type == 'Bl':
                code.append('\tbytes.writeUnsignedByte(this.' + variable + ');')
            code.append('}')
        elif pack_type in ('players',):
            code.append('bytes.writeUnsignedShort(this.' + variable + '.length);')
            code.append('for(var i:int = 0; i < this.' + variable + '.length; i++)')
            code.append('{')
            code.append('\t\tvar player:Array = this.' + variable + '[i];')
            code.append('\tbytes.writeUnsignedByte(player[0].length);')
            code.append('\tbytes.writeUTFBytes(player[0])')
            code.append('\tbytes.writeUnsignedInt(player[1]);')
            code.append('\tbytes.writeUnsignedByte(player[2]);')
            code.append('}')
        elif pack_type in ('money',):
            code.append('// money not implemented')
        elif pack_type in ('pl',):
            code.append('// pl not implemented')
        else:
            code.append("// implement " + variable + " of type " + pack_type)
        return code
            
    @staticmethod
    def field2as_calcsize(field):
        (variable, default, pack_type) = field
        code = []
        if pack_type in ('I', 'c'):
            code.append('size += 4; // ' + variable)
        elif pack_type == 'H':
            code.append('size += 2; // ' + variable)
        elif pack_type in ('B', 'bool', 'cbool', 'Bnone', 'b'):
            code.append('size += 1; // ' + variable)
        elif pack_type in ('s', 'j'):
            code.append('size += 2 + this.' + variable + '.length;')
        elif pack_type in ('Il', 'Hl', 'Bl'):
            code = []
            code.append('size += 1; // length of ' + variable)
            if pack_type == 'Il':
                code.append('size += 4 * this.' + variable + '.length;')
            elif pack_type == 'Hl':
                code.append('size += 2 * this.' + variable + '.length;')
            elif pack_type == 'Bl':
                code.append('size += 1 * this.' + variable + '.length;')
        elif pack_type in ('players',):
            code.append('// players not implemented')
        elif pack_type in ('money',):
            code.append('// money not implemented')
        elif pack_type in ('pl',):
            code.append('// pl not implemented')
        else:
            code.append("// implement " + variable + " of type " + pack_type)
        return code
            
    def generate(self):
        if self.type.type in ( pokerclientpackets.PACKET_NONE,
                               pokerclientpackets.PACKET_BOOTSTRAP ):
            return
        info = self.type.info[2:]
        print "// code for " + pokerclientpackets.PacketNames[self.type.type] + " "  + str(info)
        print "public class " + self.type.__name__ + " extends Packet"
        print "{"
        for (variable, default, pack_type) in info:
            if pack_type == 'no net':
                continue
            print "\tpublic var " + variable + ":" + self.pack_type2as_type(pack_type) + ";"
        print 
        print "\tpublic override function unpack(bytes:ByteArray):ByteArray"
        print "\t{"
        print "\t\tbytes = super.unpack(bytes);"
        for field in info:
            if field[2] == 'no net':
                continue
            for line in self.field2as_unpack(field):
                print "\t\t" + line
        print "\t\treturn bytes;"
        print "\t}"
        print 
        print "\tpublic override function pack():ByteArray"
        print "\t{"
        print "\t\tvar bytes:ByteArray = super.pack();"
        for field in info:
            if field[2] == 'no net':
                continue
            for line in self.field2as_pack(field):
                print "\t\t" + line
        print "\t\treturn bytes;"
        print "\t}"
        print 
        print "\tpublic override function calcsize():int"
        print "\t{"
        print "\t\tvar size:int = super.calcsize();"
        for field in info:
            if field[2] == 'no net':
                continue
            for line in self.field2as_calcsize(field):
                print "\t\t" + line
        print "\t\treturn size;"
        print "\t}"

        print "}"
        
    
class ActionScriptGeneratorTestCase(unittest.TestCase):

    #--------------------------------------------------------------    
    def test_all(self):
        classes = []
        for type in xrange(0, 255):
            if pokerclientpackets.PacketFactory.has_key(type):
                c = pokerclientpackets.PacketFactory[type].__name__
                classes.append(c)
            else:
                classes.append('null')
        print "Packet.types = Array(" + ", ".join(classes) + ");"

        print """
public class Packet
{
        public static var types:Array = new Array();

        public var type:int;
        public var length:int;

	public function unpack(bytes:ByteArray):ByteArray
        {
    		this.type = bytes.readUnsignedByte();
    		this.length = bytes.readUnsignedShort();
                return bytes;
        }

	public function pack():ByteArray
        {
    		var bytes:ByteArray = new ByteArray();
                bytes.writeUnsignedByte(this.type);
                bytes.writeUnsignedShort(this.calcsize());
                return bytes;
        }

	public function calcsize():int
        {
                return 3;
        }
}
"""
        for type in xrange(0, 255):
            if pokerclientpackets.PacketFactory.has_key(type):
                as = ActionScriptGenerator(pokerclientpackets.PacketFactory[type])
                as.generate()

#--------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ActionScriptGeneratorTestCase))
    return suite
    
#--------------------------------------------------------------
def Run(verbose = 2):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
    
#--------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-actionscript.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/packets.py' TESTS='coverage-reset test-actionscript.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-clientserver
#!/usr/bin/python
# -*- py-indent-offset: 4; coding: iso-8859-1; mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)       2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2006       Mekensleep
#                          24 rue vieille du temple 75004 Paris
#                          <licensing@mekensleep.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>
#
import sys, os
sys.path.insert(0, "./..")
sys.path.insert(0, "..")

from twisted.trial import unittest, runner, reporter
from twisted.internet import protocol, reactor, defer
from twisted.application import service

#
# Must be done before importing pokerclient or pokerclient
# will have to be patched too.
#
from tests import testclock

from tests.testmessages import restore_all_messages, silence_all_messages, search_output, clear_all_messages, get_messages
#os.environ['VERBOSE_T'] = '0'
verbose = int(os.environ.get('VERBOSE_T', '-1'))
#if verbose < 0: silence_all_messages()

import twisted.internet.base
twisted.internet.base.DelayedCall.debug = True

import pokernetwork.server
import pokernetwork.client
import pokernetwork.protocol
from pokernetwork.packets import *

class FakeService(service.Service):
    def __init__(self):
        self._ping_delay = 0.1

class FakeAvatar:
    def __init__(self):
        pass

    def setProtocol(self, protocol):
        if verbose > 0:
            print "SetProtocol"
        self.protocol = protocol

    def handlePacket(self, packet):
        print "FakeAvatar: handlePacket " + str(packet)
        if packet.type == PACKET_ERROR:
            raise Exception, "EXCEPTION TEST"
        return []

class  FakeUser:
    def __init__(self):
        self.name = "Mr.Fakey"
        self.serial = -1

class FakeFactory(protocol.ServerFactory):

    def __init__(self, testObject = None):
        self.tester = testObject
        self.service = FakeService()
        self.verbose = 7
        self.destroyedAvatars = []

    def createAvatar(self):
        return FakeAvatar()

    def destroyAvatar(self, avatar):
        self.destroyedAvatars.append(avatar)
    
    def buildProtocol(self, addr):
        class Transport:
            def __init__(self):
                self.loseConnectionCount = 0

            def loseConnection(self):
                self.loseConnectionCount += 1

            def setTcpKeepAlive(self, val):
                pass
        self.instance = pokernetwork.server.PokerServerProtocol()

        # Asserts that assure PokerServerProtocol.__init__() acts as
        # expected
        self.tester.assertEquals(self.instance._ping_timer, None)
        self.tester.assertEquals(self.instance._ping_delay, 10)
        self.tester.assertEquals(self.instance.avatar, None)
        self.tester.assertEquals(self.instance.bufferized_packets, [])

        # Set up variables and mock ups for tests 
        self.instance.transport = Transport()
        self.instance.verbose = 7
        self.instance.exception = None
        self.instance.factory = self
        self.instance.user = FakeUser()
        return self.instance

class ClientServerTestBase(unittest.TestCase):
    def setUpServer(self):
        self.server_factory = FakeFactory(self)
        self.p = reactor.listenTCP(0, self.server_factory,
                                   interface="127.0.0.1")
        self.port = self.p.getHost().port
        if verbose > 0:
            print "Listening on 127.0.0.1:" + str(self.port)

    def setUpClient(self, index):
        self.client_factory[index] = pokernetwork.client.UGAMEClientFactory()
        self.client_factory[index].verbose = 7
        def setUpProtocol(client):
            client._poll_frequency = 0.1
            return client
        d = self.client_factory[index].established_deferred
        d.addCallback(setUpProtocol)

    def setUp(self):
        self.setUpServer()
        self.client_factory = [None, None]
        self.setUpClient(0)
        reactor.connectTCP('127.0.0.1', self.port, self.client_factory[0])
        if verbose > 0:
            print "Connecting on 127.0.0.1:" + str(self.port)

    def cleanSessions(self, arg):
        #
        # twisted Session code has leftovers : disable the hanging delayed call warnings
        # of trial by nuking all what's left.
        #
        pending = reactor.getDelayedCalls()
        if pending:
            for p in pending:
                if p.active():
#                    print "still pending:" + str(p)
                    p.cancel()
        return arg
    # -----------------------------------------------------------------------        
    def tearDown(self):
        reactor.iterate()
        reactor.iterate()
        self.p.stopListening()
        return self.cleanSessions(None)

class ClientServer(ClientServerTestBase):
    # -----------------------------------------------------------------------        
    def quit(self, args):
        client = args[0]
        client.sendPacket(PacketQuit())
        client.transport.loseConnection()
        server = self.server_factory.instance
        def serverPingTimeout(val):
            self.assertEqual(search_output("ping: timeout Mr.Fakey/-1"), True)
        client.connection_lost_deferred.addCallback(serverPingTimeout)
        silence_all_messages()
        return client.connection_lost_deferred
    # -----------------------------------------------------------------------        
    def ping(self, client):
        clear_all_messages()
        client.sendPacket(PacketPing())
        self.assertEquals(get_messages(), ["sendPacket(0) type = PING(5) "])
        return (client,)
    # -----------------------------------------------------------------------        
    def pingExpectingPrefix(self, client):
        clear_all_messages()
        client.sendPacket(PacketPing())
        self.assertEquals(get_messages(),
                          ["ATesterPrefix: sendPacket(0) type = PING(5) "])
        return (client,)
    # -----------------------------------------------------------------------        
    def setPrefix(self, client):
        client._prefix = "ATesterPrefix: "
        return client
    # -----------------------------------------------------------------------        
    def test01_ping(self):
        d = self.client_factory[0].established_deferred
        silence_all_messages()
        d.addCallback(self.ping)
        d.addCallback(self.quit)
        return d
    # -----------------------------------------------------------------------        
    def test02_pingExpectingPrefix(self):
        d = self.client_factory[0].established_deferred
        silence_all_messages()
        d.addCallback(self.setPrefix)
        d.addCallback(self.pingExpectingPrefix)
        d.addCallback(self.quit)
        return d

    def exception(self, client):
        client.sendPacket(PacketError())
        d = client.connection_lost_deferred
        def validate(result, count):
            server_protocol = self.server_factory.instance
            if server_protocol.exception:
                self.assertEquals("EXCEPTION TEST", str(server_protocol.exception[1]))
            else:
                if count >= 5: print "Waiting for exception to be raised ",
                if count > 0: print ".",
                if count == 0:
                    self.fail("exception was not received")
                else:
                    reactor.callLater(1, lambda: validate(result, count -1))

        d.addCallback(lambda result: validate(result, 5))
        return d
        
    def test02_exception(self):
        d = self.client_factory[0].established_deferred
        d.addCallback(self.exception)
        return d

    # -----------------------------------------------------------------------
    def killThenPing(self, client):
        self.messageValue = ""
        def getMessage(str):
            self.messageValue += str
        client.message = getMessage
        def sendLostConnectionPacket(val):
            client.sendPacket(PacketPing())
            self.assertEqual(self.messageValue.find("ufferized") >= 0, True)
            self.assertEqual(len(client.bufferized_packets), 1)
            self.assertEqual(client.bufferized_packets[0].type, PACKET_PING)
        d = client.connection_lost_deferred
        d.addCallback(sendLostConnectionPacket)
        return d

    def test03_killThenPing(self):
        "Designed to cover client.py when it tests for established"
        d = self.client_factory[0].established_deferred
        d.addCallback(self.killThenPing)
        return d

    # -----------------------------------------------------------------------
    def deadServerTransport(self, client):
        server = self.server_factory.instance
        saveMyTransport = server.transport
        server.transport = None

        self.messageValue = ""
        def getMessage(str):
            self.messageValue += str
        server.message = getMessage

        server.sendPackets([PacketPing()])
        self.assertEquals(len(server.bufferized_packets), 1)
        self.assertEquals(server.bufferized_packets[0].type, PACKET_PING)
        self.assertEquals(self.messageValue.find("bufferized") > 0, True)
        self.assertEquals(self.messageValue.find("no usuable transport") > 0, True)
        server.transport = saveMyTransport
        return client.connection_lost_deferred

    def test04_deadServerTransport(self):
        """Covers the case where there is no transport available and the
        packets must be buffered by the server."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.deadServerTransport)
        return d
    # -----------------------------------------------------------------------
    def clientConnectionLost(self, client):
        class ReasonMockUp:
            def __str__(self):
                return "you mock me"
            def check(self, foo):
                return False
        silence_all_messages()
        clear_all_messages()
        client.connectionLost(ReasonMockUp())
        self.assertEquals(get_messages(), ['connectionLost: reason = you mock me',
                                           'UGAMEClient.connectionLost you mock me'])
        self.assertEquals(client._ping_timer, None)
        self.assertEquals(self.client_factory[0].protocol_instance,  None)
        return True

    def test05_clientConnectionLost(self):
        """Covers the case where the client connection is lost"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.clientConnectionLost)
        return d
    # -----------------------------------------------------------------------
    def dummyClientError(self, client):
        silence_all_messages()
        clear_all_messages()
        client.error("stupid dummy error test since client never calls")
        self.assertEquals(get_messages(),
                          ["ERROR stupid dummy error test since client never calls"])
        return (client,)
    # -----------------------------------------------------------------------
    def test06_dummyClientError(self):
        """At the time of writing, client.error() is not used internally
        to client, so this is a call to test its use"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.dummyClientError)
        return d
    # -----------------------------------------------------------------------
    def test07_bufferizedClientPackets(self):
        silence_all_messages()
        d = self.client_factory[0].established_deferred
        def bufferPackets(client):
            def checkOutput(client):
                msgs = get_messages()
                self.assertEquals(msgs[0], 'sendPacket(0) type = ACK(4) ')
                return (client,)

            client.bufferized_packets = [ PacketAck() ]
            clear_all_messages()
            ccd = client.connection_lost_deferred
            ccd.addCallback(checkOutput)
            return ccd

        d.addCallback(bufferPackets)
        return d
    # -----------------------------------------------------------------------
    def test08_bufferizedClientPacketsTwo(self):
        silence_all_messages()
        d = self.client_factory[0].established_deferred
        def bufferPackets(client):
            def checkOutput(client):
                msgs = get_messages()
                self.assertEquals(msgs[0], 'sendPacket(0) type = ACK(4) ')
                self.assertEquals(msgs[1], 'sendPacket(0) type = SERIAL(6) serial = 0 ')
                return (client,)

            client.bufferized_packets = [ PacketAck(), PacketSerial() ]
            clear_all_messages()
            ccd = client.connection_lost_deferred
            ccd.addCallback(checkOutput)
            return ccd

        d.addCallback(bufferPackets)
        return d
#    def test09_badClientProtocol(self):
#        pass
#-------------------------------------------------------------------------------
class ClientServerBadClientProtocol(ClientServerTestBase):
    def setUpServer(self):
        class BadVersionFakeFactory(FakeFactory):
            def buildProtocol(self, addr):
                proto = FakeFactory.buildProtocol(self, addr)
                def badSendVersion():
                    proto.transport.write('CGI 0.00\n')
                proto._sendVersion = badSendVersion
                return proto

        self.server_factory = BadVersionFakeFactory(self)
        self.p = reactor.listenTCP(0, self.server_factory,
                                   interface="127.0.0.1")
        self.port = self.p.getHost().port
        if verbose > 0:
            print "Listening on 127.0.0.1:" + str(self.port)
    # -----------------------------------------------------------------------
    def test01_badClientProtocol(self):
        silence_all_messages()
        d = self.client_factory[0].established_deferred
        def findError(myFailure):
            from pokernetwork.protocol import PROTOCOL_MAJOR, PROTOCOL_MINOR
            msg = myFailure.getErrorMessage()
            self.failIf(msg.find("'0.00\\n', '%s.%s')" 
                                 % (PROTOCOL_MAJOR, PROTOCOL_MINOR )) < 0)
            self.failIf(msg.find("(<pokernetwork.client.UGAMEClientProtocol instance at") > 0)
        d.addErrback(findError)
        return d
#-------------------------------------------------------------------------------
class ClientServerQueuedServerPackets(ClientServerTestBase):
    def setUpServer(self):
        class BufferedFakeFactory(FakeFactory):
            def buildProtocol(self, addr):
                proto = FakeFactory.buildProtocol(self, addr)
                silence_all_messages()
                clear_all_messages()
                proto.bufferized_packets.append(PacketAck())
                return proto

        self.server_factory = BufferedFakeFactory(self)
        self.p = reactor.listenTCP(0, self.server_factory,
                                   interface="127.0.0.1")
        self.port = self.p.getHost().port
        if verbose > 0:
            print "Listening on 127.0.0.1:" + str(self.port)
    # -----------------------------------------------------------------------
    def getServerPacket(self, client):
        self.failUnless(search_output('protocol established'))
        clear_all_messages()
        def findBufferedAckPacket(client):
            self.failUnless(search_output("(3 bytes) => type = ACK(4)"))

        d = client.connection_lost_deferred
        d.addCallback(findBufferedAckPacket)
        return d
    # -----------------------------------------------------------------------
    def test01_getServerPacket(self):
        d = self.client_factory[0].established_deferred
        d.addCallback(self.getServerPacket)
        return d
#-------------------------------------------------------------------------------
class ClientServerDeferredServerPackets(ClientServerTestBase):
    def deferPacket(self, client):
        server = self.server_factory.instance
        self.failUnless(search_output('protocol established'))
        clear_all_messages()
        self.deferredPacket = defer.Deferred()
        server.sendPackets([ self.deferredPacket, PacketAck()])
        self.assertEquals(get_messages(), [])
        self.deferredPacket.callback(PacketPing())
        self.assertEquals(get_messages(), [])

        def callbackDeferredPacket(client):
            pingFound = False
            ackFound = False
            msgs = get_messages()
            for msg in get_messages():
                if msg == '(3 bytes) => type = PING(5)':
                    self.failIf(pingFound or ackFound)
                    pingFound = True
                elif msg == '(3 bytes) => type = ACK(4)':
                    self.failUnless(pingFound)
                    ackFound = True
            self.failUnless(ackFound and pingFound)

        d = client.connection_lost_deferred
        d.addCallback(callbackDeferredPacket)
        return d
    # -----------------------------------------------------------------------
    def test01_deferredPacket(self):
        d = self.client_factory[0].established_deferred
        d.addCallback(self.deferPacket)
        return d
    # -----------------------------------------------------------------------
    def deferErrorPacket(self, client):
        server = self.server_factory.instance
        clear_all_messages()
        self.deferredPacket = defer.Deferred()
        server.sendPackets([ self.deferredPacket, PacketAck()])
        self.assertEquals(get_messages(), [])
        self.deferredPacket.errback("forced to fail")
        self.assertEquals(get_messages(), [])

        def callbackDeferredPacket(client):
            errFound = False
            ackFound = False
            msgs = get_messages()
            for msg in get_messages():
                if msg == "(132 bytes) => type = ERROR(3) message = [Failure instance: Traceback (failure with no frames): <class 'twisted.python.failure.DefaultException'>: forced to fail\n], code = 0, other_type = ERROR":
                    self.failIf(errFound or ackFound)
                    errFound = True
                elif msg == '(3 bytes) => type = ACK(4)':
                    self.failUnless(errFound)
                    ackFound = True
            self.failUnless(ackFound and errFound)

        d = client.connection_lost_deferred
        d.addCallback(callbackDeferredPacket)
        return d
    # -----------------------------------------------------------------------
    def test02_deferredErrBackPacket(self):
        d = self.client_factory[0].established_deferred
        d.addCallback(self.deferErrorPacket)
        return d
# -----------------------------------------------------------------------
# Following class is used for the DummyServerTests and DummyClientTests
# for the ping code.
class  MockPingTimer:
    def __init__(self):
        self.isActive = False
        self.resetValues = []
        self.cancelCount = 0
    def active(self):
        return self.isActive
    def reset(self, val):
        self.resetValues.append(val)
    def cancel(self):
        self.cancelCount += 1
#-------------------------------------------------------------------------------
# DummyServerTests are to cover code on the server that doesn't need a
# client running to test it.

class DummyServerTests(unittest.TestCase):
    def test01_invalidProtocol(self):
        self.server_factory = FakeFactory(self)
        silence_all_messages()
        self.server_factory.buildProtocol('addr').dataReceived("invalid protocol\n")
        if verbose < 0: # can only grep output when output is redirected
            self.assertEqual(search_output('client with protocol UNKNOWN rejected'), True)
    # -----------------------------------------------------------------------
    def test02_pingWithoutTimer(self):
        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')
        del  server.__dict__['_ping_timer']
        self.assertEquals(server.ping(), None)
        self.assertEqual(get_messages(), [])
    # -----------------------------------------------------------------------
    def test03_pingWithNoneTimer(self):
        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')
        server._ping_timer = None
        self.assertEquals(server.ping(), None)
        self.assertEqual(get_messages(), [])
    # -----------------------------------------------------------------------
    def test04_pingWithActiveTimerNoUser(self):
        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')
        pt = MockPingTimer()
        pt.isActive = True
        server._ping_timer = pt
        del  server.__dict__['user']
        self.assertEquals(server.ping(), None)
        self.assertEquals(pt, server._ping_timer)
        self.assertEquals(pt.resetValues, [ 10 ])
        self.assertEquals(pt.cancelCount, 0)
        self.assertEquals(server.transport.loseConnectionCount, 0)
        self.assertEqual(get_messages(), [])
    # -----------------------------------------------------------------------
    def test05_pingWithActiveTimerWithUser(self):
        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')
        pt = MockPingTimer()
        pt.isActive = True
        server._ping_timer = pt
        self.assertEquals(server.ping(), None)
        self.assertEquals(pt, server._ping_timer)
        self.assertEquals(pt.resetValues, [ 10 ])
        self.assertEquals(pt.cancelCount, 0)
        self.assertEquals(server.transport.loseConnectionCount, 0)
        self.assertEqual(get_messages(), ['ping: renew Mr.Fakey/-1'])
    # -----------------------------------------------------------------------
    def test06_pingWithInactiveTimerNoUser(self):
        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')
        pt = MockPingTimer()
        server._ping_timer = pt
        del  server.__dict__['user']
        self.assertEquals(server.ping(), None)
        self.assertEquals(server._ping_timer, None)
        self.assertEquals(pt.resetValues, [ ])
        self.assertEquals(pt.cancelCount, 0)
        self.assertEquals(server.transport.loseConnectionCount, 1)
        self.assertEqual(get_messages(), [])
    # -----------------------------------------------------------------------
    def test07_pingWithInactiveTimerWithUser(self):
        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')
        pt = MockPingTimer()
        server._ping_timer = pt
        self.assertEquals(server.ping(), None)
        self.assertEquals(server._ping_timer, None)
        self.assertEquals(pt.resetValues, [ ])
        self.assertEquals(pt.cancelCount, 0)
        self.assertEquals(server.transport.loseConnectionCount, 1)
        self.assertEqual(get_messages(), ['ping: timeout Mr.Fakey/-1'])
    # -----------------------------------------------------------------------
    def processQueuesCounter(self):
        global processQueuesCount
        processQueuesCount += 1

    def ignoreIncomingDataCounter(self):
        global ignoreIncomingDataCount
        ignoreIncomingDataCount += 1
    # -----------------------------------------------------------------------
    def test08_connectionLostNonePingTimerNoAvatar(self):
        global processQueuesCount
        processQueuesCount = 0
        global ignoreIncomingDataCount
        ignoreIncomingDataCount = 0

        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')

        server._processQueues = self.processQueuesCounter
        server.ignoreIncomingData = self.ignoreIncomingDataCounter

        server._ping_timer = None
        server._queues = []
        server.avatar = None
 
        self.assertEquals(server.connectionLost("test08"), None)

        self.failIf(server.__dict__.has_key('avatar'))
        self.assertEquals(server._ping_timer, None)
        self.assertEquals(processQueuesCount, 0)
        self.assertEquals(ignoreIncomingDataCount, 1)
        self.assertEquals(self.server_factory.destroyedAvatars, [])

        self.assertEquals(get_messages(), ['connectionLost: reason = test08',
                                           'connectionLost: reason = test08',
                                           'client with protocol different rejected (need 002.000)'])
    # -----------------------------------------------------------------------
    def test09_connectionLostNoPingTimerWithAvatarButNoQueues(self):
        global processQueuesCount
        processQueuesCount = 0

        global ignoreIncomingDataCount
        ignoreIncomingDataCount = 0

        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')
        server._protocol_ok = True
        
        server._processQueues = self.processQueuesCounter
        server.ignoreIncomingData = self.ignoreIncomingDataCounter

        del server._ping_timer
        server._queues = []
        server.avatar = FakeAvatar()

        self.assertEquals(server.connectionLost("test09"), None)

        self.failIf(server.__dict__.has_key('avatar'))
        self.assertEquals(server._ping_timer, None)
        self.assertEquals(processQueuesCount, 0)
        self.assertEquals(ignoreIncomingDataCount, 1)
        self.assertEquals(len(self.server_factory.destroyedAvatars), 1)
        self.failUnless(isinstance(self.server_factory.destroyedAvatars[0], 
                                   FakeAvatar))
        self.assertEquals(get_messages(), ['connectionLost: reason = test09'])

    # -----------------------------------------------------------------------
    def test10_connectionLostWithInactivePingTimerWithAvatarAndQueues(self):
        global processQueuesCount
        processQueuesCount = 0

        global ignoreIncomingDataCount
        ignoreIncomingDataCount = 0

        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')
        server._protocol_ok = True
        
        def actualButDummyProcessQueueCounter():
            global processQueuesCount
            processQueuesCount += 1
            if processQueuesCount > 1:
                server._queues = []

        server._processQueues = actualButDummyProcessQueueCounter
        server.ignoreIncomingData = self.ignoreIncomingDataCounter

        pt = MockPingTimer()
        server._ping_timer = pt
        server._queues = ['a', 'b', 'c']
        server.avatar = FakeAvatar()

        self.assertEquals(server.connectionLost("test10"), None)

        self.failIf(server.__dict__.has_key('avatar'))
        self.assertEquals(server._ping_timer, None)
        self.assertEquals(processQueuesCount, 2)
        self.assertEquals(ignoreIncomingDataCount, 1)
        self.assertEquals(pt.cancelCount, 0)
        self.assertEquals(pt.resetValues, [])
        self.assertEquals(len(self.server_factory.destroyedAvatars), 1)
        self.failUnless(isinstance(self.server_factory.destroyedAvatars[0], 
                                   FakeAvatar))
        self.assertEquals(get_messages(), ['connectionLost: reason = test10'])
    # -----------------------------------------------------------------------
    def test11_connectionLostActivePingTimerNoAvatarOneQueues(self):
        global processQueuesCount
        processQueuesCount = 0

        global ignoreIncomingDataCount
        ignoreIncomingDataCount = 0

        clear_all_messages()
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')
        server._protocol_ok = True
        
        def actualButDummyProcessQueueCounter():
            global processQueuesCount
            processQueuesCount += 1
            server._queues = []

        server._processQueues = actualButDummyProcessQueueCounter
        server.ignoreIncomingData = self.ignoreIncomingDataCounter

        pt = MockPingTimer()
        pt.isActive = True
        server._ping_timer = pt
        server._queues = ['b', 'c']
        server.avatar = None

        self.assertEquals(server.connectionLost("test11"), None)

        self.failIf(server.__dict__.has_key('avatar'))
        self.assertEquals(server._ping_timer, None)
        # Queues don't get processed when lost connection without avatar
        self.assertEquals(processQueuesCount, 0)
        self.assertEquals(ignoreIncomingDataCount, 1)
        self.assertEquals(pt.cancelCount, 1)
        self.assertEquals(pt.resetValues, [])
        self.assertEquals(self.server_factory.destroyedAvatars, [])
        self.assertEquals(get_messages(), ['connectionLost: reason = test11'])
    # -----------------------------------------------------------------------
    def test12_handleConnectionNoException(self):
        """test12_handleConnectionNoException
        This and the following test is a mock-up test of server's
        _handleConnection() method.  I had searched for a way to test this
        particular method in a more interactive way using a real
        client/server connection in one of the classes above.  However, I
        was not able to find a way to force this method to be called using
        the MockUps already developed in the above test classes, and
        decided it was more expedient to test this method using these
        dummy server mechanism here."""

        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')

        pt = MockPingTimer()
        pt.isActive = True
        server._ping_timer = pt

        class MockAvatar:
            def __init__(avatarSelf, expected = None):
                avatarSelf.handlePacketCount = 0
                avatarSelf.expectedPacket = expected
            def handlePacket(avatarSelf, packet):
                global triggerCount
                global sendPacketsCount
                avatarSelf.handlePacketCount += 1
                self.assertEquals(packet, avatarSelf.expectedPacket)
                self.assertEquals(pt, server._ping_timer)
                self.assertEquals(pt.resetValues, [ 10 ])
                self.assertEquals(pt.cancelCount, 0)
                self.assertEquals(server._blocked, True)
                self.assertEquals(sendPacketsCount, 0)
                return "handlePacketsReturn"

        avatar = MockAvatar("test12 dummy packets")

        global sendPacketsCount
        triggerCount = 0
        sendPacketsCount = 0
        def doMyTrigger():
            self.failIf(True) # should never be called!
        def doSendPackets(packets):
            global sendPacketsCount
            sendPacketsCount += 1
            self.assertEquals(packets, "handlePacketsReturn")

        server.avatar = avatar
        server._blocked = False

        server.triggerTimer = doMyTrigger
        server.sendPackets = doSendPackets

        clear_all_messages()

        self.assertEquals(server.exception, None)

        server._handleConnection("test12 dummy packets")

        self.assertEquals(get_messages(), ['ping: renew Mr.Fakey/-1'])
        self.assertEquals(pt, server._ping_timer)
        self.assertEquals(pt.resetValues, [ 10 ])
        self.assertEquals(pt.cancelCount, 0)
        self.assertEquals(avatar.handlePacketCount, 1)
        self.assertEquals(server._blocked, True)
        self.assertEquals(sendPacketsCount, 1)
        self.assertEquals(triggerCount, 0)  # should be 0 since unblock() isn't called 
        self.assertEquals(server.exception, None)
        self.assertEquals(server.transport.loseConnectionCount, 0)
    # -----------------------------------------------------------------------
    def test13_handleConnectionWithExceptionRaised(self):
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')

        pt = MockPingTimer()
        pt.isActive = True
        server._ping_timer = pt

        class  MockRaise:
            def __init__(raiseSelf, str):
                raiseSelf.value = str
        class MockAvatar:
            def __init__(avatarSelf, expected = None):
                avatarSelf.handlePacketCount = 0
                avatarSelf.expectedPacket = expected
            def handlePacket(avatarSelf, packet):
                global triggerCount
                global sendPacketsCount
                avatarSelf.handlePacketCount += 1
                self.assertEquals(packet, avatarSelf.expectedPacket)
                self.assertEquals(pt, server._ping_timer)
                self.assertEquals(pt.resetValues, [ 10 ])
                self.assertEquals(pt.cancelCount, 0)
                self.assertEquals(server._blocked, True)
                self.assertEquals(triggerCount, 0)
                raise MockRaise("handlePacketsRaise")
                return "handlePacketsReturn"

        avatar = MockAvatar("test13 dummy packets")

        global triggerCount
        triggerCount = 0
        def doMyTrigger():
            global triggerCount
            triggerCount += 1
        def doSendPackets(packets):
            self.failIf(True)  # This should never be called

        server.avatar = avatar
        server._blocked = False

        server.triggerTimer = doMyTrigger
        server.sendPackets = doSendPackets

        clear_all_messages()

        self.assertEquals(server.exception, None)

        server._handleConnection("test13 dummy packets")

        self.assertEquals(get_messages(), ['ping: renew Mr.Fakey/-1'])
        self.assertEquals(pt, server._ping_timer)
        self.assertEquals(pt.resetValues, [ 10 ])
        self.assertEquals(pt.cancelCount, 0)
        self.assertEquals(avatar.handlePacketCount, 1)
        self.assertEquals(server._blocked, False)
        self.assertEquals(triggerCount, 1)
        self.assertEquals(len(server.exception), 3)
        self.assertEquals(server.exception[0], MockRaise)
        self.failUnless(isinstance(server.exception[1], MockRaise))
        self.assertEquals(server.exception[1].value, 'handlePacketsRaise')
        self.assertEquals(server.transport.loseConnectionCount, 1)
    # -----------------------------------------------------------------------
    def test14_handleConnectionWithExceptionRaisedNotSet(self):
        self.server_factory = FakeFactory(self)
        server = self.server_factory.buildProtocol('addr')

        pt = MockPingTimer()
        pt.isActive = True
        server._ping_timer = pt

        class  MockRaise:
            def __init__(raiseSelf, str):
                raiseSelf.value = str
                del server.exception
        class MockAvatar:
            def __init__(avatarSelf, expected = None):
                avatarSelf.handlePacketCount = 0
                avatarSelf.expectedPacket = expected
            def handlePacket(avatarSelf, packet):
                global triggerCount
                global sendPacketsCount
                avatarSelf.handlePacketCount += 1
                self.assertEquals(packet, avatarSelf.expectedPacket)
                self.assertEquals(pt, server._ping_timer)
                self.assertEquals(pt.resetValues, [ 10 ])
                self.assertEquals(pt.cancelCount, 0)
                self.assertEquals(server._blocked, True)
                self.assertEquals(triggerCount, 0)
                raise MockRaise("handlePacketsRaise")
                return "handlePacketsReturn"

        avatar = MockAvatar("test14 dummy packets")

        global triggerCount
        triggerCount = 0
        def doMyTrigger():
            global triggerCount
            triggerCount += 1
        def doSendPackets(packets):
            self.failIf(True)  # This should never be called

        server.avatar = avatar
        server._blocked = False

        server.triggerTimer = doMyTrigger
        server.sendPackets = doSendPackets

        clear_all_messages()

        self.assertEquals(server.exception, None)

        exceptionFound = False
        try:
            server._handleConnection("test14 dummy packets")
            self.failIf(True)  # This line should not be reached.
        except MockRaise, mr:
            exceptionFound = True
            self.failUnless(isinstance(mr, MockRaise))
            self.assertEquals(mr.value, 'handlePacketsRaise')

        self.assertEquals(exceptionFound, True)
            
        self.assertEquals(get_messages(), ['ping: renew Mr.Fakey/-1'])
        self.assertEquals(pt, server._ping_timer)
        self.assertEquals(pt.resetValues, [ 10 ])
        self.assertEquals(pt.cancelCount, 0)
        self.assertEquals(avatar.handlePacketCount, 1)
        self.assertEquals(server._blocked, False)
        self.assertEquals(triggerCount, 1)
        self.assertEquals(server.transport.loseConnectionCount, 0)
#-------------------------------------------------------------------------------
# DummyClientTests are to cover code on the server that doesn't need a
# client running to test it.

class DummyClientTests(unittest.TestCase):
    # -----------------------------------------------------------------------
    def test01_pingWithoutTimer(self):
        def myDataWrite(clientSelf): failIf(True)
        clear_all_messages()

        client = pokernetwork.client.UGAMEClientProtocol()
        client.dataWrite = myDataWrite
        del client._ping_timer
        client.factory = None

        self.assertEquals(client.ping(), None)
        self.assertEqual(get_messages(), [])
    # -----------------------------------------------------------------------
    def test02_pingWithNoneTimer(self):
        def myDataWrite(clientSelf): failIf(True)
        clear_all_messages()

        client = pokernetwork.client.UGAMEClientProtocol()
        client.dataWrite = myDataWrite
        client._ping_timer = None
        client.factory = None

        self.assertEquals(client.ping(), None)
        self.assertEqual(get_messages(), [])
    # -----------------------------------------------------------------------
    def test03_pingWithActiveTimer(self):
        def myDataWrite(clientSelf): failIf(True)
        clear_all_messages()

        client = pokernetwork.client.UGAMEClientProtocol()
        pt = MockPingTimer()
        pt.isActive = True
        client._ping_timer = pt
        client.factory = None

        self.assertEquals(client.ping(), None)
        self.assertEquals(pt, client._ping_timer)
        self.assertEquals(pt.resetValues, [ 5 ])
        self.assertEquals(pt.cancelCount, 0)
        self.assertEqual(get_messages(), [])
    # -----------------------------------------------------------------------
    def test04_pingWithInactiveTimer(self):
        global dataWritten
        dataWritten = 0
        def myDataWrite(packet):
            global dataWritten
            self.assertEquals(packet, PacketPing().pack())
            dataWritten += 1

        class DummyFactory:
            def __init__(factSelf):
                factSelf.verbose = 7

        clear_all_messages()

        client = pokernetwork.client.UGAMEClientProtocol()
        pt = MockPingTimer()
        pt.isActive = False
        client._ping_timer = pt
        client.factory = DummyFactory()
        client.dataWrite = myDataWrite
        client._prefix = "BLAH "

        # Reactor failure should occur if this never gets called.  We
        # replace the real object's ping with pingDummy and call using the
        # static method so that new reactor setup works properly.
        pingRecallDeferred = defer.Deferred()
        def pingDummy():
            pingRecallDeferred.callback(True)

        client.ping = pingDummy
        self.assertEquals(pokernetwork.client.UGAMEClientProtocol.ping(client), None)
        self.failUnless(isinstance(client._ping_timer, twisted.internet.base.DelayedCall))
        self.failUnless(client._ping_timer.__str__().find('pingDummy()') > 0)

        self.assertEquals(pt.resetValues, [])
        self.assertEquals(pt.cancelCount, 0)
        self.assertEquals(dataWritten, 1)
        self.assertEqual(get_messages(), ['BLAH send ping'])

        return pingRecallDeferred
    # -----------------------------------------------------------------------
    def test05_getSerial(self):
        class  MockUser:
            def __init__(userSelf):
                userSelf.serial = 5
        client = pokernetwork.client.UGAMEClientProtocol()
        client.user = MockUser()
        self.assertEquals(client.getSerial(), 5)
    # -----------------------------------------------------------------------
    def test06_getName(self):
        class  MockUser:
            def __init__(userSelf):
                userSelf.name = "joe"
        client = pokernetwork.client.UGAMEClientProtocol()
        client.user = MockUser()
        self.assertEquals(client.getName(), "joe")
    # -----------------------------------------------------------------------
    def test07_getURL(self):
        class  MockUser:
            def __init__(userSelf):
                userSelf.url = "http://example.org"
        client = pokernetwork.client.UGAMEClientProtocol()
        client.user = MockUser()
        self.assertEquals(client.getUrl(), "http://example.org")
    # -----------------------------------------------------------------------
    def test08_getOutfit(self):
        class  MockUser:
            def __init__(userSelf):
                userSelf.outfit = "naked"
        client = pokernetwork.client.UGAMEClientProtocol()
        client.user = MockUser()
        self.assertEquals(client.getOutfit(), "naked")
    # -----------------------------------------------------------------------
    def test09_isLogged(self):
        class  MockUser:
            def isLogged(userself): return True
        client = pokernetwork.client.UGAMEClientProtocol()
        client.user = MockUser()
        self.assertEquals(client.isLogged(), True)
    # -----------------------------------------------------------------------
    def test10_factoryError(self):
        clear_all_messages()
        clientFactory = pokernetwork.client.UGAMEClientFactory()
        clientFactory.error("test10")
        self.assertEquals(get_messages(), [ "ERROR test10"])
# -----------------------------------------------------------------------------------------------------
def Run():
    silence_all_messages()
    loader = runner.TestLoader()
#    loader.methodPrefix = "test09"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(ClientServer))
    suite.addTest(loader.loadClass(ClientServerBadClientProtocol))
    suite.addTest(loader.loadClass(ClientServerQueuedServerPackets))
    suite.addTest(loader.loadClass(ClientServerDeferredServerPackets))
    suite.addTest(loader.loadClass(DummyServerTests))
    suite.addTest(loader.loadClass(DummyClientTests))
    return runner.TrialRunner(reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# -----------------------------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-clientserver.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/server.py ../pokernetwork/client.py' TESTS='coverage-reset test-clientserver.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-currencyclient
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2009       Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2006       Mekensleep <licensing@mekensleep.com>
#                          24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>
#


import sys, os
sys.path.insert(0, "..")
sys.path.insert(0, "..")

from tests import testclock

from types import *

from twisted.python import failure
from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor
from twisted.internet import defer

twisted.internet.base.DelayedCall.debug = True

from urlparse import urlparse

from tests.testmessages import silence_all_messages, clear_all_messages, search_output, get_messages, restore_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokernetwork import currencyclient

class CurrencyClientTestCase(unittest.TestCase):

    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS currencytest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS currencytest'")

    # -----------------------------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.client = currencyclient.CurrencyClient()
        self.client.getPage = self.getPage

    # -----------------------------------------------------------------------------
    def tearDown(self):
        del self.client
        self.destroyDb()

    def getPage(self, url):
        ( scheme, netloc, path, parameters, query, fragement ) = urlparse(url)
        cmd = """
cat <<'EOF' | QUERY_STRING='""" + query + """' /usr/bin/php --define extension=mysql.so
<?
  ini_set('include_path', './../../pokerweb/pages:' . ini_get('include_path'));
  $GLOBALS['currency_db_base'] = 'currencytest';
  $GLOBALS['currency_db_host'] = 'localhost';
  $GLOBALS['currency_db_user'] = 'root';
  $GLOBALS['currency_db_password'] = '';
  require 'currency.php';
  parse_str(getenv('QUERY_STRING'), $_GET);
  currency_main(False);
?>
EOF
"""
        #print cmd
        fd = os.popen(cmd)
        result = fd.read()
        fd.close()
        d = defer.Deferred()
        reactor.callLater(0, lambda: d.callback(result))
        return d

    # -----------------------------------------------------------------------------
    def getNote(self, url, value):
        d = self.client.getNote(url, value)
        if "?" in url:
            check_url = url[:url.index("?")]
        else:
            check_url = url
        def validate(result):
            if isinstance(result, failure.Failure): raise result
            note = result[0]
            self.assertEqual(check_url, note[0])
            self.assertEqual(40, len(note[2]))
            self.assertEqual(value, note[3])
            return result
        d.addBoth(validate)
        return d

    # -----------------------------------------------------------------------------
    def getCommitedNote(self, url, value):
        return self.commit(self.getNote(url, value))
    # -----------------------------------------------------------------------------
    def commit(self, d):
        def commit(result):
            if isinstance(result, failure.Failure): raise result
            first_note = result[0]
            d = self.client.commit(first_note[0], first_note[2])
            d.addCallback(lambda ignore: result)
            return d
        d.addBoth(commit)
        return d

    # -----------------------------------------------------------------------------
    def test01_getNote(self):
        d = self.getNote('http://fake/', 100)
        def validate(result):
            note = result[0]
            self.assertEqual(1, note[1])
            return result
        d.addCallback(validate)
        return d

    # -----------------------------------------------------------------------------
    def test02_commit(self):
        return self.getCommitedNote('http://fake/', 100)

    # -----------------------------------------------------------------------------
    def test03_checkNote(self):
        d = self.getCommitedNote('http://fake/', 100)

        def checkNote(result):
            #print "checkNote " + str(result)
            note_to_check = result[0]
            d = self.client.checkNote(note_to_check)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                checked_note = result[0]
                self.assertEqual(note_to_check, checked_note)
                return result
            d.addBoth(validate)
            return d

        d.addCallback(checkNote)
        return d

    # -----------------------------------------------------------------------------
    def test04_changeNote(self):
        d = self.getCommitedNote('http://fake/', 100)

        def changeNote(result):
            note_to_change = result[0]
            d = self.client.changeNote(note_to_change)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                changed_note = result[0]
                self.assertEqual("http://fake/", changed_note[0])
                self.assertEqual(note_to_change[1] + 1, changed_note[1])
                self.assertEqual(40, len(changed_note[2]))
                self.assertNotEqual(note_to_change[2], changed_note[2])
                self.assertEqual(note_to_change[3], changed_note[3])
                return result
            d.addBoth(validate)
            return d

        d.addCallback(changeNote)
        return d

    # -----------------------------------------------------------------------------
    def test05_mergeNotes(self):
        notes = []
        def addnote(result):
            notes.append(result[0])
            return result

        d1 = self.getCommitedNote('http://fake/', 100)
        d1.addCallback(addnote)

        d2 = self.getCommitedNote('http://fake/', 100)
        d2.addCallback(addnote)

        d = defer.DeferredList((d1, d2))

        def mergeNotes(note):
            self.assertEquals(2, len(notes))
            d = self.client.mergeNotes(*notes)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                self.assertEqual(1, len(result))
                note = result[0]
                self.assertEqual("http://fake/", note[0])
                self.assertEqual(1, note[1])
                self.assertEqual(40, len(note[2]))
                self.assertEqual(200, note[3])
                return result
            d.addBoth(validate)
            return d

        d.addCallback(mergeNotes)
        return self.commit(d)

    # -----------------------------------------------------------------------------
    def test06_meltNotes(self):
        notes = []
        def addnote(result):
            notes.append(result[0])
            return result

        d1 = self.getCommitedNote('http://fake/', 100)
        d1.addCallback(addnote)

        d2 = self.getCommitedNote('http://fake/', 500)
        d2.addCallback(addnote)

        d = defer.DeferredList((d1, d2))

        def meltNotes(note):
            self.assertEquals(2, len(notes))
            d = self.client.meltNotes(*notes)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                self.assertEqual(1, len(result))
                note = result[0]
                self.assertEqual("http://fake/", note[0])
                self.assertEqual(1, note[1])
                self.assertEqual(40, len(note[2]))
                self.assertEqual(600, note[3])
                return result
            d.addBoth(validate)
            return d

        d.addCallback(meltNotes)
        return self.commit(d)

    # -----------------------------------------------------------------------------
    def test07_breakNote(self):
        d = self.getCommitedNote('http://fake/', 100)

        def breakNote(result):
            #print "breakNote " + str(result)
            note_to_break = result[0]
            d = self.client.breakNote(note_to_break, 30, 10, 5)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                #print "broken notes " + str(result)
                notes = result
                self.assertEqual(4, len(notes))
                self.assertEqual(30, notes[0][3])
                self.assertEqual(30, notes[1][3])
                self.assertEqual(30, notes[2][3])
                self.assertEqual(10, notes[3][3])
                return result
            d.addBoth(validate)
            return d

        d.addCallback(breakNote)
        return d

    # -----------------------------------------------------------------------------
    def test07_1_breakNote_oddLeftOver(self):
        d = self.getCommitedNote('http://fake/', 100)

        def breakNote(result):
            #print "breakNote " + str(result)
            note_to_break = result[0]
            d = self.client.breakNote(note_to_break, 15, 3, 2)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                #print "broken notes " + str(result)
                notes = result
                self.assertEqual(10, len(notes))
                for ii in [ 0, 1, 2, 3, 4, 5 ]:
                    self.assertEqual(ii+1, notes[ii][1])
                    self.assertEqual(15, notes[ii][3])
                    self.assertEqual(40, len(notes[ii][2]))
                for ii in [ 6, 7, 8 ]:
                    self.assertEqual(ii+1, notes[ii][1])
                    self.assertEqual(3, notes[ii][3])
                    self.assertEqual(40, len(notes[ii][2]))

                lastNote = 1
                lastVal = 1
                if isinstance(self.client, currencyclient.FakeCurrencyClient):
                    lastNote = 10
                    lastVal = 2
                self.assertEqual(lastNote, notes[9][1])
                self.assertEqual(lastVal, notes[9][3])
                self.assertEqual(40, len(notes[9][2]))
                return result
            d.addBoth(validate)
            return d

        d.addCallback(breakNote)
        return d
    # -----------------------------------------------------------------------------
    def test08_breakNote_zero(self):
        d = self.getCommitedNote('http://fake/', 100)

        def breakNote(result):
            #print "breakNote " + str(result)
            note_to_break = result[0]
            d = self.client.breakNote(note_to_break, 100, 0)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                #print "broken notes " + str(result)
                notes = result
                self.assertEqual(2, len(notes))
                self.assertEqual(100, notes[0][3])
                self.assertEqual(0, notes[1][3])
                return result
            d.addBoth(validate)
            return d

        d.addCallback(breakNote)
        return d

    # -----------------------------------------------------------------------------
    def test09_getNote_with_id(self):
        d = self.getNote('http://fake/?id=1', 100)
        def validate(result):
            note = result[0]
            self.assertEqual(1, note[1])
            return result
        d.addCallback(validate)
        return d

# -----------------------------------------------------------------------------
class FakeCurrencyClientTestCase(CurrencyClientTestCase):
    def setUp(self):
        currencyclient.Verbose = True
        currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
        self.destroyDb()
        self.client = currencyclient.FakeCurrencyClient()
        # Fake out the value on the starting serial so I can reuse the
        # tests completely from the previous test class.
        self.client.serial = 0
        self.client.getPage = self.getPage
        currencyclient.FakeCurrencyFailure = False
    # -----------------------------------------------------------------------------
    def getNote(self, url, value):
        clear_all_messages()
        d = self.client.getNote(url, value)
        self.assertEquals(search_output("_buildNote"), True)
        self.assertEquals(search_output("getNote"), True)
        if "?" in url:
            check_url = url[:url.index("?")]
        else:
            check_url = url
        def validate(result):
            if isinstance(result, failure.Failure): raise result
            # I wonder, actually, if FakeCurrencyClient is supposed to
            # return a list of a list as RealCurrencyClient does in this
            # instance.  I commented out:
            # note = result[0]
            # in favor of:
            note = result
            self.assertEqual(check_url, note[0])
            self.assertEqual(40, len(note[2]))
            self.assertEqual(value, note[3])
            return [result]
        d.addBoth(validate)
        return d
    # -----------------------------------------------------------------------------
    def getCommitedNote(self, url, value):
        clear_all_messages()
        def checkCommitVerboseOutput(result):
            self.assertEquals(search_output("commit"), True)
            return result
        ret = CurrencyClientTestCase.getCommitedNote(self, url, value)
        ret.addCallback(checkCommitVerboseOutput)
        return ret
    # -----------------------------------------------------------------------------
    # Had to ovveride all of test03, for the same reason discussed above, that
    #  there is another layer of list indirection missing in FakeCurrencyClient.
    def test03_checkNote(self):
        d = self.getCommitedNote('http://fake/', 100)

        def checkNote(result):
            clear_all_messages()
            note_to_check = result
            d = self.client.checkNote(note_to_check)
            self.assertEquals(search_output("checkNote"), True)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                checked_note = result
                self.assertEqual(note_to_check, checked_note)
                return result
            d.addBoth(validate)
            return d

        d.addCallback(checkNote)
        return d
    # -----------------------------------------------------------------------------
    def test05_mergeNotes(self):
        notes = []
        def addnote(result):
            notes.append(result[0])
            return result

        d1 = self.getCommitedNote('http://fake/', 100)
        d1.addCallback(addnote)

        d2 = self.getCommitedNote('http://fake/', 100)
        d2.addCallback(addnote)

        d = defer.DeferredList((d1, d2))

        def mergeNotes(note):
            self.assertEquals(2, len(notes))
            clear_all_messages()
            d = self.client.mergeNotes(*notes)
            self.assertEquals(search_output("mergeNotes"), True)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                self.assertEqual(1, len(result))
                note = result[0]
                self.assertEqual("http://fake/", note[0])
                self.assertEqual(3, note[1])
                self.assertEqual(40, len(note[2]))
                self.assertEqual(200, note[3])
                return result
            d.addBoth(validate)
            return d

        d.addCallback(mergeNotes)
        return self.commit(d)
    # -----------------------------------------------------------------------------
    def test06_meltNotes(self):
        notes = []
        def addnote(result):
            notes.append(result[0])
            return result

        d1 = self.getCommitedNote('http://fake/', 100)
        d1.addCallback(addnote)

        d2 = self.getCommitedNote('http://fake/', 500)
        d2.addCallback(addnote)

        d = defer.DeferredList((d1, d2))

        def meltNotes(note):
            self.assertEquals(2, len(notes))
            d = self.client.meltNotes(*notes)
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                self.assertEqual(1, len(result))
                note = result[0]
                self.assertEqual("http://fake/", note[0])
                self.assertEqual(3, note[1])
                self.assertEqual(40, len(note[2]))
                self.assertEqual(600, note[3])
                return result
            d.addBoth(validate)
            return d

        d.addCallback(meltNotes)
        return self.commit(d)

    def test04_changeNote(self):
        d = self.getCommitedNote('http://fake/', 100)
        clear_all_messages()
        def changeNote(result):
            class FakeNoteToChange:
                def copy(self):
                    return [8, 0, '']
            d = self.client.changeNote(FakeNoteToChange())
            def validate(result):
                if isinstance(result, failure.Failure): raise result
                self.assertEqual(result[0], 8)
                self.assertEqual(result[1], 2)
                self.assertEqual(40, len(result[2]))
                self.assertEquals(search_output("changeNote"), True)
                return result
            d.addBoth(validate)
            return d

        d.addCallback(changeNote)
        return d

    def test07_breakNote(self):
        clear_all_messages()
        d = CurrencyClientTestCase.test07_breakNote(self)
        def checkOutput(result):
            self.assertEquals(search_output("breakNote vaues"), True)
            return True

        d.addCallback(checkOutput)
        return d

    # -----------------------------------------------------------------------------
    def test09_getNote_with_id(self):
        return True
    # -----------------------------------------------------------------------------
    def test10_breakNote_FakeCurrencyFailure(self):
        currencyclient.FakeCurrencyFailure = True

        d = self.getCommitedNote('http://fake/', 100)

        mustBeCalledBackForSuccess = defer.Deferred()

        def breakNote(result):
            def failIfCalledBack(result):
                self.fail("should not have a normal callback in this situation")

            def expectedError(err):
                self.assertEquals(err.check(twisted.web.error.Error),
                                  twisted.web.error.Error)
                self.assertEquals(err.getErrorMessage(),
                              "500 breakNote: fake error")
                mustBeCalledBackForSuccess.callback(True)

            d = self.client.breakNote(result[0], 30, 10, 5)
            d.addCallback(failIfCalledBack)
            d.addErrback(expectedError)
            return d

        d.addCallback(breakNote)
        return defer.DeferredList((d, mustBeCalledBackForSuccess))
# -----------------------------------------------------------------------------
class ErrorCondtionsCurrencyClientTestCase(unittest.TestCase):
    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS currencytest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS currencytest'")
    # -----------------------------------------------------------------------------
    def setUp(self):
        self.destroyDb()
    # -----------------------------------------------------------------------------
    def tearDown(self):
        del self.client
        self.destroyDb()
    # -----------------------------------------------------------------------------
    def test01_parseResultNote_InvalidResult(self):
        from cStringIO import StringIO

        self.client = currencyclient.RealCurrencyClient()
        caughtIt = False

        oldStdio = sys.stdout
        sys.stdout = StringIO()
        try:
            self.client.parseResultNote("two\tfield")
            self.fail("Previous line should have caused exception")
        except Exception, e:
            self.assertEquals(e.__str__(), "expected notes got something else")
            caughtIt = True
        value = sys.stdout.getvalue()
        sys.stdout = oldStdio

        self.assertEquals(value, "RealCurrencyClient::parseResultNote ignore line: two\tfield\n")
        self.failUnless(caughtIt, "Should have caught an exception")
    # -----------------------------------------------------------------------------
    def test02_commit_multiLineResult(self):
        self.client = currencyclient.RealCurrencyClient()

        oldRequest = self.client.request
        requestDeferred = defer.Deferred()
        def myRequest(url = None, command = None, transaction_id = None):
            self.assertEquals(command, 'commit')
            self.assertEquals(url, "url_dummy")
            self.assertEquals(transaction_id, "transaction_dummy")
            return requestDeferred
        self.client.request = myRequest

        self.assertEquals(self.client.commit("url_dummy", "transaction_dummy"),
                          requestDeferred)


        confirmErrorFoundDeferred = defer.Deferred()
        def catchException(err):
            self.assertEquals(err.check(Exception), Exception)
            self.assertEquals(err.getErrorMessage(),
                              "expected a single line got two\nlines instead")
            confirmErrorFoundDeferred.callback(True)
        requestDeferred.addErrback(catchException)

        requestDeferred.callback("two\nlines")

        self.client.request = oldRequest
        return confirmErrorFoundDeferred
    # -----------------------------------------------------------------------------
    def test03_checkNote_checkNoteResultIsFalse(self):
        """test03_checkNote_checkNoteResultIsFalse

        The goal of this test is to cover the setting of result to
        failure.Failure() in checkNote().  We have to get a bit tricky
        with deferreds to cause this to happen.  Our chainBegin deferred
        is set up to raise an exception immediately in its callback, which
        will chain off to its own errBack.  Its errBack then calls
        checkNote.  Since there is already an error propogating through,
        the failure.Failure() will work properly to then, in turn, trigger
        the errBack of checkNotesDeferred.  Finally, we make sure the
        point is reached by having the usual rougue deferred that only
        gets called back by the verification process."""

        class PropogatedException(Exception): pass

        self.client = currencyclient.FakeCurrencyClient()
        self.client.check_note_result = False

        forceTimeoutErrorIfNotCalledBack = defer.Deferred()
        def verifyError(err):
            self.assertEquals(err.check(PropogatedException), PropogatedException)
            self.assertEquals(err.getErrorMessage(),
                              "this exception ends up in checknotes errback")
            forceTimeoutErrorIfNotCalledBack.callback(True)
            if hasattr(self, 'client'):
                self.client.check_note_result = True

        def executeCheckNote(value):
            self.assertEquals(value.check(PropogatedException), PropogatedException)
            self.assertEquals(value.getErrorMessage(),
                              "this exception ends up in checknotes errback")

            checkNotesDeferred = self.client.checkNote(None)
            checkNotesDeferred.addErrback(verifyError)
            return checkNotesDeferred

        def propogateError(value):
            raise PropogatedException("this exception ends up in checknotes errback")

        chainBegin = defer.Deferred()
        chainBegin.addCallback(propogateError)
        chainBegin.addErrback(executeCheckNote)
        chainBegin.callback(True)

        return forceTimeoutErrorIfNotCalledBack
    # -----------------------------------------------------------------------------
    def test04_commit_commitResultIsFalse(self):
        """test04_commit_commitResultIsFalse
        This test is nearly identical to
        test03_checkNote_checkNoteResultIsFalse, since the methods work
        very similarily."""

        class PropogatedException(Exception): pass

        self.client = currencyclient.FakeCurrencyClient()
        self.client.commit_result = False

        forceTimeoutErrorIfNotCalledBack = defer.Deferred()
        def verifyError(err):
            self.assertEquals(err.check(PropogatedException), PropogatedException)
            self.assertEquals(err.getErrorMessage(),
                              "this exception ends up in commit errback")
            forceTimeoutErrorIfNotCalledBack.callback(True)
            if hasattr(self, 'client'):
                self.client.commit_result = True

        def executeCommit(value):
            self.assertEquals(value.check(PropogatedException), PropogatedException)
            self.assertEquals(value.getErrorMessage(),
                              "this exception ends up in commit errback")

            commitDeferred = self.client.commit(None, None)
            commitDeferred.addErrback(verifyError)
            return commitDeferred

        def propogateError(value):
            raise PropogatedException("this exception ends up in commit errback")

        chainBegin = defer.Deferred()
        chainBegin.addCallback(propogateError)
        chainBegin.addErrback(executeCommit)
        chainBegin.callback(True)
        return forceTimeoutErrorIfNotCalledBack
# -----------------------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test07"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(CurrencyClientTestCase))
    suite.addTest(loader.loadClass(FakeCurrencyClientTestCase))
    suite.addTest(loader.loadClass(ErrorCondtionsCurrencyClientTestCase))
    return runner.TrialRunner(reporter.TextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# -----------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-currencyclient.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/currencyclient.py' TESTS='coverage-reset test-currencyclient.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-javascript
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os
sys.path.insert(0, "..")
sys.path.insert(0, "..")

import unittest
import simplejson
from struct import pack, unpack, calcsize

from pokernetwork import pokerclientpackets

class JavaScriptGenerator:
    def __init__(self, type):
        self.type = type

    
class JavaScriptGeneratorTestCase(unittest.TestCase):

    #--------------------------------------------------------------    
    def test_all(self):
        result = []
        for (index, name) in pokerclientpackets.PacketNames.iteritems():
            result.append(name + ": "  + str(index))
        print "{ " + ", ".join(result) + " }";

#--------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(JavaScriptGeneratorTestCase))
    return suite
    
#--------------------------------------------------------------
def Run(verbose = 2):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
    
#--------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-javascript.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/packets.py' TESTS='coverage-reset test-javascript.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-leak-exarkun
#!/usr/bin/python2.5
# -*- mode: python -*-
#
# Copyright (C) 2008 Jean-Paul Calderone <exarkun@twistedmatrix.com>
# Copyright (C) 2008 Johan Euphrosine <proppy@aminche.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import guppy, gc
 
from twisted.trial import unittest
from twisted.web import client, http
 
from twisted.web import server, resource
from twisted.internet import reactor, defer
 
hpy = guppy.hpy()

class Simple(resource.Resource):
        isLeaf = True
        def render_GET(self, request):
                return "<html>Hello, world!</html>"
 
def f(ignored, last, first):
        gc.collect()
        next = hpy.heap()
        print 'SINCE LAST TIME'
        print next - last
        print 'SINCE FOREVER'
        print last - first
        d = client.getPage("http://localhost:8080/")
        d.addCallback(f, next, first)

def main():
        site = server.Site(Simple())
        port = reactor.listenTCP(8080, site)
        first = hpy.heap()
        f(None, first, first)
        reactor.run()
 
main()

########NEW FILE########
__FILENAME__ = test-leak-no-trial
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2008 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

from twisted.internet import selectreactor, main
class MyReactor(selectreactor.SelectReactor):
      def runUntilCurrent(self):
            self._cancellations = 20000000
            selectreactor.SelectReactor.runUntilCurrent(self)
main.installReactor(MyReactor())
from twisted.internet import defer, reactor
from twisted.application import internet
from twisted.python import failure
from twisted.python.runtime import seconds
import twisted.internet.base
twisted.internet.base.DelayedCall.debug = True

from twisted.web import client, http

from tests import testclock

from pokernetwork import pokermemcache
from pokernetwork import pokersite
from pokernetwork import pokernetworkconfig
from pokernetwork import pokerservice
from pokernetwork.pokerpackets import *

verbose = int(os.environ.get('VERBOSE_T', '-1'))
settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="%(verbose)i" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19481" />
  <resthost host="127.0.0.1" port="19481" path="/POKER_REST" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'verbose': verbose, 'script_dir': SCRIPT_DIR}

class LeakTestCase:

      def destroyDb(self, arg = None):
            if len("") > 0:
                  os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
            else:
                  os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")

      def initServer(self):
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml_server)
            self.server_service = pokerservice.PokerService(settings)
            self.server_service.disconnectAll = lambda: True
            self.server_service.startService()
            self.server_site = pokersite.PokerSite(settings, pokerservice.PokerRestTree(self.server_service))
            self.server_port = reactor.listenTCP(19481, self.server_site, interface="127.0.0.1")

      def setUp(self):
            testclock._seconds_reset()
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            pokermemcache.memcache_singleton.clear()
            pokermemcache.memcache_expiration_singleton.clear()
            self.destroyDb()
            self.initServer()

      def tearDownServer(self):
            self.server_site.stopFactory()
            d = self.server_service.stopService()
            d.addCallback(lambda x: self.server_port.stopListening())
            return d

      def tearDown(self):
            d = self.tearDownServer()
            d.addCallback(self.destroyDb)
            d.addCallback(lambda x: reactor.disconnectAll())
            return d

      def cleanMemcache(self, x):
            pokermemcache.memcache_singleton.clear()
            pokermemcache.memcache_expiration_singleton.clear()

      def test01_ping(self):
            """
            VIRT (samples: 167, step 3s)
            34372, stable
            """
            def f(ignored):
                  d = client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPing"}')
                  d.addCallback(self.cleanMemcache)
                  d.addCallback(f)
            f(None)

      def test02_joinTable(self):
            """
            VIRT (samples: 63, step: 3s)
            35792, stable
            """
            def f(ignored, i):
                  serial = 0
                  session = 'session' + str(i)
                  self.server_site.memcache.set(session, str(serial))
                  headers = { 'Cookie': 'TWISTED_SESSION='+session }
                  d = client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPokerTableJoin","game_id":1}', headers = headers)
                  d.addCallback(lambda x: client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPokerTableQuit","game_id":1}', headers = headers))
                  d.addCallback(self.cleanMemcache)
                  d.addCallback(f, i+1)
            i = 1
            f(None, i)

      def test03_joinTable_guppy(self):
            import guppy, gc
            hpy = guppy.hpy()
            def f(ignored, last, first, i):
                  gc.collect()
                  next = hpy.heap()
                  print 'SINCE LAST TIME'
                  print next - last
                  print 'SINCE FOREVER'
                  print last - first
                  serial = 0
                  session = 'session' + str(i)
                  self.server_site.memcache.set(session, str(serial))
                  headers = { 'Cookie': 'TWISTED_SESSION='+session }
                  d = client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPokerTableJoin","game_id":1}', headers = headers)
                  d.addCallback(lambda x: client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPokerTableQuit","game_id":1}', headers = headers))
                  d.addCallback(self.cleanMemcache)
                  d.addCallback(f, next, first, i+1)
            first = hpy.heap()
            i = 1
            f(None, first, first, i)

if __name__ == '__main__':
      t = LeakTestCase()
      t.setUp()
      t.test01_ping()
      reactor.run()

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-leak-no-trial.py ) ; ( cd ../tests ; VERBOSE_T=-1 ./test-leak-no-trial.py )"
# End:

########NEW FILE########
__FILENAME__ = test-leak-reference
#!/usr/bin/python2.5
# -*- mode: python -*-
#
# Copyright (C) 2008 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

from twisted.trial import unittest, runner, reporter
from twisted.web import client, http

from twisted.web import server, resource
from twisted.internet import reactor, defer

class Simple(resource.Resource):
        isLeaf = True
        def render_GET(self, request):
		print request		
		return "<html>Hello, world!</html>"
	
class LeakReferenceTestCase(unittest.TestCase):
	def setUp(self):
		self.site = server.Site(Simple())
		self.port = reactor.listenTCP(8080, self.site)
	def tearDown(self):
		return self.port.stopListening()    
	def test01_get_page(self):
		def f(ignored):
			d = client.getPage("http://localhost:8080/")
			d.addCallback(f)
		f(None)
		d = defer.Deferred()
		return d
	def test02_get_page_guppy(self):
		import guppy, gc
		hpy = guppy.hpy()
		def f(ignored, last, first):
			gc.collect()
			next = hpy.heap()
			print 'SINCE LAST TIME'
			print next - last
			print 'SINCE FOREVER'
			print last - first
			d = client.getPage("http://localhost:8080/")
			d.addCallback(f, next, first)
		first = hpy.heap()			
		f(None, first, first)
		d = defer.Deferred()
		return d
def Run():
      loader = runner.TestLoader()
      loader.methodPrefix = "test02"
      suite = loader.suiteFactory()
      suite.addTest(loader.loadClass(LeakReferenceTestCase))
      return runner.TrialRunner(
            reporter.VerboseTextReporter,
            tracebackFormat='default',
#            logfile = '-',
            ).run(suite)

if __name__ == '__main__':
      if Run().wasSuccessful():
            sys.exit(0)
      else:
            sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-leak-reference.py ) ; ( cd ../tests ; make VERBOSE_T=-1 TESTS='test-leak-reference.py' check )"
# End:

########NEW FILE########
__FILENAME__ = test-leak
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2008 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

from twisted.trial import unittest, runner, reporter

from twisted.internet import selectreactor, main
class MyReactor(selectreactor.SelectReactor):
      def runUntilCurrent(self):
            self._cancellations = 20000000
            selectreactor.SelectReactor.runUntilCurrent(self)
main.installReactor(MyReactor())
from twisted.internet import defer, reactor
from twisted.application import internet
from twisted.python import failure
from twisted.python.runtime import seconds
import twisted.internet.base
twisted.internet.base.DelayedCall.debug = True

from twisted.web import client, http

from tests import testmessages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: testmessages.silence_all_messages()

from tests import testclock

from pokernetwork import pokermemcache
from pokernetwork import pokersite
from pokernetwork import pokernetworkconfig
from pokernetwork import pokerservice
from pokernetwork import proxyfilter
from pokernetwork.pokerpackets import *

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19481" />
  <resthost host="127.0.0.1" port="19481" path="/POKER_REST" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

class LeakTestCase(unittest.TestCase):

      def destroyDb(self, arg = None):
            if len("") > 0:
                  os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
            else:
                  os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")

      def initServer(self):
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml_server)
            self.server_service = pokerservice.PokerService(settings)
            self.server_service.disconnectAll = lambda: True
            self.server_service.startService()
            self.server_site = pokersite.PokerSite(settings, pokerservice.PokerRestTree(self.server_service))
            self.server_port = reactor.listenTCP(19481, self.server_site, interface="127.0.0.1")

      def setUp(self):
            testclock._seconds_reset()
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            pokermemcache.memcache_singleton.clear()
            pokermemcache.memcache_expiration_singleton.clear()
            self.destroyDb()
            self.initServer()

      def tearDownServer(self):
            self.server_site.stopFactory()
            d = self.server_service.stopService()
            d.addCallback(lambda x: self.server_port.stopListening())
            return d

      def tearDown(self):
            d = self.tearDownServer()
            d.addCallback(self.destroyDb)
            d.addCallback(lambda x: reactor.disconnectAll())
            return d

      def test00(self):
            pass

      def test01_ping(self):
            """
            """
            def f(ignored):
                  d = client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPing"}')
                  def cleanMemcache(x):
                        pokermemcache.memcache_singleton.clear()
                        pokermemcache.memcache_expiration_singleton.clear()
                  d.addCallback(cleanMemcache)
                  d.addCallback(f)
            f(None)
            d = defer.Deferred()
            return d
      test01_ping.timeout = pow(2, 30)

      def test02_joinTable(self):
            """
            """
            def f(ignored, i):
                  serial = 0
                  session = 'session' + str(i)
                  self.server_site.memcache.set(session, str(serial))
                  headers = { 'Cookie': 'TWISTED_SESSION='+session }
                  d = client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPokerTableJoin","game_id":1}', headers = headers)
                  d.addCallback(lambda x: client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPokerTableQuit","game_id":1}', headers = headers))
                  def cleanMemcache(x):
                        pokermemcache.memcache_singleton.clear()
                        pokermemcache.memcache_expiration_singleton.clear()
                  d.addCallback(cleanMemcache)
                  d.addCallback(f, i+1)
            i = 1
            f(None, i)
            d = defer.Deferred()
            return d
      test02_joinTable.timeout = pow(2, 30)

      def test03_joinTable_guppy(self):
            import guppy, gc
            hpy = guppy.hpy()
            def f(ignored, last, first, i):
                  gc.collect()
                  next = hpy.heap()
                  print 'SINCE LAST TIME'
                  print next - last
                  print 'SINCE FOREVER'
                  print last - first
                  serial = 0
                  session = 'session' + str(i)
                  self.server_site.memcache.set(session, str(serial))
                  headers = { 'Cookie': 'TWISTED_SESSION='+session }
                  d = client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPokerTableJoin","game_id":1}', headers = headers)
                  d.addCallback(lambda x: client.getPage("http://127.0.0.1:19481/POKER_REST", postdata = '{"type":"PacketPokerTableQuit","game_id":1}', headers = headers))
                  def cleanMemcache(x):
                        pokermemcache.memcache_singleton.clear()
                        pokermemcache.memcache_expiration_singleton.clear()
                  d.addCallback(cleanMemcache)
                  d.addCallback(f, next, first, i+1)
            first = hpy.heap()
            i = 1
            f(None, first, first, i)
            d = defer.Deferred()
            return d
      test03_joinTable_guppy.timeout = pow(2, 30)

def Run():
      loader = runner.TestLoader()
      loader.methodPrefix = "test03"
      suite = loader.suiteFactory()
      suite.addTest(loader.loadClass(LeakTestCase))
      return runner.TrialRunner(
            reporter.VerboseTextReporter,
            tracebackFormat='default',
#            logfile = '-',
            ).run(suite)

if __name__ == '__main__':
      if Run().wasSuccessful():
            sys.exit(0)
      else:
            sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-leak.py ) ; ( cd ../tests ; make VERBOSE_T=-2 TESTS='test-leak.py' check )"
# End:

########NEW FILE########
__FILENAME__ = test-nullfilter
#!/usr/bin/python
# -*- mode: python; coding: iso-8859-1 -*-
# more information about the above line at http://www.python.org/dev/peps/pep-0263/
#
# Copyright (C) 2009 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os, tempfile, shutil
sys.path.insert(0, "./..")
sys.path.insert(0, "..")
import unittest
from pokernetwork import nullfilter

# ------------------------------------------------------------    
class NullFilterTestCase(unittest.TestCase):
    # -------------------------------------------------------------------------
    def setUp(self):
        pass
    # -------------------------------------------------------------------------
    def tearDown(self):
        pass
    # -------------------------------------------------------------------------
    def test00_restfilter_none(self):
        """test00_restfilter_none"""

        self.failUnless(nullfilter.rest_filter(None, None, None),
                        "nullfilter.rest_filter always returns True")
    # -------------------------------------------------------------------------
    def test01_restfilter_strings(self):
        """test01_restfilter_strings"""

        self.failUnless(nullfilter.rest_filter("SITE", "REQUEST", "PACKET"),
                        "nullfilter.rest_filter always returns True")
# ------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(NullFilterTestCase))

    # Comment out above and use line below this when you wish to run just
    # one test by itself (changing prefix as needed).
#    suite.addTest(unittest.makeSuite(PokerGameHistoryTestCase, prefix = "test2"))
    return suite
# -----------------------------------------------------------------------------
def Run(verbose = 2):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
# -----------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-nullfilter.py ) ; ( cd ../tests ; make VERBOSE_T=-1 COVERAGE_FILES='../pokernetwork/nullfilter.py' TESTS='coverage-reset test-nullfilter.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-packets
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os
sys.path.insert(0, "..")
sys.path.insert(0, ".")
sys.path.insert(0, "..")

import unittest
import simplejson
from struct import pack, unpack, calcsize

import testpackets

from pokernetwork import packets

class PacketsTestCase(testpackets.PacketsTestBase):

    def test_unpack(self):
        class TestPacket(packets.Packet):
            def __init__(self):
                self.type = 77

        class TestPacketList(packets.PacketList):
            def __init__(self):
                self.type = 254
                packets.PacketList.__init__(self, packets = [TestPacket()])

        self.assertEqual(None, self.packetCheck(type = TestPacketList))

        class TestPacketList(packets.PacketList):
            def __init__(self):
                self.type = 253
                packets.PacketList.__init__(self, packets = [packets.Packet()])

            def unpack(self, block):
                packets.PacketList.unpack(self, block[:-3])

        self.assertEqual(None, self.packetCheck(type = TestPacketList))
        
    #--------------------------------------------------------------    
    def test_all(self):
        for type_index in packets._TYPES:
            if packets.PacketFactory.has_key(type_index):
                if self.verbose > 0:
                    print packets.PacketNames[type_index]
                self.packetCheck(type = packets.PacketFactory[type_index])

        class TestPacketList(packets.PacketList):
            def __init__(self):
                packets.PacketList.__init__(self, packets = [packets.Packet()])
        self.packetCheck(type = TestPacketList)

        packets.PacketNames[253] = 'TestPacketFieldList'
        
        class TestPacketFieldList(packets.Packet):
            type = 253

            info = packets.Packet.info + ( ('serials', [1], 'Il'), )
            
            serials = []

            format_element = "!I"

            def __init__(self, *args, **kwargs):
                self.serials = kwargs.get("serials", [])

            def pack(self):
                block = packets.Packet.pack(self)
                block += self.packlist(self.serials, TestPacketFieldList.format_element)
                return block

            def unpack(self, block):
                block = packets.Packet.unpack(self, block)
                (block, self.serials) = self.unpacklist(block, TestPacketFieldList.format_element)
                return block

            def calcsize(self):
                return packets.Packet.calcsize(self) + self.calcsizelist(self.serials, TestPacketFieldList.format_element)

            def __str__(self):
                return packets.Packet.__str__(self) + " serials = %s" % self.serials

        self.packetCheck(type = TestPacketFieldList, serials = [1])

    def defineTestPacket(self):
        d = {}
        d['PacketFactory'] = {}
        d['PacketNames'] = {}
        
        class TestPacket(packets.Packet):
            info = packets.Packet.info + (('b' , 10, 'B'),
                                          ('a', 20, 'I'),
                                          ('c', 'ABC', 's'),
                                          ('d', [1,2,3], 'Bl'),
                                          ('e', -1, 'b'),
                                          ('f', None, 'no net'),
                                          ('g', [{'a': [1,2]}, None, True], 'j'),
                                          ('h', [packets.PacketPing(), packets.PacketPing()], 'pl'),
                                          ('i', True, 'bool'),
                                          ('i1', False, 'bool'),
                                          ('j', 'n', 'cbool'),
                                          ('j1', 'y', 'cbool'),
                                          ('k', None, 'Bnone'),
                                          )
            fields = ( "\x0a", # type
                       "\0\0", # length
                       "\x02", # b
                       "\0\0\0\x01", # a
                       "\0\x03ABC", # c
                       "\x03\x01\x02\x03", # d
                       "\xff", # e
                       '\x00\x1b[{"a": [1, 2]}, null, true]', # g
                       "\x00\x02\x05\x00\x03\x05\x00\x03", # h
                       "\x01", # i
                       "\x00", # i1
                       "\x00", # j
                       "\x01", # j1
                       "\xff", # k
                       )
            binary = fields[0] + pack('!H', len("".join(fields))) + "".join(fields[2:])
        d = {}
        d['PacketFactory'] = {}
        d['PacketNames'] = {}
        packets.Packet.infoDeclare(d, TestPacket, packets.Packet, 'NAME', 10)
        return TestPacket

    def test_infoPack(self):
        type = self.defineTestPacket()
        packet = type()
        packet.a = 1
        packet.b = 2
        self.assertEqual(type.binary, packet.infoPack())

    def test_infoUnpack(self):
        type = self.defineTestPacket()
        packet = type()
        packet.infoUnpack(type.binary)
        self.assertEqual(1, packet.a)
        self.assertEqual(2, packet.b)

    def test_infoUnpackJSON(self):
        type = self.defineTestPacket()
        packet = type()
        class TestJSON(simplejson.JSONEncoder):
            @staticmethod
            def decode_objects(something):
                return something
        old_JSON = packets.Packet.JSON
        packets.Packet.JSON = TestJSON()
        packet.infoUnpack(type.binary)
        packets.Packet.JSON = old_JSON
        self.assertEqual(1, packet.a)
        self.assertEqual(2, packet.b)

    def test_infoCalcsize(self):
        type = self.defineTestPacket()
        packet = type()
        self.assertEqual(len(type.binary), packet.infoCalcsize())

    def test_infoDeclare(self):
        d = {}
        d['PacketFactory'] = {}
        d['PacketNames'] = {}
        class TestPacketClass(packets.Packet):
            pass
        index = 11
        packets.Packet.infoDeclare(d, TestPacketClass, packets.Packet, 'NAME', index)
        self.assertEqual(TestPacketClass, d['PacketFactory'][index])
        self.assertEqual('NAME', d['PacketNames'][index])
        self.assertEqual(TestPacketClass.type, index)
        test_packet = TestPacketClass()
        packet = packets.Packet()
        self.assertEqual(packet.calcsize(), test_packet.calcsize())
        self.assertEqual("AUTH_REQUEST  type = 11 length = 3", str(test_packet))

    def test_unpackpackets_errors(self):
        #
        # Unknown packet type
        #
        self.assertEqual(None, packets.Packet.unpackpackets('\x00\x01\xff\x00\x03'));
        #
        # Pretend there are 2 packets although only one is present
        #
        self.assertEqual(None, packets.Packet.unpackpackets('\x00\x02\x00\x00\x03'));

#--------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(PacketsTestCase))
    return suite
    
#--------------------------------------------------------------
def Run(verbose = 2):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
    
#--------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-packets.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/packets.py' TESTS='coverage-reset test-packets.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = pokerauth
class PokerAuth:
    def __init__(self, db, settings):
        self.gotcha = 1

def get_auth_instance(db, settings):
    return PokerAuth(db, settings)

########NEW FILE########
__FILENAME__ = test-pokerauth
# -*- mode: python -*-
#
# Note: this file is copyrighted by multiple entities; some license their
# copyrights under GPLv3-or-later and some under AGPLv3-or-later.  Read
# below for details.
#
# Copyright (C) 2008 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2006 Mekensleep <licensing@mekensleep.com>
#                    24 rue vieille du temple 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Pierre-Andre (05/2006)
#  Loic Dachary <loic@gnu.org>
#  Johan Euphrosine <proppy@aminche.com>
#  Bradley M. Kuhn <bkuhn@ebb.org>
#

import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import unittest
import os.path
import types

from tests.testmessages import silence_all_messages, clear_all_messages, get_messages, search_output
silence_all_messages()

from twisted.python.runtime import seconds

from pokernetwork import pokerauth
from pokernetwork.user import User
from pokernetwork import pokernetworkconfig
from pokernetwork.pokerdatabase import PokerDatabase
import libxml2

settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server auto_create_account="no" verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

settings_alternate_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <path>NONE/share/poker-engine/conf NONE/etc/poker-network</path>
  <users temporary="BOT"/>
  <auth script="./test-pokerauth/pokerauth.py" />
</server>
"""

class PokerAuthTestCase(unittest.TestCase):

    # -----------------------------------------------------------------------------------------------------
    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    # --------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        self.settings.header = self.settings.doc.xpathNewContext()
        self.db = PokerDatabase(self.settings)
    # -----------------------------------------------------------------------------------------------------
    def tearDown(self):
        pokerauth._get_auth_instance = None
    # -----------------------------------------------------------------------------------------------------
    def test01_Init(self):
        """test01_Init
        Test Poker auth : get_auth_instance"""
        db = None
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        auth = pokerauth.get_auth_instance(db, settings)

    # -----------------------------------------------------------------------------------------------------
    def test02_AlternatePokerAuth(self):
        """test02_AlternatePokerAuth
        Test Poker auth : get_auth_instance alternate PokerAuth"""
        db = None
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_alternate_xml, len(settings_alternate_xml))
        settings.header = settings.doc.xpathNewContext()
        auth = pokerauth.get_auth_instance(db, settings)
        self.failUnless(hasattr(auth, 'gotcha'))
    # -----------------------------------------------------------------------------------------------------
    def checkIfUserExistsInDB(self, name, selectString = "SELECT serial from users where name = '%s'"):
        cursor = self.db.cursor()
        cursor.execute(selectString % name)
        if cursor.rowcount == 1:
            (serial,) = cursor.fetchone()
            cursor.close()
            return [serial]
        elif cursor.rowcount == 0:
            cursor.close()
            return []
        else:
            serials = []
            for row in cursor.fetchall(): serials.append(row['serial'])
            cursor.close()
            return serials
    # -----------------------------------------------------------------------------------------------------
    def test03_authWithAutoCreate(self):
        """test03_authWithAutoCreate
        Test Poker auth : Try basic auth with autocreate on"""
        db = self.db
        settings = pokernetworkconfig.Config([])
        autocreate_xml = settings_xml.replace('<server auto_create_account="no" ', '<server ')
        settings.doc = libxml2.parseMemory(autocreate_xml, len(autocreate_xml))
        settings.header = settings.doc.xpathNewContext()
        auth = pokerauth.get_auth_instance(db, settings)

        clear_all_messages()
        self.assertEquals(auth.auth('joe_schmoe', 'foo'), ((4, 'joe_schmoe', 1), None))
        self.assertEquals(get_messages(), ['user joe_schmoe does not exist, create it',
                                       'creating user joe_schmoe', 'create user with serial 4'])
        self.failUnless(len(self.checkIfUserExistsInDB('joe_schmoe')) == 1)
    # -----------------------------------------------------------------------------------------------------
    def test04_authWithoutAutoCreate(self, expectedMessage = 'user john_smith does not exist'):
        """test04_authWithoutAutoCreate
        Test Poker auth : Try basic auth with autocreate on"""
        auth = pokerauth.get_auth_instance(self.db, self.settings)

        clear_all_messages()

        self.assertEquals(auth.auth('john_smith', 'blah'), (False, 'Invalid login or password'))
        if expectedMessage:
            self.assertTrue(search_output(expectedMessage))
        self.failUnless(len(self.checkIfUserExistsInDB('john_smith')) == 0)
    # -----------------------------------------------------------------------------------------------------
    def test05_authWhenDoubleEntry(self):
        """test05_authWhenDoubleEntry
        Tests case in fallback authentication where more than one entry exists.
        """
        cursor = self.db.cursor()
        cursor.execute("DROP TABLE users")
        cursor.execute("""CREATE TABLE users (
 	    serial int unsigned not null auto_increment,
	    name varchar(32), password varchar(32), privilege int default 1,
            primary key (serial))""")
        for ii in [ 1 , 2 ]:
            cursor.execute("INSERT INTO users (name, password) values ('%s', '%s')" %
                           ('doyle_brunson', 'foo'))
        cursor.close()

        auth = pokerauth.get_auth_instance(self.db, self.settings)

        clear_all_messages()
        self.assertEquals(auth.auth('doyle_brunson', 'foo'), (False, "Invalid login or password"))
        self.assertEquals(get_messages(), ['*ERROR* more than one row for doyle_brunson'])
    # -----------------------------------------------------------------------------------------------------
    def test06_validAuthWhenEntryExists(self):
        """test06_validAuthWhenEntryExists
        Tests case for single-row returned existing auth, both success and failure.
        """
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO users (created, name, password) values (%d, '%s', '%s')" %
                       (seconds(), 'dan_harrington', 'bar'))
        cursor.close()

        auth = pokerauth.get_auth_instance(self.db, self.settings)

        clear_all_messages()
        self.assertEquals(auth.auth('dan_harrington', 'bar'), ((4L, 'dan_harrington', 1L), None))
        self.assertEquals(get_messages(), [])

        clear_all_messages()
        self.assertEquals(auth.auth('dan_harrington', 'wrongpass'), (False, 'Invalid login or password'))
        self.assertEquals(get_messages(), ['password mismatch for dan_harrington'])
    # -----------------------------------------------------------------------------------------------------
    def test07_mysql11userCreate(self):
        """test07_mysql11userCreate
        Tests userCreate() as it will behave under MySQL 1.1 by mocking up
        the situation.
        """
        class MockCursor:
            def execute(self, str): pass
            def insert_id(self):    return 4815
            def close(self):        pass
        class MockDatabase:
            def cursor(self):    return MockCursor()

        clear_all_messages()
        auth = pokerauth.get_auth_instance(MockDatabase(), self.settings)
        self.assertEquals(auth.userCreate("nobody", "nothing"), 4815)
        self.assertTrue(search_output('creating user nobody'))
        self.assertTrue(search_output('create user with serial 4815'))
    # -----------------------------------------------------------------------------------------------------
    def test08_mysqlbeyond11userCreate(self):
        """test08_mysqlbeyond11userCreate
        Tests userCreate() as it will behave under MySQL > 1.1 by mocking up
        the situation.
        """
        class MockCursor:
            def __init__(self):
                self.lastrowid = 162342
            def execute(self, str): pass
            def insert_id(self):    self.failIf(1)
            def close(self):        pass
        class MockDatabase:
            def cursor(self):    return MockCursor()

        clear_all_messages()
        auth = pokerauth.get_auth_instance(MockDatabase(), self.settings)
        self.assertEquals(auth.userCreate("somebody", "something"), 162342)
        self.assertTrue(search_output('creating user somebody'))
        self.assertTrue(search_output('create user with serial 162342'))
    # -----------------------------------------------------------------------------------------------------
    def test09_setAndGetLevel(self):
        """test09_setAndGetLevel
        Tests the SetLevel and GetLevel methods.
        """
        auth = pokerauth.get_auth_instance(self.db, self.settings)

        self.assertEquals(auth.GetLevel('first'), False)
        self.assertEquals(auth.SetLevel('first', 7), None)
        self.assertEquals(auth.GetLevel('first'), 7)
        self.assertEquals(auth.GetLevel('second'), False)
# -----------------------------------------------------------------------------------------------------
settings_mysql_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
  <auth script="%(script_dir)s/../pokernetwork/pokerauthmysql.py" host="localhost" user="root" password="" db="testpokerauthmysql" table="users"/>
</server>
""" % {'script_dir': SCRIPT_DIR}
import MySQLdb

class PokerAuthMysqlTestCase(PokerAuthTestCase):
    # -----------------------------------------------------------------------------------------------------
    def setUp(self):
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_mysql_xml, len(settings_mysql_xml))
        self.settings.header = self.settings.doc.xpathNewContext()

        self.parameters = self.settings.headerGetProperties("/server/auth")[0]
        self.db = MySQLdb.connect(host = self.parameters["host"],
                                  port = int(self.parameters.get("port", '3306')),
                                  user = self.parameters["user"],
                                  passwd = self.parameters["password"])
        self.db.query("CREATE DATABASE %s" % self.parameters["db"])
        self.db.query("USE %s" % self.parameters["db"])
        self.db.query("CREATE TABLE %s (username varchar(20), password varchar(20), privilege int)" % self.parameters["table"])
        self.db.query("INSERT INTO users (username, password, privilege) VALUES ('testuser', 'testpassword', %i)" % User.REGULAR)
    # -----------------------------------------------------------------------------------------------------
    def tearDown(self):
        self.db.query("DROP DATABASE %s" % self.parameters["db"])
        pokerauth._get_auth_instance = None
    # -----------------------------------------------------------------------------------------------------
    def checkIfUserExistsInDB(self, name, selectString = ""):
        return PokerAuthTestCase.checkIfUserExistsInDB(self, name,
                             selectString = "SELECT username from " + self.parameters["table"]
                                                +  " where username = '%s'")
    # -----------------------------------------------------------------------------------------------------
    def test01_Init(self):
        """test01_Init
        Test initalizing pokerauthmysql"""
        db = None
        auth = pokerauth.get_auth_instance(db, self.settings)
        result, message = auth.auth("testuser", "testpassword")
        self.assertNotEquals(False, result)
    # -----------------------------------------------------------------------------------------------------
    def test03_authWithAutoCreate(self):
        """test03_authWithAutoCreateis not needed for MySQLAUTH"""
        pass
    # -----------------------------------------------------------------------------------------------------
    def test04_authWithoutAutoCreate(self):
        """test04_authWithoutAutoCreate
        Test Poker auth : Try basic auth with autocreate on"""
        PokerAuthTestCase.test04_authWithoutAutoCreate(self, expectedMessage = '')
    # -----------------------------------------------------------------------------------------------------
    def test05_authWhenDoubleEntry(self):
        """test05_authWhenDoubleEntry
        Tests case in fallback authentication where more than one entry exists.
        """
        cursor = self.db.cursor()
        for ii in [ 1 , 2 ]:
            cursor.execute("INSERT INTO %s (username, password, privilege) values ('%s', '%s', %i)" %
                           (self.parameters["table"], 'doyle_brunson', 'foo', User.REGULAR))
        cursor.close()

        auth = pokerauth.get_auth_instance(self.db, self.settings)

        clear_all_messages()
        self.assertEquals(auth.auth('doyle_brunson', 'foo'), (False, "Invalid login or password"))
        self.assertEquals(get_messages(), [])
    # -----------------------------------------------------------------------------------------------------
    def test06_validAuthWhenEntryExists(self):
        """test06_validAuthWhenEntryExists
        Tests case for single-row returned existing auth, both success and failure.
        """
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO %s (username, password, privilege) values ('%s', '%s', %i)" %
                           (self.parameters["table"], 'dan_harrington', 'bar', User.REGULAR))
        cursor.close()

        auth = pokerauth.get_auth_instance(self.db, self.settings)

        clear_all_messages()
        self.assertEquals(auth.auth('dan_harrington', 'bar'), (('dan_harrington', 'dan_harrington', 1L), None))
        self.assertEquals(get_messages(), [])

        clear_all_messages()
        self.assertEquals(auth.auth('dan_harrington', 'wrongpass'), (False, 'Invalid login or password'))
        self.assertEquals(get_messages(), [])
    # -----------------------------------------------------------------------------------------------------
    def test07_mysql11userCreate(self):
        """test08_mysqlbeyond11userCreate is not needed for MySQLAUTH"""
        pass
    # -----------------------------------------------------------------------------------------------------
    def test08_mysqlbeyond11userCreate(self):
        """test08_mysqlbeyond11userCreate is not needed for MySQLAUTH"""
        pass
# -----------------------------------------------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(PokerAuthTestCase))
    suite.addTest(unittest.makeSuite(PokerAuthMysqlTestCase))
    # Comment out above and use line below this when you wish to run just
    # one test by itself (changing prefix as needed).
#    suite.addTest(unittest.makeSuite(PokerAuthTestCase, prefix = "test09"))
    return suite

# -----------------------------------------------------------------------------------------------------
def Run(verbose):
    suite = GetTestSuite()
    verbosity = int(os.environ.get('VERBOSE_T', 2))
    return unittest.TextTestRunner(verbosity=verbose).run(suite)

# -----------------------------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run(int(os.environ.get('VERBOSE_T', 2))).wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerauth.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerauth.py ../pokernetwork/pokerauthmysql.py' TESTS='coverage-reset test-pokerauth.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokeravatar
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007 - 2010 Loic Dachary    <loic@dachary.org>
# Copyright (C) 2008, 2009 Bradley M. Kuhn  <bkuhn@ebb.org>
# Copyright (C) 2008       Johan Euphrosine <proppy@aminche.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import locale
import libxml2
from types import *
import socket
from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer, error, base
from twisted.python import failure, runtime
from twisted.python.runtime import seconds

from pokerengine import pokertournament
#
# Must be done before importing pokerclient or pokerclient
# will have to be patched too.
#
from tests import testclock
import pprint

from tests.testmessages import restore_all_messages, silence_all_messages, search_output, clear_all_messages, get_messages
#os.environ['VERBOSE_T'] = '0'
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

twisted.internet.base.DelayedCall.debug = True

from pokernetwork import pokernetworkconfig
from pokernetwork import pokerclient
from pokernetwork import pokerservice
from pokernetwork import currencyclient
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerclientpackets import *
from pokernetwork.pokertable import PokerAvatarCollection
from pokernetwork.pokerrestclient import PokerRestClient

class ConstantDeckShuffler:
    def shuffle(self, what):
        what[:] = [40, 13, 32, 9, 19, 31, 15, 14, 50, 34, 20, 6, 43, 44, 28, 29, 48, 3, 21, 45, 23, 37, 35, 11, 5, 22, 24, 30, 27, 39, 46, 33, 0, 8, 1, 42, 36, 16, 49, 2, 10, 26, 4, 18, 7, 41, 47, 17]

from pokerengine import pokergame
pokergame.shuffler = ConstantDeckShuffler()

class ConstantPlayerShuffler:
    def shuffle(self, what):
        what.sort()

pokertournament.shuffler = ConstantPlayerShuffler()
PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY = -1

class PokerAvatarLocaleTestCase(unittest.TestCase):
    def test01_gettext_underscore_not_defined(self):
        from pokernetwork import pokeravatar
        service = PokerAvatarNoClientServerTestCase.MockService()
        avatar = pokeravatar.PokerAvatar(service)
        avatar.localeFunc = lambda x: x
        avatar.queuePackets()
        avatar.sendPacket(Packet())
        self.assertEquals(None, avatar._avatarSavedUnder)

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <language value="en_US.ISO-8859-1"/>
  <language value="fr_FR.ISO-8859-1"/>

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="2-4-limit" seats="10" player_timeout="60" currency_serial="0" />
  <table name="Table3" variant="holdem" betting_structure="test18pokerclient" seats="10" player_timeout="600" muck_timeout="600" currency_serial="1" forced_dealer_seat="0" />
  <table name="Table4" variant="holdem" betting_structure="ante-1-2-limit" seats="10" player_timeout="60" currency_serial="0" />
  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes"/>
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <tourney_select_info>%(script_dir)s/testtourney_select_info.py</tourney_select_info>
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

settings_xml_client = """<?xml version="1.0" encoding="ISO-8859-1"?>
<settings display2d="yes" display3d="no" ping="15000" verbose="6" delays="true" tcptimeout="2000" upgrades="no">
   <delays blind_ante_position="0" position="0" begin_round="0" end_round="0" end_round_last="0" showdown="0" lag="60"/>
  <screen fullscreen="no" width="1024" height="768"/>
  <name>user1</name>
  <passwd>password1</passwd>
  <remember>yes</remember>
  <muck>yes</muck>
  <auto_post>no</auto_post>
  <chat max_chars="40" line_length="20"/>
  <sound>yes</sound>
  <tournaments currency_serial="1" type="sit_n_go" sort="name"/>
  <lobby currency_serial="1" type="holdem" sort="name"/>
  <shadow>yes</shadow>
  <vprogram>yes</vprogram>

  <path>%(script_dir)s/../conf</path>
  <rsync path="/usr/bin/rsync" dir="." source="rsync.pok3d.com::pok3d/linux-gnu" target="/tmp/installed" upgrades="share/poker-network/upgrades"/>
  <data path="data" sounds="data/sounds"/>
  <handlist start="0" count="10"/>
</settings>
""" % {'script_dir': SCRIPT_DIR}
##############################################################################
class PokerAvatarTestCaseBaseClass(unittest.TestCase):
    timeout = 500

    def destroyDb(self, arg = None):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUpServer(self, serverSettings = settings_xml_server):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(serverSettings, len(serverSettings))
        settings.header = settings.doc.xpathNewContext()
        #
        # Setup server
        #
        self.service = pokerservice.PokerService(settings)
        self.service.verbose = 6
        self.service.startService()
        factory = pokerservice.IPokerFactory(self.service)
        self.p = reactor.listenTCP(0, factory,
                                   interface="127.0.0.1")
        self.port = self.p.getHost().port
    # ------------------------------------------------------
    def setUpClient(self, index):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_client, len(settings_xml_client))
        settings.header = settings.doc.xpathNewContext()
        self.client_factory.append(pokerclient.PokerClientFactory(settings = settings))
        self.assertEquals(len(self.client_factory), index + 1,
                          "clients must be created in daisy-chain with createClients() or createClient()")
        def setUpProtocol(client):
            client._poll_frequency = 0.1
            return client
        d = self.client_factory[index].established_deferred
        d.addCallback(setUpProtocol)
        return d
    # ------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()

        self.avatarLocales = {}
        self.avatarLocales[0] = "default"
        self.avatarLocales[1] = "default"

        self.destroyDb()
        self.setUpServer()
        self.client_factory = []

    # -------------------------------------------------------------------------
    def createClient(self):
        client_index = len(self.client_factory)
        self.setUpClient(client_index)
        reactor.connectTCP('127.0.0.1', self.port, self.client_factory[client_index])
        return client_index

    # -------------------------------------------------------------------------
    def createClients(self, numClients):
        if numClients == 0:
            return
        self.failIf(numClients <= 0, "Need to create at least one client")
        # A wish for a multi-line lambda()
        def make_connector(ii):
            def connector_func(client):
                reactor.connectTCP('127.0.0.1', self.port, self.client_factory[ii])
                return client
            return connector_func

        d = self.setUpClient(0)
        for ii in range(1, numClients):
            d.addCallback(make_connector(ii))
            d = self.setUpClient(ii)
        reactor.connectTCP('127.0.0.1', self.port, self.client_factory[0])
    # -------------------------------------------------------------------------
    def cleanSessions(self, arg):
        #
        # twisted Session code has leftovers : disable the hanging delayed call warnings
        # of trial by nuking all what's left.
        #
        pending = reactor.getDelayedCalls()
        if pending:
            for p in pending:
                if p.active():
#                    print "still pending:" + str(p)
                    p.cancel()
        return arg
    # -------------------------------------------------------------------------
    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.p.stopListening())
        d.addCallback(self.destroyDb)
        d.addCallback(self.cleanSessions)
        return d
    # -------------------------------------------------------------------------
    def quit(self, args):
        client = args[0]
        if verbose > 0:
            print "test-pokerclient: quit client " + str(client.getSerial())
        client.sendPacket(PacketQuit())
        if hasattr(client, "transport"):
            client.transport.loseConnection()
            return client.connection_lost_deferred
        else:
            raise UserWarning, "quit does not have transport %d" % client.getSerial()
    # -------------------------------------------------------------------------
    def setupCallbackChain(self, client):
        return (client, None)
    # ------------------------------------------------------------------------
    def autoBlindAnte(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerAutoBlindAnte(serial= client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_AUTO_BLIND_ANTE:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def sendExplain(self, client):
        client.sendPacket(PacketPokerExplain(value = PacketPokerExplain.ALL))
        return client.packetDeferred(True, PACKET_ACK)
    # -------------------------------------------------------------------------
    def sendRolePlay(self, (client, packet)):
        client.sendPacket(PacketPokerSetRole(serial = client.getSerial(), roles = PacketPokerSetRole.PLAY))
        return client.packetDeferred(True, PACKET_POKER_ROLES)
    # -------------------------------------------------------------------------
    def login(self, (client, packet), index):
        client.sendPacket(PacketLogin(name = 'user%d' % index, password = 'password1'))
        return client.packetDeferred(True, PACKET_POKER_PLAYER_INFO)
    # -------------------------------------------------------------------------
    def joinTable(self, (client, packet), id, gameId, name, struct, statsExpected = [],
                  variant = 'holdem', max_players = 10, reason = PacketPokerTable.REASON_TABLE_JOIN):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableJoin(serial = client.getSerial(),
                                                      game_id = gameId))
        total = 2 + len(statsExpected)
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_ARRIVE:
                game = table.game
                player = game.getPlayer(avatar.getSerial())
                if player:
                    self.assertEquals(player.buy_in_payed, packet.buy_in_payed)
            if packet.type == PACKET_POKER_TABLE:
                found += 1
                self.assertEquals(packet.betting_structure, struct)
                self.assertEquals(packet.variant, variant)
                self.assertEquals(packet.reason, reason)
                for  (kk, vv) in avatar.tables.items():
                    self.assertEquals(vv.game.id, table.game.id)
                    self.assertEquals(vv.game.name, name)
                    self.assertEquals(vv.game.max_players, max_players)
                    self.assertEquals(vv.game.variant, variant)
                    self.assertEquals(vv.game.betting_structure, struct)
            elif packet.type == PACKET_POKER_BUY_IN_LIMITS:
                found += 1
                for key in [ 'best', 'game_id', 'min', 'max' ]:
                    self.assert_(hasattr(packet, key))
            elif packet.type == PACKET_POKER_PLAYER_STATS:
                for ss in statsExpected:
                    if ss['serial'] == packet.serial:
                        found += 1
                        self.assertEquals(packet.rank, ss['rank'])
                        self.assertEquals(packet.percentile, ss['percentile'])
        self.assertEquals(found, total)
        return (client, packet)
    # -------------------------------------------------------------------------
    def seatTable(self, (client, packet), id, gameId, rank = None, percentile = None,
                  seatNumber = None):
        if seatNumber == None: seatNumber = id + 1

        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)

        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSeat(serial = client.getSerial(),
                                                 seat = seatNumber,
                                                 game_id = gameId))
        found = 0
        packets = avatar.resetPacketsQueue()
        for packet in packets:
            if packet.type == PACKET_POKER_SEATS:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                if seatNumber == -1:
                    self.failUnless(client.getSerial() in packet.seats)
                else:
                    self.assertEquals(packet.seats[seatNumber], client.getSerial())
            elif packet.type == PACKET_POKER_PLAYER_ARRIVE:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.name, "user%d" % id)
                self.assertEquals(packet.serial, client.getSerial())
                if seatNumber == -1:
                    self.failUnless(packet.seat >= 0)
                else:
                    self.assertEquals(packet.seat, seatNumber)
            elif packet.type == PACKET_POKER_PLAYER_STATS:
                found += 1
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.rank, rank)
                self.assertEquals(packet.percentile, percentile)
            elif packet.type == PACKET_POKER_PLAYER_CHIPS:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.bet, 0)
                self.assertEquals(packet.money, 0)
        expected = 3
        if percentile:
            expected += 1
        self.assertEquals(found, expected, "avatarID %d was unable to SEAT in game(%d) : %s" % (id, gameId, str(packets)))
        return (client, packet)
    # -------------------------------------------------------------------------
    def buyInTable(self, (client, packet), id, gameId, myAmount):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        seatNumber = id + 1
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerBuyIn(serial = client.getSerial(),
                                               amount = myAmount, game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_CHIPS:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.bet, 0)
                self.assertEquals(packet.money, myAmount)
        self.assertEquals(found, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def sitTable(self, (client, packet), id, gameId):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        seatNumber = id + 1
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSit(serial = client.getSerial(),
                                                game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_SIT:
                found = True
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, client.getSerial())
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def readyToPlay(self, (client, packet), id, gameId ):
        avatars = self.service.avatar_collection.get(client.getSerial())
        self.failUnless(len(avatars) ==  1, "Only one avatar should have this serial")
        avatar = avatars[0]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerReadyToPlay(serial = client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ACK:
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def sitOut(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSitOut(serial= client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_SIT_OUT:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                found = True
            elif packet.type == PACKET_POKER_CHAT:
                print packet
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def dealTable(self, (client, packet), gameId):
        table = self.service.getTable(gameId)
        table.beginTurn()
        table.update()
        return (client, packet)
    # ------------------------------------------------------------------------
    def beginHandSetup(self, (client, packet), gameId, autoDeal = False):
        dealerAssigned = 1
        blindAmount = 100
        blindExpected = 'small'
        table = self.service.getTable(gameId)
        avatar0 = self.service.avatars[0]
        avatar1 = self.service.avatars[1]
        avatar0.queuePackets()
        avatar1.queuePackets()
        # Handle the packets that initially arrive.  I learned what to
        # expect from "What to expect while a hand is being played?" in
        # pokerpackets.py
        packetList = []
        packetList.extend(avatar0.resetPacketsQueue())
        packetList.extend(avatar1.resetPacketsQueue())
        playersExpect = [ avatar0.getSerial(), avatar1.getSerial() ]
        playersExpect.sort()
        found = 0
        for packet in packetList:
            if packet.type == PACKET_POKER_IN_GAME:
                found += 1
                self.assertEquals(packet.serial, 0)
                self.assertEquals(packet.game_id, gameId)
                packet.players.sort()
                self.assertEquals(packet.players, playersExpect)
            elif packet.type == PACKET_POKER_DEALER:
                found += 1
                self.assertEquals(packet.dealer, dealerAssigned)
                self.assertEquals(packet.previous_dealer, -1)
                self.assertEquals(packet.game_id, gameId)
            elif packet.type == PACKET_POKER_START:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.level, 0)
                self.assertEquals(packet.hand_serial, 1)
                self.assertEquals(packet.serial, 0)
                self.assertEquals(packet.hands_count, 0)
                self.assertEquals(packet.time, 0)
            elif packet.type == PACKET_POKER_POSITION:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(True, packet.serial == avatar0.getSerial()
                                        or packet.serial == avatar1.getSerial())
            elif packet.type == PACKET_POKER_CHIPS_POT_RESET:
                found += 1
                self.assertEquals(packet.cookie, "")
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.length, 11)
                self.assertEquals(packet.serial, 0)
            elif packet.type == PACKET_POKER_BLIND_REQUEST:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.dead, 0)
                self.assertEquals(packet.serial, avatar1.getSerial())
                self.assertEquals(packet.amount, blindAmount)
                self.assertEquals(packet.state, blindExpected)
            elif packet.type == PACKET_POKER_SELF_IN_POSITION:
                self.assertEquals(packet.serial, avatar1.getSerial())
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.position, -1)
                self.assertEquals(packet.length, 8)
            elif packet.type == PACKET_POKER_BOARD_CARDS:
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(True, packet.serial == avatar0.getSerial()
                                        or packet.serial == avatar1.getSerial())

                self.assertEquals(packet.cards, [])
            # When I was writing this loop, I also saw a number of:
            # POKER_PLAYER_CHIPS and also the POKER_PLAYER_ARRIVE for
            # serial 5, but I thought it was safe to ignore them here.
        if autoDeal:
            expected = 16
        else:
            expected = 14
        self.assertEquals(found, expected, pprint.pformat(packetList))
        avatar0.queuePackets()
        avatar1.queuePackets()
        return (client, packet)
    # ------------------------------------------------------------------------
    def doBlindPost(self, (client, packet), id, gameId):
        # By now, we should have seen as noted above, a request for the
        # blinds for avatar1 for 100 small blind.  Here we send it.
        avatars = self.service.avatar_collection.get(client.getSerial())
        self.failUnless(len(avatars) ==  1, "Only one avatar should have this serial")
        avatar = avatars[0]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerBlind(serial= avatar.getSerial(),
                                                   game_id = gameId, dead = 0,
                                                   amount = 100))
        return (client, packet)
##############################################################################
class PokerAvatarTestCase(PokerAvatarTestCaseBaseClass):
    # -------------------------------------------------------------------------
    def setUpServer(self):
        PokerAvatarTestCaseBaseClass.setUpServer(self)
    # -------------------------------------------------------------------------
    def ping(self, client):
        client.sendPacket(PacketPing())
        return (client,)
    # -------------------------------------------------------------------------
    def test01_ping(self):
        """ test01_ping """
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.ping)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def explain(self, (client, packet)):
        avatar = self.service.avatars[0]
        self.assertNotEqual(None, avatar.explain)
        serial = 200
        packet_serial = PacketSerial(serial = serial)
        self.assertTrue(avatar.explain.explain(packet_serial))
        self.assertEqual(packet_serial, avatar.explain.forward_packets[0])
        self.assertEqual(serial, avatar.explain.getSerial())
        return (client,)
    # -------------------------------------------------------------------------
    def test02_explain(self):
        """ test02_explain """
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.explain)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def login_again(self, (client, packet)):
        avatar = self.service.avatars[0]
        self.assertNotEqual(None, avatar.explain)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketLogin(name = 'user0', password = 'password1'))
        answer = avatar._packets_queue[0]
        self.assertEqual(PACKET_ERROR, answer.type)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test03_login_again(self):
        """ test03_login """
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.login_again)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def test04_createTable(self):
        """Tests receipt of a table creation packet, followed by creation of a
           table once the avatar is logged in."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        def handleTable((client, packet)):
            avatar = self.service.avatars[0]
            packets = avatar.handlePacket(PacketPokerTable(id = 1, seats  = 5,
                        name = "A Testing Cash Table", variant = "holdem",
                        betting_structure = '2-4-limit', player_timeout =  6,
                        currency_serial = 0))
            self.assertEquals(len(avatar.tables), 1)
            for  (kk, vv) in avatar.tables.items():
                self.assertEquals(vv.game.name, "A Testing Cash Table")
                self.assertEquals(vv.game.max_players, 5)
                self.assertEquals(vv.game.variant, 'holdem')
                self.assertEquals(vv.game.betting_structure, '2-4-limit')
            found = False
            for packet in packets:
                if packet.type == PACKET_POKER_TABLE:
                    found = True
                    self.assertEquals(packet.betting_structure, '2-4-limit')
                    self.assertEquals(packet.variant, 'holdem')
                    self.assertEquals(packet.name, "A Testing Cash Table")
                    self.assertEquals(packet.reason, PacketPokerTable.REASON_TABLE_CREATE)
            self.failUnless(found, "PACKET_POKER_TABLE not present")
            return (client, packet)
        d.addCallback(handleTable)
        return d
    # -------------------------------------------------------------------------
    def test05_testStrInterpolation(self):
        """Tests to make sure the string output of an avatar is accurate"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        def stringAvatar((client, packet)):
            if verbose > 0:
                print "test05_testStrInterpolation" + str(self.service.avatars[0])
            self.assertEquals(str(self.service.avatars[0]),
                              "PokerAvatar serial = 4, name = user0")
            return (client, packet)

        d.addCallback(stringAvatar)
        return d
    # -------------------------------------------------------------------------
    def normalSetRoles(self, (client, packet), myRoles, rolesString):
        avatar = self.service.avatars[0]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSetRole(serial = client.getSerial(), roles = myRoles))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_ROLES:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.roles, rolesString)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test06_setRoles(self):
        """Tests setting of roles"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.normalSetRoles, PacketPokerRoles.PLAY, "PLAY")
        d.addCallback(self.login, 0)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def test06_5_setRolesIsAnErrorWhenDoneAfterLogin(self):
        """Tests setting of roles after a login has already occurred.  Results are
        undefined in this case."""
        # While I was writing full coverage tests here, Loic and I
        # discovered that bad behavior occurs if you set roles after
        # you've logged in.  It must be done before, as is done in the
        # above test.  Loic documented this in
        # pokernetwork/pokerpackets.py as of r3654 about this issue.  This
        # test here looks for the blow-up that we discovered in the
        # undefined behavhior.  Since we've determined the behavior to be
        # undefined, this test might need to be updated later to test for
        # the undefined behavior we see. ;) Perhaps testing for things
        # that aren't defined with this.
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        def setRoles((client, packet)):
            avatar = self.service.avatars[0]
            avatar.handlePacket(PacketPokerSetRole(serial = client.getSerial(), roles = PacketPokerRoles.PLAY))
            try:
                avatar.logout()
            except KeyError, ke:
                self.assertEquals(ke.args[0], client.getSerial())
            # Reset avatar role values back to blank so future errors of
            # this type do not occur.
            avatar.roles = ""
            return (client, packet)
        d.addCallback(setRoles)
        return d
    # -------------------------------------------------------------------------
    def errorSetRoles(self, (client, packet), myRoles, errorCode, errorMessage):
        avatar = self.service.avatars[0]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSetRole(serial = client.getSerial(), roles = myRoles))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_SET_ROLE)
                self.assertEquals(packet.code, errorCode)
                self.assertEquals(packet.message, errorMessage)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test06_7_setUnknownRole(self):
        """Tests setting of a role that is unknown."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        # This error message will need to be fixed if you add additional valid roles
        d.addCallback(self.errorSetRoles, "YOU_HAVE_NEVER_HEARD_OF_THIS_ROLE",
                      PacketPokerSetRole.UNKNOWN_ROLE, "role YOU_HAVE_NEVER_HEARD_OF_THIS_ROLE is unknown (roles = ['PLAY', 'EDIT'])")
        d.addCallback(self.login, 0)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def test06_8_setRoleAfterAnotherUserHas(self):
        """Tests setting of a role that is unknown."""
        def client1():
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.normalSetRoles, PacketPokerRoles.PLAY, "PLAY")
            d.addCallback(self.login, index)
            return d
        def client2(result):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.errorSetRoles, PacketPokerRoles.PLAY,
                           PacketPokerSetRole.NOT_AVAILABLE,
                           "another client already has role %s" % PacketPokerRoles.PLAY)
            d.addCallback(self.login, index)
            return d
        d = client1();
        d.addCallback(client2)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def test07_getImage(self):
        """Tests player getting its image"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        def getImage((client, packet)):
            avatar = self.service.avatars[0]
            avatar.queuePackets()
            avatar.handlePacketLogic(PacketPokerGetPlayerImage(
                    serial = client.getSerial()))
            found = False
            for packet in avatar._packets_queue:
                if packet.type == PACKET_POKER_PLAYER_IMAGE:
                    found = True
                    self.assertEquals(packet.serial, client.getSerial())
                    self.assertEquals(packet.image_type, "image/png")
            self.assertEquals(found, True)
            return (client, packet)
        d.addCallback(getImage)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def test08_joinTable(self):
        """Tests table joining."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def test08_1_joinTable_buy_in_payed(self):
        """Tests table joining with buy_in_payed."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def test08_joinTable_pending_packet(self):
        """Tests table joining, check that packets related to the table and still in the avatar queue are discarded."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        game_id = 2
        def joinTable((client, packet)):
            avatar = self.service.avatars[0]
            avatar.queuePackets()
            avatar.sendPacket(PacketPokerMessage(serial = 111,
                                                 game_id = 222))
            avatar.sendPacket(PacketPokerPlayerLeave(seat = 1,
                                                     serial = 111,
                                                     game_id = game_id))
            avatar.sendPacket(PacketPokerMonitor())
            avatar.handlePacketLogic(PacketPokerTableJoin(serial = client.getSerial(),
                                                          game_id = game_id))
            packets = avatar.resetPacketsQueue()
            self.assertEquals(PACKET_POKER_MESSAGE, packets[0].type)
            self.assertEquals(PACKET_POKER_MONITOR, packets[1].type)
            self.assertEquals(PACKET_POKER_TABLE, packets[2].type)
            self.assertEquals(7, len(packets))
            return (client, packet)
        d.addCallback(joinTable)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def test09_00_seatTable(self):
        """Tests table joining table and sitting down."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def createRankDBTable(self, (client, packet), gameId, rank, percentile):
        table = self.service.getTable(gameId)
        self.service.db.db.query('CREATE TABLE rank (user_serial INT, currency_serial INT, rank INT, percentile TINYINT)')
        self.service.db.db.query('INSERT INTO rank VALUES(%d, %d, %d, %d)' %
                                 (client.getSerial(), table.currency_serial, rank, percentile))
        self.service.setupLadder()
        return (client, packet)
    # ------------------------------------------------------------------------
    def test09_01_seatTableWithRankTable(self):
        """Tests joining table and sitting down, with a stats packet."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.createRankDBTable, 2, rank = 60, percentile = 80)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2, 60, 80)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def forceExplain(self, (client, packet), id):
        avatar = self.service.avatars[id]
        table = self.service.getTable(101)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerExplain(
                serial = client.getSerial(), value = PacketPokerExplain.ALL))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                found = True
                self.assertEquals(packet.other_type, PACKET_POKER_EXPLAIN)
                self.assertEquals(packet.code, 0)
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test10_explainFailsOnceAtTable(self):
        """Tests to be sure setting explain fails when you are already
        connected to to table."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.forceExplain, 0)
        d.addCallback(self.quit)
        return d

    # ------------------------------------------------------------------------
    def test10_explainTwiceIsOk(self):
        """Tests to be sure setting explain twice succeeds if already set."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        def explainAgain((client, packet), id):
            avatar = self.service.avatars[id]
            table = self.service.getTable(101)
            avatar.queuePackets()
            avatar.handlePacketLogic(PacketPokerExplain(
                    serial = client.getSerial(), value = PacketPokerExplain.ALL))
            found = False
            for packet in avatar.resetPacketsQueue():
                if packet.type == PACKET_ACK:
                    found = True
            self.assertEquals(found, True)
            return (client, packet)
        d.addCallback(explainAgain, 0)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def loginWithPasswordTooLong(self, (client, packet), index):
        client.sendPacket(PacketLogin(name = 'user%d' % index, password = 'passwordislongerthan15chars'))
        d = client.packetDeferred(True, PACKET_AUTH_REFUSED)
        def checkbadLoginReturn( (client, packet) ):
            self.assertEquals(packet.type, PACKET_AUTH_REFUSED)
            self.assertEquals(packet.message, "password must be at most 15 characters long")
            self.assertEquals(packet.code, 6)
            self.assertEquals(packet.other_type, PACKET_LOGIN)
            self.assertEquals(client.getSerial(), 0)
        d.addCallback(checkbadLoginReturn)
        return d
    # ------------------------------------------------------------------------
    def test11_loginWithPasswordTooLong(self):
        """Tests to be sure setting explain fails when you are already
        connected to to table."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.loginWithPasswordTooLong, 0)
        return d
    # ------------------------------------------------------------------------
    def test12_buyIntoGame(self):
        """Tests to be sure once sat down, the user can buy into the game"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def statsQuery(self, (client, packet), id):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerStatsQuery(serial = client.getSerial()))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_STATS:
                found = True
                self.assertEquals(packet.length, 19)
                self.assertEquals(packet.players, 3)
                assert(packet.bytesin > 0)
                assert(packet.bytesout > 0)
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test13_stats(self):
        """Test stats request"""
        self.createClients(3)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.statsQuery, 0)
        return d
    # ------------------------------------------------------------------------
    def startHandAndReceiveCards(self, (client, packet), gameId):
        table = self.service.getTable(gameId)

        lang2strings = { 'default' : [ "Dealer: user1 pays 1 blind\n",
                                       "Dealer: user0 pays 2 blind\n",
                                       "Dealer: pre-flop, 2 players\n" ],
                         'en_US' : [ "Dealer: user1 pays 1 blind\n",
                                           "Dealer: user0 pays 2 blind\n",
                                           "Dealer: pre-flop, 2 players\n" ],
                         'fr_FR' : [ "Dealer: user1 paye 1 de blind\n",
                                           "Dealer: user0 paye 2 de blind\n",
                                           "Dealer: pre-flop, 2 joueurs\n" ] }
        avatar = []
        avatar.append(self.service.avatars[0])
        avatar.append(self.service.avatars[1])

        packetList = []
        packetList.append(avatar[0].resetPacketsQueue())
        packetList.append(avatar[1].resetPacketsQueue())

        found = 0
        ignored = 0
        for avid in [0, 1]:
            otherid = avid -1
            if otherid < 0: otherid = 1
            mySerial = avatar[avid].getSerial()
            for packet in packetList[avid]:
                if packet.type == PACKET_POKER_BLIND:
                    found += 1
                    self.assertEquals(packet.game_id, gameId)
                    self.assertEquals(packet.dead, 0)
                    if packet.serial == avatar[1].getSerial():
                        self.assertEquals(packet.amount, 100)
                    elif packet.serial == avatar[0].getSerial():
                        self.assertEquals(packet.amount, 200)
                    else:
                        self.assertEquals("", "Unknown serial: %d" % packet.serial)
                elif packet.type == PACKET_POKER_CHIPS_PLAYER2BET:
                    found += 1
                    self.assertEquals(packet.game_id, gameId)
                    self.assertEquals(packet.cookie, "")
                    if (packet.serial == avatar[0].getSerial()):
                        self.assertEquals(packet.chips, [100, 2])
                    elif (packet.serial == avatar[1].getSerial()):
                        self.assertEquals(packet.chips, [100, 1])
                    else:
                        assert("unknown serial in player2bet packet: %d"
                               % packet.serial)
                elif packet.type == PACKET_POKER_CHIPS:
                    found += 1
                    self.assertEquals(packet.serial, mySerial)
                    self.assertEquals(packet.game_id, gameId)
                    if (avid == 0):
                        self.assertEquals(packet.bet, 200)
                        self.assertEquals(packet.money, 800)
                    else:
                        self.assertEquals(packet.bet, 100)
                        self.assertEquals(packet.money, 900)
                elif packet.type == PACKET_POKER_CHAT:
                    found += 1
                    self.assertEquals(packet.game_id, gameId)
                    self.assertEquals(packet.serial, 0)
                    if (packet.message not in lang2strings[self.avatarLocales[avid]]):
                        self.fail("Unexpected and/or Wrong Language (expected %s) message: %s for avatar %d"
                                  % (self.avatarLocales[avid], packet.message, avid))
                elif packet.type == PACKET_POKER_STATE:
                    found += 1
                    self.assertEquals(packet.game_id, gameId)
                    self.assertEquals(packet.serial, 0)
                    self.assertEquals(packet.string, "pre-flop")
                elif packet.type == PACKET_POKER_BEGIN_ROUND:
                    found += 1
                    self.assertEquals(packet.game_id, gameId)
                    self.assertEquals(packet.serial, 0)
                    self.assertEquals(packet.cookie, "")

                elif packet.type == PACKET_POKER_PLAYER_CARDS:
                    found += 1
                    self.assertEquals(packet.game_id, gameId)
                    if (packet.serial == mySerial):
                        self.assertEquals(len(packet.cards), 2)
                        for c in packet.cards:
                            self.assertTrue(c <  255)
                            self.assertTrue(c >  0)
                    else:
                        self.assertEquals(packet.cards, [255, 255])
                elif packet.type == PACKET_POKER_BET_LIMIT:
                    found += 1
                    self.assertEquals(packet.game_id, gameId)
                    self.assertEquals(packet.serial, 0)
                    self.assertEquals(packet.cookie, "")
                    self.assertEquals(packet.step, 100)
                    if (avid == 0):
                        self.assertEquals(packet.min, 200)
                        self.assertEquals(packet.max, 200)
                        self.assertEquals(packet.allin, 800)
                        self.assertEquals(packet.pot, 300)
                        self.assertEquals(packet.call, 0)
                    else:
                        self.assertEquals(packet.min, 300)
                        self.assertEquals(packet.max, 300)
                        self.assertEquals(packet.allin, 900)
                        self.assertEquals(packet.pot, 500)
                        self.assertEquals(packet.call, 100)
                else:
                    ignored += 1
        self.assertEquals(found, 28)
        self.assertEquals(ignored, 16)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test15_handPlay(self):
        """Test playing an actual hand all the way through"""
        # The sequence of how to get yourself seated in a cash game was
        # taken from the instructions at the top of pokerpackets.py
        # labelled "How to sit at a cash game table ?"
        def client1(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.setLocale, "fr_FR")
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.createRankDBTable, gameId, rank = 50, percentile = 30)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId, 50, 30)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.autoBlindAnte, index, gameId)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        def client2(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit',
                           [{ 'rank' : 50, 'percentile' : 30, 'serial' : 4}] )
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            # Note: this avatar does not autopost, and doBlindPost handles it.
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        gameId = 2
        d = defer.succeed(True)
        d.addCallback(client1, gameId)
        d.addCallback(client2, gameId)
        d.addCallback(self.dealTable, gameId)
        d.addCallback(self.beginHandSetup, gameId)
        d.addCallback(self.doBlindPost, 1, gameId)
        d.addCallback(self.startHandAndReceiveCards, gameId)
        return d
    # -------------------------------------------------------------------------
    def sendExplainTooLate(self, (client, packet)):
        avatar = self.service.avatars[0]
        d = client.packetDeferred(True, PACKET_ERROR)
        def checkError( (client, packet) ):
            self.assertEquals(packet.type, PACKET_ERROR)
            self.assertEquals(packet.other_type, PACKET_POKER_EXPLAIN)
            self.assertEquals(packet.code, 0)
            self.assertEquals(packet.message, "no message")
        d.addCallback(checkError)
        # I believe that turning off packet queue here happens to get some
        # extra coverage in the pokeravatar.sendPacket() function.  Think
        # twice before using the queue in this test.
        avatar.noqueuePackets()
        client.sendPacket(PacketPokerExplain(value = PacketPokerExplain.ALL))
        return  d
    # ------------------------------------------------------------------------
    def forceDbToLocaleValue(self, (client, packet), avid = 0, setTo = '', expect = '', updateCount = 0):
        from pokernetwork.pokerauth import get_auth_instance
        auth = get_auth_instance(self.service.db, self.service.settings)

        avatar = self.service.avatars[avid]
        self.avatarLocales[avid] = expect

        cursor = self.service.db.cursor()
        cursor.execute("insert into users(created, name, password, locale) values(%d, 'user%d', '%s', '%s')"
                       % (seconds(), avid, 'password1', setTo))
        self.assertEquals(cursor.rowcount, 1)
        cursor.close()
        return (client, packet)
    # ------------------------------------------------------------------------
    # RANDOM
    def test15a_handPlay_dbLocalesAndOverridesThereof(self):
        """Test playing an actual hand all the way through when locale changes"""
        def client1(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.forceDbToLocaleValue, avid = 0,
                          setTo = 'fr_FR', expect = "RESET_BY_SET_LOCALE")
            d.addCallback(self.setLocale, "fr_FR")
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.createRankDBTable, gameId, rank = 50, percentile = 30)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId, 50, 30)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.autoBlindAnte, index, gameId)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        def client2(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.forceDbToLocaleValue, avid = 1,
                           setTo = 'fr_FR', expect = "fr_FR")
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit',
                           [{ 'rank' : 50, 'percentile' : 30, 'serial' : 4}] )
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            # Note: this avatar does not autopost, and doBlindPost handles it.
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        gameId = 2
        d = defer.succeed(True)
        d.addCallback(client1, gameId)
        d.addCallback(client2, gameId)
        d.addCallback(self.dealTable, gameId)
        d.addCallback(self.beginHandSetup, gameId)
        d.addCallback(self.doBlindPost, 1, gameId)
        d.addCallback(self.startHandAndReceiveCards, gameId)
        return d

    # -------------------------------------------------------------------------
    def test16_explainTooLate(self):
        """This test covers the case where you attempt to turn on explain
        after being at a table."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.sitTable, 0, 2)
        d.addCallback(self.sendExplainTooLate)
        return d
    # -------------------------------------------------------------------------
    def pingThenExpectPrivilegeFailure(self, (client, packet), sendingPacket, id = 0):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPing())
        avatar.handlePacketLogic(sendingPacket)
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_AUTH_REQUEST:
                found = True
        self.assertEquals(found, True)
        return (client,)
    # -------------------------------------------------------------------------
    def tourneyRegisterUnpriv(self, (client, packet)):
        return self.pingThenExpectPrivilegeFailure((client, packet),
            PacketPokerTourneyRegister(serial = client.getSerial(), game_id = 3))
    # -------------------------------------------------------------------------
    def test17_0_tourneyRegisterUnpriv(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.tourneyRegisterUnpriv)
        return d
    # -------------------------------------------------------------------------
    def seatUnpriv(self, (client, packet)):
        return self.pingThenExpectPrivilegeFailure((client, packet),
                   PacketPokerSeat(serial = client.getSerial(),
                                   seat = 0, game_id = 3))
    # -------------------------------------------------------------------------
    def test17_1_seatUnpriv(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.seatUnpriv)
        return d
    # -------------------------------------------------------------------------
    def userInfoUnpriv(self, (client, packet)):
        return self.pingThenExpectPrivilegeFailure((client, packet),
             PacketPokerGetUserInfo(serial = client.getSerial()))
    # -------------------------------------------------------------------------
    def test17_2_userInfoUnpriv(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.userInfoUnpriv)
        return d
    # -------------------------------------------------------------------------
    def personalInfoUnpriv(self, (client, packet)):
        return self.pingThenExpectPrivilegeFailure((client, packet),
             PacketPokerGetPersonalInfo(serial= client.getSerial()))
    # -------------------------------------------------------------------------
    def test17_3_personalInfoUnpriv(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.personalInfoUnpriv)
        return d
    # -------------------------------------------------------------------------
    def playerInfoUnpriv(self, (client, packet)):
        return self.pingThenExpectPrivilegeFailure((client, packet),
            PacketPokerPlayerInfo(serial= client.getSerial(), name = "The Naked Guy",
                                  outfit = "Naked", url = "http://example.org"))
    # -------------------------------------------------------------------------
    def test17_4_tourneyTourneyRegisterUnpriv(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.playerInfoUnpriv)
        return d
    # -------------------------------------------------------------------------
    def requestsWithWrongSerial(self, (client, packet), avid, gameId):
        avatar = self.service.avatars[avid]
        avatar.queuePackets()
        someoneElseSerial = client.getSerial() + 1
        userByUser = " for user %d by user %d" % (someoneElseSerial, client.getSerial())
        forPlayerByPlayer = " for player %d by player %d" % \
            (someoneElseSerial, client.getSerial())
        playerByPlayer = " player %d by player %d" % \
            (someoneElseSerial, client.getSerial())
        ofPlayerByPlayer = " of player %d by player %d" % \
            (someoneElseSerial, client.getSerial())
        messageStart = ""
        badPacketAttempts = {
            'user_info' : { 'output' :
                          "%sattempt to get user info%s" % (messageStart, userByUser),
                          'packet' :
                              PacketPokerGetUserInfo(serial = someoneElseSerial) },
            'get_personal' : { 'output' :
                              "%sattempt to get personal info%s" % (messageStart, userByUser),
                                'packet' :
                                    PacketPokerGetPersonalInfo(serial = someoneElseSerial),
                               'err_type': PACKET_AUTH_REQUEST },
            'player_info' : { 'output': "%sattempt to set player info%s" \
                                  % (messageStart, forPlayerByPlayer),
                              'packet':
                              PacketPokerPlayerInfo(serial = someoneElseSerial,
                                      name = "YOU_BEEN_CRACKED",
                                      url = "http://example.com/myhack", outfit = "Naked") },
            'player_image' : { 'output' :
                               "%sattempt to set player image%s" \
                                   % (messageStart, forPlayerByPlayer),
                               'packet' :
                                   PacketPokerPlayerImage(serial = someoneElseSerial,
                                      image_type = "crack/tiff", image = "YOU_BEEN_CRACKED") },
            'tourney_create' : { 'output' :
                               "attempt to create tourney%s" \
                                   % forPlayerByPlayer,
                               'packet' :
                                   PacketPokerCreateTourney(serial = someoneElseSerial),
                               'err_type': PACKET_AUTH_REQUEST
                                 },
            'set_personal' : { 'output' :
                               "%sattempt to set player info%s" \
                                   % (messageStart, forPlayerByPlayer),
                               'packet' :
                                   PacketPokerPersonalInfo(serial = someoneElseSerial,
                                        firstname = "YOU_HAVE",
                                        lastname = "BEEN_CRACKED", birthday = "2001-01-01") },
            'cash_in' : { 'output' :
                              "%sattempt to cash in%s" % (messageStart, userByUser),
                          'packet' :
                          PacketPokerCashIn(serial = someoneElseSerial,
                                            name = "YOU_BEEN_CRACKED", value = 1000000,
                                            url = "http://example.com/myhack"),
                          'err_type' : PACKET_POKER_ERROR,
                          'other_type' : PACKET_POKER_CASH_IN },
            'cash_out' : { 'output' :
                               "%sattempt to cash out%s" % (messageStart, userByUser),
                           'packet' :
                           PacketPokerCashOut(serial = someoneElseSerial,
                                             name = "YOU_BEEN_CRACKED", value = 1000000,
                                             url = "http://example.com/myhack"),
                           'err_type' : PACKET_POKER_ERROR,
                           'other_type' : PACKET_POKER_CASH_OUT },
            'tourney_reg': { 'output':
                               "%sattempt to register in tournament %d%s"
                                         % (messageStart, gameId, forPlayerByPlayer),
                             'packet' :
                             PacketPokerTourneyRegister(serial = someoneElseSerial,
                                                        game_id = gameId) },
            'tourney_unreg': { 'output':
                                   "%sattempt to unregister from tournament %d%s"
                                         % (messageStart, gameId, forPlayerByPlayer),
                             'packet' :
                               PacketPokerTourneyUnregister(serial = someoneElseSerial,
                                                            game_id = gameId) },
            'hand_hist' : { 'output':
                                "%sattempt to get history%s" % (messageStart, ofPlayerByPlayer),
                            'packet' :
                                PacketPokerHandHistory(serial = someoneElseSerial,
                                                       serial2name = { someoneElseSerial : "YOU_BEEN_CRACKED" },
                                                       history = 'CRACKED') },
            'ready' : { 'output':
                                "%sattempt to set ready to play%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerReadyToPlay(serial = someoneElseSerial,
                                                       game_id = gameId) },
            'proc' : { 'output':
                           "%sattempt to set processing hand%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerProcessingHand(serial = someoneElseSerial,
                                                          game_id = gameId) },
            'seat' : { 'output':
                           "%sattempt to get seat%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerSeat(serial = someoneElseSerial,
                                                seat = 255, game_id = gameId) },
            'buyin' : { 'output':
                           "%sattempt to bring money%s" % (messageStart, \
                            forPlayerByPlayer),
                            'packet' :
                                PacketPokerBuyIn(serial = someoneElseSerial,
                                                 amount = 1000, game_id = gameId) },
            'table_picker' : { 'output':
                           "%sattempt to run table picker%s" % (messageStart, \
                            forPlayerByPlayer),
                           'err_type' : PACKET_POKER_ERROR,
                            'packet' :
                                PacketPokerTablePicker(serial = someoneElseSerial) },
            'rebuy' : { 'output':
                           "%sattempt to rebuy%s" % (messageStart, forPlayerByPlayer),
                            'packet' :
                                PacketPokerRebuy(serial = someoneElseSerial,
                                                 amount = 1000, game_id = gameId) },
            'chat' : { 'output':
                           "%sattempt chat%s" % (messageStart, forPlayerByPlayer),
                            'packet' :
                                PacketPokerChat(serial = someoneElseSerial, game_id = gameId,
                                    message = "I AM IN YOUR SERIALZ CHATING YOUR POKERZ") },
            'leave' : { 'output':
                           "%sattempt to leave%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerPlayerLeave(serial = someoneElseSerial, game_id = gameId,
                                                       seat = 2) },
            'sit' : { 'output':
                           "%sattempt to sit back%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerSit(serial = someoneElseSerial, game_id = gameId) },
            'sitout' : { 'output':
                           "%sattempt to sit out%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerSitOut(serial = someoneElseSerial, game_id = gameId) },
            'autoblind' : { 'output':
                           "%sattempt to set auto blind/ante%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerAutoBlindAnte(serial = someoneElseSerial, game_id = gameId) },
            'noautoblind' : { 'output':
                           "%sattempt to set auto blind/ante%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerNoautoBlindAnte(serial = someoneElseSerial, game_id = gameId) },
            'muckaccept' : { 'output':
                           "%sattempt to accept muck%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerMuckAccept(serial = someoneElseSerial, game_id = gameId) },
            'muckdeny' : { 'output':
                           "%sattempt to deny muck%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerMuckDeny(serial = someoneElseSerial, game_id = gameId) },
            'setaccount' : { 'output':
                           "password must be at least 5 characters long",
                            'packet' :
                                PacketPokerSetAccount(serial= someoneElseSerial),
                             'err_type' : PACKET_ERROR,
                             'other_type' : PACKET_POKER_SET_ACCOUNT },
            'automuck' : { 'output':
                           "%sattempt to set auto muck%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerAutoMuck(serial = someoneElseSerial, game_id = gameId, info = 0x01) },
            'blind' : { 'output':
                           "%sattempt to pay the blind%s %s" % (messageStart, \
                            ofPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerBlind(serial = someoneElseSerial, game_id = gameId, dead = 0,
                                               amount = 100) },
            'waitblind' : { 'output':
                           "%sattempt to wait for big blind%s %s" % (messageStart, \
                            ofPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerWaitBigBlind(serial = someoneElseSerial, game_id = gameId) },
            'ante' : { 'output':
                           "%sattempt to pay the ante%s %s" % (messageStart, \
                            ofPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerAnte(serial = someoneElseSerial, game_id = gameId,amount = 10) },
            'fold' : { 'output':
                           "%sattempt to fold%s %s" % (messageStart, \
                            playerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerFold(serial = someoneElseSerial, game_id = gameId) },
            'call' : { 'output':
                           "%sattempt to call%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerCall(serial = someoneElseSerial, game_id = gameId) },
            'raise' : { 'output':
                           "%sattempt to raise%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerRaise(serial = someoneElseSerial, game_id = gameId, amount=100) },
# Note that the 'start' packet test that follows is different from all the
# other packets in this group.  The point is that if a game.isEndorNull()
# is true at line 411 of pokeravatar.py, the message sent back --
# regardless of the serial -- assumes that the player with the right
# serial has requested it but cannot because a game is already going.  I
# am not sure this behavior by pokeravatar.handlePacketLogic() is entirely
# correct, but I am leaving, and have instead rewritten this test to look
# for the response given by handlePacketLogic when isEndorNull() is true
# rather than the "someoneElse" response.

#  The above no longer applies.  Loic fixed the bug today in r4046 that I
#  am describing above, and I have adjusted the packet test below to work
#  correctly now.  You will note that it now looks like the rest of the
#  tests in here (ala "not the owner") --bkuhn, 2008-07-05

            'start' : { 'output':
                           "%splayer %d %s" % (messageStart, client.getSerial(), \
                            "tried to start a new game but is not the owner of the table"),
                            'packet' : PacketPokerStart(serial = someoneElseSerial,
                                                        game_id = gameId),
                        },
# This used to generate an error packet but does not now, except
#  table.owner apperas to be zero in this setup so ti falls through to the
#  bootm else block (see details in pokeravatar.handlePacketLogic()
#                        'err_type' : PACKET_POKER_START },
            'check' : { 'output':
                           "%sattempt to check%s %s" % (messageStart, \
                            forPlayerByPlayer, "that is not the owner of the game"),
                            'packet' :
                                PacketPokerCheck(serial = someoneElseSerial, game_id = gameId) }
            }
        # Next, we loop through all the serial-related bad pack list,
        # attempting to handle each one.  Setup stdout to go to a string
        # so that we can test if they generate the right printed output.
        # Also, catch any error packets for those we expect to receive.
        for (key, info) in badPacketAttempts.iteritems():
            avatar.resetPacketsQueue()
            avatar.queuePackets()
            silence_all_messages()
            clear_all_messages()
            avatar.handlePacketLogic(info['packet'])
            self.assertEqual(search_output(info['output']), True, info['output'])
            restore_all_messages()

            found = False
            for packet in avatar.resetPacketsQueue():
                found = True
                self.assertEquals(packet.type, info['err_type'])
                if info.has_key('other_type'):
                    self.assertEquals(info['other_type'], packet.other_type)
            self.assertEquals(found, info.has_key('err_type'))
        return (client, packet)
    # -------------------------------------------------------------------------
    def test18_badAttempts(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.sitTable, 0, 2)
        d.addCallback(self.requestsWithWrongSerial, 0, 2)
        return d
    # -------------------------------------------------------------------------
    def badBuyIn(self, (client, packet), id, gameId, myAmount):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        seatNumber = id + 1
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerBuyIn(serial = client.getSerial(),
                                               amount = myAmount, game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_ERROR:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.other_type, PACKET_POKER_BUY_IN)
        self.assertEquals(found, 1)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test19_badBuyIn(self):
        """Test to cover the condition where the buyIn fails"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 1, 'Table1', '100-200-no-limit')
        d.addCallback(self.seatTable, 0, 1)

        # Note: this only "works" (i.e., fails properly) if you have a
        # currency serial that is valid, because of this line in
        # pokerservice.py's buyInPlayer
        #     if not currency_serial: return amount
        d.addCallback(self.badBuyIn, 0, 1, 1)
        return d
    # ------------------------------------------------------------------------
    def noAutoBlindAnte(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerNoautoBlindAnte(serial= client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_NOAUTO_BLIND_ANTE:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test20_turningOffAutoBlind(self):
        """Test to cover a player turning off their autoBlindAnte Setting"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.noAutoBlindAnte, 0, 2)
        return d
    # -------------------------------------------------------------------------
    def test21_sitOut(self):
        """Test playing an actual hand all the way through"""
        # The sequence of how to get yourself seated in a cash game was
        # taken from the instructions at the top of pokerpackets.py
        # labelled "How to sit at a cash game table ?"
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.sitTable, 0, 2)
        d.addCallback(self.readyToPlay, 0, 2)
        d.addCallback(self.sitOut, 0, 2)
        return d
    # -------------------------------------------------------------------------
    def sitOutClosedGame(self, (client, packet), id, gameId ):
        table = self.service.getTable(gameId)
        table.game.close()

        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSitOut(serial= client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_AUTO_FOLD:
                self.assertEquals(False, table.game.getPlayer(avatar.getSerial()).sit_out)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # -------------------------------------------------------------------------
    def joinTableAndCheckPokerSitAndAutoFoldAreSend(self, (client, packet), id, gameId, name, struct):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableJoin(serial = client.getSerial(),
                                                      game_id = gameId))
        founds = [packet.type for packet in avatar.resetPacketsQueue()
                  if packet.type == PACKET_POKER_SIT
                  or packet.type == PACKET_POKER_AUTO_FOLD]
        self.assertEquals(founds[0], PACKET_POKER_SIT)
        self.assertEquals(founds[1], PACKET_POKER_AUTO_FOLD)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test22_sitOutClosedGame(self):
        """Test playing an actual hand all the way through"""
        # The sequence of how to get yourself seated in a cash game was
        # taken from the instructions at the top of pokerpackets.py
        # labelled "How to sit at a cash game table ?"
        def client1(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.setLocale, "fr_FR")
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.createRankDBTable, gameId, rank = 50, percentile = 30)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId, 50, 30)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.autoBlindAnte, index, gameId)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            d.addCallback(self.sitOutClosedGame, index, gameId)
            return d
        def client2(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTableAndCheckPokerSitAndAutoFoldAreSend, index, gameId, 'Table2', '2-4-limit')
        gameId = 2
        d = defer.succeed(True)
        d.addCallback(client1, gameId)
        d.addCallback(client2, gameId)
        return d
    # ------------------------------------------------------------------------
    def doBlindPostAndHaveOtherGuyWaitForCardsAndQuit(self, (client, packet), id, gameId):
        # By now, we should have seen as noted above, a request for the
        # blinds for avatar1 for 100 small blind.  Here we send it.
        otherAvatar = self.service.avatars[0]
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerBlind(serial= avatar.getSerial(),
                                                   game_id = gameId, dead = 0,
                                                   amount = 100))
        otherAvatar.removePlayer(table, otherAvatar.getSerial())
        return (client, packet)
    # ------------------------------------------------------------------------
    def test23_quitPlayerInHand(self):
        """Test when a player quits in the middle of a hand."""
        # The sequence of how to get yourself seated in a cash game was
        # taken from the instructions at the top of pokerpackets.py
        # labelled "How to sit at a cash game table ?"
        def client(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.autoBlindAnte, index, gameId)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        gameId = 2
        d = defer.succeed(True)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(self.dealTable, gameId)
        d.addCallback(self.beginHandSetup, gameId, True)
        d.addCallback(self.doBlindPostAndHaveOtherGuyWaitForCardsAndQuit, 1, gameId)
        return d

    # ------------------------------------------------------------------------
    def getPersonalInfo(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerGetPersonalInfo(serial= client.getSerial()))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PERSONAL_INFO:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.name, "user%d" % id)
                self.assertEquals(packet.password, "")
                self.assertEquals(packet.rating, 1000)
                self.assertEquals(packet.affiliate, 0)
                self.assertEquals(packet.addr_street, "")
                self.assertEquals(packet.firstname, "Joe")
                self.assertEquals(packet.lastname, "Schmoe")
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def setPersonalInfo(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerPersonalInfo(serial= client.getSerial(),
                                                         firstname = "Joe",
                                                         lastname = "Schmoe"))
        return (client, packet)
    # ------------------------------------------------------------------------
    def test24_personalInfo(self):
        """Test lookup of personal information."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.setPersonalInfo, 0)
        d.addCallback(self.getPersonalInfo, 0)
        return d
    # ------------------------------------------------------------------------
    def listHands(self, (client, packet), id, mySerial):
        avatar = self.service.avatars[id]
        if mySerial == -1: mySerial = client.getSerial()
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerHandSelect(serial= mySerial, count = 5, start = 0))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_HAND_LIST:
                self.assertEquals(packet.count, 5)
                self.assertEquals(packet.hands, [])
                self.assertEquals(packet.total, 0)
                found = True
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerHandSelect(serial= None, count = 5, start = 0))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_HAND_LIST:
                self.assertEquals(packet.count, 5)
                self.assertEquals(packet.hands, [])
                self.assertEquals(packet.total, 0)
                found = True
        self.assertEquals(found, True)

        from _mysql_exceptions import OperationalError
        try:
            avatar.handlePacketLogic(PacketPokerHandSelect(serial= mySerial, count = 5, start = 0,
                                                           string = "Testing"))
        except OperationalError, oe:
            self.assertEquals(oe[0],1054)
            self.assertEquals(oe[1], "Unknown column 'Testing' in 'where clause'")

        return (client, packet)
    # ------------------------------------------------------------------------
    def test25_listHands(self):
        """Test for hand listing."""
        # It might be better to improve this test so that a few hands have
        # actually been played and therfore an actual hand list is available.
        self.createClients(3)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.listHands, 1, -1)
        return d
    # ------------------------------------------------------------------------
    def listTables(self, (client, packet), id):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableSelect(string = ""))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_TABLE_LIST:
                self.assertEquals(packet.players, 0)
                self.assertEquals(packet.tables, 4)
                count = 0
                for p in packet.packets:
                    count += 1
                    self.assertEquals(p.reason, PacketPokerTable.REASON_TABLE_LIST)
                    self.assertEquals(p.average_pot,  0)
                    self.assertEquals(p.hands_per_hour, 0)
                    self.assertEquals(p.percent_flop, 0)
                    self.assertEquals(p.players, 0)
                    self.assertEquals(p.observers, 0)
                    self.assertEquals(p.waiting, 0)
                    self.assertEquals(p.skin,  "default")
                    self.assertEquals(p.variant, "holdem")
                    if (p.id == 1):
                        self.assertEquals(p.name, "Table1")
                        self.assertEquals(p.betting_structure, "100-200-no-limit")
                        self.assertEquals(p.seats, 10)
                        self.assertEquals(p.player_timeout, 60)
                        self.assertEquals(p.currency_serial, 1)
                    elif (p.id == 2):
                        self.assertEquals(p.name, "Table2")
                        self.assertEquals(p.betting_structure, "2-4-limit")
                        self.assertEquals(p.player_timeout, 60)
                        self.assertEquals(p.muck_timeout, 5)
                        self.assertEquals(p.currency_serial, 0)
                    elif (p.id == 3):
                        self.assertEquals(p.name, "Table3")
                        self.assertEquals(p.betting_structure, "test18pokerclient")
                        self.assertEquals(p.player_timeout, 600)
                        self.assertEquals(p.muck_timeout, 600)
                        self.assertEquals(p.seats, 10)
                        self.assertEquals(p.currency_serial, 1)
                self.assertEquals(count, packet.tables)
                found = True
        self.assertEquals(found, True)

        return (client, packet)
    # ------------------------------------------------------------------------
    def test26_listTables(self):
        """Test for table listing."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.listTables, 0)
        return d
    # ------------------------------------------------------------------------
    def getPlayerInfoError(self, (client, packet), id):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerGetPlayerInfo())
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.code, PacketPokerGetPlayerInfo.NOT_LOGGED)
                self.assertEquals(packet.message, "Not logged in")
                self.assertEquals(packet.other_type, PACKET_POKER_GET_PLAYER_INFO)
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test27_playerInfoNotLoggedIn(self):
        """Test for getting player info before login has occurred."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.getPlayerInfoError, 0)
        return d
    # ------------------------------------------------------------------------
    def setPokerPlayerInfo(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerPlayerInfo(serial= client.getSerial(),
                                                       name = "The Naked Guy",
                                                       outfit = "Naked",
                                                       url = "http://example.org"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_INFO:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.name, "The Naked Guy")
                self.assertEquals(packet.outfit, "Naked")
                self.assertEquals(packet.url, "http://example.org")
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test28_setPokerPlayerInfo(self):
        """Test for setting poker player info."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.setPokerPlayerInfo, 0)
        return d
    # ------------------------------------------------------------------------
    def errorSetPokerPlayerInfo(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        def forceFalse(player_info):
            return False
        originalFunction = avatar.service.setPlayerInfo
        avatar.service.setPlayerInfo = forceFalse

        avatar.handlePacketLogic(PacketPokerPlayerInfo(serial= client.getSerial(),
                                                       name = "The Naked Guy",
                                                       outfit = "Naked",
                                                       url = "http://example.org"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_PLAYER_INFO)
                self.assertEquals(packet.code, PACKET_POKER_PLAYER_INFO)
                self.assertEquals(packet.message, "Failed to save set player information")
                found = True
        self.assertEquals(found, True)
        avatar.service.setPlayerInfo = originalFunction
        return (client, packet)
    # ------------------------------------------------------------------------
    def test29_errorSetPokerPlayerInfo(self):
        """Test for errors when setting poker player info."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.errorSetPokerPlayerInfo, 0)
        return d
    # ------------------------------------------------------------------------
    def setPokerPlayerImage(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerPlayerImage(serial= client.getSerial(),
                                                        image = "naked.png",
                                                        image_type = "image/gif"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ACK:
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def errorSetPokerPlayerImage(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        def forceFalse(player_info):
            return False
        originalFunction = avatar.service.setPlayerImage
        avatar.service.setPlayerImage = forceFalse
        avatar.handlePacketLogic(PacketPokerPlayerImage(serial= client.getSerial(),
                                                        image = "naked.png",
                                                        image_type = "image/gif"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_PLAYER_IMAGE)
                self.assertEquals(packet.code, PACKET_POKER_PLAYER_IMAGE)
                self.assertEquals(packet.message, "Failed to save set player image")
                found = True
        self.assertEquals(found, True)
        avatar.service.setPlayerImage = originalFunction
        return (client, packet)
    # ------------------------------------------------------------------------
    def test30_setPlayerImage(self):
        """Test for setting the player image."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.setPokerPlayerImage, 0)
        return d
    # ------------------------------------------------------------------------
    def test31_errorSetPlayerImage(self):
        """Test for setting the player image."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.errorSetPokerPlayerImage, 0)
        return d
    # ------------------------------------------------------------------------
    calledCashIn = False
    def cashIn(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        PokerAvatarTestCase.calledCashIn = False
        def fakeCashIn(packet):
            PokerAvatarTestCase.calledCashIn = True
        self.originalFunction = avatar.service.cashIn
        avatar.service.cashIn = fakeCashIn
        avatar.handlePacketLogic(PacketPokerCashIn(serial= client.getSerial(),
                                                   currency = "http://fake",
                                                   bserial = 0, value = 10))
        return (client, packet)
    # ------------------------------------------------------------------------
    def checkCashIn(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        self.assertEquals(PokerAvatarTestCase.calledCashIn, True)
        avatar.service.cashIn = self.originalFunction
    # ------------------------------------------------------------------------
    def test32_cashIn(self):
        """Test for doing a cash in operation."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.cashIn, 0)
        d.addCallback(self.checkCashIn, 0)
        return d
    # ------------------------------------------------------------------------
    def cashQuery(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerCashQuery(application_data =
                                                      "THIS_WILL_NOT_BE_FOUND_AS_VALID_AT_ALL"))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_CASH_QUERY)
                self.assertEquals(packet.code, PacketPokerCashQuery.DOES_NOT_EXIST)
                self.assertEquals(packet.message, "No record with application_data = 'THIS_WILL_NOT_BE_FOUND_AS_VALID_AT_ALL'")
                found = True
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test33_cashQuery(self):
        """Test for a cash query operation; it's designed to fail and get a packet error."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.cashQuery, 0)
        return d
    # ------------------------------------------------------------------------
    def setPokerAccount(self, (client, packet), id, packetType ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        if packetType == PACKET_POKER_CREATE_ACCOUNT:
            avatar.handlePacketLogic(PacketPokerCreateAccount(serial= client.getSerial()))
        else:
            avatar.handlePacketLogic(PacketPokerSetAccount(serial= client.getSerial()))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, packetType)
                self.assertEquals(packet.code, PacketPokerSetAccount.PASSWORD_TOO_SHORT)
                self.assertEquals(packet.message, "password must be at least 5 characters long")
        return (client, packet)
    # ------------------------------------------------------------------------
    def test34_setPokerAccount(self):
        """Test sending the set poker account packet."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.setPokerAccount, 0, PACKET_POKER_CREATE_ACCOUNT)
        d.addCallback(self.setPokerAccount, 0, PACKET_POKER_SET_ACCOUNT)
        return d
    # ------------------------------------------------------------------------
    def tourneySelect(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTourneySelect(string = ""))
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_TOURNEY_LIST:
                count = 0
                for p in packet.packets:
                    self.assert_(hasattr(p, 'schedule_serial'))
                    assert p.name.find("sitngo") >= 0 or  p.name.find("egular")
                    assert p.name.find("registering") >= 0 or  p.name.find("announced")
                    count += 1
                self.assertEquals(count, 2)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test35_tourneys(self):
        """Test sending the set poker account packet."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneySelect, 0)
        return d
    # ------------------------------------------------------------------------
    calledCashOut = False
    def cashOut(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        PokerAvatarTestCase.calledCashOut = False
        def fakeCashOut(packet):
            PokerAvatarTestCase.calledCashOut = True
        self.originalFunction = avatar.service.cashOut
        avatar.service.cashOut = fakeCashOut
        avatar.handlePacketLogic(PacketPokerCashOut(serial= client.getSerial(),
                                                   currency = "http://fake",
                                                   bserial = 0, value = 10))
        return (client, packet)
    # ------------------------------------------------------------------------
    def checkCashOut(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        self.assertEquals(PokerAvatarTestCase.calledCashOut, True)
        avatar.service.cashOut = self.originalFunction
    # ------------------------------------------------------------------------
    def test36_cashOut(self):
        """Test for doing a cash out operation."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.cashOut, 0)
        return d
    # ------------------------------------------------------------------------
    calledCashOutCommit = False
    def cashOutCommit(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        PokerAvatarTestCase.calledCashOutCommit = False
        def fakeCashOutCommit(packet):
            PokerAvatarTestCase.calledCashOutCommit = True
        self.originalFunction = avatar.service.cashOutCommit
        avatar.service.cashOutCommit = fakeCashOutCommit
        avatar.handlePacketLogic(PacketPokerCashOutCommit(transaction_id = 0))
        return (client, packet)
    # ------------------------------------------------------------------------
    def checkCashOutCommit(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        self.assertEquals(PokerAvatarTestCase.calledCashOutCommit, True)
        avatar.service.cashOutCommit = self.originalFunction
    # ------------------------------------------------------------------------
    def test37_cashOutCommit(self):
        """Test for doing a cash out commit operation."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.cashOutCommit, 0)
        return d
    # ------------------------------------------------------------------------
    def tourneyPlayerList(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTourneyRequestPlayersList(game_id = gameId))
        for packet in avatar.resetPacketsQueue():
            count = 0
            if packet.type == PACKET_POKER_TOURNEY_PLAYERS_LIST:
                self.assertEquals(packet.serial, 1)
                self.assertEquals(packet.game_id, 0)
                count += 1
            self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test38_tourneyPlayerList(self):
        """Test for listing players in a tourney."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneyPlayerList, 0, 1)
        return d
    # ------------------------------------------------------------------------
    def listPlayers(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableRequestPlayersList(serial = client.getSerial(),
                                                                    game_id = gameId))
        for packet in avatar.resetPacketsQueue():
            count = 0
            if packet.type == PACKET_POKER_PLAYERS_LIST:
                self.assertEquals(packet.players, [('user0', 1000, 0), ('user1', 1000, 0)])
                count += 1
            self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test39_tablePlayerList(self):
        """Test for listing players in at a table."""
        def client(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.autoBlindAnte, index, gameId)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        gameId = 2
        d = defer.succeed(True)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(self.listPlayers, 1, gameId)
        return d
    # ------------------------------------------------------------------------
    def tourneyRegister(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTourneyRegister(serial = client.getSerial(),
                                                            game_id = 1101134))
        for packet in avatar.resetPacketsQueue():
            count = 0
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_TOURNEY_REGISTER)
                self.assertEquals(packet.code, PacketPokerTourneyRegister.DOES_NOT_EXIST)
                count += 1
            self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test40_tourneyRegister(self):
        """Test for registering a players in a tourney."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneyRegister, 0)
        return d
    # ------------------------------------------------------------------------
    def tourneyUnregister(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTourneyUnregister(serial = client.getSerial(),
                                                            game_id = 1101134))
        count = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ERROR:
                self.assertEquals(packet.other_type, PACKET_POKER_TOURNEY_UNREGISTER)
                self.assertEquals(packet.code, PacketPokerTourneyUnregister.DOES_NOT_EXIST)
                count += 1
        self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test41_tourneyUnregister(self):
        """Test for unregistering players from a tourney."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneyUnregister, 0)
        return d
    # ------------------------------------------------------------------------
    def handSelectAll(self, (client, packet), id, whereStr = "" ):
        avatar = self.service.avatars[id]
        # Need more privs to do a HAND_SELECT_ALL
        oldPriv = avatar.user.privilege
        avatar.user.privilege = 32767
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerHandSelectAll(serial = client.getSerial(),
                                                          string = whereStr))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_HAND_LIST:
#             Unclear what this should be....
#                self.assertEquals(packet.count, ????)
                self.assertEquals(packet.start, 0)
                self.assertEquals(packet.hands, [])
                self.assertEquals(packet.total, 0)
                found = True
        self.assertEquals(found, True)
        avatar.user.privilege = oldPriv
        return (client, packet)
    # ------------------------------------------------------------------------
    def handSelectAllMissingPrivsMakesItFail(self, (client, packet), id):
        return self.pingThenExpectPrivilegeFailure((client, packet),
             PacketPokerHandSelectAll(serial = client.getSerial(),
                                      string = ""), id)
    # ------------------------------------------------------------------------
    def test42_handSelectAll(self):
        """Test sending hand select all packet."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.handSelectAll, 0)
        return d
    # ------------------------------------------------------------------------
    def test42_0_handSelectAll_MissingPrivsCauseFail(self):
        """Test failing hand select packet because it has only regular
        privs, no admin privs."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.handSelectAllMissingPrivsMakesItFail, 0)
        return d
    # ------------------------------------------------------------------------
    def handHistory(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerHandHistory(game_id = gameId, serial = client.getSerial() ))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_ERROR:
                found = True
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, 2)
                self.assertEquals(packet.message, "Hand %d was not found in history of player %d"
                                  % (packet.game_id, client.getSerial()))
                self.assertEquals(packet.other_type, PACKET_POKER_HAND_HISTORY)
                self.assertEquals(packet.code, PacketPokerHandHistory.NOT_FOUND)
        self.assertEquals(found, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test43_handHistory(self):
        """Test for hand history packet."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.sitTable, 0, 2)
        d.addCallback(self.readyToPlay, 0, 2)
        d.addCallback(self.handHistory, 0, 2)
        return d
    # ------------------------------------------------------------------------
    def loseConnection(self, (client, packet), gameId):
        table = self.service.getTable(gameId)
        avatar0 = self.service.avatars[0]
        avatar0.logout()
        table.observers.append(avatar0)
        avatar0.login((4, "user0", 32767))
        avatar0.queuePackets()
        count = 0
        for packet in avatar0.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_CARDS:
                count += 1
                self.assertEquals(packet.game_id, gameId)
            elif packet.type == PACKET_POKER_PLAYER_SELF:
                count += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, 4)
            elif packet.type == PACKET_POKER_BLIND_REQUEST:
                count += 1
                self.assertEquals(packet.serial, 4)
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.amount, 200)
                self.assertEquals(packet.dead, 0)
                self.assertEquals(packet.state, "big")
        self.assertEquals(count >= 3, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test44_possibleObserverLoggedIn(self):
        def client1(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        def client2(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.autoBlindAnte, index, gameId)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        gameId = 2
        d = defer.succeed(True)
        d.addCallback(client1, gameId)
        d.addCallback(client2, gameId)
        d.addCallback(self.dealTable, gameId)
        d.addCallback(self.loseConnection, gameId)
        return d
    # ------------------------------------------------------------------------
    def loseConnectionAnte(self, (client, packet), gameId):
        table = self.service.getTable(gameId)
        avatar0 = self.service.avatars[0]
        avatar0.logout()
        table.observers.append(avatar0)
        avatar0.login((4, "user0", 32767))
        avatar0.queuePackets()
        count = 0
        for packet in avatar0.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_CARDS:
                count += 1
                self.assertEquals(packet.game_id, gameId)
            elif packet.type == PACKET_POKER_PLAYER_SELF:
                count += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, 4)
            elif packet.type == PACKET_POKER_ANTE_REQUEST:
                count += 1
                self.assertEquals(packet.serial, 4)
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.amount, 10)
        self.assertEquals(count >= 3, True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test45_possibleObserverLoggedInWithAnte(self):
        def client1(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table4', 'ante-1-2-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        def client2(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.sendExplain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table4', 'ante-1-2-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.autoBlindAnte, index, gameId)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        gameId = 4
        d = defer.succeed(True)
        d.addCallback(client1, gameId)
        d.addCallback(client2, gameId)
        d.addCallback(self.dealTable, gameId)
        d.addCallback(self.loseConnectionAnte, gameId)
        return d
    # ------------------------------------------------------------------------
    def processingHand(self, (client, packet), id, gameId, isBugous=False ):
        avatar = self.service.avatars[id]

        avatar.bugous_processing_hand = isBugous

        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerProcessingHand(serial =
                                                           client.getSerial(),
                                                            game_id = gameId))
        count = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_ERROR:
                count += 1
                self.assertEquals(isBugous, True)
                self.assertEquals(packet.other_type, PACKET_POKER_PROCESSING_HAND)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, 4)
                self.assertEquals(packet.message, "no message")
                self.assertEquals(packet.code, 0)
            if packet.type == PACKET_ACK:
                count += 1
                self.assertEquals(isBugous, False)
        self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test46_processingHand(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 4, 'Table4', 'ante-1-2-limit')
        d.addCallback(self.seatTable, 0, 4)
        d.addCallback(self.buyInTable, 0, 4, 1000)
        d.addCallback(self.sitTable, 0, 4)
        d.addCallback(self.processingHand, 0, 4)
        d.addCallback(self.processingHand, 0, 4, True)
        return d
    # ------------------------------------------------------------------------
    def variousStartPackets(self, (client, packet), id, gameId ):
        # The tests in here changed with r4046, which corrected a bug in
        # the way PACKET_POKER_START was handled.
        avatar = self.service.avatars[id]

        avatar.queuePackets()
        silence_all_messages()
        clear_all_messages()
        avatar.handlePacketLogic(PacketPokerStart(serial = client.getSerial(),
                                                            game_id = gameId))
        restore_all_messages()
        self.assertEqual(search_output("tried to start a new game but is not the owner of the table"), True)
        # Coverage for when the server is shutting down

        avatar.service.shutting_down = True

        avatar.queuePackets()
        silence_all_messages()
        clear_all_messages()
        avatar.handlePacketLogic(PacketPokerStart(serial = client.getSerial(),
                                                            game_id = gameId))
        self.assertEqual(search_output("Not autodealing because server is shutting down"),
                         True)

        # Coverage for the table owner is not the player, but it would
        # otherwise be a valid start
        avatar.service.shutting_down = False

        table = self.service.getTable(gameId)
        table.owner = 32767  # Something that should never actually be one of my serials

        avatar.resetPacketsQueue()
        avatar.queuePackets()
        silence_all_messages()
        clear_all_messages()
        avatar.handlePacketLogic(PacketPokerStart(serial = client.getSerial(),
                                                             game_id = gameId))
        self.assertEquals(search_output('tried to start a new game but is not the owner of the table'), True)

        # Coverage for the table owner is the player
        avatar.service.shutting_down = False

        table = self.service.getTable(gameId)
        table.owner = client.getSerial()

        avatar.resetPacketsQueue()
        avatar.queuePackets()
        silence_all_messages()
        clear_all_messages()
        avatar.handlePacketLogic(PacketPokerStart(serial = client.getSerial(),
                                                             game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            self.assertEquals(packet.game_id, gameId)
            if packet.type == PACKET_POKER_PLAYER_CHIPS:
                 #expect 2
                found += 1
            elif packet.type == PACKET_POKER_DEALER:
                 #expect 1
                found += 1
                self.assertEquals(packet.previous_dealer, -1)
                self.assertEquals(packet.dealer, 1)
            elif packet.type == PACKET_POKER_IN_GAME:
                 #expect 1
                found += 1
            elif packet.type == PACKET_POKER_POSITION:
                # expect 4
                found += 1
            elif packet.type == PACKET_POKER_BLIND:
                 #expect 2
                found += 1
            elif packet.type == PACKET_POKER_PLAYER_CARDS:
                 #expect 2
                found += 1
            elif packet.type == PACKET_POKER_STATE:
                 #expect 1
                found += 1
            elif packet.type == PACKET_POKER_START:
                 #expect 1
                found += 1
            else:
                self.fail("Unexpected packet" + packet.__str__())

        self.assertEquals(found, 14)
        # This game start should "succeed" (but later fail due to game running) because
        #  the owner of the table is our player.
        self.assertEqual(search_output("tried to start a new game while in a game"), False)
        self.assertEqual(search_output("No autodeal"), True)

        # Following is coverage for when someone else owns the table

        avatar.service.shutting_down = False

        table = self.service.getTable(gameId)
        table.owner = client.getSerial() - 3
        avatar.queuePackets()
        silence_all_messages()
        clear_all_messages()
        avatar.handlePacketLogic(PacketPokerStart(serial = client.getSerial(),
                                                            game_id = gameId))
        self.assertEqual(search_output("tried to start a new game while in game "), True)
        self.assertEqual(search_output("No autodeal"), True)
    # ------------------------------------------------------------------------
    def test47_startPackets(self):
        def client(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.setupCallbackChain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.autoBlindAnte, index, gameId)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        gameId = 2
        table = self.service.getTable(gameId)
        table.autodeal = False
        d = defer.succeed(True)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(self.variousStartPackets, 1, gameId)
        return d
    # ------------------------------------------------------------------------
    def badSeatTable(self, (client, packet), id, gameId):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        seatNumber = id + 1
        def forceFalse(client, serial, seat):
            return False
        originalFunction = table.seatPlayer
        table.seatPlayer = forceFalse

        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSeat(serial = client.getSerial(),
                                                seat = seatNumber, game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_SEAT:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.seat, -1)
                self.assertEquals(packet.serial, client.getSerial())
        self.assertEquals(found, 1)
        table.seatPlayer = originalFunction
        return (client, packet)
    # ------------------------------------------------------------------------
    def test48_seatPackets(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.badSeatTable, 0, 2)
        return d
    # ------------------------------------------------------------------------
    def seatTableNoRole(self, (client, packet), id, gameId):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        seatNumber = id + 1

        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerSeat(serial = client.getSerial(),
                                                seat = seatNumber, game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_ERROR:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.other_type, PACKET_POKER_SEAT)
                self.assertEquals(packet.code, PacketPokerSeat.ROLE_PLAY)
        self.assertEquals(found, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test48_1_seatPacketNoRole(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTableNoRole, 0, 2)
        return d
    # ------------------------------------------------------------------------
    def badBuyRebuyRequest(self, (client, packet), id, gameId):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        def forceFalse(self, amount):
            return False
        originalRebuy = table.rebuyPlayerRequest
        originalBuyin = table.buyInPlayer
        table.rebuyPlayerRequest = forceFalse
        table.buyInPlayer = forceFalse
        for sendPack in (PacketPokerBuyIn(serial = client.getSerial(),
                                          amount = 10000, game_id = gameId),
                         PacketPokerRebuy(serial = client.getSerial(),
                                      amount = 10000, game_id = gameId)):
            avatar.queuePackets()
            avatar.handlePacketLogic(sendPack)
            found = 0
            for packet in avatar.resetPacketsQueue():
                found += 1
                if packet.type == PACKET_POKER_ERROR:
                    self.assertEquals(packet.other_type, sendPack.type)
                    self.assertEquals(packet.game_id, gameId)
                    self.assertEquals(packet.serial, client.getSerial())
            self.assertEquals(found, 1)

        table.rebuyPlayerRequest = originalRebuy
        table.buyInPlayer = originalBuyin
        return (client, packet)
    # ------------------------------------------------------------------------
    def test49_badRebuy(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.badBuyRebuyRequest, 0, 2)
        d.addCallback(self.autoBlindAnte, 0, 2)
        return d
    # ------------------------------------------------------------------------
    def chatItUp(self, (client, packet), id, gameId, myMessage):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerChat(serial = client.getSerial(),
                                                 game_id = gameId,
                                                 message = myMessage))
        found = 0
        for packet in avatar.resetPacketsQueue():
            found += 1
            if packet.type == PACKET_POKER_CHAT:
                self.assertEquals(packet.game_id, gameId)
                self.assertEqual(packet.message.find(myMessage) >= 0, True)
        self.assertEquals(found, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test50_chat(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.sitTable, 0, 2)
        d.addCallback(self.readyToPlay, 0, 2)
        d.addCallback(self.chatItUp, 0, 2, "I drink your milkshake!")
        return d
    # ------------------------------------------------------------------------
    def leaveTable(self, (client, packet), id, gameId):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerPlayerLeave(game_id = gameId,
                                                    serial = client.getSerial()))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_LEAVE:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEqual(packet.seat, 1)
        self.assertEquals(found, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test51_doLeave(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.sitTable, 0, 2)
        d.addCallback(self.readyToPlay, 0, 2)
        d.addCallback(self.leaveTable, 0, 2)
        return d
    # ------------------------------------------------------------------------
    # This test handles various requests that expect some sort of string
    # output as a return (and possibly a single packet).  This is similar to the
    # requestsWithWrongSerial() above, but in this case, we're using the
    # right serial and the game is just in the wrong state or somesuch.
    def variousPacketsWithStringOrSinglePacketReturn(self, (client, packet), avid, gameId):
        avatar = self.service.avatars[avid]
        packetTests = {
            'muck_accept' : { 'output' :
                          "[PokerGame %d] ERROR: muck: game state muck expected, found null" % gameId,
                          'packet' :
                                  PacketPokerMuckAccept(game_id = gameId,
                                                        serial = client.getSerial()) },
            'muck_deny' : { 'output' :
                          "[PokerGame %d] ERROR: muck: game state muck expected, found null" % gameId,
                          'packet' :
                                  PacketPokerMuckDeny(game_id = gameId,
                                                        serial = client.getSerial()) },
            'wait_blind' : { 'output' :
                          "[PokerGame %d] ERROR: player %d cannot pay blind while in state null" % (gameId, client.getSerial()),
                          'packet' :
                                  PacketPokerWaitBigBlind(game_id = gameId,
                                                        serial = client.getSerial()) },
            'ante' : { 'output' :
                          "[PokerGame %d] ERROR: no ante due" % gameId,
                          'packet' :
                                  PacketPokerAnte(game_id = gameId, amount = 500,
                                                        serial = client.getSerial()) },
            'lookcards' : { 'answer_type' : PACKET_POKER_LOOK_CARDS,
                          'packet' :
                                  PacketPokerLookCards(game_id = gameId,
                                                        serial = client.getSerial()) },
            'fold' : { 'output' : "ERROR: player %d cannot fold." % client.getSerial(),
                          'packet' :
                                  PacketPokerFold(game_id = gameId,
                                                        serial = client.getSerial()) },
            'call' : { 'output' : "ERROR: player %d cannot call." % client.getSerial(),
                          'packet' :
                                  PacketPokerCall(game_id = gameId,
                                                        serial = client.getSerial()) },
            'raise' : { 'output' : "ERROR: player %d cannot raise." % client.getSerial(),
                          'packet' :
                                  PacketPokerRaise(game_id = gameId, amount = 0,
                                                        serial = client.getSerial()) },
            'check' : { 'output' : "ERROR: player %d cannot check." % client.getSerial(),
                          'packet' :
                                  PacketPokerCheck(game_id = gameId,
                                                        serial = client.getSerial()) },
            'replay' : { 'output' : "*ERROR* loadHand(%d) expected one row got 0" % client.getSerial(),
                          'packet' :
                                  PacketPokerHandReplay(game_id = gameId,
                                                        serial = client.getSerial()) },
            }
        # Next, we loop through all the serial-related bad pack list,
        # attempting to handle each one.  Also, catch any error packets
        # for those we expect to receive.
        for (key, info) in packetTests.iteritems():
            avatar.resetPacketsQueue()
            avatar.queuePackets()
            silence_all_messages()
            avatar.handlePacketLogic(info['packet'])
            restore_all_messages()
            if info.has_key('output'):
                self.assertEqual(search_output(info['output']), True, info['output'])
            found = False
            for packet in avatar.resetPacketsQueue():
                found = True
                self.assertEquals(packet.type, info['answer_type'])
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, client.getSerial())
            self.assertEquals(found, info.has_key('answer_type'))
        return (client, packet)
    # ------------------------------------------------------------------------
    def test52_variousPackets(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.sitTable, 0, 2)
        d.addCallback(self.readyToPlay, 0, 2)
        d.addCallback(self.variousPacketsWithStringOrSinglePacketReturn, 0, 2)
        return d
    # ------------------------------------------------------------------------
    def autoMuck(self, (client, packet), id, gameId, autoMuckValue ):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerAutoMuck(serial= client.getSerial(),
                                                     game_id = gameId,
                                                     auto_muck = autoMuckValue))
        self.assertEquals(autoMuckValue, table.game.getPlayer(client.getSerial()).auto_muck)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test53_autoMuck(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.autoMuck, 0, 2, pokergame.AUTO_MUCK_LOSE)
        return d
    # ------------------------------------------------------------------------
    def tableQuit(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableQuit(serial= client.getSerial(),
                                                      game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_LEAVE:
                found += 1
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEqual(packet.seat, 1)
        self.assertEquals(found, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test54_doTableQuit(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.tableQuit, 0, 2)
        return d
    # ------------------------------------------------------------------------
    def joinTableForceFail(self, (client, packet), id, gameId, name, struct):
        avatar = self.service.avatars[id]

        table = self.service.getTable(gameId)
        def forceFalse(self, amount, reason = ""):
            return False
        originalJoin = table.joinPlayer
        table.joinPlayer = forceFalse

        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableJoin(serial = client.getSerial(),
                                                      game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            # Note: the behavior below, tested in the "if", of returning
            # an empty PacketTable() on error is deprecated, per
            # documentation in pokerpackets.py.  This functionality is
            # left in and supported for old clients.  The Error packet (in
            # the elif below) is the proper way to test for an error
            # return on PacketPokerTableJoin()
            if packet.type == PACKET_POKER_TABLE:
                found += 1
                self.assertEquals(packet.id, 0)
                self.assertEquals(packet.name, "noname")
                self.assertEquals(packet.reason, PacketPokerTable.REASON_TABLE_JOIN)
            elif packet.type == PACKET_POKER_ERROR:
                found += 1
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, 0)
                self.assertEquals(packet.other_type, PACKET_POKER_TABLE_JOIN)
                self.assertEquals(packet.code, PacketPokerTableJoin.GENERAL_FAILURE)
                self.failUnless(len(packet.message) > 0,
                                "some message should be included")
        self.assertEquals(found, 2)

        return (client, packet)
    # ------------------------------------------------------------------------
    def test55_tableJoinWhenFails(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTableForceFail, 0, 2, 'Table2', '2-4-limit')
        return d
    # ------------------------------------------------------------------------
    def handReplayWithoutTable(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        silence_all_messages()
        avatar.handlePacketLogic(PacketPokerHandReplay(serial= client.getSerial()))
        restore_all_messages();
        self.assertEqual(search_output("*ERROR* loadHand(%d) expected one row got 0" % client.getSerial()), True)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test56_handReplyNoTable(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.handReplayWithoutTable, 0)
        return d
    # ------------------------------------------------------------------------
    def fullQuit(self, (client, packet), id ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketQuit())
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_LEAVE:
                found += 1
                self.assertEquals(packet.serial, client.getSerial())
        self.assertEquals(found, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test57_doFullQuit(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.fullQuit, 0)
        return d
    # ------------------------------------------------------------------------
    def doLogoutSucceed(self, (client, packet), id):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketLogout())
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_PLAYER_LEAVE:
                found += 1
                self.assertEquals(packet.serial, client.getSerial())
        self.assertEquals(found, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def doLogoutFail(self, (client, packet), id):
        client.sendPacket(PacketLogout())
        d = client.packetDeferred(True, PACKET_ERROR)
        def checkbadLogoutReturn( (client, packet) ):
            self.assertEquals(packet.code, PacketPokerGetPlayerInfo.NOT_LOGGED)
            self.assertEquals(packet.message, "Not logged in")
            self.assertEquals(packet.other_type, PACKET_LOGOUT)
        d.addCallback(checkbadLogoutReturn)
        return d
    # ------------------------------------------------------------------------
    def test58_packetLogoutSucceed(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnte, 0, 2)
        d.addCallback(self.doLogoutSucceed, 0)
        return d
    # ------------------------------------------------------------------------
    def test59_packetLogoutFailed(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.doLogoutFail, 0)
        return d
    # ------------------------------------------------------------------------
    def test60_handSelectAllWithWhere(self):
        """Test sending hand select all packet."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.handSelectAll, 0, "1 = 1")
        return d
    # ------------------------------------------------------------------------
    def createTableForceFail(self, (client, packet), id):
        avatar = self.service.avatars[id]

        def forceFalse(self, amount):
            return False
        originalCreate = self.service.createTable
        self.service.createTable = forceFalse

        avatar.queuePackets()
        q = avatar.handlePacket(PacketPokerTable(id = 1, seats  = 5,
                    name = "A Testing Cash Table", variant = "holdem",
                    betting_structure = '2-4-limit', player_timeout =  6,
                    currency_serial = 0))
        found = False
        for packet in q:
            if packet.type == PACKET_POKER_TABLE:
                found = True
                self.assertEquals(packet.id, 0)
                self.assertEquals(packet.seats, 10)
                self.assertEquals(packet.name, 'noname')
                self.assertEquals(packet.reason, PacketPokerTable.REASON_TABLE_CREATE)
        self.assertEquals(found, True)
        self.service.createTable = originalCreate
        return (client, packet)
    # ------------------------------------------------------------------------
    def test61_tableCreateFails(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.createTableForceFail, 0)
        return d
    # ------------------------------------------------------------------------
    def autoBlindAnteForceTourney(self, (client, packet), id, gameId ):
        avatar = self.service.avatars[id]

        table = self.service.getTable(gameId)
        oldIsTourney = table.game.isTournament
        def forceTrue():
            return True
        table.game.isTournament = forceTrue

        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerAutoBlindAnte(serial= client.getSerial(),
                                                        game_id = gameId))
        found = False
        for packet in avatar.resetPacketsQueue():
            found = True
        # in tourneys, the packet is ignored
        self.assertEquals(found, False)
        table.game.isTournament = oldIsTourney
        return (client, packet)
    # ------------------------------------------------------------------------
    def test62_ignoreAutoBlindAnteInTourney(self):
        """Make sure auto blind/ante setting is ignored when the game is a tourney"""
        # The sequence of how to get yourself seated in a cash game was
        # taken from the instructions at the top of pokerpackets.py
        # labelled "How to sit at a cash game table ?"
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d.addCallback(self.seatTable, 0, 2)
        d.addCallback(self.buyInTable, 0, 2, 1000)
        d.addCallback(self.autoBlindAnteForceTourney, 0, 2)
        return d
    # -------------------------------------------------------------------------
    def joinTableWhenHandRunning(self, (client, packet), id, gameId, name, struct):
        avatar = self.service.avatars[id]
        table = self.service.getTable(gameId)
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTableJoin(serial = client.getSerial(),
                                                      game_id = gameId))
        found = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_TABLE:
                found += 1
                self.assertEquals(packet.variant, 'holdem')
                self.assertEquals(packet.betting_structure, struct)
                self.assertEquals(packet.reason, PacketPokerTable.REASON_TABLE_JOIN)
                for  (kk, vv) in avatar.tables.items():
                    self.assertEquals(vv.game.id, table.game.id)
                    self.assertEquals(vv.game.name, name)
                    self.assertEquals(vv.game.max_players, 10)
                    self.assertEquals(vv.game.variant, 'holdem')
                    self.assertEquals(vv.game.betting_structure, struct)
            elif packet.type == PACKET_POKER_BATCH_MODE:
                found += 1
                self.assertEquals(packet.serial, 0)
                self.assertEquals(packet.game_id, table.game.id)
            elif packet.type ==  PACKET_POKER_SEATS:
                found += 1
                self.assertEquals(packet.game_id, table.game.id)
            elif packet.type == PACKET_POKER_IN_GAME:
                found += 1
                self.assertEquals(packet.serial, 0)
                self.assertEquals(packet.players, [4, 5])
            elif packet.type ==  PACKET_POKER_BLIND:
                found += 1
                self.assertEquals(packet.serial, 5)
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.amount,  100)
            elif packet.type ==  PACKET_POKER_BLIND_REQUEST:
                found += 1
                self.assertEquals(packet.serial, 4)
                self.assertEquals(packet.game_id, table.game.id)
                self.assertEquals(packet.amount,  200)
                self.assertEquals(packet.state,  'big')
        self.assertEquals(found, 6)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test63_newObserver(self):
        """Test a third player joining the table and receiving packet playback"""
        # To cover a few lines in pokeravatar.join(), I needed a situation
        # where a third client joined while two were already playing a
        # hand.  This test does that.  Note it's the only test that uses
        # the third client.
        def client1(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.setupCallbackChain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        def client2(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.setupCallbackChain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            d.addCallback(self.autoBlindAnte, index, gameId)
            d.addCallback(self.sitTable, index, gameId)
            d.addCallback(self.readyToPlay, index, gameId)
            return d
        def client3(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.setupCallbackChain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTableWhenHandRunning, index, gameId, 'Table2', '2-4-limit')
            return d
        gameId = 2
        d = defer.succeed(True)
        d.addCallback(client1, gameId)
        d.addCallback(client2, gameId)
        d.addCallback(self.dealTable, gameId)
        d.addCallback(client3, gameId)
        return d
    # ------------------------------------------------------------------------
    def tinyFunctions(self, (client, packet), id):
        avatar = self.service.avatars[id]
        self.assertEquals(avatar.getUrl(), "random")
        self.assertEquals(avatar.getOutfit(), "random")
    # ------------------------------------------------------------------------
    def test64_testTinyFunctions(self):
        """Test a few small functions that are not otherwise called"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tinyFunctions, 0)
        return d
    # ------------------------------------------------------------------------
    def monitor(self, (client, packet)):
        avatar = self.service.avatars[0]
        avatar.queuePackets()
        self.assertEquals(0, len(self.service.monitors))
        avatar.handlePacketLogic(PacketPokerMonitor())
        self.assertEquals(1, len(self.service.monitors))
        return (client, packet)
    # ------------------------------------------------------------------------
    def test65_monitor(self):
        """Test monitor request"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.monitor)
        return d
    # ------------------------------------------------------------------------
    def tourneyManager(self, (client, packet), id, tourney_serial ):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerGetTourneyManager(tourney_serial = tourney_serial))
        for packet in avatar.resetPacketsQueue():
            count = 0
            if packet.type == PACKET_POKER_TOURNEY_MANAGER:
                self.assertEquals(packet.tourney_serial, 1)
                count += 1
            self.assertEquals(count, 1)
        return (client, packet)
    # ------------------------------------------------------------------------
    def test66_tourneyPlayerList(self):
        """Test for listing players in a tourney."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneyManager, 0, 1)
        return d
    # ------------------------------------------------------------------------
    def test68_handlePacketDefer(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        def handlePacketDefer(x):
            avatar = self.service.avatars[0]
            #
            # returns nothing
            #
            r = avatar.handlePacketDefer(PacketPing())
            self.assertEqual([], r)
            #
            # returns a deferred that returns a packet
            #
            d1 = defer.Deferred()
            def returnDefer1(packet):
                avatar.sendPacket(d1)
            avatar.handlePacketLogic = returnDefer1
            r = avatar.handlePacketDefer(PacketPing())
            self.assertEquals(True, isinstance(r, defer.Deferred))
            def checkDefer(packets):
                self.assertEquals(type(packets), ListType)
                self.assertEquals(PACKET_PING, packets[0].type)
            d1.addCallback(checkDefer)
            d1.callback(PacketPing())
            #
            # returns a list of packets
            #
            d2 = defer.Deferred()
            def returnDefer2(packet):
                avatar.sendPacket(d2)
            avatar.handlePacketLogic = returnDefer2
            r = avatar.handlePacketDefer(PacketPing())
            self.assertEquals(True, isinstance(r, defer.Deferred))
            d2.addCallback(checkDefer)
            d2.callback([PacketPing()])
        d.addCallback(handlePacketDefer)
        return d

    # ------------------------------------------------------------------------
    def getPlayerPlaces(self, (client, packet), id, name):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerGetPlayerPlaces(serial= client.getSerial()))
        packets = avatar.resetPacketsQueue()
        self.assertEquals(1, len(packets))
        packet = packets[0]
        self.assertEquals(PACKET_POKER_PLAYER_PLACES, packet.type)
        self.assertEquals([2], packet.tables)
        return (client, packet)

    # ------------------------------------------------------------------------
    def getPlayerPlacesByName(self, (client, packet), id, name):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerGetPlayerPlaces(name = name))
        packets = avatar.resetPacketsQueue()
        self.assertEquals(1, len(packets))
        packet = packets[0]
        self.assertEquals(PACKET_POKER_PLAYER_PLACES, packet.type)
        self.assertEquals([2], packet.tables)
        return (client, packet)

    def getPlayerPlacesNone(self, (client, packet), id, name):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerGetPlayerPlaces(name = name))
        packets = avatar.resetPacketsQueue()
        self.assertEquals(1, len(packets))
        packet = packets[0]
        self.assertEquals(PACKET_POKER_PLAYER_PLACES, packet.type)
        self.assertEquals([], packet.tables)
        return (client, packet)

    def getPlayerPlacesFailed(self, (client, packet), id, name):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerGetPlayerPlaces(name = name))
        packets = avatar.resetPacketsQueue()
        self.assertEquals(1, len(packets))
        packet = packets[0]
        self.assertEquals(PACKET_ERROR, packet.type)
        self.assertEquals(PACKET_POKER_PLAYER_PLACES, packet.other_type)
        return (client, packet)

    # ------------------------------------------------------------------------
    def test69_getPlayerPlaces(self):
        """Test lookup of where the player is playing."""
        self.createClients(2)
        d1 = self.client_factory[0].established_deferred
        d1.addCallback(self.sendExplain)
        d1.addCallback(self.sendRolePlay)
        d1.addCallback(self.login, 0)
        d1.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        d1.addCallback(self.seatTable, 0, 2)
        d1.addCallback(self.getPlayerPlaces, 0, 1)
        d1.addCallback(self.getPlayerPlacesByName, 0, 'user0')
        d1.addCallback(self.getPlayerPlacesFailed, 0, 'user999')

        d2 = self.client_factory[1].established_deferred
        d2.addCallback(self.sendExplain)
        d2.addCallback(self.sendRolePlay)
        d2.addCallback(self.login, 1)
        d2.addCallback(self.getPlayerPlacesNone, 1, 'user1')
        return defer.DeferredList([d1, d2]) # the order in which d1 & d2 is run does not matter

    # -------------------------------------------------------------------------
    def setLocale(self, (client, packet), myLocale, avid = 0, expectSucceed=True):

        avatar = self.service.avatars[avid]
        avatar.queuePackets()
        clear_all_messages()
        avatar.handlePacketLogic(PacketPokerSetLocale(serial = client.getSerial(),
                                                      locale = myLocale))
        foundCount = 0
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_ACK:
                if expectSucceed:
                    # Save the locale we've set so other tests can know if
                    # they need it.
                    self.avatarLocales[avid] = myLocale
                    foundCount += 1
                else:
                    foundCount -= 1
            elif packet.type == PACKET_POKER_ERROR:
                if expectSucceed:
                    foundCount -= 1
                else:
                    self.assertEquals(packet.serial, client.getSerial())
                    self.assertEquals(packet.other_type, PACKET_POKER_SET_LOCALE)
                    foundCount += 1
                    self.failUnless(search_output('Locale, "Klingon_Kronos.ISO-8859-1" not available.  Klingon_Kronos.ISO-8859-1 must not have been provide via <language/> tag in settings, or errors occured during loading.'))
        self.assertEquals(foundCount, 1)
        return (client, packet)
    # -------------------------------------------------------------------------
    def test71_setLocaleAlwaysValid(self):
        """Tests setting of roles"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.setLocale, "en_US", 0)
        d.addCallback(self.quit)
        return d
    # -------------------------------------------------------------------------
    def test72_setLocaleAlwaysFail(self):
        """Tests setting of roles"""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.setLocale, "Klingon_Kronos", 0, False)
        d.addCallback(self.quit)
        return d
    # ------------------------------------------------------------------------
    def playerTimesoutAndThenLooksAtQueuedPackets(self, (client, packet), gameId):
        avatars = self.service.avatars
        clients = {}
        table = self.service.getTable(gameId)
        for ii in [ 0, 1, 2]:
            clients[ii] = self.service.avatar_collection.get(avatars[ii].getSerial())[0]
            avatars[ii].resetPacketsQueue()
            self.sitTable((clients[ii], None), ii, gameId)
        for ii in [ 0, 1, 2]:
            avatars[ii].resetPacketsQueue()
            self.autoBlindAnte( (clients[ii], None), ii, gameId)
        for ii in [ 0 ,1, 2]:
            avatars[ii].resetPacketsQueue()
            self.readyToPlay( (clients[ii], None), ii, gameId)

#        self.timeout_policy = 'sitOut'
        table.autodeal = True
        self.dealTable((client, packet), gameId)
        def findBigBlind(id):
            bbPacket = None
            packets = []
            for ii in [ 1, 2]: packets.extend(avatars[ii].resetPacketsQueue())
            while bbPacket == None:
                for packet in packets:
                    if packet.type == PACKET_POKER_BLIND and packet.serial == avatars[id].getSerial():
                        self.assertEquals(packet.amount, 200)
                        self.assertEquals(packet.game_id, gameId)
                        bbPacket = packet
                        break
            return bbPacket

        self.assertNotEquals(findBigBlind(2), None)

        # Player 0 fails to act in time
        table.playerTimeoutTimer(clients[0].getSerial())

        avatars[1].handlePacketLogic(PacketPokerFold(serial = clients[1].getSerial(),
                                                     game_id = gameId))
        for ii in [ 0, 1, 2]:
            avatars[ii].resetPacketsQueue()
            avatars[ii].queuePackets()
        handSkip = 0
        while handSkip < 5:
            handSkip += 1
            # Player 1 folds, giving this pot to Player 2
            self.dealTable((client, packet), gameId)
            self.assertNotEquals(findBigBlind(1), None)
            avatars[2].handlePacketLogic(PacketPokerFold(serial = clients[2].getSerial(),
                                                         game_id = gameId))
            self.dealTable((client, packet), gameId)
            self.assertNotEquals(findBigBlind(2), None)
            avatars[1].handlePacketLogic(PacketPokerFold(serial = clients[1].getSerial(),
                                                         game_id = gameId))

        # After this loop, a number of heads up hands have been played.
        # Despite the fact that we set avatars[0] to queue packets before
        # the loop started, we find that only the packets from the last
        # hand are present.
        # After this loop, a number of heads up hands have been played.
        # Despite the fact that we set avatars[0] to queue packets before
        # the loop started, we find that only the packets from the last
        # hand are present.
        count = 0
        foldCount = 0
        rakeCount = 0
        winCount = 0
        for pack in avatars[0]._packets_queue:
            count += 1
            self.assertEquals(pack.game_id, gameId)
            if pack.type == PACKET_POKER_FOLD:
                foldCount += 1
            elif pack.type == PACKET_POKER_RAKE:
                self.assertEquals(pack.value, 10)
                rakeCount += 1
            elif pack.type == PACKET_POKER_WIN:
                self.assertEquals(pack.serial, 0)
                winCount += 1
        self.assertEquals(count, 200)
        self.assertEquals([ winCount, rakeCount, foldCount ], [ 10, 10, 10])
        self.assertEquals(winCount, 10)
        return (clients[2], None)
    # ------------------------------------------------------------------------
    def test73_playerTimeoutAndThenViewsQueuedPackets(self):
        """Test when a player was in a hand, reconnects after other hands
        have been played, and expects certain packet playback  packets."""
        def client(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.setupCallbackChain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            return d
        gameId = 2
        table = self.service.getTable(gameId)
        table.autodeal = False
        d = defer.succeed(True)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(self.playerTimesoutAndThenLooksAtQueuedPackets, gameId)
        return d

    # ------------------------------------------------------------------------
    def playWhileObserverGrows(self, (client, packet), gameId):
        avatars = self.service.avatars
        clients = {}
        table = self.service.getTable(gameId)
        for ii in [ 0, 1]:
            clients[ii] = self.service.avatar_collection.get(avatars[ii].getSerial())[0]
            avatars[ii].resetPacketsQueue()
            self.sitTable((clients[ii], None), ii, gameId)
        for ii in [ 0, 1]:
            avatars[ii].resetPacketsQueue()
            self.autoBlindAnte( (clients[ii], None), ii, gameId)
        for ii in [ 0 ,1]:
            avatars[ii].resetPacketsQueue()
            self.readyToPlay( (clients[ii], None), ii, gameId)

        def findBigBlind(id):
            bbPacket = None
            packets = []
            for ii in [ 0, 1]: packets.extend(avatars[ii].resetPacketsQueue())
            while bbPacket == None:
                for packet in packets:
                    if packet.type == PACKET_POKER_BLIND and packet.serial == avatars[id].getSerial():
                        self.assertEquals(packet.amount, 200)
                        self.assertEquals(packet.game_id, gameId)
                        bbPacket = packet
                        break
            return bbPacket


        for ii in [ 0, 1, 2]:
            clients[ii] = self.service.avatar_collection.get(avatars[ii].getSerial())[0]
            avatars[ii].resetPacketsQueue()

        table.autodeal = True
        handSkip = 0
        while handSkip < 5:
            handSkip += 1
            self.dealTable((client, packet), gameId)
            self.assertNotEquals(findBigBlind(0), None)
            avatars[1].handlePacketLogic(PacketPokerFold(serial = clients[1].getSerial(),
                                                         game_id = gameId))
            self.dealTable((client, packet), gameId)
            self.assertNotEquals(findBigBlind(1), None)
            avatars[0].handlePacketLogic(PacketPokerFold(serial = clients[0].getSerial(),
                                                         game_id = gameId))

        # After this loop, a number of heads up hands have been played.
        # Despite the fact that we set avatars[0] to queue packets before
        # the loop started, we find that only the packets from the last
        # hand are present.
        count = 0
        foldCount = 0
        rakeCount = 0
        winCount = 0
        for pack in avatars[2]._packets_queue:
            count += 1
            self.assertEquals(pack.game_id, gameId)
            if pack.type == PACKET_POKER_FOLD:
                foldCount += 1
            elif pack.type == PACKET_POKER_RAKE:
                self.assertEquals(pack.value, 10)
                rakeCount += 1
            elif pack.type == PACKET_POKER_WIN:
                self.assertEquals(pack.serial, 0)
                winCount += 1
        self.assertEquals(count, 200)
        self.assertEquals([ winCount, rakeCount, foldCount ], [ 10, 10, 10])
        self.assertEquals(winCount, 10)
        return (client, None)
    # ------------------------------------------------------------------------
    def test74_tooManyPacketsGrowOnObserver(self):
        """Test when a player merely observes, the packet queue grows and grows"""
        def client(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.setupCallbackChain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            return d
        gameId = 2
        table = self.service.getTable(gameId)
        table.autodeal = False
        d = defer.succeed(True)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(self.playWhileObserverGrows, gameId)
        return d
    # ------------------------------------------------------------------------
    def playerSitsBrieflyThenSitsOut(self, (client, packet), gameId):
        avatars = self.service.avatars
        clients = {}
        table = self.service.getTable(gameId)
        for ii in [ 0, 1, 2]:
            clients[ii] = self.service.avatar_collection.get(avatars[ii].getSerial())[0]
            avatars[ii].resetPacketsQueue()
            self.sitTable((clients[ii], None), ii, gameId)
        for ii in [ 0, 1, 2]:
            avatars[ii].resetPacketsQueue()
            self.autoBlindAnte( (clients[ii], None), ii, gameId)
        for ii in [ 0 ,1, 2]:
            avatars[ii].resetPacketsQueue()
            self.readyToPlay( (clients[ii], None), ii, gameId)

        self.sitOut((clients[ii], None), 2, gameId)

        def findBigBlind(id):
            bbPacket = None
            packets = []
            for ii in [ 0, 1]: packets.extend(avatars[ii].resetPacketsQueue())
            while bbPacket == None:
                for packet in packets:
                    if packet.type == PACKET_POKER_BLIND and packet.serial == avatars[id].getSerial():
                        self.assertEquals(packet.amount, 200)
                        self.assertEquals(packet.game_id, gameId)
                        bbPacket = packet
                        break
            return bbPacket

        for ii in [ 0, 1, 2]:
            clients[ii] = self.service.avatar_collection.get(avatars[ii].getSerial())[0]
            avatars[ii].resetPacketsQueue()

        table.autodeal = True
        handSkip = 0
        while handSkip < 5:
            handSkip += 1
            self.dealTable((client, packet), gameId)
            self.assertNotEquals(findBigBlind(0), None)
            avatars[1].handlePacketLogic(PacketPokerFold(serial = clients[1].getSerial(),
                                                         game_id = gameId))
            self.dealTable((client, packet), gameId)
            self.assertNotEquals(findBigBlind(1), None)
            avatars[0].handlePacketLogic(PacketPokerFold(serial = clients[0].getSerial(),
                                                         game_id = gameId))

        # After this loop, a number of heads up hands have been played.
        # Despite the fact that we set avatars[0] to queue packets before
        # the loop started, we find that only the packets from the last
        # hand are present.
        count = 0
        foldCount = 0
        rakeCount = 0
        winCount = 0
        for pack in avatars[2]._packets_queue:
            count += 1
            self.assertEquals(pack.game_id, gameId)
            if pack.type == PACKET_POKER_FOLD:
                foldCount += 1
            elif pack.type == PACKET_POKER_RAKE:
                self.assertEquals(pack.value, 10)
                rakeCount += 1
            elif pack.type == PACKET_POKER_WIN:
                self.assertEquals(pack.serial, 0)
                winCount += 1
        self.assertEquals(count, 200)
        self.assertEquals([ winCount, rakeCount, foldCount ], [ 10, 10, 10])
        self.assertEquals(winCount, 10)
        return (clients[2], None)
    # ------------------------------------------------------------------------
    def test75_playerSitsBrieflyThenOut(self):
        """Test when a player sits in briefly, then sits out.  Packet queue grows?"""
        def client(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.setupCallbackChain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            return d
        gameId = 2
        table = self.service.getTable(gameId)
        table.autodeal = False
        d = defer.succeed(True)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(self.playerSitsBrieflyThenSitsOut, gameId)
        return d
    # ------------------------------------------------------------------------
    def forceObserverDisconnectPacketQueue(self, (client, packet), gameId):
        silence_all_messages()
        avatars = self.service.avatars
        clients = {}
        table = self.service.getTable(gameId)
        for ii in [ 0, 1]:
            clients[ii] = self.service.avatar_collection.get(avatars[ii].getSerial())[0]
            avatars[ii].resetPacketsQueue()
            self.sitTable((clients[ii], None), ii, gameId)
        for ii in [ 0, 1]:
            avatars[ii].resetPacketsQueue()
            self.autoBlindAnte( (clients[ii], None), ii, gameId)
        for ii in [ 0 ,1]:
            avatars[ii].resetPacketsQueue()
            self.readyToPlay( (clients[ii], None), ii, gameId)

        def findBigBlind(id, expectedCount):
            bbPacket = None
            packets = []
            for ii in [ 0, 1]:
                self.assertEquals(expectedCount, len(avatars[ii]._packets_queue))
                if expectedCount >= 15:
                    self.assertTrue(search_output("ERROR WARNING: user %d has more than 15 packets queued; will force-disconnect when 21 are queued" % clients[ii].getSerial()))
                packets.extend(avatars[ii].resetPacketsQueue())
            while bbPacket == None:
                for packet in packets:
                    if packet.type == PACKET_POKER_BLIND and packet.serial == avatars[id].getSerial():
                        self.assertEquals(packet.amount, 200)
                        self.assertEquals(packet.game_id, gameId)
                        bbPacket = packet
                        break
            return bbPacket

        for ii in [ 0, 1, 2]:
            clients[ii] = self.service.avatar_collection.get(avatars[ii].getSerial())[0]
            avatars[ii].resetPacketsQueue()

        table.autodeal = True
        expectedCount = 14

        clear_all_messages()
        self.dealTable((client, packet), gameId)
        self.assertNotEquals(findBigBlind(0, expectedCount), None)
        avatars[1].handlePacketLogic(PacketPokerFold(serial = clients[1].getSerial(),
                                                     game_id = gameId))
        # we should get the warning on the observer
        self.assertTrue(search_output("ERROR WARNING: user %d has more than 15 packets queued; will force-disconnect when 21 are queued"  % clients[2].getSerial()))
        expectedCount = 20
        clear_all_messages()
        self.dealTable((client, packet), gameId)
        self.assertNotEquals(findBigBlind(1, expectedCount), None)
        avatars[0].handlePacketLogic(PacketPokerFold(serial = clients[0].getSerial(),
                                                     game_id = gameId))
        # This is the point where observer has been disconnected.  We need
        # to create a callback, I picked this function because it appears
        # to be the pure bottom of the chain of items that are called when
        # self.service.destroyAvatar() is called.

        #  Note that we are returning checkLogoutDeferred which should
        #  generate reactor 120 second error if checkLogout is never
        #  called.
        realLogout = avatars[2].user.logout
        self.service.verbose = 6
        clear_all_messages()
        checkLogoutDeferred = defer.Deferred()
        # The array can't have a closure around it, it appears.... I did
        # this to save time rather than resarching closures around arrays
        # in Python. :)
        av0 = avatars[0]
        av1 = avatars[1]
        av2 = avatars[2]
        def checkLogout():
            self.assertEquals(search_output('connection lost for %s/%d' %
                                            (av2.getName(), av2.getSerial())), True)
            self.assertEquals(search_output('[Server][PokerGame %d] removing player %d from game' % (gameId, av2.getSerial())), True)
            self.assertTrue(len(av2._packets_queue) > 21)
            for pack in av0._packets_queue[-1:], av0._packets_queue[-1:]:
                pack = pack[0]
                self.assertEquals(pack.type, PACKET_POKER_PLAYER_LEAVE)
                self.assertEquals(pack.serial, av2.getSerial())
                self.assertEquals(pack.game_id, gameId)
            self.assertFalse(av2 in self.service.avatars)
            self.assertFalse(av2 in self.service.monitors)
            self.assertEquals([], self.service.avatar_collection.get(av2.user.serial))
            realLogout()
            checkLogoutDeferred.callback(True)
        av2.user.logout = checkLogout
        return checkLogoutDeferred
    # ------------------------------------------------------------------------
    def test76_forceObserverDisconnectPacketQueue(self):
        """Tests packet queue growth and cutoff by setting max leng small"""
        def client(result, gameId):
            index = self.createClient()
            d = self.client_factory[index].established_deferred
            d.addCallback(self.setupCallbackChain)
            d.addCallback(self.sendRolePlay)
            d.addCallback(self.login, index)
            d.addCallback(self.joinTable, index, gameId, 'Table2', '2-4-limit')
            d.addCallback(self.seatTable, index, gameId)
            d.addCallback(self.buyInTable, index, gameId, 1000)
            return d
        gameId = 2
        saveClientQueueMax = self.service.client_queued_packet_max
        self.service.client_queued_packet_max = 21
        table = self.service.getTable(gameId)
        table.autodeal = False
        d = defer.succeed(True)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(client, gameId)
        d.addCallback(self.forceObserverDisconnectPacketQueue, gameId)
        def resetQueueMax(d, saveClientQueueMax):
            self.service.client_queued_packet_max = saveClientQueueMax
            return d
        d.addCallback(resetQueueMax, saveClientQueueMax)
        return d
    # ------------------------------------------------------------------------
    def tourneyCreate(self, (client, packet), id):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        wrong_player = 4444
        avatar.handlePacketLogic(PacketPokerCreateTourney(serial = client.getSerial(),
                                                          buy_in = 100,
                                                          players = [wrong_player]))
        found = False
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_ERROR:
                self.assertSubstring(str(wrong_player), packet.message)
                found = True
        self.assertEquals(found, True)
        return (client, packet)

    # ------------------------------------------------------------------------
    def test80_tourneyCreate(self):
        """Test user created tournament."""
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.tourneyCreate, 0)
        return d

    # ------------------------------------------------------------------------
    def test81_distributePacket(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        def handleDistributedPacket(x):
            avatar = self.service.avatars[0]
            self.service.packet2resthost = lambda packet: (('host', 11111, '/PATH'), 2)
            getOrCreateRestClient = avatar.getOrCreateRestClient
            d = defer.Deferred()
            def getOrCreateRestClientMockup(resthost, game_id):
                client = getOrCreateRestClient(resthost, game_id)
                client.sendPacket = lambda packet, data: d
                return client
            avatar.getOrCreateRestClient = getOrCreateRestClientMockup
            r = avatar.handleDistributedPacket(None, PacketPing(), '{ "type": "PacketPing" }')
            r.addCallback(lambda packets: self.assertEquals(['foo'], packets))
            r.addCallback(lambda arg: self.assertEquals(True, avatar.game_id2rest_client.has_key(2)))
            d.callback(['foo'])
            return d
        d.addCallback(handleDistributedPacket)
        return d
    # ------------------------------------------------------------------------
    def test82_distributePacketNoMoreActiveTable(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY = 0.1
        def handleDistributedPacket(x):
            avatar = self.service.avatars[0]
            self.service.packet2resthost = lambda packet: (('host', 11111, '/PATH'), 2)
            getOrCreateRestClient = avatar.getOrCreateRestClient
            clients = {}
            d = defer.Deferred()
            def getOrCreateRestClientMockup(resthost, game_id):
                clients[game_id] = getOrCreateRestClient(resthost, game_id)
                clients[game_id].sendPacket = lambda packet, data: d
                return clients[game_id]
            avatar.getOrCreateRestClient = getOrCreateRestClientMockup
            def clearActiveTable(arg):
                avatar.tables = {}
                return arg
            d.addCallback(clearActiveTable)
            r = avatar.handleDistributedPacket(None, PacketPing(), '{ "type": "PacketPing" }')
            r.addCallback(lambda packets: self.assertEquals(['foo'], packets))
            r.addCallback(lambda arg: self.assertEquals({}, avatar.game_id2rest_client))
            r.addCallback(lambda arg: self.assertEquals(None, clients[2].timer))
            def f(x): PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY = -1
            r.addCallback(f)
            d.callback(['foo'])
            return d
        d.addCallback(handleDistributedPacket)
        return d
    # ------------------------------------------------------------------------
    def test82_1_distributePacketNoMoreActiveGame(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY = 0.1
        def handleDistributedPacket(x):
            avatar = self.service.avatars[0]
            self.service.packet2resthost = lambda packet: (('host', 11111, '/PATH'), 2)
            getOrCreateRestClient = avatar.getOrCreateRestClient
            clients = {}
            d = defer.Deferred()
            def getOrCreateRestClientMockup(resthost, game_id):
                clients[game_id] = getOrCreateRestClient(resthost, game_id)
                clients[game_id].sendPacket = lambda packet, data: d
                return clients[game_id]
            avatar.getOrCreateRestClient = getOrCreateRestClientMockup
            def clearActiveTable(arg):
                avatar.tables = {}
                avatar.explain.games.games = {}
                return arg
            d.addCallback(clearActiveTable)
            r = avatar.handleDistributedPacket(None, PacketPing(), '{ "type": "PacketPing" }')
            r.addCallback(lambda packets: self.assertEquals(PACKET_PING, packets[0].type))
            r.addCallback(lambda arg: self.assertEquals({}, avatar.game_id2rest_client))
            r.addCallback(lambda arg: self.assertEquals(None, clients[2].timer))
            def f(x): PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY = -1
            r.addCallback(f)
            d.callback([PacketPing()])
            return d
        d.addCallback(handleDistributedPacket)
        return d
    # ------------------------------------------------------------------------
    def test82_2_distributePacketDisconnect(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY = 0.1
        def handleDistributedPacket(x):
            avatar = self.service.avatars[0]
            self.service.packet2resthost = lambda packet: (('host', 11111, '/PATH'), 2)
            getOrCreateRestClient = avatar.getOrCreateRestClient
            clients = {}
            d = defer.Deferred()
            def getOrCreateRestClientMockup(resthost, game_id):
                clients[game_id] = getOrCreateRestClient(resthost, game_id)
                clients[game_id].sendPacketData = lambda data: d
                clients[game_id].pendingLongPoll = True
                return clients[game_id]
            avatar.getOrCreateRestClient = getOrCreateRestClientMockup
            def disconnectAvatar(arg):
                avatar.connectionLost('reason')
                return arg
            d.addCallback(disconnectAvatar)
            r = avatar.handleDistributedPacket(None, PacketPing(), '{ "type": "PacketPing" }')
            r.addCallback(lambda packets: self.assertEquals(PACKET_PING, packets[0].type))
            r.addCallback(lambda arg: self.assertEquals({}, avatar.game_id2rest_client))
            r.addCallback(lambda arg: self.assertEquals(None, clients[2].timer))
            def f(x): PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY = -1
            r.addCallback(f)
            d.callback('[{ "type": "PacketPing" }]')
            return d
        d.addCallback(handleDistributedPacket)
        return d
    # ------------------------------------------------------------------------
    def test83_distributePacketNoGameId(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY = 0.1
        def handleDistributedPacket(x):
            avatar = self.service.avatars[0]
            self.service.packet2resthost = lambda packet: (('host', 11111, '/PATH'), None)
            getOrCreateRestClient = avatar.getOrCreateRestClient
            d = defer.Deferred()
            def getOrCreateRestClientMockup(resthost, game_id):
                client = getOrCreateRestClient(resthost, game_id)
                self.assertEquals(None, client.longPollCallback)
                self.assertEquals(-1, client.longPollFrequency)
                client.sendPacket = lambda packet, data: d
                return client
            avatar.getOrCreateRestClient = getOrCreateRestClientMockup
            r = avatar.handleDistributedPacket(None, PacketPing(), '{ "type": "PacketPing" }')
            r.addCallback(lambda packets: self.assertEquals(['foo'], packets))
            r.addCallback(lambda arg: self.assertEquals({}, avatar.game_id2rest_client))
            d.callback(['foo'])
            return d
        d.addCallback(handleDistributedPacket)
        return d
    # ------------------------------------------------------------------------
    def test84_distributePacketNoRestHost(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        def handleDistributedPacket(x):
            avatar = self.service.avatars[0]
            self.service.packet2resthost = lambda packet: (None, None)
            r = avatar.handleDistributedPacket(None, PacketPing(), '{ "type": "PacketPing" }')
            self.assertEquals([], r)
        d.addCallback(handleDistributedPacket)
        return d
    # ------------------------------------------------------------------------
    def test85_longPoll(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        def handleLongPoll(x):
            avatar = self.service.avatars[0]
            uid = 'ZUID'
            auth = 'ZAUTH'
            avatar.setDistributedArgs(uid, auth)
            client = avatar.getOrCreateRestClient(('host', 11111, 'path'), 2)
            self.failUnlessSubstring(uid, client.path)
            self.failUnlessSubstring(auth, client.path)
            avatar.noqueuePackets()
            d = avatar.handlePacketDefer(PacketPokerLongPoll())
            self.assertEquals(True, avatar._queue_packets)
            self.assertEquals(d, avatar._longpoll_deferred)
            self.assertEquals(False, avatar._block_longpoll_deferred)
            avatar._longpoll_deferred.addCallback(lambda packets: self.assertEquals(PACKET_PING, packets[0].type))
            client.longPollCallback([PacketPing()])
            self.assertEquals(False, avatar.longPollTimer.active())
            return d
        d.addCallback(handleLongPoll)
        return d
    # ------------------------------------------------------------------------
    def test85_1_longPollTimeout(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        def handleLongPoll(x):
            avatar = self.service.avatars[0]
            uid = 'ZUID'
            auth = 'ZAUTH'
            avatar.setDistributedArgs(uid, auth)
            client = avatar.getOrCreateRestClient(('host', 11111, 'path'), 2)
            client.sendPacket = lambda packet, data: defer.Deferred()
            self.failUnlessSubstring(uid, client.path)
            self.failUnlessSubstring(auth, client.path)
            d = avatar.handlePacketDefer(PacketPokerLongPoll())
            self.assertEquals(d, avatar._longpoll_deferred)
            self.assertEquals(False, avatar._block_longpoll_deferred)
            self.assertEquals(True, avatar.longPollTimer.active())
            avatar._packets_queue = ['foo']
            avatar._longpoll_deferred.addCallback(self.assertEquals, ['foo'])
            return d
        d.addCallback(handleLongPoll)
        return d
    # ------------------------------------------------------------------------
    def test85_2_longPollCallback(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        def handleLongPoll(x):
            avatar = self.service.avatars[0]
            uid = 'ZUID'
            auth = 'ZAUTH'
            avatar.setDistributedArgs(uid, auth)
            client = avatar.getOrCreateRestClient(('host', 11111, 'path'), 2)
            client.longPollCallback([PacketPing()])
            self.assertEquals(1, len(avatar._packets_queue))
        d.addCallback(handleLongPoll)
        return d
    # ------------------------------------------------------------------------
    def test86_longPollReturn(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        def handleLongPollReturn(x):
            avatar = self.service.avatars[0]
            d = avatar.handlePacketDefer(PacketPokerLongPoll())
            avatar._packets_queue = ['foo']
            d.addCallback(self.assertEquals, ['foo'])
            avatar.handlePacketDefer(PacketPokerLongPollReturn())
            self.assertEquals(False, avatar.longPollTimer.active())
            return d
        d.addCallback(handleLongPollReturn)
        return d
    # ------------------------------------------------------------------------
    def test86_2_longPollReturnFlushNextLongPoll(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        def handleLongPollReturn(x):
            avatar = self.service.avatars[0]
            avatar.handlePacketDefer(PacketPokerLongPollReturn())
            self.assertEquals(True, avatar._flush_next_longpoll)
            d = avatar.handlePacketDefer(PacketPokerLongPoll())
            self.assertEquals(None, avatar._longpoll_deferred)
            self.assertEquals(False, avatar._flush_next_longpoll)
            return d
        d.addCallback(handleLongPollReturn)
        return d
    # ------------------------------------------------------------------------
    def test86_3_longPollReturnEmpty(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        def handleLongPollReturn(x):
            avatar = self.service.avatars[0]
            avatar._packets_queue = ['foo']
            packets = avatar.handlePacketDefer(PacketPokerLongPollReturn())
            self.assertEquals([], packets)
        d.addCallback(handleLongPollReturn)
        return d
    # ------------------------------------------------------------------------
    def test87_flushLongPollDeferred(self):
        self.createClients(1)
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupCallbackChain)
        d.addCallback(self.login, 0)
        d.addCallback(self.joinTable, 0, 2, 'Table2', '2-4-limit')
        def handleLongPoll(x):
            avatar = self.service.avatars[0]
            avatar._packets_queue = ['foo']
            d = avatar.handlePacketDefer(PacketPokerLongPoll())
            d.addCallback(self.assertEquals, ['foo'])
            self.assertNotEquals(None, d)
            return d
        d.addCallback(handleLongPoll)
        return d
    # ------------------------------------------------------------------------
    def test88_avatar_with_same_login(self):
        a1 = self.service.createAvatar()
        a1.relogin(1)
        a1.queuePackets()
        a1.handlePacketLogic(PacketPokerTableJoin(serial = 1,
                                                      game_id = 2))
        a1.handlePacketLogic(PacketPokerSetRole(serial = 1, roles = PacketPokerSetRole.PLAY))
        a1.handlePacketLogic(PacketPokerSeat(serial = 1,
                                             seat = 1,
                                             game_id = 2))
        a2 = self.service.createAvatar()
        a2.relogin(1)
        a2.queuePackets()
        a2.handlePacketLogic(PacketPokerTableJoin(serial = 1,
                                                      game_id = 2))
        self.assertEquals(2, len(self.service.avatar_collection.get(1)))
        self.assertEquals(2, len(self.service.tables[2].avatar_collection.get(1)))
        self.assertEquals(True, 1 in self.service.tables[2].game.serial2player)
        self.service.destroyAvatar(a2)
        self.assertEquals(1, len(self.service.tables[2].avatar_collection.get(1)))
        self.assertEquals(True, 1 in self.service.tables[2].game.serial2player)

##############################################################################
class PokerAvatarNoClientServerTestCase(unittest.TestCase):
    timeout = 500

    class MockPlayerInfo:
        def __init__(mpiSelf):
            mpiSelf.url = "http://example.org/"
            mpiSelf.outfit = "naked"
            mpiSelf.locale = 'mylocale'
            mpiSelf.name = 'Doyle Brunson'
    class MockService:
        def __init__(msSelf):
            msSelf.verbose = 6
            def transFunc(locale, encoding = ''):
                if locale == 'mylocale':
                    return lambda s: "MYTRANSLATION"
                else:
                    return lambda s: "BROKEN FAIL"
            msSelf.locale2translationFunc = transFunc
            msSelf.avatar_collection = PokerAvatarCollection()

        def getClientQueuedPacketMax(self):
            return 200000
        def getPlayerInfo(msSelf, serial):
            return PokerAvatarNoClientServerTestCase.MockPlayerInfo()
        def getPlayerPlaces(msSelf, serial):
            class MockPlace:
                def __init__(mpSelf): mpSelf.tourneys = "MOCKPLACES"
            return MockPlace()
        def destroyAvatar(msSelf, avatar):
            avatar.connectionLost("Disconnected")

    class MockExplain:
        def __init__(meSelf): meSelf.handleSerialPackets = []
        def handleSerial(meSelf, pack):
            meSelf.handleSerialPackets.append(pack)
    # ------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()

        self.avatarLocales = {}
        self.avatarLocales[0] = "default"
        self.avatarLocales[1] = "default"
    # ------------------------------------------------------------------------
    def test01_reloginCoverage(self):
        """No packet actualy does a relogin, this covers it 'by-hand', as
        it were."""
        from pokernetwork import pokeravatar

        service = PokerAvatarNoClientServerTestCase.MockService()
        avatar = pokeravatar.PokerAvatar(service)
        explain = PokerAvatarNoClientServerTestCase.MockExplain()
        saveExplain = avatar.explain
        avatar.explain = explain

        avatar.localeFunc = lambda s: "DONOTOVERRIDE"

        avatar.relogin(1042)
        self.assertEquals(avatar.user.serial, 1042)
        self.assertEquals(avatar.user.name, 'Doyle Brunson')
        self.assertEquals(avatar.user.url, "http://example.org/")
        self.assertEquals(avatar.user.outfit, "naked")
        self.assertEquals(avatar.user.privilege, pokeravatar.User.REGULAR)
        self.assertEquals(avatar.tourneys, "MOCKPLACES")

        self.assertEquals([avatar], service.avatar_collection.get(1042))

        avatar.explain = saveExplain

        self.assertEquals(len(explain.handleSerialPackets), 1)
        self.assertEquals(explain.handleSerialPackets[0].serial, 1042)
        self.assertEquals(explain.handleSerialPackets[0].type, PACKET_SERIAL)

        self.assertEquals(avatar.localeFunc("DUMMY"),  "DONOTOVERRIDE")
    # ------------------------------------------------------------------------
    def test02_relogin_localeAlreadySet(self):
        """No packet actualy does a relogin, this covers it 'by-hand', as
        it were."""
        from pokernetwork import pokeravatar

        service = PokerAvatarNoClientServerTestCase.MockService()
        avatar = pokeravatar.PokerAvatar(service)
        explain = PokerAvatarNoClientServerTestCase.MockExplain()
        saveExplain = avatar.explain
        avatar.explain = explain

        avatar.relogin(1042)
        self.assertEquals(avatar.user.serial, 1042)
        self.assertEquals(avatar.user.name, 'Doyle Brunson')
        self.assertEquals(avatar.user.url, "http://example.org/")
        self.assertEquals(avatar.user.outfit, "naked")
        self.assertEquals(avatar.user.privilege, pokeravatar.User.REGULAR)
        self.assertEquals(avatar.tourneys, "MOCKPLACES")

        self.assertEquals([avatar], service.avatar_collection.get(1042))

        avatar.explain = saveExplain

        self.assertEquals(len(explain.handleSerialPackets), 1)
        self.assertEquals(explain.handleSerialPackets[0].serial, 1042)
        self.assertEquals(explain.handleSerialPackets[0].type, PACKET_SERIAL)

        self.assertEquals(avatar.localeFunc("DUMMY"), "MYTRANSLATION")
    # ------------------------------------------------------------------------
    def test03_relogin_localeNotFound(self):
        """No packet actualy does a relogin, this covers it 'by-hand', as
        it were."""
        from pokernetwork import pokeravatar

        service = PokerAvatarNoClientServerTestCase.MockService()
        def transFunc(l, codeset = ''): return None
        service.locale2translationFunc = transFunc
        avatar = pokeravatar.PokerAvatar(service)
        explain = PokerAvatarNoClientServerTestCase.MockExplain()
        saveExplain = avatar.explain
        avatar.explain = explain

        avatar.relogin(1042)
        self.assertEquals(avatar.user.serial, 1042)
        self.assertEquals(avatar.user.name, 'Doyle Brunson')
        self.assertEquals(avatar.user.url, "http://example.org/")
        self.assertEquals(avatar.user.outfit, "naked")
        self.assertEquals(avatar.user.privilege, pokeravatar.User.REGULAR)
        self.assertEquals(avatar.tourneys, "MOCKPLACES")

        self.assertEquals([avatar], service.avatar_collection.get(1042))

        avatar.explain = saveExplain

        self.assertEquals(len(explain.handleSerialPackets), 1)
        self.assertEquals(explain.handleSerialPackets[0].serial, 1042)
        self.assertEquals(explain.handleSerialPackets[0].type, PACKET_SERIAL)

        self.assertEquals(None, avatar.localeFunc)

    # ------------------------------------------------------------------------
    def test04_relogin_avatarExists(self):
        """relogin is called where an avatar already exists."""
        from pokernetwork import pokeravatar

        serial = 1042

        service = PokerAvatarNoClientServerTestCase.MockService()
        def transFunc(l, codeset = ''): return None
        service.locale2translationFunc = transFunc
        avatar_first = pokeravatar.PokerAvatar(service)
        #
        # pre-existing avatar
        #
        avatar_second = pokeravatar.PokerAvatar(service)
        service.avatar_collection.add(serial, avatar_second)

        explain = PokerAvatarNoClientServerTestCase.MockExplain()
        saveExplain = avatar_first.explain
        avatar_first.explain = explain

        avatar_first.relogin(serial)

        self.assertEquals(avatar_first.user.serial, serial)
        self.assertEquals(avatar_first.user.name, 'Doyle Brunson')
        self.assertEquals(avatar_first.user.url, "http://example.org/")
        self.assertEquals(avatar_first.user.outfit, "naked")
        self.assertEquals(avatar_first.user.privilege, pokeravatar.User.REGULAR)
        self.assertEquals(avatar_first.tourneys, "MOCKPLACES")

        self.assertEquals([avatar_second, avatar_first], service.avatar_collection.get(serial))

        avatar_first.explain = saveExplain

        self.assertEquals(len(explain.handleSerialPackets), 1)
        self.assertEquals(explain.handleSerialPackets[0].serial, serial)
        self.assertEquals(explain.handleSerialPackets[0].type, PACKET_SERIAL)

        self.assertEquals(None, avatar_first.localeFunc)

    # ------------------------------------------------------------------------
    def test05_explain_throws(self):
        """explain throws cause the explain instance to be discarded
        and the avatar do be destroyed."""

        from pokernetwork import pokeravatar

        serial = 1042

        service = PokerAvatarNoClientServerTestCase.MockService()
        def forceAvatarDestroyMockup(avatar):
            forceAvatarDestroyMockup.called = True
        service.forceAvatarDestroy = forceAvatarDestroyMockup
        avatar = pokeravatar.PokerAvatar(service)
        class Explain:
            def explain(self, what):
                raise Exception("FAILURE")
        clear_all_messages()
        avatar.explain = Explain()
        avatar.queuePackets()
        avatar.sendPacket(Packet())
        packets = avatar.resetPacketsQueue()
        self.assertEquals(PACKET_ERROR, packets[0].type)
        self.assertSubstring('FAILURE', packets[0].message)
        self.assertEquals(True, search_output('FAILURE'))
        self.assertEquals(None, avatar.explain)
        self.assertEquals(True, forceAvatarDestroyMockup.called)
##############################################################################
settings_xml_table_picker_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="2000" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <language value="en_US.ISO-8859-1"/>
  <language value="fr_FR.ISO-8859-1"/>

  <table name="NL HE 10-max 100/200" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="NL HE 6-max 100/200" variant="holdem" betting_structure="100-200-no-limit" seats="6" player_timeout="60" currency_serial="1" />
  <table name="Limit HE 10-max 2/4" variant="holdem" betting_structure="2-4-limit" seats="10" player_timeout="60" currency_serial="2" />
  <table name="Limit HE 6-max 2/4" variant="holdem" betting_structure="2-4-limit" seats="6" player_timeout="60" currency_serial="2" />
  <table name="Stud 8-max 2/4" variant="7stud" betting_structure="2-4-limit" seats="8" player_timeout="60" currency_serial="2" />
  <table name="Play Money NL HE 10-max 1/2" variant="holdem" betting_structure="1-2-no-limit" seats="10" player_timeout="60" currency_serial="0" />
  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes"/>
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <tourney_select_info>%(script_dir)s/testtourney_select_info.py</tourney_select_info>
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}
# -----------------------------------------------------------------------------
class PokerAvatarTablePickerBaseClass(PokerAvatarTestCaseBaseClass):
    # Timeout needs to be higher for this test case because some of the
    # later tests add so many clients that 240 isn't enough.
    #timeout = 540
    timeout = 2000
    # -------------------------------------------------------------------------
    def setUpServer(self):
        PokerAvatarTestCaseBaseClass.setUpServer(self, settings_xml_table_picker_server)
    # -------------------------------------------------------------------------
    def setMoneyForPlayer(self, (client, packet), id, currency_serial, setting, gameId):
        table = self.service.getTable(gameId)
        game = table.game
        amount = 0
        if setting == "under_min":
            amount = game.buyIn() - 1
        elif setting == "over_min_under_best":
            amount = game.buyIn() + 1
        elif setting == "min":
            amount = game.buyIn()
        elif setting == "best":
            amount = game.bestBuyIn()
        elif setting == "over_best":
            amount = game.bestBuyIn() +1
        else:
            self.fail("Unknown setting for setMoneyForPlayer: %s" % setting)

        cursor = self.service.db.cursor()
        sql =  "DELETE FROM user2money WHERE user_serial = " + str(client.getSerial())
        cursor.execute(sql)
        sql = "INSERT INTO user2money(amount, user_serial, currency_serial) VALUES(%s, %s, %s)" % (str(amount),  str(client.getSerial()), str(currency_serial))
        cursor.execute(sql)
        cursor.close()
        return (client, packet)
    # ------------------------------------------------------------------------
    def tablePickerFails(self, (client, packet), id, numPlayers = 0, currencySerial = 0,
                         variant = '', structure = '', gameId = 0):
        avatar = self.service.avatars[id]
        avatar.queuePackets()
        avatar.handlePacketLogic(PacketPokerTablePicker(serial = client.getSerial(),
                                                        min_players = numPlayers,
                                                        currency_serial = currencySerial,
                                                        variant = variant,
                                                        betting_structure = structure))
        found = 0
        for packet in avatar.resetPacketsQueue():
            found += 1
            if packet.type == PACKET_POKER_ERROR:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                self.assertEquals(packet.other_type, PACKET_POKER_TABLE_PICKER)
                self.assertEquals(packet.code, PacketPokerTableJoin.GENERAL_FAILURE)
                self.failUnless(len(packet.message) > 0,
                                "some message should be included")
            else:
                self.fail("Unexpected packet found when only PACKET_POKER_ERROR"
                          + " was expected: " + packet.__str__())
        self.assertEquals(found, 1, "expected only PACKET_POKER_ERROR")
        return (client, packet)
    # -------------------------------------------------------------------------
    def tablePickerSucceeds(self, (client, packet), id, numPlayers, currencySerial,
                            variant, structure, gameId, gameName, autoBlindAnte = False):
        table = self.service.getTable(gameId)

        # Save the amount of money the player has, because, later, we may
        # will need that number to check that the right amount of money
        # was used at the table.

        preBuyInBalance = self.service.getMoney(client.getSerial(), table.currency_serial)

        avatars = self.service.avatar_collection.get(client.getSerial())
        self.failUnless(len(avatars) ==  1, "Only one avatar should have this serial")
        avatar = avatars[0]
        avatar.queuePackets()
        avatar.handlePacketLogic(
            PacketPokerTablePicker(serial = client.getSerial(),
                                   currency_serial = currencySerial,
                                   min_players = numPlayers,
                                   variant = variant,
                                   betting_structure = structure,
                                   auto_blind_ante = autoBlindAnte))
        total = 7
        if autoBlindAnte: total += 1
        found = 0
        seatNumber = None
        # next three vars for implementing tests about buyIn amounts.  See
        # details after loop
        amountBoughtIn = None
        bestBuyInAmount = None
        minBuyInAmount = None
        for packet in avatar.resetPacketsQueue():
            if packet.type == PACKET_POKER_TABLE:
                found += 1
                self.assertEquals(packet.reason, PacketPokerTable.REASON_TABLE_PICKER)
                for  (kk, vv) in avatar.tables.items():
                    self.assertEquals(vv.game.id, table.game.id)
                    self.assertEquals(vv.game.name, gameName)
                    for ourVariant in [ vv.game.variant, packet.variant ]:
                        if variant != '':
                            self.assertEquals(ourVariant, variant)
                        else:
                            self.failUnless(ourVariant in [ 'holdem', '7stud' ])
                    for ourStruct in [ packet.betting_structure, vv.game.betting_structure ]:
                        if structure != '':
                            self.assertEquals(ourStruct, structure)
                        else:
                            self.failUnless(ourStruct in [ '100-200-no-limit',
                                                             '2-4-limit' ],
                                "strange struct: \"" + ourStruct + "\"")
                    self.failUnless(vv.game.max_players in [ 8, 10, 6 ])
            elif packet.type == PACKET_POKER_SEATS:
                self.assertEquals(packet.game_id, table.game.id)
                # Ignore ones that are not about this user
                if client.getSerial() not in packet.seats:
                    continue

                found += 1
                # Allow for the case where PACKET_POKER_SEATS and
                # PACKET_POKER_PLAYER_ARRIVE can come out of order.  Set
                # seatNumber by the one that comes first.
                if seatNumber != None:
                    self.assertEquals(packet.seats[seatNumber], client.getSerial())
                else:
                    for ss in range(0, len(packet.seats)):
                        if packet.seats[ss] == client.getSerial():
                            seatNumber = ss
                            break
                    self.failIf(seatNumber == None, "seat not found in packet.seats on PACKET_POKER_SEATS")
            elif packet.type == PACKET_POKER_PLAYER_ARRIVE:
                self.assertEquals(packet.game_id, table.game.id)
                # Ignore ones that are not about this user
                if packet.serial != client.getSerial():
                    continue
                found += 1
                self.assertEquals(packet.name, "user%d" % id)
                self.assertEquals(packet.serial, client.getSerial())
                if seatNumber != None:
                    self.assertEquals(packet.seat, seatNumber)
                else:
                    seatNumber = packet.seat
                self.failIf(seatNumber == None, "invalid seat in PACKET_POKER_PLAYER_ARRIVE")
            elif packet.type == PACKET_POKER_PLAYER_CHIPS:
                self.assertEquals(packet.game_id, table.game.id)
                # Ignore ones that are not about this user
                if packet.serial != client.getSerial():
                    continue

                found += 1
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.bet, 0)
                amountBoughtIn = int(packet.money)
            elif packet.type == PACKET_POKER_BUY_IN_LIMITS:
                found += 1
                for key in [ 'best', 'game_id', 'min', 'max' ]:
                    self.failUnless(hasattr(packet, key), "BUY_IN_LIMITS packet missing key" + key)
                bestBuyInAmount = packet.best
                minBuyInAmount = packet.min
            elif packet.type == PACKET_POKER_SIT:
                self.assertEquals(packet.game_id, gameId)
                if packet.serial == client.getSerial():
                    found += 1
            elif packet.type == PACKET_POKER_AUTO_BLIND_ANTE:
                self.assertEquals(packet.serial, client.getSerial())
                self.assertEquals(packet.game_id, gameId)
                found += 1
                self.failUnless(autoBlindAnte,
                        "should not see an autoBlindAnte since it was not asked for")

        self.assertEquals(found, total,
                          "only found %d packet (if that's just 1, then likely the table pick failed rather than succeeded" % found)

        # Regarding stuff below: the rule is, as described in
        # pokerpackets.py, that if the player had enough money in this
        # currency to buy in for the 'best' amount, then that is how much
        # should be bought in for, otherwise the 'min' should be used.  We
        # cached the amount of money that the player had before sending
        # TablePicker packet, so that we can now determine if that process
        # happened correctly.

        # start with a sanity check that the packets came and buy in was correct
        self.failIf(amountBoughtIn == None or amountBoughtIn <= 0,
                    "Never got PACKET_POKER_PLAYER_CHIPS with amount bought in")

        self.failIf(bestBuyInAmount == None or bestBuyInAmount <= 0,
                    "best buy in amount is undefined or 0")
        self.failIf(minBuyInAmount == None or minBuyInAmount <= 0,
                    "min buy in amount is undefined or 0")
        if table.currency_serial > 0:
            self.assertEquals(preBuyInBalance - amountBoughtIn,
                              self.service.getMoney(client.getSerial(), table.currency_serial))
        # Next, we should never have been allowed to buy in at a table with
        # a minimum less than we have.
        self.failUnless(preBuyInBalance > minBuyInAmount)
        # Next, check algorithm on how much to buy in for when picker is in use worked.
        if preBuyInBalance >= bestBuyInAmount:
            self.assertEquals(bestBuyInAmount, amountBoughtIn)
        else:
            self.assertEquals(minBuyInAmount, amountBoughtIn)
        return (client, packet)
    # ------------------------------------------------------------------------
    def dummyTableCanAddPlayer(self, (client, packet), tableNumber):
        table = self.service.getTable(tableNumber)
        self.savedCanAddPlayer = table.game.canAddPlayer
        def mockCanAddPlayer(serial):
            return False
        table.game.canAddPlayer = mockCanAddPlayer

        return (client, packet)
    # ------------------------------------------------------------------------
    def restoreTableCanAddPlayer(self, (client, packet), tableNumber):
        table = self.service.getTable(tableNumber)
        table.game.canAddPlayer  = self.savedCanAddPlayer

        return (client, packet)
    # ------------------------------------------------------------------------
    def startPlayerSeatedAndPlaying(self, result, tableNumber, tableName,
                                    tableStructure, variant, maxPlayers, currencySerial):
        playerNumber = self.createClient()
        d = self.client_factory[playerNumber].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, playerNumber)
        d.addCallback(self.setMoneyForPlayer, playerNumber, currencySerial,
                      "over_min_under_best", tableNumber)
        d.addCallback(self.joinTable, playerNumber, tableNumber,
                      tableName, tableStructure,
                      variant = variant, max_players = maxPlayers)
        d.addCallback(self.seatTable, playerNumber, tableNumber, seatNumber = -1)
        d.addCallback(self.buyInTable, playerNumber, tableNumber,
                      self.service.getTable(tableNumber).game.buyIn())
        d.addCallback(self.autoBlindAnte, playerNumber, tableNumber)
        d.addCallback(self.sitTable, playerNumber, tableNumber)
        d.addCallback(self.readyToPlay, playerNumber, tableNumber)

        return d
    # ------------------------------------------------------------------------
    def preparePlayerForTablePickerSend(self, playerNumber):
        playerNumber_confirm = self.createClient()
        assert playerNumber_confirm == playerNumber
        d = self.client_factory[playerNumber].established_deferred
        d.addCallback(self.sendExplain)
        d.addCallback(self.sendRolePlay)
        d.addCallback(self.login, playerNumber)

        return d
class PokerAvatarTablePickerTestCase(PokerAvatarTablePickerBaseClass):
    # ------------------------------------------------------------------------
    def test00_tablePicker_failure_by_min(self):
        playerNumber = len(self.client_factory)
        playerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
        playerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 2, "over_best", 1)
        playerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_best", 1)

        playerDeferred.addCallback(self.tablePickerFails, playerNumber, 100, 0,
                                    "holdem", "2-4-limit")
        return playerDeferred
    # ------------------------------------------------------------------------
    def test01_tablePicker_failure_by_variant(self):
        playerNumber = len(self.client_factory)
        playerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
        playerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 2, "over_best", 1)
        playerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_best", 1)
        playerDeferred.addCallback(self.tablePickerFails, playerNumber, 0, 0,
                                    "badugi", '')
        return playerDeferred
    # ------------------------------------------------------------------------
    def test02_tablePicker_failure_by_structure(self):
        playerNumber = len(self.client_factory)
        playerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
        playerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 2, "over_best", 1)
        playerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_best", 1)
        playerDeferred.addCallback(self.tablePickerFails, playerNumber, 0, 0,
                                    '', "500-1000-limit")
        return playerDeferred
    # ------------------------------------------------------------------------
    def test03_tablePicker_onlyOnePossible(self):

        d = defer.succeed(True)

        d.addCallback(self.startPlayerSeatedAndPlaying, 5, "Stud 8-max 2/4", "2-4-limit", "7stud", 8, 2)

        def check(result):
            playerNumber = len(self.client_factory)
            pickerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
            pickerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 2, "over_min_under_best", 5)
            pickerDeferred.addCallback(self.tablePickerSucceeds, playerNumber, 1, 0,
                                       "7stud", "2-4-limit", 5, "Stud 8-max 2/4",
                                       autoBlindAnte = True)
            def autodeal((client, packet), gameId):
                table = self.service.getTable(gameId)
                self.assertTrue(table.timer_info.has_key("dealTimeout"))
                return (client, packet)
            pickerDeferred.addCallback(autodeal, 5)
            return pickerDeferred
        d.addCallback(check)
        return d
    # ------------------------------------------------------------------------
    def test04_tablePicker_twoPossibleGivesMostFullWithSeats(self):
        d = defer.succeed(True)
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1)
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1)
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1)
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)
        def check(result):
            playerNumber = len(self.client_factory)
            pickerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
            pickerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_best", 1)
            pickerDeferred.addCallback(self.tablePickerSucceeds, playerNumber, 3, 0,
                                       "holdem", "100-200-no-limit", 2, "NL HE 6-max 100/200")
            return pickerDeferred
        d.addCallback(check)
        return d
    # ------------------------------------------------------------------------
    def test05_tablePicker_emptyTableLowestNumberWhenEverythingIsEmpty(self):
        playerNumber = len(self.client_factory)
        playerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
        playerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_best", 1)
        playerDeferred.addCallback(self.tablePickerSucceeds, playerNumber, 0, 0,
                                    '', '', 1, "NL HE 10-max 100/200")
        return playerDeferred
    # ------------------------------------------------------------------------
    def test06_tablePicker_shouldNoticeWhenSitOutMakesTableBadChoice(self):
        d = defer.succeed(True)
        table = self.service.getTable(1)
        table.autodeal = False
        table = self.service.getTable(2)
        table.autodeal = False
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 0
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 1
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 2
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 3
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 4
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 5
        d.addCallback(self.sitOut, 5, 2)
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 6
        d.addCallback(self.sitOut, 6, 2)
        def check(result):
            playerNumber = len(self.client_factory)
            pickerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
            pickerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_min_under_best", 2)
            pickerDeferred.addCallback(self.tablePickerSucceeds, playerNumber, 3, 0,
                                       "holdem", "100-200-no-limit", 1, "NL HE 10-max 100/200")
            return pickerDeferred
        d.addCallback(check)
        return d
    # ------------------------------------------------------------------------
    def test07_tablePicker_shouldNotPickFullTableEvenIfPlayerSitsOut(self):
        d = defer.succeed(True)
        table = self.service.getTable(1)
        table.autodeal = False
        table = self.service.getTable(2)
        table.autodeal = False
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 0
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 1
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 2
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 3
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 4
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 5
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 6
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 7
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 8
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 9
        d.addCallback(self.sitOut, 9, 1)
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 10
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 11
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 12

        def check(result):
            playerNumber = len(self.client_factory)
            pickerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
            pickerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_best", 1)
            pickerDeferred.addCallback(self.tablePickerSucceeds, playerNumber, 3, 0,
                                       "holdem", "100-200-no-limit", 2, "NL HE 6-max 100/200")
            return pickerDeferred
        d.addCallback(check)
        return d
    # ------------------------------------------------------------------------
    def test08_tablePicker_failureBecauseAllTablesMeetingCriteriaAreFull(self):
        d = defer.succeed(True)
        table = self.service.getTable(1)
        table.autodeal = False
        table = self.service.getTable(2)
        table.autodeal = False
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 0
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 1
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 2
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 3
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 4
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 5
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 6
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 7
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 8
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 9
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 10
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 11
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 12
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 13
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 14
        d.addCallback(self.startPlayerSeatedAndPlaying, 2, "NL HE 6-max 100/200", "100-200-no-limit", "holdem", 6, 1)   # 15

        def check(result):
            playerNumber = len(self.client_factory)
            pickerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
            pickerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_best", 1)
            pickerDeferred.addCallback(self.tablePickerFails, playerNumber, 3, 0,
                                       "holdem", "100-200-no-limit")
            return pickerDeferred
        d.addCallback(check)
        return d
    # ------------------------------------------------------------------------

    def test09_tablePicker_noTableDueToLackofFunds(self):
        d = defer.succeed(True)
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 0
        def check(result):
            playerNumber = len(self.client_factory)
            pickerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
            pickerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "under_min", 1)
            pickerDeferred.addCallback(self.tablePickerFails, playerNumber, 1, 0,
                                       "holdem", "100-200-no-limit")
            return pickerDeferred
        d.addCallback(check)
        return d
    # ------------------------------------------------------------------------
    def test10_tablePicker_sitOutCausesNoMatchesFound(self):
        playerNumber = len(self.client_factory)
        pickerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
        pickerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_best", 1)
        pickerDeferred.addCallback(self.tablePickerFails, playerNumber, 1, 0,
                                   "holdem", "100-200-no-limit")
        return pickerDeferred
    # ------------------------------------------------------------------------
    def test11_tablePicker_failureFromTableCannotAddPlayer(self):
        d = defer.succeed(True)
        d.addCallback(self.startPlayerSeatedAndPlaying, 1, "NL HE 10-max 100/200", "100-200-no-limit", "holdem", 10, 1) # 0
        def check(result):
            playerNumber = len(self.client_factory)
            pickerDeferred = self.preparePlayerForTablePickerSend(playerNumber)
            pickerDeferred.addCallback(self.setMoneyForPlayer, playerNumber, 1, "over_best", 1)
            pickerDeferred.addCallback(self.dummyTableCanAddPlayer, 1)
            pickerDeferred.addCallback(self.tablePickerFails, playerNumber, 1, 0,
                                       "holdem", "100-200-no-limit", 1)
            pickerDeferred.addCallback(self.restoreTableCanAddPlayer, 1)
            return pickerDeferred
        d.addCallback(check)
        return d
##############################################################################
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test02"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerAvatarLocaleTestCase))
    suite.addTest(loader.loadClass(PokerAvatarTestCase))
    suite.addTest(loader.loadClass(PokerAvatarNoClientServerTestCase))
    suite.addTest(loader.loadClass(PokerAvatarTablePickerTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# ------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokeravatar.py ) ; ( cd ../tests ; make VERBOSE_T=-1 COVERAGE_FILES='../pokernetwork/pokeravatar.py' TESTS='coverage-reset test-pokeravatar.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerbot
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2010 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import os
import sys
sys.path.insert(0, "./..")
sys.path.insert(0, "..")

from twisted.trial import unittest, runner, reporter

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

import tempfile
from pokernetwork import pokerbot
from twisted.application import service
from twisted.internet import defer

settings_xml_bots_generated = """<?xml version="1.0" encoding="ISO-8859-1"?>
<settings xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="poker-bot.xsd" delays="false" wait="1" reconnect="yes" watch="no" level="1" cash_in="no" ping="10" verbose="0" no_display_packets="yes" rebuy="yes" name_prefix="BOT" poker_network_version="2.0.0">
  <delays position="0" begin_round="0" end_round="0" end_round_last="0" showdown="5" lag="15"/>
  <name>test</name>
  <passwd>test</passwd>
  <servers>hostname:19380</servers>
  <muck>yes</muck>
  <auto_post>yes</auto_post>
  <currency id="1">/usr/bin/wget wget --quiet -O - 'http://pokersource.info/poker-web/currency_one.php?id=1&amp;command=get_note&amp;value=5000000&amp;count=100&amp;autocommit=yes'</currency>
  <path>/etc/poker-engine</path>

  <table name="One" count="4"/>

  <tournament name="sitngo4" count="4"/>

</settings>
"""

settings_xml_bots_named = """<?xml version="1.0" encoding="ISO-8859-1"?>
<settings xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="poker-bot.xsd" delays="false" wait="1" reconnect="yes" watch="no" level="1" cash_in="no" ping="10" verbose="0" no_display_packets="yes" rebuy="yes" name_prefix="BOT" poker_network_version="2.0.0">
  <delays position="0" begin_round="0" end_round="0" end_round_last="0" showdown="5" lag="15"/>
  <name>test</name>
  <passwd>test</passwd>
  <servers>hostname:19380</servers>
  <muck>yes</muck>
  <auto_post>yes</auto_post>
  <currency id="1">/usr/bin/wget wget --quiet -O - 'http://pokersource.info/poker-web/currency_one.php?id=1&amp;command=get_note&amp;value=5000000&amp;count=100&amp;autocommit=yes'</currency>
  <path>/etc/poker-engine</path>

  <table name="One">
        <bot name="foo1" password="bar1" />
        <bot name="foo2" password="bar2" />
        <bot name="foo3" password="bar3" />
  </table>

  <tournament name="sitngo4">
        <bot name="foo4" password="bar4" />
        <bot name="foo5" password="bar5" />
  </tournament>

</settings>
"""

class PokerBotTestCase(unittest.TestCase):
    def setUp(self):
        self.tmpdir = tempfile.mkdtemp()
        self.filename = os.path.join(self.tmpdir, "poker.server.xml")

    def createConfig(self, config):
        f = open(self.filename, "w")
        f.write(config)
        f.close()

    def test01_generated(self):
        self.createConfig(settings_xml_bots_generated)
        services = pokerbot.makeService(self.filename)
        self.assertEquals(8, len([s for s in services]))

    def test02_named(self):
        self.createConfig(settings_xml_bots_named)
        services = pokerbot.makeService(self.filename)
        factories = [s.args[2] for s in services]
        self.assertEquals(5, len(factories))
        for i, f in enumerate(factories):
            self.assertEquals('foo%s' % (i+1), f.name)
            self.assertEquals('bar%s' % (i+1), f.password)
        factories[0].reconnect = True
        factories[0].went_broke = True
        d = defer.Deferred()
        class DummyConnector:
            def connect(self):
                d.callback(None)
        factories[0].clientConnectionLost(DummyConnector(), 'reason')
        self.assertEquals('foo1', factories[0].name)
        return d

# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test01"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerBotTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerbot.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerbot.py' TESTS='coverage-reset test-pokerbot.py coverage-report' check )"
# End:


########NEW FILE########
__FILENAME__ = test-pokerbotlogic
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import os
import sys
sys.path.insert(0, "./..")
sys.path.insert(0, "..")

from twisted.trial import unittest, runner, reporter

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokernetwork.pokerbotlogic import StringGenerator, NoteGenerator, PokerBot

class StringGeneratorTestCase(unittest.TestCase):

    def test_all(self):
        generator = StringGenerator("PREFIX")
        generator.command = "echo USERONE ; echo USERTWO"
        self.assertEqual("PREFIXUSERTWO", generator.getName())
        self.assertEqual(1, len(generator.pool))
        self.assertEqual("USERONE", generator.getPassword())
        self.assertEqual(0, len(generator.pool))
        generator.command = ""
        self.failUnlessRaises(UserWarning, generator.getName)

class NoteGeneratorTestCase(unittest.TestCase):

    def test_all(self):
        generator = NoteGenerator("printf 'one\ttwo\n' ; printf 'three\tfour\n'")
        self.assertEqual(['three', 'four'], generator.getNote())
        self.assertEqual(['one', 'two'], generator.getNote())
        generator.command = ""
        self.failUnlessRaises(UserWarning, generator.getNote)

# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test40"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(StringGeneratorTestCase))
    suite.addTest(loader.loadClass(NoteGeneratorTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerbotlogic.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerbotlogic.py' TESTS='coverage-reset test-pokerbotlogic.py coverage-report' check )"
# End:


########NEW FILE########
__FILENAME__ = test-pokercashier
#!/usr/bin/python
# -*- py-indent-offset: 4; coding: iso-8859-1; mode: python -*-
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)             2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2006             Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>

import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import libxml2
from MySQLdb.cursors import DictCursor
from pprint import pprint

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages, get_messages, clear_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokernetwork import pokercashier, pokernetworkconfig, user
from pokernetwork import currencyclient
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerpackets import *
from pokernetwork.pokerdatabase import PokerDatabase

settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="3">
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
</server>
""" % {'script_dir': SCRIPT_DIR}

class PokerCashierTestCase(unittest.TestCase):
    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    # --------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        self.settings.header = self.settings.doc.xpathNewContext()
        self.db = PokerDatabase(self.settings)
        self.cashier = pokercashier.PokerCashier(self.settings)
        self.cashier.setDb(self.db)
        self.user_serial = 5050
        self.user1_serial = 6060
        self.user2_serial = 7070
        self.user3_serial = 8080
        self.users_serial = range(9000, 9010)

    # --------------------------------------------------------
    def tearDown(self):
        self.cashier.close()
#        self.destroyDb()

    # --------------------------------------------------------
    def test01_cashIn(self):
        #
        # Cash in <value> more from the fake currency
        #
        self.value = 100
        self.url = 'http://fake'
        packet = PacketPokerCashIn(serial = self.user_serial,
                                   url = self.url,
                                   bserial = 1,
                                   name = "%040d" % 1,
                                   value = self.value)
        d = self.cashier.cashIn(packet)
        d.addCallback(lambda result: self.check01_cashIn(packet))
        return d
    # --------------------------------------------------------
    def check01_cashIn(self, packet):
        cursor = self.db.cursor(DictCursor)

        #
        # A currency was created
        #
        cursor.execute("SELECT url, serial FROM currencies")
        self.assertEquals(1, cursor.rowcount)
        currency_row = cursor.fetchone()
        self.assertEquals(self.url, currency_row['url'])
        self.assertEquals(1, currency_row['serial'])
        #
        # With a single currency note
        #
        cursor.execute("SELECT currency_serial, serial, name, value FROM safe")
        self.assertEquals(1, cursor.rowcount)
        safe_row = cursor.fetchone()
        self.assertEquals(currency_row['serial'], safe_row['currency_serial'])
        self.assertEquals(2, safe_row['serial'])
        self.assertEquals(self.value, safe_row['value'])
        #
        # Credited to the user
        #
        cursor.execute("SELECT currency_serial, user_serial, amount FROM user2money")
        self.assertEquals(1, cursor.rowcount)
        self.user2money_row = cursor.fetchone()
        self.assertEquals(currency_row['serial'], self.user2money_row['currency_serial'])
        self.assertEquals(self.user_serial, self.user2money_row['user_serial'])
        self.assertEquals(self.value, self.user2money_row['amount'])

        cursor.close()

        return packet

    # --------------------------------------------------------
    def test02_cashIn(self):
        self.value = 100
        self.url = 'http://fake'

        note1 = self.cashier.currency_client._buildNote(self.url, self.value)
        packet1 = PacketPokerCashIn(serial = self.user1_serial,
                                    url = note1[0],
                                    bserial = note1[1],
                                    name = note1[2],
                                    value = note1[3])
        d1 = self.cashier.cashIn(packet1)

        note2 = self.cashier.currency_client._buildNote(self.url, self.value)
        packet2 = PacketPokerCashIn(serial = self.user2_serial,
                                    url = note2[0],
                                    bserial = note2[1],
                                    name = note2[2],
                                    value = note2[3])
        d2 = self.cashier.cashIn(packet2)

        note3 = self.cashier.currency_client._buildNote(self.url, self.value)
        packet3 = PacketPokerCashIn(serial = self.user3_serial,
                                    url = note3[0],
                                    bserial = note3[1],
                                    name = note3[2],
                                    value = note3[3])
        d3 = self.cashier.cashIn(packet3)

        d = defer.DeferredList((d1, d2, d3), fireOnOneErrback = True)
        d.addCallback(lambda result: self.check02_cashIn())
        return d
    # --------------------------------------------------------
    def check02_cashIn(self):
        cursor = self.db.cursor(DictCursor)

        #
        # Only one currency for all buyIn
        #
        cursor.execute("SELECT url, serial FROM currencies")
        self.assertEquals(1, cursor.rowcount)
        currency_row = cursor.fetchone()
        #
        # With a single currency note with an amount == <value> * 2
        #
        cursor.execute("SELECT currency_serial, name, serial, value FROM safe")
        self.assertEquals(1, cursor.rowcount)
        safe_row = cursor.fetchone()
        self.assertEquals(currency_row['serial'], safe_row['currency_serial'])
        self.assertEquals(7, safe_row['serial'])
        self.assertEquals(self.value * 3, safe_row['value'])
        #
        # Credited to the user1
        #
        cursor.execute("SELECT currency_serial, user_serial, amount FROM user2money WHERE user_serial = " + str(self.user1_serial))
        self.assertEquals(1, cursor.rowcount)
        user2money_row = cursor.fetchone()
        self.assertEquals(currency_row['serial'], user2money_row['currency_serial'])
        self.assertEquals(self.user1_serial, user2money_row['user_serial'])
        self.assertEquals(self.value, user2money_row['amount'])
        #
        # Credited to the user2
        #
        cursor.execute("SELECT currency_serial, user_serial, amount FROM user2money WHERE user_serial = " + str(self.user2_serial))
        self.assertEquals(1, cursor.rowcount)
        user2money_row = cursor.fetchone()
        self.assertEquals(currency_row['serial'], user2money_row['currency_serial'])
        self.assertEquals(self.user2_serial, user2money_row['user_serial'])
        self.assertEquals(self.value, user2money_row['amount'])
        #
        # Credited to the user3
        #
        cursor.execute("SELECT currency_serial, user_serial, amount FROM user2money WHERE user_serial = " + str(self.user3_serial))
        self.assertEquals(1, cursor.rowcount)
        user2money_row = cursor.fetchone()
        self.assertEquals(currency_row['serial'], user2money_row['currency_serial'])
        self.assertEquals(self.user3_serial, user2money_row['user_serial'])
        self.assertEquals(self.value, user2money_row['amount'])

        cursor.close()

    def cashOut(self, packet):
        cashOut_packet = PacketPokerCashOut(serial = packet.serial,
                                            url = packet.url,
                                            value = 15,
                                            application_data = 'appdata')
        return self.cashier.cashOut(cashOut_packet)
    # --------------------------------------------------------
    def check03_cashOut(self, packet):
        #print "check03_cashOut " + str(note)
        cursor = self.db.cursor(DictCursor)

        #
        # With two currency notes on the counter
        #
        cursor.execute("SELECT transaction_id, user_serial, currency_serial, name, serial, value, status, application_data FROM counter WHERE status = 'c'")
        self.assertEquals(1, cursor.rowcount)
        counter_row = cursor.fetchone()
        #print "counter_row " + str(counter_row)
        self.assertEquals(15, counter_row['value'])
        self.assertEquals(packet.name, counter_row['name'])
        self.assertEquals(packet.application_data, counter_row['application_data'])

        cursor.close()

        return packet
    # --------------------------------------------------------
    def cashOutCommit(self, packet):
        return self.cashier.cashOutCommit(PacketPokerCashOutCommit(transaction_id = packet.name))

    def check03_cashOutCommit(self, count):
        #print "check03_cashOutCommit " + str(count)
        cursor = self.db.cursor(DictCursor)

        cursor.execute("SELECT * FROM counter ORDER BY value")
        self.assertEquals(0, cursor.rowcount)

        cursor.close()

        return count
    # --------------------------------------------------------
    def test03_cashOut(self):
        d = self.test01_cashIn()

        d.addCallback(self.cashOut)
        d.addCallback(self.check03_cashOut)
        d.addCallback(self.cashOutCommit)
        d.addCallback(self.check03_cashOutCommit)
        return d
    # --------------------------------------------------------
    def test03_cashOut_failure(self):
        d = self.test01_cashIn()

        def cashOutFailure(packet):
            currencyclient.FakeCurrencyFailure = True
            return packet
        d.addCallback(cashOutFailure)
        d.addCallback(self.cashOut)

        self.failed = False

        def check_cashOutFailure(reason):
            currencyclient.FakeCurrencyFailure = False
            from twisted.python import failure
            from twisted.web import error
            self.failUnless(isinstance(reason, failure.Failure))
            self.failUnless(isinstance(reason.value, error.Error))
            self.assertEqual("(page content)", reason.value.response)
            self.failed = True
            return True
        d.addErrback(check_cashOutFailure)

        def check_failed(*args):
            currencyclient.FakeCurrencyFailure = False
            self.failUnless(self.failed, "cash out did not fail but was expected to fail")
            del self.failed

        d.addCallback(check_failed)

        return d
    # --------------------------------------------------------
    def cashQuery(self, packet):
        result = self.cashier.cashQuery(PacketPokerCashQuery(application_data = 'appdata'))
        self.assertEqual(PacketAck(), result)
        result = self.cashier.cashQuery(PacketPokerCashQuery(application_data = 'fakeinvalid'))
        self.assertEqual(PACKET_ERROR, result.type)
        self.assertEqual(PacketPokerCashQuery.DOES_NOT_EXIST, result.code)
        return packet
    # --------------------------------------------------------
    def test04_cashQuery(self):
        d = self.test01_cashIn()

        d.addCallback(self.cashOut)
        d.addCallback(self.cashQuery)
        return d
    # --------------------------------------------------------
    def test06_cashInMany(self):
        self.value = 100
        self.url = 'http://fake'

        dlist = []
        for serial in self.users_serial:
            note = self.cashier.currency_client._buildNote(self.url, self.value)
            packet = PacketPokerCashIn(serial = serial,
                                       url = note[0],
                                       bserial = note[1],
                                       name = note[2],
                                       value = note[3])
            dlist.append(self.cashier.cashIn(packet))

        d = defer.DeferredList(dlist, fireOnOneErrback = True)
        d.addCallback(lambda result: self.check04_cashInMany())
        return d

    def check04_cashInMany(self):
        cursor = self.db.cursor(DictCursor)

        #
        # Only one currency for all buyIn
        #
        cursor.execute("SELECT url, serial FROM currencies")
        self.assertEquals(1, cursor.rowcount)
        currency_row = cursor.fetchone()
        #
        # With a single currency note with an amount == <value> * 2
        #
        cursor.execute("SELECT currency_serial, name, serial, value FROM safe")
        self.assertEquals(1, cursor.rowcount)
        safe_row = cursor.fetchone()
        self.assertEquals(currency_row['serial'], safe_row['currency_serial'])
        count = len(self.users_serial)
        self.assertEquals(count * 2 + 1, safe_row['serial'])
        self.assertEquals(self.value * count, safe_row['value'])
        #
        # Credited to the user N
        #
        for serial in self.users_serial:
            cursor.execute("SELECT currency_serial, user_serial, amount FROM user2money WHERE user_serial = " + str(serial))
            self.assertEquals(1, cursor.rowcount)
            user2money_row = cursor.fetchone()
            self.assertEquals(currency_row['serial'], user2money_row['currency_serial'])
            self.assertEquals(serial, user2money_row['user_serial'])
            self.assertEquals(self.value, user2money_row['amount'])

        cursor.close()

    # --------------------------------------------------------
    def test07_getCurrencySerial(self):
        clear_all_messages()
        self.cashier.parameters['user_create'] = 'no';

        pe = self.failUnlessRaises(PacketError, self.cashier.getCurrencySerial, 'http://fake')
        self.assertEquals(pe.type, PACKET_ERROR)
        self.assertEquals(pe.other_type, PACKET_POKER_CASH_IN)
        self.assertEquals(pe.message,
                        'Invalid currency http://fake and user_create = no in settings.')
        self.assertEquals(pe.code, PacketPokerCashIn.REFUSED)
        self.assertEquals(get_messages(),
                          ["SELECT serial FROM currencies WHERE url = 'http://fake'"])
    # --------------------------------------------------------
    def test08_forcecashInUpdateSafeFail(self):
        self.value = 100
        self.url = 'http://fake'
        p = PacketPokerCashIn(serial = self.user_serial,
                              url = self.url, currency_serial = 1L,
                              bserial = 1, name = "%040d" % 1,
                              value = self.value)
        p.currency_serial = 1L

        gotError = False
        try:
            self.cashier.cashInUpdateSafe("OK",
                                      "0000000000000000000000000000000000000002",
                                      p)
        except PacketError, pe:
            gotError = True
            self.assertEquals(pe.code, PacketPokerCashIn.SAFE)
            self.assertEquals(pe.other_type, PACKET_POKER_CASH_IN)
            self.assertEqual(pe.message.find("INSERT INTO safe SELECT currency_serial, serial, name, value FROM counter") >= 0, True)
        self.assertEquals(gotError, True)

    # --------------------------------------------------------
    def test09_forceCashInUpdateCounter(self):
        self.value = 100
        self.url = 'http://fake'
        p = PacketPokerCashIn(serial = self.user_serial,
                              url = self.url, currency_serial = 1L,
                              bserial = 1, name = "%040d" % 1,
                              value = self.value)
        p.currency_serial = 1L

        cursor = self.db.cursor()
        cursor.execute("DROP table counter")
        cursor.close()

        gotError = False
        try:
            self.cashier.cashInUpdateCounter(
                [['http://fake', 2, '0000000000000000000000000000000000000002', 100]],
                p,
                [('http://fake', 1, '0000000000000000000000000000000000000001', 100)])

        except Exception, e:
            self.assertEquals(e[0], 1146)
            self.assertEquals(e[1], "Table 'pokernetworktest.counter' doesn't exist")
            gotError = True
        self.assertEquals(gotError, True)
    # --------------------------------------------------------
    def test10_foundCounterRowBreakingNote(self):
        self.value = 100
        self.url = 'http://fake'
        p = PacketPokerCashIn(serial = self.user_serial,
                              url = self.url, currency_serial = 1L,
                              bserial = 1, name = "%040d" % 1,
                              value = self.value)
        p.currency_serial = 1L
        cursor = self.db.cursor()
        cursor.execute("insert into counter(transaction_id, user_serial, currency_serial, serial, name, value) values('foo', %d, %d, %d, '%040d', %d)" % (self.user_serial, 1L, 1, 1, self.value))
        cursor.close()
        d = self.cashier.cashInValidateNote(1L, p)
        def check_validateNoteFailure(reason):
            from twisted.python import failure
            from twisted.web import error
            self.failUnless(isinstance(reason, failure.Failure))
            self.failUnless(isinstance(reason.value, PacketError))
            self.assertEqual(reason.value.type, PACKET_ERROR)
            self.assertEqual(reason.value.other_type, PACKET_POKER_CASH_IN)
            self.assertEqual(reason.value.message.find("INSERT INTO safe SELECT currency_serial, serial, name, value FROM counter") >= 0, True)
            return True
        d.addErrback(check_validateNoteFailure)
        return d
    # --------------------------------------------------------
    def test11_duplicateSafeEntriesForCashInValidateNote(self):
        self.value = 100
        self.url = 'http://fake'
        p = PacketPokerCashIn(serial = self.user_serial,
                              url = self.url, currency_serial = 1L,
                              bserial = 1, name = "%040d" % 1,
                              value = self.value)
        p.currency_serial = 1L
        cursor = self.db.cursor()
        cursor.execute("insert into safe(currency_serial, serial, name, value) values(%d, %d, '%040d', %d)" % (1L, 1, 1, self.value))
        cursor.execute("insert into safe(currency_serial, serial, name, value) values(%d, %d, '%040d', %d)" % (1L, 2, 1, self.value))
        cursor.close()
        gotError = False
        try:
            self.cashier.cashInValidateNote(1L, p)
            self.assertEquals("This line should not be reached", False)
        except PacketError, pe:
            gotError = True
            self.assertEquals(pe.other_type, PACKET_POKER_CASH_IN)
            self.assertEquals(pe.code, PacketPokerCashIn.SAFE)
            self.assertEqual(pe.message.find("found 2 records instead of 0 or 1") >= 0, True)
        self.assertEquals(gotError, True)
        return True
    # --------------------------------------------------------
    def test12_cashOutCollectWithoutTransaction(self):
        gotError = False
        self.assertEquals(self.cashier.cashOutCollect(1L, None), None)
        return True
    # --------------------------------------------------------
    def test13_cashOutUpdateSafeTest(self):
        gotError = False
        try:
            self.cashier.cashOutUpdateSafe(None, 1, 1)
            self.assertEquals("This line should not be reached", False)
        except PacketError, pe:
            gotError = True
            self.assertEquals(pe.other_type, PACKET_POKER_CASH_OUT)
            self.assertEquals(pe.code, PacketPokerCashOut.SAFE)
            self.assertEqual(pe.message.find("affected 0 records") >= 0, True)
        self.assertEquals(gotError, True)
        return True
    # --------------------------------------------------------
    def test14_cashOutUpdateSafeSecondPartFails(self):
        self.value = 100
        self.url = 'http://fake'
        cursor = self.db.cursor()
        cursor.execute("insert into safe(currency_serial, serial, name, value) values(%d, %d, '%040d', %d)" % (1L, 1, 1, self.value))

        cursor.execute("insert into counter(transaction_id, user_serial, currency_serial, serial, name, value, status) values(%d, %d, %d, %d, '%040d', %d, '%s')" % (2, 2, 1, 2L, 2, self.value, 'n'))
        cursor.execute("insert into counter(transaction_id, user_serial, currency_serial, serial, name, value, status) values(%d, %d, %d, %d, '%040d', %d, '%s')" % (1, 1, 1, 1L, 1, self.value, 'c'))
        cursor.execute("insert into currencies(url, serial) values('%s', %d)" % ('http://fake', 1))
        cursor.close()
        self.closuredCount = 0
        def dummyCashOutCollect(currency_serial, trans_id):
            self.closuredCount += 1
            if self.closuredCount == 1:
                return None
            else:
                return PacketPokerCashOut(serial = 5, url = 'http://fake',
                                          bserial = 5, name = "5", value = 5,
                                          application_data = "dummy")
        origCashOutCollect = self.cashier.cashOutCollect
        self.cashier.cashOutCollect = dummyCashOutCollect

        gotError = False
        try:
            self.cashier.cashOutUpdateSafe(None, 1L, 1)
            self.assertEquals("This line should not be reached", False)
        except PacketError, pe:
            gotError = True
            self.assertEquals(pe.other_type, PACKET_POKER_CASH_OUT)
            self.assertEquals(pe.code, PacketPokerCashOut.SAFE)
            self.assertEqual(pe.message.find("UPDATE user2money SET amount") >= 0,
                             True)
            self.assertEqual(pe.message.find("affected 0 records instead of 1") >= 0,
                             True)
        self.assertEquals(gotError, True)
        self.cashier.cashOutCollect = origCashOutCollect
        return True
# --------------------------------------------------------
# Following tests use a MockDB rather than the real MySQL database
class PokerCashierFakeDBTestCase(unittest.TestCase):
    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    # --------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        self.settings.header = self.settings.doc.xpathNewContext()
        self.cashier = pokercashier.PokerCashier(self.settings)
        self.user_serial = 5050
        self.user1_serial = 6060
        self.user2_serial = 7070
        self.user3_serial = 8080
        self.users_serial = range(9000, 9010)

    # --------------------------------------------------------
    def tearDown(self):
        self.cashier.close()
#        self.destroyDb()
    # --------------------------------------------------------
    def test01_getCurrencySerial_forceExceptionOnRowCount(self):
        clear_all_messages()
        self.cashier.parameters['user_create'] = 'yes'
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
            def close(cursorSelf): pass
            def execute(*args):
                self = args[0]
                sql = args[1]
                if sql.find('SELECT') >= 0:
                    self.rowcount = 0
                elif sql.find('INSERT') >= 0:
                    self.rowcount = 0
                else:
                    self.failIf(True)  # Should not be reached.
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
            def cursor(dbSelf):
                return MockCursor()

        self.cashier.setDb(MockDatabase())

        caughtExeption = False
        try:
            self.cashier.getCurrencySerial("http://example.org")
            self.failIf(True)
        except Exception, e:
            caughtExeption = True
            self.assertEquals(e.__str__(), "SQL command 'INSERT INTO currencies (url) VALUES (%s)' failed without raising exception.  Underlying DB may be severely hosed")
        self.failUnless(caughtExeption)

        self.assertEquals(get_messages(), ['SELECT serial FROM currencies WHERE url = http://example.org', 'INSERT INTO currencies (url) VALUES (http://example.org)'])
    # --------------------------------------------------------
    def test02_getCurrencySerial_forceExceptionOnExecute(self):
        clear_all_messages()
        from MySQLdb.constants import ER
        self.cashier.parameters['user_create'] = 'yes'
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
            def close(cursorSelf): pass
            def execute(*args):
                self = args[0]
                sql = args[1]
                if sql.find('SELECT') >= 0:
                    self.rowcount = 0
                elif sql.find('INSERT INTO') >= 0:
                    raise Exception(ER.DUP_ENTRY)
                else:
                    self.failIf(True)  # Should not be reached.
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
            def cursor(dbSelf):
                return MockCursor()

        self.cashier.setDb(MockDatabase())

        caughtExeption = False
        try:
            self.cashier.getCurrencySerial("http://example.org", reentrant = False)
            self.failIf(True)
        except Exception, e:
            caughtExeption = True
            self.assertEquals(len(e.args), 1)
            self.assertEquals(e[0], ER.DUP_ENTRY)
        self.failUnless(caughtExeption)

        self.assertEquals(get_messages(), ['SELECT serial FROM currencies WHERE url = http://example.org', 'INSERT INTO currencies (url) VALUES (http://example.org)'])
    # --------------------------------------------------------
    def test03_getCurrencySerial_forceRecursionWithNoResolution(self):
        clear_all_messages()
        from MySQLdb.constants import ER
        self.cashier.parameters['user_create'] = 'yes'
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.selectCount = 0
                cursorSelf.insertCount = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                if sql.find('SELECT') >= 0:
                    self.rowcount = 0
                    cursorSelf.selectCount += 1
                elif sql.find('INSERT INTO') >= 0:
                    cursorSelf.insertCount += 1
                    raise Exception(ER.DUP_ENTRY)
                else:
                    self.failIf(True)  # Should not be reached.
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf):
                return dbSelf.cursorValue

        db = MockDatabase()
        self.cashier.setDb(db)

        caughtExeption = False
        try:
            self.cashier.getCurrencySerial("http://example.org")
            self.failIf(True)
        except Exception, e:
            caughtExeption = True
            self.assertEquals(len(e.args), 1)
            self.assertEquals(e[0], ER.DUP_ENTRY)
        self.failUnless(caughtExeption)
        self.assertEquals(db.cursor().selectCount, 2)
        self.assertEquals(db.cursor().insertCount, 2)

        self.assertEquals(get_messages(), ['SELECT serial FROM currencies WHERE url = http://example.org', 'INSERT INTO currencies (url) VALUES (http://example.org)', 'SELECT serial FROM currencies WHERE url = http://example.org', 'INSERT INTO currencies (url) VALUES (http://example.org)'])
    # --------------------------------------------------------
    def test04_cashOutUpdateSafe_twoNullPackets(self):
        """test04_cashOutUpdateSafe_forceFallThrough
        This test is handling the case where cashOutCollect() twice
        returns an empty packet in a row.  The code in cashOutUpdateSafe()
        does not actually check what is returned on the second call, but
        is wrapped in a try/except, so we catch that and make sure the
        operations."""

        clear_all_messages()
        from MySQLdb.constants import ER
        self.cashier.parameters['user_create'] = 'yes'
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'SELECT', 'INSERT INTO', 'UPDATE',
                                                  'DELETE', 'START TRANSACTION',
                                                  'COMMIT', 'ROLLBACK' ]
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        if str == "DELETE" or str == 'UPDATE':
                            cursorSelf.rowcount = 1
                        found = True
                        break
                self.failUnless(found)
                return cursorSelf.rowcount
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf):
                return dbSelf.cursorValue

        db = MockDatabase()
        self.cashier.setDb(db)

        caughtExeption = False
        try:
            packet = self.cashier.cashOutUpdateSafe("IGNORED", 5, 8)
            self.failIf(True)
        except Exception, e:
            caughtExeption = True
            self.assertEquals(len(e.args), 1)
            self.assertEquals(e[0], "'NoneType' object has no attribute 'value'")

        self.assertEquals(caughtExeption, True)
        self.assertEquals(db.cursor().counts['SELECT'], 2)
        self.assertEquals(db.cursor().counts['DELETE'], 2)
        self.assertEquals(db.cursor().counts['INSERT INTO'], 1)
        self.assertEquals(db.cursor().counts['ROLLBACK'], 1)
        self.assertEquals(db.cursor().counts['COMMIT'], 0)
    # --------------------------------------------------------
    def test05_cashOutUpdateSafe_secondPacketGood(self):
        """test05_cashOutUpdateSafe_secondPacketGood
        On the second call to cashOutCollect(), we return a valid row.
        This causes us to get back a valid packet.  But still an (ignored)
        error on the lock() not existing."""
        clear_all_messages()
        from MySQLdb.constants import ER
        self.cashier.parameters['user_create'] = 'yes'
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'SELECT', 'INSERT INTO', 'UPDATE',
                                                  'DELETE', 'START TRANSACTION',
                                                  'COMMIT', 'ROLLBACK' ]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        if str == "DELETE" or str == 'UPDATE':
                            cursorSelf.rowcount = 1
                        found = True
                        break
                self.failUnless(found)
                # The second time cashOutCollect() is called, we want to
                # return a valid set of values.
                if str == "SELECT" and cursorSelf.counts[str] == 2:
                    cursorSelf.rowcount = 1
                    cursorSelf.row = (5, "http://example.org", 5, "example", 10, "")
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf):
                return dbSelf.cursorValue

        db = MockDatabase()
        self.cashier.setDb(db)

        packet = self.cashier.cashOutUpdateSafe("IGNORED", 5, 8)
        self.assertEquals(packet.type, PACKET_POKER_CASH_OUT)
        self.assertEquals(packet.serial, 5)
        self.assertEquals(packet.url, "http://example.org")
        self.assertEquals(packet.name, "example")
        self.assertEquals(packet.bserial, 5)
        self.assertEquals(packet.value, 10)
        self.assertEquals(db.cursor().counts['SELECT'], 2)
        self.assertEquals(db.cursor().counts['DELETE'], 2)
        self.assertEquals(db.cursor().counts['INSERT INTO'], 1)
        self.assertEquals(db.cursor().counts['ROLLBACK'], 0)
        self.assertEquals(db.cursor().counts['COMMIT'], 1)
        msgs = get_messages()
        self.assertEquals(msgs[len(msgs)-1], '*ERROR* cashInUnlock: unexpected missing cash_5 in locks (ignored)')
    # --------------------------------------------------------
    def test06_cashOutUpdateSafe_forceFakeFalsePacket(self):
        """test06_cashOutUpdateSafe_forceFakeFalsePacket
        We override the second call to cashOutCollect(), so we return a
        valid row.  We force the packet returned to always be false, to
        force the final error code to operate.  """
        clear_all_messages()
        from MySQLdb.constants import ER
        self.cashier.parameters['user_create'] = 'yes'
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'SELECT', 'INSERT INTO', 'UPDATE',
                                                  'DELETE', 'START TRANSACTION',
                                                  'COMMIT', 'ROLLBACK' ]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        if str == "DELETE" or str == 'UPDATE':
                            cursorSelf.rowcount = 1
                        found = True
                        break
                self.failUnless(found)
                return cursorSelf.rowcount
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf):
                return dbSelf.cursorValue

        db = MockDatabase()
        self.cashier.setDb(db)

        global calledCount
        calledCount = 0

        class  MockPacket:
            def __init__(mockPacketSelf):
                mockPacketSelf.serial  = 5
                mockPacketSelf.value  = 10
            def __nonzero__(mockPacketSelf): return False

        def mockedcashOutCollect(currencySerial, transactionId):
            return MockPacket()

        self.cashier.cashOutCollect = mockedcashOutCollect

        packet = self.cashier.cashOutUpdateSafe("IGNORED", 5, 8)

        self.assertEquals(packet.type, PACKET_ERROR)
        self.assertEquals(packet.message, 'no currency note to be collected for currency 5')
        self.assertEquals(packet.other_type, PACKET_POKER_CASH_OUT)
        self.assertEquals(packet.code, PacketPokerCashOut.EMPTY)

        self.assertEquals(db.cursor().counts['SELECT'], 0)
        self.assertEquals(db.cursor().counts['DELETE'], 2)
        self.assertEquals(db.cursor().counts['INSERT INTO'], 1)
        self.assertEquals(db.cursor().counts['ROLLBACK'], 0)
        self.assertEquals(db.cursor().counts['COMMIT'], 1)
        msgs = get_messages()
        self.assertEquals(msgs[len(msgs)-1], '*ERROR* cashInUnlock: unexpected missing cash_5 in locks (ignored)')
    # --------------------------------------------------------
    def cashOutUpdateCounter_weirdLen(self, new_notes, message):
        clear_all_messages()
        class  MockDatabase:
            def cursor(dbSelf): return MockCursor()
        class  MockCursor: pass
        db = MockDatabase()
        self.cashier.setDb(db)

        caughtIt = False
        try:
            self.cashier.cashOutUpdateCounter(new_notes, "dummy packet")
            self.failIf(True)
        except PacketError, pe:
            caughtIt = True
            self.assertEquals(pe.type, PACKET_ERROR)
            self.assertEquals(pe.other_type, PACKET_POKER_CASH_OUT)
            self.assertEquals(pe.code, PacketPokerCashOut.BREAK_NOTE)
            self.assertEquals(pe.message, "breaking dummy packet resulted in %d notes (%s) instead of 2"
                              % (len(new_notes), message))
            self.assertEquals(get_messages(),
                              ["cashOutUpdateCounter: new_notes = %s packet = dummy packet" % message])
        self.failUnless(caughtIt)
    # --------------------------------------------------------
    def test07_cashOutUpdateCounter_weirdLen_1(self):
        self.cashOutUpdateCounter_weirdLen(['a'], "['a']")
    # --------------------------------------------------------
    def test07_cashOutUpdateCounter_weirdLen_3(self):
        self.cashOutUpdateCounter_weirdLen(['a', 'b', 'c'], "['a', 'b', 'c']")
    # --------------------------------------------------------
    def test08_cashOutUpdateCounter_various(self):
        """test08_cashOutUpdateCounter_various
        This is a somewhat goofy test in that it is covering a bunch of
        oddball situations in cashOutUpdateCounter().  First, it's
        checking for the case where the new_notes args are in order [
        user, server].  Second, it checks that when server_note's value is
        zero, only one INSERT is done.  Third, it's handling the case when
        an Exception is thrown by the execute causing a rollback. """
        self.cashier.parameters['user_create'] = 'yes'
        class MockException(Exception):
            pass
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'INSERT INTO', 'START TRANSACTION',
                                                  'COMMIT', 'ROLLBACK' ]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                if sql[:len(str)] == "INSERT INTO": raise MockException()
                return cursorSelf.rowcount
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf):
                return dbSelf.cursorValue
        class  MockPacket:
            def __init__(mockPacketSelf):
                mockPacketSelf.value  = 55
                mockPacketSelf.currency_serial = 5
                mockPacketSelf.serial = 1
                mockPacketSelf.application_data = "application"
            def __str__(mockPacketSelf): return "MOCK PACKET"

        db = MockDatabase()
        self.cashier.setDb(db)

        caughtIt = False
        clear_all_messages()
        try:
            self.cashier.cashOutUpdateCounter([ (0, 5, "joe", 55), (0, 0, "server", 0)],
                                              MockPacket())
            self.failIf(True)
        except MockException, me:
            caughtIt = True
            self.failUnless(isinstance(me, MockException))

        self.failUnless(caughtIt)
        self.assertEquals(db.cursor().counts['INSERT INTO'], 1)
        self.assertEquals(db.cursor().counts['ROLLBACK'], 1)
        self.assertEquals(db.cursor().counts['COMMIT'], 0)
        self.assertEquals(db.cursor().counts['START TRANSACTION'], 1)
        self.assertEquals(get_messages(),
                          ["cashOutUpdateCounter: new_notes = [(0, 5, 'joe', 55), (0, 0, 'server', 0)] packet = MOCK PACKET"])
    # --------------------------------------------------------
    def test09_cashOutUpdateCounter_forceRaiseOnNotesOrder(self):
        """test09_cashOutUpdateCounter_forceRaiseOnNotesOrder
        This test handles the case where new_notes do not match what is in
        the packet sent to cashOutUpdateCounter() """
        caughtIt = False
        clear_all_messages()
        class  MockPacket:
            def __init__(mockPacketSelf): mockPacketSelf.value  = 43
            def __str__(mockPacketSelf):  return "MOCK PACKET"
        class  MockDatabase:
            def cursor(mockDBSelf): return "MOCK CURSOR"
        db = MockDatabase()
        self.cashier.setDb(db)
        try:
            self.cashier.cashOutUpdateCounter([ (0, 5, "joe", 57), (0, 0, "server", 59)],
                                              MockPacket())
            self.failIf(True)
        except PacketError, pe:
            caughtIt = True
            self.failUnless(isinstance(pe, PacketError))
            self.assertEquals(pe.other_type, PACKET_POKER_CASH_OUT)
            self.assertEquals(pe.code, PacketPokerCashOut.BREAK_NOTE)
            self.assertEquals(pe.message,
                              "breaking MOCK PACKET did not provide a note with the proper value (notes are [(0, 5, 'joe', 57), (0, 0, 'server', 59)])")
        self.failUnless(caughtIt)
    # --------------------------------------------------------
    def test10_cashOutBreakNote_DeferredFromCommit(self):
        """test10_cashOutBreakNote_DeferredFromCommit
        Handle situation where the currency_serial already has an entry in
        counter table, and causes a deferred to be returned from
        cashOutCurrencyCommit()."""
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'SELECT transaction_id',
                                                  "SELECT serial FROM currencies",
                                                  "SELECT counter.user_serial"]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        cursorSelf.row = ()
                        found = True
                        break
                self.failUnless(found)
                if sql[:len(str)] == 'SELECT transaction_id':
                    cursorSelf.rowcount = 1
                    cursorSelf.row = (777,)
                elif sql[:len(str)] == "SELECT serial FROM currencies":
                    cursorSelf.rowcount = 1
                    cursorSelf.row = (6,)
                elif sql[:len(str)] == "SELECT counter.user_serial":
                    cursorSelf.rowcount = 1
                    cursorSelf.row = ( 6, "http://example.org", 9, "joe", 100, "application" )
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue
        class  MockPacket:
            def __init__(mockPacketSelf):
                mockPacketSelf.url  = "http://cashier.example.org"
                mockPacketSelf.currency_serial = 12
            def __str__(mockPacketSelf): return "MOCK PACKET"
        class  MockCurrencyClient:
            def commit(ccSelf, url, transactionId):
                self.assertEquals(url, "http://cashier.example.org")
                self.assertEquals(transactionId, 777)
                return defer.Deferred()

        db = MockDatabase()
        self.cashier.setDb(db)
        self.cashier.currency_client = MockCurrencyClient()

        clear_all_messages()
        d = self.cashier.cashOutBreakNote("MEANINGLESS ARG", MockPacket())

        for key in db.cursor().counts.keys():
            if key in [ 'SELECT transaction_id', "SELECT serial FROM currencies" ]:
                self.assertEquals(db.cursor().counts[key], 1)
            else:
                self.assertEquals(db.cursor().counts[key], 0)
        self.assertEquals(get_messages(), ['SELECT transaction_id FROM counter WHERE  currency_serial = 12', 'cashOutCurrencyCommit', 'SELECT serial FROM currencies WHERE url = http://cashier.example.org'])
        clear_all_messages()

        self.assertEquals(d.callback(True), None)
        pack = d.result
        self.assertEquals(pack.type, PACKET_POKER_CASH_OUT)
        self.assertEquals(pack.serial,  6)
        self.assertEquals(pack.url, 'http://example.org')
        self.assertEquals(pack.name, 'joe')
        self.assertEquals(pack.bserial, 9)
        self.assertEquals(pack.value, 100)
        self.assertEquals(pack.application_data, 'application')
        [self.assertEquals(db.cursor().counts[key], 1) for key in db.cursor().counts.keys()]
        msgs = get_messages()
        self.assertEquals(len(msgs), 4)
        self.assertEquals(msgs[0], 'cashOutUpdateSafe: 6 777')
        self.assertEquals(msgs[3], '*ERROR* cashInUnlock: unexpected missing cash_6 in locks (ignored)')
    # --------------------------------------------------------
    def test11_cashOutBreakNote_multirowForSerial(self):
        """test11_cashOutBreakNote_multirowForSerial

        """
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'SELECT transaction_id',
                                                  'SELECT name']
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        cursorSelf.row = ()
                        found = True
                        break
                self.failUnless(found)
                return cursorSelf.rowcount
        class MockDatabase:
            def __init__(dbSelf):
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue
        class  MockPacket:
            def __init__(mockPacketSelf):
                mockPacketSelf.url  = "http://cashier.example.org"
                mockPacketSelf.currency_serial = 12
            def __str__(mockPacketSelf): return "MOCK PACKET"
        db = MockDatabase()
        self.cashier.setDb(db)

        clear_all_messages()
        caughtIt = False
        failMsg = 'SELECT name, serial, value FROM safe WHERE currency_serial = 12 found 0 records instead of exactly 1'
        try:
            self.cashier.cashOutBreakNote("MEANINGLESS ARG", MockPacket())
            self.failIf(True)  # Should not be reached
        except PacketError, pe:
            caughtIt = True
            self.assertEquals(pe.other_type, PACKET_POKER_CASH_OUT)
            self.assertEquals(pe.type, PACKET_ERROR)
            self.assertEquals(pe.code, PacketPokerCashOut.SAFE)
            self.assertEquals(pe.message, failMsg)
        self.failUnless(caughtIt)
        msgs = get_messages()
        self.assertEquals(len(msgs), 3)
        self.assertEquals(msgs[2], "*ERROR* " + failMsg)
# --------------------------------------------------------
# Following tests are for the lock/unlock mechanism and do not need any
# database at all.
class PokerCashierLockUnlockTestCase(unittest.TestCase):
    # --------------------------------------------------------
    def setUp(self):
        from pokernetwork import pokerlock
        class  MockLock:
            def __init__(lockSelf, params):
                lockSelf.alive = False
                lockSelf.started = False
                lockSelf.acquireCounts = {}
            def isAlive(lockSelf): return lockSelf.alive
            def close(lockSelf):
                lockSelf.alive = False
                lockSelf.started = False
            def release(lockSelf, name):
                lockSelf.alive = False
                lockSelf.acquireCounts[name] -= 1
            def start(lockSelf):
                lockSelf.alive = True
                lockSelf.started = True
            def acquire(lockSelf, name, value):
                self.assertEquals(value, 5)
                if lockSelf.acquireCounts.has_key(name):
                    lockSelf.acquireCounts[name] += 1
                else:
                    lockSelf.acquireCounts[name] = 1
                return "ACQUIRED %s: %d" % (name, lockSelf.acquireCounts[name])

        pokercashier.PokerLock = MockLock
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        self.settings.header = self.settings.doc.xpathNewContext()
        self.cashier = pokercashier.PokerCashier(self.settings)
    # --------------------------------------------------------
    def tearDown(self):
        pass
    # --------------------------------------------------------
    def test01_unlockNonExistent(self):
        """test01_unlockNonExistent
        Tests when unlock is called on a serial that does not exist."""
        self.assertEquals(self.cashier.locks, {})
        clear_all_messages()
        self.assertEquals(self.cashier.unlock(5), None)
        self.assertEquals(self.cashier.locks, {})
        self.assertEquals(get_messages(), ['*ERROR* cashInUnlock: unexpected missing cash_5 in locks (ignored)'])
    # --------------------------------------------------------
    def test02_lockCreateTwice(self):
        """test02_lockCreateTwice
        Testing creation of the lock twice."""
        self.assertEquals(self.cashier.locks, {})
        clear_all_messages()
        self.assertEquals(self.cashier.lock(2), "ACQUIRED cash_2: 1")
        self.assertEquals(self.cashier.locks.keys(), ['cash_2'])
        cash2Lock = self.cashier.locks['cash_2']
        self.failUnless(cash2Lock.alive)
        self.failUnless(cash2Lock.started)
        self.assertEquals(cash2Lock.acquireCounts.keys(), [ 'cash_2' ])
        self.assertEquals(cash2Lock.acquireCounts['cash_2'], 1)
    # --------------------------------------------------------
    def test03_lockCreateTwiceWhenUnalive(self):
        """test03_lockCreateTwiceWhenUnalive
        Testing creation of the lock again after the activity is turned
        off."""
        self.assertEquals(self.cashier.locks, {})
        clear_all_messages()
        self.assertEquals(self.cashier.lock(2), "ACQUIRED cash_2: 1")
        self.assertEquals(self.cashier.locks.keys(), ['cash_2'])
        cash2Lock = self.cashier.locks['cash_2']
        self.failUnless(cash2Lock.alive)
        self.failUnless(cash2Lock.started)
        self.assertEquals(cash2Lock.acquireCounts.keys(), [ 'cash_2' ])
        self.assertEquals(cash2Lock.acquireCounts['cash_2'], 1)
        self.assertEquals(get_messages(), ['get lock cash_2'])

        clear_all_messages()
        cash2Lock.alive = False

        self.assertEquals(self.cashier.lock(2), "ACQUIRED cash_2: 1")
        self.assertEquals(self.cashier.locks.keys(), ['cash_2'])
        cash2newLock = self.cashier.locks['cash_2']
        self.failUnless(cash2newLock.alive)
        self.failUnless(cash2newLock.started)
        self.assertEquals(cash2newLock.acquireCounts.keys(), [ 'cash_2' ])
        self.assertEquals(cash2newLock.acquireCounts['cash_2'], 1)
        self.assertEquals(get_messages(), ['get lock cash_2'])
    # --------------------------------------------------------
    def test04_unlockTwice(self):
        """test03_unlockTwice
        try to unlock a lock twice"""
        self.assertEquals(self.cashier.locks, {})
        clear_all_messages()
        self.assertEquals(self.cashier.lock(2), "ACQUIRED cash_2: 1")
        self.assertEquals(self.cashier.locks.keys(), ['cash_2'])
        cash2Lock = self.cashier.locks['cash_2']
        self.failUnless(cash2Lock.alive)
        self.failUnless(cash2Lock.started)
        self.assertEquals(cash2Lock.acquireCounts.keys(), [ 'cash_2' ])
        self.assertEquals(cash2Lock.acquireCounts['cash_2'], 1)
        self.assertEquals(get_messages(), ['get lock cash_2'])

        clear_all_messages()

        self.assertEquals(self.cashier.unlock(2), None)
        self.assertEquals(self.cashier.locks.keys(), ['cash_2'])
        cash2newLock = self.cashier.locks['cash_2']
        self.failIf(cash2newLock.alive)
        self.failUnless(cash2newLock.started)
        self.assertEquals(cash2newLock.acquireCounts.keys(), [ 'cash_2' ])
        self.assertEquals(cash2newLock.acquireCounts['cash_2'], 0)
        self.assertEquals(get_messages(), [])

        self.assertEquals(self.cashier.unlock(2), None)
        self.assertEquals(self.cashier.locks.keys(), ['cash_2'])
        cash2newLock = self.cashier.locks['cash_2']
        self.failIf(cash2newLock.alive)
        self.failUnless(cash2newLock.started)
        self.assertEquals(cash2newLock.acquireCounts.keys(), [ 'cash_2' ])
        self.assertEquals(cash2newLock.acquireCounts['cash_2'], 0)
        self.assertEquals(get_messages(),
                          ['*ERROR* cashInUnlock: unexpected dead cash_2 pokerlock (ignored)'])
    # --------------------------------------------------------
    def test05_lockCreateTwiceWhenAliven(self):
        """test05_lockCreateTwiceWhenAlive
        relock after lock leaving it alive"""
        self.assertEquals(self.cashier.locks, {})
        clear_all_messages()
        self.assertEquals(self.cashier.lock(2), "ACQUIRED cash_2: 1")
        self.assertEquals(self.cashier.locks.keys(), ['cash_2'])
        cash2Lock = self.cashier.locks['cash_2']
        self.failUnless(cash2Lock.alive)
        self.failUnless(cash2Lock.started)
        self.assertEquals(cash2Lock.acquireCounts.keys(), [ 'cash_2' ])
        self.assertEquals(cash2Lock.acquireCounts['cash_2'], 1)
        self.assertEquals(get_messages(), ['get lock cash_2'])

        clear_all_messages()

        self.assertEquals(self.cashier.lock(2), "ACQUIRED cash_2: 2")
        self.assertEquals(self.cashier.locks.keys(), ['cash_2'])
        cash2newLock = self.cashier.locks['cash_2']
        self.failUnless(cash2newLock.alive)
        self.failUnless(cash2newLock.started)
        self.assertEquals(cash2newLock.acquireCounts.keys(), [ 'cash_2' ])
        self.assertEquals(cash2newLock.acquireCounts['cash_2'], 2)
        self.assertEquals(get_messages(), ['get lock cash_2'])
# --------------------------------------------------------
def GetTestSuite():
    suite = runner.TestSuite(PokerCashierTestCase)
    suite.addTest(unittest.makeSuite(PokerCashierTestCase))
    suite.addTest(unittest.makeSuite(PokerCashierFakeDBTestCase))
    suite.addTest(unittest.makeSuite(PokerCashierLockUnlockTestCase))
    return suite
# --------------------------------------------------------
def GetTestedModule():
    return pokerengineconfig

# --------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test11"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerCashierTestCase))
    suite.addTest(loader.loadClass(PokerCashierFakeDBTestCase))
    suite.addTest(loader.loadClass(PokerCashierLockUnlockTestCase))
    return runner.TrialRunner(reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# --------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokercashier.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokercashier.py' TESTS='coverage-reset test-pokercashier.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerclient
#!/usr/bin/python
# -*- py-indent-offset: 4; coding: iso-8859-1; mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)       2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2006 Mekensleep <licensing@mekensleep.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>

import sys, os, tempfile, shutil, platform
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import libxml2

import socket
import time
from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer, error, base
from twisted.python import failure, runtime

from pokerengine import pokertournament
#
# Must be done before importing pokerclient or pokerclient
# will have to be patched too.
#
from tests import testclock

from tests.testmessages import silence_all_messages, get_messages, search_output, clear_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
silence_all_messages()

twisted.internet.base.DelayedCall.debug = True

from pokernetwork import pokerservice
from pokernetwork import pokernetworkconfig
from pokernetwork import pokerclient
from pokernetwork import currencyclient
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerclientpackets import *
from tests import testlock

class ConstantDeckShuffler:
    def shuffle(self, what):
        what[:] = [40, 13, 32, 9, 19, 31, 15, 14, 50, 34, 20, 6, 43, 44, 28, 29, 48, 3, 21, 45, 23, 37, 35, 11, 5, 22, 24, 30, 27, 39, 46, 33, 0, 8, 1, 42, 36, 16, 49, 2, 10, 26, 4, 18, 7, 41, 47, 17]

from pokerengine import pokergame
pokergame.shuffler = ConstantDeckShuffler()

class ConstantPlayerShuffler:
    def shuffle(self, what):
        what.sort()

pokertournament.shuffler = ConstantPlayerShuffler()

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table3" variant="holdem" betting_structure="test18pokerclient" seats="10" player_timeout="600" muck_timeout="600" currency_serial="1" forced_dealer_seat="0" />

  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

settings_xml_client = """<?xml version="1.0" encoding="ISO-8859-1"?>
<settings display2d="yes" display3d="no" ping="15000" verbose="6" delays="true" tcptimeout="2000" upgrades="no">
   <delays blind_ante_position="0" position="0" begin_round="0" end_round="0" end_round_last="0" showdown="0" lag="60"/>
  <screen fullscreen="no" width="1024" height="768"/>
  <name>user1</name>
  <passwd>password1</passwd>
  <remember>yes</remember>
  <muck>yes</muck>
  <auto_post>no</auto_post>
  <chat max_chars="40" line_length="20"/>
  <web browser="/usr/bin/firefox">http://localhost/poker-web/</web>
  <sound>yes</sound>
  <tournaments currency_serial="1" type="sit_n_go" sort="name"/>
  <lobby currency_serial="1" type="holdem" sort="name"/>
  <shadow>yes</shadow>
  <vprogram>yes</vprogram>

  <path>%(script_dir)s/../conf</path>
  <rsync path="/usr/bin/rsync" dir="." source="rsync.pok3d.com::pok3d/linux-gnu" target="/tmp/installed" upgrades="share/poker-network/upgrades"/>
  <data path="data" sounds="data/sounds"/>
  <handlist start="0" count="10"/>
</settings>
""" % {'script_dir': SCRIPT_DIR}

TABLE1 = 1
TABLE2 = 2
TABLE3 = 3

class PokerClientTestCase(unittest.TestCase):

    timeout = 1500

    def destroyDb(self, arg = None):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUpServer(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_server, len(settings_xml_server))
        settings.header = settings.doc.xpathNewContext()
        #
        # Setup server
        #
        self.service = pokerservice.PokerService(settings)
        self.service.startService()
        factory = pokerservice.IPokerFactory(self.service)
        self.p = reactor.listenTCP(0, factory,
                                   interface="127.0.0.1")
        self.port = self.p.getHost().port

    def setUpClient(self, index):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_client, len(settings_xml_client))
        settings.header = settings.doc.xpathNewContext()
        clear_all_messages()
        self.client_factory[index] = pokerclient.PokerClientFactory(settings = settings)
        self.assertEquals(get_messages(), ["PokerClient: delays {'lag': 60.0, 'end_round_last': 0.0, 'showdown': 0.0, 'blind_ante_position': 0.0, 'position': 0.0, 'begin_round': 0.0, 'end_round': 0.0}"])
        clear_all_messages()

        def setUpProtocol(client):
            client._poll_frequency = 0.1
            return client
        d = self.client_factory[index].established_deferred
        d.addCallback(setUpProtocol)
        return d

    # ------------------------------------------------------
    def setUp(self):
        global connectionLostMessage
        connectionLostMessage = 'connectionLost: noticed, aborting all tables.'
        testclock._seconds_reset()
        self.destroyDb()
        self.setUpServer()
        self.client_factory = [None, None]
        def connectClient1(client):
            reactor.connectTCP('127.0.0.1', self.port, self.client_factory[1])
            return client

        d = self.setUpClient(0)
        d.addCallback(connectClient1)
        self.setUpClient(1)
        reactor.connectTCP('127.0.0.1', self.port, self.client_factory[0])

    def cleanSessions(self, arg):
        #
        # twisted Session code has leftovers : disable the hanging delayed call warnings
        # of trial by nuking all what's left.
        #
        pending = reactor.getDelayedCalls()
        if pending:
            for p in pending:
                if p.active():
#                    print "still pending:" + str(p)
                    p.cancel()
        return arg

    def tearDownClearMessages(arg1, arg2):
        clear_all_messages()
        return (arg1, arg2)

    def tearDownCheckforConnectionLostMessage(arg1, arg2):
        global connectionLostMessage
        assert search_output(connectionLostMessage) > 0
        return (arg1, arg2)

    def tearDown(self):
        clear_all_messages()
        d = self.service.stopService()
        d.addCallback(lambda x: self.p.stopListening())
        d.addCallback(self.tearDownCheckforConnectionLostMessage)
#        d.addCallback(self.destroyDb)
        d.addCallback(self.cleanSessions)

        return d

    def quit(self, args):
        client = args[0]
        if verbose > 0:
            print "test-pokerclient: quit client " + str(client.getSerial())
        client.sendPacket(PacketQuit())
        if hasattr(client, "transport"):
            client.transport.loseConnection()
            return client.connection_lost_deferred
        else:
            raise UserWarning, "quit does not have transport %d" % client.getSerial()

    def ping(self, client):
        self.assertEquals(search_output('protocol established') > 0, True)
        clear_all_messages()
        client.sendPacket(PacketPing())
        self.assertEquals(get_messages(), ['sendPacket(0) type = PING(5) '])
        clear_all_messages()
        return (client,)

    def test01_ping(self):
        """ test01_ping """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.ping)
        d.addCallback(self.quit)
        clear_all_messages()
        return d

    def login(self, client, index):
        client.sendPacket(PacketPokerSetRole(roles = PacketPokerRoles.PLAY))
        client.sendPacket(PacketLogin(name = 'user%d' % index, password = 'password1'))
        return client.packetDeferred(True, PACKET_POKER_PLAYER_INFO)

    def test02_login(self):
        """ test02_login """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.quit)
        return d

    def cashIn(self, client, url, value):
        note = self.service.cashier.currency_client._buildNote(url, value)
        client.sendPacket(PacketPokerCashIn(serial = client.getSerial(), note = note))
        client.setPrefix("[Client %d]" % client.getSerial())
        return client.packetDeferred(True, PACKET_ACK)

    def check_cashIn(self, (client, packet)):
        client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
        d = client.packetDeferred(True, PACKET_POKER_USER_INFO)
        def validate((client, packet),):
            self.assertEquals(PACKET_POKER_USER_INFO, packet.type)
            self.assertEquals(2, len(packet.money))
            self.assertEquals([1, 2], packet.money.keys())
            self.assertEquals(100, packet.money[1][0])
            self.assertEquals(200, packet.money[2][0])
            return (client, packet)
        d.addCallback(validate)
        return d

    def test03_cashIn(self):
        """ test03_cashIn """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 100))
        d.addCallback(lambda (client, packet): self.cashIn(client, "TWO", 200))
        d.addCallback(self.check_cashIn)
        d.addCallback(self.quit)
        return d

    def sit(self, (client, packet), game_id = TABLE1, seat = -1, auto_muck = pokergame.AUTO_MUCK_ALWAYS):
        client.sendPacket(PacketPokerTableJoin(serial = client.getSerial(),
                                               game_id = game_id))
        client.sendPacket(PacketPokerSeat(serial = client.getSerial(),
                                          game_id = game_id,
                                          seat = seat))
        client.sendPacket(PacketPokerAutoBlindAnte(serial = client.getSerial(),
                                                   game_id = game_id))
        client.sendPacket(PacketPokerBuyIn(serial = client.getSerial(),
                                           game_id = game_id,
                                           amount = 200000))
        if auto_muck != pokergame.AUTO_MUCK_ALWAYS:
            client.sendPacket(PacketPokerAutoMuck(serial = client.getSerial(),
                                                  game_id = game_id,
                                                  auto_muck = auto_muck))
        client.sendPacket(PacketPokerSit(serial = client.getSerial(),
                                         game_id = game_id))
        return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)

    def allIn(self, (client, packet), sit_out = True):
        self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
        self.assertEqual(client.getSerial(), packet.serial)
        if sit_out:
            client.sendPacket(PacketPokerSitOut(serial = packet.serial,
                                                game_id = packet.game_id))
        game = client.getGame(packet.game_id)
        player = game.getPlayer(packet.serial)
        if game.canRaise(player.serial):
            if verbose > 0:
                print "(A) ALLIN RAISE"
            client.sendPacket(PacketPokerRaise(serial = packet.serial,
                                               game_id = packet.game_id,
                                               amount = player.money))
        else:
            if verbose > 0:
                print "(A) ALLIN CALL"
            client.sendPacket(PacketPokerCall(serial = packet.serial,
                                              game_id = packet.game_id))

        return client.packetDeferred(True, PACKET_POKER_WIN)

    def check_or_call(self, (client, packet)):
        self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
        self.assertEqual(client.getSerial(), packet.serial)
        game = client.getGame(packet.game_id)
        player = game.getPlayer(packet.serial)
        if game.canCheck(player.serial):
            if verbose > 0:
                print "(A) CHECK"
            client.sendPacket(PacketPokerCheck(serial = packet.serial,
                                               game_id = packet.game_id))
        else:
            if verbose > 0:
                print "(A) CALL"
            client.sendPacket(PacketPokerCall(serial = packet.serial,
                                              game_id = packet.game_id))

        return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)

    def win(self, (client, packet), expect = None):
        if verbose > 0:
            print "(A) WIN " + str(packet)
        if expect:
            return client.packetDeferred(True, expect)
        else:
            return (client, packet)

    def test04_playHand(self):
        """ test04_playHand """
        global connectionLostMessage
        connectionLostMessage = "connectionLost: reason = [Failure"
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
            d[index].addCallback(self.sit)
            d[index].addCallback(self.allIn)
            d[index].addCallback(self.win)
            d[index].addCallback(self.quit)
        return defer.DeferredList(d)

    def getUserInfo(self, (client, packet)):
        if verbose > 0:
            print "getUserInfo " + str(packet)
        game = client.getGame(packet.game_id)
        self.assertEqual(False, game.isRunning())
        client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
        clear_all_messages()
        return client.packetDeferred(True, PACKET_POKER_USER_INFO)

    def printUserInfo(self, (client, packet)):
        if verbose > 0:
            print "printUserInfo " + str(packet)
        self.assertEquals(search_output("handleUserInfo: type = POKER_USER_INFO(92) serial = %d name = user%d, password = , email = , rating = 1000, affiliate = 0" % (packet.serial, packet.serial - 4)) >= 0, True)
        self.assertEqual(PACKET_POKER_USER_INFO, packet.type)
        return (client, packet)

    def test05_userInfo(self):
        """ test05_userInfo """
        global connectionLostMessage
        connectionLostMessage = "connectionLost: reason = [Failure"
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
            d[index].addCallback(self.sit)
            d[index].addCallback(self.allIn)
            d[index].addCallback(self.getUserInfo)
            d[index].addCallback(self.printUserInfo)
            d[index].addCallback(self.quit)
        return defer.DeferredList(d)

    def test06_cannotGetSeat(self):
        """ test06_cannotGetSeat """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
        def wrongSeat((client, packet),):
            client.sendPacket(PacketPokerTableJoin(serial = client.getSerial(),
                                                   game_id = TABLE1))
            client.sendPacket(PacketPokerSeat(serial = client.getSerial(),
                                              game_id = TABLE1,
                                              seat = 42))
            return client.packetDeferred(True, PACKET_POKER_SEAT)
        d.addCallback(wrongSeat)
        def checkWrongSeat((client, packet),):
            self.assertEqual(PACKET_POKER_SEAT, packet.type)
            self.assertEqual(-1, packet.seat)
            return (client, packet)
        d.addCallback(checkWrongSeat)
        d.addCallback(self.quit)
        return d

    def rebuy(self, (client, packet)):
        client.sendPacket(PacketPokerTableJoin(serial = client.getSerial(),
                                               game_id = TABLE1))
        client.sendPacket(PacketPokerSeat(serial = client.getSerial(),
                                          game_id = TABLE1))
        client.sendPacket(PacketPokerBuyIn(serial = client.getSerial(),
                                           game_id = TABLE1,
                                           amount = 200000))
        client.sendPacket(PacketPokerRebuy(serial = client.getSerial(),
                                           game_id = TABLE1,
                                           amount = 200000))
        return client.packetDeferred(True, PACKET_POKER_PLAYER_CHIPS)

    def test07_rebuy(self):
        """ test07_rebuy """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 400000))
        d.addCallback(self.rebuy)
        def checkSit((client, packet),):
            self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
            self.assertEqual(0, packet.money)
            return client.packetDeferred(True, PACKET_POKER_PLAYER_CHIPS)
        d.addCallback(checkSit)
        def checkBuyIn((client, packet),):
            self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
            self.assertEqual(200000, packet.money)
            return client.packetDeferred(True, PACKET_POKER_PLAYER_CHIPS)
        d.addCallback(checkBuyIn)
        def checkRebuy((client, packet),):
            self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
            self.assertEqual(400000, packet.money)
            return (client, packet)
        d.addCallback(checkRebuy)
        d.addCallback(self.quit)
        return d

    def processingHand(self, (client, packet),):
        if verbose > 0:
            print "processingHand"
        self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
        client.sendPacket(PacketPokerProcessingHand(serial = client.getSerial(),
                                                    game_id = TABLE1))
        return (client, packet)

    def readyToPlay(self, (client, packet),):
        client.sendPacket(PacketPokerReadyToPlay(serial = client.getSerial(),
                                                 game_id = TABLE1))
        return (client, packet)

    def test08_processing_readytoplay(self):
        """ test08_processing_readytoplay """
        global connectionLostMessage
        connectionLostMessage = "connectionLost: reason = [Failure"
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 600000))
            d[index].addCallback(self.sit)
            d[index].addCallback(self.processingHand)
            d[index].addCallback(self.allIn)
            def atShowdown((client, packet),):
                if verbose > 0:
                    print "atShowdown"
                client.sendPacket(PacketPokerRebuy(serial = client.getSerial(),
                                                   game_id = TABLE1,
                                                   amount = 200000))
                client.sendPacket(PacketPokerSit(serial = client.getSerial(),
                                                 game_id = TABLE1))
                return (client, packet)
            d[index].addCallback(atShowdown)
            if index == 1:
                d[index].addCallback(self.readyToPlay)
            def nextTurn((client, packet),):
                if verbose > 0:
                    print "nextTurn"
                return client.packetDeferred(True, PACKET_POKER_START)
            d[index].addCallback(nextTurn)
            #
            # Game will start after the client index=0 times out
            # and is marked as bugous because it failed to send
            # the READY_TO_PLAY packet
            #
            if index == 0:
                def checkBugousClient((client, packet),):
                    if verbose > 0:
                        print "checkBugousClient for %d" % client.getSerial()
                    table = self.service.tables.values()[0]
                    has_bugous = False
                    for server_client in table.avatar_collection.get(client.getSerial()):
                        if server_client.bugous_processing_hand == True:
                            has_bugous = True
                    self.assertEqual(True, has_bugous, "has bugous")
                    return (client, packet)
                d[index].addCallback(checkBugousClient)
            d[index].addCallback(self.quit)
        return defer.DeferredList(d)

    def test09_serverShutdown(self):
        """ test04_serverShutdown : the clients are still seated """
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
            d[index].addCallback(self.sit)
            d[index].addCallback(self.allIn)
        return defer.DeferredList(d)

    def test10_playerImage(self):
        """ test10_login """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        def setPlayerImage((client, packet),):
            client.sendPacket(PacketPokerPlayerImage(serial = client.getSerial(),
                                                     image = "2345"))
            return client.packetDeferred(True, PACKET_ACK)
        d.addCallback(setPlayerImage)
        def getPlayerImage((client, packet),):
            self.assertEqual(PACKET_ACK, packet.type)
            client.sendPacket(PacketPokerGetPlayerImage(serial = client.getSerial()))
            return client.packetDeferred(True, PACKET_POKER_PLAYER_IMAGE)
        d.addCallback(getPlayerImage)
        def checkPlayerImage((client, packet),):
            self.assertEqual(PACKET_POKER_PLAYER_IMAGE, packet.type)
            self.assertEqual("2345", packet.image)
            return (client, packet)
        d.addCallback(checkPlayerImage)
        d.addCallback(self.quit)
        return d

    def cashOut(self, client, url, value):
        client.sendPacket(PacketPokerCashOut(serial = client.getSerial(), url = url, value = value))
        return client.packetDeferred(True, PACKET_POKER_CASH_OUT)

    def cashOutCommit(self, (client, packet)):
        self.assertEquals(PACKET_POKER_CASH_OUT, packet.type)
        client.sendPacket(PacketPokerCashOutCommit(serial = client.getSerial(), transaction_id = packet.name))
        return client.packetDeferred(True, PACKET_ACK)

    def test11_cashOut_zero(self):
        """ test11_cashOut_zero """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 100))
        d.addCallback(lambda (client, packet): self.cashIn(client, "TWO", 200))
        d.addCallback(self.check_cashIn)
        d.addCallback(lambda (client, packet): self.cashOut(client, "ONE", 100))
        d.addCallback(self.cashOutCommit)
        def check_cashOut((client, packet),):
            if verbose > 0:
                print "check_cashOut_zero"
            client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
            d = client.packetDeferred(True, PACKET_POKER_USER_INFO)
            def validate((client, packet),):
                if verbose > 0:
                    print "check_cashOut " + str(packet)
                self.assertEquals(PACKET_POKER_USER_INFO, packet.type)
                self.assertEquals(2, len(packet.money))
                self.assertEquals([1, 2], packet.money.keys())
                self.assertEquals(0, packet.money[1][0])
                self.assertEquals(200, packet.money[2][0])
                return (client, packet)
            d.addCallback(validate)
            return d
        d.addCallback(check_cashOut)
        d.addCallback(self.quit)
        return d

    def test12_cashOut(self):
        """ test12_cashOut """
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 100))
        d.addCallback(lambda (client, packet): self.cashIn(client, "TWO", 200))
        d.addCallback(self.check_cashIn)
        d.addCallback(lambda (client, packet): self.cashOut(client, "ONE", 50))
        d.addCallback(self.cashOutCommit)
        def check_cashOut((client, packet),):
            if verbose > 0:
                print "check_cashOut"
            client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
            d = client.packetDeferred(True, PACKET_POKER_USER_INFO)
            def validate((client, packet),):
                if verbose > 0:
                    print "check_cashOut " + str(packet)
                self.assertEquals(PACKET_POKER_USER_INFO, packet.type)
                self.assertEquals(2, len(packet.money))
                self.assertEquals([1, 2], packet.money.keys())
                self.assertEquals(50, packet.money[1][0])
                self.assertEquals(200, packet.money[2][0])
                return (client, packet)
            d.addCallback(validate)
            return d
        d.addCallback(check_cashOut)
        d.addCallback(self.quit)
        return d

    def test13_cashOut_failure(self):
        """ test12_cashOut """
        currencyclient.Verbose = True
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 100))
        d.addCallback(lambda (client, packet): self.cashIn(client, "TWO", 200))
        d.addCallback(self.check_cashIn)
        def cashOutFail((client, packet),):
            currencyclient.FakeCurrencyFailure = True
            client.sendPacket(PacketPokerCashOut(serial = client.getSerial(), url = "ONE", value = 50))
            client.sendPacket(PacketPokerGetUserInfo(serial = client.getSerial()))
            return client.packetDeferred(True, PACKET_POKER_USER_INFO)

        d.addCallback(cashOutFail)
        def check_cashOutFail((client, packet),):
            if verbose > 0:
                print "check_cashOutFail " + str(packet)
            self.assertEquals(PACKET_POKER_USER_INFO, packet.type)
            self.assertEquals(2, len(packet.money))
            self.assertEquals([1, 2], packet.money.keys())
            self.assertEquals(100, packet.money[1][0])
            self.assertEquals(200, packet.money[2][0])
            return (client, packet)
        d.addCallback(check_cashOutFail)
        d.addCallback(self.quit)
        return d

    def test14_messages(self):
        d = self.client_factory[0].established_deferred
        def waitForMessage(client):
            db = self.service.db.db
            db.query("INSERT INTO messages (send_date, message) VALUES (" + str(testclock._seconds_value + 2) + ", 'the message')")
            return client.packetDeferred(True, PACKET_MESSAGE)
        d.addCallback(waitForMessage)
        return d

    def sitngo(self, (client, packet)):
        client.sendPacket(PacketPokerTableJoin(serial = client.getSerial(),
                                               game_id = TABLE1))
        client.sendPacket(PacketPokerSeat(serial = client.getSerial(),
                                          game_id = TABLE1))
        client.sendPacket(PacketPokerAutoBlindAnte(serial = client.getSerial(),
                                                   game_id = TABLE1))
        client.sendPacket(PacketPokerBuyIn(serial = client.getSerial(),
                                           game_id = TABLE1,
                                           amount = 200000))
        client.sendPacket(PacketPokerSit(serial = client.getSerial(),
                                         game_id = TABLE1))
        return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)

    def search_sitngo2(self, (client, packet),):
        client.sendPacket(PacketPokerTourneySelect(string = "sitngo2"))
        return client.packetDeferred(True, PACKET_POKER_TOURNEY_LIST)

    def register_sitngo2(self, (client, packet),):
        self.assertEqual(PACKET_POKER_TOURNEY_LIST, packet.type)
        self.assertEqual(1, len(packet.packets))
        tourney = packet.packets[0]
        client.sendPacket(PacketPokerTourneyRegister(serial = client.getSerial(),
                                                     game_id = tourney.serial))
        return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)

    def tourneyRank(self, (client, packet), ):
        self.assertEqual(PACKET_POKER_WIN, packet.type)
        return client.packetDeferred(True, PACKET_POKER_TOURNEY_RANK)

    # -----------------------------------------------
    def test15_0_playTourney(self):
        """ Play regular tourney, all players go allin immediately. Simplest case, no tricks. """
        global connectionLostMessage
        connectionLostMessage = "connectionLost: reason = [Failure"
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000000))

            d[index].addCallback(self.search_sitngo2)
            d[index].addCallback(self.register_sitngo2)
            d[index].addCallback(lambda arg: self.allIn(arg, sit_out = False))
            d[index].addCallback(self.tourneyRank)
            d[index].addCallback(self.quit)

        return defer.DeferredList(d)

    def check_breaks(self, (client, packet),):
        self.assertEqual(PACKET_POKER_TOURNEY_LIST, packet.type)
        self.assertEqual(1, len(packet.packets))
        tourney = packet.packets[0]
        self.failUnless(hasattr(tourney, 'breaks_first'))
        self.assertEqual(7200, tourney.breaks_first)
        self.failUnless(hasattr(tourney, 'breaks_interval'))
        self.assertEqual(3600, tourney.breaks_interval)
        self.failUnless(hasattr(tourney, 'breaks_duration'))
        self.assertEqual(300, tourney.breaks_duration)
        return (client,)

    # -----------------------------------------------
    def test15_1_check_breaks(self, ):
        """ """
        global connectionLostMessage
        connectionLostMessage = "connectionLost: reason = [Failure"
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.search_sitngo2)
        d.addCallback(self.check_breaks)
        d.addCallback(self.quit)
        return d

    # -----------------------------------------------
    def test16_playTourney_sitout_sit(self):
        """ Play regular tourney, one player sits out and sits back immediately afterwards. """
        global connectionLostMessage
        connectionLostMessage = "connectionLost: reason = [Failure"
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000000))

            d[index].addCallback(self.search_sitngo2)
            d[index].addCallback(self.register_sitngo2)
            if index == 0:
                def sitout((client, packet),):
                    if verbose > 0:
                        print "(A) SITOUT"
                    self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
                    client.sendPacket(PacketPokerSitOut(serial = packet.serial,
                                                        game_id = packet.game_id))
                    client.sendPacket(PacketPokerSit(serial = packet.serial,
                                                     game_id = packet.game_id))
                    return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
                d[index].addCallback(sitout)
            else:
                def callNraise((client, packet),):
                    if verbose > 0:
                        print "(A) CALLNRAISE"
                    self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
                    game = client.getGame(packet.game_id)
                    player = game.getPlayer(packet.serial)
                    client.sendPacket(PacketPokerRaise(serial = packet.serial,
                                                       game_id = packet.game_id,
                                                       amount = player.money))
                    return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
                d[index].addCallback(callNraise)

            d[index].addCallback(self.check_or_call)
            d[index].addCallback(lambda arg: self.allIn(arg, sit_out = False))
            d[index].addCallback(self.tourneyRank)
            d[index].addCallback(self.quit)

        return defer.DeferredList(d)

    # -----------------------------------------------
    def test17_playTourney_timeout_sit(self):
        """ Play regular tourney, one player timeouts out and sits back immediately afterwards. """
        global connectionLostMessage
        connectionLostMessage = "connectionLost: reason = [Failure"
        self.service.settings.headerSet("/server/delays/@showdown", '20')
        for tourney  in self.service.tourneys.values():
            tourney.player_timeout = 100
        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000000))

            d[index].addCallback(self.search_sitngo2)
            d[index].addCallback(self.register_sitngo2)
            if index == 0:
                def timeout((client, packet),):
                    if verbose > 0:
                        print "(A) TIMEOUT"
                    self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
                    return client.packetDeferred(True, PACKET_POKER_TIMEOUT_NOTICE)
                d[index].addCallback(timeout)
                def sitback((client, packet),):
                    if verbose > 0:
                        print "(A) SITBACK"
                    self.assertEqual(PACKET_POKER_TIMEOUT_NOTICE, packet.type)
                    client.sendPacket(PacketPokerSit(serial = packet.serial,
                                                     game_id = packet.game_id))
                    return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
                d[index].addCallback(sitback)
            else:
                def callNraise((client, packet),):
                    if verbose > 0:
                        print "(A) CALLNRAISE"
                    self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
                    game = client.getGame(packet.game_id)
                    player = game.getPlayer(packet.serial)
                    client.sendPacket(PacketPokerRaise(serial = packet.serial,
                                                       game_id = packet.game_id,
                                                       amount = player.money))
                    return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)
                d[index].addCallback(callNraise)

            d[index].addCallback(self.check_or_call)
            d[index].addCallback(lambda arg: self.allIn(arg, sit_out = False))
            d[index].addCallback(self.tourneyRank)
            d[index].addCallback(self.quit)

        return defer.DeferredList(d)
    test17_playTourney_timeout_sit.timeout = 150000

    def test18_blindAllIn(self):
        """ test18_blindAllIn """
        global connectionLostMessage
        connectionLostMessage = "connectionLost: reason = [Failure"
        def raiseAlmostAllIn((client, packet)):
            self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
            self.assertEqual(client.getSerial(), packet.serial)
            game = client.getGame(packet.game_id)
            player = game.getPlayer(packet.serial)
            if verbose > 0:
                print "(A) ALMOST ALLIN RAISE " + str(packet.serial)
            client.sendPacket(PacketPokerRaise(serial = packet.serial,
                                               game_id = packet.game_id,
                                               amount = player.money - 50))
            return client.packetDeferred(True, PACKET_POKER_SELF_IN_POSITION)

        def fold((client, packet), expect = PACKET_POKER_SELF_IN_POSITION):
            self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
            self.assertEqual(client.getSerial(), packet.serial)
            game = client.getGame(packet.game_id)
            player = game.getPlayer(packet.serial)
            if verbose > 0:
                print "(A) FOLD " + str(packet.serial)
            client.sendPacket(PacketPokerFold(serial = packet.serial,
                                              game_id = packet.game_id))
            return client.packetDeferred(True, expect)

        def muck((client, packet),):
            self.assertEqual(client.getSerial(), packet.muckable_serials[0])
            game = client.getGame(packet.game_id)
            player = game.getPlayer(packet.serial)
            if verbose > 0:
                print "(A) MUCK " + str(client.getSerial())
            client.sendPacket(PacketPokerMuckAccept(serial = client.getSerial(),
                                                    game_id = packet.game_id))
            return client.packetDeferred(True, PACKET_POKER_WIN)

        def call((client, packet), expect = PACKET_POKER_SELF_IN_POSITION):
            self.assertEqual(PACKET_POKER_SELF_IN_POSITION, packet.type)
            self.assertEqual(client.getSerial(), packet.serial)
            game = client.getGame(packet.game_id)
            player = game.getPlayer(packet.serial)
            if verbose > 0:
                print "(A) ALLIN CALL " + str(packet.serial)
            client.sendPacket(PacketPokerCall(serial = packet.serial,
                                              game_id = packet.game_id))
            return client.packetDeferred(True, expect)

        d = [None, None]
        for index in (0,1):
            d[index] = self.client_factory[index].established_deferred
            d[index].addCallback(self.login, index)
            d[index].addCallback(lambda (client, packet): self.cashIn(client, "ONE", 200000))
            d[index].addCallback(self.sit, TABLE3, index, pokergame.AUTO_MUCK_NEVER)
            if index == 0: # serial 4
                d[index].addCallback(call, PACKET_POKER_MUCK_REQUEST)
                d[index].addCallback(muck)
            else:
                d[index].addCallback(raiseAlmostAllIn)
                d[index].addCallback(fold, PACKET_POKER_WIN)
            if index == 1: # serial 5
                d[index].addCallback(self.win, PACKET_POKER_MUCK_REQUEST)
                d[index].addCallback(muck)
            else:
                def waitWin((client, packet)):
                    return client.packetDeferred(True, PACKET_POKER_WIN)
                d[index].addCallback(waitWin)
            d[index].addCallback(self.quit)
        return defer.DeferredList(d)

    def test19_setPlayerDelay(self):
        d = self.client_factory[0].established_deferred
        def setPlayerDelay(client):

            class Player:
                def __init__(self):
                    self.user_data = {'delay': 0}

                def getUserData(self):
                    return self.user_data

            class Game:
                def __init__(self):
                    self.player = Player()

                def getPlayer(self, serial):
                    return self.player

            game = Game()
            client.setPlayerDelay(game, 42, 100)
            self.assertEqual(testclock._seconds_value + 100, game.player.user_data['delay'])
        d.addCallback(setPlayerDelay)
        return d

    def test20_resendPlayerTimeoutWarning(self):
        d = self.client_factory[0].established_deferred
        def resendPlayerTimeoutWarning(client):

            class Player:
                def __init__(self):
                    self.user_data = {'timeout': None }

                def getUserData(self):
                    return self.user_data

            class Game:
                def __init__(self):
                    self.player = Player()
                    self.id = 1010

                def getPlayer(self, serial):
                    return self.player

                def isRunning(self):
                    return True

                def getSerialInPosition(self):
                    return 0

            game = Game()
            client.setPlayerTimeout(game, PacketPokerTimeoutWarning(game_id = game.id,
                                                                    serial = client.getSerial(),
                                                                    timeout = 50))

            self.assertEqual(int(testclock._seconds_value), game.player.user_data['timeout'][0])
            testclock._seconds_value += 1
            ( packet, ) = client.resendPlayerTimeoutWarning(game)
            self.assertEqual(int(testclock._seconds_value), packet.when)
            self.assertApproximates(50 - 1 - 1, packet.timeout, 1) # approximates because of rounding
            self.assertEqual(PACKET_POKER_TIMEOUT_WARNING, packet.type)
        d.addCallback(resendPlayerTimeoutWarning)
        return d

    def test21_publishDelay(self):
        d = self.client_factory[0].established_deferred
        def publishDelay(client):
            client.publishDelay(10)
            self.assertEqual(testclock._seconds_value + 10, client.publish_time)
        d.addCallback(publishDelay)
        return d

    def test22_resendPackets(self):
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(lambda (client, packet): self.cashIn(client, "ONE", 400000))
        d.addCallback(self.rebuy)
        def resendPackets((client, packet),):
            client.resendPackets(TABLE1)
            types = {}
            for packet in client.publish_packets:
                if packet.type == PACKET_POKER_TABLE:
                    types[packet.type] = 1
                elif packet.type == PACKET_POKER_BUY_IN_LIMITS:
                    for key in [ 'best', 'game_id', 'min', 'max' ]:
                        self.assert_(hasattr(packet, key))
                    types[packet.type] = 1

            self.assertEqual(types[PACKET_POKER_BUY_IN_LIMITS], 1)
            self.assertEqual(types[PACKET_POKER_TABLE], 1)
        d.addCallback(resendPackets)
        return d

    #-----------------------------------------------------------------------------
    translateConfigs = [ ('limit-2-4',
"""<?xml version="1.0" encoding="ISO-8859-1"?>
<bet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="bet.xsd" name="2-4 limit" table-stakes="yes" unit="100" buy-in="1000" best-buy-in="6000" max-buy-in="100000000" poker_engine_version="1.3.0">
    <description>Limit 2/4</description>
    <blind small="100" big="200"/>
    <all_in method="side"/>
    <variants ids="omaha omaha8 holdem">
      <round name="pre-flop" fixed="200" cap="3"/>
      <round name="flop" fixed="200" cap="3"/>
      <round name="turn" fixed="400" cap="3"/>
      <round name="river" fixed="400" cap="3"/>
    </variants>
</bet>
""", 'Limit 2/4', [] ),
    ( 'undescribed' ,
"""<?xml version="1.0" encoding="ISO-8859-1"?>
<bet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="bet.xsd" name="2-4 limit" table-stakes="yes" unit="100" buy-in="1000" best-buy-in="6000" max-buy-in="100000000" poker_engine_version="1.3.0">
    <blind small="100" big="200"/>
    <all_in method="side"/>
    <variants ids="omaha omaha8 holdem">
      <round name="pre-flop" fixed="200" cap="3"/>
      <round name="flop" fixed="200" cap="3"/>
      <round name="turn" fixed="400" cap="3"/>
      <round name="river" fixed="400" cap="3"/>
    </variants>
</bet>
""" , 'undescribed',
[ "ERROR *CRITICAL* can't find readable name for undescribed"]) ]
    def test23_checkTranslateToFileName(self):
        global connectionLostMessage
        connectionLostMessage = "Shutdown immediately"
        self.tmpdir = tempfile.mkdtemp()
        self.client_factory[0].dirs = [ self.tmpdir ]

        for (name, data, expectedReturn, expectedOutput) in self.translateConfigs:
            outFile = os.path.join(self.tmpdir, "poker.%s.xml" % name)
            outFH = open(outFile, "w")
            outFH.write(data)
            outFH.close()
            clear_all_messages()
            self.assertEquals(self.client_factory[0].translateFile2Name(name),
                              expectedReturn)
            self.assertEquals(get_messages(), expectedOutput)

        shutil.rmtree(self.tmpdir)
        clear_all_messages()
        return True
    # ---------------------------------------------------------------------------
    def updatePot(self, (client, packet)):
        class Game:
            def __init__(self):
                self.id = 1015
        g = Game()
        clear_all_messages()
        packetCount = 0
        for p in client.updatePotsChips(g, None):
            self.assertEqual(p.game_id, 1015)
            self.assertEqual(p.type, PACKET_POKER_CHIPS_POT_RESET)
            packetCount += 1
        self.assertEquals(packetCount, 1)
        self.assertEqual(get_messages(), [])
        return (client, packet)

    def test25_updatePotChipsNoSidePots(self):
        """Tests operation of PokerClientProtocol.updatePotChips"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.updatePot)
        return d
    # ---------------------------------------------------------------------------
    def updatePotWithSides(self, (client, packet), sides):
        class Game:
            def __init__(self):
                self.id = 1020
            unit = 1
        g = Game()
        packetCount = 0
        clear_all_messages()
        packetList = client.updatePotsChips(g, sides)
        self.assertEqual(get_messages(), ['normalizeChips: [1, 10] [1]',
                                          'normalizeChips: [1, 40] [1]'])
        self.assertEquals(len(packetList), 2)
        for ii in [ 0, 1 ]:
            self.assertEquals(packetList[ii].game_id, 1020)
            self.assertEquals(packetList[ii].index, ii)
            self.assertEqual(packetList[ii].type, PACKET_POKER_POT_CHIPS)
        self.assertEqual(packetList[0].bet, [1, 10])
        self.assertEqual(packetList[1].bet, [1, 40])
        print packetList[1].bet
        return (client, packet)

    def test26_updatePotChipsNoSidePots(self):
        """Tests operation of PokerClientProtocol.updatePotChips"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.updatePotWithSides, { 'pots' : [(10, 20), (40, 50) ]})
        return d
    # ---------------------------------------------------------------------------
    def changingURLHandlePacketInfo(self, (client, packet), forceCrash=False):
        skin = client.factory.getSkin()

        global specialCallCountforURL
        specialCallCountforURL = 0
        def misInterpretURLforSkin(url, outfit, force=forceCrash):
            global specialCallCountforURL
            specialCallCountforURL += 1
            if force and specialCallCountforURL > 1:
                return ("http://thatisthree", outfit)
            return ("http://thatistwo", outfit)
        correctInterpret = skin.interpret
        skin.interpret = misInterpretURLforSkin

        clear_all_messages()
        client.handlePlayerInfo(PacketPokerPlayerInfo(name = "test",
                                                  url = "http://thatisone/",
                                                  outfit = "Stablize",
                                                  serial = client.getSerial()))
        if forceCrash:
            self.assertEquals(get_messages(),
                              ['ERROR *CRITICAL*: PACKET_POKER_PLAYER_INFO: may enter loop packet.url = http://thatisone/\n url = http://thatistwo\n url_check = http://thatisthree\npacket.outfit = Stablize\n outfit = Stablize\n outfit_check = Stablize'])
        else:
            self.assertEquals(get_messages(), ['sendPacket(4) type = POKER_PLAYER_INFO(87) serial = 4 game_id = 0 name = test, url = http://thatistwo, outfit = Stablize  '])

        skin.interpret = correctInterpret
        return (client, packet)

    def test27_playerInfoPacket(self):
        """Tests when the url returned by the skin.interpret changes
        twice inbetween calls."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.changingURLHandlePacketInfo)
        return d

    def test28_playerInfoPacket(self):
        """Tests when the url returned by the skin.interpret changes
        three times."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.changingURLHandlePacketInfo, True)
        return d
    # ---------------------------------------------------------------------------
    def changingOutfitHandlePacketInfo(self, (client, packet), forceCrash=False):
        skin = client.factory.getSkin()

        global specialCallCountforOutfit
        specialCallCountforOutfit = 0
        def misInterpretOutfitforSkin(url, outfit, force=forceCrash):
            global specialCallCountforOutfit
            specialCallCountforOutfit += 1
            if force and specialCallCountforOutfit > 1:
                return (url, "OutfitThree")
            return (url, "OutfitTwo")
        correctInterpret = skin.interpret
        skin.interpret = misInterpretOutfitforSkin

        clear_all_messages()
        client.handlePlayerInfo(PacketPokerPlayerInfo(name = "test",
                                                  url = "http://stable/",
                                                  outfit = "OutfitOne",
                                                  serial = client.getSerial()))
        if forceCrash:
            self.assertEquals(get_messages(),
                              ['ERROR *CRITICAL*: PACKET_POKER_PLAYER_INFO: may enter loop packet.url = http://stable/\n url = http://stable/\n url_check = http://stable/\npacket.outfit = OutfitOne\n outfit = OutfitTwo\n outfit_check = OutfitThree'])
        else:
            self.assertEquals(get_messages(), ['sendPacket(4) type = POKER_PLAYER_INFO(87) serial = 4 game_id = 0 name = test, url = http://stable/, outfit = OutfitTwo  '])

        skin.interpret = correctInterpret
        return (client, packet)

    def test29_playerInfoPacketChangingOutfit(self):
        """Tests when the outfit returned by the skin.interpret changes
        twice inbetween calls."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.changingOutfitHandlePacketInfo)
        return d

    def test30_playerInfoPacketChangingOutfit(self):
        """Tests when the outfit returned by the skin.interpret changes
        three times."""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.changingOutfitHandlePacketInfo, True)
        return d
    # ---------------------------------------------------------------------------
    def badPlayerObjectSetPlayerDelay(self, (client, packet)):
        class Game:
            def getPlayer(self, serial):
                return None
        g = Game()
        clear_all_messages()
        client.setPlayerDelay(g, client.getSerial(), 101873)
        self.assertEquals(get_messages(), [ "WARNING setPlayerDelay for a non-existing player %d" % client.getSerial() ])
        clear_all_messages()
        return (client, packet)

    def test31_badPlayerObjectSetPlayerDelay(self):
        """Tests the action of setPlayerDelay when the player object
        returned by game is None"""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.login, 0)
        d.addCallback(self.badPlayerObjectSetPlayerDelay)
        return d

    # ---------------------------------------------------------------------------
    def setCrashing(self, (client,)):
        self.client_factory[0].crashing = True
        global connectionLostMessage
        connectionLostMessage = "connectionLost: crashing, just return."
        return (client,)

    def test32_crashClient(self):
        d = self.client_factory[0].established_deferred
        d.addCallback(self.ping)
        d.addCallback(self.setCrashing)
        return d

    # ---------------------------------------------------------------------------
    def publishDeadPacket(self, client):
        if client.publish_packets == []:
            client.publish_packets.append(PacketPing())
        clear_all_messages()
        client.publishPacket()
        self.assertEquals(get_messages(), ['publishPacket: skip because connection not established'])
        return (client,)

    def setupDeadPacketPublish(self, client):
        d = client.connection_lost_deferred
        d.addCallback(self.publishDeadPacket)
        return (client,)

    def test33_sendPacketAfterLost(self):
        global connectionLostMessage
        connectionLostMessage = ""
        d = self.client_factory[0].established_deferred
        d.addCallback(self.setupDeadPacketPublish)
        return d

# -------------------------------------------------------------------------------
class PokerClientFactoryMockup(pokerclient.PokerClientFactory):
    def __init__(self, *args, **kwargs):
        pokerclient.PokerClientFactory.__init__(self, *args, **kwargs)
        self.call_networkNotAvailable = False
        self.call_networkAvailable = False
        self.rsync_host_no_network = False
        self.rsync_host_not_responding = False
        self.resolve_return_error = False

    def resolve(self, url):
        if self.resolve_return_error is True:
            return defer.fail(url)
        else:
            return defer.succeed(url)

    def networkNotAvailable(self):
        self.call_networkNotAvailable = True

    def networkAvailable(self):
        self.call_networkAvailable = True

    def failedUpgradeHostDoesNotRespond(self, logs, reason):
        self.rsync_host_not_responding = True

    def failedUpgradeNoNetwork(self, logs, reason):
        self.rsync_host_no_network = True

class PokerClientFactoryTestCase(unittest.TestCase):

    timeout = 1500

    def setUp(self):
        testclock._seconds_reset()
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_client, len(settings_xml_client))
        settings.header = settings.doc.xpathNewContext()
        self.client_factory = PokerClientFactoryMockup(settings = settings)

    def tearDown(self):
        pass

    def checkResultFalse(self, d):
        self.assertEqual(True, self.client_factory.call_networkNotAvailable)
        self.assertEqual(False, self.client_factory.call_networkAvailable)

    def checkResultTrue(self, d):
        self.assertEqual(False, self.client_factory.call_networkNotAvailable)
        self.assertEqual(True, self.client_factory.call_networkAvailable)

    def testCheckNetworkSucess(self):
        self.resolve_return_error = False
        return self.client_factory.checkNetwork("dummy").addCallback(self.checkResultTrue)

    def testCheckNetworkError(self):
        self.resolve_return_error = True
        return self.client_factory.checkNetwork("dummy").addErrback(self.checkResultFalse)


class SettingMockup:
    def __init__(self):
        self.return_batch = False
        self.return_upgrade = False

    def headerGet(self, path):
        if path == "/settings/@batch":
            return self.return_batch
        if path == "/settings/@upgrades":
            return self.return_upgrade
        return None

# ------------------------------------------------------
from pokernetwork.pokerclient import PokerSkin

class PokerSkinMethodUnitTest(unittest.TestCase):

    timeout = 1500

    # ---------------------------------------------------------------------------
    def setUp(self):
        pass
    # ---------------------------------------------------------------------------
    def tearDown(self):
        pass
    # ---------------------------------------------------------------------------
    def test00_destroyDoesNothing(self):
        skin = PokerSkin(settings = 'testing')
        skin.destroy()
        self.assertEquals(skin.url, "random")
        self.assertEquals(skin.outfit, "random")
        self.assertEquals(skin.settings, "testing")
    # ---------------------------------------------------------------------------
    def test02_getAndSetURL(self):
        skin = PokerSkin(settings = 'testing')
        self.assertEquals(skin.getUrl(), "random")
        skin.setUrl("http://www.example.org/poker")
        self.assertEquals(skin.getUrl(), "http://www.example.org/poker")
    # ---------------------------------------------------------------------------
    def test03_getAndSetOutfit(self):
        skin = PokerSkin(settings = 'testing')
        self.assertEquals(skin.getOutfit(), "random")
        skin.setOutfit("naked")
        self.assertEquals(skin.getOutfit(), "naked")
    # ---------------------------------------------------------------------------
    def test04_hideOutfitEditorDoesNothing(self):
        skin = PokerSkin(settings = 'testing')
        skin.hideOutfitEditor()
        self.assertEquals(skin.url, "random")
        self.assertEquals(skin.outfit, "random")
        self.assertEquals(skin.settings, "testing")
    # ---------------------------------------------------------------------------
    def test05_showOutfitEditorDoesNothing(self):
        skin = PokerSkin(settings = 'testing')
        skin.showOutfitEditor(None)
        self.assertEquals(skin.url, "random")
        self.assertEquals(skin.outfit, "random")
        self.assertEquals(skin.settings, "testing")
# ------------------------------------------------------
class PokerClientLogErrorFunctionTestCase(unittest.TestCase):

    timeout = 1500

    # ---------------------------------------------------------------------------
    def setUp(self):
        pass
    # ---------------------------------------------------------------------------
    def tearDown(self):
        pass
    # ---------------------------------------------------------------------------
    def test00_errLogTest(self):
        from twisted.python import log as twistedLog
        from pokernetwork import pokerclient as pc

        saveLogErr = pc.log_err

        global myLogErrorCallCount
        myLogErrorCallCount = 0
        def myLogErr(firstArg, secondArg, thirdArg = None):
            global myLogErrorCallCount
            myLogErrorCallCount += 1
            self.assertEquals(firstArg, "FirstOne")
            self.assertEquals(secondArg, "SecondOne")
            self.assertEquals(thirdArg, "ThirdOne")
        pc.log_err  = myLogErr

        self.failIf(twistedLog.error_occurred,
                    "Twisted Log should not have an error occurred yet")

        pc.err("FirstOne", "SecondOne", thirdArg = "ThirdOne")
        self.assertEquals(myLogErrorCallCount, 1)
        self.failUnless(twistedLog.error_occurred,
                    "Twisted Log should have logged an error occurred")

        pc.log_err = saveLogErr
# ------------------------------------------------------
settings_xml_client_noChatNoDelays = """<?xml version="1.0" encoding="ISO-8859-1"?>
<settings display2d="yes" display3d="no" ping="15000" verbose="6" delays="true" tcptimeout="2000" upgrades="no">
  <screen fullscreen="no" width="1024" height="768"/>
  <name>user1</name>
  <passwd>password1</passwd>
  <remember>yes</remember>
  <muck>yes</muck>
  <auto_post>no</auto_post>
  <web browser="/usr/bin/firefox">http://localhost/poker-web/</web>
  <sound>yes</sound>
  <tournaments currency_serial="1" type="sit_n_go" sort="name"/>
  <lobby currency_serial="1" type="holdem" sort="name"/>
  <shadow>yes</shadow>
  <vprogram>yes</vprogram>

  <path>%(script_dir)s/../conf</path>
  <rsync path="/usr/bin/rsync" dir="." source="rsync.pok3d.com::pok3d/linux-gnu" target="/tmp/installed" upgrades="share/poker-network/upgrades"/>
  <data path="data" sounds="data/sounds"/>
  <handlist start="0" count="10"/>
</settings>
""" % {'script_dir': SCRIPT_DIR}

settings_xml_client_delaysWithRoundNoBlindAnte = """<?xml version="1.0" encoding="ISO-8859-1"?>
<settings display2d="yes" display3d="no" ping="15000" verbose="6" delays="true" tcptimeout="2000" upgrades="no">
   <delays position="66" round="42" begin_round="77" end_round="99" end_round_last="0" showdown="0" lag="60"/>
  <screen fullscreen="no" width="1024" height="768"/>
  <name>user1</name>
  <passwd>password1</passwd>
  <remember>yes</remember>
  <muck>yes</muck>
  <auto_post>no</auto_post>
  <web browser="/usr/bin/firefox">http://localhost/poker-web/</web>
  <sound>yes</sound>
  <tournaments currency_serial="1" type="sit_n_go" sort="name"/>
  <lobby currency_serial="1" type="holdem" sort="name"/>
  <shadow>yes</shadow>
  <vprogram>yes</vprogram>

  <path>%(script_dir)s/../conf</path>
  <rsync path="/usr/bin/rsync" dir="." source="rsync.pok3d.com::pok3d/linux-gnu" target="/tmp/installed" upgrades="share/poker-network/upgrades"/>
  <data path="data" sounds="data/sounds"/>
  <handlist start="0" count="10"/>
</settings>
""" % {'script_dir': SCRIPT_DIR}

class PokerClientFactoryUnitMethodCoverageTestCase(unittest.TestCase):
    """These tests cover the methods in PokerClientFactory that are not
    otherwise covered by other tests in this file.  They are not
    particularly "aware" tests, they simply exercise various parts of the
    code to be sure the expected behavior occurs in the context of the
    individual methods."""

    timeout = 1500

    # ---------------------------------------------------------------------------
    def setUp(self):
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml_client, len(settings_xml_client))
        self.settings.header = self.settings.doc.xpathNewContext()
    # ---------------------------------------------------------------------------
    def tearDown(self): pass
    # ---------------------------------------------------------------------------
    def test00_initWithBadConfig(self):
        config_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<nothing/>"""
        config = pokernetworkconfig.Config([])
        config.doc = libxml2.parseMemory(config_xml, len(config_xml))
        config.header = config.doc.xpathNewContext()
        caughtIt = False
        try:
            clientFactory = pokerclient.PokerClientFactory(
                settings = self.settings, config = config)
            self.fail("previous line should have thrown exception")
        except UserWarning, uw:
            self.assertEquals(uw.__str__(), "PokerClientFactory: no /sequence/chips found in None")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
    # ---------------------------------------------------------------------------
    def test01_initWithEmptySequence(self):
        config_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<sequence>
</sequence>"""
        config = pokernetworkconfig.Config([])
        config.doc = libxml2.parseMemory(config_xml, len(config_xml))
        config.header = config.doc.xpathNewContext()
        caughtIt = False
        try:
            clientFactory = pokerclient.PokerClientFactory(
                settings = self.settings, config = config)
            self.fail("previous line should have thrown exception")
        except UserWarning, uw:
            self.assertEquals(uw.__str__(), "PokerClientFactory: no /sequence/chips found in None")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
    # ---------------------------------------------------------------------------
    def test02_initWithstringValues(self):
        config_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<sequence>
<chips>10 bar</chips>
</sequence>"""
        config = pokernetworkconfig.Config([])
        config.doc = libxml2.parseMemory(config_xml, len(config_xml))
        config.header = config.doc.xpathNewContext()
        caughtIt = False
        try:
            clientFactory = pokerclient.PokerClientFactory(
                settings = self.settings, config = config)
            self.fail("previous line should have thrown exception")
        except ValueError, ve:
            self.assertEquals(ve.__str__(),
                              "invalid literal for int() with base 10: 'bar'")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
    # ---------------------------------------------------------------------------
    def test03_init_configWithProperInts(self):
        config_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<sequence>
<chips>5 200 10 15 20</chips>
</sequence>"""
        config = pokernetworkconfig.Config([])
        config.doc = libxml2.parseMemory(config_xml, len(config_xml))
        config.header = config.doc.xpathNewContext()

        clientFactory = pokerclient.PokerClientFactory(settings = self.settings,
                                                 config = config)
        self.assertEquals(clientFactory.chips_values,
                          [5, 200, 10, 15, 20])
    # ---------------------------------------------------------------------------
    def test04_init_missingChatMissingDelays(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_client_noChatNoDelays,
                                           len(settings_xml_client_noChatNoDelays))
        settings.header = settings.doc.xpathNewContext()
        clientFactory = pokerclient.PokerClientFactory(settings = settings)
        self.assertEquals(clientFactory.delays, {})
        self.assertEquals(clientFactory.chat_config, {})
    # ---------------------------------------------------------------------------
    def test05_init_roundPositionOverrides(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_client_delaysWithRoundNoBlindAnte,
                                           len(settings_xml_client_delaysWithRoundNoBlindAnte))
        settings.header = settings.doc.xpathNewContext()

        # Confirm the delays are properly read from the file before init'ing
        # PokerClientFactory
        delays = settings.headerGetProperties("/settings/delays")[0]
        for (key, value) in delays.iteritems():
            delays[key] = float(value)
        self.assertEquals(delays["end_round"], 99)
        self.assertEquals(delays["begin_round"], 77)
        self.assertEquals(delays["round"], 42)
        self.assertEquals(delays["position"], 66)
        self.failIf(delays.has_key("blind_ante_position"))

        clientFactory = pokerclient.PokerClientFactory(settings = settings)

        self.assertEquals(len(clientFactory.delays.keys()), 7)
        self.assertEquals(clientFactory.delays['lag'], 60.0)
        self.assertEquals(clientFactory.delays['end_round_last'], 0.0)
        self.assertEquals(clientFactory.delays['showdown'], 0.0)
        self.assertEquals(clientFactory.delays['blind_ante_position'], 66.0)
        self.assertEquals(clientFactory.delays['begin_round'], 42.0)
        self.assertEquals(clientFactory.delays['position'], 66.0)
        self.assertEquals(clientFactory.delays['end_round'], 42.0)
    # ---------------------------------------------------------------------------
    def test06_delRemovesGames(self):
        clientFactory = pokerclient.PokerClientFactory(settings = self.settings)
        global mockGamesDelCount
        mockGamesDelCount = 0
        class MockGames():
            def __del__(self):
                global mockGamesDelCount
                mockGamesDelCount += 1
        clientFactory.games = MockGames()
        clientFactory.__del__()
        self.assertEquals(mockGamesDelCount, 1)
    # ---------------------------------------------------------------------------
    def test07_resolve(self):
        clientFactory = pokerclient.PokerClientFactory(settings = self.settings)

        realResolve = reactor.resolve

        global myResolveCallCount
        myResolveCallCount = 0
        def myResolve(url, stuff):
            global myResolveCallCount
            myResolveCallCount += 1
            self.assertEquals(url, "http://example.org")
            self.assertEquals(stuff, (1,1))

        reactor.resolve = myResolve
        clientFactory.resolve("http://example.org")
        reactor.resolve = realResolve
        self.assertEquals(myResolveCallCount, 1)
    # ---------------------------------------------------------------------------
    def test08_checkNetwork_ForceHostNotResolved(self):
        clientFactory = pokerclient.PokerClientFactory(settings = self.settings)

        realResolve = reactor.resolve
        saveNetworkNotAvailable = clientFactory.networkNotAvailable

        resolveDeferred = defer.Deferred()
        def myResolve(url, stuff):
            return resolveDeferred

        mustGetCalledBackForTestSuccessDefferred = defer.Deferred()
        def myNetworkNotAvailable():
            reactor.resolve = realResolve  # Restore reactor's resolve
            clientFactory.networkNotAvailable = saveNetworkNotAvailable
            mustGetCalledBackForTestSuccessDefferred.callback(True)

        reactor.resolve = myResolve
        clientFactory.networkNotAvailable = myNetworkNotAvailable

        resolveDeferred.errback(True)
        return defer.DeferredList([
            clientFactory.checkNetwork("http://example.org"),
            mustGetCalledBackForTestSuccessDefferred])
    # ---------------------------------------------------------------------------
    def restoreReactorOs(self):
        sys.argv = self.saveSysArgv
        sys.executable = self.saveExecutable
        reactor.disconnectAll = self.saveReactorDisconnectAll
# ------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test03"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerClientTestCase))
    suite.addTest(loader.loadClass(PokerClientFactoryTestCase))
    suite.addTest(loader.loadClass(PokerSkinMethodUnitTest))
    suite.addTest(loader.loadClass(PokerClientLogErrorFunctionTestCase))
    suite.addTest(loader.loadClass(PokerClientFactoryUnitMethodCoverageTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# ------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerclient.py ) ; ( cd ../tests ; make VERBOSE_T=-1 COVERAGE_FILES='../pokernetwork/pokerclient.py' TESTS='coverage-reset test-pokerclient.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerclientpackets
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)       2009 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os
sys.path.insert(0, "..")
sys.path.insert(0, ".")
sys.path.insert(0, "..")

import unittest
from struct import pack, unpack, calcsize

import testpackets

from pokerengine.pokercards import PokerCards
from pokerengine.pokerchips import PokerChips

from pokernetwork import packets
from pokernetwork import pokerclientpackets
from pokernetwork import OLDpokerclientpackets

class PokerClientPacketsTestCase(testpackets.PacketsTestBase):

    @staticmethod
    def copydict(packet):
        packet_dict = packet.__dict__.copy()
        if packet_dict.has_key('length'): del packet_dict['length']
        if packet_dict.has_key('type'): del packet_dict['type']
        return packet_dict

    def comparedict(self, packet, other_packet):
        packet_dict = self.copydict(packet)
        other_packet_dict = self.copydict(other_packet)
        self.assertEqual(packet_dict, other_packet_dict)

    def OLDpacketCheck(self, **kwargs):
        packet_type = kwargs['type']
        del kwargs['type']
        packet = packet_type(**kwargs)
        size = packet.calcsize()
        packed = packet.pack()
        self.assertEqual(size, len(packed))
        other_packet = packet_type()
        self.assertNotEqual(None, other_packet.unpack(packed))
        self.assertEqual(repr(packet), repr(other_packet))
        self.assertEqual(packet, other_packet)
        self.comparedict(packet, other_packet)
        self.assertEqual(packed, other_packet.pack())
        return packet
        
    #--------------------------------------------------------------    
    def test_packets(self):
        verbose = int(os.environ.get('VERBOSE_T', '-1'))
        for type in pokerclientpackets._TYPES:
            if pokerclientpackets.PacketFactory.has_key(type):
                if verbose > 0:
                    print pokerclientpackets.PacketNames[type]
                self.packetCheck(type = pokerclientpackets.PacketFactory[type])

    #--------------------------------------------------------------    
    def test_backward(self):
        for type_index in pokerclientpackets._TYPES:
            if type_index > 208:
                break
            self.assertEqual(pokerclientpackets.PacketFactory.has_key(type_index), OLDpokerclientpackets.PacketFactory.has_key(type_index))
            if pokerclientpackets.PacketFactory.has_key(type_index):
                if self.verbose > 0:
                    print pokerclientpackets.PacketNames[type_index]
                self.assertEqual(OLDpokerclientpackets.PacketNames[type_index], pokerclientpackets.PacketNames[type_index])
                self.OLDpacketCheck(type = OLDpokerclientpackets.PacketFactory[type_index])

                OLDtype = OLDpokerclientpackets.PacketFactory[type_index]
                type = pokerclientpackets.PacketFactory[type_index]
                #
                # Check that default fields are identical and set to the same values
                #
                OLDpacket = OLDtype()
                packet = type()
                if self.verbose > 2:
                    print "%s: %s == %s" % ( pokerclientpackets.PacketNames[type_index], str(self.copydict(OLDpacket)), str(self.copydict(packet)) )
                self.comparedict(packet, OLDpacket)
                #
                # Check that the serialization of packets with pack/unpack functions
                # did not change.
                #
                if OLDtype.__dict__.has_key('pack'):
                    if self.verbose > 0:
                        print pokerclientpackets.PacketNames[type_index] + " test pack"
                    self.assertEqual(OLDpacket.pack(), packet.pack())
                else:
                    if self.verbose > 0:
                        print pokerclientpackets.PacketNames[type_index] + " no pack function"

    #--------------------------------------------------------------    
    def test_chips2amount(self):
        self.assertEqual(10, pokerclientpackets.chips2amount([1, 2, 4, 2]))

    def test_chips2amount_old(self):
        self.assertEqual(10, OLDpokerclientpackets.chips2amount([1, 2, 4, 2]))

    def defineTestPacket(self):
        d = {}
        d['PacketFactory'] = {}
        d['PacketNames'] = {}
        
        class TestPacket(packets.Packet):
            info = packets.Packet.info + (('f1' , [1, 10], 'c'),
                                          ('f2' , [PokerChips([1],[3]), PokerCards([255,255]), ["a", 1]], 'j'),
                                          )
            fields = ( "\x0a", # type
                       "\0\0", # length
                       "\0\0\0\x0a", # f1
                       '\x00-[["Chips", 3], ["Cards", 255, 255], ["a", 1]]', # f2
                       )
            binary = fields[0] + pack('!H', len("".join(fields))) + "".join(fields[2:])

        d = {}
        d['PacketFactory'] = {}
        d['PacketNames'] = {}
        packets.Packet.infoDeclare(d, TestPacket, packets.Packet, 'NAME', 10)
        return TestPacket

    def test_infoPack(self):
        type = self.defineTestPacket()
        packet = type()
        self.assertEqual(type.binary, packet.infoPack())

    def test_infoPackFail(self):
        type = self.defineTestPacket()
        class Foo:
            pass
        type.info = packets.Packet.info + (('f1' , Foo(), 'j'),)
        self.failUnlessRaises(TypeError, type)

    def test_infoUnpack(self):
        type = self.defineTestPacket()
        packet = type()
        packet.infoUnpack(type.binary)
        self.failUnless(isinstance(packet.f2[0], PokerChips))
        self.failUnless(isinstance(packet.f2[1], PokerCards))
        self.assertEqual(type.binary, packet.infoPack())

    def test_infoCalcsize(self):
        type = self.defineTestPacket()
        packet = type()
        self.assertEqual(len(type.binary), packet.infoCalcsize())

#--------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(PokerClientPacketsTestCase))
    return suite
    
#--------------------------------------------------------------
def Run(verbose = 2):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
    
#--------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerclientpackets.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerclientpackets.py ../pokernetwork/OLDpokerclientpackets.py' TESTS='coverage-reset test-pokerclientpackets.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerdatabase
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008, 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2006 Mekensleep <licensing@mekensleep.com>
#                    24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor

twisted.internet.base.DelayedCall.debug = True
import libxml2
import re

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokernetwork import pokerdatabase
from pokernetwork import pokernetworkconfig
from pokernetwork import version

actualSchemaFile = "%s/../database/schema.sql" % SCRIPT_DIR

settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="4">
  <database name="pokernetworktest" host="localhost" user="pokernettestuser" password="mytestuser"
            root_user="root" root_password="" schema="%s" command="/usr/bin/mysql" />
</server>
""" % actualSchemaFile
settings_missing_schema_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="4">
  <database name="pokernetworktest" host="localhost" user="pokernetworktestuser" password="mytestuser"
            root_user="root" root_password="" schema="/this/is/not/a/file/and/should/not/be/there/not-my-schema-go-away.sql" command="/usr/bin/mysql" />
</server>
"""
settings_root_both_users_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="4">
  <database name="pokernetworktest" host="localhost" user="root" password=""
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
</server>
""" % {'script_dir': SCRIPT_DIR}
settings_missing_root_users_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="4">
  <database name="pokernetworktest" host="localhost" user="root" password=""
  schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
</server>
""" % {'script_dir': SCRIPT_DIR}
class PokerDatabaseTestCase(unittest.TestCase):
    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password=''  -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
    # ----------------------------------------------------------------------------
    def setUp(self):
        self.tearDown()
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.settings = settings
        r = re.compile("""INSERT\s+INTO\s+server\s+\(\s*version\s*\)\s+VALUES\s*\("([\d\.]+)"\s*\)""", flags=re.I)
        infile = open(actualSchemaFile, "r")
        self.pokerdbVersion = "0.0.0"
        for line in infile:
            m = re.match(r, line)
            if m:
                self.pokerdbVersion = m.group(1)
                break
        infile.close()
        # We should be able to find the version number
        self.assertNotEquals(self.pokerdbVersion, "0.0.0")
    # ----------------------------------------------------------------------------
    def tearDown(self):
        try:
            self.db.close()
        except:
            pass
        try:
            import MySQLdb
            settings = pokernetworkconfig.Config([])
            settings.doc = libxml2.parseMemory(settings_xml,
                                           len(settings_xml))
            settings.header = settings.doc.xpathNewContext()
            parameters = settings.headerGetProperties("/server/database")[0]
            db = MySQLdb.connect(host = parameters["host"],
                                 port = int(parameters.get("port", '3306')),
                                 user = parameters["root_user"],
                                 passwd = parameters["root_password"],
                                 db = 'mysql')
            try:
                db.query("REVOKE ALL PRIVILEGES, GRANT OPTION FROM '%s'" % parameters['user'])
                db.query("drop user '%s'" % parameters['user'])
            except:
                db.query("delete from user where user = '%s'" % parameters['user'])

            db.query("FLUSH PRIVILEGES")
            db.close()
        except Exception, e:
            print e
            assert("Unable to delete the user, " + parameters["user"] + "; some tests will fail incorrectly.")
        try:
            del self.db
        except:
            pass
        try:
            self.destroyDb()
        except:
            pass
    # ----------------------------------------------------------------------------
    def test01_upgrade(self):
        self.db = pokerdatabase.PokerDatabase(self.settings)
        self.db.setVersionInDatabase("0.0.0")
        self.db.version = version.Version("0.0.0")
        good = '%s/test-pokerdatabase/good' % SCRIPT_DIR
        self.db.upgrade(good, False)
        self.assertEquals(self.db.getVersion(), self.pokerdbVersion)
    # ----------------------------------------------------------------------------
    def test02_dbVersionTooOld(self):
        import MySQLdb
        class DummyMySQL:
            def get_server_info(self):
                return "3.2.5"
            def query(self, string):
                return string
            def close(self):
                pass
        def dummyConnect(host, port, user, passwd, db='mysql', reconnect=1):
            parameters = self.settings.headerGetProperties("/server/database")[0]
            if user == parameters['user']:
                raise SqlError
            else:
                return DummyMySQL()
        realconnect = MySQLdb.connect
        MySQLdb.connect = dummyConnect
        try:
            self.db = pokerdatabase.PokerDatabase(self.settings)
        except UserWarning, uw:
            self.assertEqual(uw.args[0], "PokerDatabase: MySQL server version is 3.2.5 but version >= 5.0 is required")
        MySQLdb.connect = realconnect
    # ----------------------------------------------------------------------------
    def test03_schemaFileMissing(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_missing_schema_xml,
                                           len(settings_missing_schema_xml))
        settings.header = settings.doc.xpathNewContext()
        self.settings = settings
        try:
            self.db = pokerdatabase.PokerDatabase(self.settings)
            assert("Schema file was missing so this line should not be reached.")
        except UserWarning, uw:
            self.assertEqual(uw.args[0], "PokerDatabase: schema /this/is/not/a/file/and/should/not/be/there/not-my-schema-go-away.sql file not found")
    # ----------------------------------------------------------------------------
    def test04_rootBothUsers(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_root_both_users_xml,
                                           len(settings_root_both_users_xml))
        settings.header = settings.doc.xpathNewContext()
        self.settings = settings
        try:
            self.db = pokerdatabase.PokerDatabase(self.settings)
        except OperationalError, oe:
            self.assertEquals(oe.args[0], 1396)
            self.assertEquals(oe.args[1], "Operation CREATE USER failed for 'root'@'%'")
        self.assertEquals(self.db.getVersion(), self.pokerdbVersion)
    # ----------------------------------------------------------------------------
    def test05_missingRootUser(self):
        import MySQLdb

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_missing_root_users_xml,
                                           len(settings_missing_root_users_xml))
        settings.header = settings.doc.xpathNewContext()
        self.settings = settings
        try:
            self.db = pokerdatabase.PokerDatabase(self.settings)
            assert("Root user information was missing so this line should not be reached.")
        except MySQLdb.OperationalError, oe: # handle trouble
            self.assertEquals(oe.args[1], "Unknown database 'pokernetworktest'")
            self.assertEquals(oe.args[0], 1049)
    # ----------------------------------------------------------------------------
    def test06_databaseAlreadyExists(self):
        """Test for when the database already exists"""
        import MySQLdb
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_root_both_users_xml,
                                           len(settings_root_both_users_xml))
        settings.header = settings.doc.xpathNewContext()
        self.settings = settings
        parameters = settings.headerGetProperties("/server/database")[0]
        db = MySQLdb.connect(host = parameters["host"],
                             port = int(parameters.get("port", '3306')),
                             user = parameters["root_user"],
                             passwd = parameters["root_password"])
        db.query("CREATE DATABASE " + parameters["name"])
        db.close()
        self.db = pokerdatabase.PokerDatabase(self.settings)
        self.assertEquals(self.db.getVersion(), '1.0.5')
    # ----------------------------------------------------------------------------
    def test07_multipleRowsInVersionTable(self):
        """Test for when the database already exists"""
        import MySQLdb
        from pokernetwork.pokerdatabase import ExceptionUpgradeFailed

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml,
                                           len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.settings = settings
        parameters = settings.headerGetProperties("/server/database")[0]

        self.db = pokerdatabase.PokerDatabase(self.settings)

        self.db.db.query("DROP TABLE IF EXISTS server;")
        self.db.db.query("""CREATE TABLE server (version VARCHAR(16) NOT NULL)
                            ENGINE=InnoDB CHARSET=utf8;""")
        self.db.db.query("""INSERT INTO server (version) VALUES ("1.1.0");""")
        self.db.db.query("""INSERT INTO server (version) VALUES ("1.2.0");""")
        try:
            self.db.setVersionInDatabase("1.3.0")
        except ExceptionUpgradeFailed, euf: # handle trouble
            self.assertEquals(euf.args[0], "update server set version = '1.3.0': changed 2 rows, expected one or zero")
    # ----------------------------------------------------------------------------
    def test08_forceTestDatabaseTooOld(self):
        import pokernetwork.version
        ver = pokernetwork.version.Version("32767.32767.32767")
        realDBVersion = pokerdatabase.version
        pokerdatabase.version = ver

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.settings = settings
        parameters = settings.headerGetProperties("/server/database")[0]

        try:
            self.db = pokerdatabase.PokerDatabase(self.settings)
            self.db.checkVersion()
            assert("Should have gotten ExceptionDatabaseTooOld and this line should not have been reached.")
        except pokerdatabase.ExceptionDatabaseTooOld, edto:
            self.assertEquals(edto.args, ())
            pokerdatabase.version = realDBVersion  # Restore original version
    # ----------------------------------------------------------------------------
    def test09_forceTestPokerNetworkTooOld(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.settings = settings
        parameters = settings.headerGetProperties("/server/database")[0]
        try:
            self.db = pokerdatabase.PokerDatabase(self.settings)
            import pokernetwork.version
            ver = pokernetwork.version.Version("32767.32767.32767")
            realDBVersion = self.db.version
            self.db.version = ver

            self.db.checkVersion()
            assert("Should have gotten ExceptionSoftwareTooOld and this line should not have been reached.")
        except pokerdatabase.ExceptionSoftwareTooOld, edto:
            self.assertEquals(edto.args, ())
            self.db.version = realDBVersion  # Restore original version
    # ----------------------------------------------------------------------------
    def test10_badUpgradeSqlFiles(self):
        self.db = pokerdatabase.PokerDatabase(self.settings)
        self.db.setVersionInDatabase("0.0.5")
        self.db.version = version.Version("0.0.5")
        try:
            bad = '%s/test-pokerdatabase/bad' % SCRIPT_DIR
            self.db.upgrade(bad, False)
            assert("Should have gotten ExceptionUpgradeFailed and this line should not have been reached.")
        except pokerdatabase.ExceptionUpgradeFailed, euf:
            self.assertEquals(euf.args[0], "upgrade failed")
        self.assertEquals(self.db.getVersion(), "0.0.5")
    # ----------------------------------------------------------------------------
    def test11_confirmLiteralMethodPassThrough(self):
        """test11_confirmLiteralMethodPassThrough
        The method "literal" in the database class should simply pass
        through to the internal representation method of the same name."""
        class MockDatabaseWithOnlyLiteral():
            def literal(mdSelf, args): return "LITERAL TEST " + args

        self.db = pokerdatabase.PokerDatabase(self.settings)
        saveRealDb = self.db.db
        self.db.db = MockDatabaseWithOnlyLiteral()

        self.assertEquals(self.db.literal("ahoy hoy!"),  "LITERAL TEST ahoy hoy!")
        self.db.db = saveRealDb

# --------------------------------------------------------------------------------
def GetTestSuite():
    suite = runner.TestSuite(PokerDatabaseTestCase)
    suite.addTest(unittest.makeSuite(PokerDatabaseTestCase))
    return suite
# --------------------------------------------------------------------------------
def GetTestedModule():
    return pokerdatabase

# --------------------------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test08"
    os.environ['VERBOSE_T'] = '4'

    suite = loader.loadClass(PokerDatabaseTestCase)
    return runner.TrialRunner(reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)
# --------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerdatabase.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerdatabase.py' TESTS='coverage-reset test-pokerdatabase.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerexplain
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys
import os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

from twisted.trial import unittest, runner, reporter

from tests import testclock

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokerengine import pokergame
from pokernetwork.pokerexplain import PokerGames
from pokernetwork import pokerexplain

class MockupPokerGameClient:

    def __init__(self, template, dirs):
        self.id = 0
        self.name = "noname"

class PokerGamesTestCase(unittest.TestCase):

    def setUp(self):
        self.games = PokerGames()
        self.games.game_client = MockupPokerGameClient

    def test_all(self):
        self.failIf(self.games.getGame(1))
        game = self.games.getOrCreateGame(1)
        self.assertEquals([1], self.games.getGameIds())
        self.assertEquals([game], self.games.getAll())
        self.assertEquals("noname", game.name)
        self.assertEquals(game, self.games.getGame(1))
        self.assertEquals(game, self.games.getGameByNameNoCase('NoName'))
        self.failIf(self.games.getGameByNameNoCase('unknown'))
        class Packet:
            pass
        p = Packet()
        self.assertEquals(False, self.games.packet2game(p))
        p.game_id = 1
        self.assertEquals(game, self.games.packet2game(p))
        self.failUnless(self.games.gameExists(1))
        self.games.deleteGame(1)
        self.failIf(self.games.getGame(1))

from pokernetwork.pokerexplain import PokerExplain
from pokernetwork.pokerclientpackets import *

class PokerExplainTestCase(unittest.TestCase):

    def setUp(self):
        self.explain = PokerExplain()
        self.explain.games.dirs = ['%s/poker-engine' % SCRIPT_DIR]
        self.explain.setVerbose(10)

    def test01_utilities(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        self.explain.message("")
        self.explain.setVerbose(10)
        self.explain.error("test")
        self.explain.setPrefix("foo")
        self.assertEqual("foo", self.explain._prefix)

    def test02_normalizeChips(self):
        class PokerGame:
            unit = 10
        game = PokerGame()
        self.assertEqual([1, 5, 10, 3], self.explain.normalizeChips(game, 35))
        game.unit = 237
        self.assertEqual([1,5], self.explain.normalizeChips(game, 5))

    def test03_updatePlayerChips(self):
        class PokerGame:
            id = 3
        game = PokerGame()

        class Player:
            bet = 13
            money = 17
            serial = 1
        player = Player()
        packet = self.explain.updatePlayerChips(game, player)
        self.assertEqual(player.money, packet.money)
        self.assertEqual(player.bet, packet.bet)

    def test04_updatePotsChips(self):
        class PokerGame:
            id = 1
            unit = 1
        game = PokerGame()
        packets = self.explain.updatePotsChips(game, [])
        self.assertEqual(PACKET_POKER_CHIPS_POT_RESET, packets[0].type)
        packets = self.explain.updatePotsChips(game, {'pots': [[10, 20], [20, 40]]})
        self.assertEqual(2, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_POT_CHIPS, packet.type)
        self.assertEqual([1, 6, 2, 2], packet.bet)

    def test05_chipsPlayer2Bet(self):
        class PokerGame:
            id = 1
            unit = 1
        class PokerPlayer:
            serial = 10
            bet = 30
            money = 50
        packets = self.explain.chipsPlayer2Bet(PokerGame(), PokerPlayer(), 10)
        self.assertEqual(3, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_CHIPS_PLAYER2BET, packet.type)
        self.assertEqual([1, 6, 2, 2], packet.chips)

    def test06_chipsBet2Pot(self):
        class PokerGame:
            id = 1
            unit = 1

            def isSecondRound(self):
                return True

        class PokerPlayer:
            serial = 10
            bet = 30
            money = 50
            dead = 3

        pot_index = 0
        packets = self.explain.chipsBet2Pot(PokerGame(), PokerPlayer(), 13, pot_index)
        self.assertEqual(3, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_CHIPS_BET2POT, packet.type)
        self.assertEqual([1, 6, 2, 2], packet.chips)
        self.assertEqual(pot_index, packet.pot)
        packet = packets[1]
        self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
        packet = packets[2]
        self.assertEqual(PACKET_POKER_CLIENT_PLAYER_CHIPS, packet.type)

        # test without explain chipstack
        self.explain.what = PacketPokerExplain.REST
        packets = self.explain.chipsBet2Pot(PokerGame(), PokerPlayer(), 13, pot_index)
        self.assertEqual(2, len(packets))

    def test07_chipsPot2Player(self):
        class PokerGame:
            id = 1
            unit = 1

        class PokerPlayer:
            serial = 1

        reason = "reason"
        pot_index = 1
        packet = self.explain.chipsPot2Player(PokerGame(), PokerPlayer(), 10, pot_index, reason)
        self.assertEqual(PACKET_POKER_CHIPS_POT2PLAYER, packet.type)
        self.assertEqual([1, 6, 2, 2], packet.chips)
        self.assertEqual(reason, packet.reason)
        self.assertEqual(pot_index, packet.pot)

    def test08_gameEvent_position(self):
        self.explain.forward_packets = [ 'fake' ]
        class PokerGame:
            id = 3
            def inGameCount(self):
                return 1
        class PokerGames:
            def getGame(self, id):
                return PokerGame()
        self.explain.games = PokerGames()
        self.assertEquals(True, self.explain.gameEvent(1, "position"))
        self.assertEquals(PACKET_POKER_ALLIN_SHOWDOWN, self.explain.forward_packets[1].type)

    def test08_gameEvent_failure(self):
        self.failIf(self.explain.gameEvent(1, "end_round"))
        self.explain.forward_packets = [ 'fake' ]
        self.failIf(self.explain.gameEvent(1, "end_round"))

    def test08_gameEvent_end_round(self):
        self.explain.forward_packets = [ 'fake' ]
        class PokerGame:
            id = 3
        class PokerGames:
            def getGame(self, id):
                return PokerGame()
        self.explain.games = PokerGames()
        self.assertEqual(True, self.explain.gameEvent(1, "end_round"))
        self.assertEqual(2, len(self.explain.forward_packets))
        packet = self.explain.forward_packets[1]
        self.assertEqual(PACKET_POKER_END_ROUND, packet.type)

        self.explain.forward_packets = [ 'fake' ]
        self.assertEqual(True, self.explain.gameEvent(1, "end_round_last"))
        self.assertEqual(2, len(self.explain.forward_packets))
        packet = self.explain.forward_packets[1]
        self.assertEqual(PACKET_POKER_END_ROUND_LAST, packet.type)

    def test08_gameEvent_money2bet(self):
        self.explain.forward_packets = [ 'fake' ]
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))

        event = ( "raise", player_serial, 20 )
        game.historyAdd(*event)
        self.assertEqual(True, self.explain.gameEvent(game_id, "money2bet", player_serial, 20))
        self.assertEqual(5, len(self.explain.forward_packets))
        packet = self.explain.forward_packets[1]
        self.assertEqual(PACKET_POKER_HIGHEST_BET_INCREASE, packet.type)
        packet = self.explain.forward_packets[2]
        self.assertEqual(PACKET_POKER_CHIPS_PLAYER2BET, packet.type)
        packet = self.explain.forward_packets[3]
        self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
        packet = self.explain.forward_packets[4]
        self.assertEqual(PACKET_POKER_CLIENT_PLAYER_CHIPS, packet.type)

        # test without explain chipstack
        self.explain.what = PacketPokerExplain.REST
        self.explain.forward_packets = [ 'fake' ]
        self.assertEqual(True, self.explain.gameEvent(game_id, "money2bet", player_serial, 20))
        self.assertEqual(4, len(self.explain.forward_packets))


    def test08_gameEvent_bet2pot(self):
        self.explain.forward_packets = [ 'fake' ]
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))

        game.current_round = -1
        self.assertEqual(True, self.explain.gameEvent(game_id, "bet2pot", player_serial, 20))
        self.assertEqual(4, len(self.explain.forward_packets))
        packet = self.explain.forward_packets[1]
        self.assertEqual(PACKET_POKER_CHIPS_BET2POT, packet.type)
        packet = self.explain.forward_packets[2]
        self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
        packet = self.explain.forward_packets[3]
        self.assertEqual(PACKET_POKER_CLIENT_PLAYER_CHIPS, packet.type)

        # test without explain chipstack
        self.explain.what = PacketPokerExplain.REST
        self.explain.forward_packets = [ 'fake' ]
        self.assertEqual(True, self.explain.gameEvent(game_id, "bet2pot", player_serial, 20))
        self.assertEqual(3, len(self.explain.forward_packets))


    def test08_gameEvent_round_cap_decrease(self):
        self.explain.forward_packets = [ 'fake' ]
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        def updateBetLimit(game):
            return ('updateBetLimit called',)
        self.explain.updateBetLimit = updateBetLimit
        self.assertEqual(True, self.explain.gameEvent(1, "round_cap_decrease"))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual('updateBetLimit called', self.explain.forward_packets[1])


    def test09_handleSerial(self):
        serial = 1
        self.explain.handleSerial(PacketSerial(serial = serial))
        self.assertEqual(serial, self.explain.serial)
        self.assertEqual('[%i]' % serial, self.explain._prefix)
        self.assertEqual('[%i]' % serial, self.explain.games.prefix)

    def test09_1_handleSerialPrefix(self):
        serial = 1
        self.explain.setPrefix('myprefix')
        self.explain.handleSerial(PacketSerial(serial = serial))
        self.assertEqual(serial, self.explain.serial)
        self.assertEqual('myprefix', self.explain._prefix)
        self.assertEqual('myprefix', self.explain.games.prefix)

    def test10_setPlayerTimeout(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        player.setUserData({ 'timeout': None })

        packet = PacketPokerTimeoutWarning(serial = player_serial,
                                           timeout = 0)
        self.assertEqual(False, self.explain.setPlayerTimeout(game, packet))
        packet.timeout = 2
        self.assertEqual(True, self.explain.setPlayerTimeout(game, packet))
        self.assertEqual((int(testclock._seconds_value), 2), player.user_data['timeout'])
        return (game, player)

    def test11_resendPlayerTimeoutWarning(self):
        (game, player) = self.test10_setPlayerTimeout()
        self.assertEqual((), self.explain.resendPlayerTimeoutWarning(game))
        self.explain.handleSerial(PacketSerial(serial = player.serial))
        game.state = pokergame.GAME_STATE_PRE_FLOP
        game.player_list = [ player.serial ]
        game.position = 0
        (packet,) = self.explain.resendPlayerTimeoutWarning(game)
        self.assertEqual(PACKET_POKER_TIMEOUT_WARNING, packet.type)
        self.assertEqual(player.serial, packet.serial)

    def test12_unsetPlayerTimeout(self):
        (game, player) = self.test10_setPlayerTimeout()
        self.explain.unsetPlayerTimeout(game, player.serial)
        self.assertEqual(None, player.user_data['timeout'])

    def test13_serial2name(self):
        class PokerGame:
            id = 1
            def getPlayer(self, serial):
                return False
        self.assertEqual("<unknown>", self.explain.serial2name(PokerGame(), 1))

        class PokerPlayer:
            name = "myname"

        class PokerGame:
            id = 1
            def getPlayer(self, serial):
                return PokerPlayer()
        self.assertEqual("myname", self.explain.serial2name(PokerGame(), 1))

    def test14_moveBet2Pot(self):

        player_serial = 1

        class PokerPlayer:
            serial = player_serial
            bet = 30
            money = 50
            dead = 3

        game_id = 1
        amount = 23
        class PokerGame:
            id = game_id
            unit = 1
            pots = {'pots': [[10, 20], [20, 40]]}

            def getPots(self):
                return self.pots

            def getPlayer(self, serial):
                return PokerPlayer()

            def getLatestPotContributions(self):
                return {0: {player_serial: amount}}

            def isSecondRound(self):
                return False

        packets = self.explain.moveBet2Pot(PokerGame())
        self.assertEqual(5, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_CHIPS_BET2POT, packet.type)
        self.assertEqual([1, 6, 2, 6, 5, 1], packet.chips)
        packet = packets[1]
        self.assertEqual(PACKET_POKER_PLAYER_CHIPS, packet.type)
        packet = packets[2]
        self.assertEqual(PACKET_POKER_CLIENT_PLAYER_CHIPS, packet.type)

        # test without explain chipstack
        self.explain.what = PacketPokerExplain.REST
        packets = self.explain.moveBet2Pot(PokerGame())
        self.assertEqual(4, len(packets))


    def test15_updateBetLimit(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        self.explain.handleSerial(PacketSerial(serial = player.serial))

        game.player_list = [ player.serial ]
        game.state = pokergame.GAME_STATE_PRE_FLOP
        game.current_round = 0
        game.bet_info = { 0: {'fixed': 1} }

        packets = self.explain.updateBetLimit(game)
        self.assertEqual(1, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_BET_LIMIT, packet.type)

        self.explain.chips_values = []
        self.assertEqual([], self.explain.updateBetLimit(game))

    def test16_currentGames(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        packet = self.explain.currentGames(game_id)
        self.assertEqual(PACKET_POKER_CURRENT_GAMES, packet.type)

    def test17_packetPot2Player(self):
        class PokerPlayer:
            serial = 1
            bet = 10
            money = 20

        chips_left = 2

        class PokerGame:
            id = 1
            unit = 1
            serial2player = {1: PokerPlayer()}

            def getPlayer(self, serial):
                return self.serial2player[1]

        #
        # chips_left
        #
        class PokerGameChipsLeft(PokerGame):
            showdown_stack = [
                {'type': None,
                 'side_pots': {'pots': []}},
                {'type': 'left_over',
                 'chips_left': chips_left,
                 'serial': 1 },
                ]


        packets = self.explain.packetsPot2Player(PokerGameChipsLeft())
        self.assertEqual(4, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_CHIPS_POT2PLAYER, packet.type)
        self.assertEqual('left_over', packet.reason)
        self.assertEqual([1, chips_left], packet.chips)

        #
        # uncalled
        #
        uncalled = 2
        class PokerGameUncalled(PokerGame):
            showdown_stack = [
                {'type': None,
                 'side_pots': {'pots': []}},
                {'type': 'uncalled',
                 'uncalled': uncalled,
                 'serial': 1 },
                ]

        packets = self.explain.packetsPot2Player(PokerGameUncalled())
        self.assertEqual(4, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_CHIPS_POT2PLAYER, packet.type)
        self.assertEqual('uncalled', packet.reason)
        self.assertEqual([1, chips_left], packet.chips)

        #
        # resolve single winner, single frame
        #
        class PokerGameResolve(PokerGame):
            showdown_stack = [
                {'type': None,
                 'side_pots': {'pots': [[10, 10], [10, 20]]},
                 'pot': 20,
                 },
                {'type': 'resolve',
                 'pot': 20,
                 'serial': 1,
                 'serial2share': {1: 20},
                 },
                ]

        packets = self.explain.packetsPot2Player(PokerGameResolve())
        self.assertEqual(5, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_CHIPS_POT_MERGE, packet.type)
        self.assertEqual([0], packet.sources)
        self.assertEqual(1, packet.destination)
        packet = packets[1]
        self.assertEqual(PACKET_POKER_CHIPS_POT2PLAYER, packet.type)
        self.assertEqual("win", packet.reason)

        #
        # resolve
        #
        class PokerGameResolve(PokerGame):
            showdown_stack = [
                {'type': None,
                 'side_pots': {'pots': [[10, 10], [10, 20]]},
                 'pot': 20,
                 },
                {'type': 'resolve',
                 'pot': 10,
                 'serial': 1,
                 'serial2share': {1: 10},
                 },
                {'type': 'resolve',
                 'pot': 10,
                 'serial': 1,
                 'serial2share': {1: 10},
                 },
                ]

        packets = self.explain.packetsPot2Player(PokerGameResolve())
        self.assertEqual(5, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_CHIPS_POT2PLAYER, packet.type)
        self.assertEqual("win", packet.reason)
        self.assertEqual([1, 6, 2, 2], packet.chips)

    def test18_packetsShowdown(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        self.failIf(self.explain.packetsShowdown(game))
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        game.showdown_stack = [{'serial2delta': {player_serial: 1}}]
        game.state = pokergame.GAME_STATE_END
        game.winners = [player_serial]

        card = 1
        player.hand.add(card, True) # add a visible card

        game.variant = "7stud"
        hand_value_string = "HandValue"
        hand_value = 1010
        hand = [1, 2, 3, 4, 5]
        game.serial2best = {player_serial:
                            {'hi': (hand_value, [hand_value_string] + hand),
                             'low': (hand_value, [hand_value_string] + hand)},
                            }
        game.side2winners = {
            'hi': [player_serial],
            'low': [player_serial],
            }
        game.win_orders = [ "hi", "low" ]
        packets = self.explain.packetsShowdown(game)
        self.assertEqual(4, len(packets))
        packet = packets[0]
        self.assertEqual(PACKET_POKER_PLAYER_NO_CARDS, packet.type)
        packet = packets[1]
        self.assertEqual(PACKET_POKER_PLAYER_CARDS, packet.type)
        self.assertEqual([card], packet.cards)
        packet = packets[2]
        self.assertEqual(PACKET_POKER_BEST_CARDS, packet.type)
        self.assertEqual(hand, packet.bestcards)
        self.assertEqual("hi", packet.side)
        packet = packets[3]
        self.assertEqual(PACKET_POKER_BEST_CARDS, packet.type)
        self.assertEqual(hand, packet.bestcards)
        self.assertEqual("low", packet.side)

    def test19_packetsTableQuit(self):
        class PokerPlayer:
            serial = 1
            seat = 1
        class PokerGame:
            id = 1
            def playersAll(self):
                return [PokerPlayer()]
        game = PokerGame()
        self.explain.games.games = {1: game}
        packets = self.explain.packetsTableQuit(game)
        self.assertEqual(5, len(packets))
        self.assertEqual(PACKET_POKER_BATCH_MODE, packets[0].type)
        self.assertEqual(PACKET_POKER_PLAYER_LEAVE, packets[1].type)
        self.assertEqual(PACKET_POKER_STREAM_MODE, packets[2].type)
        self.assertEqual(PACKET_POKER_TABLE_QUIT, packets[3].type)
        self.assertEqual(PACKET_POKER_CURRENT_GAMES, packets[4].type)

    def test20_explain_poker_table(self):
        self.assertTrue(self.explain.explain(PacketPokerTable(id = 0)))
        self.assertEqual(1, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_TABLE, self.explain.forward_packets[0].type)

        self.assertTrue(self.explain.explain(PacketPokerTable(id = 1,
                                                              betting_structure = '1-2-no-limit',
                                                              variant = 'holdem')))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_TABLE, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_CURRENT_GAMES, self.explain.forward_packets[1].type)

    def test20_explain_poker_table_deleteGame(self):
        self.assertTrue(self.explain.explain(PacketPokerTable(id = 1,
                                                              betting_structure = '1-2-no-limit',
                                                              variant = 'holdem')))
        game = self.explain.games.getGame(1)
        self.assertTrue(self.explain.explain(PacketPokerTable(id = 1,
                                                              betting_structure = '1-2-no-limit',
                                                              variant = 'holdem')))
        self.assertNotEqual(game, self.explain.games.getGame(1))

    def test21_explain_serial(self):
        self.explain.explain(PacketSerial(serial = 42))
        self.assertEqual(42, self.explain.serial)

    def test22_explain_error(self):
        self.failIf(self.explain.explain(PacketError()))

    def test23_explain_table_destroy(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        self.explain.explain(PacketPokerTableDestroy(game_id = game_id))

    def test24_explain_start(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))

        poker_start = PacketPokerStart(game_id = game_id, hand_serial = 0)

        self.explain.explain(poker_start)
        self.assertEqual([], self.explain.forward_packets)

        poker_start.hand_serial = 1
        game.state = "plop"
        self.failUnlessRaises(UserWarning, self.explain.explain, poker_start)

        game.state = pokergame.GAME_STATE_NULL

        call = []
        game.beginTurn = lambda serial: call.append('beginTurn')
        game.player_list = [ player_serial ]
        packets = self.explain.explain(poker_start)
        self.assertEqual(['beginTurn'], call)

    def test25_explain_canceled(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        player.bet = 10

        amount = 1
        self.assertTrue(self.explain.explain(PacketPokerCanceled(game_id = game_id,
                                                                 serial = player_serial,
                                                                 amount = amount)))
        self.assertEqual(6, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_CANCELED, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_CHIPS_BET2POT, self.explain.forward_packets[1].type)
        self.assertEqual(PACKET_POKER_PLAYER_CHIPS, self.explain.forward_packets[2].type)
        self.assertEqual(PACKET_POKER_CLIENT_PLAYER_CHIPS, self.explain.forward_packets[3].type)

        # test without explain chipstack
        self.explain.forward_packets = []
        self.explain.what = PacketPokerExplain.REST
        self.assertTrue(self.explain.explain(PacketPokerCanceled(game_id = game_id,
                                                                 serial = player_serial,
                                                                 amount = amount)))
        self.assertEqual(5, len(self.explain.forward_packets))

    def test26_explain_player_arrive(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.assertTrue(self.explain.explain(PacketPokerPlayerArrive(game_id = game_id,
                                                                     serial = player_serial,
                                                                     seat = 2,
                                                                     name = 'name',
                                                                     url = 'url',
                                                                     outfit = 'outfit',
                                                                     auto_blind_ante = 1,
                                                                     wait_for = 0)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_PLAYER_ARRIVE, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_SEATS, self.explain.forward_packets[1].type)

    def test26_1_explain_player_arrive_no_seats_left(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        game.seats_left = []
        player_serial = 3
        self.assertTrue(self.explain.explain(PacketPokerPlayerArrive(game_id = game_id,
                                                                     serial = player_serial,
                                                                     seat = 2,
                                                                     name = 'name',
                                                                     url = 'url',
                                                                     outfit = 'outfit',
                                                                     auto_blind_ante = 1,
                                                                     wait_for = 0)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_PLAYER_ARRIVE, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_SEATS, self.explain.forward_packets[1].type)

    def test27_explain_player_leave(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        self.assertTrue(self.explain.explain(PacketPokerPlayerLeave(game_id = game_id,
                                                                    serial = player_serial)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_PLAYER_LEAVE, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_SEATS, self.explain.forward_packets[1].type)

    def test27_explain_table_move(self):
        game_id = 1
        to_game_id = 10
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        self.assertTrue(self.explain.explain(PacketPokerTableMove(game_id = game_id,
                                                                  to_game_id = to_game_id,
                                                                  serial = player_serial)))
        self.assertEqual(3, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_TABLE_MOVE, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_PLAYER_LEAVE, self.explain.forward_packets[1].type)
        self.assertEqual(PACKET_POKER_SEATS, self.explain.forward_packets[2].type)

    def test27_explain_player_self_leave(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        self.explain.explain(PacketSerial(serial = player_serial))
        self.assertTrue(self.explain.explain(PacketPokerPlayerLeave(game_id = game_id,
                                                                    serial = player_serial)))
        self.assertEqual(False, self.explain.games.getGame(game_id))

    def test28_explain_player_self(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        self.explain.updateBetLimit = lambda game: [Packet()]
        player_serial = 3
        game.position_info = [ player_serial, False ]
        self.explain.serial = player_serial
        self.assertTrue(self.explain.explain(PacketPokerPlayerSelf(game_id = game_id,
                                                                   serial = player_serial)))
        self.assertEqual(PACKET_POKER_PLAYER_SELF, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_NONE, self.explain.forward_packets[1].type)

    def test29_explain_position(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        game.current_round = -1
        game.state = pokergame.GAME_STATE_PRE_FLOP
        player_serial = 3
        game.player_list = [ player_serial ]
        self.assertTrue(self.explain.explain(PacketPokerPosition(game_id = game_id,
                                                                 position = 0)))
        self.assertEqual(PACKET_POKER_POSITION, self.explain.forward_packets[0].type)
        self.assertEqual(player_serial, self.explain.forward_packets[0].serial)

    def test30_explain_setters(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        #
        # PacketPokerSeats
        #
        self.assertTrue(self.explain.explain(PacketPokerSeats(game_id = game_id)))
        self.assertEqual([], self.explain.forward_packets)
        #
        # PacketPokerPlayerCards
        #
        self.assertTrue(self.explain.explain(
            PacketPokerPlayerCards(game_id = game_id,
                                   serial = player_serial,
                                   cards = [ 1 ])
            ))
        self.assertEqual(PACKET_POKER_PLAYER_CARDS, self.explain.forward_packets[0].type)
        #
        # PacketPokerBoardCards
        #
        self.assertTrue(self.explain.explain(
            PacketPokerBoardCards(game_id = game_id,
                                  cards = [ 1 ])
            ))
        self.assertEqual(PACKET_POKER_BOARD_CARDS, self.explain.forward_packets[0].type)
        #
        # PacketPokerDealer
        #
        self.assertTrue(self.explain.explain(
            PacketPokerDealer(game_id = game_id,
                              dealer = 1)
            ))
        self.assertEqual(PACKET_POKER_DEALER, self.explain.forward_packets[0].type)
        #
        # PacketPokerSitOut
        #
        player.sit_out = False
        self.failUnless(player.isSit())
        self.assertTrue(self.explain.explain(
            PacketPokerSitOut(game_id = game_id,
                              serial = player_serial)
            ))
        self.assertEqual(PACKET_POKER_SIT_OUT, self.explain.forward_packets[0].type)
        self.failUnless(player.isSitOut())
        #
        # PacketPokerSit
        #
        player.buy_in_payed = True
        player.money = 10000
        player.sit_out = True
        self.failIf(player.isSit())
        self.assertTrue(self.explain.explain(
            PacketPokerSit(game_id = game_id,
                           serial = player_serial)
            ))
        self.assertEqual(PACKET_POKER_SIT, self.explain.forward_packets[0].type)
        self.failUnless(player.isSit())
        #
        # PacketPokerAutoFold
        #
        self.failIf(player.isAuto())
        self.assertTrue(self.explain.explain(
            PacketPokerAutoFold(game_id = game_id,
                               serial = player_serial)
            ))
        self.assertEqual(PACKET_POKER_AUTO_FOLD, self.explain.forward_packets[0].type)
        self.failUnless(player.isAuto())
        #
        # PacketPokerAutoBlindAnte
        #
        self.failIf(player.isAutoBlindAnte())
        self.assertTrue(self.explain.explain(
            PacketPokerAutoBlindAnte(game_id = game_id,
                                     serial = player_serial)
            ))
        self.assertEqual(PACKET_POKER_AUTO_BLIND_ANTE, self.explain.forward_packets[0].type)
        self.failUnless(player.isAutoBlindAnte())
        #
        # PacketPokerNoautoBlindAnte
        #
        player.auto_blind_ante = True
        self.failUnless(player.isAutoBlindAnte())
        self.assertTrue(self.explain.explain(
            PacketPokerNoautoBlindAnte(game_id = game_id,
                                       serial = player_serial)
            ))
        self.assertEqual(PACKET_POKER_NOAUTO_BLIND_ANTE, self.explain.forward_packets[0].type)
        self.failIf(player.isAutoBlindAnte())
        #
        # PacketPokerMuckRequest
        #
        self.assertTrue(self.explain.explain(
            PacketPokerMuckRequest(game_id = game_id,
                                   muckable_serials = [player_serial])
            ))
        self.assertEqual(PACKET_POKER_MUCK_REQUEST, self.explain.forward_packets[0].type)
        self.assertEqual([player_serial], game.muckable_serials)
        #
        # PacketPokerRake
        #
        game.getRakeContributions = lambda: 0
        rake_amount = 101
        self.assertTrue(self.explain.explain(
            PacketPokerRake(game_id = game_id,
                            value = rake_amount)
            ))
        self.assertEqual(PACKET_POKER_RAKE, self.explain.forward_packets[0].type)
        self.assertEqual(rake_amount, game.raked_amount)

    def test31_explain_game_action(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        #
        # fold
        #
        fold = []
        game.fold = lambda serial: fold.append('fold')
        game.isSitOut = lambda serial: fold.append('isSitOut') or True
        self.assertTrue(self.explain.explain(PacketPokerFold(game_id = game_id)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(['fold', 'isSitOut'], fold)
        #
        # call
        #
        call = []
        game.call = lambda serial: call.append('call')
        self.assertTrue(self.explain.explain(PacketPokerCall(game_id = game_id)))
        self.assertEqual(['call'], call)
        #
        # check
        #
        check = []
        game.check = lambda serial: check.append('check')
        self.assertTrue(self.explain.explain(PacketPokerCheck(game_id = game_id)))
        self.assertEqual(['check'], check)
        #
        # raise
        #
        _raise = []
        game.callNraise = lambda serial, amount: _raise.append(amount)
        raise_amount = 303
        self.assertTrue(self.explain.explain(PacketPokerRaise(game_id = game_id,
                                                              amount = raise_amount)))
        self.assertEqual([raise_amount], _raise)
        #
        # blind
        #
        blind = []
        game.blind = lambda serial, amount, dead: blind.append(amount)
        blind_amount = 404
        self.assertTrue(self.explain.explain(PacketPokerBlind(game_id = game_id,
                                                              amount = blind_amount)))
        self.assertEqual([blind_amount], blind)
        #
        # ante
        #
        ante = []
        game.ante = lambda serial, amount: ante.append(amount)
        ante_amount = 505
        self.assertTrue(self.explain.explain(PacketPokerAnte(game_id = game_id,
                                                             amount = ante_amount)))
        self.assertEqual([ante_amount], ante)
        #
        # blind_request
        #
        blind_request = []
        game.setPlayerBlind = lambda serial, state: blind_request.append(state)
        blind_state = "small"
        self.assertTrue(self.explain.explain(PacketPokerBlindRequest(game_id = game_id,
                                                                     state = blind_state)))
        self.assertEqual([blind_state], blind_request)

    def test32_explain_state_flop(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        game.player_list = [player_serial]
        self.explain.moveBet2Pot = lambda game: ['moveBet2Player']
        game_actions = []
        game.initRound = lambda: game_actions.append('initRound')
        game.isRunning = lambda: game_actions.append('isRunning') or True
        game.cardsDealt = lambda: game_actions.append('cardsDealt') or True
        game.serialsNotFold = lambda: game_actions.append('serialsNotFold') or [player_serial]
        down_cards_count = 1
        game.downCardsDealtThisRoundCount = lambda: game_actions.append('downCardsDealtThisRoundCount') or down_cards_count
        cards_count = 2
        game.cardsDealtThisRoundCount = lambda: game_actions.append('cardsDealtThisRoundCount') or cards_count
        self.assertTrue(self.explain.explain(PacketPokerState(game_id = game_id,
                                                              string = pokergame.GAME_STATE_FLOP)))
        self.assertEqual(6, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_STATE, self.explain.forward_packets[0].type)
        self.assertEqual('moveBet2Player', self.explain.forward_packets[1])
        self.assertEqual(PACKET_POKER_DEAL_CARDS, self.explain.forward_packets[2].type)
        self.assertEqual(down_cards_count, self.explain.forward_packets[2].numberOfCards)
        self.assertEqual(PACKET_POKER_PLAYER_CARDS, self.explain.forward_packets[3].type)
        self.assertEqual([], self.explain.forward_packets[3].cards)
        self.assertEqual(PACKET_POKER_BEGIN_ROUND, self.explain.forward_packets[4].type)
        self.assertEqual(PACKET_POKER_POSITION, self.explain.forward_packets[5].type)
        self.assertEqual(player_serial, self.explain.forward_packets[5].serial)

    def test33_explain_state_end(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        game.player_list = [player_serial]
        self.explain.moveBet2Player = lambda game: ['moveBet2Player']
        game_actions = []
        game.isSingleUncalledBet = lambda side_pots: game_actions.append('isSingleUncalledBet') or True

        self.assertTrue(self.explain.explain(PacketPokerState(game_id = game_id,
                                                              string = pokergame.GAME_STATE_END)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual('moveBet2Player', self.explain.forward_packets[1])

        game_actions = []
        game.isFirstRound = lambda: True
        game.isBlindAnteRound = lambda: True
        game.blindAnteRoundEnd = lambda: game_actions.append('blindAnteRoundEnd')
        game.isRunning = lambda: False
        game.initRound = lambda: game_actions.append('initRound')
        game.state = pokergame.GAME_STATE_FLOP
        game.endState = lambda: game_actions.append('endState')
        self.assertTrue(self.explain.explain(PacketPokerState(game_id = game_id,
                                                              string = pokergame.GAME_STATE_END)))
        self.assertEqual(1, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_STATE, self.explain.forward_packets[0].type)
        self.assertEqual(['blindAnteRoundEnd', 'endState', 'initRound'], game_actions)

    def test34_explain_in_game(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        player.buy_in_payed = True
        player.money = 10000
        #
        # player in game and wait for
        #
        player.wait_for = True
        self.assertTrue(self.explain.explain(PacketPokerInGame(game_id = game_id,
                                                               players = [player_serial])))
        self.assertEqual(3, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_IN_GAME, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_SIT, self.explain.forward_packets[1].type)
        self.assertEqual(PACKET_POKER_WAIT_FOR, self.explain.forward_packets[2].type)
        self.assertEqual([player_serial], game.getStaticPlayerList())

        #
        # player not in game and wait for
        #
        self.assertTrue(self.explain.explain(PacketPokerInGame(game_id = game_id,
                                                               players = [])))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_IN_GAME, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_WAIT_FOR, self.explain.forward_packets[1].type)
        #
        # player not in game and not wait for
        #
        player.wait_for = False
        self.assertTrue(self.explain.explain(PacketPokerInGame(game_id = game_id,
                                                               players = [])))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_IN_GAME, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_SIT_OUT, self.explain.forward_packets[1].type)
        #
        # player in game and auto
        #
        player.auto = True
        player.sit_out = True
        self.assertTrue(self.explain.explain(PacketPokerInGame(game_id = game_id,
                                                               players = [player_serial])))
        self.assertEqual(3, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_IN_GAME, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_SIT, self.explain.forward_packets[1].type)
        self.assertEqual(PACKET_POKER_AUTO_FOLD, self.explain.forward_packets[2].type)

    def test35_explain_wait_for(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        wait_for = "big"
        self.assertTrue(self.explain.explain(PacketPokerWaitFor(game_id = game_id,
                                                                serial = player_serial,
                                                                reason = wait_for)))
        self.assertEqual(0, len(self.explain.forward_packets))
        self.assertEqual(player.wait_for, wait_for)

    def test36_explain_timeout(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        player.setUserData({ 'timeout': None })
        #
        # timeout = 33
        #
        timeout = 33
        self.assertTrue(self.explain.explain(PacketPokerTimeoutWarning(game_id = game_id,
                                                                       serial = player_serial,
                                                                       timeout = timeout)))
        self.assertEqual(1, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_TIMEOUT_WARNING, self.explain.forward_packets[0].type)
        self.assertEqual(timeout, player.getUserData()['timeout'][1])
        #
        # timeout = 0
        #
        self.assertTrue(self.explain.explain(PacketPokerTimeoutWarning(game_id = game_id,
                                                                       serial = player_serial,
                                                                       timeout = 0)))
        self.assertEqual(0, len(self.explain.forward_packets))
        #
        # unset the player timeout when the deconnection notice comes
        #
        self.assertTrue(self.explain.explain(PacketPokerTimeoutNotice(game_id = game_id,
                                                                      serial = player_serial)))
        self.assertEqual(1, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_TIMEOUT_NOTICE, self.explain.forward_packets[0].type)
        self.assertEqual(None, player.getUserData()['timeout'])

    def test37_explain_rebuy(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        rebuy = []
        game.rebuy = lambda serial, amount: rebuy.append(amount) or True
        amount = 11
        self.assertTrue(self.explain.explain(PacketPokerRebuy(game_id = game_id,
                                                              serial = player_serial,
                                                              amount = amount)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_PLAYER_CHIPS, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_CLIENT_PLAYER_CHIPS, self.explain.forward_packets[1].type)

        # test without explain chipstack
        self.explain.forward_packets = []
        self.explain.what = PacketPokerExplain.REST
        self.assertTrue(self.explain.explain(PacketPokerRebuy(game_id = game_id,
                                                              serial = player_serial,
                                                              amount = amount)))
        self.assertEqual(1, len(self.explain.forward_packets))

    def test38_explain_player_chips(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 3
        self.failUnless(game.addPlayer(player_serial, 1))
        player = game.getPlayer(player_serial)
        bet = 12
        money = 23
        #
        # set the money/bet
        #
        self.assertTrue(self.explain.explain(PacketPokerPlayerChips(game_id = game_id,
                                                                    serial = player_serial,
                                                                    money = money - 1,
                                                                    bet = bet - 1)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_PLAYER_CHIPS, self.explain.forward_packets[0].type)
        self.assertEqual(money - 1, player.money)
        self.assertEqual(bet - 1, player.bet)
        self.assertEqual(PACKET_POKER_CLIENT_PLAYER_CHIPS, self.explain.forward_packets[1].type)
        self.assertEqual([1, 7, 2, 2], self.explain.forward_packets[1].bet)
        self.assertEqual([1, 7, 2, 5, 5, 1], self.explain.forward_packets[1].money)

        self.failUnless(player.isBuyInPayed())
        #
        # override the money/bet
        #
        self.assertTrue(self.explain.explain(PacketPokerPlayerChips(game_id = game_id,
                                                                    serial = player_serial,
                                                                    money = money,
                                                                    bet = bet)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_PLAYER_CHIPS, self.explain.forward_packets[0].type)
        self.assertEqual(money, player.money)
        self.assertEqual(bet, player.bet)
        self.assertEqual(PACKET_POKER_CLIENT_PLAYER_CHIPS, self.explain.forward_packets[1].type)
        self.assertEqual([1, 6, 2, 3], self.explain.forward_packets[1].bet)
        self.assertEqual([1, 6, 2, 6, 5, 1], self.explain.forward_packets[1].money)

        # test without explain chipstack
        self.explain.forward_packets = []
        self.explain.what = PacketPokerExplain.REST
        self.assertTrue(self.explain.explain(PacketPokerPlayerChips(game_id = game_id,
                                                                    serial = player_serial,
                                                                    money = money,
                                                                    bet = bet)))
        self.assertEqual(1, len(self.explain.forward_packets))

    def test39_explain_win(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        game.isGameEndInformationValid = lambda: True
        self.explain.packetsPot2Player = lambda game: ['packetsPot2Player' ]
        #
        # winners are known
        #
        game.winners = [1]
        self.assertTrue(self.explain.explain(PacketPokerWin(game_id = game_id,
                                                            serials = [1])))
        self.assertEqual(5, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_WIN, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_PLAYER_WIN, self.explain.forward_packets[1].type)
        self.assertEqual(PACKET_POKER_SHOWDOWN, self.explain.forward_packets[2].type)
        self.assertEqual('packetsPot2Player', self.explain.forward_packets[3])
        self.assertEqual(PACKET_POKER_POSITION, self.explain.forward_packets[4].type)
        #
        # winners in packet and computed from the game are inconsistant
        #
        game.winners = []
        game.distributeMoney = lambda: game.winners.append(1)
        self.failUnlessRaises(UserWarning, self.explain.explain, PacketPokerWin(game_id = game_id, serials = [3]))

        #
        # winners are not known
        #
        game.winners = []
        game.endTurn = lambda: True
        self.explain.packetsShowdown = lambda game: ['packetsShowdown']
        self.assertTrue(self.explain.explain(PacketPokerWin(game_id = game_id, serials = [1])))
        self.assertEqual(6, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_WIN, self.explain.forward_packets[0].type)
        self.assertEqual(PACKET_POKER_PLAYER_WIN, self.explain.forward_packets[1].type)
        self.assertEqual('packetsShowdown', self.explain.forward_packets[2])
        self.assertEqual(PACKET_POKER_SHOWDOWN, self.explain.forward_packets[3].type)
        self.assertEqual('packetsPot2Player', self.explain.forward_packets[4])
        self.assertEqual(PACKET_POKER_POSITION, self.explain.forward_packets[5].type)

    def test40_explain_position(self):
        game_id = 1
        game = self.explain.games.getOrCreateGame(game_id)
        player_serial = 1
        self.explain.serial = player_serial
        self.explain.unsetPlayerTimeout = lambda game, serial: True
        game.isRunning = lambda: True
        #
        # game running, position is obsolete and self is in position
        #
        game.position_info = [player_serial, True]
        game.getSerialInPosition = lambda: player_serial
        self.assertTrue(self.explain.explain(PacketPokerId(game_id = game_id)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_SELF_IN_POSITION, self.explain.forward_packets[1].type)
        self.assertEqual(player_serial, self.explain.forward_packets[1].serial)
        #
        # game running, position is not osbolete and self lost its position to another player
        #
        game.position_info = [player_serial, False]
        other_player_serial = 75
        game.getSerialInPosition = lambda: other_player_serial
        other_player_position = 3
        game.position = other_player_position
        self.assertTrue(self.explain.explain(PacketPokerId(game_id = game_id)))
        self.assertEqual(3, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_POSITION, self.explain.forward_packets[1].type)
        self.assertEqual(other_player_serial, self.explain.forward_packets[1].serial)
        self.assertEqual(other_player_position, self.explain.forward_packets[1].position)
        self.assertEqual(PACKET_POKER_SELF_LOST_POSITION, self.explain.forward_packets[2].type)
        self.assertEqual(other_player_serial, self.explain.forward_packets[2].serial)
        #
        # game running, position is not obsolete and self lost its position
        #
        game.position_info = [player_serial, False]
        game.getSerialInPosition = lambda: 0
        self.assertTrue(self.explain.explain(PacketPokerId(game_id = game_id)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_SELF_LOST_POSITION, self.explain.forward_packets[1].type)
        #
        # game not running, self in position
        #
        game.position_info = [player_serial, False]
        game.isRunning = lambda: False
        self.assertTrue(self.explain.explain(PacketPokerId(game_id = game_id)))
        self.assertEqual(2, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_SELF_LOST_POSITION, self.explain.forward_packets[1].type)

    def test41_explain_state_flop_hand_strength(self):
        game_id = 1
        self.explain.explain(PacketPokerTable(id = game_id,
                                              betting_structure = '1-2-no-limit',
                                              variant = 'holdem'))
        def addPlayer(player_serial, seat):
            self.explain.explain(PacketPokerPlayerArrive(game_id = game_id,
                                                         serial = player_serial,
                                                         seat = seat,
                                                         name = 'name',
                                                         url = 'url',
                                                         outfit = 'outfit',
                                                         auto_blind_ante = 1,
                                                         wait_for = 0))
            self.explain.explain(PacketPokerPlayerChips(game_id = game_id,
                                                        serial = player_serial,
                                                        money = 20000))
            self.explain.explain(PacketPokerSit(game_id = game_id,
                                                serial = player_serial))
        addPlayer(42, 1)
        addPlayer(43, 2)
        self.explain.explain(PacketSerial(serial = 42))
        self.explain.explain(PacketPokerInGame(game_id = game_id,
                                               players = [42, 43]))
        self.explain.explain(PacketPokerStart(game_id = game_id, hand_serial = 11))
        self.explain.explain(PacketPokerPlayerCards(game_id = game_id,
                                                    serial = 42,
                                                    cards = [ 1, 2 ]))
        self.explain.explain(PacketPokerPlayerCards(game_id = game_id,
                                                    serial = 43,
                                                    cards = [ 3, 4 ]))
        self.explain.explain(PacketPokerState(game_id = game_id,
                                              string = pokergame.GAME_STATE_PRE_FLOP))
        self.explain.explain(PacketPokerCheck(game_id = game_id, serial = 43))
        self.explain.explain(PacketPokerCheck(game_id = game_id, serial = 42))
        self.explain.explain(PacketPokerBoardCards(game_id = game_id,
                                                   cards = [ 5, 6, 7 ]))
        self.explain.explain(PacketPokerState(game_id = game_id,
                                              string = pokergame.GAME_STATE_FLOP))
        self.assertEqual(7, len(self.explain.forward_packets))
        self.assertEqual(PACKET_POKER_PLAYER_HAND_STRENGTH, self.explain.forward_packets[2].type)
        self.assertEqual('Flush Nine high: 9h, 8h, 7h, 4h, 3h', self.explain.forward_packets[2].hand)

    def test42_explain_state_flop_hand_strength_not_in_game(self):
        game_id = 1
        self.explain.explain(PacketPokerTable(id = game_id,
                                              betting_structure = '1-2-no-limit',
                                              variant = 'holdem'))
        def addPlayer(player_serial, seat):
            self.explain.explain(PacketPokerPlayerArrive(game_id = game_id,
                                                         serial = player_serial,
                                                         seat = seat,
                                                         name = 'name',
                                                         url = 'url',
                                                         outfit = 'outfit',
                                                         auto_blind_ante = 1,
                                                         wait_for = 0))
            self.explain.explain(PacketPokerPlayerChips(game_id = game_id,
                                                        serial = player_serial,
                                                        money = 20000))
            self.explain.explain(PacketPokerSit(game_id = game_id,
                                                serial = player_serial))
        addPlayer(42, 1)
        addPlayer(43, 2)
        self.explain.explain(PacketSerial(serial = 44))
        self.explain.explain(PacketPokerInGame(game_id = game_id,
                                               players = [42, 43]))
        self.explain.explain(PacketPokerStart(game_id = game_id, hand_serial = 11))
        self.explain.explain(PacketPokerPlayerCards(game_id = game_id,
                                                    serial = 42,
                                                    cards = [ 1, 2 ]))
        self.explain.explain(PacketPokerPlayerCards(game_id = game_id,
                                                    serial = 43,
                                                    cards = [ 3, 4 ]))
        self.explain.explain(PacketPokerState(game_id = game_id,
                                              string = pokergame.GAME_STATE_PRE_FLOP))
        self.explain.explain(PacketPokerCheck(game_id = game_id, serial = 43))
        self.explain.explain(PacketPokerCheck(game_id = game_id, serial = 42))
        self.explain.explain(PacketPokerBoardCards(game_id = game_id,
                                                   cards = [ 5, 6, 7 ]))
        self.explain.explain(PacketPokerState(game_id = game_id,
                                              string = pokergame.GAME_STATE_FLOP))
        self.assertEqual(5, len(self.explain.forward_packets))
        for packet in self.explain.forward_packets:
            self.assertNotEqual(PACKET_POKER_PLAYER_HAND_STRENGTH, packet.type)

# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test42"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerGamesTestCase))
    suite.addTest(loader.loadClass(PokerExplainTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerexplain.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerexplain.py' VERBOSE_T=6 TESTS='coverage-reset test-pokerexplain.py coverage-report' check )"
# End:


########NEW FILE########
__FILENAME__ = test-pokergameclient
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import os
import sys
sys.path.insert(0, "./..")
sys.path.insert(0, "..")

from twisted.trial import unittest, runner, reporter

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokernetwork.pokergameclient import PokerNetworkGameClient

class PokerNetworkGameClientTestCase(unittest.TestCase):

    def setUp(self):
        self.game = PokerNetworkGameClient("poker.%s.xml", [])
        self.game.verbose = int(os.environ.get('VERBOSE_T', '-1'))

    def test_init(self):
        for key in ( 'currency_serial', 'history_index', 'position_info' ):
            self.failUnless(hasattr(self.game, key))

    def test_reset(self):
        player_list = ['oups']
        self.game.setStaticPlayerList(player_list)
        self.game.reset()
        self.assertEqual(None, self.game.getStaticPlayerList())

    def test_endState(self):
        player_list = ['oups']
        self.game.setStaticPlayerList(player_list)
        self.game.endTurn = lambda: True
        self.game.endState()
        self.assertEqual(None, self.game.getStaticPlayerList())

    def test_cancelState(self):
        player_list = ['oups']
        self.game.setStaticPlayerList(player_list)
        self.game.cancelState()
        self.assertEqual(None, self.game.getStaticPlayerList())

    def test_buildPlayerList(self):
        player_serial = 10
        player_list = [10]
        self.failUnless(self.game.addPlayer(player_serial, 1))
        self.game.getPlayer(player_serial).sit_out = False
        self.game.setStaticPlayerList(player_list)
        self.failUnless(self.game.buildPlayerList(True))
        self.assertEqual(self.game.getStaticPlayerList(), self.game.player_list)
        self.failUnless(self.game.buildPlayerList(False))
        self.assertEqual(self.game.getStaticPlayerList(), self.game.player_list)
        self.game.getPlayer(player_serial).sit_out = True
        self.assertRaises(AssertionError, self.game.buildPlayerList, True)
        self.game.setStaticPlayerList([200])
        self.assertRaises(KeyError, self.game.buildPlayerList, True)

# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test14"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerNetworkGameClientTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokergameclient.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokergameclient.py' VERBOSE_T=-1 TESTS='coverage-reset test-pokergameclient.py coverage-report' check )"
# End:


########NEW FILE########
__FILENAME__ = test-pokerlock
#!/usr/bin/pythonpython test-pokerlock.py
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2008, 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2006       Mekensleep <licensing@mekensleep.com>
#                          24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>
#

import sys, os
sys.path.insert(0, "..")
sys.path.insert(0, "..")

from tests.testmessages import silence_all_messages, clear_all_messages, search_output, get_messages

from twisted.python import failure
from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor
from twisted.internet import defer

twisted.internet.base.DelayedCall.debug = True

from urlparse import urlparse

from pokernetwork import pokerlock

class PokerLockTestCase(unittest.TestCase):
    # A note about clear_all_messages() calls: Note that due to the
    #  threading nature of the pokerlock methods, you must be very careful
    #  when you call clear_all_messages() in these tests.  This is because
    #  a thread can wake up and write the messages you are hoping for to
    #  check in your tests while you are clearing them.  The most
    #  important rule-of-thumb that I discovered was to make sure that you
    #  always call clear_all_messages() before each lock.aquire() method
    #  call.
    #  ----------------------------------------------------------------
    def setUp(self, verbose = 6):
        pokerlock.PokerLock.acquire_sleep = 1
#        verbose = int(os.environ.get('VERBOSE_T', '-1'))
        silence_all_messages()
        if verbose < 0:
            pokerlock.PokerLock.message = lambda self, string: True
        self.parameters = {'host': 'localhost', 'user': 'root', 'password': ''}
        pokerlock.PokerLock.queue_timeout = 30
        self.locker = pokerlock.PokerLock(self.parameters)
        if verbose >= 0: self.locker.verbose = verbose;
        self.locker.start()
    # ----------------------------------------------------------------    
    def tearDown(self):
        self.locker.close()
    # ----------------------------------------------------------------    
    def test01_simple(self):
        clear_all_messages()
        d = self.locker.acquire('lock01')
        def validate(result):
            if isinstance(result, failure.Failure): raise result
            for string in  ['__acquire lock01',
                         '__acquire got MySQL lock', 'acquired' ]:
                self.failUnless(search_output(string), "missing '%s' in output" % string)
            self.assertEqual("lock01", result)
            self.locker.release('lock01')
            return result
        d.addBoth(validate)
        return d
    # ----------------------------------------------------------------
    # Note that test02_wait, no locker2 failure, is the only test that
    # looks for 'loop, queue size' in the output strings.  The other tests
    # do not do this because the system may be so fast that it never
    # loops.
    def test02_wait(self):
        def locker2_succeeded(result):
            self.locker.release('lock01')
            self.fail("locker2 succeeded with result = %s : should have failed with timeout")
            self.locker2.close()

        def locker2_failed(result):
            for string in [ '__acquire lock01', 'acquired', 'exception in function', 
                         'release because exception', 'loop, queue size']:
                if not search_output(string): print get_messages()
                self.failUnless(search_output(string), "missing '%s' in output" % string)

            clear_all_messages()
            self.locker.release('lock01')
            self.assertTrue(isinstance(result, failure.Failure))
            self.assertEqual(result.value[0], pokerlock.PokerLock.TIMED_OUT)
            self.locker2.close()

        def locker2():
            clear_all_messages()
            self.locker2 = pokerlock.PokerLock(self.parameters)
            self.locker2.start()
            self.locker2.verbose = 6
            d = self.locker2.acquire('lock01', 0)
            d.addCallback(locker2_succeeded)
            d.addErrback(locker2_failed)
            return d
            
        def validate(result):
            if isinstance(result, failure.Failure): raise result

            for string in ['__acquire lock01',
                           'acquired', '__acquire got MySQL lock']:
                if not search_output(string): print get_messages()
                self.failUnless(search_output(string),
                                "%s not found in string" % string)
            self.assertEqual("lock01", result)
            return locker2()

        clear_all_messages()
        d = self.locker.acquire('lock01', 0)
        d.addBoth(validate)
        return d
    # ----------------------------------------------------------------    
    def test03_acquire_dead(self):
        self.locker.close()
        clear_all_messages()
        try:
            self.locker.acquire('lock01')
            problem = True
        except Exception, e:
            problem = False
            self.assertEqual(e[0], pokerlock.PokerLock.DEAD)
            self.failUnless(search_output('acquire'), "missing 'acquire' in output")
        if problem:
            self.fail("acquire on dead PokerLock did not raise exception")
    # ----------------------------------------------------------------    
    def test04_release_twice(self):
        def validate(result):
            if isinstance(result, failure.Failure): raise result
            self.assertEqual("lock01", result)
            for string in ['__acquire lock01', 'acquired',
                           '__acquire got MySQL lock']:
                if not search_output(string): print get_messages()
                self.failUnless(search_output(string), "%s not found in output" % string)

            clear_all_messages()
            self.locker.release("lock01")
            self.failUnless(search_output('release lock01'),
                            "missing 'release lock01' in output")
            clear_all_messages()
            try:
                self.locker.release("lock01")
                problem = True
            except Exception, e:
                problem = False
                self.assertEqual(e[0], pokerlock.PokerLock.RELEASE)
                self.failUnless(search_output('release lock01'),
                                "missing 'release lock01' in output")
            if problem:
                self.fail("double release did not raise exception")

        clear_all_messages()
        d = self.locker.acquire('lock01')
        d.addBoth(validate)
        return d
    # ----------------------------------------------------------------    
    def test05_many(self):
        self.locker.message = lambda self, string: True
        self.locker.verbose = 0
        # Runs too slow if you have messages on
        dl = []
        def show(x):
            self.locker.release('lock01')

        pokerlock.PokerLock.acquire_sleep = 0.01

        for i in xrange(1,300):
            d = self.locker.acquire('lock01', 3)
            d.addBoth(show)
            dl.append(d)
        clear_all_messages()
        return defer.DeferredList(dl)
    # ----------------------------------------------------------------    
    def test06_aquireTimeout(self):
        pokerlock.PokerLock.acquire_sleep = 0.01

        def lockTimeoutExpected_succeeded(result):
            self.locker.release('lock01')
            self.fail("lock timeout succeeded with result = %s : should have failed with timeout"
                      % result)

        def lockTimeoutExpected_failed(result):
            self.assertTrue(isinstance(result, failure.Failure))
            self.assertEqual(result.value[0], pokerlock.PokerLock.TIMED_OUT)
            self.failUnless(search_output('__acquire TIMED OUT'),
                            "missing '__acquire TIMED OUT' in output")
            
        def lockFastTimeout():
            self.failUnless(search_output('acquire'),
                            "missing 'acquire' in output")
            pokerlock.PokerLock.acquire_sleep = 1
            clear_all_messages()
            d = self.locker.acquire('lock01', 0)
            d.addCallback(lockTimeoutExpected_succeeded)
            d.addErrback(lockTimeoutExpected_failed)
            return d
            
        def validate(result):
            if isinstance(result, failure.Failure): raise result
            self.assertEqual("lock01", result)
            for string in  ['__acquire lock01',
                         '__acquire got MySQL lock', 'acquired' ]:
                if not search_output(string):
                    print get_messages()
                self.failUnless(search_output(string), "missing '%s' in output" % string)
            return lockFastTimeout()

        pokerlock.PokerLock.acquire_sleep = 0.01
        clear_all_messages()
        d = self.locker.acquire('lock01', 30)
        d.addBoth(validate)
        return d
    # ----------------------------------------------------------------    
    def test07_mainTests_stopped(self):
        clear_all_messages()
        self.locker.stopping()
        self.failUnless(search_output("stopping"), "missing 'stopping' in output")
        clear_all_messages()
        d = defer.Deferred()
        def checker(val):
            self.failIf(self.locker.running)
            self.failUnless(search_output("stopped"), "missing 'stopped' in output")
        reactor.callLater(pokerlock.PokerLock.acquire_sleep*3, lambda: d.callback(True))
        return d
    # ----------------------------------------------------------------    
    def test08_mainTests_emptyQueue(self):
        """test08_mainTests_emptyQueue

        This test creates a dummy PokerLock.__init__() so that a MockQueue
        can be used that force-raises a Queue.Empty() exception, which is
        caught by the running loop in the lock and ends it."""
        import Queue
        from pokernetwork.pokerlock import PokerLock
        import threading
        class  MockQueue:
            def __init__(qSelf):
                qSelf.qSizeCallCount = 0
                qSelf.getCallCount = 0
            def qsize(qSelf):
                qSelf.qSizeCallCount += 1
                return 1
            def get(qSelf, timeout = 1):
                qSelf.getCallCount += 1
                raise Queue.Empty("MOCK")
            def empty(qSelf):
                return False
            def put(qSelf, val):
                pass
        myMockQueue = MockQueue()
        class MockInitLock(PokerLock):
            def __init__(self, parameters):
                self.verbose = 6
                self.q = myMockQueue
                self.lock = threading.Lock()
                self.db = None
                self.running = True
                self.connect(parameters)
                threading.Thread.__init__(self, target = self.main)

        clear_all_messages()
        mockLocker = MockInitLock(self.parameters)
        mockLocker.start()
        mockLocker.close()
        self.failUnless(search_output("timeout"),
                          "output does not contain 'timeout'")
        self.failUnless(search_output("loop"),
                          "output does not contain 'loop'")
        self.failUnless(myMockQueue.qSizeCallCount > 0,
                        "MockQueue.qSize() should be called at least once.")
        self.failUnless(myMockQueue.getCallCount > 0,
                        "MockQueue.get() should be called at least once.")
    # ----------------------------------------------------------------    
    def test09_mainTests_wrongRaise(self):
        import Queue
        import time
        from cStringIO import StringIO
        class MockException(Exception): pass
        class  MockQueue:
            def qsize(qSelf):
                return 1
            def get(qSelf, timeout = 1):
                raise MockException("MOCK")
            def empty(qSelf):
                return False
            def put(qSelf, val):
                pass
        oldStderr = sys.stderr
        sys.stderr = StringIO()
        anotherLock = pokerlock.PokerLock(self.parameters)
        anotherLock.q = MockQueue()
        anotherLock.start()
        time.sleep(2)
        value = sys.stderr.getvalue()
        sys.stderr = oldStderr
        self.failUnless(value.find('raise MockException("MOCK")\nMockException: MOCK') >= 0)
    # ----------------------------------------------------------------    
    def test10_mainTests_notRunningForCallback(self):
        import Queue
        import time

        global myLock
        def setNotRunning(name, timeout):
            global myLock
            myLock.running = False

        d = defer.Deferred()
        def succeeded(result): 
            self.failIf(True)
            
        def failed(result): 
            self.failIf(True)
        d.addErrback(failed)
        d.addCallback(succeeded)

        class  MockQueue:
            def __init__(qSelf):
                qSelf.count = 1
            def qsize(qSelf):
                return qSelf.count
            def get(qSelf, timeout = 1):
                if qSelf.count > 0:
                    qSelf.count = 0
                    return ("Mocky", setNotRunning, 10, d)
                else:
                    raise Queue.Empty
            def empty(qSelf):
                return qSelf.count <= 0
            def put(qSelf, val):
                pass
        class  MockLock:
            def __init__(lSelf):
                lSelf.calledReleaseCount = 0
            def release(lSelf):
                lSelf.calledReleaseCount += 1

        silence_all_messages()
        clear_all_messages()
        anotherLock = pokerlock.PokerLock(self.parameters)
        anotherLock.q = MockQueue()
        anotherLock.lock = MockLock()
        anotherLock.verbose = 6
        myLock = anotherLock
        anotherLock.start()
        time.sleep(2)
        self.failUnless(search_output('release because not running'), 
                        "missing 'release because not running' in output")
        self.assertEquals(anotherLock.running, False)
        self.assertEquals(anotherLock.lock.calledReleaseCount, 1)
    # ----------------------------------------------------------------    
    def test11_mainTests_raiseForceRelease(self):
        import Queue
        import time
        class MockException(Exception): pass

        def raiseForceRelease(name, timeout):
            raise MockException()

        def succeeded(result): 
            self.failIf(True)
            
        def failed(result): 
            self.failUnless(issinstance(result, MockException))
            # FIXME: this callback never happens; it should, however.  I
            # am not completely sure why; I assume it's because the
            # reactor.callFromThread() errback call in the main() doesn't
            # get executed before the reactor dies.  OTOH, I don't fully
            # understand the thread/reactor interaction issues .  If
            # someone can figure out and make sure this callback happens,
            # I'd appreciate it.
        d = defer.Deferred()
        d.addErrback(failed)
        d.addCallback(succeeded)

        class  MockQueue:
            def __init__(qSelf):
                qSelf.count = 1
            def qsize(qSelf):
                return qSelf.count
            def get(qSelf, timeout = 1):
                if qSelf.count > 0:
                    qSelf.count = 0
                    return ("Mocky", raiseForceRelease, 10, d)
                else:
                    raise Queue.Empty
            def empty(qSelf):
                return qSelf.count <= 0
            def put(qSelf, val):
                pass
        class  MockLock:
            def release(lSelf):
                raise MockException("MOCKY NO LOCK RELEASE")

        silence_all_messages()
        clear_all_messages()
        anotherLock = pokerlock.PokerLock(self.parameters)

        anotherLock.q = MockQueue()
        anotherLock.lock = MockLock()
        anotherLock.verbose = 6
        anotherLock.start()
        time.sleep(2)

        self.assertEquals(anotherLock.running, True)
        for string in [ 'exception in function Traceback', 'release because exception',
                        'raise MockException("MOCKY NO LOCK RELEASE")']:
            self.failUnless(search_output(string), "missing '%s' in output" % string)
    # ----------------------------------------------------------------    
    def test12_mainTests_makeSureDBCloses(self):
        class  MockDB:
            def __init__(dbSelf):
                dbSelf.closeCount = 0
            def close(dbSelf):
                dbSelf.closeCount += 1
        db = MockDB()
        oldIsAlive = self.locker.isAlive
        def mockIsAlive(): return False
        self.locker.isAlive = mockIsAlive
        oldDb = self.locker.db
        self.locker.db = db
        self.locker.close()
        self.assertEquals(self.locker.db, None)
        self.locker.db = oldDb
        self.assertEquals(db.closeCount, 1)
        self.locker.isAlive = oldIsAlive
# ----------------------------------------------------------------
def GetTestSuite():
    suite = runner.TestSuite(PokerLockTestCase)
    suite.addTest(unittest.makeSuite(PokerLockTestCase))
    return suite
# ----------------------------------------------------------------
def GetTestedModule():
    return currencyclient
# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test02"
    suite = loader.loadClass(PokerLockTestCase)
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
        #                              reporter.TextReporter,
        #                              tracebackFormat='verbose',
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerlock.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerlock.py' TESTS='coverage-reset test-pokerlock.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokermemcache
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2009 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys, os
sys.path.insert(0, "./..")
sys.path.insert(0, "..")

import unittest

from pokernetwork.pokermemcache import MemcacheMockup

class MemcacheTestCase(unittest.TestCase):

      def test01(self):
            memcache = MemcacheMockup.Client([''])
            memcache.set('a', 'b')
            self.assertEqual(None, memcache.get('c'))
            self.assertEqual('b', memcache.get('a'))
            self.assertEqual(0, memcache.add('a', 'd'))
            self.assertEqual(1, memcache.add('f', 'g'))
            self.assertEqual(0, memcache.replace('z', 'k'))
            self.assertEqual(1, memcache.replace('f', 'l'))
            self.assertEqual(0, memcache.delete('r'))
            self.assertEqual(1, memcache.delete('f'))
            map = {'A': '1', 'B':'2'}
            self.assertEqual([], memcache.set_multi(map))
            self.assertEqual(map, memcache.get_multi(map.keys()))
            self.assertEqual(1, memcache.delete_multi(map.keys()))
            self.assertEqual({}, memcache.get_multi(map.keys()))
      def test02(self):
            memcache = MemcacheMockup.Client([''])
            memcache.set('a', 'b', time = 1)
            self.assertEqual(1, memcache.expiration['a'])
            map = {'A': 'x', 'B':'y'}
            self.assertEqual([], memcache.set_multi(map, time = 2))
            self.assertEqual(2, memcache.expiration['A'])
            self.assertEqual(2, memcache.expiration['B'])
            memcache.replace('A', 'z', time = 1)
            self.assertEqual(1, memcache.expiration['A'])
            memcache.add('C', 'x', time = 3)
            self.assertEqual(3, memcache.expiration['C'])            
      def test03_checkKeyNoString(self):
            from pokernetwork.pokermemcache import MemcachedStringEncodingError
            from pokernetwork.pokermemcache import check_key
            caughtIt = False
            try:
                  check_key(u'\ufeff')
                  self.fail("Previous line should have caused exception")
            except MemcachedStringEncodingError, mse:
                  self.assertEquals(mse.__str__(),
                  "Keys must be str()'s, notunicode.  Convert your unicode strings using mystring.encode(charset)!")
                  caughtIt = True
            self.failUnless(caughtIt, "MemcachedStringEncodingError was not caught")
      def test04_log(self):
            memcache = MemcacheMockup.Client([''])
            memcache.log = []
            memcache.set('a', 'b', time = 1)
            memcache.set('a', 'c', time = 2)
            self.assertEquals(memcache.log, [('set', ('a', 'b', 1)), ('set', ('a', 'c', 2))])

#--------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(MemcacheTestCase))
    return suite
    
#--------------------------------------------------------------
def Run(verbose = 2):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
    
#--------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokermemcache.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokermemcache.py' TESTS='coverage-reset test-pokermemcache.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokernetworkconfig
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008 Loic Dachary <loic@dachary.org>
# Copyright (C) 2006 Mekensleep <licensing@mekensleep.com>
#                    24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#

import sys, os, shutil
sys.path.insert(0, "..")
sys.path.insert(0, "..")

import unittest

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokernetwork import pokernetworkconfig

class PokerNetworkConfigTestCase(unittest.TestCase):
    
    #--------------------------------------------------------------
    def setUp(self):
        self.Config = pokernetworkconfig.Config(['.'])
        shutil.copyfile('./conf/poker.server.xml.in', 'poker.server.xml.in')
    
    #--------------------------------------------------------------    
    def tearDown(self):
        del self.Config
        os.remove('poker.server.xml.in')
        
    #--------------------------------------------------------------    
    def test_loadFromString(self):

        self.Config.loadFromString("""<?xml version="1.0" encoding="ISO-8859-1"?>
<server>
</server>
""")
            
        self.assertNotEqual(self.Config.header, None)

    #--------------------------------------------------------------    
    def test_load(self):
        self.assertEqual(True, self.Config.load("poker.server.xml.in"))
        pokernetworkconfig.Config.upgrades_repository = '.'
        self.assertEqual(True, self.Config.load("poker.server.xml.in"))
        self.Config.checkVersion = lambda field, version, repository: False
        self.assertEqual(False, self.Config.load("poker.server.xml.in"))
        
    #--------------------------------------------------------------    
    def test_notify(self):
        def f(config):
            pass
        self.Config.loadFromString("""<?xml version="1.0" encoding="ISO-8859-1"?>
<server name='value'>
</server>
""")
        self.Config.notifyUpdates(f)
        self.Config.denotifyUpdates(f)
        self.Config.notifyUpdates(f)
        self.Config.headerSet("/server/@name", "othervalue")
        
#--------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(PokerNetworkConfigTestCase))
    return suite
    
#--------------------------------------------------------------
def GetTestedModule():
    return pokernetworkconfig
  
#--------------------------------------------------------------
def Run(verbose = 2):
    unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
    
#--------------------------------------------------------------
if __name__ == '__main__':
    Run()

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokernetworkconfig.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokernetworkconfig.py' TESTS='coverage-reset test-pokernetworkconfig.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerpackets
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys, os
sys.path.insert(0, "..")
sys.path.insert(0, ".")
sys.path.insert(0, "..")

import unittest

from pokernetwork import pokerpackets
import testpackets

class PokerPacketsTestCase(testpackets.PacketsTestBase):

    @staticmethod
    def polute(packet):
        if packet.type == pokerpackets.PACKET_POKER_USER_INFO:
            packet.money = {5: (1,2,3), 10: (10,11,12)}
        else:
            testpackets.PacketsTestBase.polute(packet)
        
    def packUnpack(self, packet, field):
        packed = packet.pack()
        other_packet = pokerpackets.PacketFactory[packet.type]()
        other_packet.unpack(packed)
        self.assertEqual(packed, other_packet.pack())
        self.assertEqual(packet.__dict__[field], other_packet.__dict__[field])
        info_packet = pokerpackets.PacketFactory[packet.type]()
        info_packet.infoUnpack(packed);
        self.assertEqual(packed, info_packet.infoPack())
        
    #--------------------------------------------------------------    
    def test_all(self):
        verbose = int(os.environ.get('VERBOSE_T', '-1'))
        for type_index in pokerpackets._TYPES:
            if pokerpackets.PacketFactory.has_key(type_index):
                if verbose > 0:
                    print pokerpackets.PacketNames[type_index]
                self.packetCheck(type = pokerpackets.PacketFactory[type_index])

    #--------------------------------------------------------------    
    def test_PacketPokerPlayerArrive(self):
        packet = pokerpackets.PacketPokerPlayerArrive(seat = 1)
        self.packUnpack(packet, 'seat')
        packet = pokerpackets.PacketPokerPlayerArrive(blind = None)
        self.packUnpack(packet, 'blind')
        packet = pokerpackets.PacketPokerPlayerArrive(blind = False)
        self.packUnpack(packet, 'blind')

    #--------------------------------------------------------------    
    def test_PacketPokerUserInfo(self):
        packet = pokerpackets.PacketPokerUserInfo(money = {1: (2, 3, 4), 10: (20, 30, 40)})
        self.packUnpack(packet, 'money')
        self.failUnless("20/30/40" in str(packet))

    #--------------------------------------------------------------    
    def test_PacketPokerPlayersList(self):
        packet = pokerpackets.PacketPokerPlayersList(players = [('name', 10, 20)])
        self.packUnpack(packet, 'players')
        self.failUnless("name|10|20" in str(packet))
        
    #--------------------------------------------------------------    
    def test_PacketPokerMoneyTransfert(self):
        packet = pokerpackets.PacketPokerCashIn(note = ('url', 10, 'name', 20))
        self.packUnpack(packet, 'name')
        self.failUnless("name = name" in str(packet))        

    #--------------------------------------------------------------    
    def test_verifyfactory(self):
        from pokernetwork.pokerpackets import PacketNames, PacketFactory
        for packid in PacketNames.keys():
            self.failUnless(PacketFactory.has_key(packid))
            self.assertEquals(PacketFactory[packid].type, packid)
        for packid in PacketFactory.keys():
            self.failUnless(PacketNames.has_key(packid))
    #--------------------------------------------------------------    
    def test_PacketPokerTable(self):
        packet = pokerpackets.PacketPokerTable(tourney_serial = 2)
        self.failUnless("tourney_serial = 2" in str(packet))
    #--------------------------------------------------------------    
    def test_PacketPokerSetLocale(self):
        packet = pokerpackets.PacketPokerSetLocale(serial = 42, locale = "fr_FR", game_id = 100)
        self.packUnpack(packet, 'game_id')
        self.failUnless("100" in str(packet))
#--------------------------------------------------------------    
    def test_verifyfactory(self):
        from pokernetwork.pokerpackets import PacketNames, PacketFactory
        for packid in PacketNames.keys():
            self.failUnless(PacketFactory.has_key(packid))
            self.assertEquals(PacketFactory[packid].type, packid)
        for packid in PacketFactory.keys():
            self.failUnless(PacketNames.has_key(packid))
                            


#--------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(PokerPacketsTestCase))
    return suite
    
#--------------------------------------------------------------
def Run(verbose = 2):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
    
#--------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerpackets.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerpackets.py' TESTS='coverage-reset test-pokerpackets.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerrestclient
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2009 Johan Euphrosine <proppy@aminche.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

from twisted.trial import unittest, runner, reporter
from twisted.internet import defer, reactor
from twisted.internet import defer
from twisted.python.util import InsensitiveDict

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from tests import testclock

from pokernetwork import  pokerrestclient
from pokernetwork import pokerservice
from pokernetwork import pokernetworkconfig
from pokernetwork import pokermemcache
from pokernetwork import pokersite
from pokernetwork.pokerpackets import *

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19481" />
  <resthost host="127.0.0.1" port="19481" path="/POKER_REST" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

class PokerRestClientTestCase(unittest.TestCase):
      def destroyDb(self, arg = None):
            if len("") > 0:
                  os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
            else:
                  os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")
      # --------------------------------------------------------------
      def initServer(self):
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml_server)
            self.server_service = pokerservice.PokerService(settings)
            self.server_service.disconnectAll = lambda: True
            self.server_service.startService()
            self.server_site = pokersite.PokerSite(settings, pokerservice.PokerRestTree(self.server_service))
            self.server_port = reactor.listenTCP(19481, self.server_site, interface="127.0.0.1")
      # --------------------------------------------------------------
      def setUp(self):
            testclock._seconds_reset()
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            pokermemcache.memcache_singleton = {}
            self.destroyDb()
            self.initServer()
      # --------------------------------------------------------------
      def tearDownServer(self):
            self.server_site.stopFactory()
            d = self.server_service.stopService()
            d.addCallback(lambda x: self.server_port.stopListening())
            return d
      # --------------------------------------------------------------
      def tearDown(self):
            d = self.tearDownServer()
            d.addCallback(self.destroyDb)
            d.addCallback(lambda x: reactor.disconnectAll())
            return d
      # --------------------------------------------------------------
      def test01_longPoll(self):
            def longPollCallback(packets):
                  self.assertEquals(PACKET_PING, packets[0].type)
            client = pokerrestclient.PokerRestClient('127.0.0.1', 19481, '/POKER_REST?explain=no', longPollCallback, verbose=6)
            def sendPacketData(data):
                  self.assertSubstring('LongPoll', data)
                  return '[ { "type": "PacketPing" } ]'
            client.sendPacketData = sendPacketData
            self.assertNotEquals(None, client.timer)
            client.longPoll()
            self.assertEquals(True, client.pendingLongPoll)
            self.assertEquals(None, client.timer)
            return client.queue
      # --------------------------------------------------------------
      def test02_longPollReturn(self):
            packets = []
            client = pokerrestclient.PokerRestClient('127.0.0.1', 19481, '/POKER_REST?explain=no', lambda packets: None, verbose=6)
            def sendPacketData(data):
                  packets.append(data)
                  return "[]"
            client.sendPacketData = sendPacketData
            client.longPoll()
            d = client.sendPacket(PacketPokerTableSelect(), '{"type": "PacketPokerTableSelect"}')
            d.addCallback(lambda arg: self.assertSubstring('LongPollReturn', packets[1]))
            d.addCallback(lambda arg: self.assertNotEquals(None, client.timer))
            return client.queue
      # --------------------------------------------------------------
      def test03_longPollSchedule(self):
            client = pokerrestclient.PokerRestClient('127.0.0.1', 19481, '/POKER_REST?explain=no', lambda packets: None, verbose=6)
            client.sendPacketData = lambda data: "[]"
            client.longPoll()
            client.longPoll()
            self.assertNotEquals(None, client.timer)
            client.clearTimeout()
            return client.queue
      # --------------------------------------------------------------
      def test04_sendPacketData(self):
            client = pokerrestclient.PokerRestClient('127.0.0.1', 19481, '/POKER_REST?explain=no', None, verbose=6)
            d = client.sendPacketData('{"type": "PacketPokerTableSelect"}')
            d.addCallback(lambda data: self.assertSubstring('PacketPokerTableList', data))
            return d
      # --------------------------------------------------------------
      def test05_sendPacket(self):
            client = pokerrestclient.PokerRestClient('127.0.0.1', 19481, '/POKER_REST?explain=no', None, verbose=6)
            d = client.sendPacket(PacketPokerTableSelect(), '{"type": "PacketPokerTableSelect"}')
            d.addCallback(lambda packets: self.assertEquals(PACKET_POKER_TABLE_LIST, packets[0].type))
            return d
      # --------------------------------------------------------------
      def test06_404(self):
            client = pokerrestclient.PokerRestClient('127.0.0.1', 19481, '/POKER_REST2', None, verbose=6)
            d = client.sendPacket(PacketPokerTableSelect(), '{"type": "PacketPokerTableSelect"}')
            d.addCallback(lambda packets: self.assertEquals(PACKET_ERROR, packets[0].type))
            return d
      # --------------------------------------------------------------
      def test07_connectionFailed(self):
            client = pokerrestclient.PokerRestClient('127.0.0.1', 20000, '/POKER_REST?explain=no', None, verbose=6)
            d = client.sendPacket(PacketPokerTableSelect(), '{"type": "PacketPokerTableSelect"}')
            d.addCallback(lambda packets: self.assertEquals(PACKET_ERROR, packets[0].type))
            return d
      def test08_noCallback(self):
            client = pokerrestclient.PokerRestClient('127.0.0.1', 20000, '/POKER_REST?explain=no', None, verbose=6)
            self.assertEquals(-1, client.longPollFrequency)
            self.assertEquals(None, client.timer)

class MockRequest:
      def finish(self): pass
      def setResponseCode(self, arg1, arg2): pass
      def handlerHeader(self, arg1, arg2): pass
      def setHeader(self, arg1, arg2): pass
      def write(self, arg1): pass

class MockReason():
      def check(self, reason): return False

class PokerProxyClientFactoryTestCase(unittest.TestCase):
      def destroyDb(self, arg = None):
            if len("") > 0:
                  os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
            else:
                  os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")
      # --------------------------------------------------------------
      def initServer(self):
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml_server)
            self.server_service = pokerservice.PokerService(settings)
            self.server_service.disconnectAll = lambda: True
            self.server_service.startService()
            self.server_site = pokersite.PokerSite(settings, pokerservice.PokerRestTree(self.server_service))
            self.server_port = reactor.listenTCP(19481, self.server_site, interface="127.0.0.1")
      # --------------------------------------------------------------
      def setUp(self):
            testclock._seconds_reset()
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            pokermemcache.memcache_singleton = {}
            self.destroyDb()
            self.initServer()
      # --------------------------------------------------------------
      def tearDownServer(self):
            self.server_site.stopFactory()
            d = self.server_service.stopService()
            d.addCallback(lambda x: self.server_port.stopListening())
            return d
      # --------------------------------------------------------------
      def tearDown(self):
            d = self.tearDownServer()
            d.addCallback(self.destroyDb)
            d.addCallback(lambda x: reactor.disconnectAll())
            return d
      # --------------------------------------------------------------
      def test01_proxy(self):
            data = '{"type": "PacketPing"}'
            headers = InsensitiveDict()
            headers.setdefault('Content-Length', len(data))
            headers.setdefault("connection", "close")
            headers.setdefault("proxy-connection", "foo")
            host = '127.0.0.1'
            port = 19481
            path = '/POKER_REST'
            factory = pokerrestclient.PokerProxyClientFactory('POST', path, '1.1', headers, data, MockRequest(), 6, host + ':' + str(port) + path)
            reactor.connectTCP(host, port, factory)
            factory.deferred.addCallback(self.assertNotEquals, None)
            return factory.deferred
      # --------------------------------------------------------------
      def test02_proxy_failed(self):
            factory = pokerrestclient.PokerProxyClientFactory("command", "rest", "version", "headers", "data", "father",
                                                              "verbose", "destination")
            def errback(reason):
                  self.assertNotEquals(None, reason)
            factory.deferred.addErrback(errback)
            factory.clientConnectionFailed(None, MockReason())
            return factory.deferred
      # --------------------------------------------------------------
      def test03_proxy_lost(self):
            factory = pokerrestclient.PokerProxyClientFactory("command", "rest", "version", "headers", "data", "father",
                                                              "verbose", "destination")
            def errback(reason):
                  self.assertNotEquals(None, reason)
            factory.deferred.addErrback(errback)
            factory.clientConnectionLost(None, MockReason())
            return factory.deferred

def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test05"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerRestClientTestCase))
    suite.addTest(loader.loadClass(PokerProxyClientFactoryTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
        tracebackFormat='default',
        ).run(suite)

if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerrestclient.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerrestclient.py' VERBOSE_T=-1 TESTS='coverage-reset test-pokerrestclient.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerserver-run-load
#!/usr/bin/python
# -*- mode: python; coding: iso-8859-1 -*-
# more information about the above line at http://www.python.org/dev/peps/pep-0263/
#
# Copyright (C) 2009 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os, tempfile, shutil
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import unittest
from twisted.internet import reactor, defer

from cStringIO import StringIO

settings_xml_server_open_options = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19481" %(listen_options)s />
  <resthost host="127.0.0.1" port="19481" path="/POKER_REST" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf %(additional_path)s</path>
  <users temporary="BOT"/>
</server>
"""
# ------------------------------------------------------------
class PokerServerRunTestCase(unittest.TestCase):
    def destroyDb(self, arg = None):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")
    # -------------------------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.tmpdir = tempfile.mkdtemp()
        self.saveSysout = None
        self.saveArgv = None
    # -------------------------------------------------------------------------
    def tearDown(self):
        shutil.rmtree(self.tmpdir)
        if self.saveSysout:
            value = sys.stdout.getvalue()
            if self.expectedOutput:
                self.failUnless(value.find(self.expectedOutput) >= 0,
                                "Unable to find " + self.expectedOutput + " in " + value)
            sys.stdout = self.saveSysout
        if self.saveArgv:
            sys.argv = self.saveArgv
    # -------------------------------------------------------------------------
    def holdStdout(self):
        self.saveSysout = sys.stdout
        sys.stdout = StringIO()
    # -------------------------------------------------------------------------
    def setArgv(self, newArgv):
        self.saveArgv = sys.argv
        sys.argv = newArgv
    # -------------------------------------------------------------------------
    def test01_validConfig_mockupStartApplication(self):
        """test01_validConfig_mockupStartApplication
        Test that the pokerserver application runs properly.  Since the
        reactor.run() is called by pokerserver's run(), this test might
        HANG INDEFINITELY for some types of test failures.  Unlikely but
        possible."""
        from pokernetwork.pokerserver import run as pokerServerRun

        from twisted.application import app
        configFile = os.path.join(self.tmpdir, "ourconfig.xml")
        configFH = open(configFile, "w")
        configFH.write(settings_xml_server_open_options %\
                       { 'listen_options' : '',
                        'additional_path' : self.tmpdir,
                        'script_dir': SCRIPT_DIR})
        self.setArgv([configFile])
        configFH.close()

        def mockStartApplication(application, val):
            from twisted.python.components import Componentized
            self.failUnless(isinstance(application, Componentized))
            self.assertEquals(val, None)
        savedStartApplication = app.startApplication
        app.startApplication = mockStartApplication

        def doCallback(val):
            self.assertEquals(val, "done")
            app.startApplication = savedStartApplication
            reactor.stop()

        defferedStillRunningMeansReactorNotStarted = defer.Deferred()
        defferedStillRunningMeansReactorNotStarted.addCallback(doCallback)

        reactor.callLater(1, lambda: defferedStillRunningMeansReactorNotStarted.callback("done"))
        pokerServerRun()
# ------------------------------------------------------------
class PokerServerLoadingSSLTestCase(unittest.TestCase):
    # ----------------------------------------------------------------
    def test01_openSSLMissing(self):
        """test01_openSSLMissing"""
        import sys

        for mod in ['OpenSSL', 'pokernetwork', 'pokerserver']:
            if sys.modules.has_key(mod): del sys.modules[mod]

        realImporter = __builtins__.__import__

        def failSSLImport(moduleName, *args, **kwargs):
            if moduleName == "OpenSSL":
                raise Exception("SSL was imported")
            else:
                return realImporter(moduleName, *args, **kwargs)

        __builtins__.__import__  = failSSLImport

        oldStout = sys.stdout
        sys.stdout = StringIO()

        from pokernetwork import pokerserver as ps

        value = sys.stdout.getvalue()
        sys.stdout = oldStout

        self.failIf(ps.HAS_OPENSSL, "HAS_OPENSSL should be False when OpenSSL.SSL is not available")
        self.failUnless('openSSL not available.' in value)

        __builtins__.__import__  = realImporter
# ------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    # Make sure you do the LoadingSSLTestCase FIRST.
    suite.addTest(unittest.makeSuite(PokerServerLoadingSSLTestCase))
    suite.addTest(unittest.makeSuite(PokerServerRunTestCase))

    # Comment out above and use line below this when you wish to run just
    # one test by itself (changing prefix as needed).
#    suite.addTest(unittest.makeSuite(PokerGameHistoryTestCase, prefix = "test2"))
    return suite
# -----------------------------------------------------------------------------
def Run(verbose = 2):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
# -----------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerserver-run-load.py tests/test-pokerserver.py ) ; ( cd ../tests ; make VERBOSE_T=-1 COVERAGE_FILES='../pokernetwork/pokerserver.py' TESTS='coverage-reset test-pokerserver-run-load.py test-pokerserver.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerserver
#!/usr/bin/python
# -*- mode: python; coding: iso-8859-1 -*-
# more information about the above line at http://www.python.org/dev/peps/pep-0263/
#
# Copyright (C) 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2008 Johan Euphrosine <proppy@aminche.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys, os, tempfile, shutil, exceptions, libxml2
from cStringIO import StringIO

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

from twisted.trial import unittest, runner, reporter
from twisted.application import service
from twisted.internet import reactor, defer
from pokernetwork.pokerserver import makeService, makeApplication
from pokernetwork.pokerserver import run as pokerServerRun
from twisted.manhole import telnet
from twisted.application.internet import SSLServer
from twisted.application.internet import TCPServer
from twisted.web.server import Site as TwistedSite
from pokernetwork.pokerservice import PokerService, PokerRestTree, PokerFactoryFromPokerService, SSLContextFactory
from pokernetwork.pokersite import PokerSite
from pokernetwork.pokertable import PokerTable

from tests.testmessages import silence_all_messages, search_output, clear_all_messages, get_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
silence_all_messages()

settings_xml_server_manhole = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19481" manhole="%(manhole_port)i" />
  <resthost host="127.0.0.1" port="19481" path="/POKER_REST" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
"""

# Dummy CERT borrowed from Debian's snake-oil certificate.  Including it
# here since I can't assume what distribution I am on.

snake_oil_cert = """-----BEGIN CERTIFICATE-----
MIIDKzCCApQCCQDEKuqSPjfcEDANBgkqhkiG9w0BAQUFADCB2TELMAkGA1UEBhMC
WFgxKjAoBgNVBAgTIVRoZXJlIGlzIG5vIHN1Y2ggdGhpbmcgb3V0c2lkZSBVUzET
MBEGA1UEBxMKRXZlcnl3aGVyZTEOMAwGA1UEChMFT0NPU0ExPDA6BgNVBAsTM09m
ZmljZSBmb3IgQ29tcGxpY2F0aW9uIG9mIE90aGVyd2lzZSBTaW1wbGUgQWZmYWly
czEXMBUGA1UEAxMObWFwbGUuc2ZsYy12cG4xIjAgBgkqhkiG9w0BCQEWE3Jvb3RA
bWFwbGUuc2ZsYy12cG4wHhcNMDkwMTAyMTg1NzA0WhcNMDkwMjAxMTg1NzA0WjCB
2TELMAkGA1UEBhMCWFgxKjAoBgNVBAgTIVRoZXJlIGlzIG5vIHN1Y2ggdGhpbmcg
b3V0c2lkZSBVUzETMBEGA1UEBxMKRXZlcnl3aGVyZTEOMAwGA1UEChMFT0NPU0Ex
PDA6BgNVBAsTM09mZmljZSBmb3IgQ29tcGxpY2F0aW9uIG9mIE90aGVyd2lzZSBT
aW1wbGUgQWZmYWlyczEXMBUGA1UEAxMObWFwbGUuc2ZsYy12cG4xIjAgBgkqhkiG
9w0BCQEWE3Jvb3RAbWFwbGUuc2ZsYy12cG4wgZ8wDQYJKoZIhvcNAQEBBQADgY0A
MIGJAoGBAO0t+HjxiiliSHO9kge943+cXHGCtJp4/RPpHDN7hbpblY+FYCjuCmW/
/m2G59aMMl2Uwj1BO8cDwdGDtkNV21vcIo0siSD9VREFiYcLthaOK98muqD+Tfqa
MuGzZyui1RKuirCZzqyJPS2SXOtWSXUW8YQa75y/o4vcQSWWZ3VDAgMBAAEwDQYJ
KoZIhvcNAQEFBQADgYEApx7Q+PzLgdJu7OQJ776Kr+EI+Ho03pM5Nb5e26P5ZL6h
hk+gRLfBt8q3bihx4qjBSOpx1Qxq+BAMg6SAkDzkz+tN2CSr/vv2uuc26cDaf1co
oKCay2gMThIoURl+FSPeWAraGWbrcVy9ctoCipxMza9fn42dbn9OHxP/M+0qgvY=
-----END CERTIFICATE-----
-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDtLfh48YopYkhzvZIHveN/nFxxgrSaeP0T6Rwze4W6W5WPhWAo
7gplv/5thufWjDJdlMI9QTvHA8HRg7ZDVdtb3CKNLIkg/VURBYmHC7YWjivfJrqg
/k36mjLhs2crotUSroqwmc6siT0tklzrVkl1FvGEGu+cv6OL3EEllmd1QwIDAQAB
AoGBAL4ws+QABIOE/YZaSKSOn8Rv1S1s23hXdtGlh2i9L5It6LOrB14q7AmFuPeJ
S5We3LBwHoZSLiY7nAtvLBO44GmwpSiJuLaI0z/7YIqkS6KjiDy1GFdQ5IEaRzxK
nyDcvES4h4QdOa/UeMEWg8TmasEoG3Wm3+aZt5KRz57HQQJRAkEA/uN0aw+1jqVP
YKbG89k7DEdNOdfgLjFofXruwXPfQmEFNg3Vp5ke1SeaR0tzYDXgZ5fDlwnR0EgA
HrR0om3PKwJBAO42vxdAVjrfMt0ws0wTmKS7mLlY8p7dKVKKIwP6F2b/61QyEX7z
czjyBaegw8qbX93OD0g2TETms73Py4WFJkkCQBV97FUSsAZlHfpSVbg9+uKgKHzW
HQsIE31xHiylro+USrIyHG/TU2w5uKKGVCYqpM9XVqCnrU9Yotnz8Vm41J0CQQCf
VccjikkjP8AJ61VCgakMJt7UuwYt9Mh7CSK6ukGFB5Ek1AiX3ccoQ9o8cXAEyUCq
X/Yg2xDQ1W9Mev0q5hDhAkBKSJF0V/24bz27z1yUSzHRHO3FAKXepkR81g6IRl41
r9nOQTOBo04TLBXtyP+o7GFNzBjEm6fVaqwk5SVsdQ+t
-----END RSA PRIVATE KEY-----
"""
settings_xml_server_open_options = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19481" %(listen_options)s />
  <resthost host="127.0.0.1" port="19481" path="/POKER_REST" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf %(additional_path)s</path>
  <users temporary="BOT"/>
</server>
"""
# ----------------------------------------------------------------
class PokerServerMakeServiceManholeTestCase(unittest.TestCase):
    def destroyDb(self, arg = None):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")
    # -------------------------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.tmpdir = tempfile.mkdtemp()
        self.filename = os.path.join(self.tmpdir, "poker.server.xml")
        f = open(self.filename, "w")
        self.manhole_port = 33333
        f.write(settings_xml_server_manhole %\
                {'manhole_port' : self.manhole_port,
                 'script_dir': SCRIPT_DIR})
        f.close()
        argv =  [self.filename]
        self.service = makeService(self.filename)
        self.service.startService()
    # -------------------------------------------------------------------------
    def tearDown(self):
        shutil.rmtree(self.tmpdir)
        return self.service.stopService()
    # -------------------------------------------------------------------------
    def test01_manhole(self):
        self.assertEquals(self.service.namedServices.keys(), ['manhole'])
        manhole = self.service.getServiceNamed('manhole')
        self.assertNotEqual(None, manhole)
        self.assertEqual(self.manhole_port, manhole._port.port)
        self.assertEqual('127.0.0.1', manhole._port.interface)
        self.assertEqual(telnet.Shell, manhole._port.factory.protocol)
        self.assertEquals(manhole._port.connected, 1)
        self.assertEquals(manhole.parent, self.service)
        self.failUnless(manhole.running)
        self.assertNotEqual(None, manhole._port.factory.namespace['poker_service'])
        self.assertNotEqual(None, manhole._port.factory.namespace['poker_site'])
# ----------------------------------------------------------------
class PokerServerMakeServiceCoverageTestCase(unittest.TestCase):
    def destroyDb(self, arg = None):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")
    # -------------------------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.tmpdir = tempfile.mkdtemp()
        self.filename = os.path.join(self.tmpdir, "poker.server.xml")
    # -------------------------------------------------------------------------
    def createService(self):
        self.service = makeService(self.filename)
        self.service.startService()
    # -------------------------------------------------------------------------
    def tearDown(self):
        shutil.rmtree(self.tmpdir)
        if hasattr(self, 'service'):
            return self.service.stopService()
        else:
            return None
    # -------------------------------------------------------------------------
    def createConfig(self, optionsDict):
        configFH = open(self.filename, "w")
        optionsDict['script_dir'] = SCRIPT_DIR
        configFH.write(settings_xml_server_open_options % optionsDict)
        configFH.close()
    # -------------------------------------------------------------------------
    def createPemFile(self):
        pemFile = os.path.join(self.tmpdir, "poker.pem")
        pemFH = open(pemFile, "w")
        pemFH.write(snake_oil_cert)
        pemFH.close()
    # -------------------------------------------------------------------------
    def test00_missingSettingsFile(self):
        caughtIt = False
        try:
            self.createService()
            self.fail("previous line should have thrown exception")
        except exceptions.SystemExit, e:
            self.assertEquals(e.__str__(), "1")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
    # -------------------------------------------------------------------------
    def test01_emptySettingsFile(self):
        f = open(self.filename, "w")
        f.close()
        caughtIt = False
        try:
            self.createService()
            self.fail("previous line should have thrown exception")
        except libxml2.parserError, e:
            self.assertEquals(e.__str__(),'xmlParseFile() failed')
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
    # -------------------------------------------------------------------------
    def test02_tcpSsl_hasSSL(self):
        self.createConfig({'listen_options' : 'tcp_ssl="3234"',
                          'additional_path' : self.tmpdir})
        self.createPemFile()

        self.createService()

        # Only named service that we could possibly expect is manhole, and
        # that's not turned on here.  Hence:
        self.assertEquals(self.service.namedServices, {})

        self.assertEquals(len(self.service.services), 3)
        for service in self.service.services:
            self.assertEquals(service.parent, self.service)
            if isinstance(service, PokerService):
                self.assertEquals(len(service.tables.keys()), 2)
                self.failUnless(isinstance(service.tables[1], PokerTable))
                self.failUnless(isinstance(service.tables[2], PokerTable))
            elif isinstance(service, TCPServer):
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of pokernetwork.pokerservice.PokerFactoryFromPokerService on") == 0)
                self.failUnless(service._port.port > 1024)
                self.assertNotEquals(service._port.port, 3234)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            elif isinstance(service, SSLServer):
                self.failUnless(isinstance(service.args[1], PokerFactoryFromPokerService))
                self.failUnless(isinstance(service.args[2], SSLContextFactory))
                self.assertEquals(service._port.__str__(),
                                  "<<class 'twisted.internet.ssl.Port'> of pokernetwork.pokerservice.PokerFactoryFromPokerService on 3234>")
                self.assertEquals(service._port.port, 3234)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.assertNotEquals(service._port.ctxFactory, None)
                self.assertEquals(service._port.ctxFactory, service.args[2])
                self.failUnless(service.running)
            else:
                self.fail("Unknown service found in multiservice list")
    # -------------------------------------------------------------------------
    def test03_tcpSsl_hasSSL_noPemFile(self):
        self.createConfig({'listen_options' : 'tcp_ssl="3234"',
                          'additional_path' : self.tmpdir})
        caughtIt = False
        try:
            self.createService()
            self.fail("previous line should have thrown exception")
        except exceptions.TypeError, ee:
            self.assertEquals(ee.__str__(),'use_certificate_file() argument 1 must be string, not None')
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
    # -------------------------------------------------------------------------
    def test04_httpSSL_hasSSL_noPemFile(self):
        self.createConfig({'listen_options' : 'http_ssl="3234"',
                          'additional_path' : self.tmpdir})
        caughtIt = False
        try:
            self.createService()
            self.fail("previous line should have thrown exception")
        except exceptions.TypeError, ee:
            self.assertEquals(ee.__str__(),'use_certificate_file() argument 1 must be string, not None')
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
    # -------------------------------------------------------------------------
    def test05_httpSSL_hasSSL(self):
        self.createConfig({'listen_options' : 'http_ssl="9356"',
                          'additional_path' : self.tmpdir})
        self.createPemFile()

        self.createService()

        # Only named service that we could possibly expect is manhole, and
        # that's not turned on here.  Hence:
        self.assertEquals(self.service.namedServices, {})

        self.assertEquals(len(self.service.services), 3)
        for service in self.service.services:
            self.assertEquals(service.parent, self.service)
            if isinstance(service, PokerService):
                self.assertEquals(len(service.tables.keys()), 2)
                self.failUnless(isinstance(service.tables[1], PokerTable))
                self.failUnless(isinstance(service.tables[2], PokerTable))
            elif isinstance(service, TCPServer):
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of pokernetwork.pokerservice.PokerFactoryFromPokerService on") == 0)
                self.failUnless(service._port.port > 1024)
                self.assertNotEquals(service._port.port, 9356)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            elif isinstance(service, SSLServer):
                self.failUnless(isinstance(service.args[1], TwistedSite))
                self.failUnless(isinstance(service.args[2], SSLContextFactory))
                self.assertEquals(service._port.__str__(),
                                  "<<class 'twisted.internet.ssl.Port'> of twisted.web.server.Site on 9356>")
                self.assertEquals(service._port.port, 9356)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.assertEquals(service._port.ctxFactory, service.args[2])
                self.failUnless(service.running)
            else:
                self.fail("Unknown service found in multiservice list")
    # -------------------------------------------------------------------------
    def test06_restSSL_hasSSL_noPemFile(self):
        self.createConfig({'listen_options' : 'rest_ssl="10234"',
                          'additional_path' : self.tmpdir})
        caughtIt = False
        try:
            self.createService()
            self.fail("previous line should have thrown exception")
        except exceptions.TypeError, ee:
            self.assertEquals(ee.__str__(),'use_certificate_file() argument 1 must be string, not None')
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
    # -------------------------------------------------------------------------
    def test07_restSSL_hasSSL(self):
        self.createConfig({'listen_options' : 'rest_ssl="10234"',
                          'additional_path' : self.tmpdir})
        self.createPemFile()

        self.createService()

        # Only named service that we could possibly expect is manhole, and
        # that's not turned on here.  Hence:
        self.assertEquals(self.service.namedServices, {})

        self.assertEquals(len(self.service.services), 3)
        for service in self.service.services:
            self.assertEquals(service.parent, self.service)
            if isinstance(service, PokerService):
                self.assertEquals(len(service.tables.keys()), 2)
                self.failUnless(isinstance(service.tables[1], PokerTable))
                self.failUnless(isinstance(service.tables[2], PokerTable))
            elif isinstance(service, TCPServer):
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of pokernetwork.pokerservice.PokerFactoryFromPokerService on") == 0)
                self.failUnless(service._port.port > 1024)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            elif isinstance(service, SSLServer):
                self.failUnless(isinstance(service.args[1], PokerSite))
                self.failUnless(isinstance(service.args[1].resource, PokerRestTree))
                self.failUnless(isinstance(service.args[2], SSLContextFactory))
                self.assertEquals(service._port.__str__(),
                                  "<<class 'twisted.internet.ssl.Port'> of pokernetwork.pokersite.PokerSite on 10234>")
                self.assertEquals(service._port.port, 10234)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.assertEquals(service._port.ctxFactory, service.args[2])
                self.failUnless(service.running)
            else:
                self.fail("Unknown service found in multiservice list")
    # -------------------------------------------------------------------------
    def test08_plainREST(self):
        self.createConfig({'listen_options' : 'rest="11944"',
                          'additional_path' : self.tmpdir})
        self.createService()

        # Only named service that we could possibly expect is manhole, and
        # that's not turned on here.  Hence:
        self.assertEquals(self.service.namedServices, {})

        self.assertEquals(len(self.service.services), 3)
        count = 0
        for service in self.service.services:
            self.assertEquals(service.parent, self.service)
            if isinstance(service, PokerService):
                count += 1
                self.assertEquals(len(service.tables.keys()), 2)
                self.failUnless(isinstance(service.tables[1], PokerTable))
                self.failUnless(isinstance(service.tables[2], PokerTable))
            elif isinstance(service, TCPServer) and service._port.port == 11944:
                count += 1
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of pokernetwork.pokersite.PokerSite on 11944>") == 0)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            elif isinstance(service, TCPServer):
                count += 1
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of pokernetwork.pokerservice.PokerFactoryFromPokerService on") == 0)
                self.failUnless(service._port.port > 1024)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            else:
                self.fail("Unknown service found in multiservice list")
        self.assertEquals(len(self.service.services), count)
    # -------------------------------------------------------------------------
    def test09_plainHTTP(self):
        self.createConfig({'listen_options' : 'http="10235"',
                          'additional_path' : self.tmpdir})
        self.createService()

        # Only named service that we could possibly expect is manhole, and
        # that's not turned on here.  Hence:
        self.assertEquals(self.service.namedServices, {})

        self.assertEquals(len(self.service.services), 3)
        count = 0
        for service in self.service.services:
            self.assertEquals(service.parent, self.service)
            if isinstance(service, PokerService):
                count += 1
                self.assertEquals(len(service.tables.keys()), 2)
                self.failUnless(isinstance(service.tables[1], PokerTable))
                self.failUnless(isinstance(service.tables[2], PokerTable))
            elif isinstance(service, TCPServer) and service._port.port == 10235:
                count += 1
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of twisted.web.server.Site on 10235>") == 0)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            elif isinstance(service, TCPServer):
                count += 1
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of pokernetwork.pokerservice.PokerFactoryFromPokerService on") == 0)
                self.failUnless(service._port.port > 1024)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            else:
                self.fail("Unknown service found in multiservice list")
        self.assertEquals(len(self.service.services), count)
    # -------------------------------------------------------------------------
    def test10_everythingOn(self):
        #"19481"
        self.createConfig({'listen_options' :
        'http="7658" http_ssl="6675" rest="5563" rest_ssl="7765" tcp_ssl="9123" manhole="10143"',
                          'additional_path' : self.tmpdir})
        self.createPemFile()
        self.createService()

        self.assertEquals(self.service.namedServices.keys(), ['manhole'])
        self.failUnless(isinstance(self.service.namedServices['manhole'], TCPServer))

        # Check Manhole first
        manhole = self.service.getServiceNamed('manhole')
        self.assertNotEqual(None, manhole)
        self.assertEqual(10143, manhole._port.port)
        self.assertEqual('127.0.0.1', manhole._port.interface)
        self.assertEqual(telnet.Shell, manhole._port.factory.protocol)
        self.assertEquals(manhole._port.connected, 1)
        self.assertEquals(manhole.parent, self.service)
        self.failUnless(manhole.running)
        self.assertNotEqual(None, manhole._port.factory.namespace['poker_service'])
        self.assertNotEqual(None, manhole._port.factory.namespace['poker_site'])

        self.assertEquals(len(self.service.services), 8)
        count = 0
        for service in self.service.services:
            self.assertEquals(service.parent, self.service)
            if isinstance(service, PokerService):
                count += 1
                self.assertEquals(len(service.tables.keys()), 2)
                self.failUnless(isinstance(service.tables[1], PokerTable))
                self.failUnless(isinstance(service.tables[2], PokerTable))
            elif isinstance(service, TCPServer) and service._port.port == 19481:
                count += 1
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of pokernetwork.pokerservice.PokerFactoryFromPokerService on 19481") == 0)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            elif isinstance(service, TCPServer) and service._port.port == 10143:
                count += 1
                print service._port.__str__()
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of twisted.manhole.telnet.ShellFactory on 10143>") == 0)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '127.0.0.1')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            elif isinstance(service, SSLServer) and service._port.port == 9123:
                count += 1
                self.failUnless(isinstance(service.args[1], PokerFactoryFromPokerService))
                self.failUnless(isinstance(service.args[2], SSLContextFactory))
                self.assertEquals(service._port.__str__(),
                                  "<<class 'twisted.internet.ssl.Port'> of pokernetwork.pokerservice.PokerFactoryFromPokerService on 9123>")
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.assertNotEquals(service._port.ctxFactory, None)
                self.assertEquals(service._port.ctxFactory, service.args[2])
                self.failUnless(service.running)
            elif isinstance(service, SSLServer) and service._port.port == 6675:
                count += 1
                self.failUnless(isinstance(service.args[1], TwistedSite))
                self.failUnless(isinstance(service.args[2], SSLContextFactory))
                self.assertEquals(service._port.__str__(),
                                  "<<class 'twisted.internet.ssl.Port'> of twisted.web.server.Site on 6675>")
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.assertEquals(service._port.ctxFactory, service.args[2])
                self.failUnless(service.running)
            elif isinstance(service, SSLServer) and service._port.port == 7765:
                count += 1
                self.failUnless(isinstance(service.args[1], PokerSite))
                self.failUnless(isinstance(service.args[1].resource, PokerRestTree))
                self.failUnless(isinstance(service.args[2], SSLContextFactory))
                self.assertEquals(service._port.__str__(),
                                  "<<class 'twisted.internet.ssl.Port'> of pokernetwork.pokersite.PokerSite on 7765>")
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.assertEquals(service._port.ctxFactory, service.args[2])
                self.failUnless(service.running)
            elif isinstance(service, TCPServer) and service._port.port == 5563:
                count += 1
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of pokernetwork.pokersite.PokerSite on 5563>") == 0)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            elif isinstance(service, TCPServer) and service._port.port == 7658:
                count += 1
                self.failUnless(service._port.__str__().find("<<class 'twisted.internet.tcp.Port'> of twisted.web.server.Site on 7658>") == 0)
                self.assertEquals(service._port.port, service._port._realPortNumber)
                self.assertEquals(service._port.interface, '')
                self.assertEquals(service._port.connected, 1)
                self.assertNotEquals(service._port.socket, None)
                self.failIf(hasattr(service._port, 'ctxFactory'))
                self.failUnless(service.running)
            else:
                self.fail("Unknown service found in multiservice list")
        self.assertEquals(len(self.service.services), count)
# ----------------------------------------------------------------
class PokerServerMakeApplicationCoverageTestCase(unittest.TestCase):
    def destroyDb(self, arg = None):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")
    # -------------------------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.tmpdir = tempfile.mkdtemp()
    # -------------------------------------------------------------------------
    def tearDown(self):
        shutil.rmtree(self.tmpdir)
    # -------------------------------------------------------------------------
    def test00_missingConfigFileGivenOnCLI(self):
        doesNotExistFile = os.path.join(self.tmpdir, "thisdoesnotexist.xml")
        caughtIt = False
        try:
            makeApplication([doesNotExistFile])
            self.fail("previous line should have thrown exception")
        except exceptions.SystemExit, e:
            self.assertEquals(e.__str__(), "1")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
    # -------------------------------------------------------------------------
    def test01_missingConfigFileGivenOnCLI_sysVersionDitched(self):
        doesNotExistFile = os.path.join(self.tmpdir, "doesnotexists.xml")
        saveSysVersion = sys.version
        sys.version = "BMK"
        caughtIt = False
        try:
            makeApplication([doesNotExistFile])
            self.fail("previous line should have thrown exception")
        except exceptions.SystemExit, e:
            self.assertEquals(e.__str__(), "1")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")
        sys.version = saveSysVersion
    # -------------------------------------------------------------------------
    def test02_validConfig(self):
        configFile = os.path.join(self.tmpdir, "ourconfig.xml")
        configFH = open(configFile, "w")
        configFH.write(settings_xml_server_open_options %\
                       { 'listen_options' : '', 'additional_path' : '',
                        'script_dir': SCRIPT_DIR})
        configFH.close()
        application =  makeApplication([configFile])
        from twisted.python.components import Componentized
        self.failUnless(isinstance(application, Componentized))
# ----------------------------------------------------------------
class PokerServerRunCoverageTestCase(unittest.TestCase):
    def destroyDb(self, arg = None):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")
    # -------------------------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.tmpdir = tempfile.mkdtemp()
        self.saveSysout = None
        self.saveArgv = None
    # -------------------------------------------------------------------------
    def tearDown(self):
        shutil.rmtree(self.tmpdir)
        if self.saveSysout:
            value = sys.stdout.getvalue()
            if self.expectedOutput:
                self.failUnless(value.find(self.expectedOutput) >= 0,
                                "Unable to find " + self.expectedOutput + " in " + value)
            sys.stdout = self.saveSysout
        if self.saveArgv:
            sys.argv = self.saveArgv
    # -------------------------------------------------------------------------
    def holdStdout(self):
        self.saveSysout = sys.stdout
        sys.stdout = StringIO()
    # -------------------------------------------------------------------------
    def setArgv(self, newArgv):
        self.saveArgv = sys.argv
        sys.argv = newArgv
    # -------------------------------------------------------------------------
    def test00_missingConfigFileGivenOnCLI(self):
        doesNotExistFile = os.path.join(self.tmpdir, "thisdoesnotexist.xml")
        caughtIt = False
        self.holdStdout()
        try:
            sys.argv = [ doesNotExistFile ]
            pokerServerRun()
            self.fail("previous line should have thrown exception")
        except exceptions.SystemExit, e:
            self.assertEquals(e.__str__(), "1")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")

        self.expectedOutput = "poll reactor already installed"
    def test01_missingConfigFileGivenOnCLI_forceReactorInstall(self):
        import platform
        from twisted.internet import pollreactor
        doesNotExistFile = os.path.join(self.tmpdir, "thisdoesnotexist.xml")
        caughtIt = False
        self.holdStdout()

        saveSystem = platform.system
        if platform.system() == "Windows":
            def fakeSystem():
                return "NotWindowsButReallyIs"
            platform.system = fakeSystem

        reactorCalled = False
        def reactorFake():
            reactorCalled = True
        saveReactor = pollreactor.install
        pollreactor.install = reactorFake

        reactorModulesSave = sys.modules['twisted.internet.reactor']
        del sys.modules['twisted.internet.reactor']

        try:
            pokerServerRun()
            self.fail("previous line should have thrown exception")
        except exceptions.SystemExit, e:
            self.assertEquals(e.__str__(), "1")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")

        self.expectedOutput = "installing poll reactor"

        self.failIf(reactorCalled, "Poll reactor should have been installed")

        if saveSystem:
            platform.system = saveSystem
        pollreactor.install = saveReactor
        sys.modules['twisted.internet.reactor'] = reactorModulesSave
# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test_trynow"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerServerMakeServiceManholeTestCase))
    suite.addTest(loader.loadClass(PokerServerMakeServiceCoverageTestCase))
    suite.addTest(loader.loadClass(PokerServerMakeApplicationCoverageTestCase))
    suite.addTest(loader.loadClass(PokerServerRunCoverageTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#       reporter.TextReporter,
#	tracebackFormat='verbose',
        tracebackFormat='default',
        ).run(suite)

if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerserver.py tests/test-pokerserver-run-load.py ) ; ( cd ../tests ; make VERBOSE_T=-1 COVERAGE_FILES='../pokernetwork/pokerserver.py' TESTS='coverage-reset test-pokerserver.py test-pokerserver-run-load.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokerservice-load
#!/usr/bin/python
# -*- mode: python; coding: iso-8859-1 -*-
# more information about the above line at http://www.python.org/dev/peps/pep-0263/
#
# Copyright (C) 2009 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Bradley M. Kuhn <bkuhn@ebb.org>
#
import sys, os, tempfile, shutil

import unittest
from cStringIO import StringIO

sys.path.insert(0, "./..")
sys.path.insert(0, "..")

tmpdir = tempfile.mkdtemp()
open(os.path.join(tmpdir, "__init__.py"), "w").close()

# Dummy up the OpenSSL file so that OpenSSL.SSL won't import.

openSslFile = os.path.join(tmpdir, "OpenSSL.py")
open(openSslFile, "w").close()

# Dummy up the OpenSSL file so that OpenSSL.SSL won't import.

soapFile = os.path.join(tmpdir, "SOAPpy.py")
soapFH = open(soapFile, "w")
soapFH.write("""raise NotImplementedError("overriden to force error")\n""")
soapFH.close()
        
# Note, you very much need the below for this test.  This is because
# inside each test, the cwd is different and the above relative pathnames
# don't work.
sys.path[:] = map(os.path.abspath, sys.path)

##############################################################################
class LogicThatOccursDuringLoadTestCase(unittest.TestCase):
    # ----------------------------------------------------------------
    def test01_openSSLMissing_badTwistedLoad_soapPyMissing(self):
        """test01_openSSLMissing_badTwistedLoad_soapPyMissing"""
        import sys

        oldPath = sys.path
        sys.path.insert(0, tmpdir)

        from twisted.application import service
        from twisted.internet import protocol, reactor, defer
        from twisted.python.runtime import seconds
        from twisted.web import server, resource, util, http
        from zope.interface import Interface as ZopeRealInterface

        import twisted.python.components as comps

        comps.Interface = ZopeRealInterface

        # Now, do something super-nasty.  It's setting up the test for the
        # zope.interface.implements stuff by delete those things from
        # zope.

        fh = open(openSslFile, "w")
        fh.write("from zope import interface as MockChopInterface\nsaveMe = MockChopInterface.implements\ndel MockChopInterface.implements\n")
        fh.close()

        for mod in ['OpenSSL', 'pokernetwork', 'pokerservice']:
            if sys.modules.has_key(mod): del sys.modules[mod]

        oldStout = sys.stdout
        sys.stdout = StringIO()

        from pokernetwork import pokerservice as ps

        value = sys.stdout.getvalue()
        sys.stdout = oldStout

        self.failIf(ps.HAS_OPENSSL, "HAS_OPENSSL should be False when OpenSSL.SSL is not available")
        self.assertEquals(value, 'openSSL not available.\nPython SOAP module not available\n')

        oldStout = sys.stdout
        sys.stdout = StringIO()

        # Cleanup the loading weirness to fail twisted
        import OpenSSL
        OpenSSL.MockChopInterface.implements = OpenSSL.saveMe

        # Next, we'll test ps.implements that was defined 

        saveGetFrame = sys._getframe
        
        class MockFrameFirstRaise():
            def __init__(self):
                self.f_locals = ['testing']
                self.f_globals = ['something else' ]
        def getFirstRaiseFrame(x): return MockFrameFirstRaise()

        sys._getframe = getFirstRaiseFrame
        gotError = False
        try:
            ps.implements(None)
            self.failIf(True, "should not reach this point, TypeError should occur")
        except TypeError, te:
            self.assertEquals(te.__str__(), " can be used only from a class definition.")
            gotError = True
        self.failUnless(gotError, "Should have caught a TypeError")

        class MockFrameSecondRaise():
            def __init__(self):
                self.f_locals = ['__implements__', '__module__']
                self.f_globals = ['something else']

        def getSecondRaiseFrame(x): return MockFrameSecondRaise()
        
        sys._getframe = getSecondRaiseFrame

        gotError = False
        try:
            ps.implements(None)
            self.failIf(True, "should not reach this point, TypeError should occur")
        except TypeError, te:
            self.assertEquals(te.__str__(), " can be used only once in a class definition.")
            gotError = True
        self.failUnless(gotError, "Should have caught a TypeError")
        sys._getframe = saveGetFrame

##############################################################################
class CleanupTempDir(unittest.TestCase):
    def test01_cleanupTempDir(self):
        shutil.rmtree(tmpdir)
##############################################################################
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(LogicThatOccursDuringLoadTestCase))
    suite.addTest(unittest.makeSuite(CleanupTempDir))
    # Comment out above and use line below this when you wish to run just
    # one test by itself (changing prefix as needed).
#    suite.addTest(unittest.makeSuite(PokerChipsTestCase, prefix = "test2"))
    return suite
# ----------------------------------------------------------------
def GetTestedModule():
    return pokerservice
# ----------------------------------------------------------------
def Run(verbose):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())
# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run(2).wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerservice.py tests/test-pokerservice-load.py ) ; ( cd ../tests ; make VERBOSE_T=-1 COVERAGE_FILES='../pokernetwork/pokerservice.py' TESTS='coverage-reset test-pokerservice-load.py test-pokerservice.py coverage-report' check )"
# End:


########NEW FILE########
__FILENAME__ = test-pokerservice
#!/usr/bin/python
# -*- mode: python; coding: iso-8859-1 -*-
# more information about the above line at http://www.python.org/dev/peps/pep-0263/
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)       2008, 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C)             2009 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2006             Mekensleep <licensing@mekensleep.com>
#                                24 rue vieille du temple 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@gnu.org>
#  Bradley M. Kuhn <bkuhn@ebb.org>
#  Cedric Pinson <cpinson@freesheep.org>
#
import sys, os, tempfile, shutil
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import time

from string import split
import libxml2
import random
import locale
import sets
from _mysql_exceptions import IntegrityError
import exceptions
from pprint import pprint
from datetime import date

from tests import testclock

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages, search_output, clear_all_messages, get_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
silence_all_messages()

from pokerengine import pokertournament, pokergame
from pokernetwork import pokerservice, pokernetworkconfig, user
from pokernetwork import currencyclient
from pokernetwork import pokerdatabase
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerpackets import *
from pokernetwork.packets import PacketError
from pokernetwork.pokertable  import PokerAvatarCollection
from MySQLdb.cursors import DictCursor


class ConstantDeckShuffler:
    def shuffle(self, what):
        what[:] = [40, 13, 32, 9, 19, 31, 15, 14, 50, 34, 20, 6, 43, 44, 28, 29, 48, 3, 21, 45, 23, 37, 35, 11, 5, 22, 24, 30, 27, 39, 46, 33, 0, 8, 1, 42, 36, 16, 49, 2, 10, 26, 4, 18, 7, 41, 47, 17]

from pokerengine import pokergame
pokergame.shuffler = ConstantDeckShuffler()

class ConstantPlayerShuffler:
    def shuffle(self, what):
        what.sort()

from pokerengine import pokertournament
pokertournament.shuffler = ConstantPlayerShuffler()

TABLE1 = 1
TABLE2 = 2
TABLE3 = 3

# Note that we use the locale fr_FR.ISO-8859-1 here for testing.  This must be
# a valid locale on the system!  Important tests are skipped otherwise!!!

localLocale = locale.getlocale(locale.LC_ALL)
FRENCH_LOCALE_MISSING = False
MESSAGE_WHEN_FRENCH_LOCALE_MISSING = "WARNING: Locale fr_FR.ISO-8859-1 missing, so certain tests will be SKIPPED and coverage will be INCOMPLETE! FAIL!  fail!"
try:
    locale.setlocale(locale.LC_ALL, "fr_FR.ISO-8859-1")
except locale.Error, le:
    print MESSAGE_WHEN_FRENCH_LOCALE_MISSING
    FRENCH_LOCALE_MISSING = True

locale.setlocale(locale.LC_ALL, localLocale)


settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" remove_completed="1" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <language value="en_US.ISO-8859-1"/>
  <language value="fr_FR.ISO-8859-1"/>
  <language value="fr_FX.ISO-8859-1"/>
  <language value="de_DE.ISO-8859-1"/>
  <language value="en_GB.ISO-8859-1"/>
  <language value="es_ES.ISO-8859-1"/>
  <language value="nl_NL.ISO-8859-1"/>
  <language value="fr_BE.ISO-8859-1"/>
  <language value="en_CA.ISO-8859-1"/>
  <language value="fr_CA.ISO-8859-1"/>
  <language value="it_IT.ISO-8859-1"/>
  <language value="pt_PT.ISO-8859-1"/>
  <language value="da_DK.ISO-8859-1"/>
  <language value="fi_FI.ISO-8859-1"/>
  <language value="nb_NO.ISO-8859-1"/>
  <language value="sv_SE.ISO-8859-1"/>
  <language value="this_locale_does_not_exist"/>

  <stats type="RankPercentile"/>

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

def fun_name():
    try:
        raise ZeroDivisionError
    except ZeroDivisionError:
        return sys.exc_info()[2].tb_frame.f_back.f_code.co_name

class MockCursorBase:
    def __init__(cursorSelf, testObject, acceptList):
        cursorSelf.testObject = testObject
        cursorSelf.rowcount = 0
        cursorSelf.closedCount = 0
        cursorSelf.counts = {}
        cursorSelf.acceptedStatements = acceptList
        cursorSelf.row = ()
        for cntType in cursorSelf.acceptedStatements:
            cursorSelf.counts[cntType] = 0
    def close(cursorSelf):
        cursorSelf.closedCount += 1
    def statementActions(cursorSelf, sql, statment):
        raise NotImplementedError("MockCursor subclass must implement this")
    def execute(*args):
        cursorSelf = args[0]
        sql = args[1]
        found = False
        for statement in cursorSelf.acceptedStatements:
            if sql[:len(statement)] == statement:
                cursorSelf.counts[statement] += 1
                cursorSelf.rowcount = 0
                found = True
                break
        cursorSelf.row = (None,)
        cursorSelf.testObject.failUnless(found, "Unknown sql statement: " + sql)
        cursorSelf.statementActions(sql, statement)
        return cursorSelf.rowcount
    def fetchone(cursorSelf): return cursorSelf.row

class MockDatabase:
    def __init__(dbSelf, cursorClass):
        class MockInternalDatabase:
            def literal(intDBSelf, *args): return args[0]
        dbSelf.db = MockInternalDatabase()
        dbSelf.cursorValue = cursorClass()
    def cursor(dbSelf): return dbSelf.cursorValue
    def literal(dbSelf, val): return dbSelf.db.literal(val)

class PokerServiceTestCaseBase(unittest.TestCase):

    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    # ----------------------------------------------------------------
    def setUp(self, settingsFile = settings_xml):
        testclock._seconds_reset()
        self.destroyDb()
        self.settings = settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settingsFile, len(settingsFile))
        settings.header = settings.doc.xpathNewContext()
        self.db = pokerdatabase.PokerDatabase(settings)
        self.service = pokerservice.PokerService(settings)
        self.default_money = 10000000
#        self.service.verbose = 0
#        self.service.verbose = 4

    # ----------------------------------------------------------------
    def tearDown(self):
        self.db.close()
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d

    # ----------------------------------------------------------------
    def createUsers(self):
        cursor = self.db.cursor()
        for user_number in (1, 2, 3):
            cursor.execute("INSERT INTO users (name, password, created) VALUES ('user%d', 'password%d', 0)" % ( user_number, user_number ))
            self.assertEqual(1, cursor.rowcount)

        ( (self.user1_serial, name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        ( (self.user2_serial, name, privilege), message ) = self.service.auth("user2", "password2", "role1")
        ( (self.user3_serial, name, privilege), message ) = self.service.auth("user3", "password3", "role1")

        for user_number in (self.user1_serial, self.user2_serial, self.user3_serial):
            if self.default_money > 0 and user_number == self.user3_serial:
                cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount) VALUES (%d, 2, %d)" % ( user_number, self.default_money ) )
                self.assertEqual(1, cursor.rowcount)

        cursor.close()

monitor_settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <listen tcp="19480" />

  <monitor>.././monitorplugin.py</monitor>
  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

class MonitorTestCase(unittest.TestCase):

    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()
        self.destroyDb()
        settings = pokernetworkconfig.Config([])
        settings.loadFromString(monitor_settings_xml)
        self.db = pokerdatabase.PokerDatabase(settings)
        self.service = pokerservice.PokerService(settings)

    # ----------------------------------------------------------------
    def tearDown(self):
        self.db.close()
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d

    # ----------------------------------------------------------------
    def test01_monitor(self):
        self.service.startService()
        test = self
        class Avatar:
            protocol = True
            def sendPacketVerbose(self, packet):
                test.assertEquals(PACKET_POKER_MONITOR_EVENT, packet.type)
                test.assertEquals(1, packet.event)
                test.assertEquals(2, packet.param1)
                test.assertEquals(3, packet.param2)
                self.sent = True
        avatar = Avatar()
        self.assertEquals(PACKET_ACK, self.service.monitor(avatar).type)
        self.service.databaseEvent(event = 1, param1 = 2, param2 = 3)
        self.failUnless(avatar.sent)
        self.failUnless(hasattr(self.service, 'HERE'))
        cursor = self.db.cursor()
        cursor.execute("SELECT COUNT(*) FROM monitor WHERE event = 1")
        self.assertEquals(1, cursor.rowcount)

class CleanUpTestCase(PokerServiceTestCaseBase):

    # ----------------------------------------------------------------
    def test01_cleanUp(self):
        self.service.startService()
        db = self.service.db
        cursor = db.cursor()
        cursor.execute("INSERT INTO users (serial, name, password, created) VALUES (43, 'BOTAA', 'passwordAA', 0)")
        cursor.execute("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (43, 1, 200)")
        cursor.execute("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (44, 1, 200)")
        self.service.cleanUp('BOT')
        cursor.execute("SELECT COUNT(*) FROM users WHERE name like 'BOT%'")
        self.assertEqual(0, cursor.fetchone()[0])
        #
        # Bot removed from tourney
        #
        cursor.execute("SELECT COUNT(*) FROM user2tourney WHERE user_serial = 43")
        self.assertEqual(0, cursor.fetchone()[0])
        #
        # Non bot not removed from tourney
        #
        cursor.execute("SELECT COUNT(*) FROM user2tourney WHERE user_serial = 44")
        self.assertEqual(1, cursor.fetchone()[0])
        cursor.close()

list_table_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" remove_completed="1" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="NL HE 10-max 100/200" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="NL HE 6-max 100/200" variant="holdem" betting_structure="100-200-no-limit" seats="6" player_timeout="60" currency_serial="2" />
  <table name="Limit HE 10-max 2/4" variant="holdem" betting_structure="2-4-limit" seats="10" player_timeout="60" currency_serial="2" />
  <table name="Limit HE 6-max 2/4" variant="holdem" betting_structure="2-4-limit" seats="6" player_timeout="60" currency_serial="1" />
  <table name="Stud 8-max 2/4" variant="7stud" betting_structure="2-4-limit" seats="8" player_timeout="60" currency_serial="2" />

  <listen tcp="19480" />

  <language value="en_US.ISO-8859-1"/>

  <stats type="RankPercentile"/>

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

class ListTablesSearchTablesTestCases(PokerServiceTestCaseBase):
    def setUp(self):
        PokerServiceTestCaseBase.setUp(self, settingsFile = list_table_xml)
    # ----------------------------------------------------------------
    def test01_my(self):
        self.service.startService()
        db = self.service.db
        serial = 44
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE1))
        tables = self.service.listTables('my', serial)
        self.assertEqual(1, len(tables))
        self.assertEqual(tables[0]['serial'], TABLE1)
    # ----------------------------------------------------------------
    def test02_currency(self):
        self.service.startService()
        tables = self.service.listTables('50', 0)
        self.assertEqual(0, len(tables))
        tables = self.service.listTables('1', 0)
        self.assertEqual(2, len(tables))
        tables = self.service.listTables('2', 0)
        self.assertEqual(3, len(tables))
    # ----------------------------------------------------------------
    def test03_currency_and_variant(self):
        self.service.startService()
        tables = self.service.listTables('1\tfakevariant', 0)
        self.assertEqual(0, len(tables))
        tables = self.service.listTables('2\tfakevariant', 0)
        self.assertEqual(0, len(tables))
        tables = self.service.listTables('1\tholdem', 0)
        self.assertEqual(2, len(tables))
        tables = self.service.listTables('2\tholdem', 0)
        self.assertEqual(2, len(tables))
        tables = self.service.listTables('1\t7stud', 0)
        self.assertEqual(0, len(tables))
        tables = self.service.listTables('2\t7stud', 0)
        self.assertEqual(1, len(tables))
    # ----------------------------------------------------------------
    def test04_variant(self):
        self.service.startService()
        tables = self.service.listTables('\tfakevariant', 0)
        self.assertEqual(0, len(tables))
        tables = self.service.listTables('\tholdem', 0)
        self.assertEqual(4, len(tables))
        tables = self.service.listTables('\t7stud', 0)
        self.assertEqual(1, len(tables))
    # ----------------------------------------------------------------
    def test05_all(self):
        self.service.startService()
        tables = self.service.listTables('', 0)
        self.assertEqual(5, len(tables))
        tables = self.service.listTables('all', 0)
        self.assertEqual(5, len(tables))
    # ----------------------------------------------------------------
    def test06_name(self):
        self.service.startService()
        tables = self.service.listTables('fakename', 0)
        self.assertEqual(0, len(tables))
        for name in [ "NL HE 10-max 100/200", "NL HE 6-max 100/200",
                      "Limit HE 10-max 2/4", "Limit HE 6-max 2/4", "Stud 8-max 2/4" ]:
            tables = self.service.listTables(name, 0)
            self.assertEqual(1, len(tables))
    # ----------------------------------------------------------------
    def test07_currency_and_variant_and_bettingStructure(self):
        self.service.startService()
        tables = self.service.searchTables(1, 'fakevariant', 'fakebetting')
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(2, 'fakevariant', '2-4-limit')
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(None, 'fakevariant', '2-4-limit')
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(None, None, '2-4-limit')
        self.assertEqual(3, len(tables))
        tables = self.service.searchTables(None, None, '100-200-no-limit')
        self.assertEqual(2, len(tables))
        tables = self.service.searchTables(None, 'holdem', '100-200-no-limit')
        self.assertEqual(2, len(tables))
        tables = self.service.searchTables(None, 'holdem', '2-4-limit')
        self.assertEqual(2, len(tables))
        tables = self.service.searchTables(None, '7stud', '2-4-limit')
        self.assertEqual(1, len(tables))
        tables = self.service.searchTables(None, '7stud', '100-200-no-limit')
        self.assertEqual(0, len(tables))
    # ----------------------------------------------------------------
    def test08_currency_and_variant_and_bettingStructure_and_count_noOne(self):
        self.service.startService()
        tables = self.service.searchTables(1,'fakevariant', 'fakebetting', 2)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(2, 'fakevariant', '2-4-limit', 2)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(None, 'fakevariant', '2-4-limit', 2)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(None, None, '2-4-limit', 2)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(None, None, '100-200-no-limit', 2)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(None, 'holdem', '100-200-no-limit', 2)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(None, 'holdem', '2-4-limit', 2)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(None, '7stud', '2-4-limit', 2)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(None, '7stud', '100-200-no-limit', 2)
        self.assertEqual(0, len(tables))
    # ----------------------------------------------------------------
    def test09_currency_and_variant_and_bettingStructure_and_count_withSome(self):
        self.service.startService()
        clear_all_messages()
        nlHe100Currency1 = 1
        nlHe100Currency2 = 2
        limitHE24Currency2 = 3
        limitHE24Currency1 = 4
        stud24Currency2 = 5

        insertSql = "UPDATE pokertables SET players = %d WHERE serial = %d"
        db = self.service.db

        db.db.query(insertSql % (2, limitHE24Currency1))
        db.db.query(insertSql % (2, limitHE24Currency2))
        db.db.query(insertSql % (1, stud24Currency2))

        tables = self.service.searchTables(None, None, None, 0)
        self.assertEqual(5, len(tables))
        tables = self.service.searchTables(None, None, '2-4-limit', 0)
        self.assertEqual(3, len(tables))

        tables = self.service.searchTables(None, None, '2-4-limit', 1)
        self.assertEqual(3, len(tables), "searchTables() should return 3 for 2-4-limit w/ <= 1 player")
        tables = self.service.searchTables(None, None, None, 1)
        self.assertEqual(3, len(tables), "searchTables() query should return 3 for <= 1 player")

        tables = self.service.searchTables(None, None, '2-4-limit', 2)
        self.assertEqual(2, len(tables))
        tables = self.service.searchTables(None, None, None, 2)
        self.assertEqual(2, len(tables))

        for ii in [ 3, 4, 5, 6 ]:
            tables = self.service.searchTables(None, None, '2-4-limit', ii)
            self.assertEqual(0, len(tables))
            tables = self.service.searchTables(None, None, None, ii)
            self.assertEqual(0, len(tables))

        tables = self.service.searchTables(None, 'holdem', None, 0)
        self.assertEqual(4, len(tables))
        tables = self.service.searchTables(None, 'holdem', '2-4-limit', 0)
        self.assertEqual(2, len(tables))

        for ii in [ 1, 2 ]:
            tables = self.service.searchTables(None, 'holdem', '2-4-limit', ii)
            self.assertEqual(2, len(tables), "holdem 2-4-limit <= %d players should be 2" % ii)
            tables = self.service.searchTables(None, 'holdem', None, ii)
            self.assertEqual(2, len(tables), "holdem <= %d players should be 2" % ii)

        for ii in [ 3, 4, 5, 6 ]:
            tables = self.service.searchTables(None, 'holdem', '2-4-limit', ii)
            self.assertEqual(0, len(tables))
            tables = self.service.searchTables(None, 'holdem', None, ii)
            self.assertEqual(0, len(tables))

        # The 100-200 NL tables have no one initially, check that, then
        # add two players to each, checking that now a search for at least
        # two works.

        for query in [ '\t\t100-200-no-limit\t0',  '\tholdem\t100-200-no-limit\t0']:
            tables = self.service.searchTables(None, None, '100-200-no-limit', 0)
            self.assertEqual(2, len(tables), "100-200-no-limit should be 2")
            tables = self.service.searchTables(None, 'holdem', '100-200-no-limit', 0)
            self.assertEqual(2, len(tables), "100-200-no-limit w/ holdem should be 2")

        for ii in [ 1, 2, 3, 4, 5, 6]:
            for query in [ '\t\t100-200-no-limit\t%d',  '\tholdem\t100-200-no-limit\t%d']:
                tables = self.service.searchTables(None, None, '100-200-no-limit', ii)
                self.assertEqual(0, len(tables))
                tables = self.service.searchTables(None, 'holdem', '100-200-no-limit', ii)
                self.assertEqual(0, len(tables))

        db.db.query(insertSql % (3, nlHe100Currency1))
        db.db.query(insertSql % (2, nlHe100Currency2))

        for ii in [ 0, 1, 2 ]:
            for query in  [ '\t\t100-200-no-limit\t%d', '\tholdem\t100-200-no-limit\t%d']:
                for variant in [ None, 'holdem' ]:
                    tables = self.service.searchTables(None, variant, '100-200-no-limit', ii)
                    self.assertEqual(2, len(tables))

        for variant in [ None, 'holdem' ]:
            tables = self.service.searchTables(None, variant, '100-200-no-limit', 3)
            self.assertEqual(1, len(tables))

        for ii in [ 4, 5, 6 ]:
            for variant in [ None, 'holdem' ]:
                tables = self.service.searchTables(None, variant, '100-200-no-limit', ii)
                self.assertEqual(0, len(tables))

        # Now we have a variety of holdem tables, so we can search for
        # holdem user counts without a betting_structure.  There should be
        # four holdem tables with at least 2 people, and one holdem table
        # with at least 3 people.

        for ii in [ 0, 1, 2 ]:
            tables = self.service.searchTables(None, 'holdem', None, ii)
            self.assertEqual(4, len(tables),
              "searchTables() query: holdem w/ players <= %d yields %d not 4" % (ii, len(tables)))

        tables = self.service.searchTables(None, 'holdem', None, 3)
        self.assertEqual(1, len(tables))

        for ii in [ 4, 5, 6 ]:
            tables = self.service.searchTables(None, 'holdem', None, ii)
            self.assertEqual(0, len(tables))

        # Stud only has one player, check that, then add one and see result change.
        tables = self.service.searchTables(None, '7stud', '2-4-limit', 2)
        self.assertEqual(0, len(tables))
        db.db.query(insertSql % (2, stud24Currency2))
        tables = self.service.searchTables(None, '7stud', '2-4-limit', 2)
        self.assertEqual(1, len(tables))

        # Tests with currency serial tests in place

        tables = self.service.searchTables(1, None, None, 0)
        self.assertEqual(2, len(tables), "search for currency_serial 1 yields %d not 4"
                         % len(tables))
        for ii in [ 0, 1, 2 ]:
            tables = self.service.searchTables(1, None, None, ii)
            self.assertEqual(2, len(tables))
            tables = self.service.searchTables(1, 'holdem', None, ii)
            self.assertEqual(2, len(tables))
            tables = self.service.searchTables(1, 'holdem', '100-200-no-limit', ii)
            self.assertEqual(1, len(tables))
            tables = self.service.searchTables(1, 'holdem', '2-4-limit', ii)
            self.assertEqual(1, len(tables))
            tables = self.service.searchTables(1, None, '2-4-limit', ii)
            self.assertEqual(1, len(tables))
            tables = self.service.searchTables(1, '7stud', None, ii)
            self.assertEqual(0, len(tables))
            tables = self.service.searchTables(1, '7stud', '2-4-limit', ii)
            self.assertEqual(0, len(tables))

        tables = self.service.searchTables(2, None, None, 0)
        self.assertEqual(3, len(tables))
        for ii in [ 0, 1, 2 ]:
            tables = self.service.searchTables(2, None, None, ii)
            self.assertEqual(3, len(tables))
            tables = self.service.searchTables(2, 'holdem', None, ii)
            self.assertEqual(2, len(tables))
            tables = self.service.searchTables(2, 'holdem', '100-200-no-limit', ii)
            self.assertEqual(1, len(tables))
            tables = self.service.searchTables(2, 'holdem', '2-4-limit', ii)
            self.assertEqual(1, len(tables))
            tables = self.service.searchTables(2, None, '2-4-limit', ii)
            self.assertEqual(2, len(tables))
            tables = self.service.searchTables(2, '7stud', None, ii)
            self.assertEqual(1, len(tables))
            tables = self.service.searchTables(2, '7stud', '2-4-limit', ii)
            self.assertEqual(1, len(tables))

        # The threes are different: all currency two queries with holdem
        # don't have three.  Also, all stud queries on currency 1 have no one, because
        # there are no currency 1 stud tables.
        tables = self.service.searchTables(2, None, None, 3)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(2, 'holdem', None, 3)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(2, 'holdem', '100-200-no-limit', 3)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(2, 'holdem', '2-4-limit', 3)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(2, None, '2-4-limit', 3)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(1, '7stud', None, 3)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(1, '7stud', '2-4-limit', 3)
        self.assertEqual(0, len(tables))

        tables = self.service.searchTables(1, None, None, 3)
        self.assertEqual(1, len(tables), "searchTables() query: yields %d not 1" % len(tables))
        tables = self.service.searchTables(1, 'holdem', None, 3)
        self.assertEqual(1, len(tables), "searchTables() query: yields %d not 1" % len(tables))
        tables = self.service.searchTables(1, 'holdem', '100-200-no-limit', 3)
        self.assertEqual(1, len(tables), "searchTables() query: yields %d not 1" % len(tables))

        # The rest have zero
        tables = self.service.searchTables(1, 'holdem', '2-4-limit', 3)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(1, None, '2-4-limit', 3)
        self.assertEqual(0, len(tables))
        tables = self.service.searchTables(1, '7stud', None, 3)
        self.assertEqual(0, len(tables))

        # Finally, no query beyond 3 users should be anything but zero.
        for ii in [ 4, 5, 6 ]:
            for currencySerial in [ 1, 2, None ]:
                for variant in [ None, 'holdem', '7stud', '' ]:
                    for betting in [ None, '', '2-4-limit', '100-200-no-limit' ]:
                        tables = self.service.searchTables(currencySerial, variant, betting, ii)
                        self.assertEqual(0, len(tables))
        self.assertEquals(get_messages(), [])
    # ----------------------------------------------------------------
    def test10_tooMany(self):
        self.service.startService()

        clear_all_messages()
        tables = self.service.listTables('\tholdem\t', 0)
        self.assertEqual(4, len(tables))
        self.assertEquals(get_messages(), ["*ERROR* Following listTables() criteria string has more parameters than expected, ignoring third one and beyond in: \tholdem\t"])
    # ----------------------------------------------------------------
    def test11_currencySerialIsNotAnInteger(self):
        self.service.startService()

        clear_all_messages()
        tables = self.service.listTables("hithere\t", 0)
        self.assertEqual(0, len(tables))
        self.assertEquals(get_messages(), ["*ERROR* listTables(): currency_serial parameter must be an integer, instead was: hithere"])
    # ----------------------------------------------------------------
    def test13_emptyArgsShouldGenerateSameAsSelectAll(self):
        self.service.startService()

        clear_all_messages()
        tables = self.service.listTables("all", 0)
        allSelectCount = len(tables)
        self.assertEquals(allSelectCount, 5)
        self.assertEquals(get_messages(), [])

        clear_all_messages()
        tables = self.service.listTables("\t", 0)
        self.assertEqual(allSelectCount, len(tables))
        self.assertEquals(get_messages(), [])
    # ----------------------------------------------------------------
    def test14_sqlInjectionInParametersShouldNotWork(self):
        self.service.startService()

        clear_all_messages()
        tables = self.service.listTables("\tholdem'; DELETE from pokertables WHERE variant = 'holdem", 0)
        self.assertEqual(0, len(tables))
        self.assertEquals(get_messages(), [])

        clear_all_messages()
        tables = self.service.listTables("\tholdem", 0)
        self.assertEqual(4, len(tables))
        self.assertEquals(get_messages(), [])
###############################################################################
# Much of GetTableByCriteriaTestCase() is testing the algorithm defined in
# getTableBestByCriteria()

class MockPlayerForCriteria:
    def __init__(self, sittingIn = True):
        self.sittingIn = sittingIn
    def isSit(self): return self.sittingIn

class GetTableBestByCriteriaTestCase(PokerServiceTestCaseBase):
    def setUp(self):
        PokerServiceTestCaseBase.setUp(self, settingsFile = list_table_xml)
        self.service.startService()
    # ----------------------------------------------------------------
    def giveUserMoney(self, userSerial, currencySerial, amount):
        """Note: only call this after service is started in the test."""
        db = self.service.db

        insertSql = "INSERT INTO user2money(amount, user_serial, currency_serial) VALUES(%s, %d, %d)"
        db.db.query(insertSql % (str(amount), userSerial, currencySerial))
    # ----------------------------------------------------------------
    def test00_nothingReturnedDueToNoTableMatchingString(self):
        self.giveUserMoney(22, 2, 100000)
        self.giveUserMoney(22, 3, 100000)
        self.giveUserMoney(22, 1, 100000)

        # There are no tables that take currency 3.
        self.assertEquals(self.service.getTableBestByCriteria(22, 3), None)
    # ----------------------------------------------------------------
    def test01_nothingReturnedDueToNotEnoughMoney(self):
        self.giveUserMoney(22, 1, 999)
        self.giveUserMoney(22, 2, 999)

        self.assertEquals(self.service.getTableBestByCriteria(22, 1), None)
        self.assertEquals(self.service.getTableBestByCriteria(22, 2), None)
    # ----------------------------------------------------------------
    def test02_onlySubSetPossibleDueToLimitedFunds(self):
        from pokernetwork.pokertable import PokerTable

        self.giveUserMoney(22, 1, 5000)
        self.giveUserMoney(22, 2, 5000)

        tableCurrency1 = self.service.getTableBestByCriteria(22, 1)
        tableCurrency2 = self.service.getTableBestByCriteria(22, 2)

        self.failUnless(isinstance(tableCurrency1, PokerTable))
        self.failUnless(isinstance(tableCurrency2, PokerTable))

        self.assertEquals(tableCurrency1.game.id, 4)
        self.failUnless(tableCurrency2.game.id in [ 3, 5 ])
    # ----------------------------------------------------------------
    def test03_manyChoicesDueToWealth(self):
        from pokernetwork.pokertable import PokerTable

        self.giveUserMoney(22, 1, 200000)
        self.giveUserMoney(22, 2, 200000)

        tableCurrency1 = self.service.getTableBestByCriteria(22, 1)
        tableCurrency2 = self.service.getTableBestByCriteria(22, 2)

        self.failUnless(isinstance(tableCurrency1, PokerTable))
        self.failUnless(isinstance(tableCurrency2, PokerTable))

        self.failUnless(tableCurrency1.game.id in [ 1, 4 ])
        self.failUnless(tableCurrency2.game.id in [ 2, 3, 5 ])
    # ----------------------------------------------------------------
    def test04_nothingFoundDueToFullness(self):
        self.giveUserMoney(22, 1, 1000)

        # Mock up full table.
        table = self.service.getTable(4)
        for ii in range(table.game.max_players):
            table.game.serial2player[ii] = MockPlayerForCriteria()

        self.assertEquals(self.service.getTableBestByCriteria(22, 1), None)
    # ----------------------------------------------------------------
    def test05_noneDueToAskingForPlayers(self):
        self.giveUserMoney(22, 1, 200000)

        self.assertEquals(self.service.getTableBestByCriteria(22, 1, min_players = 3), None)
    # ----------------------------------------------------------------
    def test06_oneSpecificDueToPlayerSittingOut(self):
        self.giveUserMoney(99, 1, 200000)

        nlHe100Currency1 = 1
        limitHE24Currency1 = 4

        # Note to properly mock up players at the table, you have to both
        # fill the DB properly and set the game object correctly

        insertSql = "UPDATE pokertables SET players = %d WHERE serial = %d"
        db = self.service.db
        db.db.query(insertSql % (3, limitHE24Currency1))
        db.db.query(insertSql % (3, nlHe100Currency1))

        for ii in range(3):
            table = self.service.getTable(limitHE24Currency1)
            table.game.serial2player[ii] = MockPlayerForCriteria()
            table = self.service.getTable(nlHe100Currency1)
            table.game.serial2player[ii] = MockPlayerForCriteria(ii != 0)

        from pokernetwork.pokertable import PokerTable

        foundTable = self.service.getTableBestByCriteria(99, 1, min_players = 3)

        self.failUnless(isinstance(foundTable, PokerTable))

        self.assertEquals(foundTable.game.id, limitHE24Currency1)
    # ----------------------------------------------------------------
    def test07_noneDueToSittingOut(self):
        self.giveUserMoney(99, 1, 200000)

        nlHe100Currency1 = 1
        limitHE24Currency1 = 4

        # Note to properly mock up players at the table, you have to both
        # fill the DB properly and set the game object correctly

        insertSql = "UPDATE pokertables SET players = %d WHERE serial = %d"
        db = self.service.db
        db.db.query(insertSql % (3, limitHE24Currency1))
        db.db.query(insertSql % (3, nlHe100Currency1))

        for ii in range(3):
            table = self.service.getTable(limitHE24Currency1)
            table.game.serial2player[ii] = MockPlayerForCriteria(ii != 1)
            table = self.service.getTable(nlHe100Currency1)
            table.game.serial2player[ii] = MockPlayerForCriteria(ii != 0)

        from pokernetwork.pokertable import PokerTable

        foundTable = self.service.getTableBestByCriteria(99, 1, min_players = 3)

        self.assertEquals(foundTable, None)
#####################################################################
class TourneySelectTestCase(PokerServiceTestCaseBase):

    def test00_all(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('')
        self.assertEqual(2, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual('regular1', tourneys[1]['name'])

    def test01_sit_n_go(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])

    def test02_regular(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('\tregular')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('regular1', tourneys[0]['name'])

    def test02_currency_serial(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('1\tregular')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('regular1', tourneys[0]['name'])
        tourneys = self.service.tourneySelect('44\tregular')
        self.assertEqual(0, len(tourneys))

    def test03_name(self):
        self.service.startService()
        tourneys = self.service.tourneySelect('regular1')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('regular1', tourneys[0]['name'])

    def test04_registered(self):
        self.service.startService()
        self.createUsers()
        (heads_up,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        tourneys = self.service.tourneySelect('')
        self.assertEqual(2, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(0, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('sitngo2')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(0, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(0, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('1\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(0, tourneys[0]['registered'])
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user2_serial,
                                                                game_id = heads_up.serial))
        tourneys = self.service.tourneySelect('')
        self.assertEqual(2, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(1, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('sitngo2')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(1, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(1, tourneys[0]['registered'])
        tourneys = self.service.tourneySelect('1\tsit_n_go')
        self.assertEqual(1, len(tourneys))
        self.assertEqual('sitngo2', tourneys[0]['name'])
        self.assertEqual(heads_up.serial, tourneys[0]['serial'])
        self.assertEqual(1, tourneys[0]['registered'])

    def test04_with_old_completed(self):
        self.service.startService()
        self.createUsers()
        tourneys = self.service.tourneySelect('')
        self.assertEquals(len(tourneys),2)
        db = self.service.db
        db.db.query("UPDATE tourneys SET finish_time = UNIX_TIMESTAMP(NOW() - INTERVAL 2 HOUR), state = 'complete' WHERE name = 'regular1'")
        self.assertEquals(self.service.remove_completed, 1)
        tourneys = self.service.tourneySelect('')
        self.assertEquals(len(tourneys),1)
        self.assertEquals(tourneys[0]["name"], "sitngo2")

class PlayerPlacesTestCase(PokerServiceTestCaseBase):

    def test00_not_anywhere(self):
        self.service.startService()
        serial = 888
        places = self.service.getPlayerPlaces(serial)
        self.assertEqual(0, len(places.tables))
        self.assertEqual(0, len(places.tourneys))
        self.assertEqual(serial, places.serial)

    def test01_tables_and_tourneys(self):
        self.service.startService()
        db = self.service.db
        serial = 888
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE1))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE2))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE3))
        tourney_serial = 999
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial, 'registering'))
        places = self.service.getPlayerPlaces(serial)
        self.assertEqual([TABLE1, TABLE2, TABLE3], places.tables)
        self.assertEqual([tourney_serial], places.tourneys)
        self.assertEqual(serial, places.serial)

    def test02_tables_and_tourneys_by_name(self):
        self.service.startService()
        db = self.service.db
        serial = 888
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE1))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE2))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE3))
        tourney_serial = 999
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial, 'registering'))
        name = 'testuser'
        db.db.query("INSERT INTO users (serial, name) VALUES (%d, '%s')" % (serial, name))
        places = self.service.getPlayerPlacesByName(name)
        self.assertEqual([TABLE1, TABLE2, TABLE3], places.tables)
        self.assertEqual([tourney_serial], places.tourneys)
        self.assertEqual(serial, places.serial)

    def test02_tables_and_tourneys_by_name_error(self):
        self.service.startService()
        db = self.service.db
        serial = 888
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE1))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE2))
        db.db.query("INSERT INTO user2table (user_serial, table_serial) VALUES (%d, %d)" % (serial, TABLE3))
        tourney_serial = 999
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial))
        name = 'testuser1'
        db.db.query("INSERT INTO users (serial, name) VALUES (%d, '%s')" % (serial, name))
        result = self.service.getPlayerPlacesByName('testuser2')
        self.assertEqual(PACKET_POKER_PLAYER_PLACES, result.other_type)

    def test03_list_tourneys_in_registering_running_break_break_wait_state(self):
        self.service.startService()
        db = self.service.db
        serial = 888
        tourney_serial = 999
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+1))
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+2))
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+3))
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+4))
        db.db.query("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, %d)" % (serial, tourney_serial+5))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial, 'announced'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+1, 'registering'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+2, 'running'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+3, 'breakwait'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+4, 'break'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+5, 'complete'))
        db.db.query("INSERT INTO tourneys (serial, state) VALUES (%d, '%s')" % (tourney_serial+6, 'canceled'))
        places = self.service.getPlayerPlaces(serial)
        self.assertEqual([], places.tables)
        self.assertEqual([tourney_serial+1, tourney_serial+2, tourney_serial+3, tourney_serial+4], places.tourneys)
        self.assertEqual(serial, places.serial)

class ResthostTestCase(unittest.TestCase):

    xml_with_resthost = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <resthost host="HOST" port="7777" path="/PATH" />
  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

    xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

    xml_with_resthost_name = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <resthost host="HOST" port="7777" path="/PATH" name="explain1" />
  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUp(self):
        self.destroyDb()

    def setUpService(self, xml):
        settings = pokernetworkconfig.Config([])
        settings.loadFromString(xml)
        self.service = pokerservice.PokerService(settings)

    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d

    def test00_init(self):
        """ setupResthost twice with the same information gives the same serial """
        self.setUpService(self.xml_with_resthost)
        self.service.startService()
        self.assertEqual(1, self.service.resthost_serial)
        self.service.resthost_serial = 0
        self.service.setupResthost()
        self.assertEqual(1, self.service.resthost_serial)
        db = self.service.db
        cursor = db.cursor()
        cursor.execute("SELECT * FROM resthost WHERE serial = 1")
        self.assertEqual(1, cursor.rowcount)
        (serial,name,host,port,path) = cursor.fetchone()
        self.assertEqual(1, serial)
        self.assertEqual('HOST', host)
        self.assertEqual(7777, port)
        self.assertEqual('/PATH', path)
        self.assertEqual(None, name)

    def test001_init_with_name(self):
        """ setupResthost with name """
        self.setUpService(self.xml_with_resthost_name)
        self.service.startService()
        db = self.service.db
        cursor = db.cursor()
        cursor.execute("SELECT * FROM resthost WHERE serial = 1")
        self.assertEqual(1, cursor.rowcount)
        (serial,name,host,port,path) = cursor.fetchone()
        self.assertEqual(1, serial)
        self.assertEqual('HOST', host)
        self.assertEqual(7777, port)
        self.assertEqual('/PATH', path)
        self.assertEqual('explain1', name)

    def test01_packet2resthost(self):
        self.setUpService(self.xml_with_resthost)
        self.service.startService()

        db = self.service.db
        db.db.query("INSERT INTO resthost VALUES (2, 'two', 'host2', 2222, 'path2')")
        db.db.query("INSERT INTO route VALUES (102, 0, 0, 2)")

        #
        # ping is never routed
        #
        resthost, game_id = self.service.packet2resthost(PacketPing())
        self.assertEqual(None, resthost)
        self.assertEqual(None, game_id)
        #
        # packet with a valid game_id is routed if resthost is != from server
        #
        resthost, game_id = self.service.packet2resthost(PacketPokerCheck(game_id = 102))
        self.assertEqual('host2', resthost[0])
        self.assertEqual(102, game_id)
        #
        # packet is not routed if resthost point to the same server
        #
        resthost, game_id = self.service.packet2resthost(PacketPokerCheck(game_id = 1))
        self.assertEqual(None, resthost)
        self.assertEqual(1, game_id)
        #
        # packet with an unknown game_id is not routed
        #
        resthost, game_id = self.service.packet2resthost(PacketPokerCheck(game_id = 888))
        self.assertEqual(None, resthost)
        self.assertEqual(888, game_id)
        #
        # packet to a tourney is routed if resthost is != from server
        #
        db = self.service.db
        db.db.query("INSERT INTO route VALUES (0, 484, 1, 2)")
        resthost, game_id = self.service.packet2resthost(PacketPokerGetTourneyManager(tourney_serial = 484))
        self.assertEqual('host2', resthost[0])
        #
        # packet to a tourney is routed if resthost is != from server
        #
        resthost, game_id = self.service.packet2resthost(PacketPokerTourneyRegister(game_id = 484))
        self.assertEqual('host2', resthost[0])
        #
        # packet to a tourney table is routed if resthost is != from server
        #
        db.db.query("INSERT INTO route VALUES (232, 484, 1, 2)")
        resthost, game_id = self.service.packet2resthost(PacketPokerCheck(game_id = 232))
        self.assertEqual('host2', resthost[0])
        self.assertEqual(232, game_id)
        #
        # packet to an unknown tourney_serial is not routed
        #
        resthost, game_id = self.service.packet2resthost(PacketPokerGetTourneyManager(tourney_serial = 999))
        self.assertEqual(None, resthost)
        #
        # packet to an unknown tourney_serial is not routed
        #
        resthost, game_id = self.service.packet2resthost(PacketPokerTourneyRegister(game_id = 999))
        self.assertEqual(None, resthost)

    def test02_packet2resthost_createTourney(self):
        self.setUpService(self.xml)
        self.service.startService()
        resthost, game_id = self.service.packet2resthost(PacketPokerCreateTourney())
        self.failIf(resthost)
        self.failIf(game_id)
        db = self.service.db
        db.db.query("INSERT INTO resthost VALUES (10, 'one', 'host1', 1, 'path1')")
        db.db.query("INSERT INTO route VALUES (0, 100, 0, 10)")
        db.db.query("INSERT INTO route VALUES (0, 200, 0, 10)")
        db.db.query("INSERT INTO resthost VALUES (20, 'two', 'host2', 2, 'path2')")
        db.db.query("INSERT INTO route VALUES (0, 300, 0, 20)")
        resthost, game_id = self.service.packet2resthost(PacketPokerCreateTourney())
        self.assertEqual('host2', resthost[0])
        self.assertEqual(None, game_id)

class PokerServiceTestCase(PokerServiceTestCaseBase):

    # ----------------------------------------------------------------
    def configValues(self, settings_data, joined_max, missed_round_max=10, delaysValue=-1, queuedPacketMax = 500):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_data, len(settings_data))
        settings.header = settings.doc.xpathNewContext()
        self.service = pokerservice.PokerService(settings)

        for (key, value) in ( ('position', '60'), ('autodeal', '18'),
                              ('showdown', '30'), ('round', '12'), ('finish', '18')):
            self.assertEquals(self.service.delays[key], value)
        for (key, value) in ( ('serial', '1'), ('amount', '10000000')):
            self.assertEquals(self.service.refill[key], value)

        self.assertEquals(self.service.verbose, 6)

        self.assertEquals(joined_max, self.service.joined_max)
        self.assertEquals(missed_round_max, self.service.missed_round_max)
        self.assertEquals(missed_round_max, self.service.getMissedRoundMax())
        self.assertEquals(queuedPacketMax, self.service.client_queued_packet_max)
        self.assertEquals(queuedPacketMax, self.service.getClientQueuedPacketMax())

        startedOnlyVars = [ ('joined_count', 0),
                            ('tables', 2), ('tourney_table_serial', 1),
                            ('shutting_down', False), ('avatars', []),
                            ('avatar_collection', PokerAvatarCollection()), ('simultaneous', 4),
                            ('monitors', []), ('gettextFuncs', 17) ]
        for (instanceVar, val) in startedOnlyVars:
            self.assertEquals(self.service.__dict__.has_key(instanceVar), False)

        clear_all_messages()
        self.service.startService()
        self.failUnless(search_output('*ERROR* Unable to find codeset string in language value: this_locale_does_not_exist'))
        self.failUnless(search_output("*ERROR* No translation for language this_locale_does_not_exist for this_locale_does_not_exist in poker-engine; locale ignored: [Errno 2] No translation file found for domain: 'poker-engine'"))
        self.failUnless(search_output('*ERROR* Translation setup for this_locale_does_not_exist failed.  Strings for clients requesting this_locale_does_not_exist will likely always be in English'))
        for (instanceVar, val) in startedOnlyVars:
            self.assertEquals(self.service.__dict__.has_key(instanceVar), True)
            if instanceVar == "tables":
                self.assertEquals(len(self.service.__dict__[instanceVar]), val)

        for ii in ('this_locale_does_not_exist', 'en_US.ISO-8859-1', 'fr_FR.ISO-8859-1'):
            self.assertEquals(self.service.gettextFuncs.has_key(ii), True)
            self.assertEquals(callable(self.service.locale2translationFunc(ii)), True)
        for ii in ('this_locale_does_not_exist', 'en_US.ISO-8859-1'):
            self.assertEquals(self.service.gettextFuncs[ii]("Aces"), "Aces")
        self.assertEquals(self.service.gettextFuncs['fr_FR.ISO-8859-1']("Aces"), "d'As")

        for ii in ('nothing', 'unknown'):
            self.assertEquals(self.service.locale2translationFunc(ii), None)

        # If delaysValue is negative, that means in the context of this
        # test that we want to assume they weren't given in the settings
        # file and therefore service.delays() should not have them as keys.

        for str in ('extra_wait_tourney_break', 'extra_wait_tourney_start', 'extra_wait_tourney_finish'):
            if delaysValue < 0:
                self.assertEquals(self.service.delays.has_key(str), False)
            else:
                self.assertEquals(int(self.service.delays[str]), delaysValue)

    def test00_01_configValues(self):
        self.configValues(settings_xml, 1000)

    def test00_02_configValues(self):
        self.configValues(settings_xml.replace('max_joined="1000"', ""), 4000)

    def test00_03_configValues(self):
        self.configValues(settings_xml.replace('max_joined="1000"',
                                               'max_missed_round="5" max_queued_client_packets="100"'),
                          4000, 5, queuedPacketMax=100)

    def test00_4_badLocaleObject(self):
        """test00_4_badLocaleObject
        Check the case where the imported locale object's setlocal
        function does not work and causes errors in configuration."""

        def badSetLocale(a, b):
            raise locale.Error("testing bad setlocale")

        myLocale = locale.getlocale(locale.LC_ALL)
        saveLocale = locale.setlocale
        locale.setlocale = badSetLocale

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.service = pokerservice.PokerService(settings)
        clear_all_messages()
        self.service.startService()
        self.assertEquals(len(self.service.gettextFuncs), 17)
        self.failUnless(search_output('*ERROR* Unable to find codeset string in language value: this_locale_does_not_exist'))
        self.failUnless(search_output("*ERROR* No translation for language this_locale_does_not_exist for this_locale_does_not_exist in poker-engine; locale ignored: [Errno 2] No translation file found for domain: 'poker-engine'"))
        for ii in ('en_US.ISO-8859-1', 'fr_FR.ISO-8859-1'):
            self.assertEquals(self.service.gettextFuncs.has_key(ii), True)
        self.assertEquals(self.service.gettextFuncs['en_US.ISO-8859-1']("Aces"), "Aces")
        self.assertEquals(self.service.gettextFuncs['fr_FR.ISO-8859-1']("Aces"), "d'As")
        self.assertEquals(search_output("*ERROR* Unable to restore original locale: testing bad setlocale"), True)
        locale.setlocale = saveLocale

    def test00_05_configValues(self):
        self.configValues(settings_xml.replace('delays',
                                               'delays extra_wait_tourney_break="60" extra_wait_tourney_start="60" extra_wait_tourney_finish="60"'), 1000, delaysValue=60)

    def test00_12_badEncoding(self):
        """test00_12_badEncoding
        Check the case where an error occurs due to an encoding requested
        for a config language value has an unknown encoding."""

        new_settings_xml = settings_xml.replace('<language value="fr_FR.ISO-8859-1"/>',
                                                '<language value="fr_FR.MAGIC-PIXIE-DUST"/>')

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(new_settings_xml, len(new_settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.service = pokerservice.PokerService(settings)
        clear_all_messages()
        self.service.startService()
        self.assertEquals(len(self.service.gettextFuncs), 17)
        self.failUnless(search_output('*ERROR* Unsupported codeset MAGIC-PIXIE-DUST for fr_FR.MAGIC-PIXIE-DUST in poker-engine; locale ignored: unknown encoding: MAGIC-PIXIE-DUST'))
        self.failUnless(search_output('*ERROR* Unable to find codeset string in language value: this_locale_does_not_exist'))
        self.failUnless(search_output("*ERROR* No translation for language this_locale_does_not_exist for this_locale_does_not_exist in poker-engine; locale ignored: [Errno 2] No translation file found for domain: 'poker-engine'"))
        for ii in ('en_US.ISO-8859-1', 'fr_FR.MAGIC-PIXIE-DUST'):
            self.assertEquals(self.service.gettextFuncs.has_key(ii), True)
            self.assertEquals(self.service.gettextFuncs[ii]("Aces"), "Aces")

    def test00_13_anotherBadEncoding(self):
        """test00_13_anotherBadEncoding
        Check the case where an error occurs due to an encoding requested
        for a config language value has an unknown encoding."""

        new_settings_xml = settings_xml.replace('<language value="fr_FR.ISO-8859-1"/>',
                                                '<language value=".MAGIC-PIXIE-DUST"/>')

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(new_settings_xml, len(new_settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.service = pokerservice.PokerService(settings)
        clear_all_messages()
        self.service.startService()
        self.assertEquals(len(self.service.gettextFuncs), 17)
        self.failUnless(search_output('*ERROR* Unable to find codeset string in language value: .MAGIC-PIXIE-DUST'))
        self.failUnless(search_output("*ERROR* No translation for language .MAGIC-PIXIE-DUST for .MAGIC-PIXIE-DUST in poker-engine; locale ignored: [Errno 2] No translation file found for domain: 'poker-engine'"))
        for ii in ('en_US.ISO-8859-1', '.MAGIC-PIXIE-DUST'):
            self.assertEquals(self.service.gettextFuncs.has_key(ii), True)
            self.assertEquals(self.service.gettextFuncs[ii]("Aces"), "Aces")

    def test00_14_languageEmptyStringForSeperate(self):
        """test00_14_languageEmptyString
        Check the case where an error occurs due to a language being the empty string."""

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.service = pokerservice.PokerService(settings)
        clear_all_messages()
        self.service.startService()
        self.service._separateCodesetFromLocale('')
        msgs = get_messages()[-2:]
        self.assertEquals(msgs, ['*ERROR* Unable to find codeset string in language value: ', '*ERROR* Unable to find locale string in language value: '])
    # ----------------------------------------------------------------
    def test01_auth(self):
        self.service.startService()
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        self.assertEquals(None, message)
        self.assertEquals(4, serial)
        self.assertEquals("user1", name)
        self.assertEquals(user.User.REGULAR, privilege)

    # ----------------------------------------------------------------
    def test01_auth_invalid_login(self):
        self.service.startService()
        self.service.poker_auth.auto_create_account = False
        ( status, message ) = self.service.auth("user1", "password1", sets.Set("role1"))
        self.assertEquals("Invalid login or password", message)
        self.assertEquals(False, status)

    # ----------------------------------------------------------------
    def test01_auth_already_logged(self):
        class Client:
            def __init__(self):
                self.roles = sets.Set('role1')
            def getName(self):
                return "user1"

        self.service.startService()
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", sets.Set('role1'))
        self.service.avatar_collection.add(serial, Client())
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", sets.Set('role1'))
        self.assertEquals(None, message)
        self.assertEquals("user1", name)

    # ----------------------------------------------------------------
    def cashIn(self):

        cursor = self.db.cursor()
        cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount, points, rake) VALUES (%d, 1, 100, 0, 0)" % ( self.user1_serial, ))
        cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount, points, rake) VALUES (%d, 1, 100, 0, 0)" % ( self.user2_serial, ))
        cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount, points, rake) VALUES (%d, 2, 200, 0, 0)" % ( self.user2_serial, ))
        cursor.close()
        return

    # ----------------------------------------------------------------
    def test04_getUserInfo(self):
        self.service.startService()
        self.service.refill = None

        self.default_money = 0
        self.createUsers()
        #
        # No cash in means no money
        #
        info = self.service.getUserInfo(self.user1_serial)
        self.assertEqual(0, len(info.money))
        self.cashIn()
        info = self.service.getUserInfo(self.user2_serial)
        self.assertEquals({1: (100, 0, 0), 2: (200, 0, 0)}, info.money)

        #
        # Some money is on a table
        #
        table_serial = self.service.tables.values()[0].game.id
        buy_in = 50
        currency_serial = 1
        self.assertEquals(1, table_serial)
        self.assertEquals(currency_serial, self.service.tables.values()[0].currency_serial)
        self.service.seatPlayer(self.user2_serial, table_serial, 0)
        self.service.buyInPlayer(self.user2_serial, table_serial, currency_serial, buy_in)
        info = self.service.getUserInfo(self.user2_serial)
        self.assertEquals({1: (50, 50, 0), 2: (200, 0, 0)}, info.money)
        #
        # The other player only has one currency
        #
        self.service.seatPlayer(self.user1_serial, table_serial, 0)
        self.service.buyInPlayer(self.user1_serial, table_serial, currency_serial, buy_in)
        info = self.service.getUserInfo(self.user1_serial)
        self.assertEquals({1: (50, 50, 0)}, info.money)

    # ----------------------------------------------------------------
    def test05_getPersonalInfo(self):
        self.service.startService()

        self.createUsers()
        info = self.service.getPersonalInfo(self.user1_serial)
        self.assertEquals(self.user1_serial, info.serial)

    # ----------------------------------------------------------------
    def test07_cashInOut(self):
        self.service.startService()
        class Cashier:
            def cashIn(self, packet):
                self.cashIn_called = True
            def cashOut(self, packet):
                self.cashOut_called = True
            def cashOutCommit(self, packet):
                return packet.count
            def close(self):
                pass
        self.service.cashier = Cashier()

        self.service.cashIn(Packet())
        self.assertTrue(self.service.cashier.cashIn_called)
        self.service.cashOut(Packet())
        self.assertTrue(self.service.cashier.cashOut_called)
        packet = PacketPokerCashOutCommit()
        packet.count = 0
        self.assertEqual(PACKET_ACK, self.service.cashOutCommit(packet).type)
        packet.count = 2
        self.assertEqual(PACKET_ERROR, self.service.cashOutCommit(packet).type)

    # ----------------------------------------------------------------

    class ClientMockup:
        def __init__(self, serial, testObject):
            self.via_satellite = 0
            self.serial = serial
            self.packet_end_tournament = None
            self.packets = []
            self.tables = {}
            self.joinedTables = []
            self.testObject = testObject
            self.expectedReason = ""

        def sendPacketVerbose(self, packet):
            # packet_end_tournament was an expected field by some tests
            # when I got here so I left it as is but added my own packet
            # list for my own tests.
            self.packet_end_tournament = packet
            self.packets.append(packet)

        def join(self, table, reason = ""):
            self.joinedTables.append(table)
            self.tables[table.game.id] = table
            self.testObject.assertEquals(self.expectedReason, reason)

        def getSerial(self):
            return self.serial

        def sendPacket(self, packet):
            self.packets.append(packet)


    class TableMockup:
        def __init__(self):
            self.serial = None
        def kickPlayer(self, serial):
            self.kick_player = serial

    class TourneyMockup:
        def __init__(self):
            self.satellite_of = 0
            self.call_rank = None
            self.serial = 10
            self.schedule_serial = 1
            self.players = [0, 2, 4]
            self.prize = [10,20,30]
            self.rank = 10
        def getRank(self, serial):
            return self.rank

        def prizes(self):
            return self.prize


    def test09_endOfTournamentsNotInPlayers(self):
        self.service.startService()
        self.createUsers()

        table = self.TableMockup()
        kickplayer = None
        def getTableMockup( game_id):
            return table

        tourney = self.TourneyMockup()
        self.service.client = self.ClientMockup(self.user1_serial, self)
        self.service.getTable = getTableMockup
        self.service.tourneyRemovePlayer(tourney, 0, self.user1_serial)
        self.assertEquals(self.service.client.packet_end_tournament == None, True)

    def test10_endOfTournamentsNoPrize(self):
        self.service.startService()
        self.createUsers()

        table = self.TableMockup()
        kickplayer = None
        def getTableMockup( game_id):
            return table

        tourney = self.TourneyMockup()
        tourney.players = [2, self.user1_serial, 10]
        client = self.ClientMockup(self.user1_serial, self)
        self.service.avatar_collection.add(self.user1_serial, client)
        self.service.getTable = getTableMockup
        self.service.tourneyRemovePlayer(tourney, 0, self.user1_serial)
        self.assertEquals(client.packet_end_tournament != None, True)
        self.assertEquals(client.packet_end_tournament.serial == tourney.serial, True)
        self.assertEquals(client.packet_end_tournament.money == 0, True)
        self.assertEquals(client.packet_end_tournament.rank == 10, True)
        self.assertEquals(client.packet_end_tournament.players == 3, True)

    def test11_endOfTournamentsPrize(self):
        self.service.startService()
        self.createUsers()

        table = self.TableMockup()
        kickplayer = None
        def getTableMockup( game_id):
            return table

        tourney = self.TourneyMockup()
        tourney.rank = 2
        client = self.ClientMockup(self.user1_serial, self)
        self.service.avatar_collection.add(self.user1_serial, client)
        self.service.getTable = getTableMockup
        self.service.tourneyRemovePlayer(tourney, 0, self.user1_serial)
        self.assertEquals(client.packet_end_tournament != None, True)
        self.assertEquals(client.packet_end_tournament.serial == tourney.serial, True)
        self.assertEquals(client.packet_end_tournament.money == 20, True)
        self.assertEquals(client.packet_end_tournament.rank == 2, True)
        self.assertEquals(client.packet_end_tournament.players == 3, True)


    # ----------------------------------------------------------------
    def test12_playerImage(self):
        self.service.startService()

        self.createUsers()
        player_image1 = PacketPokerPlayerImage(serial = self.user1_serial,
                                               image = "12345")
        self.assertEquals(True, self.service.setPlayerImage(player_image1))
        player_image2 = self.service.getPlayerImage(self.user1_serial)
        self.assertEquals(player_image1.image, player_image2.image)
        player_image2 = self.service.getPlayerImage(self.user2_serial)
        self.assertEquals("", player_image2.image)

    # ----------------------------------------------------------------
    def test13_checkTourneysSchedule_spawn_regular(self):
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.5

        #
        # A regular tournament starts registration now
        #
        #  Note that we have to set a respawn here by default so that it
        #  gets created; the default schema doesn't respawn this tourney
        #  by default.
        cursor = self.db.cursor()
        cursor.execute("UPDATE tourneys_schedule SET respawn = 'y', register_time = UNIX_TIMESTAMP(NOW() + INTERVAL 1 SECOND) WHERE name = 'regular1'")
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

        self.service.startService()
        d = defer.Deferred()
        def checkTourneys(status):
            t = self.service.tourneys.values()[0]
            self.failUnless(filter(lambda tourney: tourney.sit_n_go == 'n', self.service.tourneys.values()))
            self.failUnless(filter(lambda tourney: tourney.name == 'regular1', self.service.tourneys.values()))
        d.addCallback(checkTourneys)
        reactor.callLater(3, lambda: d.callback(True))

        return d

    # ----------------------------------------------------------------
    def test14_checkTourneysSchedule_cancel_regular(self):
        pokerservice.DELETE_OLD_TOURNEYS_DELAY = 0
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        #
        # A regular tournament starts registration now
        #
        cursor = self.db.cursor()
        cursor.execute("UPDATE tourneys_schedule " +
                       " SET register_time = " + str(testclock._seconds_value) + ", " +
                       "     start_time = " + str(testclock._seconds_value + 10) + ", " +
                       "     respawn = 'n' " +
                       " WHERE name = 'regular1'")
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

        self.service.startService()
        self.createUsers()

        #
        # Register a user who will be re-imbursed when the tournament is canceled
        #
        d1 = defer.Deferred()
        def registerPlayer(status):
            (regular,) = filter(lambda tourney: tourney.name == 'regular1', self.service.tourneys.values())
            self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                    game_id = regular.serial))
            self.assertEquals(self.default_money - regular.buy_in - regular.rake, self.service.getMoney(self.user1_serial, 1))
            self.assertEquals([ self.user1_serial ], regular.players)

        d1.addCallback(registerPlayer)
        reactor.callLater(5, lambda: d1.callback(True))

        d2 = defer.Deferred()
        def checkTourneys(status):
            self.assertEquals([], filter(lambda tourney: tourney['name'] == 'regular1', self.service.tourneys_schedule.values()))
            self.assertEquals([], filter(lambda tourney: tourney.name == 'regular1', self.service.tourneys.values()))
            self.assertEquals(self.default_money, self.service.getMoney(self.user1_serial, 1))
        d2.addCallback(checkTourneys)
        reactor.callLater(15, lambda: d2.callback(True))

        return defer.DeferredList((d1, d2), fireOnOneErrback = True)

    def test14_sng_timeout(self):
        settings = """<?xml version="1.0" encoding="ISO-8859-1"?>
        <server sng_timeout="111">
        <delays />
        </server>
        """
        service = pokerservice.PokerService(settings)
        self.assertEqual(111, service.sng_timeout)

    # ----------------------------------------------------------------
    def test14_checkTourneysSchedule_cancel_sitngo(self):
        self.service.startService()
        self.service.sng_timeout = 0
        (heads_up_before,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        register_time = int(pokerservice.seconds()) - 1
        self.service.checkTourneysSchedule()
        self.assertEquals(pokertournament.TOURNAMENT_STATE_CANCELED, heads_up_before.state)
        (heads_up_after1, heads_up_after2) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        self.failUnless(abs(register_time - heads_up_after2.register_time) <= 1)
        self.assertEquals(heads_up_before.serial, heads_up_after1.serial)
        self.assertNotEqual(heads_up_before.serial, heads_up_after2.serial)
        self.assertEqual(heads_up_before.schedule_serial, heads_up_after2.schedule_serial)

    # ----------------------------------------------------------------
    def test14_1_checkTourneysSchedule_cancel_sitngo_already_canceled(self):
        self.service.startService()
        self.service.sng_timeout = 0
        (heads_up_before,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        heads_up_before.state = pokertournament.TOURNAMENT_STATE_CANCELED
        heads_up_before.changeState = lambda x: self.assertFalse(True)
        self.service.checkTourneysSchedule()

    # ----------------------------------------------------------------
    def test15_runTourney(self):
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        self.service.startService()
        self.createUsers()

        client1 = self.ClientMockup(self.user1_serial, self)
        self.service.avatar_collection.add(self.user1_serial, client1)
        client1.expectedReason = PacketPokerTable.REASON_TOURNEY_START
        (heads_up,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        clear_all_messages()
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = heads_up.serial))
        self.failUnless(search_output('tourneyRegister: UPDATE user2money SET amount = amount - 300000 WHERE user_serial = %d AND        currency_serial = 1 AND        amount >= 300000' % self.user1_serial), "UPDATE user2money notice not  found in verbose output")
        self.failUnless(search_output('tourneyRegister: INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (%d, 1, 1)' % self.user1_serial), "INSERT INTO user2tourney notice not found in verbose output")
        clear_all_messages()
        self.assertEquals(len(client1.packets), 1)
        self.assertEquals(client1.packets[0].type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(client1.packets[0].serial, self.user1_serial)
        self.assertEquals(client1.packets[0].game_id, heads_up.serial)
        client1.packets = []
        self.assertEquals(self.service.joined_count, 0)

        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user2_serial,
                                                                game_id = heads_up.serial))

        d = defer.Deferred()
        def checkTourneys(status):
            # joined_count should now be one, as the tourneyGameFilled() should
            # have been called, and we only had one client connected.
            self.assertEquals(self.service.joined_count, 1)
            self.assertEquals(len(client1.packets), 14)
            for p in client1.packets:
                self.assertEquals(p.game_id, self.service.tables.values()[2].game.id)
            self.assertEquals(len(client1.tables), 1)
            self.assertEquals(client1.tables.has_key(self.service.tables.values()[2].game.id), True)
            self.assertEquals(client1.tables[self.service.tables.values()[2].game.id], self.service.tables.values()[2])

            self.assertEquals(pokertournament.TOURNAMENT_STATE_RUNNING, heads_up.state)
            game = heads_up.games[0]
            in_position = game.getSerialInPosition()
            game.callNraise(in_position, game.maxBuyIn())
            in_position = game.getSerialInPosition()
            game.call(in_position)
            self.service.tables.values()[2].update() # two tables already in settings

        d.addCallback(checkTourneys)
        reactor.callLater(3, lambda: d.callback(True))

        return d

    # ----------------------------------------------------------------
    def test16_runTourney_freeroll(self):
        return self.runTourney_freeroll(True)

    # ----------------------------------------------------------------
    def test17_runTourney_freeroll(self):
        return self.runTourney_freeroll(False)

    # ----------------------------------------------------------------
    def runTourney_freeroll(self, has_bailor):
        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        #
        # A regular tournament starts registration now
        #
        cursor = self.db.cursor()
        prize = 100
        cursor.execute("UPDATE tourneys_schedule SET currency_serial = 2, buy_in = 0, prize_min = %d WHERE name = 'sitngo2'" % prize )
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

        self.service.startService()
        self.createUsers()

        (heads_up,) = filter(lambda tourney: tourney.name == 'sitngo2', self.service.tourneys.values())
        if has_bailor:
            heads_up.bailor_serial = self.user3_serial
        else:
            heads_up.bailor_serial = 42

        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = heads_up.serial))
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user2_serial,
                                                                game_id = heads_up.serial))

        d = defer.Deferred()
        def checkTourneys(status):
            self.assertEquals(pokertournament.TOURNAMENT_STATE_RUNNING, heads_up.state)
            game = heads_up.games[0]
            in_position = game.getSerialInPosition()
            game.callNraise(in_position, game.maxBuyIn())
            in_position = game.getSerialInPosition()
            game.call(in_position)
            self.service.tables.values()[2].update() # two tables already in settings
            if has_bailor:
                self.assertEquals(0, self.service.getMoney(self.user1_serial, 2), "bailor user1")
                self.assertEquals(prize, self.service.getMoney(self.user2_serial, 2), "bailor user2")
                self.assertEquals(self.default_money - prize, self.service.getMoney(self.user3_serial, 2), "bailor user3")
            else:
                self.assertEquals(0, self.service.getMoney(self.user1_serial, 2))
                self.assertEquals(0, self.service.getMoney(self.user2_serial, 2))
                self.assertEquals(self.default_money, self.service.getMoney(self.user3_serial, 2))

        d.addCallback(checkTourneys)
        reactor.callLater(15, lambda: d.callback(True))

        return d

    # ----------------------------------------------------------------
    def test18_cleanupTourneys_registering(self):
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO tourneys (serial, sit_n_go, name, start_time) VALUES (4000, 'n', 'regular3', " + str(testclock._seconds_value + 120) + ")")
        cursor.execute("INSERT INTO user2tourney VALUES (1, 1, 4000, 0, -1)")
        cursor.execute("INSERT INTO user2tourney VALUES (2, 1, 4000, 0, -1)")
        cursor.execute("INSERT INTO user2tourney VALUES (3, 1, 4000, 0, -1)")
        self.service.db = pokerdatabase.PokerDatabase(self.settings)
        self.service.dirs = ['%s/../conf' % SCRIPT_DIR]
        self.service.cleanupTourneys()
        tourney = self.service.tourneys[4000]
        self.assertEqual([1, 2, 3], tourney.players)
        cursor.execute("SELECT tourney_serial FROM route WHERE tourney_serial = 4000")
        self.assertEqual(1, cursor.rowcount)
        (tournament_serial,) = cursor.fetchone()
        self.assertEqual(4000, tournament_serial)
        cursor.close()
    # ----------------------------------------------------------------
    def test19_testJoinCounter(self):
        expectedMax = 1000
        val = 0
        self.service.startService()
        while val < expectedMax + 100:
            self.assertEquals(self.service.joinedCountIncrease(5), val+5)
            self.assertEquals(self.service.joinedCountDecrease(4), val+1)
            val += 1
            self.assertEquals(self.service.joinedCountReachedMax(),
                              val >= expectedMax)
        self.service.stopService()
    # ----------------------------------------------------------------
    def test20_spawnTourneyCurrencySerialFromDateFormat(self):
        cursor = self.db.cursor()
        currency_serial_from_date_format = '%Y%m'
        cursor.execute("UPDATE tourneys_schedule SET currency_serial_from_date_format = '%s' WHERE name = 'sitngo2'" % currency_serial_from_date_format)
        self.assertEqual(1, cursor.rowcount)
        cursor.close()
        self.service.today = lambda: date(1970, 01, 01)
        currency_serial_from_date = 197001L
        self.service.startService()
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.assertEqual(currency_serial_from_date_format, schedule["currency_serial_from_date_format"])
        cursor = self.db.cursor()
        cursor.execute("SELECT currency_serial from tourneys WHERE name = '%s'" % 'sitngo2')
        self.assertEqual(1, cursor.rowcount)
        currency_serial = cursor.fetchone()[0]
        cursor.close()
        self.assertEqual(currency_serial_from_date, currency_serial)
        tourney = self.service.tourneys[tourney_serial]
        self.assertEqual(currency_serial_from_date, tourney.currency_serial)
    # ----------------------------------------------------------------
    def test20_spawnTourneyPrizeCurrencyFromDateFormat(self):
        cursor = self.db.cursor()
        prize_currency_from_date_format = '%W'
        cursor.execute("UPDATE tourneys_schedule SET prize_currency_from_date_format = '%s' WHERE name = 'sitngo2'" % prize_currency_from_date_format)
        self.assertEqual(1, cursor.rowcount)
        cursor.close()
        self.service.today = lambda: date(1970, 1, 8)
        prize_currency_from_date = 1L
        self.service.startService()
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.assertEqual(prize_currency_from_date_format, schedule["prize_currency_from_date_format"])
        cursor = self.db.cursor()
        cursor.execute("SELECT prize_currency from tourneys WHERE name = '%s'" % 'sitngo2')
        self.assertEqual(1, cursor.rowcount)
        prize_currency = cursor.fetchone()[0]
        cursor.close()
        self.assertEqual(prize_currency_from_date, prize_currency)
        tourney = self.service.tourneys[tourney_serial]
        self.assertEqual(prize_currency_from_date, tourney.prize_currency)
    # ----------------------------------------------------------------
    def test21_today(self):
        self.assertEqual(self.service.today(), date.today())
    # ----------------------------------------------------------------
    def test22_spawnTourneyBadCurrencySerialFromDateFormat(self):
        cursor = self.db.cursor()
        cursor.execute("UPDATE tourneys_schedule SET currency_serial_from_date_format = 'NaN666' WHERE name = 'sitngo2'")
        cursor.close()
        self.assertRaises(UserWarning, self.service.startService)
    # ----------------------------------------------------------------
    def test22_spawnTourneyBadPrizeCurrencyFromDateFormat(self):
        cursor = self.db.cursor()
        cursor.execute("UPDATE tourneys_schedule SET prize_currency_from_date_format = 'NaN666' WHERE name = 'sitngo2'")
        cursor.close()
        self.assertRaises(UserWarning, self.service.startService)
    # ----------------------------------------------------------------
    def test23_isShuttingDown(self):
        from exceptions import AttributeError
        caughtIt = False
        try:
            self.service.isShuttingDown()
            self.failIf(True)  # Should not be reached
        except AttributeError, ae:
            caughtIt = True
            self.assertEquals(ae.__str__(),
                              "PokerService instance has no attribute 'shutting_down'")
        self.failUnless(caughtIt)

        self.service.startService()
        self.assertEquals(self.service.isShuttingDown(), False)
        self.assertEquals(self.service.isShuttingDown(), self.service.shutting_down)

        self.service.stopService()
        self.assertEquals(self.service.isShuttingDown(), True)
        self.assertEquals(self.service.isShuttingDown(), self.service.shutting_down)
    # ----------------------------------------------------------------
    def test24_stopFactory(self):
        # Nothing is actually done by stopFactory(), so this test can't
        # really check anything of use.
        self.assertEquals(self.service.stopFactory(), None)
##############################################################################
    def test23_localeChecks(self):
        self.service.startService()
        for enlo in ('this_locale_does_not_exist', 'en_GB.ISO-8859-1',
                     'en_US.ISO-8859-1', 'en_CA.ISO-8859-1'):
            self.assertEquals(self.service.locale2translationFunc(enlo)("Aces"), "Aces")
        clear_all_messages()
        self.assertEquals(self.service.locale2translationFunc('fr_FR', 'UTF-8'),
                         None)
        self.assertEquals(get_messages(), ['Locale, "fr_FR.UTF-8" not available.  fr_FR.UTF-8 must not have been provide via <language/> tag in settings, or errors occured during loading.'])
        enc = 'ISO-8859-1'
        self.assertEquals(self.service.locale2translationFunc('da_DK', enc)("%(name)s mucks loosing hand"), "%(name)s mucker tabende h\xe5nd")
        self.assertEquals(self.service.locale2translationFunc('de_DE', enc)("%(name)s raises %(amount)s"), '%(name)s erh\xf6ht %(amount)s' )
        self.assertEquals(self.service.locale2translationFunc('fi_FI', enc)("Board: %(board)s"), 'P\xf6yt\xe4kortit: %(board)s')
        for fr in ('fr_FR', 'fr_FX', 'fr_BE', 'fr_CA'):
            self.assertEquals(self.service.locale2translationFunc(fr, enc)("%(name)s receives %(amount)s"), '%(name)s re\xe7oit %(amount)s')
        self.assertEquals(self.service.locale2translationFunc('it_IT', enc)("High card %(card)s"),'Carta pi\xf9 alta: %(card)s')
        self.assertEquals(self.service.locale2translationFunc('nb_NO', enc)("%(name)s mucks loosing hand"), '%(name)s skjuler tapende h\xe5nd')
        self.assertEquals(self.service.locale2translationFunc('nl_NL', enc)("Four of a kind %(card)s"), 'Carr\xe9 %(card)s')
        self.assertEquals(self.service.locale2translationFunc('pt_PT', enc)("Rake %(amount)s"), 'Comiss\xe3o %(amount)s')
        self.assertEquals(self.service.locale2translationFunc('sv_SE', enc)("winners share a pot of %(pot)s"), 'vinnarna delar p\xe5 potten %(pot)s')
    # ----------------------------------------------------------------
    def test24_buyInPlayerNoneAmount(self):
        self.service.startService()
        self.service.refill = None
        self.createUsers()
        table_serial = self.service.tables.values()[0].game.id
        currency_serial = 1
        self.service.seatPlayer(self.user1_serial, table_serial, 0)
        clear_all_messages()
        self.service.buyInPlayer(self.user1_serial, table_serial, currency_serial, None)
        self.assertTrue("*ERROR*" in get_messages()[0])
    # ----------------------------------------------------------------
    def test25_chatMessageArchive(self):
        self.service.startService()
        player_serial = 10
        game_id = 42
        message = 'yeah'
        self.service.chatMessageArchive(player_serial, game_id, message)
        cursor = self.service.db.cursor(DictCursor)
        cursor.execute("SELECT * FROM chat_messages")
        result = cursor.fetchone()
        self.assertEquals(player_serial, result['player_serial'])
        self.assertEquals(game_id, result['game_id'])
        self.assertEquals(message, result['message'])
        self.assertNotEquals(0, result['timestamp'])


##############################################################################
class RefillTestCase(unittest.TestCase):

    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUp(self):
        settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
        <server verbose="3">
        <listen tcp="19480" />
        <refill serial="1" amount="10000" />
        <delays />
        <path>%(script_dir)s/../conf</path>
        <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
        <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
        </server>
        """ % {'script_dir': SCRIPT_DIR}
        testclock._seconds_reset()
        self.destroyDb()
        self.service = pokerservice.PokerService(settings_xml)

    def tearDown(self):
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d

    def test_refill(self):
        self.service.startService()
        refill = 10000
        ( (serial, name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        self.assertEquals(0, self.service.autorefill(serial))
        table_money = 1000
        table_serial = 200
        self.service.db.db.query("INSERT INTO user2table VALUES (" + str(serial) + ", " + str(table_serial) + ", " + str(table_money) + ", 0)")
        self.service.db.db.query("INSERT INTO pokertables (serial, name, currency_serial, tourney_serial) VALUES (" + str(table_serial) + ", 'foo', 1, 0)")
        money_left = 100
        self.service.db.db.query("UPDATE user2money SET amount = " + str(money_left) + " WHERE user_serial = " + str(serial))
        self.assertEquals(refill - table_money, self.service.autorefill(serial))

class TimerTestCase(unittest.TestCase):

    def test_cancelTimers(self):
        settings = """<?xml version="1.0" encoding="ISO-8859-1"?>
        <server verbose="3">
        <delays />
        </server>
        """
        service = pokerservice.PokerService(settings)
        class Timer:
            def active(self):
                return False
        service.timer['foo_1'] = Timer()
        service.timer['foo_2'] = Timer()
        service.cancelTimers('foo')
        self.assertEqual([], service.timer.keys())

class TourneyUnregisterTestCase(PokerServiceTestCaseBase):

    def test_ok(self):
        tourney_serial = 100
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['%s/../conf'
                                                          % SCRIPT_DIR])
        tourney.currency_serial = 1
        tourney.via_satellite = 0
        self.service.tourneys[tourney_serial] = tourney
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        packet = PacketPokerId(serial = user_serial,
                               game_id = tourney_serial)
        return_packet = self.service.tourneyUnregister(packet)
        self.assertEqual(packet, return_packet)
    # ----------------------------------------------------------------
    def test_does_not_exist(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.DOES_NOT_EXIST, p.code)
    # ----------------------------------------------------------------
    def test_not_registered(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['%s/../conf'
                                                          % SCRIPT_DIR])
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.NOT_REGISTERED, p.code)
    # ----------------------------------------------------------------
    def test_too_late(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['%s/../conf'
                                                          % SCRIPT_DIR])
        tourney.register(user_serial)
        tourney.currency_serial = 1
        tourney.state = pokertournament.TOURNAMENT_STATE_RUNNING
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.TOO_LATE, p.code)
    # ----------------------------------------------------------------
    def test_no_user2money(self):
        tourney_serial = 100
        user_serial = 1
        self.service.startService()
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['%s/../conf'
                                                          % SCRIPT_DIR])
        tourney.register(user_serial)
        tourney.currency_serial = 1
        tourney.buy_in = 1000
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.SERVER_ERROR, p.code)
        self.assertTrue("not in user2money" in p.message)
    # ----------------------------------------------------------------
    def test_no_user2tourney(self):
        tourney_serial = 100
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        tourney = pokertournament.PokerTournament(serial = tourney_serial,
                                                  dirs = ['%s/../conf'
                                                          % SCRIPT_DIR])
        tourney.register(user_serial)
        tourney.currency_serial = 1
        self.service.tourneys[tourney_serial] = tourney
        p = self.service.tourneyUnregister(PacketPokerId(serial = user_serial,
                                                         game_id = tourney_serial))
        self.assertEqual(PacketPokerTourneyUnregister.SERVER_ERROR, p.code)
        self.assertTrue("not in user2tourney" in p.message)
    # ----------------------------------------------------------------
    def test_coverDatabaseEvent(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockClient:
            def __init__(mcSelf): mcSelf.errorPackets = []
            def sendPacketVerbose(mcSelf, pack): mcSelf.errorPackets.append(pack)
        class MockPacket:
            def __init__(mpSelf):
                mpSelf.serial = 423
                mpSelf.game_id = 865
        class MockTourney:
            def __init__(mtSelf):
                mtSelf.currency_serial = mtSelf.buy_in = mtSelf.rake = 10
            def isRegistered(mtSelf, serial):
                self.assertEquals(serial, 423)
                return True
            def canUnregister(mtSelf, serial):
                self.assertEquals(serial, 423)
                return True
            def unregister(mtSelf, serial):
                self.assertEquals(serial, 423)
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if sql[:len(statement)] == "UPDATE user2money SET amount = amount + ":
                    cursorSelf.rowcount = 1
                elif sql[:len(statement)] == "DELETE FROM user2tourney WHERE user_serial":
                    cursorSelf.rowcount = 1
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self,
                                        [ "UPDATE user2money SET amount = amount + ",
                                          "DELETE FROM user2tourney WHERE user_serial"])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        client = MockClient()
        tourney = MockTourney()
        self.service.avatar_collection = PokerAvatarCollection()
        self.service.avatar_collection.add(423, client)
        self.service.tourneys = { 865 : tourney }

        # Not worth making this test cover dbevent, other tests do.  Here,
        # we make sure it is called as expected
        oldDbEvent = self.service.databaseEvent
        global calledDBCount
        calledDBCount = 0
        def dbEventMock(event = None, param1 = None, param2 = None, param3 = None):
            global calledDBCount
            calledDBCount += 1
            self.assertEquals(event, PacketPokerMonitorEvent.UNREGISTER)
            self.assertEquals(param1, 423)
            self.assertEquals(param2, 10)
            self.assertEquals(param3, 20)

        self.service.databaseEvent = dbEventMock

        clear_all_messages()

        pack = MockPacket()
        retPack =  self.service.tourneyUnregister(pack)
        self.assertEquals(pack, retPack)
        self.assertEquals(calledDBCount, 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find('tourneyUnregister: UPDATE user2money SET amount = amount + 20') >= 0)
        self.failUnless(msgs[1].find('tourneyUnregister: DELETE FROM user2tourney WHERE user_serial = 423') >= 0)
        self.service.db = oldDb
        self.service.databaseEvent = oldDbEvent
# ----------------------------------------------------------------
class TourneyCancelTestCase(PokerServiceTestCaseBase):
    def test_ok(self):
        class Tournament:
            def __init__(self):
                self.players = [1]
                self.serial = 1

        self.service.tourneys = {}
        self.service.tourneyCancel(Tournament())
        if verbose < 0:
            self.assertTrue(search_output('tourneyCancel:'))
# ----------------------------------------------------------------
class TourneyManagerTestCase(PokerServiceTestCaseBase):
    class ClientMockup:
        def __init__(self, serial, testObject):
            self.serial = serial
            self.tableJoined = None
            self.packets = []
            self.testObject = testObject
            self.expectedReason = ""

        def join(self, table, reason = ""):
            self.tableJoined = table
            self.testObject.assertEquals(self.expectedReason, reason)

        def sendPacketVerbose(self, packet):
            self.packets.append(packet)
    # ----------------------------------------------------------------
    def test01_no_rank(self):
        self.service.startService()
        self.service.verbose = 6
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        # One client (user1) has a Client logged in
        client1 = TourneyManagerTestCase.ClientMockup(self.user1_serial, self)
        self.service.avatar_collection.add(self.user1_serial, client1)
        self.service.spawnTourney(schedule)
        clear_all_messages()
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        self.failUnless(search_output('tourneyRegister: UPDATE user2money SET amount = amount - 300000 WHERE user_serial = 4 AND        currency_serial = 1 AND        amount >= 300000'), "UPDATE user2money expected verbose output not found")
        self.failUnless(search_output('tourneyRegister: INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (4, 1, 1)'), "INSERT INTO user2tourney")
        self.assertEquals(len(client1.packets), 1)
        self.assertEquals(client1.packets[0].type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(client1.packets[0].serial, self.user1_serial)
        self.assertEquals(client1.packets[0].game_id, tourney_serial)
        client1.packets = []
        self.assertEquals(client1.tableJoined, None)
        self.service.db.db.query("INSERT INTO user2table VALUES (" + str(self.user1_serial) + ", " + str(table_serial) + ", " + str(table_money) + ", 0)")
        self.service.db.db.query("UPDATE user2tourney SET table_serial = " + str(table_serial))
        self.service.tourneys[tourney_serial].can_register = False
        clear_all_messages()
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEquals(get_messages(), [])
        self.assertEqual(tourney_serial, packet.tourney['serial'])
        self.assertNotEqual(None, packet.tourney['rank2prize'])
        self.assertEqual(1, packet.tourney['registered'])
        self.assertEqual({'4' : {'rank': -1,
                                 'table_serial': table_serial,
                                 'name' : 'user1',
                                 'money': table_money}}, packet.user2properties)
    # ----------------------------------------------------------------
    def test02_no_money_no_table(self):
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.service.spawnTourney(schedule)
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEqual(tourney_serial, packet.tourney['serial'])
        self.assertEqual(1, packet.tourney['registered'])
        self.assertEqual({'4' : {'rank': -1,
                                 'table_serial': None,
                                 'name' : 'user1',
                                 'money': -1}}, packet.user2properties)
    # ----------------------------------------------------------------
    def test03_player_removed(self):
        self.service.startService()
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.service.spawnTourney(schedule)
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        table_serial = -1
        self.service.db.db.query("UPDATE user2tourney SET table_serial = " + str(table_serial))
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEqual(tourney_serial, packet.tourney['serial'])
        self.assertEqual(1, packet.tourney['registered'])
        self.assertEqual(0, len(packet.table2serials))
    # ----------------------------------------------------------------
    def test04_coverOldMySQLByMockUp(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'INSERT INTO tourneys',
                                                  'UPDATE tourneys_schedule',
                                                  'REPLACE INTO route']
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def insert_id(cSelf): return 15
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                cursorSelf.rowcount = 0
                cursorSelf.row = (None,)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service.startService()
        self.createUsers()
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]

        oldDb = self.service.db
        self.service.db = MockDatabase()
        realSpawnTourneyInCore = self.service.spawnTourneyInCore
        self.service.spawnTourneyInCore = lambda a, x, y, z, zz: True

        clear_all_messages()
        self.service.spawnTourney(schedule)
        msgs = get_messages()
        self.assertEquals(len(msgs), 1)
        self.assertEquals(msgs[0].find("spawnTourney: {'"), 0)
        self.assertEquals(self.service.db.cursorValue.counts,
                          {'INSERT INTO tourneys': 1,
                           'UPDATE tourneys_schedule': 0, 'REPLACE INTO route': 1})
        self.service.db = oldDb
        self.service.spawnTourneyInCore = realSpawnTourneyInCore
    # ------------------------------------------------------------------------
    def test04_bogusTourneySerial(self):
        self.service.startService()
        self.createUsers()
        tourney_serial = 17731
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEquals(packet.type, PACKET_ERROR)
        self.assertEquals(packet.other_type, PACKET_POKER_GET_TOURNEY_MANAGER)
        self.failUnless(packet.message.find("%d" % tourney_serial) >= 0)
        self.assertEquals(packet.code, PacketPokerGetTourneyManager.DOES_NOT_EXIST)
    # ------------------------------------------------------------------------
    def test05_moreThanOneTourneyRow(self):
        validStatements = ["SELECT user_serial, table_serial, rank FROM user2tourney WHERE tourney_serial =",
                           'SELECT user_serial, name FROM user2tourney, users WHERE user2tourney.tourney_serial',
                           "SELECT * FROM tourneys WHERE serial = "
                           ]
        class MockCursor(MockCursorBase):
            def fetchall(mcSelf): return mcSelf.rows
            def statementActions(cursorSelf, sql, statement):
                if statement == "SELECT * FROM tourneys WHERE serial = ":
                    cursorSelf.rowcount = 6
                    cursorSelf.rows = []
                    cursorSelf.row = {'sit_n_go' : 'n', 'buy_in' : 0, 'prize_min' : 0,
                                      }
                else:
                    cursorSelf.rowcount = 0
                    cursorSelf.rows = [ ]
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, validStatements)
        class MockDBWithDifferentCursorMethod(MockDatabase):
            def cursor(dbSelf, dummy = None):
                # Needed because tourneyManger() calls with argument "DictCursor"
                return MockDatabase.cursor(dbSelf)

        self.service = pokerservice.PokerService(self.settings)
        self.service.startService()

        oldDb = self.service.db
        self.service.db = MockDBWithDifferentCursorMethod(MockCursor)
        self.service.tourneys = {}
        tourney_serial = 17735
        clear_all_messages()
        packet = self.service.tourneyManager(tourney_serial)
        msgs = get_messages()
        self.failUnless(len(msgs) >= 1, "We should get at least one error message")
        self.assertEquals(msgs[0], 'tourneyManager: tourney_serial(17735) has more than one row in tourneys table, using first row returned')
        self.assertEquals(packet.type, PACKET_POKER_TOURNEY_MANAGER)

        self.service.db = oldDb
    # ------------------------------------------------------------------------
    def test06_prizes_tourney_regular(self):
        self.service.startService()
        self.createUsers()
        db = self.service.db.db
        tourney_serial = 11791
        db.query("INSERT INTO tourneys (serial, sit_n_go, state, buy_in) VALUES (%d, '%s', '%s', %d)" % (tourney_serial, 'n', 'complete', 1000))
        db.query("INSERT INTO user2tourney (tourney_serial, user_serial, table_serial, rank) VALUES (11791, 1, 1, 1)")
        db.query("INSERT INTO user2tourney (tourney_serial, user_serial, table_serial, rank) VALUES (11791, 2, 1, 2)")
        db.query("INSERT INTO user2tourney (tourney_serial, user_serial, table_serial, rank) VALUES (11791, 3, 1, 3)")
        db.query("INSERT INTO user2tourney (tourney_serial, user_serial, table_serial, rank) VALUES (11791, 4, 1, 4)")
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEquals(packet.type, PACKET_POKER_TOURNEY_MANAGER)
        rank2prize = packet.tourney['rank2prize']
        self.assertEquals(len(rank2prize), 2)
        self.assertEquals(int(rank2prize[0]), 2800)
        self.assertEquals(int(rank2prize[1]), 1200)
        self.assertEquals(packet.tourney['registered'], 4)

    # ------------------------------------------------------------------------
    def test07_prizes_tourney_sng(self):
        self.service.startService()
        self.createUsers()
        db = self.service.db.db
        tourney_serial = 11791
        db.query("INSERT INTO tourneys (serial, sit_n_go, state, buy_in, players_quota) VALUES (%d, '%s', '%s', %d, %d)" % (tourney_serial, 'y', 'complete', 1000, 10))
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEquals(packet.type, PACKET_POKER_TOURNEY_MANAGER)
        rank2prize = packet.tourney['rank2prize']
        self.assertEquals(len(rank2prize), 3)
        self.assertEquals(int(rank2prize[0]), 5000)
        self.assertEquals(int(rank2prize[1]), 3000)
        self.assertEquals(int(rank2prize[2]), 2000)
        self.assertEquals(packet.tourney['registered'], 0)

    # ------------------------------------------------------------------------
    def test08_prizes_guarantee_amount(self):
        self.service.startService()
        self.createUsers()
        db = self.service.db.db
        tourney_serial = 11791
        db.query("INSERT INTO tourneys (serial, sit_n_go, state, buy_in, players_quota, prize_min) VALUES (%d, '%s', '%s', %d, %d, %d)" % (tourney_serial, 'n', 'complete', 100, 1000, 10000))
        db.query("INSERT INTO user2tourney (tourney_serial, user_serial, table_serial, rank) VALUES (11791, 1, 1, 1)")
        db.query("INSERT INTO user2tourney (tourney_serial, user_serial, table_serial, rank) VALUES (11791, 2, 1, 2)")
        db.query("INSERT INTO user2tourney (tourney_serial, user_serial, table_serial, rank) VALUES (11791, 3, 1, 3)")
        db.query("INSERT INTO user2tourney (tourney_serial, user_serial, table_serial, rank) VALUES (11791, 4, 1, 4)")
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEquals(packet.type, PACKET_POKER_TOURNEY_MANAGER)
        rank2prize = packet.tourney['rank2prize']
        self.assertEquals(len(rank2prize), 2)
        self.assertEquals(int(rank2prize[0]), 7000)
        self.assertEquals(int(rank2prize[1]), 3000)
        self.assertEquals(packet.tourney['registered'], 4)

###########################################################################
class TourneyCreateTestCase(PokerServiceTestCaseBase):

    def test01_create(self):
        self.service.startService()
        self.service.settings.headerSet("/server/@autodeal", "no")
        self.createUsers()
        tourney_name = 'testname'
        packet = PacketPokerCreateTourney(currency_serial = 1,
                                          name = tourney_name,
                                          players = [ self.user1_serial, self.user2_serial ])
        result = self.service.tourneyCreate(packet)
        self.assertEquals(PACKET_ACK, result.type)
        places = self.service.getPlayerPlaces(self.user1_serial)
        tourney = self.service.tourneys[places.tourneys[0]]
        self.assertEquals(tourney_name, tourney.name)

    def test02_register_failed(self):
        self.service.startService()
        self.createUsers()
        players = [ self.user1_serial, self.user2_serial ]
        packet = PacketPokerCreateTourney(currency_serial = 1,
                                          buy_in = self.default_money * 10,
                                          players = players)
        result = self.service.tourneyCreate(packet)
        self.assertEquals(PACKET_POKER_ERROR, result.type)
        self.assertSubstring(str(players), result.message)

###########################################################################
class TourneyMovePlayerTestCase(PokerServiceTestCaseBase):

    tourney_serial = 10

    class Tournament:
        def __init__(self):
            self.serial = TourneyMovePlayerTestCase.tourney_serial

    class Table:
        def __init__(self, testObject):
            self.avatar_collection = PokerAvatarCollection()
            self.testObj = testObject

        def movePlayer(self, client, serial, to_game_id, reason = ""):
            self.testObj.assertEquals(reason, PacketPokerTable.REASON_TOURNEY_MOVE)

    def test_ok(self):
        self.service.startService()
        self.service.getTable = lambda from_game_id: TourneyMovePlayerTestCase.Table(self)
        user_serial = 1
        table_serial = 100
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial, table_serial) VALUES (%d, %d, %d, %d)" % ( user_serial, 1, TourneyMovePlayerTestCase.tourney_serial, table_serial ))
        self.assertTrue(self.service.tourneyMovePlayer(TourneyMovePlayerTestCase.Tournament(), table_serial, 200, user_serial))
        cursor.close()

    def test_missing_db_record(self):
        self.service.startService()
        self.service.getTable = lambda from_game_id: TourneyMovePlayerTestCase.Table(self)
        user_serial = 1
        table_serial = 100
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial, table_serial) VALUES (%d, %d, %d, %d)" % ( user_serial, 1, TourneyMovePlayerTestCase.tourney_serial, table_serial ))
        wrong_user_serial = 2
        self.assertFalse(self.service.tourneyMovePlayer(TourneyMovePlayerTestCase.Tournament(), table_serial, 200, wrong_user_serial))
        cursor.close()

# ----------------------------------------------------------------
class TourneyNotifyTestCase(PokerServiceTestCaseBase):
    # ----------------------------------------------------------------
    def startTournament(self, table_serial, table_money):
        #
        # start tournament
        #
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.service.spawnTourney(schedule)
        self.service.tourneyRegister(PacketPokerTourneyRegister(serial = self.user1_serial,
                                                                game_id = tourney_serial))
        self.service.db.db.query("INSERT INTO user2table VALUES (" + str(self.user1_serial) + ", " + str(table_serial) + ", " + str(table_money) + ", 0)")
        self.service.db.db.query("UPDATE user2tourney SET table_serial = " + str(table_serial))
        self.service.tourneys[tourney_serial].can_register = False
        packet = self.service.tourneyManager(tourney_serial)
        self.assertEqual(tourney_serial, packet.tourney['serial'])
        self.assertNotEqual(None, packet.tourney['rank2prize'])
        self.assertEqual(1, packet.tourney['registered'])
        self.assertEqual({'4' : {'rank': -1,
                                 'table_serial': table_serial,
                                 'name' : 'user1',
                                 'money': table_money}}, packet.user2properties)

    def test01_notifyStart(self):
        self.service.startService()
        self.service.verbose = 6
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        #
        # user isLogged and in explain mode
        #
        avatar1 = self.service.createAvatar()
        avatar1.queuePackets()
        avatar1.relogin(self.user1_serial)
        avatar1.setExplain(True)
        #
        # user isLogged but not in explain mode
        #
        avatar2 = self.service.createAvatar()
        avatar1.queuePackets()
        avatar2.relogin(self.user2_serial)

        self.startTournament(table_serial, table_money)

        #
        # tourneyNotifyStart only notifies user1
        #
        avatar1.resetPacketsQueue()
        avatar2.resetPacketsQueue()
        self.assertEquals(1, len(self.service.tourneyNotifyStart(tourney_serial)))
        #
        # If user2 is notified, it will be called and raise an error
        #
        def deferredCanceled(packets):
            self.assertEqual(None, packets)

        def check(packets):
            self.assertEqual(1, len(packets))
            self.assertEqual(PACKET_POKER_TOURNEY_START, packets[0].type)
            self.assertEqual(tourney_serial, packets[0].tourney_serial)
            self.assertEqual(table_serial, packets[0].table_serial)
            self.assertEqual([], avatar2.resetPacketsQueue())
            self.assertEqual(0, avatar2.flushLongPollDeferred().called)
            avatar2.flushLongPollDeferred().callback(None)
            return packets
        d2 = avatar2.longpollDeferred()
        avatar2.longPollTimer.cancel()
        d2.addCallback(deferredCanceled)
        d1 = avatar1.longpollDeferred()
        avatar1.longPollTimer.cancel()
        d1.addCallback(check)
        return defer.DeferredList((d1, d2), fireOnOneErrback = True)

    def test02_no_explain(self):
        self.service.startService()
        self.service.verbose = 6
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        #
        # user isLogged and in explain mode
        #
        avatar1 = self.service.createAvatar()
        avatar1.queuePackets()
        avatar1.relogin(self.user1_serial)
        avatar1.setExplain(True)

        self.startTournament(table_serial, table_money)
        avatar1.resetPacketsQueue()
        self.assertEquals(1, len(self.service.tourneyNotifyStart(tourney_serial)))
        #
        # When the actual notification occurs (scheduled with callLater) it
        # will not be broadcasted because the avatar is no longer in explain mode.
        #
        avatar1.setExplain(None)
        #
        # If user1 is notified, it will be called and raise an error
        #
        def mustNotBeCalled(packets):
            self.assertEqual(None, packets)
        avatar1.longpollDeferred().addCallback(mustNotBeCalled)
        avatar1.longPollTimer.cancel()

    def test03_not_logged_in(self):
        self.service.startService()
        self.service.verbose = 6
        self.createUsers()
        user_serial = self.user1_serial
        table_serial = 606
        table_money = 140
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        #
        # user isLogged and in explain mode
        #
        avatar1 = self.service.createAvatar()
        avatar1.queuePackets()
        avatar1.relogin(self.user1_serial)
        avatar1.setExplain(True)

        self.startTournament(table_serial, table_money)
        self.assertEquals(1, len(self.service.tourneyNotifyStart(tourney_serial)))
        #
        # When the actual notification occurs (scheduled with callLater) it
        # will not be broadcasted because the avatar is no longer logged in.
        #
        avatar1.logout()
        avatar1.resetPacketsQueue()
        #
        # If user1 is notified, it will be called and raise an error
        #
        def mustNotBeCalled(packets):
            self.assertEqual(None, packets)
        avatar1.longpollDeferred().addCallback(mustNotBeCalled)
        avatar1.longPollTimer.cancel()

    def test04_wrong_tourney(self):
        self.service.startService()
        caughtIt = False
        try:
            self.service.tourneyNotifyStart(48484848)
            self.failIf(True, "We should have caught a UserWarning")
        except UserWarning:
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught a UserWarning!")

    def test05_broadcast_start(self):
        self.service.startService()
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        host = 'hostname'
        port = '80'
        tourney_serial = str(tourney_serial)
        self.service.db.db.query("INSERT INTO resthost (name, host, port) VALUES ('name', '%s', %s)" % ( host, port ))
        def getPage(url):
            self.assertEqual('http://' + host + ':' + port + '/TOURNEY_START?tourney_serial=' + tourney_serial, url)
        self.service.getPage = getPage
        self.service.tourneyBroadcastStart(tourney_serial)

    def test06_monitor(self):
        self.service.startService()
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        self.createUsers()
        table_serial = 606
        table_money = 140
        self.startTournament(table_serial, table_money)
        tourney = self.service.tourneys[tourney_serial]
        self.assertEqual(pokertournament.TOURNAMENT_STATE_REGISTERING, tourney.state)
        self.databaseEvent_called = False
        def databaseEvent(event = None, param1 = None, param2 = None, param3 = None):
            self.databaseEvent_called = True
            self.assertEqual(PacketPokerMonitorEvent.TOURNEY_START, event)
            self.assertEqual(tourney_serial, param1)
        self.service.databaseEvent = databaseEvent
        self.service.tourneyNewState(tourney, pokertournament.TOURNAMENT_STATE_REGISTERING, pokertournament.TOURNAMENT_STATE_RUNNING)
        self.assertEqual(True, self.databaseEvent_called)

class ListHandsTestCase(PokerServiceTestCaseBase):

    def test_ok(self):
        self.service.startService()
        ( total, hands ) = self.service.listHands("SELECT '1'", "SELECT '2'")
        self.assertEqual(["1"], hands)
        self.assertEqual("2", total)

class SetAccountTestCase(PokerServiceTestCaseBase):

    def test_insert_ok(self):
        self.service.startService()
        affiliate = 3
        info = self.service.setAccount(PacketPokerSetAccount(name = 'test08_1',
                                                             password = 'PASSWORD',
                                                             email = 'test08_1@HOME.COM',
                                                             affiliate = affiliate,
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        self.assertEquals(affiliate, info.affiliate)
        packed = info.pack()
        other_info = PacketPokerPersonalInfo()
        other_info.unpack(packed)
        self.assertEquals('1980-01-01', other_info.birthdate)

    def test_update_ok(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(serial = serial,
                                                             name = 'user1',
                                                             password = 'password2',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)

    def test_setPersonalInfo_fail(self):
        self.service.startService()
        self.service.setPersonalInfo = lambda x: False
        info = self.service.setAccount(PacketPokerSetAccount(name = 'test08_1',
                                                             password = 'PASSWORD',
                                                             email = 'test08_1@HOME.COM',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals("unable to set personal information", info.message)
        self.assertEquals(PacketPokerSetAccount.SERVER_ERROR, info.code)

    def test_name_already_exists(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(serial = 10001,
                                                             email = 'a@b.c',
                                                             name = 'user1'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.NAME_ALREADY_EXISTS, info.code)

    def test_email_already_exists(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = '1@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user2',
                                                             password = 'password2',
                                                             email = '2@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        info = self.service.setAccount(PacketPokerSetAccount(serial = serial,
                                                             name = 'user1',
                                                             email = '2@b.c'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.EMAIL_ALREADY_EXISTS, info.code)

    def test_update_duplicate_serial(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        serial = info.serial
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user2',
                                                             password = 'password2',
                                                             email = '2@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        cursor = self.db.cursor()
        cursor.execute('ALTER TABLE users CHANGE COLUMN serial s1 INT UNSIGNED NOT NULL AUTO_INCREMENT')
        cursor.execute('ALTER TABLE users ADD COLUMN serial INT UNSIGNED NOT NULL')
        cursor.execute('DROP INDEX name_idx ON users')
        cursor.execute('DROP INDEX email_idx ON users')
        cursor.execute('UPDATE users SET serial = %d' % serial)
        info = self.service.setAccount(PacketPokerSetAccount(serial = serial,
                                                             name = 'user1',
                                                             password = 'password4',
                                                             email = 'a@b.c'))
        self.assertEquals(info.type, PACKET_ERROR)
        self.assertEquals(PacketPokerSetAccount.SERVER_ERROR, info.code)

    def test_name_error(self):
        info = self.service.setAccount(PacketPokerSetAccount(name = 'ab'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.NAME_TOO_SHORT, info.code)

    def test_password_error(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'abcdef',
                                                             password = ''))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.PASSWORD_TOO_SHORT, info.code)

    def test_email_error(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'abcdef',
                                                             password = 'ABCDEF',
                                                             email = ''))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.INVALID_EMAIL, info.code)

    def test_email_duplicate(self):
        self.service.startService()
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                             password = 'password1',
                                                             email = 'a@b.c',
                                                             birthdate = '1980/01/01'))
        self.assertEquals(PACKET_POKER_PERSONAL_INFO, info.type)
        info = self.service.setAccount(PacketPokerSetAccount(name = 'user2',
                                                             password = 'password2',
                                                             email = 'a@b.c'))
        self.assertEquals(PACKET_ERROR, info.type)
        self.assertEquals(PacketPokerSetAccount.EMAIL_ALREADY_EXISTS, info.code)

    def test_user_private_duplicate(self):
        self.service.startService()
        cursor = self.db.cursor()
        cursor.execute("INSERT INTO users_private (serial) VALUES (4)")
        cursor.close()
        raised = False
        try:
            info = self.service.setAccount(PacketPokerSetAccount(name = 'user1',
                                                                 password = 'password1',
                                                                 email = 'a@b.c',
                                                                 birthdate = '1980/01/01'))
        except IntegrityError:
            raised = True
        self.assertTrue(raised)

class ShutdownCheckTestCase(PokerServiceTestCaseBase):

    class PokerGame:
        def isEndOrNull(self):
            return not self.playing

    class PokerTable:
        def __init__(self):
            self.game = ShutdownCheckTestCase.PokerGame()


    def tearDown(self):
        pass

    def test_down(self):
        self.deferred_called = False
        def c(x):
            self.deferred_called = True
        d = defer.Deferred()
        d.addCallback(c)
        self.service.shutdown_deferred = d
        self.service.down = True
        self.service.shutdownCheck()
        self.assertTrue(self.deferred_called)
        del self.deferred_called

    def test_ok(self):
        table = ShutdownCheckTestCase.PokerTable()
        table.game.playing = True
        self.service.tables = { 1: table }
        self.service.down = False
        d = defer.Deferred()
        self.service.shutdown_deferred = d
        self.service.shutdownCheck()
        self.assertEqual(d, self.service.shutdown_deferred)
        table.game.playing = False
        def f(status):
            self.assertTrue(self.service.down)
            return status
        d.addCallback(f)
        return d

class TourneySatelliteTestCase(PokerServiceTestCaseBase):

    def test_lookup_nop(self):
        class Tournament:
            def __init__(self):
                self.satellite_of = 0

        self.service.startService()
        self.assertEqual((0, None), self.service.tourneySatelliteLookup(Tournament()), 'tourneySatelliteLookup does nothing')

    def test_lookup_not_found(self):
        class Tournament:
            def __init__(self):
                self.satellite_of = 12345

        self.service.startService()
        self.assertEqual((0, False), self.service.tourneySatelliteLookup(Tournament()), 'tourneySatelliteLookup does not find the tournament for which it is a satellite')

    def test_lookup_found_wrong_state(self):
        class Tournament:
            def __init__(self):
                self.serial = 234
                self.satellite_of = 12345

        class TournamentCandidate:
            def __init__(self):
                self.schedule_serial = 12345
                self.state = pokertournament.TOURNAMENT_STATE_RUNNING

        self.service.startService()
        self.service.tourneys = { 12345: TournamentCandidate() }
        self.assertEqual((0, pokertournament.TOURNAMENT_STATE_REGISTERING), self.service.tourneySatelliteLookup(Tournament()), 'tourneySatelliteLookup find a tournament which is not in the expected state')

    def test_lookup(self):
        class Tournament:
            def __init__(self):
                self.satellite_of = 12345

        class TournamentCandidate:
            def __init__(self):
                self.serial = 4343
                self.schedule_serial = 12345
                self.state = pokertournament.TOURNAMENT_STATE_REGISTERING

        self.service.startService()
        self.service.tourneys = { 12345: TournamentCandidate() }
        self.assertEqual((4343, None), self.service.tourneySatelliteLookup(Tournament()), 'tourneySatelliteLookup finds a tournament')

    def test_WaitingList_nop(self):
        class Tournament:
            def __init__(self):
                self.satellite_of = 0

        self.service.startService()
        self.assertEqual(False, self.service.tourneySatelliteWaitingList(Tournament()), 'tourneySatelliteWaitingList does nothing')

    def test_WaitingList_no_players_left(self):
        class Tournament:
            def __init__(self):
                self.satellite_of = 1
                self.satellite_registrations = [ 1 ]
                self.satellite_player_count = 1

        self.service.startService()
        self.assertEqual(False, self.service.tourneySatelliteWaitingList(Tournament()), 'tourneySatelliteWaitingList does nothing')

    def test_WaitingList(self):

        self.service.startService()
        self.createUsers()

        tourney_serial, tourney = self.service.tourneys.items()[0]
        tourney.players_quota = 10

        class Tournament:
            def __init__(Tself):
                Tself.satellite_of = tourney_serial
                Tself.satellite_registrations = [ ]
                Tself.satellite_player_count = 2
                Tself.winners = [ self.user2_serial, self.user1_serial, self.user3_serial, 200 ]

        tournament = Tournament()
        self.assertEqual(True, self.service.tourneySatelliteSelectPlayer(tournament, self.user2_serial, 1), 'tourneySatelliteSelectPlayer')
        self.assertEqual([self.user2_serial], tournament.satellite_registrations)
        tournament.satellite_registrations = [] # pretend the user was registered as a a side effect of a previous tournament
        self.failUnless(self.service.tourneySatelliteWaitingList(tournament), 'tourneySatelliteWaitingList adds player ' + str(self.user1_serial))
        self.assertEquals([self.user1_serial, self.user3_serial], tournament.satellite_registrations)
        cursor = self.db.cursor()
        cursor.execute("SELECT * FROM user2tourney WHERE user_serial = %d and tourney_serial = %d" % ( self.user1_serial, tourney_serial ))
        self.assertEqual(1, cursor.rowcount, 'user %d registered' % self.user1_serial)
        cursor.close()

    def test_SelectPlayer_nop(self):
        class Tournament:
            def __init__(self):
                self.satellite_of = 0

        self.service.startService()
        self.assertEqual(False, self.service.tourneySatelliteSelectPlayer(Tournament(), 0, 0), 'tourneySatelliteSelectPlayer does nothing')

    def test_SelectPlayer(self):
        class Tournament:
            def __init__(self):
                self.satellite_player_count = 10
                self.satellite_registrations = []

        self.service.startService()
        self.createUsers()
        tournament = Tournament()
        tourney_serial, schedule = self.service.tourneys.items()[0]
        tournament.satellite_of = tourney_serial

        rank = 1
        cursor = self.db.cursor()

        cursor.execute("SELECT * FROM user2tourney WHERE user_serial = %d and tourney_serial = %d" % ( self.user1_serial, tourney_serial ))
        self.assertEqual(0, cursor.rowcount, 'user %d not registered' % self.user1_serial)

        self.assertEqual(True, self.service.tourneySatelliteSelectPlayer(tournament, self.user1_serial, rank), 'tourneySatelliteSelectPlayer')

        self.assertEqual([ self.user1_serial ], tournament.satellite_registrations, 'registrations')
        cursor.execute("SELECT * FROM user2tourney WHERE user_serial = %d and tourney_serial = %d" % ( self.user1_serial, tourney_serial ))
        self.assertEqual(1, cursor.rowcount, 'user %d registered' % self.user1_serial)
        cursor.close()

    def test_SelectPlayer_duplicate_user(self):
        class Tournament:
            def __init__(self):
                self.satellite_player_count = 10
                self.satellite_registrations = []

        class ClientMockup:
            def __init__(self, serial):
                self.serial = serial
                self.packets = []

            def sendPacketVerbose(self, packet):
                self.packets.append(packet)

        self.service.startService()
        self.createUsers()
        client1 = ClientMockup(self.user1_serial)
        self.service.avatar_collection.add(self.user1_serial, client1)
        tournament = Tournament()
        tourney_serial, schedule = self.service.tourneys_schedule.items()[0]
        tournament.satellite_of = tourney_serial

        rank = 1
        cursor = self.db.cursor()

        cursor.execute("SELECT * FROM user2tourney WHERE user_serial = %d and tourney_serial = %d" % ( self.user1_serial, tourney_serial ))
        self.assertEqual(0, cursor.rowcount, 'user %d not registered' % self.user1_serial)

        #
        # The user is registered to satellite_of
        #
        self.assertEqual(True, self.service.tourneySatelliteSelectPlayer(tournament, self.user1_serial, rank), 'tourneySatelliteSelectPlayer')
        self.assertEqual(1, len(client1.packets))
        self.assertEqual(PACKET_POKER_TOURNEY_REGISTER, client1.packets[0].type)
        self.assertEqual([ self.user1_serial ], tournament.satellite_registrations, 'registrations')

        cursor.execute("SELECT * FROM user2tourney WHERE user_serial = %d and tourney_serial = %d" % ( self.user1_serial, tourney_serial ))
        self.assertEqual(1, cursor.rowcount, 'user %d registered' % self.user1_serial)

        #
        # Another attempt to register the same user returns an error packet
        #
        self.assertEqual(True, self.service.tourneySatelliteSelectPlayer(tournament, self.user1_serial, rank), 'tourneySatelliteSelectPlayer')
        self.assertEqual(2, len(client1.packets))
        self.assertEqual(PACKET_ERROR, client1.packets[1].type)
        self.assertEqual(PacketPokerTourneyRegister.ALREADY_REGISTERED, client1.packets[1].code)

        cursor.execute("SELECT * FROM user2tourney WHERE user_serial = %d and tourney_serial = %d" % ( self.user1_serial, tourney_serial ))
        self.assertEqual(1, cursor.rowcount, 'user %d registered' % self.user1_serial)
        cursor.close()

class TourneyFinishedTestCase(PokerServiceTestCaseBase):

    class ClientMockup:
        def __init__(self, serial, testObject):
            self.serial = serial
#            self.tableJoined = None
            self.packets = []
            self.testObject = testObject
            self.expectedReason = ""

        def join(self, table, reason = ""):
            self.tableJoined = table
            self.assertEquals(self.execptedReason, reason)

        def sendPacketVerbose(self, packet):
            self.packets.append(packet)

    def test_ok(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.prize_currency = 0
                self.serial = 1
                self.players = []

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial, self)
        self.service.avatar_collection.add(self.user1_serial, client1)
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT amount FROM user2money WHERE user_serial = %d" % winner_serial)
        (amount,) = cursor.fetchone()
        self.assertEqual(self.default_money + tournament.prize_min, amount)
        cursor.close()

    def test_prize_currency(self):
        prize_currency = 2
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.prize_currency = prize_currency
                self.serial = 1
                self.players = []
                self.bailor_serial = 0

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial, self)
        self.service.avatar_collection.add(self.user1_serial, client1)
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT amount FROM user2money WHERE user_serial = %d AND currency_serial = %d" % ( winner_serial, prize_currency ))
        (amount,) = cursor.fetchone()
        self.assertEqual(tournament.prize_min, amount)
        cursor.close()

    def test_no_bailor(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.prize_currency = 0
                self.serial = 1
                self.players = []

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        tournament = Tournament()
        winner_serial = 10
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = 2000
        self.assertEqual(False, self.service.tourneyFinished(tournament))
        if verbose < 0:
            self.assertTrue(search_output("bailor failed to provide requested money"))

    def test_bailor_zero(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.prize_currency = 0
                self.serial = 1
                self.players = []

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        tournament = Tournament()
        winner_serial = 10
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = 0
        self.assertEqual(True, self.service.tourneyFinished(tournament))

    def test_tourney_finish(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.prize_currency = 0
                self.serial = 1
                self.finish_time = testclock._seconds_value
                self.players = []

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial, self)
        self.service.avatar_collection.add(self.user1_serial, client1)
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT finish_time FROM tourneys WHERE serial = %d" % tournament.serial)
        (finish_time,) = cursor.fetchone()
        self.failUnless(tournament.finish_time - finish_time < 1)
        cursor.close()

    def test_delete_route(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.prize_currency = 0
                self.serial = 1
                self.players = []

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial, self)
        client1.tourneys = []
        client2 = self.ClientMockup(self.user2_serial, self)
        client2.tourneys = [1, 2]
        self.service.avatar_collection.add(self.user1_serial, client1)
        self.service.avatar_collection.add(self.user2_serial, client2)
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        tournament.players = [ self.user1_serial, self.user2_serial ]
        self.service._ping_delay = 1
        d = defer.Deferred()
        d.addCallback(self.service.tourneyDeleteRouteActual)
        self.service.tourneyDeleteRouteActual = d.callback
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT tourney_serial FROM route WHERE tourney_serial = %s", tournament.serial)
        self.assertEqual(1, cursor.rowcount)
        (tournament_serial,) = cursor.fetchone()
        self.assertEqual(tournament.serial, tournament_serial)
        self.secondsStart = testclock._seconds_value
        def checkAvatarTourneys(x):
            self.assertEqual(True, 1 not in client1.tourneys)
            self.assertEqual(True, 1 not in client2.tourneys)
        def checkRoute(x):
            cursor.execute("SELECT tourney_serial FROM route WHERE tourney_serial = %s", tournament.serial)
            self.assertEqual(0, cursor.rowcount)
            self.assertEquals(testclock._seconds_value - self.secondsStart  >= self.service._ping_delay/1000.0, True)
            cursor.close()
        d.addCallback(checkAvatarTourneys)
        d.addCallback(checkRoute)
        return d

    def test_delete_route_table_delay(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.prize_currency = 0
                self.serial = 1
                self.players = []

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial, self)
        self.service.avatar_collection.add(self.user1_serial, client1)
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        self.service._ping_delay = 1
        self.service.delays['extra_wait_tourney_finish'] = "40"
        d = defer.Deferred()
        d.addCallback(self.service.tourneyDeleteRouteActual)
        self.service.tourneyDeleteRouteActual = d.callback
        self.service.tourneyFinished(tournament)
        cursor = self.db.cursor()
        cursor.execute("SELECT tourney_serial FROM route WHERE tourney_serial = %s", tournament.serial)
        self.assertEqual(1, cursor.rowcount)
        (tournament_serial,) = cursor.fetchone()
        self.assertEqual(tournament.serial, tournament_serial)
        self.secondsStart = testclock._seconds_value
        def checkRoute(x):
            cursor.execute("SELECT tourney_serial FROM route WHERE tourney_serial = %s", tournament.serial)
            self.assertEqual(0, cursor.rowcount)
            self.assertEquals(testclock._seconds_value - self.secondsStart  >= int(self.service.delays['extra_wait_tourney_finish']), True)
        d.addCallback(checkRoute)
        return d

    def test_tourney_finish_packet(self):
        class Tournament:
            def __init__(self):
                self.prize_min = 10
                self.buy_in = 0
                self.registered = 2
                self.currency_serial = 1
                self.prize_currency = 0
                self.serial = 1
                self.players = []

            def prizes(self):
                return [self.prize_min]
        self.service.startService()
        self.createUsers()
        client1 = self.ClientMockup(self.user1_serial, self)
        self.service.avatar_collection.add(self.user1_serial, client1)
        client2 = self.ClientMockup(self.user2_serial, self)
        self.service.avatar_collection.add(self.user2_serial, client2)
        tournament = Tournament()
        winner_serial = self.user1_serial
        tournament.winners = [ winner_serial ]
        tournament.bailor_serial = self.user2_serial
        self.service.tourneyFinished(tournament)
        self.assertEqual(0, len(client1.packets))
        self.assertEqual(0, len(client2.packets))

##############################################################################
class BreakTestCase(PokerServiceTestCaseBase):
    class Table:
        def __init__(self):
            self.message = None
            self.type = None
            self.destroyCalled = 0

        def broadcastMessage(self, type, message):
            self.type = type
            self.message = message

        def scheduleAutoDeal(self):
            self.autodeal = 1

    class Database:
        class Cursor:
            def execute(self, sql):
                self.sql = sql
                self.rowcount = 1

            def close(self):
                pass

        def cursor(self):
            self._cursor = BreakTestCase.Database.Cursor()
            return self._cursor

        def close(self):
            pass

        def literal(self, args):
            pass

        class InternalDatabase:
            def query(self, args):
                pass
        db = InternalDatabase()

    class Tournament:
        def __init__(self):
            self.serial = 1
            self.start_time = 1
    # ------------------------------------------------------------------------
    def test01_tourneyNewState_simpleTransitions(self):
        def ok(tourney):
            self.callCount += 1
        def notok(tourney):
            self.failIf(1)

        saveDb = self.service.db
        self.callCount = 0

        self.service.db = BreakTestCase.Database()
        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDestroyGame = notok

        self.service.tourneyBreakWait = ok
        self.service.tourneyNewState(BreakTestCase.Tournament(),
             pokertournament.TOURNAMENT_STATE_RUNNING, pokertournament.TOURNAMENT_STATE_BREAK_WAIT)
        self.assertEquals(self.callCount, 1)
        self.service.tourneyBreakWait = notok
        self.callCount = 0
        self.service.db = saveDb
    # ------------------------------------------------------------------------
    def tourneyNewState_tourneyResumeAndDeal(self, waitMin, waitMax):
        """Helper function for testing tourneyResumeAndDeal state change.
        The wait for the action must be between waitMin and waitMax"""

        self.service.startService()
        saveDb = self.service.db

        # First, Setup functions that should not be caled and force them
        # to fail

        def notok(tourney):
            self.failIf(1)

        self.service.db = BreakTestCase.Database()
        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDestroyGame = notok

        # Next, create deferreds that must be called.  Since the deferred
        # callbacks are in the function, we will get a reactor 120 second
        # timeout error if these functions are not called.  They also use
        # callCount to make sure they aren't called too often.

        tourneyBreakResumeDeferred = defer.Deferred()
        def confirmTourneyBreakResume(tourney):
            # Note that when asserts in here fail, it is just a reactor error
            self.assertEquals(testclock._seconds_value - self.secondsStart  >= waitMin, True)
            self.assertEquals(testclock._seconds_value - self.secondsStart  <= waitMax, True)
            self.assertEquals(self.callCount, 0)
            self.callCount += 1
            tourneyBreakResumeDeferred.callback(True)

        tourneyDealDeferred = defer.Deferred()
        def confirmTourneyDeal(tourney):
            self.assertEquals(self.callCount, 1)
            self.callCount += 1
            tourneyDealDeferred.callback(True)

        self.callCount = 0
        self.service.tourneyBreakResume = confirmTourneyBreakResume
        self.service.tourneyDeal = confirmTourneyDeal
        self.secondsStart = testclock._seconds_value

        self.service.tourneyNewState(BreakTestCase.Tournament(), pokertournament.TOURNAMENT_STATE_BREAK, pokertournament.TOURNAMENT_STATE_RUNNING)

        self.service.db = saveDb
        return defer.DeferredList((tourneyBreakResumeDeferred, tourneyDealDeferred), fireOnOneErrback = True)

    def test02_tourneyNewState_tourneyResumeAndDeal_nowait(self):
        return self.tourneyNewState_tourneyResumeAndDeal(0, 5)

    def test03_tourneyNewState_tourneyResumeAndDeal_withWait(self):
        self.service.delays['extra_wait_tourney_break'] = "40"
        return self.tourneyNewState_tourneyResumeAndDeal(40, 45)
    # ------------------------------------------------------------------------
    def tourneyNewState_tourneyStart(self, waitMin, waitMax):
        """Helper function for testing tourney starting state change.
        The wait for the action must be between waitMin and waitMax"""

        self.service.startService()
        saveDb = self.service.db

        # First, Setup functions that should not be caled and force them
        # to fail

        def notok(tourney):
            self.failIf(1)

        self.service.db = BreakTestCase.Database()
        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDestroyGame = notok

        # Next, create deferreds that must be called.  Since the deferred
        # callbacks are in the function, we will get a reactor 120 second
        # timeout error if these functions are not called.  They also use
        # callCount to make sure they aren't called too often.

        def confirmTourneyDeal(tourney):
            self.assertEquals(testclock._seconds_value - self.secondsStart  >= waitMin, True)
            self.assertEquals(testclock._seconds_value - self.secondsStart  <= waitMax, True)
            self.assertEquals(self.callCount, 0)
            self.callCount += 1
            tourneyDealDeferred.callback(True)

        tourneyDealDeferred = defer.Deferred()

        self.callCount = 0
        self.service.tourneyDeal = confirmTourneyDeal
        self.secondsStart = testclock._seconds_value

        self.service.tourneyNewState(BreakTestCase.Tournament(), pokertournament.TOURNAMENT_STATE_REGISTERING, pokertournament.TOURNAMENT_STATE_RUNNING)

        self.service.db = saveDb
        return tourneyDealDeferred

    def test04_tourneyNewState_tourneyStart_nowait(self):
        return self.tourneyNewState_tourneyStart(0, 5)

    def test05_tourneyNewState_tourneyStart_withWait(self):
        self.service.delays['extra_wait_tourney_start'] = "40"
        return self.tourneyNewState_tourneyStart(40, 45)
    # ------------------------------------------------------------------------
    def tourneyFinish(self, waitMin, waitMax):
        """Helper function for testing tourney Finish callback.
        The wait for the action must be between waitMin and waitMax"""

        self.service.startService()
        saveDb = self.service.db
        saveTables = self.service.tables

        # Create a deferred that our MockTable will call when it is
        # destroyed, since that is the last function called by
        # tourneyDestroyGameActual().  If the callback isn't done, we will
        # get a reactor 120 second timeout error, so we can thus confirm
        # that DestroyGameActual got called

        tableDestroyDeferred = defer.Deferred()
        class MockTable:
            def __init__(self):
                self.destroyCalled = 0
            def destroy(table):
                self.assertEquals(testclock._seconds_value - self.secondsStart  >= waitMin, True)
                self.assertEquals(testclock._seconds_value - self.secondsStart  <= waitMax, True)
                self.assertEquals(table.destroyCalled, 0)
                table.destroyCalled += 1
                tableDestroyDeferred.callback(True)
                self.service.tables = saveTables

        ourTable  = MockTable()
        class MockGame:
            def __init__(game):
                game.id = 1102

        ourTable.game = MockGame()
        self.service.tables = { 1102: ourTable }

        def notok(tourney):
            self.failIf(1)

        self.service.db = BreakTestCase.Database()
        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDeal =  notok

        self.secondsStart = testclock._seconds_value
        self.service.tourneyDestroyGame(None, ourTable.game)

        self.service.db = saveDb
        return tableDestroyDeferred

    def test06_tourneyFinish_nowait(self):
        return self.tourneyFinish(0, 5)

    def test07_tourneyFinish_withWait(self):
        self.service.delays['extra_wait_tourney_finish'] = "40"
        return self.tourneyFinish(40, 45)
    # ------------------------------------------------------------------------
    def test08_tourneyNewState_tourneyBreak(self):
        """test08_tourneyNewState_tourneyBreak

        This test is a bit more complicated than the previous, since when
        entering the break state, we need to check to see that broadcast
        packets were sent."""
        def ok(tourney): self.callCount += 1
        def notok(tourney): self.failIf(1)

        saveDb = self.service.db
        self.callCount = 0

        # The complexity of this test requires mock-ups of its own,
        # specifically to handle the making sure the seconds to resume are
        # computed correctly and the packets are sent to the tables as
        # needed.

        class Table(BreakTestCase.Table):
            def __init__(self):
                self.broadcastedPackets = []
                BreakTestCase.Table.__init__(self)

            def broadcast(self, packet):
                self.broadcastedPackets.append(packet)
        tables = {}
        tables[1] = Table()
        tables[2] = Table()
        class Game:
            def __init__(self, newId=0):
                self.id = newId
            def getTable(gameId):
                if gameId == 1: return tables[1]
                elif  gameId == 2: return tables[2]
                else: self.failIf(True)

        breaks_duration = 120
        class Tournament(BreakTestCase.Tournament):
            def __init__(self, remainingSeconds = None):
                self.remaining_secs = remainingSeconds
                self.breaks_duration = breaks_duration
                self.games = [ Game(1), Game(2) ]
                BreakTestCase.Tournament.__init__(self)

            def remainingBreakSeconds(self):
                return self.remaining_secs

        self.service.db = BreakTestCase.Database()
        self.service.tables = { 1 : tables[1], 2 : tables[2] }
        self.service.tourneyBreakCheck = ok

        self.service.tourneyDeal = notok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok
        self.service.tourneyDestroyGame = notok

        # When we enter the break state, we should see Begin packets
        # sent.

        # First test here: see what happens when tourney.remaining_secs()
        # is None, thus yielding a return of None from
        # tourney.remainingBreakSeconds().  In this case, we should see
        # the resume_time as the current time, plus whatever
        # tourney.breaks_duration is.

        now = pokerservice.seconds()
        self.service.tourneyNewState(Tournament(), pokertournament.TOURNAMENT_STATE_RUNNING, pokertournament.TOURNAMENT_STATE_BREAK)
        self.assertEquals(self.callCount, 1)
        for ii in [ 1, 2 ]:
            self.assertEquals(len(tables[ii].broadcastedPackets), 1)
            pp = tables[ii].broadcastedPackets[0]
            self.assertEquals(pp.game_id, ii)
            self.assertEquals(pp.type, PACKET_POKER_TABLE_TOURNEY_BREAK_BEGIN)
            self.assertTrue(abs((pp.resume_time - now) - breaks_duration) < 1.0)

        # Reset for next test below
        self.callCount = 0
        for ii in [ 1, 2 ]: tables[ii].broadcastedPackets = []

        # Second test here: see what happens when
        # tourney.remainingBreakSeconds() can return an actual integer
        # value.  This is forced by setting tourney.remaining_secs to 111
        # in __init__.  We should get a resume_time of the current time
        # plus the remaining seconds.

        now = pokerservice.seconds()
        remainingSeconds = 111
        self.service.tourneyNewState(Tournament(remainingSeconds = remainingSeconds),
                                     pokertournament.TOURNAMENT_STATE_RUNNING, pokertournament.TOURNAMENT_STATE_BREAK)
        self.assertEquals(self.callCount, 1)
        for ii in [ 1, 2 ]:
            self.assertEquals(len(tables[ii].broadcastedPackets), 1)
            pp = tables[ii].broadcastedPackets[0]
            self.assertEquals(pp.game_id, ii)
            self.assertEquals(pp.type, PACKET_POKER_TABLE_TOURNEY_BREAK_BEGIN)
            self.assertTrue(abs((pp.resume_time - now) - remainingSeconds) < 1.0)
        self.callCount = 0

        self.service.tourneyBreakCheck = notok
        self.service.db = saveDb

    # ------------------------------------------------------------------------
    def test_tourneyDeal(self):
        class Game:

            def __init__(self):
                self.id = 1

        class Tournament:
            def __init__(self):
                self.games = [ Game() ]
                self.serial = 1

        tourney = Tournament()
        table = BreakTestCase.Table()
        table.game = tourney.games[0]
        self.service.tables = { 1: table }
        self.service.tourneyDeal(tourney)
        self.failUnless(hasattr(table, 'autodeal'))

    def test_tourneyBreakWait(self):
        class Game:

            def __init__(self):
                self.id = 1
                self.running = False

            def isRunning(self):
                return self.running

        class Tournament:
            def __init__(self):
                self.games = [ Game() ]
                self.serial = 1

        tourney = Tournament()
        table = BreakTestCase.Table()
        table.game = tourney.games[0]
        self.service.tables = { 1: table }
        tourney.games[0].running = True
        self.service.tourneyBreakWait(tourney)
        self.failUnless("at the end of the hand" in table.message)
        tourney.games[0].running = False
        self.service.tourneyBreakWait(tourney)
        self.failUnless("finish their hand" in table.message)
    # ------------------------------------------------------------------------
    def test11_tourneyBreakResume(self):
        class Table(BreakTestCase.Table):
            def __init__(self):
                self.broadcastedPackets = []
                BreakTestCase.Table.__init__(self)
            def broadcast(self, packet):
                self.broadcastedPackets.append(packet)
        tables = {}
        tables[1] = Table()
        tables[2] = Table()
        #the following gives me a syntax error
        #class  Game:
        class Game:
            def __init__(self, newId=0):
                self.id = newId
            def getTable(gameId):
                if gameId == 1: return tables[1]
                elif  gameId == 2: return tables[2]
                else: self.failIf(True)
        class Tournament(BreakTestCase.Tournament):
            def __init__(self):
                self.games = [ Game(1), Game(2) ]
                BreakTestCase.Tournament.__init__(self)

        tourney = Tournament()
        self.service.tables = { 1: tables[1], 2: tables[2] }

        self.service.tourneyBreakResume(tourney)
        for ii in [ 1, 2 ]:
            self.assertEqual(tables[ii].message, "Tournament resumes")
            self.assertEqual(tables[ii].type, PacketPokerGameMessage)
            self.assertEquals(len(tables[ii].broadcastedPackets), 1)
            pp = tables[ii].broadcastedPackets[0]
            self.assertEquals(pp.game_id, ii)
            self.assertEquals(pp.type, PACKET_POKER_TABLE_TOURNEY_BREAK_DONE)

    # ------------------------------------------------------------------------
    def test_tourneyBreakCheck(self):

        class Game:

            def __init__(self):
                self.id = 1

        class Tournament:

            def __init__(self):
                self.state = pokertournament.TOURNAMENT_STATE_RUNNING
                self.remaining = 0
                self.games = [ Game() ]
                self.serial = 1

            def remainingBreakSeconds(self):
                return self.remaining

            def updateBreak(self):
                pass

        tourney = Tournament()
        table = BreakTestCase.Table()
        table.game = tourney.games[0]
        self.service.tables = { 1: table }
        self.service.tourneyBreakCheck(tourney)
        self.failIf(table.message)
        tourney.state = pokertournament.TOURNAMENT_STATE_BREAK
        self.service.tourneyBreakCheck(tourney)
        self.failUnless("less than a minute" in table.message)
        tourney.remaining = 60
        self.service.tourneyBreakCheck(tourney)
        self.failUnless("one minute" in table.message)
        tourney.remaining = 120
        self.service.tourneyBreakCheck(tourney)
        self.failUnless("2 minute" in table.message)
##############################################################################
class UpdatePlayerRakeTestCase(PokerServiceTestCaseBase):

    def test_updatePlayerRake(self):
        self.service.startService()
        self.service.db = pokerdatabase.PokerDatabase(self.settings)
        cursor = self.db.cursor(DictCursor)
        cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount, points, rake) VALUES (101, 1, 10, 10, 10)")
        self.assertEqual(True, self.service.updatePlayerRake(1, 101, 5))
        cursor.execute("SELECT * FROM user2money WHERE user_serial = 101 AND currency_serial = 1")
        row = cursor.fetchone()
        self.assertEqual(15, row['rake'])
        self.assertEqual(15, row['points'])
        cursor.close()
##############################################################################
class PokerFactoryFromPokerServiceTestCase(unittest.TestCase):
    def test01_createService(self):
        class MockServiceSmall():
            def __init__(servSelf):
                servSelf.verbose = 9
                servSelf.createAvatarCount = 0
                servSelf.destroyAvatarCount = 0
            def createAvatar(servSelf):
                servSelf.createAvatarCount += 1
            def destroyAvatar(servSelf, mockAvatar):
                servSelf.destroyAvatarCount += 1
                self.assertEquals(mockAvatar, "MOCK MY AVATAR UP")

        mockServ = MockServiceSmall()
        pokerFactory = pokerservice.PokerFactoryFromPokerService(mockServ)
        self.assertEquals(pokerFactory.service, mockServ)
        self.assertEquals(pokerFactory.verbose, mockServ.verbose)
        self.assertEquals(mockServ.createAvatarCount, 0)
        self.assertEquals(mockServ.destroyAvatarCount, 0)

        pokerFactory.createAvatar()
        self.assertEquals(mockServ.createAvatarCount, 1)
        self.assertEquals(mockServ.destroyAvatarCount, 0)

        pokerFactory.destroyAvatar("MOCK MY AVATAR UP")
        self.assertEquals(mockServ.createAvatarCount, 1)
        self.assertEquals(mockServ.destroyAvatarCount, 1)

        self.assertEquals(pokerservice.PokerFactoryFromPokerService.protocol,
                          pokerservice.PokerServerProtocol)
        # FIXME?: cover registerAdapater line???
##############################################################################
class PokerServiceCoverageTests(unittest.TestCase):
    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        self.settings.header = self.settings.doc.xpathNewContext()
    # ----------------------------------------------------------------
    def tearDown(self):
        if hasattr(self, 'service'):
            d = self.service.stopService()
            return d
    # ----------------------------------------------------------------
    def test01_statsWithHands(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'SELECT MAX(serial)' ]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                if str == 'SELECT MAX(serial)' and cursorSelf.counts[str] == 1:
                    cursorSelf.rowcount = 1
                    cursorSelf.row = (8,)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()
        self.service.avatars =  [ 'a', 'b', 'c' ]

        pack = self.service.stats("THIS ARG IS IGNORED")
        self.assertEquals(pack.players, 3)
        self.assertEquals(pack.hands, 8)
        self.assertEquals(pack.bytesin, 0)
        self.assertEquals(pack.bytesout, 0)
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test02_statsWithoutHands(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'SELECT MAX(serial)' ]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                if str == 'SELECT MAX(serial)' and cursorSelf.counts[str] == 1:
                    cursorSelf.rowcount = 0
                    cursorSelf.row = (None,)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()
        self.service.avatars =  [ 'a', 'b', 'c' ]

        pack = self.service.stats("THIS ARG IS IGNORED")
        self.assertEquals(pack.players, 3)
        self.assertEquals(pack.hands, 0)
        self.assertEquals(pack.bytesin, 0)
        self.assertEquals(pack.bytesout, 0)
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test04_createAvatar(self):
        from pokernetwork.pokeravatar import PokerAvatar
        self.service = pokerservice.PokerService(self.settings)
        self.service.avatars = []
        a = self.service.createAvatar()
        self.failUnless(isinstance(a, PokerAvatar))
        self.assertEquals(self.service.avatars, [a])
    # ----------------------------------------------------------------
    class MockAvatar:
        def __init__(maSelf):
            maSelf.connectionLostArgs = []
        def connectionLost(maSelf, val):
            maSelf.connectionLostArgs.append(val)
    # ----------------------------------------------------------------
    def test05_forceAvatarDestory_notInAnyList(self):
        self.service = pokerservice.PokerService(self.settings)
        ma = PokerServiceCoverageTests.MockAvatar()
        self.assertEquals(ma.connectionLostArgs, [])

        self.service.avatars = []
        self.service.monitors = []


        # This will cause a reactor timeout if this deferred is never
        # called back.
        testDestroyCalledDefer = defer.Deferred()
        def testDestroyCalled():
            msgs = get_messages()
            self.assertEquals(len(msgs), 1)
            self.assertEquals(msgs[0].find('*ERROR* avatar <__main__.MockAvatar instance at '), 0)
            self.failUnless(msgs[0].find(' is not in the list of known avatars') > 0)
            self.assertEquals(ma.connectionLostArgs, [ 'Disconnected' ])
            self.assertEquals(self.service.avatars, [])
            self.assertEquals(self.service.monitors, [])
            testDestroyCalledDefer.callback(True)

        clear_all_messages()
        self.service.forceAvatarDestroy(ma)
        reactor.callLater(5, testDestroyCalled)
        return testDestroyCalledDefer
    # ----------------------------------------------------------------
    def test06_forceAvatarDestory_inAvatarsListOnly(self):
        self.service = pokerservice.PokerService(self.settings)
        ma = PokerServiceCoverageTests.MockAvatar()
        self.assertEquals(ma.connectionLostArgs, [])

        self.service.avatars = [ma]
        self.service.monitors = []

        # This will cause a reactor timeout if this deferred is never
        # called back.
        testDestroyCalledDefer = defer.Deferred()
        def testDestroyCalled():
            self.assertEquals(get_messages(), [])
            self.assertEquals(ma.connectionLostArgs, [ 'Disconnected' ])
            self.assertEquals(self.service.avatars, [])
            self.assertEquals(self.service.monitors, [])
            testDestroyCalledDefer.callback(True)

        clear_all_messages()
        self.service.forceAvatarDestroy(ma)
        reactor.callLater(5, testDestroyCalled)

        return testDestroyCalledDefer
    # ----------------------------------------------------------------
    def test07_forceAvatarDestory_inMonitorsAndAvatars(self):
        self.service = pokerservice.PokerService(self.settings)
        ma = PokerServiceCoverageTests.MockAvatar()
        self.assertEquals(ma.connectionLostArgs, [])

        self.service.avatars = [ma]
        self.service.monitors = []
        pack = self.service.monitor(ma)
        self.assertEquals(pack.type, PACKET_ACK)
        self.assertEquals(self.service.monitors, [ma])

        # This will cause a reactor timeout if this deferred is never
        # called back.
        testDestroyCalledDefer = defer.Deferred()
        def testDestroyCalled():
            self.assertEquals(get_messages(), [])
            self.assertEquals(ma.connectionLostArgs, [ 'Disconnected' ])
            self.assertEquals(self.service.avatars, [])
            self.assertEquals(self.service.monitors, [])
            testDestroyCalledDefer.callback(True)

        clear_all_messages()
        self.service.forceAvatarDestroy(ma)
        reactor.callLater(5, testDestroyCalled)

        return testDestroyCalledDefer
    # ----------------------------------------------------------------
    def test08_sessionStartSucceed(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'insert into session' ]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                cursorSelf.rowcount = 1
                cursorSelf.row = (None,)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args):
                        return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()

        clear_all_messages()
        self.failUnless(self.service.sessionStart(5, '192.168.0.1'))
        self.assertEquals(get_messages(), ["sessionStart(5, 192.168.0.1): "])
        self.assertEquals(self.service.db.cursorValue.counts,
                          {'insert into session' : 1 })
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test09_sessionStartFail(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'insert into session' ]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                cursorSelf.rowcount = 0
                cursorSelf.row = (None,)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()

        clear_all_messages()
        self.failUnless(self.service.sessionStart(7, '192.168.0.2'))
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.assertEquals(msgs[0], 'sessionStart(7, 192.168.0.2): ')
        self.assertEquals(msgs[1].find("*ERROR* modified 0 rows (expected 1): insert into session ( user_serial, started, ip ) values ( 7, "), 0)
        self.failUnless(msgs[1].find(", '192.168.0.2')") > 0)

        self.assertEquals(self.service.db.cursorValue.counts,
                          {'insert into session' : 1 })
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test10_sessionEndSucceed(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'insert into session_history',
                                                  'delete from session']
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                cursorSelf.rowcount = 1
                cursorSelf.row = (None,)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()

        clear_all_messages()
        self.failUnless(self.service.sessionEnd(9))
        self.assertEquals(get_messages(), ['sessionEnd(9): '])

        self.assertEquals(self.service.db.cursorValue.counts,
                          { 'insert into session_history' : 1,
                            'delete from session' : 1 })
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test11_sessionEndInsertFailsDeleteSucceeds(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'insert into session_history',
                                                  'delete from session']
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                if sql[:len(str)] == 'insert into session_history':
                    cursorSelf.rowcount = 3
                else:
                    cursorSelf.rowcount = 1
                cursorSelf.row = (None,)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()

        clear_all_messages()
        self.failUnless(self.service.sessionEnd(9))
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.assertEquals(msgs[0], 'sessionEnd(9): ')
        self.assertEquals(msgs[1].find('*ERROR* a) modified 3 rows (expected 1): insert into session_history'), 0)
        self.assertEquals(self.service.db.cursorValue.counts,
                          { 'insert into session_history' : 1,
                            'delete from session' : 1 })
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test12_sessionEndAllSqlFails(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'insert into session_history',
                                                  'delete from session']
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                cursorSelf.rowcount = 0
                cursorSelf.row = (None,)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()

        clear_all_messages()
        self.failUnless(self.service.sessionEnd(9))
        msgs = get_messages()
        self.assertEquals(len(msgs), 3)
        self.assertEquals(msgs[0], 'sessionEnd(9): ')
        self.assertEquals(msgs[1].find('*ERROR* a) modified 0 rows (expected 1): insert into session_history'), 0)
        self.assertEquals(msgs[2].find('*ERROR* b) modified 0 rows (expected 1): delete from session'), 0)
        self.assertEquals(self.service.db.cursorValue.counts,
                          { 'insert into session_history' : 1,
                            'delete from session' : 1 })
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test13_tourneyNewState_DBFail_forceTourneyDeal(self):
        self.callCount = 0
        def ok(tourney): self.callCount += 1
        def notok(tourney): self.failIf(1)

        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'update tourneys set']
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                cursorSelf.rowcount = 8
                cursorSelf.row = (None,)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()

        clear_all_messages()

        self.service.tourneyBreakCheck = notok
        self.service.tourneyDeal = ok
        self.service.tourneyBreakWait = notok
        self.service.tourneyBreakResume = notok

        class MockTourney:
            def __init__(mtSelf):
                mtSelf.start_time = 5
                mtSelf.serial = 19
        self.service.tourneyNewState(MockTourney(),
                                     pokertournament.TOURNAMENT_STATE_BREAK_WAIT,
                                     pokertournament.TOURNAMENT_STATE_RUNNING)
        self.assertEquals(self.callCount, 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.assertEquals(msgs[0].find("tourneyNewState: update tourneys set state"), 0)
        self.assertEquals(msgs[1], "*ERROR* modified 8 rows (expected 1): update tourneys set state = 'running', start_time = 5 where serial = 19 ")

        self.assertEquals(self.service.db.cursorValue.counts,
                          {'update tourneys set': 1})
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test14_tourneyFinished_prizeNegative(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ 'UPDATE tourneys SET finish_time']

                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 1
                        found = True
                        break
                self.failUnless(found)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue
            def literal(dbSelf, val): return dbSelf.db.literal(val)
        class MockTourney:
            def prizes(mtSelf): return [-5]
            def __init__(mtSelf):
                mtSelf.serial = 15
                mtSelf.prize_min = 0
                mtSelf.prize_currency = 0
                mtSelf.currency_serial = 1
                mtSelf.buy_in = 5
                mtSelf.registered = 1
                mtSelf.winners = [9]

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()

        mockTourney = MockTourney()

        # Not worth making this test cover dbevent, other tests do
        oldDbEvent = self.service.databaseEvent
        def dbEventMock(event = None, param1 = None): pass
        self.service.databaseEvent = dbEventMock

        # Same with tourneyDeleteRoute -- we just check that it is called.
        oldTourneyDeleteRoute = self.service.tourneyDeleteRoute
        global tourneyDeleteRouteCount
        tourneyDeleteRouteCount = 0
        def mockTourneyDeleteRoute(tourney):
            global tourneyDeleteRouteCount
            tourneyDeleteRouteCount += 1
            self.assertEquals(tourney, mockTourney)
        self.service.tourneyDeleteRoute = mockTourneyDeleteRoute

        self.service.avatar_collection = PokerAvatarCollection()
        clear_all_messages()
        self.assertEquals(self.service.tourneyFinished(mockTourney), True)

        self.assertEquals(get_messages(), [])
        self.assertEquals(self.service.db.cursorValue.counts,
                          {'UPDATE tourneys SET finish_time' : 1})
        self.assertEquals(tourneyDeleteRouteCount, 1)
        self.service.db = oldDb
        self.service.databaseEvent = oldDbEvent
        self.service.tourneyDeleteRoute = oldTourneyDeleteRoute
    # ----------------------------------------------------------------
    def test15_tourneyGameFilled_updateTableFail(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ "update user2tourney set" ]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                self.failUnless(found)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue
        class MockTable:
            def __init__(mtSelf): mtSelf.updateCount = 0
            def update(mtSelf):   mtSelf.updateCount += 1

        class MockTourney:
            def prizes(mtSelf): return [-5]
            def __init__(mtSelf):
                mtSelf.serial = 15
                mtSelf.prize_min = 0
                mtSelf.buy_in = 5
                mtSelf.registered = 1
                mtSelf.winners = [9]
        class MockGame:
            class MockPlayer:
                def __init__(mpSelf): mpSelf.serial = 10
                def setUserData(mpSelf, values): pass
            def __init__(mgSelf): mgSelf.id = 22
            def playersAll(mgSelf): return [ MockGame.MockPlayer() ]
            def buyIn(mgSelf): return 100

        self.service = pokerservice.PokerService(self.settings)
        oldDb = self.service.db
        self.service.db = MockDatabase()

        oldSeatPlayer = self.service.seatPlayer
        def mySeatPlayer(x, y, z): pass
        self.service.seatPlayer = mySeatPlayer

        self.service.avatar_collection = PokerAvatarCollection()
        self.service.tables = { 22 : MockTable() }

        clear_all_messages()
        self.service.tourneyGameFilled(MockTourney(), MockGame())

        self.assertEquals(self.service.db.cursorValue.counts, {'update user2tourney set': 1})
        self.assertEquals(self.service.tables[22].updateCount, 1)

        msgs = get_messages()
        self.assertEquals(len(msgs), 3)
        self.assertEquals(msgs[0], 'tourneyGameFilled: player 10 disconnected')
        self.assertEquals(msgs[1].find('tourneyGameFilled: update user2tourney set'), 0)
        self.assertEquals(msgs[2].find('*ERROR* modified 0 rows (expected 1): update user2tourney set'), 0)

        self.service.db = oldDb
        self.service.seatPlayer = oldSeatPlayer
    # ----------------------------------------------------------------
    def test16_tourneyPlayersList_nonExistent(self):
        self.service = pokerservice.PokerService(self.settings)

        self.service.tourneys = {}

        pack = self.service.tourneyPlayersList(99)
        self.assertEquals(pack.type, PACKET_ERROR)
        self.assertEquals(pack.other_type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(pack.code, PacketPokerTourneyRegister.DOES_NOT_EXIST)
        self.assertEquals(pack.message, "Tournament 99 does not exist")
    # ----------------------------------------------------------------
    def test17_tourneyPlayersList_sucess(self):
        """Covers parts of tourneyPlayersList as well as getName()"""
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ "select name from users" ]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                if cursorSelf.counts[str] == 1:
                    cursorSelf.rowcount = 1
                    cursorSelf.row = ("joe",)
                else:
                    cursorSelf.rowcount = 0
                    cursorSelf.row = (None,)
                self.failUnless(found)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase()

        class MockTourney:
            def __init__(mtSelf): mtSelf.players = [ 5, 6, 0 ]

        self.service.tourneys = { 77: MockTourney() }

        clear_all_messages()
        pack = self.service.tourneyPlayersList(77)
        self.assertEquals(pack.players, [('joe', -1, 0),
                                         ('UNKNOWN', -1, 0), ('anonymous', -1, 0)])
        self.assertEquals(pack.type, PACKET_POKER_TOURNEY_PLAYERS_LIST)
        self.assertEquals(pack.serial, 77)
        self.assertEquals(get_messages(),
                          ['*ERROR* getName(6) expected one row got 0'])

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test18_tourneyStats_sqlFails(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ "SELECT COUNT(*) FROM tourneys",
                                                  "SELECT COUNT(*) FROM user2tourney"]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                cursorSelf.rowcount = 0
                cursorSelf.row = (None,)
                self.failUnless(found)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase()

        clear_all_messages()

        caughtIt = False
        try:
            self.service.tourneyStats()
            self.failIf(True)  # Should not be reached
        except TypeError, te:
            self.assertEquals(te.__str__(), "int() argument must be a string or a number, not 'NoneType'")
            caughtIt = True

        self.failUnless(caughtIt)
        self.assertEquals(get_messages(), [])

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test19_tourneyStats_succeed(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ "SELECT COUNT(*) FROM tourneys",
                                                  "SELECT COUNT(*) FROM user2tourney"]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                cursorSelf.rowcount = 1
                cursorSelf.row = (9,)
                self.failUnless(found)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase()

        clear_all_messages()
        self.assertEquals(self.service.tourneyStats(), (9,9))
        self.assertEquals(get_messages(), [])

        self.assertEquals(self.service.db.cursorValue.counts,
                          {'SELECT COUNT(*) FROM user2tourney': 1,
                           'SELECT COUNT(*) FROM tourneys': 1})

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test20_tourneyRegister_tourneyMissing(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockClient:
            def sendPacketVerbose(mcSelf, pack): mcSelf.errorPacket = pack
        class MockPacket:
            def __init__(mpSelf):
                mpSelf.serial = 42
                mpSelf.game_id = 91

        client = MockClient()
        self.service.avatar_collection = PokerAvatarCollection()
        self.service.avatar_collection.add(42, client)
        self.service.tourneys = { }

        clear_all_messages()

        self.failIf(self.service.tourneyRegister(MockPacket()))
        self.assertEquals(get_messages(),
                          ['*ERROR* type = ERROR(3) message = Tournament 91 does not exist, code = 1, other_type = POKER_TOURNEY_REGISTER'])
        self.failUnless(hasattr(client, "errorPacket"))
        self.assertEquals(client.errorPacket.type, PACKET_ERROR)
        self.assertEquals(client.errorPacket.code,
                          PacketPokerTourneyRegister.DOES_NOT_EXIST)
        self.assertEquals(client.errorPacket.message,
                          "Tournament 91 does not exist")
    # ----------------------------------------------------------------
    def test21_getPlayerInfo_validReturns(self):
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ "select locale,name,skin_url,skin_outfit"]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                cursorSelf.rowcount = 1
                cursorSelf.row = ('ourlocal','ourname','ourskinurl',None)
                self.failUnless(found)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase()

        pack = self.service.getPlayerInfo(5)
        self.assertEquals(pack.locale, 'ourlocal')
        self.assertEquals(pack.name, 'ourname')
        self.assertEquals(pack.url, 'ourskinurl')
        self.assertEquals(pack.outfit, 'random')

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test22_tourneyRegister_tourneyAlreadyRegistering(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockClient:
            def __init__(mcSelf): mcSelf.errorPackets = []
            def sendPacketVerbose(mcSelf, pack): mcSelf.errorPackets.append(pack)
        class MockPacket:
            def __init__(mpSelf):
                mpSelf.serial = 44
                mpSelf.game_id = 99
        class MockTourney:
            via_satellite = 0
            def isRegistered(mtSelf, serial):
                self.assertEquals(serial, 44)
                return True

        client = MockClient()
        tourney = MockTourney()
        self.service.avatar_collection = PokerAvatarCollection()
        self.service.avatar_collection.add(44, client)
        self.service.tourneys = { 99 : tourney }

        clear_all_messages()

        self.failIf(self.service.tourneyRegister(MockPacket()))
        self.failUnless(hasattr(client, "errorPackets"))
        self.assertEquals(len(client.errorPackets), 1)
        pack = client.errorPackets[0]
        self.assertEquals(pack.type, PACKET_ERROR)
        self.failUnless(pack.message.find('Player 44 already registered in tournament 99') == 0)
        self.assertEquals(pack.other_type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(pack.code,
                          PacketPokerTourneyRegister.ALREADY_REGISTERED)
        msgs = get_messages()
        self.assertEquals(len(msgs), 1)
        self.failUnless(msgs[0].find('*ERROR* type = ERROR(3) message = Player 44 already registered in tournament 99')  == 0)
        self.failUnless(msgs[0].find('other_type = POKER_TOURNEY_REGISTER') >= 0)
    # ----------------------------------------------------------------
    def test23_tourneyRegister_tourneyRefuseRegistration(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockClient:
            def __init__(mcSelf): mcSelf.errorPackets = []
            def sendPacketVerbose(mcSelf, pack): mcSelf.errorPackets.append(pack)
        class MockPacket:
            def __init__(mpSelf):
                mpSelf.serial = 29
                mpSelf.game_id = 123
        class MockTourney:
            via_satellite = 0
            def isRegistered(mtSelf, serial):
                self.assertEquals(serial, 29)
                return False
            def canRegister(mtSelf, serial):
                self.assertEquals(serial, 29)
                return False

        client = MockClient()
        tourney = MockTourney()
        self.service.avatar_collection = PokerAvatarCollection()
        self.service.avatar_collection.add(29, client)
        self.service.tourneys = { 123 : tourney }

        clear_all_messages()

        self.failIf(self.service.tourneyRegister(MockPacket()))
        self.failUnless(hasattr(client, "errorPackets"))
        self.assertEquals(len(client.errorPackets), 1)
        pack = client.errorPackets[0]
        self.assertEquals(pack.type, PACKET_ERROR)
        self.failUnless(pack.message.find('Registration refused in tournament 123') == 0)
        self.assertEquals(pack.other_type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(pack.code,
                          PacketPokerTourneyRegister.REGISTRATION_REFUSED)
        msgs = get_messages()
        self.assertEquals(len(msgs), 1)
        self.failUnless(msgs[0].find('*ERROR* type = ERROR(3) message = Registration refused in tournament 123')  == 0)

    # ----------------------------------------------------------------
    def test22_tourneyRegister_viaSatellite(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockClient:
            def __init__(mcSelf): mcSelf.errorPackets = []
            def sendPacketVerbose(mcSelf, pack): mcSelf.errorPackets.append(pack)
        class MockTourney:
            def __init__(self):
                self.via_satellite = 1

        client = MockClient()
        tourney = MockTourney()
        self.service.avatar_collection = PokerAvatarCollection()
        self.service.avatar_collection.add(44, client)
        self.service.tourneys = { 99 : tourney }

        self.failIf(self.service.tourneyRegister(PacketPokerTourneyRegister(serial = 44, game_id = 99)))
        self.assertEquals(len(client.errorPackets), 1)
        pack = client.errorPackets[0]
        self.assertEquals(pack.type, PACKET_ERROR)
        self.assertEquals(pack.other_type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(pack.code,
                          PacketPokerTourneyRegister.VIA_SATELLITE)

    # ----------------------------------------------------------------
    def test24_tourneyRegister_tourneyNotEnoughMoneyToRegister(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockClient:
            def __init__(mcSelf): mcSelf.errorPackets = []
            def sendPacketVerbose(mcSelf, pack): mcSelf.errorPackets.append(pack)
        class MockPacket:
            def __init__(mpSelf):
                mpSelf.serial = 194
                mpSelf.game_id = 526
        class MockTourney:
            via_satellite = 0
            def __init__(mtSelf):
                mtSelf.currency_serial = mtSelf.buy_in = mtSelf.rake = 10
            def isRegistered(mtSelf, serial):
                self.assertEquals(serial, 194)
                return False
            def canRegister(mtSelf, serial):
                self.assertEquals(serial, 194)
                return True
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ "UPDATE user2money SET amount = amount"]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                cursorSelf.rowcount = 0
                cursorSelf.row = (None,)
                self.failUnless(found)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase()

        client = MockClient()
        tourney = MockTourney()
        self.service.avatar_collection = PokerAvatarCollection()
        self.service.avatar_collection.add(194, client)
        self.service.tourneys = { 526 : tourney }

        clear_all_messages()

        self.failIf(self.service.tourneyRegister(MockPacket()))
        self.failUnless(hasattr(client, "errorPackets"))
        self.assertEquals(len(client.errorPackets), 1)
        pack = client.errorPackets[0]
        self.assertEquals(pack.type, PACKET_ERROR)
        self.failUnless(pack.message.find('Not enough money to enter the tournament 526') == 0)
        self.assertEquals(pack.other_type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(pack.code, PacketPokerTourneyRegister.NOT_ENOUGH_MONEY)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find('tourneyRegister: UPDATE user2money SET amount')  == 0)
        self.failUnless(msgs[1].find('*ERROR* type = ERROR(3) message = Not enough money to enter the tournament 526')  == 0)

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test25_tourneyRegister_updateMoneyWeirdness(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockClient:
            def __init__(mcSelf): mcSelf.errorPackets = []
            def sendPacketVerbose(mcSelf, pack): mcSelf.errorPackets.append(pack)
        class MockPacket:
            def __init__(mpSelf):
                mpSelf.serial = 194
                mpSelf.game_id = 526
        class MockTourney:
            via_satellite = 0
            def __init__(mtSelf):
                mtSelf.currency_serial = mtSelf.buy_in = mtSelf.rake = 10
            def isRegistered(mtSelf, serial):
                self.assertEquals(serial, 194)
                return False
            def canRegister(mtSelf, serial):
                self.assertEquals(serial, 194)
                return True
        class MockCursor:
            def __init__(cursorSelf):
                cursorSelf.rowcount = 0
                cursorSelf.counts = {}
                cursorSelf.acceptedStatements = [ "UPDATE user2money SET amount = amount"]
                cursorSelf.row = ()
                for cntType in cursorSelf.acceptedStatements:
                    cursorSelf.counts[cntType] = 0
            def close(cursorSelf): pass
            def execute(*args):
                cursorSelf = args[0]
                sql = args[1]
                found = False
                for str in cursorSelf.acceptedStatements:
                    if sql[:len(str)] == str:
                        cursorSelf.counts[str] += 1
                        cursorSelf.rowcount = 0
                        found = True
                        break
                cursorSelf.rowcount = 2
                cursorSelf.row = (None,)
                self.failUnless(found)
                return cursorSelf.rowcount
            def fetchone(cursorSelf): return cursorSelf.row
        class MockDatabase:
            def __init__(dbSelf):
                class MockInternalDatabase:
                    def literal(intDBSelf, *args): return args[0]
                dbSelf.db = MockInternalDatabase()
                dbSelf.cursorValue = MockCursor()
            def cursor(dbSelf): return dbSelf.cursorValue

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase()

        client = MockClient()
        tourney = MockTourney()
        self.service.avatar_collection = PokerAvatarCollection()
        self.service.avatar_collection.add(194, client)
        self.service.tourneys = { 526 : tourney }

        clear_all_messages()

        self.failIf(self.service.tourneyRegister(MockPacket()))
        self.failUnless(hasattr(client, "errorPackets"))
        self.assertEquals(len(client.errorPackets), 1)
        pack = client.errorPackets[0]
        self.assertEquals(pack.type, PACKET_ERROR)
        self.failUnless(pack.message.find('Server error') == 0)
        self.assertEquals(pack.other_type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(pack.code, PacketPokerTourneyRegister.SERVER_ERROR)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find('tourneyRegister: UPDATE user2money SET amount')  == 0)
        self.failUnless(msgs[1].find('*ERROR* modified 2 rows (expected 1): UPDATE user2money SET amount')  == 0)

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test26_tourneyRegister_user2tourneyFailure(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockClient:
            def __init__(mcSelf): mcSelf.errorPackets = []
            def sendPacketVerbose(mcSelf, pack): mcSelf.errorPackets.append(pack)
        class MockPacket:
            def __init__(mpSelf):
                mpSelf.serial = 423
                mpSelf.game_id = 865
        class MockTourney:
            via_satellite = 0
            def __init__(mtSelf):
                mtSelf.currency_serial = mtSelf.buy_in = mtSelf.rake = 10
            def isRegistered(mtSelf, serial):
                self.assertEquals(serial, 423)
                return False
            def canRegister(mtSelf, serial):
                self.assertEquals(serial, 423)
                return True
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if sql[:len(statement)] == "UPDATE user2money SET amount = amount":
                    cursorSelf.rowcount = 1
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self,
                                        [ "UPDATE user2money SET amount = amount",
                                       "INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES"])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        client = MockClient()
        tourney = MockTourney()
        self.service.avatar_collection = PokerAvatarCollection()
        self.service.avatar_collection.add(423, client)
        self.service.tourneys = { 865 : tourney }

        # Not worth making this test cover dbevent, other tests do.  Here,
        # we make sure it is called as expected
        oldDbEvent = self.service.databaseEvent
        def dbEventMock(event = None, param1 = None, param2 = None, param3 = None):
            self.assertEquals(event, PacketPokerMonitorEvent.REGISTER)
            self.assertEquals(param1, 423)
            self.assertEquals(param2, 10)
            self.assertEquals(param3, 20)

        self.service.databaseEvent = dbEventMock

        clear_all_messages()

        self.failIf(self.service.tourneyRegister(MockPacket()))
        self.failUnless(hasattr(client, "errorPackets"))
        self.assertEquals(len(client.errorPackets), 1)
        pack = client.errorPackets[0]
        self.assertEquals(pack.type, PACKET_ERROR)
        self.failUnless(pack.message.find('Server error') == 0)
        self.assertEquals(pack.other_type, PACKET_POKER_TOURNEY_REGISTER)
        self.assertEquals(pack.code, PacketPokerTourneyRegister.SERVER_ERROR)
        msgs = get_messages()
        self.assertEquals(len(msgs), 3)
        self.failUnless(msgs[0].find('tourneyRegister: UPDATE user2money SET amount = amount - 20 WHERE user_serial = 423') >= 0)
        self.assertEquals(msgs[1], 'tourneyRegister: INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (423, 10, 865)')
        self.assertEquals(msgs[2], '*ERROR* insert 0 rows (expected 1): INSERT INTO user2tourney (user_serial, currency_serial, tourney_serial) VALUES (423, 10, 865) ')

        self.service.db = oldDb
        self.service.databaseEvent = oldDbEvent
    # ----------------------------------------------------------------
    def test27_loadHand_noRowFound(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                pass
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["select description from hands where"])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(self.service.loadHand(5), None)
        self.assertEquals(get_messages(), ['*ERROR* loadHand(5) expected one row got 0'])
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test28_loadHand_row(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 1
                cursorSelf.row = (']',)

            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["select description from hands where"])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(self.service.loadHand(7), None)
        self.assertEquals(get_messages(), ['*ERROR* loadHand(7) eval failed for ]'])

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test29_loadHand_confirm_backslash_r_replaced(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 1
                cursorSelf.row = ("hand_serial\r+5",)

            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["select description from hands where"])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(self.service.loadHand(9), 14)
        self.assertEquals(get_messages(),[])

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test30_loadHand_confirm_working_code(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 1
                # cute trick below... eventually, this gets evaled and the
                # hand_serial, the arg we send into loadHand() is set to
                # the arg hand_serial.  So, we can test later to see if
                # its value.
                cursorSelf.row = ("hand_serial+5",)

            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["select description from hands where"])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(self.service.loadHand(3), 8)
        self.assertEquals(get_messages(), [])
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test31_getHandSerial_coverCursorWithLastrowid(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 1
                cursorSelf.row = ()
                cursorSelf.lastrowid = 9.7

            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["INSERT INTO hands"])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(self.service.getHandSerial(), 9)
        self.assertEquals(get_messages(), [])
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test32_getHandSerial_coverCursorWithInsertID(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 1
                cursorSelf.row = ()

            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["INSERT INTO hands"])
            def insert_id(cursorSelf):  return 22.8

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(self.service.getHandSerial(), 22)
        self.assertEquals(get_messages(), [])
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test33_getHandHistory_failedLoadHand(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 1
                cursorSelf.row = ("None",)

            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["select description from hands where"])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        pack = self.service.getHandHistory(723, 99)
        self.assertEquals(pack.game_id, 723)
        self.assertEquals(pack.serial, 99)
        self.assertEquals(pack.code, PacketPokerHandHistory.NOT_FOUND)
        self.assertEquals(pack.other_type, PACKET_POKER_HAND_HISTORY)
        self.assertEquals(pack.message, "Hand 723 was not found in history of player 99")

        self.assertEquals(get_messages(), [])
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test34_getHandHistory_playerProhibited(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 1
                #!         (type, level, hand_serial, hands_count, time, variant, betting_structure, player_list, dealer, serial2chips)
                cursorSelf.row = ('[ ("foo", 3, 988, 1, 100, "he", "1-2-limit", [5, 6, 7], 8, {})]',)

            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["select description from hands where"])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        pack = self.service.getHandHistory(636, 222)
        # Note this interesting fact: getHandHistory() returns the
        # hand_history given in the row from the database, not the one you
        # passed it.  Theoretically, it should not generate a different
        # one, but this test confirms that the one from the DB is used
        # if they are.
        self.assertEquals(pack.game_id, 988)
        self.assertEquals(pack.serial, 222)
        self.assertEquals(pack.code, PacketPokerHandHistory.FORBIDDEN)
        self.assertEquals(pack.other_type, PACKET_POKER_HAND_HISTORY)
        self.assertEquals(pack.message, "Player 222 did not participate in hand 988")

        self.assertEquals(get_messages(), [])
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test35_getHandHistory_succeedWithCardReplacement(self):
        from pokerengine.pokercards import PokerCards
        def mockLoseNotVisible(cardSelf): cardSelf.cards = -1
        PokerCards.loseNotVisible = mockLoseNotVisible
        saveFunc = PokerCards.loseNotVisible
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 1
                if statement == "select description from hands where":
                    # (type, level, hand_serial, hands_count, time, variant, betting_structure, player_list, dealer, serial2chips)
                    cursorSelf.row = ("""[
("foo", 3, 988, 1, 100, "he", "1-2-limit", [113, 222], 8, {}),
("round", "preflop", [], { 113 : PokerCards("AsAh"),
222 : PokerCards("KsKd") }),
("showdown", [], { 113 : PokerCards("AsAh"),
222 : PokerCards("KsKd") }),
("neither", [], { 113 : PokerCards("AsAh"),
222 : PokerCards("KsKd") }),
]""",)
                else:
                    userSerial =  int(sql[len(statement):])
                    if userSerial == 113: cursorSelf.row = ("Doyle Brunson",)
                    elif userSerial == 222: cursorSelf.row = ("Stu Unger",)
                    else: self.fail("unknown user serial %d" % userSerial)

            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["select description from hands where",
                                                         "select name from users where serial = "])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        pack = self.service.getHandHistory(696, 222)
        self.assertEquals(pack.history, "[('foo', 3, 988, 1, 100, 'he', '1-2-limit', [113, 222], 8, {}), ('round', 'preflop', [], {113: PokerCards(-1), 222: PokerCards([50])}), ('showdown', [], {113: PokerCards(-1), 222: PokerCards([50])}), ('neither', [], {113: PokerCards([51]), 222: PokerCards([50])})]")
        self.assertEquals(pack.serial2name, "{113: 'Doyle Brunson', 222: 'Stu Unger'}")
        self.assertEquals(pack.type, PACKET_POKER_HAND_HISTORY)
        self.assertEquals(pack.game_id, 988)
        self.assertEquals(pack.serial, 222)

        self.assertEquals(get_messages(), [])
        self.service.db = oldDb
        PokerCards.loseNotVisible = saveFunc
    # ----------------------------------------------------------------
    def test36_saveHand_badRowcountOnUpdate(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 5
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["update hands set "])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        pack = self.service.saveHand([
                ("foo", 3, 991, 1, 100, "he", "1-2-limit", [113, 222], 8, {})], 991)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find("saveHand: update hands set  description = ") == 0)
        self.failUnless(msgs[1].find('*ERROR* modified 5 rows (expected 1 or 0): update hands') == 0)
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test37_saveHand_coverFailureOfInsert(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                # Make it always 1, so the update succeeds and insert fails
                cursorSelf.rowcount = 1
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["update hands set ",
                                                           "insert into user2hand values "])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        pack = self.service.saveHand([
                ("foo", 3, 991, 1, 100, "he", "1-2-limit", [113, 222], 8, {})], 991)
        msgs = get_messages()
        self.assertEquals(len(msgs), 3)
        self.failUnless(msgs[0].find("saveHand: update hands set  description = ") == 0)
        self.failUnless(msgs[1].find('saveHand: insert into user2hand') == 0)
        self.failUnless(msgs[2].find('*ERROR* inserted 1 rows (expected exactly 2): insert into user2hand values') == 0)
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test38_eventTable_serialZero(self):
        class MockCursor(MockCursorBase):
            def execute(cursorSelf, *args):
                MockCursorBase.execute(cursorSelf, *args)
                self.assertEquals(args[1][0], 99)
                self.assertEquals(args[1][1], 0)
            def statementActions(cursorSelf, sql, statement):
                pass
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["REPLACE INTO route"])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        class MockGame:
            def __init__(mgSelf):
                mgSelf.id = 99
        class MockTable:
            def __init__(mtSelf):
                mtSelf.game = MockGame()
                mtSelf.tourney = None

        self.service.eventTable(MockTable())
        self.assertEquals(get_messages(), [])
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test39_statsTable(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                # Make it always 1, so the update succeeds and insert fails
                cursorSelf.rowcount = 1

                if statement == "SELECT COUNT(*) FROM pokertables":
                    cursorSelf.row = (1235,)
                elif statement == "SELECT COUNT(*) FROM user2table":
                    cursorSelf.row = (7356,)
                else:
                    self.failIf(1)
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["SELECT COUNT(*) FROM pokertables",
                                                           "SELECT COUNT(*) FROM user2table"])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(self.service.statsTables(), (7356,1235))

        self.assertEquals(get_messages(), [])
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test40_cleanupTourneys_oneFoundFromPrimarySelect(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 0
                cursorSelf.row = []
                if statement == "SELECT * FROM tourneys":
                    if cursorSelf.counts[statement] <= 1:
                        cursorSelf.row = { 'buy_in' : 100, 'currency_serial' : 168,
                                           'serial' : 732 }
                        cursorSelf.rowcount = 1
                    # Second time method does select, we just want 0 rows returned.
                elif statement == "UPDATE user2money,user2tourney SET amount = amount":
                    # row count 0 is ok, next check for proper serials in statement
                    self.failUnless(sql.find("currency_serial = 168") > 0)
                    self.failUnless(sql.find("tourney_serial = 732") > 0)
                elif statement == "DELETE FROM tourneys WHERE serial =":
                    # row count 0 is ok, check for proper serial
                    self.failUnless(sql.find("serial = 732") > 0)
                elif statement == "DELETE FROM user2tourney WHERE tourney_serial =":
                    # row count 0 is ok, check for proper serial
                    self.failUnless(sql.find("serial = 732") > 0)
                else:
                    self.failIf(1, "unknown sql statement: " + statement + " " + sql)
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["SELECT * FROM tourneys",
                                    "UPDATE user2money,user2tourney SET amount = amount",
                                    "DELETE FROM tourneys WHERE serial =",
                                    "DELETE FROM user2tourney WHERE tourney_serial ="])
        class MockDBWithDifferentCursorMethod(MockDatabase):
            def cursor(dbSelf, dummy = None):
                # Needed because cleanupTourneys() calls with argument "DictCursor"
                return MockDatabase.cursor(dbSelf)

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDBWithDifferentCursorMethod(MockCursor)

        clear_all_messages()

        self.service.cleanupTourneys()

        # Make sure the right number of SQL statements got executed; the loop should
        # have only went once
        for expectJustOneStr in [ "UPDATE user2money,user2tourney SET amount = amount",
                                  "DELETE FROM tourneys WHERE serial =",
                                  "DELETE FROM user2tourney WHERE tourney_serial =" ]:
            self.assertEquals(self.service.db.cursorValue.counts[expectJustOneStr], 1)
        self.assertEquals(self.service.db.cursorValue.counts["SELECT * FROM tourneys"], 2)

        msgs = get_messages()
        self.assertEquals(len(msgs), 5)
        self.assertEquals(msgs[0].find("cleanupTourneys: SELECT * FROM tourneys WHERE"), 0)
        self.assertEquals(msgs[1].find('cleanupTourneys: UPDATE user2money,user2tourney'), 0)
        self.assertEquals(msgs[2].find('cleanupTourneys: DELETE FROM tourneys WHERE'), 0)
        self.assertEquals(msgs[3].find('cleanupTourneys: DELETE FROM user2tourney'), 0)
        self.assertEquals(msgs[4].find("cleanupTourneys: SELECT * FROM tourneys  WHERE"), 0)

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test41_getMoney_bigRowCount(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 3
                cursorSelf.row = []
                self.failUnless(sql.find("user_serial = 7775") > 0, "user_serial wrong")
                self.failUnless(sql.find("currency_serial = 2356") > 0,
                                "currency_serial wrong")
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self,
                                        ["SELECT amount FROM user2money "])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(self.service.getMoney(7775, 2356), 0)

        self.assertEquals(self.service.db.cursorValue.counts["SELECT amount FROM user2money "], 1)
        self.assertEquals(self.service.db.cursorValue.closedCount, 1)

        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.assertEquals(msgs[0].find('SELECT amount FROM user2money'), 0)
        self.failUnless(msgs[0].find("user_serial = 7775") > 0)
        self.failUnless(msgs[0].find("currency_serial = 2356") > 0)
        self.assertEquals(msgs[1], '*ERROR* getMoney(7775) expected one row got 3')

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test42_cashQuery(self):
        class MockCashier():
            def cashQuery(cashierSelf, packet):
                cashierSelf.packet = packet
                return "Called"

        self.service = pokerservice.PokerService(self.settings)
        oldCashier = self.service.cashier

        cashier = MockCashier()
        self.service.cashier = cashier

        packet = 'Testing'
        self.assertEquals(self.service.cashQuery(packet), 'Called')
        self.assertEquals(cashier.packet, packet)

        self.service.cashier = oldCashier
    # ----------------------------------------------------------------
    def test43_cashOutCommit_commitFailure(self):
        class MockCashier():
            def cashOutCommit(cashierSelf, packet): return 8675309
        class MockPacket():
            def __init__(packetSelf): packetSelf.transaction_id = "Hi There"

        self.service = pokerservice.PokerService(self.settings)
        oldCashier = self.service.cashier

        cashier = MockCashier()
        self.service.cashier = cashier

        packet = self.service.cashOutCommit(MockPacket())
        self.assertEquals(packet.code, PacketPokerCashOutCommit.INVALID_TRANSACTION)
        self.assertEquals(packet.message, "transaction Hi There affected 8675309 rows instead of zero or one")
        self.assertEquals(packet.other_type, PACKET_POKER_CASH_OUT_COMMIT)
        self.assertEquals(packet.type, PACKET_ERROR)

        self.service.cashier = oldCashier
    # ----------------------------------------------------------------
    def test44_getPlayerInfo_serialIs0(self):
        self.service = pokerservice.PokerService(self.settings)
        packet = self.service.getPlayerInfo(0)
        self.assertEquals(packet.serial, 0)
        self.assertEquals(packet.name, "anonymous")
        self.assertEquals(packet.url, "random")
        self.assertEquals(packet.outfit, "random")
        # FIXME_PokerPlayerInfoLocale: (see also sr #2262 )
        # PokerService.getPlayerInfo() sends locale argument when creating
        # the PokerPlayerInfo() packet, but that argument is not used.
        # Should it be?  If it should be, then changes should be made to
        # pokerpackets.py to use it and the assert below should be put in.
#        self.assertEquals(packet.locale, "en_US")
    # ----------------------------------------------------------------
    def test45_getPlayerInfo_badRowCount(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 3
                cursorSelf.row = []
                self.failUnless(sql.find("serial = 235") > 0, "serial wrong")
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self,
                                      ["select locale,name,skin_url,skin_outfit from users"])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        packet = self.service.getPlayerInfo(235)
        self.assertEquals(get_messages(),
                          ['*ERROR* getPlayerInfo(235) expected one row got 3'])
        self.assertEquals(packet.serial, 235)
        self.assertEquals(packet.name, "anonymous")
        self.assertEquals(packet.url, "random")
        self.assertEquals(packet.outfit, "random")
        # FIXME_PokerPlayerInfoLocale: (see also sr #2262 )
        # PokerService.getPlayerInfo() sends locale argument when creating
        # the PokerPlayerInfo() packet, but that argument is not used.
        # Should it be?  If it should be, then changes should be made to
        # pokerpackets.py to use it and the assert below should be put in.
#        self.assertEquals(packet.locale, "en_US")

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test46_getUserInfo_badRowCount(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 3
                cursorSelf.row = []
                self.failUnless(sql.find("serial = 765") > 0, "serial wrong")
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self,
                                      ["SELECT rating,affiliate,email,name FROM users"])
        class MockDBWithDifferentCursorMethod(MockDatabase):
            def cursor(dbSelf, dummy = None):
                # Needed because getUserInfo() calls with argument "DictCursor"
                return MockDatabase.cursor(dbSelf)

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDBWithDifferentCursorMethod(MockCursor)

        clear_all_messages()

        packet = self.service.getUserInfo(765)
        self.assertEquals(get_messages(),
                          ['*ERROR* getUserInfo(765) expected one row got 3'])
        self.assertEquals(packet.serial, 765)
        self.assertEquals(packet.type, PACKET_POKER_USER_INFO)

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test47_setPesonalInfo_badRowCount(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 3
                cursorSelf.row = []
                self.failUnless(sql.find("serial = 1854") > 0, "serial wrong")
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self,
                                      ["UPDATE users_private SET "])
        class MockPlayerInfo():
            def __init__(mpSelf):
                mpSelf.__dict__ = { 'serial' : 1854,
                                    'firstname' : '', 'lastname' : '', 'addr_street' : '',
                                    'addr_street2' : '', 'addr_zip' : '',
                                    'addr_town' : '', 'addr_state' : '',
                                    'addr_country' : '', 'phone' : '',
                                    'gender' : '', 'birthdate' : '' }

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.failIf(self.service.setPersonalInfo(MockPlayerInfo()))
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.assertEquals(msgs[0].find("setPersonalInfo: UPDATE users_private SET"), 0)
        self.assertEquals(msgs[1].find("*ERROR* setPersonalInfo: modified 3 rows (expected 1 or 0): UPDATE users_private"), 0)

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test48_setAccount_badRowcountOnInsert(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 0
                cursorSelf.row = []
                if sql == "SELECT serial FROM users WHERE":
                    self.failUnless(sql.find("name = 'OMGClayAiken'") > 0, "name wrong")
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self,
                                        ["SELECT serial FROM users WHERE",
                                         "INSERT INTO users"])
        self.service = pokerservice.PokerService(self.settings)

        class MockPacket():
            def __init__(mpSelf):
                mpSelf.name = "OMGClayAiken"
                mpSelf.email = "OMGClayAiken@example.org"
                mpSelf.password = "foobalg352"
                mpSelf.affiliate = 0
                mpSelf.type = PACKET_POKER_SET_ACCOUNT

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        packet = self.service.setAccount(MockPacket())
        self.assertEquals(packet.type, PACKET_ERROR)
        self.assertEquals(packet.message, 'inserted 0 rows (expected 1)')
        self.assertEquals(packet.code, PacketPokerSetAccount.SERVER_ERROR)
        self.assertEquals(packet.other_type, PACKET_POKER_SET_ACCOUNT)

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test49_setAccount_lastrowidFailure(self):
        class MockCursor(MockCursorBase):
            def insert_id(mcSelf): return 22
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 0
                cursorSelf.row = []
                if statement == "SELECT serial FROM users WHERE name":
                    self.failUnless(sql.find("name = 'durrrr'") > 0, "name wrong")
                    cursorSelf.rowcount = 0
                    cursorSelf.row = []
                elif statement == "INSERT INTO users ":
                    cursorSelf.rowcount = 1
                    cursorSelf.row = []
                elif statement == "INSERT INTO users_private":
                    self.failUnless(sql.find("VALUES ('22')") > 0, "serial for users_private wrong")
                elif statement == "SELECT serial FROM users WHERE email":
                    self.failUnless(sql.find("email = 'durrrr@example.org'") > 0, "name wrong")
                    cursorSelf.rowcount = 0
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self,
                                        ["SELECT serial FROM users WHERE name",
                                         "SELECT serial FROM users WHERE email",
                                         "INSERT INTO users ",
                                         "INSERT INTO users_private"])
        self.service = pokerservice.PokerService(self.settings)

        class MockPacket():
            def __init__(mpSelf):
                mpSelf.name = "durrrr"
                mpSelf.email = "durrrr@example.org"
                mpSelf.password = "blash535"
                mpSelf.affiliate = 0
                mpSelf.type = PACKET_POKER_SET_ACCOUNT

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        inputPacket = MockPacket()
        def mockSetPersonalInfo(packet):
            self.assertEquals(inputPacket, packet)
            return True
        def mockGetPersonalInfo(serial):
            self.assertEquals(22, serial)
            return "IT WORKED!!!"

        saveSetPersonalInfo = self.service.setPersonalInfo
        saveGetPersonalInfo = self.service.getPersonalInfo
        self.service.setPersonalInfo = mockSetPersonalInfo
        self.service.getPersonalInfo = mockGetPersonalInfo

        self.assertEquals("IT WORKED!!!",
                          self.service.setAccount(inputPacket))

        self.assertEquals(self.service.db.cursorValue.counts["SELECT serial FROM users WHERE name"], 1)
        self.assertEquals(self.service.db.cursorValue.counts["SELECT serial FROM users WHERE email"], 1)
        self.assertEquals(self.service.db.cursorValue.counts["INSERT INTO users "], 1)
        self.assertEquals(self.service.db.cursorValue.counts["INSERT INTO users_private"], 1)

        self.service.setPersonalInfo = saveSetPersonalInfo
        self.service.getPersonalInfo = saveGetPersonalInfo

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test50_setPlayerInfo_success(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                cursorSelf.rowcount = 1
                if statement == "update users set ":
                    self.failUnless(sql.find("name = 'Pham'") > 0, "name wrong")
                    self.failUnless(sql.find("skin_url = 'http://example.org'") > 0, "url wrong")
                    self.failUnless(sql.find("skin_outfit = 'naked'") > 0, "outfit wrong")
                    self.failUnless(sql.find("serial = 2891") > 0, "serial wrong")
                    cursorSelf.rowcount = 1
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["update users set "])
        self.service = pokerservice.PokerService(self.settings)

        class MockPlayerInfo():
            def __init__(mpSelf):
                mpSelf.name = 'Pham'
                mpSelf.url = 'http://example.org'
                mpSelf.outfit = 'naked'
                mpSelf.serial = 2891

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.failUnless(self.service.setPlayerInfo(MockPlayerInfo()))
        self.assertEquals(self.service.db.cursorValue.counts["update users set "], 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 1)
        self.failUnless(msgs[0].find('setPlayerInfo: update users set') == 0)

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test51_setPlayerInfo_badUpdateValue(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "update users set ":
                    self.failUnless(sql.find("name = 'Pham'") > 0, "name wrong")
                    self.failUnless(sql.find("skin_url = 'http://example.org'") > 0, "url wrong")
                    self.failUnless(sql.find("skin_outfit = 'naked'") > 0, "outfit wrong")
                    self.failUnless(sql.find("serial = 2891") > 0, "serial wrong")
                    cursorSelf.rowcount = 3
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["update users set "])
        self.service = pokerservice.PokerService(self.settings)

        class MockPlayerInfo():
            def __init__(mpSelf):
                mpSelf.name = 'Pham'
                mpSelf.url = 'http://example.org'
                mpSelf.outfit = 'naked'
                mpSelf.serial = 2891

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.failIf(self.service.setPlayerInfo(MockPlayerInfo()), "setPlayerInfo should fail here")
        self.assertEquals(self.service.db.cursorValue.counts["update users set "], 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find('setPlayerInfo: update users set') == 0)
        self.failUnless(msgs[1].find('*ERROR* setPlayerInfo: modified 3 rows (expected 1 or 0): update users set') == 0)

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test52_getPlayerImage_serial0(self):
        clear_all_messages()
        self.service = pokerservice.PokerService(self.settings)
        pack = self.service.getPlayerImage(0)
        self.assertEquals(pack.type, PACKET_POKER_PLAYER_IMAGE)
        self.assertEquals(pack.serial, 0)
        self.assertEquals(pack.image, '')
        self.assertEquals(pack.image_type, 'image/png')

        self.assertEquals(get_messages(), [])
    # ----------------------------------------------------------------
    def test53_getPlayerImage_selectRowCount3(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "select skin_image,":
                    self.failUnless(sql.find("serial = 825") > 0, "serial wrong")
                    cursorSelf.rowcount = 3
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["select skin_image,"])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        pack = self.service.getPlayerImage(825)
        self.assertEquals(pack.type, PACKET_POKER_PLAYER_IMAGE)
        self.assertEquals(pack.serial, 825)
        self.assertEquals(pack.image, '')
        self.assertEquals(pack.image_type, 'image/png')

        self.assertEquals(self.service.db.cursorValue.counts["select skin_image,"], 1)
        self.assertEquals(get_messages(), ['*ERROR* getPlayerImage(825) expected one row got 3'])

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test54_setPlayerImage_rowcountwrong(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "update users set":
                    self.failUnless(sql.find("serial = 277") > 0, "serial wrong")
                    self.failUnless(sql.find("skin_image = 'Picture'") > 0, "skin_image wrong")
                    self.failUnless(sql.find("skin_image_type = 'image/png'") > 0, "image_type wrong")
                    cursorSelf.rowcount = 3
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["update users set"])
        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        class MockPlayerImage():
            def __init__(mpSelf):
                mpSelf.image = 'Picture'
                mpSelf.image_type = 'image/png'
                mpSelf.serial = 277

        clear_all_messages()

        self.failIf(self.service.setPlayerImage(MockPlayerImage()), 'with row returning 3, this should fail')

        self.assertEquals(self.service.db.cursorValue.counts["update users set"], 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find("setPlayerInfo: update users set") == 0,
                        'first message should be verbose output')
        self.failUnless(msgs[1].find("*ERROR* setPlayerImage: modified 3 rows (expected 1 or 0): update users set") == 0,
                        'second message should be error about rows')


        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test55_buyInPlayer_currencySerialNone(self):
        self.service = pokerservice.PokerService(self.settings)
        self.assertEquals(self.service.buyInPlayer(775, 232, None, 2330), 2330)
    # ----------------------------------------------------------------
    def test56_buyInPlayer_updateRowcountBad(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "UPDATE user2money,user2table SET ":
                    self.failUnless(sql.find("user2table.money = user2table.money + 4") > 0, "money wrong")
                    self.failUnless(sql.find("user2money.amount = user2money.amount - 4") > 0, "amount wrong")
                    self.failUnless(sql.find("user2money.user_serial = 634") > 0, "serial wrong")
                    self.failUnless(sql.find("user2money.currency_serial = 222") > 0, "currency_serial wrong")
                    self.failUnless(sql.find("user2table.user_serial = 634") > 0, "serial wrong")
                    self.failUnless(sql.find("user2table.table_serial = 123") > 0, "table serial wrong")
                    cursorSelf.rowcount = 1
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["UPDATE user2money,user2table SET "])

        self.service = pokerservice.PokerService(self.settings)

        def mockGetMoney(serial, currency_serial): return 4
        def mockDBEvent(event, param1, param2, param3):
            self.assertEquals(param3, 4)
            self.assertEquals(param2, 123)
            self.assertEquals(param1, 634)
            self.assertEquals(event, PacketPokerMonitorEvent.BUY_IN)

        saveGetMoney = self.service.getMoney
        saveDBEvent = self.service.databaseEvent
        self.service.getMoney = mockGetMoney
        self.service.databaseEvent = mockDBEvent

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(4, self.service.buyInPlayer(634, 123, 222, 500))

        self.assertEquals(self.service.db.cursorValue.counts["UPDATE user2money,user2table SET "], 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find("buyInPlayer: UPDATE user2money,user2table SET ") == 0,
                        'first message should be verbose output')
        self.failUnless(msgs[1].find("*ERROR* modified 1 rows (expected 0 or 2): UPDATE user2money,user2table SET ") == 0,
                        'second message should be error about rows')

        self.service.getMoney = saveGetMoney
        self.service.databaseEvent = saveDBEvent
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test57_seatPlayer_insertRowcountBad(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "INSERT INTO user2table":
                    self.failUnless(sql.find("654, 936, 100") > 0, "values wrong")
                    cursorSelf.rowcount = 0
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["INSERT INTO user2table"])

        self.service = pokerservice.PokerService(self.settings)

        def mockDBEvent(event, param1, param2):
            self.assertEquals(param2, 936)
            self.assertEquals(param1, 654)
            self.assertEquals(event, PacketPokerMonitorEvent.SEAT)

        saveDBEvent = self.service.databaseEvent
        self.service.databaseEvent = mockDBEvent
        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.failIf(self.service.seatPlayer(654, 936, 100), "bad rows should cause error")

        self.assertEquals(self.service.db.cursorValue.counts["INSERT INTO user2table"], 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find("seatPlayer: INSERT INTO user2table") == 0,
                        'first message should be verbose output')
        self.failUnless(msgs[1].find("*ERROR* inserted 0 rows (expected 1): INSERT INTO user2table") == 0,
                        'second message should be error about rows')

        self.service.databaseEvent = saveDBEvent
        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test58_movePlayer_selectRowCount0WithMoneyNone(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "SELECT money FROM user2table":
                    self.failUnless(sql.find("user_serial = 9356") > 0, "user_serial wrong")
                    self.failUnless(sql.find("table_serial = 1249") > 0, "from_table_serial wrong")
                    cursorSelf.rowcount = 0
                    cursorSelf.row = (None,)
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["SELECT money FROM user2table"])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(None, self.service.movePlayer(9356, 1249, 6752))
        self.assertEquals(self.service.db.cursorValue.counts["SELECT money FROM user2table"], 1)
        self.assertEquals(get_messages(), ["movePlayer(9356) expected one row got 0"])

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test59_movePlayer_selectRowCount1WithMoneyPositiveUpdateRowCount3(self):
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                self.failUnless(sql.find("user_serial = 8356") > 0, "user_serial wrong")
                if statement == "SELECT money FROM user2table":
                    self.failUnless(sql.find("table_serial = 2249") > 0, "from_table_serial wrong")
                    cursorSelf.rowcount = 1
                    cursorSelf.row = (6000,)
                if statement == "UPDATE user2table":
                    self.failUnless(sql.find("table_serial = 2249") > 0, "from_table_serial wrong")
                    self.failUnless(sql.find("SET table_serial = 6752") > 0, "to_table_serial wrong")
                    cursorSelf.rowcount = 3
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, ["SELECT money FROM user2table",
                                                           "UPDATE user2table"])

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.assertEquals(-1, self.service.movePlayer(8356, 2249, 6752))
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.assertEquals(self.service.db.cursorValue.counts["SELECT money FROM user2table"], 1)
        self.failUnless(msgs[0].find("movePlayer: UPDATE user2table") == 0, "first message wrong")
        self.failUnless(msgs[1].find("*ERROR* modified 3 rows (expected 1): UPDATE user2table") == 0,
                        "second message wrong")

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test60_leavePlayer_updateRowCountTooHigh(self):
        validStatements = ["UPDATE user2money,user2table,pokertables",
                           'DELETE from user2table']
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == 'DELETE from user2table':
                    pass
                elif statement == "UPDATE user2money,user2table,pokertables":
                    self.failUnless(sql.find("tables.serial = 6543") > 0, "table_serial wrong")
                    self.failUnless(sql.find("table_serial = 6543") > 0, "table_serial wrong")
                    self.failUnless(sql.find("user_serial = 236") > 0, "user_serial wrong")
                    cursorSelf.rowcount = 12
                    cursorSelf.row = []
                elif statement == "UPDATE user2table":
                    self.failUnless(sql.find("table_serial = 2249") > 0, "from_table_serial wrong")
                    self.failUnless(sql.find("SET table_serial = 6752") > 0, "to_table_serial wrong")
                    cursorSelf.rowcount = 3
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, validStatements)

        self.service = pokerservice.PokerService(self.settings)

        def mockDBEvent(event, param1, param2):
            self.assertEquals(param2, 6543)
            self.assertEquals(param1, 236)
            self.assertEquals(event, PacketPokerMonitorEvent.LEAVE)

        saveDBEvent = self.service.databaseEvent
        self.service.databaseEvent = mockDBEvent

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.failIf(self.service.leavePlayer(236, 6543, 8999))
        for statement in validStatements:
            self.assertEquals(self.service.db.cursorValue.counts[statement], 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 4)
        self.failUnless(msgs[0].find('leavePlayer UPDATE user2money,user2table,pokertables') == 0)
        self.failUnless(msgs[1].find('*ERROR* modified 12 rows (expected 0 or 1): UPDATE user2money,user2table,pokertables') == 0)
        self.failUnless(msgs[2].find('leavePlayer DELETE from user2table') == 0)
        self.failUnless(msgs[3].find('*ERROR* modified 0 rows (expected 1): DELETE from user2table') == 0)

        self.service.db = oldDb
        self.service.databaseEvent = saveDBEvent
    # ----------------------------------------------------------------
    def test61_updatePlayerRake_amountAsZero(self):
        self.service = pokerservice.PokerService(self.settings)
        clear_all_messages()
        self.failUnless(self.service.updatePlayerRake(7355, 1026, 0))
        self.assertEquals(get_messages(), [])
    # ----------------------------------------------------------------
    def test62_updatePlayerRake_updateReturns0Rows(self):
        validStatements = ["UPDATE user2money SET"]
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "UPDATE user2money SET":
                    self.failUnless(sql.find("rake + 77") > 0, "amount value wrong")
                    self.failUnless(sql.find("points + 77") > 0, "amount value wrong")
                    self.failUnless(sql.find("user_serial = 742") > 0, "user_serial wrong")
                    self.failUnless(sql.find("currency_serial = 852") > 0, "currency_serial wrong")
                    cursorSelf.rowcount = 0
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, validStatements)

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.failIf(self.service.updatePlayerRake(852, 742, 77))
        for statement in validStatements:
            self.assertEquals(self.service.db.cursorValue.counts[statement], 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find('updatePlayerRake: UPDATE user2money SET') == 0,
                        "Missing expected string in: " + msgs[0])
        self.failUnless(msgs[1].find('*ERROR* modified 0 rows (expected 1): UPDATE user2money SET') == 0,
                        "Missing expected string in: " +  msgs[1])

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test63_updatePlayerMoney_amountAsZero(self):
        self.service = pokerservice.PokerService(self.settings)
        clear_all_messages()
        self.failUnless(self.service.updatePlayerMoney(7355, 1026, 0))
        self.assertEquals(get_messages(), [])
    # ----------------------------------------------------------------
    def test64_updatePlayerMoney_updateReturns0Rows(self):
        validStatements = ["UPDATE user2table SET"]
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "UPDATE user2table SET":
                    self.failUnless(sql.find("money + 77") > 0, "amount value wrong")
                    self.failUnless(sql.find("bet - 77") > 0, "amount value wrong")
                    self.failUnless(sql.find("user_serial = 742") > 0, "user_serial wrong")
                    self.failUnless(sql.find("table_serial = 852") > 0, "currency_serial wrong")
                    cursorSelf.rowcount = 0
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, validStatements)

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.failIf(self.service.updatePlayerMoney(742, 852, 77))
        for statement in validStatements:
            self.assertEquals(self.service.db.cursorValue.counts[statement], 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find('updatePlayerMoney: UPDATE user2table SET') == 0,
                        "Missing expected string in: " + msgs[0])
        self.failUnless(msgs[1].find('*ERROR* modified 0 rows (expected 1): UPDATE user2table SET') == 0,
                        "Missing expected string in: " +  msgs[1])

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test64_updatePlayerMoney_updateReturns0Rows(self):
        validStatements = ["UPDATE user2table SET"]
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "UPDATE user2table SET":
                    self.failUnless(sql.find("money + 77") > 0, "amount value wrong")
                    self.failUnless(sql.find("bet - 77") > 0, "amount value wrong")
                    self.failUnless(sql.find("user_serial = 742") > 0, "user_serial wrong")
                    self.failUnless(sql.find("table_serial = 852") > 0, "currency_serial wrong")
                    cursorSelf.rowcount = 0
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, validStatements)

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.failIf(self.service.updatePlayerMoney(742, 852, 77))
        for statement in validStatements:
            self.assertEquals(self.service.db.cursorValue.counts[statement], 1)
        msgs = get_messages()
        self.assertEquals(len(msgs), 2)
        self.failUnless(msgs[0].find('updatePlayerMoney: UPDATE user2table SET') == 0,
                        "Missing expected string in: " + msgs[0])
        self.failUnless(msgs[1].find('*ERROR* modified 0 rows (expected 1): UPDATE user2table SET') == 0,
                        "Missing expected string in: " +  msgs[1])

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test65_createTable_insertFailsAndLasRowNotThere(self):
        validStatements = ["INSERT pokertables", 'REPLACE INTO route']
        class MockCursor(MockCursorBase):
            def insert_id(mcBase): return 1567
            def statementActions(cursorSelf, sql, statement):
                if statement == "INSERT pokertables":
                    cursorSelf.rowcount = 0
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, validStatements)


        self.service = pokerservice.PokerService(self.settings)
        self.service.dirs = ['%s/../conf' % SCRIPT_DIR]

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.service.tables = {}
        table = self.service.createTable("bobby", { 'seats' : 7, 'currency_serial' : 2663,
                                                    'name': "This", 'variant' : 'omaha',
                                                    'betting_structure' : "2-4-limit" })
        self.assertEquals(self.service.tables[1567], table)
        self.assertEquals(table.owner, 'bobby')
        self.assertEquals(table.game.name, "This")
        self.assertEquals(table.game.variant, "omaha")
        self.assertEquals(table.game.max_players, 7)
        self.assertEquals(table.currency_serial, 2663)

        for statement in validStatements:
            self.assertEquals(self.service.db.cursorValue.counts[statement], 1)
        msgs = get_messages()
        self.failUnless(len(msgs) >= 3, "There should be at least three output messages")
        self.failUnless(search_output('createTable: INSERT pokertables'))
        self.failUnless(search_output('*ERROR* inserted 0 rows (expected 1): INSERT pokertables'))
        self.failUnless(search_output('table created : This'))

        self.service.db = oldDb
    # ----------------------------------------------------------------
        # NOTE: these test below (65a) can be used to replace
        # the above test 65 above if sr #2273 is ever closed.

#     def test65a_createTable_insertFailsProperly(self):
#         validStatements = ["INSERT pokertables"]
#         class MockCursor(MockCursorBase):
#             def insert_id(mcBase): return 1567
#             def statementActions(cursorSelf, sql, statement):
#                 if statement == "INSERT pokertables":
#                     cursorSelf.rowcount = 0
#                     cursorSelf.row = []
#             def __init__(cursorSelf):
#                 MockCursorBase.__init__(cursorSelf, self, validStatements)


#         self.service = pokerservice.PokerService(self.settings)
#         self.service.dirs = ['%s/../conf' % SCRIPT_DIR]

#         oldDb = self.service.db
#         self.service.db = MockDatabase(MockCursor)

#         clear_all_messages()

#         self.service.tables = {}
#         table = self.service.createTable("bobby", { 'seats' : 7, 'currency_serial' : 2663,
#                                                     'name': "This", 'variant' : 'omaha',
#                                                     'betting_structure' : "2-4-limit" })
#         self.failIf(self.service.tables.has_key(1567), "Table Should not have been created, INSERT 0 rows!")
#         self.assertEquals(table, None)

#         for statement in validStatements:
#             self.assertEquals(self.service.db.cursorValue.counts[statement], 1)
#         msgs = get_messages()
#         self.failUnless(len(msgs) >= 2, "There should be at least two output messages")
#         self.failUnless(search_output('createTable: INSERT pokertables'))
#         self.failUnless(search_output('*ERROR* inserted 0 rows (expected 1): INSERT pokertables'))

#         self.service.db = oldDb
    # ----------------------------------------------------------------
    def test65b_createTable_insertSucceedsWithLargerThan1ReturnedWithLastRowThere(self):
        validStatements = ["INSERT pokertables", 'REPLACE INTO route']
        class MockCursor(MockCursorBase):
            def insert_id(mcBase): return 1567
            def statementActions(cursorSelf, sql, statement):
                if statement == "INSERT pokertables":
                    cursorSelf.rowcount = 3
                    cursorSelf.row = []
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, validStatements)


        self.service = pokerservice.PokerService(self.settings)
        self.service.dirs = ['%s/../conf' % SCRIPT_DIR]

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        clear_all_messages()

        self.service.tables = {}
        table = self.service.createTable("bobby", { 'seats' : 7, 'currency_serial' : 2663,
                                                    'name': "This", 'variant' : 'omaha',
                                                    'betting_structure' : "2-4-limit" })
        self.assertEquals(self.service.tables[1567], table)
        self.assertEquals(table.owner, 'bobby')
        self.assertEquals(table.game.name, "This")
        self.assertEquals(table.game.variant, "omaha")
        self.assertEquals(table.game.max_players, 7)
        self.assertEquals(table.currency_serial, 2663)

        for statement in validStatements:
            self.assertEquals(self.service.db.cursorValue.counts[statement], 1)
        msgs = get_messages()
        self.failUnless(len(msgs) >= 3, "There should be at least three output messages")
        self.failUnless(search_output('createTable: INSERT pokertables'))
        self.failUnless(search_output('*ERROR* inserted 3 rows (expected 1): INSERT pokertables'))
        self.failUnless(search_output('table created : This'))

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test66_deleteTable_deleteRowsNot1(self):
        validStatements = ["delete from  pokertables"]
        class MockCursor(MockCursorBase):
            def statementActions(cursorSelf, sql, statement):
                if statement == "delete from  pokertables":
                    cursorSelf.rowcount = 3
                    cursorSelf.row = []
                    self.failUnless(sql.find("serial = 7775") > 0, "serial value wrong")
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, validStatements)

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        class MockGame():
            def __init__(mgSelf):
                mgSelf.id = 7775
                mgSelf.name =  "Mocky"
        game = MockGame()
        self.service.tables = {7775: game}
        class MockTable():
            def __init__(mtSelf): mtSelf.game = game

        clear_all_messages()

        table = self.service.deleteTable(MockTable())

        self.assertEquals(self.service.tables, {})

        for statement in validStatements:
            self.assertEquals(self.service.db.cursorValue.counts[statement], 1)

        msgs = get_messages()
        self.failUnless(len(msgs) == 3, "Expected excatly three messages")
        self.assertEquals(msgs[0], 'table Mocky/7775 removed from server')
        self.failUnless(msgs[1].find('deleteTable: delete from  pokertables') == 0)
        self.failUnless(msgs[2].find('*ERROR* deleted 3 rows (expected 1): delete from  pokertables') == 0)

        self.service.db = oldDb
    # ----------------------------------------------------------------
    def test67_broadcast(self):
        """test67_broadcast
        Full Coverage for the PokerService broadcast method"""
        class MockPacket(): pass
        packet = MockPacket()

        class MockAvatar():
            def __init__(maSelf, desc):
                maSelf.name = desc
                maSelf.packets = []
            def __str__(maSelf): return maSelf.name
            def setProtocol(maSelf, val): maSelf.protocol = val
            def sendPacketVerbose(maSelf, packet): maSelf.packets.append(packet)

        self.service = pokerservice.PokerService(self.settings)

        avatarList = []
        avatarList.append(MockAvatar("Without protocol"))
        avatarList.append(MockAvatar("Protocol is None"))
        avatarList[1].setProtocol(None)
        avatarList.append(MockAvatar("Protocol is False"))
        avatarList[2].setProtocol(False)
        avatarList.append(MockAvatar("Protocol is True"))
        avatarList[3].setProtocol(True)

        self.service.avatars = avatarList

        clear_all_messages()
        self.service.broadcast(packet)
        msgs = get_messages()

        for ii in [ 0, 1, 2]: self.assertEquals(avatarList[ii].packets, [])
        self.assertEquals(avatarList[3].packets, [packet])

        self.failUnless(len(msgs) == 3, "Expected exactly three messages")
        for (ii, value) in [ (0, "Without protocol"), (1, "Protocol is None"),
                             (2, "Protocol is False")]:
            self.assertEquals(msgs[ii], "broadcast: avatar %s excluded" % value)
    # ----------------------------------------------------------------
    def test68_messageCheck(self):
        validStatements = ["SELECT serial,message FROM messages",
                           "UPDATE messages SET"]
        class MockCursor(MockCursorBase):
            def fetchall(mcSelf): return mcSelf.rows
            def statementActions(cursorSelf, sql, statement):
                if statement == "SELECT serial,message FROM messages":
                    cursorSelf.rowcount = 2
                    cursorSelf.rows = [ (7325, "Greeting 1"), (22235, "Goodbye") ]
                elif statement == "UPDATE messages SET":
                    if cursorSelf.counts["UPDATE messages SET"] == 1:
                        self.failUnless(sql.find('serial = 7325') > 0, "first serial in update wrong")
                    else:
                        self.failUnless(sql.find('serial = 22235') > 0, "second serial in update wrong")
                    cursorSelf.rowcount = 0
                    cursorSelf.rows = [ ]
            def __init__(cursorSelf):
                MockCursorBase.__init__(cursorSelf, self, validStatements)
        class MockAvatar():
            def __init__(maSelf, desc):
                maSelf.name = desc
                maSelf.packets = []
                maSelf.protocol = True
            def sendPacketVerbose(maSelf, packet): maSelf.packets.append(packet)

        self.service = pokerservice.PokerService(self.settings)

        oldDb = self.service.db
        self.service.db = MockDatabase(MockCursor)

        self.service.avatars = [ MockAvatar("Joe") ]

        # Set up Deffered to be sure callback worked.  We should get a
        # reactor/deferred error on the test if the timer works wrong.
        deferredMessageCheck = defer.Deferred()
        def testThatMessageCheckTimerWorked():
            self.assertEquals(get_messages(), [])
            deferredMessageCheck.callback(True)
            self.service.db = oldDb

        # Set up fake message Check for callback.
        self.service.realMessageCheck = self.service.messageCheck
        self.service.messageCheck = testThatMessageCheckTimerWorked

        clear_all_messages()
        self.service.delays['messages'] = 3

        self.service.realMessageCheck()

        self.assertEquals(self.service.db.cursorValue.counts["SELECT serial,message FROM messages"], 1)
        self.assertEquals(self.service.db.cursorValue.counts["UPDATE messages SET"], 2)
        self.assertEquals(len(self.service.avatars[0].packets), 2)
        self.assertEquals(self.service.avatars[0].packets[0].string, "Greeting 1")
        self.assertEquals(self.service.avatars[0].packets[1].string, "Goodbye")

        self.assertEquals(get_messages(), [])

        clear_all_messages()
        return deferredMessageCheck
##############################################################################
class SSLContextFactoryCoverage(unittest.TestCase):
    # ----------------------------------------------------------------
    def test01_initNoHeader(self):
        class MockSettings():
            def headerGet(msSelf, path): return ""
        scf = pokerservice.SSLContextFactory(MockSettings())
        self.assertEquals(scf.pem_file, None)
    # ----------------------------------------------------------------
    def test02_initNoneExist(self):
        class MockSettings():
            def headerGet(msSelf, path): return "/this/goes/nowhere /and/this/does/not/either"
        scf = pokerservice.SSLContextFactory(MockSettings())
        self.assertEquals(scf.pem_file, None)
    # ----------------------------------------------------------------
    def test03_oneGoodFile(self):
        tmpdir = tempfile.mkdtemp()
        filename = os.path.join(tmpdir, "poker.pem")
        f = open(filename, "w")
        f.close()
        class MockSettings():
            def headerGet(msSelf, path): return tmpdir
        scf = pokerservice.SSLContextFactory(MockSettings())
        self.assertEquals(scf.pem_file, filename)

        shutil.rmtree(tmpdir)
    # ----------------------------------------------------------------
    def test04_secondFileFavored(self):
        tmpdir1 = tempfile.mkdtemp()
        filename1 = os.path.join(tmpdir1, "poker.pem")
        f = open(filename1, "w")
        f.close()
        tmpdir2 = tempfile.mkdtemp()
        filename2 = os.path.join(tmpdir2, "poker.pem")
        f = open(filename2, "w")
        f.close()
        class MockSettings():
            def headerGet(msSelf, path): return tmpdir1 + " " + tmpdir2
        scf = pokerservice.SSLContextFactory(MockSettings())
        self.assertEquals(scf.pem_file, filename2)

        shutil.rmtree(tmpdir1)
        shutil.rmtree(tmpdir2)
    # ----------------------------------------------------------------
    def test05_getContext(self):
        from OpenSSL import SSL
        tmpdir = tempfile.mkdtemp()
        filename = os.path.join(tmpdir, "poker.pem")
        f = open(filename, "w")
        f.close()

        class MockSettings():
            def headerGet(msSelf, path): return tmpdir

        scf = pokerservice.SSLContextFactory(MockSettings())
        self.assertEquals(scf.pem_file, filename)

        class MockContext():
            def __init__(mcSelf, val):
                self.assertEquals(SSL.SSLv23_METHOD, val)
                mcSelf.testerData = "Stuff"
            def use_certificate_file(mcSelf, file):
                self.assertEquals(scf.pem_file, file)
            def use_privatekey_file(mcSelf, file):
                self.assertEquals(scf.pem_file, file)

        saveContext = SSL.Context
        SSL.Context = MockContext

        context = scf.getContext()
        self.assertEquals(context.testerData, "Stuff")

        SSL.Context = saveContext
        shutil.rmtree(tmpdir)
##############################################################################
from pokernetwork.pokerservice import PokerTree, PokerSOAP, PokerREST, PokerXMLRPC
class MockRequestBase():
    def __init__(mrSelf):
        mrSelf.method = "GET"
class PokerTreeCoverageTestCase(unittest.TestCase):
    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        self.settings.header = self.settings.doc.xpathNewContext()
    # ----------------------------------------------------------------
    def tearDown(self):
        if hasattr(self, 'service'):
            d = self.service.stopService()
            return d
    # ----------------------------------------------------------------
    def test01_init(self):
        self.service = pokerservice.PokerService(self.settings)
        pt = pokerservice.PokerTree(self.service)
        self.assertEquals(pt.service, self.service)
        for (child, cl) in [ ("RPC2", PokerXMLRPC), ("SOAP", PokerSOAP) ]:
            self.failUnless(pt.children.has_key(child), "Missing child of PokerTree: " + child)
            self.failUnless(isinstance(pt.children[child], cl))
            self.assertEquals(pt.getChildWithDefault(child, MockRequestBase()).service, self.service)
    # ----------------------------------------------------------------
    def test02_initNoSoap(self):
        self.service = pokerservice.PokerService(self.settings)
        class MockPokerSOAP():
            def __init__(mpsSelf, service):
                self.assertEquals(self.service, service)
                raise Exception("Force SOAP unavailable")
        savePokerSoap = pokerservice.PokerSOAP
        pokerservice.PokerSOAP = MockPokerSOAP

        pt = pokerservice.PokerTree(self.service)

        for (childStr, cl) in [ ("RPC2", PokerXMLRPC) ]:
            self.failUnless(pt.children.has_key(childStr), "Missing child of PokerTree: " + childStr)
            self.failUnless(isinstance(pt.children[childStr], cl))
            self.assertEquals(pt.getChildWithDefault(childStr, MockRequestBase()).service, self.service)

        self.failIf(pt.children.has_key("SOAP"), "SOAP should be disabled")
        child = pt.getChildWithDefault('SOAP', MockRequestBase())
        self.assertEquals(child.code, 404)
        self.assertEquals(child.brief, 'No Such Resource')

        pokerservice.PokerSOAP = savePokerSoap
    # ----------------------------------------------------------------
    def test03_render(self):
        self.service = pokerservice.PokerService(self.settings)
        pt = pokerservice.PokerTree(self.service)
        self.assertEquals(pt.render(MockRequestBase()), "Use /RPC2 or /SOAP")
##############################################################################
from pokernetwork.pokersite import PokerImageUpload, PokerAvatarResource, PokerResource
class PokerRestTreeCoverageTestCase(unittest.TestCase):
    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        self.settings.header = self.settings.doc.xpathNewContext()
    # ----------------------------------------------------------------
    def tearDown(self):
        if hasattr(self, 'service'):
            d = self.service.stopService()
            return d
    # ----------------------------------------------------------------
    def test01_init(self):
        self.service = pokerservice.PokerService(self.settings)
        prt = pokerservice.PokerRestTree(self.service)
        self.assertEquals(prt.service, self.service)
        self.assertEquals(prt.verbose, self.service.verbose)
        for (child, cl) in [ ("POKER_REST", PokerResource), ("UPLOAD", PokerImageUpload),
                             ("AVATAR", PokerAvatarResource) ]:
            self.failUnless(prt.children.has_key(child), "Missing child of PokerTree: " + child)
            self.failUnless(isinstance(prt.children[child], cl))
            self.assertEquals(prt.getChildWithDefault(child, MockRequestBase()).service, self.service)
    # ----------------------------------------------------------------
    def test02_render(self):
        self.service = pokerservice.PokerService(self.settings)
        prt = pokerservice.PokerRestTree(self.service)
        self.assertEquals(prt.render(MockRequestBase()), "Use /POKER_REST or /UPLOAD or /AVATAR or /TOURNEY_START")
##############################################################################
# The following Mockups are used for PokerXML and its subclasses.

class MockAvatarForPokerXML():
    def __init__(self, val):
        self.name = val
        self.packetList = []
        self.packetsQueuedCount = 0
    def handlePacket(self, packet):
        self.packetList.append(packet)
        return [ PacketPing() ]
    def queuePackets(self):
        self.packetsQueuedCount += 1

class MockSessionForPokerXML():
    pass

# To use MockRequestForPokerXML, you should expect to test the contents of
# the following variables after running your test function:
#    service.avatar
#    service.createAvatarCount
#    service.oldAvatars
class MockServiceForPokerXML():
    def __init__(self, avatar = None):
        self.verbose = 6
        if avatar:
            self.avatar = avatar
        else:
            self.avatar = None
        self.createAvatarCount = 0
        self.oldAvatars = []
        self.destroyedAvatars = []

    def createAvatar(self):
        if hasattr(self, 'avatar') and self.avatar:
            self.oldAvatars.append(self.avatar)
        self.avatar = MockAvatarForPokerXML("MOCK_CREATE_AVATAR_%d" % self.createAvatarCount)
        self.createAvatarCount += 1
        return self.avatar

    def destroyAvatar(self, avatar):
        self.destroyedAvatars.append(avatar)

# To use MockRequestForPokerXML, you should expect to test the contents of
# the following variables after running your test function:
#    request.headerData
class MockRequestForPokerXML():
    def __init__(self, content):
        self.content = content
        self.headerData = {}

    def setHeader(self, header, value):
        if not self.headerData.has_key(header):
            self.headerData[header] = []
        self.headerData[header].append(value)

class MockContentForPokerXML():
    def __init__(self, data):
        self.data = data
    def read(self):
        return self.data
    def seek(self, start, finish):
        pass

class PokerXMLCoverageTestCase(unittest.TestCase):
    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()
        self.settings = pokernetworkconfig.Config([])
        self.settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        self.settings.header = self.settings.doc.xpathNewContext()
    # ----------------------------------------------------------------
    def tearDown(self):
        if hasattr(self, 'service'):
            d = self.service.stopService()
            return d
    # ----------------------------------------------------------------
    def test01_getRequestCookie_hasInstanceVariable(self):
        class MockRequestWithCookie(MockRequestBase):
            def __init__(mrSelf):
                mrSelf.cookies = [ 'thisone', 'notthisone' ]

        self.assertEquals(pokerservice._getRequestCookie(MockRequestWithCookie()),
                          'thisone')
    # ----------------------------------------------------------------
    def test02_getRequestCookie_callsGetCookie(self):
        class MockRequestWithCookie(MockRequestBase):
            def __init__(mrSelf, val):
                mrSelf.cookies = None
                mrSelf.sitepath = val
            def getCookie(mrSelf, stuff):
                self.assertEquals(stuff, "TWISTED_SESSION_one_two_three")
                return "called_getcookie"

        caughtIt = False
        try:
            self.assertEquals(pokerservice._getRequestCookie(MockRequestWithCookie("notalist")),
                              'thisone')
            self.failIf(True, "We should have caught a TypeError")
        except TypeError, te:
            self.assertEquals(te.__str__(), 'can only concatenate list (not "str") to list')
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught a TypeError!")

        self.assertEquals(pokerservice._getRequestCookie(MockRequestWithCookie(['one', 'two', 'three'])),
                           "called_getcookie")
    # ----------------------------------------------------------------
    def test03_init(self):
        self.service = pokerservice.PokerService(self.settings)
        px = pokerservice.PokerXML(self.service)
        self.assertEquals(px.service, self.service)
        self.assertEquals(px.verbose, self.service.verbose)
        self.assertNotEquals(pokerservice.PokerXML.encoding, "")
        self.assertNotEquals(pokerservice.PokerXML.encoding, None)
    # ----------------------------------------------------------------
    def test04_render(self):
        service = MockServiceForPokerXML()
        pxml = pokerservice.PokerXML(service)
        request = MockRequestForPokerXML(MockContentForPokerXML("hello"))

        clear_all_messages()

        caughtIt = False
        try:
            pxml.render(request)
            self.failIf(True, "We should have caught a NotImplementedError")
        except NotImplementedError:
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught a NotImplementedError!")

        self.assertEquals(request.headerData,
                          {'Content-type': ['text/xml; charset="ISO-8859-1"']})
        self.failUnless(search_output('render hello'), "render hello should occur in output!")
    # ----------------------------------------------------------------
    def test04a_maps2result(self):
        service = MockServiceForPokerXML()
        pxml = pokerservice.PokerXML(service)
        request = MockRequestForPokerXML(MockContentForPokerXML("hello"))

        caughtIt = False
        try:
            pxml.maps2result(request, {})
            self.failIf(True, "We should have caught a NotImplementedError")
        except NotImplementedError:
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught a NotImplementedError!")
    # ----------------------------------------------------------------
    def test05_render_noEncoding(self):
        service = MockServiceForPokerXML()
        pxml = pokerservice.PokerXML(service)
        request = MockRequestForPokerXML(MockContentForPokerXML("hello"))

        clear_all_messages()

        caughtIt = False
        pxml.encoding = None
        try:
            pxml.render(request)
            self.failIf(True, "We should have caught a NotImplementedError")
        except NotImplementedError:
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught a NotImplementedError!")

        self.assertEquals(request.headerData, {'Content-type': ['text/xml']})

        self.assertEquals(get_messages(), ['render hello'])
    # ----------------------------------------------------------------
    def test06_errorFunction(self):
        service = MockServiceForPokerXML()
        pxml = pokerservice.PokerXML(service)

        clear_all_messages()
        pxml.error("Test an error")
        self.assertEquals(get_messages(), ['*ERROR* Test an error'])
##############################################################################
class PokerXMLRPCCoverageTestCase(unittest.TestCase):
    # ----------------------------------------------------------------
    def test01_render_dummyXMLCall(self):
        service = MockServiceForPokerXML()
        pxmlrpc = pokerservice.PokerXMLRPC(service)
        request = MockRequestForPokerXML(MockContentForPokerXML("""<?xml version="1.0"?>
<methodCall>
<methodName>examples.Nothing</methodName>
<params>
<param>  <value><i4>41</i4></value>  </param>
</params></methodCall>"""))

        clear_all_messages()
        self.assertEquals(pxmlrpc.render(request), """<?xml version='1.0'?>
<methodResponse>
<params>
<param>
<value><array><data>
</data></array></value>
</param>
</params>
</methodResponse>
""")
        self.assertEquals(len(service.destroyedAvatars), 1)
        self.assertEquals(service.destroyedAvatars[0].name, "MOCK_CREATE_AVATAR_0")
        self.assertEquals(service.destroyedAvatars[0], service.avatar)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)

        self.assertEquals(len(request.headerData.keys()), 2)
        self.assertEquals(request.headerData['Content-length'],  ['138'])
        self.assertEquals(request.headerData['Content-type'], ['text/xml; charset="ISO-8859-1"'])
        msgs = get_messages()
        self.failUnless(len(msgs) >= 2, "Missing Message Output")
        self.failUnless(search_output('render '), "Missing render output")
        self.failUnless(search_output('result_string '), "Missing result_string output")
    # ----------------------------------------------------------------
##############################################################################
# Mock Ups for PokerREST

# Variables to check after tests for MockRequestForPokerREST
#   expireCount, notifyFunctions
#   (you should call each notifyFunction and make sure it DTRT

class MockRequestForPokerREST(MockRequestForPokerXML):
    def __init__(mrSelf, content):
        mrSelf.args = {}
        mrSelf.cookieRequests = []
        MockRequestForPokerXML.__init__(mrSelf, content)
    def getCookie(mrSelf, stuff):
        mrSelf.cookieRequests.append(stuff)
        return "DUMMY_COOKIE_%d" % len(mrSelf.cookieRequests)

# Variables to check after tests for MockSessionForPokerREST:
#   expireCount, notifyFunctions
#   (you should call each notifyFunction and make sure it DTRT
class MockSessionForPokerREST(MockSessionForPokerXML):
    def __init__(msSelf):
        msSelf.expireCount = 0
        msSelf.notifyFunctions = []
    def expire(msSelf): msSelf.expireCount += 1
    def notifyOnExpire(msSelf, fun):
        msSelf.notifyFunctions.append(fun)

class MockRequestForRESTWithSession(MockRequestForPokerREST):
    def getSession(mrSelf):
        if not hasattr(mrSelf, 'session') or not mrSelf.session:
            mrSelf.session = MockSessionForPokerREST()
        return mrSelf.session

class PokerRESTCoverageTestCase(unittest.TestCase):
    # ----------------------------------------------------------------
    def test01_render_dummyRESTCall(self):
        service = MockServiceForPokerXML()
        prest = pokerservice.PokerREST(service)
        request = MockRequestForPokerREST(MockContentForPokerXML("""
{"type" : "41"}
"""))

        clear_all_messages()
        val = prest.render(request)
        self.assertEquals(val, """[{"message": "Invalid type name 41", "code": 0, "type": "PacketError", "other_type": 3}]""")

        self.assertEquals(request.cookieRequests, [])
        self.assertEquals(len(service.destroyedAvatars), 1)
        self.assertEquals(service.destroyedAvatars[0].name, "MOCK_CREATE_AVATAR_0")
        self.assertEquals(service.destroyedAvatars[0], service.avatar)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)

        self.assertEquals(len(request.headerData.keys()), 2)
        self.assertEquals(request.headerData['Content-length'],  ['88'])
        self.assertEquals(request.headerData['Content-type'], ['text/xml; charset="ISO-8859-1"'])
        msgs = get_messages()
        self.failUnless(len(msgs) >= 2, "Missing Message Output")
        self.failUnless(search_output('render '), "Missing render output")
        self.failUnless(search_output('result_string '), "Missing result_string output")
    # ----------------------------------------------------------------
    def test02_render_withNewSession_withjsonp(self):
        class MockServiceWithoutAvatar(MockServiceForPokerXML):
            def __init__(self, avatar = None):
                MockServiceForPokerXML.__init__(self, avatar)
                if hasattr(self, "avatar") and not avatar:
                    del self.avatar

        service = MockServiceWithoutAvatar()
        prest = pokerservice.PokerREST(service)
        request = MockRequestForRESTWithSession(MockContentForPokerXML("""
{"type" : "41"}
"""))
        request.args = { 'session' : ['new'], 'name' : ['joe'], 'jsonp' : ["JSON_PREFIX"],
                         'packet' : ["""{ "type" : "PacketPing" }"""] }

        clear_all_messages()
        val = prest.render(request)
        self.assertEquals(val, """JSON_PREFIX([{"type": "PacketPing"}])""")

        self.assertEquals(request.session.expireCount, 0)
        self.assertEquals(len(request.session.notifyFunctions), 1)
        self.failUnless(hasattr(request.session, 'avatar'))

        self.assertEquals("""JSON_PREFIX([{"type": "PacketPing"}])""", val)
        self.assertEquals(len(service.destroyedAvatars), 0)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)

        self.assertEquals(len(service.avatar.packetList), 1)
        self.assertEquals(service.avatar.packetList[0].type, PACKET_PING)
        self.assertEquals(service.avatar.packetsQueuedCount, 1)
        self.assertEquals(service.avatar.name, 'MOCK_CREATE_AVATAR_0')

        self.assertEquals(request.cookieRequests, ['TWISTED_SESSION_joe'])
        self.assertEquals(request.cookies, [])
        self.assertEquals(request.sitepath, ['joe'])

        self.assertEquals(len(request.headerData.keys()), 2)
        self.assertEquals(request.headerData['Content-length'],  ['37'])
        self.assertEquals(request.headerData['Content-type'], ['text/xml; charset="ISO-8859-1"'])
        msgs = get_messages()
        self.failUnless(len(msgs) >= 2, "Missing Message Output")
        self.failUnless(search_output('render '), "Missing render output")
        self.failUnless(search_output('result_string JSON_PREFIX'), "Missing result_string output")

        # Now call the notifyFunction and see if does what is expected:
        request.session.notifyFunctions[0]()

        self.assertEquals(len(service.destroyedAvatars), 1)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)
        self.failIf(hasattr(request.session, 'avatar'))
    # ----------------------------------------------------------------
    def test03_render_withSessionYes_HandleMultiplePackets(self):
        class MockAvatarWithMultipleHandle(MockAvatarForPokerXML):
            def handlePacket(self, packet):
                MockAvatarForPokerXML.handlePacket(self, packet)
                return [PacketSerial(serial = 12), PacketPing()]

        class MockServiceWithMultipleHandleAvatar(MockServiceForPokerXML):
            def __init__(self, avatar = None):
                MockServiceForPokerXML.__init__(self, avatar)
                if hasattr(self, "avatar") and not avatar:
                    del self.avatar

            def createAvatar(self):
                if hasattr(self, 'avatar') and self.avatar:
                    self.oldAvatars.append(self.avatar)
                self.avatar = MockAvatarWithMultipleHandle("MOCK_CREATE_AVATAR_%d" % self.createAvatarCount)
                self.createAvatarCount += 1
                return self.avatar

        service = MockServiceWithMultipleHandleAvatar()
        prest = pokerservice.PokerREST(service)
        request = MockRequestForRESTWithSession(MockContentForPokerXML("""
{"type" : "41"}
"""))
        request.args = { 'session' : ['yes'], 'name' : ['joe'], 'jsonp' : ["JSON_PREFIX"],
                         'packet' : ["""{ "type" : "PacketPing" }"""] }
        request.cookies = None

        clear_all_messages()
        val = prest.render(request)

        self.assertEquals(request.session.expireCount, 0)
        self.assertEquals(len(request.session.notifyFunctions), 1)
        self.failUnless(hasattr(request.session, 'avatar'))

        self.assertEquals('JSON_PREFIX([{"type": "PacketSerial", "serial": 12, "cookie": "DUMMY_COOKIE_2"}, {"type": "PacketPing"}])', val)
        self.assertEquals(len(service.destroyedAvatars), 0)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)

        self.assertEquals(len(service.avatar.packetList), 1)
        self.assertEquals(service.avatar.packetList[0].type, PACKET_PING)
        self.assertEquals(service.avatar.packetsQueuedCount, 1)
        self.assertEquals(service.avatar.name, 'MOCK_CREATE_AVATAR_0')

        self.assertEquals(request.cookieRequests, ['TWISTED_SESSION_joe', 'TWISTED_SESSION_joe'])
        self.assertEquals(request.cookies, None)
        self.assertEquals(request.sitepath, ['joe'])

        self.assertEquals(len(request.headerData.keys()), 2)
        self.assertEquals(request.headerData['Content-length'],  ['105'])
        self.assertEquals(request.headerData['Content-type'], ['text/xml; charset="ISO-8859-1"'])
        msgs = get_messages()
        self.failUnless(len(msgs) >= 3, "Missing Message Output")
        self.failUnless(search_output('receive session cookie DUMMY_COOKIE_1'),
                         'Missing receive session cookie')
        self.failUnless(search_output('send session cookie DUMMY_COOKIE_2'),
                         'Missing send session cookie')
        self.failUnless(search_output('render '), "Missing render output")
        self.failUnless(search_output('result_string JSON_PREFIX'), "Missing result_string output")

        # Now call the notifyFunction and see if does what is expected:
        request.session.notifyFunctions[0]()

        self.assertEquals(len(service.destroyedAvatars), 1)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)
        self.failIf(hasattr(request.session, 'avatar'))
    # ----------------------------------------------------------------
    def test04_render_withSessionYes_logout(self):
        class MockAvatarLogout(MockAvatarForPokerXML):
            def handlePacket(self, packet):
                MockAvatarForPokerXML.handlePacket(self, packet)
                return [PacketLogout()]

        class MockServiceLogout(MockServiceForPokerXML):
            def __init__(self, avatar = None):
                MockServiceForPokerXML.__init__(self, avatar)
                if hasattr(self, "avatar") and not avatar:
                    del self.avatar

            def createAvatar(self):
                if hasattr(self, 'avatar') and self.avatar:
                    self.oldAvatars.append(self.avatar)
                self.avatar = MockAvatarLogout("MOCK_CREATE_AVATAR_%d" % self.createAvatarCount)
                self.createAvatarCount += 1
                return self.avatar

        service = MockServiceLogout()
        prest = pokerservice.PokerREST(service)
        request = MockRequestForRESTWithSession(MockContentForPokerXML("""
{"type" : "41"}
"""))
        request.args = { 'session' : ['yes'], 'name' : ['joe'], 'jsonp' : ["JSON_PREFIX"],
                         'packet' : ["""{ "type" : "PacketLogout" }"""] }
        request.cookies = None

        clear_all_messages()
        val = prest.render(request)
        self.assertEquals(val, """JSON_PREFIX([{"type": "PacketLogout"}])""")

        self.assertEquals(request.session.expireCount, 1)
        self.assertEquals(len(request.session.notifyFunctions), 1)
        self.failUnless(hasattr(request.session, 'avatar'))

        self.assertEquals(len(service.destroyedAvatars), 0)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)

        self.assertEquals(len(service.avatar.packetList), 1)
        self.assertEquals(service.avatar.packetList[0].type, PACKET_LOGOUT)
        self.assertEquals(service.avatar.packetsQueuedCount, 0)
        self.assertEquals(service.avatar.name, 'MOCK_CREATE_AVATAR_0')

        self.assertEquals(request.cookieRequests, ['TWISTED_SESSION_joe'])
        self.assertEquals(request.cookies, None)
        self.assertEquals(request.sitepath, ['joe'])

        self.assertEquals(len(request.headerData.keys()), 2)
        self.assertEquals(request.headerData['Content-length'],  ['39'])
        self.assertEquals(request.headerData['Content-type'], ['text/xml; charset="ISO-8859-1"'])
        msgs = get_messages()
        self.failUnless(len(msgs) >= 3, "Missing Message Output")
        self.failUnless(search_output('receive session cookie DUMMY_COOKIE_1'),
                         'Missing receive session cookie')
        self.failUnless(search_output('render '), "Missing render output")
        self.failUnless(search_output('result_string JSON_PREFIX'), "Missing result_string output")

        # Now call the notifyFunction and see if does what is expected:
        request.session.notifyFunctions[0]()

        self.assertEquals(len(service.destroyedAvatars), 1)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)
        self.failIf(hasattr(request.session, 'avatar'))
    # ----------------------------------------------------------------
    def test05_render_withSessionYes_Deferred(self):
        resultDeferred = defer.Deferred()
        class MockAvatarDeferred(MockAvatarForPokerXML):
            def handlePacket(self, packet):
                MockAvatarForPokerXML.handlePacket(self, packet)
                return [resultDeferred]

        class MockServiceDeferredAvatar(MockServiceForPokerXML):
            def __init__(self, avatar = None):
                MockServiceForPokerXML.__init__(self, avatar)
                if hasattr(self, "avatar") and not avatar:
                    del self.avatar

            def createAvatar(self):
                if hasattr(self, 'avatar') and self.avatar:
                    self.oldAvatars.append(self.avatar)
                self.avatar = MockAvatarDeferred("MOCK_CREATE_AVATAR_%d" % self.createAvatarCount)
                self.createAvatarCount += 1
                return self.avatar

        class MockRequestRESTForCallback(MockRequestForRESTWithSession):
            def __init__(mrSelf, data):
                MockRequestForRESTWithSession.__init__(mrSelf, data)
                mrSelf.finishCount = 0
                mrSelf.writtenData = ""
            def finish(mrSelf):
                mrSelf.finishCount += 1
            def write(mrSelf, data):
                mrSelf.writtenData += data

        service = MockServiceDeferredAvatar()
        prest = pokerservice.PokerREST(service)
        request = MockRequestRESTForCallback(MockContentForPokerXML("""
{"type" : "41"}
"""))
        request.args = { 'session' : ['yes'], 'name' : ['joe'], 'jsonp' : ["JSON_PREFIX"],
                         'packet' : ["""{ "type" : "PacketPing" }"""] }
        request.cookies = None

        clear_all_messages()
        val = prest.render(request)
        self.assertEquals(val, twisted.web.server.NOT_DONE_YET)

        self.assertEquals(request.session.expireCount, 0)
        self.assertEquals(len(request.session.notifyFunctions), 1)
        self.failUnless(hasattr(request.session, 'avatar'))

        self.assertEquals(len(service.destroyedAvatars), 0)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)

        self.assertEquals(len(service.avatar.packetList), 1)
        self.assertEquals(service.avatar.packetList[0].type, PACKET_PING)
        self.assertEquals(service.avatar.packetsQueuedCount, 0)
        self.assertEquals(service.avatar.name, 'MOCK_CREATE_AVATAR_0')

        self.assertEquals(request.cookieRequests, ['TWISTED_SESSION_joe'])
        self.assertEquals(request.cookies, None)
        self.assertEquals(request.sitepath, ['joe'])

        msgs = get_messages()
        self.failUnless(len(msgs) >= 2, "Missing Message Output")
        self.failUnless(search_output('receive session cookie DUMMY_COOKIE_1'),
                         'Missing receive session cookie')
        self.failUnless(search_output('render '), "Missing render output")

        # Now call the notifyFunction and see if does what is expected:
        request.session.notifyFunctions[0]()

        self.assertEquals(len(service.destroyedAvatars), 1)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)
        self.failIf(hasattr(request.session, 'avatar'))

        # Finally, let's make sure our deferred does the right thing,
        # first testing to verify it has not been rendered, and then
        # calling back and making sure it was rendered

        self.assertEquals(len(request.headerData.keys()), 1)
        self.failIf(request.headerData.has_key('Content-length'))
        self.assertEquals(request.headerData['Content-type'], ['text/xml; charset="ISO-8859-1"'])
        self.assertEquals(request.writtenData, "")
        self.assertEquals(request.finishCount, 0)

        resultDeferred.callback(PacketLogout())

        self.assertEquals(len(request.headerData.keys()), 2)
        self.assertEquals(request.headerData['Content-length'],  ['39'])
        self.assertEquals(request.headerData['Content-type'], ['text/xml; charset="ISO-8859-1"'])
        self.assertEquals(request.writtenData, 'JSON_PREFIX([{"type": "PacketLogout"}])')
        self.assertEquals(request.finishCount, 1)
    # ----------------------------------------------------------------
    def test06_render_clearSessions(self):
        service = MockServiceForPokerXML()
        prest = pokerservice.PokerREST(service)
        request = MockRequestForRESTWithSession(MockContentForPokerXML("""
{"type" : "PacketPing"}
"""))
        request.args = { 'session' : ['clear'] }

        clear_all_messages()
        val = prest.render(request)
        self.assertEquals(val, '[{"type": "PacketPing"}]')

        self.assertEquals(request.cookieRequests, [])
        self.assertEquals(len(service.destroyedAvatars), 1)
        self.assertEquals(service.destroyedAvatars[0].name, "MOCK_CREATE_AVATAR_0")
        self.assertEquals(service.destroyedAvatars[0], service.avatar)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)

        self.assertEquals(len(request.headerData.keys()), 2)
        self.assertEquals(request.headerData['Content-length'],  ['24'])
        self.assertEquals(request.headerData['Content-type'], ['text/xml; charset="ISO-8859-1"'])
        msgs = get_messages()
        self.failUnless(len(msgs) >= 2, "Missing Message Output")
        self.failUnless(search_output('render '), "Missing render output")
        self.failUnless(search_output('result_string '), "Missing result_string output")
    # ----------------------------------------------------------------
##############################################################################
class PokerSOAPCoverageTestCase(unittest.TestCase):
    # ----------------------------------------------------------------
    def test01_render_dummySOAPCall(self):
        service = MockServiceForPokerXML()
        psoap = pokerservice.PokerSOAP(service)
        request = MockRequestForPokerXML(MockContentForPokerXML("""<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<soap:Body soap:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
<SomeMethod>
<Result>
<Packet>
   <type>PacketPing</type>
</Packet>
</Result>
</SomeMethod>
</soap:Body>
</soap:Envelope>"""))

        clear_all_messages()
        val = psoap.render(request)
        self.assertEquals(val, """<?xml version="1.0" encoding="ISO-8859-1"?>
<SOAP-ENV:Envelope
  SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
  xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/"
  xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance"
  xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
>
<SOAP-ENV:Body>
<returnPacket SOAP-ENC:root="1">
<Result SOAP-ENC:arrayType="ns1:SOAPStruct[0]" xsi:type="SOAP-ENC:Array" xmlns:ns1="http://soapinterop.org/xsd">
</Result>
</returnPacket>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
""")
        self.assertEquals(len(service.destroyedAvatars), 1)
        self.assertEquals(service.destroyedAvatars[0].name, "MOCK_CREATE_AVATAR_0")
        self.assertEquals(service.destroyedAvatars[0], service.avatar)
        self.assertEquals(service.oldAvatars, [])
        self.assertEquals(service.createAvatarCount, 1)

        self.assertEquals(len(request.headerData.keys()), 2)
        self.assertEquals(request.headerData['Content-length'],  ['538'])
        self.assertEquals(request.headerData['Content-type'], ['text/xml; charset="ISO-8859-1"'])
        msgs = get_messages()
        self.failUnless(len(msgs) >= 2, "Missing Message Output")
        self.failUnless(search_output("args = [{'Packet': {'type': 'PacketPing'}}]"),
                        'Missing args')
        self.failUnless(search_output('render '), "Missing render output")
        self.failUnless(search_output('result_string '), "Missing result_string output")
    # ----------------------------------------------------------------
##############################################################################
class TourneySelectInfoTestCase(unittest.TestCase):

    def test01_not_found(self):
        xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <listen tcp="19480" />

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <tourney_select_info>UNLIKELY</tourney_select_info>
  <path>%s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % SCRIPT_DIR
        try:
            self.service = pokerservice.PokerService(xml)
            self.service.setupTourneySelectInfo()
            caught = False
        except exceptions.IOError:
            caught = True
        self.assertEqual(True, caught)

    def test02_no_init(self):
        xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <listen tcp="19480" />

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <path>%(script_dir)s/../conf</path>
  <tourney_select_info>%(script_dir)s/testfilter.py</tourney_select_info>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}
        try:
            self.service = pokerservice.PokerService(xml)
            self.service.setupTourneySelectInfo()
            caught = False
        except exceptions.AttributeError:
            caught = True
        self.assertEqual(True, caught)

    def test03_no_handle(self):
        xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <listen tcp="19480" />

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <path>%(script_dir)s/../conf</path>
  <tourney_select_info>%(script_dir)s/testtourney_select_info_no_call.py</tourney_select_info>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}
        try:
            self.service = pokerservice.PokerService(xml)
            self.service.setupTourneySelectInfo()
            caught = False
        except exceptions.AttributeError:
            caught = True
        self.assertEqual(True, caught)

    def test04_ok(self):
        xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <listen tcp="19480" />

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <tourney_select_info settings="%(script_dir)s/testsettings.xml">%(script_dir)s/testtourney_select_info.py</tourney_select_info>
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}
        self.service = pokerservice.PokerService(xml)
        self.service.setupTourneySelectInfo()
        self.assertEqual(PACKET_POKER_TOURNEY_INFO, self.service.tourneySelectInfo('packet', 'tourneys').type)
        self.assertEqual('tourneys', self.service.tourney_select_info.tourneys)
        self.assertEqual('packet', self.service.tourney_select_info.packet)
        self.assertTrue(self.service.tourney_select_info.settings.path.find('testsettings.xml'))

    def test05_non_specified(self):
        xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <listen tcp="19480" />

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <path>%s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % SCRIPT_DIR
        self.service = pokerservice.PokerService(xml)
        self.service.setupTourneySelectInfo()
        self.assertEqual(None, self.service.tourneySelectInfo('packet', 'tourneys'))
##############################################################################
class LadderTestCase(PokerServiceTestCaseBase):

    def createRank(self):
        self.db.db.query("CREATE TABLE rank ( " +
                          "  user_serial INT UNSIGNED NOT NULL," +
                          "  currency_serial INT UNSIGNED NOT NULL," +
                          "  amount BIGINT NOT NULL," +
                          "  rank INT UNSIGNED NOT NULL," +
                          "  percentile TINYINT UNSIGNED DEFAULT 0 NOT NULL )")

    def test01_setupLadder(self):
        self.createRank()
        self.service.startService()
        self.assertEqual(True, self.service.setupLadder())
        self.db.db.query("DROP TABLE rank")
        self.assertEqual(False, self.service.setupLadder())
        self.assertEqual(False, self.service.has_ladder)

    def test02_getLadder(self):
        self.createRank()
        self.service.startService()
        self.assertEqual(True, self.service.setupLadder())
        packet = self.service.getLadder(0, 0, 0)
        self.assertEqual(PACKET_POKER_ERROR, packet.type)
        self.db.db.query("INSERT INTO rank VALUES (1, 2, 3, 4, 5)")
        packet = self.service.getLadder(None, 2, 1)
        self.assertEqual(PACKET_POKER_PLAYER_STATS, packet.type)
        self.assertEqual(0, packet.game_id)
        game_id = 10
        packet = self.service.getLadder(game_id, 2, 1)
        self.assertEqual(game_id, packet.game_id)

# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test07_"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerServiceTestCase))
    suite.addTest(loader.loadClass(RefillTestCase))
    suite.addTest(loader.loadClass(TimerTestCase))
    suite.addTest(loader.loadClass(BreakTestCase))
    suite.addTest(loader.loadClass(TourneyFinishedTestCase))
    suite.addTest(loader.loadClass(TourneyUnregisterTestCase))
    suite.addTest(loader.loadClass(TourneyMovePlayerTestCase))
    suite.addTest(loader.loadClass(TourneyCancelTestCase))
    suite.addTest(loader.loadClass(TourneySatelliteTestCase))
    suite.addTest(loader.loadClass(TourneyManagerTestCase))
    suite.addTest(loader.loadClass(TourneyCreateTestCase))
    suite.addTest(loader.loadClass(ShutdownCheckTestCase))
    suite.addTest(loader.loadClass(ListHandsTestCase))
    suite.addTest(loader.loadClass(SetAccountTestCase))
    suite.addTest(loader.loadClass(UpdatePlayerRakeTestCase))
    suite.addTest(loader.loadClass(MonitorTestCase))
    suite.addTest(loader.loadClass(ListTablesSearchTablesTestCases))
    suite.addTest(loader.loadClass(GetTableBestByCriteriaTestCase))
    suite.addTest(loader.loadClass(TourneySelectTestCase))
    suite.addTest(loader.loadClass(PlayerPlacesTestCase))
    suite.addTest(loader.loadClass(CleanUpTestCase))
    suite.addTest(loader.loadClass(ResthostTestCase))
    suite.addTest(loader.loadClass(PokerFactoryFromPokerServiceTestCase))
    suite.addTest(loader.loadClass(PokerServiceCoverageTests))
    suite.addTest(loader.loadClass(SSLContextFactoryCoverage))
    suite.addTest(loader.loadClass(PokerTreeCoverageTestCase))
    suite.addTest(loader.loadClass(PokerRestTreeCoverageTestCase))
    suite.addTest(loader.loadClass(PokerXMLCoverageTestCase))
    suite.addTest(loader.loadClass(PokerXMLRPCCoverageTestCase))
    suite.addTest(loader.loadClass(PokerRESTCoverageTestCase))
    suite.addTest(loader.loadClass(PokerSOAPCoverageTestCase))
    suite.addTest(loader.loadClass(TourneySelectInfoTestCase))
    suite.addTest(loader.loadClass(TourneyNotifyTestCase))
    suite.addTest(loader.loadClass(LadderTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#       reporter.TextReporter,
#	tracebackFormat='verbose',
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokerservice.py tests/test-pokerservice-load.py ) ; ( cd ../tests ; make VERBOSE_T=-1 COVERAGE_FILES='../pokernetwork/pokerservice.py' TESTS='coverage-reset test-pokerservice.py test-pokerservice-load.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokersite
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2009 Johan Euphrosine <proppy@aminche.com>
# Copyright (C) 2008 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys, os
sys.path.insert(0, "./..")
sys.path.insert(0, "..")

import libxml2
import base64
import cgi

from twisted.trial import unittest, runner, reporter
from twisted.internet import defer
from twisted.python import failure
import twisted.internet.base
twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from tests import testclock

from pokernetwork import pokermemcache
from pokernetwork import pokersite
from pokernetwork import pokernetworkconfig
from pokernetwork import pokeravatar
from pokernetwork.pokertable import PokerAvatarCollection
from pokernetwork.pokerpackets import *

class PokerServiceMockup:

      def __init__(self):
            self.verbose = 6
            self.avatar_collection = PokerAvatarCollection()
            self.dirs = []

      def getPlayerInfo(self, serial):
            packet = PacketPokerPlayerInfo(serial = serial)
            packet.locale = 'en_US.UTF-8'
            return packet

      def locale2translationFunc(self, locale, codeset = ""):
            return None
      
      def createAvatar(self):
            return pokeravatar.PokerAvatar(self)

      def destroyAvatar(self, avatar):
            pass

      def getPlayerPlaces(self, serial):
            return PacketPokerPlayerPlaces(serial = serial)

      def tourneyNotifyStart(self, tourney_serial):
            self.tourney_serial = tourney_serial
      
      player_image = None
      def setPlayerImage(self, player_image):
            self.player_image = player_image      

      player_serial = None
      def getPlayerImage(self, serial):
            self.player_serial = serial
            return self.player_image

      def getClientQueuedPacketMax(self):
            return 2000

      def packet2resthost(self, packet):
            return (None, None)

class HelpersTestCase(unittest.TestCase):

      def test_fromutf8(self):
            self.assertEqual(['b', {'a': 'c'}, ('d',), 1], pokersite.fromutf8([u'b', {u'a': u'c'}, (u'd',), 1]))
            self.assertEqual([u'b', {u'a': u'c'}, (u'd',), 1], pokersite.toutf8(['b', {'a': 'c'}, ('d',), 1]))
                             
      def test_args2packets(self):
            self.assertEqual([PacketPing()], pokersite.args2packets([{'type':'PacketPing'}]))
            packets = pokersite.args2packets([{'type':'BadPacket'}])
            self.assertSubstring('Unable to instantiate', packets[0].message)
            packets = pokersite.args2packets([{'type':'0'}])
            self.assertSubstring('Invalid type', packets[0].message)

      def test_packets2maps(self):
            self.assertEqual([{'type': 'PacketPing'}], pokersite.packets2maps([PacketPing()]))
            self.assertEqual([{'packets': [{'type': 'PacketPing'}], 'type': 'PacketList'}], pokersite.packets2maps([PacketList(packets = [PacketPing()])]))
            packet = Packet()
            packet.message = "MESSAGE"
            packet.what = { 0: 1 }
            self.assertEqual([{'message': 'MESSAGE', 'type': 'Packet', 'what': {'X0': 1}}], pokersite.packets2maps([packet]))

class PokerSiteBase(unittest.TestCase):

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" />
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            pokermemcache.memcache_singleton.clear()
            pokermemcache.memcache_expiration_singleton.clear()
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerResource(self.service))

      def tearDown(self):
            self.site.stopFactory()

class PokerResourceTestCase(PokerSiteBase):

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerResourceTestCase.Transport()
                  self.site = site

            def requestDone(self, request):
                  pass

      def test01_render(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.queued = 0
            d = r.notifyFinish()
            def finish(result):
                  self.assertSubstring('\r\n\r\n[]', r.transport.getvalue())
            d.addCallback(finish)
            r.requestReceived('GET', '/', '')
            return d
      
      def test02_render_error(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.queued = 0
            error_pattern = 'UNLIKELY'
            def handlePacketLogic(packet):
                  raise UserWarning, error_pattern
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            r.getSession().avatar.handlePacketLogic = handlePacketLogic
            r.requestReceived('GET', '/?uid=uid&auth=auth', '')
            self.assertSubstring(error_pattern, r.transport.getvalue())

      def test03_render_simultaneous(self):
            """
            requests that are received while another request is being
            handled (this may happen if the packet logic returned a
            deferred) are not blocked by the first request.
            """
            channel = self.Channel(self.site)
            r1 = pokersite.Request(channel, True)
            r1.site = r1.channel.site
            input = '{"type": "PacketPing"}'
            r1.gotLength(len(input))
            r1.handleContentChunk(input)
            r1.queued = 0
            d1 = defer.Deferred()
            r1.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            avatar1 = r1.getSession().avatar
            def handlePacketLogic1(packet):
                  avatar1.sendPacket(d1)
            avatar1.handlePacketLogic = handlePacketLogic1
            r1.requestReceived('GET', '/?uid=uid&auth=auth', '')

            r2 = pokersite.Request(channel, True)
            r2.site = r2.channel.site
            input = '{"type": "PacketPing"}'
            r2.gotLength(len(input))
            r2.handleContentChunk(input)
            r2.queued = 0
            r2.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            avatar2 = r2.getSession().avatar
            def handlePacketLogic2(packet):
                  avatar2.sendPacket(PacketPing())
            r2.getSession().avatar.handlePacketLogic = handlePacketLogic2
            r2.requestReceived('GET', '/?uid=uid&auth=auth', '')

            #
            # r1 not complete yet
            #
            self.assertEqual('', r1.transport.getvalue())
            #
            # r2 complete
            #
            self.assertSubstring('PacketPing', r2.transport.getvalue())
            #
            # r1 complete
            #
            d1.callback(PacketAck())
            self.assertSubstring('PacketAck', r1.transport.getvalue())

      def test04_render_jsonp(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.gotLength(0)
            r.handleContentChunk('')
            r.queued = 0
            r.requestReceived('GET', '/?jsonp=FUN&packet={"type":"PacketPing"}', '')

            self.assertSubstring('\r\n\r\nFUN([])', r.transport.getvalue())

      def test05_render_content(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.gotLength(0)
            r.handleContentChunk('')
            r.queued = 0
            r.requestReceived('GET', '/?packet={"type":"PacketPing"}', '')

            self.assertSubstring('\r\n\r\n[]', r.transport.getvalue())

      def test06_render_expire_logged(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.queued = 0
            session = 'session'
            serial = '5'
            r.received_cookies['TWISTED_SESSION'] = session
            r.site.memcache.set(session, serial)
            d = r.notifyFinish()
            def finish(result):
                  self.assertSubstring('\r\n\r\n[]', r.transport.getvalue())
                  self.failIfSubstring('Expire', r.transport.getvalue())
            d.addCallback(finish)
            r.requestReceived('GET', '/', '')
            return d

      def test06_1_render_do_not_expire_session_if_long_poll_return(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPokerLongPollReturn"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.queued = 0
            d = r.notifyFinish()
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            session = r.getSession()
            def finish(result):
                  self.assertEqual(False, session.expired)
            d.addCallback(finish)
            r.requestReceived('GET', '/?uid=uid&auth=auth', '')
            return d

      def test06_2_render_do_not_update_session_if_long_poll_return(self):
            def longPoll():
                  r = pokersite.Request(self.Channel(self.site), True)
                  r.site = r.channel.site
                  input = '{"type": "PacketPokerLongPoll"}'
                  r.gotLength(len(input))
                  r.handleContentChunk(input)
                  r.queued = 0
                  d = r.notifyFinish()
                  r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
                  session = r.getSession()
                  r.requestReceived('GET', '/?uid=uid&auth=auth', '')
                  return d
            def longPollReturn():
                  r = pokersite.Request(self.Channel(self.site), True)
                  r.site = r.channel.site
                  input = '{"type": "PacketPokerLongPollReturn"}'
                  r.gotLength(len(input))
                  r.handleContentChunk(input)
                  r.queued = 0
                  d = r.notifyFinish()
                  r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
                  session = r.getSession()
                  def finish(result):                        
                        self.failIfSubstring('Session instance has no attribute \'avatar\'', r.transport.getvalue())
                  d.addCallback(finish)
                  r.requestReceived('GET', '/?uid=uid&auth=auth', '')
                  return d
            dl = defer.DeferredList([longPoll(), longPollReturn()])
            return dl

      def test07_message_prefix(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.received_headers['x-forwarded-for'] = '1.2.3.4'
            r.site.resource.message = lambda message: self.assertSubstring('1.2.3.4', message)
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.queued = 0
            d = r.notifyFinish()
            r.requestReceived('GET', '/', '')
            return d

      def test08_error_prefix(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.received_headers['x-forwarded-for'] = '1.2.3.4'
            d = defer.Deferred()
            d.addCallback(lambda error: self.assertSubstring('1.2.3.4', error))
            r.site.resource.error = d.callback
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.queued = 0
            error_pattern = 'UNLIKELY'
            def handlePacketLogic(packet):
                  raise UserWarning, error_pattern
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            r.getSession().avatar.handlePacketLogic = handlePacketLogic
            r.requestReceived('GET', '/?uid=uid&auth=auth', '')
            return d

class PokerTourneyStartTestCase(unittest.TestCase):

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerTourneyStartTestCase.Transport()
                  self.site = site

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" />
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            pokermemcache.memcache_singleton.clear()
            pokermemcache.memcache_expiration_singleton.clear()
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerTourneyStartResource(self.service))

      def tearDown(self):
            pass

      def test01_render(self):            
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = ''
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.requestReceived('GET', '/?tourney_serial=666', '')
            self.assertSubstring('\nOK', r.transport.getvalue())
            self.assertEquals(666, self.service.tourney_serial)
            r.getSession().expire()

class PokerImageUploadTestCase(unittest.TestCase):

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerImageUploadTestCase.Transport()
                  self.site = site

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" />
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            pokermemcache.memcache_singleton.clear()
            pokermemcache.memcache_expiration_singleton.clear()
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerImageUpload(self.service))
            self.image_data = "image data"
            def parse_multipart_mockup(content, dict):
                  return {'filename':[self.image_data]}
            self.cgi_parse_multipart = cgi.parse_multipart
            cgi.parse_multipart = parse_multipart_mockup
            
      def tearDown(self):
            cgi.parse_multipart = self.cgi_parse_multipart

      def test01_render(self):            
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            r.site.memcache.set('auth', '111')
            self.assertEquals(True, r.getSession().avatar.isLogged());

            image_data = "image data"
            r.received_headers['content-type'] = 'multipart/form-data'
            input = ''
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.requestReceived('POST', '/?uid=uid&auth=auth', '')
            self.assertSubstring('image uploaded', r.transport.getvalue())
            self.assertEquals(base64.b64encode(self.image_data),
                              self.service.player_image.image)
            r.getSession().expire()

      def test02_unauthorized(self):            
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            self.assertEquals(False, r.getSession().avatar.isLogged());

            r.received_headers['content-type'] = 'multipart/form-data'
            input = ''
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.requestReceived('POST', '/?uid=uid&auth=auth', '')
            self.assertSubstring('not logged', r.transport.getvalue())
            self.assertEquals(None, self.service.player_image)
      
      def test03_error(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            r.site.memcache.set('auth', '111')
            self.assertEquals(True, r.getSession().avatar.isLogged());

            image_data = "image data"
            r.received_headers['content-type'] = 'multipart/form-data'
            input = ''
            r.gotLength(len(input))
            r.handleContentChunk(input)
            error_pattern = 'UNLIKELY'
            def setPlayerImageFailed(player_image):
                  raise UserWarning, error_pattern
            self.service.setPlayerImage = setPlayerImageFailed
            r.requestReceived('POST', '/?uid=uid&auth=auth', '')
            self.assertSubstring(error_pattern, r.transport.getvalue())
            self.assertEquals(None, self.service.player_image)
            r.getSession().expire()

class PokerAvatarResourceTestCase(unittest.TestCase):

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerAvatarResourceTestCase.Transport()
                  self.site = site

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" />
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerAvatarResource(self.service))

      def test01_render(self):
            data = 'image data'
            serial = 64
            self.service.setPlayerImage(PacketPokerPlayerImage(image = base64.b64encode(data), serial = serial))
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.gotLength(0)
            r.handleContentChunk('')
            r.requestReceived('GET', '/%i' % serial, '')
            self.assertSubstring('\r\n\r\n%s' % data, r.transport.getvalue())
            self.assertEquals(serial, self.service.player_serial)

      def test02_not_found(self):
            serial = 100
            self.service.setPlayerImage(PacketPokerPlayerImage(image = '', serial = serial))
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.gotLength(0)
            r.handleContentChunk('')
            r.requestReceived('GET', '/%i' % serial, '')
            self.assertSubstring('not found', r.transport.getvalue())
            self.assertEquals(serial, self.service.player_serial)

      def test03_error(self):
            data = 'image data'
            serial = 64
            self.service.setPlayerImage(PacketPokerPlayerImage(image = base64.b64encode(data), serial = serial))
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.gotLength(0)
            r.handleContentChunk('')
            error_pattern = 'UNLIKELY'
            def getPlayerImageFailed(player_serial):
                  raise UserWarning, error_pattern
            self.service.getPlayerImage = getPlayerImageFailed
            r.requestReceived('GET', '/%i' % serial, '')
            self.assertSubstring('error_pattern', r.transport.getvalue())
            self.assertEquals(None, self.service.player_serial)

class FilterTestCase(unittest.TestCase):

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" >
<rest_filter>.././testfilter.py</rest_filter>
<rest_filter>.././../pokernetwork/nullfilter.py</rest_filter>
</server>
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerResource(self.service))

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerResourceTestCase.Transport()
                  self.site = site

      def test01_render(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.requestReceived('GET', '/', '')
            
            self.assertSubstring('\r\n\r\n[]', r.transport.getvalue())
            self.assertEqual(True, hasattr(r, "HERE"))

class FilterErrorTestCase(unittest.TestCase):

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" >
<rest_filter>.././testerrorfilter.py</rest_filter>
</server>
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerResource(self.service))

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerResourceTestCase.Transport()
                  self.site = site

      def test01_render(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            
            d = r.notifyFinish()
            def finish(reason):
                  self.assertSubstring('UNLIKELY', r.transport.getvalue())
                  return True
            d.addBoth(finish)
            r.requestReceived('GET', '/', '')
            return d

      def test02_error_prefix(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            r.received_headers['x-forwarded-for'] = '1.2.3.4'
            d = defer.Deferred()            
            d.addCallback(lambda error: self.assertSubstring('1.2.3.4', error))
            r.site.resource.error = d.callback
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)            
            r.requestReceived('GET', '/', '')
            return d

class FilterFinishTestCase(unittest.TestCase):

      def setUp(self):
            testclock._seconds_reset()        
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" >
<rest_filter>.././finishedfilter.py</rest_filter>
</server>
"""
            self.settings = pokernetworkconfig.Config([])
            self.settings.loadFromString(settings_xml)
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            self.service = PokerServiceMockup()
            self.site = pokersite.PokerSite(self.settings, pokersite.PokerResource(self.service))

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerResourceTestCase.Transport()
                  self.site = site

            def requestDone(self, request):
                  pass

      def test01_render(self):
            r = pokersite.Request(self.Channel(self.site), True)
            r.site = r.channel.site
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.queued = 0
            d = r.notifyFinish()
            def finish(reason):
                  self.assertSubstring('FINISHED', r.transport.getvalue())
                  return True
            d.addCallback(finish)
            r.requestReceived('GET', '/', '')
            return d

class SessionTestCase(PokerSiteBase):

      def test01_checkExpired(self):
            uid = 'uid'
            auth = 'auth'
            session = self.site.makeSessionFromUidAuth(uid, auth, False)
            self.site.memcache.set(auth, '0')
            self.assertEqual(True, session.checkExpired())
            self.site.memcache.delete(auth)
            self.assertEqual(False, session.checkExpired())

      def test02_checkDistributedArgs(self):
            uid = 'ZUID'
            auth = 'ZAUTH'
            session = self.site.makeSessionFromUidAuth(uid, auth, False)
            self.failUnlessSubstring(uid, session.avatar.distributed_args)
            self.failUnlessSubstring(auth, session.avatar.distributed_args)
            session.expire()

class SessionExplainTestCase(PokerSiteBase):

      def test01_explain_missing_yes(self):
            class Channel:
                  def __init__(self, site):
                        self.site = site
            
            r = pokersite.Request(Channel(self.site), True)
            r.site = r.channel.site
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            session = r.getSession()
            self.assertNotEquals(None, session.avatar.explain)
            session.expire()
            self.assertEqual(True, session.expired)

      def test02_explain_yes(self):
            class Channel:
                  def __init__(self, site):
                        self.site = site
            
            r = pokersite.Request(Channel(self.site), True)
            r.site = r.channel.site
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'], 'explain': ['yes'] }
            session = r.getSession()
            self.assertNotEquals(None, session.avatar.explain)
            session.expire()
            self.assertEqual(True, session.expired)

      def test02_explain_no(self):
            class Channel:
                  def __init__(self, site):
                        self.site = site
            
            r = pokersite.Request(Channel(self.site), True)
            r.site = r.channel.site
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'], 'explain': ['no'] }
            session = r.getSession()
            self.assertEquals(None, session.avatar.explain)
            session.expire()
            self.assertEqual(True, session.expired)

      def test02_expireFromTwisted(self):
            uid = 'uid'
            auth = 'auth'
            session = self.site.makeSessionFromUidAuth(uid, auth, 'yes')
            self.site.memcache.set(uid, '0')
            self.site.memcache.set(auth, '0')
            session.lastModified = 0
            session.expire()
            session.checkExpired()

      def test03_replaceFromGetSession(self):
            uid = 'uid'
            auth = 'auth'
            session = self.site.makeSessionFromUidAuth(uid, auth, 'yes')
            session.avatar.user.serial = 5
            session.lastModified = 0
            self.site.memcache.set(uid, '0')
            self.site.memcache.set(auth, '0')
            self.assertEqual(False, session.checkExpired())

class RequestTestCase(PokerSiteBase):

      def test01_name(self):
            class Channel:
                  def __init__(self, site):
                        self.site = site
            
            r = pokersite.Request(Channel(self.site), True)
            r.site = r.channel.site
            r.args = { 'uid': [ 'uid' ], 'auth': ['auth'] }
            session = r.getSession()
            session.expire()
            self.assertEqual(True, session.expired)

      def test02_ipNumberProxy(self):
            from twisted.internet import address

            class Channel:
                  def __init__(self, site):
                        self.site = site
            class MockClient:
                  pass
                  
            addr = address.IPv4Address('TCP', 'proxy.example.org', 7775)
            r = pokersite.Request(Channel(self.site), True)
            r.client = addr
            self.assertEquals(r.findProxiedIP(), ('client-ip', 'proxy.example.org'))

            # received_headers will become requestHeaders RSN, according to:
            # http://python.net/crew/mwh/apidocs/twisted.web.http.Request.html

            r.received_headers['x-cluster-client-ip'] = 'cluster-player.example.com'

            self.assertEquals(r.findProxiedIP(), ('x-cluster-client-ip', 'cluster-player.example.com'))
            
            r.received_headers['x-forwarded-for'] = 'forward-player.example.com'
            self.assertEquals(r.findProxiedIP(), ('x-forwarded-for', 'forward-player.example.com'))


class PokerSiteTestCase(PokerSiteBase):

      def test01_init_full(self):
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" memcached="127.0.0.1:11211" session_timeout="60" session_check="10" cookie_timeout="120" />
"""
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml)
            service = PokerServiceMockup()
            site = pokersite.PokerSite(settings, pokersite.PokerResource(service))
            self.assertEqual([ '127.0.0.1:11211' ], site.memcache.addresses)
            self.assertEqual(60, site.sessionFactory.sessionTimeout)
            self.assertEqual(10, site.sessionCheckTime)
            self.assertEqual(120, site.cookieTimeout)

      def test02_init_default(self):
            sessionTimeout = pokersite.PokerSite.sessionFactory.sessionTimeout
            sessionCheckTime = pokersite.PokerSite.sessionCheckTime
            service = PokerServiceMockup()
            site = pokersite.PokerSite(self.settings, pokersite.PokerResource(service))
            self.assertEqual([ ], site.memcache.addresses)
            self.assertEqual(sessionTimeout, site.sessionFactory.sessionTimeout)
            self.assertEqual(sessionCheckTime, site.sessionCheckTime)

      def test03_01_getSession(self):
            """
            A session exists in core but not in memcache :
            the in core session expires
            """
            uid = 'uid'
            auth = 'auth'
            session = self.site.makeSession(uid, auth, False)
            self.site.memcache.delete(auth)
            exception = False
            try:
                  self.site.getSession(session.uid, session.auth, False)
            except KeyError:
                  exception = True
            self.assertEqual(True, exception)
            self.assertEqual(True, session.expired)

      def test03_01_getSession_uid_not_string(self):
            """
            Try to get a session with a numeric uid instead of a string
            """
            uid = 111
            auth = 'auth'
            exception = False
            try:
                  self.site.getSession(uid, auth, False)
            except Exception, e:
                  self.failUnlessSubstring('uid is not str', str(e))
                  exception = True
            self.assertEqual(True, exception)

      def test03_01_getSession_auth_not_string(self):
            """
            Try to get a session with a numeric auth instead of a string
            """
            uid = 'uid'
            auth = 111
            exception = False
            try:
                  self.site.getSession(uid, auth, False)
            except Exception, e:
                  self.failUnlessSubstring('auth is not str', str(e))
                  exception = True
            self.assertEqual(True, exception)

      def test03_02_getSession(self):
            """
            A session exists in core and in memcache. The memcache serial
            is set from the outside.
            """
            session = self.site.makeSession('uid', 'auth', True)
            serial = 111
            self.site.memcache.set(session.auth, str(serial))
            self.site.getSession(session.uid, session.auth, True)
            self.assertEquals(serial, session.avatar.getSerial())
            self.assertNotEquals(None, session.avatar.explain)
            self.assertEquals(serial, session.avatar.explain.serial)
            self.assertEquals(True, PacketPokerRoles.PLAY in session.avatar.roles)
            """
            Memcache serial changed and becomes inconsistent.
            """
            self.site.memcache.set(session.auth, str(serial + 1))
            session = self.site.getSession(session.uid, session.auth, True)
            self.assertEquals(serial + 1, session.avatar.getSerial())

      def test04_updateSession_noop(self):
            """
            nothing happened and user logged out
            """
            session = self.site.makeSession('uid', 'auth', False)
            self.site.updateSession(session)
            self.assertEquals('0', self.site.memcache.get(session.auth))

      def test04_updateSession_login(self):
            """
            memcache serial is 0 and serial is > 0, meaning the user logged in.
            The memcache must be updated accordingly by updating the session id
            entry with the serial
            """
            session = self.site.makeSession('uid', 'auth', False)
            serial = 100
            session.avatar.user.serial = serial
            self.site.updateSession(session)
            self.assertEquals(serial, int(self.site.memcache.get(session.auth)))
            self.assertEquals(self.site.cookieTimeout, self.site.memcache.expiration[session.auth])
            
      def test04_updateSession_logout(self):
            """
            memcache serial is > 0 and serial is == 0, meaning the user logged out
            the memcache must be updated by setting the session id entry to 0
            """
            session = self.site.makeSession('uid', 'auth', False)
            #
            # login
            #
            serial = 100
            session.avatar.user.serial = serial
            session.avatar.tables[1] = 'table'
            self.site.updateSession(session)
            self.assertEquals(serial, int(self.site.memcache.get(session.auth)))
            self.assertEquals(self.site.cookieTimeout, self.site.memcache.expiration[session.auth])
            #
            # logout
            #
            session.memcache_serial = serial # would be set by getSession()
            session.avatar.user.serial = 0
            self.site.updateSession(session)
            self.assertEquals(0, int(self.site.memcache.get(session.auth)))

      def test04_updateSession_inconsistent_serial(self):
            """
            memcache serial is > 0 and serial is > 0 and memcache_serial != serial, 
            serial wins and take over
            """
            session = self.site.makeSession('uid', 'auth', False)
            #
            # login
            #
            serial = 100
            session.avatar.user.serial = serial
            session.avatar.tables[1] = 'table'
            self.site.updateSession(session)
            self.assertEquals(serial, int(self.site.memcache.get(session.auth)))
            #
            # inconsistency in serial, previous serial is discarded
            #
            new_serial = 200
            session.memcache_serial = serial # would be set by getSession()
            session.avatar.user.serial = new_serial
            self.site.updateSession(session)
            self.assertEquals(new_serial, int(self.site.memcache.get(session.auth)))
            self.assertEquals(session.memcache_serial, new_serial)

      def test05_startFactory(self):
            self.site.startFactory()
            self.assertEqual(False, hasattr(self.site, "logFile"))

      class Transport:
            def getPeer(self):
                  return None
            def getHost(self):
                  return None

      class Channel:
            def __init__(self, site):
                  self.transport = PokerResourceTestCase.Transport()
                  self.site = site

      def test08_memcache_key_not_string(self):
            exceptionCaught = False
            session = self.site.makeSession('uid', 'auth', False)
            self.assertRaises(Exception, self.site.memcache.get, unicode(session.auth))
            self.assertRaises(Exception, self.site.getSession, unicode(session.uid), session.auth)
            self.assertRaises(Exception, self.site.getSession, session.uid, unicode(session.auth))

      def test09_error_coverage(self):
            self.site.message = lambda text: self.assertSubstring("*ERROR*", text)
            self.site.error('foo')

      def test10_persistSession(self):
            """
            the session expires after persistSession, unless there are tables
            """
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6">
<resthost host="HOST" port="7777" path="PATH" />
</server>"""
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml)
            service = PokerServiceMockup()
            site = pokersite.PokerSite(settings, pokersite.PokerResource(service))

            session = self.site.makeSession('uid', 'auth', False)
            session.avatar.tables[1] = 'table'
            self.assertEquals(True, site.persistSession(session))
            self.assertEquals(False, session.expired)
            # persistSession should not set memcache entry if avatar has no explain bug#14883
            self.assertEquals(None, site.memcache.get('uid'))
            session.avatar.tables = []
            self.assertEquals(False, site.persistSession(session))
            self.assertEquals(True, session.expired)
            self.assertEquals(None, site.memcache.get('uid'))

      def test10_persistSessionExplain(self):
            """
            the session expires after persistSession, unless there are games in explain
            """
            settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6">
<resthost host="HOST" port="7777" path="PATH" />
</server>"""
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml)
            service = PokerServiceMockup()
            site = pokersite.PokerSite(settings, pokersite.PokerResource(service))
            
            session = self.site.makeSession('uid', 'auth', False)
            session.avatar.tables = []
            session.avatar.setExplain(PacketPokerExplain.ALL)
            session.avatar.explain.games.games[1] = 'table'
            self.assertEquals(True, site.persistSession(session))
            self.assertEquals(False, session.expired)
            self.assertEquals(('HOST', 7777, 'PATH'), site.memcache.get('uid'))

            session.avatar.explain.games.games = {}
            self.assertEquals(False, site.persistSession(session))
            self.assertEquals(True, session.expired)
            self.assertEquals(None, site.memcache.get('uid'))

            session = self.site.makeSession('uid', 'auth', False)
            session.avatar.explain = None
            self.assertEquals(False, site.persistSession(session))
            self.assertEquals(True, session.expired)
            self.assertEquals(None, site.memcache.get('uid'))
            

def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test01"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(FilterErrorTestCase))
    suite.addTest(loader.loadClass(FilterTestCase))
    suite.addTest(loader.loadClass(FilterFinishTestCase))
    suite.addTest(loader.loadClass(PokerResourceTestCase))
    suite.addTest(loader.loadClass(PokerImageUploadTestCase))
    suite.addTest(loader.loadClass(PokerAvatarResourceTestCase))
    suite.addTest(loader.loadClass(SessionTestCase))
    suite.addTest(loader.loadClass(SessionExplainTestCase))
    suite.addTest(loader.loadClass(RequestTestCase))
    suite.addTest(loader.loadClass(PokerSiteTestCase))
    suite.addTest(loader.loadClass(HelpersTestCase))
    suite.addTest(loader.loadClass(PokerTourneyStartTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
        tracebackFormat='default',
        ).run(suite)

if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokersite.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokersite.py' VERBOSE_T=-1 TESTS='coverage-reset test-pokersite.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokersql
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import unittest
import simplejson

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
silence_all_messages()

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="3" admin="yes">

  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
</server>
""" % {'script_dir': SCRIPT_DIR}

from pokernetwork import pokersql
from pokernetwork import pokernetworkconfig

class SqlTestCase(unittest.TestCase):

    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUp(self):
        self.destroyDb()

    def tearDown(self):
        self.destroyDb()

    def test01_getPath(self):
        self.assertTrue("poker.server.xml" in pokersql.getPath(['a/b/foo.bar']))
        self.assertTrue("config.xml" in pokersql.getPath(['a/b/config.xml']))

    def test02_getSettings(self):
        settings = pokersql.getSettings('%s/pokersql.xml' % SCRIPT_DIR)
        self.assertEquals('true', settings.headerGet("/server/@admin"))
        caught = False
        try:
            pokersql.getSettings('%s/pokersqlfail.xml' % SCRIPT_DIR)
        except AssertionError, e:
            self.assertTrue('enable' in str(e))
            caught = True
        self.assertTrue(caught)

    def test03_runQuery(self):
        settings = pokernetworkconfig.Config([])
        settings.loadFromString(settings_xml_server)
        #
        # return selected rows
        #
        value = '4242'
        os.environ['QUERY_STRING'] = 'query=select%20' + value + '&output=rows'
        output = pokersql.runQuery(settings)
        self.assertTrue('Content-type:' in output, output)
        self.assertTrue(value in output, output)
        #
        # return the number of affected rows
        #
        os.environ['QUERY_STRING'] = 'query=select%200' + value
        output = pokersql.runQuery(settings)
        self.assertTrue('Content-type:' in output, output)
        self.assertTrue('\n1' in output, output)
        os.environ['QUERY_STRING'] = 'query=select%200' + value + '&output=rowcount'
        output = pokersql.runQuery(settings)
        self.assertTrue('Content-type:' in output, output)
        self.assertTrue('\n1' in output, output)
        #
        # return the latest autoincrement
        #
        os.environ['QUERY_STRING'] = 'query=INSERT%20INTO%20messages()VALUES()&output=lastrowid'
        output = pokersql.runQuery(settings)
        self.assertTrue('Content-type:' in output, output)
        self.assertTrue('\n1' in output, output)
        os.environ['QUERY_STRING'] = 'query=INSERT%20INTO%20messages()VALUES()&output=lastrowid'
        output = pokersql.runQuery(settings)
        self.assertTrue('Content-type:' in output, output)
        self.assertTrue('\n2' in output, output)

    def test04_run(self):
        self.assertEquals("Content-type: text/plain\n\n",
                          pokersql.run(['%s/pokersql.xml' % SCRIPT_DIR]))

#--------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(SqlTestCase))
    return suite

#--------------------------------------------------------------
def Run(verbose = 2):
    return unittest.TextTestRunner(verbosity=verbose).run(GetTestSuite())

#--------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokersql.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokersql.py' TESTS='coverage-reset test-pokersql.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-pokertable
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2006, 2007, 2008       Loic Dachary <loic@dachary.org>
# Copyright (C)             2008, 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C)                   2009 Johan Euphrosine <proppy@aminche.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import libxml2
from pprint import pprint
from string import split
import time

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

from random import seed, randint
import copy

twisted.internet.base.DelayedCall.debug = True

#
# Must be done before importing pokerclient or pokerclient
# will have to be patched too.
#
from tests import testclock

from tests.testmessages import restore_all_messages, silence_all_messages, search_output, clear_all_messages, get_messages, redirect_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
silence_all_messages()

from pokerengine import pokertournament
from pokernetwork import pokertable, pokernetworkconfig
from pokernetwork.pokerpackets import *
from pokernetwork.pokeravatar import DEFAULT_PLAYER_USER_DATA, PokerAvatar
from pokerengine.pokercards import PokerCards

global table1ID
global table2ID
table1ID = 100
table2ID = 200
settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="4" autodeal="yes" max_missed_round="5">
  <delays autodeal_tournament_min="2" autodeal="2" autodeal_max="2" autodeal_check="0" round="0" position="0" showdown="0" finish="0" />

  <path>%s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % SCRIPT_DIR
settings_stripped_deck_no_autodeal_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="4" autodeal="no" >
  <delays autodeal_tournament_min="2" autodeal="2" autodeal_max="2" autodeal_check="0" round="0" position="0" showdown="0" finish="0" />

  <decks>
    <deck>9c 9d 9h Ts Tc Td Th Ts Jc Jd Jh Js Qc Qd Qh Qs Kc Kd Kh Ks Ac Ad Ah As</deck>
  </decks>

  <path>%s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % SCRIPT_DIR

board = PokerCards()
hand1 = PokerCards(['Qd', 'Ts'])
hand2 = PokerCards(['Kh', 'Kc'])
hand1_extra_river = PokerCards(['Qd', 'Ts', '9c'])
hand2_extra_river = PokerCards(['Qd', 'Ts', '9h'])
flop  = PokerCards(['Jd', 'Js', "Jc"])
turn  = PokerCards(['Tc', 'Js', 'Jc', 'Tc'])
river  = PokerCards(['Tc', 'Js', 'Jc', 'Tc', 'Ad'])
river_extra_river  = PokerCards(['Tc', 'Js', 'Jc', 'Tc', 'Ad', '9d'])

exampleHand =  [ \
        ('wait_for', 1, 'first_round'), \
        ('player_list', [1, 2]), \
        ('round', 'round1', board, { 1 : hand1, 2 : hand2}), \
        ('round', 'round2', flop, { 1 : hand1, 2 : hand2}), \
        ('round', 'round3', turn, { 1 : hand1, 2 : hand2}), \
        ('round', 'round4', river, { 1 : hand1, 2 : hand2}), \
# Round 5 doesn't changed the board to test certain code in
# compressedHistory: it expects that if you haven't changed the board in a
# new round, the history gives you "None"
        ('round', 'round5', river, { 1 : hand1, 2 : hand2}), \
        ('showdown', river, {1 : hand1, 2 : hand2}), \
        ('showdown', river_extra_river, {1 : hand1_extra_river, 2 : hand2_extra_river}), \
        ('position', 1), \
        ('blind_request', 1, 222, 735, 'big_and_dead'), \
        ('wait_blind', 1), \
        ('blind', 1, 222, 0), \
        ('ante_request', 1, 111), \
        ('ante', 1, 111), \
        ('ante', 5, 555), \
        ('all-in', 1), \
        ('call', 1, 411), \
        ('call', 6, 626), \
        ('check', 1), \
        ('fold', 1), \
        ('raise', 1, 888, 888, 666), \
# Note: 3 appears first here to test something appearing first as a raise.
        ('raise', 10, 976, 976, 754), \
        ('canceled', 4, 10), \
        ('rake', 7, { 1 : 7}), \
        ('end', [8, 1], [{ 'serial2share': { 8: 888, 1: 233 } }]), \
        ('sitOut', 1), \
        ('leave', [(1, 2), (2, 7)]), \
        ('finish', 1), \
        ('muck', (1,2)), \
        ('rebuy', 1, 9999), \
        ('unknown',) ]
def convertHandHistoryToDict (hist):
    dict = {}
    for entry in hist:
        key = entry[0]
        dict[key] = entry[1:-1]
    return dict

class MockService:

    def __init__(self, settings):
        self.settings = settings
        self.verbose = settings.headerGetInt("/server/@verbose")
        self.dirs = split(settings.headerGet("/server/path"))
        self.simultaneous = 1
        self.shutting_down = False
        self.hand_serial = 0
        self.hands = {}
        self.chat = False
        self.players = {}
        self.table1 = None
        self.table2 = None
        self.testObject = None
        self.joined_count = 0
        self.joined_max = 1000
        self.chat_messages = []

    def getMissedRoundMax(self):
        return 5  # if you change this, change it in settings_xml above

    # Just copied these joinedCount functions from the real service.
    def joinedCountReachedMax(self):
        """Returns True iff. the number of joins to tables has exceeded
        the maximum allowed by the server configuration"""
        return self.joined_count >= self.joined_max

    def joinedCountIncrease(self, num = 1):
        """Increases the number of currently joins to tables by num, which
        defaults to 1."""
        self.joined_count += num
        return self.joined_count

    def joinedCountDecrease(self, num = 1):
        """Decreases the number of currently joins to tables by num, which
        defaults to 1."""
        self.joined_count -= num
        return self.joined_count

    def getTable(self, gameId):
        if gameId == self.table1.game.id:
            return self.table1
        elif gameId == self.table2.game.id:
            return self.table2
        else:
            self.error("Unknown game requested: " + gameId)
            return None

    def message(self, message):
        print "MockService " + message

    def getName(self, serial):
        return "MockServiceName%d" % serial

    def getPlayerInfo(self, serial):
        class Dummy:
            def __init__(self):
                self.name = "MockServicePlayerInfo"
                self.url = "MockServicePlayerInfo.url"
                self.outfit = "MockServicePlayerInfo.outfit"
        return Dummy()

    def error(self, message):
        self.message("error " + message)

    def movePlayer(self, serial, fromGameId, toGameId):
        return 0

    def seatPlayer(self, serial, table_id, amount):
        if self.players.has_key(serial):
            self.error("Player is already seated at table, ." % table_id)
            return False
        else:
            self.players[serial] = { 'table_id' : table_id, 'amount' : amount }
            return True

    def buyInPlayer(self, serial, game_id, currency_serial, amount):
        if serial == 9 and amount != 1000 and amount != 100000000:
            return 0
        else:
            return amount

    def getHandSerial(self):
        self.hand_serial += 1
        return self.hand_serial

    def tableMoneyAndBet(self, table_id):
        return (0, 500)

    def leavePlayer(self, serial, table_id, currency_serial):
        if self.players.has_key(serial):
            del self.players[serial]
            return True
        else:
            self.error("Player is already seated at table, %d." % table_id)
            return False

    def deleteTable(self, x):
        pass

    def destroyTable(self, x):
        pass

    def eventTable(self, table):
        pass

    def updateTableStats(self, game, observers, waiting):
        pass

    def loadHand(self, handId, removeList = []):
        # Only ever return the one hand; the only one this mock game ever had...
        #  ... but only if they give a positive integer as a handId.
        if handId <= 0:
            return None
        else:
            l = copy.deepcopy(exampleHand)
            # Remove anything that this specific test wants to get rid of,
            # perhaps because it messes with their results.
            for xx in removeList:
                l.remove(xx)
            l.insert(0, ('game', 1, handId, 3, time.time(), 'variant','betting_structure', [1, 2], 7, { 1 : 7890, 2 : 1234, 'values' : ''}))
            self.hands[handId] = convertHandHistoryToDict(l)
            return l

    def saveHand(self, history, serial):
        if self.testObject:
            historyDict = convertHandHistoryToDict(history)
            handId = historyDict['game'][1]
            origDict = self.hands[handId]
            for (action, fields) in historyDict.iteritems():
                if action == "showdown":
                    self.testObject.failUnless(fields == (None,) or fields == (PokerCards([34, 48, 35, 34, 25, 20]),))
                elif action == "round" and fields[0] == "round5":
                    self.testObject.assertEqual(fields, ('round5', None,))
                else:
                    self.testObject.assertEqual(origDict[action], fields)

    def updatePlayerMoney(self, serial, gameId, amount):
        # Most of this function matches up with the false hand history above
        #  Compare it to that when figuring out where these numbers come from,
        #  except for serial 3, which is based on the ante he makes in test21
        if self.testObject:
            self.testObject.assertEqual(gameId,  self.testObject.table1_value)
            if serial == 1:
                self.testObject.assertEqual(amount,  -1399)
            elif serial == 3:
                self.testObject.assertEqual(amount,  -100)
            elif serial == 10:
                self.testObject.assertEqual(amount,  -976)
            elif serial == 4:
                self.testObject.assertEqual(amount,  10)
            elif serial == 5:
                self.testObject.assertEqual(amount,  -555)
            elif serial == 6:
                self.testObject.assertEqual(amount,  -626)
            elif serial == 8:
                self.testObject.assertEqual(amount,  888)
            else:
                self.testObject.fail("Unkown serial in hand history: %d" % serial)

    def updatePlayerRake(self, currencySerial, serial, rakeAmount):
        if self.testObject:
            self.testObject.assertEqual(rakeAmount,  7)
            self.testObject.assertEqual(serial,  1)

    def tourneyEndTurn(self, tourney, game_id):
        if self.testObject:
            self.testObject.assertEqual(game_id,  self.testObject.table1_value)
            self.testObject.assertEqual(tourney.name,  'My Old Sit and Go')

    def resetBet(self, gameId):
        if self.testObject:
            self.testObject.assertEqual(gameId,  self.testObject.table1_value)

    def databaseEvent(self, event, param1, param2):
        if self.testObject:
            self.testObject.assertEqual(PacketPokerMonitorEvent.HAND, event)

    def chatMessageArchive(self, player_serial, game_id, message):
        self.chat_messages.append((player_serial, game_id, message))

if verbose < 0: redirect_messages(MockService)

class MockClient:
    class User:
        def isLogged(self):
            return True

    def __init__(self, serial, testObject, expectedReason = ""):
        self.serial = serial
        self.deferred = None
        self.raise_if_packet = None
        self.type = None
        self.tables = {}
        self.packets = []
        self.user = MockClient.User()
        self.testObject = testObject
        self.reasonExpected = expectedReason
        self.bugous_processing_hand = False

    def __str__(self):
        return "MockClient of Player%d" % self.serial

    def waitFor(self, type):
        self.deferred = defer.Deferred()
        self.type = type
        return self.deferred

    def raiseIfPacket(self, type):
        self.raise_if_packet = type

    def lookForPacket(self, type):
        for packet in self.packets:
            if packet.type == type:
                return packet
        return False

    def message(self, message):
        print "MockClient " + message

    def error(self, message):
        self.message("error " + message)

    def join(self, table, reason = ""):
        self.testObject.assertEquals(reason, self.reasonExpected)

    # Loic indicates that it's the job of the Client to pass along a few
    # things, including "player removes", and various clients settings, to
    # the game class.  These next few functions do that to be consistent
    # with what the pokertable API expects.

    def removePlayer(self, table, serial):
        if not self.tables.has_key(table.game.id):
            self.error("Table with game number %d does not occur exactly once for this player." % table.game.id)
        if serial == 9:
            table.game.removePlayer(serial)
            return False
        return table.game.removePlayer(serial)

    def autoBlindAnte(self, table, serial, auto):
        table.game.getPlayer(serial).auto_blind_ante = auto

    def sitPlayer(self, table, serial):
        table.game.sit(serial)

    def addPlayer(self, table, seat):
        self.tables[table.game.id] = table
        if table.game.addPlayer(self.serial, seat):
            player = table.game.getPlayer(self.serial)
            player.setUserData(DEFAULT_PLAYER_USER_DATA.copy())
        return True

    def sitOutPlayer(self, table, serial):
        table.game.sitOutNextTurn(serial)

    def sendPacket(self, packet):
        self.message("sendPacket: " + str(packet))
        self.packets.append(packet)
        if self.deferred:
            if self.raise_if_packet and packet.type == self.raise_if_packet:
                reactor.callLater(0, lambda: self.deferred.errback(packet))
            elif self.type == packet.type:
                reactor.callLater(0, lambda: self.deferred.callback(packet))

    def sendPacketVerbose(self, packet):
        self.sendPacket(packet)

    def getSerial(self):
        return self.serial

    def setMoney(self, table, amount):
        return table.game.payBuyIn(self.serial, amount)

    def getName(self):
        return "Player%d" % self.serial

    def getPlayerInfo(self):
        class MockPlayerInfo:
            def __init__(self, player):
                self.player = player
                self.name = self.player.getName()
                self.url = "http://fake"
                self.outfit = None
        return MockPlayerInfo(self)

if verbose < 0: redirect_messages(MockClient)

# --------------------------------------------------------------------------------
class MockClientBot(MockClient):
    def getName(self):
        return "BOT%d" % self.serial
# --------------------------------------------------------------------------------
class MockClientWithTableDict(MockClient):
    def __init__(self, serial, testObject):
        self.tables = {}
        MockClient.__init__(self, serial, testObject)

    def addPlayer(self, table, seat):
        MockClient.addPlayer(self, table, seat)
        self.tables[table.game.id] = seat
# --------------------------------------------------------------------------------
class MockClientWithRemoveTable(MockClient):
    def removeTable(self, gameId):
        return True
# --------------------------------------------------------------------------------
class MockClientWithRealJoin(MockClient, PokerAvatar):
    def join(self, table, reason=""):
        PokerAvatar.join(self, table, reason)

class PokerAvatarCollectionTestCase(unittest.TestCase):

    def test01(self):
        avatar_collection = pokertable.PokerAvatarCollection(prefix = '', verbose = 6)
        serial1 = 200
        serial2 = 400
        self.assertEquals([], avatar_collection.get(serial1))
        avatar1 = "a1"
        avatar2 = "a2"
        avatars = [ avatar1, avatar2 ]
        avatar_collection.set(serial1, avatars)
        self.assertRaises(AssertionError, avatar_collection.set, serial1, avatars)
        self.assertEquals(avatars, avatar_collection.get(serial1))
        avatar_collection.remove(serial1, avatar1)
        self.assertRaises(AssertionError, avatar_collection.remove, serial1, avatar1)
        self.assertEquals([avatar2], avatar_collection.get(serial1))
        avatar_collection.add(serial1, avatar2) # add twice is noop
        self.assertEquals([[avatar2]], avatar_collection.values())
        avatar_collection.add(serial1, avatar1)
        self.assertEquals([avatar2, avatar1], avatar_collection.get(serial1))
        avatar_collection.add(serial2, avatar1)
        self.assertEquals([avatar1], avatar_collection.get(serial2))
        avatar_collection.remove(serial2, avatar1)
        self.assertEquals([], avatar_collection.get(serial2))

# --------------------------------------------------------------------------------
class PokerTableTestCaseBase(unittest.TestCase):
    # -------------------------------------------------------------------
    def setUp(self, settingsXmlStr=settings_xml, ServiceClass = MockService):
        testclock._seconds_reset()
        global table1ID
        global table2ID
        table1ID = table1ID + 1
        table2ID += 1
        self.table1_value = table1ID
        self.table2_value = table2ID

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settingsXmlStr, len(settingsXmlStr))
        settings.header = settings.doc.xpathNewContext()
        self.service = ServiceClass(settings)
        self.table = pokertable.PokerTable(self.service, table1ID,
                                           { 'name': "table1",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6,
                                             'muck_timeout' : 1,
                                             'currency_serial': 0,
                                             'max_missed_round' : 3
                                             })
        self.table2 = pokertable.PokerTable(self.service, table2ID,
                                           { 'name': "table2",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6,
                                             'muck_timeout' : 1,
                                             'currency_serial': 0
                                             })
        self.service.table1 = self.table
        self.service.table2 = self.table2

        # Test to make sure that the max_missed_round count can be
        # overwritten by description in init settings.  note That table1
        # has setting of '1' for that value, but table2 accepts the
        # default above.
        self.assertEquals(self.table.max_missed_round, 3)
        self.assertEquals(self.table2.max_missed_round, 5)

        self.clients = {}
    # -------------------------------------------------------------------
    def tearDown(self):
        self.table.cancelDealTimeout()
        self.table.cancelPlayerTimers()
        del self.table
        del self.service
    # -------------------------------------------------------------------
    def createPlayer(self, serial, getReadyToPlay=True, clientClass=MockClient, table=None):
        if table == None:
            table = self.table
        client = clientClass(serial, self)
        client.service = self.service
        self.clients[serial] = client
        if getReadyToPlay:
            client.reasonExpected = "MockCreatePlayerJoin"
            self.assertEqual(True, table.joinPlayer(client, serial,
                                       reason  = "MockCreatePlayerJoin"))
            client.reasonExpected = ""
            self.assertEqual(True, table.seatPlayer(client, serial, -1))
            self.assertEqual(True, table.buyInPlayer(client, self.table.game.maxBuyIn()))
            self.table.sitPlayer(client, serial)
        return client
    # -------------------------------------------------------------------
    def createBot(self, serial, getReadyToPlay=True, clientClass=MockClientBot, table=None):
        return self.createPlayer(serial, getReadyToPlay, clientClass, table)
# --------------------------------------------------------------------------------
class PokerTableTestCase(PokerTableTestCaseBase):
    # -------------------------------------------------------------------
    def test01_autodeal(self):
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return defer.DeferredList((self.clients[1].waitFor(PACKET_POKER_START),
                                   self.clients[2].waitFor(PACKET_POKER_START)))
    # -------------------------------------------------------------------
    def test01_5_autodealWithBots(self):
        """Test that autodeal won't happen when it's all bots sitting down.  I
        wish there was a packet we could catch here to confirm, but I
        can't even do a raise_if_packet because none are coming."""
        self.createBot(1)
        self.createBot(2)
        self.createBot(3)
        self.assertEquals(None, self.table.scheduleAutoDeal())
    # -------------------------------------------------------------------
    def test01_7_autodealShutDown(self):
        self.createPlayer(1)
        self.createPlayer(2)
        self.service.shutting_down = True
        self.assertEquals(None, self.table.scheduleAutoDeal())

    # -------------------------------------------------------------------
    def test01_8_testClientsBogusPokerProcessingHand(self):
        """Test specific situation in autodeal when poker clients send a Processing Hand before a Ready To Play"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        self.table.processingHand(1)
        self.table.scheduleAutoDeal()
        threeGetsStart = self.clients[3].waitFor(PACKET_POKER_START)
        verboseVal = self.table.factory.verbose
        if self.table.factory.verbose < 2:
            self.table.factory.verbose = 2
        def checkValues(value):
            search_output('Player 1 marked as having a bugous PokerProcessingHand protocol')
            self.failUnless(player[1].bugous_processing_hand, "1 should have bugous_processing_hand")
            for ii in [ 2, 3, 4]:
                self.failIf(player[ii].bugous_processing_hand,
                            "%d should not have bugous_processing_hand" % ii)

        threeGetsStart.addCallback(checkValues)

        clear_all_messages()
        return defer.DeferredList((self.clients[2].waitFor(PACKET_POKER_START),
                                   threeGetsStart))
    # -------------------------------------------------------------------
    def test02_autodeal_check(self):
        self.createPlayer(1)
        self.table.processingHand(1)
        self.table.game_delay["delay"] = 2
        self.table.game_delay["start"] = testclock._seconds_value
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)
    # -------------------------------------------------------------------
    def test_02_1_autodeal_destroy(self):
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.processingHand(1)
        self.table.autoDealCheck(20, 10)
        dealTimeout = self.table.timer_info["dealTimeout"]
        self.table.destroy()
        #self.assertEquals(1, dealTimeout.cancelled)
        self.assertEquals(False, self.table.timer_info.has_key("dealTimeout"))
    # -------------------------------------------------------------------
    def test06_duplicate_buyin(self):
        """ Buy in requested twice for a given player """
        self.createPlayer(1)
        client = self.clients[1]
        self.assertEqual(False, self.table.buyInPlayer(client, self.table.game.maxBuyIn()))
    # -------------------------------------------------------------------
    def test08_player_has_trouble_joining(self):
        """Test for when the table is full and a player is trying hard to join"""
        # Do not use serials of 0's here -- pokerengine will hate that. :)
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        player[5] = self.createPlayer(5, False)

        # people at table aren't obsrevers
        self.assertEqual(False, self.table.isSerialObserver(1))

        # player5 can't sit because the table is full of 1-4...
        self.assertEqual(False, self.table.seatPlayer(player[5], 5, -1))
        # player5 still not an observer
        self.assertEqual(False, self.table.isSerialObserver(5))

        self.assertEqual(True, self.table.joinPlayer(player[5], 5))
        # player5 now an observer
        self.assertEqual(True, self.table.isSerialObserver(5))
        #  ... but player5 decides to set all sorts of things that she can't
        #      because she's still just an observer.
        self.assertEqual(False, self.table.muckAccept(player[5], 5))
        self.assertEqual(False, self.table.muckDeny(player[5], 5))
        self.assertEqual(False, self.table.autoBlindAnte(player[5], 5, True))
        self.assertEqual(False, self.table.buyInPlayer(player[5], 0))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 30))

        # player5 cannot sit out either because she isn't joined yet.
        self.assertEqual(False, self.table.sitOutPlayer(player[5], 5))

        # player1 leaves on his own...
        self.assertEqual(True, self.table.leavePlayer(player[1], 1))

        # ... which allows player5 to finally join legitimately and change
        # her settings.  However, she tries to sit in everyone else's
        # seat, she tries to sit out before getting the seat, rebuy before
        # even buying, and then buys in for nothing, and thus must rebuy

        for p in self.table.game.playersAll():
            self.assertEqual(False, self.table.seatPlayer(player[5], 5, p.seat))

        self.assertEqual(False, self.table.sitPlayer(player[5], 5))

        self.assertEqual(True, self.table.seatPlayer(player[5], 5, -1))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 2))

        self.assertEqual(True, self.table.buyInPlayer(player[5], 0))

        # ... but cannot sit down again
        self.assertEqual(False, self.table.seatPlayer(player[5], 5, -1))

        # I wonder if these should really return True rather than None?  -- bkuhn
        self.assertEqual(None, self.table.muckAccept(player[5], 5))
        self.assertEqual(None, self.table.muckDeny(player[5], 5))
        self.assertEqual(None, self.table.autoBlindAnte(player[5], 5, True))

        self.assertEqual(True, self.table.rebuyPlayerRequest(player[5], \
                                              self.table.game.maxBuyIn()))
        # finally, player5 tries to join table 2, which isn't permitted since
        # we've set MockService.simultaneous to 1
        self.assertEqual(False, self.table2.joinPlayer(player[5], 5))
    # -------------------------------------------------------------------
    def test08_2_brokenSeatFactory(self):
        player = self.createPlayer(1, False)
        self.assertEqual(True, self.table.joinPlayer(player, 1))
        self.table.factory.seatPlayer = lambda a, b, c: False
        self.assertEqual(False, self.table.seatPlayer(player, 1, -1))
    # -------------------------------------------------------------------
    def test08_5_kick(self):
        """Test that kick works correctly"""
        player = self.createPlayer(2)

        self.assertEqual(None, self.table.kickPlayer(2))
        # Test to make sure it's ok if we kick him twice.
        try:
            self.assertEqual(None, self.table.kickPlayer(2))
        except KeyError, ke:
            self.assertEqual(2, ke[0])

        # Special test: player 9's removePlayer always fails, so it covers
        # error conditions.  Note that this has to be reset via this method in
        # tests that wish to use it:

        def fakeGameRemovePlayer(serial):
            from pokerengine.pokergame import PokerGameServer
            ret = PokerGameServer.removePlayer(self.table.game, serial)
            if serial == 9:
                return False
            else:
                return ret
        self.table.game.removePlayer = fakeGameRemovePlayer
        p = self.createPlayer(9)
        self.assertEquals(None, self.table.kickPlayer(9))
    # -------------------------------------------------------------------
    def test08_7_sitout(self):
        """Test that sitOut works correctly"""
        player = self.createPlayer(4)

        # player4 sits out but tries it twice.  (Guess he clicked too much
        # on the button)
        self.assertEqual(True, self.table.sitOutPlayer(player, 4))
        self.assertEqual(True, self.table.sitOutPlayer(player, 4))
    # -------------------------------------------------------------------
    def test08_8_buyinOverMax(self):
        """Test that buyins over the maximum are refused"""
        player = self.createPlayer(1)

        self.assertEqual(False, self.table.rebuyPlayerRequest(player, 1))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player, 2))
    # -------------------------------------------------------------------
    def test09_list_players(self):
        """Test to make sure the list of players given by pokertable is right"""
        d = {}
        for ii in [1, 2, 3, 4]:
            d['Player%d' % ii] = self.createPlayer(ii)
        for x in self.table.listPlayers():
            del d[x[0]]
        self.assertEqual({}, d)
    # -------------------------------------------------------------------
    def test10_info_and_chat(self):
        """Test player discussions and info"""
        p = {}
        for ii in [1, 2, 3, 4]:
            p[ii] = self.createPlayer(ii)
        d = self.table.getPlayerInfo(2)
        self.failUnlessSubstring("Player2", d.name)
        self.table.chatPlayer(self.clients[1], 1, "Hi, I am the One.")
        self.assertEquals(1, self.service.chat_messages[0][0])
        self.assertEquals(table1ID, self.service.chat_messages[0][1])
        self.assertEquals("Hi, I am the One.", self.service.chat_messages[0][2])
        x = p[ii].waitFor(PACKET_POKER_CHAT)
        def chatCatch(packet):
            self.assertEqual(serial, 1)
            self.assertEqual(serial, "Hi, I am the One.")
        x.callback(chatCatch)
        return x
    # -------------------------------------------------------------------
    def test11_packet(self):
        """Test toPacket"""
        packetStr = "%s" % self.table.toPacket()
        idstr = 'id = %d' % self.table.game.id
        for str in [ idstr, 'name = table1', 'variant = holdem', \
                     'betting_structure = 2-4-limit', 'seats = 4', \
                     'average_pot = 0', 'hands_per_hour = 0', \
                     'percent_flop = 0', 'players = 0', 'observers = 0', \
                     'waiting = 0', 'player_timeout = 6', 'muck_timeout = 1', \
                     'currency_serial = 0', 'skin = default' ]:
            self.failUnlessSubstring(str, packetStr)
    # -------------------------------------------------------------------
    def test12_everyone_timeout(self):
        """Test if all players fall through timeout"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        self.table.update()

        return defer.DeferredList((player[1].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[2].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[3].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[4].waitFor(PACKET_POKER_TIMEOUT_NOTICE)))
    # -------------------------------------------------------------------
    def test13_disconnect(self):
        """Test a disconnected player"""
        p1 = self.createPlayer(1, clientClass=MockClientWithTableDict)
        p9 = self.createPlayer(9, clientClass=MockClientWithTableDict)
        self.table.disconnectPlayer(p1, 1)
        self.table.disconnectPlayer(p9, 9)
    # -------------------------------------------------------------------
    def test14_closed_games(self):
        """Do typical operations act as expected when the game is closed?"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        self.table.game.close()
        self.table.quitPlayer(player[1], 1)

        # Leaving a closed table generates an error.  player[2] is going
        # to leave, we wait for the error packet to come back, and make
        # sure that they other_type indicates it's a response to our leave
        # request.
        deferredLeaveErrorWait = player[2].waitFor(PACKET_POKER_ERROR)
        def checkReturnPacket(packet):
            self.assertEqual(PACKET_POKER_PLAYER_LEAVE, packet.other_type)
            self.failUnlessSubstring("annot leave", packet.message)
        deferredLeaveErrorWait.addCallback(checkReturnPacket)

        self.table.leavePlayer(player[2], 2)
        return deferredLeaveErrorWait
    # -------------------------------------------------------------------
    def test16_autoMuckTimeoutPolicy(self):
        """Make sure other timeout policies function properly"""
        player = self.createPlayer(1)
        player2 = self.createPlayer(2)
        # Sit out policy is the default
        self.assertEqual(self.table.timeout_policy,  "sitOut")
        self.table.timeout_policy =  "fold"

        expectPlayerAutoFold = player2.waitFor(PACKET_POKER_AUTO_FOLD)
        def checkReturnPacket(packet):
            # Don't assert which serial we get here, as it could be from
            # either player
            self.assertEqual(packet.game_id, self.table1_value)
        expectPlayerAutoFold.addCallback(checkReturnPacket)

        clear_all_messages()
        self.table.update()
        self.assertEquals(get_messages(), ['*ERROR* table %d bet mismatch 0 in memory versus 500 in database' % self.table.game.id, 'AutodealCheck scheduled in 0.000000 seconds'])

        return expectPlayerAutoFold
    # -------------------------------------------------------------------
    def test17_bogusTimeoutPolicy(self):
        self.table.timeout_policy =  "muck"
        player = self.createPlayer(1)
        player2 = self.createPlayer(2)
        self.table.update()
        return player.waitFor(PACKET_POKER_TIMEOUT_NOTICE)
    # -------------------------------------------------------------------
    def test17a_resetTimeoutPolicy(self):
        """Set timeout policy back to the default"""
        self.table.timeout_policy = "sitOut"
    # -------------------------------------------------------------------
    def test18_handReplay(self):
        """Test replay of hand from pokertable"""
        player1 = self.createPlayer(1)

        # First try a hand that doesn't exist
        self.assertEqual(None, self.table.handReplay(player1, 0))

        myHandId = randint(777, 79825)
        def checkHandSerial(packet):
            self.assertEqual(packet.hand_serial, myHandId)
        def checkAmount(amount, value):
            self.assertEqual(amount, value)
        def checkAnteAmount(packet):
            checkAmount(packet.amount, 111)
        def checkBlindAmount(packet):
            checkAmount(packet.amount, 222)
        def checkCallAmount(packet):
            checkAmount(packet.amount, 411)
        def checkRaiseAmount(packet):
            checkAmount(packet.amount, 888)
        def checkRebuyAmount(packet):
            checkAmount(packet.amount, 9999)
        def checkCanceledAmount(packet):
            checkAmount(packet.amount, 10)
        def checkRakeAmount(packet):
            self.assertEqual(packet.value, 7)
        def checkPosition(packet):
            self.assertEqual(packet.position, 1)
        def checkBlindRequest(packet):
            self.assertEqual(packet.state, "big_and_dead")
            checkBlindAmount(packet)
        def checkPlayerMoney(packet):
            self.assertEqual(True, packet.serial == 1 or packet.serial == 2)
            if packet.serial == 1:
                self.assertEqual(packet.amount, 7890)
            else:
                self.assertEqual(packet.amount, 1234)
        def checkPlayerCards(packet):
            self.assertEqual(True, packet.serial == 1 or packet.serial == 2)
            if packet.serial == 1:
                self.assertEqual(packet.cards, [23, 47])
            else:
                self.assertEqual(packet.cards, [11, 37])
        def checkMuckSerials(packet):
            self.assertEqual(packet.muckable_serials, (1, 2))

        # To get coverage of a player who isn't joined to the table requesting.
        player2 = self.createPlayer(2, False)

        player1.reasonExpected = "HandReplay"
        player2.reasonExpected = "HandReplay"
        for player in (player1, player2):
            self.table.handReplay(player, myHandId)
            checkHandSerial(player.lookForPacket(PACKET_POKER_START))
            checkPlayerCards(player.lookForPacket(PACKET_POKER_PLAYER_CARDS))
            checkPlayerCards(player.lookForPacket(PACKET_POKER_PLAYER_CARDS))
            checkPosition(player.lookForPacket(PACKET_POKER_POSITION))
            checkBlindRequest(player.lookForPacket(PACKET_POKER_BLIND_REQUEST))
            checkBlindAmount(player.lookForPacket(PACKET_POKER_BLIND))
            checkAnteAmount(player.lookForPacket(PACKET_POKER_ANTE_REQUEST))
            checkAnteAmount(player.lookForPacket(PACKET_POKER_ANTE))
            checkRebuyAmount(player.lookForPacket(PACKET_POKER_REBUY))
            player.lookForPacket(PACKET_POKER_CALL)
            player.lookForPacket(PACKET_POKER_CHECK)
            player.lookForPacket(PACKET_POKER_FOLD)
            checkRaiseAmount(player.lookForPacket(PACKET_POKER_RAISE))
            checkCanceledAmount(player.lookForPacket(PACKET_POKER_CANCELED))
            checkRakeAmount(player.lookForPacket(PACKET_POKER_RAKE))
            player.lookForPacket(PACKET_POKER_SIT_OUT)
            checkMuckSerials(player.lookForPacket(PACKET_POKER_MUCK_REQUEST))
            checkRebuyAmount(player.lookForPacket(PACKET_POKER_REBUY))
    # -------------------------------------------------------------------
    def test19_avatar_collection_empty(self):
        """Test replay of hand from pokertable"""
        self.assertEqual("MockServiceName1", self.table.getName(1))
        d = self.table.getPlayerInfo(1)
        self.failUnlessSubstring("MockServicePlayerInfo", d.name)
    # -------------------------------------------------------------------
    def test20_quitting(self):
        p = self.createPlayer(1)
        self.assertEquals(True, self.table.quitPlayer(p, 1))
        p = self.createPlayer(2, False, clientClass=MockClientWithTableDict)
        self.assertEqual(True, self.table.joinPlayer(p, 2))
        p.tables[self.table.game.id] = self.table
        self.assertEquals(True, self.table.quitPlayer(p, 2))
        # Special test: player 9's removePlayer always fails
        p = self.createPlayer(9)
        self.assertEquals(True, self.table.quitPlayer(p, 9))
    # -------------------------------------------------------------------
    def test20altForNewClientAPI_quitting(self):
        # This is disabled until the API changes
        return True

        p = self.createPlayer(1)
        self.assertEquals(True, self.table.quitPlayer(p, 1))
        p = self.createPlayer(2, False, clientClass=MockClientWithRemoveTable)
        self.assertEqual(True, self.table.joinPlayer(p, 2))
        self.assertEquals(True, self.table.quitPlayer(p, 2))
    # -------------------------------------------------------------------
    def test20_1_brokenLeaving(self):
        p = self.createPlayer(1)
        self.assertEquals(True, self.table.leavePlayer(p, 1))
        # Special test: player 9's removePlayer always fails
        p = self.createPlayer(9)
        self.assertEquals(True, self.table.leavePlayer(p, 9))
    # -------------------------------------------------------------------
    def test21_syncDatabase(self):
        """Test syncing the Database back to the MockService"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
            self.table.readyToPlay(ii)
        self.service.testObject = self
        self.table.game.turn_history = self.service.loadHand(randint(777, 8975))
        clear_all_messages()
        self.table.update()

        return player[3].waitFor(PACKET_POKER_TIMEOUT_NOTICE)
    # -------------------------------------------------------------------
    def test22_possibleObserverLoggedIn(self):
        """Test possibleObserverLoggedIn"""
        p = self.createPlayer(1)
        self.table.disconnectPlayer(p, 1)
        p2 = self.createPlayer(2)
        # Player 1 is already at the table, so this should be meaningless:
        self.table.possibleObserverLoggedIn(p, 1)
        # Player 2's object has been "lost", s owe created
        p2_reconnected = self.createPlayer(3, getReadyToPlay=False)
        self.table.joinPlayer(p2_reconnected, 3)
        self.table.possibleObserverLoggedIn(p2_reconnected, 2)
    # -------------------------------------------------------------------
    def test23_broadcastingPlayerCards(self):
        """Test to make sure PokerPlayerCards are broadcasted correctly.  This
        test is not particularly good, in my view, because it was written
        to target certain lines in private2public directly and may not
        actually be an adequate test of actual functionality."""
        p = self.createPlayer(1)
        p2 = self.createPlayer(2)
        c1 = PokerCards([ 'As', 'Ah' ])
        c1.allHidden()
        self.table.game.getPlayer(2).hand.set(c1)
        self.table.broadcast([ PacketPokerPlayerCards(game_id = self.table.game.id, serial = 2,
                                                      cards = self.table.game.getPlayer(2).hand.toRawList())])
        def checkReturnPacketBySerial(packet, serial):
            self.assertEqual(packet.serial, 2)
            if serial == 2:
                hand_expected = [243, 204]
            else:
                hand_expected = [255, 255]
            self.assertEqual(packet.cards, hand_expected)
            self.assertEqual(packet.game_id, self.table1_value)

        checkReturnPacketBySerial(p.lookForPacket(PACKET_POKER_PLAYER_CARDS), 1)
        checkReturnPacketBySerial(p2.lookForPacket(PACKET_POKER_PLAYER_CARDS), 2)
    # -------------------------------------------------------------------
    def test24_treeFallingInWoodsWithNoPlayerToHearIt(self):
        """Test a broadcast message that no one is here to hear"""
        self.assertEqual(False, self.table.broadcastMessage(PacketPokerGameMessage, "Tommy, can you hear me?"))
    # -------------------------------------------------------------------
    def test25_buyingInWhilePlaying(self):
        """Test if all players fall through timeout"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)

        def postBlindCallback(packet):
            player[3].sendPacket(PacketPokerBlind())
            self.table.buyInPlayer(player[3], 10)
        defPlayer3Blind = player[3].waitFor(PACKET_POKER_BLIND_REQUEST)

        defPlayer3Blind.addCallback(postBlindCallback)

        self.table.update()
        return defPlayer3Blind
    # -------------------------------------------------------------------
    def test26_wrongPlayerUpdateTimes(self):
        """Test if playerUpdateTimers get called with the wrong serial"""
        p = self.createPlayer(1)
        p = self.createPlayer(2)
        self.assertEqual(None, self.table.playerWarningTimer(2))
        self.assertEqual(None, self.table.playerTimeoutTimer(2))
    # -------------------------------------------------------------------
    def test27_buyinFailures(self):
        p9 = self.createPlayer(9, False)
        self.assertEqual(True, self.table.joinPlayer(p9, 9))
        self.assertEqual(True, self.table.seatPlayer(p9, 9, -1))
        self.assertEqual(True, self.table.buyInPlayer(p9, 1000))

        self.table.game.getPlayer(9).money = 0
        self.assertEqual(False, self.table.rebuyPlayerRequest(p9, 50))

        p1 = self.createPlayer(1)
        self.table.game.getPlayer(1).money = 50
        self.table.game.rebuy = lambda a, b: False
        self.assertEqual(False, self.table.rebuyPlayerRequest(p1, 0))
    # -------------------------------------------------------------------
    def checkFailedJoinDueToMax(self, player):
        self.assertEqual(False, self.table.isJoined(player))
        self.assertEquals(get_messages(), ['*ERROR* joinPlayer: %d cannot join game %d because the server is full' % (player.serial, self.table.game.id), 'sendPacket: type = ERROR(53) serial = %d game_id = %d message = This server has too many seated players and observers., code = 1, other_type = POKER_TABLE_JOIN' % (player.serial, self.table.game.id)])
        self.assertEquals(len(player.packets), 1)
        p = player.packets[0]
        self.assertEquals(p.type, PACKET_POKER_ERROR)
        self.assertEquals(p.serial, player.serial)
        self.assertEquals(p.game_id, self.table.game.id)
        self.assertEquals(p.message, "This server has too many seated players and observers.")
        self.assertEquals(p.code, PacketPokerTableJoin.FULL)
        self.assertEquals(p.other_type, PACKET_POKER_TABLE_JOIN)
        player.packets = []
    # -------------------------------------------------------------------
    def doJoinAndFailDueToMax(self, player):
        """Helper method used to check to for a join failed due to the
        maximum value."""
        clear_all_messages()
        self.table.joinPlayer(player, player.serial)
        self.checkFailedJoinDueToMax(player)
    # -------------------------------------------------------------------
    def test28_tooManyPlayers(self):
        """Generate so many players, trying to join tables, such that we
        get too many.  To force this to happen, we decrease the number of
        permitted players to be very low."""
        clear_all_messages()
        self.table.factory.joined_max = 3
        self.assertEquals(self.table.factory.joined_count, 0)
        players = {}
        for ii in [ 1, 2, 3, 4 ]:
            players[ii] = self.createPlayer(ii, getReadyToPlay = False)
            self.assertEquals(self.table.factory.joined_count, 0)

        for ii in [ 1, 2, 3 ]:
            self.table.joinPlayer(players[ii], players[ii].serial)
            self.assertEqual(True, self.table.isJoined(players[ii]))
            self.assertEqual(players[ii].packets, [])
            self.assertEquals(self.table.factory.joined_count, ii)
        self.assertEquals(get_messages(), [])
        self.doJoinAndFailDueToMax(players[4])
        self.assertEquals(self.table.factory.joined_count, 3)
    # -------------------------------------------------------------------
    def test29_leavingDoesNotDecreaseCount(self):
        """Players who leave do not actually cease being observers, and
        therefore do not decrease max join count"""
        clear_all_messages()
        self.table.factory.joined_max = 3
        self.assertEquals(self.table.factory.joined_count, 0)
        players = {}
        for ii in [ 1, 2, 3, 4 ]:
            players[ii] = self.createPlayer(ii, getReadyToPlay = False)
            self.assertEquals(self.table.factory.joined_count, 0)

        for ii in [ 1, 2, 3 ]:
            self.table.joinPlayer(players[ii], players[ii].serial)
            self.assertEqual(True, self.table.isJoined(players[ii]))
            self.assertEqual(players[ii].packets, [])
            self.assertEquals(self.table.factory.joined_count, ii)
        self.assertEquals(get_messages(), [])
        self.assertEquals(True, self.table.leavePlayer(players[1], players[1].serial))

        self.doJoinAndFailDueToMax(players[4])
        self.assertEquals(self.table.factory.joined_count, 3)
    # -------------------------------------------------------------------
    def test30_justEnoughPlayers(self):
        """Tests situation where players truely are gone from the table
        and are no longer observers either, thus allowing more players to
        be conntected."""
        clear_all_messages()
        self.table.factory.joined_max = 3
        self.assertEquals(self.table.factory.joined_count, 0)
        players = {}
        for ii in [ 1, 2, 3 ]:
            players[ii] = self.createPlayer(ii, getReadyToPlay = True)
            self.assertEqual(True, self.table.isJoined(players[ii]))
            self.assertEqual(players[ii].packets, [])
            self.assertEquals(self.table.factory.joined_count, ii)
        messages = get_messages()
        self.failUnlessSubstring('player 1 get seat 1', messages[1])
        self.failUnlessSubstring('player 2 get seat 6', messages[3])
        self.failUnlessSubstring('player 3 get seat 3', messages[5])
        clear_all_messages()

        for ii in [ 4, 5, 6 ]:
            players[ii] = self.createPlayer(ii, getReadyToPlay = False)
            self.assertEquals(self.table.factory.joined_count, 3)
        self.assertEquals(get_messages(), [])

        # leavePlayer turns an actual player into an observer, so they are still
        #  connected.  player 4 should still be unable to join.
        self.assertEquals(True, self.table.leavePlayer(players[1], players[1].serial))
        self.assertEquals(self.table.factory.joined_count, 3)
        self.doJoinAndFailDueToMax(players[4])
        self.assertEquals(self.table.factory.joined_count, 3)
        clear_all_messages()

        self.assertEquals(True, self.table.quitPlayer(players[2], 2))
        search_output('[Server][PokerGame %d] removing player %d from game'
                      % (self.table.game.id, players[2].serial))
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 2)

        self.table.joinPlayer(players[4], players[4].serial)
        self.assertEqual(True, self.table.isJoined(players[4]))
        self.assertEquals(get_messages(), [])
        self.assertEquals(self.table.factory.joined_count, 3)

        self.assertEquals(None, self.table.kickPlayer(players[3].serial))
        search_output('[Server][PokerGame %d] removing player %d from game'
                      % (self.table.game.id, players[3].serial))
        self.assertEquals(self.table.factory.joined_count, 3)

        self.doJoinAndFailDueToMax(players[5])
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 3)

        self.assertEquals(True, self.table.disconnectPlayer(players[3], 3))
        search_output('[Server][PokerGame %d] removing player %d from game'
                      % (self.table.game.id, players[3].serial))
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 2)

        self.table.joinPlayer(players[5], players[5].serial)
        self.assertEqual(True, self.table.isJoined(players[5]))
        self.assertEquals(get_messages(), [])
        self.assertEquals(self.table.factory.joined_count, 3)

        self.doJoinAndFailDueToMax(players[6])
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 3)
    # -------------------------------------------------------------------
    def test31_kickPlayerForMissingTooManyBlinds(self):
        """test31_kickPlayerForMissingTooManyBlinds
        Players who pass or equal the max_missed_round count are
        automatically kicked from the table and turned into observers.
        This happens via the update function's call of
        cashGame_kickPlayerSittingOutTooLong().  That function searches in
        the history for a 'finish' event (meaning the hand is done) and
        then kicks the player afer that.  This test sets up that situatoin
        and makes sure the player gets kicked."""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
            self.assertEquals(self.service.players.has_key(ii), True)

        self.table.game.serial2player[4].missed_big_blind_count = 1000
        self.table.game.turn_history = self.service.loadHand(6352,
                                         [('leave', [(1, 2), (2, 7)])])

        # Table starts with no observers before our update

        self.assertEquals(len(self.table.observers), 0)
        if self.table.factory.verbose < 2: self.table.factory.verbose = 2
        clear_all_messages()
        self.table.update()
        for msg in ['[Server][PokerGame %d] removing player 4 from game', 'broadcast[1, 2, 3] type = POKER_PLAYER_LEAVE(81) serial = 4 game_id = %d seat = 8', 'sendPacket: type = POKER_PLAYER_LEAVE(81) serial = 4 game_id = %d seat = 8', 'sendPacket: type = POKER_PLAYER_LEAVE(81) serial = 4 game_id = %d seat = 8', 'sendPacket: type = POKER_PLAYER_LEAVE(81) serial = 4 game_id = %d seat = 8', 'sendPacket: type = POKER_PLAYER_LEAVE(81) serial = 4 game_id = %d seat = 8']:
            self.assertEquals(search_output(msg % self.table1_value), True)

        for ii in [1, 2, 3, 4]:
            # Our service's leavePlayer() should have been called for 4,
            # the rest should still be there
            self.assertEquals(self.service.players.has_key(ii), ii != 4)
            foundCount = 0
            for pp in player[ii].packets:
                if pp.type == PACKET_POKER_PLAYER_LEAVE:
                    foundCount += 1
                    self.assertEquals(pp.serial, 4)
                    self.assertEquals(pp.game_id, self.table1_value)
                    self.assertEquals(pp.seat, 8)
            self.assertEquals(foundCount, 1)
        # Table should now have one observer, 4
        self.assertEquals(len(self.table.observers), 1)
        self.assertEquals(self.table.observers[0].serial, 4)
        return player[1].waitFor(PACKET_POKER_TIMEOUT_NOTICE)
    # -------------------------------------------------------------------
    def test32_seatPlayerUpdateTableStats(self):
        player = self.createPlayer(1, False)
        def updateTableStats(game, observers, waiting):
            updateTableStats.called = True
        updateTableStats.called = False
        self.table.factory.updateTableStats = updateTableStats
        self.assertEquals(True, self.table.joinPlayer(player, 1))
        self.assertEquals(True, self.table.seatPlayer(player, 1, 1))
        self.assertEquals(True, updateTableStats.called)
    # -------------------------------------------------------------------
    def test33_leavePlayerUpdateTableStats(self):
        player = self.createPlayer(1)
        def updateTableStats(game, observers, waiting):
            updateTableStats.called = True
        updateTableStats.called = False
        self.table.factory.updateTableStats = updateTableStats
        self.table.game.is_open = True
        self.table.leavePlayer(player, 1)
        self.assertEquals(True, updateTableStats.called)
    # -------------------------------------------------------------------
    def test34_leavePlayerDelayedNoUpdateTableStats(self):
        player = self.createPlayer(1)
        def updateTableStats(game, observers, waiting):
            updateTableStats.called = True
        updateTableStats.called = False
        self.table.factory.updateTableStats = updateTableStats
        self.table.game.is_open = False
        self.table.leavePlayer(player, 1)
        self.assertEquals(False, updateTableStats.called)
    # -------------------------------------------------------------------
    def test35_quitPlayerUpdateTableStats(self):
        player = self.createPlayer(1)
        def updateTableStats(game, observers, waiting):
            updateTableStats.called = True
        updateTableStats.called = False
        self.table.factory.updateTableStats = updateTableStats
        self.table.game.is_open = True
        self.table.quitPlayer(player, 1)
        self.assertEquals(True, updateTableStats.called)
    # -------------------------------------------------------------------
    def test36_quitPlayerDelayedNoUpdateTableStats(self):
        player = self.createPlayer(1)
        def updateTableStats(game, observers, waiting):
            updateTableStats.called = True
        updateTableStats.called = False
        self.table.factory.updateTableStats = updateTableStats
        self.table.game.is_open = False
        self.table.quitPlayer(player, 1)
        self.assertEquals(False, updateTableStats.called)
    # -------------------------------------------------------------------
    def test37_disconnectPlayerUpdateTableStats(self):
        player = self.createPlayer(1)
        def updateTableStats(game, observers, waiting):
            updateTableStats.called = True
        updateTableStats.called = False
        self.table.factory.updateTableStats = updateTableStats
        self.table.game.is_open = True
        self.table.disconnectPlayer(player, 1)
        self.assertEquals(True, updateTableStats.called)
    # -------------------------------------------------------------------
    def test38_disconnectPlayerDelayedNoUpdateTableStats(self):
        player = self.createPlayer(1)
        def updateTableStats(game, observers, waiting):
            updateTableStats.called = True
        updateTableStats.called = False
        self.table.factory.updateTableStats = updateTableStats
        self.table.game.is_open = False
        self.table.disconnectPlayer(player, 1)
        self.assertEquals(False, updateTableStats.called)
    # -------------------------------------------------------------------
    def test39_kickPlayerUpdateTableStats(self):
        player = self.createPlayer(1)
        def updateTableStats(game, observers, waiting):
            updateTableStats.called = True
        updateTableStats.called = False
        self.table.factory.updateTableStats = updateTableStats
        self.table.game.is_open = True
        self.table.kickPlayer(1)
        self.assertEquals(True, updateTableStats.called)
    # -------------------------------------------------------------------
    def test40_destroy_table(self):
        """Test table destruction"""
        p1 = self.createPlayer(1, clientClass=MockClientWithTableDict)
        d = p1.waitFor(PACKET_POKER_TABLE_DESTROY)
        self.table.destroy()
         # Make sure we can't update once table is destroyed.
        self.assertEquals("not valid", self.table.update())
        return d
    # -------------------------------------------------------------------
    def test40_destroy_table_with_observers(self):
        """Test table destruction with observers at the table"""
        p1 = self.createPlayer(1, clientClass=MockClientWithTableDict)
        self.table.seated2observer(p1)
        d = p1.waitFor(PACKET_POKER_TABLE_DESTROY)
        self.table.destroy()
         # Make sure we can't update once table is destroyed.
        self.assertEquals("not valid", self.table.update())
        return d
    # -------------------------------------------------------------------
    def test41_update_exception(self):
        """Test if exception caught in update and hitory reduced"""
        self.table.history_index = -1
        def failure(history_tail):
            raise Exception("FAIL")
        self.table.updateTimers = failure
        exception_occurred = False
        try:
            self.table.update()
        except Exception, e:
            exception_occurred = True
            self.assertEquals("FAIL", e.message)
        self.assertEquals(0, self.table.history_index)
        self.assertEquals(True, exception_occurred)
    # -------------------------------------------------------------------
    def test42_update_recursion(self):
        """Test if update is protected against recursion"""
        self.table.prot = False
        def recurse(dummy):
            self.table.prot = True
            self.assertEquals("recurse", self.table.update())
        self.table.updateTimers = recurse
        self.assertEquals("ok", self.table.update())
        self.assertEquals(True, search_output('unexpected recursion'))
        self.assertEquals(True, self.table.prot)
    # -------------------------------------------------------------------
    def test43_gameStateIsMuckonAutoDealSched(self):
        """If game state is muck when autodeal tries to schedule, it should fail"""
        from pokerengine.pokergame import GAME_STATE_MUCK
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)

        verboseVal = self.table.factory.verbose
        if self.table.factory.verbose < 3: self.table.factory.verbose = 4
        clear_all_messages()
        self.table.game.state = GAME_STATE_MUCK
        self.table.scheduleAutoDeal()
        self.table.factory.verbose = verboseVal

        # No packets should be received if we tried to autodeal in
        # GAME_STATE_MUCK
        for ii in [1, 2, 3, 4]:
            self.assertEquals(player[ii].packets, [])

        search_output("Not autodealing %d because game is in muck state" % self.table.game.id)
    # -------------------------------------------------------------------
    def test44_muckTimeoutTimer_hollowedOutGameWithMuckableSerials(self):
        from pokerengine.pokergame import GAME_STATE_MUCK
        class MockGame():
            def __init__(mgSelf):
                mgSelf.muckable_serials = [ 1, 2 ]
                mgSelf.mucked = {}
                mgSelf.id = 77701
                mgSelf.state = GAME_STATE_MUCK
            def muck(mgSelf, serial, want_to_muck = False):
                mgSelf.mucked[serial] = want_to_muck

            # Rest MockGame methods below are dummy methods needed when
            # self.table.update() gets called.
            def historyGet(mgSelf): return []
            def isRunning(mgSelf): return False
            def potAndBetsAmount(mgSelf): return 0

        self.table.timer_info["muckTimeout"] = None
        origGame = self.table.game
        self.table.game = MockGame()
        verboseVal = self.table.factory.verbose
        if self.table.factory.verbose <= 0: self.table.factory.verbose = 1
        clear_all_messages()

        self.table.muckTimeoutTimer()

        self.assertEquals(len(self.table.game.mucked.keys()), 2)
        for ii in [ 1, 2 ]:
            self.failUnless(self.table.game.mucked[ii], "Serial %d should be mucked" % ii)
        self.assertEquals(get_messages()[0], 'muck timed out')
        self.table.factory.verbose = verboseVal
        self.table.game = origGame
    # -------------------------------------------------------------------
    def test45_cancelMuckTimer_hollowedOutTimer(self):
        class AMockTime(): # Spot the ST:TOS reference. :-) -- bkuhn
            def __init__(amtSelf):
                amtSelf.cancelCalledCount = 0
                amtSelf.activeCalledCount = 0
            def active(amtSelf):
                amtSelf.activeCalledCount += 1
                return True
            def cancel(amtSelf):
                amtSelf.cancelCalledCount += 1
        saveTimerInfo = self.table.timer_info

        aMockTimer = AMockTime()
        self.table.timer_info = { 'muckTimeout' : aMockTimer }

        clear_all_messages()
        self.table.cancelMuckTimer()

        self.assertEquals(self.table.timer_info['muckTimeout'], None)
        self.assertEquals(aMockTimer.cancelCalledCount, 1)
        self.assertEquals(aMockTimer.activeCalledCount, 1)
        self.assertEquals(get_messages(), [])

        self.table.timer_info = saveTimerInfo
    # -------------------------------------------------------------------
    def test46_updatePlayerTimers_hollowedOutGameAndMockedTableVals(self):
        from pokerengine.pokergame import GAME_STATE_MUCK
        class MockGame():
            def __init__(mgSelf):
                mgSelf.muckable_serials = [ 1, 2 ]
                mgSelf.mucked = {}
                mgSelf.id = 77701
                mgSelf.state = GAME_STATE_MUCK
            def isRunning(mgSelf): return True
            def getSerialInPosition(mgSelf): return 664
            def historyGet(mgSelf): return [ "" ]

        self.table.game = MockGame()
        self.table.playerTimeout = 100
        self.table.history_index = -1
        deferredMustBeCalledBackForSuccess = defer.Deferred()
        def myPlayerTimeout(serial):
            self.assertEquals(self.tableSave.timer_info["playerTimeoutSerial"], serial)
            self.assertEquals(serial, 664)
            deferredMustBeCalledBackForSuccess.callback(True)
            self.assertEquals(get_messages(), [])

        self.table.playerWarningTimer = myPlayerTimeout
        def failedToCancelTimeout():
            self.fail("existing playerTimeout was not replaced as expected")

        self.table.timer_info = { 'playerTimeout' :
                                  reactor.callLater(20, failedToCancelTimeout),
                                  'playerTimeoutSerial' : 229 }
                                  # Note: serial is diff from one in position
        clear_all_messages()
        self.table.updatePlayerTimers()

        self.tableSave = self.table

        return deferredMustBeCalledBackForSuccess
    # -------------------------------------------------------------------
    def test48_muckTimeoutTimerShouldEmptyMuckableSerials(self):
        """
        See https://gna.org/bugs/?13898
        """
        from pokerengine.pokergame import GAME_STATE_MUCK

        self.table.timer_info["muckTimeout"] = None
        if self.table.factory.verbose <= 0: self.table.factory.verbose = 1
        clear_all_messages()

        self.createPlayer(1)
        self.createPlayer(2)
        self.table.beginTurn()

        self.table.game.state = GAME_STATE_MUCK
        self.table.game.muckable_serials = [1,2]
        self.table.syncDatabase = lambda: None
        self.table.muckTimeoutTimer()
        self.assertEquals([], self.table.game.muckable_serials)

# -------------------------------------------------------------------

# I seriously considered not having *all* the same tests run with
# predifined decks because it was not needed to get coverage.  A simple
# setup test would have worked.  However, I think it's good leaving it
# this way because if predifined decks are later used extensively, we
# would want all the tests to run and when additional use of predefined
# decks is added.  -- bkuhn, 2008-01-21

# I later decided to mix together the tests for predefined decks with
# tests for autodeal turned off; that's why so many tests are replaced.

class PokerTableTestCaseWithPredefinedDecksAndNoAutoDeal(PokerTableTestCase):
    def setUp(self, settingsXmlStr=settings_stripped_deck_no_autodeal_xml, ServiceClass = MockService):
        PokerTableTestCase.setUp(self, settingsXmlStr, ServiceClass)

    # -------------------------------------------------------------------
    def test01_autodeal(self):
        self.createPlayer(1)
        self.createPlayer(2)
        # Nothing should happen, we don't have autodeal
        self.assertEqual(None, self.table.scheduleAutoDeal())
    # -------------------------------------------------------------------
    def test01_8_testClientsBogusPokerProcessingHand(self):
        """Test specific situation in autodeal when poker clients send a
        Processing Hand before a Ready To Play: not needed when autodeal is off"""
        pass
    # -------------------------------------------------------------------
    def test02_autodeal_check(self):
        self.createPlayer(1)
        self.table.processingHand(1)
        self.table.game_delay["delay"] = 2
        self.table.game_delay["start"] = testclock._seconds_value
        self.createPlayer(2)
        self.assertEqual(None, self.table.scheduleAutoDeal())
    # -------------------------------------------------------------------
    def test12_everyone_timeout(self):
        """Test if all players fall through timeout"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        self.table.cancelDealTimeout()
        self.table.beginTurn()
        self.table.update()

        return defer.DeferredList((player[1].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[2].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[3].waitFor(PACKET_POKER_TIMEOUT_NOTICE),
                                   player[4].waitFor(PACKET_POKER_TIMEOUT_NOTICE)))
    # -------------------------------------------------------------------
    def test16_autoMuckTimeoutPolicy(self):
        """Make sure other timeout policies function properly"""
        player = self.createPlayer(1)
        player2 = self.createPlayer(2)
        # Sit out policy is the default
        self.assertEqual(self.table.timeout_policy,  "sitOut")
        self.table.timeout_policy =  "fold"

        expectPlayerAutoFold = player2.waitFor(PACKET_POKER_AUTO_FOLD)
        def checkReturnPacket(packet):
            # Don't assert which serial we get here, as it could be from
            # either player
            self.assertEqual(packet.game_id, self.table1_value)
        expectPlayerAutoFold.addCallback(checkReturnPacket)

        self.table.cancelDealTimeout()
        self.table.beginTurn()
        self.table.update()

        return expectPlayerAutoFold
    # -------------------------------------------------------------------
    def test17_bogusTimeoutPolicy(self):
        self.table.timeout_policy =  "muck"
        player = self.createPlayer(1)
        player2 = self.createPlayer(2)

        self.table.cancelDealTimeout()
        self.table.beginTurn()
        self.table.update()
        return player.waitFor(PACKET_POKER_TIMEOUT_NOTICE)
    # -------------------------------------------------------------------
    def test21_syncDatabase(self):
        """Test syncing the Database back to the MockService"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
            self.table.readyToPlay(ii)
        self.service.testObject = self
        self.table.game.turn_history = self.service.loadHand(randint(777, 8975))
        self.table.beginTurn()
        self.table.update()
        return player[4].waitFor(PACKET_POKER_TIMEOUT_NOTICE)
    # -------------------------------------------------------------------
    def test25_buyingInWhilePlaying(self):
        """Test if all players fall through timeout"""
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        self.table.beginTurn()

        def postBlindCallback(packet):
            player[3].sendPacket(PacketPokerBlind(serial = 3, game_id = packet.game_id, amount = packet.amount, dead = packet.dead))
            self.assertEqual(False, self.table.buyInPlayer(player[3], 10))

        defPlayer3Blind = player[3].waitFor(PACKET_POKER_BLIND_REQUEST)

        defPlayer3Blind.addCallback(postBlindCallback)

        self.table.update()

        return defPlayer3Blind
    def test27_buyinFailures(self):
        """This test doesn't matter in this subclass"""
        return True
    # -------------------------------------------------------------------
    def test28_joinTwice(self):
        """Player join a second time : packets sent twice"""
        player = self.createPlayer(1)
        self.assertEqual(True, self.table.isJoined(player))
        def join(table, reason = ""):
            player.joined = True
        player.join = join
        self.assertEqual(True, self.table.joinPlayer(player, player.serial))
        self.failUnless(player.joined)
    # -------------------------------------------------------------------
    def test31_kickPlayerForMissingTooManyBlinds(self):
        """SKIP THIS TEST IN THIS SUBCLASS
        """
        return True
# -------------------------------------------------------------------
# This class tests the same operations as PokerTableTestCase but for tables that
#  are transient.  Note the outcome of various operations are quite different
#  when the table is transient.
class PokerTableTestCaseTransient(PokerTableTestCase):
    def setUp(self, settingsXmlStr=settings_xml, ServiceClass = MockService):
        testclock._seconds_reset()
        global table1ID
        global table2ID
        table1ID = table1ID + 1
        table2ID += 1
        self.table1_value = table1ID
        self.table2_value = table2ID

        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settingsXmlStr, len(settingsXmlStr))
        settings.header = settings.doc.xpathNewContext()
        self.service = ServiceClass(settings)
        class Tournament:
            name = 'My Old Sit and Go'
            serial = 2
        self.table = pokertable.PokerTable(self.service, table1ID,
                                           { 'name': "table1",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6,
                                             'muck_timeout' : 1,
                                             'transient' : True,
                                             'tourney' : Tournament(),
                                             'currency_serial': 0
                                             })
        self.table2 = pokertable.PokerTable(self.service, table2ID,
                                           { 'name': "table2",
                                             'variant': "holdem",
                                             'betting_structure': "2-4-limit",
                                             'seats': 4,
                                             'player_timeout' : 6,
                                             'muck_timeout' : 1,
                                             'transient' : True,
                                             'tourney' : Tournament(),
                                             'currency_serial': 0
                                             })
        self.service.table1 = self.table
        self.service.table2 = self.table2
        self.clients = {}

    def createPlayer(self, serial, getReadyToPlay=True, clientClass=MockClient, table=None):
        if table == None:
            table = self.table
        client = clientClass(serial, self)
        self.clients[serial] = client
        client.reasonExpected = "MockTransientCreatePlayer"
        table.joinPlayer(client, serial, reason = "MockTransientCreatePlayer")
        client.reasonExpected = ""
        if getReadyToPlay:
            self.assertEqual(True, table.seatPlayer(client, serial, -1))
            table.sitPlayer(client, serial)
        return client

    # -------------------------------------------------------------------
    def test01_autodeal(self):
        """ Transient tables hand deal has a minimum duration if all players are in auto mode """
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.game_delay["start"] = testclock._seconds_value
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)
    # -------------------------------------------------------------------
    def test02_autodeal_check(self):
        self.createPlayer(1)
        self.table.processingHand(1)
        self.table.game_delay["delay"] = 2
        self.table.game_delay["start"] = testclock._seconds_value
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        return self.clients[2].waitFor(PACKET_POKER_MESSAGE)
    # -------------------------------------------------------------------
    def test04_autodeal_transient_now(self):
        """ Transient tables hand deal has no minium duration if all players are in auto mode but the hand lasted more than the required minium """
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.game_delay["start"] = testclock._seconds_value - 300
        self.table.scheduleAutoDeal()
        self.clients[2].raiseIfPacket(PACKET_POKER_MESSAGE)
        return self.clients[2].waitFor(PACKET_POKER_START)
    # -------------------------------------------------------------------
    def test05_autodeal_transient_normal(self):
        """ Transient tables hand deal normaly if at least one player is not in auto mode """
        self.createPlayer(1)
        self.createPlayer(2)
        self.table.scheduleAutoDeal()
        self.clients[2].raiseIfPacket(PACKET_POKER_MESSAGE)
        return self.clients[2].waitFor(PACKET_POKER_START)

    def test08_player_has_trouble_joining(self):
        """Test for when the table is full and a player is trying hard to join"""
        # Do not use serials of 0's here -- pokerengine will hate that. :)
        player = {}
        for ii in [1, 2, 3, 4]:
            player[ii] = self.createPlayer(ii)
        player[5] = self.createPlayer(5, False)

        # player5 can't sit because the table is full of 1-4...
        self.assertEqual(False, self.table.seatPlayer(player[5], 5, -1))

        #  ... but player5 decides to set all sorts of things that she can't
        #      because she's still just an observer.
        self.assertEqual(False, self.table.muckAccept(player[5], 5))
        self.assertEqual(False, self.table.muckDeny(player[5], 5))
        self.assertEqual(False, self.table.autoBlindAnte(player[5], 5, True))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 30))

        # player5 cannot sit out either because she isn't joined yet.
        self.assertEqual(False, self.table.sitOutPlayer(player[5], 5))

        # player1 leaves on his own...
        self.assertEqual(True, self.table.leavePlayer(player[1], 1))

        # ... which allows player5 to finally join legitimately and change
        # her settings.  However, she tries to sit out before getting the
        # seat, rebuy before even buying, and then buys in for nothing,
        # and thus must rebuy

        self.assertEqual(True, self.table.seatPlayer(player[5], 5, -1))
        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], 2))

        # this table is transient, so no one can buy in.
        self.assertEqual(False, self.table.buyInPlayer(player[5], 0))

        # I wonder if these should really return True rather than None?  -- bkuhn
        self.assertEqual(None, self.table.muckAccept(player[5], 5))
        self.assertEqual(None, self.table.muckDeny(player[5], 5))
        self.assertEqual(None, self.table.autoBlindAnte(player[5], 5, True))

        self.assertEqual(False, self.table.rebuyPlayerRequest(player[5], \
                                              self.table.game.maxBuyIn()))

        # player2 tries to rebuy but is already at the max, and besides,
        # in transient mode, this doesn't work anyway

        self.assertEqual(False, self.table.rebuyPlayerRequest(player[2], 1))
    # -------------------------------------------------------------------
    def test07_break_message(self):
        """ Tournament break issue a message to all players """
        class Tournament:
            def __init__(self):
                self.state = pokertournament.TOURNAMENT_STATE_BREAK_WAIT

        self.createPlayer(1)
        self.createPlayer(2)
        self.table.tourney = Tournament()
        self.table.game.isTournament = lambda: True
        self.table.scheduleAutoDeal()
        self.failUnless(self.clients[1].lookForPacket(PACKET_POKER_GAME_MESSAGE))
        self.failUnless(self.clients[2].lookForPacket(PACKET_POKER_GAME_MESSAGE))
    # -------------------------------------------------------------------
    def test11bis_packet_with_tourney_serial(self):
        """Test toPacket"""
        packetStr = "%s" % self.table.toPacket()
        idstr = 'id = %d' % self.table.game.id
        for str in [ idstr, 'name = table1', 'variant = holdem', \
                     'betting_structure = 2-4-limit', 'seats = 4', \
                     'average_pot = 0', 'hands_per_hour = 0', \
                     'percent_flop = 0', 'players = 0', 'observers = 0', \
                     'waiting = 0', 'player_timeout = 6', 'muck_timeout = 1', \
                     'currency_serial = 0', 'skin = default', \
                     'tourney_serial = 2' ]:
            self.failUnlessSubstring(str, packetStr)
    # -------------------------------------------------------------------
    def test27_buyinFailures(self):
        """This test doesn't matter in this subclass"""
        return True
    # -------------------------------------------------------------------
    def test28_tooManyPlayers(self):
        """Generate so many players, trying to join tables, such that we
        get too many.  To force this to happen, we decrease the number of
        permitted players to be very low.  Note that for transient tables,
        immediate joins are forced, and therefore we get the error
        immediately upon getting ready to play"""
        clear_all_messages()
        self.table.factory.joined_max = 3
        self.assertEquals(self.table.factory.joined_count, 0)
        players = {}
        for ii in [ 1, 2, 3 ]:
            players[ii] = self.createPlayer(ii, getReadyToPlay = False)
            self.assertEqual(True, self.table.isJoined(players[ii]))
            self.assertEquals(self.table.factory.joined_count, ii)
        self.assertEquals(self.table.factory.joined_count, 3)
        clear_all_messages()
        players[4] = self.createPlayer(4, getReadyToPlay = False)
        self.checkFailedJoinDueToMax(players[4])
        self.assertEquals(self.table.factory.joined_count, 3)
    # -------------------------------------------------------------------
    def test29_leavingDoesNotDecreaseCount(self):
        """Players who leave do not actually cease being observers, and
        therefore do not decrease max join count.  Note this works
        differently with transient tables because the seating is
        automatic."""
        clear_all_messages()
        self.table.factory.joined_max = 3
        self.assertEquals(self.table.factory.joined_count, 0)
        players = {}
        for ii in [ 1, 2, 3 ]:
            players[ii] = self.createPlayer(ii, getReadyToPlay = False)
            self.assertEqual(True, self.table.isJoined(players[ii]))
            self.assertEquals(self.table.factory.joined_count, ii)

        self.assertEquals(self.table.factory.joined_count, 3)

        self.assertEquals(get_messages(), [])
        self.assertEquals(True, self.table.leavePlayer(players[1], players[1].serial))

        clear_all_messages()  # Ignore any messages from leave
        players[4] = self.createPlayer(4, getReadyToPlay = False)
        self.checkFailedJoinDueToMax(players[4])

        self.assertEquals(self.table.factory.joined_count, 3)
    # -------------------------------------------------------------------
    def test30_justEnoughPlayers(self):
        """Tests situation where players truely are gone from the table
        and are no longer observers either, thus allowing more players to
        be conntected.  With transient tables, this automatically tries to
        seat them."""
        clear_all_messages()
        self.table.factory.joined_max = 3
        players = {}
        for ii in [ 1, 2, 3 ]:
            players[ii] = self.createPlayer(ii, getReadyToPlay = True)
            self.assertEqual(True, self.table.isJoined(players[ii]))
            self.assertEqual(players[ii].packets, [])
            self.assertEquals(self.table.factory.joined_count, ii)
        messages = get_messages()
        self.failUnlessSubstring('player 1 get seat 1', messages[1])
        self.failUnlessSubstring('player 2 get seat 6', messages[3])
        self.failUnlessSubstring('player 3 get seat 3', messages[5])
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 3)

        for ii in [ 4, 5, 6 ]:
            players[ii] = self.createPlayer(ii, getReadyToPlay = False)
            self.checkFailedJoinDueToMax(players[ii])
            clear_all_messages()
            self.assertEquals(self.table.factory.joined_count, 3)

        # leavePlayer turns an actual player into an observer, so they are still
        #  connected.  player 4 should still be unable to join.
        self.assertEquals(True, self.table.leavePlayer(players[1], players[1].serial))
        self.doJoinAndFailDueToMax(players[4])
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 3)

        self.assertEquals(True, self.table.quitPlayer(players[2], 2))
        search_output('[Server][PokerGame %d] removing player %d from game'
                      % (self.table.game.id, players[2].serial))
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 2)
        self.table.joinPlayer(players[4], players[4].serial)
        self.assertEqual(True, self.table.isJoined(players[4]))
        self.assertEquals(get_messages(), [])
        self.assertEquals(self.table.factory.joined_count, 3)

        self.assertEquals(None, self.table.kickPlayer(players[3].serial))
        search_output('[Server][PokerGame %d] removing player %d from game'
                      % (self.table.game.id, players[3].serial))
        self.assertEquals(self.table.factory.joined_count, 3)

        self.doJoinAndFailDueToMax(players[5])
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 3)

        self.assertEquals(True, self.table.disconnectPlayer(players[3], 3))
        search_output('[Server][PokerGame %d] removing player %d from game'
                      % (self.table.game.id, players[3].serial))
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 2)

        self.table.joinPlayer(players[5], players[5].serial)
        self.assertEqual(True, self.table.isJoined(players[5]))
        self.assertEquals(get_messages(), [])
        self.assertEquals(self.table.factory.joined_count, 3)

        self.doJoinAndFailDueToMax(players[6])
        clear_all_messages()
        self.assertEquals(self.table.factory.joined_count, 3)
    # -------------------------------------------------------------------
    def test31_kickPlayerForMissingTooManyBlinds(self):
        """SKIP THIS TEST IN THIS SUBCLASS
        """
        return True
# --------------------------------------------------------------------------------
class MockServiceWithLadder(MockService):
    def __init__(self, settings):
        MockService.__init__(self, settings)
        self.has_ladder = True
        self.calledLadderMockup = None

    def getLadder(self, game_id, currency_serial, user_serial):
        self.calledLadderMockup = user_serial
        return PacketPokerPlayerStats()

# --------------------------------------------------------------------------------
class PokerTableMoveTestCase(PokerTableTestCaseBase):
    def setUp(self, ServiceClass = MockServiceWithLadder):
        PokerTableTestCaseBase.setUp(self, ServiceClass = MockServiceWithLadder)

    # -------------------------------------------------------------------
    def test15_moveTo(self):
        """Make sure a player can move from one place to another"""
        player = self.createPlayer(1)
        player.reasonExpected = "MockMoveTest"

        otherTablePlayer = self.createPlayer(2, table=self.table2)

        expectPlayerDeferred = otherTablePlayer.waitFor(PACKET_POKER_PLAYER_ARRIVE)
        def checkReturnPacket(packet):
            self.assertEqual(packet.game_id, self.table2_value)
            self.assertEquals(self.service.calledLadderMockup, packet.serial)
            self.assertEquals(self.table2.timer_info.has_key('dealTimeout'), False)
        expectPlayerDeferred.addCallback(checkReturnPacket)

        self.table2.cancelDealTimeout()
        
        self.table_joined = None
        def checkJoin(table, reason):
            print table
            self.table_joined = table
        player.join = checkJoin
        
        self.service.movePlayer = lambda a,b,c: self.table.game.maxBuyIn()
        
        self.table.movePlayer([player], 1, self.table2.game.id, reason = "MockMoveTest")
        self.assertEquals(self.table_joined, self.table2)
        
        return expectPlayerDeferred


class PokerTableRejoinTestCase(PokerTableTestCaseBase):
    def setUp(self, ServiceClass = MockServiceWithLadder):
        PokerTableTestCaseBase.setUp(self, ServiceClass = MockServiceWithLadder)

    def test49_playerRejoinCheckAutoFlag(self):
        """
        See https://gna.org/bugs/?14797
        """
        player1 = self.createPlayer(1)
        player2 = self.createPlayer(2, clientClass=MockClientWithRealJoin)
        
        self.table.scheduleAutoDeal()
        d = player2.waitFor(PACKET_POKER_START)
        def quitPlayer(x):
            thisPlayer = self.table.game.serial2player[2]
            self.table.quitPlayer(player2, 2)
            self.assertTrue(thisPlayer.isAuto())
        def joinPlayer(x):
            self.assertTrue(self.table.joinPlayer(player2, 2))
            d = player2.waitFor(PACKET_POKER_PLAYER_ARRIVE)
            return d
        def checkAutoFlag(x):
            playerArrive = [p for p in player2.packets if p.type == PACKET_POKER_PLAYER_ARRIVE and p.serial == 2]
            self.assertEqual(len(playerArrive), 1)
            self.assertFalse(self.table.game.serial2player[2].isAuto())
            self.assertFalse(playerArrive[0].auto)
        d.addCallback(quitPlayer)
        d.addCallback(joinPlayer)
        d.addCallback(checkAutoFlag)
        return d

# --------------------------------------------------------------------------------
def Run():
    seed(time.time())
    loader = runner.TestLoader()
#    loader.methodPrefix = "test40"
#    os.environ['VERBOSE_T'] = '4'
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerAvatarCollectionTestCase))
    suite.addTest(loader.loadClass(PokerTableTestCase))
    suite.addTest(loader.loadClass(PokerTableTestCaseWithPredefinedDecksAndNoAutoDeal))
    suite.addTest(loader.loadClass(PokerTableTestCaseTransient))
    suite.addTest(loader.loadClass(PokerTableMoveTestCase))
    suite.addTest(loader.loadClass(PokerTableRejoinTestCase))
    return runner.TrialRunner(reporter.VerboseTextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)
# ------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-pokertable.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokertable.py' TESTS='coverage-reset test-pokertable.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-protocol
#!/usr/bin/python2.4
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)       2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2006       Mekensleep <licensing@mekensleep.com>
#                          24 rue vieille du temple 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  J.Jeannin <griim.work@gmail.com>
#  Bradley M. Kuhn <bkuhn@ebb.org>

import sys, os
sys.path.insert(0, "./..")
sys.path.insert(0, "..")

from tests.testmessages import silence_all_messages, search_output, clear_all_messages, get_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
verbose = 5
if verbose < 0: silence_all_messages()

from pokernetwork import protocol
from pokernetwork import protocol_number
from pokernetwork.version import Version

from twisted.trial import unittest, runner, reporter
from twisted.internet import reactor, defer

from time import time

protocol_version = Version(protocol_number)

#-----------------

class FakeFactory:
    """Factory for testing purpose"""
    def __init__(self, verbose):
        self.verbose = verbose

class FakeTransport:
    """Transport for testing purpose"""
    def __init__(self):
        self._loseConnection = False

    def write(self, data = ''):
        return True

    def loseConnection(self):
        self._loseConnection = True
        
class FakeTimer:
    """Timer for testing purpose"""
    def __init__(self):
        self._active = True

    def active(self):
        return self._active

    def cancel(self):
        self._active = False

class FakePacket:
    """Packet for testing purpose"""
    def __init__(self, time, id = None):
        self.time__ = time
        self.nodelay__ = None
        self.arg = time
        self.id = id

#-----------------

class QueueTestCase(unittest.TestCase):
    """Test case for class Queue"""

    def testQueueInit(self):
        """Testing class Queue init"""
        
        queue = protocol.Queue()
        assert queue.delay == 0 , "invalid delay (0 expected)"
        assert len(queue.packets) == 0 , "list packets not empty"

class UGAMEProtocolTestCase(unittest.TestCase):
    """Test case for class UGAMEProtocol"""

    def setUp(self):
        self.u = protocol.UGAMEProtocol()
        self.u.transport = FakeTransport()
        self.u.factory = FakeFactory(int(os.environ.get('VERBOSE_T', 6)))
        silence_all_messages()

    def fakeProcessQueuesDeferred(self, count = 1):
        global calledProcessQueuesCount
        calledProcessQueuesCount = 0
        self.soughtCount= count
        def mockProcessQueues():
            global calledProcessQueuesCount
            calledProcessQueuesCount += 1

        self.u._processQueues = mockProcessQueues

        def doneOk(mySelf):
            global calledProcessQueuesCount
            self.assertEquals(calledProcessQueuesCount, mySelf.soughtCount)
        d = defer.Deferred()
        d.addCallback(doneOk)
        # Note, if test fails, you'll get a reactor error.
        reactor.callLater(1, lambda: d.callback(self))

        return d


    def testUGAMEProtocolInit(self):
        """Testing class UGAMEProtocol init"""
        
        assert len(self.u._packet) == 0       , "list _packet not empty"
        assert self.u._packet_len  == 0       , "invalid _packet_len  (0 expected)"
        assert self.u._timer == None          , "invalid _timer (None expected)"
        assert self.u._packet2id(1) == 0      , "function _packet2id invalid"
        assert self.u._packet2front(2) == False , "function _packet2front invalid"
        assert len(self.u._queues) == 0       , "dictionnary _queues not empty"
        assert self.u._lagmax == 0            , "invalid _lagmax (0 expected)"
        assert self.u._lag == 0               , "invalid _lag (0 expected)"
        assert self.u._prefix == ""           , "invalid _prefix"
        assert self.u._blocked == False       , "invalid _blocked (False expected)"
        assert self.u.established == 0        , "invalid ugp.established (0 expected)"
        assert self.u._protocol_ok == False   , "invalid _protocol_ok (False expected)"
        assert self.u._poll == True                      , "invalid _poll (True expected)"
        assert self.u._poll_frequency == 0.01    , "invalid _poll_frequency (0.01 expected)"
        assert self.u._ping_delay == 5        , "invalid _ping_delay"

    def testSetPingDelay(self):
        """Testing setPingDelay"""        

        self.u.setPingDelay(10)
        assert self.u._ping_delay == 10       , "_ping_delay is not set correctly"

    def testGetPingDelay(self):
        """Testing getPingDelay"""        

        self.u.setPingDelay(8)
        assert self.u.getPingDelay() == 8     , "return value is not the one expected"

    def testGetLag(self):
        """Testing getLag"""

        assert self.u.getLag() == 0             , "return value is not the one expected"

    def testGetOrCreateQueue(self):
        """Testing getOrCreateQueue"""
        
        assert self.u._queues.has_key(0) == False , "queues already containing Key '0'"
        q1 = self.u.getOrCreateQueue(0)
        assert self.u._queues.has_key(0) == True  , "getOrCreateQueue does not have created queues"
        q2 = self.u.getOrCreateQueue(0)

        assert q1 == q2                           , "getOrCreateQueue overwrite queues"

    def testConnectionMade(self):
        """Testing connectionMade"""
        global writeCallCount
        writeCallCount = 0

        def mockTestSendVersion(data):
            global writeCallCount
            self.assertEquals(data, 'CGI %s.%s\n' % (protocol.PROTOCOL_MAJOR, 
                                                     protocol.PROTOCOL_MINOR))
            writeCallCount += 1
        self.u.transport.write = mockTestSendVersion

        self.u.connectionMade()
        self.assertEquals(writeCallCount, 1)
 
    def testConnectionLost(self):
        """Testing ConnectionLost"""
        silence_all_messages()
        clear_all_messages()
        self.u.established = 1
        self.u.connectionLost("testing")
        self.assertEquals(search_output("connectionLost: reason = testing"), True)
            
        assert self.u.established == 0

    def testConnectionLostWithProtocolOk(self):
        """Testing ConnectionLostWithProtocolOk"""
        silence_all_messages()
        clear_all_messages()
        self.u.established = 1
        self.u._protocol_ok = True
        self.u.connectionLost("another")
        self.assertEquals(search_output("connectionLost: reason = another"), True)
            
        assert self.u.established == 0
    
    def testHandleConnection(self):
        """Testing _handleConnection"""        
        clear_all_messages()
        # there is just a pass here in the implementation, there is really
        # nothing to be done to truly test it.
        self.assertEquals(self.u._handleConnection("..."), None)
        self.assertEquals(get_messages(), [])

    def testIgnoreIncomingData(self):
        """Testing ignoreIncomingData"""
        
        self.u.ignoreIncomingData()           
        self.u._timer = FakeTimer()
        self.u.ignoreIncomingData()
        assert self.u._timer._active == False

    def testHandleVersion(self):
        """Testing handleVersion"""

        assert self.u._protocol_ok == False        , "_protocol_ok : False expected"
        # Messages should be empty, protocol is not established
        clear_all_messages()
        self.u._handleVersion()
        self.assertEquals(get_messages(), [])
        
        assert self.u._protocol_ok == False        ,"_protocol_ok change unexpected"
        
        self.u._packet = list('\n')
        # Messages should be empty, protocol is not established
        clear_all_messages()
        self.u._handleVersion()
        self.assertEquals(get_messages(), [])
        assert self.u.transport._loseConnection == True , "loseConnection not called"

        self.u.transport = FakeTransport()      # transport re-init
        self.u._packet = list('CGI a.b\n')
        # Messages should be empty, protocol is not established
        clear_all_messages()
        self.u._handleVersion()
        self.assertEquals(get_messages(), [])
        assert self.u.transport._loseConnection == True , "loseConnection not called"

        self.u.transport = FakeTransport()      # transport re-init
        vers = Version(protocol_number)
        PROTOCOL_MAJOR = "%03d" % vers.major()
        PROTOCOL_MINOR = "%d%02d" % ( vers.medium(), vers.minor() )
        self.u._packet = list( 'CGI %s.%s \n' % (PROTOCOL_MAJOR, PROTOCOL_MINOR ))
        clear_all_messages()
        self.u._handleVersion()
        self.assertEquals(get_messages(), ["protocol established"])

        assert self.u._protocol_ok == True ,  "_protocol_ok value unexpected"

    def testProtocolEstablished(self):
        pass

    def testProtocolInvalid(self):
        pass
    
    def testHold(self):
        """Testing hold"""

        self.u.hold(-2,0)
        assert self.u._queues.has_key(0) == True  , "queue has not been created"
        assert self.u._queues[0].delay == -2  , "delay wrongly set"

        self.u.hold(-4)
        assert self.u._queues[0]. delay == -4 , "delay wrongly  set"

        self.u.hold(1)
        assert self.u._queues[0].delay > 0 , "delay wrongly set"

    def testBlock(self):
        """Testing block"""

        self.u._blocked = False
        self.u.block()
        assert self.u._blocked == True   ,   "block don't block..."

    def testUnblock(self):
        """Testing unblock"""

        self.u._blocked = True
        self.u.unblock()
        assert self.u._blocked == False  ,   "unblock don't unblock..."
 
    def testDiscardPackets(self):
        """Testing discardPackets"""
        
        self.u._queues[0] = protocol.Queue()
        self.u.discardPackets(0)
        assert not hasattr(self.u , '_queues[0]')  ,  "queue not deleted"
 
    def testCanHandlePacket(self):
        """Testing canHandlePackets"""

        assert self.u.canHandlePacket('') == (True,0)
    
    def testProcessQueues(self):
        """Testing _proccessQueues"""
        global triggerTimerCallCount
        triggerTimerCallCount = 0
        def mockTriggerTimer():
            global triggerTimerCallCount
            triggerTimerCallCount += 1
            
        self.u.triggerTimer = mockTriggerTimer
        self.u.canHandlePacket = lambda x : (False, time()+10)
        self.failIf(self.u._queues.has_key(0))
        self.u.getOrCreateQueue(0)
        self.failUnless(self.u._queues.has_key(0))

        self.u._lagmax = 10

        self.failIf(self.u._queues.has_key(1))
        self.u.getOrCreateQueue(1)
        self.failUnless(self.u._queues.has_key(1))
        self.u._queues[1].delay = time()+10
        oneArg = 0
        self.u._queues[1].packets.insert( 0, FakePacket(oneArg, "one") )
        self.u._queues[1].packets[0].nodelay__ = True

        self.failIf(self.u._queues.has_key(2))
        self.u.getOrCreateQueue(2)
        self.failUnless(self.u._queues.has_key(2))
        self.u._queues[2].delay = time()
        twoArg = time()
        self.u._queues[2].packets.insert( 0, FakePacket(twoArg, "two") )

        self.failIf(self.u._queues.has_key(3))
        self.u.getOrCreateQueue(3)
        self.failUnless(self.u._queues.has_key(3))
        self.u._queues[3].delay = time()+1
        threeArg = time() +10
        self.u._queues[3].packets.insert( 0, FakePacket(threeArg, "three") )

        # Ok, Test blocked first -- nothing happens
        clear_all_messages()
        self.u._blocked = True
        self.u._processQueues()
        k = self.u._queues.keys()
        self.assertEquals(triggerTimerCallCount,  1)

        k.sort()
        self.assertEquals(k, [ 0, 1, 2, 3 ])
        self.assertEquals(get_messages(), [])
        self.assertEquals(self.u._lag, 0)

        # Unblocked test, function fully runs
        triggerTimerCallCount = 0
        self.u._blocked = False

        global callCount
        callCount = 0
        def mockHandler(packet):
            global callCount
            callCount += 1
            self.assertEquals(packet.arg, oneArg)
            self.assertEquals(packet.id, 'one')
                
        self.u._handler = mockHandler

        startTime = time()
        self.u._processQueues()
        endTime = time()

        self.assertEquals(callCount, 1)
        self.failUnless(self.u._lag > startTime)
        self.failUnless(self.u._lag <= endTime)

        k = self.u._queues.keys()
        k.sort()
        self.assertEquals(k, [ 1, 2, 3 ])

        self.assertEquals(len(self.u._queues[1].packets), 0)
        self.assertEquals(len(self.u._queues[2].packets), 1)
        self.assertEquals(len(self.u._queues[3].packets), 1)
        self.assertEquals(triggerTimerCallCount,  1)

        self.assertEquals(len(get_messages()), 2)
        self.assertEquals(get_messages()[0], ' => queue 1 delay canceled because lag too high')
        self.assertEquals(get_messages()[1].find('seconds before handling the next packet in queue 3') > 0, True)

    def triggerTimer_expectNoCallLater(self, doneOk):
        def mockProcessQueue(): self.fail()
        self.u._processQueues = mockProcessQueue
        self._poll_frequency = 0.1
        self.u.triggerTimer()

        d = defer.Deferred()
        d.addCallback(doneOk)
        reactor.callLater(1, lambda: d.callback(self))
        return d

    def testTriggerTimer_alreadyHaveActiveTimer(self):
        """Testing triggerTimer when it already has an active timer
        """
        self.assertEquals(self.u._timer, None)
        class  MockTimer:
            def __init__(self): self.myID = "MOCK"
            def active(self): return True

        self.u._timer = MockTimer()

        def doneOk(mySelf):
            mySelf.assertEquals(mySelf.u._timer.myID, "MOCK")

        # Note that _poll is removed because it should never actually be
        # read and if it is, we know something has gone wrong with test.
        del self.u.__dict__['_poll']

        return self.triggerTimer_expectNoCallLater(doneOk)

    def testTriggerTimer_inactiveTimerNoPoll(self):
        """Testing triggerTimer when timer exists, is inactive, but not polling
        """
        self.assertEquals(self.u._timer, None)
        class  MockTimer:
            def __init__(self): self.myID = "MOCK2"
            def active(self): return False

        self.u._timer = MockTimer()

        def doneOk(mySelf):
            mySelf.assertEquals(mySelf.u._timer.myID, "MOCK2")

        self.u._poll = False

        return self.triggerTimer_expectNoCallLater(doneOk)

    def testTriggerTimer_noTimerPollingEmptyQueues(self):
        """Testing triggerTimer without timer, polling on, empty queue
        """
        self.assertEquals(self.u._timer, None)

        def doneOk(mySelf):
            mySelf.assertEquals(mySelf.u._timer, None)

        self.u._poll = True

        return self.triggerTimer_expectNoCallLater(doneOk)

    def testTriggerTimer_reactorIsCalled(self):
        """Testing triggerTimer when reactor is called
        """
        self.assertEquals(self.u._timer, None)
        self.u._poll = True
        self.u.getOrCreateQueue(0)

        global processQueueCalled
        processQueueCalled = 0
        def mockProcessQueue():
            global processQueueCalled
            processQueueCalled += 1
            
        self.u._processQueues = mockProcessQueue

        def doneOk(mySelf):
            global processQueueCalled
            self.assertEquals(processQueueCalled, 1)

        d = defer.Deferred()
        d.addCallback(doneOk)
        # Note, if test fails, you'll get a reactor error.
        reactor.callLater(1, lambda: d.callback(self))

        self.u.triggerTimer()

        return d

    def testPushPacket(self):
        """Testing pushPacket"""
        global triggerTimerCallCount
        triggerTimerCallCount = 0
        def mockTriggerTimer():
            global triggerTimerCallCount
            triggerTimerCallCount += 1
            
        self.u.triggerTimer = mockTriggerTimer
       
        self.u._packet2front = lambda x:  x <= 0

        self.u.pushPacket( FakePacket(1) );        
        self.u.pushPacket( FakePacket(0) );        
        
        assert len(self.u._queues[0].packets) == 2  , "packets not in list"
        assert self.u._queues[0].packets[0].arg <  self.u._queues[0].packets[1].arg  , "packet not set in front of the queue"
        self.assertEquals(triggerTimerCallCount, 2)

    def testHandleData(self):
        """Testing handleData"""
        fakeProcessQueuesDeferred = self.fakeProcessQueuesDeferred()

        self.u._expected_len = 3
        self.u._packet.append("\x00\x00\x03")
        self.u._packet_len = len("\x00\x00\x03")
        clear_all_messages()
        self.u.handleData() 
        self.assertEquals(get_messages(), ['(3 bytes) => type = NONE(0)'])

        self.u._poll = False
        self.u._packet.append("\x00\x00\x03")
        self.u._packet_len = len("\x00\x00\x03")
        clear_all_messages()
        self.u.handleData()
        self.assertEquals(get_messages(), ['(3 bytes) => type = NONE(0)'])

        self.u._packet.append("\xff\x00\x03")
        self.u._packet_len = len("\xff\x00\x03")
        clear_all_messages()
        self.u.handleData()
        self.assertEquals(get_messages(), [': unknown message received (id 255, length 3)\n', "known types are {0: 'NONE', 1: 'STRING', 2: 'INT', 3: 'ERROR', 4: 'ACK', 5: 'PING', 6: 'SERIAL', 7: 'QUIT', 8: 'AUTH_OK', 9: 'AUTH_REFUSED', 10: 'LOGIN', 11: 'AUTH_REQUEST', 12: 'LIST', 13: 'LOGOUT', 14: 'BOOTSTRAP', 15: 'PROTOCOL_ERROR', 16: 'MESSAGE', 50: 'POKER_SEATS', 51: 'POKER_ID', 52: 'POKER_MESSAGE', 53: 'ERROR', 54: 'POKER_POSITION', 55: 'POKER_INT', 56: 'POKER_BET', 57: 'POKER_FOLD', 58: 'POKER_STATE', 59: 'POKER_WIN', 60: 'POKER_CARDS', 61: 'POKER_PLAYER_CARDS', 62: 'POKER_BOARD_CARDS', 63: 'POKER_CHIPS', 64: 'POKER_PLAYER_CHIPS', 65: 'POKER_CHECK', 66: 'POKER_START', 67: 'POKER_IN_GAME', 68: 'POKER_CALL', 69: 'POKER_RAISE', 70: 'POKER_DEALER', 71: 'POKER_TABLE_JOIN', 72: 'POKER_TABLE_SELECT', 73: 'POKER_TABLE', 74: 'POKER_TABLE_LIST', 75: 'POKER_SIT', 76: 'POKER_TABLE_DESTROY', 77: 'POKER_TIMEOUT_WARNING', 78: 'POKER_TIMEOUT_NOTICE', 79: 'POKER_SEAT', 80: 'POKER_TABLE_MOVE', 81: 'POKER_PLAYER_LEAVE', 82: 'POKER_SIT_OUT', 83: 'POKER_TABLE_QUIT', 84: 'POKER_BUY_IN', 85: 'POKER_REBUY', 86: 'POKER_CHAT', 87: 'POKER_PLAYER_INFO', 88: 'POKER_PLAYER_ARRIVE', 89: 'POKER_HAND_SELECT', 90: 'POKER_HAND_LIST', 91: 'POKER_HAND_SELECT_ALL', 92: 'POKER_USER_INFO', 93: 'POKER_GET_USER_INFO', 94: 'POKER_ANTE', 95: 'POKER_BLIND', 96: 'POKER_WAIT_BIG_BLIND', 97: 'POKER_AUTO_BLIND_ANTE', 98: 'POKER_NOAUTO_BLIND_ANTE', 99: 'POKER_CANCELED', 100: 'POKER_BLIND_REQUEST', 101: 'POKER_ANTE_REQUEST', 102: 'POKER_AUTO_FOLD', 103: 'POKER_WAIT_FOR', 104: 'POKER_STREAM_MODE', 105: 'POKER_BATCH_MODE', 106: 'POKER_LOOK_CARDS', 107: 'POKER_TABLE_REQUEST_PLAYERS_LIST', 108: 'POKER_PLAYERS_LIST', 109: 'POKER_PERSONAL_INFO', 110: 'POKER_GET_PERSONAL_INFO', 111: 'POKER_TOURNEY_SELECT', 112: 'POKER_TOURNEY', 113: 'POKER_TOURNEY_INFO', 114: 'POKER_TOURNEY_LIST', 115: 'POKER_TOURNEY_REQUEST_PLAYERS_LIST', 116: 'POKER_TOURNEY_REGISTER', 117: 'POKER_TOURNEY_UNREGISTER', 118: 'POKER_TOURNEY_PLAYERS_LIST', 119: 'POKER_HAND_HISTORY', 120: 'POKER_SET_ACCOUNT', 121: 'POKER_CREATE_ACCOUNT', 122: 'POKER_PLAYER_SELF', 123: 'POKER_GET_PLAYER_INFO', 124: 'POKER_ROLES', 125: 'POKER_SET_ROLE', 126: 'POKER_READY_TO_PLAY', 127: 'POKER_PROCESSING_HAND', 128: 'POKER_MUCK_REQUEST', 129: 'POKER_AUTO_MUCK', 130: 'POKER_MUCK_ACCEPT', 131: 'POKER_MUCK_DENY', 132: 'POKER_CASH_IN', 133: 'POKER_CASH_OUT', 134: 'POKER_CASH_OUT_COMMIT', 135: 'POKER_CASH_QUERY', 136: 'POKER_RAKE', 137: 'POKER_TOURNEY_RANK', 138: 'POKER_PLAYER_IMAGE', 139: 'POKER_GET_PLAYER_IMAGE', 140: 'POKER_HAND_REPLAY', 141: 'POKER_GAME_MESSAGE', 142: 'POKER_EXPLAIN', 143: 'POKER_STATS_QUERY', 144: 'POKER_STATS', 145: 'POKER_BUY_IN_LIMITS', 146: 'POKER_MONITOR', 147: 'POKER_MONITOR_EVENT', 148: 'POKER_GET_TOURNEY_MANAGER', 149: 'POKER_TOURNEY_MANAGER', 151: 'POKER_GET_PLAYER_PLACES', 152: 'POKER_PLAYER_PLACES', 153: 'POKER_SET_LOCALE', 154: 'POKER_TABLE_TOURNEY_BREAK_BEGIN', 155: 'POKER_TABLE_TOURNEY_BREAK_DONE', 156: 'POKER_TOURNEY_START', 161: 'POKER_PLAYER_STATS', 164: 'POKER_TOURNEY_INFO', 165: 'POKER_TABLE_PICKER', 166: 'POKER_CREATE_TOURNEY', 167: 'POKER_LONG_POLL', 168: 'POKER_LONG_POLL_RETURN', 170: 'POKER_BEST_CARDS', 171: 'POKER_POT_CHIPS', 172: 'POKER_CLIENT_ACTION', 173: 'POKER_BET_LIMIT', 174: 'POKER_SIT_REQUEST', 175: 'POKER_PLAYER_NO_CARDS', 176: 'POKER_CHIPS_PLAYER2BET', 177: 'POKER_CHIPS_BET2POT', 178: 'POKER_CHIPS_POT2PLAYER', 179: 'POKER_CHIPS_POT_MERGE', 180: 'POKER_CHIPS_POT_RESET', 181: 'POKER_CHIPS_BET2PLAYER', 182: 'POKER_END_ROUND', 183: 'POKER_DISPLAY_NODE', 184: 'POKER_DEAL_CARDS', 185: 'POKER_CHAT_HISTORY', 186: 'POKER_DISPLAY_CARD', 187: 'POKER_SELF_IN_POSITION', 188: 'POKER_SELF_LOST_POSITION', 189: 'POKER_HIGHEST_BET_INCREASE', 190: 'POKER_PLAYER_WIN', 191: 'POKER_ANIMATION_PLAYER_NOISE', 192: 'POKER_ANIMATION_PLAYER_FOLD', 193: 'POKER_ANIMATION_PLAYER_BET', 194: 'POKER_ANIMATION_PLAYER_CHIPS', 195: 'POKER_ANIMATION_DEALER_CHANGE', 196: 'POKER_ANIMATION_DEALER_BUTTON', 197: 'POKER_BEGIN_ROUND', 198: 'POKER_CURRENT_GAMES', 199: 'POKER_END_ROUND_LAST', 200: 'POKER_PYTHON_ANIMATION', 201: 'POKER_SIT_OUT_NEXT_TURN', 202: 'POKER_RENDERER_STATE', 203: 'POKER_CHAT_WORD', 204: 'POKER_SHOWDOWN', 205: 'POKER_CLIENT_PLAYER_CHIPS', 206: 'POKER_INTERFACE_COMMAND', 207: 'POKER_PLAYER_ME_LOOK_CARDS', 208: 'POKER_PLAYER_ME_IN_FIRST_PERSON', 209: 'POKER_ALLIN_SHOWDOWN', 210: 'POKER_PLAYER_HAND_STRENGTH'} "])
        # trying with wrong packet
        self.u._packet.append("\xff\x00\x00")
        self.u._packet_len = len("\xff\x00\x00")
        clear_all_messages()
        self.u.handleData()
        # FIXME (maybe): I am not completely sure it's correct that we
        # should get absolutely no output when we send the "wrong packet".
        # I've asked Loic to take a look.
        self.assertEquals(get_messages(), [])
        return fakeProcessQueuesDeferred
        
    def testDataReceived(self):
        """Testing dataReceived"""
        global handledVersion
        global handledData
        handledData = handledVersion = 0

        def mockHandleVersion():
            global handledVersion
            handledVersion += 1

        def mockHandleData():
            global handledData
            handledData += 1

        self.u._handleVersion = mockHandleVersion
        self.u.handleData = mockHandleData

        self.assertEquals(self.u._packet, [])
        self.assertEquals(self.u._packet_len, 0)

        self.u.dataReceived("packet_1")

        self.assertEquals(self.u._packet, ['packet_1'])
        self.assertEquals(self.u._packet_len, 8)
        self.failIf(handledData > 0)
        self.failUnless(handledVersion == 1)
        self.assertEquals(self.u.established, 0)

        handledVersion = 0
        self.u.established = 1
        self.u.dataReceived("packet_2  ")

        self.assertEquals(self.u._packet, ['packet_1', 'packet_2  '])
        self.assertEquals(self.u._packet_len, 18)
        self.failIf(handledVersion > 0)
        self.failUnless(handledData == 1)
        
    def testForceError(self):
        """Testing error call"""
        clear_all_messages()
        self.u.error("testing this error")
        self.assertEquals(get_messages(), ["ERROR testing this error"])

    def testCoverDataWrite(self):
        """Testing data write"""
        clear_all_messages()
        tot = protocol.UGAMEProtocol._stats_write

        global calledWrite
        calledWrite = 0
        myData = "testing data"
        def mockTransportWrite(data):
            global calledWrite
            self.assertEquals(data, myData)
            calledWrite += 1
        self.u.transport.write = mockTransportWrite

        self.u.dataWrite(myData)

        self.assertEquals(tot + len(myData), protocol.UGAMEProtocol._stats_write)

        self.assertEquals(calledWrite, 1)
        self.assertEquals(get_messages(), [])

#------------------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
    # Comment in line below this when you wish to run just one test by
    # itself (changing prefix as needed).
#    loader.methodPrefix = "testProcess"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(QueueTestCase))
    suite.addTest(loader.loadClass(UGAMEProtocolTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#	tracebackFormat='verbose',
        tracebackFormat='default',
        ).run(suite)
# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-protocol.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/protocol.py' TESTS='coverage-reset test-protocol.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-proxy
#!/usr/bin/python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 2009 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Bradley M. Kuhn <bkuhn@ebb.org>
#
import sys, os, tempfile, shutil
sys.path.insert(0, "./..")
sys.path.insert(0, "..")

import time

from tests import testclock

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer, address

from pokernetwork.proxy import ConnectProtocol, Client, Connector

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages, search_output, clear_all_messages, get_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
silence_all_messages()
# ----------------------------------------------------------------
class MockTransport():
    def __init__(self, bufSize = None):
        self.bufferSize = bufSize
        self.writtenData = []
        self.proxyConnectDoneCallCount = 0
    def write(self, value):      self.writtenData.append(value)
    def _proxyConnectDone(self): self.proxyConnectDoneCallCount += 1
# ----------------------------------------------------------------
class ProxyConnectProtocolTestCase(unittest.TestCase):
    def test00_ConnectProtocol_init(self):
        cp = ConnectProtocol("myhost", "myport")
        self.assertEquals(cp.host, "myhost")
        self.assertEquals(cp.port, "myport")
        self.assertEquals(cp.buffer, "")
    # -------------------------------------------------------------------------
    def test01_ConnectProtocol_connectionMade(self):
        cp = ConnectProtocol("testhost", 3222)
        cp.transport = MockTransport(23)
        self.assertEquals(cp.transport.bufferSize, 23)
        self.assertEquals(cp.transport.writtenData, [])

        cp.connectionMade()
        self.assertEquals(cp.bufferSize, 23)
        self.assertEquals(cp.buffer, "")
        self.assertEquals(cp.transport.bufferSize, 1)
        self.assertEquals(cp.transport.writtenData,
                          ['CONNECT testhost:3222 HTTP/1.0\n\n'])
        self.assertEquals(cp.transport.proxyConnectDoneCallCount, 0)
    # -------------------------------------------------------------------------
    def test02_ConnectProtocol_dataReceived_noNewlinesThere(self):
        cp = ConnectProtocol("somewhere.example.org", 2723)
        cp.transport = MockTransport(99)
        self.assertEquals(cp.transport.bufferSize, 99)
        self.assertEquals(cp.transport.writtenData, [])

        cp.dataReceived("There are no newlines in this data\rbut has\rback-rs")
        self.failIf(hasattr(cp, 'bufferSize'),
                    "bufferSize not created by mere receive")
        self.assertEquals(cp.buffer,
                          "There are no newlines in this data\rbut has\rback-rs")
        self.assertEquals(cp.transport.bufferSize, 99)
        self.assertEquals(cp.transport.writtenData, [])
        self.assertEquals(cp.transport.proxyConnectDoneCallCount, 0)
    # -------------------------------------------------------------------------
    def test03_ConnectProtocol_dataReceived_newlinesThere_badString(self):
        cp = ConnectProtocol("somewhere.example.org", 2723)
        cp.transport = MockTransport(99)
        self.assertEquals(cp.transport.bufferSize, 99)
        self.assertEquals(cp.transport.writtenData, [])

        caughtIt = False
        try:
            cp.dataReceived("We got two newlines here\n\nBut we'll fail\rno HTTP")
            self.fail("previous line should have thrown exception")
        except Exception, e:
            self.assertEquals(e.__str__(), "We got two newlines here\n\nBut we'll failno HTTP")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")

        self.failIf(hasattr(cp, 'bufferSize'),
                    "bufferSize not created by mere receive")
        self.assertEquals(cp.buffer,
                          "We got two newlines here\n\nBut we'll fail\rno HTTP")
        self.assertEquals(cp.transport.bufferSize, 99)
        self.assertEquals(cp.transport.writtenData, [])
        self.assertEquals(cp.transport.proxyConnectDoneCallCount, 0)
    # -------------------------------------------------------------------------
    def test04_ConnectProtocol_dataReceived_newlinesThere_GoodHTTPString(self):
        cp = ConnectProtocol("another.example.org", 2222)
        cp.transport = MockTransport(26)
        self.assertEquals(cp.transport.bufferSize, 26)
        self.assertEquals(cp.transport.writtenData, [])

        cp.connectionMade()
        self.assertEquals(cp.bufferSize, 26)
        self.assertEquals(cp.buffer, "")
        self.assertEquals(cp.transport.bufferSize, 1)
        self.assertEquals(cp.transport.writtenData,
                          ['CONNECT another.example.org:2222 HTTP/1.0\n\n'])
        self.assertEquals(cp.transport.proxyConnectDoneCallCount, 0)

        cp.dataReceived("HT\rTP\r/9\r.9\r          266\r\r\r\r\n\r\r\n\r\r")

        self.assertEquals(cp.bufferSize, 26)
        self.assertEquals(cp.buffer, "HT\rTP\r/9\r.9\r          266\r\r\r\r\n\r\r\n\r\r")
        self.assertEquals(cp.bufferSize, cp.transport.bufferSize)
        self.assertEquals(cp.transport.proxyConnectDoneCallCount, 1)
        self.assertEquals(cp.transport.writtenData,
                          ['CONNECT another.example.org:2222 HTTP/1.0\n\n'])
    # -------------------------------------------------------------------------
    def test05_ConnectProtocol_dataReceived_HTTP10ConsideredHarmful(self):
        cp = ConnectProtocol("somewhere.example.org", 2723)
        cp.transport = MockTransport(99)
        self.assertEquals(cp.transport.bufferSize, 99)
        self.assertEquals(cp.transport.writtenData, [])

        caughtIt = False
        try:
            cp.dataReceived("HTTP/10.0 200\n\n")
            self.fail("previous line should have thrown exception")
        except Exception, e:
            self.assertEquals(e.__str__(), "HTTP/10.0 200\n\n")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an Exception")

        self.failIf(hasattr(cp, 'bufferSize'),
                    "bufferSize not created by mere receive")
        self.assertEquals(cp.buffer, "HTTP/10.0 200\n\n")
        self.assertEquals(cp.transport.bufferSize, 99)
        self.assertEquals(cp.transport.writtenData, [])
        self.assertEquals(cp.transport.proxyConnectDoneCallCount, 0)
# ----------------------------------------------------------------
class MockSocket():
    def getsockname(self):
        return ("mocksocket.example.org", 923)

from twisted.internet import ssl, tcp

class ProxyClientTestCase(unittest.TestCase):
    # -------------------------------------------------------------------------
    # setUp creates MockUp methods for pokernetwork.proxy.Client class.
    # Note that many of the tests.  
    def setUp(self):
        self.client = None
        self.saveMethods = {}

        def sslClientInit(clientSelf, host, port, bindAddress, contextFactory, connector, reactor):
            clientSelf.callCounts = {}
            for ss in ['startReading', 'makeConnection', 'startWriting',                       'startTLS', 'connectionDone', 'tcpConnectDone' ]:
                clientSelf.callCounts[ss] = 0

            clientSelf.addr = (host, port)
            clientSelf.socket = MockSocket()
            self.assertEquals(contextFactory, clientSelf.contextFactory)

        def sslClientStartReading(clientSelf):
            clientSelf.callCounts['startReading'] += 1

        def sslClientStartWriting(clientSelf):
            clientSelf.callCounts['startWriting'] += 1

        def sslClientStartTLS(clientSelf, contextFactory):
            clientSelf.callCounts['startTLS'] += 1
            self.assertEquals(clientSelf.contextFactory, contextFactory)

        def connectProtocolMakeConnection(connectionSelf, clientSelf):
            self.assertEquals(clientSelf, self.client)
            clientSelf.callCounts['makeConnection'] += 1

        def tcpClientConnectDone(clientSelf):
            self.assertEquals(clientSelf, self.client)
            clientSelf.callCounts['tcpConnectDone'] += 1

        self.saveMethods['sslClientInit'] = ssl.Client.__init__
        self.saveMethods['sslClientStartTLS'] = ssl.Client.startTLS
        self.saveMethods['sslClientStartWriting'] = ssl.Client.startWriting
        self.saveMethods['sslClientStartReading'] = ssl.Client.startReading
        self.saveMethods['cpMakeConnection'] = ConnectProtocol.makeConnection
        self.saveMethods['tcpClientConnectDone'] = tcp.Client._connectDone
        ssl.Client.__init__ = sslClientInit
        ssl.Client.startReading = sslClientStartReading
        ConnectProtocol.makeConnection = connectProtocolMakeConnection
        ssl.Client.startTLS = sslClientStartTLS
        ssl.Client.startWriting = sslClientStartWriting
        tcp.Client._connectDone = tcpClientConnectDone
    # -------------------------------------------------------------------------
    def tearDown(self):
        ssl.Client.__init__ = self.saveMethods['sslClientInit']
        ssl.Client.startReading = self.saveMethods['sslClientStartReading']
        ConnectProtocol.makeConnection = self.saveMethods['cpMakeConnection']
        ssl.Client.startTLS = self.saveMethods['sslClientStartTLS']
        ssl.Client.startWriting = self.saveMethods['sslClientStartWriting']
        tcp.Client._connectDone = self.saveMethods['tcpClientConnectDone']
    # -------------------------------------------------------------------------
    def test00_Client_init(self):
        self.client = Client("testhost", 7677, "bindaddr", "fakecontext", 
                             "fakeconnector", "fakeproxy")
        self.assertEquals(self.client.proxy, "fakeproxy")
        self.assertEquals(self.client.contextFactory, "fakecontext")
    # -------------------------------------------------------------------------
    def test01_Client_getHost_contextIsNone(self):
        self.client = Client("testhost", 7677, "bindaddr", None, 
                             "fakeconnector", "fakeproxy")
        host = self.client.getHost()
        self.assertEquals(host._bwHack, 'INET')
        self.assertEquals(host.host, 'mocksocket.example.org')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 923)
    # -------------------------------------------------------------------------
    def test02_Client_getHost_contextIsFalse(self):
        self.client = Client("testhost", 7677, "bindaddr", False, 
                             "fakeconnector", "fakeproxy")
        host = self.client.getHost()
        self.assertEquals(host._bwHack, 'INET')
        self.assertEquals(host.host, 'mocksocket.example.org')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 923)
    # -------------------------------------------------------------------------
    def test03_Client_getHost_contextIsString(self):
        self.client = Client("testhost", 7677, "bindaddr", "ContextISString", 
                             "fakeconnector", "fakeproxy")
        host = self.client.getHost()
        self.assertEquals(host._bwHack, 'SSL')
        self.assertEquals(host.host, 'mocksocket.example.org')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 923)
    # -------------------------------------------------------------------------
    def test04_Client_getHost_contextIsTrue(self):
        self.client = Client("testhost", 7677, "bindaddr", True,
                             "fakeconnector", "fakeproxy")
        host = self.client.getHost()
        self.assertEquals(host._bwHack, 'SSL')
        self.assertEquals(host.host, 'mocksocket.example.org')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 923)
    # -------------------------------------------------------------------------
    def test05_Client_getPeer_contextIsNone(self):
        self.client = Client("testhost", 7677, "bindaddr", None, 
                             "fakeconnector", "fakeproxy")
        host = self.client.getPeer()
        self.assertEquals(host._bwHack, 'INET')
        self.assertEquals(host.host, 'testhost')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 7677)
    # -------------------------------------------------------------------------
    def test06_Client_getPeer_contextIsFalse(self):
        self.client = Client("testhost", 7677, "bindaddr", False, 
                             "fakeconnector", "fakeproxy")
        host = self.client.getPeer()
        self.assertEquals(host._bwHack, 'INET')
        self.assertEquals(host.host, 'testhost')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 7677)
    # -------------------------------------------------------------------------
    def test07_Client_getPeer_contextIsString(self):
        self.client = Client("testhost", 7677, "bindaddr", "ContextISString", 
                             "fakeconnector", "fakeproxy")
        host = self.client.getPeer()
        self.assertEquals(host._bwHack, 'SSL')
        self.assertEquals(host.host, 'testhost')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 7677)
    # -------------------------------------------------------------------------
    def test08_Client_getPeer_contextIsTrue(self):
        self.client = Client("testhost", 7677, "bindaddr", True,
                             "fakeconnector", "fakeproxy")
        host = self.client.getPeer()
        self.assertEquals(host._bwHack, 'SSL')
        self.assertEquals(host.host, 'testhost')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 7677)
    # -------------------------------------------------------------------------
    def test09_Client_connectDone_usesProxy(self):
        self.client = Client("testhost", 7677, "bindaddr", True,
                             "fakeconnector", "fakeproxy")
        self.client.proxy = ("proxy.example.org", 215)
        host = self.client._connectDone()
        self.assertEquals(self.client.connected, 1)
        self.assertEquals(self.client.logstr, 'ConnectProtocol,client')

        for ss in self.client.callCounts.keys():
            val = 0
            if ss == 'startReading' or ss == 'makeConnection': val = 1
            self.assertEquals(self.client.callCounts[ss], val)
    # -------------------------------------------------------------------------
    def test09_Client_connectDone_usesProxy(self):
        self.client = Client("testhost", 7677, "bindaddr", True,
                             "fakeconnector", "fakeproxy")
        self.client.proxy = ("proxy.example.org", 215)
        host = self.client._connectDone()
        self.assertEquals(self.client.connected, 1)
        self.assertEquals(self.client.logstr, 'ConnectProtocol,client')

        for ss in self.client.callCounts.keys():
            val = 0
            if ss == 'startReading' or ss == 'makeConnection': val = 1
            self.assertEquals(self.client.callCounts[ss], val)

        self.assertEquals(self.client.protocol.host, "proxy.example.org")
        self.assertEquals(self.client.protocol.port, 215)
    # -------------------------------------------------------------------------
    def test10_Client_connectDone_noProxy_noContextFactory(self):
        self.client = Client("testhost", 7677, "bindaddr", None,
                             "fakeconnector", "fakeproxy")
        self.client.proxy = None
        host = self.client._connectDone()

        self.assertEquals(self.client.connected, 0)
        self.assertEquals(self.client.logstr, 'Uninitialized')
        self.assertEquals(self.client.protocol, None)

        for ss in self.client.callCounts.keys():
            val = 0
            if ss == 'tcpConnectDone': val = 1
            self.assertEquals(self.client.callCounts[ss], val)
    # -------------------------------------------------------------------------
    def test11_Client_connectDone_noProxy_withContextFactory(self):
        self.client = Client("testhost", 7677, "bindaddr", "FakeContextFactory",
                             "fakeconnector", "fakeproxy")
        self.client.proxy = None
        host = self.client._connectDone()

        self.assertEquals(self.client.connected, 0)
        self.assertEquals(self.client.logstr, 'Uninitialized')
        self.assertEquals(self.client.protocol, None)

        for ss in self.client.callCounts.keys():
            val = 0
            if ss == 'tcpConnectDone' or ss == 'startTLS' or ss == 'startWriting':
               val = 1
            self.assertEquals(self.client.callCounts[ss], val)
# ----------------------------------------------------------------
class ConnectorTestCase(unittest.TestCase):
    def setUp(self):
        self.connector = None
        self.saveMethods = {}

        def sslConnectorInit(conSelf, host, port, factory, contextFactory, timeout, bindAddr, reactor):
            self.assertEquals(conSelf.proxy, None)
            self.assertEquals(conSelf.host, host)
            self.assertEquals(conSelf.port, port)
            conSelf.bindAddress = bindAddr
            conSelf.contextFactory = contextFactory
            conSelf.reactor = reactor

        def sslClientInit(clientSelf, host, port, bindAddress, contextFactory, connector, reactor):
            self.assertEquals(contextFactory, clientSelf.contextFactory)
            self.assertEquals(contextFactory, self.connector.contextFactory)
            self.assertEquals(bindAddress, self.connector.bindAddress)
            self.assertEquals(reactor, self.connector.reactor)
            self.assertEquals(host, self.connector.host)
            self.assertEquals(port, self.connector.port)

        self.saveMethods['sslClientInit'] = ssl.Client.__init__
        ssl.Client.__init__ = sslClientInit
        self.saveMethods['sslConnectorInit'] = ssl.Connector.__init__
        ssl.Connector.__init__ = sslConnectorInit
    # -------------------------------------------------------------------------
    def tearDown(self):
        ssl.Client.__init__ = self.saveMethods['sslClientInit']
        ssl.Connector.__init__ = self.saveMethods['sslConnectorInit']
    # -------------------------------------------------------------------------
    def test00_connector_init(self):
        self.connector = Connector("fake.example.org", 1233, None,
                                   None, None, None)
    # -------------------------------------------------------------------------
    def test01_connector_setProxyHost_noColon(self):
        self.connector = Connector("fake.example.org", 1233, None,
                                   None, None, None)
        self.assertEquals(self.connector.proxy, None)
        caughtIt = False
        try:
            self.connector.setProxyHost("proxy.example.org")
        except IndexError, ie:
            self.assertEquals(ie.__str__(), "list index out of range")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an IndexError")
    # -------------------------------------------------------------------------
    def test02_connector_setProxyHost_colonOnRight(self):
        self.connector = Connector("fake.example.org", 1233, None,
                                   None, None, None)
        self.assertEquals(self.connector.proxy, None)
        caughtIt = False
        try:
            self.connector.setProxyHost("proxy.example.org:")
        except ValueError, ve:
            self.assertEquals(ve.__str__(),
                              "invalid literal for int() with base 10: ''")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an ValueError")
    # -------------------------------------------------------------------------
    def test03_connector_setProxyHost_portIsNotInt(self):
        self.connector = Connector("fake.example.org", 1233, None,
                                   None, None, None)
        self.assertEquals(self.connector.proxy, None)
        caughtIt = False
        try:
            self.connector.setProxyHost("proxy.example.org:my22port22")
        except ValueError, ve:
            self.assertEquals(ve.__str__(),
                        "invalid literal for int() with base 10: 'my22port22'")
            caughtIt = True
        self.failUnless(caughtIt, "Should have caught an ValueError")
    # -------------------------------------------------------------------------
    def test04_connector_setProxyHost_colonOnLeft(self):
        self.connector = Connector("fake.example.org", 1233, None,
                                   None, None, None)
        self.assertEquals(self.connector.proxy, None)

        self.connector.setProxyHost(":555")

        self.assertEquals(self.connector.proxy, ('', 555))
    # -------------------------------------------------------------------------
    def test05_connector_setProxyHost_fullyValid(self):
        self.connector = Connector("fake.example.org", 1233, None,
                                   None, None, None)
        self.assertEquals(self.connector.proxy, None)

        self.connector.setProxyHost("myproxy.example.org:274")

        self.assertEquals(self.connector.proxy, ('myproxy.example.org', 274))
    # -------------------------------------------------------------------------
    def test06_connector_makeTransport(self):
        self.connector = Connector("fake.example.org", 1233, None,
                                   "conextFactoryDummy", None, 7634)
        client = self.connector._makeTransport()
        # Note: other checks in the setUp() init.
        self.assertEquals(client.contextFactory, "conextFactoryDummy")
    # -------------------------------------------------------------------------
    def test07_connector_getDestination_contextIsNone(self):
        self.connector = Connector("fake.example.org", 1233, None,
                                   None, None, 7634)

        host = self.connector.getDestination()
        self.assertEquals(host._bwHack, 'INET')
        self.assertEquals(host.host, 'fake.example.org')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 1233)
    # -------------------------------------------------------------------------
    def test08_connector_getDestination_contextIsFalse(self):
        self.connector = Connector("fake.example.org", 1234, None,
                                   False, None, 7634)
        host = self.connector.getDestination()
        self.assertEquals(host._bwHack, 'INET')
        self.assertEquals(host.host, 'fake.example.org')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 1234)
    # -------------------------------------------------------------------------
    def test09_connector_getDestination_contextIsString(self):
        self.connector = Connector("myfake.example.org", 1235, None,
                                   "conextFactoryDummy", None, 7634)
        host = self.connector.getDestination()
        self.assertEquals(host._bwHack, 'SSL')
        self.assertEquals(host.host, 'myfake.example.org')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 1235)
    # -------------------------------------------------------------------------
    def test10_connector_getDestination_contextIsTrue(self):
        self.connector = Connector("afake.example.org", 1400, None,
                                   True, None, 7634)
        host = self.connector.getDestination()
        self.assertEquals(host._bwHack, 'SSL')
        self.assertEquals(host.host, 'afake.example.org')
        self.assertEquals(host.type, 'TCP')
        self.assertEquals(host.port, 1400)
# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test_trynow"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(ProxyConnectProtocolTestCase))
    suite.addTest(loader.loadClass(ProxyClientTestCase))
    suite.addTest(loader.loadClass(ConnectorTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#       reporter.TextReporter,
#	tracebackFormat='verbose',
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)


# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-proxy.py ) ; ( cd ../tests ; make VERBOSE_T=-1 COVERAGE_FILES='../pokernetwork/proxy.py' TESTS='coverage-reset test-proxy.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-proxyfilter
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2008, 2009 Loic Dachary    <loic@dachary.org>
# Copyright (C) 2009 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import simplejson

from twisted.trial import unittest, runner, reporter
from twisted.internet import defer, reactor
from twisted.application import internet
from twisted.python import failure
from twisted.python.runtime import seconds
import twisted.internet.base
twisted.internet.base.DelayedCall.debug = True

from twisted.web import client, http

from tests import testmessages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: testmessages.silence_all_messages()

from tests import testclock

from pokernetwork import pokermemcache
from pokernetwork import pokersite
from pokernetwork import pokernetworkconfig
from pokernetwork import pokerservice
from pokernetwork import proxyfilter
from pokernetwork.pokerpackets import *

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19481" />
  <resthost host="127.0.0.1" port="19481" path="/POKER_REST" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

settings_xml_proxy = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <listen tcp="19480" />

  <rest_filter>.././../pokernetwork/proxyfilter.py</rest_filter>

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}
class ProxyTestCase(unittest.TestCase):
      def destroyDb(self, arg = None):
            if len("") > 0:
                  os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
            else:
                  os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")
      # --------------------------------------------------------------
      def initServer(self):
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml_server)
            self.server_service = pokerservice.PokerService(settings)
            self.server_service.disconnectAll = lambda: True
            self.server_service.startService()
            self.server_site = pokersite.PokerSite(settings, pokerservice.PokerRestTree(self.server_service))
            self.server_port = reactor.listenTCP(19481, self.server_site, interface="127.0.0.1")
      # --------------------------------------------------------------
      def initProxy(self):
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml_proxy)
            self.proxy_service = pokerservice.PokerService(settings)
            self.proxy_service.disconnectAll = lambda: True
            self.proxy_service.startService()
            self.proxy_site = pokersite.PokerSite(settings, pokerservice.PokerRestTree(self.proxy_service))
            self.proxy_port = reactor.listenTCP(19480, self.proxy_site, interface="127.0.0.1")
      # --------------------------------------------------------------
      def setUp(self):
            testclock._seconds_reset()
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            pokermemcache.memcache_singleton = {}
            self.destroyDb()
            self.initServer()
            self.initProxy()
      # --------------------------------------------------------------
      def tearDownServer(self):
            self.server_site.stopFactory()
            d = self.server_service.stopService()
            d.addCallback(lambda x: self.server_port.stopListening())
            return d
      # --------------------------------------------------------------
      def tearDownProxy(self):
            self.proxy_site.stopFactory()
            d = self.proxy_service.stopService()
            d.addCallback(lambda x: self.proxy_port.stopListening())
            return d
      # --------------------------------------------------------------
      def tearDown(self):
            d = defer.DeferredList((
                  self.tearDownServer(),
                  self.tearDownProxy()
                  ))
            d.addCallback(self.destroyDb)
            d.addCallback(lambda x: reactor.disconnectAll())
            return d
      # --------------------------------------------------------------
      def test01_ping_proxy(self):
            """
            Ping to the proxy.
            """
            d = client.getPage("http://127.0.0.1:19480/POKER_REST",
                               postdata = '{"type": "PacketPing"}')
            def checkPing(result):
                  self.assertEqual('[]', str(result))
            d.addCallback(checkPing)
            return d
      # --------------------------------------------------------------
      def test02_ping_server(self):
            """
            Ping to the server.
            """
            d = client.getPage("http://127.0.0.1:19481/POKER_REST",
                               postdata = '{"type": "PacketPing"}')
            def checkPing(result):
                  self.assertEqual('[]', str(result))
            d.addCallback(checkPing)
            return d
      # --------------------------------------------------------------
      def test03_listTables(self):
            """
            Select all tables. The list obtained from the proxy contains the tables
            created by the server.
            """
            d = client.getPage("http://127.0.0.1:19480/POKER_REST",
                               postdata = '{"type":"PacketPokerTableSelect"}')
            def checkTables(result):
                  packets = simplejson.JSONDecoder().decode(result)
                  self.assertEqual('PacketPokerTableList', packets[0]['type'])
                  tables = packets[0]['packets']
                  self.assertEqual('Table1', tables[0]['name'])
            d.addCallback(checkTables)
            return d
      # --------------------------------------------------------------
      def test04_tableJoin(self):
            """
            Join a table thru a proxy.
            """
            d = client.getPage("http://127.0.0.1:19480/POKER_REST",
                               postdata = '{"type":"PacketPokerTableJoin","game_id":1}')
            def checkTable(result):
                  packets = simplejson.JSONDecoder().decode(result)
                  self.assertEqual('PacketPokerTable', packets[0]['type'])
                  self.assertEqual('Table1', packets[0]['name'])
            d.addCallback(checkTable)
            return d
      # --------------------------------------------------------------
      def test05_connectionrefused(self):
            """
            Create a route that leads to a non-existent server.
            """
            db = self.proxy_service.db
            db.db.query("INSERT INTO route VALUES (6, 0, 0, 60)")
            db.db.query("INSERT INTO resthost VALUES (60, 'fake', '127.0.0.1', 6666, '/fail')")
            d = client.getPage("http://127.0.0.1:19480/POKER_REST",
                               postdata = '{"type":"PacketPokerTableJoin","game_id":6}')
            def checkTable(result):
                  self.assertSubstring('Connection was refused by other side', result.value.response)
            d.addBoth(checkTable)
            return d
      # --------------------------------------------------------------
      def test06_tableSeat_auth(self):
            """
            Join a table thru a proxy, using an authenticated session
            """
            info = self.server_service.auth('user1', 'password1', PacketPokerRoles.PLAY)
            serial = info[0][0]
            self.proxy_site.memcache.set('auth', str(serial))
            #
            # Join table
            #
            d = client.getPage("http://127.0.0.1:19480/POKER_REST?uid=uid&auth=auth",
                               postdata = '{"type":"PacketPokerTableJoin","game_id":1,"serial":' + str(serial) + '}')
            def checkTable(result):
                  packets = simplejson.JSONDecoder().decode(result)
                  self.assertEqual('PacketPokerTable', packets[0]['type'])
                  self.assertEqual('Table1', packets[0]['name'])
                  return result
            d.addCallback(checkTable)
            #
            # Get a seat
            #
            def seat(result):
                  d1 = client.getPage("http://127.0.0.1:19480/POKER_REST?uid=uid&auth=auth",
                                     postdata = '{"type":"PacketPokerSeat","game_id":1,"serial":' + str(serial) + '}')
                  def checkSeat(result):
                        self.assertSubstring('PlayerArrive', result)
                        return True
                  d1.addCallback(checkSeat)
                  return d1
            d.addCallback(seat)
            return d
      # --------------------------------------------------------------
      def test07_tourneyRegister(self):
            """
            Register to a tourney thru a proxy, using an authenticated session
            """
            #
            # Create tourney
            #
            db = self.server_service.db
            cursor = db.cursor()
            cursor.execute("INSERT INTO tourneys_schedule (resthost_serial, active, start_time) VALUES (%s, 'y', %s)", ( self.server_service.resthost_serial, seconds() + 36000))
            schedule_serial = cursor.lastrowid
            self.server_service.updateTourneysSchedule()
            cursor.execute("SELECT serial FROM tourneys WHERE schedule_serial = %s", schedule_serial)
            tourney_serial = cursor.fetchone()[0]
            cursor.close()
            self.assertEqual(True, self.server_service.tourneys.has_key(tourney_serial))
            #
            # Create user
            #

            info = self.server_service.auth('user1', 'password1', PacketPokerRoles.PLAY)
            serial = info[0][0]
            self.proxy_site.memcache.set('auth', str(serial))
            #
            # Register tourney
            #
            d = client.getPage("http://127.0.0.1:19480/POKER_REST?uid=uid&auth=auth",
                               postdata = '{"type":"PacketPokerTourneyRegister","game_id":' + str(tourney_serial) + ',"serial":' + str(serial) + '}')
            def checkTable(result):
                  packets = simplejson.JSONDecoder().decode(result)
                  self.assertEqual('PacketPokerTourneyRegister', packets[0]['type'])
                  self.assertEqual(tourney_serial, packets[0]['game_id'])
                  return result
            d.addCallback(checkTable)
            return d
      # --------------------------------------------------------------
      def test08_tableSeat_relogin(self):
            """
            Join a table thru a proxy, using an anonymous session that becomes an
            authenticated session
            """
            self.proxy_site.memcache.set('auth', '0')
            #
            # Join table
            #
            d = client.getPage("http://127.0.0.1:19480/POKER_REST?uid=uid&auth=auth",
                               postdata = '{"type":"PacketPokerTableJoin","game_id":1}')
            def checkTable(result):
                  packets = simplejson.JSONDecoder().decode(result)
                  self.assertEqual('PacketPokerTable', packets[0]['type'])
                  self.assertEqual('Table1', packets[0]['name'])
                  return result
            d.addCallback(checkTable)
            #
            # Login
            #
            def login(result):
                  d3 = client.getPage("http://127.0.0.1:19480/POKER_REST?uid=uid&auth=auth",
                                     postdata = '{"type":"PacketLogin","user":"user1","password":"password"}')
                  def checkLogin(result):
                        global serial
                        packets = simplejson.JSONDecoder().decode(result)
                        serial = packets[1]['serial']
                        return True
                  d3.addCallback(checkLogin)
                  return d3
            d.addCallback(login)
            #
            # Get a seat
            #
            def seat(result):
                  global serial
                  d1 = client.getPage("http://127.0.0.1:19480/POKER_REST?uid=uid&auth=auth",
                                     postdata = '{"type":"PacketPokerSeat","game_id":1,"serial":' + str(serial) + '}')
                  def checkSeat(result):
                        self.assertSubstring('PlayerArrive', result)
                        return True
                  d1.addCallback(checkSeat)
                  return d1
            d.addCallback(seat)
            return d
      # --------------------------------------------------------------
      def test09_pokerPoll(self):
            """
            """
            d = client.getPage("http://127.0.0.1:19480/POKER_REST",
                               postdata = '{"type":"PacketPokerPoll","game_id":1}')
            def checkTable(result):
                  packets = simplejson.JSONDecoder().decode(result)
                  self.assertEqual(0, len(packets))
            d.addCallback(checkTable)
            return d
      # --------------------------------------------------------------
      def test10_error500(self):
            """
            """
            def error500(game_id):
                  raise UserWarning, "%d fail" % game_id
            self.server_service.getTable = error500
            d = client.getPage("http://127.0.0.1:19480/POKER_REST",
                               postdata = '{"type":"PacketPokerTableJoin","game_id":1}')
            def checkError(result):
                  self.assertSubstring('500', str(result))
                  return True
            d.addErrback(checkError)
            return d
################################################################################
class ProxyFilterTestCase(unittest.TestCase):
      # --------------------------------------------------------------
      def test01_rest_filter_finished_request(self):
            """
            proxyfilter.rest_filter should ignore finished request
            """
            class Transport:
                  def write(self, data):
                        pass
            class Channel:
                  transport = Transport()
                  def requestDone(self, request):
                        pass
            class Service:
                  verbose = 6
                  def packet2resthost(self, packet):
                        return (None, None, None)
            class Resource:
                  service = Service()
            class Site:
                  resource = Resource()
            class Packet:
                  pass
            r = pokersite.Request(Channel(), True)
            input = '{"type": "PacketPing"}'
            r.gotLength(len(input))
            r.handleContentChunk(input)
            r.setResponseCode(http.OK)
            r.write("FINISHED")
            r.finish()
            r.noLongerQueued()
            proxyfilter.rest_filter(Site(), r, Packet())
      # --------------------------------------------------------------
      def test02_forceInitCoverHeaderReplace(self):
            from pokernetwork.proxyfilter import ProxyClient

            pc = ProxyClient("COMMAND", "REST", "VERSION",
                             { 'proxy-connection' : 'ThisWillBeGone',
                               'cookie' : 'ThisWillStay'}, "DATA", "FATHER")
            self.assertEquals(pc.father, "FATHER")
            self.assertEquals(pc.command, "COMMAND")
            self.assertEquals(pc.rest, "REST")
            self.assertEquals(pc.headers, {'cookie' : 'ThisWillStay',
                                           'connection' : 'close'})
            self.assertEquals(pc.data, "DATA")
      # --------------------------------------------------------------
      def test03_checkbadReason(self):
            class MockReason():
                  def check(mrS, reason): return False
            class MockDeferred():
                  def __init__(mdS):
                        mdS.errbackCount = 0
                        mdS.called = False
                  def errback(mdS, reason):
                        mdS.errbackCount += 1
                        self.failUnless(isinstance(reason, MockReason))

            from pokernetwork.proxyfilter import ProxyClientFactory

            pcf = ProxyClientFactory("command", "rest", "version", "headers", "data", "father",
                                     "verbose", "destination")

            pcf.deferred = MockDeferred()
            pcf.clientConnectionLost(None, MockReason())

            self.assertEquals(pcf.deferred.errbackCount, 1)
################################################################################
def Run():
      loader = runner.TestLoader()
#      loader.methodPrefix = "test06"
      suite = loader.suiteFactory()
      suite.addTest(loader.loadClass(ProxyTestCase))
      suite.addTest(loader.loadClass(ProxyFilterTestCase))
      return runner.TrialRunner(
            reporter.VerboseTextReporter,
            tracebackFormat='default',
#            logfile = '-',
            ).run(suite)

if __name__ == '__main__':
      if Run().wasSuccessful():
            sys.exit(0)
      else:
            sys.exit(1)
################################################################################
# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-proxyfilter.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/proxyfilter.py' VERBOSE_T=-1 TESTS='coverage-reset test-proxyfilter.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-servercrash
#!/usr/bin/python
# -*- py-indent-offset: 4; coding: iso-8859-1; mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2006 Mekensleep <licensing@mekensleep.com>
#                    24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import libxml2

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer, error
from twisted.python import failure

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from twisted.python.runtime import seconds

from pokernetwork import pokerservice
from pokernetwork import pokernetworkconfig
from pokernetwork.pokerdatabase import PokerDatabase

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="3" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="4" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="4" currency_serial="1" />

  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

class PokerCrashTestCase(unittest.TestCase):

    def destroyDb(self, arg = None):
        os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    def setUpServer(self):
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml_server, len(settings_xml_server))
        settings.header = settings.doc.xpathNewContext()
        #
        # Setup database
        #
        self.db = PokerDatabase(settings)
        #
        # Setup server
        #
        self.service = pokerservice.PokerService(settings)
        self.service.verbose = 6

    # -------------------------------------------------
    def setUp(self):
        self.destroyDb()
        self.setUpServer()

    def tearDown(self):
        self.db.close()
        return self.service.stopService()

    def test01_cleanupCrashedTables(self):
        cursor = self.db.cursor()
        #
        # Although the name is not in the configuration file (settings),
        # it has a matching resthost_serial and is cleanedup
        #
        cursor.execute('INSERT INTO pokertables (serial, name, variant, betting_structure, currency_serial) VALUES (142, "one", "holdem", "2-4", 1)')
        cursor.execute('INSERT INTO user2table (user_serial, table_serial, money, bet) VALUES (1000, 142, 10, 1)')
        cursor.execute("INSERT INTO users (serial, created, name) VALUES (1000, 0, 'testuser')")
        cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount) VALUES (1000, 1, 0)")
        #
        # resthost_serial does not match, the records are left untouched
        #
        cursor.execute('INSERT INTO pokertables (serial, name, variant, betting_structure, currency_serial, resthost_serial) VALUES (202, "two", "holdem", "2-4", 1, 10)')
        cursor.execute('INSERT INTO user2table (user_serial, table_serial, money, bet) VALUES (1000, 202, 10, 1)')
        #
        # Table1 is in the configuration file and cleaned up even though
        # resthost_serial does not match
        #
        cursor.execute('INSERT INTO pokertables (serial, name, variant, betting_structure, currency_serial, resthost_serial) VALUES (303, "Table1", "holdem", "2-4", 1, 44)')
        self.service.startService()
        cursor.execute("SELECT user_serial,table_serial FROM user2table")
        self.assertEqual(1, cursor.rowcount)
        self.assertEqual((1000, 202), cursor.fetchone())
        cursor.execute("SELECT serial FROM pokertables")
        self.assertEqual((202,), cursor.fetchone())
        cursor.execute("SELECT amount FROM user2money")
        self.assertEqual(11, cursor.fetchone()[0])
        cursor.close()

    def test02_cleanupTourneys_refund(self):
        tourney_serial = '10'
        user_serial = '200'
        buy_in = '300'
        currency_serial = '44'
        cursor = self.db.cursor()
        cursor.execute('INSERT INTO tourneys (serial,name,buy_in,currency_serial) VALUES (%s, "one", %s, %s)', ( tourney_serial, buy_in, currency_serial ))
        cursor.execute('INSERT INTO user2tourney (user_serial,currency_serial,tourney_serial) VALUES (%s,1,%s)', ( user_serial, tourney_serial ))
        cursor.execute('INSERT INTO user2money (user_serial,currency_serial) VALUES (%s,%s)', ( user_serial, currency_serial ))
        cursor.execute('SELECT * FROM tourneys WHERE serial = ' + tourney_serial)
        self.assertEqual(1, cursor.rowcount)
        cursor.execute('SELECT amount FROM user2money WHERE user_serial = %s AND currency_serial = %s', ( user_serial, currency_serial ))
        self.assertEqual((0,), cursor.fetchone())
        self.service.startService()
        cursor.execute('SELECT * FROM tourneys WHERE serial = ' + tourney_serial)
        self.assertEqual(0, cursor.rowcount)
        cursor.execute('SELECT amount FROM user2money WHERE user_serial = %s AND currency_serial = %s', ( user_serial, currency_serial ))
        self.assertEqual((300,), cursor.fetchone())
        cursor.close()

    def test02_cleanupTourneys_restore(self):
        regular_tourney_serial = '10'
        sng_tourney_serial = '40'
        user_serial = '200'
        cursor = self.db.cursor()
        cursor.execute("DELETE FROM tourneys_schedule")
        #
        # Sit and go in 'registering' state is trashed
        #
        cursor.execute('INSERT INTO tourneys (serial,name) VALUES (%s, "one")', sng_tourney_serial)
        cursor.execute('INSERT INTO user2tourney (user_serial,currency_serial,tourney_serial) VALUES (%s,1,%s)', ( user_serial, sng_tourney_serial ))
        cursor.execute('SELECT * FROM tourneys WHERE serial = ' + sng_tourney_serial)
        self.assertEqual(1, cursor.rowcount)
        #
        # Regular in 'registering' state is kept
        #
        cursor.execute('INSERT INTO tourneys (serial,name,sit_n_go,start_time) VALUES (%s, "one", "n", %s)', ( regular_tourney_serial, seconds() + 2000))
        cursor.execute('INSERT INTO user2tourney (user_serial,currency_serial,tourney_serial) VALUES (%s,1,%s)', ( user_serial, regular_tourney_serial ))
        cursor.execute('SELECT * FROM tourneys WHERE serial = ' + regular_tourney_serial)
        self.assertEqual(1, cursor.rowcount)
        #
        # Run cleanupTourneys as a side effect
        #
        self.service.startService()
        #
        # Sanity checks
        #
        self.assertEqual([int(regular_tourney_serial)], self.service.tourneys.keys())
        cursor.execute('SELECT * FROM user2tourney WHERE tourney_serial = %s', regular_tourney_serial)
        self.assertEqual(1, cursor.rowcount)
        cursor.execute('SELECT * FROM user2tourney WHERE tourney_serial = %s', sng_tourney_serial)
        self.assertEqual(0, cursor.rowcount)
        cursor.execute('SELECT * FROM user2tourney')
        self.assertEqual(1, cursor.rowcount)
        cursor.execute('SELECT * FROM tourneys')
        self.assertEqual(1, cursor.rowcount)
        cursor.close()

# -----------------------------------------------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "test09"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(PokerCrashTestCase))
    return runner.TrialRunner(reporter.TextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# -----------------------------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-servercrash.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokertable.py ../pokernetwork/pokerservice.py  ../pokernetwork/pokerserver.py' TESTS='coverage-reset test-servercrash.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-sessionproxyfilter
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2008, 2009 Loic Dachary    <loic@dachary.org>
# Copyright (C) 2009 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2009 Johan Euphrosine <proppy@aminche.com>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import simplejson

from twisted.trial import unittest, runner, reporter
from twisted.internet import defer, reactor
from twisted.application import internet
from twisted.python import failure
from twisted.python.runtime import seconds
import twisted.internet.base
twisted.internet.base.DelayedCall.debug = True

from twisted.web import client, http

from tests import testmessages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: testmessages.silence_all_messages()

from tests import testclock

from pokernetwork import pokermemcache
from pokernetwork import pokersite
from pokernetwork import pokernetworkconfig
from pokernetwork import pokerservice
from pokernetwork import sessionproxyfilter
from pokernetwork.pokerpackets import *
from pokernetwork.pokerrestclient import PokerRestClient
PokerRestClient.DEFAULT_LONG_POLL_FREQUENCY = -1
import time

settings_xml_server = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19482" />
  <resthost host="127.0.0.1" port="19482" path="/POKER_REST" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

settings_xml_explain = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <listen tcp="19481" />
  <resthost host="127.0.0.1" port="19481" path="/POKER_REST" name="explain1" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

settings_xml_proxy = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="20" round="0" position="0" showdown="0" autodeal_max="1" finish="0" messages="60" />

  <listen tcp="19480" />

  <rest_filter>.././../pokernetwork/sessionproxyfilter.py</rest_filter>

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}
class SessionProxyFilterTestCase(unittest.TestCase):
      def destroyDb(self, arg = None):
            if len("") > 0:
                  os.system("/usr/bin/mysql -u root --password='' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
            else:
                  os.system("/usr/bin/mysql -u root -e 'DROP DATABASE IF EXISTS pokernetworktest'")
      # --------------------------------------------------------------
      def initServer(self):
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml_server)
            self.server_service = pokerservice.PokerService(settings)
            self.server_service.disconnectAll = lambda: True
            self.server_service.startService()
            self.server_site = pokersite.PokerSite(settings, pokerservice.PokerRestTree(self.server_service))
            self.server_port = reactor.listenTCP(19482, self.server_site, interface="127.0.0.1")
      # --------------------------------------------------------------
      def initExplain(self):
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml_explain)
            self.explain_service = pokerservice.PokerService(settings)
            self.explain_service.disconnectAll = lambda: True
            self.explain_service.startService()
            self.explain_site = pokersite.PokerSite(settings, pokerservice.PokerRestTree(self.explain_service))
            self.explain_port = reactor.listenTCP(19481, self.explain_site, interface="127.0.0.1")
      # --------------------------------------------------------------
      def initProxy(self):
            settings = pokernetworkconfig.Config([])
            settings.loadFromString(settings_xml_proxy)
            self.proxy_service = pokerservice.PokerService(settings)
            self.proxy_service.disconnectAll = lambda: True
            self.proxy_service.startService()
            self.proxy_site = pokersite.PokerSite(settings, pokerservice.PokerRestTree(self.proxy_service))
            self.proxy_port = reactor.listenTCP(19480, self.proxy_site, interface="127.0.0.1")
      # --------------------------------------------------------------
      def setUp(self):
            testclock._seconds_reset()
            pokermemcache.memcache = pokermemcache.MemcacheMockup
            pokermemcache.memcache_singleton = {}
            pokermemcache.memcache_singleton_expiration = {}
            pokermemcache.memcache_singleton_log = []
            self.destroyDb()
            self.initServer()
            self.initExplain()
            self.initProxy()
      # --------------------------------------------------------------
      def tearDownServer(self):
            self.server_site.stopFactory()
            d = self.server_service.stopService()
            d.addCallback(lambda x: self.server_port.stopListening())
            return d
      # --------------------------------------------------------------
      def tearDownExplain(self):
            self.proxy_site.stopFactory()
            d = self.explain_service.stopService()
            d.addCallback(lambda x: self.explain_port.stopListening())
            return d
      # --------------------------------------------------------------
      def tearDownProxy(self):
            self.proxy_site.stopFactory()
            d = self.proxy_service.stopService()
            d.addCallback(lambda x: self.proxy_port.stopListening())
            return d
      # --------------------------------------------------------------
      def tearDown(self):
            d = defer.DeferredList((
                  self.tearDownServer(),
                  self.tearDownExplain(),
                  self.tearDownProxy()
                  ))
            d.addCallback(self.destroyDb)
            d.addCallback(lambda x: reactor.disconnectAll())
            return d
      # --------------------------------------------------------------
      def test01_ping_proxy(self):
            """
            Ping to the proxy.
            """
            d = client.getPage("http://127.0.0.1:19480/POKER_REST?uid=1bebebaffe&auth=deadbeef",
                               postdata = '{"type": "PacketPing"}')
            def checkPing(result):
                  self.assertEqual('[]', str(result))
            d.addCallback(checkPing)
            return d
      # --------------------------------------------------------------
      def test02_tableJoin(self):
            """
            Join a table thru a proxy.
            """
            uid = '1bebebaffe'
            session = 'deadbeef'
            resthost = ('127.0.0.1', 19481, '/POKER_REST')
            self.proxy_site.memcache.set(uid, resthost)
            d = client.getPage("http://127.0.0.1:19480/POKER_REST?uid=%s&auth=%s" % (uid, session),
                               postdata = '{"type":"PacketPokerTableJoin","game_id":1}')
            def checkTable(result):
                  packets = simplejson.JSONDecoder().decode(result)
                  self.assertEqual('PacketPokerTable', packets[0]['type'])
                  self.assertEqual('Table1', packets[0]['name'])
                  self.assertEqual(resthost, self.proxy_site.memcache.get(uid))
                  set_uid_log = [v for (l, (k, v, t)) in self.proxy_site.memcache.log if k == uid]
                  self.assertFalse(('127.0.0.1', 19482, '/POKER_REST') in set_uid_log)
            d.addCallback(checkTable)
            return d
      # --------------------------------------------------------------
      def test03_tableJoinNoRestHostExplain(self):
            """
            Join a table thru an explain server without reshost being set for the session.
            """
            uid = '1bebebaffe'
            session = 'deadbeef'
            resthost = ('127.0.0.1', 19481, '/POKER_REST')
            d = client.getPage("http://127.0.0.1:19481/POKER_REST?uid=%s&auth=%s" % (uid, session),
                               postdata = '{"type":"PacketPokerTableJoin","game_id":1}')
            def checkTable(result):
                  packets = simplejson.JSONDecoder().decode(result)
                  self.assertEqual('PacketPokerTable', packets[0]['type'])
                  self.assertEqual('Table1', packets[0]['name'])
                  self.assertEqual(resthost, self.proxy_site.memcache.get(uid))
                  set_uid_log = [v for (l, (k, v, t)) in self.proxy_site.memcache.log if k == uid]
                  self.assertFalse(('127.0.0.1', 19482, '/POKER_REST') in set_uid_log)
            d.addCallback(checkTable)
            return d
      # --------------------------------------------------------------
      def test04_tableJoinNoRestHostProxy(self):
            """
            Join a table thru a proxy server without reshost being set for the session.
            """
            uid = '1bebebaffe'
            session = 'deadbeef'
            resthost = ('127.0.0.1', 19481, '/POKER_REST')
            d = client.getPage("http://127.0.0.1:19480/POKER_REST?uid=%s&auth=%s" % (uid, session),
                               postdata = '{"type":"PacketPokerTableJoin","game_id":1}')
            def checkTable(result):
                  packets = simplejson.JSONDecoder().decode(result)
                  self.assertEqual('PacketPokerTable', packets[0]['type'])
                  self.assertEqual('Table1', packets[0]['name'])
                  self.assertEqual(resthost, self.proxy_site.memcache.get(uid))
                  set_uid_log = [v for (l, (k, v, t)) in self.proxy_site.memcache.log if k == uid]
                  self.assertFalse(('127.0.0.1', 19482, '/POKER_REST') in set_uid_log)
            d.addCallback(checkTable)
            return d

################################################################################
def Run():
      loader = runner.TestLoader()
#      loader.methodPrefix = "test02"
      suite = loader.suiteFactory()
      suite.addTest(loader.loadClass(SessionProxyFilterTestCase))
      return runner.TrialRunner(
            reporter.VerboseTextReporter,
            tracebackFormat='default',
#            logfile = '-',
            ).run(suite)

if __name__ == '__main__':
      if Run().wasSuccessful():
            sys.exit(0)
      else:
            sys.exit(1)
################################################################################
# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-sessionproxyfilter.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/sessionproxyfilter.py' VERBOSE_T=-1 TESTS='coverage-reset test-sessionproxyfilter.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-tourney
#!/usr/bin/python
# -*- mode: python; coding: iso-8859-1 -*-
# more information about the above line at http://www.python.org/dev/peps/pep-0263/
#
# Copyright (C)       2008 Bradley M. Kuhn <bkuhn@ebb.org>
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C)       2006 Mekensleep <licensing@mekensleep.com>
#                          24 rue vieille du temple 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Bradley M. Kuhn <bkuhn@ebb.org>
#
import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import time

from string import split
import libxml2
import random
import locale
import sets
from _mysql_exceptions import IntegrityError
from pprint import pprint
from datetime import date

from tests import testclock

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages, search_output, clear_all_messages, get_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
silence_all_messages()

from pokerengine import pokertournament, pokergame
from pokernetwork import pokerservice, pokernetworkconfig, user
from pokernetwork import currencyclient
from pokernetwork import pokerdatabase
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerpackets import *
from pokernetwork.packets import PacketError
from MySQLdb.cursors import DictCursor

class ConstantDeckShuffler:
    def shuffle(self, what):
        what[:] = [40, 13, 32, 9, 19, 31, 15, 14, 50, 34, 20, 6, 43, 44, 28, 29, 48, 3, 21, 45, 23, 37, 35, 11, 5, 22, 24, 30, 27, 39, 46, 33, 0, 8, 1, 42, 36, 16, 49, 2, 10, 26, 4, 18, 7, 41, 47, 17]

from pokerengine import pokergame
pokergame.shuffler = ConstantDeckShuffler()

class ConstantPlayerShuffler:
    def shuffle(self, what):
        what.sort()

from pokerengine import pokertournament
pokertournament.shuffler = ConstantPlayerShuffler()

settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" max_joined="1000" simultaneous="4" chat="yes" remove_completed="1" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <language value="en_US.ISO-8859-1"/>

  <stats type="RankPercentile"/>

  <tourney_attrs type="SponsoredPrizes"/>

  <refill serial="1" amount="10000000" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}
class UserMockup:
    def isLogged(self): return True

class ClientMockup:
    def __init__(self, serial):
        self.user = UserMockup()
        self.serial = serial
        self.packet_end_tournament = None
        self.packets = []
        self.tables = {}
        self.joinedTables = []
        self.deferred = None

    def getPlayerInfo(self):
        class MockInfo:
            def __init__(miSelf):
                miSelf.name =  "PLAYER INFO: %d" % self.serial
                miSelf.url  = "http://example.org"
                miSelf.outfit  = "naked"
        return MockInfo()

    def sendPacket(self, packet):
        self.packets.append(packet)
        if self.deferred and self.type == packet.type:
                reactor.callLater(0, lambda: self.deferred.callback(packet))

    def join(self, table, reason = ""):
        self.joinedTables.append(table)
        self.tables[table.game.id] = table

    def getSerial(self):
        return self.serial

    def sendPacketVerbose(self, packet):
        self.sendPacket(packet)

    def waitFor(self, type):
        self.deferred = defer.Deferred()
        self.type = type
        return self.deferred

class TourneyTableBalanceTestCase(unittest.TestCase):

    def destroyDb(self):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    # ----------------------------------------------------------------
    def setUp(self):
        testclock._seconds_reset()
        self.destroyDb()
        self.settings = settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.db = pokerdatabase.PokerDatabase(settings)
        self.service = pokerservice.PokerService(settings)
        self.default_money = 10000000
#        self.service.verbose = 0
#        self.service.verbose = 4
    # ----------------------------------------------------------------
    def tearDown(self):
        self.db.close()
        d = self.service.stopService()
        d.addCallback(lambda x: self.destroyDb())
        return d
    # ----------------------------------------------------------------
    def createUsers(self):
        cursor = self.db.cursor()
        for user_number in (1, 2, 3, 4, 5, 6):
            cursor.execute("INSERT INTO users (name, password, created) VALUES ('user%d', 'password%d', 0)" % ( user_number, user_number ))
            self.assertEqual(1, cursor.rowcount)

        self.user_serials = []
        for ii in range(0,6): self.user_serials.append(None)
        ( (self.user_serials[0], name, privilege), message ) = self.service.auth("user1", "password1", "role1")
        ( (self.user_serials[1], name, privilege), message ) = self.service.auth("user2", "password2", "role1")
        ( (self.user_serials[2], name, privilege), message ) = self.service.auth("user3", "password3", "role1")
        ( (self.user_serials[3], name, privilege), message ) = self.service.auth("user4", "password4", "role1")
        ( (self.user_serials[4], name, privilege), message ) = self.service.auth("user5", "password5", "role1")
        ( (self.user_serials[5], name, privilege), message ) = self.service.auth("user6", "password6", "role1")

#         for user_number in self.user_serials:
#             if self.default_money > 0 and user_number == self.user3_serial:
#                 cursor.execute("INSERT INTO user2money (user_serial, currency_serial, amount) VALUES (%d, 2, %d)" % ( user_number, self.default_money ) )
#                 self.assertEqual(1, cursor.rowcount)

        cursor.close()
    # ----------------------------------------------------------------
    def test01_sixPlayersTourney5PerTable(self):
        """test01_sixPlayersTourney5PerTable

        Test the condition where six players sign up for a tourney that
        has five people per table.  It has been reported that this causes
        5 people at one table and 1 player at the other"""

        pokerservice.UPDATE_TOURNEYS_SCHEDULE_DELAY = 1
        pokerservice.CHECK_TOURNEYS_SCHEDULE_DELAY = 0.1

        cursor = self.db.cursor()
        cursor.execute("""
INSERT INTO `tourneys_schedule` ( `name`, `description_short` , `description_long` , `players_quota` , `variant` , `betting_structure` , `seats_per_game` , `currency_serial` , `buy_in` , `rake` , `sit_n_go` , `start_time` , `register_time` , `respawn` , `respawn_interval`, `players_min`, `breaks_first` )
VALUES ( 'Only6', 'Sit and Go 6 players and only 6 , Holdem', 'Sit and Go 6 players only', '6', 'holdem', 'level-15-30-no-limit', '5', 1, '0', '0', 'y', '0', '0', 'y', '0', '6', 1 );
""")
        cursor.close()
#INSERT INTO `tourneys_schedule` (`name`, `description_short`, `description_long`, `players_quota`, `variant`, `betting_structure`, `seats_per_game`, `currency_serial`, `buy_in`, `rake`, `sit_n_go`, `breaks_interval`, `rebuy_delay`, `add_on`, `add_on_delay`, `start_time`, `register_time`, `respawn`, `respawn_interval`, `players_min`) VALUES ('Only6', 'Only 6  Freeroll', 'Only 6 No Limit Freeroll', '6', 'holdem', 'level-001', '5', 1, '0', '0', 'y', '60', '30', '1', '60', unix_timestamp(now() + INTERVAL 2 MINUTE), unix_timestamp(now() - INTERVAL 1 HOUR), 'n', '0', '6');

        self.service.startService()
        self.createUsers()
        tourneys = self.service.tourneySelect('Only6')
        self.assertEquals(len(tourneys), 1)
        t = tourneys[0]
        self.assertEquals(t['name'], 'Only6')
        self.assertEquals(t['betting_structure'], 'level-15-30-no-limit')
        self.assertEquals(t['players_quota'], 6L)
        self.assertEquals(t['players_min'], 6L)
        self.assertEquals(t['seats_per_game'], 5L)
        tourneySerial = t['serial']

        clients = {}
        for userSerial in self.user_serials:
            clients[userSerial] = ClientMockup(userSerial)
            self.service.avatar_collection.add(userSerial, clients[userSerial])
            self.service.tourneyRegister(PacketPokerTourneyRegister(serial = userSerial,
                                                                    game_id = tourneySerial))

        tourneys =  self.service.tourneys.values()

        (sixTourney,) = filter(lambda tourney: tourney.name == 'Only6', self.service.tourneys.values())
        self.assertEquals(sixTourney.serial, tourneySerial)


        d = defer.Deferred()
        def checkTourney(status):
            self.assertEquals(pokertournament.TOURNAMENT_STATE_RUNNING, sixTourney.state)

            self.assertEquals(self.service.joined_count, 6)

            # Check that we don't get a table with only one player.
            for game in sixTourney.games:
                print game.__dict__
                self.failUnless(len(game.serial2player.keys()) >= 2)

            # The test fails with dirty reactor unless we cancel this timeout.
            for game in sixTourney.games:
                if len(game.serial2player.keys()) > 1:
                    table = self.service.getTable(game.id)
                    table.cancelDealTimeout()

        d.addCallback(checkTourney)

        reactor.callLater(3, lambda: d.callback(True))

        return d
# ----------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
    loader.methodPrefix = "test01"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(TourneyTableBalanceTestCase))
    return runner.TrialRunner(
        reporter.VerboseTextReporter,
#       reporter.TextReporter,
#	tracebackFormat='verbose',
        tracebackFormat='default',
        ).run(suite)

# ----------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)


########NEW FILE########
__FILENAME__ = test-user
# -*- mode: python -*-
#
# Copyright (C)             2008 Bradley M. Kuhn <bkuhn@ebb.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Bradley M. Kuhn <bkuhn@ebb.org>
#

import sys, os
sys.path.insert(0, "..")

import unittest
import os.path
import types

from tests.testmessages import silence_all_messages, clear_all_messages, get_messages
silence_all_messages()

from pokernetwork.user import User
from pokernetwork import user as userClass
from pokernetwork.pokerpackets import PacketPokerSetAccount as mylimits

class PokerUserTestCase(unittest.TestCase):
        
    # -----------------------------------------------------------------------------------------------------
    def setUp(self):
        pass
    # -----------------------------------------------------------------------------------------------------    
    def tearDown(self):
        pass
    # -----------------------------------------------------------------------------------------------------    
    def test01_init(self):
        """test01_init
        test initialization of object"""

        user = User(4815162342)
        self.assertEquals(user.isLogged(), True)
        self.assertEquals(user.serial, 4815162342)
        self.assertEquals(user.name, 'anonymous')
        self.assertEquals(user.url, 'random')
        self.assertEquals(user.outfit, 'random')
        self.assertEquals(user.privilege, None)
    # -----------------------------------------------------------------------------------------------------    
    def test02_logout(self):
        """test02_logout
        test logout, isLogged, and __str__ methods"""

        user = User(4815162342)
        self.assertEquals(user.isLogged(), True)
        user.name = "Joe"
        user.url = "http://example.org/"
        user.outfit = "naked"
        user.privilege = User.ADMIN
        self.assertEquals(user.isLogged(), True)

        # Test __str__
        self.assertEquals("%s" % user, 'serial = 4815162342, name = Joe, url = http://example.org/, outfit = naked, privilege = %d' % User.ADMIN)

        user.logout()
        self.assertEquals(user.isLogged(), False)
        self.assertEquals(user.serial, 0)
        self.assertEquals(user.name, 'anonymous')
        self.assertEquals(user.url, 'random')
        self.assertEquals(user.outfit, 'random')
        self.assertEquals(user.privilege, None)
    # -----------------------------------------------------------------------------------------------------    
    def test03_hasPrivilege(self):
        """test03_hasPrivilege
        test hasPrivilege method"""
        user = User(4815162342)
        self.assertEquals(user.hasPrivilege(None), True)
        self.assertEquals(user.hasPrivilege(User.ADMIN), False)
        self.assertEquals(user.hasPrivilege(User.REGULAR), False)
        user.privilege = User.REGULAR
        self.assertEquals(user.hasPrivilege(None), True)
        self.assertEquals(user.hasPrivilege(User.ADMIN), False)
        self.assertEquals(user.hasPrivilege(User.REGULAR), True)
        user.privilege = User.ADMIN
        self.assertEquals(user.hasPrivilege(None), True)
        self.assertEquals(user.hasPrivilege(User.ADMIN), True)
        self.assertEquals(user.hasPrivilege(User.REGULAR), True)
        user.logout()
        self.assertEquals(user.hasPrivilege(None), True)
        self.assertEquals(user.hasPrivilege(User.ADMIN), False)
        self.assertEquals(user.hasPrivilege(User.REGULAR), False)
    # -----------------------------------------------------------------------------------------------------    
    def test04_checkName(self):
        """test04_checkName
        test checkName static function"""

        # Empty string.
        self.assertEquals(userClass.checkName(""),
                          (False, mylimits.NAME_TOO_SHORT, 'login name must be at least 5 characters long'))


        # First, loops to test length only.  All generated strings should be valid

        #                                 [A-Z]          [a-z]     
        atoZ = [ chr(xx) for xx in range(65, 91) + range(97,123) ]
        underbar =  [ '_' ]
        #                             [0-9]
        nums = [ chr(xx) for xx in range(48, 58) ]
        weirdChars =  [ chr(xx) for xx in range(33, 48) + range(91, 94) ]

        # SPEED NOTE: replaced atoZ with [ 'a', 'z', 'h', 'H', 'A', 'Z' ] for speed
        for first in [ 'a', 'z', 'h', 'H', 'A', 'Z' ]:
            for cc in  [ 'a', 'z', 'A', 'Z' ] + nums + underbar:
                name = first
                while len(name) < userClass.NAME_LENGTH_MIN:
                    self.assertEquals(userClass.checkName(name),
                                      (False, mylimits.NAME_TOO_SHORT, 'login name must be at least 5 characters long'))
                    name += cc
                while len(name) <= userClass.NAME_LENGTH_MAX:
                    self.assertEquals(userClass.checkName(name), (True, None, None))
                    if len(name) < userClass.NAME_LENGTH_MAX:
                        for dd in underbar + nums:
                            self.assertEquals(userClass.checkName(dd + name),
                                              (False, mylimits.NAME_MUST_START_WITH_LETTER,
                                               'login name must start with a letter'))
                            self.assertEquals(userClass.checkName(name + dd), (True, None, None))
                        for dd in weirdChars:
                            self.assertEquals(userClass.checkName(dd + name),
                                              (False, mylimits.NAME_MUST_START_WITH_LETTER,
                                               'login name must start with a letter'))
                            self.assertEquals(userClass.checkName(name + dd),
                                              (False, mylimits.NAME_NOT_ALNUM,
                                               'login name must be all letters, digits or underscore '))
                    name += cc
                for kk in range(20):
                    self.assertEquals(userClass.checkName(name), 
                                      (False, mylimits.NAME_TOO_LONG, 'login name must be at most 50 characters long'))
    # -----------------------------------------------------------------------------------------------------    
    def test05_checkPassword(self):
        """test05_checkPassword
        test checkPassword static function"""

        # Empty string.
        self.assertEquals(userClass.checkPassword(""),
                          (False, mylimits.PASSWORD_TOO_SHORT, 'password must be at least %d characters long' % userClass.PASSWORD_LENGTH_MIN))


        # First, loops to test length only.  All generated strings should be valid

        #                                 [A-Z]          [a-z]     
        atoZ = [ chr(xx) for xx in range(65, 91) + range(97,123) ]
        underbar =  [ '_' ]
        #                             [0-9]
        nums = [ chr(xx) for xx in range(48, 58) ]
        weirdChars =  [ chr(xx) for xx in range(33, 48) + range(91, 94) ]

        # SPEED NOTE: replaced atoZ with [ 'a', 'z', 'h', 'H', 'A', 'Z' ] for speed
        for cc in  [ 'a', 'z', 'H', 'h' 'A', 'Z' ] + nums:
            pw = cc
            while len(pw) < userClass.PASSWORD_LENGTH_MIN:
                self.assertEquals(userClass.checkPassword(pw),
                                  (False, mylimits.PASSWORD_TOO_SHORT, 'password must be at least %d characters long' % userClass.PASSWORD_LENGTH_MIN))
                pw += cc
            while len(pw) <= userClass.PASSWORD_LENGTH_MAX:
                self.assertEquals(userClass.checkPassword(pw), (True, None, None))
                if len(pw) < userClass.PASSWORD_LENGTH_MAX:
                    for dd in weirdChars:
                        self.assertEquals(userClass.checkPassword(pw + dd),
                                          (False, mylimits.PASSWORD_NOT_ALNUM,
                                           'password must be all letters and digits'))
                pw += cc
            for kk in range(20):
                self.assertEquals(userClass.checkPassword(pw), 
                                  (False, mylimits.PASSWORD_TOO_LONG, 'password must be at most %d characters long' % userClass.PASSWORD_LENGTH_MAX))
    # -----------------------------------------------------------------------------------------------------    
    def test06_checkNameAndPassword(self):
        """test06_checkNameAndPassword
        make sure check and password name"""
        global thisCount
        thisCount = 0
        def firstOneNone(name):
            return (None, "one", "one")
        def firstOneFalse(name):
            return (False, "two", "two")
        def firstOneTrue(name):
            return (True, "three", "three")
        def countCall(password):
            global thisCount
            thisCount += 1
            return (True, "FOUND", "FOUND")

        saveCheckName = userClass.checkName
        saveCheckPassword = userClass.checkPassword

        userClass.checkPassword = countCall

        userClass.checkName = firstOneNone
        self.assertEquals(userClass.checkNameAndPassword("dummy", "dummy"), (None, "one", "one"))
        self.assertEquals(thisCount, 0)

        userClass.checkName = firstOneFalse
        self.assertEquals(userClass.checkNameAndPassword("dummy", "dummy"), (False, "two", "two"))
        self.assertEquals(thisCount, 0)

        userClass.checkName = firstOneTrue
        self.assertEquals(userClass.checkNameAndPassword("dummy", "dummy"), (True, "FOUND", "FOUND"))
        self.assertEquals(thisCount, 1)

        userClass.checkName = saveCheckName 
        userClass.checkPassword = saveCheckPassword 
# -----------------------------------------------------------------------------------------------------
def GetTestSuite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(PokerUserTestCase))
    # Comment out above and use line below this when you wish to run just
    # one test by itself (changing prefix as needed).
#    suite.addTest(unittest.makeSuite(PokerUserTestCase, prefix = "test05"))
    return suite
# -----------------------------------------------------------------------------------------------------
def Run(verbose):
    suite = GetTestSuite()
    verbosity = int(os.environ.get('VERBOSE_T', 2))
    return unittest.TextTestRunner(verbosity=verbose).run(suite)
    
# -----------------------------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run(int(os.environ.get('VERBOSE_T', 2))).wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-user.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/user.py' TESTS='coverage-reset test-user.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = test-webservice
#!/usr/bin/python
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2006 Mekensleep <licensing@mekensleep.com>
#                    24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import sys, os
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, SCRIPT_DIR)
sys.path.insert(0, "..")

import simplejson
import urllib
import libxml2
from types import ListType

from twisted.trial import unittest, runner, reporter
import twisted.internet.base
from twisted.internet import reactor, defer

#
# Must be done before importing pokerclient or pokerclient
# will have to be patched too.
#
from tests import testclock
twisted.internet.base.DelayedCall.debug = True

from tests.testmessages import silence_all_messages
verbose = int(os.environ.get('VERBOSE_T', '-1'))
if verbose < 0: silence_all_messages()

from pokernetwork import pokerservice, pokernetworkconfig, user
from pokernetwork import currencyclient
from pokernetwork import pokersite
currencyclient.CurrencyClient = currencyclient.FakeCurrencyClient
from pokernetwork.pokerclientpackets import *

from twisted.web import xmlrpc

settings_xml = """<?xml version="1.0" encoding="ISO-8859-1"?>
<server verbose="6" ping="300000" autodeal="yes" simultaneous="4" chat="yes" >
  <delays autodeal="18" round="12" position="60" showdown="30" finish="18" />

  <table name="Table1" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />
  <table name="Table2" variant="holdem" betting_structure="100-200-no-limit" seats="10" player_timeout="60" currency_serial="1" />

  <listen tcp="19480" />

  <cashier acquire_timeout="5" pokerlock_queue_timeout="30" user_create="yes" />
  <database name="pokernetworktest" host="localhost" user="pokernetworktest" password="pokernetwork"
            root_user="root" root_password="" schema="%(script_dir)s/../database/schema.sql" command="/usr/bin/mysql" />
  <path>%(script_dir)s/../conf</path>
  <users temporary="BOT"/>
</server>
""" % {'script_dir': SCRIPT_DIR}

from twisted.web import xmlrpc, server, client, http, resource

from tests import testlock

#
# Override QueryProtocol from xmlrpc because it lacks
# the Cookie header.
#
class QueryProtocol(http.HTTPClient):

    def connectionMade(self):
	if hasattr(self.factory, "path"): # twisted-2.4 / 2.5
            self.sendCommand('POST', self.factory.path)
	elif hasattr(self.factory, "url"): # twisted-2.2
            self.sendCommand('POST', self.factory.url)
        self.sendHeader('User-Agent', 'Twisted/XMLRPClib')
        self.sendHeader('Host', self.factory.host)
        if self.factory.cookie:
            self.sendHeader('Cookie', self.factory.cookie)
        self.sendHeader('Content-type', 'text/xml')
        self.sendHeader('Content-length', str(len(self.factory.payload)))
	if hasattr(self.factory, "user") and self.factory.user:
            auth = '%s:%s' % (self.factory.user, self.factory.password)
            auth = auth.encode('base64').strip()
            self.sendHeader('Authorization', 'Basic %s' % (auth,))
        self.endHeaders()
        self.transport.write(self.factory.payload)

    def handleStatus(self, version, status, message):
        if status != '200':
            self.factory.badStatus(status, message)

    def handleResponse(self, contents):
        self.factory.parseResponse(contents)


class PokerServiceTestCase(unittest.TestCase):

    def destroyDb(self, arg = None):
        if len("") > 0:
            os.system("/usr/bin/mysql -u root --password='' -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")
        else:
            os.system("/usr/bin/mysql -u root -h 'localhost' -e 'DROP DATABASE IF EXISTS pokernetworktest'")

    # -----------------------------------------------------------------------------------------------------
    def setUp(self):
        self.destroyDb()
        settings = pokernetworkconfig.Config([])
        settings.doc = libxml2.parseMemory(settings_xml, len(settings_xml))
        settings.header = settings.doc.xpathNewContext()
        self.service = pokerservice.PokerService(settings)
        if verbose >=0: self.service.verbose = verbose
        site = server.Site(resource.IResource(self.service))
        self.p = reactor.listenTCP(0, site,
                                   interface="127.0.0.1")
        self.port = self.p.getHost().port
        self.cookie = None

    def cleanSessions(self, arg):
        #
        # twisted Session code has leftovers : disable the hanging delayed call warnings
        # of trial by nuking all what's left.
        #
        pending = reactor.getDelayedCalls()
        if pending:
            for p in pending:
                if p.active():
#                    print "still pending:" + str(p)
                    p.cancel()
        return arg

    def tearDown(self):
        self.cookie = None
        d = self.service.stopService()
        d.addCallback(lambda x: self.p.stopListening())
        d.addCallback(self.destroyDb)
        d.addCallback(self.cleanSessions)
        return d

    def query(self, *args):
        pass

    def login(self):
        def validate(result):
            self.assertEquals(2, len(result))
            self.assertEquals({'type': 'PacketAuthOk'}, result[0])
            serial_packet = result[1]
            if int(os.environ.get('VERBOSE_T', '-1')) > 0:
                print "serial_packet " + str(serial_packet)
            self.assertEquals(serial_packet['type'], 'PacketSerial')
            self.failUnless(serial_packet.has_key('cookie'))
            self.cookie = serial_packet['cookie']
            self.failUnless(serial_packet.has_key('serial'))
            self.user_serial = serial_packet['serial']
            return serial_packet['cookie']

        d = self.query('use sessions', { 'type': 'PacketLogin',
                                         'name': 'user1',
                                         'password': 'password' })
        d.addCallback(validate)
        return d

    def logout(self, *args):
        def validate(result):
            self.assertEquals([], result)
            return result

        d = self.query('use sessions', { 'type': 'PacketLogout' })
        d.addCallback(validate)
        return d

    def test01_ping(self):
        self.service.startService()
        d = self.query('no sessions', { 'type': 'PacketPing' })
        d.addCallback(self.assertEquals, [])
        return d

    def test02_login(self):
        self.service.startService()
        d = self.login()
        d.addCallback(self.logout)
        return d

    def cashIn(self, arg):
        d = self.query('use sessions', { 'type': 'PacketPokerCashIn',
                                         'serial': self.user_serial,
                                         'url': 'ONE',
                                         'name': "%040d" % 1,
                                         'bserial': 1,
                                         'value': 100 })
        d.addCallback(self.assertEquals, [{'type': 'PacketAck'}])
        return d

    def test03_cashIn(self):
        self.service.startService()
        d = self.login()
        d.addCallback(self.cashIn)
        d.addCallback(self.logout)
        return d

    def getPersonalInfo(self, arg):
        def validate(result):
            self.assertEquals(1, len(result))
            info = result[0]
            self.assertEquals('PacketPokerPersonalInfo', info['type'])
            self.assertEquals(self.user_serial, info['serial'])

        d = self.query('use sessions', { 'type': 'PacketPokerGetPersonalInfo',
                                         'serial': self.user_serial })
        d.addCallback(validate)
        return d

    def test04_getPersonalInfo(self):
        self.service.startService()
        d = self.login()
        d.addCallback(self.getPersonalInfo)
        d.addCallback(self.logout)
        return d

    def cashOut(self, arg):
        d = self.query('use sessions', { 'type': 'PacketPokerCashOut',
                                         'serial': self.user_serial,
                                         'url': 'ONE',
                                         'value': 10 })
        def validate(packet):
            self.assertEquals('PacketPokerCashOut', packet[0]['type'])
            self.assertEquals(3, packet[0]['bserial'])
            return packet

        d.addCallback(validate)
        return d

    def cashOutCommit(self, arg):
        d = self.query('use sessions', { 'type': 'PacketPokerCashOutCommit',
                                         'transaction_id': "%040d" % 1,
                                         'value': 10 })
        d.addCallback(self.assertEquals, [{'type': 'PacketAck'}])
        return d

    def test05_cashOut(self):
        self.service.startService()
        d = self.login()
        d.addCallback(self.cashIn)
        d.addCallback(self.cashOut)
        d.addCallback(self.cashOutCommit)
        d.addCallback(self.logout)
        return d

    def stats(self):
        d = self.query('no sessions', { 'type': 'PacketPokerStatsQuery' })
        def validate(packet):
            self.assertEquals('PacketPokerStats', packet[0]['type'])
            self.assertEquals(1, packet[0]['players'])
            return packet

        d.addCallback(validate)
        return d

    def test06_stats(self):
        self.service.startService()
        return self.stats()
        return d

    def test07_tableSelect(self):
        self.service.startService()
        d = self.query('no sessions', { 'type': 'PacketPokerTableSelect', 'string': ''})
        def validate(packet):
            self.assertEquals('PacketPokerTableList', packet[0]['type'])
            return packet

        d.addCallback(validate)
        return d

    def test08_polling(self):
        self.service.startService()
        d = self.login()
        def avatarPoll(*args):
            #
            # the avatar must be queuing packets broadcasted to it
            #
            avatar = self.service.avatars[0]
            self.assertTrue(avatar._queue_packets)
            avatar.sendPacket(PacketAck())
            #
            # sending a ping packet will return the packets queued
            # by the avatar
            #
            d = self.query('use sessions', { 'type': 'PacketPing' })
            d.addCallback(self.assertEquals, [{'type': 'PacketAck'}])
            return d
        d.addCallback(avatarPoll)
        return d

class XMLRPCPokerServiceTestCase(PokerServiceTestCase):

    def query(self, *args):
        if hasattr(xmlrpc, "_QueryFactory"): # twisted-2.5
            factory = xmlrpc._QueryFactory('/RPC2', '127.0.0.1:' + str(self.port), 'handlePacket', None, None, False, args)
        elif hasattr(factory, "path"): # twisted-2.4
            factory = xmlrpc.QueryFactory('/RPC2', '127.0.0.1:' + str(self.port), 'handlePacket', None, None, *args)
        else: # twisted-2.3
            factory = xmlrpc.QueryFactory('/RPC2', '127.0.0.1:' + str(self.port), 'handlePacket', *args)
        factory.protocol = QueryProtocol
        factory.cookie = self.cookie
        reactor.connectTCP('127.0.0.1', self.port, factory)
        return factory.deferred


class SOAPPokerServiceTestCase(PokerServiceTestCase):

    def query(self, *args):
        pass # not implemented

# -----------------------------------------------------------------------------------------------------
def GetTestedModule():
    return pokerengineconfig

# -----------------------------------------------------------------------------------------------------
def Run():
    loader = runner.TestLoader()
#    loader.methodPrefix = "testREST03"
    suite = loader.suiteFactory()
    suite.addTest(loader.loadClass(XMLRPCPokerServiceTestCase))
    return runner.TrialRunner(reporter.TextReporter,
#                              tracebackFormat='verbose',
                              tracebackFormat='default',
                              ).run(suite)

# -----------------------------------------------------------------------------------------------------
if __name__ == '__main__':
    if Run().wasSuccessful():
        sys.exit(0)
    else:
        sys.exit(1)

# Interpreted by emacs
# Local Variables:
# compile-command: "( cd .. ; ./config.status tests/test-webservice.py ) ; ( cd ../tests ; make COVERAGE_FILES='../pokernetwork/pokerservice.py' TESTS='coverage-reset test-webservice.py coverage-report' check )"
# End:

########NEW FILE########
__FILENAME__ = testclock
#!@PYTHON@
# -*- py-indent-offset: 4; coding: iso-8859-1; mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Tweak poker-engine & twisted to use a fake clock so that
# the tests are immune to the performances of the machine
# running the test, even when testing timeouts or other delays.
#
import time, os
from twisted.python import runtime
from twisted.internet import reactor, base
from pokerengine import pokertournament

#
# unless otherwise specified, implementation is for twisted versions < 8.0.1
#
_seconds_value = time.time()
def _seconds_reset():
    global _seconds_original
    _seconds_original = _seconds_value
_seconds_reset()
_seconds_verbose = int(os.environ.get('VERBOSE_T', '3'))
def _seconds_tick():
    global _seconds_value
    if _seconds_verbose > 3:
        print "tick: %.01f" % ( _seconds_value - _seconds_original )
    _seconds_value += 0.1
    return _seconds_value

reactor.seconds = _seconds_tick # twisted >= 8.0.1
base.seconds = _seconds_tick
#
# select timeout must return immediately, it makes no sense
# to wait while testing.
#
reactor.timeout = lambda: 0
runtime.seconds = _seconds_tick
pokertournament.tournament_seconds = _seconds_tick

from pokernetwork.pokerlock import PokerLock
PokerLock.acquire_sleep = 0.01

########NEW FILE########
__FILENAME__ = testerrorfilter
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

def rest_filter(site, request, packet):
    raise UserWarning, "UNLIKELY"

########NEW FILE########
__FILENAME__ = testfilter
#
# Copyright (C) 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
def rest_filter(site, request, packet):
    request.HERE = True
    return True


########NEW FILE########
__FILENAME__ = testlock
from twisted.internet import reactor, defer

class PokerLockMockup:
    def __init__(self, params):
        pass
    def isAlive(self):
        return True
    def close(self):
        pass
    def start(self):
        pass
    def acquire(self, name, timeout):
        d = defer.Deferred()
        reactor.callLater(0.1, lambda: d.callback(name))
        return d
    def release(self, name):
        pass

from pokernetwork import pokercashier
pokercashier.PokerLock = PokerLockMockup

########NEW FILE########
__FILENAME__ = testmessages
#
# Copyright (C) 2006, 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
# Copyright (C) 2006 Mekensleep <licensing@mekensleep.com>
#                    24 rue vieille du temple, 75004 Paris
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#  Loic Dachary <loic@dachary.org>
#
import sys, os

classes = []

from pokernetwork import currencyclient
classes.append(currencyclient.FakeCurrencyClient)
from pokernetwork import client
classes.append(client.UGAMEClientFactory)
from pokernetwork import protocol
classes.append(protocol.UGAMEProtocol)
from pokernetwork import pokerservice
classes.append(pokerservice.PokerService)
classes.append(pokerservice.PokerXML)
from pokernetwork import pokerauth
classes.append(pokerauth.PokerAuth)
from pokernetwork import pokerauthmysql
classes.append(pokerauthmysql.PokerAuth)
from pokernetwork import pokerlock
classes.append(pokerlock.PokerLock)
from pokernetwork import pokeravatar
classes.append(pokeravatar.PokerAvatar)
from pokernetwork import pokerexplain
classes.append(pokerexplain.PokerExplain)
from pokernetwork import pokertable
classes.append(pokertable.PokerTable)
classes.append(pokertable.PokerAvatarCollection)
from pokernetwork import pokercashier
classes.append(pokercashier.PokerCashier)
from pokernetwork import pokerdatabase
classes.append(pokerdatabase.PokerDatabase)
from pokerengine import pokergame
classes.append(pokergame.PokerGame)
from pokerengine import pokertournament
classes.append(pokertournament.PokerTournament)
from pokernetwork import pokerrestclient
classes.append(pokerrestclient.PokerRestClient)
classes.append(pokerrestclient.PokerProxyClientFactory)
from pokernetwork import pokersite
classes.append(pokersite.PokerResource)
classes.append(pokersite.PokerImageUpload)
classes.append(pokersite.PokerAvatarResource)
classes.append(pokersite.PokerTourneyStartResource)
classes.append(pokersite.PokerSite)
# that does not work because it gets imported in two different ways
#from pokernetwork import proxyfilter
#classes.append(proxyfilter.ProxyClientFactory)

from twisted.internet import defer

verbose = int(os.environ.get('VERBOSE_T', '-1'))

#
# for coverage purpose, make sure all message functions
# are called at least once
#
def call_messages():
    import StringIO
    for a_class in classes:
        stdout = sys.stdout
        sys.stdout = StringIO.StringIO()
        class Fake:
            host = 'H'
            port = 'port'
            serial = 1
            prefix = 'P'
            _prefix = 'P'
            id = 1
            name = 'name'
        a_class.message.im_func(Fake(), '')
        sys.stdout = stdout
    pokerauth.message('')
call_messages()

messages_needle = ''
messages_grep_hit = None
def grep_output(needle):
    messages_grep_hit = defer.Deferred()
    messages_needle = needle
    return messages_grep_hit

def messages_grep(haystack):
    if haystack.find(messages_needle):
        hit = messages_grep_hit
        messages_grep_hit = None
        hit.callback(haystack)
        
def messages_append(string):
    if verbose < -1:
        return
    if verbose > 3:
        print "OUTPUT: " + string
    if not hasattr(string, '__str__'):
        raise Exception, "Message comes in as non-stringifiable object" 
    string = string.__str__()
    messages_out.append(string)
    messages_grep(string)

class2message = {
    pokergame.PokerGame: lambda self, string: messages_append(self.prefix + "[PokerGame " + str(self.id) + "] " + string)
    }
messages_out = []

def redirect_messages(obj, is_class = True):
    if not hasattr(obj, 'orig_message'):
        obj.orig_message = [ ]
    obj.orig_message.append(obj.message)
    if is_class:
        obj.message = class2message.get(obj, lambda self, string: messages_append(string))
    else:
        obj.message = lambda string: messages_append(string)

def silence_all_messages():
    messages_out = []
    for a_class in classes:
        redirect_messages(a_class, True)
    redirect_messages(pokerauth, False)
    
def restore_all_messages():
    for a_class in classes:
        a_class.message = a_class.orig_message.pop()
    pokerauth.message = pokerauth.orig_message.pop()

def search_output(what):
    if verbose > 1:
        print "search_output: " + what
    for message in messages_out:
        if message.find(what) >= 0:
            return True
        if verbose > 1:
            print "\tnot in " + message
    return False

def clear_all_messages():
    global messages_out
    messages_out = []

def get_messages():
    return messages_out

########NEW FILE########
__FILENAME__ = testpackets
# -*- mode: python -*-
#
# Copyright (C) 2007, 2008, 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#
import os

import unittest

class PacketsTestBase(unittest.TestCase):

    def setUp(self):
        self.verbose = int(os.environ.get('VERBOSE_T', '-1'))
        
    @staticmethod
    def polute(packet):
        int_value = 1
        info = packet.info[2:] # skip type + length
        for (variable, default, pack_type) in info:
            if pack_type in ('I', 'H', 'B'):
                packet.__dict__[variable] = int_value
                int_value += 1
        
    def packetCheck(self, **kwargs):
        packet_type = kwargs['type']
        del kwargs['type']
        packet = packet_type(**kwargs)
        self.polute(packet)
        size = packet.calcsize()
        packet.infoInit()
        self.assertEqual(size, packet.infoCalcsize())
        packed = packet.pack()
        self.assertEqual(size, len(packed))
        self.assertEqual(packed, packet.infoPack())
        other_packet = packet_type()
        if other_packet.unpack(packed) != None:
            self.assertEqual(repr(packet), repr(other_packet))
            self.assertEqual(packet, other_packet)
            self.assertEqual(packed, other_packet.pack())
            info_packet = packet_type()
            info_packet.infoInit()
            info_packet.infoUnpack(packed)
            self.assertEqual(packed, info_packet.infoPack())
            return packet
        else:
            return None

########NEW FILE########
__FILENAME__ = testtourney_select_info
#
# Copyright (C) 2009 Loic Dachary <loic@dachary.org>
#
# This software's license gives you freedom; you can copy, convey,
# propagate, redistribute and/or modify this program under the terms of
# the GNU Affero General Public License (AGPL) as published by the Free
# Software Foundation (FSF), either version 3 of the License, or (at your
# option) any later version of the AGPL published by the FSF.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program in a file in the toplevel directory called
# "AGPLv3".  If not, see <http://www.gnu.org/licenses/>.
#

from pokernetwork.pokerpackets import PacketPokerTourneyInfo

class Handle:
    def __init__(self, service, settings):
        self.init = True
        self.settings = settings
    
    def __call__(self, service, packet, tourneys):
        self.packet = packet
        self.tourneys = tourneys
        return PacketPokerTourneyInfo()


########NEW FILE########
__FILENAME__ = testtourney_select_info_no_call
class Handle:
    def __init__(self, service, settings):
        pass

########NEW FILE########
__FILENAME__ = test_apiserver
#!/usr/bin/env python
# coding: utf-8

from twisted.internet.defer import succeed
from twisted.trial import unittest
from twisted.web import http, server
from twisted.web.test.test_web import DummyRequest

from pokernetwork import apiclient
from pokernetwork import apiserver


class DummyHTTPHeaders:
    def getAllRawHeaders(self):
        return []


class OAuthRequest(DummyRequest):
    def __init__(self):
        DummyRequest.__init__(self, [''])
        self.requestHeaders = DummyHTTPHeaders()

    def URLPath(self):
        return self.uri


def _build_dummy_request(key, secret, body=''):
    dummy_request = OAuthRequest()
    oauth2_request = apiclient.build_request(dummy_request.uri, key, secret,
                                             body)
    for arg, value in oauth2_request.iteritems():
        dummy_request.addArg(arg, value)
    return dummy_request


class MockAPISecretStore(object):
    def __init__(self, secrets):
        self.secrets = secrets

    def get_secret(self, key):
        if key in self.secrets:
            return self.secrets[key]
        return None


class MockOAuthResource(apiserver.OAuthResource):
    def __init__(self, secret_store):
        apiserver.OAuthResource.__init__(self, secret_store)

    def render_GET(self, request):
        request.setResponseCode(http.OK)
        return "{}"


def _render(resource, request):
    result = resource.render(request)
    if isinstance(result, str):
        request.write(result)
        request.finish()
        return succeed(None)
    elif result is server.NOT_DONE_YET:
        if request.finished:
            return succeed(None)
        else:
            return request.notifyFinish()
    else:
        raise ValueError("Unexpected return value: %r" % (result,))


class OAuthResourceTests(unittest.TestCase):
    def setUp(self):
        self.key = 'some_key'
        self.secret = 'some_secret'
        secret_store = MockAPISecretStore({self.key: self.secret})
        self.resource = MockOAuthResource(secret_store)


    def _test_request(self, request, expected_status_code):
        d = _render(self.resource, request)

        def rendered(ignored):
            self.assertEquals(request.responseCode, expected_status_code)

        d.addCallback(rendered)
        return d

    def test_successful_oauth_request(self):
        request = _build_dummy_request(self.key, self.secret)
        print request
        return self._test_request(request, http.OK)

    def test_bad_oauth_request(self):
        return self._test_request(OAuthRequest(), http.BAD_REQUEST)

    def test_unauthorized_oauth_request_bad_secret(self):
        request = _build_dummy_request(self.key, 'bad_secret')
        return self._test_request(request, http.UNAUTHORIZED)

    def test_unauthorized_oauth_request_bad_key(self):
        request = _build_dummy_request('bad_key', self.secret)
        self.resource.render(request)
        self.assertEquals(request.responseCode, http.UNAUTHORIZED)

########NEW FILE########
__FILENAME__ = test_tableconfigutils
#!/usr/bin/env python
# coding: utf-8

import os
import tempfile
import unittest

from pokernetwork import tableconfigutils


SERVER_CONFIG_TEMPLATE = """\
<?xml version="1.0" encoding="ISO-8859-1"?>
<server xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="server.xsd" poker_network_version="2.0.0">
%s
</server>"""


TABLE_CONFIG_TEMPLATE = """\
<?xml version="1.0" encoding="UTF-8"?>
<tables>
%s
</tables>"""


TABLE_NODE_TEMPLATE = """\
<table name="%(name)s" variant="%(variant)s" betting_structure="%(betting_structure)s" seats="%(seats)s" />"""


SERVER_CONFIG_TABLES = [
    ('One', 'holdem', '5-10-no-limit'),
    ('Two', 'omaha', '2-4-limit'),
    ('Four', 'omaha8', '.01-.02-pot-limit'),
    ('Ten', 'stud', '10-20-limit'),
    ('Eleven', 'stud', '30-60-limit')
]


TABLE_CONFIGS = {
    'holdem.limit.xml': [('One', 'holdem', '2-4-limit'),
                         ('Two', 'holdem', '10-20-limit')],
    'holdem.no-limit.xml': [('Three', 'holdem', '.02-.04-no-limit'),
                            ('Four', 'holdem', '.05-.10-no-limit', '6'),
                            ('Five', 'holdem', '100-200-no-limit')],
    'omaha.limit.xml': [('Six', 'omaha', '2-4-limit'),
                        ('Seven', 'omaha', '10-20-limit', '8')],
    'omaha8.limit.xml': [('Eight', 'omaha8', '20-40-limit'),
                         ('Nine', 'omaha8', '5-10-limit')]
}


# result of merging SERVER_CONFIG_TABLES with tables in TABLE_CONFIGS
MERGED_TABLES = [
    ('One', 'holdem', '2-4-limit'),
    ('Two', 'holdem', '10-20-limit'),
    ('Three', 'holdem', '.02-.04-no-limit'),
    ('Four', 'holdem', '.05-.10-no-limit', '6'),
    ('Five', 'holdem', '100-200-no-limit'),
    ('Six', 'omaha', '2-4-limit'),
    ('Seven', 'omaha', '10-20-limit', '8'),
    ('Eight', 'omaha8', '20-40-limit'),
    ('Nine', 'omaha8', '5-10-limit'),
    ('Ten', 'stud', '10-20-limit'),
    ('Eleven', 'stud', '30-60-limit')
]


def create_table_dict(name, variant, betting_structure, seats='10'):
    return {'name': name, 'variant': variant,
            'betting_structure': betting_structure, 'seats': seats}


def create_table_xml_entry(table_properties):
    return TABLE_NODE_TEMPLATE % table_properties


def create_config(config_template, tables):
    table_xml_entries = []
    for table in tables:
        table_properties = create_table_dict(*table)
        table_xml_entries.append(create_table_xml_entry(table_properties))
    return config_template % '\n'.join(table_xml_entries)


class DummyServerConfig():
    def __init__(self, table_descriptions,
                 table_node_xpath=tableconfigutils.DEFAULT_TABLE_NODE_XPATH):
        self.path = None
        self.table_descriptions = table_descriptions
        self.table_node_xpath = table_node_xpath

    def reload(self):
         pass

    def headerGetProperties(self, name):
        if name is self.table_node_xpath:
            return self.table_descriptions
        return []


class TableConfigUtilsTests(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.config_basedir = tempfile.mkdtemp()
        cls.server_config_path = os.path.join(cls.config_basedir,
                                              'poker.server.xml')
        with open(cls.server_config_path, 'w+t') as server_config:
            contents = create_config(SERVER_CONFIG_TEMPLATE,
                                     SERVER_CONFIG_TABLES)
            server_config.write(contents)

        cls.table_configs_dir = os.path.join(cls.config_basedir, 'tables.d')
        os.mkdir(cls.table_configs_dir)

        cls.table_config_paths = []
        for config_filename, tables in TABLE_CONFIGS.iteritems():
            config_path = os.path.join(cls.table_configs_dir, config_filename)
            cls.table_config_paths.append(config_path)
            with open(config_path, 'w+t') as table_config:
                contents = create_config(TABLE_CONFIG_TEMPLATE, tables)
                table_config.write(contents)

    @classmethod
    def tearDownClass(cls):
        for config_path in cls.table_config_paths:
            os.remove(config_path)
        os.removedirs(cls.table_configs_dir)

    def test_parse_table_config(self):
        tables = tableconfigutils.parse_table_config(self.server_config_path)
        assert len(tables) == len(SERVER_CONFIG_TABLES)

    def test_parse_table_configs(self):
        tables = tableconfigutils.parse_table_configs(self.table_configs_dir)
        assert len(tables) == sum(len(tables) for tables in
                                  TABLE_CONFIGS.values())

    def _compare_tables(self, tables_a, tables_b):
        """
        Returns True if both lists of tables contain the same table entries
        (order is not important).

        `tables_a`: a list of dicts containing table properties as keys
        `tables_b`: a list of dicts containing table properties as keys
        """
        if len(tables_a) != len(tables_b):
            return False

        seen = {}
        for table in tables_a:
            seen[table['name']] = table

        for table in tables_b:
            table_name = table['name']
            if table_name not in seen or table != seen[table_name]:
                return False
        return True

    def test_merge_tables_with_no_tables(self):
        assert tableconfigutils.merge_tables([], []) == []

    def test_merge_tables_with_no_server_config_tables(self):
        table_config_tables = [
            create_table_dict('One', 'holdem', '2-4-limit'),
            create_table_dict('Two', 'holdem', '5-10-no-limit'),
            create_table_dict('Three', 'omaha8', '3-6-limit')
        ]
        merged_tables = tableconfigutils.merge_tables([], table_config_tables)
        assert self._compare_tables(merged_tables, table_config_tables)

    def test_merge_tables_with_no_table_config_tables(self):
        server_config_tables = [
            create_table_dict('One', 'holdem', '2-4-limit'),
            create_table_dict('Two', 'holdem', '5-10-no-limit'),
            create_table_dict('Five', 'omaha', '.10-.20-pot-limit'),
            create_table_dict('Six', 'omaha8', '3-6-limit')
        ]
        merged_tables = tableconfigutils.merge_tables(server_config_tables, [])
        assert self._compare_tables(merged_tables, server_config_tables)

    def test_get_all_table_descriptions(self):
        server_config_tables = [create_table_dict(*table) for table in
                                SERVER_CONFIG_TABLES]
        server_config = DummyServerConfig(server_config_tables)
        table_descriptions = tableconfigutils.get_table_descriptions(
                                server_config, self.table_configs_dir)

        expected_tables = [create_table_dict(*table) for table in MERGED_TABLES]

        assert self._compare_tables(table_descriptions, expected_tables)

########NEW FILE########
