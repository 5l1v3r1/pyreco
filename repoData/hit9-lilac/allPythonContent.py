__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# lilac documentation build configuration file, created by
# sphinx-quickstart on Tue Jun  4 20:37:22 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Lilac'
copyright = u'2013, hit9'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3.9'
# The full version, including alpha/beta/rc tags.
release = '0.3.9'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
# pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Lilacdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Lilac.tex', u'Lilac Documentation',
   u'hit9', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'Lilac', u'Lilac Documentation',
     [u'hit9'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Lilac', u'Lilac Documentation',
   u'hit9', 'Lilac', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


sys.path.append(os.path.abspath('_themes'))
html_theme_path = ['_themes']
html_theme = 'rux'

########NEW FILE########
__FILENAME__ = cli
# coding=utf8

"""cli interface"""


import logging
import sys
from .utils import join
from os.path import dirname
from .logger import logger
from .server import server
from . import version
from .generator import generator
from .daemon import lilac_daemon
from subprocess import call
from docopt import docopt


def task(task_func):
    def wrapper(*args, **kwargs):
        if task_func.__doc__:
            logger.info(task_func.__doc__)
        return task_func(*args, **kwargs)
    return wrapper


@task
def deploy():
    """deploy blog: less/, src/post/, config.toml, Makefile"""
    lib_dir = dirname(__file__)  # this library's directory
    res = join(lib_dir, "resources")
    call("rsync -aqu " + join(res, "*") + " .", shell=True)
    logger.success("deploy done")
    logger.info("Please edit config.toml to meet tour needs")
    logger.info("Run 'make build' to build blog to htmls")
    logger.info("Run 'make clean' to remove built htmls")


@task
def clean():
    """rm -rf post page tag 404.html about.html archives.html feed.atom index.html tags.html"""
    paths = [
        "post",
        "page",
        "tag",
        "404.html",
        "about.html",
        "archives.html",
        "feed.atom",
        "index.html",
        "tags.html"
    ]

    cmd = ["rm", "-rf"] + paths
    call(cmd)
    logger.success("clean done")


def main():
    """Usage:
  lilac serve [<port>] [--watch]
  lilac (deploy|build|clean)
  lilac (start|stop|status|restart)
  lilac [-h|-v]

Options:
  -h --help     show this help message
  -v --version  show version
  --watch       watch source files for changes
  <port>        which port for server to use(default: 8888)

Commands:
  deploy        deploy blog in current directory
  build         build source files to htmls
  clean         remove files built by lilac
  serve         start a web server, as a option, start watching
  start         start http server and auto rebuilding as a daemon running in the background
  stop          stop the http server and auto rebuilding daemon
  restart       restart http server and auto rebuilding daemon
  status        report the status of the daemon"""

    arguments = docopt(main.__doc__, version='lilac version: ' + version)
    # set logger's level to info
    logger.setLevel(logging.INFO)

    if arguments["deploy"]:
        deploy()
    elif arguments["clean"]:
        clean()
    elif arguments["build"]:
        generator.generate(localhost=False)  # be honest to config.toml
    elif arguments["serve"]:

        port_s = arguments["<port>"]

        if not port_s:
            port = 8888
        else:
            try:
                port = int(port_s)
            except ValueError:
                logger.error("Error format of argument 'port': '%s'" % port_s)
                sys.exit(1)

        server.run(arguments["--watch"], port)
    elif arguments["start"]:
        lilac_daemon.start()
    elif arguments["stop"]:
        lilac_daemon.stop()
    elif arguments["restart"]:
        lilac_daemon.restart()
    elif arguments["status"]:
        lilac_daemon.status()
    else:
        exit(main.__doc__)

########NEW FILE########
__FILENAME__ = config
# coding=utf8

"""Configuration manager, config is in toml"""

from . import charset
from .exceptions import ConfigSyntaxError

import toml
from os.path import join
from os.path import exists


class Config(object):
    """Configuration manager"""

    filename = "config.toml"
    filepath = join(".", filename)
    # default configuration
    default = {
        'root_path': '',
        'blog': {
            'name': 'Sunshine Every Day',
            'description': 'Never give up',
            'url': 'http://your-site.com',
            'theme': 'less'
        },
        'author': {
            'name': 'hit9',
            'email': 'nz2324@126.com'
        },
        'disqus': {
            'shortname': ''  # empty to disable comment ability
        }
    }

    def read(self):
        """Read and parse config, return a dict"""

        if not exists(self.filepath):
            # if not exists, touch one
            open(self.filepath, "a").close()

        content = open(self.filepath).read().decode(charset)
        try:
            config = toml.loads(content)
        except toml.TomlSyntaxError:
            raise ConfigSyntaxError

        return config

config = Config()  # build a config instance

########NEW FILE########
__FILENAME__ = daemon
#coding=utf8


'''
    ***
    Modified generic daemon class
    ***

    Author:     http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/
                www.boxedice.com

    License:    http://creativecommons.org/licenses/by-sa/3.0/

    Changes:    23rd Jan 2009 (David Mytton <david@boxedice.com>)
                - Replaced hard coded '/dev/null in __init__ with os.devnull
                - Added OS check to conditionally remove code that doesn't work on OS X
                - Added output to console on completion
                - Tidied up formatting
                11th Mar 2009 (David Mytton <david@boxedice.com>)
                - Fixed problem with daemon exiting on Python 2.4 (before SystemExit was part of the Exception base)
                13th Aug 2010 (David Mytton <david@boxedice.com>
                - Fixed unhandled exception if PID file is empty
'''

# Core modules
import atexit
import os
import sys
import time
import signal
import logging

from .server import server
from .logger import logger


class Daemon(object):
    """
    A generic daemon class.

    Usage: subclass the Daemon class and override the run() method
    """
    def __init__(self, pidfile, stdin=os.devnull, stdout=os.devnull, stderr=os.devnull, home_dir='.', umask=022, verbose=1):
        self.stdin = stdin
        self.stdout = stdout
        self.stderr = stderr
        self.pidfile = pidfile
        self.home_dir = home_dir
        self.verbose = verbose
        self.umask = umask
        self.daemon_alive = True

    def daemonize(self):
        """
        Do the UNIX double-fork magic, see Stevens' "Advanced
        Programming in the UNIX Environment" for details (ISBN 0201563177)
        http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
        """
        try:
            pid = os.fork()
            if pid > 0:
                # Exit first parent
                sys.exit(0)
        except OSError, e:
            sys.stderr.write("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
            sys.exit(1)

        # Decouple from parent environment
        os.chdir(self.home_dir)
        os.setsid()
        os.umask(self.umask)

        # Do second fork
        try:
            pid = os.fork()
            if pid > 0:
                # Exit from second parent
                sys.exit(0)
        except OSError, e:
            sys.stderr.write("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
            sys.exit(1)

        if sys.platform != 'darwin': # This block breaks on OS X
            # Redirect standard file descriptors
            sys.stdout.flush()
            sys.stderr.flush()
            si = file(self.stdin, 'r')
            so = file(self.stdout, 'a+')
            if self.stderr:
                se = file(self.stderr, 'a+', 0)
            else:
                se = so
            os.dup2(si.fileno(), sys.stdin.fileno())
            os.dup2(so.fileno(), sys.stdout.fileno())
            os.dup2(se.fileno(), sys.stderr.fileno())

        def sigtermhandler(signum, frame):
            self.daemon_alive = False
        signal.signal(signal.SIGTERM, sigtermhandler)
        signal.signal(signal.SIGINT, sigtermhandler)

        if self.verbose >= 1:
            logger.success("Started, server listening at 0.0.0.0:8888")

        # Write pidfile
        atexit.register(self.delpid) # Make sure pid file is removed if we quit
        pid = str(os.getpid())
        file(self.pidfile,'w+').write("%s\n" % pid)

    def delpid(self):
        os.remove(self.pidfile)

    def start(self, *args, **kwargs):
        """
        Start the daemon
        """

        if self.verbose >= 1:
            logger.info("Start lilac daemon...")

        # Check for a pidfile to see if the daemon already runs
        try:
            pf = file(self.pidfile,'r')
            pid = int(pf.read().strip())
            pf.close()
        except IOError:
            pid = None
        except SystemExit:
            pid = None

        if pid:
            message = "pidfile %s already exists. Is it already running?"
            logger.warning(message % self.pidfile)
            sys.exit(1)

        # Start the daemon
        self.daemonize()
        self.run(*args, **kwargs)

    def stop(self):
        """
        Stop the daemon
        """

        if self.verbose >= 1:
            logger.info("Stop lilac daemon...")

        # Get the pid from the pidfile
        try:
            pf = file(self.pidfile,'r')
            pid = int(pf.read().strip())
            pf.close()
        except IOError:
            pid = None
        except ValueError:
            pid = None

        if not pid:
            message = "pidfile %s does not exist. Not running?"
            logger.warning(message % self.pidfile)

            # Just to be sure. A ValueError might occur if the PID file is empty but does actually exist
            if os.path.exists(self.pidfile):
                os.remove(self.pidfile)

            return # Not an error in a restart

        # Try killing the daemon process
        try:
            i = 0
            while 1:
                os.kill(pid, signal.SIGTERM)
                time.sleep(0.1)
                i = i + 1
                if i % 10 == 0:
                    os.kill(pid, signal.SIGHUP)
        except OSError, err:
            err = str(err)
            if err.find("No such process") > 0:
                if os.path.exists(self.pidfile):
                    os.remove(self.pidfile)
            else:
                logger.error(str(err))
                sys.exit(1)

        if self.verbose >= 1:
            logger.success("Stopped")

    def restart(self):
        """
        Restart the daemon
        """
        self.stop()
        self.start()

    def status(self):
        """report daemon status"""
        try:
            pf = file(self.pidfile,'r')
            pid = int(pf.read().strip())
            pf.close()
        except IOError:
            pid = None
        except SystemExit:
            pid = None

        if pid:
            logger.info("Running")
        else:
            logger.info("Stopped")


    def run(self):
        """
        You should override this method when you subclass Daemon. It will be called after the process has been
        daemonized by start() or restart().
        """


class LilacDaemon(Daemon):

    def run(self):
        logger.setLevel(logging.ERROR)
        server.run(True, 8888)
        logger.setLevel(logging.INFO)


lilac_daemon = LilacDaemon("/tmp/lilac-daemon.pid", stdout="/dev/stdout")

########NEW FILE########
__FILENAME__ = exceptions
# coding=utf8

"""all possible exceptions"""

class LilacException(Exception):
    """There was an ambiguous exception that occurred while
    handling lilac process"""
    pass


class SourceDirectoryNotFound(LilacException):
    """Source directory was not found"""
    pass


class ParseException(LilacException):
    """There was an exception occurred while parsing the source"""
    pass


class RenderException(LilacException):
    """There was an exception occurred while rendering to html"""
    pass


class SeparatorNotFound(ParseException):
    """There was no separator found in post's source"""
    pass


class PostDateTimeNotFound(ParseException):
    """There was no datetime found in post's source"""
    pass


class PostTitleNotFound(ParseException):
    """There was no title found in post's source"""
    pass


class PostDateTimeInvalid(ParseException):
    """Invalid datetime format, should like '2012-04-05 10:10'"""
    pass


class PostTagsTypeInvalid(ParseException):
    """Invalid tags datatype, should be a array"""
    pass


class PostHeaderSyntaxError(ParseException):
    """TomlSyntaxError occurred in post's header"""
    pass


class ConfigSyntaxError(LilacException):
    """TomlSyntaxError occurred in config.toml"""
    pass


class JinjaTemplateNotFound(RenderException):
    """Jinja2 template was not found"""
    pass

########NEW FILE########
__FILENAME__ = generator
# coding=utf8

"""this is the main processor when lilac building"""


import signals
from .config import config
from .parser import parser
from .renderer import renderer
from .exceptions import *
from .logger import logger, logging
from .utils import chunks, update_nested_dict, mkdir_p, join
from .models import Post, Tag, Page
from .models import blog, author, about, tags, archives, feed, page_404, charset

import sys
import toml
from os.path import exists
from datetime import datetime
from pyatom import AtomFeed


class Generator(object):

    def __init__(self):
        """init attributes to store runtime data"""
        # initialize them the default value.
        self.reset()
        # register signals
        self.register_signals()

    def reset(self):
        """reset all posts, tags, pages .etc."""
        self.posts = []
        self.tags = []
        self.pages = []
        self.about = about
        self.blog = blog
        self.author = author
        self._tags = tags
        self.archives = archives
        self.feed = feed
        self.page_404 = page_404
        self.config = config.default
        self.root_path = ''
        self.theme = {}

    def register_signals(self):
        """Register all signals in this process"""
        signals.initialized.connect(self.parse_posts)
        signals.initialized.connect(self.render_about_page)
        signals.initialized.connect(self.render_page_404)
        signals.posts_parsed.connect(self.extract_tags)
        signals.posts_parsed.connect(self.compose_pages)
        signals.posts_parsed.connect(self.render_posts)
        signals.posts_parsed.connect(self.render_archives)
        signals.posts_parsed.connect(self.generate_feed)
        signals.tags_extracted.connect(self.render_tags)
        signals.page_composed.connect(self.render_pages)

    def step(step_method):
        """decorator to wrap each step method"""
        def wrapper(self, *args, **kwargs):
            logger.info(step_method.__doc__)
            return step_method(self, *args, **kwargs)
        return wrapper

    @step
    def initialize(self, localhost):
        """Initialize config, blog, author, feed and jinja2 environment"""
        # read config to update the default
        try:
            conf = config.read()
        except ConfigSyntaxError as e:
            logger.error(e.__doc__)
            sys.exit(1)

        update_nested_dict(self.config, conf)
        # update blog and author according to configuration
        self.blog.__dict__.update(self.config['blog'])
        self.author.__dict__.update(self.config['author'])
        # reset root_path if not in localhost
        if not localhost:
            self.root_path = self.config["root_path"]
        # initialize feed
        self.feed.feed = AtomFeed(
            title=self.blog.name,
            subtitle=self.blog.description,
            feed_url=self.blog.url+"/feed.atom",
            url=self.blog.url,
            author=self.author.name
        )
        #
        # -------- initialize jinja2 --
        #
        # detect if there is a theme.toml
        theme_toml = join(self.blog.theme, "theme.toml")

        if exists(theme_toml):
            self.theme = toml.loads(open(theme_toml).read().decode(charset))
        # update theme_conf with config's theme section
        # user's configuation can reset theme's configuation
        config_theme_section = self.config.get("theme", {})
        update_nested_dict(self.theme, config_theme_section)

        # get templates directory
        templates = join(self.blog.theme, "templates")
        # set a render
        jinja_global_data = dict(
            root_path=self.root_path,
            blog=self.blog,
            author=self.author,
            config=self.config,
            theme=self.theme
        )
        renderer.initialize(templates, jinja_global_data)
        logger.success("Generator initialized, root_path = \"%s\"" % self.root_path)
        # send signal that generator was already initialized
        signals.initialized.send(self)

    # make alias to initialize
    generate = initialize

    def re_generate(self, localhost):
        """Reset generator's data and build"""
        self.reset()
        self.generate(localhost)

    @step
    def parse_posts(self, sender):
        """Parse posts and sort them by create time"""
        # glob all source files
        try:
            files = Post.glob_src_files()
        except SourceDirectoryNotFound as e:
            logger.error(e.__doc__)
            sys.exit(1)

        # parse each post's content and append post instance to self.posts
        for filepath, name in files.iteritems():
            try:
                post = parser.parse_from(filepath)
            except ParseException, e:
                logger.warn(e.__doc__ + ": filepath '%s'" % filepath)
                pass  # skip the wrong parsed post
            else:
                post.name = name  # set it a name attribute
                self.posts.append(post)
        # sort posts by its create time
        self.posts.sort(
            key=lambda post: post.datetime.timetuple(),  # from now to past
            reverse=True
        )
        logger.success("Posts parsed")
        signals.posts_parsed.send(self)

    @step
    def extract_tags(self, sender):
        """Extract tags from posts, and sort by their posts' amount"""
        # traversal all posts and get the minial tag to posts dict
        tags = {}

        for post in self.posts:
            for tag in post.tags:
                tags.setdefault(tag, []).append(post)

        # initialize tags
        for tag, posts in tags.iteritems():
            self.tags.append(Tag(tag, posts))

        # sort by tag's size
        self.tags.sort(key=lambda x: len(x.posts), reverse=True)
        logger.success("Tag extracted")
        signals.tags_extracted.send(self)

    @step
    def compose_pages(self, sender):
        """Compose pages from posts"""
        # Actually I don't want to put this as a configuation item
        # but some themes need this, so lilac gets it from theme's conf,
        # by default: 7
        posts_count_per_page = self.theme.get("posts_count_per_page", 7)

        groups = chunks(self.posts, posts_count_per_page)  # 7 posts per page

        for index, group in enumerate(groups):
            self.pages.append(Page(number=index+1, posts=list(group)))

        if self.pages:  # must not empty
            self.pages[0].first = True
            self.pages[-1].last = True
        logger.success("Pages composed")
        signals.page_composed.send(self)

    def render_to(self, path, template, **data):
        """shortcut to render data with template and then write to path.
        Just add exception catch to renderer.render_to"""
        try:
            renderer.render_to(path, template, **data)
        except JinjaTemplateNotFound as e:
            logger.error(e.__doc__ + ": Template '%s'" % template)
            sys.exit(1)  # template not found,  must exit the script

    @step
    def render_posts(self, sender):
        """Render all posts to 'post/' with template 'post.html'"""
        mkdir_p(Post.out_dir)

        for post in self.posts:
            self.render_to(post.out, Post.template, post=post)

        logger.success("Posts rendered")

    @step
    def render_tags(self, sender):
        """Render all tags to 'tag/' with template 'tag.html'"""
        mkdir_p(Tag.out_dir)

        for tag in self.tags:
            self.render_to(tag.out, Tag.template, tag=tag)

        self.render_to(self._tags.out, self._tags.template, tags=self.tags)
        logger.success("Tags rendered")

    @step
    def render_pages(self, sender):
        """Render all pages to 'page/' with template 'page.html'"""
        mkdir_p(Page.out_dir)

        for page in self.pages:
            self.render_to(page.out, Page.template, page=page)
        logger.success("Pages rendered")

    @step
    def render_archives(self, sender):
        """Render archives page to 'archives.html' with template 'archives.html'"""
        self.render_to(self.archives.out, self.archives.template, posts=self.posts)
        logger.success("Archives rendered")

    @step
    def render_about_page(self, sender):
        """Render about me page to 'about.html' with template 'about.html'"""
        about = self.about
        about.markdown = parser.markdown.render(about.content)
        self.render_to(about.out, about.template, about=about)
        logger.success("About page rendered")

    @step
    def generate_feed(self, sender):
        """Generate feed for first 10 posts to 'feed.atom'"""
        for post in self.posts[:self.feed.size]:
            try:
                self.feed.feed.add(
                    title=post.title,
                    content=post.html,
                    content_type="html",
                    author=self.author.name,
                    url=self.blog.url + "/" + post.out,
                    updated=post.datetime
                )
            except Exception as e:
                logger.warning(str(e))
                pass  # skip

        self.feed.write()
        logger.success("Feed generated")

    @step
    def render_page_404(self, sender):
        """Render 404 page to '404.html' with template '404.html' """
        self.render_to(self.page_404.out, self.page_404.template)
        logger.success("404 rendered")

generator = Generator()

########NEW FILE########
__FILENAME__ = logger
# coding=utf8

"""logger for lilac"""

from utils import colored

import logging
import sys
from logging import Formatter
from logging import getLogger
from logging import StreamHandler
from datetime import datetime


class ColoredFormatter(Formatter):
    """colored output formatter"""

    def format(self, record):
        message = record.getMessage()

        mapping = {
            'CRITICAL': 'bgred',
            'ERROR': 'red',
            'WARNING': 'yellow',
            'SUCCESS': 'green',
            'INFO': 'cyan',
            'DEBUG': 'bggrey',
        }
        color = mapping.get(record.levelname, 'white')

        level = colored('%-8s' % record.levelname, color)
        time = colored(datetime.now().strftime("(%H:%M:%S)"), "magenta")
        return " ".join([level, time, message])


logger = getLogger('lilac')

# add level 'success'
logging.SUCCESS = 25  # 25 is between WARNING(30) and INFO(20)
logging.addLevelName(logging.SUCCESS, 'SUCCESS')

# stackoverflow told me to use method `_log`,  but the `log` is better
# because, `log` check its level's enablity

logger.success = lambda msg, *args, **kwargs: logger.log(logging.SUCCESS, msg, *args, **kwargs)

# add colored handler
handler = StreamHandler(sys.stdout)
formatter = ColoredFormatter()
handler.setFormatter(formatter)
logger.addHandler(handler)


if __name__ == '__main__':
    logger.setLevel(logging.DEBUG)
    logger.info('info')
    logger.success('success')
    logger.debug('debug')
    logger.warning('warning')
    logger.error('error')
    logger.critical('critical')

########NEW FILE########
__FILENAME__ = models
# coding=utf8

"""models in lilac: Blog, Author, Post, Tag, Page"""


from .exceptions import SourceDirectoryNotFound
from . import src_ext, out_ext, src_dir, out_dir, charset

from hashlib import md5
from os import listdir as ls
from os.path import exists
from .utils import join


class Blog(object):
    """
    The blog itself.
    attributes
      name        unicode     blog's name
      description unicode     blog's description
      url         str         blog's site url
      theme   str             which theme to use
    """

    def __init__(self, name=None, description=None, url=None, theme=None):
        self.name = name
        self.description = description
        self.url = url
        self.theme = theme


blog = Blog()


class Author(object):
    """
    The blog's author, only one.
    attributs
      name          unicode     author's name
      email         unicode     author's email
      gravatar_id   str         gravatar_id generated from email
    the gravatar_id is a property decorated method.
    """

    def __init__(self, name=None, email=None):
        self.name = name
        self.email = email

    @property
    def gravatar_id(self):
        """it's md5(author.email), author's gravatar_id"""
        return md5(self.email).hexdigest()


author = Author()

class Post(object):
    """
    The blog's post(s).
    attributes
      name      str      post's filename without extension
      title     unicode  post's title
      datetime  datetime post's create time, e.g. "2012-10-10 13:20"
      tags      list     post's tags
      markdown  unicode  post's markdown source(its body)
      html      unicode  post's html(parrsed from markdown)
    the `html` is a property decorated method
    """

    src_dir = join(src_dir, "post")  # src directroy of posts
    out_dir = join(out_dir, "post")  # html directroy of posts
    template = "post.html"  # all posts are rendered with this template

    def __init__(
        self,
        name=None, tags=None, title=None, datetime=None, markdown=None,
        **other_attrs
    ):
        self.name = name
        self.title = title
        self.datetime = datetime
        self.markdown = markdown

        if tags is None:
            self.tags = []
        else:
            self.tags = tags

        self.__dict__.update(other_attrs)

    @property
    def html(self):
        """Return the post's content's rendered markdown"""
        # the parser should be import in method, else will cause annoying loop
        # import issue
        from .parser import parser
        return parser.markdown.render(self.markdown)

    def __getattr__(self, key):
        if key == "summary":  # if no summary defined in post's header return the first 200 char
            return self.slice(0, 200)
        else:
            raise AttributeError

    def slice(self, start=0, end=200):
        """render post's body's some slice to html, and return it"""
        from .parser import parser
        return parser.markdown.render(self.markdown[start:end])


    @property
    def src(self):
        """Return the post's source filepath"""
        return join(Post.src_dir, self.name + src_ext)

    @property
    def out(self):
        """Return the post's output(html) filepath"""
        return join(Post.out_dir, self.name + out_ext)

    @classmethod
    def glob_src_files(cls):
        """Glob source files return filepath to name dict"""

        if not exists(Post.src_dir):
            raise SourceDirectoryNotFound

        dct = {}

        for fn in ls(Post.src_dir):
            if fn.endswith(src_ext):
                name = fn[:-len(src_ext)]
                path = join(Post.src_dir, fn)
                dct[path] = name

        return dct


class Tag(object):
    """
    Each posts may have tags, each tag has some posts.
    attributes
      name      unicode     tag's name
      posts     list        posts in this tag
    """

    out_dir = join(out_dir, "tag")
    template = "tag.html"

    def __init__(self, name=None, posts=None):
        self.name = name

        if posts is None:
            self.posts = []
        else:
            self.posts = posts

    @property
    def out(self):
        """return this tag's output filepath"""
        return join(Tag.out_dir, self.name + out_ext)


class Page(object):
    """
    The pages, 1st, 2nd, 3rd page..
    attributes
      number    int   the order of this page
      posts     list  the posts in this page
      first     bool  is this page the first page?
      last      bool  is this page the last page
    """

    template = "page.html"
    out_dir = join(out_dir, "page")

    def __init__(self, number=1, posts=None, first=False, last=False):
        self.number = number
        self.first = first
        self.last = last

        if posts is None:
            self.posts = []
        else:
            self.posts = posts

    @property
    def out(self):
        if self.first:
            return join(out_dir, "index" + out_ext)
        else:
            return join(Page.out_dir, str(self.number) + out_ext)


class About(object):
    """
    The blog's about page, only one.
    attributes
      markdown  its content
      html      its markdown's html
    about has no header, only body in markdown.
    the `html` is a property decorated method.
    """

    def __init__(self, markdown=None):
        self.markdown = markdown
        self.src = join(src_dir, "about" + src_ext)
        self.out = join(out_dir, "about" + out_ext)
        self.template = "about.html"

    @property
    def html(self):
        """Render its markdown to html"""
        from .parser import parser
        return parser.markdown.render(self.markdown)

    @property
    def content(self):
        """open source file and return the content"""
        if exists(self.src):
            return open(self.src).read().decode(charset)
        else:
            return u''


about = About()

class Tags(object):
    """
    the 'tags.html' of this blog, it displays all tags
    in single page.
    """

    def __init__(self):
        self.template = "tags.html"
        self.out = join(out_dir, "tags" + out_ext)


tags = Tags()

class Archives(object):
    """the 'archives.html' of this blog, it displays all posts
    in single page."""

    def __init__(self):
        self.template = "archives.html"
        self.out = join(out_dir, "archives" + out_ext)


archives = Archives()

class Feed(object):
    """the feed 'feed.atom'"""

    size = 10

    def __init__(self, feed=None):
        self.feed = feed  # pyatom feed object
        self.out = join(out_dir, "feed.atom")

    def write(self):
        """write feed to file"""
        return open(self.out, "w").write(self.feed.to_string().encode(charset))


feed = Feed()

class Page404(object):
    """page 404.html"""

    def __init__(self):
        self.out = join(out_dir, "404" + out_ext)
        self.template = "404.html"


page_404 = Page404()

########NEW FILE########
__FILENAME__ = parser
# coding=utf8

"""this module provides a parser to parse post's source to post instance"""


from . import charset
from .models import Post
from .exceptions import *

from datetime import datetime

import toml
import misaka
import houdini
from misaka import HtmlRenderer, SmartyPants
from pygments import highlight
from pygments.lexers import get_lexer_by_name
from pygments.formatters import HtmlFormatter
from pygments.util import ClassNotFound


class ColorRender(HtmlRenderer, SmartyPants):
    """misaka render with color codes feature"""

    def _code_no_lexer(self, text):
        # encode to utf8 string
        text = text.encode(charset).strip()
        return(
            """
            <div class="highlight">
              <pre><code>%s</code></pre>
            </div>
            """ % houdini.escape_html(text)
        )

    def block_code(self, text, lang):
        """text: unicode text to render"""

        if not lang:
            return self._code_no_lexer(text)

        try:
            lexer = get_lexer_by_name(lang, stripall=True)
        except ClassNotFound:  # lexer not found, use plain text
            return self._code_no_lexer(text)

        formatter = HtmlFormatter()

        return highlight(text, lexer, formatter)


class Parser(object):
    """This initialize an instance so called parser to parse posts from source
    to post instance
    Usage::

        parser = Parser()
        parser.parse(str)   # return post instance
        parser.parse_from(str)  # parse from file's path
        parser.markdown.render(markdown_str)  # render markdown to html
    """

    separator = '---'  # separator between toml header and markdown body

    def __init__(self):
        """Initialize the parser, set markdown render handler as
        an attribute `markdown` of the parser"""
        render = ColorRender()  # initialize the color render
        extensions = (
            misaka.EXT_FENCED_CODE |
            misaka.EXT_NO_INTRA_EMPHASIS |
            misaka.EXT_AUTOLINK |
            misaka.EXT_TABLES
        )

        self.markdown = misaka.Markdown(render, extensions=extensions)

    def parse(self, source):
        """Parse unicode post source to <Post object>"""
        lines = source.splitlines()

        l = None  # flag: if there is separator

        for line_no, line in enumerate(lines):
            if self.separator in line:
                l = line_no  # got the separator's line number
                break

        if not l:
            raise SeparatorNotFound

        # seperate header and body from source
        header, body = "\n".join(lines[:l]), "\n".join(lines[l+1:])

        # check header's validation

        try:
            attrs = toml.loads(header)
        except toml.TomlSyntaxError:  # if header syntax error
            raise PostHeaderSyntaxError

        #TODO: Check title and datetime's type

        if 'title' not in attrs:
            raise PostTitleNotFound

        if 'datetime' not in attrs:
            raise PostDateTimeNotFound
        else:
            try:
                attrs['datetime'] = datetime.strptime(
                    attrs["datetime"], "%Y-%m-%d %H:%M")
            except ValueError:
                raise PostDateTimeInvalid

        tags = attrs.get('tags', [])  # tags is optional

        if not isinstance(tags, list):
            raise PostTagsTypeInvalid

        attrs['markdown'] = body  # append markdown to attributes
        return Post(**attrs)

    def parse_from(self, filepath):
        """parse from filepath, return <Post object>"""
        return self.parse(open(filepath).read().decode(charset))


parser = Parser()  # build a runtime parser

########NEW FILE########
__FILENAME__ = renderer
# coding=utf8

"""renderer to render data with jinja2 templates"""

from . import charset
from .exceptions import JinjaTemplateNotFound
from jinja2 import Environment, FileSystemLoader
from jinja2.exceptions import TemplateNotFound


class Renderer(object):

    def initialize(self, templates_path, global_data):
        """initialized with templates_path.
        parameters
          templates_path    str     the position of templates' directory
          global_data       dict    the global data can be touched in
        any templates
        """
        # initialize jinja2 environment
        self.env = Environment(loader=FileSystemLoader(templates_path))
        self.env.trim_blocks = True
        self.global_data = global_data

    def render(self, template, **data):
        """Render data with template, return html unicodes.
        parameters
          template   str  the template's filename
          data       dict the data to render
        """
        # make a copy and update the copy
        dct = self.global_data.copy()
        dct.update(data)

        try:
            html = self.env.get_template(template).render(**dct)
        except TemplateNotFound:
            raise JinjaTemplateNotFound
        return html

    def render_to(self, path, template, **data):
        """Render data with template and then write to path"""
        html = self.render(template, **data)
        return open(path, "w").write(html.encode(charset))


renderer = Renderer()  # initialized a renderer, and use it each time

########NEW FILE########
__FILENAME__ = server
# coding=utf8

"""web server and watcher"""

from .utils import join
from .models import Post, about
from .config import config
from .logger import logger
from .generator import generator

import sys
import logging
import socket
from os import listdir as ls
from os import stat
from os.path import exists
from time import sleep
from threading import Thread
from SocketServer import ThreadingMixIn
from BaseHTTPServer import HTTPServer
from BaseHTTPServer import BaseHTTPRequestHandler
from SimpleHTTPServer import SimpleHTTPRequestHandler


class Handler(SimpleHTTPRequestHandler):
    """Our own http handler"""

    def log_message(self, format, *args):
        logger.info("%s - %s" % (
            self.address_string(), format % args
        ))


class MultiThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """Multiple threaded http server"""
    pass


class Server(object):
    """To build source to html, optional, can watch files for
    changes to auto rebuild , or start a web server here the same time"""

    def __init__(self):
        # files_stat: filepath to file's updated time dict
        self.files_stat = {}
        # server: the server instance initialized from MultiThreadedHTTPServer
        self.server = None
        # watcher: the thread to watch files for changes
        self.watcher = Thread(target=self.watch_files)
        # this tell thread to terminate when the main process ends
        self.watcher.daemon = True

        # logger.setLevel(logging.INFO)

    def run_server(self, port=8888):
        """run a server binding to port(default 8888)"""

        try:
            self.server = MultiThreadedHTTPServer(('0.0.0.0', port), Handler)
        except socket.error, e:  # failed to bind port
            logger.error(str(e))
            sys.exit(1)

        logger.info("Serve at http://0.0.0.0:%d (ctrl-c to stop it) ..." % port)

        try:
            self.server.serve_forever()
        except KeyboardInterrupt:
            logger.info("^C received, shutting down server")
            self.shutdown_server()

    def get_files_stat(self):
        """Get current filepath to file updated time dict"""
        # posts
        paths = Post.glob_src_files().keys()
        # about
        if exists(about.src):
            paths.append(about.src)
        # config.toml
        if exists(config.filepath):
            paths.append(config.filepath)
        # files - a <filepath to updated time> dict
        files = dict((p, stat(p).st_mtime) for p in paths)
        return files

    def watch_files(self):
        """watch files for changes, if changed, rebuild blog. this thread
        will quit if the main process ends"""

        try:
            while 1:
                sleep(1.5)  # checkout every 1.5s

                files_stat = self.get_files_stat()

                if self.files_stat != files_stat:
                    logger.info("Changes detected, start rebuilding..")

                    try:
                        generator.re_generate(localhost=True)
                        logger.success("Rebuild success")
                    except SystemExit:  # catch sys.exit, it means fatal error
                        logger.error("Error occurred, server shut down")
                        self.shutdown_server()

                    self.files_stat = files_stat  # update files' stat
        except KeyboardInterrupt:
            # I dont know,  but this exception won't be catched
            # because absolutly each KeyboardInterrupt is catched by
            # the server thread, which will terminate this thread the same time
            logger.info("^C received, shutting down watcher")
            self.shutdown_watcher()

    def run(self, watch=False, port=8888):
        """start building blog, options: run a server, start watching
        changes"""
        if watch:  # if watch, start a thread to watch
            self.watcher.start()

        self.run_server(port)

    def shutdown_server(self):
        """shut down the web server"""
        self.server.shutdown()
        self.server.socket.close()

    def shutdown_watcher(self):
        """shut down the watcher thread"""
        self.watcher.join()


server = Server()

########NEW FILE########
__FILENAME__ = signals
# coding=utf8

"""All blinker signals in building process, actually this
enable as to make our plugins. And lilac use it in build-in
building process"""

# Thanks to blinker, great job!!

from blinker import signal

initialized = signal('initialized')
posts_parsed = signal('posts_parsed')
tags_extracted = signal('tags_extracted')
page_composed = signal('page_composed')

########NEW FILE########
__FILENAME__ = utils
# coding=utf8

"""this module provides utility functions that are used within lilac"""

import os
import errno


def chunks(lst, number):
    """
    A generator, split list `lst` into `number` equal size parts.
    usage::

        >>> parts = chunks(range(8),3)
        >>> parts
        <generator object chunks at 0xb73bd964>
        >>> list(parts)
        [[0, 1, 2], [3, 4, 5], [6, 7]]

    """
    lst_len = len(lst)

    for i in xrange(0, lst_len, number):
        yield lst[i: i+number]


def update_nested_dict(a, b):
    """
    update nested dict `a` with another dict b.
    usage::

        >>> a = {'x' : { 'y': 1}}
        >>> b = {'x' : {'z':2, 'y':3}, 'w': 4}
        >>> update_nested_dict(a,b)
        {'x': {'y': 3, 'z': 2}, 'w': 4}

    """
    for k, v in b.iteritems():
        if isinstance(v, dict):
            d = a.setdefault(k, {})
            update_nested_dict(d, v)
        else:
            a[k] = v
    return a


def mkdir_p(path):
    """mkdir -p
    Note: comes from stackoverflow"""
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


def join(*p):
    """return normpath version of path.join"""
    return os.path.normpath(os.path.join(*p))


class Color(object):
    """
     utility to return ansi colored text
     usage::

         >>> colored("text","red")
        '\x1b[31mtext\x1b[0m'

    """
    colors = {
        'black': 30,
        'red': 31,
        'green': 32,
        'yellow': 33,
        'blue': 34,
        'magenta': 35,
        'cyan': 36,
        'white': 37,
        'bgred': 41,
        'bggrey': 100
    }

    prefix = '\033['

    suffix = '\033[0m'

    def colored(self, text, color=None):
        if color not in self.colors:
            color = 'white'

        clr = self.colors[color]
        return (self.prefix+'%dm%s'+self.suffix) % (clr, text)

colored = Color().colored

########NEW FILE########
