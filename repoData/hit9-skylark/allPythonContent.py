__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# skylark documentation build configuration file, created by
# sphinx-quickstart on Wed May 21 21:50:20 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'skylark'
copyright = u'2014, hit9'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.9.0'
# The full version, including alpha/beta/rc tags.
release = '0.9.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'skylarkdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'skylark.tex', u'skylark Documentation',
   u'hit9', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'skylark', u'skylark Documentation',
     [u'hit9'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'skylark', u'skylark Documentation',
   u'hit9', 'skylark', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


sys.path.append(os.path.abspath('_themes'))
html_theme_path = ['_themes']
html_theme = 'plain'
html_theme_options = {
    'github': 'hit9',  # Here, fill in your own GitHub ID
    # 'project_logo': 'https://raw.githubusercontent.com/hit9/artworks/master/png/Skylark.png',  # your project logo address
    'project_logo': 'http://project-logos.qiniudn.com/Skylark.png',
    'navs': [('index', 'overview'), ('quickstart', 'quickstart'), ('snippets', 'snippets'),
             ('https://github.com/hit9/skylark/issues', 'issues'),
             ('https://github.com/hit9/skylark/blob/master/CHANGES', 'changes')]
}

########NEW FILE########
__FILENAME__ = config
# coding=utf8

DB_CONN_CFG = {
    'db': 'mydb',
    'user': 'root',
    'passwd': '',
    'charset': 'utf8'
}

# app's secret_key, you can use `os.urandom(24)` to generate one
SECRET_KEY = '\x1e\xd4Uz\xd5%^g\xf0\x9f\n0\x00y\xd3\x04\xfd\xe5\xac\x1b\x86q\x9d\xd3'

DEBUG = True

########NEW FILE########
__FILENAME__ = models
# coding=utf8


import pymysql
from skylark import Database, Model, Field
from messageboard import app


class Message(Model):
    title = Field()
    content = Field()
    create_at = Field()


Database.set_dbapi(pymysql)
Database.config(**app.config['DB_CONN_CFG'])

########NEW FILE########
__FILENAME__ = views
# coding=utf8

from datetime import datetime

from messageboard import app
from messageboard.models import Message

from flask import flash, render_template, request, redirect, url_for


@app.route('/', methods=['GET'])
def index():
    query = Message.orderby(
        Message.create_at, desc=True).select()  # sort by created time
    results = query.execute()
    messages = results.all()
    return render_template('template.html', messages=messages)


@app.route('/create', methods=['POST'])
def create():
    title = request.form['title']
    content = request.form['content']

    if title and content:
        message = Message.create(
            title=title, content=content, create_at=datetime.now())
        if message is not None:  # ok
            flash(dict(type='success', content='New message created'))
        else:  # create failed
            flash(dict(type='error', content='Failed to create new message'))
    else:  # invalid input
        flash(dict(type='warning', content='Empty input'))
    return redirect(url_for('index'))


@app.route('/delete/<int:id>')
def delete(id):
    query = Message.at(id).delete()
    if query.execute():
        flash(dict(type='success', content='Message %d dropped' % id))
    else:
        flash(dict(type='error', content='Failed to drop message %d' % id))
    return redirect(url_for('index'))

########NEW FILE########
__FILENAME__ = runserver
# coding=utf8

from messageboard import app


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python

import sys
from subprocess import call

if sys.hexversion < 0x03000000:
    PY_VERSION = 2
else:
    PY_VERSION = 3

base_cmd = ('DBAPI=%s NOSE_NOCAPTURE=1 '
            'nosetests -w tests -x -v --nologcapture --process-timeout=4;')

cmds = [base_cmd % 'pymysql', base_cmd % 'sqlite3']

if PY_VERSION == 2:
    cmds.insert(0, base_cmd % 'MySQLdb')

for cmd in cmds:
    exit_code = call(cmd, shell=True)

    if exit_code != 0:
        sys.exit(exit_code)

########NEW FILE########
__FILENAME__ = create
from models import User, Post

User.create(name='Amy', email='Amy@gmail.com')  # return an instance of User

User.create(User.name == 'Join', User.email == 'Join@gmail.com')

user = User(name='Mark', email='Mark@github.com')
user.save()

post = Post()
post.name = 'Hello World'
post.user_id = 1
post.save()

########NEW FILE########
__FILENAME__ = delete
from models import User

query = User.at(3).delete()
query.execute()  # return rows deleted

user = User.at(2).getone()
user.destroy()  # return rows deleted

########NEW FILE########
__FILENAME__ = models
import sqlite3
from skylark import Database, Model, Field, PrimaryKey, ForeignKey

class User(Model):
    name = Field()
    email = Field()

class Post(Model):
    name = Field()
    post_id = PrimaryKey()
    user_id = ForeignKey(User.id)

Database.set_dbapi(sqlite3)
Database.config(db='mydb')

########NEW FILE########
__FILENAME__ = read
from models import User, Post

# get the first user
first_user = User.at(1).getone()
print first_user.name

# get user who called 'Join'
jack = User.where(name='jack').getone()

# get all users
for user in User.select():
    print user.name

# have a look at posts written by 'jack'

[post.name
 for post in Post.join(User).where(User.name == 'jack').select(Post.name)]

########NEW FILE########
__FILENAME__ = sample
# coding=utf8

from skylark import Database, Model, Field


Database.config(user='root', passwd='', db='mytest')


class User(Model):
    name = Field()
    email = Field()


user = User(name='Join', email='Join@gmail.com')
user.save()

########NEW FILE########
__FILENAME__ = update
from models import User


query = User.at(2).update(email='Join@github.com')
query.execute()  # return rows updated

user = User.where(User.email == 'Join@github.com').getone()
user.email = 'Join123@github.com'
user.save()

########NEW FILE########
__FILENAME__ = skylark
# -*- coding: utf-8 -*-
#
#            /)
#           / )
#    (\    /  )
#    ( \  /   )
#     ( \/ / )
#     (@)   )
#     / \_   \
#        // \\\
#        ((   \\
#       ~ ~ ~   \
#      skylark
#

"""
    skylark
    ~~~~~~~

    A micro python orm for mysql and sqlite.

    :author: Chao Wang (Hit9).
    :license: BSD.
"""


__version__ = '0.9.0'


__all__ = (
    '__version__',
    'SkylarkException',
    'UnSupportedDBAPI',
    'PrimaryKeyValueNotFound',
    'SQLSyntaxError',
    'ForeignKeyNotFound',
    'Database', 'database',
    'sql', 'SQL',
    'Field',
    'PrimaryKey',
    'ForeignKey',
    'compiler',
    'fn',
    'distinct', 'Distinct'
    'Model',
    'MultiModels', 'Models',
    'JoinModel'
)


import sys


if sys.hexversion < 0x03000000:
    PY_VERSION = 2
else:
    PY_VERSION = 3

if PY_VERSION == 3:
    from functools import reduce


# common operators (~100)
OP_OP = 0  # custom op
OP_LT = 1
OP_LE = 2
OP_GT = 3
OP_GE = 4
OP_EQ = 5
OP_NE = 6
OP_ADD = 7
OP_SUB = 8
OP_MUL = 9
OP_DIV = 10
OP_MOD = 11
OP_AND = 12
OP_OR = 13
OP_RADD = 27
OP_RSUB = 28
OP_RMUL = 29
OP_RDIV = 30
OP_RMOD = 31
OP_RAND = 32
OP_ROR = 33
OP_LIKE = 99

# special operators (100+)
OP_BETWEEN = 101
OP_IN = 102
OP_NOT_IN = 103

# runtimes
RT_ST = 1
RT_VL = 2
RT_SL = 3
RT_WH = 4
RT_GP = 5
RT_HV = 6
RT_OD = 7
RT_LM = 8
RT_JN = 9
RT_TG = 10
RT_FM = 11


# query types
QUERY_INSERT = 1
QUERY_UPDATE = 2
QUERY_SELECT = 3
QUERY_DELETE = 4


class SkylarkException(Exception):
    pass


class UnSupportedDBAPI(SkylarkException):
    pass


class PrimaryKeyValueNotFound(SkylarkException):
    pass


class SQLSyntaxError(SkylarkException):
    pass


class ForeignKeyNotFound(SkylarkException):
    pass


class DBAPI(object):

    placeholder = '%s'

    def __init__(self, module):
        self.module = module

    def conn_is_open(self, conn):
        return conn and conn.open

    def close_conn(self, conn):
        return conn.close()

    def connect(self, configs):
        return self.module.connect(**configs)

    def set_autocommit(self, conn, boolean):
        return conn.autocommit(boolean)

    def conn_is_alive(self, conn):
        try:
            conn.ping()
        except self.module.OperationalError:
            return False
        return True  # ok

    def get_cursor(self, conn):
        return conn.cursor()

    def execute_cursor(self, cursor, args):
        return cursor.execute(*args)

    def select_db(self, db, conn, configs):
        configs.update({'db': db})
        if self.conn_is_open(conn):
            conn.select_db(db)

    def begin_transaction(self, conn):
        pass

    def commit_transaction(self, conn):
        return conn.commit()

    def rollback_transaction(self, conn):
        return conn.rollback()


class MySQLdbAPI(DBAPI):
    pass


class PyMySQLAPI(DBAPI):

    def conn_is_open(self, conn):
        return conn and conn.socket and conn._rfile


class Sqlite3API(DBAPI):

    placeholder = '?'

    def conn_is_open(self, conn):
        if conn:
            try:
                # return the total number of db rows that have been modified
                conn.total_changes
            except self.module.ProgrammingError:
                return False
            return True
        return False

    def connect(self, configs):
        db = configs['db']
        return self.module.connect(db)

    def set_autocommit(self, conn, boolean):
        if boolean:
            conn.isolation_level = None
        else:
            conn.isolation_level = ''

    def select_db(self, db, conn, configs):
        # for sqlite3, to change database, must create a new connection
        configs.update({'db': db})
        if self.conn_is_open(conn):
            self.close_conn(conn)

    def conn_is_alive(self, conn):
        return 1   # sqlite is serverless


DBAPI_MAPPINGS = {
    'MySQLdb': MySQLdbAPI,
    'pymysql': PyMySQLAPI,
    'sqlite3': Sqlite3API,
}


DBAPI_LOAD_ORDER = ('MySQLdb', 'pymysql', 'sqlite3')


class DatabaseType(object):

    def __init__(self):
        self.dbapi = None
        self.conn = None
        self.configs = {}
        self.autocommit = None

        for name in DBAPI_LOAD_ORDER:
            try:
                module = __import__(name)
            except ImportError:
                continue
            self.set_dbapi(module)
            break

    def set_dbapi(self, module):
        name = module.__name__

        if name in DBAPI_MAPPINGS:
            # clear current configs and connection
            if self.dbapi and self.dbapi.conn_is_open(self.conn):
                self.conn.close()
            self.configs = {}
            self.conn = None
            self.dbapi = DBAPI_MAPPINGS[name](module)
        else:
            raise UnSupportedDBAPI

    def config(self, **configs):
        self.autocommit = configs.pop('autocommit', True)
        self.configs.update(configs)

        # close active connection on configs change
        if self.dbapi.conn_is_open(self.conn):
            self.dbapi.close_conn(self.conn)

    def connect(self):
        self.conn = self.dbapi.connect(self.configs)
        self.dbapi.set_autocommit(self.conn, self.autocommit)
        return self.conn

    def get_conn(self):
        if not (
            self.dbapi.conn_is_open(self.conn) and
            self.dbapi.conn_is_alive(self.conn)
        ):
            self.connect()
        return self.conn

    def __del__(self):
        if self.dbapi.conn_is_open(self.conn):
            return self.dbapi.close_conn(self.conn)

    def execute(self, *args):
        cursor = self.dbapi.get_cursor(self.get_conn())
        self.dbapi.execute_cursor(cursor, args)
        return cursor

    def execute_sql(self, sql):  # execute a sql object
        return self.execute(sql.literal, sql.params)

    def change(self, db):
        return self.dbapi.select_db(db, self.conn, self.configs)

    def set_autocommit(self, boolean):
        self.autocommit = boolean
        if self.dbapi.conn_is_open(self.conn):
            return self.dbapi.set_autocommit(self.conn, boolean)

    def begin(self):
        return self.dbapi.begin_transaction(self.conn)

    def commit(self):
        return self.dbapi.commit_transaction(self.conn)

    def rollback(self):
        return self.dbapi.rollback_transaction(self.conn)

    def transaction(self):
        return Transaction(self)

    select_db = change  # alias


database = Database = DatabaseType()


class Transaction(object):

    def __init__(self, database):
        self.database = database

    def begin(self):
        return self.database.begin()

    def commit(self):
        return self.database.commit()

    def rollback(self):
        return self.database.rollback()

    def __enter__(self):
        self.begin()
        return self

    def __exit__(self, except_tp, except_val, trace):
        return self.commit()


class Leaf(object):

    def _e(op_type, invert=False):
        def e(self, right):
            if invert:
                return Expr(right, self, op_type)
            return Expr(self, right, op_type)
        return e

    __lt__ = _e(OP_LT)
    __le__ = _e(OP_LE)
    __gt__ = _e(OP_GT)
    __ge__ = _e(OP_GE)
    __eq__ = _e(OP_EQ)
    __ne__ = _e(OP_NE)

    __add__ = _e(OP_ADD)
    __sub__ = _e(OP_SUB)
    __mul__ = _e(OP_MUL)
    __div__ = _e(OP_DIV)
    __truediv__ = _e(OP_DIV)
    __mod__ = _e(OP_MOD)
    __and__ = _e(OP_AND)
    __or__ = _e(OP_OR)

    __radd__ = _e(OP_ADD, invert=True)
    __rsub__ = _e(OP_SUB, invert=True)
    __rmul__ = _e(OP_MUL, invert=True)
    __rdiv__ = _e(OP_DIV, invert=True)
    __rtruediv__ = _e(OP_DIV, invert=True)
    __rmod__ = _e(OP_MOD, invert=True)
    __rand__ = _e(OP_AND, invert=True)
    __ror__ = _e(OP_OR, invert=True)

    def like(self, pattern):
        return Expr(self, pattern, OP_LIKE)

    def between(self, left, right):
        return Expr(self, (left, right), OP_BETWEEN)

    def _in(self, *vals):
        return Expr(self, vals, OP_IN)

    def not_in(self, *vals):
        return Expr(self, vals, OP_NOT_IN)

    def op(self, op_str):
        def func(other):
            return Expr(self, other, OP_OP, op_str=op_str)
        return func


class SQL(Leaf):

    def __init__(self, literal, *params):
        self.literal = literal
        self.params = params

    def __repr__(self):
        return '<sql %r %r>' % (self.literal, self.params)

    @classmethod
    def format(cls, spec, *args):
        literal = spec % tuple(arg.literal for arg in args)
        params = sum([arg.params for arg in args], tuple())
        return cls(literal, *params)

    @classmethod
    def join(cls, sptr, seq):
        # seq maybe a generator, so cast it static to iter twice
        seq = tuple(seq)
        literal = sptr.join(sql.literal for sql in seq)
        params = sum([sql.params for sql in seq], tuple())
        return cls(literal, *params)

    def normalize(self):
        # let sql literal behave normal
        self.literal = ' '.join(self.literal.split())  # remove spaces
        # remove unnecessary parentheses
        size = len(self.literal)
        count = 0
        pairs = []

        for p in range(size):
            if self.literal[p] != '(':
                continue
            for q in range(p, size):
                if self.literal[q] == '(':
                    count += 1
                if self.literal[q] == ')':
                    count -= 1
                if count == 0:
                    break
            if count != 0:
                raise SQLSyntaxError  # unbalanced '()'
            pairs.append((p, q))

        blacklist = []

        for p, q in pairs:
            if (p + 1, q - 1) in pairs:
                blacklist.append(p)
                blacklist.append(q)

        self.literal = ''.join(v for k, v in enumerate(self.literal)
                               if k not in blacklist)


sql = SQL


class Expr(Leaf):

    def __init__(self, left, right, op_type, op_str=None):
        self.left = left
        self.right = right
        self.op_type = op_type
        self.op_str = op_str


class Alias(object):

    def __init__(self, name, inst):
        self.name = name
        self.inst = inst


class FieldDescriptor(object):

    def __init__(self, field):
        self.field = field

    def __get__(self, inst, type=None):
        if inst:
            return inst.data[self.field.name]
        return self.field

    def __set__(self, inst, val):
        inst.data[self.field.name] = val


class Field(Leaf):

    def __init__(self, is_primarykey=False, is_foreignkey=False):
        self.is_primarykey = is_primarykey
        self.is_foreignkey = is_foreignkey

    def describe(self, name, model):
        self.name = name
        self.model = model
        self.fullname = '%s.%s' % (model.table_name, name)
        setattr(model, name, FieldDescriptor(self))

    def alias(self, name):
        return Alias(name, self)


class PrimaryKey(Field):

    def __init__(self):
        super(PrimaryKey, self).__init__(is_primarykey=True)


class ForeignKey(Field):

    def __init__(self, reference):
        super(ForeignKey, self).__init__(is_foreignkey=True)
        self.reference = reference


class Function(Leaf):

    def __init__(self, name, *args):
        self.name = name
        self.args = args

    def alias(self, name):
        return Alias(name, self)


class Fn(object):

    def _e(self, name):
        def e(*args):
            return Function(name, *args)
        return e

    def __getattr__(self, name):
        return self._e(name)


fn = Fn()


class Distinct(object):
    # 'distinct user.name, user.email..' -> legal
    # 'user.id distinct user.name' -> illegal
    # 'user.id, count(distinct user.name)' -> legal

    def __init__(self, *args):
        self.args = args


distinct = Distinct


class Query(object):

    def __init__(self, type, runtime):
        self.type = type
        self.sql = compiler.compile(self.type, runtime)
        runtime.reset_data()


class InsertQuery(Query):

    def __init__(self, runtime):
        super(InsertQuery, self).__init__(QUERY_INSERT, runtime)

    def execute(self):
        cursor = database.execute_sql(self.sql)
        last_insert_id = cursor.lastrowid
        rows_affected = cursor.rowcount
        cursor.close()
        if rows_affected:
            return last_insert_id


class UpdateQuery(Query):

    def __init__(self, runtime):
        super(UpdateQuery, self).__init__(QUERY_UPDATE, runtime)

    def execute(self):
        cursor = database.execute_sql(self.sql)
        rows_affected = cursor.rowcount
        cursor.close()
        return rows_affected


class SelectQuery(Query):

    def __init__(self, runtime):
        self.model = runtime.model
        self.nodes = runtime.data[RT_SL]
        super(SelectQuery, self).__init__(QUERY_SELECT, runtime)

    def execute(self):
        cursor = database.execute_sql(self.sql)
        result = SelectResult(tuple(cursor.fetchall()), self.model, self.nodes)
        cursor.close()
        return result

    def __iter__(self):
        result = self.execute()
        return iter(result.all())


class DeleteQuery(Query):

    def __init__(self, runtime):
        super(DeleteQuery, self).__init__(QUERY_DELETE, runtime)

    def execute(self):
        cursor = database.execute_sql(self.sql)
        rows_affected = cursor.rowcount
        cursor.close()
        return rows_affected


class SelectResult(object):

    def __init__(self, rows, model, nodes, rowcount=-1):
        self.rows = rows
        self.model = model
        # for sqlite3, DBAPI2 said rowcount on select will always be -1
        self.count = rowcount if rowcount >= 0 else len(rows)
        self._rows = (row for row in self.rows)

        # distinct should be the first select node if it exists
        if nodes and isinstance(nodes[0], Distinct):
            nodes = list(nodes[0].args) + nodes[1:]
        self.nodes = nodes

    def inst(self, model, row):
        inst = model()
        inst.set_in_db(True)

        for idx, node in enumerate(self.nodes):
            if isinstance(node, Field) and node.model is model:
                inst.data[node.name] = row[idx]
            if isinstance(node, Alias) and isinstance(node.inst, Field) \
                    and node.inst.model is model:
                setattr(inst, node.name, row[idx])
        return inst

    def __one(self, row):
        if self.model.single:
            return self.inst(self.model, row)
        return tuple(map(lambda m: self.inst(m, row), self.model.models))

    def one(self):
        try:
            row = next(self._rows)  # py2.6+/3.0+
        except StopIteration:
            return None
        return self.__one(row)

    def all(self):
        return tuple(map(self.__one, self.rows))

    def tuples(self):
        return self.rows


class Compiler(object):

    mappings = {
        OP_LT: '<',
        OP_LE: '<=',
        OP_GT: '>',
        OP_GE: '>=',
        OP_EQ: '=',
        OP_NE: '<>',
        OP_ADD: '+',
        OP_SUB: '-',
        OP_MUL: '*',
        OP_DIV: '/',
        OP_MOD: '%%',  # escape '%'
        OP_AND: 'and',
        OP_OR: 'or',
        OP_LIKE: 'like',
        OP_BETWEEN: 'between',
        OP_IN: 'in',
        OP_NOT_IN: 'not in',
    }

    def sql2sql(sql):
        return sql

    def query2sql(query):
        return sql.format('(%s)', query.sql)

    def alias2sql(alias):
        spec = '%%s as %s' % alias.name
        return sql.format(spec, compiler.sql(alias.inst))

    def field2sql(field):
        return sql(field.fullname)

    def function2sql(function):
        spec = '%s(%%s)' % function.name
        args = sql.join(', ', map(compiler.sql, function.args))
        return sql.format(spec, args)

    def distinct2sql(distinct):
        args = sql.join(', ', map(compiler.sql, distinct.args))
        return sql.format('distinct(%s)', args)

    def expr2sql(expr):
        if expr.op_str is None:
            op_str = compiler.mappings[expr.op_type]
        else:
            op_str = expr.op_str

        left = compiler.sql(expr.left)

        if expr.op_type < 100:  # common ops
            right = compiler.sql(expr.right)
        elif expr.op_type is OP_BETWEEN:
            right = sql.join(' and ', map(compiler.sql, expr.right))
        elif expr.op_type in (OP_IN, OP_NOT_IN):
            vals = sql.join(', ', map(compiler.sql, expr.right))
            right = sql.format('(%s)', vals)

        spec = '%%s %s %%s' % op_str

        if expr.op_type in (OP_AND, OP_OR):
            spec = '(%s)' % spec

        return sql.format(spec, left, right)

    conversions = {
        SQL: sql2sql,
        Expr: expr2sql,
        Alias: alias2sql,
        Field: field2sql,
        PrimaryKey: field2sql,
        ForeignKey: field2sql,
        Function: function2sql,
        Distinct: distinct2sql,
        Query: query2sql,
        InsertQuery: query2sql,
        UpdateQuery: query2sql,
        SelectQuery: query2sql,
        DeleteQuery: query2sql
    }

    def sql(self, inst):
        tp = type(inst)
        if tp in self.conversions:
            return self.conversions[tp](inst)
        return sql(database.dbapi.placeholder, inst)

    def jn2sql(lst):
        prefix, main, join, expr = lst

        prefix = '' if prefix is None else '%s ' % prefix

        if expr is None:
            foreignkey = _detect_bridge(main, join)
            expr = foreignkey == foreignkey.reference

        spec = '%sjoin %s on %%s' % (prefix, join.table_name)
        return sql.format(spec, compiler.sql(expr))

    def od2sql(lst):
        node, desc = lst
        spec = 'order by %%s%s' % (' desc' if desc else '')
        return sql.format(spec, compiler.sql(node))

    def gp2sql(lst):
        spec = 'group by %s'
        arg = sql.join(', ', map(compiler.sql, lst))
        return sql.format(spec, arg)

    def hv2sql(lst):
        spec = 'having %s'
        arg = sql.join(' and ', map(compiler.sql, lst))
        return sql.format(spec, arg)

    def wh2sql(lst):
        spec = 'where %s'
        arg = sql.join(' and ', map(compiler.sql, lst))
        return sql.format(spec, arg)

    def sl2sql(lst):
        return sql.join(', ', map(compiler.sql, lst))

    def lm2sql(lst):
        offset, rows = lst
        literal = 'limit %s%s' % (
            '%s, ' % offset if offset is not None else '', rows)
        return sql(literal)

    def st2sql(lst):
        pairs = [
            sql.format('%s=%%s' % expr.left.name, compiler.sql(expr.right))
            for expr in lst]
        return sql.join(', ', pairs)

    def vl2sql(lst):
        keys = ', '.join([expr.left.name for expr in lst])
        vals = map(compiler.sql, [expr.right for expr in lst])
        spec = '(%s) values (%%s)' % keys
        arg = sql.join(', ', vals)
        return sql.format(spec, arg)

    def tg2sql(lst):
        args = map(sql, [m.table_name for m in lst])
        return sql.join(', ', args)

    def fm2sql(lst):
        args = map(sql, [m.table_name for m in lst])
        return sql.join(', ', args)

    rt_conversions = {
        RT_OD: od2sql,
        RT_GP: gp2sql,
        RT_HV: hv2sql,
        RT_WH: wh2sql,
        RT_SL: sl2sql,
        RT_LM: lm2sql,
        RT_ST: st2sql,
        RT_VL: vl2sql,
        RT_JN: jn2sql,
        RT_TG: tg2sql,
        RT_FM: fm2sql,
    }

    patterns = {
        QUERY_INSERT: ('insert into %s %s', (RT_TG, RT_VL)),
        QUERY_UPDATE: ('update %s set %s %s', (RT_TG, RT_ST, RT_WH)),
        QUERY_SELECT: ('select %s from %s %s %s %s %s %s %s', (
            RT_SL, RT_FM, RT_JN, RT_WH, RT_GP, RT_HV, RT_OD, RT_LM)),
        QUERY_DELETE: ('delete %s from %s %s', (RT_TG, RT_FM, RT_WH))
    }

    def compile(self, type, runtime):
        pattern = self.patterns[type]

        spec, rts = pattern

        args = []

        for tp in rts:
            data = runtime.data[tp]
            if data:
                args.append(self.rt_conversions[tp](data))
            else:
                args.append(sql(''))

        sq = sql.format(spec, *args)
        sq.normalize()
        return sq


compiler = Compiler()


class Runtime(object):

    RUNTIMES = (
        RT_ST,  # update set
        RT_VL,  # insert values
        RT_SL,  # select fields
        RT_WH,  # where
        RT_GP,  # group by
        RT_HV,  # having
        RT_OD,  # order by
        RT_LM,  # limit
        RT_JN,  # join (inner, left, inner)
        RT_TG,  # target table
        RT_FM,  # from table
    )

    def __init__(self, model):
        self.model = model
        self.reset_data()

    def reset_data(self):
        self.data = dict((k, []) for k in self.RUNTIMES)

    def _e(tp):
        def e(self, lst):
            self.data[tp] = list(lst)
        return e

    set_st = _e(RT_ST)

    set_vl = _e(RT_VL)

    set_sl = _e(RT_SL)

    set_wh = _e(RT_WH)

    set_gp = _e(RT_GP)

    set_hv = _e(RT_HV)

    set_od = _e(RT_OD)

    set_lm = _e(RT_LM)

    set_jn = _e(RT_JN)

    set_tg = _e(RT_TG)

    set_fm = _e(RT_FM)


class MetaModel(type):

    def __init__(cls, name, bases, attrs):
        # table_name is not inheritable
        table_name = cls.__dict__.get(
            'table_name', cls.__default_table_name())
        # table_prefix is inheritable
        table_prefix = getattr(cls, 'table_prefix', None)
        if table_prefix:
            table_name = table_prefix + table_name
        cls.table_name = table_name
        cls.table_prefix = table_prefix

        primarykey = None
        fields = {}
        for key, val in cls.__dict__.items():
            if isinstance(val, Field):
                fields[key] = val
                if val.is_primarykey:
                    primarykey = val
        if primarykey is None:
            fields['id'] = primarykey = PrimaryKey()
        for name, field in fields.items():
            field.describe(name, cls)

        cls.fields = fields
        cls.primarykey = primarykey
        cls.runtime = Runtime(cls)

    def __default_table_name(cls):
        def _e(x, y):
            s = '_' if y.isupper() else ''
            return s.join((x, y))
        return reduce(_e, list(cls.__name__)).lower()

    def __contains__(cls, inst):
        if isinstance(inst, cls):
            if inst._in_db:
                return True
            query = cls.where(**inst.data).select(fn.count(cls.primarykey))
            result = query.execute()
            if result.tuples()[0][0] > 0:
                return True
        return False

    def __and__(cls, other):
        return JoinModel(cls, other)


class Model(MetaModel('NewBase', (object, ), {})):  # py3 compat

    single = True

    def __init__(self, *lst, **dct):
        self.data = {}

        for expr in lst:
            field, val = expr.left, expr.right
            self.data[field.name] = val

        self.data.update(dct)
        self._cache = self.data.copy()
        self.set_in_db(False)

    def set_in_db(self, boolean):
        self._in_db = boolean

    def __kwargs(func):
        @classmethod
        def _func(cls, *lst, **dct):
            lst = list(lst)
            if dct:
                lst.extend([cls.fields[k] == v for k, v in dct.items()])
            return func(cls, *lst)
        return _func

    @__kwargs
    def insert(cls, *lst, **dct):
        cls.runtime.set_vl(lst)
        cls.runtime.set_tg([cls])
        return InsertQuery(cls.runtime)

    @__kwargs
    def update(cls, *lst, **dct):
        cls.runtime.set_st(lst)
        cls.runtime.set_tg([cls])
        return UpdateQuery(cls.runtime)

    @classmethod
    def select(cls, *lst):
        if not lst:
            lst = cls.fields.values()
        cls.runtime.set_sl(lst)
        cls.runtime.set_fm([cls])
        return SelectQuery(cls.runtime)

    @classmethod
    def delete(cls):
        cls.runtime.set_fm([cls])
        return DeleteQuery(cls.runtime)

    @classmethod
    def create(cls, *lst, **dct):
        query = cls.insert(*lst, **dct)
        id = query.execute()

        if id is not None:
            dct[cls.primarykey.name] = id
            inst = cls(*lst, **dct)
            inst.set_in_db(True)
            return inst
        return None

    @__kwargs
    def where(cls, *lst, **dct):
        cls.runtime.set_wh(lst)
        return cls

    @classmethod
    def at(cls, id):
        return cls.where(cls.primarykey == id)

    @classmethod
    def orderby(cls, field, desc=False):
        cls.runtime.set_od((field, desc))
        return cls

    @classmethod
    def groupby(cls, *lst):
        cls.runtime.set_gp(lst)
        return cls

    @classmethod
    def having(cls, *lst):
        cls.runtime.set_hv(lst)
        return cls

    @classmethod
    def limit(cls, rows, offset=None):
        cls.runtime.set_lm((offset, rows))
        return cls

    @classmethod
    def join(cls, model, on=None, prefix=None):
        cls.runtime.set_jn((prefix, cls, model, on))
        return cls

    @classmethod
    def left_join(cls, model, on=None):
        return cls.join(model, on=on, prefix='left')

    @classmethod
    def right_join(cls, model, on=None):
        return cls.join(model, on=on, prefix='right')

    @classmethod
    def full_join(cls, model, on=None):
        return cls.join(model, on=on, prefix='full')

    @classmethod
    def findone(cls, *lst, **dct):
        query = cls.where(*lst, **dct).select()
        result = query.execute()
        return result.one()

    @classmethod
    def findall(cls, *lst, **dct):
        query = cls.where(*lst, **dct).select()
        result = query.execute()
        return result.all()

    @classmethod
    def getone(cls):
        return cls.select().execute().one()

    @classmethod
    def getall(cls):
        return cls.select().execute().all()

    @property
    def _id(self):
        return self.data.get(type(self).primarykey.name, None)

    def save(self):
        model = type(self)

        if not self._in_db:  # insert
            id = model.insert(**self.data).execute()

            if id is not None:
                self.data[model.primarykey.name] = id
                self.set_in_db(True)
                self._cache = self.data.copy()  # sync cache on saving
            return id
        else:  # update
            dct = dict(set(self.data.items()) - set(self._cache.items()))

            if self._id is None:
                raise PrimaryKeyValueNotFound

            if dct:
                query = model.at(self._id).update(**dct)
                rows_affected = query.execute()
            else:
                rows_affected = 0
            self._cache = self.data.copy()
            return rows_affected

    def destroy(self):
        if self._in_db:
            if self._id is None:
                raise PrimaryKeyValueNotFound
            result = type(self).at(self._id).delete().execute()
            if result:
                self.set_in_db(False)
            return result
        return None

    def aggregator(name):
        @classmethod
        def _func(cls, arg=None):
            if arg is None:
                arg = cls.primarykey
            function = Function(name, arg)
            query = cls.select(function)
            result = query.execute()
            return result.tuples()[0][0]
        return _func

    count = aggregator('count')

    sum = aggregator('sum')

    max = aggregator('max')

    min = aggregator('min')

    avg = aggregator('avg')


class MultiModels(object):

    single = False

    def __init__(self, *models):
        self.models = models
        self.runtime = Runtime(self)

    def select(self, *lst):
        if not lst:
            lst = sum([list(m.fields.values()) for m in self.models], [])
        self.runtime.set_sl(lst)
        self.runtime.set_fm(self.models)
        return SelectQuery(self.runtime)

    def delete(self, *targets):  # default target: all (mysql only)
        if not targets:
            targets = self.models
        self.runtime.set_fm(self.models)
        self.runtime.set_tg(targets)
        return DeleteQuery(self.runtime)

    def update(self, *lst):
        self.runtime.set_fm(self.models)
        self.runtime.set_set(lst, {})
        return UpdateQuery(self.runtime)

    def where(self, *lst):
        self.runtime.set_wh(lst)
        return self

    def orderby(self, field, desc=False):
        self.runtime.set_od((field, desc))
        return self

    def groupby(self, *lst):
        self.runtime.set_gp(lst)
        return self

    def having(self, *lst):
        self.runtime.set_hv(lst)
        return self

    def limit(self, rows, offset=None):
        self.runtime.set_lm((offset, rows))
        return self

    def findone(self, *lst):
        query = self.where(*lst).select()
        result = query.execute()
        return result.one()

    def findall(self, *lst):
        query = self.where(*lst).select()
        result = query.execute()
        return result.all()

    def getone(self):
        return self.select().execute().one()

    def getall(self):
        return self.select().execute().all()


Models = MultiModels


class JoinModel(MultiModels):

    def __init__(self, main, join):
        super(JoinModel, self).__init__(main, join)
        self.bridge = _detect_bridge(main, join)

    def build_bridge(func):
        def _func(self, *args, **kwargs):
            self.runtime.data[RT_WH].append(
                self.bridge == self.bridge.reference)
            return func(self, *args, **kwargs)
        return _func

    @build_bridge
    def select(self, *lst):
        return super(JoinModel, self).select(*lst)

    @build_bridge
    def update(self, *lst):
        return super(JoinModel, self).update(*lst)

    @build_bridge
    def delete(self, *targets):
        return super(JoinModel, self).delete(*targets)


def _detect_bridge(m, n):
    # detect foreignkey point between m and n
    models = (m, n)

    for i, k in enumerate(models):
        for field in k.fields.values():
            j = models[1 ^ i]
            if field.is_foreignkey and field.reference is j.primarykey:
                return field
    raise ForeignKeyNotFound

########NEW FILE########
__FILENAME__ = aggregators
from models import User

count = User.count()
max_id = User.max(User.id)
min_id = User.min(User.id)
sum_of_ids = User.sum(User.id)
avg_of_ids = User.avg(User.id)

########NEW FILE########
__FILENAME__ = alias
from models import User
from skylark import fn

query = User.at(1).select(User.name.alias('un'))
result = query.execute()
user = result.one()
user.un  # retrieve `name` by user.un

query = User.select(fn.count(User.name))
result = query.execute()
result.tuples()[0][0]  # retrieve count result by result.tuples()

########NEW FILE########
__FILENAME__ = change_db
from models import Database

Database.change('db2')  # change to `db2`

########NEW FILE########
__FILENAME__ = count_distinct_field
from skylark import fn, distinct
from models import User

# select count(distinct(user.name)) from user
query = User.select(fn.count(distinct(User.name)))
result = query.execute()
return result.tuples()[0][0]

########NEW FILE########
__FILENAME__ = create
from models import User

user = User.create(name='jack', email='jack@gmail.com')  # model instance

user = User(name='Kate', email='kate@gmail.com')
user.save()  # last insert id

########NEW FILE########
__FILENAME__ = delete
from models import User

User.at(1).delete()  # rows affected

user = User.at(2).getone()
user.destroy()  # rows affected

########NEW FILE########
__FILENAME__ = delete_from_multi_tables
from models import User, Post

# delete user from post, user where post.user_id = user.id
query = (Post & User).delete(User)  # mysql supports; sqlite3 dosenot support

########NEW FILE########
__FILENAME__ = expressions_with_priority
from models import User

# select user.id from user where (user.id > '1' and (user.name = 'jack' or user.email = 'abc@abc.com'))
User.where(
    (User.id > 1) & ((User.name == 'jack') | (User.email == 'abc@abc.com'))
).select(User.id)

########NEW FILE########
__FILENAME__ = having
from models import User
from skylark import fn, sql

# create data..
User.create(name='jack')
User.create(name='jack')
User.create(name='foo')

# select count(user.id) as count_id, user.name from user group by user.name having count_id >= '2'
query = User.groupby(User.name).having(
    sql('count_id') >= 2
).select(fn.count(User.id).alias('count_id'), User.name)
result = query.execute()

for row in result.tuples():
    print row[0]  # count of id
    print row[1]  # user's name

########NEW FILE########
__FILENAME__ = instance_in_model
from models import User

user = User(name='jack')

if user in User:
    print 'Some one in table is named jack'

########NEW FILE########
__FILENAME__ = models
import MySQLdb
from skylark import Database, Model, Field, PrimaryKey, ForeignKey


class User(Model):
    name = Field()
    email = Field()


class Post(Model):
    name = Field()
    post_id = PrimaryKey()
    user_id = ForeignKey(User.id)

Database.set_dbapi(MySQLdb)
Database.config(db='mydb', user='root', passwd='')

########NEW FILE########
__FILENAME__ = operators
from models import User

# select user.id, user.name, user.email from user where user.id < '4'
query = User.where(User.id < 4).select()

# select user.id, user.name, user.email from user where user.id <= '4'
query = User.where(User.id <= 4).select()

# select user.id, user.name, user.email from user where user.id > '4'
query = User.where(User.id > 4).select()

# select user.id, user.name, user.email from user where user.id >= '4'
query = User.where(User.id >= 4).select()

# select user.id, user.name, user.email from user where user.id = '4'
query = User.where(User.id == 4).select()

# select user.id, user.name, user.email from user where user.id <> '4'
query = User.where(User.id != 4).select()

# select user.id, user.name, user.email from user where (user.id > '4'
# and user.id < '7')
User.where((User.id > 4) & (User.id < 7)).select()

# select user.id, user.name, user.email from user where (user.id = '4'
# or user.id = '7')
User.where((User.id == 4) | (User.id == 7)).select()

# select user.id, user.name, user.email from user where user.name like '%abc'
User.where(User.name.like('%abc')).select()

# select user.id, user.name, user.email from user where user.id
# between '4' and '7'
User.where(User.id.between(4, 7)).select()

# select user.id, user.name, user.email from user where user.id in ('5', '6')
User.where(User.id._in(5, 6)).select()

# select user.id, user.name, user.email from user where user.id
# not in ('5', '6')
User.where(User.id.not_in(5, 6)).select()

########NEW FILE########
__FILENAME__ = raw_sql
from models import Database

cursor = Database.execute('show tables')

########NEW FILE########
__FILENAME__ = read
from models import User

# user at id=1
user = User.at(1).getone()
user = User.findone(id=1)

# all users
users = User.getall()

# user 2 < id < 5
users = User.findall(User.id > 2, User.id < 5)

########NEW FILE########
__FILENAME__ = subquery
from models import User, Post

# select user.id, user.name, user.email from user where user.id in (select post.user_id from post)
query = User.where(User.id._in(Post.select(Post.user_id))).select()

########NEW FILE########
__FILENAME__ = tuples
from models import User

query = User.select()
results = query.execute()
return results.tuples()  # tuple of rows, each row like: (1L, 'jack', 'jack@gmail.com')

########NEW FILE########
__FILENAME__ = update
from models import User

User.at(1).update(name='tom')  # rows affected

user = User.at(1).getone()
user.save()  # rows affected

########NEW FILE########
__FILENAME__ = models
# coding=utf8

import sys
sys.path.insert(0, '..')

from skylark import Model, PrimaryKey, Field, ForeignKey


class BaseModel(Model):
    table_prefix = 't_'


class User(BaseModel):
    name = Field()
    email = Field()


class Post(BaseModel):
    post_id = PrimaryKey()
    name = Field()
    user_id = ForeignKey(User.id)

########NEW FILE########
__FILENAME__ = tests
# coding=utf8

import os
import sys
import logging
logging.basicConfig(level=logging.INFO)
from decimal import Decimal

import toml

sys.path.insert(0, '..')
from skylark import Database, database, DBAPI_MAPPINGS, DatabaseType,\
    Model, fn, sql, distinct, PrimaryKeyValueNotFound, compiler, Models

from models import User, Post


dbapi_name = os.environ.get('DBAPI', 'MySQLdb')
dbapi = __import__(dbapi_name)
configs = toml.loads(open('conf.toml').read())[dbapi_name]

db_type_mappings = {
    'pymysql': 'mysql',
    'MySQLdb': 'mysql',
    'sqlite3': 'sqlite',
}

db_type = db_type_mappings[dbapi_name]

user_sql = open('%s.user.sql' % db_type).read()
post_sql = open('%s.post.sql' % db_type).read()


database.set_dbapi(dbapi)
logging.info('Using DBAPI %s' % dbapi_name)
database.config(**configs)
database.set_autocommit(True)


class Test(object):

    def setUp(self):
        database.execute(user_sql)
        database.execute(post_sql)

    def tearDown(self):
        database.execute("drop table t_post")
        database.execute("drop table t_user")

    def create_data(self, count, table=None):
        database.set_autocommit(False)
        # lots of insert in a transaction
        with database.transaction():
            if table is 1:  # only create data in table `user`
                for i in range(1, count + 1):
                    User.create(name='name' + str(i), email='email' + str(i))
            elif table is 2:  # only create data in table `post`
                for i in range(1, count + 1):
                    Post.create(name='name' + str(i), user_id=count + 1 - i)
            else:  # both, default
                for i in range(1, count + 1):
                    User.create(name='name' + str(i), email='email' + str(i))
                for i in range(1, count + 1):
                    Post.create(name='name' + str(i), user_id=count + 1 - i)
        database.set_autocommit(True)


class TestDatabase_:

    def setUp(self):
        self.database = DatabaseType()

    def test_alias(self):
        assert database is Database

    def __shouldnt_import(self, name):
        try:
            __import__(name)
            raise Exception
        except ImportError:
            pass

    def test_init(self):
        assert self.database.conn is None
        assert self.database.configs == {}
        assert self.database.dbapi.module.__name__ in DBAPI_MAPPINGS

        # test load orders
        name = self.database.dbapi.module.__name__

        if name == 'MySQLdb':
            assert __import__('MySQLdb')
        elif name == 'pymysql':
            assert __import__('pymysql')
            self.__shouldnt_import('MySQLdb')
        elif name == 'sqlite3':
            assert __import__('sqlite3')
            self.__shouldnt_import('MySQLdb')
            self.__shouldnt_import('pymysql')

    def test_set_dbapi(self):
        self.database.set_dbapi(dbapi)
        assert self.database.dbapi.module.__name__ == dbapi_name


class TestDatabase(Test):

    def setUp(self):
        self.database = DatabaseType()
        self.database.set_dbapi(dbapi)
        super(TestDatabase, self).setUp()

    def test_config(self):
        assert self.database.configs == {}
        self.database.config(**configs)
        assert self.database.configs
        assert not self.database.conn
        self.database.connect()
        assert self.database.conn
        self.database.config(**configs)
        assert not self.database.dbapi.conn_is_open(self.database.conn)

    def test_connect(self):
        assert self.database.conn is None
        self.database.config(**configs)
        conn1 = self.database.connect()
        conn2 = self.database.connect()
        assert conn1 is not conn2
        assert self.database.dbapi.conn_is_open(conn1)
        assert self.database.dbapi.conn_is_open(conn2)

    def test_get_conn(self):
        assert self.database.conn is None
        self.database.config(**configs)
        conn = self.database.get_conn()
        assert conn and self.database.dbapi.conn_is_open(conn)
        assert conn and self.database.dbapi.conn_is_alive(conn)
        conn1 = self.database.get_conn()
        assert conn1 is conn

    def test___del__(self):
        self.database.config(**configs)
        self.database.connect()
        conn = self.database.conn
        dbapi = self.database.dbapi
        del self.database
        conn = None
        assert not dbapi.conn_is_open(conn)

    def test_execute(self):
        self.database.config(**configs)
        cursor = self.database.execute(
            "insert into t_user (name, email) values ('jack', 'i@gmail.com')")
        assert cursor.lastrowid == 1

    def test_execute_sql(self):
        pass

    def change(self):
        self.database.configs(**configs)
        self.database.connect()
        old_conn = self.database.conn
        self.database.execute('create database skylarktests2')
        self.database.change('skylarktests2')
        assert self.database.configs != configs
        if db_type == 'mysql':
            self.database.conn is old_conn
        else:
            self.database.conn is not old_conn
            assert not self.database.dbapi.conn_is_open(old_conn)

    def test_transaction(self):
        db = self.database
        db.config(**configs)
        db.execute("insert into t_user (name, email) values ('j', 'j@i.com')")
        db.set_autocommit(False)
        t = db.transaction()
        try:
            db.execute("insert into t_user set x;")  # syntax error
        except Exception:
            t.rollback()
        else:
            raise Exception
        cursor = db.execute('select count(*) from t_user;')
        db.conn.commit()  # !important
        assert cursor.fetchone()[0] == 1

        with db.transaction() as t:
            db.execute(
                "insert into t_user (name, email) values ('a', 'a@b.com')")
            db.execute(
                "insert into t_user (name, email) values ('a', 'a@b.com')")
        cursor = db.execute('select count(*) from t_user')
        db.commit()
        assert cursor.fetchone()[0] == 3


class TestField_:

    def test_name(self):
        assert User.name.name == 'name'
        assert User.email.name == 'email'
        assert Post.name.name == 'name'
        assert Post.user_id.name == 'user_id'

    def test_fullname(self):
        assert User.name.fullname == 't_user.name'
        assert User.email.fullname == 't_user.email'
        assert Post.name.fullname == 't_post.name'
        assert Post.user_id.fullname == 't_post.user_id'

    def test_model(self):
        assert User.id.model is User
        assert User.name.model is User
        assert User.email.model is User
        assert Post.name.model is Post
        assert Post.user_id.model is Post

    def test_alias(self):
        fd = User.id.alias('user_id')
        assert fd.name == 'user_id'
        assert fd.inst is User.id


class TestPrimaryKey_:

    def test_is_primarykey(self):
        assert User.id.is_primarykey is True
        assert User.name.is_primarykey is False
        assert User.email.is_primarykey is False
        assert Post.post_id.is_primarykey is True
        assert Post.user_id.is_primarykey is False
        assert Post.name.is_primarykey is False


class TestForeignKey_:

    def test_is_foreignkey(self):
        assert User.id.is_foreignkey is False
        assert User.name.is_foreignkey is False
        assert User.email.is_foreignkey is False
        assert Post.post_id.is_foreignkey is False
        assert Post.name.is_foreignkey is False
        assert Post.user_id.is_foreignkey is True


class TestAlias_:

    def setUp(self):
        self._alias = User.name.alias('username')

    def test_name(self):
        assert self._alias.name == 'username'

    def test_inst(self):
        assert self._alias.inst is User.name


class TestAlias(Test):

    def test_function_alias(self):
        User.create(name='jack', email='jack@g.cn')
        User.create(name='jack', email='jack@gg.cn')
        User.create(name='amy', email='amy@g.cn')
        query = User.groupby(User.name).having(sql('count') >= 2).select(
            User.name, fn.count(User.id).alias('count')
        )
        result = query.execute()
        assert result.tuples()[0][1] == 2
        assert result.one().name == 'jack'

    def test_field_alias(self):
        User.create(name='jack', email='jack@g.cn')
        User.create(name='jack', email='jack@g.cn')
        User.create(name='amy', email='amy@g.cn')

        query = User.groupby(User.name).having(
            sql('em').like('%@g.cn')).orderby(User.id).select(
            User.name, User.email.alias('em'))

        assert [(user.name, user.em) for user in query] == [
            ('jack', 'jack@g.cn'), ('amy', 'amy@g.cn')
        ]


class TestModel_:

    def test_table_name(self):
        class MyModel(Model):
            pass
        assert MyModel.table_name == 'my_model'

        class Member(Model):
            pass
        assert Member.table_name == 'member'

        class Cat(Model):
            table_name = 'cute_cat'
        assert Cat.table_name == 'cute_cat'

    def test_table_prefix(self):
        class Users(Model):
            table_prefix = 't_'
        assert Users.table_name == 't_users'

        class CuteDog(Model):
            table_prefix = 'dd_'
        assert CuteDog.table_name == 'dd_cute_dog'

        class Dog(Model):
            table_name = 'custom_table_name'
            table_prefix = 'd_'
        assert Dog.table_name == 'd_custom_table_name'

    def test_table_prefix_is_inheritable(self):
        class X(Model):
            table_prefix = 't_'

        class A(X):
            pass

        class B(X):
            pass

        assert A.table_prefix is X.table_prefix
        assert B.table_prefix is X.table_prefix
        assert A.table_name == 't_a'
        assert B.table_name == 't_b'

    def test_primarykey(self):
        assert User.primarykey is User.id
        assert Post.primarykey is Post.post_id

    def test_fields(self):
        field_names = set(User.fields.keys())
        _field_names = set(('id', 'name', 'email'))
        assert field_names == _field_names
        field_names = set(Post.fields.keys())
        _field_names = set(('post_id', 'name', 'user_id'))
        assert field_names == _field_names


class TestModel(Test):

    def test_insert(self):
        query = User.insert(name='jack', email='jack@gmail.com')
        assert query.execute() == 1
        assert User.count() == 1
        user = User.getone()
        assert user.name == 'jack' and user.email == 'jack@gmail.com'

    def test_update(self):
        user = User.create(name='jack', email='jack@gmail.com')
        assert user.id == 1
        assert user.name == 'jack'
        assert user.email == 'jack@gmail.com'
        assert User.count() == 1

        query = User.at(1).update(email='jack@g.com')
        rows_affected = query.execute()
        assert rows_affected == 1
        user = User.getone()
        assert user.id == 1 and user.email == 'jack@g.com'

    def test_inst_in_model(self):
        user = User.create(name='jack', email='jack@gmail.com')

        # inst with `_in_db=True` won't call db to run a query
        database.conn.close()  # close conn to test if any sql was executed
        database.conn = None
        assert user in User
        assert database.conn is None

        # inst without `_in_db=True` call a query
        assert User(name='amy') not in User
        assert database.conn is not None

    def test_select(self):
        User.create(name='jack', email='jack@gmail.com')
        User.create(name='amy', email='amy@gmail.com')
        User.create(name='tom', email='tom@gmail.com')
        ### select all fields
        query = User.select()
        result = query.execute()
        assert result.count == 3
        for user in result.all():
            assert '%s@gmail.com' % user.name == user.email
        ### select part fields
        query = User.select(User.name)
        result = query.execute()
        assert result.count == 3
        jack = result.one()
        assert jack.name == 'jack'
        amy = result.one()
        assert amy.name == 'amy'
        tom = result.one()
        assert tom.name == 'tom'
        assert result.one() is None
        ### select with where
        query = User.where(name='jack').select()
        result = query.execute()
        assert result.count == 1
        assert result.one().name == 'jack'

    def test_delete(self):
        User.create(name='jack', email='jack@gmail.com')
        User.create(name='amy', email='amy@gmail.com')
        query = User.at(3).delete()
        rows_affected = query.execute()
        assert rows_affected == 0
        query = User.at(1).delete()
        rows_affected = query.execute()
        assert rows_affected == 1
        assert User.count() == 1

    def test_create(self):
        user = User.create(name='jack', email='jack@gmail.com')
        assert user.data == {
            'name': 'jack', 'email': 'jack@gmail.com', 'id': 1
        }
        assert user in User
        assert user._in_db
        assert User.count() == 1

        _user = User.getone()
        assert _user.data == user.data
        assert _user._in_db

    def test_where(self):
        User.create(name='jack', email='jack@gmail.com')
        User.create(name='amy', email='amy@gmail.com')
        User.create(name='tom', email='tom@gmail.com')

        assert ['jack'] == [
            user.name for user in User.where(name='jack').select()]

        assert [1] == [
            user.id for user in User.where(id=1).select()
        ]

        assert ['tom'] == [
            user.name for user in User.where(User.name.like('t%')).select()]

    def test_at(self):
        User.create(name='jack', email='jack@gmail.com')
        assert User.at(1).getone().name == 'jack'
        assert User.at(2).getone() is None
        assert User.at(-1).select().execute().count == 0

    def test_orderby(self):
        User.create(name='jack', email='jack@gmail.com')
        User.create(name='amy', email='amy@gmail.com')
        User.create(name='tom', email='tom@gmail.com')

        query = User.orderby(User.id).select()
        result = query.execute()
        users = result.all()
        assert [(user.id, user.name) for user in users] == [
            (1, 'jack'), (2, 'amy'), (3, 'tom')
        ]

        query = User.orderby(User.id, desc=True).select()
        result = query.execute()
        users = result.all()
        assert [(user.id, user.name) for user in users] == [
            (3, 'tom'), (2, 'amy'), (1, 'jack')
        ]

    def test_groupby(self):
        for x in range(2):
            User.create(name='jack', email='jack@github.com')
        for x in range(3):
            User.create(name='tom', email='jack@github.com')

        query = User.groupby(User.name).orderby(sql('count')).select(
            fn.count(User.id).alias('count'), User.name)
        result = query.execute()
        assert result.tuples() == (
            (2, 'jack'), (3, 'tom')
        )

    def test_having(self):
        for x in range(2):
            User.create(name='jack', email='jack@github.com')
        for x in range(3):
            User.create(name='tom', email='jack@github.com')

        query = User.groupby(User.name).having(sql('count') > 2).select(
            fn.count(User.id).alias('count'), User.name)
        result = query.execute()
        user = result.one()
        count = result.tuples()[0][0]
        assert count == 3 and user.name == 'tom'

    def test_limit(self):
        self.create_data(10)
        query = User.limit(4).select()
        result = query.execute()
        assert result.count == 4
        query = User.limit(9, offset=1).select(User.id)
        result = query.execute()
        assert result.count == 9
        query = User.limit(100, offset=9).select(User.id)
        result = query.execute()
        assert result.count == 1

    def test_distinct(self):
        assert User.create(name='jack', email='jack@github.com')
        assert User.create(name='jack', email='jack@ele.me')
        assert User.create(name='wangchao', email='nz2324@126.com')
        assert User.create(name='hit9', email='nz2324@126.com')
        query = User.select(fn.count(distinct(User.name)))
        result = query.execute()
        count = result.tuples()[0][0]
        assert count == 3

        query = User.orderby(User.id).select(distinct(User.email))
        result = query.execute()
        assert result.tuples() == (
            ('jack@github.com',), ('jack@ele.me',), ('nz2324@126.com', )
        )

        emails = [user.email for user in result.all()]
        assert len(emails) == len(set(emails))

        query = User.orderby(User.id).select(distinct(User.name, User.email))
        try:
            result = query.execute()
        except Exception:  # should raise an error
            pass
        else:
            raise Exception

        query = User.orderby(User.id).select(distinct(User.name), User.email)
        result = query.execute()
        assert result.count == 4

    def test_findone(self):
        assert User.create(name='jack', email='jack@gmail.com')
        assert User.create(name='amy', email='amy@gmail.com')
        jack = User.findone(name='jack')
        amy = User.findone(name='amy')
        assert jack.email == 'jack@gmail.com'
        assert amy.email == 'amy@gmail.com'

    def test_findall(self):
        assert User.create(name='jack', email='jack@gmail.com')
        assert User.create(name='amy', email='amy@gmail.com')

        users = User.findall(User.email.like('%@gmail.com'))
        assert ['jack', 'amy'] == [user.name for user in users]

    def test_getone(self):
        assert User.create(name='jack', email='jack@gmail.com')
        assert User.create(name='amy', email='amy@gmail.com')

        user = User.at(1).getone()
        assert user.name == 'jack' and user.id == 1

        user = User.at(10).getone()
        assert user is None

    def test_getall(self):
        assert User.create(name='jack', email='jack@gmail.com')
        assert User.create(name='amy', email='amy@gmail.com')
        users = User.getall()
        assert ['jack', 'amy'] == [user.name for user in users]

    def test_inst_save(self):
        user = User(name='jack', email='jack@gmail.com')
        assert user.save() == 1  # insert
        assert user._in_db and user in User
        assert User.count() == 1
        assert User.getone().name == 'jack'
        user.email = 'hack@gmail.com'
        assert user.save() == 1  # update
        assert User.getone().email == 'hack@gmail.com'
        # test inst._cache
        assert user.save() == 0  # nothing change

        user = User(name='jack', email='jack@g.cn')
        user.set_in_db(True)
        try:
            user.save()
        except PrimaryKeyValueNotFound:
            pass
        else:
            raise Exception

    def test_inst_desctroy(self):
        user = User(name='jack', email='jack@gmail.com')
        assert user.save() == 1  # insert
        assert user.destroy() == 1  # delete
        user = User.create(name='i', email='b')
        assert user.destroy() == 1  # rows_affected
        user = User(name='a', email='b')
        assert user.destroy() is None

    def test_subquery(self):
        self.create_data(10)

        query = User.where(User.id._in(Post.select(Post.user_id))).select()
        result = query.execute()
        assert result.count == 10

        query = User.where(id=(Post.select(fn.max(Post.user_id)))).select()
        result = query.execute()
        assert result.count == 1
        assert result.one().id == 10

        query = User.where(
            User.id < Post.select(fn.min(Post.user_id))).select()
        result = query.execute()
        assert result.count == 0

    def test_transaction(self):
        database.set_autocommit(False)
        with database.transaction() as t:
            User.create(name='jack', email='jack@gmail.com')

        with database.transaction() as t:
            try:
                User.create(name='amy', id=1)
            except:
                t.rollback()
        database.set_autocommit(True)
        assert User.count() == 1

    def test_join(self):
        User.create(name='jack', email='jack@gmail.com')
        User.create(name='amy', email='amy@gmail.com')
        Post.create(name='Hello world', user_id=1)
        query = User.join(Post).select(User.name)
        result = query.execute()
        assert result.count == 1
        user = result.one()
        assert user.name == 'jack'

    def test_left_join(self):
        User.create(name='jack', email='jack@gmail.com')
        User.create(name='amy', email='amy@gmail.com')
        Post.create(name='Hello world', user_id=1)
        query = User.left_join(Post).select(User.name)
        result = query.execute()
        assert result.count == 2

    def test_right_join(self):
        if db_type != 'sqlite':  # sqlite3 current not support right join
            User.create(name='jack', email='jack@gmail.com')
            User.create(name='amy', email='amy@gmail.com')
            Post.create(name='Hello world', user_id=1)
            query = Post.right_join(User).select()
            result = query.execute()
            assert result.count == 2


class TestSelectResult(Test):

    def test_count(self):
        self.create_data(4, table=1)
        query = User.where(User.id > 4).select()
        result = query.execute()
        assert result.count == 0
        query = User.where(User.id > 3).select()
        result = query.execute()
        assert result.count == 1

    def test_one(self):
        self.create_data(3, table=1)
        query = User.orderby(User.id).select()
        result = query.execute()
        user = result.one()
        assert user.id == 1

    def test_all(self):
        self.create_data(3, table=1)
        query = User.orderby(User.id).select()
        result = query.execute()
        users = result.all()
        assert [user.id for user in users] == [1, 2, 3]

    def test_tuples(self):
        assert User.create(name='jack', email='jack@gmail.com')
        assert User.create(name='amy', email='amy@gmail.com')
        assert User.create(name='tom', email='tom@gmail.com')
        query = User.select(User.id)
        result = query.execute()
        assert result.tuples() == ((1,), (2,), (3,))

    def test_selected_inst_in_db(self):
        self.create_data(4, table=1)
        query = User.select()
        result = query.execute()
        user = result.one()
        assert user._in_db is True
        users = result.all()
        for user in users:
            assert user._in_db is True

    def test_distinct_nodes(self):
        assert User.create(name='jack', email='jack@gmail.com')
        assert User.create(name='amy', email='amy@gmail.com')
        assert User.create(name='amy', email='amy@gmail.com')
        assert User.create(name='tom', email='tom@gmail.com')

        query = User.select(distinct(User.name))
        result = query.execute()
        users = result.all()
        assert [user.name for user in users] == ['jack', 'amy', 'tom']

    def test_a_lot_of_insert_in_transaction(self):
        database.set_autocommit(False)
        with database.transaction():
            for i in range(1000):
                User.create(name=str(i), email=str(i))
        database.set_autocommit(True)


class TestOperators(Test):

    def test_expr_priority(self):
        assert User.create(name='jack', email='jack@gmail.com')
        # query should be:
        #  "(id < 0) and (name='jack' or email='jack@gmail.com')" => 0 rows
        # but not be:
        #  "id < 0 and name = 'jack' or email='jack@gmail.com'" => 1 rows
        query = User.where(
            (User.id < 0) & (
                (User.name == 'jack') | (User.email == 'jack@gmail.com')
            )
        ).select()
        assert query.execute().count == 0  # not 1

        query = User.where(
            (User.id < 0) & (
                User.name == 'jack') | (User.email == 'jack@gmail.com')
        ).select()
        assert query.execute().count == 1

    def test_bitwise_operator(self):
        assert User.create(name='jack', email='jack@gmail.com')
        if db_type != 'sqlite':  # sqlite3 dosen't know operator '^'
            query = User.select(User.id.op('^')(1))
            result = query.execute()
            assert result.tuples()[0][0] == 0

        query = User.select(User.id.op('&')(0))
        result = query.execute()
        assert result.tuples()[0][0] == 0

        query = User.select(sql('').op('~-')(User.id))
        result = query.execute()
        assert result.tuples()[0][0] == 0


class TestOperators_:

    def test_operators(self):
        def eq(expr, string, data):
            string = string.replace('?', database.dbapi.placeholder)
            sq1 = compiler.sql(expr)
            sq2 = sql(string, *data)
            return sq1.literal == sq2.literal and sq1.params == sq2.params

        assert eq(User.id < 1, 't_user.id < ?', (1,))
        assert eq(User.id <= 1, 't_user.id <= ?', (1,))
        assert eq(User.id > 1, 't_user.id > ?', (1,))
        assert eq(User.id >= 1, 't_user.id >= ?', (1,))
        assert eq(User.id == 1, 't_user.id = ?', (1,))
        assert eq(User.id != 1, 't_user.id <> ?', (1,))
        assert eq(User.id + 1, 't_user.id + ?', (1,))
        assert eq(User.id - 1, 't_user.id - ?', (1,))
        assert eq(User.id * 1, 't_user.id * ?', (1,))
        assert eq(User.id / 1, 't_user.id / ?', (1,))
        assert eq(User.id % 1, 't_user.id % ?', (1,))
        assert eq((User.id > 1) & (User.id < 4),
                  '(t_user.id > ? and t_user.id < ?)', (1, 4))
        assert eq((User.id > 1) | (User.id < 4),
                  '(t_user.id > ? or t_user.id < ?)', (1, 4))
        assert eq(1 + User.id, '? + t_user.id', (1,))
        assert eq(1 - User.id, '? - t_user.id', (1,))
        assert eq(1 * User.id, '? * t_user.id', (1,))
        assert eq(1 / User.id, '? / t_user.id', (1,))
        assert eq(1 % User.id, '? % t_user.id', (1,))
        assert eq(1 & User.id, '(? and t_user.id)', (1,))
        assert eq(1 | User.id, '(? or t_user.id)', (1,))
        assert eq(User.name.like('%a'), 't_user.name like ?', ('%a',))
        assert eq(User.id._in(1, 2), 't_user.id in (?, ?)', (1, 2))
        assert eq(User.id.not_in(1, 2), 't_user.id not in (?, ?)', (1, 2))
        assert eq(User.id.between(1, 2), 't_user.id between ? and ?', (1, 2))
        # custom bitwise ops
        assert eq(User.id.op('^')(1), 't_user.id ^ ?', (1,))
        assert eq(User.id.op('&')(1), 't_user.id & ?', (1,))
        assert eq(sql('').op('~')(User.id), ' ~ t_user.id', tuple())


class TestCommonFunctions(Test):

    def test_count(self):
        self.create_data(4)
        assert User.count() == 4
        assert Post.count() == 4
        query = User.select(fn.count(User.id))
        result = query.execute()
        assert result.count == 1
        assert result.tuples()[0][0] == 4

    def test_max(self):
        self.create_data(4)
        query = User.select(fn.max(User.id))
        result = query.execute()
        assert result.count == 1
        assert result.tuples()[0][0] == 4

    def test_min(self):
        self.create_data(4)
        query = User.where(User.id > 2).select(fn.min(User.id))
        result = query.execute()
        assert result.count == 1
        assert result.tuples()[0][0] == 3

    def test_sum(self):
        self.create_data(4)
        query = User.select(fn.sum(User.id))
        result = query.execute()
        assert result.count == 1
        assert result.tuples()[0][0] == 10
        assert User.sum(User.id) == 10

    def test_avg(self):
        self.create_data(4)
        query = User.select(fn.avg(User.id))
        result = query.execute()
        assert result.count == 1
        if db_type == 'mysql':  # return decimal
            # py2.6 compat
            assert result.tuples()[0][0] == User.avg(User.id) == Decimal('2.5')
        else:
            assert result.tuples()[0][0] == User.avg(User.id) == 2.5

    def test_concat(self):
        assert User.create(name='jack', email='jack@gmail.com')
        if db_type != 'sqlite':  # in sqlite, `||` is concat
            query = User.select(fn.concat(User.name, ' + ', User.email))
            result = query.execute()
            assert result.tuples()[0][0] == 'jack + jack@gmail.com'
            query = User.at(1).update(name=fn.concat(User.name, ':'))
            result = query.execute()
            assert result == 1
            jack = User.at(1).getone()
            assert jack.name == 'jack:'
        else:
            query = User.select(User.name.op('||')(' + ').op('||')(User.email))
            result = query.execute()
            assert result.tuples()[0][0] == 'jack + jack@gmail.com'
            query = User.at(1).update(name=User.name.op('||')(':'))
            result = query.execute()
            assert result == 1
            jack = User.at(1).getone()
            assert jack.name == 'jack:'


class TestMultiModels(Test):

    def setUp(self):
        super(TestMultiModels, self).setUp()
        self.create_data(4)
        self.models = Models(Post, User)

    def test_where(self):
        assert self.models.where(
            User.id == Post.user_id).select().execute().count == 4
        assert self.models.where(
            User.id == Post.user_id, User.id == 1
        ).select().execute().count == 1

    def test_select(self):
        for post, user in self.models.where(
            User.id == Post.user_id
        ).select():
            assert user.id == post.user_id

        post, user = self.models.where(
            Post.post_id == User.id
        ).getone()

        assert user.id == post.post_id == 1

    def test_delete(self):
        if db_type != 'sqlite':  # sqlite dosen't support 'delete xx from xxx'
            assert self.models.where(
                User.id == Post.user_id).delete().execute() == 8
            assert self.models.where(
                User.id == Post.user_id).select().execute().count == 0
            assert Post.count() == 0
            assert User.count() == 0

    def test_delete2(self):
        if db_type != 'sqlite':  # sqlite dosen't support 'delete xx from xxx'
            assert self.models.where(
                User.id == Post.user_id).delete(Post).execute() == 4
            assert User.select().execute().count == 4
            assert Post.count() == 0

    def test_groupby(self):
        query = self.models.groupby(User.name).select()
        results = query.execute()
        assert results.count == 4

        query = self.models.groupby(User.name, Post.name).select()
        result = query.execute()
        assert result.count == 16

    def test_having(self):
        query = self.models.groupby(
            User.name).having(fn.count(User.id) >= 1).select()
        results = query.execute()
        assert results.count == 4

        query = self.models.groupby(
            User.name).having(fn.count(User.id) > 4).select()
        results = query.execute()
        assert results.count == 0

        query = self.models.groupby(
            User.name).having(fn.count(User.id) == 4).select()
        results = query.execute()
        assert results.count == 4   # 16 / 4 =4

    def test_distinct(self):
        query = self.models.select(distinct(User.name))
        result = query.execute()
        assert result.count == 4

    def test_orderby(self):
        g = self.models.where(
            Post.post_id == User.id
        ).orderby(User.name, desc=True).getall()
        d = tuple(g)
        assert d == tuple(sorted(d, key=lambda x: x[1].name, reverse=True))

    def test_limit(self):
        query = self.models.where(
            (Post.user_id == User.id) & (User.id > 1)
        ).limit(4, offset=2).select()
        result = query.execute()
        assert result.count == 1

    def test_getone(self):
        post, user = self.models.where(User.id == Post.user_id).getone()
        assert user.id == post.user_id

    def test_getall(self):
        g = self.models.where(User.id == Post.user_id).getall()
        for post, user in g:
            assert post.user_id == user.id


class TestJoinModel(Test):

    def test_select(self):
        assert User.create(name='jack', email='jack@gmail.com')
        assert User.create(name='amy', email='amy@gmail.com')
        assert Post.create(name='hello world!', user_id=1)

        assert [('jack', 'hello world!')] == [
            (user.name, post.name) for user, post in (User & Post).select()]

########NEW FILE########
