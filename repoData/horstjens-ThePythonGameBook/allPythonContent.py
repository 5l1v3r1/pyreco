__FILENAME__ = conf
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# ThePythonGameBook documentation build configuration file, created by
# sphinx-quickstart on Fri Apr 25 07:43:30 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'ThePythonGameBook'
copyright = '2014, Horst JENS'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.4'
# The full version, including alpha/beta/rc tags.
release = '0.4'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = 'images/tux_forkme_pythongamebook491.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = 'images/favicon32.ico'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_domain_indices = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'ThePythonGameBookd'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'ThePythonGameBook.tex', 'ThePythonGameBook Documentation',
   'Horst JENS', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'thepythongamebook', 'ThePythonGameBook Documentation',
     ['Horst JENS'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'ThePythonGameBook', 'ThePythonGameBook Documentation',
   'Horst JENS', 'ThePythonGameBook', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# -- Options for Epub output ----------------------------------------------

# Bibliographic Dublin Core info.
epub_title = 'ThePythonGameBook'
epub_author = 'Horst JENS'
epub_publisher = 'Horst JENS'
epub_copyright = '2014, Horst JENS'

# The basename for the epub file. It defaults to the project name.
#epub_basename = 'ThePythonGameBook'

# The HTML theme for the epub output. Since the default themes are not optimized
# for small screen space, using the same theme for HTML and epub output is
# usually not wise. This defaults to 'epub', a theme designed to save visual
# space.
#epub_theme = 'epub'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# A sequence of (type, uri, title) tuples for the guide element of content.opf.
#epub_guide = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
epub_exclude_files = ['search.html']

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

# Choose between 'default' and 'includehidden'.
#epub_tocscope = 'default'

# Fix unsupported image types using the PIL.
#epub_fix_images = False

# Scale large images.
#epub_max_image_width = 0

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#epub_show_urls = 'inline'

# If false, no index is generated.
#epub_use_index = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = 002_display_fps
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
002_display_fps.py

Open a Pygame window and display framerate.
Program terminates by pressing the ESCAPE-Key.
 
Tested with Python 2.7 and 3.3. 

URL    : http://thepythongamebook.com/en:part2:pygame:step002
Author : horst.jens@spielend-programmieren.at
License: GPL, see http://www.gnu.org/licenses/gpl.html
"""

#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division
import pygame

# Initialize Pygame.
pygame.init()
# Set size of pygame window.
screen=pygame.display.set_mode((640,480))
# Create empty pygame surface.
background = pygame.Surface(screen.get_size())
# Fill the background white color.
background.fill((255, 255, 255))
# Convert Surface object to make blitting faster.
background = background.convert()
# Copy background to screen (position (0, 0) is upper left corner).
screen.blit(background, (0,0))
# Create Pygame clock object.  
clock = pygame.time.Clock()

mainloop = True
# Desired framerate in frames per second. Try out other values.              
FPS = 30
# How many seconds the "game" is played.
playtime = 0.0

while mainloop:
    # Do not go faster than this framerate.
    milliseconds = clock.tick(FPS) 
    playtime += milliseconds / 1000.0 
    
    for event in pygame.event.get():
        # User presses QUIT-button.
        if event.type == pygame.QUIT:
            mainloop = False 
        elif event.type == pygame.KEYDOWN:
            # User presses ESCAPE-Key
            if event.key == pygame.K_ESCAPE:
                mainloop = False
                
    # Print framerate and playtime in titlebar.
    text = "FPS: {0:.2f}   Playtime: {1:.2f}".format(clock.get_fps(), playtime)
    pygame.display.set_caption(text)

    #Update Pygame display.
    pygame.display.flip()

# Finish Pygame.  
pygame.quit()

# At the very last:
print("This game was played for {0:.2f} seconds".format(playtime))


########NEW FILE########
__FILENAME__ = 002_display_fps_pretty
#!/usr/bin/env python

"""
Name:    002_display_fps_yipyip.py
Purpose: Display framerate and playtime
URL:     http://thepythongamebook.com/en:part2:pygame:step002
Author:  yipyip
Licence: gpl, see http://www.gnu.org/licenses/gpl.html
"""

####

import pygame 


####

class PygView(object):

  
    def __init__(self, width=640, height=400, fps=30):
        """Initialize pygame, window, background, font,...
        """
        pygame.init()
        pygame.display.set_caption("Press ESC to quit")
        self.width = width
        self.height = height
        #self.height = width // 4
        self.screen = pygame.display.set_mode((self.width, self.height), pygame.DOUBLEBUF)
        self.background = pygame.Surface(self.screen.get_size()).convert()  
        self.clock = pygame.time.Clock()
        self.fps = fps
        self.playtime = 0.0
        self.font = pygame.font.SysFont('mono', 20, bold=True)


    def run(self):
        """The mainloop
        """
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False 
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        running = False

            milliseconds = self.clock.tick(self.fps)
            self.playtime += milliseconds / 1000.0
            self.draw_text("FPS: %6.3f%sPLAYTIME: %6.3f SECONDS" %
                           (self.clock.get_fps(), " "*5, self.playtime))

            pygame.display.flip()
            self.screen.blit(self.background, (0, 0))
            
        pygame.quit()


    def draw_text(self, text):
        """Center text in window
        """
        fw, fh = self.font.size(text) # fw: font width,  fh: font height
        surface = self.font.render(text, True, (0, 255, 0))
        self.screen.blit(surface, ((self.width - fw) // 2, (self.height - fh) // 2))

####

if __name__ == '__main__':

    # call with width of window and fps
    PygView(640, 400).run()

########NEW FILE########
__FILENAME__ = 003_static_blit
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
003_static_blit.py
static blitting and drawing
url: http://thepythongamebook.com/en:part2:pygame:step003
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

Blitting a surface on a static position
Drawing a filled circle into ballsurface.
Blitting this surface once.
introducing pygame draw methods
The ball's rectangular surface is black because the background
color of the ball's surface was never defined nor filled."""


#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

import pygame
pygame.init()
screen=pygame.display.set_mode((640,480))
background = pygame.Surface(screen.get_size())
background.fill((255,255,255))     # fill the background white (red,green,blue)
background = background.convert()  # faster blitting
ballsurface = pygame.Surface((50,50))     # create a rectangular surface for the ball
#pygame.draw.circle(Surface, color, pos, radius, width=0) # from pygame.org documentation
pygame.draw.circle(ballsurface, (0,0,255), (25,25),25) # draw blue filled circle on ball surface
ballsurface = ballsurface.convert()              # faster blitting
ballx = 320
bally = 240
#------- try out some pygame draw functions --------
# pygame.draw.rect(Surface, color, Rect, width=0): return Rect
pygame.draw.rect(background, (0,255,0), (50,50,100,25)) # rect: (x1, y1, width, height)
# pygame.draw.circle(Surface, color, pos, radius, width=0): return Rect
pygame.draw.circle(background, (0,200,0), (200,50), 35)
# pygame.draw.polygon(Surface, color, pointlist, width=0): return Rect
pygame.draw.polygon(background, (0,180,0), ((250,100),(300,0),(350,50)))
# pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1): return Rect
pygame.draw.arc(background, (0,150,0),(400,10,150,100), 0, 3.14) # radiant instead of grad
#------- blit the surfaces on the screen to make them visible
screen.blit(background, (0,0))     # blit the background on the screen (overwriting all)
screen.blit(ballsurface, (ballx, bally))  # blit the topleft corner of ball surface at pos (ballx, bally)
clock = pygame.time.Clock()
mainloop = True
FPS = 30 # desired framerate in frames per second. try out other values !
playtime = 0.0
while mainloop:
    milliseconds = clock.tick(FPS) # do not go faster than this frame rate
    playtime += milliseconds / 1000.0
    # ----- event handler -----
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            mainloop = False # pygame window closed by user
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                mainloop = False # user pressed ESC
    pygame.display.set_caption("Frame rate: %.2f frames per second. Playtime: %.2f seconds" % (clock.get_fps(),playtime))
    pygame.display.flip()          # flip the screen like in a flipbook
print( "this 'game' was played for %.2f seconds" % playtime)

########NEW FILE########
__FILENAME__ = 003_static_blit_pretty
# -*- coding: utf-8 -*-
"""
003_static_blit_pretty.py
static blitting and drawing (pretty version)
url: http://thepythongamebook.com/en:part2:pygame:step003
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

Blitting a surface on a static position
Drawing a filled circle into ballsurface.
Blitting this surface once.
introducing pygame draw methods
The ball's rectangular surface is black because the background
color of the ball's surface was never defined nor filled."""


import pygame 



class PygView(object):

  
    def __init__(self, width=640, height=400, fps=30):
        """Initialize pygame, window, background, font,...
           default arguments 
        """
        pygame.init()
        pygame.display.set_caption("Press ESC to quit")
        self.width = width
        self.height = height
        self.screen = pygame.display.set_mode((self.width, self.height), pygame.DOUBLEBUF)
        self.background = pygame.Surface(self.screen.get_size()).convert()  
        self.background.fill((255,255,255)) # fill background white
        self.clock = pygame.time.Clock()
        self.fps = fps
        self.playtime = 0.0
        self.font = pygame.font.SysFont('mono', 24, bold=True)

    def paint(self):
        """painting on the surface"""
        #------- try out some pygame draw functions --------
        # pygame.draw.rect(Surface, color, Rect, width=0): return Rect
        pygame.draw.rect(self.background, (0,255,0), (50,50,100,25)) # rect: (x1, y1, width, height)
        # pygame.draw.circle(Surface, color, pos, radius, width=0): return Rect
        pygame.draw.circle(self.background, (0,200,0), (200,50), 35)
        # pygame.draw.polygon(Surface, color, pointlist, width=0): return Rect
        pygame.draw.polygon(self.background, (0,180,0), ((250,100),(300,0),(350,50)))
        # pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1): return Rect
        pygame.draw.arc(self.background, (0,150,0),(400,10,150,100), 0, 3.14) # radiant instead of grad
        # ------------------- blitting a Ball --------------
        myball = Ball() # creating the Ball object
        myball.blit(self.background) # blitting it

    def run(self):
        """The mainloop
        """
        self.paint() 
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False 
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        running = False

            milliseconds = self.clock.tick(self.fps)
            self.playtime += milliseconds / 1000.0
            self.draw_text("FPS: %6.3f%sPLAYTIME: %6.3f SECONDS" %
                           (self.clock.get_fps(), " "*5, self.playtime))

            pygame.display.flip()
            self.screen.blit(self.background, (0, 0))
            
        pygame.quit()


    def draw_text(self, text):
        """Center text in window
        """
        fw, fh = self.font.size(text)
        surface = self.font.render(text, True, (0, 0, 0))
        self.screen.blit(surface, (50,150))

class Ball(object):
    """this is not a native pygame sprite but instead a pygame surface"""
    def __init__(self, radius = 50, color=(0,0,255), x=320, y=240):
        """create a (black) surface and paint a blue ball on it"""
        self.radius = radius
        self.color = color
        self.x = x
        self.y = y
        # create a rectangular surface for the ball 50x50
        self.surface = pygame.Surface((2*self.radius,2*self.radius))    
        # pygame.draw.circle(Surface, color, pos, radius, width=0) # from pygame documentation
        pygame.draw.circle(self.surface, color, (radius, radius), radius) # draw blue filled circle on ball surface
        self.surface = self.surface.convert() # for faster blitting. 
        # to avoid the black background, make black the transparent color:
        # self.surface.set_colorkey((0,0,0))
        # self.surface = self.surface.convert_alpha() # faster blitting with transparent color
        
    def blit(self, background):
        """blit the Ball on the background"""
        background.blit(self.surface, ( self.x, self.y))


    
####

if __name__ == '__main__':

    # call with width of window and fps
    PygView().run()

########NEW FILE########
__FILENAME__ = 004_alphademo
#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" 004_alphademo.py
    colorkey and alpha-value
    url: http://thepythongamebook.com/en:part2:pygame:step004
    author: horst.jens@spielend-programmieren.at
    per-pixel-alpha code by Claudio Canepa <ccanepacc@gmail.com>
    licence: gpl, see http://www.gnu.org/licenses/gpl.html
"""
import pygame
import os

 
def get_alpha_surface( surf, alpha=128, red=128, green=128, blue=128, mode=pygame.BLEND_RGBA_MULT):
    """returns a copy of a surface object with user-defined 
       values for red, green, blue and alpha. 
       Values from 0-255. 
       thanks to Claudio Canepa <ccanepacc@gmail.com>
       for this function."""
  
    tmp = pygame.Surface( surf.get_size(), pygame.SRCALPHA, 32)
    tmp.fill( (red,green,blue,alpha) )
    tmp.blit(surf, (0,0), surf.get_rect(), mode)
    return tmp
 
def bounce(value, direction, bouncing=True, valuemin=0, valuemax=255):
    """bouncing a value (like alpha or color) between 
       baluemin and valuemax. 
       When bouncing is True,
       direction (usually -1 or 1)  is inverted when reaching valuemin or valuemax"""
       
    value += direction # increase or decrase value by direction
    if value <= valuemin:
        value = valuemin
        if bouncing:
            direction *= -1
    elif value >= valuemax:
        value = valuemax
        if bouncing: 
            direction *= -1
    return value, direction  
    
def write(msg="pygame is cool", size=24, color=(255,255,255)):
    myfont = pygame.font.SysFont("None", size)
    mytext = myfont.render(msg, True, color)
    mytext = mytext.convert_alpha()
    return mytext
 
def alphademo(width=800, height=600):
    pygame.init()
    screen=pygame.display.set_mode((width, height))
    background = pygame.Surface(screen.get_size()).convert()
    #background.fill((255, 255, 255))     #fill the background white
    venus = pygame.image.load(os.path.join("data","800px-La_naissance_de_Venus.jpg")).convert()
    # transform venus and blit on background in one go
    pygame.transform.scale(venus, (width, height), background) 
    # --------- png image with convert.alpha() ------------------
    # .png and .gif graphics can have transparency. use convert_alpha()
    pngMonster = pygame.image.load(os.path.join("data", "colormonster.png")).convert_alpha()
    pngMonster0 = pngMonster.copy() # a copy 
    pngMonster3 = pngMonster.copy() # copy for per-pixel alpha
    
    # ---------- jpg image  ------------
    # using .convert() at an .png image is the same as using a .jpg  
    # => no transparency !
    jpgMonster = pygame.image.load(os.path.join("data","colormonster.jpg")).convert()
    jpgMonster0 = jpgMonster.copy() # copy of jpgMonster 
    jpgMonster1 = jpgMonster.copy() # another copy to demonstrate colorkey
    jpgMonster1.set_colorkey((255,255,255)) # make white color transparent
    jpgMonster1.convert_alpha() 
    jpgMonster2 = jpgMonster.copy() # another copy for surface alpha
    jpgMonster3 = jpgMonster.copy() # anoter copy for per-pixel alpha
    # ------- text surfaces ----------
    png0text = write("png (has alpha)")
    png3text = write("png with pixel-alpha")
    jpg0text = write("jpg (no alpha)")
    jpg1text = write("jpg with colorkey")
    jpg2text = write("jpg with surface alpha")
    jpg3text = write("jpg with pixel-alpha")
    # ------- for bitmap-alpha --------
    alpha = 128   # between 0 and 255. 
    direction = 1 # change of alpha
    # ------- for per-pixel-alpha -----
    r = 255 # red
    g = 255 # green
    b = 255 # blue
    a = 255 # pixel-alpha
    modeNr = 7 
    # index 7, int-value 8, name="BLEND_RGB_MULT" ,usage = pygame.BLEND_RGB_MULT
    paper = pygame.Surface((400,100)) # background for instructions
    #paper.fill((0,0,0))              # is already black, no fill necessary
    paper.set_alpha(128)              # half-transparent
    
    
    modelist = [ "BLEND_ADD",
                 "BLEND_SUB",
                 "BLEND_MULT",
                 "BLEND_MIN",
                 "BLEND_MAX",
                 "BLEND_RGBA_ADD",
                 "BLEND_RGBA_SUB",
                 "BLEND_RGBA_MULT",
                 "BLEND_RGBA_MIN",
                 "BLEND_RGBA_MAX" ]
    
    
    # -------  mainloop ----------
    clock = pygame.time.Clock()
    mainloop = True
    effects = False
    while mainloop:
        clock.tick(30)
        screen.blit(background, (0,0)) # draw background every frame
        pygame.display.set_caption("insert/del=red:%i, home/end=green:%i, pgup/pgdwn=blue:%i, +/-=pixalpha:%i press ESC" % ( r, g, b, a))
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False
            elif event.type == pygame.KEYDOWN: # press and release key
                if event.key == pygame.K_ESCAPE:
                    mainloop = False
                if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                    #modeNr += 1
                    #if modeNr > 9: 
                    #    modeNr = 0 # cycle throug number 0 to 9
                    modeNr = (modeNr + 1) % len(modelist) # by yipyip
        mode = pygame.constants.__dict__[modelist[modeNr]]
        # ------ keyb is pressed ? -------
        dr, dg, db, da = 0,0,0,0 # set changing to 0 for red, green, blue, pixel-alpha
        pressed_keys = pygame.key.get_pressed()
        if pressed_keys[pygame.K_PAGEUP]: 
            db = 1 # blue up
        if pressed_keys[pygame.K_PAGEDOWN]: 
            db = -1 # blue down
        if pressed_keys[pygame.K_HOME]:
            dg = 1 # green up
        if pressed_keys[pygame.K_END]:
            dg = -1 # green down
        if pressed_keys[pygame.K_INSERT]:
            dr = 1 # red up
        if pressed_keys[pygame.K_DELETE]:
            dr = -1 # red down
        if pressed_keys[pygame.K_KP_PLUS]:
            da = 1 # alpha up
        if pressed_keys[pygame.K_KP_MINUS]:
            da = -1 # alpha down
        # ------- change color and alpha values -------- 
        alpha, direction = bounce(alpha, direction) # change alpha
        r, dr = bounce(r,dr, False)  # red for per-pixel
        g, dg = bounce(g,dg, False)  # green for per-pixel
        b, db = bounce(b, db, False) # blue for per-pixel
        a, da = bounce(a, da, False) # alpha for per-pixel
        
        # ----- blit jpgMonster0 as ist is, no alpha at all ------
        screen.blit(jpgMonster0, (0, 300))
        screen.blit(jpg0text,(0,550))
        # ------blit jpgMonster1 with the colorkey set to white ------
        screen.blit(jpgMonster1, (200,300))
        screen.blit(jpg1text, (200,550))
        # ----- blit jpgmonster2 with alpha for whole  surface  --------
        jpgMonster2.set_alpha(alpha) # alpha for whole surface
        screen.blit(jpgMonster2, (400,300))  # blit on screen
        screen.blit(jpg2text,(400,550))
        screen.blit(write("surface-alpha: %i" % alpha),(400,570))
        # ----- blit jpgmonster3 with per-pixel alpha-------
        tmp = get_alpha_surface(jpgMonster3, a, r, g, b, mode) # get current alpha
        screen.blit(tmp, (600,300))
        screen.blit(jpg3text, (600, 550))
        # ----- blit pngMonster0 as it is, with transparency from image ---
        screen.blit(pngMonster0, (0, 10))
        screen.blit(png0text, (0, 200))
        # ----- blit pngMonster1 with colorkey set to black ----
        #  ***  png already has alpha, does not need colorkey **
        # ----- blit pngMonster2 with alpha for whole surface -----
        #  *** surface-alpha does not work if surface (png) already has alpha ***
        # ----- blit pngmonster3 with per-pixel alpha-------
        tmp = get_alpha_surface(pngMonster3, a, r, g, b, mode) # get current alpha
        screen.blit(tmp, (600,10))
        screen.blit(png3text, (600,200))
        # ---- instructions ----
        screen.blit(paper, (188,150)) #  semi-transparent background for instructions
        screen.blit(write("press [INS] / [DEL] to change red value: %i" % r,24, (255,255,255)),(190,150))
        screen.blit(write("press [HOME] / [END] to change green value: %i" % g),(190,170))
        screen.blit(write("press [PgUp] / [PgDwn] to chgange blue value: %i"% b), (190, 190))
        screen.blit(write("press [Enter] for mode: %i (%s)" % (mode, modelist[modeNr])), (190,230))
        screen.blit(write("press [+] / [-] (Keypad) to chgange alpha value: %i"% a), (190, 210))
        # ------ next frame --------
        pygame.display.flip()       # flip the screen 30 times a second
        
if __name__ == "__main__":
    alphademo()

########NEW FILE########
__FILENAME__ = 004_alphademo_pretty
#!/usr/bin/env python

"""
004_alphademo_pretty.py
Experiments with colorkey and alpha-value
URL: http://thepythongamebook.com/en:part2:pygame:step004
Author: horst.jens@spielend-programmieren.at, prettifying by yipyip
per-pixel-alpha code by Claudio Canepa <ccanepacc@gmail.com>
Licence: gpl, see http://www.gnu.org/licenses/gpl.html
"""

####

import pygame
import os
import itertools



####

BLENDMODES = ((pygame.BLEND_ADD, "ADD"),
              (pygame.BLEND_SUB, "SUB"),
              (pygame.BLEND_MULT, "MULT"),
              (pygame.BLEND_MIN, "MIN"),
              (pygame.BLEND_MAX, "MAX"),
              (pygame.BLEND_RGBA_ADD, "RGBA ADD"),
              (pygame.BLEND_RGBA_SUB, "RGBA SUB"),
              (pygame.BLEND_RGBA_MULT, "RGBA MULT"),
              (pygame.BLEND_RGBA_MIN, "RGBA MIN"),
              (pygame.BLEND_RGBA_MAX, "RGBA MAX"))

####

def load_pic(name, path="data"):

    return pygame.image.load(os.path.join(path, name))

####

def check(x, minval=0, maxval=255):

    return min(maxval, max(minval, x))
    
####
 
def get_alpha_surface(surface, rgba=(128, 128, 128, 128), mode=pygame.BLEND_RGBA_ADD):
    """
    Return a copy of a surface object with user-defined 
    values for red, green, blue and alpha. Values from 0-255. 
    (Thanks to Claudio Canepa <ccanepacc@gmail.com>)
    """  
    new_surface = pygame.Surface(surface.get_size(), pygame.SRCALPHA|pygame.HWSURFACE)
    new_surface.fill(rgba)
    new_surface.blit(surface, (0, 0), surface.get_rect(), mode)
    
    return new_surface

####

class AlphaDemo(object):


    def __init__(self, width=900, height=600, fontsize=14):

        pygame.init()
        self.screen = pygame.display.set_mode((width, height), pygame.DOUBLEBUF)
        self.background = pygame.Surface(self.screen.get_size()).convert()
        self.font = pygame.font.SysFont('mono', fontsize, bold=True)
        self.clock = pygame.time.Clock()
        
        #self.background.fill((255, 255, 255))
        venus = load_pic("800px-La_naissance_de_Venus.jpg").convert()
        # transform venus and blit 
        pygame.transform.scale(venus, (width, height), self.background)
        
        # .png and .gif graphics can have transparency, use convert_alpha()
        self.png_monster = load_pic("colormonster.png").convert_alpha()
        
        # jpg image, no transparency!
        self.jpg_monster = load_pic("colormonster.jpg").convert()

        # per pixel rgba
        self.pp_rgba = [255, 255, 255, 128]
        alpha_up = range(0, 256, 4)
        alpha_down = alpha_up[-1::-1]
        self.glob_alphas = itertools.cycle(alpha_up + alpha_down)
        self.step = 4
        self.mode_nr = 5


    def run(self):
        """
        Mainloop
        """
        mainloop = True
        while mainloop:
            self.clock.tick(20)
            # draw background every frame
            self.screen.blit(self.background, (0, 0))
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    mainloop = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        mainloop = False

            self.action(pygame.key.get_pressed())
            pygame.display.flip()
           

    def action(self, pressed_keys):

        red, green, blue, alpha = self.pp_rgba
        if pressed_keys[pygame.K_PAGEUP]: 
            blue = blue + self.step
        if pressed_keys[pygame.K_PAGEDOWN]: 
            blue = blue - self.step    
        if pressed_keys[pygame.K_HOME]:
            green = green + self.step    
        if pressed_keys[pygame.K_END]:
            green = green - self.step
        if pressed_keys[pygame.K_INSERT]:
            red = red + self.step    
        if pressed_keys[pygame.K_DELETE]:
            red = red - self.step   
        if pressed_keys[pygame.K_KP_PLUS]:
            alpha = alpha + self.step  
        if pressed_keys[pygame.K_KP_MINUS]:
            alpha = alpha - self.step
        if pressed_keys[pygame.K_RETURN]:
            self.mode_nr = (self.mode_nr + 1) % len(BLENDMODES)    
        
        mode, mode_text = BLENDMODES[self.mode_nr]
        self.pp_rgba = map(check, (red, green, blue, alpha))       
        glob_alpha = self.glob_alphas.next()
        self.show_surfaces(self.png_monster, 'png', 0, 0, 200, 180,
                           glob_alpha, self.pp_rgba, mode)
        self.show_surfaces(self.jpg_monster, 'jpg', 0, 300, 200, 180,
                           glob_alpha, self.pp_rgba, mode)

        text = "ins/del=red>%d  home/end=green>%d  pgup/pgdwn=blue>%d  "\
               "+/-=ppalpha>%d  " % tuple(self.pp_rgba)
        pygame.display.set_caption("%s  Mode>%s" % (text, mode_text))
      
  
    def show_surfaces(self, surf, pictype, x, y, x_delta, height,
                      glob_alpha, pp_rgba, mode):

        yh = y + height
        #pure surface
        self.screen.blit(surf, (x, y))
        self.write(x, y + height, "%s pure" % pictype)
        # with with colorkey
        ck_surf = surf.copy()
        ck_surf.set_colorkey((255,255,255))
        x = x + x_delta
        self.screen.blit(ck_surf, (x, y))
        self.write(x, yh, "%s colorkey" % pictype)
        # with alpha for whole surface 
        alpha_surf = surf.copy()
        alpha_surf.set_alpha(glob_alpha)
        x = x + x_delta
        self.screen.blit(alpha_surf, (x, y))
        self.write(x, yh, "%s alpha> %d" % (pictype, glob_alpha))
        # with per-pixel alpha
        ppa_surf = surf.copy()
        ppa_surf = get_alpha_surface(ppa_surf, pp_rgba, mode)
        x = x + x_delta
        self.screen.blit(ppa_surf, (x, y))
        self.write(x, yh, "%s, per-pixel-alpha" % pictype)


    def write(self, x, y, msg, color=(255,255,0)):

        self.screen.blit(self.font.render(msg, True, color), (x, y))
            
####
        
if __name__ == "__main__":
    
    AlphaDemo().run()

########NEW FILE########
__FILENAME__ = 004_alphademo_pretty_python3x
#!/usr/bin/env python

"""
004_alphademo_pretty_python3x.py
This program should work with python3.x only
Experiments with colorkey and alpha-value
URL: http://thepythongamebook.com/en:part2:pygame:step004
Author: horst.jens@spielend-programmieren.at, prettifying by yipyip
python3.x adaption by Andrei
per-pixel-alpha code by Claudio Canepa <ccanepacc@gmail.com>
Licence: gpl, see http://www.gnu.org/licenses/gpl.html
"""

####

import pygame
import os
import itertools

####

BLENDMODES = ((pygame.BLEND_ADD, "ADD"),
              (pygame.BLEND_SUB, "SUB"),
              (pygame.BLEND_MULT, "MULT"),
              (pygame.BLEND_MIN, "MIN"),
              (pygame.BLEND_MAX, "MAX"),
              (pygame.BLEND_RGBA_ADD, "RGBA ADD"),
              (pygame.BLEND_RGBA_SUB, "RGBA SUB"),
              (pygame.BLEND_RGBA_MULT, "RGBA MULT"),
              (pygame.BLEND_RGBA_MIN, "RGBA MIN"),
              (pygame.BLEND_RGBA_MAX, "RGBA MAX"))

####

def load_pic(name, path="data"):

    return pygame.image.load(os.path.join(path, name))

####

def check(x, minval=0, maxval=255):

    return min(maxval, max(minval, x))
    
####
 
def get_alpha_surface(surface, rgba=(128, 128, 128, 128), mode=pygame.BLEND_RGBA_ADD):
    """
    Return a copy of a surface object with user-defined 
    values for red, green, blue and alpha. Values from 0-255. 
    (Thanks to Claudio Canepa <ccanepacc@gmail.com>)
    """  
    new_surface = pygame.Surface(surface.get_size(), pygame.SRCALPHA|pygame.HWSURFACE)
    new_surface.fill(rgba)
    new_surface.blit(surface, (0, 0), surface.get_rect(), mode)
    
    return new_surface

####

class AlphaDemo(object):


    def __init__(self, width=900, height=600, fontsize=14):

        pygame.init()
        self.screen = pygame.display.set_mode((width, height), pygame.DOUBLEBUF)
        self.background = pygame.Surface(self.screen.get_size()).convert()
        self.font = pygame.font.SysFont('mono', fontsize, bold=True)
        self.clock = pygame.time.Clock()
        
        #self.background.fill((255, 255, 255))
        venus = load_pic("800px-La_naissance_de_Venus.jpg").convert()
        # transform venus and blit 
        pygame.transform.scale(venus, (width, height), self.background)
        
        # .png and .gif graphics can have transparency, use convert_alpha()
        self.png_monster = load_pic("colormonster.png").convert_alpha()
        
        # jpg image, no transparency!
        self.jpg_monster = load_pic("colormonster.jpg").convert()

        # per pixel rgba
        self.pp_rgba = [255, 255, 255, 128]
        alpha_up = list(range(0, 256, 4))                           # 3.x change by Andrei
        alpha_down = alpha_up[-1::-1]                               # 3.x change by Andrei
        self.glob_alphas = itertools.cycle(alpha_up + alpha_down)   # 3.x change by Andrei
        self.step = 4
        self.mode_nr = 5


    def run(self):
        """
        Mainloop
        """
        mainloop = True
        while mainloop:
            self.clock.tick(20)
            # draw background every frame
            self.screen.blit(self.background, (0, 0))
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    mainloop = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        mainloop = False

            self.action(pygame.key.get_pressed())
            pygame.display.flip()
           

    def action(self, pressed_keys):

        red, green, blue, alpha = self.pp_rgba
        if pressed_keys[pygame.K_PAGEUP]: 
            blue = blue + self.step
        if pressed_keys[pygame.K_PAGEDOWN]: 
            blue = blue - self.step    
        if pressed_keys[pygame.K_HOME]:
            green = green + self.step    
        if pressed_keys[pygame.K_END]:
            green = green - self.step
        if pressed_keys[pygame.K_INSERT]:
            red = red + self.step    
        if pressed_keys[pygame.K_DELETE]:
            red = red - self.step   
        if pressed_keys[pygame.K_KP_PLUS]:
            alpha = alpha + self.step  
        if pressed_keys[pygame.K_KP_MINUS]:
            alpha = alpha - self.step
        if pressed_keys[pygame.K_RETURN]:
            self.mode_nr = (self.mode_nr + 1) % len(BLENDMODES)    
        
        mode, mode_text = BLENDMODES[self.mode_nr]
        self.pp_rgba = list(map(check, (red, green, blue, alpha))) # 3.x change by Andrei
        glob_alpha = next(self.glob_alphas) # 3.x change by Andrei
        self.show_surfaces(self.png_monster, 'png', 0, 0, 200, 180,
                           glob_alpha, self.pp_rgba, mode)
        self.show_surfaces(self.jpg_monster, 'jpg', 0, 300, 200, 180,
                           glob_alpha, self.pp_rgba, mode)

        text = "ins/del=red>%d  home/end=green>%d  pgup/pgdwn=blue>%d  "\
               "+/-=ppalpha>%d  " % tuple(self.pp_rgba)
        pygame.display.set_caption("%s  Mode>%s" % (text, mode_text))
      
  
    def show_surfaces(self, surf, pictype, x, y, x_delta, height,
                      glob_alpha, pp_rgba, mode):

        yh = y + height
        #pure surface
        self.screen.blit(surf, (x, y))
        self.write(x, y + height, "%s pure" % pictype)
        # with with colorkey
        ck_surf = surf.copy()
        ck_surf.set_colorkey((255,255,255))
        x = x + x_delta
        self.screen.blit(ck_surf, (x, y))
        self.write(x, yh, "%s colorkey" % pictype)
        # with alpha for whole surface 
        alpha_surf = surf.copy()
        alpha_surf.set_alpha(glob_alpha)
        x = x + x_delta
        self.screen.blit(alpha_surf, (x, y))
        self.write(x, yh, "%s alpha> %d" % (pictype, glob_alpha))
        # with per-pixel alpha
        ppa_surf = surf.copy()
        ppa_surf = get_alpha_surface(ppa_surf, pp_rgba, mode)
        x = x + x_delta
        self.screen.blit(ppa_surf, (x, y))
        self.write(x, yh, "%s, per-pixel-alpha" % pictype)


    def write(self, x, y, msg, color=(255,255,0)):

        self.screen.blit(self.font.render(msg, True, color), (x, y))
            
####
        
if __name__ == "__main__":
    
    AlphaDemo().run()

########NEW FILE########
__FILENAME__ = 004_colorkey
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
004_colorkey.py
dynamic blitting and colorkey
url: http://thepythongamebook.com/en:part2:pygame:step004
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

Blitting one surface on 2 static positions, once before the
mainloop and once inside the mainloop.
using colorkey to make a part of the surfaces tranparent
blitting lines on the screen to create a colourful pattern
like in a screensaver
"""
 
import pygame
import random
pygame.init()
screen=pygame.display.set_mode((640,480))
background = pygame.Surface(screen.get_size())
background.fill((255,255,255))     # fill the background white (red,green,blue)
background = background.convert()  # faster blitting
ballsurface = pygame.Surface((50,50))     # create a new surface (black by default)
ballsurface.set_colorkey((0,0,0))         # make black the transparent color (red,green,blue)
#pygame.draw.circle(Surface, color, pos, radius, width=0)
pygame.draw.circle(ballsurface, (0,0,255), (25,25),25) # paint blue circle
ballsurface = ballsurface.convert_alpha()        # faster blitting, convert_alpha() because transparency
screen.blit(background, (0,0))     #draw background on screen (overwriting all)
ballx = 20   # left ball position
bally = 240
screen.blit(ballsurface, (ballx, bally))  #draw the ball surface (lines will draw over this ball)
ballx2 = 400  # right ball position
bally2 = 380
clock = pygame.time.Clock()
mainloop = True
FPS = 30 # desired framerate in frames per second. try out other values !
playtime = 0.0
t = 0 # variable used to draw a pattern
color1 = 0
color2 = 0
while mainloop:
    milliseconds = clock.tick(FPS) # do not go faster than this framerate
    playtime += milliseconds / 1000.0
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            mainloop = False # pygame window closed by user
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                mainloop = False # user pressed ESC
    # ------- draw cute pattern ------------------
    pygame.draw.line(screen, (color1,255-color1,color2), (32*t,0), (0,480-24*t))
    pygame.draw.line(screen, (255-color2,color2,color1), (32*t,480), (640,480-24*t))
    screen.blit(ballsurface, (ballx2, bally2))  #draw the ball over the lines 
    t += 1   # increase t
    if t > 20:
        t = 0 # reset t
        color1 = random.randint(0,255) # new color
        color2 = random.randint(0,255)
    # --------- end of cute pattern drawing code ----------
    pygame.display.set_caption("Frame rate %.2f frames per second. Playtime: %.2f seconds" % (clock.get_fps(),playtime))  
    pygame.display.flip()          # flip the screen 30 times a second
print "This 'game' was played for %.2f seconds." % playtime

########NEW FILE########
__FILENAME__ = 004_per-pixel-alphademo
#!/usr/bin/env python

"""
004_per-pixel-alphademo.py
Experiments with per-pixel alpha value. Use mouse and scrollwheel !
URL: http://thepythongamebook.com/en:part2:pygame:step004
Author:   Dirk Ketturkat  dkt@alice.de
Licence: Do What The Fuck You Want To Public License (WTFPL) http://sam.zoy.org/wtfpl/
"""
  
####

import pygame
import os

####

def load_pic(name, path="data"):

    pic = pygame.image.load(os.path.join(path, name))
    if pic.get_alpha():
        return pic.convert_alpha()
    else:
        return pic.convert()

####

def check(x, minval=0, maxval=255):
    
    return min(maxval, max(minval, x))
    
####

def offset(len1, len2):
    """ For picture centering
    """
    return max(0, (len1 - len2) // 2)

####

class PeepDemo(object):


    def __init__(self, **opts):

        pygame.init()
        self.width = opts['width']
        self.height = opts['height']
        self.fps = opts['fps']
        self.screen = pygame.display.set_mode((self.width, self.height), pygame.DOUBLEBUF)
        self.clock = pygame.time.Clock()
        pygame.display.set_caption("Move Mouse and Scroll Mouse Wheel")

        self.pic = load_pic(opts['pic'])
        self.background = pygame.Surface(self.screen.get_size()).convert()  
        self.background.fill(opts['backcol'])

        self.ppa_surface = pygame.Surface(self.screen.get_size(), flags=pygame.SRCALPHA)
        self.pic_offset = offset(self.width, self.pic.get_width()),\
                          offset(self.height, self.pic.get_height())

        # init stuff for circles with alpha value 
        self.center = self.width // 2, self.height // 2
        self.max_radius = min(self.width, self.height)
        self.hole_count = opts['holes']
        self.calc_centers(self.center, self.center, self.hole_count)
        self.calc_rad_alphas(self.max_radius, self.hole_count)


    def calc_rad_alphas(self, radius, n):
        """
        Calculate linear radius and alpha values
        """
        assert 0 < n < 256, "Invalid number of holes!"

        rad_step = radius // n
        alpha_step = 256 // n
        self.rad_alphas = [(radius - i * rad_step, 255 - i*alpha_step) for i in xrange(n)]
             

    def calc_centers(self, center, pos, holes):
        """
        Calculate center points from center (of window) to mouse position
        """

        cx, cy = center
        mx, my = pos 
        vx, vy = mx - cx, my - cy

        xs = vx // holes
        ys = vy // holes
        self.centers = [(cx + xs*i, cy + ys*i) for i in xrange(holes)]

        
    def run(self):
        """
        Mainloop
        """
        mainloop = True
        while mainloop:
            self.flip()
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    mainloop = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        mainloop = False
                elif event.type == pygame.MOUSEMOTION:
                    self.calc_centers(self.center, pygame.mouse.get_pos(),
                                      self.hole_count)
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    # check mouse wheel
                    if event.button in (4, 5):
                        self.hole_count = check(self.hole_count+ [-1, 1][event.button-4],
                                                2, 64)  
                        self.calc_rad_alphas(self.max_radius, self.hole_count)
                        self.calc_centers(self.center, pygame.mouse.get_pos(),
                                          self.hole_count)
                        
            self.show()
        pygame.quit()
            
   
    def show(self):
        """
        Draw all
        """

        # picture on screen
        self.screen.blit(self.pic, self.pic_offset)
        # circles on alpha surface
        for (r, a), c in zip(self.rad_alphas, self.centers):
            pygame.draw.circle(self.ppa_surface, (0, 0, 0, a), c, r)

        # alpha surface on screen
        self.screen.blit(self.ppa_surface, (0, 0))
        # erase alpha surface for new circles
        self.ppa_surface.fill((0, 0, 0))
        
 
    def flip(self):
        """
        Show drawing and erase
        """
        pygame.display.flip()
        self.screen.blit(self.background, (0, 0))
        self.clock.tick(self.fps)
            
####

opts = {'width': 800,
        'height': 600,
        'backcol': (255, 0, 0),
        'fps': 100,
        'fontsize': 18,
        'pic': 'ente.jpg',
        'holes': 7}
####

if __name__ == "__main__":

    PeepDemo(**opts).run()

########NEW FILE########
__FILENAME__ = 005_frame_based_movement
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
005_bouncing_ball_frame_based.py
bouncing ball and pulsating circle
url: http://thepythongamebook.com/en:part2:pygame:step005
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

bouncing ball. each frame the complete screen is filled with the background,
making this example simple to code but possible slow on larger resolutions.
Each frame, a random-coloured circle is drawn with randomized radius directly on the screen.
Try to manipulate the display.set_mode values to change the resolution."""
import pygame
import random
pygame.init()
screen=pygame.display.set_mode((640,480),) # try out larger values and see what happens !
screenrect = screen.get_rect()
# ------ constants ------------
clock = pygame.time.Clock()
mainloop = True
FPS = 30 # desired framerate in frames per second. 
playtime = 0
radius = 50 # for pulsating circle
dr = 1  # change of radius in pixel per frame
# ------- background ---------
background = pygame.Surface(screen.get_size())
background.fill((255,155,155))     #fill the background white (red,green,blue)
background = background.convert()
screen.blit(background, (0,0))     #draw background on screen (overwriting all)
# -------- bouncing ball surface ---------
ballsurface = pygame.Surface((50,50))     #create a new surface (black by default)
ballsurface.set_colorkey((0,0,0))         #make black the transparent color (red,green,blue)
#pygame.draw.circle(Surface, color, pos, radius, width=0)
pygame.draw.circle(ballsurface, (100,175,81), (25,25),25) # paint blue circle
ballsurface = ballsurface.convert_alpha()       # if you use tranparent colors you need convert_alpha()
ballrect = ballsurface.get_rect() # the rectangle of the ball surface, for collision detection
ballx, bally = 550, 240           # start position of the ball (x,y)
dx = 10                 # x speed vector of the ball in pixel per frame            
dy = 0                 # y speed vector of the ball in pixel per frame
# ----------- bouncing ball (drawing) ------
x1 = 50
y1 = 200
dx1 = 7
dy1 = 0
radius1 = 40
# --------- static big blue ball -----------
pygame.draw.circle(background, (0,0,200), (screenrect.width/2, screenrect.height/2), screenrect.width/3)
# --------- mainloop ----------
while mainloop:
    # do all this each frame
    milliseconds = clock.tick(FPS) # do not go faster than this framerate
    playtime += milliseconds / 1000.0
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            mainloop = False # pygame window closed by user
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                mainloop = False # user pressed ESC
    pygame.display.set_caption("FPS: %.2f X: %.2f Y: %.2f dx: %.2f dy:"
                               " %.2f" % (clock.get_fps(), ballx, bally, dx, dy))
    # ----- clean screen ----------
    screen.blit(background, (0,0))     #draw background on screen (overwriting all)
    # ------- bouncing ball (drawing) ---------
    x1 += dx1
    if x1 + radius1 >= screenrect.width:
        x1 = screenrect.width - radius1
        dx1 *= -1
    elif x1 - radius1 <= 0:
        x1 =  radius1
        dx1 *= -1
    pygame.draw.circle(screen, (255,255,0), (x1,y1), radius1)
    # -------- bouncing ball surface ----------
    ballx += dx
    bally += dy 
    if ballx < 0: # bounce ball if out of screen
        ballx = 0
        dx *= -1 
    elif ballx + ballrect.width > screenrect.width:
        ballx = screenrect.width - ballrect.width
        dx *= -1
    screen.blit(ballsurface, (round(ballx,0), round(bally,0)))    
    # ----- pulsating circle -----------
    colour = (random.randint(0,255),random.randint(0,255),random.randint(0,255))
    if radius >100 or radius < 5:
        dr *= -1
    radius += dr
    pygame.draw.circle(screen, colour , (100,100), radius, 2) # draw pulsating circle
    # --------- flip screen ------------------
    pygame.display.flip()          # flip the screen FPS times a second
print "This 'game' was played for %.2f seconds." % playtime

########NEW FILE########
__FILENAME__ = 005_frame_based_movement_pretty
#!/usr/bin/env python

"""
Name   : blit_pulse2.py
URL    : http://thepythongamebook.com/en:part2:pygame:step003
Author : yipyip
Licence: gpl, see http://www.gnu.org/licenses/gpl.html
"""

####

import pygame as pyg
import random as rand

####

def random_rgb():
    
   return rand.randint(0, 255), rand.randint(0,255), rand.randint(0, 255)

####

class PygView(object):

  
    def __init__(self, width=800, height=600, fps=50):
        """Initializing background surface for static drawing
           and screen surface for dynamic drawing 
        """
        pyg.init()
        pyg.display.set_caption("Press ESC to quit")
        
        self.width = width
        self.height = height
        
        self.screen = pyg.display.set_mode((self.width, self.height), pyg.DOUBLEBUF)
        self.background = pyg.Surface(self.screen.get_size()).convert()  
        # white blackground
        self.background.fill((255, 255, 255))

        self.act_surface = self.screen
        self.act_rgb = 255, 0, 0

        
    def draw_static(self):

        self.act_surface = self.background


    def draw_dynamic(self):

        self.act_surface = self.screen


    def set_color(self, rgb):

        self.act_rgb = rgb

        
    def circle(self, x, y, radius, width):
        """Allocate surface for blitting and draw circle
        """
        rad2 = 2 * radius
        surface = pyg.Surface((rad2, rad2))
        pyg.draw.circle(surface, self.act_rgb, (radius, radius), radius, width)
        surface.set_colorkey((0, 0, 0))
        self.act_surface.blit(surface.convert_alpha(), (x, y))


    def run(self, draw_dynamic):
        """The mainloop
        """
        running = True
        while running:
            for event in pyg.event.get():
                if event.type == pyg.QUIT:
                    running = False 
                elif event.type == pyg.KEYDOWN:
                    if event.key == pyg.K_ESCAPE:
                        running = False

            draw_dynamic()
            pyg.display.flip()
            self.screen.blit(self.background, (0, 0))
            
        pyg.quit()

####

class Ball(object):
    """A circle object with no hardcoded dependency on pygame
       (and other libs too, obviously...)
    """
    def __init__(self, x, y, radius, speed_x=1, speed_pulse=0, color=(0,0,255), width=0):

        self.x = x
        self.y = y
        self.radius = radius
        self.act_radius = radius
        self.speed_x = speed_x
        self.speed_pulse = speed_pulse
        self.color = color
        self.width = width
        self.shrinking = True


    @property
    def max_x(self):

        return self.x + self.radius * 2
    
        
    def rel_move(self, dx, dy):

        self.x += dx
        self.y += dy


    def pulse(self):
        """Shrink or expand ball
        """
        if not self.speed_pulse:
            return

        # balls are shrinking first 
        if self.shrinking:
            if self.act_radius > self.width:
                self.act_radius -= self.speed_pulse
                self.act_radius = max(self.act_radius, self.width)
            else:
                self.shrinking = False
        else:
            if self.act_radius < self.radius:
                self.act_radius += self.speed_pulse
            else:
                self.shrinking = True
        
        
    def draw(self, view):
        """ Draw on a device with an appropriate interface
        """
        if self.speed_pulse:
            color = random_rgb()
        else:
            color = self.color 
        view.set_color(color)
        view.circle(self.x, self.y, self.act_radius, self.width)
     
####

def action(balls, width, view):
    """ Return a function for the pygame mainloop
    """
    # balls move to the right first 
    right_moving = [True] * len(balls)

    def animate_balls():
        """ Draw moving balls
        """
        for i, ball in enumerate(balls):
            if right_moving[i]:
                if ball.max_x < width:
                    ball.rel_move(ball.speed_x, 0)
                else:
                    right_moving[i] = False
            else:
                if ball.x > 0:
                    ball.rel_move(-ball.speed_x, 0)
                else:
                    right_moving[i] = True
            
            ball.pulse() 
            ball.draw(view)

    return animate_balls    
        
####

def main(width):
    """Simple example with stationary and moving balls
    """   
    view = PygView(width)
    
    view.draw_static()
    # args:  x, y, radius, speed_x, speed_pulse, color, border_width
    # border_width <= radius !
    ball01 = Ball(50, 60, 50, 0, 0, (255, 255, 0))
    ball01.draw(view)
    ball02 = Ball(250, 150, 190, 0, 0, (66, 1, 166))
    ball02.draw(view)

    view.draw_dynamic()
    ball1 = Ball(15, 130, 100, 1, 0, (255, 0, 0))
    ball2 = Ball(25, 200, 80, 2, 0, (0, 255, 155))
    ball3 = Ball(20, 220, 110, 1, 1, (100, 55, 155))
    ball4 = Ball(20, 400, 70, 3, 0, (250, 100, 255))
    ball5 = Ball(90, 390, 70, 0, 1, (250, 100, 255), 1)

    loopfunc = action((ball1, ball2, ball4, ball5), width, view)
    view.run(loopfunc)

####
    
if __name__ == '__main__':

    main(900)
    

########NEW FILE########
__FILENAME__ = 006_time_based_movement
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
006_time_baed_movement.py
url: http://thepythongamebook.com/en:part2:pygame:step006
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html
 
bouncing ball. Movement is now time based.
Because at coding, you never know exactly how many milliseconds
will have been passed between two frames, this example use pygame's
clock function to calculate the passed time and move the ballsurface at
constantly the same speed. 
If you toggle the wild circle painting by pressing SPACE, the computer
has more to paint, framerate will drop, more time will pass between 
2 frames and movement of the ball surface will be choppy (less smooth).
However, the movent speed remain unchanged because of the time-based movement.
"""
import pygame
import random
#pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
pygame.init()
screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
screenrect = screen.get_rect()
background = pygame.Surface(screen.get_size()) #create surface for background
background.fill((255,255,255))     #fill the background white (red,green,blue)
background = background.convert()  #convert surface for faster blitting
background2 = background.copy()    # clean background to restore for later 
ballsurface = pygame.Surface((50,50))     #create a new surface (black by default)
ballsurface.set_colorkey((0,0,0))         #make black the transparent color (red,green,blue)
#pygame.draw.circle(Surface, color, pos, radius, width=0)
pygame.draw.circle(ballsurface, (0,0,255), (25,25),25) # paint blue circle
ballsurface = ballsurface.convert_alpha()        # for faster blitting. because transparency, use convert_alpha()
ballrect = ballsurface.get_rect()
ballx, bally = 550,240             # start position for the ball surface (topleft corner)
dx,dy  = 60, 50                    # speed of ball surface in pixel per second !
screen.blit(background, (0,0))     #blit the background on screen (overwriting all)
screen.blit(ballsurface, (ballx, bally))  #blit the ball surface on the screen (on top of background)
 
 
clock = pygame.time.Clock()        #create pygame clock object
mainloop = True
FPS = 60                           # desired max. framerate in frames per second. 
playtime = 0
paint_big_circles = False
 
while mainloop:
    milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
    seconds = milliseconds / 1000.0 # seconds passed since last frame (float)
    playtime += seconds
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            mainloop = False # pygame window closed by user
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                mainloop = False # user pressed ESC
            elif event.key == pygame.K_SPACE: # toggle painting 
                paint_big_circles = not paint_big_circles
            elif event.key == pygame.K_c: # restore old background
                background.blit(background2, (0,0)) # clean the screen
    pygame.display.set_caption("[FPS]: %.2f X:%.1f Y:%.1f press Space"
    "to toggle painting, c to clean" % (clock.get_fps(), ballx, bally))
    screen.blit(background, (0,0))     #draw background on screen (overwriting all)
    if paint_big_circles:
        pygame.draw.circle(background, (random.randint(0,255),
                          random.randint(0,255), random.randint(0,255)),
                          (random.randint(0,screenrect.width),
                           random.randint(0,screenrect.height)),
                           random.randint(50,500))
    #calculate new center of ball (time-based)
    ballx += dx * seconds # float, since seconds passed since last frame is a decimal value
    bally += dy * seconds 
    # bounce ball if out of screen
    if ballx < 0:
        ballx = 0
        dx *= -1 
    #elif ballx + ball.get_width() > screen.get_width():
    elif ballx + ballrect.width > screenrect.width:
        ballx = screenrect.width - ballrect.width
        dx *= -1
    if bally < 0:
        bally = 0
        dy *= -1
    elif bally + ballrect.height > screenrect.height:
        bally = screenrect.height - ballrect.height
        dy *= -1
    # paint the ball    
    screen.blit(ballsurface, (round(ballx,0), round(bally,0 )))
    pygame.display.flip()          # flip the screen 30 times a second
print "This 'game' was played for %.2f seconds" % playtime

########NEW FILE########
__FILENAME__ = 007_loading_files_from_folders_and_subsurfaces
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
007_loading_files_from_folders_and_subsurfaces.py
loading images (from subfolder) and dirtyrects
url: http://thepythongamebook.com/en:part2:pygame:step007
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

press p to toggle painting of pretty background
press d to toggle dirtyrect painting 
press c to restore the ugly image

pretty Venus image from:
http://en.wikipedia.org/wiki/File:La_naissance_de_V%C3%A9nus.jpg
http://commons.wikimedia.org/wiki/Sandro_Botticelli

ugly image from Horst JENS
"""
import pygame
import random
import os
pygame.init()
folder = "data" # replace with "." if pictures lay in the same folder as program
try: # try to load images from the harddisk
    prettybackground = pygame.image.load(os.path.join(folder, "800px-La_naissance_de_Venus.jpg"))
    uglybackground = pygame.image.load(os.path.join(folder, "background800x470.jpg"))
    snakesurface = pygame.image.load(os.path.join(folder,"snake.gif")) # with tranparent colour
except:
     msg= "\nSadly i could not open one of those pictures from the folder 'data': \n"
     msg+="800px-La_naissance_de_Venus.jpg \n"
     msg+="background800x470.jpg \n"
     msg+="snake.gif \n"
     msg+="please make sure that files and folder exist. \n"
     msg+="see http://thepythongamebook.com/en:part2:pygame:step007 for more information"
     raise UserWarning, msg # print error message and exit program 
screen=pygame.display.set_mode((800,470)) # try out larger values and see what happens !
screenrect = screen.get_rect()
prettybackground = prettybackground.convert()  #convert (no alpha! because no tranparent parts) for faster blitting
uglybackground = uglybackground.convert() # no alpha !
background = uglybackground.copy() # the actual background
snakesurface = snakesurface.convert_alpha()
snakerect = snakesurface.get_rect()

# mypicture = pygame.image.load("picturefile.jpg") # simple method if picture in same folder
x = 1     # start position for the snake surface (topleft corner)
y = 1             
dx,dy  = 40, 85                    # speed of ball surface in pixel per second !
screen.blit(uglybackground, (0,0))     #blit the background on screen (overwriting all)
screen.blit(snakesurface, (x, y))  #blit the ball surface on the screen (on top of background)
clock = pygame.time.Clock()        #create pygame clock object
mainloop = True
FPS = 60                           # desired max. framerate in frames per second. 
playtime = 0
painting = False # do not overpaint the ugly background yet
dirty = False # do clear dirty part of screen

while mainloop:
    milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
    seconds = milliseconds / 1000.0 # seconds passed since last frame (float)
    playtime += seconds
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            mainloop = False # pygame window closed by user
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                mainloop = False # user pressed ESC

            elif event.key == pygame.K_c: # restore old background
                background = uglybackground.copy() # the old ugly background
                screen.blit(uglybackground,(0,0))
                print "ugly background restored!"
            elif event.key == pygame.K_p: # paint pretty background
                painting = not painting # toggle
                print "painting is now set to %s" % painting
            elif event.key == pygame.K_d:
                dirty = not dirty # toggle
                print "dirty is now set to %s" % dirtyrect
                
    
    
    pygame.display.set_caption("[FPS]: %.2f dx:%i dy:%i p:"
    "toggle paint, d: toggle dirtyrect, c: restore" % (clock.get_fps(), dx, dy))
    #this would repaint the whole screen (secure, but slow)
    #screen.blit(background, (0,0))     #draw background on screen (overwriting all)
    #this only repaints the "dirty" part of the screen
    if not dirty: # calculate dirtyrect and blit it
        dirtyrect = background.subsurface((x,y,snakerect.width, snakerect.height))
        screen.blit(dirtyrect, (x,y))
    x += dx * seconds # float, since seconds passed since last frame is a decimal value
    y += dy * seconds 
    # bounce snake if out of screen
    if x < 0:
        x = 0
        dx *= -1 
        dx += random.randint(-15,15) # new random direction
    elif x + snakerect.width >= screenrect.width:
        ballx = screenrect.width - snakerect.width
        dx *= -1 
        dx += random.randint(-15,15) 
    if y < 0:
        y = 0
        dy *= -1
        dy += random.randint(-15,15) 
    elif y + snakerect.height >= screenrect.height:
        y = screenrect.height - snakerect.height
        dy *= -1 
        dy += random.randint(-15,15) 
    # paint the snake
    screen.blit(snakesurface, (x,y))
    # TV corner: paint a subsurface on the screen of this part of prettybackground
    # where snake is at the moment (rect argument)
    try:
        tvscreen = prettybackground.subsurface((x,y,snakerect.width, snakerect.height))
    except:
        print "some problem with subsurface"
    screen.blit(tvscreen, (0,0)) # blit into screen like a tv 
    if painting:
        background.blit(tvscreen, (x,y)) # blit from pretty background into background
    pygame.display.flip()          # flip the screen 30 times a second
print "This 'game' was played for %.2f seconds" % playtime

########NEW FILE########
__FILENAME__ = 008_animation
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
008_animation.py
animation & spritesheet
url: http://thepythongamebook.com/en:part2:pygame:step008
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html


spritesheet from
http://www.flyingyogi.com

using subsurface, this program gets "sprites" from a sprite sheet 
and display them, creating an animation.
"""
import pygame
import random
import os
pygame.init()
folder = "data" # replace with "." if pictures lay in the same folder as program
try: 
    spritesheet = pygame.image.load(os.path.join(folder, "char9.bmp"))
except: 
    raise UserWarning, "i'm unable to load 'cahr9.bmp' form the folder 'data'" # error msg and exit

screen=pygame.display.set_mode((800,480)) # try out larger values and see what happens !
spritesheet.convert() # convert only works afteer display_setmode is set.
screenrect = screen.get_rect()
background = pygame.Surface((screen.get_size()))
backgroundrect = background.get_rect()
background.fill((255,255,255)) # fill white
background = background.convert()
screen.blit(background,(0,0))

lions = [] # a list for the lion images
# the spritesheet has lions, 128 x 64 pixels
for nbr in range(1,5,1): # first line contains 4 pictures of lions
   lions.append(spritesheet.subsurface((127*(nbr-1),64,127,127)))
for nbr in range(5,7,1): # second line contains 2 pictures of lions
   lions.append(spritesheet.subsurface((127*(nbr-5),262-64,127,127)))
print "len:",len(lions)

for nbr in range(len(lions)):
   lions[nbr].set_colorkey((0,0,0)) # black transparent
   lions[nbr] = lions[nbr].convert_alpha()
   print "converted nbr", nbr

for nbr in range(len(lions)):
    screen.blit(lions[nbr], (nbr*127, 0))  #blit the ball surface on the screen (on top of background)
    print "blitted nbr", nbr

screen.blit(lions[nbr], (nbr*127, 0))  #blit the ball surface on the screen (on top of background)
#screen.blit(lions[1], (x, 
clock = pygame.time.Clock()        #create pygame clock object
mainloop = True
FPS = 60                           # desired max. framerate in frames per second. 
playtime = 0
cycletime = 0 
#newnr = 0 # index of the first lionimage to display
#oldnr = 0 # needed to compare if image has changed
interval = .15 # how long one single images should be displayed in seconds 
picnr = 0
while mainloop:
    milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
    seconds = milliseconds / 1000.0 # seconds passed since last frame (float)
    playtime += seconds
    cycletime += seconds
    if cycletime > interval:        
        mypicture = lions[picnr] ## 
        screen.blit(background.subsurface((300,300,128,66)),(300,300)) ##
        screen.blit(mypicture, (300,300)) 
        picnr += 1
        if picnr > 5:
            picnr = 0
        cycletime = 0

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            mainloop = False # pygame window closed by user
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                mainloop = False # user pressed ESC
 
    pygame.display.set_caption("[FPS]: %.2f picture: %i" % (clock.get_fps(), picnr))
    #this would repaint the whole screen (secure, but slow)
    #screen.blit(background, (0,0))     #draw background on screen (overwriting all)

    pygame.display.flip()          # flip the screen 30 times a second
print "This 'game' was played for %.2f seconds" % playtime

########NEW FILE########
__FILENAME__ = 009_01_tile_based_graphic_(ugly)
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
009_01_tile_based_graphic_(ugly).py
tile based graphic 
url: http://thepythongamebook.com/en:part2:pygame:step009
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html
 
maze game without pygame sprites and tile-based graphic,
no external files necessary
 
escape the maze by pressing the cursor keys
this program has some bugs, like that the ball can move throug a block sometimes
"""   
def mazegame():
 
    import pygame
    import random
 
    pygame.init()
    screen=pygame.display.set_mode((640,480)) 
    screenrect = screen.get_rect()
    background = pygame.Surface((screen.get_size()))
    backgroundrect = background.get_rect()
    background.fill((255,255,255)) # fill white
    background = background.convert()
    background0 = background.copy()
    screen.blit(background,(0,0))
 
    ballsurface = pygame.Surface((10,10))
    ballsurface.set_colorkey((0,0,0)) # black transparent
    pygame.draw.circle(ballsurface,(255,0,0),(5,5),5) # red ball
    ballsurface = ballsurface.convert_alpha()
    ballrect = ballsurface.get_rect()
 
    dx = 0 # delta x ... x moving vector of ball surface
    dy = 0 # delta y ... y moving vector of ball surface
 
    # -------------------- maze ----------------
    # s...startposition of ball
    # n...next level
    # p...previous level
    # r...random level
    # e...end (game won)
    # x...wall 
 
    #syntax: levelname = ["firstline", "secondline",..]
 
    #startlevel: 24 x 15
    startlevel = ["xxx.xxxxxxxxxxxxxxxxxx",
                  ".s.....x..............",
                  "xxxx.........xx......x",
                  "x......x....x.x......x",
                  "x......x......x......x",
                  "x......x......x......x",
                  "x...xxxxxx....x......x",
                  "x......x.............x",
                  "x......x......xxxxxxxx",
                  "xxxxxx.x.............x",
                  "x......x.............x",
                  "x......x.............x",
                  "x..........xxxx...xxxx",
                  "x..........x.........x",
                  "xxxxxxxxxxxxxxxxx.xxnx"]
    # middlelevel = 15 x 16
    middlelevel =  ["xxxxxxxxxxxxxxx",
                    "xs............x",
                    "x.........x...x",
                    "x.........x...x",
                    "x......x..x...x",
                    "x.....x...x...x",
                    "x..p.xxxxxx...x",
                    "x.....x.......x",
                    "x.x....x......x",
                    "x.x...........x",                   
                    "x.x...x.......x",
                    "x.x....x......x",
                    "x.xxxxxxx..n..x",
                    "x......x......x",
                    "x.....x.......x",
                    "xxxxxxxxxxxxxxx"]
    # smilelevel: 32 x 18
    winlevel = ["xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
                "xs.............................x",
                "x..............................x",
                "x..............................x",
                "x............xxx....xxx........x",
                "x...........xx.xx..xx.xx.......x",
                "x............xxx....xxx........x",
                "x..............................x",
                "x................x.............x",
                "x................x.............x",
                "x................x.............x",
                "x..............................x",
                "x................r.............x",
                "x............xx....xxx.........x",
                "x.............xxxxxxx..........x",
                "x..............................x",
                "x..............................x",
                "xxxxxxpxxxxxxxxxxxnxxxxxxxxxxxex"]
 
 
    def createblock(length, height, color):
        tmpblock = pygame.Surface((length, height))
        tmpblock.fill(color)
        tmpblock.convert()
        return tmpblock
 
    def addlevel(level):
        """this function read the layout of the level dictionary
           and blit it to the screen.
           recalculate and return variables like block, height etc.
           usage:
 
           length, height, block, goal, ballx, bally, background = addlevel(newlevel)
        """
 
        lines = len(level)
        columns = len(level[0])
 
        length = screenrect.width / columns
        height = screenrect.height / lines
 
        wallblock = createblock(length, height,(20,0,50))
        nextblock = createblock(length, height,(255,50,50))
        prevblock = createblock(length, height,(255,50,255))
        endblock  = createblock(length, height,(100,100,100))
        randomblock = createblock(length, height,(0,0,200))
 
        background = background0.copy()
 
        for y in range(lines):
            for x in range(columns):
                if level[y][x] == "x": # wall
                    background.blit(wallblock, (length * x, height * y))
                elif level[y][x] == "n": # next level
                    background.blit(nextblock, (length * x, height * y))
                elif level[y][x] == "p": # previous level
                    background.blit(prevblock, (length * x, height * y))
                elif level[y][x] == "r": # random level
                    background.blit(randomblock, (length*x, height * y))
                elif level[y][x] == "e": # end block
                    background.blit(endblock,  (length * x, height * y))
                elif level[y][x] == "s": #start
                    ballx = length * x
                    bally = height * y
        screen.blit(background0, (0,0))
 
        return length, height, ballx, bally , lines, columns, background
 
    # a list holding all levels
    all_levels = [startlevel, middlelevel, winlevel]  
    max_levels = len(all_levels)        
    my_maze = all_levels[0] # start with the first level
    length, height,  ballx, bally, lines, columns, background = addlevel(my_maze)
    # ------------------- maze --------------------------
 
 
    clock = pygame.time.Clock() #create pygame clock object
    mainloop = True
    FPS = 60         # desired max. framerate in frames per second. 
    playtime = 0
 
    while mainloop:
        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame (float)
        playtime += seconds
 
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                # pygame window closed by user
                mainloop = False 
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False 
                if event.key == pygame.K_UP:
                    dy -= 1 
                if event.key == pygame.K_DOWN:
                    dy += 1
                if event.key == pygame.K_RIGHT:
                    dx += 1
                if event.key == pygame.K_LEFT:
                    dx -= 1
        pygame.display.set_caption("[FPS]: %.2f dx: %i dy %i press cursor keys to move ball" % (clock.get_fps(), dx, dy))
        screen.blit(background, (0,0)) # delete all
        # ---------find out probing point of ball surface
        if dx > 0:
            pointx = ballx + ballrect.width
        else:
            pointx = ballx
        if dy > 0:
            pointy = bally + ballrect.height
        else:
            pointy = bally
        # ------- find out if ball want to leave screen
        if pointx + dx < 0:
            ballx = 0
            pointx = 0
            dx = 0
        elif pointx + dx > screenrect.width:
            ballx = screenrect.width - ballrect.width
            pointx = screenrect.width - ballrect.width
            dx = 0
        if pointy + dy < 0:
            bally = 0
            pointy = 0
            dy = 0
        elif pointy + dy > screenrect.height:
            bally = screenrect.height - ballrect.height
            pointy = screenrect.height - ballrect.height
            dy = 0
        # ------- find out if probing point is inside wall
        # make sure proing point does not produce out of index error
        y1 = int(pointy/height)
        y1 = max(0,y1) # be never smaller than 0
        y1 = min(y1,lines-1) # be never bigger than lines
        x1 = int((pointx + dx)/length)
        x1 = max(0,x1) # be never smaller than 0
        x1 = min(x1,columns-1) 
        y2 = int((pointy+dy)/height)
        y2 = max(0,y2)
        y2 = min(y2,lines-1)
        # -------------- check the type of tile where the ball is ------
        if my_maze[y1][x1] == "x":
            dx = 0
        else:
            ballx += dx
        if my_maze[y2][x1] == "x":
            dy = 0
        else:
            bally += dy
        # ---------------move ball surface
        screen.blit(ballsurface, (ballx, bally))
        # -------------- check special tile
        bline = int(bally / height) # a line where ball is currently
        bcolumn = int(ballx / length) # column where ball is currently
        if my_maze[bline][bcolumn] == "n":
           actual = all_levels.index(my_maze)
           # cycle forward
           my_maze = all_levels[(actual + 1) % max_levels]
           length, height,  ballx, bally,  lines, columns,background = addlevel(my_maze)
        elif my_maze[bline][bcolumn] == "p":           
            actual = all_levels.index(my_maze)
            # cycle backward
            my_maze = all_levels[(max_levels + actual - 1) % max_levels]
            length, height,  ballx, bally,  lines, columns,background = addlevel(my_maze)
        elif my_maze[bline][bcolumn] == "r":
            my_maze = random.choice(all_levels)
            length, height,  ballx, bally,  lines, columns,background = addlevel(my_maze)
        elif my_maze[bline][bcolumn] == "e":
            # game won, exit mainloop
            print "---*** congratulation, you escaped the maze ! ***-------"
            mainloop = False
        pygame.display.flip() # flip the screen 30 times a second
    print "This maze game was played for %.2f seconds" % playtime
if __name__ == "__main__":
    mazegame()

########NEW FILE########
__FILENAME__ = 009_02_tile_based_graphic_(improved)
#!/usr/bin/env python
 
"""
009_02_tile_based_graphic_(improved).py
tile based graphic 
url: http://thepythongamebook.com/en:part2:pygame:step009
author: yipyip
licence: gpl, see http://www.gnu.org/licenses/gpl.html

Improved version of the "ugly" verison
(009_01_tile_based_graphic_(ugly).py)
A simple maze game in one file"""
 
####
 
import pygame as pyg
import random as rand
import math
 
#### configuration 
 
mapcolors =\
{'x': (100, 60, 30),
 'd': (30, 120, 10),
 'u': (30, 190, 10),
 'r': (250, 250, 0),
 'e': (250, 0, 0)}  
 
config =\
{'fullscreen': False,
 'visibmouse': False,
 'width': 800,
 'height': 600,
 'back_color': (230, 180, 40),
 'font_ratio': 8,
 'font_color': (255, 255, 255),
 'fps': 100,
 'dt': 0.01,
 'friction': 0.987,
 'player_sizefac': 1.2,
 'player_color': (0, 0, 255),
 'player_accel': 400,
 'width_sensors': 8,
 'height_sensors': 8,
 'title': "Maze Wanderer   (Move with Cursor Keys, press Esc to exit)",
 'waiting_text': "quit=Esc, again=Other Key"}
 
#### maps
# x = wall
# s = start
# d = level down
# u = level up
# r = random level
 
# 20 x 16
easy_map =\
["xxxxxxxxxxxxxxxxxxxx",
 "xs.....x...........x",
 "xxxx.......xxxx....x",
 "x.rx.......x..x..xxx",
 "x..x...x......x...dx",
 "x......x......x....x",
 "x...xxxx..xx.......x",
 "x...x.....x........x",
 "x.............x..xxx",
 "xxxxxx.x...xxxx...rx",
 "x......x......x....x",
 "x......x...........x",
 "xxx..x.....xx......x",
 "xrx..xxxx..x...xxxxx",
 "x.................ux",
 "xxxxxxxxxxxxxxxxxxxx"]
 
# 22 x 16
medium_map =\
["xxxxxxxxxxxxxxxxxxxxxx",
 "xs................x.rx",
 "xxx...x......x....x..x",
 "x.....xx.xxxxxxx.....x",
 "x..x..x..xr...x.....xx",
 "x..xxxx..xx..........x",
 "x.....x..x..xx..xx...x",
 "xxxx.............x.d.x",
 "x......xxx....x..xxx.x",
 "x...x..x....xxxd.....x",
 "xd..x..x..x.......x..x",
 "x...x.xx..xxxxx...x..x",
 "x..xx.........x...x.xx",
 "xx......xx...........x",
 "xr.......x.........xux",
 "xxxxxxxxxxxxxxxxxxxxxx"]
 
# 26 x 19
hard_map =\
["xxxxxxxxxxxxxxxxxxxxxxxxxx",
 "xs....x........x.....x..rx",
 "xxxx..xx..xxx..x..x..x..xx",
 "x..........x......x......x",
 "x..xxx.....x..xxxxx...xxxx",
 "x..x.....................x",
 "x..x.xxxxxx.x..x.....xx..x",
 "x....xr.....x..xxxx..xd..x",
 "xxx..x......x..xd....xxxxx",
 "x....xxxxx.xx..x..x......x",
 "x........x........x...x.xx",
 "x............x..xxxx..x..x",
 "xx...xxxxx.........x..x..x",
 "x.....x......xxxx........x",
 "x..xxxx...xxxx.rx...x....x",
 "x............x..x...x....x",
 "xxxxxxx..x...x..x..xx..xxx",
 "xd.......x...x..........ex",
 "xxxxxxxxxxxxxxxxxxxxxxxxxx"]
 
# 5 x 8
test_map=\
["xxxxx",
 "xs..x",
 "x..ux",
 "x..dx",
 "x..rx",
 "x..ex",
 "x...x",
 "xxxxx"]
 
 
# game maps
maps =  easy_map, medium_map, hard_map
 
# testing
# maps = test_map, easy_map, medium_map, hard_map
 
#### map constants
 
UP = 1
DOWN = -1
RANDOM = -2
START = -3
PLACES = set(('u', 'd', 'r', 'e'))
NOT_DRAWABLES = set(('.', 's'))
 
####
 
class PygView(object):
  """Pygame interface"""
 
  CURSORKEYS = slice(273, 277)
  QUIT_KEYS = pyg.K_ESCAPE, pyg.K_q
  EVENTS = 'up', 'down', 'right', 'left'
 
  def __init__(self, controller, config):
 
    self.controller = controller
    self.width = config.width
    self.height = config.height
    self.back_color = config.back_color
    self.fps = config.fps
    self.font_color = config.font_color
 
    pyg.init()
    flags = pyg.DOUBLEBUF | [0, pyg.FULLSCREEN][config.fullscreen]
    self.canvas = pyg.display.set_mode((self.width, self.height), flags)
    pyg.display.set_caption(config.title)
    self.clock = pyg.time.Clock()
    pyg.mouse.set_visible(config.visibmouse)
    self.font = pyg.font.Font(None, self.height // config.font_ratio)
 
 
  @property
  def frame_duration_secs(self):
 
    return 0.001 * self.clock.get_time()
 
 
  def run(self):
    """Main loop"""
 
    running = True
    while running:
      self.clock.tick_busy_loop(self.fps) 
      running = self.controller.dispatch(self.get_events())
      self.flip()
    else:
      self.quit()
 
 
  def get_events(self):
 
    keys = pyg.key.get_pressed()[PygView.CURSORKEYS]
    move_events = [e for e, k in zip(PygView.EVENTS, keys) if k]
 
    for event in pyg.event.get():
      if event.type == pyg.QUIT:
        return 'quit', move_events
      if event.type == pyg.KEYDOWN:
        if event.key in PygView.QUIT_KEYS:
          return 'quit', move_events
        else:
          return 'other_key', move_events
    else:
      return None, move_events
 
 
  def rectangle(self, xywh, color, border=0):
 
    pyg.draw.rect(self.canvas, color, xywh, border)
 
 
  def draw_text(self, text):
 
    fw, fh = self.font.size(text)
    surface = self.font.render(text, True, self.font_color)
    self.canvas.blit(surface, ((self.width - fw) // 2, (self.height - fh) // 2))
 
 
  def flip(self):
 
    pyg.display.flip()
    self.canvas.fill(self.back_color) 
 
 
  def quit(self):
 
    pyg.quit()
 
####
 
class Grid(object):
  """Calculate points on a rectangular grid."""
 
  def __init__(self, dx=1, dy=1, xoff=0, yoff=0):
 
    self.dx = dx
    self.dy = dy
    self.xoff = xoff
    self.yoff = yoff
 
 
  def get_point(self, x, y):
 
    return self.xoff + x * self.dx, self.yoff + y * self.dy
 
 
  def get_rect(self, x, y):
    """Return rectangle parameters for pygame."""
 
    return self.get_point(x, y) + (self.dx, self.dy)
 
 
  def get_cell(self, x, y):
    """Snap coordinates to center point grid."""
    x = int(x+0.5)
    y = int(y+0.5)
    return (x-self.xoff+self.dx//2)//self.dx, (y-self.yoff+self.dy//2)//self.dy
 
####
 
class Map(object):
  """Maze map representation""" 
 
  def __init__(self, map_data):
 
    self.width = len(map_data[0])
    self.height = len(map_data)
    self.data = map_data
 
 
  def __getitem__(self, (x, y)):
 
    return self.data[y][x]
 
 
  @property
  def start(self):
    """Search the starting point, there should be only one."""
 
    for i, y in enumerate(self.data):
      for j, x in enumerate(y):
        if x == 's':
          return j, i
 
####
 
class Mapper(object):
  """Manage all maps."""
 
  def __init__(self, maps, width, height):
 
    self.view_width = width
    self.view_height = height
    self.maps = [Map(m) for m in maps]
 
 
  def select(self, mode=START):
 
    assert mode in (START, UP, DOWN, RANDOM), "wrong selection"
 
    n = len(self.maps)
    if mode == START:
      self.act_index = 0
    elif mode == RANDOM:
      if len(self.maps) > 1:
        self.act_index = rand.choice(list(set(xrange(n)) - set((self.act_index,))))  
    else:
      self.act_index = (self.act_index + n + mode) % len(self.maps)
 
    self.act_grid, self.act_center_grid = self.adjust_grids()
    return self.act_map, self.act_grid, self.act_center_grid
 
 
  def adjust_grids(self):
    """There are 2 sorts of grids:
    a grid for the upper left Corner for drawing rectangles,
    a grid for their center points, which are used for collision detection."""
 
    smap = self.act_map
    w = self.view_width // smap.width - 1
    h = self.view_height // smap.height - 1
    xoff = self.view_width - smap.width * w 
    yoff = self.view_height - smap.height * h
    grid = Grid(w, h, xoff//2, yoff//2)
    # +1 !
    center_grid = Grid(w, h, xoff//2 + w//2 + 1, yoff//2 + h//2 + 1)
 
    return grid, center_grid
 
 
  def draw_map(self, view):
 
    smap = self.act_map
    grid = self.act_grid
    width = smap.width
 
    for y in xrange(smap.height):
      for x in xrange(width):
        place = smap[x, y]
        if place not in NOT_DRAWABLES:
          view.rectangle(grid.get_rect(x, y), mapcolors[place], place in PLACES)
 
 
  @property
  def act_map(self):
 
    return self.maps[self.act_index]
 
 
  @property
  def start(self):
 
    return self.act_map.start
 
 
  def get_point(self, x, y):
 
    return self.act_grid.get_point(x, y)
 
 
  def get_rect(self, x, y):
 
    return self.act_grid.get_rect(x, y)
 
 
  def get_cell(self, x, y):
 
    return self.act_center_grid.get_cell(x, y)
 
 
  @property
  def player_sizehint(self):
 
    return self.act_grid.dx // 2, self.act_grid.dy // 2
 
 ####
 
class Player(object):
  """Representation of the moving player rectangle"""
 
  dirs = {'up': (0, -1),
          'down': (0, 1),
          'left': (-1, 0),
          'right': (1, 0)}
 
  sensor_pts = ((0, 0), (1, 0), (1, 1), (0, 1))
 
  def __init__(self, x, y, width, height, color):
 
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self.width2 = width // 2
    self.height2 = height // 2
    self.color = color
    self.dx = 0
    self.dy = 0
 
 
  @property
  def pos(self):
 
    return self.x, self.y
 
 
  @property
  def oldpos(self):
 
    return self.xold, self.yold
 
 
  def restore_pos(self):
 
    self.x, self.y = self.oldpos
 
 
  @property
  def center(self):
 
    x, y = self.pos
    return x + self.width2, y + self.height2
 
 
  def move(self, dt, friction):
 
    self.dx *= friction
    self.dy *= friction
    self.xold, self.yold = self.pos
    self.x += self.dx * dt
    self.y += self.dy * dt
 
 
  def accelerate(self, direct, acc):
 
    xdir, ydir = Player.dirs[direct]
    self.accx = xdir * acc
    self.accy = ydir * acc
    self.dx += self.accx
    self.dy += self.accy
 
 
  @property
  def vertex_sensors(self):
 
    x, y = self.pos
    return [(x + sx * self.width, y + sy * self.height) for sx, sy in Player.sensor_pts]
 
 
  def north_sensors(self, n):
 
    x, y = self.pos
    delta = self.width // n
    return [(x + i * delta, y) for i in xrange(1, n)]
 
 
  def south_sensors(self, n):
 
    x, y = self.pos
    delta = self.width // n
    h = y + self.height
    return [(x + i * delta, h) for i in xrange(1, n)]
 
 
  def west_sensors(self, n):
 
    x, y = self.pos
    delta = self.height // n
    return [(x, y + i * delta) for i in xrange(1, n)]
 
 
  def east_sensors(self, n):
 
    x, y = self.pos
    delta = self.height // n
    w = x + self.width 
    return [(w, y + i * delta) for i in xrange(1, n)]
 
 
  def bounce(self, west_east, north_south):
 
    self.dx = (self.dx, -self.dx)[west_east]
    self.dy = (self.dy, -self.dy)[north_south]
 
 
  def draw(self, view):
 
    view.rectangle((self.x, self.y, self.width, self.height), self.color)
 
####
 
class Controller(object):
  """Global game control"""
 
  def __init__(self, view, maps, config):
 
    self.view = view(self, config)
    self.game = MazeGame(maps, config)
    self.game.reset(START)
    self.state = 'playing'
 
 
  def dispatch(self, all_events):
    """Control the game state."""
 
    event, move_events = all_events
    if event == 'quit':
      self.game.quit()
      return False
 
    if self.state == 'playing':
      self.state = self.game.process(self.view, move_events)
      return True
 
    if self.state == 'ending':
      self.game.wait(self.view)
      if event == 'other_key':
        self.state = 'playing'
        self.game.reset(START)
 
    return True
 
 
  def run(self):
 
    self.view.run()
 
####
 
class MazeGame(object):
  """The actual game"""
 
  def __init__(self, maps, config):
 
    self.config = config
    self.dtimer = DeltaTimer(config.dt)
    self.mapper = Mapper(maps, config.width, config.height)
    self.player_accel= config.player_accel
    self.friction = config.friction
 
 
  def reset(self, mode):
 
    self.text = ""
    self.mapper.select(mode)
    x, y = self.mapper.get_point(*self.mapper.start)
    w, h =  self.mapper.player_sizehint
    size =  self.config.player_sizefac
    width = int(w * size)
    height = int(h * size)
    self.player = Player(x+1, y+1, width, height, self.config.player_color)
 
 
  def accelerate_player(self, events, accel):
 
    for ev in events:
      self.player.accelerate(ev, accel)
 
 
  def check_places(self):
 
    place = self.mapper.act_map[self.mapper.get_cell(*self.player.center)]
    if place in PLACES:
      if place == 'e':
        return 'ending'
      else:
        self.reset({'u': UP, 'd': DOWN, 'r': RANDOM}.get(place)) 
 
    return 'playing'
 
 
  def check_collision(self):
    """Check at first 4 sides of the player rectangle,
    if no collision occurs, check corners."""
 
    smap = self.mapper.act_map
    mapper = self.mapper
 
    ws = self.config.width_sensors
    hs = self.config.height_sensors
    north = [smap[mapper.get_cell(sx, sy)] == 'x'
             for sx, sy in self.player.north_sensors(ws)]
    south = [smap[mapper.get_cell(sx, sy)] == 'x'
             for sx, sy in self.player.south_sensors(ws)]
    east = [smap[mapper.get_cell(sx, sy)] == 'x'
             for sx, sy in self.player.east_sensors(hs)]
    west = [smap[mapper.get_cell(sx, sy)] == 'x'
            for sx, sy in self.player.west_sensors(hs)]
 
    west_east = any(west) or any(east)
    north_south = any(north) or any(south)
 
    if west_east or north_south:
      self.player.bounce(west_east, north_south)
      return True
 
    csx = False
    for sx, sy in self.player.vertex_sensors:
      if smap[mapper.get_cell(sx, sy)] == 'x':
        csx, csy = sx, sy
        break
 
    if not csx:
      return False
 
    old_px, old_py = self.player.oldpos
    px, py = self.player.pos
    old_csx = csx - px + old_px
    old_csy = csy - py + old_py
 
    old_cellx, old_celly = mapper.get_cell(old_csx, old_csy)
    cellx, celly = mapper.get_cell(csx, csy)
    self.player.bounce(abs(old_cellx - cellx) > 0, abs(old_celly - celly) > 0)
 
    return True
 
 
  def process(self, view, move_events):
    """Main method"""
 
    dur = view.frame_duration_secs
    #self.text = str(view.frame_duration_secs)
    self.accelerate_player(move_events, dur * self.player_accel)
    self.dtimer += dur
    self.dtimer.integrate(self.transform_player, self.friction)
 
    self.mapper.draw_map(view)
    self.player.draw(view)
    self.draw_text(view)
 
    return self.check_places()
 
 
  def transform_player(self, dt, friction):
    """Move player in 1 timestep dt."""
 
    self.player.move(dt, friction)  
    collision = self.check_collision()
    if collision:
      self.player.restore_pos()
      self.player.move(dt, friction)  
 
 
  def wait(self, view):
    """If player finds exit, ask for new game."""
 
    self.text = self.config.waiting_text
    self.draw_text(view)
 
 
  def draw_text(self, view):
 
    view.draw_text(self.text)
 
 
  def quit(self):
 
    print "Bye"
 
####
 
class DeltaTimer(object):
  """Timing control"""
 
  def __init__(self, dt):
 
    self.dt = dt
    self.accu = 0.0
 
 
  def __iadd__(self, delta):
 
    self.accu += delta
    return self
 
 
  def integrate(self, func, *args):
    """For a fixed timestep dt, adjust movement to fps."""
    while self.accu >= self.dt:
      func(self.dt, *args)
      self.accu -= self.dt
 
####
 
class Config(object):
  """Change dictionary to object attributes."""
 
  def __init__(self, **kwargs):
 
    self.__dict__.update(kwargs)
 
####
 
def main():
 
  Controller(PygView, maps, Config(**config)).run()
 
####
 
if __name__ == '__main__':
 
  main()

########NEW FILE########
__FILENAME__ = 010_sound_and_music
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
010_sound_and_music.py
plays music and sound effects
url: http://thepythongamebook.com/en:part2:pygame:step010
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

This program plays music and 
plays a sound effect whenever the a of b  key is pressed and released
All files must be in a 'data' subfolder.
The 'data' subfolder must be in the same folder as the program.
"""
import pygame
import os


pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
pygame.init()                      #initialize pygame

try:
    pygame.mixer.music.load(os.path.join('data', 'an-turr.ogg'))#load music
    jump = pygame.mixer.Sound(os.path.join('data','jump.wav'))  #load sound
    fail = pygame.mixer.Sound(os.path.join('data','fail.wav'))  #load sound
except:
    raise UserWarning, "could not load or play soundfiles in 'data' folder :-("

pygame.mixer.music.play(-1)                           # play music non-stop

screen=pygame.display.set_mode((640,480)) # set screensize of pygame window
background = pygame.Surface(screen.get_size())  #create empty pygame surface
background.fill((255,255,255))     #fill the background white color (red,green,blue)
background = background.convert()  #convert Surface object to make blitting faster
screen.blit(background, (0,0))     #draw the background on screen
clock = pygame.time.Clock()        #create a pygame clock object
mainloop = True                    
FPS = 30 # desired framerate in frames per second. try out other values !
while mainloop:
    milliseconds = clock.tick(FPS) # do not go faster than this framerate
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            mainloop = False # pygame window closed by user
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                mainloop = False # user pressed ESC
            if event.key == pygame.K_a:
                fail.play()                  # play sound effect
            if event.key == pygame.K_b:
                jump.play()                  # play sound effect
    # print the framerate into the pygame window title
    pygame.display.set_caption("FPS: %.2f Press a or b to play sound effects" % clock.get_fps())
    pygame.display.flip()          # flip the screen

########NEW FILE########
__FILENAME__ = 010_sound_only_no_graphic
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Name:    010_sound_only_no_graphic.py
Purpose: demonstrate use of pygame for playing sound & music
URL:     http://ThePythonGameBook.com 
Author:  Horst.Jens@spielend-programmieren.at
Licence: gpl, see http://www.gnu.org/licenses/gpl.html
"""


import pygame
import os


pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
pygame.init()                              #initialize pygame

# look for sound & music files in subfolder 'data'
pygame.mixer.music.load(os.path.join('data', 'an-turr.ogg'))#load music
jump = pygame.mixer.Sound(os.path.join('data','jump.wav'))  #load sound
fail = pygame.mixer.Sound(os.path.join('data','fail.wav'))  #load sound

# play music non-stop
pygame.mixer.music.play(-1)                           

# game loop
gameloop = True

while gameloop:
    # indicate if music is playing
    if pygame.mixer.music.get_busy():
        print " music is playing"
    else: 
        print " music is not playing"
    # print menu 
    print "please press key:"
    print "[a] to play 'jump.wav' sound"
    print "[b] to play 'fail.wav' sound"
    print "[m] to toggle music on/off"
    print "[q] to quit"
    answer = raw_input("press key a or b or m or q , followed by ENTER")
    answer = answer.lower() # force lower case
    if "a" in answer:
        jump.play()
        print "playing jump.wav once"
    elif "b" in answer:
        fail.play()
        print "playing fail.wav once"
    elif "m" in answer:
        if pygame.mixer.music.get_busy():
            pygame.mixer.music.stop()
        else:
            pygame.mixer.music.play()
    elif "q" in answer:
        #break from gameloop
        gameloop = False
    else:
        print "please press either a, b, m or q and ENTER"


print "bye-bye"
pygame.quit() # clean exit 

########NEW FILE########
__FILENAME__ = 011_rotozoom
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
011-rotozoom.py
moving, rotating and zooming a pygame surface
url: http://thepythongamebook.com/en:part2:pygame:step011
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

loading the background image and snake.gif from a subfolder called 'data'
The subfolder must be inside the same folder as the program itself. 
The snake surface can be moved with the cursor keys, 
rotated with a and d key and and zoomed with w and s key.
"""
import pygame
import os

try:
    # load from subfolder 'data'
    background = pygame.image.load(os.path.join("data","background640x480_a.jpg"))
    snake = pygame.image.load(os.path.join("data","snake.gif"))
except:
    raise UserWarning, "Unable to find the images in the folder 'data' :-( "
#finally:
pygame.init()
screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
background = background.convert()  # jpg can not have transparency
snake = snake.convert_alpha()      # png image has transparent color 
snake_original = snake.copy()      # store a unmodified copy of the snake surface
snakex, snakey = 250, 240            # start position of snake surface
dx, dy  = 0, 0                   # snake speed in pixel per second !
speed = 60                       # in pixel / second
angle = 0                        # current orientation of snake
zoom = 1.0                       # current zoom factor
zoomspeed = 0.01                   
turnspeed = 180                  # in Grad (360) per second
screen.blit(background, (0,0))     # blit background on screen (overwriting all)
screen.blit(snake, (snakex, snakey))  # blit the snake shape 
clock = pygame.time.Clock()        # create pygame clock object 
mainloop = True
FPS = 60                           # desired max. framerate in frames per second. 
while mainloop:
    milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
    seconds = milliseconds / 1000.0 # seconds passed since last frame
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            mainloop = False # pygame window closed by user
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                mainloop = False # user pressed ESC
    pygame.display.set_caption("press cursor keys and w a s d - fps:"
        "%.2f zoom: %.2f angle %.2f" % (clock.get_fps(), zoom, angle))
    # only blit the part of the background where the snake was (cleanrect)
    #try:
        #if the subsurface is outside the screen pygame would raise an error
        #this can happen when using rotozoom, therfore check inside try..except
    #    dirtyrect = background.subsurface((round(snakex,0), 
    #            round(snakey,0), snake.get_width(), snake.get_height()))
    
    #    screen.blit(dirtyrect, (round(snakex,0), round(snakey,0))) 
    #except:
    #print "autch!"
    snakerect = pygame.Rect(round(snakex,0), 
                round(snakey,0), snake.get_width(), snake.get_height())
    dirty = background.subsurface(snakerect.clip(screen.get_rect()))
    dirtyrect = dirty.get_rect()
    screen.blit(dirty, (round(snakex), round(snakey)))
        
        #screen.blit(background,(0,0)) # blit the whole background (slow but secure)
        #raise UserWarning, "subsurface out of screen?"
    # move snake with cursor keys
    pressedkeys = pygame.key.get_pressed()
    dx, dy  = 0, 0   # no cursor key, no movement
    if pressedkeys[pygame.K_LEFT]:
        dx -= speed
    if pressedkeys[pygame.K_RIGHT]:
        dx += speed
    if pressedkeys[pygame.K_UP]:
        dy -= speed
    if pressedkeys[pygame.K_DOWN]:
        dy += speed
    #calculate new center of snake 
    snakex += dx * seconds # time based movement
    snakey += dy * seconds
    # rotate snake with a and d key
    turnfactor = 0  # neither a nor d, no turning
    if pressedkeys[pygame.K_a]:
        turnfactor += 1 # counter-clockwise
    if pressedkeys[pygame.K_d]:
        turnfactor -= 1 #clock-wise
    # zoom snake with w and s key
    zoomfactor = 1.0 # neither w nor s, no zooming
    if pressedkeys[pygame.K_w]:
        zoomfactor += zoomspeed
    if pressedkeys[pygame.K_s]:
        zoomfactor -= zoomspeed
    if turnfactor != 0 or zoomfactor !=1.0:
        angle += turnfactor * turnspeed * seconds # time-based turning
        zoom *= zoomfactor 
        # the surface shrinks and zooms and moves by rotating
        oldrect = snake.get_rect() # store current surface rect
        snake = pygame.transform.rotozoom(snake_original, angle, zoom)
        newrect = snake.get_rect() # store new surface rect
        # put new surface rect center on same spot as old surface rect center
        snakex += oldrect.centerx - newrect.centerx
        snakey += oldrect.centery - newrect.centery
    # paint the snake    
    screen.blit(snake, (round(snakex,0), round(snakey,0)))    
    pygame.display.flip()          # flip the screen 30 times a second                # flip the screen 30 (or FPS) times a second

########NEW FILE########
__FILENAME__ = 012_text
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
012_text.py
displaying and moving text
url: http://thepythongamebook.com/en:part2:pygame:step012
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

This program demonstrate how to render and blit text into a surface"""

import pygame
import random

def flytext(msg="hello world", duration=5):
    """blinking text bouncing around the screen"""

    def newcolour():
        # any colour but black or white 
        return (random.randint(10,250), random.randint(10,250), random.randint(10,250))

    def write(msg="pygame is cool"):
        myfont = pygame.font.SysFont("None", random.randint(34,128))
        mytext = myfont.render(msg, True, newcolour())
        mytext = mytext.convert_alpha()
        return mytext
        
    pygame.init()
    x = 60
    y = 60
    dx = 5
    dy = 5

    screen = pygame.display.set_mode((640,400))
    background = pygame.Surface((screen.get_width(), screen.get_height()))
    background.fill((255,255,255)) # white
    background = background.convert()
    screen.blit(background, (0,0)) # clean whole screen
    clock = pygame.time.Clock()
    mainloop = True
    FPS = 60 # desired framerate in frames per second.
    while mainloop:
        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
        textsurface = write("hello world")
        #screen.blit(background, (0,0)) # clean whole screen
        x += dx
        y += dy
        if x < 0:
           x = 0
           dx *= -1
           screen.blit(background, (0,0)) # clean whole screen
        elif x + textsurface.get_width() > screen.get_width():
            x = screen.get_width() - textsurface.get_width()
            dx *= -1
        if y < 0:
            y = 0
            dy *= -1
        elif y + textsurface.get_height() > screen.get_height():
            y = screen.get_height() - textsurface.get_height()
            dy *= -1
            
        screen.blit(textsurface, (x,y))
        pygame.display.flip()
    pygame.quit()

if __name__=="__main__":
    flytext() 

########NEW FILE########
__FILENAME__ = 013_catch_the_thief
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
013_catch_the_thief.py
a game without pygame sprites
url: http://thepythongamebook.com/en:part2:pygame:step013
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

The player(s) can control the Pygame snake (with cursor keys) and the
Tux bird (with the mouse). A blue police icon moves toward the middle
distance between snake and bird (indicated by a cross).
Your task is to catch the thief (red triangle) with the blue police circle.
The thief moves by random. You have only a short period of time. For each 
millisecond where the police circle touches the thief triangle, you get points.

Loading  images and sounds from a subfolder called 'data'
The subfolder must be inside the same folder as the program itself. 
"""
import pygame
import os
import random

# ------ a class to store global variables
class Config(object):
    """place to store some variables so that every function can access them
       also a good place to start modding the game"""
    screenwidth = 1024                    # screen resolution
    screenheight = 600
    thiefx, thiefy = 50,50                # start position of thief
    thiefdx = random.randint(-150,150)    # speed of thief
    thiefdy = random.randint(-150,150)
    thiefmaxspeed = 200                   # max speed of thief
    erratic = 1                           # possible change +/- of thief speed
    policex, policey = 250, 240           # start position of police 
    policedx, policedy  = 0, 0            # police speed in pixel per second !
    birdx, birdy = 100,100                # start position of bird
    birddx, birddy = 0,0                  # start speed of bird
    snakex, snakey = 200,200              # start position of snake
    snakedx, snakedy = 0,0                # start speed of snake
    crossx, crossy = 150,150              # start position of cross

# ------- some functions for later use ----------

def intro(screen):
    """draw game instructions and wait for mouseclick"""
    screen.fill((255,255,255))
    #pygame.draw.rect(background, (200,200,200), ((0,0), (470,110)))
    #pygame.draw.rect(background, (200,200,200), ((screen.get_width()-360, 
    #                 screen.get_height()-25), (360,25)))
    
    screen.blit(write("Catch the hief - INSTRUCTIONS", (0,0,255), 64), (80, 15))    
    screen.blit(write("control the snake with the cursor keys or WASD (Enter or LCTRLto stop)"),(10,70))
    screen.blit(write("control the bird with the mouse (left button to stop)"), (10,90))
    screen.blit(write("the cross is always in the middle between snake and bird"), (10,110))
    screen.blit(write("the blue circle (police) moves toward the cross"),(10,130))
    screen.blit(write("catch the red triangle (the thief) with the blue circle to win points"),(10,150))
    screen.blit(write("click the left mouse button to start"),(50,290))
    pygame.display.flip()
        
    while True:
        for event in pygame.event.get():
            pass # do nothing but pull all events
        if pygame.mouse.get_pressed()[0]: # mouse button pressed
                return  # escape this function
            
    
def write(msg="pygame is cool", colour=(0,0,0), fontsize=24):
    """returns a surface with text"""
    myfont = pygame.font.SysFont("None", fontsize)
    mytext = myfont.render(msg, True, colour)
    mytext = mytext.convert_alpha()
    return mytext


def draw(sprite, x, y):
    """blit a sprite at position x, y"""
    Config.screen.blit(sprite, (round(x,0) - sprite.get_width()/2,
                         round(y,0) - sprite.get_height()/2)) 
def bounce(sprite, x, y, dx, dy):
    """bounce sprite if it touches the screen borders"""
    if x - sprite.get_width()/2 < 0:
        x =  sprite.get_width()/2
        dx *= -1 
    elif x + sprite.get_width()/2 > Config.screenwidth:
        x = Config.screenwidth - sprite.get_width()/2
        dx *= -1
    if y - sprite.get_height()/2 < 0:
        y = sprite.get_height()/2
        dy *= -1
    elif y + sprite.get_height()/2 > Config.screenheight:
        y = Config.screenheight - sprite.get_height()/2
        dy *= -1
    return x,y,dx,dy
    
def randomcolour():
    """returns a random colour tuple (red,green,blue)"""
    return (random.randint(0,255), random.randint(0,255), random.randint(0,255))

def arrow(sprite, dx, dy):
    midx = sprite.get_width() /2
    midy = sprite.get_height() /2
    
    return sprite


def play_the_game():


    pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
    pygame.init()
    try:
        # load graphic files from subfolder 'data'
        background = pygame.image.load(os.path.join("data","wien.jpg"))
        snake = pygame.image.load(os.path.join("data","snake.gif"))
        bird = pygame.image.load(os.path.join("data","babytux.png"))
        # load sound files 
        over = pygame.mixer.Sound(os.path.join('data','time_is_up_game_over.ogg'))
        spring = pygame.mixer.Sound(os.path.join('data', 'spring.wav'))

    except:
        raise UserWarning, "Unable to find or play the files in the folder 'data' :-( "


    # ----------- start ---------

    screen=pygame.display.set_mode((1024,600)) # try out larger values and see what happens !
    Config.screen = screen # copy screen into the Config class so that functions can access screen
    background = pygame.transform.scale(background, (screen.get_width(), screen.get_height()))
    background = background.convert()  # jpg can not have transparency
    Config.background = background # copy background in the Config class so that functions can access background
    snake = snake.convert_alpha()
    bird = bird.convert_alpha()
    police = pygame.Surface((50,50)) 
    pygame.draw.circle(police, (0,0,255), (25,25),25) # blue police
    police.set_colorkey((0,0,0)) # black transparent colour 
    police.blit(write("P", (255,255,255), 48), ((12,10))) # white "P"
    police = police.convert_alpha()        # png image has transparent color 
    cross = pygame.Surface((10,10))
    cross.fill((255,255,255)) # fill white
    pygame.draw.line(cross, (0,0,0), (0,0), (10,10)) # black lines
    pygame.draw.line(cross, (0,0,0), (0,10), (10,0))
    cross.set_colorkey((255,255,255))
    cross = cross.convert_alpha()
    thief = pygame.Surface((26,26))
    thief.set_colorkey((0,0,0))
    pygame.draw.polygon(thief, (255,0,0), [(0,0),(25,0),(12,25)])
    thief.blit(write("T", (0,0,0), 32), ((6,3))) # transparent "T"
    thief = thief.convert_alpha()

    catch_in_last_frame = False
    catch_in_this_frame = False
    intro(screen)
    #pygame.draw.rect(background, (200,200,200), ((0,0), (470,110)))
    pygame.draw.rect(background, (200,200,200), ((screen.get_width()-360, 
                     screen.get_height()-25), (360,25)))

    screen.blit(background, (0,0))     # blit background on screen (overwriting all)
    clock = pygame.time.Clock()        # create pygame clock object 
    mainloop = True
    FPS = 60                     # desired max. framerate in frames per second.       
    playtime = 60.0              # seconds of playtime left
    points = 0.0
    gameOver = False
    gameOverSound = True
    while mainloop:
        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame
        playtime -= seconds
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
        pygame.display.set_caption("[FPS]: %.2f Snake: dx %i dy %i Bird:"
                                   " dx %i dy %i police: dx %.2f dy %.2f " % 
                                   (clock.get_fps(), Config.snakedx, Config.snakedy,
                                    Config.birddx, Config.birddy, Config.policedx, Config.policedy ))
        if playtime < 0:
            gameOver = True
        # ---------------- clean screen ----------
        screen.blit(background,(0,0)) 
        # --------  detect game over ------------
        if gameOver:
            if gameOverSound:
                over.play()
                gameOverSound = False # play the sound only once
            screen.blit(write("Game Over. %.2f points. Press ESCAPE" % points, (128,0,128), 64), (20,250))
        else:
            screen.blit(write("points: %.2f time left: %.2f seconds" % (points, playtime)), 
                       (screen.get_width()-350,screen.get_height()-20))
            # ----- compute movement ----
            # ---- mouse ---
            #(Config.birdx, Config.birdy) = pygame.mouse.get_pos()
            (mousex, mousey) = pygame.mouse.get_pos()
            if mousex < Config.birdx:
                Config.birddx -= 1
            elif mousex > Config.birdx:
                Config.birddx += 1
            if mousey < Config.birdy:
                Config.birddy -= 1
            elif mousey > Config.birdy:
                Config.birddy += 1
            if pygame.mouse.get_pressed()[0] == True:
                Config.birddx = 0 # stop movement by mouseclick (left button)
                Config.birddy = 0
            # ---- keyboard ------
            # cursor keys or wasd
            pressedkeys = pygame.key.get_pressed() # all keys that are pressed now
            if pressedkeys[pygame.K_LEFT] or pressedkeys[pygame.K_a]:
                Config.snakedx -= 1
            if pressedkeys[pygame.K_RIGHT] or pressedkeys[pygame.K_d]:
                Config.snakedx += 1
            if pressedkeys[pygame.K_UP] or pressedkeys[pygame.K_w]:
                Config.snakedy -= 1
            if pressedkeys[pygame.K_DOWN] or pressedkeys[pygame.K_s]:
                Config.snakedy += 1
            if pressedkeys[pygame.K_RETURN] or pressedkeys[pygame.K_LCTRL]:
                Config.snakedx = 0 # stop movement by pressing the 's' key
                Config.snakedy = 0
            # ------------ compute movement ----------------
            Config.crossx = min(Config.birdx,Config.snakex) + ( max(Config.birdx, Config.snakex) -  # cross is in the middle of bird and snake 
                     min(Config.birdx,Config.snakex)) / 2.0 -cross.get_width()/2
            Config.crossy = min(Config.birdy,Config.snakey) + ( max(Config.birdy, Config.snakey) - 
                     min(Config.birdy,Config.snakey)) / 2.0 - cross.get_height()/2
            if Config.crossx < Config.policex:
                Config.policedx -= 1        # police moves toward cross
            elif Config.crossx > Config.policex:
                Config.policedx += 1
            if Config.crossy > Config.policey:
                Config.policedy += 1
            elif Config.crossy < Config.policey:
                Config.policedy -= 1
            Config.thiefdx += random.randint( -Config.erratic,Config.erratic )  # thief is erratic
            Config.thiefdy += random.randint( -Config.erratic,Config.erratic )
            Config.thiefdx = max(Config.thiefdx, -Config.thiefmaxspeed)         # limit speed of thief
            Config.thiefdx = min(Config.thiefdx, Config.thiefmaxspeed)
            Config.thiefdy = max(Config.thiefdy, -Config.thiefmaxspeed)
            Config.thiefdy = min(Config.thiefdy, Config.thiefmaxspeed)
            # ---- friction... sprites get slower ----
            Config.policedx *= 0.995
            Config.policedy *= 0.995
            Config.snakedx *= 0.995
            Config.snakedy *= 0.995
            Config.birddx *= 0.995
            Config.birddy *= 0.995
            # --------- new position -----------
            Config.policex += Config.policedx * seconds 
            Config.policey += Config.policedy * seconds
            Config.birdx += Config.birddx * seconds
            Config.birdy += Config.birddy * seconds
            Config.snakex += Config.snakedx * seconds
            Config.snakey += Config.snakedy * seconds
            Config.thiefx += Config.thiefdx * seconds
            Config.thiefy += Config.thiefdy * seconds
            # ----------- bounce ----------
            Config.policex, Config.policey, Config.policedx, Config.policedy = bounce(police, Config.policex, Config.policey, Config.policedx, Config.policedy)
            Config.birdx, Config.birdy, Config.birddx, Config.birddy = bounce(bird, Config.birdx, Config.birdy, Config.birddx, Config.birddy)
            Config.snakex, Config.snakey, Config.snakedx, Config.snakedy = bounce(snake, Config.snakex, Config.snakey, Config.snakedx, Config.snakedy)
            Config.thiefx, Config.thiefy, Config.thiefdx, Config.thiefdy = bounce(thief, Config.thiefx, Config.thiefy, Config.thiefdx, Config.thiefdy)
            # --- police got thief ? collision detection -----
            distx =  max(Config.policex + police.get_width()/2 , Config.thiefx + 
                     thief.get_width()/2) - min(Config.policex + 
                     police.get_width()/2, Config.thiefx + thief.get_width()/2)
            disty =  max(Config.policey + police.get_height()/2 , Config.thiefy + 
                     thief.get_height()/2) - min(Config.policey + police.get_width()/2,
                     Config.thiefy + thief.get_width()/2)
            catch_in_last_frame = catch_in_this_frame # save old catch info
            catch_in_this_frame = False
            if (distx < police.get_width() /2) and (disty < police.get_height()/2):
                catch_in_this_frame = True
                points += seconds
                screen.fill(randomcolour()) 
                if not pygame.mixer.get_busy():
                    spring.play() # only play this sound if mixer is silent at the moment
            else:   # no catch this time
                if catch_in_last_frame:
                    screen.blit(background, (0,0)) # restore background
            # ---------- blit ----------------
            draw(bird, Config.birdx, Config.birdy)
            draw(snake, Config.snakex, Config.snakey)
            pygame.draw.line(screen, randomcolour(), (Config.snakex,Config.snakey), (Config.birdx, Config.birdy), 1)
            pygame.draw.line(screen, randomcolour(), (Config.crossx,Config.crossy), (Config.policex, Config.policey) ,1)
            draw(police, Config.policex, Config.policey)
            draw(cross, Config.crossx, Config.crossy)
            draw(thief, Config.thiefx, Config.thiefy)
        pygame.display.flip()          # flip the screen FPS times a second    
    pygame.quit()
# check if the program is imported. if not, start it directly
if __name__ == "__main__":
    play_the_game()

########NEW FILE########
__FILENAME__ = 013_catch_the_thief_dirtyrect
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
part2step013-catch-the-thief.py

Loading  images and sounds from a subfolder called 'data'
The subfolder must be inside the same folder as the program itself. 
The player(s) can control the Pygame snake (with cursor keys) and the
Tux bird (with the mouse). A blue police icon moves toward the middle
distance between snake and bird (indicated by a cross).
Your task is to catch the thief (red triangle) with the blue police circle.
The thief moves by random. You have only a short period of time. For each 
millisecond where the police circle touches the thief triangle, you get points.

cleanrect function seems to be not perfect. 
"""
def play_the_game():
    import pygame
    import os
    import random

    pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
    pygame.init()
    try:
        # load graphic files from subfolder 'data'
        background = pygame.image.load(os.path.join("data","wien.jpg"))
        snake = pygame.image.load(os.path.join("data","snake.gif"))
        bird = pygame.image.load(os.path.join("data","babytux.png"))
        # load sound files 
        over = pygame.mixer.Sound(os.path.join('data','time_is_up_game_over.ogg'))
        spring = pygame.mixer.Sound(os.path.join('data', 'spring.wav'))

    except:
        raise UserWarning, "Unable to find or play the files in the folder 'data' :-( "
    # ------- some functions for later use ----------
    def write(msg="pygame is cool", colour=(0,0,0), fontsize=24):
        """returns a surface with text"""
        myfont = pygame.font.SysFont("None", fontsize)
        mytext = myfont.render(msg, True, colour)
        mytext = mytext.convert_alpha()
        return mytext
    def cleanblit(sprite,x,y):
        """clean a sprite from the screen, restoring the background"""
        dirtyrect = background.subsurface((round(x - sprite.get_width()/2, 0),
                                           round(y - sprite.get_height()/2,0),
                                           sprite.get_width(), sprite.get_height()))
        screen.blit(dirtyrect, ((round(x - sprite.get_width()/2, 0),
                                round(y - sprite.get_height()/2,0)))) 
    def cleanrect(x1,y1,x2,y2):
        """clean a rect from the screen, restoring the background"""
        startx = max(0,min(x1,x2) -5)
        starty = max(0,min(y1,y2) -5)
        width = min(screen.get_width(), 5 +max(x1,x2) - min(x1,x2))
        height =min(screen.get_height(), 5+ max(y1,y2) - min(y1,y2)) 
        dirtyrect = background.subsurface((startx, starty, width, height))
        screen.blit(dirtyrect, (startx, starty))
    def draw(sprite, x, y):
        """blit a sprite"""
        screen.blit(sprite, (round(x,0) - sprite.get_width()/2,
                             round(y,0) - sprite.get_height()/2)) 
    def bounce(sprite, x, y, dx, dy):
        """bounce sprite if it touches the screen borders"""
        if x - sprite.get_width()/2 < 0:
            x =  sprite.get_width()/2
            dx *= -1 
        elif x + sprite.get_width()/2 > screen.get_width():
            x = screen.get_width() - sprite.get_width()/2
            dx *= -1
        if y - sprite.get_height()/2 < 0:
            y = sprite.get_height()/2
            dy *= -1
        elif y + sprite.get_height()/2 > screen.get_height():
            y = screen.get_height() - sprite.get_height()/2
            dy *= -1
        return x,y,dx,dy
    def randomcolour():
        """returns a random colour tuple (red,green,blue)"""
        return (random.randint(0,255), random.randint(0,255), random.randint(0,255))
    # ----------- start ---------

    screen=pygame.display.set_mode((1024,600)) # try out larger values and see what happens !
    background = pygame.transform.scale(background, (screen.get_width(), screen.get_height()))
    background = background.convert()  # jpg can not have transparency
    snake = snake.convert_alpha()
    bird = bird.convert_alpha()
    police = pygame.Surface((50,50)) 
    pygame.draw.circle(police, (0,0,255), (25,25),25) # blue police
    police.set_colorkey((0,0,0)) # black transparent colour 
    police.blit(write("P", (255,255,255), 48), ((12,10))) # white "P"
    police = police.convert_alpha()        # png image has transparent color 
    cross = pygame.Surface((10,10))
    cross.fill((255,255,255)) # fill white
    pygame.draw.line(cross, (0,0,0), (0,0), (10,10)) # black lines
    pygame.draw.line(cross, (0,0,0), (0,10), (10,0))
    cross.set_colorkey((255,255,255))
    cross = cross.convert_alpha()
    thief = pygame.Surface((26,26))
    thief.set_colorkey((0,0,0))
    pygame.draw.polygon(thief, (255,0,0), [(0,0),(25,0),(12,25)])
    thief.blit(write("T", (0,0,0), 32), ((6,3))) # transparent "T"
    thief = thief.convert_alpha()
    thiefx, thiefy = 50,50
    thiefdx, thiefdy = random.randint(-150,150), random.randint(-150,150)
    thiefmaxspeed = 200
    erratic = 3                            # possible change +/- of thief speed
    policex, policey = 250, 240            # start position of police surface
    policedx, policedy  = 0, 0                   # police speed in pixel per second !
    birdx, birdy = 100,100
    birddx, birddy = 0,0
    snakex, snakey = 200,200
    snakedx, snakedy = 0,0
    crossx, crossy = 150,150
    catch_in_last_frame = False
    catch_in_this_frame = False
    pygame.draw.rect(background, (200,200,200), ((0,0), (470,110)))
    pygame.draw.rect(background, (200,200,200), ((screen.get_width()-360, 
                     screen.get_height()-25), (360,25)))
    background.blit(write("control the snake with the cursor keys (Enter to stop)"),(10,10))
    background.blit(write("control the bird with the mouse (left button to stop)"), (10,30))
    background.blit(write("the cross is always in the middle between snake and bird"), (10,50))
    background.blit(write("the blue circle (police) moves toward the cross"),(10,70))
    background.blit(write("catch the red triangle with the blue circle to win points"),(10,90))
    screen.blit(background, (0,0))     # blit background on screen (overwriting all)
    clock = pygame.time.Clock()        # create pygame clock object 
    mainloop = True
    FPS = 60                     # desired max. framerate in frames per second.       
    playtime = 60.0              # seconds of playtime left
    points = 0.0
    gameOver = False
    gameOverSound = True
    while mainloop:
        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame
        playtime -= seconds
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
        pygame.display.set_caption("[FPS]: %.2f Snake: dx %i dy %i Bird:"
                                   " dx %i dy %i police: dx %.2f dy %.2f " % 
                                   (clock.get_fps(), snakedx, snakedy,
                                    birddx, birddy, policedx, policedy ))
        if playtime < 0:
            gameOver = True
        if gameOver:
            #background.fill((255,255,255)) # white b
            screen.blit(background,(0,0))
            if gameOverSound:
                over.play()
                gameOverSound = False # play the sound only once
            screen.blit(write("Game Over. %.2f points. Press ESCAPE" % points, (128,0,128), 64), (20,250))
        else:
            #screen.blit(background, (0,0))  # not GameOver
            #-------- clean -----------
            cleanblit(police, policex, policey)
            cleanblit(bird, birdx, birdy)
            cleanblit(snake, snakex, snakey)
            cleanblit(cross, crossx, crossy)
            cleanblit(thief, thiefx, thiefy)
            pygame.draw.rect(screen, (200,200,200), (screen.get_width()-360, 
                     screen.get_height()-25, 360,25))
            cleanrect(policex, policey,crossx,crossy)
            cleanrect(snakex, snakey, birdx, birdy)
            screen.blit(write("points: %.2f time left: %.2f seconds" % (points, playtime)), 
                       (screen.get_width()-350,screen.get_height()-20))
            
            # ----- compute movement ----
            # ---- mouse ---
            #(birdx, birdy) = pygame.mouse.get_pos()
            (mousex, mousey) = pygame.mouse.get_pos()
            if mousex < birdx:
                birddx -= 1
            elif mousex > birdx:
                birddx += 1
            if mousey < birdy:
                birddy -= 1
            elif mousey > birdy:
                birddy += 1
            if pygame.mouse.get_pressed()[0] == True:
                birddx = 0 # stop movement by mouseclick (left button)
                birddy = 0
            # ---- keyboard ------
            pressedkeys = pygame.key.get_pressed() # all keys that are pressed now
            if pressedkeys[pygame.K_LEFT]:
                snakedx -= 1
            if pressedkeys[pygame.K_RIGHT]:
                snakedx += 1
            if pressedkeys[pygame.K_UP]:
                snakedy -= 1
            if pressedkeys[pygame.K_DOWN]:
                snakedy += 1
            if pressedkeys[pygame.K_RETURN]:
                snakedx = 0 # stop movement by pressing the 's' key
                snakedy = 0
            # ------------ AI ----------------
            crossx = min(birdx,snakex) + ( max(birdx, snakex) -  # cross is in the middle of bird and snake 
                     min(birdx,snakex)) / 2.0 -cross.get_width()/2
            crossy = min(birdy,snakey) + ( max(birdy, snakey) - 
                     min(birdy,snakey)) / 2.0 - cross.get_height()/2
            if crossx < policex:
                policedx -= 1        # police moves toward cross
            elif crossx > policex:
                policedx += 1
            if crossy > policey:
                policedy += 1
            elif crossy < policey:
                policedy -= 1
            thiefdx += random.randint( -erratic,erratic )  # thief is erratic
            thiefdy += random.randint( -erratic,erratic )
            thiefdx = max(thiefdx, -thiefmaxspeed)         # limit speed of thief
            thiefdx = min(thiefdx, thiefmaxspeed)
            thiefdy = max(thiefdy, -thiefmaxspeed)
            thiefdy = min(thiefdy, thiefmaxspeed)
            # ---- friction... sprites get slower ----
            policedx *= 0.995
            policedy *= 0.995
            snakedx *= 0.995
            snakedy *= 0.995
            birddx *= 0.995
            birddy *= 0.995
            # --------- new position -----------
            policex += policedx * seconds 
            policey += policedy * seconds
            birdx += birddx * seconds
            birdy += birddy * seconds
            snakex += snakedx * seconds
            snakey += snakedy * seconds
            thiefx += thiefdx * seconds
            thiefy += thiefdy * seconds
            # ----------- bounce ----------
            policex, policey, policedx, policedy = bounce(police, policex, policey, policedx, policedy)
            birdx, birdy, birddx, birddy = bounce(bird, birdx, birdy, birddx, birddy)
            snakex, snakey, snakedx, snakedy = bounce(snake, snakex, snakey, snakedx, snakedy)
            thiefx, thiefy, thiefdx, thiefdy = bounce(thief, thiefx, thiefy, thiefdx, thiefdy)
            # --- police got thief ? -----
            distx =  max(policex + police.get_width()/2 , thiefx + 
                     thief.get_width()/2) - min(policex + 
                     police.get_width()/2, thiefx + thief.get_width()/2)
            disty =  max(policey + police.get_height()/2 , thiefy + 
                     thief.get_height()/2) - min(policey + police.get_width()/2,
                     thiefy + thief.get_width()/2)
            catch_in_last_frame = catch_in_this_frame # save old catch info
            catch_in_this_frame = False
            if (distx < police.get_width() /2) and (disty < police.get_height()/2):
                catch_in_this_frame = True
                points += seconds
                screen.fill(randomcolour()) 
                if not pygame.mixer.get_busy():
                    spring.play() # only play this sound if mixer is silent at the moment
            else:
                # no catch this time
                if catch_in_last_frame:
                    screen.blit(background, (0,0)) # restore background
            # ---------- blit ----------------
            draw(bird, birdx, birdy)
            draw(snake, snakex, snakey)
            pygame.draw.line(screen, randomcolour(), (snakex,snakey), (birdx, birdy), 1)
            pygame.draw.line(screen, randomcolour(), (crossx,crossy), (policex, policey) ,1)
            draw(police, policex, policey)
            draw(cross, crossx, crossy)
            draw(thief, thiefx, thiefy)
        pygame.display.flip()          # flip the screen FPS times a second                
# check if the program is imported. if not, start it directly
if __name__ == "__main__":
    play_the_game()

########NEW FILE########
__FILENAME__ = 014_sprites
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
014-sprites.py
real pygame sprites
url: http://thepythongamebook.com/en:part2:pygame:step014
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

Real pygame Sprites moving around. Create more sprites with mouse click.
Shows collision detection
loading images from a subfolder called 'data'
all images files must be in the subfolder 'data'. The subfolder must be inside the
same folder as the program itself. 
"""
import pygame
import os
import random


pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
pygame.init()
screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
#winstyle = 0  # |FULLSCREEN # Set the display mode
BIRDSPEED = 50.0

def write(msg="pygame is cool"):
    myfont = pygame.font.SysFont("None", 32)
    mytext = myfont.render(msg, True, (0,0,0))
    mytext = mytext.convert_alpha()
    return mytext

class BirdCatcher(pygame.sprite.Sprite):
    def __init__(self):
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.image = pygame.Surface((100,100)) # created on the fly
        self.image.set_colorkey((0,0,0)) # black transparent
        pygame.draw.circle(self.image, (255,0,0), (50,50), 50, 2) # red circle
        self.image = self.image.convert_alpha()
        self.rect = self.image.get_rect()
        self.radius = 50 # for collide check
    def update(self, seconds):
        # no need for seconds but the other sprites need it
        self.rect.center = pygame.mouse.get_pos()


class Bird(pygame.sprite.Sprite):
    image=[]  # list of all images
    # not necessary:
    birds = {} # a dictionary of all Birds, each Bird has its own number
    number = 0  
    def __init__(self, startpos=(50,50), area=screen.get_rect()):
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.pos = [0.0,0.0]
        self.pos[0] = startpos[0]*1.0 # float
        self.pos[1] = startpos[1]*1.0 # float
        self.image = Bird.image[0]
        self.rect = self.image.get_rect()
        self.area = area # where the sprite is allowed to move
        self.newspeed()
        self.catched = False
        #--- not necessary:
        self.number = Bird.number # get my personal Birdnumber
        Bird.number+= 1           # increase the number for next Bird
        Bird.birds[self.number] = self # store myself into the Bird dictionary
        #print "my number %i Bird number %i " % (self.number, Bird.number)
    def newspeed(self):
        # new birdspeed, but not 0
        speedrandom = random.choice([-1,1]) # flip a coin
        self.dx = random.random() * BIRDSPEED * speedrandom + speedrandom 
        self.dy = random.random() * BIRDSPEED * speedrandom + speedrandom 
      
    def update(self, seconds):
        self.pos[0] += self.dx * seconds
        self.pos[1] += self.dy * seconds
        # -- check if out of screen
        if not self.area.contains(self.rect):
            self.image = Bird.image[1] # crash into wall
            # --- compare self.rect and area.rect
            if self.pos[0] + self.rect.width/2 > self.area.right:
                self.pos[0] = self.area.right - self.rect.width/2
            if self.pos[0] - self.rect.width/2 < self.area.left:
                self.pos[0] = self.area.left + self.rect.width/2
            if self.pos[1] + self.rect.height/2 > self.area.bottom:
                self.pos[1] = self.area.bottom - self.rect.height/2
            if self.pos[1] - self.rect.height/2 < self.area.top:
                self.pos[1] = self.area.top + self.rect.height/2
            self.newspeed() # calculate a new direction
        else:
            if self.catched:
                self.image = Bird.image[2] # blue rectangle
            else:
                self.image = Bird.image[0] # normal bird image
        #--- calculate new position on screen -----
            
        self.rect.centerx = round(self.pos[0],0)
        self.rect.centery = round(self.pos[1],0)


    
background = pygame.Surface((screen.get_width(), screen.get_height()))
background.fill((255,255,255))     # fill white
background.blit(write("Press left mouse button for more sprites. Press ESC to quit"),(5,10))
background = background.convert()  # jpg can not have transparency
screen.blit(background, (0,0))     # blit background on screen (overwriting all)
clock = pygame.time.Clock()        # create pygame clock object 
mainloop = True
FPS = 60                           # desired max. framerate in frames per second. 

# load images into classes (class variable !)
try:
    Bird.image.append(pygame.image.load(os.path.join("data","babytux.png")))
    Bird.image.append(pygame.image.load(os.path.join("data","babytux_neg.png")))
except:
    raise UserWarning, "Unable to find babytux images in the folder 'data' :-( "
Bird.image.append(Bird.image[0].copy()) # copy of first image
pygame.draw.rect(Bird.image[2], (0,0,255), (0,0,32,36), 1) # blue border
Bird.image[0] = Bird.image[0].convert_alpha()
Bird.image[1] = Bird.image[1].convert_alpha()
Bird.image[2] = Bird.image[2].convert_alpha()

birdgroup = pygame.sprite.Group()
allgroup = pygame.sprite.Group()
        
#assign default groups to each sprite class
Bird.groups = birdgroup, allgroup
BirdCatcher.groups = allgroup
# one single Bird
Bird()
# display the BirdCatcher and name it "hunter"
hunter = BirdCatcher() 

while mainloop:
    milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
    seconds = milliseconds / 1000.0 # seconds passed since last frame
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            mainloop = False # pygame window closed by user
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                mainloop = False # user pressed ESC
    # create new Bird on mouseclick
    if pygame.mouse.get_pressed()[0]:
        Bird(pygame.mouse.get_pos()) # create a new Bird at mousepos
    
    pygame.display.set_caption("[FPS]: %.2f birds: %i" % (clock.get_fps(), len(birdgroup)))
    
    # ------ collision detecttion
    for bird in birdgroup:
        bird.catched = False   # set all Bird sprites to not catched
        
    #pygame.sprite.spritecollide(sprite, group, dokill, collided = None): return Sprite_list
    crashgroup = pygame.sprite.spritecollide(hunter, birdgroup, False, pygame.sprite.collide_circle)
    # pygame.sprite.collide_circle works only if one sprite has self.radius
    # you can do without that argument collided and only the self.rects will be checked
    for crashbird in crashgroup:
        crashbird.catched = True # will get a blue border from Bird.update()
        #crashbird.kill()   # this would remove him from all his groups
        
    allgroup.clear(screen, background)
    allgroup.update(seconds)
    allgroup.draw(screen)
    
    pygame.display.flip()          # flip the screen 30 times a second             

########NEW FILE########
__FILENAME__ = 015_more_sprites
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
015_more_sprites.py
pygame sprites with hitbars and exploding fragments
url: http://thepythongamebook.com/en:part2:pygame:step015
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

pygame sprites moving araound and exploding into little fragments 
(on mouseclick). Effect of gravity on the fragments can be toggled.
Differnt coding style and its outcome on performance (framerate)
can be toggled and is displayed by green bars. a long bar indicates
a slow performance.
"""
def game():
        
    import pygame
    import os
    import random


    pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
    pygame.init()
    screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
    #winstyle = 0  # |FULLSCREEN # Set the display mode
    BIRDSPEEDMAX = 200
    BIRDSPEEDMIN = 10
    FRICTION =.999
    HITPOINTS = 100.0 
    FORCE_OF_GRAVITY = 9.81 # in pixel per second² .See http://en.wikipedia.org/wiki/Gravitational_acceleration
    print pygame.ver 
    def write(msg="pygame is cool"):
        """write text into pygame surfaces"""
        myfont = pygame.font.SysFont("None", 32)
        mytext = myfont.render(msg, True, (0,0,0))
        mytext = mytext.convert_alpha()
        return mytext
    
    #define sprite groups
    birdgroup = pygame.sprite.LayeredUpdates()   
    bargroup = pygame.sprite.Group()
    stuffgroup = pygame.sprite.Group()
    fragmentgroup = pygame.sprite.Group()
    # LayeredUpdates instead of group to draw in correct order
    allgroup = pygame.sprite.LayeredUpdates() # more sophisticated than simple group

    class BirdCatcher(pygame.sprite.Sprite):
        """circle around the mouse pointer. Left button create new sprite, right button kill sprite"""
        def __init__(self):
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.image = pygame.Surface((100,100)) # created on the fly
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.circle(self.image, (255,0,0), (50,50), 50, 2) # red circle
            self.image = self.image.convert_alpha()
            self.rect = self.image.get_rect()
            self.radius = 50 # for collide check

        def update(self, seconds):
            # no need for seconds but the other sprites need it
            self.rect.center = pygame.mouse.get_pos()

    class Fragment(pygame.sprite.Sprite):
        """a fragment of an exploding Bird"""
        gravity = True # fragments fall down ?
        def __init__(self, pos):
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.pos = [0.0,0.0]
            self.pos[0] = pos[0]
            self.pos[1] = pos[1]
            self.image = pygame.Surface((10,10))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.circle(self.image, (random.randint(1,64),0,0), (5,5), 
                                            random.randint(2,5))
            self.image = self.image.convert_alpha()
            self.rect = self.image.get_rect()
            self.rect.center = self.pos #if you forget this line the sprite sit in the topleft corner
            self.lifetime = 1 + random.random()*5 # max 6 seconds
            self.time = 0.0
            self.fragmentmaxspeed = BIRDSPEEDMAX * 2 # try out other factors !
            self.dx = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
            self.dy = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
            
        def update(self, seconds):
            self.time += seconds
            if self.time > self.lifetime:
                self.kill() 
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            if Fragment.gravity:
                self.dy += FORCE_OF_GRAVITY # gravity suck fragments down
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
            
    class Timebar(pygame.sprite.Sprite):
        """shows a bar as long as how much milliseconds are passed between two frames"""
        def __init__(self, long):
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.long = long   * 2
            self.image = pygame.Surface((self.long,5))
            self.image.fill((128,255,0))
            self.image.convert()
            self.rect = self.image.get_rect()
            self.rect.bottomleft = (0,screen.get_height())
        
        def update(self, time):
            self.rect.centery = self.rect.centery - 7
            if self.rect.centery < 0:
                self.kill()

    class Livebar(pygame.sprite.Sprite):
        """shows a bar with the hitpoints of a Bird sprite"""
        def __init__(self, boss):
            pygame.sprite.Sprite.__init__(self,self.groups)
            self.boss = boss
            self.image = pygame.Surface((self.boss.rect.width,7))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.rect(self.image, (0,255,0), (0,0,self.boss.rect.width,7),1)
            self.rect = self.image.get_rect()
            self.oldpercent = 0
            self.bossnumber = self.boss.number # the unique number (name) of my boss
            
        def update(self, time):
            self.percent = self.boss.hitpoints / self.boss.hitpointsfull * 1.0
            if self.percent != self.oldpercent:
                pygame.draw.rect(self.image, (0,0,0), (1,1,self.boss.rect.width-2,5)) # fill black
                pygame.draw.rect(self.image, (0,255,0), (1,1,
                    int(self.boss.rect.width * self.percent),5),0) # fill green
            self.oldpercent = self.percent
            self.rect.centerx = self.boss.rect.centerx
            self.rect.centery = self.boss.rect.centery - self.boss.rect.height /2 - 10
            #check if boss is still alive
            if not Bird.birds[self.bossnumber]:
                self.kill() # kill the hitbar

    class Bird(pygame.sprite.Sprite):
        """a nice little sprite that bounce off walls and other sprites"""
        image=[]  # list of all images
        # not necessary:
        birds = {} # a dictionary of all Birds, each Bird has its own number
        number = 0  
        def __init__(self, startpos=screen.get_rect().center):
            pygame.sprite.Sprite.__init__(self,  self.groups ) #call parent class. NEVER FORGET !
            self.pos = [0,0] # dummy values to create a list
            self.pos[0] = float(startpos[0]) # float for more precise calculation
            self.pos[1] = float(startpos[1])
            self.area = screen.get_rect()
            self.image = Bird.image[0]
            self.hitpointsfull = float(HITPOINTS) # maximal hitpoints , float makes decimal
            self.hitpoints = float(HITPOINTS) # actual hitpoints
            self.rect = self.image.get_rect()
            self.radius = max(self.rect.width, self.rect.height) / 2.0
                        
            self.newspeed()
            self.cleanstatus()
            self.catched = False
            self.crashing = False
            #--- not necessary:
            self.number = Bird.number # get my personal Birdnumber
            Bird.number+= 1           # increase the number for next Bird
            Bird.birds[self.number] = self # store myself into the Bird dictionary
            #print "my number %i Bird number %i " % (self.number, Bird.number)
            Livebar(self) #create a Livebar for this Bird. 
            
        def newspeed(self):
            # new birdspeed, but not 0
            speedrandom = random.choice([-1,1]) # flip a coin
            self.dx = random.random() * BIRDSPEEDMAX * speedrandom + speedrandom 
            self.dy = random.random() * BIRDSPEEDMAX * speedrandom + speedrandom 
            
        def kill(self):
            """because i want to do some special effects (sound, dictionary etc.)
            before killing the Bird sprite i have to write my own kill(self)
            function and finally call pygame.sprite.Sprite.kill(self) 
            to do the 'real' killing"""
            cry.play()
            #print Bird.birds, "..."
            for _ in range(random.randint(3,15)):
                Fragment(self.pos)
            Bird.birds[self.number] = None # kill Bird in sprite dictionary
            pygame.sprite.Sprite.kill(self) # kill the actual Bird 

        def cleanstatus(self):
            self.catched = False   # set all Bird sprites to not catched
            self.crashing = False

        def update(self, seconds):
            # friction make birds slower
            if abs(self.dx) > BIRDSPEEDMIN and abs(self.dy) > BIRDSPEEDMIN:
                self.dx *= FRICTION
                self.dy *= FRICTION
            # spped limit
            if abs(self.dx) > BIRDSPEEDMAX:
                self.dx = BIRDSPEEDMAX * self.dx / self.dx
            if abs(self.dy) > BIRDSPEEDMAX:
                self.dy = BIRDSPEEDMAX * self.dy / self.dy
            # new position
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            # -- check if Bird out of screen
            if not self.area.contains(self.rect):
                self.crashing = True # change colour later
                # --- compare self.rect and area.rect
                if self.pos[0] + self.rect.width/2 > self.area.right:
                    self.pos[0] = self.area.right - self.rect.width/2
                if self.pos[0] - self.rect.width/2 < self.area.left:
                    self.pos[0] = self.area.left + self.rect.width/2
                if self.pos[1] + self.rect.height/2 > self.area.bottom:
                    self.pos[1] = self.area.bottom - self.rect.height/2
                if self.pos[1] - self.rect.height/2 < self.area.top:
                    self.pos[1] = self.area.top + self.rect.height/2
                self.newspeed() # calculate a new direction
            #--- calculate actual image: crasing, catched, both, nothing ?
            self.image = Bird.image[self.crashing + self.catched*2]
            #--- calculate new position on screen -----
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
            #--- loose hitpoins
            if self.crashing:
                self.hitpoints -=1
            #--- check if still alive
            if self.hitpoints <= 0:
                self.kill()
        
    background = pygame.Surface((screen.get_width(), screen.get_height()))
    background.fill((255,255,255))     # fill white
    background.blit(write("press left mouse button for more sprites."),(150,10))
    background.blit(write("press right mouse button to kill sprites."),(150,40))
    background.blit(write("press g to toggle gravity"),(150,70))
    background.blit(write("press b to toggle bad coding"),(150,100))
    background.blit(write("press c to toggle clever coding"), (150,130))
    background.blit(write("Press ESC to quit"), (150,160))

    # paint vertical lines to measure passed time (Timebar)
    #for x in range(0,screen.get_width()+1,20):
    for x in range(0,140,20):
        pygame.draw.line(background, (255,0,255), (x,0) ,(x,screen.get_height()), 1)
    background = background.convert()  # jpg can not have transparency
    screen.blit(background, (0,0))     # blit background on screen (overwriting all)


    #assign default groups to each sprite class
    # (only allgroup is useful at the moment)
    Livebar.groups =  bargroup, allgroup 
    Timebar.groups = bargroup, allgroup
    Bird.groups =  birdgroup, allgroup
    Fragment.groups = fragmentgroup, allgroup
    BirdCatcher.groups = stuffgroup, allgroup
    #assign default layer for each sprite (lower numer is background)
    BirdCatcher._layer = 5 # top foreground
    Fragment._layer = 4
    Timebar._layer = 3
    Bird._layer = 2
    Livebar._layer = 1




    # load images into classes (class variable !)
    try:
        Bird.image.append(pygame.image.load(os.path.join("data","babytux.png")))
        Bird.image.append(pygame.image.load(os.path.join("data","babytux_neg.png")))
    except:
        raise UserWarning, "no image files 'babytux.png' and 'babytux_neg.png' in subfolder 'data'"
    Bird.image.append(Bird.image[0].copy()) # copy of first image
    pygame.draw.rect(Bird.image[2], (0,0,255), (0,0,32,36), 1) # blue border
    Bird.image.append(Bird.image[1].copy()) # copy second image
    pygame.draw.rect(Bird.image[3], (0,0,255), (0,0,32,36), 1) # blue border
    Bird.image[0] = Bird.image[0].convert_alpha()
    Bird.image[1] = Bird.image[1].convert_alpha()
    Bird.image[2] = Bird.image[2].convert_alpha()
    Bird.image[3] = Bird.image[3].convert_alpha()

    try:
        cry = pygame.mixer.Sound(os.path.join('data','claws.ogg'))  #load sound
    except:
        raise UserWarning, "could not load sound claws.ogg from 'data'"


   

    # at game start create a Bird and one BirdCatcher
    Bird()  # one single Bird
    hunter = BirdCatcher() # display the BirdCatcher and name it "hunter"

    # set 
    millimax = 0
    othergroup =  [] # important for good collision detection
    badcoding = False
    clevercoding = False
    clock = pygame.time.Clock()        # create pygame clock object 
    mainloop = True
    FPS = 60                           # desired max. framerate in frames per second. 


    while mainloop:
        
        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
        Timebar(milliseconds)
        if milliseconds > millimax:
            millimax = milliseconds
        seconds = milliseconds / 1000.0 # seconds passed since last frame
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
                elif event.key == pygame.K_g:
                    Fragment.gravity = not Fragment.gravity # toggle gravity class variable
                elif event.key == pygame.K_b:
                    if badcoding:
                        othergroup =  [] # 
                    badcoding = not badcoding
                    if badcoding: 
                        clevercoding = False
                elif event.key == pygame.K_c:
                    clevercoding = not clevercoding
                    if clevercoding:
                        badcoding = False
                elif event.key == pygame.K_p:
                    print "----------"
                    print "toplayer:", allgroup.get_top_layer()
                    print "bottomlayer:", allgroup.get_bottom_layer()
                    print "layers;", allgroup.layers()
                    

        # create new Bird on mouseclick
        if pygame.mouse.get_pressed()[0]:
            #if not pygame.sprite.spritecollideany(hunter, birdgroup): 
                Bird(pygame.mouse.get_pos()) # create a new Bird at mousepos
        if pygame.mouse.get_pressed()[2]:
            # kill sprites
            crashgroup = pygame.sprite.spritecollide(hunter, birdgroup, True, pygame.sprite.collide_circle)
        pygame.display.set_caption("ms: %i max(ms): %i fps: %.2f birds: %i gravity: %s bad:%s clever:%s"% (milliseconds, 
                                    millimax, clock.get_fps(), len(birdgroup), Fragment.gravity, badcoding, clevercoding))
        
        # ------ collision detecttion
        for bird in birdgroup:
            bird.cleanstatus()
            
        #pygame.sprite.spritecollide(sprite, group, dokill, collided = None): return Sprite_list
        crashgroup = pygame.sprite.spritecollide(hunter, birdgroup, False, pygame.sprite.collide_circle)
        # pygame.sprite.collide_circle works only if one sprite has self.radius
        # you can do without that argument collided and only the self.rects will be checked
        for crashbird in crashgroup:
            crashbird.catched = True # will get a blue border from Bird.update()
            #crashbird.kill()   # this would remove him from all his groups
        
        # test if a bird collides with another bird
        for bird in birdgroup:
            if not clevercoding:
                if badcoding:
                    othergroup = birdgroup.copy() # WRONG ! THIS CODE MAKES UGLY TIME-CONSUMING GARBAGE COLLECTION !
                else:
                    othergroup[:] = birdgroup.sprites() # correct. no garbage collection
                othergroup.remove(bird) # remove the actual bird, only all other birds remain
                if pygame.sprite.spritecollideany(bird, othergroup): 
                    
                    crashgroup = pygame.sprite.spritecollide(bird, othergroup, False )
                    for crashbird in crashgroup:
                        bird.crashing = True
                        bird.dx -= crashbird.pos[0] - bird.pos[0]
                        bird.dy -= crashbird.pos[1] - bird.pos[1]
            else:
                # very clever coding
                crashgroup = pygame.sprite.spritecollide(bird, birdgroup, False)
                for crashbird in crashgroup:
                    if crashbird.number != bird.number: #avoid collision with itself
                        bird.crashing = True # make bird blue
                        bird.dx -= crashbird.pos[0] - bird.pos[0] # move bird away from other bird
                        bird.dy -= crashbird.pos[1] - bird.pos[1]
                    
        # ----------- clear, draw , update, flip -----------------  
        allgroup.clear(screen, background)
        allgroup.update(seconds)
        allgroup.draw(screen)           
        pygame.display.flip()         

if __name__ == "__main__":
    game()

########NEW FILE########
__FILENAME__ = 016_layers
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
016_layers.py
pygame sprites with different layers and parallax scrolling
url: http://thepythongamebook.com/en:part2:pygame:step016
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html


change the sprite layer by clicking with left or right mouse button
the birdsprites will appear before or behind the blocks

point on a sprite and pres "p" to print out more information about that sprite
part of www.pythongamebook.com by Horst JENS

for copyright and install instructions see
http://www.spielend-programmieren.at/pythongamebook/doku.php?id=en:part2:step016
"""
def game():
        
    import pygame
    import os
    import random


    pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
    pygame.init()
    screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
    #winstyle = 0  # |FULLSCREEN # Set the display mode
    print "pygame version", pygame.ver 

    BIRDSPEEDMAX = 200
    BIRDSPEEDMIN = 10
    FRICTION =.999
    FORCE_OF_GRAVITY = 9.81
    
    
    def write(msg="pygame is cool"):
        """write text into pygame surfaces"""
        myfont = pygame.font.SysFont("None", 32)
        mytext = myfont.render(msg, True, (0,0,0))
        mytext = mytext.convert_alpha()
        return mytext
    
    class Text(pygame.sprite.Sprite):
        """ display a text"""
        def __init__(self, msg ):
            self.groups = allgroup, textgroup
            self._layer = 99
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.newmsg(msg)

            
        def update(self, time):
            pass
        
        def newmsg(self, msg="i have nothing to say"):
            self.image =  write(msg)
            self.rect = self.image.get_rect()
            self.rect.center = (screen.get_width()/2,10)

    class Mountain(pygame.sprite.Sprite):
        """generate a mountain sprite for the background, to 
           demonstrate parallax scrolling. Like in the classic
           'moonbuggy' game. Mountains slide from right to left"""
        def __init__(self, type):
            self.type = type
            if self.type == 1:
                self._layer = -1
                self.dx = -100
                self.color = (0,0,255) # blue mountains, close
            elif self.type == 2:
                self._layer = -2
                self.color = (200,0,255) # pink mountains, middle
                self.dx = -75
            else:
                self._layer = -3
                self.dx = -35
                self.color = (255,0,0) # red mountains, far away
            self.groups = allgroup, mountaingroup
            pygame.sprite.Sprite.__init__(self, self.groups) # THE Line
            self.dy = 0
            x = 100 * self.type * 1.5
            y = screen.get_height() / 2 + 50 * (self.type -1)
            self.image = pygame.Surface((x,y))
            #self.image.fill((0,0,0)) # fill with black
            self.image.set_colorkey((0,0,0)) # black is transparent
            pygame.draw.polygon(self.image, self.color,
               ((0,y),
                (0,y-10*self.type), 
                (x/2, int(random.random()*y/2)),
                (x,y-10*self.type),
                (x,y),
                (9,y)),0) # width=0 fills the polygon
            self.image.convert_alpha()
            self.rect = self.image.get_rect()
            self.pos = [0.0,0.0]
            # start right side from visible screen
            self.pos[0] = screen.get_width()+self.rect.width/2
            self.pos[1] = screen.get_height()-self.rect.height/2
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
            self.parent = False
            
        def update(self, time):
            self.pos[0] += self.dx * time
            self.pos[1] += self.dy * time
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
            # kill mountains too far to the left
            if self.rect.centerx + self.rect.width/2+10 < 0:
                self.kill()
            # create new mountains if necessary
            if not self.parent:
                if self.rect.centerx  < screen.get_width():
                    self.parent = True
                    Mountain(self.type) # new Mountain coming from the right side
            
           
    
    class Block(pygame.sprite.Sprite):
        """a block with a number indicating it's layer.
           Blocks move horizontal and bounce on screen edges"""
        def __init__(self, blocknumber=1):
            self.blocknumber = blocknumber
            self.color = (random.randint(10,255),
                          random.randint(10,255),
                          random.randint(10,255))
            self._layer = self.blocknumber
            self.groups = allgroup, blockgroup
            pygame.sprite.Sprite.__init__(self, self.groups) # THE line
            self.area = screen.get_rect()
            self.image = pygame.Surface((100,100))
            self.image.fill(self.color)
            self.image.blit(write(str(self.blocknumber)),(40,40))
            self.image = self.image.convert()
            self.rect = self.image.get_rect()
            self.rect.centery = screen.get_height() / 2
            self.rect.centerx = 100 * self.blocknumber + 50
            #self.rect.centery = (screen.get_height() / 10.0) * self.blocknumber + self.image.get_height() / 2
            self.pos = [0.0,0.0]
            self.pos[0] = self.rect.centerx
            self.pos[1] = self.rect.centery
            self.dy = random.randint(50,100) * random.choice((-1,1))
            self.dx = 0
            
        def newspeed(self):
            self.dy *= -1
            
        def update(self, time):
            if not self.area.contains(self.rect):
                # --- compare self.rect and area.rect
                if self.pos[1]  < self.area.top:
                    self.pos[1] = self.area.top
                    self.newspeed() # calculate a new direction
                elif self.pos[1] > self.area.bottom:
                    self.pos[1] = self.area.bottom
                    self.newspeed() # calculate a new direction
            self.pos[0] += self.dx * time
            self.pos[1] += self.dy * time
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
            
    class BirdCatcher(pygame.sprite.Sprite):
        """circle around the mouse pointer. Left button create new sprite, right button kill sprite"""
        def __init__(self):
            self._layer = 9
            self.groups = allgroup, stuffgroup
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.image = pygame.Surface((100,100)) # created on the fly
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.circle(self.image, (255,0,0), (50,50), 50, 2) # red circle
            self.image = self.image.convert_alpha()
            self.rect = self.image.get_rect()
            self.radius = 50 # for collide check

        def update(self, seconds):
            # no need for seconds but the other sprites need it
            self.rect.center = pygame.mouse.get_pos()

    class Lifebar(pygame.sprite.Sprite):
        """shows a bar with the hitpoints of a Bird sprite
           with a given bossnumber, the Lifebar class can 
           identify the boos (Bird sprite) with this codeline:
           Bird.birds[bossnumber] """
        def __init__(self, bossnumber):
            self.groups = allgroup, bargroup
            self.bossnumber = bossnumber
            self._layer = Bird.birds[self.bossnumber]._layer
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.image = pygame.Surface((Bird.birds[self.bossnumber].rect.width,7))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.rect(self.image, (0,255,0), (0,0,Bird.birds[self.bossnumber].rect.width,7),1)
            self.rect = self.image.get_rect()
            self.oldpercent = 0
            
        def update(self, time):
            self.percent = Bird.birds[self.bossnumber].hitpoints / Bird.birds[self.bossnumber].hitpointsfull * 1.0
            if self.percent != self.oldpercent:
                pygame.draw.rect(self.image, (0,0,0), (1,1,Bird.birds[self.bossnumber].rect.width-2,5)) # fill black
                pygame.draw.rect(self.image, (0,255,0), (1,1,
                                 int(Bird.birds[self.bossnumber].rect.width * self.percent),5),0) # fill green
            self.oldpercent = self.percent
            self.rect.centerx = Bird.birds[self.bossnumber].rect.centerx
            self.rect.centery = Bird.birds[self.bossnumber].rect.centery - Bird.birds[self.bossnumber].rect.height /2 - 10
            #check if boss is still alive
            if Bird.birds[self.bossnumber].hitpoints < 1:
                self.kill() # kill the hitbar
      
    class Bird(pygame.sprite.Sprite):
        """a nice little sprite that bounce off walls and other sprites"""
        image=[]  # list of all images
        birds = {} # a dictionary of all Birds, each Bird has its own number
        number = 0  
        waittime = 1.0 # seconds
        def __init__(self, layer = 4 ):
            self.groups = birdgroup, allgroup # assign groups 
            self._layer = layer                   # assign level
            #self.layer = layer
            pygame.sprite.Sprite.__init__(self,  self.groups  ) #call parent class. NEVER FORGET !
            #pygame.sprite.Sprite.__init__(self,  *args ) #call parent class. NEVER FORGET !
            self.pos = [random.randint(50,screen.get_width()-50),
                        random.randint(25,screen.get_height()-25)] 
            self.area = screen.get_rect()
            self.image = Bird.image[0]
            self.hitpointsfull = float(100) # maximal hitpoints
            self.hitpoints = float(100) # actual hitpoints
            self.rect = self.image.get_rect()
            self.radius = max(self.rect.width, self.rect.height) / 2.0
            self.dx = 0   # wait at the beginning
            self.dy = 0            
            self.waittime = Bird.waittime # 1.0 # one second
            #self.newspeed()
            self.lifetime = 0.0
            self.waiting = True
            self.rect.center = (-100,-100) # out of visible screen
            self.cleanstatus()
            self.catched = False
            self.crashing = False
            #--- not necessary:
            self.number = Bird.number # get my personal Birdnumber
            Bird.number+= 1           # increase the number for next Bird
            Bird.birds[self.number] = self # store myself into the Bird dictionary
            #print "my number %i Bird number %i " % (self.number, Bird.number)
            Lifebar(self.number) #create a Lifebar for this Bird. 
            # starting implosion of blue fragments
            for _ in range(8):
                Fragment(self.pos, True)
            
        def newspeed(self):
            # new birdspeed, but not 0
            speedrandom = random.choice([-1,1]) # flip a coin
            self.dx = random.randint(BIRDSPEEDMIN,BIRDSPEEDMAX) * speedrandom 
            self.dy = random.randint(BIRDSPEEDMIN,BIRDSPEEDMAX) * speedrandom 

        def cleanstatus(self):
            self.catched = False   # set all Bird sprites to not catched
            self.crashing = False
        
        def kill(self):
            # a shower of red fragments, exploding outward
            for _ in range(15):
                Fragment(self.pos)
            pygame.sprite.Sprite.kill(self) # kill the actual Bird 
            
        
        def update(self, seconds):
            #---make Bird only visible after waiting time
            self.lifetime += seconds
            if self.lifetime > (self.waittime) and self.waiting:
                self.newspeed()
                self.waiting = False
                self.rect.centerx = round(self.pos[0],0)
                self.rect.centery = round(self.pos[1],0)
            if self.waiting:
                self.rect.center = (-100,-100)
            else:
                # speedcheck
                # friction make birds slower
                if abs(self.dx) > BIRDSPEEDMIN and abs(self.dy) > BIRDSPEEDMIN:
                    self.dx *= FRICTION
                    self.dy *= FRICTION
                # spped limit
                if abs(self.dx) > BIRDSPEEDMAX:
                    self.dx = BIRDSPEEDMAX * self.dx / self.dx
                if abs(self.dy) > BIRDSPEEDMAX:
                    self.dy = BIRDSPEEDMAX * self.dy / self.dy
                # movement
                self.pos[0] += self.dx * seconds
                self.pos[1] += self.dy * seconds
                # -- check if Bird out of screen
                if not self.area.contains(self.rect):
                    self.crashing = True # change colour later
                    # --- compare self.rect and area.rect
                    if self.pos[0] + self.rect.width/2 > self.area.right:
                        self.pos[0] = self.area.right - self.rect.width/2
                    if self.pos[0] - self.rect.width/2 < self.area.left:
                        self.pos[0] = self.area.left + self.rect.width/2
                    if self.pos[1] + self.rect.height/2 > self.area.bottom:
                        self.pos[1] = self.area.bottom - self.rect.height/2
                    if self.pos[1] - self.rect.height/2 < self.area.top:
                        self.pos[1] = self.area.top + self.rect.height/2
                    self.newspeed() # calculate a new direction
                #--- calculate actual image: crasing, catched, both, nothing ?
                self.image = Bird.image[self.crashing + self.catched*2]
                #--- calculate new position on screen -----
                self.rect.centerx = round(self.pos[0],0)
                self.rect.centery = round(self.pos[1],0)
                #--- loose hitpoins
                if self.crashing:
                    self.hitpoints -=1
                #--- check if still alive
                if self.hitpoints <= 0:
                    self.kill()
            
    class Fragment(pygame.sprite.Sprite):
        """a fragment of an exploding Bird"""
        gravity = False # fragments fall down ?
        def __init__(self, pos, bluefrag = False):
            self._layer = 9
            self.groups = allgroup, stuffgroup
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.bluefrag = bluefrag
            self.pos = [0.0,0.0]
            self.target = pos
            self.fragmentmaxspeed = BIRDSPEEDMAX * 2 # try out other factors !
            if self.bluefrag:
                # blue frament implodes from screen edge toward Bird
                self.color = (0,0,random.randint(25,255)) # blue
                self.side = random.randint(1,4)
                if self.side == 1:  # left side
                    self.pos[0] = 0   
                    self.pos[1] = random.randint(0,screen.get_height())
                elif self.side == 2: # top
                    self.pos[0] = random.randint(0,screen.get_width()) 
                    self.pos[1] = 0
                elif self.side == 3: #right
                    self.pos[0] = screen.get_width() 
                    self.pos[1] = random.randint(0,screen.get_height())
                else: #bottom
                    self.pos[0] = random.randint(0,screen.get_width()) 
                    self.pos[1] = screen.get_height()
                # calculating flytime for one second.. Bird.waittime should be 1.0
                self.dx = (self.target[0] - self.pos[0]) * 1.0 / Bird.waittime
                self.dy = (self.target[1] - self.pos[1]) * 1.0 / Bird.waittime
                self.lifetime = Bird.waittime + random.random() * .5 # a bit more livetime after the Bird appears
            else: # red fragment explodes from the bird toward screen edge
                self.color = (random.randint(25,255),0,0) # red            
                self.pos[0] = pos[0]
                self.pos[1] = pos[1]
                self.dx = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
                self.dy = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
                self.lifetime = 1 + random.random()*3 # max 3 seconds
            self.image = pygame.Surface((10,10))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.circle(self.image, self.color, (5,5), random.randint(2,5))
            self.image = self.image.convert_alpha()
            self.rect = self.image.get_rect()
            self.rect.center = self.pos #if you forget this line the sprite sit in the topleft corner
            self.time = 0.0
            
        def update(self, seconds):
            self.time += seconds
            if self.time > self.lifetime:
                self.kill() 
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            if Fragment.gravity and not self.bluefrag:
                self.dy += FORCE_OF_GRAVITY # gravity suck fragments down
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
    
        
    background = pygame.Surface((screen.get_width(), screen.get_height()))
    background.fill((255,255,255))     # fill white
    background.blit(write("press left mouse button to increase Bird's layer"),(50,40))
    background.blit(write("press right mouse button to decrease Bird's layer."),(50,65))
    background.blit(write("layer of mountains are: -1 (blue), -2 (pink), -3 (red)"),(50,90))
    background.blit(write("Press ESC to quit, p to print info at mousepos"), (50,115))
    # secret keys: g (gravity), p (print layers)
    
    background = background.convert()  # jpg can not have transparency
    screen.blit(background, (0,0))     # blit background on screen (overwriting all)

    #define sprite groups. Do this before creating sprites 
    blockgroup = pygame.sprite.LayeredUpdates()
    birdgroup = pygame.sprite.Group() 
    textgroup = pygame.sprite.Group()
    bargroup = pygame.sprite.Group()
    stuffgroup = pygame.sprite.Group()
    mountaingroup = pygame.sprite.Group()
    # only the allgroup draws the sprite, so i use LayeredUpdates() instead Group()
    allgroup = pygame.sprite.LayeredUpdates() # more sophisticated, can draw sprites in layers 



    
    try: # load images into classes (class variable !). if not possible, draw ugly images
        Bird.image.append(pygame.image.load(os.path.join("data","babytux.png")))
        Bird.image.append(pygame.image.load(os.path.join("data","babytux_neg.png")))
    except:
        print "no image files 'babytux.png' and 'babytux_neg.png' in subfolder 'data'"
        print "therfore drawing ugly sprites instead"
        image = pygame.Surface((32,36))
        image.fill((255,255,255))
        pygame.draw.circle(image, (0,0,0), (16,18), 15,2)
        image.set_colorkey((255,255,255))
        Bird.image.append(image) # alternative ugly image
        image2 = image.copy()
        pygame.draw.circle(image2, (0,0,255), (16,18), 13,0)
        Bird.image.append(image2)
    Bird.image.append(Bird.image[0].copy()) # copy of first image
    pygame.draw.rect(Bird.image[2], (0,0,255), (0,0,32,36), 1) # blue border
    Bird.image.append(Bird.image[1].copy()) # copy second image
    pygame.draw.rect(Bird.image[3], (0,0,255), (0,0,32,36), 1) # blue border
    Bird.image[0] = Bird.image[0].convert_alpha()
    Bird.image[1] = Bird.image[1].convert_alpha()
    Bird.image[2] = Bird.image[2].convert_alpha()
    Bird.image[3] = Bird.image[3].convert_alpha()

    
    try: # ------- load sound -------
        cry = pygame.mixer.Sound(os.path.join('data','claws.ogg'))  #load sound
    except:
        ##raise SystemExit, "could not load sound claws.ogg from 'data'"
        print "could not load sound file claws.ogg from folder data. no sound, sorry"


    #create Sprites
    hunter = BirdCatcher() # display the BirdCatcher and name it "hunter"

    for x in range(screen.get_width()/100):
        Block(x) # add more Blocks if you y screen resolution is bigger
    
    othergroup =  [] # important for good collision detection
    badcoding = False
    clock = pygame.time.Clock()        # create pygame clock object 
    mainloop = True
    FPS = 60                           # desired max. framerate in frames per second. 
   
    birdlayer = 4
    birdtext = Text("current Bird _layer = %i" % birdlayer) # create Text sprite
    cooldowntime = 0 #sec
    
    # start with some Birds
    for _ in range(15):
        Bird(birdlayer)  # one single Bird
    
    # create the first parallax scrolling mountains
    Mountain(1) # blue
    Mountain(2) # pink
    Mountain(3) # red

    while mainloop: # ----------------- mainloop ----------------------
        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
                #elif event.key == pygame.K_g:
                    #Fragment.gravity = not Fragment.gravity # toggle gravity class variable
                elif event.key == pygame.K_p: # get sprites at mouse position, print info
                    print"========================="
                    print "-----Spritelist---------"
                    spritelist = allgroup.get_sprites_at(pygame.mouse.get_pos())
                    for sprite in spritelist:
                        print sprite, "Layer:",allgroup.get_layer_of_sprite(sprite)
                    print "------------------------"
                    print "toplayer:", allgroup.get_top_layer()
                    print "bottomlayer:", allgroup.get_bottom_layer()
                    print "layers;", allgroup.layers()
                    print"========================="
                    
                elif event.key == pygame.K_g:
                    Fragment.gravity = not Fragment.gravity # toggle gravity class variable
   

        # change birdlayer on mouseclick
        if cooldowntime <= 0: # to 
            if pygame.mouse.get_pressed()[0]:
                if birdlayer < 10:
                    birdlayer += 1
                    cooldowntime = .5 # seconds
                    cry.play()
                    for bird in birdgroup:
                        allgroup.change_layer(bird, birdlayer) # allgroup draws the sprite 
                    for bar in bargroup:
                        allgroup.change_layer(bar, birdlayer) # allgroup draws the sprite 
            if pygame.mouse.get_pressed()[2]:
                if birdlayer > -4:
                    birdlayer -= 1
                    cooldowntime = .5
                    cry.play()
                    for bird in birdgroup:
                        allgroup.change_layer(bird, birdlayer) # allgroup draws the sprite !
                    for bar in bargroup:
                        allgroup.change_layer(bar, birdlayer) # allgroup draws the sprite 
        else:
            cooldowntime -= seconds # to avoid speedclicking

        pygame.display.set_caption("fps: %.2f birds: %i grav: %s" % (clock.get_fps(), len(birdgroup), Fragment.gravity))
        

        birdtext.newmsg("current Bird _layer = %i" % birdlayer) # update text for birdlayer
    
        # ------ collision detection
        for bird in birdgroup:
            bird.cleanstatus() 
            
        #pygame.sprite.spritecollide(sprite, group, dokill, collided = None): return Sprite_list
        crashgroup = pygame.sprite.spritecollide(hunter, birdgroup, False, pygame.sprite.collide_circle)
        # pygame.sprite.collide_circle works only if one sprite has self.radius
        # you can do without that argument collided and only the self.rects will be checked
        for crashbird in crashgroup:
            crashbird.catched = True # will get a blue border from Bird.update()
        
        for bird in birdgroup:  # test if a bird collides with another bird
            # check the Bird.number to make sure the bird is not crashing with himself
            crashgroup = pygame.sprite.spritecollide(bird, birdgroup, False )
            for crashbird in crashgroup:
                if crashbird.number != bird.number: #different number means different birds
                    bird.crashing = True
                    if not bird.waiting:
                        bird.dx -= crashbird.pos[0] - bird.pos[0]
                        bird.dy -= crashbird.pos[1] - bird.pos[1]
        
        # create 10 new Birds if fewer than 11 birds alive
        if len(birdgroup) < 10:
            for _ in range(random.randint(1,5)):
                Bird(birdlayer)
                    
        # ----------- clear, draw , update, flip -----------------  
        allgroup.clear(screen, background)
        allgroup.update(seconds)
        allgroup.draw(screen)           
        pygame.display.flip()         

if __name__ == "__main__":
    game()
else:
    print "i was imported by", __name__

########NEW FILE########
__FILENAME__ = 017_asteroids
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Name:    pygmin.py
Purpose: Minimal code skeleton for pygame experiments 
URL:     
Author:  yipyip
Licence: gpl, see http://www.gnu.org/licenses/gpl.html
"""

####

import pygame

####

class PygView(object):

  
    def __init__(self, width=640, height=400):
        
        pygame.init()
        self.width = width
        self.height = height
        self.screen = pygame.display.set_mode((self.width, self.height), pygame.DOUBLEBUF)
        self.fps = 30 # frames per second
        pygame.display.set_caption("Press ESC to quit")
       

    def run(self):
        """The mainloop
        """
        self.clock = pygame.time.Clock() 
        running = True
        while running:
            self.seconds = self.clock.tick(self.fps)/1000.0 # seconds since last frame
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False 
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        running = False

            pygame.display.set_caption("press Esc to quit. Fps: %.2f (%i x %i)"%(self.clock.get_fps(), self.width, self.height))
            pygame.display.flip()          
        pygame.quit()

class Player(pygame.sprite.Sprite):
   images = []
   def __init__(self):
       self.image = Player.images[0]
          
####

if __name__ == '__main__':

    PygView().run()

########NEW FILE########
__FILENAME__ = 017_turning_and_physic
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
017_turning_and_physic.py
pygame sprites primitive physic (elastic collision)
url: http://thepythongamebook.com/en:part2:pygame:step017
author: horst.jens@spielend-programmieren.at
physic by Leonard Michlmayr
licence: gpl, see http://www.gnu.org/licenses/gpl.html

move the big bird around with the keys w,a,s,d  and q and e
fire with space, toggle gravity with g
"""
def game(folder = "data"):
    import pygame
    import os
    import random
    import math 
    #------ starting pygame -------------
    pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
    pygame.init()
    screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
    #winstyle = 0  # |FULLSCREEN # Set the display mode
    print "pygame version", pygame.ver 
    # ------- game constants ----------------------
    BIRDSPEEDMAX = 200
    FRAGMENTMAXSPEED = 200
    FRICTION =.991  # between 1 and 0. 1 means no friction at all (deep space)
    FORCE_OF_GRAVITY = 2.81 # pixel per second square earth: 9.81 m/s²
    GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad
    # ----------- functions -----------
    def write(msg="pygame is cool", color=(0,0,0)):
        """write text into pygame surfaces"""
        myfont = pygame.font.SysFont("None", 32)
        mytext = myfont.render(msg, True, color)
        mytext = mytext.convert_alpha()
        return mytext
    def getclassname(class_instance):
        """this function extract the class name of a class instance.
        For an instance of a XWing class, it will return 'XWing'."""
        text = str(class_instance.__class__) # like "<class '__main__.XWing'>"
        parts = text.split(".") # like ["<class '__main__","XWing'>"]
        return parts[-1][0:-2] # from the last (-1) part, take all but the last 2 chars
    
    def elastic_collision(sprite1, sprite2):
        """elasitc collision between 2 sprites (calculated as disc's).
           The function alters the dx and dy movement vectors of both sprites.
           The sprites need the property .mass, .radius, .pos[0], .pos[1], .dx, dy
           pos[0] is the x postion, pos[1] the y position"""
        # here we do some physics: the elastic
        # collision
        #
        # first we get the direction of the push.
        # Let's assume that the sprites are disk
        # shaped, so the direction of the force is
        # the direction of the distance.
        dirx = sprite1.pos[0] - sprite2.pos[0]
        diry = sprite1.pos[1] - sprite2.pos[1]
        #
        # the velocity of the centre of mass
        sumofmasses = sprite1.mass + sprite2.mass
        sx = (sprite1.dx * sprite1.mass + sprite2.dx * sprite2.mass) / sumofmasses
        sy = (sprite1.dy * sprite1.mass + sprite2.dy * sprite2.mass) / sumofmasses
        # if we sutract the velocity of the centre
        # of mass from the velocity of the sprite,
        # we get it's velocity relative to the
        # centre of mass. And relative to the
        # centre of mass, it looks just like the
        # sprite is hitting a mirror.
        #
        bdxs = sprite2.dx - sx
        bdys = sprite2.dy - sy
        cbdxs = sprite1.dx - sx
        cbdys = sprite1.dy - sy
        # (dirx,diry) is perpendicular to the mirror
        # surface. We use the dot product to
        # project to that direction.
        distancesquare = dirx * dirx + diry * diry
        if distancesquare == 0:
            # no distance? this should not happen,
            # but just in case, we choose a random
            # direction
            dirx = random.randint(0,11) - 5.5
            diry = random.randint(0,11) - 5.5
            distancesquare = dirx * dirx + diry * diry
        dp = (bdxs * dirx + bdys * diry) # scalar product
        dp /= distancesquare # divide by distance * distance.
        cdp = (cbdxs * dirx + cbdys * diry)
        cdp /= distancesquare
        # We are done. (dirx * dp, diry * dp) is
        # the projection of the velocity
        # perpendicular to the virtual mirror
        # surface. Subtract it twice to get the
        # new direction.
        #
        # Only collide if the sprites are moving
        # towards each other: dp > 0
        if dp > 0:
            sprite2.dx -= 2 * dirx * dp 
            sprite2.dy -= 2 * diry * dp
            sprite1.dx -= 2 * dirx * cdp 
            sprite1.dy -= 2 * diry * cdp
    # ----------- classes ------------------------
    class Text(pygame.sprite.Sprite):
        """a pygame Sprite displaying text"""
        def __init__(self, msg="The Python Game Book", color=(0,0,0)):
            self.groups = allgroup
            self._layer = 1
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.newmsg(msg,color)
            
        def update(self, time):
            pass # allgroup sprites need update method that accept time
        
        def newmsg(self, msg, color=(0,0,0)):
            self.image =  write(msg,color)
            self.rect = self.image.get_rect()

    class Lifebar(pygame.sprite.Sprite):
        """shows a bar with the hitpoints of a Bird sprite
           with a given bossnumber, the Lifebar class can 
           identify the boos (Bird sprite) with this codeline:
           Bird.birds[bossnumber] """
        def __init__(self, boss):
            self.groups = allgroup
            self.boss = boss
            self._layer = self.boss._layer
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.oldpercent = 0
            self.paint()
            
        def paint(self):
            self.image = pygame.Surface((self.boss.rect.width,7))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.rect(self.image, (0,255,0), (0,0,self.boss.rect.width,7),1)
            self.rect = self.image.get_rect()
 
        def update(self, time):
            self.percent = self.boss.hitpoints / self.boss.hitpointsfull * 1.0
            if self.percent != self.oldpercent:
                self.paint() # important ! boss.rect.width may have changed (because rotating)
                pygame.draw.rect(self.image, (0,0,0), (1,1,self.boss.rect.width-2,5)) # fill black
                pygame.draw.rect(self.image, (0,255,0), (1,1,
                                 int(self.boss.rect.width * self.percent),5),0) # fill green
            self.oldpercent = self.percent
            self.rect.centerx = self.boss.rect.centerx
            self.rect.centery = self.boss.rect.centery - self.boss.rect.height /2 - 10
            if self.boss.hitpoints < 1:   #check if boss is still alive
                self.kill() # kill the hitbar
       
    class Bird(pygame.sprite.Sprite):
        """generic Bird class, to be called from SmallBird and BigBird"""
        image=[]  # list of all images
        birds = {} # a dictionary of all Birds, each Bird has its own number
        number = 0  
        waittime = 1.0 # seconds
        def __init__(self, layer = 4, bigbird = False ):
            self.groups = birdgroup, allgroup, gravitygroup # assign groups 
            self._layer = layer                   # assign level
            #self.layer = layer
            pygame.sprite.Sprite.__init__(self,  self.groups  ) #call parent class. NEVER FORGET !
            self.pos = [random.randint(50,screen.get_width()-50),
                        random.randint(25,screen.get_height()-25)] 
            self.area = screen.get_rect()
            self.image = Bird.image[2]
            self.image = Bird.image[0]
            self.hitpointsfull = float(30) # maximal hitpoints
            self.hitpoints = float(30) # actual hitpoints
            self.rect = self.image.get_rect()
            self.radius = max(self.rect.width, self.rect.height) / 2.0
            self.dx = 0   # wait at the beginning
            self.dy = 0            
            self.waittime = Bird.waittime # 1.0 # one second
            self.lifetime = 0.0
            self.waiting = True
            self.rect.center = (-100,-100) # out of visible screen
            self.crashing = False
            self.frags = 25 # number of framgents if Bird is killed
            self.number = Bird.number # get my personal Birdnumber
            Bird.number+= 1           # increase the number for next Bird
            Bird.birds[self.number] = self # store myself into the Bird dictionary
            print "my number %i Bird number %i and i am a %s " % (self.number, Bird.number, getclassname(self))
            self.mass = 100.0
            self.angle = 0.0
            self.boostspeed = 10 # speed to fly upward
            self.boostmax = 0.9 # max seconds of "fuel" for flying upward
            self.boostmin = 0.4 # min seconds of "fuel" for flying upward
            self.boosttime = 0.0 # time (fuel) remaining
            warpsound.play()
            for _ in range(8):
                BlueFragment(self.pos) # blue Frags
      
        def kill(self):
            # a shower of red fragments, exploding outward
            for _ in range(self.frags):
                RedFragment(self.pos)
            pygame.sprite.Sprite.kill(self) # kill the actual Bird 
            
        def speedcheck(self):
            #if abs(self.dx) > BIRDSPEEDMAX:
            #   self.dx = BIRDSPEEDMAX * (self.dx/abs(self.dx)) # dx/abs(dx) is 1 or -1
            #if abs(self.dy) > BIRDSPEEDMAX:
            #   self.dy = BIRDSPEEDMAX * (self.dy/abs(self.dy))
            if abs(self.dx) > 0 : 
                self.dx *= FRICTION  # make the Sprite slower over time
            if abs(self.dy) > 0 :
                self.dy *= FRICTION

        def areacheck(self):
            if not self.area.contains(self.rect):
                self.crashing = True # change colour later
                # --- compare self.rect and area.rect
                if self.pos[0] + self.rect.width/2 > self.area.right:
                    self.pos[0] = self.area.right - self.rect.width/2
                    self.dx *= -0.5 # bouncing off but loosing speed
                if self.pos[0] - self.rect.width/2 < self.area.left:
                    self.pos[0] = self.area.left + self.rect.width/2
                    self.dx *= -0.5 # bouncing off the side but loosing speed
                if self.pos[1] + self.rect.height/2 > self.area.bottom:
                    self.pos[1] = self.area.bottom - self.rect.height/2
                    #self.dy *= -1 # bouncing off the ground
                    #if reaching the bottom, the birds get a boost and fly upward to the sky
                    #at the bottom the bird "refuel" a random amount of "fuel" (the boostime)
                    self.dy = 0 # break at the bottom
                    self.dx *= 0.3 # x speed is reduced at the ground
                    self.boosttime = self.boostmin + random.random()* (self.boostmax - self.boostmin)
                if self.pos[1] - self.rect.height/2 < self.area.top:
                    self.pos[1] = self.area.top + self.rect.height/2
                    self.dy = 0 # stop when reaching the sky
                    #self.dy *= -1 
                    self.hitpoints -= 1 # reaching the sky cost 1 hitpoint
        def update(self, seconds):
            #---make Bird only visible after waiting time
            self.lifetime += seconds
            if self.lifetime > (self.waittime):
                self.waiting = False
            if self.waiting:
                self.rect.center = (-100,-100)
            else: # the waiting time (Blue Fragments) is over
                if self.boosttime > 0:   # boost flying upwards ?
                    self.boosttime -= seconds
                    self.dy -= self.boostspeed # upward is negative y !
                    self.ddx = -math.sin(self.angle*GRAD) 
                    self.ddy = -math.cos(self.angle*GRAD) 
                    Smoke(self.rect.center, -self.ddx , -self.ddy )
                self.speedcheck()    # ------------- movement
                self.pos[0] += self.dx * seconds
                self.pos[1] += self.dy * seconds
                self.areacheck() # ------- check if Bird out of screen
                #--- calculate actual image: crasing, bigbird, both, nothing ?
                self.image = Bird.image[self.crashing+self.big] # 0 for not crashing, 1 for crashing
                self.image0 = Bird.image[self.crashing+self.big] # 0 for not crashing, 1 for crashing
                #--------- rotate into direction of movement ------------
                self.angle = math.atan2(-self.dx, -self.dy)/math.pi*180.0 
                self.image = pygame.transform.rotozoom(self.image0,self.angle,1.0)
                #--- calculate new position on screen -----
                self.rect.centerx = round(self.pos[0],0)
                self.rect.centery = round(self.pos[1],0)
                if self.hitpoints <= 0:
                    self.kill()
    
    class SmallBird(Bird):
        """A bird that get pushed around by shots, red fragments and other birds."""
        #gravity = True
        def __init__(self):
            self.big = 0
            Bird.__init__(self)
            Lifebar(self)
        
        def kill(self):
            crysound.play()
            Bird.kill(self)
    
    class BigBird(Bird):
        """A big bird controlled by the player"""
        def __init__(self):
            self.big = 2 # smallsprites have the value 0 for this attribute (.big) -> important for Bird.image
            Bird.__init__(self) # create a "little" Bird but do more than that
            self.hitpoints = float(100)
            self.hitpointsfull = float(100)
            self.image = Bird.image[2] # big bird image
            self.pos = [screen.get_width()/2, screen.get_height()/2]
            self.rect = self.image.get_rect()
            self.angle = 0
            self.speed = 20.0 # base movement speed factor
            self.rotatespeed = 1.0 # rotating speed
            self.frags = 100
            Lifebar(self)
            self.cooldowntime = 0.08 #seconds
            self.cooldown = 0.0
            self.damage = 5 # how many damage one bullet inflict
            self.shots = 0
            self.radius = self.image.get_width() / 2.0
            self.mass = 400.0
        
        def kill(self):
            bombsound.play()
            Bird.kill(self)
            
        def update(self, time):
            """BigBird has its own update method, overwriting the 
               update method from the Bird class"""
            self.lifetime += seconds
            if self.lifetime > (self.waittime):
                self.waiting = False
            if self.waiting:
                self.rect.center = (-100,-100)
            else:
                #--- calculate actual image: crasing, bigbird, both, nothing ?
                self.image = Bird.image[self.crashing+self.big] # 0 for not crashing, 2 for big
                pressedkeys = pygame.key.get_pressed()
                self.ddx = 0.0
                self.ddy = 0.0
                if pressedkeys[pygame.K_w]: # forward
                         self.ddx = -math.sin(self.angle*GRAD) 
                         self.ddy = -math.cos(self.angle*GRAD) 
                         Smoke(self.rect.center, -self.ddx , -self.ddy )
                if pressedkeys[pygame.K_s]: # backward
                         self.ddx = +math.sin(self.angle*GRAD) 
                         self.ddy = +math.cos(self.angle*GRAD) 
                         Smoke(self.rect.center, -self.ddx, -self.ddy )
                if pressedkeys[pygame.K_e]: # right side
                         self.ddx = +math.cos(self.angle*GRAD)
                         self.ddy = -math.sin(self.angle*GRAD)
                         Smoke(self.rect.center, -self.ddx , -self.ddy )
                if pressedkeys[pygame.K_q]: # left side
                         self.ddx = -math.cos(self.angle*GRAD) 
                         self.ddy = +math.sin(self.angle*GRAD) 
                         Smoke(self.rect.center, -self.ddx , -self.ddy )
                # ------------shoot-----------------
                if self.cooldown > 0:
                    self.cooldown -= time 
                else:
                    if pressedkeys[pygame.K_SPACE]: # shoot forward
                        self.ddx = +math.sin(self.angle*GRAD)#recoil
                        self.ddy = +math.cos(self.angle*GRAD)
                        lasersound.play() # play sound
                        self.shots += 1
                        Bullet(self, -math.sin(self.angle*GRAD) ,
                               -math.cos(self.angle*GRAD) )
                    self.cooldown = self.cooldowntime
                # ------------move------------------
                if not self.waiting:
                    self.dx += self.ddx * self.speed
                    self.dy += self.ddy * self.speed
                #self.speedcheck()   # friction, maxspeed             
                self.pos[0] += self.dx * seconds
                self.pos[1] += self.dy * seconds
                # -- check if Bird out of screen
                self.areacheck()
                # ------------- rotate ------------------
                if pressedkeys[pygame.K_a]: # left turn , counterclockwise
                    self.angle += self.rotatespeed
                if pressedkeys[pygame.K_d]: # right turn, clockwise
                    self.angle -= self.rotatespeed
                self.oldcenter = self.rect.center
                self.image = pygame.transform.rotate(self.image, self.angle)
                self.rect = self.image.get_rect()
                self.rect.center = self.oldcenter
                #--- calculate new position on screen -----
                self.rect.centerx = round(self.pos[0],0)
                self.rect.centery = round(self.pos[1],0)
                if self.hitpoints <= 0: # ----- alive---- 
                    self.kill()
            
    class Fragment(pygame.sprite.Sprite):
        """generic Fragment class. Inherits to blue Fragment (implosion),
           red Fragment (explosion), smoke (black) and shots (purple)"""
        def __init__(self, pos, layer = 9):
            self._layer = layer
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.pos = [0.0,0.0]
            self.fragmentmaxspeed = FRAGMENTMAXSPEED# try out other factors !

        def init2(self):  # split the init method into 2 parts for better access from subclasses
            self.image = pygame.Surface((10,10))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.circle(self.image, self.color, (5,5), random.randint(2,5))
            self.image = self.image.convert_alpha()
            self.rect = self.image.get_rect()
            self.rect.center = self.pos #if you forget this line the sprite sit in the topleft corner
            self.time = 0.0
            
        def update(self, seconds):
            self.time += seconds
            if self.time > self.lifetime:
                self.kill() 
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
    
    class RedFragment(Fragment):
        """explodes outward from (killed) Bird"""
        def __init__(self,pos):
            self.groups = allgroup, fragmentgroup, gravitygroup
            Fragment.__init__(self,pos)
            #red-only part -----------------------------
            self.color = (random.randint(25,255),0,0) # red            
            self.pos[0] = pos[0]
            self.pos[1] = pos[1]
            self.dx = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
            self.dy = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
            self.lifetime = 1 + random.random()*3 # max 3 seconds
            self.init2() # continue with generic Fragment class
            self.mass = 48.0
            
    class BlueFragment(Fragment):
        """implode inward toward new Bird (and a bittle outward after
           reaching the target position"""
        def __init__(self, pos):
            self.groups = allgroup 
            Fragment.__init__(self, pos)
            self.target = pos
            self.color = (0,0,random.randint(25,255)) # blue
            self.side = random.randint(1,4)
            if self.side == 1:  # left side
                self.pos[0] = 0   
                self.pos[1] = random.randint(0,screen.get_height())
            elif self.side == 2: # top
                self.pos[0] = random.randint(0,screen.get_width()) 
                self.pos[1] = 0
            elif self.side == 3: #right
                self.pos[0] = screen.get_width() 
                self.pos[1] = random.randint(0,screen.get_height())
            else: #bottom
                self.pos[0] = random.randint(0,screen.get_width()) 
                self.pos[1] = screen.get_height()
            # calculating flytime for one second.. Bird.waittime should be 1.0
            self.dx = (self.target[0] - self.pos[0]) * 1.0 / Bird.waittime
            self.dy = (self.target[1] - self.pos[1]) * 1.0 / Bird.waittime
            self.lifetime = Bird.waittime + random.random() * .5 # a bit more livetime after the Bird appears
            self.init2()
            
    class Smoke(Fragment):
        """black exhaust indicating that the BigBird sprite is moved by
           the player. Exhaust direction is inverse of players movement direction"""
        def __init__(self, pos, dx, dy):
           self.color = ( random.randint(1,50), random.randint(1,50), random.randint(1,50) )
           self.groups = allgroup
           Fragment.__init__(self,pos, 3) # give startpos and layer 
           self.pos[0] = pos[0]
           self.pos[1] = pos[1]
           self.lifetime = 1 + random.random()*2 # max 3 seconds
           Fragment.init2(self)
           self.smokespeed = 120.0 # how fast the smoke leaves the Bird
           self.smokearc = .3 # 0 = thin smoke stream, 1 = 180 Degrees
           arc = self.smokespeed * self.smokearc
           self.dx = dx * self.smokespeed + random.random()*2*arc - arc
           self.dy = dy * self.smokespeed + random.random()*2*arc - arc
           
    class Bullet(Fragment):
        """a bullet flying in the direction of the BigBird's heading. May 
           be subject to gravity"""
        def __init__(self, boss, dx, dy):
            self.color = (200,0,200)
            self.boss = boss
            self.groups = allgroup, bulletgroup, gravitygroup
            Fragment.__init__(self, self.boss.rect.center, 3) # layer behind Bird
            self.pos[0] = self.boss.pos[0]
            self.pos[1] = self.boss.pos[1]
            self.lifetime = 5 # 5 seconds
            self.image = pygame.Surface((4,20))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.rect(self.image, self.color, (0,0,4,20) )
            pygame.draw.rect(self.image, (10,0,0), (0,0,4,4)) # point
            self.image = self.image.convert_alpha()
            self.image0 = self.image.copy()
            self.rect = self.image.get_rect()
            self.rect.center = self.boss.rect.center
            self.image = pygame.transform.rotate(self.image, self.boss.angle)
            self.rect = self.image.get_rect()
            self.rect.center = self.boss.rect.center
            self.time = 0.0
            self.bulletspeed = 250.0 # pixel per second ?
            self.bulletarc = 0.05 # perfect shot has 0.0
            arc = self.bulletspeed * self.bulletarc
            self.dx = dx * self.bulletspeed + random.random()*2*arc -arc
            self.dy = dy * self.bulletspeed + random.random()*2*arc -arc
            self.mass = 25.0
            self.angle = self.boss.angle
            
        def update(self, time):
            Fragment.update(self,time)
            #--------- rotate into direction of movement ------------
            self.angle = math.atan2(-self.dx, -self.dy)/math.pi*180.0 
            self.image = pygame.transform.rotozoom(self.image0,self.angle,1.0)
            
    # ----------------- background artwork -------------  
    background = pygame.Surface((screen.get_width(), screen.get_height()))
    background.fill((255,255,255))     # fill white
    background.blit(write("navigate with w,a,s,d and q and e "),(50,40))
    background.blit(write("press SPACE to fire bullets"),(50,70))
    background.blit(write("press g to toggle gravity"), (50, 100))
    background.blit(write("Press ESC to quit "), (50,130))
    background = background.convert()  # jpg can not have transparency
    screen.blit(background, (0,0))     # blit background on screen (overwriting all)
    #-----------------define sprite groups------------------------
    birdgroup = pygame.sprite.Group() 
    bulletgroup = pygame.sprite.Group()
    fragmentgroup = pygame.sprite.Group()
    gravitygroup = pygame.sprite.Group()
    # only the allgroup draws the sprite, so i use LayeredUpdates() instead Group()
    allgroup = pygame.sprite.LayeredUpdates() # more sophisticated, can draw sprites in layers 

    #-------------loading files from data subdirectory -------------------------------
    try: # load images into classes (class variable !). if not possible, draw ugly images
        Bird.image.append(pygame.image.load(os.path.join(folder,"babytux.png")))
        Bird.image.append(pygame.image.load(os.path.join(folder,"babytux_neg.png")))
    except:
        print "no image files 'babytux.png' and 'babytux_neg.png' in subfolder %s" % folder
        print "therfore drawing ugly sprites instead"
        image = pygame.Surface((32,36))
        image.fill((255,255,255))
        pygame.draw.circle(image, (0,0,0), (16,18), 15,2)
        pygame.draw.polygon(image, (0,0,0), ((32,36),(0,36),(16,0)),1) # triangle
        image.set_colorkey((255,255,255))
        Bird.image.append(image) # alternative ugly image
        image2 = image.copy()
        pygame.draw.circle(image2, (0,0,255), (16,18), 13,0)
        Bird.image.append(image2)
    Bird.image.append(pygame.transform.scale2x(Bird.image[0])) # copy of first image, big bird
    Bird.image.append(pygame.transform.scale2x(Bird.image[1])) # copy of blue image, big bird
    Bird.image[0] = Bird.image[0].convert_alpha()
    Bird.image[1] = Bird.image[1].convert_alpha()
    Bird.image[2] = Bird.image[2].convert_alpha()
    Bird.image[3] = Bird.image[3].convert_alpha()

    try: # ------- load sound -------
        crysound = pygame.mixer.Sound(os.path.join(folder,'claws.ogg'))  #load sound
        warpsound = pygame.mixer.Sound(os.path.join(folder,'wormhole.ogg'))
        bombsound = pygame.mixer.Sound(os.path.join(folder,'bomb.ogg'))
        lasersound = pygame.mixer.Sound(os.path.join(folder,'shoot.ogg'))
        hitsound = pygame.mixer.Sound(os.path.join(folder,'beep.ogg'))
    except:
        print "could not load one of the sound files from folder %s. no sound, sorry" %folder
    # ------------- before the main loop ----------------------
    screentext = Text()
    clock = pygame.time.Clock()        # create pygame clock object 
    mainloop = True
    FPS = 60                           # desired max. framerate in frames per second. 
    amount = 7 # how many small birds should always be present on the screen
    player = BigBird() # big Bird
    overtime = 15 # time in seconds to admire the explosion of player before the game ends
    gameOver = False
    hits = 0  # how often the player was hitting a small Bird
    quota = 0 # hit/miss quota
    gametime = 60 # how long to play (seconds)
    playtime = 0  # how long the game was played
    gravity = True
        
    while mainloop:
        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame
        playtime += seconds # keep track of playtime
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
                elif event.key == pygame.K_x:
                    player.hitpoints -= 1
                    print player.hitpoints
                elif event.key == pygame.K_y:
                    player.hitpoints += 1
                    print player.hitpoints
                elif event.key == pygame.K_g:
                    gravity = not gravity # toggle gravity
                elif event.key == pygame.K_p: # get sprites at mouse position, print info
                    print"========================="
                    print "-----Spritelist---------"
                    spritelist = allgroup.get_sprites_at(pygame.mouse.get_pos())
                    for sprite in spritelist:
                        print sprite, "Layer:",allgroup.get_layer_of_sprite(sprite)
                    print "------------------------"
         
   
        if player.shots > 0:
            quota = (float(hits)/player.shots )* 100
        pygame.display.set_caption("fps: %.2f gravity: %s hits:%i shots:%i quota:%.2f%%"  % (clock.get_fps(), 
                                     gravity, hits, player.shots, quota))
        # ------ collision detection
        for bird in birdgroup:  # test if a bird collides with another bird
            bird.crashing = False # make bird NOT blue
            # check the Bird.number to make sure the bird is not crashing with himself
            if not bird.waiting: # do not check birds outside the screen
                crashgroup = pygame.sprite.spritecollide(bird, birdgroup, False )
                for crashbird in crashgroup:  # test bird with other bird collision
                    if crashbird.number > bird.number: #avoid checking twice
                        bird.crashing = True # make bird blue
                        crashbird.crashing = True # make other bird blue
                        if not (bird.waiting or crashbird.waiting):
                            elastic_collision(crashbird, bird) # change dx and dy of both birds
                                            
                crashgroup = pygame.sprite.spritecollide(bird, bulletgroup, False)
                for ball in crashgroup:  # test for collision with bullet
                    if ball.boss.number != bird.number:
                        hitsound.play()
                        hits +=1
                        bird.hitpoints -= ball.boss.damage
                        factor =  (ball.mass / bird.mass)
                        bird.dx += ball.dx * factor
                        bird.dy += ball.dy * factor
                        ball.kill()
                        
                crashgroup = pygame.sprite.spritecollide(bird, fragmentgroup, False)
                for frag in crashgroup: # test for red fragments
                    bird.hitpoints -=1
                    factor =  frag.mass / bird.mass
                    bird.dx += frag.dx * factor
                    bird.dy += frag.dy * factor
                    frag.kill()
                    
        if gravity: # ---- gravity check ---
            for thing in gravitygroup:
                thing.dy += FORCE_OF_GRAVITY # gravity suck down all kind of things
                    
        if len(birdgroup) < amount: # create enough SmallBirds
            for _ in range(random.randint(1,3)):
                SmallBird()
        
        # ------game Over ? -------------
        if (player.hitpoints < 1 or playtime > gametime) and not gameOver:
            gameOver = True # do those things once when the game ends
            screentext.newmsg("Game Over. hits/shots: %i/%i quota: %.2f%%" % (hits, player.shots, quota), (255,0,0))
            player.hitpoints = 0 # kill the player into a big explosion
        if gameOver: # overtime to watch score, explosion etc
            overtime -= seconds
            if overtime < 0:
                mainloop = False
        else: # not yet gameOver
            screentext.newmsg("Time left: %.2f" % (gametime - playtime))
        
        # ----------- clear, draw , update, flip -----------------  
        allgroup.clear(screen, background)
        allgroup.update(seconds)
        allgroup.draw(screen)           
        pygame.display.flip()         

if __name__ == "__main__":
    game()
else:
    print "i was imported by", __name__

########NEW FILE########
__FILENAME__ = 018_perfect_collision_detection
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
018_pefect_collision_detection.py
pixel perfect collision detection for pygame sprites
url: http://thepythongamebook.com/en:part2:pygame:step018
author: horst.jens@spielend-programmieren.at
physic by Leonard Michlmayr
licence: gpl, see http://www.gnu.org/licenses/gpl.html
 
this code demonstrate the difference between
colliderect, collidecircle and collidemask
 
move the small babytux around with the keys w,a,s,d  and q and e
fire with space, toggle gravity with g
toggle collision detection with c
Shoot on the giant monsters and watch the yellow impact "wounds"
"""
def game(folder = "data"):
    import pygame
    import os
    import random
    import math 
    #------ starting pygame -------------
    pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
    pygame.init()
    screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
    #winstyle = 0  # |FULLSCREEN # Set the display mode
    print "pygame version", pygame.ver 
    # ------- game constants ----------------------
    #BIRDSPEEDMIN = 10
    FRAGMENTMAXSPEED = 200
    FRICTION =.991  # between 1 and 0. 1 means no friction at all (deep space)
    FORCE_OF_GRAVITY = 2.81 # pixel per second square. Earth: 9.81 m/s²
    GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad
    # ----------- functions -----------
    def write(msg="pygame is cool", color=(0,0,0)):
        """write text into pygame surfaces"""
        myfont = pygame.font.SysFont("None", 32)
        mytext = myfont.render(msg, True, color)
        mytext = mytext.convert_alpha()
        return mytext
    def getclassname(class_instance):
        """this function extract the class name of a class instance.
        For an instance of a XWing class, it will return 'Wing'."""
        text = str(class_instance.__class__) # like "<class '__main__.XWing'>"
        parts = text.split(".") # like ["<class '__main__","XWing'>"]
        return parts[-1][0:-2] # from the last (-1) part, take all but the last 2 chars
    # ----------- classes ------------------------
    class Text(pygame.sprite.Sprite):
        """a pygame Sprite displaying text"""
        def __init__(self, msg="The Python Game Book", pos = (0,0), color=(0,0,0)):
            self.groups = allgroup, textgroup
            self.pos = pos
            self._layer = 1
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.newmsg(msg,color)
            self.rect.topleft = self.pos
            
        def update(self, time):
            pass # allgroup sprites need update method that accept time
        
        def newmsg(self, msg, color=(0,0,0)):
            self.image =  write(msg,color)
            self.rect = self.image.get_rect()
            self.rect.topleft = self.pos
            #self.rect.center = (screen.get_width()/2,10)

    class Lifebar(pygame.sprite.Sprite):
        """shows a bar with the hitpoints of a Bird sprite
           with a given bossnumber, the Lifebar class can 
           identify the boos (Bird sprite) with this codeline:
           Bird.birds[bossnumber] """
        def __init__(self, boss):
            self.groups = allgroup, bargroup
            self.boss = boss
            self._layer = self.boss._layer
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.oldpercent = 0
            self.paint()
            
        def paint(self):
            self.image = pygame.Surface((self.boss.rect.width,7))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.rect(self.image, (0,255,0), (0,0,self.boss.rect.width,7),1)
            self.rect = self.image.get_rect()
 
        def update(self, time):
            self.percent = self.boss.hitpoints / self.boss.hitpointsfull * 1.0
            if self.percent != self.oldpercent:
                self.paint() # important ! boss.rect.width may have changed (because rotating)
                pygame.draw.rect(self.image, (0,0,0), (1,1,self.boss.rect.width-2,5)) # fill black
                pygame.draw.rect(self.image, (0,255,0), (1,1,
                                 int(self.boss.rect.width * self.percent),5),0) # fill green
            self.oldpercent = self.percent
            self.rect.centerx = self.boss.rect.centerx
            self.rect.centery = self.boss.rect.centery - self.boss.rect.height /2 - 10
            if self.boss.hitpoints < 1:   #check if boss is still alive
                self.kill() # kill the hitbar
       
    class Bird(pygame.sprite.Sprite):
        """generic Bird class, to be called from SmallBird and BigBird"""
        image=[]  # list of all images
        birds = {} # a dictionary of all Birds, each Bird has its own number
        number = 0  
        waittime = 1.0 # seconds
        def __init__(self, layer = 4 ):
            if getclassname(self) == "Monster":
                self.groups = birdgroup, allgroup  # assign groups 
            else:
                self.groups = birdgroup, allgroup, gravitygroup
            self._layer = layer                   # assign level
            #self.layer = layer
            pygame.sprite.Sprite.__init__(self,  self.groups  ) #call parent class. NEVER FORGET !
            self.pos = [random.randint(50,screen.get_width()-50),
                        random.randint(25,screen.get_height()-25)] 
            self.area = screen.get_rect()
            self.rect = self.image.get_rect()
            #small radius from center to midleft
            self.radius = self.rect.width / 2
            #big radius from center to corner:
            #self.radius = ((self.rect.width/2) **2 + (self.rect.height/2) **2) ** .5
            self.dx = 0   # wait at the beginning
            self.dy = 0            
            self.frags = 25 # number of framgents if Bird is killed
            self.number = Bird.number # get my personal Birdnumber
            Bird.number+= 1           # increase the number for next Bird
            Bird.birds[self.number] = self # store myself into the Bird dictionary
            print "my number %i Bird number %i and i am a %s " % (self.number, Bird.number, getclassname(self))
            self.mass = 100.0
            
      
        def kill(self):
            # a shower of red fragments, exploding outward
            for _ in range(self.frags):
                RedFragment(self.pos)
            pygame.sprite.Sprite.kill(self) # kill the actual Bird 
            
        def speedcheck(self):
            #if abs(self.dx) > BIRDSPEEDMAX:
            #   self.dx = BIRDSPEEDMAX * (self.dx/abs(self.dx)) # dx/abs(dx) is 1 or -1
            #if abs(self.dy) > BIRDSPEEDMAX:
            #   self.dy = BIRDSPEEDMAX * (self.dy/abs(self.dy))
            if abs(self.dx) > 0 : 
                self.dx *= FRICTION  # make the Sprite slower over time
            if abs(self.dy) > 0 :
                self.dy *= FRICTION

        def areacheck(self):
            if not self.area.contains(self.rect):
                #self.crashing = True # change colour later
                # --- compare self.rect and area.rect
                if self.pos[0] + self.rect.width/2 > self.area.right:
                    self.pos[0] = self.area.right - self.rect.width/2
                    self.dx *= -0.5 # bouncing off but loosing speed
                if self.pos[0] - self.rect.width/2 < self.area.left:
                    self.pos[0] = self.area.left + self.rect.width/2
                    self.dx *= -0.5 # bouncing off the side but loosing speed
                if self.pos[1] + self.rect.height/2 > self.area.bottom:
                    self.pos[1] = self.area.bottom - self.rect.height/2
                    self.dy *= -0.5
                if self.pos[1] - self.rect.height/2 < self.area.top:
                    self.pos[1] = self.area.top + self.rect.height/2
                    self.dy *= -0.5 # stop when reaching the sky
                    
        def update(self, seconds):
            self.speedcheck()    
            # ------------- movement
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            # -------------- check if Bird out of screen
            self.areacheck()
            # ------ rotating
            if self.dx != 0 and self.dy!=0:
                ratio = self.dy / self.dx
                if self.dx > 0:
                    self.angle = -90-math.atan(ratio)/math.pi*180.0 # in grad
                else:
                    self.angle = 90-math.atan(ratio)/math.pi*180.0 # in grad
            #self.image = pygame.transform.rotozoom(self.image0,self.angle,1.0)
            #--- calculate new position on screen -----
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
            if self.hitpoints <= 0:
                self.kill()
    
    class Monster(Bird):
        """a very big bird for target practising"""
        def __init__(self, image):
            self.image = image
            Bird.__init__(self)
            #self.rect = self.image.get_rect()
            #self.radius = self.rect.width / 2 # for collision detection
            self.mask = pygame.mask.from_surface(self.image) # pixelmask
            self.hitpoints = float(1000)
            self.hitpointsfull = float(1000)
            #self.image = Bird.image[2] # big bird image
            Lifebar(self)
            
        def update(self, time):
            if random.randint(1,60) == 1:
                self.dx = random.randint(-100,100)
                self.dy = random.randint(-50,50)
            Bird.update(self,time)
            
        
    
    class BigBird(Bird):
        """A big bird controlled by the player"""
        
        def __init__(self):
            self.image = Bird.image[0] # big bird image
            self.image0 = Bird.image[0]
            #self.big = 2 # smallsprites have the value 0 for this attribute (.big) -> important for Bird.image
            Bird.__init__(self,5) # create a "little" Bird but do more than that
            self.hitpoints = float(100)
            self.hitpointsfull = float(100)
            self.pos = [screen.get_width()/2, screen.get_height()/2]
            #print "my BigBirdNumber is", self.number # i have a number in the Bird class !
            self.angle = 0
            self.speed = 20.0 # base movement speed factor
            self.rotatespeed = 1.0 # rotating speed
            self.frags = 100
            Lifebar(self)
            self.cooldowntime = 0.08 #seconds
            self.cooldown = 0.0
            self.damage = 5 # how many damage one bullet inflict
            self.shots = 0
            #self.radius = self.image.get_width() / 2.0
            self.mass = 400.0
        
        def kill(self):
            bombsound.play()
            Bird.kill(self)
            
        def update(self, time):
            """BigBird has its own update method, overwriting the 
               update method from the Bird class"""
             
            #--- calculate actual image: crasing, bigbird, both, nothing ?
            #self.image = Bird.image[self.crashing+self.big] # 0 for not crashing, 2 for big
            pressedkeys = pygame.key.get_pressed()
            self.ddx = 0.0
            self.ddy = 0.0
            if pressedkeys[pygame.K_w]: # forward
                     self.ddx = -math.sin(self.angle*GRAD) 
                     self.ddy = -math.cos(self.angle*GRAD) 
                     Smoke(self.rect.center, -self.ddx , -self.ddy )
            if pressedkeys[pygame.K_s]: # backward
                     self.ddx = +math.sin(self.angle*GRAD) 
                     self.ddy = +math.cos(self.angle*GRAD) 
                     Smoke(self.rect.center, -self.ddx, -self.ddy )
            if pressedkeys[pygame.K_e]: # right side
                     self.ddx = +math.cos(self.angle*GRAD)
                     self.ddy = -math.sin(self.angle*GRAD)
                     Smoke(self.rect.center, -self.ddx , -self.ddy )
            if pressedkeys[pygame.K_q]: # left side
                     self.ddx = -math.cos(self.angle*GRAD) 
                     self.ddy = +math.sin(self.angle*GRAD) 
                     Smoke(self.rect.center, -self.ddx , -self.ddy )
            # ------------shoot-----------------
            if self.cooldown > 0:
                self.cooldown -= time 
            else:
                if pressedkeys[pygame.K_SPACE]: # shoot forward
                    lasersound.play() # play sound
                    self.shots += 1
                    Bullet(self, -math.sin(self.angle*GRAD) ,
                           -math.cos(self.angle*GRAD) )
                self.cooldown = self.cooldowntime
            # ------------move------------------
            self.dx += self.ddx * self.speed
            self.dy += self.ddy * self.speed
            #self.speedcheck()   # friction, maxspeed             
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            # -- check if Bird out of screen
            self.areacheck()
            # ------------- rotate ------------------
            if pressedkeys[pygame.K_a]: # left turn , counterclockwise
                self.angle += self.rotatespeed
            if pressedkeys[pygame.K_d]: # right turn, clockwise
                self.angle -= self.rotatespeed
            self.oldcenter = self.rect.center
            self.image = pygame.transform.rotate(self.image0, self.angle)
            self.rect = self.image.get_rect()
            self.rect.center = self.oldcenter
            #--- calculate new position on screen -----
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
            if self.hitpoints <= 0: # ----- alive---- 
                self.kill()
            
    class Fragment(pygame.sprite.Sprite):
        """generic Fragment class. Inherits to blue Fragment (implosion),
           red Fragment (explosion), smoke (black) and shots (purple)"""
        def __init__(self, pos, layer = 9):
            self._layer = layer
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.pos = [0.0,0.0]
            self.fragmentmaxspeed = FRAGMENTMAXSPEED# try out other factors !

        def init2(self):  # split the init method into 2 parts for better access from subclasses
            self.image = pygame.Surface((10,10))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.circle(self.image, self.color, (5,5), random.randint(2,5))
            self.image = self.image.convert_alpha()
            self.rect = self.image.get_rect()
            self.rect.center = self.pos #if you forget this line the sprite sit in the topleft corner
            self.time = 0.0
            
        def update(self, seconds):
            self.time += seconds
            if self.time > self.lifetime:
                self.kill() 
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
    
    class RedFragment(Fragment):
        """explodes outward from (killed) Bird"""
        def __init__(self,pos):
            self.groups = allgroup, stuffgroup, fragmentgroup, gravitygroup
            Fragment.__init__(self,pos)
            #red-only part -----------------------------
            self.color = (random.randint(25,255),0,0) # red            
            self.pos[0] = pos[0]
            self.pos[1] = pos[1]
            self.dx = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
            self.dy = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
            self.lifetime = 1 + random.random()*3 # max 3 seconds
            self.init2() # continue with generic Fragment class
            self.mass = 48.0
            
   
    class Smoke(Fragment):
        """black exhaust indicating that the BigBird sprite is moved by
           the player. Exhaust direction is inverse of players movement direction"""
        def __init__(self, pos, dx, dy):
           self.color = ( random.randint(1,50), random.randint(1,50), random.randint(1,50) )
           self.groups = allgroup, stuffgroup
           Fragment.__init__(self,pos, 3) # give startpos and layer 
           self.pos[0] = pos[0]
           self.pos[1] = pos[1]
           self.lifetime = 1 + random.random()*2 # max 3 seconds
           Fragment.init2(self)
           self.smokespeed = 120.0 # how fast the smoke leaves the Bird
           self.smokearc = .3 # 0 = thin smoke stream, 1 = 180 Degrees
           arc = self.smokespeed * self.smokearc
           self.dx = dx * self.smokespeed + random.random()*2*arc - arc
           self.dy = dy * self.smokespeed + random.random()*2*arc - arc
           
    class Wound(Fragment):
        """yellow impact wound that shows the exact location of the hit"""
        def __init__(self, pos, victim):
            self.color = ( random.randint(200,255), random.randint(200,255), random.randint(0,50))
            self.groups = allgroup, stuffgroup
            Fragment.__init__(self, pos, 7) # layer
            self.pos[0] = pos[0]
            self.pos[1] = pos[1]
            self.lifetime = 1 + random.random()*2 # max 3 seconds
            Fragment.init2(self)
            self.victim = victim
        
        def update(self,time):
            self.dx = self.victim.dx
            self.dy = self.victim.dy
            Fragment.update(self, time)
           
    class Bullet(Fragment):
        """a bullet flying in the direction of the BigBird's heading. May 
           be subject to gravity"""
        def __init__(self, boss, dx, dy):
            self.color = (200,0,200)
            self.boss = boss
            self.groups = allgroup, bulletgroup, gravitygroup
            Fragment.__init__(self, self.boss.rect.center, 3) # layer behind Bird
            self.pos[0] = self.boss.pos[0]
            self.pos[1] = self.boss.pos[1]
            self.lifetime = 5 # 5 seconds
            self.image = pygame.Surface((4,20))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.rect(self.image, self.color, (0,0,4,20) )
            pygame.draw.rect(self.image, (10,0,0), (0,0,4,4)) # point
            self.image = self.image.convert_alpha()
            self.image0 = self.image.copy()
            self.rect = self.image.get_rect()
            self.rect.center = self.boss.rect.center
            self.image = pygame.transform.rotate(self.image, self.boss.angle)
            self.rect = self.image.get_rect()
            self.rect.center = self.boss.rect.center
            self.time = 0.0
            self.bulletspeed = 250.0 # pixel per second ?
            self.bulletarc = 0.05 # perfect shot has 0.0
            arc = self.bulletspeed * self.bulletarc
            self.dx = dx * self.bulletspeed + random.random()*2*arc -arc
            self.dy = dy * self.bulletspeed + random.random()*2*arc -arc
            self.mass = 25.0
            self.angle = self.boss.angle
            
        def update(self, time):
            Fragment.update(self,time)
            #--------- rotate into direction of movement ------------
            if self.dx != 0 and self.dy!=0:
                ratio = self.dy / self.dx
                if self.dx > 0:
                    self.angle = -90-math.atan(ratio)/math.pi*180.0 # in grad
                else:
                    self.angle = 90-math.atan(ratio)/math.pi*180.0 # in grad
            self.image = pygame.transform.rotozoom(self.image0,self.angle,1.0)
            
    # ----------------- end of definitions ------------  
    # ----------------- background artwork -------------  
    background = pygame.Surface((screen.get_width(), screen.get_height()))
    background.fill((255,255,255))     # fill white
    background.blit(write("navigate with w,a,s,d and q and e "),(50,40))
    background.blit(write("press SPACE to fire bullets"),(50,70))
    background.blit(write("press g to toggle gravity"), (50, 100))
    background.blit(write("press c to toggle collision detection."),(50,130))
    background.blit(write("Press ESC to quit "), (50,160))
    background = background.convert()  # jpg can not have transparency
    screen.blit(background, (0,0))     # blit background on screen (overwriting all)
    #-----------------define sprite groups------------------------
    birdgroup = pygame.sprite.Group() 
    textgroup = pygame.sprite.Group()
    bargroup = pygame.sprite.Group()
    stuffgroup = pygame.sprite.Group()
    bulletgroup = pygame.sprite.Group()
    fragmentgroup = pygame.sprite.Group()
    gravitygroup = pygame.sprite.Group()
    # only the allgroup draws the sprite, so i use LayeredUpdates() instead Group()
    allgroup = pygame.sprite.LayeredUpdates() # more sophisticated, can draw sprites in layers 

    #-------------loading files from data subdirectory -------------------------------
    try: # load images into classes (class variable !). if not possible, draw ugly images
        Bird.image.append(pygame.image.load(os.path.join(folder,"babytux.png")))
        Bird.image.append(pygame.image.load(os.path.join(folder,"crossmonster.png")))
        Bird.image.append(pygame.image.load(os.path.join(folder,"xmonster.png")))
    except:
        raise UserWarning, "could not load images from folder %s" % folder
        # ------------
    Bird.image[0] = Bird.image[0].convert_alpha()
    Bird.image[1] = Bird.image[1].convert_alpha()
    Bird.image[2] = Bird.image[2].convert_alpha()
    
    try: # ------- load sound -------
        crysound = pygame.mixer.Sound(os.path.join(folder,'claws.ogg'))  #load sound
        bombsound = pygame.mixer.Sound(os.path.join(folder,'bomb.ogg'))
        lasersound = pygame.mixer.Sound(os.path.join(folder,'shoot.ogg'))
        hitsound = pygame.mixer.Sound(os.path.join(folder,'beep.ogg'))
    except:
        print "could not load one of the sound files from folder %s. no sound, sorry" %folder
    # ------------- before the main loop ----------------------
    collision = "rect"
    screentext = Text()
    screentext2 = Text("collsion detection: %s" % collision, (200,0))
    othergroup =  [] # important for good collision detection
    clock = pygame.time.Clock()        # create pygame clock object 
    mainloop = True
    FPS = 60                           # desired max. framerate in frames per second. 
    amount = 7 # how many small birds should always be present on the screen
    #for _ in range(amount):     # start with some small Birds
    #    SmallBird()  # some small Birds
    player = BigBird() # big Bird
    dummy = Monster(Bird.image[1])
    dummy2 = Monster(Bird.image[2])  # add more giant birds at will
    overtime = 15 # time in seconds to admire the explosion of player before the game ends
    gameOver = False
    hits = 0  # how often the player was hitting a small Bird
    quota = 0 # hit/miss quota
    gametime = 60 # how long to play (seconds)
    playtime = 0  # how long the game was played
    gravity = True
        
    while mainloop:
        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame
        playtime += seconds # keep track of playtime
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
                elif event.key == pygame.K_x:
                    player.hitpoints -= 1
                    print player.hitpoints
                elif event.key == pygame.K_y:
                    player.hitpoints += 1
                    print player.hitpoints
                elif event.key == pygame.K_g:
                    gravity = not gravity # toggle gravity
                elif event.key == pygame.K_p: # get sprites at mouse position, print info
                    print"========================="
                    print "-----Spritelist---------"
                    spritelist = allgroup.get_sprites_at(pygame.mouse.get_pos())
                    for sprite in spritelist:
                        print sprite, "Layer:",allgroup.get_layer_of_sprite(sprite)
                    print "------------------------"
                elif event.key == pygame.K_c:
                    if collision == "rect":
                        collision = "circle"
                    elif collision == "circle":
                        collision = "mask"
                    elif collision == "mask":
                        collision = "rect"
                    screentext2.newmsg("collsion detection: %s" % collision)
         
   
        if player.shots > 0:
            quota = (float(hits)/player.shots )* 100
        pygame.display.set_caption("fps: %.2f gravity: %s hits:%i shots:%i quota:%.2f%%"  % (clock.get_fps(), 
                                     gravity, hits, player.shots, quota))
        # ------ collision detection
        for bird in birdgroup:

            if collision == "rect":
                crashgroup = pygame.sprite.spritecollide(bird, bulletgroup, False, pygame.sprite.collide_rect)
            elif collision == "circle":
                crashgroup = pygame.sprite.spritecollide(bird, bulletgroup, False, pygame.sprite.collide_circle)
            elif collision == "mask":
                crashgroup = pygame.sprite.spritecollide(bird, bulletgroup, False, pygame.sprite.collide_mask)
            else:
                raise SystemExit, "wrong/missing collisoin method"
            for ball in crashgroup:  # test for collision with bullet
                if ball.boss.number != bird.number:
                    hitsound.play()
                    hits +=1
                    bird.hitpoints -= ball.boss.damage
                    #factor =  (ball.mass / bird.mass)
                    #bird.dx += ball.dx * factor
                    #bird.dy += ball.dy * factor
                    Wound(ball.rect.center, bird)
                    ball.kill()
                    
            crashgroup = pygame.sprite.spritecollide(bird, fragmentgroup, False)
            for frag in crashgroup: # test for red fragments
                bird.hitpoints -=1
                factor =  frag.mass / bird.mass
                bird.dx += frag.dx * factor
                bird.dy += frag.dy * factor
                frag.kill()
                    
        if gravity: # ---- gravity check ---
            for thing in gravitygroup:
                thing.dy += FORCE_OF_GRAVITY # gravity suck down all kind of things
                    
        #if len(birdgroup) < amount: # create enough SmallBirds
        #    for _ in range(random.randint(1,3)):
        #        SmallBird()
        
        # ------game Over ? -------------
        if (player.hitpoints < 1 or playtime > gametime) and not gameOver:
            gameOver = True # do those things once when the game ends
            screentext2.newmsg("")
            screentext.newmsg("Game Over. hits/shots: %i/%i quota: %.2f%%" % (hits, player.shots, quota), (255,0,0))
            player.hitpoints = 0 # kill the player into a big explosion
        if gameOver: # overtime to watch score, explosion etc
            overtime -= seconds
            if overtime < 0:
                mainloop = False
        else: # not yet gameOver
            screentext.newmsg("Time left: %.2f" % (gametime - playtime))
        
        # ----------- clear, draw , update, flip -----------------  
        allgroup.clear(screen, background)
        allgroup.update(seconds)
        allgroup.draw(screen)           
        pygame.display.flip()         

if __name__ == "__main__":
    game()
else:
    print "i was imported by", __name__

########NEW FILE########
__FILENAME__ = 019_homing_missiles
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
019_homing_missiles.py
2-player game with homing missiles
url: http://thepythongamebook.com/en:part2:pygame:step019
author: horst.jens@spielend-programmieren.at
physic by Leonard Michlmayr
licence: gpl, see http://www.gnu.org/licenses/gpl.html

2 player can shoot at each other and/or at monster(s).
2 types of homing missiles (can also be shot down)
create new monsters with key m
"""

def game(folder = "data"):
    import pygame
    import os
    import random
    import math 
    #------ starting pygame -------------
    pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
    pygame.init()
    screen=pygame.display.set_mode((1024,600)) # try out larger values and see what happens !
    screenrect = screen.get_rect()
    #winstyle = 0  # |FULLSCREEN # Set the display mode
    #print "pygame version", pygame.ver 
    # ------- game constants ----------------------
    GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad
    # ----------- functions -----------
    def write(msg="pygame is cool", color=(0,0,0)):
        """write text into pygame surfaces"""
        myfont = pygame.font.SysFont("None", 32)
        mytext = myfont.render(msg, True, color)
        mytext = mytext.convert_alpha()
        return mytext
    def getclassname(class_instance):
        """this function extract the class name of a class instance.
        For an instance of a XWing class, it will return 'XWing'."""
        text = str(class_instance.__class__) # like "<class '__main__.XWing'>"
        parts = text.split(".") # like ["<class '__main__","XWing'>"]
        return parts[-1][0:-2] # from the last (-1) part, take all but the last 2 chars
    
    def radians_to_degrees(radians):
        return (radians / math.pi) * 180.0
    
    def degrees_to_radians(degrees):
        return degrees * (math.pi / 180.0)
    
    def elastic_collision(sprite1, sprite2):
        """elasitc collision between 2 sprites (calculated as disc's).
           The function alters the dx and dy movement vectors of both sprites.
           The sprites need the property .mass, .radius, .pos[0], .pos[1], .dx, dy
           pos[0] is the x postion, pos[1] the y position"""
        # here we do some physics: the elastic
        # collision
        # first we get the direction of the push.
        # Let's assume that the sprites are disk
        # shaped, so the direction of the force is
        # the direction of the distance.
        dirx = sprite1.pos[0] - sprite2.pos[0]
        diry = sprite1.pos[1] - sprite2.pos[1]
        # the velocity of the centre of mass
        sumofmasses = sprite1.mass + sprite2.mass
        sx = (sprite1.dx * sprite1.mass + sprite2.dx * sprite2.mass) / sumofmasses
        sy = (sprite1.dy * sprite1.mass + sprite2.dy * sprite2.mass) / sumofmasses
        # if we sutract the velocity of the centre
        # of mass from the velocity of the sprite,
        # we get it's velocity relative to the
        # centre of mass. And relative to the
        # centre of mass, it looks just like the
        # sprite is hitting a mirror.
        bdxs = sprite2.dx - sx
        bdys = sprite2.dy - sy
        cbdxs = sprite1.dx - sx
        cbdys = sprite1.dy - sy
        # (dirx,diry) is perpendicular to the mirror
        # surface. We use the dot product to
        # project to that direction.
        distancesquare = dirx * dirx + diry * diry
        if distancesquare == 0:
            # no distance? this should not happen,
            # but just in case, we choose a random
            # direction
            dirx = random.randint(0,11) - 5.5
            diry = random.randint(0,11) - 5.5
            distancesquare = dirx * dirx + diry * diry
        dp = (bdxs * dirx + bdys * diry) # scalar product
        dp /= distancesquare # divide by distance * distance.
        cdp = (cbdxs * dirx + cbdys * diry)
        cdp /= distancesquare
        # We are done. (dirx * dp, diry * dp) is
        # the projection of the velocity
        # perpendicular to the virtual mirror
        # surface. Subtract it twice to get the
        # new direction.
        # Only collide if the sprites are moving
        # towards each other: dp > 0
        if dp > 0:
            sprite2.dx -= 2 * dirx * dp 
            sprite2.dy -= 2 * diry * dp
            sprite1.dx -= 2 * dirx * cdp 
            sprite1.dy -= 2 * diry * cdp
    
    # ----------- classes ------------------------

    class Text(pygame.sprite.Sprite):
        """a pygame Sprite displaying text"""
        def __init__(self, msg="The Python Game Book", color=(0,0,0), topleft=(0,0)):
            self.groups = allgroup
            self.topleft = topleft
            self._layer = 1
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.newmsg(msg,color)
            
        def update(self, time):
            pass # allgroup sprites need update method that accept time
        
        def newmsg(self, msg, color=(0,0,0)):
            self.image =  write(msg,color)
            self.rect = self.image.get_rect()
            self.rect.topleft = self.topleft

    class Lifebar(pygame.sprite.Sprite):
        """shows a bar with the hitpoints of a GameObject sprite
           with a given bossnumber, the Lifebar class can 
           identify the boss (GameObject sprite) with this codeline:
           GameObject.gameobjects[self.bossnumber] """
        def __init__(self, boss):
            self.groups = allgroup
            self.boss = boss
            self._layer = self.boss._layer
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.oldpercent = 0
            self.color = (0,255,0)
            self.distance = 10
            self.paint()
            self.oldangle = self.boss.angle # store angle of boss to redraw bar if boss is rotating
            
        def paint(self):
            self.image = pygame.Surface((self.boss.rect.width,7))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.rect(self.image, self.color, (0,0,self.boss.rect.width,7),1)
            self.rect = self.image.get_rect()
 
        def recalc(self):
            self.percent = self.boss.hitpoints / self.boss.hitpointsfull * 1.0
 
        def update(self, time):
            self.recalc()
            #self.paint()
            if (self.percent != self.oldpercent) or (self.oldangle != self.boss.angle):
                self.oldangle = self.boss.angle # store angle of boss
                self.paint() # important ! boss.rect.width may have changed (because rotating)
                pygame.draw.rect(self.image, (0,0,0), (1,1,self.boss.rect.width-2,5)) # fill black
                pygame.draw.rect(self.image, self.color, (1,1,
                                 int(self.boss.rect.width * self.percent),5),0) # fill green
            self.oldpercent = self.percent
            self.rect.centerx = self.boss.rect.centerx
            self.rect.centery = self.boss.rect.centery - self.boss.rect.height /2 - self.distance
            if GameObject.gameobjects[self.boss.number] == None:
                self.kill() # kill the hitbar
    
    class Rocketbar(Lifebar):
        """shows a bar to indicate the stock of rockets."""
        def __init__(self, boss):
            Lifebar.__init__(self,boss)
            self.color = (0,0,128)
            self.distance = 16
        
        def recalc(self):
            if self.boss.rockets > self.boss.rocketsmax / 2:
                self.color = (0,0,255)
            else:
                self.color = (0,0,128)
            self.percent = self.boss.rockets / self.boss.rocketsmax * 1.0
        
    class GameObject(pygame.sprite.Sprite):
        """generic Game Object Sprite class, to be called from every Sprite
           with a physic collision (Player, Rocket, Monster, Bullet)
           need self.image and self.image0 and self.groups to be set
           need self.rect and self.pos to be set
           self.hitpoints must be set to a float, also self.hitpointsfull"""
        image=[]  # list of all images
        gameobjects = {} # a dictionary of all GameObjects, each GameObject has its own number
        number = 0  
        #def __init__(self, pos, layer= 4, area=screenrect, areastop = False, areabounce = False, angle=0, speedmax = 500, friction = 0.95, lifetime = -1):
        def __init__(self, layer= 4, area=screenrect, areastop = False, areabounce = False, angle=0, speedmax = 500, friction = 0.95, lifetime = -1):
            #self.pos = pos
            self._layer = layer                   # assign level
            self.area = area
            self.areastop = areastop
            self.areabounce = areabounce
            self.angle = angle 
            self.oldangle = angle
            self.speedmax = speedmax
            self.friction = friction # between 0 and 1, 1 means no friction, 0 means no more movement is possible
            self.lifetime = lifetime # -1 means infinite lifetime
            pygame.sprite.Sprite.__init__(self,  self.groups  ) #---------------call parent class. NEVER FORGET !
            self.alivetime = 0.0 # how long does this GameObject exist ?
            self.bouncefriction = -0.5 # how much speed is lost by bouncing off a wall. 1 means no loss, 0 means full stop
            self.dx = 0   # wait at the beginning
            self.dy = 0            
            self.number = GameObject.number # get my personal GameObject number
            GameObject.number+= 1           # increase the number for next GameObject
            GameObject.gameobjects[self.number] = self # store myself into the GameObject dictionary
          
        def speedcheck(self):
            speed = (self.dx**2 + self.dy**2)**0.5 ## calculate total speed
            if speed > self.speedmax:
                factor = self.speedmax / speed * 1.0
                self.dx *= factor
                self.dy *= factor
            else:
                self.color = (0,0,128)
            self.percent = self.boss.rockets / self.boss.rocketsmax * 1.0
        
    class GameObject(pygame.sprite.Sprite):
        """generic Game Object Sprite class, to be called from every Sprite
           with a physic collision (Player, Rocket, Monster, Bullet)
           need self.image and self.image0 and self.groups to be set
           need self.rect and self.pos to be set
           self.hitpoints must be set to a float, also self.hitpointsfull"""
        image=[]  # list of all images
        gameobjects = {} # a dictionary of all GameObjects, each GameObject has its own number
        number = 0  
        #def __init__(self, pos, layer= 4, area=screenrect, areastop = False, areabounce = False, angle=0, speedmax = 500, friction = 0.95, lifetime = -1):
        def __init__(self, layer= 4, area=screenrect, areastop = False, areabounce = False, angle=0, speedmax = 500, friction = 0.95, lifetime = -1):
            #self.pos = pos
            self._layer = layer                   # assign level
            self.area = area
            self.areastop = areastop
            self.areabounce = areabounce
            self.angle = angle 
            self.oldangle = angle
            self.speedmax = speedmax
            self.friction = friction # between 0 and 1, 1 means no friction, 0 means no more movement is possible
            self.lifetime = lifetime # -1 means infinite lifetime
            pygame.sprite.Sprite.__init__(self,  self.groups  ) #---------------call parent class. NEVER FORGET !
            self.alivetime = 0.0 # how long does this GameObject exist ?
            self.bouncefriction = -0.5 # how much speed is lost by bouncing off a wall. 1 means no loss, 0 means full stop
            self.dx = 0   # wait at the beginning
            self.dy = 0            
            self.number = GameObject.number # get my personal GameObject number
            GameObject.number+= 1           # increase the number for next GameObject
            GameObject.gameobjects[self.number] = self # store myself into the GameObject dictionary
          
        def speedcheck(self):
            speed = (self.dx**2 + self.dy**2)**0.5 ## calculate total speed
            if speed > self.speedmax:
                factor = self.speedmax / speed * 1.0
                self.dx *= factor
                self.dy *= factor
            #----------- friction -------------            
            if abs(self.dx) > 0 : 
                self.dx *= self.friction  # make the Sprite slower over time
            if abs(self.dy) > 0 :
                self.dy *= self.friction

        def areacheck(self):
            """if GameObject leave self.arena, it is bounced (self.areabounce) or stopped (self.areastop)"""
            if (self.areastop or self.areabounce) and not self.area.contains(self.rect):
                # --- compare self.rect and area.rect
                if self.pos[0] + self.rect.width/2 > self.area.right:
                    self.pos[0] = self.area.right - self.rect.width/2
                    if self.areabounce:
                        self.dx *= self.bouncefriction # bouncing off but loosing speed
                    else:
                        self.dx = 0
                if self.pos[0] - self.rect.width/2 < self.area.left:
                    self.pos[0] = self.area.left + self.rect.width/2
                    if self.areabounce:
                        self.dx *= self.bouncefriction # bouncing off but loosing speed
                    else:
                        self.dx = 0
                if self.pos[1] + self.rect.height/2 > self.area.bottom:
                    self.pos[1] = self.area.bottom - self.rect.height/2
                    if self.areabounce:
                        self.dy *= self.bouncefriction # bouncing off but loosing speed
                    else:
                        self.dy = 0
                if self.pos[1] - self.rect.height/2 < self.area.top:
                    self.pos[1] = self.area.top + self.rect.height/2
                    if self.areabounce:
                        self.dy *= self.bouncefriction # bouncing off but loosing speed
                    else:
                        self.dy = 0
                        
        def rotate_toward_moving(self, dx= None, dy=None):
            if dx is None and dy is None:
                dx = self.dx
                dy = self.dy
            return  math.atan2(-dx, -dy)/math.pi*180.0 
        
        def kill(self):
            GameObject.gameobjects[self.number] =   None # delete sprite from dictionary
            pygame.sprite.Sprite.kill(self) # kill the sprite              
        
        def update(self, seconds):
            self.alivetime += seconds
            # ------- killing --------------
            if self.hitpoints <= 1:
                self.kill()
            if self.lifetime != -1:
                if self.alivetime > self.lifetime:
                    self.kill() # end of natural lifetime
            # --------- rotated ? -------------------
            if self.angle != self.oldangle:            
                self.oldcenter = self.rect.center
                self.image = pygame.transform.rotate(self.image0, self.angle)
                self.rect = self.image.get_rect()
                self.rect.center = self.oldcenter
                self.oldangle = self.angle

            #----------moving ----------------
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            self.speedcheck()    # ------------- movement
            self.areacheck() # ------- check if Bird out of screen
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
    
    class Player(GameObject):
        """a class to hold all players"""
        number = 0
        image = []
        duel = False # duel or cooperative play
        def __init__(self, playernumber = 0):
            self.playernumber = Player.number
            self.bullets_fired = 0
            self.rockets_fired = 0
            self.bullets_hit = 0
            self.rockets_hit = 0
            Player.number += 1 # prepare number for next player 
            self.hitpoints = 450.0
            self.hitpointsfull = 450.0
            self.image = Player.image[self.playernumber] # start with 0
            self.image0 = Player.image[self.playernumber] # start with 0 
            self.rect = self.image.get_rect()
            self.mask = pygame.mask.from_surface(self.image) # pixelmask ---- necessary ?
            if self.playernumber == 0:
                self.pos = [screen.get_width()/10*2,screen.get_height()-30]
                self.angle = 270
                self.bulletcolor = (200,0,200)
                self.rocket1color = (200,50,50)
                self.rocket2color = (250,100,0)
            elif self.playernumber ==1:
                self.pos = [screen.get_width()/10*8,screen.get_height()-30]
                self.angle = 90
                self.bulletcolor = (0,200,200)
                self.rocket1color = (50,50,200)
                self.rocket2color = (0,200,250)
            # ---------- both players ---------
            self.bulletlifetime = 1.4 # short lifetime, but steals hitpoints
            self.max_abberation = 5.5 # low value means more precise shooting
            self.groups = allgroup, playergroup, gravitygroup
            #  def __init__(self, pos, layer= 4, area=screenrect, areastop = False, areabounce = False, angle=0, speedmax = 500, friction = 0.8, lifetime = -1)
            GameObject.__init__(self, areastop = True, angle = self.angle, speedmax = 300) # ------------------- important ! ----------------------
            self.speed = 50.0 # base movement speed factor
            self.rotatespeed = 3.0 # rotating speed
            self.frags = 100
            Lifebar(self)
            self.cooldowntime = 0.08 #seconds
            self.cooldown = 0.0
            self.rocketcooldowntime = .005 #seconds
            self.rocketcooldown = 0.0
            self.rocketreloadtime = 1.6 # seconds
            self.peacetime = 0.0 # how long no shot was fired
            self.rockets = 0.0   # must be float or bar sprite will not work correctly
            self.rocketsmax = 32.0 # max amount of rockets in stock
                                 # all rockets above rocketsmax/2 are heavy rockets
            Rocketbar(self) # draw bar to indicate how many rockets are left
            self.mass = 400.0
            self.frags = 100
            self.oldangle = -5
            
        def kill(self):
            bombsound.play()
            for _ in range(self.frags):
                RedFragment(self.pos)
            GameObject.kill(self) # call parent method
        
        def get_target_nr(self):
            # select a random monster as target
            if Player.duel:
                if (GameObject.gameobjects[0] is not None) and (GameObject.gameobjects[1] is not None):
                    # both players alive and duel mode, select other player
                    if self.number == 0:
                        return 1
                    else:
                        return 0
                else:
                    Player.duel = False # switch to cooperative mode because only one player is alive
            if not Player.duel and len(Monster.monsters) > 0:
                    return random.choice(Monster.monsters)
            else:
                pass # ------
                
        
        def update(self, seconds):
              pressedkeys = pygame.key.get_pressed()
              self.ddx = 0.0
              self.ddy = 0.0
              self.targetnumber = self.get_target_nr()
              if self.playernumber == 0:
                    if pressedkeys[pygame.K_w]: # forward
                             self.ddx = -math.sin(self.angle*GRAD) 
                             self.ddy = -math.cos(self.angle*GRAD) 
                             Smoke(self.rect.center, -self.ddx , -self.ddy )
                    if pressedkeys[pygame.K_s]: # backward
                             self.ddx = +math.sin(self.angle*GRAD) 
                             self.ddy = +math.cos(self.angle*GRAD) 
                             Smoke(self.rect.center, -self.ddx, -self.ddy )
                    if pressedkeys[pygame.K_e]: # right side
                             self.ddx = +math.cos(self.angle*GRAD)
                             self.ddy = -math.sin(self.angle*GRAD)
                             Smoke(self.rect.center, -self.ddx , -self.ddy )
                    if pressedkeys[pygame.K_q]: # left side
                             self.ddx = -math.cos(self.angle*GRAD) 
                             self.ddy = +math.sin(self.angle*GRAD) 
                             Smoke(self.rect.center, -self.ddx , -self.ddy )
              elif self.playernumber == 1:
                    if pressedkeys[pygame.K_KP8]: # forward
                             self.ddx = -math.sin(self.angle*GRAD) 
                             self.ddy = -math.cos(self.angle*GRAD) 
                             Smoke(self.rect.center, -self.ddx , -self.ddy )
                    if pressedkeys[pygame.K_KP5] or pressedkeys[pygame.K_KP2]: # backward
                             self.ddx = +math.sin(self.angle*GRAD) 
                             self.ddy = +math.cos(self.angle*GRAD) 
                             Smoke(self.rect.center, -self.ddx, -self.ddy )
                    if pressedkeys[pygame.K_KP9]: # right side
                             self.ddx = +math.cos(self.angle*GRAD)
                             self.ddy = -math.sin(self.angle*GRAD)
                             Smoke(self.rect.center, -self.ddx , -self.ddy )
                    if pressedkeys[pygame.K_KP7]: # left side
                             self.ddx = -math.cos(self.angle*GRAD) 
                             self.ddy = +math.sin(self.angle*GRAD) 
                             Smoke(self.rect.center, -self.ddx , -self.ddy )                        
              # ------------shoot-----------------
              self.peacetime += seconds # increase peacetime if no shot was fired
              if self.cooldown > 0: # ------ can not shoot
                    self.cooldown -= seconds # pause between bullets
              else: # --------can shoot
                    if ((self.playernumber == 1 and pressedkeys[pygame.K_KP0]) or 
                        (self.playernumber == 0 and pressedkeys[pygame.K_SPACE])): # shoot forward
                            self.ddx = +math.sin(self.angle*GRAD)#recoil
                            self.ddy = +math.cos(self.angle*GRAD)
                            lasersound.play() # play sound
                            Bullet(self, None, self.max_abberation )
                            self.peacetime = 0 # reset peacetime
                            self.cooldown = self.cooldowntime 
                            self.bullets_fired += 1
                            if self.rocketcooldown > 0:
                                self.rocketcooldown -= seconds
                            else:
                                if self.rockets > self.rocketsmax / 2: # heavy sliding rocket
                                    if self.targetnumber is not None:
                                        crysound.play()
                                        Rocket(self,self.targetnumber,1,-30) #boss, target, type, launchangle
                                        Rocket(self,self.targetnumber,1, 30) #boss, target, type, launchangle
                                        self.rockets_fired +=2
                                        self.rockets -= 2
                                        self.rocketcooldown = self.rocketcooldowntime
                                elif self.rockets > 2: # weak seeking rocket
                                    if self.targetnumber is not None:
                                        crysound.play()
                                        Rocket(self,self.targetnumber, 2, -80 )#boss, target, type
                                        Rocket(self,self.targetnumber, 2, 80 )#boss, target, type
                                        self.rockets_fired += 2
                                        self.rockets -= 2
                                        self.rocketcooldown = self.rocketcooldowntime
              #----- add more rockets --------
              if self.peacetime > self.rocketreloadtime:
                  self.rockets += 2
                  self.peacetime = 0
              #-------------rotate----------------
              if self.playernumber == 0:
                    if pressedkeys[pygame.K_a]: # left turn , counterclockwise
                        self.angle += self.rotatespeed
                    if pressedkeys[pygame.K_d]: # right turn, clockwise
                        self.angle -= self.rotatespeed
              elif self.playernumber == 1:
                    if pressedkeys[pygame.K_KP4]: # left turn , counterclockwise
                        self.angle += self.rotatespeed
                    if pressedkeys[pygame.K_KP6]: # right turn, clockwise
                        self.angle -= self.rotatespeed
              # ------------move------------------
              self.dx += self.ddx * self.speed 
              self.dy += self.ddy * self.speed
              # ----- move, rotate etc. ------------  
              GameObject.update(self, seconds)# ------- calll parent function 
            
    class Monster(GameObject):
        """neutral Monster, hunt both players"""
        image = []
        monsters=[]
        def __init__(self, pos=screenrect.center):
            self.groups = allgroup, gravitygroup, playergroup, monstergroup
            self.image = Monster.image[0]
            self.bullets_fired = 0
            self.rockets_fired = 0
            self.bullets_hit = 0
            self.bulletcolor=(0,128,0)
            self.bulletlifetime = 2.8 # longer lifetime than player's bullet, but no lifestealing effect
            self.max_abberation = 6
            self.rocket1color = (20,random.randint(200,255),80)
            self.rocket2color = (20,random.randint(200,255),80)
            self.rockets_hit = 0
            self.rect = self.image.get_rect()
            self.pos = [0.0,0.0]
            self.pos[0] = pos[0]
            self.pos[1] = pos[1]
            self.rect.center = pos
            self.hitpoints = 500.0
            self.hitpointsfull = 1000.0
            self.mass = 1000
            self.radius = self.rect.width / 2
            GameObject.__init__(self, layer= 5, area=screenrect, areastop = True, areabounce = True, angle=0, speedmax = 300, friction = 0.95, lifetime = -1)
            Monster.monsters.append(self.number)
            self.frags = 1406 
            self.hunttime = 0.0
            self.targetnumber = self.choose_target_nr()
            self.target = GameObject.gameobjects[self.targetnumber]
            self.playernumber = Player.number
            Player.number += 1
            Lifebar(self)
            self.firetime = 0.0 # how long the fire image is visible
            self.phase =  "nothing" # do not shoot
            self.phases = ["nothing", "bullets", "heavy rockets", "small rockets"]
        
        def kill(self):
            bombsound.play()
            for  _ in range(self.frags):
                RedFragment(self.pos)
            Monster.monsters.remove(self.number)
            GameObject.kill(self)
            
        def choose_target_nr(self):
            # as long as one player exist, target him
            # else, target another monster
            if GameObject.gameobjects[0] is not None and GameObject.gameobjects[1] is not None: # both players alive
               return random.randint(0,1) # choose one of both
            elif GameObject.gameobjects[0] is not None:
                return 0 # choose the surviving player
            elif GameObject.gameobjects[1] is not None:
                return 1 # choose the surviving player
            elif len(monstergroup) > 0: # 1+ Monsters are alive
                mynumber = self.number
                while mynumber == self.number:
                   mynumber = random.choice(Monster.monsters)
                return mynumber
            else:
                return None
                
            
        def update(self, seconds):
            # each second, decide if to hunt player 0 or player 1
            self.hunttime += seconds
            if self.hunttime > 15:
                self.hunttime = 0
                self.targetnumber = self.choose_target_nr()
                self.target = GameObject.gameobjects[self.targetnumber]
            # hunting
            self.image = Monster.image[0] # "normal" xmonster
            if GameObject.gameobjects[self.targetnumber] is not None:
                self.targetdistancex = self.target.pos[0] - self.pos[0]
                self.targetdistancey = self.target.pos[1] - self.pos[1]
                if self.targetdistancex > 0:
                    self.dx += 1
                    if self.targetdistancex > 100:
                        self.image = Monster.image[3] # look right
                        #self.image0 = Monster.image[3] # look right
                elif self.targetdistancex <0:
                    self.dx -= 1
                    if self.targetdistancex < -100:
                        self.image = Monster.image[2] # look left
                        #self.image0 = Monster.image[2] # look left
                if self.targetdistancey > 0:
                    self.dy += 1
                elif self.targetdistancey < 0:
                    self.dy -= 1
                # ----- shoot rockets --------
                # ---- 4 different phases: bullets, heavy rockets, light rockets, pausing
                # ---- chance to change into another phase each full second
                self.phase = self.phases[int(self.alivetime) % 4 ] # fully cycle throug all phases each 3 seconds
                if self.phase == "nothing":
                    pass # do not shoot
                elif self.phase == "bullets":
                    if random.randint(1,2) == 1:
                        Bullet(self, GameObject.rotate_toward_moving(self, self.targetdistancex, self.targetdistancey), self.max_abberation)
                        self.bullets_fired += 1
                        self.firetime = 0.1
                elif self.phase == "heavy rockets":
                    #self.angle = math.atan2(-self.dx, -self.dy)/math.pi*180.0 
                    if random.randint(1,50) == 1:
                        Rocket(self, self.targetnumber, 1) # shoot a slow, heavy rocket
                        self.rockets_fired += 1
                        self.firetime = 0.25 # show fire image for this time
                elif self.phase == "small rockets":
                    if random.randint(1,25) == 1:
                        Rocket(self, self.targetnumber, 2) # shoot a small fast rocket
                        self.rockets_fired += 1
                        self.firetime = 0.25 # show fire image for this time
                    
                if self.firetime > 0:
                    self.image = Monster.image[1] # show fire image for monster
                    self.firetime -= seconds    
                else:
                    self.firetime = 0
            GameObject.update(self, seconds)
            
            
    class Fragment(pygame.sprite.Sprite):
        """generic Fragment class. """
        number = 0
        def __init__(self, pos, layer = 9):
            self._layer = layer
            pygame.sprite.Sprite.__init__(self, self.groups)
            self.pos = [0.0,0.0]
            self.fragmentmaxspeed = 200# try out other factors !
            self.number = Fragment.number
            Fragment.number += 1
            
        def init2(self):  # split the init method into 2 parts for better access from subclasses
            self.image = pygame.Surface((10,10))
            self.image.set_colorkey((0,0,0)) # black transparent
            self.fragmentradius = random.randint(2,5)
            pygame.draw.circle(self.image, self.color, (5,5), self.fragmentradius)
            self.image = self.image.convert_alpha()
            self.rect = self.image.get_rect()
            self.rect.center = self.pos #if you forget this line the sprite sit in the topleft corner
            self.time = 0.0
            
        def update(self, seconds):
            self.time += seconds
            if self.time > self.lifetime:
                self.kill() 
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
    
    class RedFragment(Fragment):
        """explodes outward from (killed) sprite"""
        def __init__(self,pos, stay = False):
            self.groups = allgroup, fragmentgroup, gravitygroup
            Fragment.__init__(self,pos)
            self.stay = stay # if the Fragment stay still or moves
            self.color = (random.randint(25,255),0,0) # red            
            self.pos[0] = pos[0]
            self.pos[1] = pos[1]
            if self.stay:
                self.dx = 0
                self.dy = 0
            else:
                self.dx = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
                self.dy = random.randint(-self.fragmentmaxspeed,self.fragmentmaxspeed)
            self.lifetime = 0.5 + random.random() # max 1.5 seconds
            self.init2() # continue with generic Fragment class
            self.mass = 48.0
            
    class Wound(Fragment):
        """yellow impact wound that shows the exact location of the hit"""
        def __init__(self, pos, greenmin = 200, greenmax = 255 ):
            self.greenmin = greenmin
            self.greenmax = greenmax
            self.color = ( random.randint(200,255), random.randint(self.greenmin,self.greenmax), random.randint(0,50))
            self.groups = allgroup
            Fragment.__init__(self, pos, 7) # layer
            self.pos[0] = pos[0]
            self.pos[1] = pos[1]
            self.lifetime = 1 + random.random()*2 # max 3 seconds
            Fragment.init2(self)
            self.dx = 0
            self.dy = 0
        
        def update(self,time):
            self.color = ( random.randint(200,255), random.randint(self.greenmin,self.greenmax), random.randint(0,50))
            pygame.draw.circle(self.image, self.color, (5,5), self.fragmentradius)
            self.image = self.image.convert_alpha()
            Fragment.update(self, time)
            
    class Smoke(Fragment):
        """black exhaust indicating that the sprite is moved.
           Exhaust direction is inverse of players movement direction"""
        def __init__(self, pos, dx, dy, colmin=1, colmax=50):
           self.color = ( random.randint(colmin,colmax), random.randint(colmin,colmax), random.randint(colmin,colmax) )
           self.groups = allgroup
           Fragment.__init__(self,pos, 3) # give startpos and layer 
           self.pos[0] = pos[0]
           self.pos[1] = pos[1]
           self.lifetime = 0.25 + random.random()*0.5 # 
           Fragment.init2(self)
           self.smokespeed = 120.0 # how fast the smoke leaves the Bird
           self.smokearc = .3 # 0 = thin smoke stream, 1 = 180 Degrees
           arc = self.smokespeed * self.smokearc
           self.dx = dx * self.smokespeed + random.random()*2*arc - arc
           self.dy = dy * self.smokespeed + random.random()*2*arc - arc
           
    class Bullet(GameObject):
        """a bullet flying in the direction of the boss sprite's facing.
           If shooting direction should be independent of boss sprite's facing,
           angle can be given as argument"""
        def __init__(self, boss, myangle = None, max_abberation = 5.5):
            self.boss = boss
            if myangle is None:
                myangle = self.boss.angle 
            self.abberation = random.uniform(-max_abberation,max_abberation) # no shot is perfect
            myangle += self.abberation # spoil the perfect shot
            dx =  -math.sin(myangle*GRAD) 
            dy =  -math.cos(myangle*GRAD)
            self.color = self.boss.bulletcolor
            self.groups = allgroup, bulletgroup, gravitygroup,projectilegroup
            self.lifetime = self.boss.bulletlifetime 
            self.image = pygame.Surface((4,20))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.rect(self.image, self.color, (0,0,4,20) )
            pygame.draw.rect(self.image, (10,0,0), (0,0,4,4)) # point
            self.image = self.image.convert_alpha()
            self.image0 = self.image.copy()
            self.rect = self.image.get_rect()
            self.pos = self.boss.pos[:]
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
            #GameObject.__init__(self, self.boss.pos, layer= 4, area=screenrect, areastop = False, areabounce = False, angle=self.boss.angle, speedmax = 500, friction = 1.0, lifetime = 1.2)
            GameObject.__init__(self, layer= 4, area=screenrect, areastop = True, areabounce = True, angle=myangle + self.abberation, speedmax = 400, friction = 1.0, lifetime = self.lifetime)
            self.dx = dx * self.speedmax  
            self.dy = dy * self.speedmax  
            self.damage = 1
            self.hitpoints = 3
            self.mass = 50
            self.radius = self.rect.width / 2.0
            
        def update(self, seconds):
            self.angle = GameObject.rotate_toward_moving(self)
            #GameObject.speedcheck(self)
            GameObject.update(self, seconds)
            
            
    class Rocket(GameObject):
        """a rocket flying and steering toward a target
           type 1 is a haevy damage, slow-flying, sliding rocket
           type 2 is a light damage, fast-flying, direct seeking rocket"""
        def __init__(self, boss, targetnr, type=1, launchangle = 0):
            self.boss = boss
            if type == 1:   # --------heavy sliding missile ----------
                self.size = 6
                self.color = self.boss.rocket1color
                self.damage = 15
                self.mass = 40
                self.hitpoints = 5 # more hitpoints because less hard to avoid
                self.lifetime = 38 # longer lifetime because less hard to avoid
                self.speed = 50
                self.starttime = 0.9 # missles are launched but are not homing in this time
                rocketfriction = 0.989            
            elif type==2:            # ---------light direct seeking missile ----------------
                self.size = 4
                self.color = self.boss.rocket2color
                self.damage = 5
                self.hitpoints = 2
                self.mass = 10
                self.lifetime = 14
                self.speed = 155 # pixel per second ?
                self.starttime = 0.9 # missles are launched but are not homing in this time
                rocketfriction = 0.99
            self.boss = boss
            self.targetnr = targetnr
            self.target = GameObject.gameobjects[targetnr] # player ?
            self.type = type
            #---------- image --------------
            self.image = pygame.Surface((self.size,20))
            self.image.set_colorkey((0,0,0)) # black transparent
            pygame.draw.rect(self.image, self.color, (0,0,self.size,20) )
            pygame.draw.rect(self.image, (10,0,0), (0,0,self.size,4)) # point
            self.image = self.image.convert_alpha()
            self.image0 = self.image.copy()
            self.rect = self.image.get_rect()
            self.angle = launchangle + self.boss.angle
            self.groups = allgroup, rocketgroup, projectilegroup
            #GameObject.__init__(self, self.boss.pos[:], layer= 8, area=screenrect, areastop = False, areabounce = False, angle=self.angle, speedmax = 800, friction = rocketfriction, lifetime = self.lifetime)
            self.pos = self.boss.pos[:]
            GameObject.__init__(self, layer= 8, area=screenrect, areastop = True, areabounce = False, angle=self.angle, speedmax = 800, friction = rocketfriction, lifetime = self.lifetime)
            self.ddx = -math.sin(self.angle*GRAD) 
            self.ddy = -math.cos(self.angle*GRAD) 
            self.dx = self.ddx * self.speed
            self.dy = self.ddy * self.speed
            self.rotspeed = 5 # grad per second
            self.radius = self.rect.width / 2.0
            self.frags = 5
            self.smokechance = 3 # probability of 1:5 for each frame to launch Smoke
            
        def kill(self):
            #for _ in range(self.frags):
            #    RedFragment(self.pos)
            Wound(self.pos, 0,50)
            GameObject.kill(self)
            
        def update(self, seconds):
            
            self.alivetime += seconds
            if self.alivetime > self.lifetime:
                self.kill() 
            if self.hitpoints < 1:
                self.kill()
            if GameObject.gameobjects[self.targetnr] is None:
                self.kill()
            if self.alivetime < self.starttime:
                #--------- rotate into direction of movement ------------
                self.angle = math.atan2(-self.dx, -self.dy)/math.pi*180.0 
            else:
                #-------- rotate toward target
                if self.target is not None:
                    ix = self.target.pos[0] - self.pos[0]
                    iy = self.target.pos[1] - self.pos[1]
                    self.angle = radians_to_degrees(math.atan2(iy,- ix))+90
                self.ddx = -math.sin(self.angle*GRAD)  
                self.ddy = -math.cos(self.angle*GRAD) 
            if self.type == 1: # sliding
                self.dx += self.ddx  #* self.speed
                self.dy += self.ddy  #* self.speed
                if random.randint(1,self.smokechance) ==1:
                    Smoke(self.pos, -self.ddx * 2, -self.ddy * 2)
            elif self.type == 2: #seeking
                self.dx = self.ddx * self.speed
                self.dy = self.ddy * self.speed
                if random.randint(1, self.smokechance) ==1:
                    Smoke(self.pos, -self.ddx, -self.ddy, 25, 75)
            #----------- both ------------
            GameObject.speedcheck(self)
            oldrect = self.rect.center
            self.image = pygame.transform.rotozoom(self.image0,self.angle,1.0) 
            self.rect = self.image.get_rect()   
            self.rect.center = oldrect
            self.pos[0] += self.dx * seconds
            self.pos[1] += self.dy * seconds
            self.rect.centerx = round(self.pos[0],0)
            self.rect.centery = round(self.pos[1],0)
    #------------- end of classes -----------------
    # ----------------- background artwork -------------  
    background = pygame.Surface((screen.get_width(), screen.get_height()))
    background.fill((255,255,255))     # fill white
    background.blit(write("red player:  w,a,s,d,q,e fire: SPACE", (130,130,130)),(50,110))
    background.blit(write("blue player: Numpad 8,4,5,6,7,9 fire: 0", (130,130,130)),(50,140))
    background.blit(write("icrease # of rockets by not firing", (130,130,130)), (50, 170))
    background.blit(write("ESC=quit, m=new monster o=more overtime", (130,130,130)), (50,200))
    background = background.convert()  # jpg can not have transparency
    screen.blit(background, (0,0))     # blit background on screen (overwriting all)
    #-----------------define sprite groups------------------------
    playergroup = pygame.sprite.Group() 
    monstergroup = pygame.sprite.Group()
    bulletgroup = pygame.sprite.Group()
    fragmentgroup = pygame.sprite.Group()
    rocketgroup = pygame.sprite.Group()
    gravitygroup = pygame.sprite.Group()
    projectilegroup = pygame.sprite.Group()
    # only the allgroup draws the sprite, so i use LayeredUpdates() instead Group()
    allgroup = pygame.sprite.LayeredUpdates() # more sophisticated, can draw sprites in layers 

    #-------------loading files from data subdirectory -------------------------------
    try:
        Player.image.append(pygame.image.load(os.path.join(folder,"player_red2.png")).convert_alpha())   #0
        Player.image.append(pygame.image.load(os.path.join(folder,"player_blue2.png")).convert_alpha())  #1
        Monster.image.append(pygame.image.load(os.path.join(folder, "xmonster_s.png")).convert_alpha())        #0
        Monster.image.append(pygame.image.load(os.path.join(folder, "xmonster_fire_s.png")).convert_alpha())   #1
        Monster.image.append(pygame.image.load(os.path.join(folder, "xmonster_left_s.png")).convert_alpha())   #2
        Monster.image.append(pygame.image.load(os.path.join(folder, "xmonster_right_s.png")).convert_alpha())  #3

        # ------- load sound -------
        crysound = pygame.mixer.Sound(os.path.join(folder,'claws.ogg'))  #load sound
        warpsound = pygame.mixer.Sound(os.path.join(folder,'wormhole.ogg'))
        bombsound = pygame.mixer.Sound(os.path.join(folder,'bomb.ogg'))
        lasersound = pygame.mixer.Sound(os.path.join(folder,'shoot.ogg'))
        hitsound = pygame.mixer.Sound(os.path.join(folder,'beep.ogg'))
        impactsound = pygame.mixer.Sound(os.path.join(folder,'explode.ogg'))
    except:
        raise UserWarning, "Sadly i could not loading all graphic or sound files from %s" % folder
    
    # ------------- before the main loop ----------------------
    screentext1 = Text("first line", (255,0,255),(0,0))
    screentext2 = Text("second line",(0,0,0),(0,25))
    screentext3 = Text("third line", (255,0,0),(0,50))
    screentext4 = Text("fourth line", (0,0,255),(0,75))
    
    clock = pygame.time.Clock()        # create pygame clock object 
    mainloop = True                    # if False, game ends
    FPS = 60                           # desired max. framerate in frames per second. 
    player1 = Player() # game object number 0
    player2 = Player() # game object number 1
    warpsound.play()   # play new monster sound
    Monster() # create a single Monster
    overtime = 15 # time in seconds to admire the explosion of player before the game ends
    gameOver = False # if True, game still continues until overtime runs out
    gametime = 360 # how long to play (seconds)
    playtime = 0  # how long the game was played
    gravity = False # gravity can be toggled
    
        
    while mainloop:
        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame
        playtime += seconds # keep track of playtime
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
                elif event.key == pygame.K_g:
                    gravity = not gravity # toggle gravity
                elif event.key == pygame.K_m:
                    warpsound.play()
                    Monster() # create a new monster
                    Player.duel = False
                elif event.key == pygame.K_o:
                    if gameOver:
                        overtime += 10 # more overtime to watch monsters fight each other
        #---- new Monster ?
        #if random.randint(1,1000) == 1:
        #    Monster()
        pygame.display.set_caption("Monster duel. FPS: %.2f"   % clock.get_fps())
        if len(monstergroup) == 0:
            Player.duel = True
        else:
            Player.duel = False
            
        for player in playergroup:  # test if a player crash into enemy bullet ... vamipr health stealing effect !
            crashgroup = pygame.sprite.spritecollide(player, bulletgroup, False, pygame.sprite.collide_mask)
            for bullet in crashgroup: # this include friendly fire
                if bullet.boss.playernumber != player.playernumber: # only care for unfriendly fire
                    if bullet.boss.number < 2:
                        hitsound.play() # only "crysound" if player shot at monster
                    player.hitpoints -= bullet.damage
                    bullet.boss.bullets_hit += 1
                    bullet.boss.hitpoints += 1 # shooter steals at least one hitpoint from victim. Vampire effect
                    Wound(bullet.pos[:]) # pos, victim, move_with_victim = False
                    elastic_collision(bullet, player) # impact on player
                    bullet.kill()
            # player vs player
            crashgroup = pygame.sprite.spritecollide(player, playergroup, False, pygame.sprite.collide_circle)
            for crashplayer in crashgroup:
                if player.number > crashplayer.number:
                    elastic_collision(crashplayer, player) # impact on player
                    # player.hitpoints -= crashplayer.damage
                # no damage ?
        
            # test if player crash into enemy rocket
            crashgroup = pygame.sprite.spritecollide(player, rocketgroup, False, pygame.sprite.collide_mask)
            for rocket in crashgroup:
                #if projectile.physicnumber > crashbody.physicnumber: #avoid checking twice
                if rocket.boss.playernumber != player.playernumber: # avoid friendly fire
                   impactsound.play()
                   player.hitpoints -= rocket.damage
                   rocket.boss.rockets_hit += 1
                   Wound(rocket.pos[:])
                   elastic_collision(rocket, player)
                   rocket.kill()
        
        for projectile in projectilegroup:
            # rocket vs rocket vs bullet vs bullet
            crashgroup = pygame.sprite.spritecollide(projectile, projectilegroup, False )
            for crashthing in crashgroup:
                if projectile.number > crashthing.number:
                    if crashthing.boss.playernumber != projectile.boss.playernumber:
                        projectile.hitpoints -= crashthing.damage
                        crashthing.hitpoints -= projectile.damage
                        elastic_collision(projectile, crashthing)
            
        if gravity: # ---- gravity check ---
            for thing in gravitygroup:  # gravity suck down bullets, players, monsters
                thing.dy += 2.81 # pixel per second square earth: 9.81 m/s
        # ------game Over ? -------------
        #if  (playtime > gametime) and not gameOver:
        #    gameOver = True # do those things once when the game ends
        if GameObject.gameobjects[0] is None and GameObject.gameobjects[1] is None:
            gameOver = True # both players death
            screentext1.newmsg("Game Over. Time played: %.2f seconds" % playtime)
            screentext2.newmsg("both players killed")
        elif GameObject.gameobjects[0] is None or GameObject.gameobjects[1] is None:
            if player1.hitpoints > 0:
                textname = "Red Player"
                textcolor = (255,0,0)
            else:
                textname = "Blue Player"
                textcolor = (0,0,255)
            if len(monstergroup) == 0: 
                gameOver = True # one player dead, all monsters dead
                screentext2.newmsg("%s, you win!" % textname, textcolor)
            elif len(monstergroup) == 1:
                screentext2.newmsg("%s, fight the monster !" % textname, textcolor)
            else:
                screentext2.newmsg("%s, fight the monsters !" % textname, textcolor)
        elif len(monstergroup) == 0:
            Player.duel = True # both players alive, no monsters alive
            screentext2.newmsg("Duel mode. Both Players, fight each other!", (255,0,255))
        elif len(monstergroup) == 1:
            Player.duel = False
            screentext2.newmsg("Both players, fight the monster", (255,0,255))
        elif len(monstergroup) > 1:
            Player.duel = False
            screentext2.newmsg("Both players, fight the monsters", (255,0,255))
        if gameOver: # overtime to watch score, explosion etc
            overtime -= seconds
            screentext1.newmsg("Game over. Overtime: %.2f" % overtime)
            if overtime < 0:
                mainloop = False
        else: # not yet gameOver
            screentext1.newmsg("Time left: %.2f" % (gametime - playtime),(255,0,255))
            #if player1.bullets_fired > 0:
            screentext3.newmsg("Red player: bullets: %i hit: %i quota: %.2f%% rockets: %i hits: %i quota: %.2f%%"
                               % (player1.bullets_fired, player1.bullets_hit, player1.bullets_hit *100.0 / max(1, player1.bullets_fired),
                               player1.rockets_fired, player1.rockets_hit, player1.rockets_hit * 100.0 / max(1,player1.rockets_fired))
                               ,(255,0,0))
            screentext4.newmsg("Blue player: bullets: %i hit: %i quota: %.2f%% rockets: %i hits: %i quota: %.2f%%"
                               % (player2.bullets_fired, player2.bullets_hit, player2.bullets_hit *100.0 / max(1, player2.bullets_fired),
                               player2.rockets_fired, player2.rockets_hit, player2.rockets_hit * 100.0 / max(1,player2.rockets_fired))
                               ,(0,0,255))
        # ----------- clear, draw , update, flip -----------------  
        allgroup.clear(screen, background)
        allgroup.update(seconds)
        allgroup.draw(screen)           
        pygame.display.flip()         

if __name__ == "__main__":
    game()

########NEW FILE########
__FILENAME__ = 020_shooting_from_tank
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
020_shooting_from_tank.py
demo of tank game with rotating turrets
url: http://thepythongamebook.com/en:part2:pygame:step020
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

demo of 2 tanks shooting bullets at the end of it's cannon
and shooting tracers at the end of it's bow Machine Gun
and from the turret-machine gun (co-axial with main gun)
"""
 
import pygame
import random
import math
GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad
 
class Config(object):
    """ a class to hold all game constants that may be modded by the user"""
    fullscreen = False
    width = 640
    height = 480
    fps = 100
    xtiles = 30 # how many grid tiles for x axis
    ytiles = 20 # how many grid tiles for y axis
 
class Text(pygame.sprite.Sprite):
    """ a helper class to write text on the screen """
    number = 0 
    book = {}
    def __init__(self, pos, msg):
        self.number = Text.number # get a unique number
        Text.number += 1 # prepare number for next Textsprite
        Text.book[self.number] = self # store myself into the book
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.pos = [0.0,0.0]
        self.pos[0] = pos[0]
        self.pos[1] = pos[1]
        self.msg = msg
        self.changemsg(msg)
 
    def update(self, seconds):        
        pass
 
    def changemsg(self,msg):
        self.msg = msg
        self.image = write(self.msg)
        self.rect = self.image.get_rect()
        self.rect.centerx = self.pos[0]
        self.rect.centery = self.pos[1]
 
class Bullet(pygame.sprite.Sprite):
    """ a big projectile fired by the tank's main cannon"""
    side = 7 # small side of bullet rectangle
    vel = 180 # velocity
    mass = 50
    maxlifetime = 10.0 # seconds
    def __init__(self, boss):
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.boss = boss
        self.dx = 0
        self.dy = 0
        self.angle = 0
        self.lifetime = 0.0
        self.color = self.boss.color
        self.calculate_heading() # !!!!!!!!!!!!!!!!!!!
        self.dx += self.boss.dx
        self.dy += self.boss.dy # add boss movement
        self.pos = self.boss.pos[:] # copy (!!!) of boss position 
        #self.pos = self.boss.pos   # uncomment this linefor fun effect
        self.calculate_origin()
        self.update() # to avoid ghost sprite in upper left corner, 
                      # force position calculation.
 
    def calculate_heading(self):
        """ drawing the bullet and rotating it according to it's launcher"""
        self.radius = Bullet.side # for collision detection
        self.angle += self.boss.turretAngle
        self.mass = Bullet.mass
        self.vel = Bullet.vel
        image = pygame.Surface((Bullet.side * 2, Bullet.side)) # rect 2 x 1
        image.fill((128,128,128)) # fill grey
        pygame.draw.rect(image, self.color, (0,0,int(Bullet.side * 1.5), Bullet.side)) # rectangle 1.5 length
        pygame.draw.circle(image, self.color, (int(self.side *1.5) ,self.side/2), self.side/2) #  circle
        image.set_colorkey((128,128,128)) # grey transparent
        self.image0 = image.convert_alpha()
        self.image = pygame.transform.rotate(self.image0, self.angle)
        self.rect = self.image.get_rect()
        self.dx = math.cos(degrees_to_radians(self.boss.turretAngle)) * self.vel
        self.dy = math.sin(degrees_to_radians(-self.boss.turretAngle)) * self.vel
 
    def calculate_origin(self):
        # - spawn bullet at end of turret barrel instead tank center -
        # cannon is around Tank.side long, calculatet from Tank center
        # later subtracted 20 pixel from this distance
        # so that bullet spawns closer to tank muzzle
        self.pos[0] +=  math.cos(degrees_to_radians(self.boss.turretAngle)) * (Tank.side-20)
        self.pos[1] +=  math.sin(degrees_to_radians(-self.boss.turretAngle)) * (Tank.side-20)
 
    def update(self, seconds=0.0):
        # ---- kill if too old ---
        self.lifetime += seconds
        if self.lifetime > Bullet.maxlifetime:
            self.kill()
        # ------ calculate movement --------
        self.pos[0] += self.dx * seconds
        self.pos[1] += self.dy * seconds
        # ----- kill if out of screen
        if self.pos[0] < 0:
            self.kill()
        elif self.pos[0] > Config.width:
            self.kill()
        if self.pos[1] < 0:
            self.kill()
        elif self.pos[1] > Config.height:
            self.kill()
        #------- move -------
        self.rect.centerx = round(self.pos[0],0)
        self.rect.centery = round(self.pos[1],0)
 
class Tracer(Bullet):
    """Tracer is nearly the same as Bullet, but smaller
       and with another origin (bow MG rect instead cannon.
       Tracer inherits all methods of Bullet, but i overwrite
       calculate_heading and calculate_origin"""
    side = 15 # long side of bullet rectangle
    vel = 200 # velocity
    mass = 10
    color = (200,0,100)
    maxlifetime = 10.0 # seconds
    def __init__(self, boss, turret=False):
        self.turret = turret
        Bullet.__init__(self,boss ) # this line is important 
 
    def calculate_heading(self):
        """overwriting the method because there are some differences 
           between a tracer and a main gun bullet"""
        self.radius = Tracer.side # for collision detection
        self.angle = 0
        self.angle += self.boss.tankAngle
        if self.turret:
            self.angle = self.boss.turretAngle
        self.mass = Tracer.mass
        self.vel = Tracer.vel
        image = pygame.Surface((Tracer.side, Tracer.side / 4)) # a line 
        image.fill(self.boss.color) # fill yellow ? 
        pygame.draw.rect(image, (0,0,0), (Tracer.side * .75, 0, Tracer.side, Tracer.side / 4)) # red dot at front
        image.set_colorkey((128,128,128)) # grey transparent
        self.image0 = image.convert_alpha()
        self.image = pygame.transform.rotate(self.image0, self.angle)
        self.rect = self.image.get_rect()
        if self.turret:
            # turret mg
            self.dx = math.cos(degrees_to_radians(self.boss.turretAngle)) * self.vel
            self.dy = math.sin(degrees_to_radians(-self.boss.turretAngle)) * self.vel
        else:
            # bow mg
            self.dx = math.cos(degrees_to_radians(self.boss.tankAngle)) * self.vel
            self.dy = math.sin(degrees_to_radians(-self.boss.tankAngle)) * self.vel
 
    def calculate_origin(self):
        """overwriting because another point of origin is needed"""
        # - spawn bullet at end of machine gun muzzle (bow or turret)
        if self.turret:
            self.pos[0] +=  math.cos(degrees_to_radians(-90+self.boss.turretAngle)) * 15
            self.pos[1] +=  math.sin(degrees_to_radians(90-self.boss.turretAngle)) * 15
        else:
            self.pos[0] +=  math.cos(degrees_to_radians(30+self.boss.tankAngle)) * (Tank.side/2)
            self.pos[1] +=  math.sin(degrees_to_radians(-30-self.boss.tankAngle)) * (Tank.side/2)
 
class Tank(pygame.sprite.Sprite):
    """ A Tank, controlled by the Player with Keyboard commands.
    This Tank draw it's own Turret (including the main gun) 
    and it's bow rectangle (slit for Tracer Machine Gun"""
    side = 100 # side of the quadratic tank sprite
    recoiltime = 0.75 # how many seconds  the cannon is busy after firing one time
    mgrecoiltime = 0.2 # how many seconds the bow mg (machine gun) is idle
    turretTurnSpeed = 25 # turret
    tankTurnSpeed = 8 # tank
    movespeed = 25
    maxrotate = 360 # maximum amount of degree the turret is allowed to rotate
    book = {} # a book of tanks to store all tanks
    number = 0 # each tank gets his own number
    # keys for tank control, expand if you need more tanks
    #          player1,        player2    etc
    firekey = (pygame.K_k, pygame.K_DOWN)
    mgfirekey = (pygame.K_LCTRL, pygame.K_KP_ENTER)
    mg2firekey = (pygame.K_i, pygame.K_UP)
    turretLeftkey = (pygame.K_j, pygame.K_LEFT)
    turretRightkey = (pygame.K_l, pygame.K_RIGHT)
    forwardkey = (pygame.K_w, pygame.K_KP8)
    backwardkey = (pygame.K_s, pygame.K_KP5)
    tankLeftkey = (pygame.K_a, pygame.K_KP4)
    tankRightkey = (pygame.K_d, pygame.K_KP6)
    color = ((200,200,0), (0,0,200))
    msg = ["wasd LCTRL, ijkl", "Keypad: 4852, ENTER, cursor"]
 
    def __init__(self, startpos = (150,150), angle=0):
        self.number = Tank.number # now i have a unique tank number
        Tank.number += 1 # prepare number for next tank
        Tank.book[self.number] = self # store myself into the tank book
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.pos = [startpos[0], startpos[1]] # x,y
        self.dx = 0
        self.dy = 0
        self.ammo = 30 # main gun
        self.mgammo = 500 # machinge gun
        self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
        Text((Config.width/2, 30+20*self.number), self.msg) # create status line text sprite
        self.color = Tank.color[self.number]
        self.turretAngle = angle #turret facing
        self.tankAngle = angle # tank facing
        self.firekey = Tank.firekey[self.number] # main gun
        self.mgfirekey = Tank.mgfirekey[self.number] # bow mg
        self.mg2firekey = Tank.mg2firekey[self.number] # turret mg
        self.turretLeftkey = Tank.turretLeftkey[self.number] # turret
        self.turretRightkey = Tank.turretRightkey[self.number] # turret
        self.forwardkey = Tank.forwardkey[self.number] # move tank
        self.backwardkey = Tank.backwardkey[self.number] # reverse tank
        self.tankLeftkey = Tank.tankLeftkey[self.number] # rotate tank
        self.tankRightkey = Tank.tankRightkey[self.number] # rotat tank
        # painting facing north, have to rotate 90° later
        image = pygame.Surface((Tank.side,Tank.side)) # created on the fly
        image.fill((128,128,128)) # fill grey
        if self.side > 10:
             pygame.draw.rect(image, self.color, (5,5,self.side-10, self.side-10)) #tank body, margin 5
             pygame.draw.rect(image, (90,90,90), (0,0,self.side/6, self.side)) # track left
             pygame.draw.rect(image, (90,90,90), (self.side-self.side/6, 0, self.side,self.side)) # right track
             pygame.draw.rect(image, (255,0,0), (self.side/6+5 , 10, 10, 5)) # red bow rect left
             #pygame.draw.rect(image, (255,0,0), (self.side/2 - 5, 10, 10, 5)) # red bow rect middle
        pygame.draw.circle(image, (255,0,0), (self.side/2,self.side/2), self.side/3 , 2) # red circle for turret
        image = pygame.transform.rotate(image,-90) # rotate so to look east
        self.image0 = image.convert_alpha()
        self.image = image.convert_alpha()
        self.rect = self.image0.get_rect()
        #---------- turret ------------------
        self.firestatus = 0.0 # time left until cannon can fire again
        self.mgfirestatus = 0.0 # time until mg can fire again
        self.mg2firestatus = 0.0 # time until turret mg can fire again
        self.turndirection = 0    # for turret
        self.tankturndirection = 0
        self.movespeed = Tank.movespeed
        self.turretTurnSpeed = Tank.turretTurnSpeed
        self.tankTurnSpeed = Tank.tankTurnSpeed
        Turret(self) # create a Turret for this tank
 
    def update(self, seconds):
        # no need for seconds but the other sprites need it
        #-------- reloading, firestatus----------
        if self.firestatus > 0:
            self.firestatus -= seconds # cannon will soon be ready again
            if self.firestatus <0:
                self.firestatus = 0 #avoid negative numbers
        if self.mgfirestatus > 0:
            self.mgfirestatus -= seconds # bow mg will soon be ready again
            if self.mgfirestatus <0:
                self.mgfirestatus = 0 #avoid negative numbers
        if self.mg2firestatus > 0:
            self.mg2firestatus -= seconds # turret mg will soon be ready again
            if self.mg2firestatus <0:
                self.mg2firestatus = 0 #avoid negative numbers
 
        # ------------ keyboard --------------
        pressedkeys = pygame.key.get_pressed()
        # -------- turret manual rotate ----------
        self.turndirection = 0    #  left / right turret rotation
        if pressedkeys[self.turretLeftkey]:
            self.turndirection += 1
        if pressedkeys[self.turretRightkey]:
            self.turndirection -= 1
 
        #---------- tank rotation ---------
        self.tankturndirection = 0 # reset left/right rotation
        if pressedkeys[self.tankLeftkey]:
            self.tankturndirection += 1
        if pressedkeys[self.tankRightkey]:
            self.tankturndirection -= 1
 
        # ---------------- rotate tank ---------------
        self.tankAngle += self.tankturndirection * self.tankTurnSpeed * seconds # time-based turning of tank
        # angle etc from Tank (boss)
        oldcenter = self.rect.center
        oldrect = self.image.get_rect() # store current surface rect
        self.image  = pygame.transform.rotate(self.image0, self.tankAngle) 
        self.rect = self.image.get_rect()
        self.rect.center = oldcenter 
        # if tank is rotating, turret is also rotating with tank !
        # -------- turret autorotate ----------
        self.turretAngle += self.tankturndirection * self.tankTurnSpeed * seconds  + self.turndirection * self.turretTurnSpeed * seconds # time-based turning
        # ---------- fire cannon -----------
        if (self.firestatus ==0) and (self.ammo > 0):
            if pressedkeys[self.firekey]:
                self.firestatus = Tank.recoiltime # seconds until tank can fire again
                Bullet(self)    
                self.ammo -= 1
                self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
                Text.book[self.number].changemsg(self.msg)
        # -------- fire bow mg ---------------
        if (self.mgfirestatus ==0) and (self.mgammo >0):
            if pressedkeys[self.mgfirekey]:
                self.mgfirestatus = Tank.mgrecoiltime
                Tracer(self, False) # turret mg = False
                self.mgammo -= 1
                self.msg = "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
                Text.book[self.number].changemsg(self.msg)
        # -------- fire turret mg ---------------
        if (self.mg2firestatus ==0) and (self.mgammo >0):
            if pressedkeys[self.mg2firekey]:
                self.mg2firestatus = Tank.mgrecoiltime # same recoiltime for both mg's
                Tracer(self, True) # turret mg = True
                self.mgammo -= 1
                self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
                Text.book[self.number].changemsg(self.msg)
        # ---------- movement ------------
        self.dx = 0
        self.dy = 0
        self.forward = 0 # movement calculator
        if pressedkeys[self.forwardkey]:
            self.forward += 1
        if pressedkeys[self.backwardkey]:
            self.forward -= 1
        # if both are pressed togehter, self.forward becomes 0
        if self.forward == 1:
            self.dx =  math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
            self.dy =  -math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
        if self.forward == -1:
            self.dx =  -math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
            self.dy =  math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
        # ------------- check border collision ---------------------
        self.pos[0] += self.dx * seconds
        self.pos[1] += self.dy * seconds
        if self.pos[1] + self.side/2 >= Config.height:
            self.pos[1] = Config.height - self.side/2
            self.dy = 0 # crash into border
        elif self.pos[1] -self.side/2 <= 0:
            self.pos[1] = 0 + self.side/2
            self.dy = 0
        # ---------- paint sprite at correct position ---------
        self.rect.centerx = round(self.pos[0], 0) #x
        self.rect.centery = round(self.pos[1], 0) #y    
 
class Turret(pygame.sprite.Sprite):
    """turret on top of tank"""
    def __init__(self, boss):
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.boss = boss
        self.side = self.boss.side        
        self.images = {} # how much recoil after shooting, reverse order of apperance
        self.images[0] = self.draw_cannon(0)  # idle position
        self.images[1] = self.draw_cannon(1)
        self.images[2] = self.draw_cannon(2)
        self.images[3] = self.draw_cannon(3)
        self.images[4] = self.draw_cannon(4)
        self.images[5] = self.draw_cannon(5)
        self.images[6] = self.draw_cannon(6)
        self.images[7] = self.draw_cannon(7)
        self.images[8] = self.draw_cannon(8)  # position of max recoil
        self.images[9] = self.draw_cannon(4)
        self.images[10] = self.draw_cannon(0) # idle position
 
    def update(self, seconds):        
        # painting the correct image of cannon
        if self.boss.firestatus > 0:
            self.image = self.images[int(self.boss.firestatus / (Tank.recoiltime / 10.0))]
        else:
            self.image = self.images[0]
        # --------- rotating -------------
        # angle etc from Tank (boss)
        oldrect = self.image.get_rect() # store current surface rect
        self.image  = pygame.transform.rotate(self.image, self.boss.turretAngle) 
        self.rect = self.image.get_rect()
        # ---------- move with boss ---------
        self.rect = self.image.get_rect()
        self.rect.center = self.boss.rect.center
 
    def draw_cannon(self, offset):
         # painting facing right, offset is the recoil
         image = pygame.Surface((self.boss.side * 2,self.boss.side * 2)) # created on the fly
         image.fill((128,128,128)) # fill grey
         pygame.draw.circle(image, (255,0,0), (self.side,self.side), 22, 0) # red circle
         pygame.draw.circle(image, (0,255,0), (self.side,self.side), 18, 0) # green circle
         pygame.draw.rect(image, (255,0,0), (self.side-10, self.side + 10, 15,2)) # turret mg rectangle
         pygame.draw.rect(image, (0,255,0), (self.side-20 - offset,self.side - 5, self.side - offset,10)) # green cannon
         pygame.draw.rect(image, (255,0,0), (self.side-20 - offset,self.side - 5, self.side - offset,10),1) # red rect 
         image.set_colorkey((128,128,128))
         return image
# ---------------- End of classes --------------------
#------------ defs ------------------
def radians_to_degrees(radians):
    return (radians / math.pi) * 180.0
 
def degrees_to_radians(degrees):
    return degrees * (math.pi / 180.0)
 
def write(msg="pygame is cool"):
    """helper function for the Text sprite"""
    myfont = pygame.font.SysFont("None", 28)
    mytext = myfont.render(msg, True, (255,0,0))
    mytext = mytext.convert_alpha()
    return mytext        
 
def pressedKeysString():
    """returns the pressed keys (for the player1 tank) to be displayd in the status line"""
    pressedkeys = pygame.key.get_pressed()
    line = ""
    if pressedkeys[pygame.K_a]:
        line += "a "
    if pressedkeys[pygame.K_d]:
        line += "d "
    if pressedkeys[pygame.K_w]:
        line += "w "
    if pressedkeys[pygame.K_s]:
        line += "s "
    if pressedkeys[pygame.K_LCTRL]:
        line += "LCTRL"
    return line
 
def main():
    """the game itself"""
    pygame.init()
    screen=pygame.display.set_mode((Config.width,Config.height)) 
    background = pygame.Surface((screen.get_size()))
    background.fill((128,128,255)) # fill grey light blue:(128,128,255) 
    # paint a grid of white lines
    for x in range(0,Config.width,Config.width/Config.xtiles): #start, stop, step
        pygame.draw.line(background, (255,255,255), (x,0), (x,Config.height))
    for y in range(0,Config.height,Config.height/Config.ytiles): #start, stop, step
        pygame.draw.line(background, (255,255,255), (0,y), (Config.width,y))
    # paint upper rectangle to have background for text
    pygame.draw.rect(background, (128,128,255), (0,0,Config.width, 70))
 
    background = background.convert()
    screen.blit(background, (0,0)) # delete all
    clock = pygame.time.Clock()    # create pygame clock object
    FPS = Config.fps               # desired max. framerate 
    playtime = 0
 
    tankgroup = pygame.sprite.Group()
    bulletgroup = pygame.sprite.Group()
    allgroup = pygame.sprite.LayeredUpdates()
 
    Tank._layer = 4   # base layer
    Bullet._layer = 7 # to prove that Bullet is in top-layer
    Tracer._layer = 5 # above Tank, but below Turret
    Turret._layer = 6 # above Tank & Tracer
    Text._layer = 3   # below Tank
 
    #assign default groups to each sprite class
    Tank.groups = tankgroup, allgroup
    Turret.groups = allgroup
    Bullet.groups = bulletgroup, allgroup
    Text.groups = allgroup
    player1 = Tank((150,250), 90) # create  first tank, looking north
    player2 = Tank((450,250), -90) # create second tank, looking south
    status3 = Text((Config.width/2, 10), "Tank Demo. Press ESC to quit")
    mainloop = True           
    while mainloop:
        milliseconds = clock.tick(Config.fps)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame (float)
        playtime += seconds
 
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                # pygame window closed by user
                mainloop = False 
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # exit game
 
        pygame.display.set_caption("FPS: %.2f keys: %s" % ( clock.get_fps(), pressedKeysString()))
        #screen.blit(background, (0,0)) # delete all
        allgroup.clear(screen, background) # funny effect if you outcomment this line
        allgroup.update(seconds)
        allgroup.draw(screen)
        pygame.display.flip() # flip the screen 30 times a second
    return 0
 
if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = 021_targeting
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
021_targeting.py
demo of tank game with rotating turrets
url: http://thepythongamebook.com/en:part2:pygame:step021
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

the player2 tank rotate it's turrent always to player1 tank
you can "teleport" player1 tank by mouse click

special thanks to Jonathan Persson for motivation to write this
"""


import pygame
import random
import math
GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad

class Config(object):
    """ a class to hold all game constants that may be modded by the user"""
    fullscreen = False
    width = 640
    height = 480
    fps = 100
    xtiles = 30 # how many grid tiles for x axis
    ytiles = 20 # how many grid tiles for y axis
    title = "Esc: quit"

class Text(pygame.sprite.Sprite):
    """ a helper class to write text on the screen """
    number = 0 
    book = {}
    def __init__(self, pos, msg):
        self.number = Text.number # get a unique number
        Text.number += 1 # prepare number for next Textsprite
        Text.book[self.number] = self # store myself into the book
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.pos = [0.0,0.0]
        self.pos[0] = pos[0]
        self.pos[1] = pos[1]
        self.msg = msg
        self.changemsg(msg)
        
    def update(self, seconds):        
        pass
        
    def changemsg(self,msg):
        self.msg = msg
        self.image = write(self.msg)
        self.rect = self.image.get_rect()
        self.rect.centerx = self.pos[0]
        self.rect.centery = self.pos[1]
        
class Bullet(pygame.sprite.Sprite):
    """ a big projectile fired by the tank's main cannon"""
    side = 7 # small side of bullet rectangle
    vel = 180 # velocity
    mass = 50
    maxlifetime = 10.0 # seconds
    def __init__(self, boss):
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.boss = boss
        self.dx = 0
        self.dy = 0
        self.angle = 0
        self.lifetime = 0.0
        self.color = self.boss.color
        self.calculate_heading() # !!!!!!!!!!!!!!!!!!!
        self.dx += self.boss.dx
        self.dy += self.boss.dy # add boss movement
        self.pos = self.boss.pos[:] # copy (!!!) of boss position 
        #self.pos = self.boss.pos   # uncomment this linefor fun effect
        self.calculate_origin()
        self.update() # to avoid ghost sprite in upper left corner, 
                      # force position calculation.
                      
    def calculate_heading(self):
        """ drawing the bullet and rotating it according to it's launcher"""
        self.radius = Bullet.side # for collision detection
        self.angle += self.boss.turretAngle
        self.mass = Bullet.mass
        self.vel = Bullet.vel
        image = pygame.Surface((Bullet.side * 2, Bullet.side)) # rect 2 x 1
        image.fill((128,128,128)) # fill grey
        pygame.draw.rect(image, self.color, (0,0,int(Bullet.side * 1.5), Bullet.side)) # rectangle 1.5 length
        pygame.draw.circle(image, self.color, (int(self.side *1.5) ,self.side/2), self.side/2) #  circle
        image.set_colorkey((128,128,128)) # grey transparent
        self.image0 = image.convert_alpha()
        self.image = pygame.transform.rotate(self.image0, self.angle)
        self.rect = self.image.get_rect()
        self.dx = math.cos(degrees_to_radians(self.boss.turretAngle)) * self.vel
        self.dy = math.sin(degrees_to_radians(-self.boss.turretAngle)) * self.vel
        
    def calculate_origin(self):
        # - spawn bullet at end of turret barrel instead tank center -
        # cannon is around Tank.side long, calculatet from Tank center
        # later subtracted 20 pixel from this distance
        # so that bullet spawns closer to tank muzzle
        self.pos[0] +=  math.cos(degrees_to_radians(self.boss.turretAngle)) * (Tank.side-20)
        self.pos[1] +=  math.sin(degrees_to_radians(-self.boss.turretAngle)) * (Tank.side-20)
 
    def update(self, seconds=0.0):
        # ---- kill if too old ---
        self.lifetime += seconds
        if self.lifetime > Bullet.maxlifetime:
            self.kill()
        # ------ calculate movement --------
        self.pos[0] += self.dx * seconds
        self.pos[1] += self.dy * seconds
        # ----- kill if out of screen
        if self.pos[0] < 0:
            self.kill()
        elif self.pos[0] > Config.width:
            self.kill()
        if self.pos[1] < 0:
            self.kill()
        elif self.pos[1] > Config.height:
            self.kill()
        #------- move -------
        self.rect.centerx = round(self.pos[0],0)
        self.rect.centery = round(self.pos[1],0)
        
class Tracer(Bullet):
    """Tracer is nearly the same as Bullet, but smaller
       and with another origin (bow MG rect instead cannon.
       Tracer inherits all methods of Bullet, but i overwrite
       calculate_heading and calculate_origin"""
    side = 15 # long side of bullet rectangle
    vel = 200 # velocity
    mass = 10
    color = (200,0,100)
    maxlifetime = 10.0 # seconds
    def __init__(self, boss, turret=False):
        self.turret = turret
        Bullet.__init__(self,boss ) # this line is important 
        
    def calculate_heading(self):
        """overwriting the method because there are some differences 
           between a tracer and a main gun bullet"""
        self.radius = Tracer.side # for collision detection
        self.angle = 0
        self.angle += self.boss.tankAngle
        if self.turret:
            self.angle = self.boss.turretAngle
        self.mass = Tracer.mass
        self.vel = Tracer.vel
        image = pygame.Surface((Tracer.side, Tracer.side / 4)) # a line 
        image.fill(self.boss.color) # fill yellow ? 
        pygame.draw.rect(image, (0,0,0), (Tracer.side * .75, 0, Tracer.side, Tracer.side / 4)) # red dot at front
        image.set_colorkey((128,128,128)) # grey transparent
        self.image0 = image.convert_alpha()
        self.image = pygame.transform.rotate(self.image0, self.angle)
        self.rect = self.image.get_rect()
        if self.turret:
            # turret mg
            self.dx = math.cos(degrees_to_radians(self.boss.turretAngle)) * self.vel
            self.dy = math.sin(degrees_to_radians(-self.boss.turretAngle)) * self.vel
        else:
            # bow mg
            self.dx = math.cos(degrees_to_radians(self.boss.tankAngle)) * self.vel
            self.dy = math.sin(degrees_to_radians(-self.boss.tankAngle)) * self.vel

    def calculate_origin(self):
        """overwriting because another point of origin is needed"""
        # - spawn bullet at end of machine gun muzzle (bow or turret)
        if self.turret:
            self.pos[0] +=  math.cos(degrees_to_radians(-90+self.boss.turretAngle)) * 15
            self.pos[1] +=  math.sin(degrees_to_radians(90-self.boss.turretAngle)) * 15
        else:
            self.pos[0] +=  math.cos(degrees_to_radians(30+self.boss.tankAngle)) * (Tank.side/2)
            self.pos[1] +=  math.sin(degrees_to_radians(-30-self.boss.tankAngle)) * (Tank.side/2)
        
    
class Tank(pygame.sprite.Sprite):
    """ A Tank, controlled by the Player with Keyboard commands.
    This Tank draw it's own Turret (including the main gun) 
    and it's bow rectangle (slit for Tracer Machine Gun"""
    side = 100 # side of the quadratic tank sprite
    recoiltime = 0.75 # how many seconds  the cannon is busy after firing one time
    mgrecoiltime = 0.2 # how many seconds the bow mg (machine gun) is idle
    turretTurnSpeed = 50 # turret
    tankTurnSpeed = 80 # tank
    movespeed = 80
    #maxrotate = 360 # maximum amount of degree the turret is allowed to rotate
    book = {} # a book of tanks to store all tanks
    number = 0 # each tank gets his own number
    # keys for tank control, expand if you need more tanks
    #          player1,        player2    etc
    firekey = (pygame.K_k, pygame.K_DOWN)
    mgfirekey = (pygame.K_LCTRL, pygame.K_KP_ENTER)
    mg2firekey = (pygame.K_i, pygame.K_UP)
    turretLeftkey = (pygame.K_j, pygame.K_LEFT)
    turretRightkey = (pygame.K_l, pygame.K_RIGHT)
    forwardkey = (pygame.K_w, pygame.K_KP8)
    backwardkey = (pygame.K_s, pygame.K_KP5)
    tankLeftkey = (pygame.K_a, pygame.K_KP4)
    tankRightkey = (pygame.K_d, pygame.K_KP6)
    color = ((200,200,0), (0,0,200))
    #msg = ["wasd LCTRL, ijkl", "Keypad: 4852, ENTER, cursor"]
          
    def __init__(self, startpos = (150,150), angle=0):
        self.number = Tank.number # now i have a unique tank number
        Tank.number += 1 # prepare number for next tank
        Tank.book[self.number] = self # store myself into the tank book
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.pos = [startpos[0], startpos[1]] # x,y
        self.dx = 0
        self.dy = 0
        self.ammo = 30 # main gun
        self.mgammo = 500 # machinge gun
        self.color = Tank.color[self.number]
        self.turretAngle = angle #turret facing
        self.tankAngle = angle # tank facing
        self.msg =  "tank%i: x:%i y:%i facing: turret:%i tank:%i"  % (self.number, self.pos[0], self.pos[1], self.turretAngle, self.tankAngle )
        Text((Config.width/2, 30+20*self.number), self.msg) # create status line text sprite
        self.firekey = Tank.firekey[self.number] # main gun
        self.mgfirekey = Tank.mgfirekey[self.number] # bow mg
        self.mg2firekey = Tank.mg2firekey[self.number] # turret mg
        self.turretLeftkey = Tank.turretLeftkey[self.number] # turret
        self.turretRightkey = Tank.turretRightkey[self.number] # turret
        self.forwardkey = Tank.forwardkey[self.number] # move tank
        self.backwardkey = Tank.backwardkey[self.number] # reverse tank
        self.tankLeftkey = Tank.tankLeftkey[self.number] # rotate tank
        self.tankRightkey = Tank.tankRightkey[self.number] # rotat tank
        # painting facing north, have to rotate 90° later
        image = pygame.Surface((Tank.side,Tank.side)) # created on the fly
        image.fill((128,128,128)) # fill grey
        if self.side > 10:
             pygame.draw.rect(image, self.color, (5,5,self.side-10, self.side-10)) #tank body, margin 5
             pygame.draw.rect(image, (90,90,90), (0,0,self.side/6, self.side)) # track left
             pygame.draw.rect(image, (90,90,90), (self.side-self.side/6, 0, self.side,self.side)) # right track
             pygame.draw.rect(image, (255,0,0), (self.side/6+5 , 10, 10, 5)) # red bow rect left
             #pygame.draw.rect(image, (255,0,0), (self.side/2 - 5, 10, 10, 5)) # red bow rect middle
        pygame.draw.circle(image, (255,0,0), (self.side/2,self.side/2), self.side/3 , 2) # red circle for turret
        image = pygame.transform.rotate(image,-90) # rotate so to look east
        self.image0 = image.convert_alpha()
        self.image = image.convert_alpha()
        self.rect = self.image0.get_rect()
        #---------- turret ------------------
        self.firestatus = 0.0 # time left until cannon can fire again
        self.mgfirestatus = 0.0 # time until mg can fire again
        self.mg2firestatus = 0.0 # time until turret mg can fire again
        self.turndirection = 0    # for turret
        self.tankturndirection = 0
        self.movespeed = Tank.movespeed
        self.turretTurnSpeed = Tank.turretTurnSpeed
        self.tankTurnSpeed = Tank.tankTurnSpeed
        Turret(self) # create a Turret for this tank
        
    def update(self, seconds):
        # no need for seconds but the other sprites need it
        #-------- reloading, firestatus----------
        if self.firestatus > 0:
            self.firestatus -= seconds # cannon will soon be ready again
            if self.firestatus <0:
                self.firestatus = 0 #avoid negative numbers
        if self.mgfirestatus > 0:
            self.mgfirestatus -= seconds # bow mg will soon be ready again
            if self.mgfirestatus <0:
                self.mgfirestatus = 0 #avoid negative numbers
        if self.mg2firestatus > 0:
            self.mg2firestatus -= seconds # turret mg will soon be ready again
            if self.mg2firestatus <0:
                self.mg2firestatus = 0 #avoid negative numbers
        
        # ------------ keyboard --------------
        pressedkeys = pygame.key.get_pressed()
        # -------- turret manual rotate ----------
        self.turndirection = 0    #  left / right turret rotation
        if self.number == 1:   # only for tank2
            self.aim_at_player()       # default aim at player0
        else:
            if pressedkeys[self.turretLeftkey]:
                self.turndirection += 1
            if pressedkeys[self.turretRightkey]:
                self.turndirection -= 1
           
        #---------- tank rotation ---------
        self.tankturndirection = 0 # reset left/right rotation
        if pressedkeys[self.tankLeftkey]:
            self.tankturndirection += 1
        if pressedkeys[self.tankRightkey]:
            self.tankturndirection -= 1
        
        # ---------------- rotate tank ---------------
        self.tankAngle += self.tankturndirection * self.tankTurnSpeed * seconds # time-based turning of tank
        # angle etc from Tank (boss)
        oldcenter = self.rect.center
        oldrect = self.image.get_rect() # store current surface rect
        self.image  = pygame.transform.rotate(self.image0, self.tankAngle) 
        self.rect = self.image.get_rect()
        self.rect.center = oldcenter 
        # if tank is rotating, turret is also rotating with tank !
        # -------- turret autorotate ----------
        self.turretAngle += self.tankturndirection * self.tankTurnSpeed * seconds  + self.turndirection * self.turretTurnSpeed * seconds # time-based turning
        # ---------- fire cannon -----------
        if (self.firestatus ==0) and (self.ammo > 0):
            if pressedkeys[self.firekey]:
                self.firestatus = Tank.recoiltime # seconds until tank can fire again
                Bullet(self)    
                self.ammo -= 1
                #self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
                #Text.book[self.number].changemsg(self.msg)
        # -------- fire bow mg ---------------
        if (self.mgfirestatus ==0) and (self.mgammo >0):
            if pressedkeys[self.mgfirekey]:
                self.mgfirestatus = Tank.mgrecoiltime
                Tracer(self, False) # turret mg = False
                self.mgammo -= 1
                #self.msg = "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
                #Text.book[self.number].changemsg(self.msg)
        # -------- fire turret mg ---------------
        if (self.mg2firestatus ==0) and (self.mgammo >0):
            if pressedkeys[self.mg2firekey]:
                self.mg2firestatus = Tank.mgrecoiltime # same recoiltime for both mg's
                Tracer(self, True) # turret mg = True
                self.mgammo -= 1
                #self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
                #Text.book[self.number].changemsg(self.msg)
        # ---------- movement ------------
        self.dx = 0
        self.dy = 0
        self.forward = 0 # movement calculator
        if pressedkeys[self.forwardkey]:
            self.forward += 1
        if pressedkeys[self.backwardkey]:
            self.forward -= 1
        # if both are pressed togehter, self.forward becomes 0
        if self.forward == 1:
            self.dx =  math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
            self.dy =  -math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
        if self.forward == -1:
            self.dx =  -math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
            self.dy =  math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
        # ------------- check border collision ---------------------
        self.pos[0] += self.dx * seconds
        self.pos[1] += self.dy * seconds
        if self.pos[1] + self.side/2 >= Config.height:
            self.pos[1] = Config.height - self.side/2
            self.dy = 0 # crash into border
        elif self.pos[1] -self.side/2 <= 0:
            self.pos[1] = 0 + self.side/2
            self.dy = 0
        
        self.rect.centerx = round(self.pos[0], 0) #x
        self.rect.centery = round(self.pos[1], 0) #y    
        self.msg =  "tank%i: x:%i y:%i facing: turret:%i tank:%i"  % (self.number, self.pos[0], self.pos[1], self.turretAngle, self.tankAngle )
        Text.book[self.number].changemsg(self.msg)
                    
    def aim_at_player(self, targetnumber=0):
        #print "my  pos: x:%.1f y:%.1f " % ( self.pos[0], self.pos[1])
        #print "his pos: x:%.1f y:%.1f " % ( Tank.book[0].pos[0], Tank.book[0].pos[1])  
        deltax = Tank.book[targetnumber].pos[0] - self.pos[0]
        deltay = Tank.book[targetnumber].pos[1] - self.pos[1]
        angle =   math.atan2(-deltax, -deltay)/math.pi*180.0    
        
        diff = (angle - self.turretAngle - 90) %360 #reset at 360
        if diff == 0:
            self.turndirection = 0
        elif diff > 180:
            self.turndirection = 1
        else:
            self.turndirection = -1
        return diff

class Turret(pygame.sprite.Sprite):
    """turret on top of tank"""
    def __init__(self, boss):
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.boss = boss
        self.side = self.boss.side
        
        self.images = {} # how much recoil after shooting, reverse order of apperance
        self.images[0] = self.draw_cannon(0)  # idle position
        self.images[1] = self.draw_cannon(1)
        self.images[2] = self.draw_cannon(2)
        self.images[3] = self.draw_cannon(3)
        self.images[4] = self.draw_cannon(4)
        self.images[5] = self.draw_cannon(5)
        self.images[6] = self.draw_cannon(6)
        self.images[7] = self.draw_cannon(7)
        self.images[8] = self.draw_cannon(8)  # position of max recoil
        self.images[9] = self.draw_cannon(4)
        self.images[10] = self.draw_cannon(0) # idle position
         
    def update(self, seconds):        
        # painting the correct image of cannon
        if self.boss.firestatus > 0:
            self.image = self.images[int(self.boss.firestatus / (Tank.recoiltime / 10.0))]
        else:
            self.image = self.images[0]
        # --------- rotating -------------
        # angle etc from Tank (boss)
        oldrect = self.image.get_rect() # store current surface rect
        self.image  = pygame.transform.rotate(self.image, self.boss.turretAngle) 
        self.rect = self.image.get_rect()
        # ---------- move with boss ---------
        self.rect = self.image.get_rect()
        self.rect.center = self.boss.rect.center

    
    def draw_cannon(self, offset):
         # painting facing right, offset is the recoil
         image = pygame.Surface((self.boss.side * 2,self.boss.side * 2)) # created on the fly
         image.fill((128,128,128)) # fill grey
         pygame.draw.circle(image, (255,0,0), (self.side,self.side), 22, 0) # red circle
         pygame.draw.circle(image, (0,255,0), (self.side,self.side), 18, 0) # green circle
         pygame.draw.rect(image, (255,0,0), (self.side-10, self.side + 10, 15,2)) # turret mg rectangle
         pygame.draw.rect(image, (0,255,0), (self.side-20 - offset,self.side - 5, self.side - offset,10)) # green cannon
         pygame.draw.rect(image, (255,0,0), (self.side-20 - offset,self.side - 5, self.side - offset,10),1) # red rect 
         image.set_colorkey((128,128,128))
         return image

# ---------------- End of classes --------------------

#------------ defs ------------------
def radians_to_degrees(radians):
    return (radians / math.pi) * 180.0

def degrees_to_radians(degrees):
    return degrees * (math.pi / 180.0)

def write(msg="pygame is cool"):
    """helper function for the Text sprite"""
    myfont = pygame.font.SysFont("None", 28)
    mytext = myfont.render(msg, True, (0,0,0))
    mytext = mytext.convert_alpha()
    return mytext        

def main():
    """the game itself"""
    pygame.init()
    screen=pygame.display.set_mode((Config.width,Config.height)) 
    #screenrect = screen.get_rect()
    background = pygame.Surface((screen.get_size()))
    #backgroundrect = background.get_rect()

    background.fill((128,128,255)) # fill grey light blue:(128,128,255) 
    # paint a grid of white lines
    for x in range(0,Config.width,Config.width/Config.xtiles): #start, stop, step
        pygame.draw.line(background, (255,255,255), (x,0), (x,Config.height))
    for y in range(0,Config.height,Config.height/Config.ytiles): #start, stop, step
        pygame.draw.line(background, (255,255,255), (0,y), (Config.width,y))
    # paint upper rectangle to have background for text
    pygame.draw.rect(background, (128,128,255), (0,0,Config.width, 70))
    
    background = background.convert()
    screen.blit(background, (0,0)) # delete all
    clock = pygame.time.Clock()    # create pygame clock object
    FPS = Config.fps               # desired max. framerate 
    playtime = 0
    
    tankgroup = pygame.sprite.Group()
    bulletgroup = pygame.sprite.Group()
    allgroup = pygame.sprite.LayeredUpdates()
    
    Tank._layer = 4   # base layer
    Bullet._layer = 7 # to prove that Bullet is in top-layer
    Tracer._layer = 5 # above Tank, but below Turret
    Turret._layer = 6 # above Tank & Tracer
    Text._layer = 3   # below Tank
 
    #assign default groups to each sprite class
    Tank.groups = tankgroup, allgroup
    Turret.groups = allgroup
    Bullet.groups = bulletgroup, allgroup
    Text.groups = allgroup
    player1 = Tank((150,250), 90) # create  first tank, looking north
    player2 = Tank((450,250), 90) # create second tank, looking south
     
    status3 = Text((Config.width/2, 10), "difference angle (from blue to yellow): %i" % Tank.book[1].aim_at_player())
    mainloop = True           
    while mainloop:
        status3.changemsg( "difference angle (from blue to yellow): %i" % Tank.book[1].aim_at_player() )
        milliseconds = clock.tick(Config.fps)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame (float)
        playtime += seconds
            
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                # pygame window closed by user
                mainloop = False 
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # exit game
            # teleport player1 tank if left mousebutton is pressed
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if pygame.mouse.get_pressed()[0]:
                    #left mousebutton was pressed
                    player1.pos[0]=pygame.mouse.get_pos()[0]
                    player1.pos[1]=pygame.mouse.get_pos()[1]
        
        pygame.display.set_caption("%s FPS: %.2f playtime: %.1f " % ( Config.title,clock.get_fps(), playtime))
        #screen.blit(background, (0,0)) # delete all
        allgroup.clear(screen, background) # funny effect if you outcomment this line
        allgroup.update(seconds)
        allgroup.draw(screen)
        pygame.display.flip() # flip the screen 30 times a second
    return 0

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = 022_minimap
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
022_minimap.py
demo of tank game with rotating turrets and minimap
url: http://thepythongamebook.com/en:part2:pygame:step022
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

the minimap displays tanks, traces and bullets even for elements
currently not visible on the playfield.
"""

import pygame
import random
import math
GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad

class Config(object):
    """ a class to hold all game constants that may be modded by the user"""
    fullscreen = False
    width = 640
    height = 480
    bigmapwidth = 1024
    bigmapheight = 800
    fps = 60
    xtiles = 15 # how many grid tiles for x axis
    ytiles = 15 # how many grid tiles for y axis
    title = "Esc: quit"
    scrollstepx = 3 # how many pixels to scroll when pressing cursor key
    scrollstepy = 3 # how many pixels to scroll when pressing cursor key
    cornerpoint = [0,0] # left upper edge of visible screen rect inside bigmap
    radarmapwidth = 200
    radarmapheight = 150

class Text(pygame.sprite.Sprite):
    """ a helper class to write text on the screen """
    number = 0 
    book = {}
    def __init__(self, pos, msg):
        self.number = Text.number # get a unique number
        Text.number += 1 # prepare number for next Textsprite
        Text.book[self.number] = self # store myself into the book
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.pos = [0.0,0.0]
        self.pos[0] = pos[0]
        self.pos[1] = pos[1]
        self.msg = msg
        self.changemsg(msg)
        
    def update(self, seconds):        
        pass
        
    def changemsg(self,msg):
        self.msg = msg
        self.image = write(self.msg)
        self.rect = self.image.get_rect()
        self.rect.centerx = self.pos[0] 
        self.rect.centery = self.pos[1]
        
class Bullet(pygame.sprite.Sprite):
    """ a big projectile fired by the tank's main cannon"""
    side = 7 # small side of bullet rectangle
    vel = 180 # velocity
    mass = 50
    maxlifetime = 10.0 # seconds
    book = {}
    number = 0
    def __init__(self, boss):
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.boss = boss
        self.number = Bullet.number 
        Bullet.number += 1
        Bullet.book[self.number] = self # add myself into the bulletbook
        self.dx = 0
        self.dy = 0
        self.angle = 0
        self.tracer = False # the tracer class will have self.tracer = True
        self.lifetime = 0.0
        self.color = self.boss.color
        self.calculate_heading() # !!!!!!!!!!!!!!!!!!!
        self.dx += self.boss.dx
        self.dy += self.boss.dy # add boss movement
        self.pos = self.boss.pos[:] # copy (!!!) of boss position 
        #self.pos = self.boss.pos   # uncomment this linefor fun effect
        self.calculate_origin()
        self.update() # to avoid ghost sprite in upper left corner,  force position calculation.
                      
    def calculate_heading(self):
        """ drawing the bullet and rotating it according to it's launcher"""
        self.radius = Bullet.side # for collision detection
        self.angle += self.boss.turretAngle
        self.mass = Bullet.mass
        self.vel = Bullet.vel
        image = pygame.Surface((Bullet.side * 2, Bullet.side)) # rect 2 x 1
        image.fill((128,128,128)) # fill grey
        pygame.draw.rect(image, self.color, (0,0,int(Bullet.side * 1.5), Bullet.side)) # rectangle 1.5 length
        pygame.draw.circle(image, self.color, (int(self.side *1.5) ,self.side/2), self.side/2) #  circle
        pygame.draw.circle(image, (0,0,0), (int(Bullet.side * 1.5) , Bullet.side / 2) , 2) # point circle
        image.set_colorkey((128,128,128)) # grey transparent
        self.image0 = image.convert_alpha()
        self.image = pygame.transform.rotate(self.image0, self.angle)
        self.rect = self.image.get_rect()
        self.dx = math.cos(degrees_to_radians(self.boss.turretAngle)) * self.vel
        self.dy = math.sin(degrees_to_radians(-self.boss.turretAngle)) * self.vel
        
    def calculate_origin(self):
        # - spawn bullet at end of turret barrel instead tank center -
        # cannon is around Tank.side long, calculatet from Tank center
        # later subtracted 20 pixel from this distance
        # so that bullet spawns closer to tank muzzle
        self.pos[0] +=  math.cos(degrees_to_radians(self.boss.turretAngle)) * (Tank.side-20)
        self.pos[1] +=  math.sin(degrees_to_radians(-self.boss.turretAngle)) * (Tank.side-20)
 
    def kill(self):
        # overwriting this function to kill myself out of the bullet book correctly
        del Bullet.book[self.number] # delete myself out of the book
        pygame.sprite.Sprite.kill(self) # call the kill function
 
    def update(self, seconds=0.0):
        # ---- kill if too old ---
        self.lifetime += seconds
        if self.lifetime > Bullet.maxlifetime:
            self.kill()
        # ------ calculate movement --------
        self.pos[0] += self.dx * seconds
        self.pos[1] += self.dy * seconds
        # ----- kill if out of screen
        if self.pos[0] < 0:
            self.kill()
        elif self.pos[0] > Config.bigmapwidth:
            self.kill()
        if self.pos[1] < 0:
            self.kill()
        elif self.pos[1] > Config.bigmapheight:
            self.kill()
        #------- move -------
        self.rect.centerx = round(self.pos[0] - Config.cornerpoint[0],0)
        self.rect.centery = round(self.pos[1] - Config.cornerpoint[1],0)
        
class Tracer(Bullet):
    """Tracer is nearly the same as Bullet, but smaller
       and with another origin (bow MG rect instead cannon.
       Tracer inherits all methods of Bullet, but i overwrite
       calculate_heading and calculate_origin"""
    side = 15 # long side of bullet rectangle
    vel = 200 # velocity
    mass = 10
    color = (200,0,100)
    maxlifetime = 10.0 # seconds
    def __init__(self, boss, turret=False):
        self.turret = turret
        Bullet.__init__(self,boss ) # this line is important 
        self.tracer = True
        
    def calculate_heading(self):
        """overwriting the method because there are some differences 
           between a tracer and a main gun bullet"""
        self.radius = Tracer.side # for collision detection
        self.angle = 0
        self.angle += self.boss.tankAngle
        if self.turret:
            self.angle = self.boss.turretAngle
        self.mass = Tracer.mass
        self.vel = Tracer.vel
        image = pygame.Surface((Tracer.side, Tracer.side / 4)) # a line 
        image.fill(self.boss.color) # fill yellow ? 
        pygame.draw.rect(image, (0,0,0), (Tracer.side * .75, 0, Tracer.side, Tracer.side / 4)) # red dot at front
        image.set_colorkey((128,128,128)) # grey transparent
        self.image0 = image.convert_alpha()
        self.image = pygame.transform.rotate(self.image0, self.angle)
        self.rect = self.image.get_rect()
        if self.turret:
            # turret mg
            self.dx = math.cos(degrees_to_radians(self.boss.turretAngle)) * self.vel
            self.dy = math.sin(degrees_to_radians(-self.boss.turretAngle)) * self.vel
        else:
            # bow mg
            self.dx = math.cos(degrees_to_radians(self.boss.tankAngle)) * self.vel
            self.dy = math.sin(degrees_to_radians(-self.boss.tankAngle)) * self.vel

    def calculate_origin(self):
        """overwriting because another point of origin is needed"""
        # - spawn bullet at end of machine gun muzzle (bow or turret)
        if self.turret:
            self.pos[0] +=  math.cos(degrees_to_radians(-90+self.boss.turretAngle)) * 15
            self.pos[1] +=  math.sin(degrees_to_radians(90-self.boss.turretAngle)) * 15
        else:
            self.pos[0] +=  math.cos(degrees_to_radians(30+self.boss.tankAngle)) * (Tank.side/2)
            self.pos[1] +=  math.sin(degrees_to_radians(-30-self.boss.tankAngle)) * (Tank.side/2)
        
class Radarmap(pygame.sprite.Sprite):
    """a classic radarmap of the bigmap, 
    to be displayed alsways in the upper right corner 
    of the screen. With colored dots for the tanks
    and a rect for the visible screen area"""
    def __init__(self):
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.image = pygame.Surface((Config.radarmapwidth, Config.radarmapheight))
        self.paintmap() # self image's color is not defined, therfore it remains black
        self.rect = self.image.get_rect()
        self.rect.topleft = (Config.width - Config.radarmapwidth, 0) # topleft is a pygame variable
        self.factorx = Config.radarmapwidth  * 1.0 / Config.bigmapwidth # 1.0 to force decimapl point calculation 
        self.factory = Config.radarmapheight *1.0 / Config.bigmapheight
        
    def paintmap(self):
        self.image.fill((0,0,0))
        pygame.draw.rect(self.image, (150,0,0), (0,0, Config.radarmapwidth, Config.radarmapheight),1)    
    
    def update(self, seconds):
        self.paintmap() # redraw black map # outcomment for funny painting effect
        # draw a withe rect to show the visible area of the bigmap
        pygame.draw.rect(self.image, (255,255,255), (round(Config.cornerpoint[0] * self.factorx,0),
                                                     round(Config.cornerpoint[1] * self.factory,0),
                                                     round(Config.width * self.factorx, 0),
                                                     round(Config.height * self.factory, 0)),1)
        for tanknumber in Tank.book: # tank are circles with radius 4
            pos = Tank.book[tanknumber].pos
            color = Tank.book[tanknumber].color
            pygame.draw.circle(self.image,color, (int(pos[0] * self.factorx),
                                                  int(pos[1] * self.factory)), 4 )
        for bulletnumber in Bullet.book:
            if Bullet.book[bulletnumber].tracer:
                dotlength = 2 # bullets are rectangles with sidelength 4 (bullets) or 2 (tracer)
            else:
                dotlength = 4 # rect with length 1 is not visible
            pos = Bullet.book[bulletnumber].pos
            color = Bullet.book[bulletnumber].color
            pygame.draw.rect(self.image, color,(int(pos[0] * self.factorx),
                                                int(pos[1] * self.factory),
                                                dotlength, dotlength))
    
class Tank(pygame.sprite.Sprite):
    """ A Tank, controlled by the Player with Keyboard commands.
    This Tank draw it's own Turret (including the main gun) 
    and it's bow rectangle (slit for Tracer Machine Gun"""
    side = 100 # side of the quadratic tank sprite
    recoiltime = 0.75 # how many seconds  the cannon is busy after firing one time
    mgrecoiltime = 0.2 # how many seconds the bow mg (machine gun) is idle
    turretTurnSpeed = 50 # turret
    tankTurnSpeed = 80 # tank
    movespeed = 80
    #maxrotate = 360 # maximum amount of degree the turret is allowed to rotate
    book = {} # a book of tanks to store all tanks
    number = 0 # each tank gets his own number
    # keys for tank control, expand if you need more tanks
    #          player1,        player2    etc
    firekey = (pygame.K_k, pygame.K_KP0)
    mgfirekey = (pygame.K_LCTRL, pygame.K_KP_ENTER)
    mg2firekey = (pygame.K_i, pygame.K_KP_PLUS)
    turretLeftkey = (pygame.K_j, pygame.K_KP7)
    turretRightkey = (pygame.K_l, pygame.K_KP9)
    forwardkey = (pygame.K_w, pygame.K_KP8)
    backwardkey = (pygame.K_s, pygame.K_KP5)
    tankLeftkey = (pygame.K_a, pygame.K_KP4)
    tankRightkey = (pygame.K_d, pygame.K_KP6)
    color = ((200,200,0), (100,100,255))
    #msg = ["wasd LCTRL, ijkl", "Keypad: 4852, ENTER, cursor"]
          
    def __init__(self, startpos = (150,150), angle=0):
        self.number = Tank.number # now i have a unique tank number
        Tank.number += 1 # prepare number for next tank
        Tank.book[self.number] = self # store myself into the tank book
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.pos = [startpos[0], startpos[1]] # x,y
        self.dx = 0
        self.dy = 0
        self.ammo = 30 # main gun
        self.mgammo = 500 # machinge gun
        self.color = Tank.color[self.number]
        self.turretAngle = angle #turret facing
        self.tankAngle = angle # tank facing
        self.msg =  "tank%i: x:%i y:%i facing: turret:%i tank:%i"  % (self.number, self.pos[0], self.pos[1], self.turretAngle, self.tankAngle )
        #Text((Config.width/2, 30+20*self.number), self.msg) # create status line text sprite
        self.firekey = Tank.firekey[self.number] # main gun
        self.mgfirekey = Tank.mgfirekey[self.number] # bow mg
        self.mg2firekey = Tank.mg2firekey[self.number] # turret mg
        self.turretLeftkey = Tank.turretLeftkey[self.number] # turret
        self.turretRightkey = Tank.turretRightkey[self.number] # turret
        self.forwardkey = Tank.forwardkey[self.number] # move tank
        self.backwardkey = Tank.backwardkey[self.number] # reverse tank
        self.tankLeftkey = Tank.tankLeftkey[self.number] # rotate tank
        self.tankRightkey = Tank.tankRightkey[self.number] # rotat tank
        # painting facing north, have to rotate 90° later
        image = pygame.Surface((Tank.side,Tank.side)) # created on the fly
        image.fill((128,128,128)) # fill grey
        if self.side > 10:
             pygame.draw.rect(image, self.color, (5,5,self.side-10, self.side-10)) #tank body, margin 5
             pygame.draw.rect(image, (90,90,90), (0,0,self.side/6, self.side)) # track left
             pygame.draw.rect(image, (90,90,90), (self.side-self.side/6, 0, self.side,self.side)) # right track
             pygame.draw.rect(image, (255,0,0), (self.side/6+5 , 10, 10, 5)) # red bow rect left
             #pygame.draw.rect(image, (255,0,0), (self.side/2 - 5, 10, 10, 5)) # red bow rect middle
        pygame.draw.circle(image, (255,0,0), (self.side/2,self.side/2), self.side/3 , 2) # red circle for turret
        image = pygame.transform.rotate(image,-90) # rotate so to look east
        self.image0 = image.convert_alpha()
        self.image = image.convert_alpha()
        self.rect = self.image0.get_rect()
        #---------- turret ------------------
        self.firestatus = 0.0 # time left until cannon can fire again
        self.mgfirestatus = 0.0 # time until mg can fire again
        self.mg2firestatus = 0.0 # time until turret mg can fire again
        self.turndirection = 0    # for turret
        self.tankturndirection = 0
        self.movespeed = Tank.movespeed
        self.turretTurnSpeed = Tank.turretTurnSpeed
        self.tankTurnSpeed = Tank.tankTurnSpeed
        Turret(self) # create a Turret for this tank
        
    def update(self, seconds):  # no need for seconds but the other sprites need it
        #-------- reloading, firestatus----------
        if self.firestatus > 0:
            self.firestatus -= seconds # cannon will soon be ready again
            if self.firestatus <0:
                self.firestatus = 0 #avoid negative numbers
        if self.mgfirestatus > 0:
            self.mgfirestatus -= seconds # bow mg will soon be ready again
            if self.mgfirestatus <0:
                self.mgfirestatus = 0 #avoid negative numbers
        if self.mg2firestatus > 0:
            self.mg2firestatus -= seconds # turret mg will soon be ready again
            if self.mg2firestatus <0:
                self.mg2firestatus = 0 #avoid negative numbers
        
        # ------------ keyboard --------------
        pressedkeys = pygame.key.get_pressed()
        # -------- turret manual rotate ----------
        self.turndirection = 0    #  left / right turret rotation
        if self.number == 1:   # only for tank2
            self.aim_at_player()       # default aim at player0
        else:
            if pressedkeys[self.turretLeftkey]:
                self.turndirection += 1
            if pressedkeys[self.turretRightkey]:
                self.turndirection -= 1
           
        #---------- tank rotation ---------
        self.tankturndirection = 0 # reset left/right rotation
        if pressedkeys[self.tankLeftkey]:
            self.tankturndirection += 1
        if pressedkeys[self.tankRightkey]:
            self.tankturndirection -= 1
        
        # ---------------- rotate tank ---------------
        self.tankAngle += self.tankturndirection * self.tankTurnSpeed * seconds # time-based turning of tank
        # angle etc from Tank (boss)
        oldcenter = self.rect.center
        oldrect = self.image.get_rect() # store current surface rect
        self.image  = pygame.transform.rotate(self.image0, self.tankAngle) 
        self.rect = self.image.get_rect()
        self.rect.center = oldcenter 
        # if tank is rotating, turret is also rotating with tank !
        # -------- turret autorotate ----------
        self.turretAngle += self.tankturndirection * self.tankTurnSpeed * seconds  + self.turndirection * self.turretTurnSpeed * seconds # time-based turning
        # ---------- fire cannon -----------
        if (self.firestatus ==0) and (self.ammo > 0):
            if pressedkeys[self.firekey]:
                self.firestatus = Tank.recoiltime # seconds until tank can fire again
                Bullet(self)    
                self.ammo -= 1
                #self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
                #Text.book[self.number].changemsg(self.msg)
        # -------- fire bow mg ---------------
        if (self.mgfirestatus ==0) and (self.mgammo >0):
            if pressedkeys[self.mgfirekey]:
                self.mgfirestatus = Tank.mgrecoiltime
                Tracer(self, False) # turret mg = False
                self.mgammo -= 1
                #self.msg = "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
                #Text.book[self.number].changemsg(self.msg)
        # -------- fire turret mg ---------------
        if (self.mg2firestatus ==0) and (self.mgammo >0):
            if pressedkeys[self.mg2firekey]:
                self.mg2firestatus = Tank.mgrecoiltime # same recoiltime for both mg's
                Tracer(self, True) # turret mg = True
                self.mgammo -= 1
                #self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
                #Text.book[self.number].changemsg(self.msg)
        # ---------- movement ------------
        self.dx = 0
        self.dy = 0
        self.forward = 0 # movement calculator
        if pressedkeys[self.forwardkey]:
            self.forward += 1
        if pressedkeys[self.backwardkey]:
            self.forward -= 1
        # if both are pressed togehter, self.forward becomes 0
        if self.forward == 1:
            self.dx =  math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
            self.dy =  -math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
        if self.forward == -1:
            self.dx =  -math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
            self.dy =  math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
        # ------------- check border collision ---------------------
        self.pos[0] += self.dx * seconds
        self.pos[1] += self.dy * seconds
        if self.pos[0] + self.side/2 >= Config.bigmapwidth:
            self.pos[0] = Config.bigmawidth - self.side/2
            self.dx = 0 # crash into border
        elif self.pos[0] -self.side/2 <= 0:
            self.pos[0] = 0 + self.side/2
            self.dx = 0
        if self.pos[1] + self.side/2 >= Config.bigmapheight:
            self.pos[1] = Config.bigmapheight - self.side/2
            self.dy = 0 # crash into border
        elif self.pos[1] -self.side/2 <= 0:
            self.pos[1] = 0 + self.side/2
            self.dy = 0    
        
        self.rect.centerx = round(self.pos[0] - Config.cornerpoint[0], 0) #x
        self.rect.centery = round(self.pos[1] - Config.cornerpoint[1], 0) #y    
        #self.msg =  "tank%i: x:%i y:%i facing: turret:%i tank:%i"  % (self.number, self.pos[0], self.pos[1], self.turretAngle, self.tankAngle )
                    
    def aim_at_player(self, targetnumber=0):
        deltax = Tank.book[targetnumber].pos[0] - self.pos[0]
        deltay = Tank.book[targetnumber].pos[1] - self.pos[1]
        angle =   math.atan2(-deltax, -deltay)/math.pi*180.0    
        
        diff = (angle - self.turretAngle - 90) %360 #reset at 360
        diff -= 180
        # to avoid a jittering canon introduce a tolerance range of 4 degrees
        if abs(diff) < 2:
            self.turndirection = 0
        elif diff > 0:
            self.turndirection = 1
        else:
            self.turndirection = -1
        # return diff
     
     
class Turret(pygame.sprite.Sprite):
    """turret on top of tank"""
    def __init__(self, boss):
        pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
        self.boss = boss
        self.side = self.boss.side
        self.images = {} # how much recoil after shooting, reverse order of apperance
        self.images[0] = self.draw_cannon(0)  # idle position
        self.images[1] = self.draw_cannon(1)
        self.images[2] = self.draw_cannon(2)
        self.images[3] = self.draw_cannon(3)
        self.images[4] = self.draw_cannon(4)
        self.images[5] = self.draw_cannon(5)
        self.images[6] = self.draw_cannon(6)
        self.images[7] = self.draw_cannon(7)
        self.images[8] = self.draw_cannon(8)  # position of max recoil
        self.images[9] = self.draw_cannon(4)
        self.images[10] = self.draw_cannon(0) # idle position
         
    def update(self, seconds):        
        # painting the correct image of cannon
        if self.boss.firestatus > 0:
            self.image = self.images[int(self.boss.firestatus / (Tank.recoiltime / 10.0))]
        else:
            self.image = self.images[0]
        # --------- rotating -------------
        # angle etc from Tank (boss)
        oldrect = self.image.get_rect() # store current surface rect
        self.image  = pygame.transform.rotate(self.image, self.boss.turretAngle) 
        self.rect = self.image.get_rect()
        # ---------- move with boss ---------
        self.rect = self.image.get_rect()
        self.rect.center = self.boss.rect.center
    
    def draw_cannon(self, offset):
         # painting facing right, offset is the recoil
         image = pygame.Surface((self.boss.side * 2,self.boss.side * 2)) # created on the fly
         image.fill((128,128,128)) # fill grey
         pygame.draw.circle(image, (255,0,0), (self.side,self.side), 22, 0) # red circle
         pygame.draw.circle(image, (0,255,0), (self.side,self.side), 18, 0) # green circle
         pygame.draw.rect(image, (255,0,0), (self.side-10, self.side + 10, 15,2)) # turret mg rectangle
         pygame.draw.rect(image, (0,255,0), (self.side-20 - offset,self.side - 5, self.side - offset,10)) # green cannon
         pygame.draw.rect(image, (255,0,0), (self.side-20 - offset,self.side - 5, self.side - offset,10),1) # red rect 
         image.set_colorkey((128,128,128))
         return image
# ---------------- End of classes --------------------

#------------ defs ------------------
def radians_to_degrees(radians):
    return (radians / math.pi) * 180.0

def degrees_to_radians(degrees):
    return degrees * (math.pi / 180.0)

def write(msg="pygame is cool"):
    """helper function for the Text sprite"""
    myfont = pygame.font.SysFont("None", 28)
    mytext = myfont.render(msg, True, (255,255,255))
    mytext = mytext.convert_alpha()
    return mytext        

def main():
    """the game itself"""
    pygame.init()
    screen=pygame.display.set_mode((Config.width,Config.height)) 
    # note that "map" is an pygame function and can not be used as a name for a variable
    bigmap = pygame.Surface((Config.bigmapwidth, Config.bigmapheight))
    # ----------------- create bigmap -------------------
    bigmap.fill((128,128,128)) # fill grey 
    # paint a grid of dark lines
    for x in range(0,Config.bigmapwidth,Config.bigmapwidth/Config.xtiles): #start, stop, step
        pygame.draw.line(bigmap, (64,64,64), (x,0), (x,Config.bigmapheight))
    for y in range(0,Config.bigmapheight,Config.bigmapheight/Config.ytiles): #start, stop, step
        pygame.draw.line(bigmap, (64,64,64), (0,y), (Config.bigmapwidth,y))
    pygame.draw.rect(bigmap, (255,0,0), (0,0,Config.bigmapwidth, Config.bigmapheight), 25) # red bigmap edge
    # paint thin red cross in the middle of the map
    pygame.draw.line(bigmap, (200,0,0), (Config.bigmapwidth /2, 0),( Config.bigmapwidth / 2, Config.bigmapheight),1)
    pygame.draw.line(bigmap, (200,0,0), (0, Config.bigmapheight/2),( Config.bigmapwidth , Config.bigmapheight/2),1)
    bigmap = bigmap.convert()
    # ------- background is a subsurface of bigmap ----------
    background = pygame.Surface((screen.get_size()))
    backgroundrect = background.get_rect()
    background = bigmap.subsurface((Config.cornerpoint[0],
                                    Config.cornerpoint[1],
                                    Config.width,
                                    Config.height)) # take snapshot of bigmap
    # -----------------------------------
    background = background.convert()
    screen.blit(background, (0,0)) # delete all
    clock = pygame.time.Clock()    # create pygame clock object
    FPS = Config.fps               # desired max. framerate 
    playtime = 0
    
    tankgroup = pygame.sprite.Group()
    bulletgroup = pygame.sprite.Group()
    allgroup = pygame.sprite.LayeredUpdates()
    
    Tank._layer = 4   # base layer
    Bullet._layer = 7 # to prove that Bullet is in top-layer
    Tracer._layer = 5 # above Tank, but below Turret
    Turret._layer = 6 # above Tank & Tracer
    Text._layer = 3   # below Tank
    Radarmap._layer = 3  # below Tank # better 9 ?
 
    #assign default groups to each sprite class
    Tank.groups = tankgroup, allgroup
    Turret.groups = allgroup 
    Bullet.groups = bulletgroup, allgroup
    Text.groups = allgroup # text does not move with map !
    Radarmap.groups = allgroup # radar does not move with map
    
    player1 = Tank((150,250), 90) # create  first tank, looking north
    player2 = Tank((450,250), 90) # create second tank, looking south
    Radarmap() # there is only one radarmap, so no variable assigned to it
     
    status3 = Text((155, 25), "cursor keys to scroll the map,")
    status3 = Text((155, 45), "tanks: keypad, wasd, ijkl, lctrl")
    mainloop = True           
    while mainloop:
        milliseconds = clock.tick(Config.fps)  # milliseconds passed since last frame
        seconds = milliseconds / 1000.0 # seconds passed since last frame (float)
        playtime += seconds
            
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                # pygame window closed by user
                mainloop = False 
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # exit game
            # teleport player1 tank if left mousebutton is pressed
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if pygame.mouse.get_pressed()[0]:
                    #left mousebutton was pressed
                    player1.pos[0]=pygame.mouse.get_pos()[0] + Config.cornerpoint[0]
                    player1.pos[1]=pygame.mouse.get_pos()[1] + Config.cornerpoint[1]
                    
        # -------- scroll the big map ----------
        scrollx = 0
        scrolly = 0
        pressedkeys = pygame.key.get_pressed()
        # --- handle Cursor keys to scroll map ----
        if pressedkeys[pygame.K_LEFT]:
             scrollx -= Config.scrollstepx
        if pressedkeys[pygame.K_RIGHT]:
             scrollx += Config.scrollstepx
        if pressedkeys[pygame.K_UP]:
             scrolly -= Config.scrollstepy
        if pressedkeys[pygame.K_DOWN]:
             scrolly += Config.scrollstepy
        # -------- scroll the visible part of the map ------
        Config.cornerpoint[0] += scrollx
        Config.cornerpoint[1] += scrolly
        #--------- do not scroll out of bigmap edge -----
        if Config.cornerpoint[0] < 0:
            Config.cornerpoint[0] = 0
            scrollx = 0
        elif Config.cornerpoint[0] > Config.bigmapwidth - Config.width:
            Config.cornerpoint[0] = Config.bigmapwidth - Config.width
            scrollx = 0
        if Config.cornerpoint[1] < 0:
            Config.cornerpoint[1] = 0
            scrolly = 0
        elif Config.cornerpoint[1] > Config.bigmapheight - Config.height:
            Config.cornerpoint[1] = Config.bigmapheight - Config.height
            scrolly = 0
        
        pygame.display.set_caption("%s FPS: %.2f playtime: %.1f " % ( Config.title,clock.get_fps(), playtime))
        #screen.blit(background, (0,0)) # delete all
        if scrollx == 0 and scrolly == 0:    # only necessery if there was no scrolling
            allgroup.clear(screen, background) # funny effect if you outcomment this line
        else:
            background = bigmap.subsurface((Config.cornerpoint[0],
                                            Config.cornerpoint[1],
                                            Config.width,
                                            Config.height)) # take snapshot of bigmap
            screen.blit(background, (0,0))
        allgroup.update(seconds) 
        allgroup.draw(screen)
        pygame.display.flip() # flip the screen 30 times a second
    return 0

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = 023_dirtyLayeredSprites

########NEW FILE########
__FILENAME__ = 024_easyguimenu
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
easyguimenu.py

demonstration of a game menu with easygui.
The gamemenu can change resolution, call a pygame 
program (the screensaver), return values (the playtime),
write and display a highscore list

Url:        http://ThePythonGameBook.com/en:part2:pygame:start
Author:     Horst JENS, horst.jens@spielend-programmieren.at
License:    GPL see http://www.gnu.org/licenses/gpl.html
Date:       2011/06
"""

import pygame
from lib import easygui 
from lib import screensaver 
import os
import os.path
import time
import webbrowser

def createGameDir(gamefolder):
    """create directory for logfile"""
    if os.path.isdir(gamefolder):
        print "directory already exist"
    else:
        print "directory does not exist yet"            
        try:
            os.mkdir(gamefolder)
        except:
            raise UserWarning, "error at creating directory %s" % gamefolder
            exit()

def createGameFile(gamefile):
    """create logfile inside game directory"""
    if os.path.isfile(gamefile):
        print "highscore file aready exist"
    else:
        try:
            f = file(gamefile, "w") # open for writing
            f.write("--- screensaver logfile ---\n")
            f.close()
        except:
            raise UserWarning, "error while creating file %s" % gamefile
            exit()
            
def getPygameModes():
    """open pygame, get a list of valid screen resolutions, close pygame"""
    pygame.init()
    reslist = pygame.display.list_modes()
    pygame.quit()
    return reslist
    
def readGameFile(gamefile):
    try:
        f = file(gamefile, "r") # read
        text = f.read() 
        f.close()
    except:
        raise UserWarning, "Error while reading higscore file %s" % gamefile
        exit()
    return text

def writeGameFile(gamefile, line):
    try:
        f = file(gamefile, "a") # append
        f.write(line)
        f.close()
    except:
        raise UserWarning, "Error while writing higscore file %s" % gamefile
        exit()

def parse(answer):
    """get a string like '(640, 480)'.
       Return integer tuple like (640, 480)"""
    comma = answer.find(",") # position of the comma inside answer
    x = int(answer[1:comma])
    y = int(answer[comma+1:-1])
    resolution = (x,y)
    return resolution

def gamemenu():
    # setting directory for stroing highscorelist / logfile 
    #~ means home on linux . as first char will hide 
    gamefolder =  os.path.expanduser(os.path.join("~",".screensavertest"))  
    gamefile = os.path.join(gamefolder, "highscorelist.txt")                   
    # do not name gamefile "file", that is a reserved word !
    createGameDir(gamefolder)
    createGameFile(gamefile)
    # gamefile should now exist in gamefolder
    resolution = [640,480]
    fullscreen = False
    watched = 0
    title = "please choose wisely:"
    buttons = ["watch screensaver", "change resolution", "toggle fullscreen", "view highscore","visit homepage", "quit"]
    #picture = None # gif file or make sure python-imaging-tk is installed correctly
    picture = "data/tux.gif" 
    # ---- use pygame only to get a list of valid screen resolutions ---
    reslist = getPygameModes()
    # --- ask player name ----
    playername = easygui.enterbox("What is you name?", "please enter you name and press ENTER or click ok", "Mister dunno")

    while True: #endless loop        
        if fullscreen:
            msg2 = "fullscreen mode"
        else:
            msg2 = "window mode"
        msg = "Welcome at screensaver game menu.\nScreensaver will run with %ix%i resolution,\n%s" % (resolution[0], resolution[1], msg2)
        selection = easygui.buttonbox(msg, title, buttons, picture)
        if selection == "quit":
            easygui.msgbox("bye-bye", "such a sad decision...")
            break # leave loop
        elif selection == "visit homepage":
            print "i try to open the webbrowser, please wait a bit..."
            webbrowser.open_new_tab("http://www.thepythongamebook.com")
        elif selection == "toggle fullscreen":
            fullscreen = not fullscreen 
        elif selection == "view highscore":
            text = readGameFile(gamefile)
            easygui.textbox("This is the Screensaver logfile", "displaying highscore", text)
        elif selection == "watch screensaver":
            watched += 1
            playtime = screensaver.screensaver(resolution, fullscreen)
            easygui.msgbox("You watched the scrensaver %i x using this game menu \nYour screen was saved for %.2f seconds" % (watched, playtime))
            # writing highscore-list
            line = "date: %s player: %s playtime:  %.2f seconds resolution: %ix%i fullscreen: %s \n" % (time.asctime(), playername, playtime, resolution[0], resolution[1], fullscreen)
            writeGameFile(gamefile, line)
        elif selection == "change resolution":
            answer = easygui.choicebox("Please select one of those screen resolutions", "x,y", reslist)
            # answer gives back a string like '(320, 200)'
            resolution = parse(answer)
            
    return 

if __name__ == '__main__':
    gamemenu()


########NEW FILE########
__FILENAME__ = 024_pygamemenu
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
pygamemenu.py

demonstration of a game menu with pygame / EzMenu.
The gamemenu can change resolution, call a pygame 
program (the screensaver), return values (the playtime),
write and display a highscore list
EzMenu from PyMike, see EzMenu.py

Url:        http://ThePythonGameBook.com/en:part2:pygame:start
Author:     Horst JENS, horst.jens@spielend-programmieren.at
License:    GPL see http://www.gnu.org/licenses/gpl.html
Date:       2011/06
"""

import pygame
import os
import os.path
import time
import webbrowser
from lib import ezmenu
from lib import screensaver


class Config(object):
    #geraet = "Joystick"
    fullscreen = False
    resolution = (640,480)
    menu = None
    menuloop = True
    gamefolder =  os.path.expanduser(os.path.join("~",".screensavertest"))  
    gamefile = os.path.join(gamefolder, "highscorelist.txt")  
    reslist = []
    watched = 0
    result = "no game played yet"

def write(msg="pygame is cool", fontcolor=(255,0,255), fontsize=42, font=None):
    myfont = pygame.font.SysFont(font, fontsize)
    mytext = myfont.render(msg, True, fontcolor)
    mytext = mytext.convert_alpha()
    return mytext
  
   
def ask(screen, question):  
    """ from pygame newsgroup
    replacement for raw_input() in pygame
    
    ask(screen, question) -> answer"""
    pygame.font.init()  
    text = ""
    pygame.display.flip()
    line1 = write("please type in your name")
    line2 = write("and press ENTER:")
    while True:
        screen.fill((0,0,0)) #paint background black
        line3 = write(">" + text)
        screen.blit(line1, (20,20))
        screen.blit(line2, (20,50))
        screen.blit(line3, (20,80))
        pygame.time.wait(50)
        #event = pygame.event.poll()
        for event in pygame.event.get():        
            if event.type == pygame.QUIT:
                sys.exit()   
            elif event.type != pygame.KEYDOWN:
                continue
            elif event.key == pygame.K_BACKSPACE:
                text = text[0:-1]
            elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                return text
            else:
                text += event.unicode.encode("ascii")         
        pygame.display.flip()
               
    
def makemenu(pos=0):
    """pos is the current menuitem"""
    Config.menu = ezmenu.EzMenu(
        ["Run the Screensaver", gameRun],
        ["Change screen resolution: %i x %i" % (Config.resolution[0], Config.resolution[1]), gameNextResolution],
        ["toggle Fullscreen: %s" % Config.fullscreen, gameFullscreen],
        ["view hightscore/logfile ", gameReadFile],
        ["visit ThePythonGameBook homepage", lambda: gameUrl("http://ThePythonGameBook.com")],
        ["Quit Game", gameQuit] )
    
    Config.menu.center_at(320, 240)

    #Set the menu font (default is the pygame font)
    Config.menu.set_font(pygame.font.SysFont("Arial", 32))

    #Set the highlight color to green (default is red)
    Config.menu.set_highlight_color((255, 255, 0))

    #Set the normal color to white (default is black)
    Config.menu.set_normal_color((255, 255, 255))
    Config.menu.option = pos       

#Functions called when an option is selected
def gameRun():
    """play a game/ watch the screensaver"""
    playtime = screensaver.screensaver(Config.resolution, Config.fullscreen, False) # the False avoid the screensaver to do pygame.quit()
    screen, background = repaint()
    
def gameReadFile():
    pass
    
def gameFullscreen():
    Config.fullscreen = not Config.fullscreen
    print Config.fullscreen
    makemenu(2) # repaint menu, set active option of item #2 (start counting with 0)

def gameNextResolution():
    """ returns the next possible screen resolution from Config.reslist
    and set it into Config.resolution. If already on the end of reslist,
    start over with first element of reslist.
    reslist is a list of tuples, resolutio is a tuple of 2 integers"""
    myRes = Config.resolution
    if myRes not in Config.reslist:
        raise UserWarning, "Error: %s is not part of %s" % ( myRes, Config.reslist)
        exit()
    mypos = Config.reslist.index(myRes)
    if mypos == len(Config.reslist) -1 :
        mypos = 0 # cycle to first element of reslist
    else:
        mypos += 1 
    Config.resolution = Config.reslist[mypos]
    makemenu(1)
    
def gameUrl(url):
    print "i try to open the webbrowser, please wait a bit..."
    webbrowser.open_new_tab(url)
    # no makemenu, because the webbrowser does not open inside python
    
def gameQuit():
    """quit game"""
    Config.menuloop = False
    


def repaint():
    """set screen and background for game menu"""
    screen = pygame.display.set_mode((640,480))
    background = pygame.image.load(os.path.join("data", "tux.jpg"))
    background = pygame.transform.scale(background, Config.resolution)
    screen.blit(background, (0,0))
    return screen, background

#Main script
def main():

    #Set up pygame
    pygame.init()
    Config.reslist = pygame.display.list_modes()
    pygame.display.set_caption("EzMenu Example")
    screen, background = repaint()
    makemenu(0)
    FPS = 30
    clock = pygame.time.Clock()
    cooldown = 0
    
    # ask for playername
    playername = ask(screen, "Please type in your name and press ENTER")
    print playername 
    
    while Config.menuloop:
        pygame.display.set_caption("last game result: %s" % Config.result)
        #Get all the events called
        seconds = clock.tick(FPS) / 1000.0 # do not go faster than this frame rate
        if cooldown < 0:
            cooldown = 0
        if cooldown > 0:
            cooldown -= seconds
        events = pygame.event.get()
        
        #...and update the menu which needs access to those events
        Config.menu.update(events)

  
        #Let's quit when the Quit button is pressed
        for e in events:
            if e.type == pygame.QUIT:
                Config.menuloop = False
                
            elif e.type == pygame.KEYDOWN:
                #print "keypress"
                if e.key == pygame.K_ESCAPE:
                     Config.menuloop = False
        
        # mouse to open url's
        if pygame.mouse.get_pressed()[0] == True and cooldown ==0: # left mouse button was pressed
           mousex = pygame.mouse.get_pos()[0] 
           mousey = pygame.mouse.get_pos()[1] 
           if mousey > 95 and mousey < 116: # open game homepage
               webbrowser.open_new_tab("http://thepythongamebook.com/en:resources:games:schwarzweiss")
               cooldown = 1
           elif mousey > 170 and mousey < 274 and mousex < 145:
               webbrowser.open_new_tab("http://thepythongamebook.com")
               cooldown = 1
           elif mousey > 284 and mousey < 457 and mousex < 145:
               webbrowser.open_new_tab("http://flattr.com/thing/163126/schwarzweiss-game")
                     
        #Draw the scene!
        #screen.fill((0, 0, 255))
        screen.blit(background, (0,0))
        Config.menu.draw(screen)
        pygame.display.flip()
    # end of menuloop 
    #pygame.quit()
    #sys.exit()
    return                

#Run the script if executed
if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = 024_textmenu
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
easyguimenu.py

demonstration of a game menu with easygui.
The gamemenu can change resolution, call a pygame 
program (the screensaver), return values (the playtime),
write and display a highscore list

Url:        http://ThePythonGameBook.com/en:part2:pygame:start
Author:     Horst JENS, horst.jens@spielend-programmieren.at
License:    GPL see http://www.gnu.org/licenses/gpl.html
Date:       2011/06
"""

import pygame
from lib import easygui 
from lib import screensaver 
import os
import os.path
import time




def gamemenu():
    gamefolder =  os.path.expanduser(os.path.join("~",".screensavertest"))  # ~ means home on linux . as first char will hide 
    gamefile = os.path.join(gamefolder, "highscorelist.txt")                    # do not call it "file", that is a reserved word !
    if os.path.isdir(gamefolder):
        print "directory already exist"
    else:
        print "directory does not exist yet"
        try:
            os.mkdir(gamefolder)
        except:
            raise UserWarning, "error at creating directory %s" % gamefolder
            exit()
    if os.path.isfile(gamefile):
        print "highscore file aready exist"
    else:
        try:
            f = file(gamefile, "w") # open for writing
            f.write("--- screensaver logfile ---\n")
            f.close()
        except:
            raise UserWarning, "error while creating file %s" % gamefile
            exit()
    # gamefile should now exist in gamefolder
    
        
    resolution = [640,480]
    fullscreen = False
    watched = 0
    title = "please choose wisely:"
    buttons = ["watch screensaver", "change resolution", "toggle fullscreen", "view highscore", "quit"]
    #picture = None # gif file or make sure python-imaging-tk is installed correctly
    picture = "data/tux.gif" 
    # ---- use pygame only to get a list of valid screen resolutions ---
    pygame.init()
    reslist = pygame.display.list_modes()
    pygame.quit()
    # ---- end of pygame ----------
    # --- ask player name ----
    playername = easygui.enterbox("What is you name?", "please enter you name and press ENTER or click ok", "Mister dunno")
    while True: #endless loop
        
        if fullscreen:
            msg = "Welcome at screensaver game menu.\nScreensaver will run with %ix%i resolution,\nfullscreen mode" % (resolution[0], resolution[1])
        else:
            msg = "Welcome at screensaver game menu.\nScreensave will run with %ix%i resolution,\nwindow mode" % (resolution[0], resolution[1])
        selection = easygui.buttonbox(msg, title, buttons, picture)
        if selection == "quit":
            easygui.msgbox("bye-bye", "such a sad decision...")
            break # leave loop
        elif selection == "toggle fullscreen":
            fullscreen = not fullscreen 
        elif selection == "view highscore":
            try:
                f = file(gamefile, "r") # read
                text = f.read() 
                f.close()
            except:
                raise UserWarning, "Error while reading higscore file %s" % gamefile
                exit()
            easygui.textbox("This is the Screensaver logfile", "displaying highscore", text)
        elif selection == "watch screensaver":
            watched += 1
            playtime = screensaver.screensaver(resolution, fullscreen)
            easygui.msgbox("You watched the scrensaver %i x using this game menu \nYour screen was saved for %.2f seconds" % (watched, playtime))
            # writing highscore-list
            try:
                f = file(gamefile, "a") # append
                f.write("date: %s player: %s playtime:  %.2f seconds resolution: %ix%i fullscreen: %s \n" % (time.asctime(), playername, playtime, resolution[0], resolution[1], fullscreen))
                f.close()
            except:
                raise UserWarning, "Error while writing higscore file %s" % gamefile
                exit()
        elif selection == "change resolution":
            answer = easygui.choicebox("Please select one of those screen resolutions", "x,y", reslist)
            # answer gives back a string like '(320, 200)'
            comma = answer.find(",") # position of the comma inside answer
            x = int(answer[1:comma])
            y = int(answer[comma+1:-1])
            resolution = (x,y)
    return 

if __name__ == '__main__':
    gamemenu()


########NEW FILE########
__FILENAME__ = aliens2
#!/usr/bin/env python
# edited from the official pygame examples
import random, os.path

#import basic pygame modules
import pygame
#from pygame.locals import *

#see if we can load more than standard BMP
if not pygame.image.get_extended():
    raise SystemExit("Sorry, extended image module required")


#game constants
MAX_SHOTS      = 2      #most player bullets onscreen
ALIEN_ODDS     = 22     #chances a new alien appears
BOMB_ODDS      = 60    #chances a new bomb will drop
ALIEN_RELOAD   = 12     #frames between new aliens
SCREENRECT     = pygame.Rect(0, 0, 640, 480)
SCORE          = 0

main_dir = os.path.split(os.path.abspath(__file__))[0]

def load_image(file):
    "loads an image, prepares it for play"
    file = os.path.join(main_dir, 'data', file)
    try:
        surface = pygame.image.load(file)
    except pygame.error:
        raise SystemExit('Could not load image "%s" %s'%(file, pygame.get_error()))
    if file[-4:].lower() == ".png" or file[-4:].lower() == ".gif":
        return surface.convert_alpha() 
    else:
        return surface.convert()

def load_images(*files):
    imgs = []
    for file in files:
        imgs.append(load_image(file))
    return imgs


class dummysound:
    def play(self): pass

def load_sound(file):
    if not pygame.mixer: return dummysound()
    file = os.path.join(main_dir, 'data', file)
    try:
        sound = pygame.mixer.Sound(file)
        return sound
    except pygame.error:
        print ('Warning, unable to load, %s' % file)
    return dummysound()



# each type of game object gets an init and an
# update function. the update function is called
# once per frame, and it is when each object should
# change it's current position and state. the Player
# object actually gets a "move" function instead of
# update, since it is passed extra information about
# the keyboard


class Player(pygame.sprite.Sprite):
    speed = 10
    bounce = 24
    gun_offset = -11
    images = []
    def __init__(self):
        pygame.sprite.Sprite.__init__(self, self.containers)
        self.image = self.images[0]
        self.rect = self.image.get_rect(midbottom=SCREENRECT.midbottom)
        self.reloading = 0
        self.origtop = self.rect.top
        self.facing = -1

    def move(self, direction):
        if direction: self.facing = direction
        self.rect.move_ip(direction*self.speed, 0)
        self.rect = self.rect.clamp(SCREENRECT)
        if direction < 0:
            self.image = self.images[0]
        elif direction > 0:
            self.image = self.images[1]
        self.rect.top = self.origtop - (self.rect.left//self.bounce%2)

    def gunpos(self):
        pos = self.facing*self.gun_offset + self.rect.centerx
        return pos, self.rect.top


class Alien(pygame.sprite.Sprite):
    speed = 13
    animcycle = 12
    images = []
    def __init__(self):
        pygame.sprite.Sprite.__init__(self, self.containers)
        self.image = self.images[0]
        self.rect = self.image.get_rect()
        self.facing = random.choice((-1,1)) * Alien.speed
        self.frame = 0
        if self.facing < 0:
            self.rect.right = SCREENRECT.right

    def update(self):
        self.rect.move_ip(self.facing, 0)
        if not SCREENRECT.contains(self.rect):
            self.facing = -self.facing;
            self.rect.top = self.rect.bottom + 1
            self.rect = self.rect.clamp(SCREENRECT)
        self.frame = self.frame + 1
        self.image = self.images[self.frame//self.animcycle%3]


class Explosion(pygame.sprite.Sprite):
    defaultlife = 12
    animcycle = 3
    images = []
    def __init__(self, actor):
        pygame.sprite.Sprite.__init__(self, self.containers)
        self.image = self.images[0]
        self.rect = self.image.get_rect(center=actor.rect.center)
        self.life = self.defaultlife

    def update(self):
        self.life = self.life - 1
        self.image = self.images[self.life//self.animcycle%2]
        if self.life <= 0: self.kill()


class Shot(pygame.sprite.Sprite):
    speed = -11
    images = []
    def __init__(self, pos):
        pygame.sprite.Sprite.__init__(self, self.containers)
        self.image = self.images[0]
        self.rect = self.image.get_rect(midbottom=pos)

    def update(self):
        self.rect.move_ip(0, self.speed)
        if self.rect.top <= 0:
            self.kill()


class Bomb(pygame.sprite.Sprite):
    speed = 9
    images = []
    def __init__(self, alien):
        pygame.sprite.Sprite.__init__(self, self.containers)
        self.image = self.images[0]
        self.rect = self.image.get_rect(midbottom=
                    alien.rect.move(0,5).midbottom)

    def update(self):
        self.rect.move_ip(0, self.speed)
        if self.rect.bottom >= 470:
            Explosion(self)
            self.kill()


class Score(pygame.sprite.Sprite):
    def __init__(self):
        pygame.sprite.Sprite.__init__(self)
        self.font = pygame.font.Font(None, 20)
        self.font.set_italic(1)
        self.color = pygame.Color('white')
        self.lastscore = -1
        self.newscore = 0
        self.update()
        self.rect = self.image.get_rect().move(10, 450)
        
        
    def add(self, number=1):
        """adds number to the score. number must be integer"""
        if type(number) == int:
           self.newscore += number
                
    def update(self):
        if self.newscore != self.lastscore:
            msg = "Score: {}".format(self.newscore)
            self.image = self.font.render(msg, 0, self.color)



def main(winstyle = 0):
    # Initialize pygame
    pygame.init()
    if pygame.mixer and not pygame.mixer.get_init():
        print ('Warning, no sound')
        pygame.mixer = None

    # Set the display mode
    winstyle = 0  # |FULLSCREEN
    bestdepth = pygame.display.mode_ok(SCREENRECT.size, winstyle, 32)
    screen = pygame.display.set_mode(SCREENRECT.size, winstyle, bestdepth)

    #Load images, assign to sprite classes
    #(do this before the classes are used, after screen setup)
    img = load_image('player1.gif')
    Player.images = [img, pygame.transform.flip(img, 1, 0)]
    img = load_image('explosion1.gif')
    Explosion.images = [img, pygame.transform.flip(img, 1, 1)]
    Alien.images = load_images('alien1.gif', 'alien2.gif', 'alien3.gif')
    Bomb.images = [load_image('bomb.gif')]
    Shot.images = [load_image('shot.gif')]

    #decorate the game window
    icon = pygame.transform.scale(Alien.images[0], (32, 32))
    pygame.display.set_icon(icon)
    pygame.display.set_caption('Pygame Aliens')
    pygame.mouse.set_visible(0)

    #create the background, tile the bgd image
    bgdtile = load_image('background.gif')
    background = pygame.Surface(SCREENRECT.size)
    for x in range(0, SCREENRECT.width, bgdtile.get_width()):
        background.blit(bgdtile, (x, 0))
    screen.blit(background, (0,0))
    pygame.display.flip()

    #load the sound effects
    boom_sound = load_sound('boom.wav')
    shoot_sound = load_sound('car_door.wav')
    if pygame.mixer:
        music = os.path.join(main_dir, 'data', 'house_lo.wav')
        pygame.mixer.music.load(music)
        pygame.mixer.music.play(-1)

    # Initialize Game Groups
    aliens = pygame.sprite.Group()
    shots = pygame.sprite.Group()
    bombs = pygame.sprite.Group()
    all = pygame.sprite.RenderUpdates()
    lastalien = pygame.sprite.GroupSingle()

    #assign default groups to each sprite class
    Player.containers = all
    Alien.containers = aliens, all, lastalien
    Shot.containers = shots, all
    Bomb.containers = bombs, all
    Explosion.containers = all
    Score.containers = all

    #Create Some Starting Values
    #global score
    alienreload = ALIEN_RELOAD
    kills = 0
    clock = pygame.time.Clock()

    #initialize our starting sprites
    #global SCORE
    SCORE = 0
    player = Player()
    Alien() #note, this 'lives' because it goes into a sprite group
    if pygame.font:
        player1_score = Score()
        all.add(player1_score)

    # ----------- main loop ----------------
    while player.alive():

        #get input
        for event in pygame.event.get():
            if event.type == pygame.QUIT or \
                (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
                    return
        keystate = pygame.key.get_pressed()

        # clear/erase the last drawn sprites
        all.clear(screen, background)

        #update all the sprites
        all.update()

        #handle player input
        direction = keystate[pygame.K_RIGHT] - keystate[pygame.K_LEFT]
        player.move(direction)
        firing = keystate[pygame.K_SPACE]
        if not player.reloading and firing and len(shots) < MAX_SHOTS:
            Shot(player.gunpos())
            shoot_sound.play()
        player.reloading = firing

        # Create new alien
        if alienreload:
            alienreload = alienreload - 1
        elif not int(random.random() * ALIEN_ODDS):
            Alien()
            alienreload = ALIEN_RELOAD

        # Drop bombs
        if lastalien and not int(random.random() * BOMB_ODDS):
            Bomb(lastalien.sprite)

        # Detect collisions
        
        # iterate over all aliens colliding with player, 1 = kill alien 
        for alien in pygame.sprite.spritecollide(player, aliens, 1):
            boom_sound.play()
            Explosion(alien)
            Explosion(player)
            SCORE = SCORE + 1
            if pygame.font:
                player1_score.add(1)
            player.kill()

        # iterate over all aliens colliding with any shot, 1,1 = kill both
        for alien in pygame.sprite.groupcollide(shots, aliens, 1, 1).keys():
            boom_sound.play()
            Explosion(alien)
            SCORE = SCORE + 1
            if pygame.font:
                player1_score.add(1)
            
        for bomb in pygame.sprite.spritecollide(player, bombs, 1):
            boom_sound.play()
            Explosion(player)
            Explosion(bomb)
            player.kill()

        #draw the scene
        dirty = all.draw(screen)
        pygame.display.update(dirty)

        #cap the framerate
        clock.tick(40)

    # ------- end of main loop ----------
    if pygame.mixer:
        pygame.mixer.music.fadeout(1000)
    pygame.time.wait(1000)
    pygame.quit()



#call the "main" function if running this script
if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = easygui
"""
@version: 0.96(2010-06-25)
@note:
EasyGui provides an easy-to-use interface for simple GUI interaction
with a user.  It does not require the programmer to know anything about
tkinter, frames, widgets, callbacks or lambda.  All GUI interactions are
invoked by simple function calls that return results.


@note:
WARNING about using EasyGui with IDLE

You may encounter problems using IDLE to run programs that use EasyGui. Try it
and find out.  EasyGui is a collection of Tkinter routines that run their own
event loops.  IDLE is also a Tkinter application, with its own event loop.  The
two may conflict, with unpredictable results. If you find that you have
problems, try running your EasyGui program outside of IDLE.

Note that EasyGui requires Tk release 8.0 or greater.
"""
egversion = __doc__.split()[1]

__all__ = ['ynbox'
    , 'ccbox'
    , 'boolbox'
    , 'indexbox'
    , 'msgbox'
    , 'buttonbox'
    , 'integerbox'
    , 'multenterbox'
    , 'enterbox'
    , 'exceptionbox'
    , 'choicebox'
    , 'codebox'
    , 'textbox'
    , 'diropenbox'
    , 'fileopenbox'
    , 'filesavebox'
    , 'passwordbox'
    , 'multpasswordbox'
    , 'multchoicebox'
    , 'abouteasygui'
    , 'egversion'
    , 'egdemo'
    , 'EgStore'
    ]

import sys, os, string, types, pickle,traceback
import pprint

#--------------------------------------------------
# check python version and take appropriate action
#--------------------------------------------------
"""
From the python documentation:

sys.hexversion contains the version number encoded as a single integer. This is
guaranteed to increase with each version, including proper support for non-
production releases. For example, to test that the Python interpreter is at
least version 1.5.2, use:

if sys.hexversion >= 0x010502F0:
    # use some advanced feature
    ...
else:
    # use an alternative implementation or warn the user
    ...
"""


if sys.hexversion >= 0x020600F0:
    runningPython26 = True
else:
    runningPython26 = False

if sys.hexversion >= 0x030000F0:
    runningPython3 = True
else:
    runningPython3 = False


if runningPython3:
    from tkinter import *
    import tkinter.filedialog as tk_FileDialog
    from io import StringIO
else:
    from Tkinter import *
    import tkFileDialog as tk_FileDialog
    from StringIO import StringIO

def write(*args):
    args = [str(arg) for arg in args]
    args = " ".join(args)
    sys.stdout.write(args)

def writeln(*args):
    write(*args)
    sys.stdout.write("\n")

say = writeln


if TkVersion < 8.0 :
    stars = "*"*75
    writeln("""\n\n\n""" + stars + """
You are running Tk version: """ + str(TkVersion) + """
You must be using Tk version 8.0 or greater to use EasyGui.
Terminating.
""" + stars + """\n\n\n""")
    sys.exit(0)

def dq(s):
    return '"%s"' % s

rootWindowPosition = "+300+200"

PROPORTIONAL_FONT_FAMILY = ("MS", "Sans", "Serif")
MONOSPACE_FONT_FAMILY    = ("Courier")

PROPORTIONAL_FONT_SIZE  = 10
MONOSPACE_FONT_SIZE     =  9  #a little smaller, because it it more legible at a smaller size
TEXT_ENTRY_FONT_SIZE    = 12  # a little larger makes it easier to see

#STANDARD_SELECTION_EVENTS = ["Return", "Button-1"]
STANDARD_SELECTION_EVENTS = ["Return", "Button-1", "space"]

# Initialize some global variables that will be reset later
__choiceboxMultipleSelect = None
__widgetTexts = None
__replyButtonText = None
__choiceboxResults = None
__firstWidget = None
__enterboxText = None
__enterboxDefaultText=""
__multenterboxText = ""
choiceboxChoices = None
choiceboxWidget = None
entryWidget = None
boxRoot = None
ImageErrorMsg = (
    "\n\n---------------------------------------------\n"
    "Error: %s\n%s")
#-------------------------------------------------------------------
# various boxes built on top of the basic buttonbox
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# ynbox
#-----------------------------------------------------------------------
def ynbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes", "No")
    , image=None
    ):
    """
    Display a msgbox with choices of Yes and No.

    The default is "Yes".

    The returned value is calculated this way::
        if the first choice ("Yes") is chosen, or if the dialog is cancelled:
            return 1
        else:
            return 0

    If invoked without a msg argument, displays a generic request for a confirmation
    that the user wishes to continue.  So it can be used this way::
        if ynbox(): pass # continue
        else: sys.exit(0)  # exit the program

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    return boolbox(msg, title, choices, image=image)


#-----------------------------------------------------------------------
# ccbox
#-----------------------------------------------------------------------
def ccbox(msg="Shall I continue?"
    , title=" "
    , choices=("Continue", "Cancel")
    , image=None
    ):
    """
    Display a msgbox with choices of Continue and Cancel.

    The default is "Continue".

    The returned value is calculated this way::
        if the first choice ("Continue") is chosen, or if the dialog is cancelled:
            return 1
        else:
            return 0

    If invoked without a msg argument, displays a generic request for a confirmation
    that the user wishes to continue.  So it can be used this way::

        if ccbox():
            pass # continue
        else:
            sys.exit(0)  # exit the program

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    return boolbox(msg, title, choices, image=image)


#-----------------------------------------------------------------------
# boolbox
#-----------------------------------------------------------------------
def boolbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes","No")
    , image=None
    ):
    """
    Display a boolean msgbox.

    The default is the first choice.

    The returned value is calculated this way::
        if the first choice is chosen, or if the dialog is cancelled:
            returns 1
        else:
            returns 0
    """
    reply = buttonbox(msg=msg, choices=choices, title=title, image=image)
    if reply == choices[0]: return 1
    else: return 0


#-----------------------------------------------------------------------
# indexbox
#-----------------------------------------------------------------------
def indexbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes","No")
    , image=None
    ):
    """
    Display a buttonbox with the specified choices.
    Return the index of the choice selected.
    """
    reply = buttonbox(msg=msg, choices=choices, title=title, image=image)
    index = -1
    for choice in choices:
        index = index + 1
        if reply == choice: return index
    raise AssertionError(
        "There is a program logic error in the EasyGui code for indexbox.")


#-----------------------------------------------------------------------
# msgbox
#-----------------------------------------------------------------------
def msgbox(msg="(Your message goes here)", title=" ", ok_button="OK",image=None,root=None):
    """
    Display a messagebox
    """
    if type(ok_button) != type("OK"):
        raise AssertionError("The 'ok_button' argument to msgbox must be a string.")

    return buttonbox(msg=msg, title=title, choices=[ok_button], image=image,root=root)


#-------------------------------------------------------------------
# buttonbox
#-------------------------------------------------------------------
def buttonbox(msg="",title=" "
    ,choices=("Button1", "Button2", "Button3")
    , image=None
    , root=None
    ):
    """
    Display a msg, a title, and a set of buttons.
    The buttons are defined by the members of the choices list.
    Return the text of the button that the user selected.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    global boxRoot, __replyButtonText, __widgetTexts, buttonsFrame


    # Initialize __replyButtonText to the first choice.
    # This is what will be used if the window is closed by the close button.
    __replyButtonText = choices[0]

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.minsize(400, 100)

    # ------------- define the messageFrame ---------------------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the imageFrame ---------------------------------


    tk_Image = None
    if image:
        imageFilename = os.path.normpath(image)
        junk,ext = os.path.splitext(imageFilename)

        if os.path.exists(imageFilename):
            if ext.lower() in [".gif", ".pgm", ".ppm"]:
                tk_Image = PhotoImage(file=imageFilename)
            else:
                try:
                    from PIL import Image   as PILImage
                    from PIL import ImageTk as PILImageTk
                    PILisLoaded = True
                except:
                    PILisLoaded = False

                if PILisLoaded:
                    try:
                        pil_Image = PILImage.open(imageFilename)
                        tk_Image = PILImageTk.PhotoImage(pil_Image)
                    except:
                        msg += ImageErrorMsg % (imageFilename,
                            "\nThe Python Imaging Library (PIL) could not convert this file to a displayable image."
                            "\n\nPIL reports:\n" + exception_format())

                else:  # PIL is not loaded
                    msg += ImageErrorMsg % (imageFilename,
                    "\nI could not import the Python Imaging Library (PIL) to display the image.\n\n"
                    "You may need to install PIL\n"
                    "(http://www.pythonware.com/products/pil/)\n"
                    "to display " + ext + " image files.")

        else:
            msg += ImageErrorMsg % (imageFilename, "\nImage file not found.")

    if tk_Image:
        imageFrame = Frame(master=boxRoot)
        imageFrame.pack(side=TOP, fill=BOTH)
        label = Label(imageFrame,image=tk_Image)
        label.image = tk_Image # keep a reference!
        label.pack(side=TOP, expand=YES, fill=X, padx='1m', pady='1m')

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    # -------------------- place the widgets in the frames -----------------------
    messageWidget = Message(messageFrame, text=msg, width=400)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')

    __put_buttons_in_buttonframe(choices)

    # -------------- the action begins -----------
    # put the focus on the first button
    __firstWidget.focus_force()

    boxRoot.deiconify()
    boxRoot.mainloop()
    boxRoot.destroy()
    if root: root.deiconify()
    return __replyButtonText


#-------------------------------------------------------------------
# integerbox
#-------------------------------------------------------------------
def integerbox(msg=""
    , title=" "
    , default=""
    , lowerbound=0
    , upperbound=99
    , image = None
    , root  = None
    , **invalidKeywordArguments
    ):
    """
    Show a box in which a user can enter an integer.

    In addition to arguments for msg and title, this function accepts
    integer arguments for "default", "lowerbound", and "upperbound".

    The default argument may be None.

    When the user enters some text, the text is checked to verify that it
    can be converted to an integer between the lowerbound and upperbound.

    If it can be, the integer (not the text) is returned.

    If it cannot, then an error msg is displayed, and the integerbox is
    redisplayed.

    If the user cancels the operation, None is returned.

    NOTE that the "argLowerBound" and "argUpperBound" arguments are no longer
    supported.  They have been replaced by "upperbound" and "lowerbound".
    """
    if "argLowerBound" in invalidKeywordArguments:
        raise AssertionError(
            "\nintegerbox no longer supports the 'argLowerBound' argument.\n"
            + "Use 'lowerbound' instead.\n\n")
    if "argUpperBound" in invalidKeywordArguments:
        raise AssertionError(
            "\nintegerbox no longer supports the 'argUpperBound' argument.\n"
            + "Use 'upperbound' instead.\n\n")

    if default != "":
        if type(default) != type(1):
            raise AssertionError(
                "integerbox received a non-integer value for "
                + "default of " + dq(str(default)) , "Error")

    if type(lowerbound) != type(1):
        raise AssertionError(
            "integerbox received a non-integer value for "
            + "lowerbound of " + dq(str(lowerbound)) , "Error")

    if type(upperbound) != type(1):
        raise AssertionError(
            "integerbox received a non-integer value for "
            + "upperbound of " + dq(str(upperbound)) , "Error")

    if msg == "":
        msg = ("Enter an integer between " + str(lowerbound)
            + " and "
            + str(upperbound)
            )

    while 1:
        reply = enterbox(msg, title, str(default), image=image, root=root)
        if reply == None: return None

        try:
            reply = int(reply)
        except:
            msgbox ("The value that you entered:\n\t%s\nis not an integer." % dq(str(reply))
                    , "Error")
            continue

        if reply < lowerbound:
            msgbox ("The value that you entered is less than the lower bound of "
                + str(lowerbound) + ".", "Error")
            continue

        if reply > upperbound:
            msgbox ("The value that you entered is greater than the upper bound of "
                + str(upperbound) + ".", "Error")
            continue

        # reply has passed all validation checks.
        # It is an integer between the specified bounds.
        return reply

#-------------------------------------------------------------------
# multenterbox
#-------------------------------------------------------------------
def multenterbox(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    ):
    r"""
    Show screen with multiple data entry fields.

    If there are fewer values than names, the list of values is padded with
    empty strings until the number of values is the same as the number of names.

    If there are more values than names, the list of values
    is truncated so that there are as many values as names.

    Returns a list of the values of the fields,
    or None if the user cancels the operation.

    Here is some example code, that shows how values returned from
    multenterbox can be checked for validity before they are accepted::
        ----------------------------------------------------------------------
        msg = "Enter your personal information"
        title = "Credit Card Application"
        fieldNames = ["Name","Street Address","City","State","ZipCode"]
        fieldValues = []  # we start with blanks for the values
        fieldValues = multenterbox(msg,title, fieldNames)

        # make sure that none of the fields was left blank
        while 1:
            if fieldValues == None: break
            errmsg = ""
            for i in range(len(fieldNames)):
                if fieldValues[i].strip() == "":
                    errmsg += ('"%s" is a required field.\n\n' % fieldNames[i])
            if errmsg == "":
                break # no problems found
            fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)

        writeln("Reply was: %s" % str(fieldValues))
        ----------------------------------------------------------------------

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg fields: a list of fieldnames.
    @arg values:  a list of field values
    """
    return __multfillablebox(msg,title,fields,values,None)


#-----------------------------------------------------------------------
# multpasswordbox
#-----------------------------------------------------------------------
def multpasswordbox(msg="Fill in values for the fields."
    , title=" "
    , fields=tuple()
    ,values=tuple()
    ):
    r"""
    Same interface as multenterbox.  But in multpassword box,
    the last of the fields is assumed to be a password, and
    is masked with asterisks.

    Example
    =======

    Here is some example code, that shows how values returned from
    multpasswordbox can be checked for validity before they are accepted::
        msg = "Enter logon information"
        title = "Demo of multpasswordbox"
        fieldNames = ["Server ID", "User ID", "Password"]
        fieldValues = []  # we start with blanks for the values
        fieldValues = multpasswordbox(msg,title, fieldNames)

        # make sure that none of the fields was left blank
        while 1:
            if fieldValues == None: break
            errmsg = ""
            for i in range(len(fieldNames)):
                if fieldValues[i].strip() == "":
                    errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
            fieldValues = multpasswordbox(errmsg, title, fieldNames, fieldValues)

        writeln("Reply was: %s" % str(fieldValues))
    """
    return __multfillablebox(msg,title,fields,values,"*")

def bindArrows(widget):
    widget.bind("<Down>", tabRight)
    widget.bind("<Up>"  , tabLeft)

    widget.bind("<Right>",tabRight)
    widget.bind("<Left>" , tabLeft)

def tabRight(event):
    boxRoot.event_generate("<Tab>")

def tabLeft(event):
    boxRoot.event_generate("<Shift-Tab>")

#-----------------------------------------------------------------------
# __multfillablebox
#-----------------------------------------------------------------------
def __multfillablebox(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    , mask = None
    ):
    global boxRoot, __multenterboxText, __multenterboxDefaultText, cancelButton, entryWidget, okButton

    choices = ["OK", "Cancel"]
    if len(fields) == 0: return None

    fields = list(fields[:])  # convert possible tuples to a list
    values = list(values[:])  # convert possible tuples to a list

    if   len(values) == len(fields): pass
    elif len(values) >  len(fields):
        fields = fields[0:len(values)]
    else:
        while len(values) < len(fields):
            values.append("")

    boxRoot = Tk()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.bind("<Escape>", __multenterboxCancel)

    # -------------------- put subframes in the boxRoot --------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    #-------------------- the msg widget ----------------------------
    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    global entryWidgets
    entryWidgets = []

    lastWidgetIndex = len(fields) - 1

    for widgetIndex in range(len(fields)):
        argFieldName  = fields[widgetIndex]
        argFieldValue = values[widgetIndex]
        entryFrame = Frame(master=boxRoot)
        entryFrame.pack(side=TOP, fill=BOTH)

        # --------- entryWidget ----------------------------------------------
        labelWidget = Label(entryFrame, text=argFieldName)
        labelWidget.pack(side=LEFT)

        entryWidget = Entry(entryFrame, width=40,highlightthickness=2)
        entryWidgets.append(entryWidget)
        entryWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,TEXT_ENTRY_FONT_SIZE))
        entryWidget.pack(side=RIGHT, padx="3m")

        bindArrows(entryWidget)

        entryWidget.bind("<Return>", __multenterboxGetText)
        entryWidget.bind("<Escape>", __multenterboxCancel)

        # for the last entryWidget, if this is a multpasswordbox,
        # show the contents as just asterisks
        if widgetIndex == lastWidgetIndex:
            if mask:
                entryWidgets[widgetIndex].configure(show=mask)

        # put text into the entryWidget
        entryWidgets[widgetIndex].insert(0,argFieldValue)
        widgetIndex += 1

    # ------------------ ok button -------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=BOTTOM, fill=BOTH)

    okButton = Button(buttonsFrame, takefocus=1, text="OK")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __multenterboxGetText
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __multenterboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------- time for action! -----------------
    entryWidgets[0].focus_force()    # put the focus on the entryWidget
    boxRoot.mainloop()  # run it!

    # -------- after the run has completed ----------------------------------
    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    return __multenterboxText


#-----------------------------------------------------------------------
# __multenterboxGetText
#-----------------------------------------------------------------------
def __multenterboxGetText(event):
    global __multenterboxText

    __multenterboxText = []
    for entryWidget in entryWidgets:
        __multenterboxText.append(entryWidget.get())
    boxRoot.quit()


def __multenterboxCancel(event):
    global __multenterboxText
    __multenterboxText = None
    boxRoot.quit()


#-------------------------------------------------------------------
# enterbox
#-------------------------------------------------------------------
def enterbox(msg="Enter something."
    , title=" "
    , default=""
    , strip=True
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter some text.

    You may optionally specify some default text, which will appear in the
    enterbox when it is displayed.

    Returns the text that the user entered, or None if he cancels the operation.

    By default, enterbox strips its result (i.e. removes leading and trailing
    whitespace).  (If you want it not to strip, use keyword argument: strip=False.)
    This makes it easier to test the results of the call::

        reply = enterbox(....)
        if reply:
            ...
        else:
            ...
    """
    result = __fillablebox(msg, title, default=default, mask=None,image=image,root=root)
    if result and strip:
        result = result.strip()
    return result


def passwordbox(msg="Enter your password."
    , title=" "
    , default=""
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter a password.
    The text is masked with asterisks, so the password is not displayed.
    Returns the text that the user entered, or None if he cancels the operation.
    """
    return __fillablebox(msg, title, default, mask="*",image=image,root=root)


def __fillablebox(msg
    , title=""
    , default=""
    , mask=None
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter some text.
    You may optionally specify some default text, which will appear in the
    enterbox when it is displayed.
    Returns the text that the user entered, or None if he cancels the operation.
    """

    global boxRoot, __enterboxText, __enterboxDefaultText
    global cancelButton, entryWidget, okButton

    if title == None: title == ""
    if default == None: default = ""
    __enterboxDefaultText = default
    __enterboxText        = __enterboxDefaultText

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.bind("<Escape>", __enterboxCancel)

    if image:
        image = os.path.normpath(image)
        junk,ext = os.path.splitext(image)
        if ext.lower() == ".gif":
            if os.path.exists(image):
                pass
            else:
                msg += ImageErrorMsg % (image, "Image file not found.")
                image = None
        else:
            msg += ImageErrorMsg % (image, "Image file is not a .gif file.")
            image = None
    # ------------- define the messageFrame ---------------------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the imageFrame ---------------------------------
    if image:
        imageFrame = Frame(master=boxRoot)
        imageFrame.pack(side=TOP, fill=BOTH)
        image = PhotoImage(file=image)
        label = Label(imageFrame,image=image)
        label.image = image # keep a reference!
        label.pack(side=TOP, expand=YES, fill=X, padx='1m', pady='1m')

    # ------------- define the entryFrame ---------------------------------
    entryFrame = Frame(master=boxRoot)
    entryFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    #-------------------- the msg widget ----------------------------
    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    # --------- entryWidget ----------------------------------------------
    entryWidget = Entry(entryFrame, width=40)
    bindArrows(entryWidget)
    entryWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,TEXT_ENTRY_FONT_SIZE))
    if mask:
        entryWidget.configure(show=mask)
    entryWidget.pack(side=LEFT, padx="3m")
    entryWidget.bind("<Return>", __enterboxGetText)
    entryWidget.bind("<Escape>", __enterboxCancel)
    # put text into the entryWidget
    entryWidget.insert(0,__enterboxDefaultText)

    # ------------------ ok button -------------------------------
    okButton = Button(buttonsFrame, takefocus=1, text="OK")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __enterboxGetText
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __enterboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)

    # ------------------- time for action! -----------------
    entryWidget.focus_force()    # put the focus on the entryWidget
    boxRoot.deiconify()
    boxRoot.mainloop()  # run it!

    # -------- after the run has completed ----------------------------------
    if root: root.deiconify()
    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    return __enterboxText


def __enterboxGetText(event):
    global __enterboxText
    __enterboxText = entryWidget.get()
    boxRoot.quit()


def __enterboxRestore(event):
    global entryWidget
    entryWidget.delete(0,len(entryWidget.get()))
    entryWidget.insert(0, __enterboxDefaultText)


def __enterboxCancel(event):
    global __enterboxText
    __enterboxText = None
    boxRoot.quit()

def denyWindowManagerClose():
    """ don't allow WindowManager close
    """
    x = Tk()
    x.withdraw()
    x.bell()
    x.destroy()



#-------------------------------------------------------------------
# multchoicebox
#-------------------------------------------------------------------
def multchoicebox(msg="Pick as many items as you like."
    , title=" "
    , choices=()
    , **kwargs
    ):
    """
    Present the user with a list of choices.
    allow him to select multiple items and return them in a list.
    if the user doesn't choose anything from the list, return the empty list.
    return None if he cancelled selection.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    if len(choices) == 0: choices = ["Program logic error - no choices were specified."]

    global __choiceboxMultipleSelect
    __choiceboxMultipleSelect = 1
    return __choicebox(msg, title, choices)


#-----------------------------------------------------------------------
# choicebox
#-----------------------------------------------------------------------
def choicebox(msg="Pick something."
    , title=" "
    , choices=()
    ):
    """
    Present the user with a list of choices.
    return the choice that he selects.
    return None if he cancels the selection selection.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    if len(choices) == 0: choices = ["Program logic error - no choices were specified."]

    global __choiceboxMultipleSelect
    __choiceboxMultipleSelect = 0
    return __choicebox(msg,title,choices)


#-----------------------------------------------------------------------
# __choicebox
#-----------------------------------------------------------------------
def __choicebox(msg
    , title
    , choices
    ):
    """
    internal routine to support choicebox() and multchoicebox()
    """
    global boxRoot, __choiceboxResults, choiceboxWidget, defaultText
    global choiceboxWidget, choiceboxChoices
    #-------------------------------------------------------------------
    # If choices is a tuple, we make it a list so we can sort it.
    # If choices is already a list, we make a new list, so that when
    # we sort the choices, we don't affect the list object that we
    # were given.
    #-------------------------------------------------------------------
    choices = list(choices[:])
    if len(choices) == 0:
        choices = ["Program logic error - no choices were specified."]
    defaultButtons = ["OK", "Cancel"]

    # make sure all choices are strings
    for index in range(len(choices)):
        choices[index] = str(choices[index])

    lines_to_show = min(len(choices), 20)
    lines_to_show = 20

    if title == None: title = ""

    # Initialize __choiceboxResults
    # This is the value that will be returned if the user clicks the close icon
    __choiceboxResults = None

    boxRoot = Tk()
    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    screen_width  = boxRoot.winfo_screenwidth()
    screen_height = boxRoot.winfo_screenheight()
    root_width    = int((screen_width * 0.8))
    root_height   = int((screen_height * 0.5))
    root_xpos     = int((screen_width * 0.1))
    root_ypos     = int((screen_height * 0.05))

    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    rootWindowPosition = "+0+0"
    boxRoot.geometry(rootWindowPosition)
    boxRoot.expand=NO
    boxRoot.minsize(root_width, root_height)
    rootWindowPosition = "+" + str(root_xpos) + "+" + str(root_ypos)
    boxRoot.geometry(rootWindowPosition)

    # ---------------- put the frames in the window -----------------------------------------
    message_and_buttonsFrame = Frame(master=boxRoot)
    message_and_buttonsFrame.pack(side=TOP, fill=X, expand=NO)

    messageFrame = Frame(message_and_buttonsFrame)
    messageFrame.pack(side=LEFT, fill=X, expand=YES)
    #messageFrame.pack(side=TOP, fill=X, expand=YES)

    buttonsFrame = Frame(message_and_buttonsFrame)
    buttonsFrame.pack(side=RIGHT, expand=NO, pady=0)
    #buttonsFrame.pack(side=TOP, expand=YES, pady=0)

    choiceboxFrame = Frame(master=boxRoot)
    choiceboxFrame.pack(side=BOTTOM, fill=BOTH, expand=YES)

    # -------------------------- put the widgets in the frames ------------------------------

    # ---------- put a msg widget in the msg frame-------------------
    messageWidget = Message(messageFrame, anchor=NW, text=msg, width=int(root_width * 0.9))
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=LEFT, expand=YES, fill=BOTH, padx='1m', pady='1m')

    # --------  put the choiceboxWidget in the choiceboxFrame ---------------------------
    choiceboxWidget = Listbox(choiceboxFrame
        , height=lines_to_show
        , borderwidth="1m"
        , relief="flat"
        , bg="white"
        )

    if __choiceboxMultipleSelect:
        choiceboxWidget.configure(selectmode=MULTIPLE)

    choiceboxWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))

    # add a vertical scrollbar to the frame
    rightScrollbar = Scrollbar(choiceboxFrame, orient=VERTICAL, command=choiceboxWidget.yview)
    choiceboxWidget.configure(yscrollcommand = rightScrollbar.set)

    # add a horizontal scrollbar to the frame
    bottomScrollbar = Scrollbar(choiceboxFrame, orient=HORIZONTAL, command=choiceboxWidget.xview)
    choiceboxWidget.configure(xscrollcommand = bottomScrollbar.set)

    # pack the Listbox and the scrollbars.  Note that although we must define
    # the textArea first, we must pack it last, so that the bottomScrollbar will
    # be located properly.

    bottomScrollbar.pack(side=BOTTOM, fill = X)
    rightScrollbar.pack(side=RIGHT, fill = Y)

    choiceboxWidget.pack(side=LEFT, padx="1m", pady="1m", expand=YES, fill=BOTH)

    #---------------------------------------------------
    # sort the choices
    # eliminate duplicates
    # put the choices into the choiceboxWidget
    #---------------------------------------------------
    for index in range(len(choices)):
        choices[index] == str(choices[index])

    if runningPython3:
        choices.sort(key=str.lower)
    else:
        choices.sort( lambda x,y: cmp(x.lower(),    y.lower())) # case-insensitive sort

    lastInserted = None
    choiceboxChoices = []
    for choice in choices:
        if choice == lastInserted: pass
        else:
            choiceboxWidget.insert(END, choice)
            choiceboxChoices.append(choice)
            lastInserted = choice

    boxRoot.bind('<Any-Key>', KeyboardListener)

    # put the buttons in the buttonsFrame
    if len(choices) > 0:
        okButton = Button(buttonsFrame, takefocus=YES, text="OK", height=1, width=6)
        bindArrows(okButton)
        okButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

        # for the commandButton, bind activation events to the activation event handler
        commandButton  = okButton
        handler = __choiceboxGetChoice
        for selectionEvent in STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

        # now bind the keyboard events
        choiceboxWidget.bind("<Return>", __choiceboxGetChoice)
        choiceboxWidget.bind("<Double-Button-1>", __choiceboxGetChoice)
    else:
        # now bind the keyboard events
        choiceboxWidget.bind("<Return>", __choiceboxCancel)
        choiceboxWidget.bind("<Double-Button-1>", __choiceboxCancel)

    cancelButton = Button(buttonsFrame, takefocus=YES, text="Cancel", height=1, width=6)
    bindArrows(cancelButton)
    cancelButton.pack(expand=NO, side=BOTTOM, padx='2m', pady='1m', ipady="1m", ipadx="2m")

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __choiceboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # add special buttons for multiple select features
    if len(choices) > 0 and __choiceboxMultipleSelect:
        selectionButtonsFrame = Frame(messageFrame)
        selectionButtonsFrame.pack(side=RIGHT, fill=Y, expand=NO)

        selectAllButton = Button(selectionButtonsFrame, text="Select All", height=1, width=6)
        bindArrows(selectAllButton)

        selectAllButton.bind("<Button-1>",__choiceboxSelectAll)
        selectAllButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

        clearAllButton = Button(selectionButtonsFrame, text="Clear All", height=1, width=6)
        bindArrows(clearAllButton)
        clearAllButton.bind("<Button-1>",__choiceboxClearAll)
        clearAllButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")


    # -------------------- bind some keyboard events ----------------------------
    boxRoot.bind("<Escape>", __choiceboxCancel)

    # --------------------- the action begins -----------------------------------
    # put the focus on the choiceboxWidget, and the select highlight on the first item
    choiceboxWidget.select_set(0)
    choiceboxWidget.focus_force()

    # --- run it! -----
    boxRoot.mainloop()

    boxRoot.destroy()
    return __choiceboxResults


def __choiceboxGetChoice(event):
    global boxRoot, __choiceboxResults, choiceboxWidget

    if __choiceboxMultipleSelect:
        __choiceboxResults = [choiceboxWidget.get(index) for index in choiceboxWidget.curselection()]

    else:
        choice_index = choiceboxWidget.curselection()
        __choiceboxResults = choiceboxWidget.get(choice_index)

    # writeln("Debugging> mouse-event=", event, " event.type=", event.type)
    # writeln("Debugging> choice=", choice_index, __choiceboxResults)
    boxRoot.quit()


def __choiceboxSelectAll(event):
    global choiceboxWidget, choiceboxChoices
    choiceboxWidget.selection_set(0, len(choiceboxChoices)-1)

def __choiceboxClearAll(event):
    global choiceboxWidget, choiceboxChoices
    choiceboxWidget.selection_clear(0, len(choiceboxChoices)-1)



def __choiceboxCancel(event):
    global boxRoot, __choiceboxResults

    __choiceboxResults = None
    boxRoot.quit()


def KeyboardListener(event):
    global choiceboxChoices, choiceboxWidget
    key = event.keysym
    if len(key) <= 1:
        if key in string.printable:
            # Find the key in the list.
            # before we clear the list, remember the selected member
            try:
                start_n = int(choiceboxWidget.curselection()[0])
            except IndexError:
                start_n = -1

            ## clear the selection.
            choiceboxWidget.selection_clear(0, 'end')

            ## start from previous selection +1
            for n in range(start_n+1, len(choiceboxChoices)):
                item = choiceboxChoices[n]
                if item[0].lower() == key.lower():
                    choiceboxWidget.selection_set(first=n)
                    choiceboxWidget.see(n)
                    return
            else:
                # has not found it so loop from top
                for n in range(len(choiceboxChoices)):
                    item = choiceboxChoices[n]
                    if item[0].lower() == key.lower():
                        choiceboxWidget.selection_set(first = n)
                        choiceboxWidget.see(n)
                        return

                # nothing matched -- we'll look for the next logical choice
                for n in range(len(choiceboxChoices)):
                    item = choiceboxChoices[n]
                    if item[0].lower() > key.lower():
                        if n > 0:
                            choiceboxWidget.selection_set(first = (n-1))
                        else:
                            choiceboxWidget.selection_set(first = 0)
                        choiceboxWidget.see(n)
                        return

                # still no match (nothing was greater than the key)
                # we set the selection to the first item in the list
                lastIndex = len(choiceboxChoices)-1
                choiceboxWidget.selection_set(first = lastIndex)
                choiceboxWidget.see(lastIndex)
                return

#-----------------------------------------------------------------------
# exception_format
#-----------------------------------------------------------------------
def exception_format():
    """
    Convert exception info into a string suitable for display.
    """
    return "".join(traceback.format_exception(
           sys.exc_info()[0]
        ,  sys.exc_info()[1]
        ,  sys.exc_info()[2]
        ))

#-----------------------------------------------------------------------
# exceptionbox
#-----------------------------------------------------------------------
def exceptionbox(msg=None, title=None):
    """
    Display a box that gives information about
    an exception that has just been raised.

    The caller may optionally pass in a title for the window, or a
    msg to accompany the error information.

    Note that you do not need to (and cannot) pass an exception object
    as an argument.  The latest exception will automatically be used.
    """
    if title == None: title = "Error Report"
    if msg == None:
        msg = "An error (exception) has occurred in the program."

    codebox(msg, title, exception_format())

#-------------------------------------------------------------------
# codebox
#-------------------------------------------------------------------

def codebox(msg=""
    , title=" "
    , text=""
    ):
    """
    Display some text in a monospaced font, with no line wrapping.
    This function is suitable for displaying code and text that is
    formatted using spaces.

    The text parameter should be a string, or a list or tuple of lines to be
    displayed in the textbox.
    """
    return textbox(msg, title, text, codebox=1 )

#-------------------------------------------------------------------
# textbox
#-------------------------------------------------------------------
def textbox(msg=""
    , title=" "
    , text=""
    , codebox=0
    ):
    """
    Display some text in a proportional font with line wrapping at word breaks.
    This function is suitable for displaying general written text.

    The text parameter should be a string, or a list or tuple of lines to be
    displayed in the textbox.
    """

    if msg == None: msg = ""
    if title == None: title = ""

    global boxRoot, __replyButtonText, __widgetTexts, buttonsFrame
    global rootWindowPosition
    choices = ["OK"]
    __replyButtonText = choices[0]


    boxRoot = Tk()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )

    screen_width = boxRoot.winfo_screenwidth()
    screen_height = boxRoot.winfo_screenheight()
    root_width = int((screen_width * 0.8))
    root_height = int((screen_height * 0.5))
    root_xpos = int((screen_width * 0.1))
    root_ypos = int((screen_height * 0.05))

    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    rootWindowPosition = "+0+0"
    boxRoot.geometry(rootWindowPosition)
    boxRoot.expand=NO
    boxRoot.minsize(root_width, root_height)
    rootWindowPosition = "+" + str(root_xpos) + "+" + str(root_ypos)
    boxRoot.geometry(rootWindowPosition)

    mainframe = Frame(master=boxRoot)
    mainframe.pack(side=TOP, fill=BOTH, expand=YES)

    # ----  put frames in the window -----------------------------------
    # we pack the textboxFrame first, so it will expand first
    textboxFrame = Frame(mainframe, borderwidth=3)
    textboxFrame.pack(side=BOTTOM , fill=BOTH, expand=YES)

    message_and_buttonsFrame = Frame(mainframe)
    message_and_buttonsFrame.pack(side=TOP, fill=X, expand=NO)

    messageFrame = Frame(message_and_buttonsFrame)
    messageFrame.pack(side=LEFT, fill=X, expand=YES)

    buttonsFrame = Frame(message_and_buttonsFrame)
    buttonsFrame.pack(side=RIGHT, expand=NO)

    # -------------------- put widgets in the frames --------------------

    # put a textArea in the top frame
    if codebox:
        character_width = int((root_width * 0.6) / MONOSPACE_FONT_SIZE)
        textArea = Text(textboxFrame,height=25,width=character_width, padx="2m", pady="1m")
        textArea.configure(wrap=NONE)
        textArea.configure(font=(MONOSPACE_FONT_FAMILY, MONOSPACE_FONT_SIZE))

    else:
        character_width = int((root_width * 0.6) / MONOSPACE_FONT_SIZE)
        textArea = Text(
            textboxFrame
            , height=25
            , width=character_width
            , padx="2m"
            , pady="1m"
            )
        textArea.configure(wrap=WORD)
        textArea.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))


    # some simple keybindings for scrolling
    mainframe.bind("<Next>" , textArea.yview_scroll( 1,PAGES))
    mainframe.bind("<Prior>", textArea.yview_scroll(-1,PAGES))

    mainframe.bind("<Right>", textArea.xview_scroll( 1,PAGES))
    mainframe.bind("<Left>" , textArea.xview_scroll(-1,PAGES))

    mainframe.bind("<Down>", textArea.yview_scroll( 1,UNITS))
    mainframe.bind("<Up>"  , textArea.yview_scroll(-1,UNITS))


    # add a vertical scrollbar to the frame
    rightScrollbar = Scrollbar(textboxFrame, orient=VERTICAL, command=textArea.yview)
    textArea.configure(yscrollcommand = rightScrollbar.set)

    # add a horizontal scrollbar to the frame
    bottomScrollbar = Scrollbar(textboxFrame, orient=HORIZONTAL, command=textArea.xview)
    textArea.configure(xscrollcommand = bottomScrollbar.set)

    # pack the textArea and the scrollbars.  Note that although we must define
    # the textArea first, we must pack it last, so that the bottomScrollbar will
    # be located properly.

    # Note that we need a bottom scrollbar only for code.
    # Text will be displayed with wordwrap, so we don't need to have a horizontal
    # scroll for it.
    if codebox:
        bottomScrollbar.pack(side=BOTTOM, fill=X)
    rightScrollbar.pack(side=RIGHT, fill=Y)

    textArea.pack(side=LEFT, fill=BOTH, expand=YES)


    # ---------- put a msg widget in the msg frame-------------------
    messageWidget = Message(messageFrame, anchor=NW, text=msg, width=int(root_width * 0.9))
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=LEFT, expand=YES, fill=BOTH, padx='1m', pady='1m')

    # put the buttons in the buttonsFrame
    okButton = Button(buttonsFrame, takefocus=YES, text="OK", height=1, width=6)
    okButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __textboxOK
    for selectionEvent in ["Return","Button-1","Escape"]:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ----------------- the action begins ----------------------------------------
    try:
        # load the text into the textArea
        if type(text) == type("abc"): pass
        else:
            try:
                text = "".join(text)  # convert a list or a tuple to a string
            except:
                msgbox("Exception when trying to convert "+ str(type(text)) + " to text in textArea")
                sys.exit(16)
        textArea.insert(END,text, "normal")

    except:
        msgbox("Exception when trying to load the textArea.")
        sys.exit(16)

    try:
        okButton.focus_force()
    except:
        msgbox("Exception when trying to put focus on okButton.")
        sys.exit(16)

    boxRoot.mainloop()

    # this line MUST go before the line that destroys boxRoot
    areaText = textArea.get(0.0,END)
    boxRoot.destroy()
    return areaText # return __replyButtonText

#-------------------------------------------------------------------
# __textboxOK
#-------------------------------------------------------------------
def __textboxOK(event):
    global boxRoot
    boxRoot.quit()



#-------------------------------------------------------------------
# diropenbox
#-------------------------------------------------------------------
def diropenbox(msg=None
    , title=None
    , default=None
    ):
    """
    A dialog to get a directory name.
    Note that the msg argument, if specified, is ignored.

    Returns the name of a directory, or None if user chose to cancel.

    If the "default" argument specifies a directory name, and that
    directory exists, then the dialog box will start with that directory.
    """
    title=getFileDialogTitle(msg,title)
    boxRoot = Tk()
    boxRoot.withdraw()
    if not default: default = None
    f = tk_FileDialog.askdirectory(
          parent=boxRoot
        , title=title
        , initialdir=default
        , initialfile=None
        )
    boxRoot.destroy()
    if not f: return None
    return os.path.normpath(f)



#-------------------------------------------------------------------
# getFileDialogTitle
#-------------------------------------------------------------------
def getFileDialogTitle(msg
    , title
    ):
    if msg and title: return "%s - %s" % (title,msg)
    if msg and not title: return str(msg)
    if title and not msg: return str(title)
    return None # no message and no title

#-------------------------------------------------------------------
# class FileTypeObject for use with fileopenbox
#-------------------------------------------------------------------
class FileTypeObject:
    def __init__(self,filemask):
        if len(filemask) == 0:
            raise AssertionError('Filetype argument is empty.')

        self.masks = []

        if type(filemask) == type("abc"):  # a string
            self.initializeFromString(filemask)

        elif type(filemask) == type([]): # a list
            if len(filemask) < 2:
                raise AssertionError('Invalid filemask.\n'
                +'List contains less than 2 members: "%s"' % filemask)
            else:
                self.name  = filemask[-1]
                self.masks = list(filemask[:-1] )
        else:
            raise AssertionError('Invalid filemask: "%s"' % filemask)

    def __eq__(self,other):
        if self.name == other.name: return True
        return False

    def add(self,other):
        for mask in other.masks:
            if mask in self.masks: pass
            else: self.masks.append(mask)

    def toTuple(self):
        return (self.name,tuple(self.masks))

    def isAll(self):
        if self.name == "All files": return True
        return False

    def initializeFromString(self, filemask):
        # remove everything except the extension from the filemask
        self.ext = os.path.splitext(filemask)[1]
        if self.ext == "" : self.ext = ".*"
        if self.ext == ".": self.ext = ".*"
        self.name = self.getName()
        self.masks = ["*" + self.ext]

    def getName(self):
        e = self.ext
        if e == ".*"  : return "All files"
        if e == ".txt": return "Text files"
        if e == ".py" : return "Python files"
        if e == ".pyc" : return "Python files"
        if e == ".xls": return "Excel files"
        if e.startswith("."):
            return e[1:].upper() + " files"
        return e.upper() + " files"


#-------------------------------------------------------------------
# fileopenbox
#-------------------------------------------------------------------
def fileopenbox(msg=None
    , title=None
    , default="*"
    , filetypes=None
    ):
    """
    A dialog to get a file name.

    About the "default" argument
    ============================
        The "default" argument specifies a filepath that (normally)
        contains one or more wildcards.
        fileopenbox will display only files that match the default filepath.
        If omitted, defaults to "*" (all files in the current directory).

        WINDOWS EXAMPLE::
            ...default="c:/myjunk/*.py"
        will open in directory c:\myjunk\ and show all Python files.

        WINDOWS EXAMPLE::
            ...default="c:/myjunk/test*.py"
        will open in directory c:\myjunk\ and show all Python files
        whose names begin with "test".


        Note that on Windows, fileopenbox automatically changes the path
        separator to the Windows path separator (backslash).

    About the "filetypes" argument
    ==============================
        If specified, it should contain a list of items,
        where each item is either::
            - a string containing a filemask          # e.g. "*.txt"
            - a list of strings, where all of the strings except the last one
                are filemasks (each beginning with "*.",
                such as "*.txt" for text files, "*.py" for Python files, etc.).
                and the last string contains a filetype description

        EXAMPLE::
            filetypes = ["*.css", ["*.htm", "*.html", "HTML files"]  ]

    NOTE THAT
    =========

        If the filetypes list does not contain ("All files","*"),
        it will be added.

        If the filetypes list does not contain a filemask that includes
        the extension of the "default" argument, it will be added.
        For example, if     default="*abc.py"
        and no filetypes argument was specified, then
        "*.py" will automatically be added to the filetypes argument.

    @rtype: string or None
    @return: the name of a file, or None if user chose to cancel

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg default: filepath with wildcards
    @arg filetypes: filemasks that a user can choose, e.g. "*.txt"
    """
    boxRoot = Tk()
    boxRoot.withdraw()

    initialbase, initialfile, initialdir, filetypes = fileboxSetup(default,filetypes)

    #------------------------------------------------------------
    # if initialfile contains no wildcards; we don't want an
    # initial file. It won't be used anyway.
    # Also: if initialbase is simply "*", we don't want an
    # initialfile; it is not doing any useful work.
    #------------------------------------------------------------
    if (initialfile.find("*") < 0) and (initialfile.find("?") < 0):
        initialfile = None
    elif initialbase == "*":
        initialfile = None

    f = tk_FileDialog.askopenfilename(parent=boxRoot
        , title=getFileDialogTitle(msg,title)
        , initialdir=initialdir
        , initialfile=initialfile
        , filetypes=filetypes
        )

    boxRoot.destroy()

    if not f: return None
    return os.path.normpath(f)


#-------------------------------------------------------------------
# filesavebox
#-------------------------------------------------------------------
def filesavebox(msg=None
    , title=None
    , default=""
    , filetypes=None
    ):
    """
    A file to get the name of a file to save.
    Returns the name of a file, or None if user chose to cancel.

    The "default" argument should contain a filename (i.e. the
    current name of the file to be saved).  It may also be empty,
    or contain a filemask that includes wildcards.

    The "filetypes" argument works like the "filetypes" argument to
    fileopenbox.
    """

    boxRoot = Tk()
    boxRoot.withdraw()

    initialbase, initialfile, initialdir, filetypes = fileboxSetup(default,filetypes)

    f = tk_FileDialog.asksaveasfilename(parent=boxRoot
        , title=getFileDialogTitle(msg,title)
        , initialfile=initialfile
        , initialdir=initialdir
        , filetypes=filetypes
        )
    boxRoot.destroy()
    if not f: return None
    return os.path.normpath(f)


#-------------------------------------------------------------------
#
# fileboxSetup
#
#-------------------------------------------------------------------
def fileboxSetup(default,filetypes):
    if not default: default = os.path.join(".","*")
    initialdir, initialfile = os.path.split(default)
    if not initialdir : initialdir  = "."
    if not initialfile: initialfile = "*"
    initialbase, initialext = os.path.splitext(initialfile)
    initialFileTypeObject = FileTypeObject(initialfile)

    allFileTypeObject = FileTypeObject("*")
    ALL_filetypes_was_specified = False

    if not filetypes: filetypes= []
    filetypeObjects = []

    for filemask in filetypes:
        fto = FileTypeObject(filemask)

        if fto.isAll():
            ALL_filetypes_was_specified = True # remember this

        if fto == initialFileTypeObject:
            initialFileTypeObject.add(fto) # add fto to initialFileTypeObject
        else:
            filetypeObjects.append(fto)

    #------------------------------------------------------------------
    # make sure that the list of filetypes includes the ALL FILES type.
    #------------------------------------------------------------------
    if ALL_filetypes_was_specified:
        pass
    elif allFileTypeObject == initialFileTypeObject:
        pass
    else:
        filetypeObjects.insert(0,allFileTypeObject)
    #------------------------------------------------------------------
    # Make sure that the list includes the initialFileTypeObject
    # in the position in the list that will make it the default.
    # This changed between Python version 2.5 and 2.6
    #------------------------------------------------------------------
    if len(filetypeObjects) == 0:
        filetypeObjects.append(initialFileTypeObject)

    if initialFileTypeObject in (filetypeObjects[0], filetypeObjects[-1]):
        pass
    else:
        if runningPython26:
            filetypeObjects.append(initialFileTypeObject)
        else:
            filetypeObjects.insert(0,initialFileTypeObject)

    filetypes = [fto.toTuple() for fto in filetypeObjects]

    return initialbase, initialfile, initialdir, filetypes

#-------------------------------------------------------------------
# utility routines
#-------------------------------------------------------------------
# These routines are used by several other functions in the EasyGui module.

def __buttonEvent(event):
    """
    Handle an event that is generated by a person clicking a button.
    """
    global  boxRoot, __widgetTexts, __replyButtonText
    __replyButtonText = __widgetTexts[event.widget]
    boxRoot.quit() # quit the main loop


def __put_buttons_in_buttonframe(choices):
    """Put the buttons in the buttons frame
    """
    global __widgetTexts, __firstWidget, buttonsFrame

    __firstWidget = None
    __widgetTexts = {}

    i = 0

    for buttonText in choices:
        tempButton = Button(buttonsFrame, takefocus=1, text=buttonText)
        bindArrows(tempButton)
        tempButton.pack(expand=YES, side=LEFT, padx='1m', pady='1m', ipadx='2m', ipady='1m')

        # remember the text associated with this widget
        __widgetTexts[tempButton] = buttonText

        # remember the first widget, so we can put the focus there
        if i == 0:
            __firstWidget = tempButton
            i = 1

        # for the commandButton, bind activation events to the activation event handler
        commandButton  = tempButton
        handler = __buttonEvent
        for selectionEvent in STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

#-----------------------------------------------------------------------
#
#     class EgStore
#
#-----------------------------------------------------------------------
class EgStore:
    r"""
A class to support persistent storage.

You can use EgStore to support the storage and retrieval
of user settings for an EasyGui application.


# Example A
#-----------------------------------------------------------------------
# define a class named Settings as a subclass of EgStore
#-----------------------------------------------------------------------
class Settings(EgStore):

    def __init__(self, filename):  # filename is required
        #-------------------------------------------------
        # Specify default/initial values for variables that
        # this particular application wants to remember.
        #-------------------------------------------------
        self.userId = ""
        self.targetServer = ""

        #-------------------------------------------------
        # For subclasses of EgStore, these must be
        # the last two statements in  __init__
        #-------------------------------------------------
        self.filename = filename  # this is required
        self.restore()            # restore values from the storage file if possible



# Example B
#-----------------------------------------------------------------------
# create settings, a persistent Settings object
#-----------------------------------------------------------------------
settingsFile = "myApp_settings.txt"
settings = Settings(settingsFile)

user    = "obama_barak"
server  = "whitehouse1"
settings.userId = user
settings.targetServer = server
settings.store()    # persist the settings

# run code that gets a new value for userId, and persist the settings
user    = "biden_joe"
settings.userId = user
settings.store()


# Example C
#-----------------------------------------------------------------------
# recover the Settings instance, change an attribute, and store it again.
#-----------------------------------------------------------------------
settings = Settings(settingsFile)
settings.userId = "vanrossum_g"
settings.store()

"""
    def __init__(self, filename):  # obtaining filename is required
        raise NotImplementedError()

    def restore(self):
        """
        Set the values of whatever attributes are recoverable
        from the pickle file.

        Populate the attributes (the __dict__) of the EgStore object
        from     the attributes (the __dict__) of the pickled object.

        If the pickled object has attributes that have been initialized
        in the EgStore object, then those attributes of the EgStore object
        will be replaced by the values of the corresponding attributes
        in the pickled object.

        If the pickled object is missing some attributes that have
        been initialized in the EgStore object, then those attributes
        of the EgStore object will retain the values that they were
        initialized with.

        If the pickled object has some attributes that were not
        initialized in the EgStore object, then those attributes
        will be ignored.

        IN SUMMARY:

        After the recover() operation, the EgStore object will have all,
        and only, the attributes that it had when it was initialized.

        Where possible, those attributes will have values recovered
        from the pickled object.
        """
        if not os.path.exists(self.filename): return self
        if not os.path.isfile(self.filename): return self

        try:
            f = open(self.filename,"rb")
            unpickledObject = pickle.load(f)
            f.close()

            for key in list(self.__dict__.keys()):
                default = self.__dict__[key]
                self.__dict__[key] = unpickledObject.__dict__.get(key,default)
        except:
            pass

        return self

    def store(self):
        """
        Save the attributes of the EgStore object to a pickle file.
        Note that if the directory for the pickle file does not already exist,
        the store operation will fail.
        """
        f = open(self.filename, "wb")
        pickle.dump(self, f)
        f.close()


    def kill(self):
        """
        Delete my persistent file (i.e. pickle file), if it exists.
        """
        if os.path.isfile(self.filename):
            os.remove(self.filename)
        return

    def __str__(self):
        """
        return my contents as a string in an easy-to-read format.
        """
        # find the length of the longest attribute name
        longest_key_length = 0
        keys = []
        for key in self.__dict__.keys():
            keys.append(key)
            longest_key_length = max(longest_key_length, len(key))

        keys.sort()  # sort the attribute names
        lines = []
        for key in keys:
            value = self.__dict__[key]
            key = key.ljust(longest_key_length)
            lines.append("%s : %s\n" % (key,repr(value))  )
        return "".join(lines)  # return a string showing the attributes




#-----------------------------------------------------------------------
#
# test/demo easygui
#
#-----------------------------------------------------------------------
def egdemo():
    """
    Run the EasyGui demo.
    """
    # clear the console
    writeln("\n" * 100)

    intro_message = ("Pick the kind of box that you wish to demo.\n"
    + "\n * Python version " + sys.version
    + "\n * EasyGui version " + egversion
    + "\n * Tk version " + str(TkVersion)
    )

    #========================================== END DEMONSTRATION DATA


    while 1: # do forever
        choices = [
            "msgbox",
            "buttonbox",
            "buttonbox(image) -- a buttonbox that displays an image",
            "choicebox",
            "multchoicebox",
            "textbox",
            "ynbox",
            "ccbox",
            "enterbox",
            "enterbox(image) -- an enterbox that displays an image",
            "exceptionbox",
            "codebox",
            "integerbox",
            "boolbox",
            "indexbox",
            "filesavebox",
            "fileopenbox",
            "passwordbox",
            "multenterbox",
            "multpasswordbox",
            "diropenbox",
            "About EasyGui",
            " Help"
            ]
        choice = choicebox(msg=intro_message
            , title="EasyGui " + egversion
            , choices=choices)

        if not choice: return

        reply = choice.split()

        if   reply[0] == "msgbox":
            reply = msgbox("short msg", "This is a long title")
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "About":
            reply = abouteasygui()

        elif reply[0] == "Help":
            _demo_help()

        elif reply[0] == "buttonbox":
            reply = buttonbox()
            writeln("Reply was: %s" % repr(reply))

            title = "Demo of Buttonbox with many, many buttons!"
            msg = "This buttonbox shows what happens when you specify too many buttons."
            reply = buttonbox(msg=msg, title=title, choices=choices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "buttonbox(image)":
            _demo_buttonbox_with_image()

        elif reply[0] == "boolbox":
            reply = boolbox()
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "enterbox":
            image = "python_and_check_logo.gif"
            message = "Enter the name of your best friend."\
                      "\n(Result will be stripped.)"
            reply = enterbox(message, "Love!", "     Suzy Smith     ")
            writeln("Reply was: %s" % repr(reply))

            message = "Enter the name of your best friend."\
                      "\n(Result will NOT be stripped.)"
            reply = enterbox(message, "Love!", "     Suzy Smith     ",strip=False)
            writeln("Reply was: %s" % repr(reply))

            reply = enterbox("Enter the name of your worst enemy:", "Hate!")
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "enterbox(image)":
            image = "python_and_check_logo.gif"
            message = "What kind of snake is this?"
            reply = enterbox(message, "Quiz",image=image)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "exceptionbox":
            try:
                thisWillCauseADivideByZeroException = 1/0
            except:
                exceptionbox()

        elif reply[0] == "integerbox":
            reply = integerbox(
                "Enter a number between 3 and 333",
                "Demo: integerbox WITH a default value",
                222, 3, 333)
            writeln("Reply was: %s" % repr(reply))

            reply = integerbox(
                "Enter a number between 0 and 99",
                "Demo: integerbox WITHOUT a default value"
                )
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "diropenbox" : _demo_diropenbox()
        elif reply[0] == "fileopenbox": _demo_fileopenbox()
        elif reply[0] == "filesavebox": _demo_filesavebox()

        elif reply[0] == "indexbox":
            title = reply[0]
            msg   =  "Demo of " + reply[0]
            choices = ["Choice1", "Choice2", "Choice3", "Choice4"]
            reply = indexbox(msg, title, choices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "passwordbox":
            reply = passwordbox("Demo of password box WITHOUT default"
                + "\n\nEnter your secret password", "Member Logon")
            writeln("Reply was: %s" % str(reply))

            reply = passwordbox("Demo of password box WITH default"
                + "\n\nEnter your secret password", "Member Logon", "alfie")
            writeln("Reply was: %s" % str(reply))

        elif reply[0] == "multenterbox":
            msg = "Enter your personal information"
            title = "Credit Card Application"
            fieldNames = ["Name","Street Address","City","State","ZipCode"]
            fieldValues = []  # we start with blanks for the values
            fieldValues = multenterbox(msg,title, fieldNames)

            # make sure that none of the fields was left blank
            while 1:
                if fieldValues == None: break
                errmsg = ""
                for i in range(len(fieldNames)):
                    if fieldValues[i].strip() == "":
                        errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
                fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)

            writeln("Reply was: %s" % str(fieldValues))

        elif reply[0] == "multpasswordbox":
            msg = "Enter logon information"
            title = "Demo of multpasswordbox"
            fieldNames = ["Server ID", "User ID", "Password"]
            fieldValues = []  # we start with blanks for the values
            fieldValues = multpasswordbox(msg,title, fieldNames)

            # make sure that none of the fields was left blank
            while 1:
                if fieldValues == None: break
                errmsg = ""
                for i in range(len(fieldNames)):
                    if fieldValues[i].strip() == "":
                        errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
                fieldValues = multpasswordbox(errmsg, title, fieldNames, fieldValues)

            writeln("Reply was: %s" % str(fieldValues))

        elif reply[0] == "ynbox":
            title = "Demo of ynbox"
            msg = "Were you expecting the Spanish Inquisition?"
            reply = ynbox(msg, title)
            writeln("Reply was: %s" % repr(reply))
            if reply:
                msgbox("NOBODY expects the Spanish Inquisition!", "Wrong!")

        elif reply[0] == "ccbox":
            title = "Demo of ccbox"
            reply = ccbox(msg,title)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "choicebox":
            title = "Demo of choicebox"
            longchoice = "This is an example of a very long option which you may or may not wish to choose."*2
            listChoices = ["nnn", "ddd", "eee", "fff", "aaa", longchoice
                    , "aaa", "bbb", "ccc", "ggg", "hhh", "iii", "jjj", "kkk", "LLL", "mmm" , "nnn", "ooo", "ppp", "qqq", "rrr", "sss", "ttt", "uuu", "vvv"]

            msg = "Pick something. " + ("A wrapable sentence of text ?! "*30) + "\nA separate line of text."*6
            reply = choicebox(msg=msg, choices=listChoices)
            writeln("Reply was: %s" % repr(reply))

            msg = "Pick something. "
            reply = choicebox(msg=msg, title=title, choices=listChoices)
            writeln("Reply was: %s" % repr(reply))

            msg = "Pick something. "
            reply = choicebox(msg="The list of choices is empty!", choices=[])
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "multchoicebox":
            listChoices = ["aaa", "bbb", "ccc", "ggg", "hhh", "iii", "jjj", "kkk"
                , "LLL", "mmm" , "nnn", "ooo", "ppp", "qqq"
                , "rrr", "sss", "ttt", "uuu", "vvv"]

            msg = "Pick as many choices as you wish."
            reply = multchoicebox(msg,"Demo of multchoicebox", listChoices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "textbox": _demo_textbox(reply[0])
        elif reply[0] == "codebox": _demo_codebox(reply[0])

        else:
            msgbox("Choice\n\n" + choice + "\n\nis not recognized", "Program Logic Error")
            return


def _demo_textbox(reply):
    text_snippet = ((\
"""It was the best of times, and it was the worst of times.  The rich ate cake, and the poor had cake recommended to them, but wished only for enough cash to buy bread.  The time was ripe for revolution! """ \
*5)+"\n\n")*10
    title = "Demo of textbox"
    msg = "Here is some sample text. " * 16
    reply = textbox(msg, "Text Sample", text_snippet)
    writeln("Reply was: %s" % str(reply))

def _demo_codebox(reply):
    code_snippet = ("dafsdfa dasflkj pp[oadsij asdfp;ij asdfpjkop asdfpok asdfpok asdfpok"*3) +"\n"+\
"""# here is some dummy Python code
for someItem in myListOfStuff:
    do something(someItem)
    do something()
    do something()
    if somethingElse(someItem):
        doSomethingEvenMoreInteresting()

"""*16
    msg = "Here is some sample code. " * 16
    reply = codebox(msg, "Code Sample", code_snippet)
    writeln("Reply was: %s" % repr(reply))


def _demo_buttonbox_with_image():
    image = "python_and_check_logo.gif"

    msg   = "Pretty nice, huh!"
    reply=msgbox(msg,image=image, ok_button="Wow!")
    writeln("Reply was: %s" % repr(reply))

    msg   = "Do you like this picture?"
    choices = ["Yes","No","No opinion"]

    reply=buttonbox(msg,image=image,choices=choices)
    writeln("Reply was: %s" % repr(reply))

    image = os.path.normpath("python_and_check_logo.png")
    reply=buttonbox(msg,image=image, choices=choices)
    writeln("Reply was: %s" % repr(reply))

    image = os.path.normpath("zzzzz.gif")
    reply=buttonbox(msg,image=image, choices=choices)
    writeln("Reply was: %s" % repr(reply))


def _demo_help():
    savedStdout = sys.stdout    # save the sys.stdout file object
    sys.stdout = capturedOutput = StringIO()
    help("easygui")
    sys.stdout = savedStdout   # restore the sys.stdout file object
    codebox("EasyGui Help",text=capturedOutput.getvalue())

def _demo_filesavebox():
    filename = "myNewFile.txt"
    title = "File SaveAs"
    msg ="Save file as:"

    f = filesavebox(msg,title,default=filename)
    writeln("You chose to save file: %s" % f)

def _demo_diropenbox():
    title = "Demo of diropenbox"
    msg = "Pick the directory that you wish to open."
    d = diropenbox(msg, title)
    writeln("You chose directory...: %s" % d)

    d = diropenbox(msg, title,default="./")
    writeln("You chose directory...: %s" % d)

    d = diropenbox(msg, title,default="c:/")
    writeln("You chose directory...: %s" % d)


def _demo_fileopenbox():
    msg  = "Python files"
    title = "Open files"
    default="*.py"
    f = fileopenbox(msg,title,default=default)
    writeln("You chose to open file: %s" % f)

    default="./*.gif"
    filetypes = ["*.jpg",["*.zip","*.tgs","*.gz", "Archive files"],["*.htm", "*.html","HTML files"]]
    f = fileopenbox(msg,title,default=default,filetypes=filetypes)
    writeln("You chose to open file: %s" % f)

    """#deadcode -- testing ----------------------------------------
    f = fileopenbox(None,None,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(None,title,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(msg,None,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(default=None)
    writeln("You chose to open file: %s" % f)
    #----------------------------------------------------deadcode """


def _dummy():
    pass

EASYGUI_ABOUT_INFORMATION = '''
========================================================================
0.96(2010-06-25)
========================================================================
This version fixes some problems with version independence.

BUG FIXES
------------------------------------------------------
 * A statement with Python 2.x-style exception-handling syntax raised
   a syntax error when running under Python 3.x.
   Thanks to David Williams for reporting this problem.

 * Under some circumstances, PIL was unable to display non-gif images
   that it should have been able to display.
   The cause appears to be non-version-independent import syntax.
   PIL modules are now imported with a version-independent syntax.
   Thanks to Horst Jens for reporting this problem.


========================================================================
0.95(2010-06-12)
========================================================================

ENHANCEMENTS
------------------------------------------------------
 * Previous versions of EasyGui could display only .gif image files using the
   msgbox "image" argument. This version can now display all image-file formats
   supported by PIL the Python Imaging Library) if PIL is installed.
   If msgbox is asked to open a non-gif image file, it attempts to import
   PIL and to use PIL to convert the image file to a displayable format.
   If PIL cannot be imported (probably because PIL is not installed)
   EasyGui displays an error message saying that PIL must be installed in order
   to display the image file.

   Note that
   http://www.pythonware.com/products/pil/
   says that PIL doesn't yet support Python 3.x.


========================================================================
0.94(2010-06-06)
========================================================================

ENHANCEMENTS
------------------------------------------------------
 * The codebox and textbox functions now return the contents of the box, rather
   than simply the name of the button ("Yes").  This makes it possible to use
   codebox and textbox as data-entry widgets.  A big "thank you!" to Dominic
   Comtois for requesting this feature, patiently explaining his requirement,
   and helping to discover the tkinter techniques to implement it.

   NOTE THAT in theory this change breaks backward compatibility.  But because
   (in previous versions of EasyGui) the value returned by codebox and textbox
   was meaningless, no application should have been checking it.  So in actual
   practice, this change should not break backward compatibility.

 * Added support for SPACEBAR to command buttons.  Now, when keyboard
   focus is on a command button, a press of the SPACEBAR will act like
   a press of the ENTER key; it will activate the command button.

 * Added support for keyboard navigation with the arrow keys (up,down,left,right)
   to the fields and buttons in enterbox, multenterbox and multpasswordbox,
   and to the buttons in choicebox and all buttonboxes.

 * added highlightthickness=2 to entry fields in multenterbox and
   multpasswordbox.  Now it is easier to tell which entry field has
   keyboard focus.


BUG FIXES
------------------------------------------------------
 * In EgStore, the pickle file is now opened with "rb" and "wb" rather than
   with "r" and "w".  This change is necessary for compatibility with Python 3+.
   Thanks to Marshall Mattingly for reporting this problem and providing the fix.

 * In integerbox, the actual argument names did not match the names described
   in the docstring. Thanks to Daniel Zingaro of at University of Toronto for
   reporting this problem.

 * In integerbox, the "argLowerBound" and "argUpperBound" arguments have been
   renamed to "lowerbound" and "upperbound" and the docstring has been corrected.

   NOTE THAT THIS CHANGE TO THE ARGUMENT-NAMES BREAKS BACKWARD COMPATIBILITY.
   If argLowerBound or argUpperBound are used, an AssertionError with an
   explanatory error message is raised.

 * In choicebox, the signature to choicebox incorrectly showed choicebox as
   accepting a "buttons" argument.  The signature has been fixed.


========================================================================
0.93(2009-07-07)
========================================================================

ENHANCEMENTS
------------------------------------------------------

 * Added exceptionbox to display stack trace of exceptions

 * modified names of some font-related constants to make it
   easier to customize them


========================================================================
0.92(2009-06-22)
========================================================================

ENHANCEMENTS
------------------------------------------------------

 * Added EgStore class to to provide basic easy-to-use persistence.

BUG FIXES
------------------------------------------------------

 * Fixed a bug that was preventing Linux users from copying text out of
   a textbox and a codebox.  This was not a problem for Windows users.

'''

def abouteasygui():
    """
    shows the easygui revision history
    """
    codebox("About EasyGui\n"+egversion,"EasyGui",EASYGUI_ABOUT_INFORMATION)
    return None



if __name__ == '__main__':
    if True:
        egdemo()
    else:
        # test the new root feature
        root = Tk()
        msg = """This is a test of a main Tk() window in which we will place an easygui msgbox.
                It will be an interesting experiment.\n\n"""
        messageWidget = Message(root, text=msg, width=1000)
        messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')
        messageWidget = Message(root, text=msg, width=1000)
        messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')


        msgbox("this is a test of passing in boxRoot", root=root)
        msgbox("this is a second test of passing in boxRoot", root=root)

        reply = enterbox("Enter something", root=root)
        writeln("You wrote:", reply)

        reply = enterbox("Enter something else", root=root)
        writeln("You wrote:", reply)
        root.destroy()

########NEW FILE########
__FILENAME__ = screensaver
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       screensaver.py
import pygame
import random

def screensaver(screenresolution = (640,480), fullscreen = False):
    # -*- coding: utf-8 -*-
    """very simple test "game" or screensaver.
       all the user have to do is press ESC or SPACE.
       the "game" paint random circles.
       the "game" accept a screen resolution tuple as argument.
       the "game" returns the time passed until the user pressed space"""
    pygame.init()                      #initialize pygame
    if fullscreen:
        screen=pygame.display.set_mode((screenresolution[0],screenresolution[1]), pygame.FULLSCREEN) # set screensize of pygame window
    else:
        screen=pygame.display.set_mode((screenresolution[0],screenresolution[1])) # set screensize of pygame window
    background = pygame.Surface(screen.get_size())  #create empty pygame surface
    background.fill((255,255,255))     #fill the background white color (red,green,blue)
    background = background.convert()  #convert Surface object to make blitting faster
    screen.blit(background, (0,0))     #draw the background on screen
    clock = pygame.time.Clock()        #create a pygame clock object
    mainloop = True                    
    FPS = 30 # desired framerate in frames per second. try out other values !
    playtime = 0.0 # how many seconds the "game" is played
    while mainloop:
        milliseconds = clock.tick(FPS) # do not go faster than this framerate
        playtime += milliseconds / 1000.0 # add seconds to playtime
        # paint random circles
        color = (random.randint(0,255), random.randint(0,255), random.randint(0,255))
        pygame.draw.circle(screen, color, (random.randint(0,screenresolution[0]),
                                           random.randint(0,screenresolution[1])),
                                           random.randint(1, min(screenresolution[0], screenresolution[1])),
                                           random.randint(0,1))        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                print "event key:", event.key
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
                if event.key == pygame.K_SPACE:
                    mainloop = False # user pressed ESC
        pygame.display.set_caption("press ESC to quit. FPS: %.2f (%ix%i), time: %.2f seonds" % (clock.get_fps(), screenresolution[0], screenresolution[1], playtime))
        pygame.display.flip()          # flip the screen like in a flip book
    print "This 'game' was played for %.2f seconds" % playtime
    pygame.quit()
    return playtime # in seconds

if __name__ == '__main__':
    screensaver()

########NEW FILE########
__FILENAME__ = gameOfLife
# Game of Life (was: Pygame Cheat Sheet)
# This program simulate the classic Conway'S Game of Life
# see http://en.wikipedia.org/wiki/Conway's_Game_of_Life
# pygame cheatsheet by Al Sweigart http://inventwithpython.com
# game by Horst JENS http://ThePythonGameBook
# bug hunting & making thinks work by yipyip
# license: gpl, see http://www.gnu.org/licenses/gpl.html


import pygame
import sys
import random

#from pygame.locals import *

pygame.init()
fpsClock = pygame.time.Clock()

screen = pygame.display.set_mode((640, 480))
pygame.display.set_caption("Conway's Game of Life")

msg = "Conway's Game of Life"
fontObj = pygame.font.Font("freesansbold.ttf", 32)
msg2 = "right click: toggle pause mode. left click while in pause mode: paint"
fontObj2 = pygame.font.Font("freesansbold.ttf", 14)

screen.fill((255,255,255)) # white
ymove = 50 # move playfield down to have room for text



cellA = {} # the playfield
#cellB = {}
#cellC = {}

maxX = 150 # maximum lenght of x dimension
maxY = 100 # maximum lenght of y dimension

# write text on screen
msgSurfaceObj = fontObj.render(msg, False, (0,0,255)) # blue
msgRectobj = msgSurfaceObj.get_rect()
msgRectobj.topleft = (10, 10)
screen.blit(msgSurfaceObj, msgRectobj)

helpTextObj = fontObj2.render(msg2, False, (0,0,255))
msgRectobj2 = helpTextObj.get_rect()
msgRectobj2.topleft = (10, ymove + maxY*4 + 10)
screen.blit(helpTextObj, msgRectobj2)

# pxSurfaceObj = pygame.surface.Surface((maxX, maxY))

#create 100 x 100 cells
# with random value
for x in range(maxX):    
    for y in range(maxY):
        cellA[x, y] = 0 # clean all

# make a copy of cellA
#cellB = cellA.copy() # full copy of clean
#cellC = cellA.copy() # a clean copy

for x in range(maxX):
    for x in range(maxX):
        for y in range(maxY):
            cellA[x, y] = random.choice([0,0,0,0,0,0,0,0,1]) # random pattern



# fill some random values in cella

def checkcell(c, x, y, direction):
    """check a neighboring cell and return it's value
       assuming a 100x100 playfield with wrap-around
       borders"""
    dx=0 # delta to calculate next cell
    dy=0 
    if direction == 0: # east
        if x == 0: 
            dx = maxX-1 
        else:
            dx = -1
    elif direction ==4: #west:
        if x == maxX-1:
            dx = -1 * (maxX-1)
        else:
            dx = 1
    elif direction ==2: # north
        if y ==0:
            dy = maxY-1
        else: dy = -1
    elif direction ==6: # south
        if y ==maxY-1:
            dy = -1 * (maxY - 1)
        else:
            dy = 1
    elif direction == 1: # northeast
        if y ==0:
            dy = maxY-1
        else: dy = -1
        if x == 0: 
            dx = maxX-1 
        else:
            dx = -1
    elif direction == 3: # northwest
        if y ==0:
            dy = maxY-1
        else: 
            dy = -1
        if x == maxX-1:
            dx = -1 * (maxX-1)
        else:
            dx = 1
    elif direction == 5: #southwest
        if x == maxX-1:
            dx = -1 * (maxX-1)
        else:
            dx = 1
        if y ==maxY-1:
            dy = -1 * (maxY - 1)
        else:
            dy = 1
    elif direction == 7: # southeast
        if x == 0: 
            dx = maxX-1 
        else:
            dx = -1
        if y ==maxY-1:
            dy = -1 * (maxY - 1)
        else:
            dy = 1
    else:
        print "wtf???"
    return c[x+dx, y+dy]

def paint(cells ):
    x = pygame.mouse.get_pos()[0]
    y = pygame.mouse.get_pos()[1]
    #print "x,y:", x,y
    if ( x < maxX*4 and 
         y < maxY*4 + ymove and
         y > ymove):
       #print x/4, (y-ymove)/4
       cells[x/4, (y-ymove)/4] = 1
    
        
def newvalue(ca, cb, x, y):
    """count the neighbors of a cell (8 directions). If too few or
    too many neighbors, the cell dies., else it become or stay alife.
    rules: 
    0 or 1 neigbors: cell dies because of underpopulation
    2 or 3 neigbors: cell stay alive
    4 or more cells: cell dies because of overpopulation
    3 neignors and cell dead: cell becomes alive.
    Returns 0 for a dead cell, 1 for an alive cell
    also see http://en.wikipedia.org/wiki/Conway's_Game_of_Life"""
    neighbors = 0
    for direction in range(8):
        neighbors += checkcell(ca, x,y,direction)
    # cell is dead and become alive ?
    if ca[x, y] == 0:
        if neighbors == 3:
            cb[x, y] = 1 # born again
            return 1
        else:
            cb[x, y] = 0 # stay dead
            return 0
    else:
        # cell is alive
        if neighbors < 2 or neighbors > 3:
            cb[x, y] = 0 # dead 
            return 0
        else:
            # stay alivie
            cb[x, y] = 1
            return 1
        
       


gameloop = True
old_cells = cellA
new_cells = {}
mousepainting = False
pause = False
while gameloop:

    if not pause:
        cellsum = 0
        # calculate cells birth and dead
        for x in range(maxX):
            for y in range(maxY):
                # cellsum is the number of alive cells in the whole playfield
                # in this frame
                cellsum += newvalue(old_cells, new_cells, x, y) # calculate values of CellB
    
    else:
        if mousepainting:
           paint(old_cells) 
    
    # paint the cells on the screen       
    for x in range(maxX):
        for y in range(maxY):
            color = pygame.Color(old_cells[x, y] * 255,0,0) # red or black
            ## paint 4 x 4 dots instead of 1 dot (fatx, faty) is the size of a dot
            pygame.draw.rect(screen, color, (x*4,ymove+y*4, 4,4), 0)
    
    if not pause:        
        old_cells  = new_cells
        new_cells = {}

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            gameloop = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                gameloop = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1: # left click
                if pause:
                   mousepainting = True
        elif event.type == pygame.MOUSEBUTTONUP:
            if event.button ==3: # right click
                pause = not pause # toggle
            if event.button ==1: # left click 
                if pause:
                   mousepainting = False
    
  
    if not pause:    
        statusmsg =  'Game of Life fps: %.2f cells:%i:%i' % (fpsClock.get_fps(), cellsum, 10000-cellsum)       
    else: 
        statusmsg = " pause mode. right-click to continue"
    pygame.display.set_caption(statusmsg)
    pygame.display.update()
    #pygame.display.flip()
    fpsClock.tick(30) # pause to run the loop at 30 frames per second

pygame.quit()
sys.exit()

########NEW FILE########
__FILENAME__ = easygui
"""
@version: 0.96(2010-06-25)
@note:
EasyGui provides an easy-to-use interface for simple GUI interaction
with a user.  It does not require the programmer to know anything about
tkinter, frames, widgets, callbacks or lambda.  All GUI interactions are
invoked by simple function calls that return results.


@note:
WARNING about using EasyGui with IDLE

You may encounter problems using IDLE to run programs that use EasyGui. Try it
and find out.  EasyGui is a collection of Tkinter routines that run their own
event loops.  IDLE is also a Tkinter application, with its own event loop.  The
two may conflict, with unpredictable results. If you find that you have
problems, try running your EasyGui program outside of IDLE.

Note that EasyGui requires Tk release 8.0 or greater.
"""
egversion = __doc__.split()[1]

__all__ = ['ynbox'
    , 'ccbox'
    , 'boolbox'
    , 'indexbox'
    , 'msgbox'
    , 'buttonbox'
    , 'integerbox'
    , 'multenterbox'
    , 'enterbox'
    , 'exceptionbox'
    , 'choicebox'
    , 'codebox'
    , 'textbox'
    , 'diropenbox'
    , 'fileopenbox'
    , 'filesavebox'
    , 'passwordbox'
    , 'multpasswordbox'
    , 'multchoicebox'
    , 'abouteasygui'
    , 'egversion'
    , 'egdemo'
    , 'EgStore'
    ]

import sys, os, string, types, pickle,traceback
import pprint

#--------------------------------------------------
# check python version and take appropriate action
#--------------------------------------------------
"""
From the python documentation:

sys.hexversion contains the version number encoded as a single integer. This is
guaranteed to increase with each version, including proper support for non-
production releases. For example, to test that the Python interpreter is at
least version 1.5.2, use:

if sys.hexversion >= 0x010502F0:
    # use some advanced feature
    ...
else:
    # use an alternative implementation or warn the user
    ...
"""


if sys.hexversion >= 0x020600F0:
    runningPython26 = True
else:
    runningPython26 = False

if sys.hexversion >= 0x030000F0:
    runningPython3 = True
else:
    runningPython3 = False


if runningPython3:
    from tkinter import *
    import tkinter.filedialog as tk_FileDialog
    from io import StringIO
else:
    from Tkinter import *
    import tkFileDialog as tk_FileDialog
    from StringIO import StringIO

def write(*args):
    args = [str(arg) for arg in args]
    args = " ".join(args)
    sys.stdout.write(args)

def writeln(*args):
    write(*args)
    sys.stdout.write("\n")

say = writeln


if TkVersion < 8.0 :
    stars = "*"*75
    writeln("""\n\n\n""" + stars + """
You are running Tk version: """ + str(TkVersion) + """
You must be using Tk version 8.0 or greater to use EasyGui.
Terminating.
""" + stars + """\n\n\n""")
    sys.exit(0)

def dq(s):
    return '"%s"' % s

rootWindowPosition = "+300+200"

PROPORTIONAL_FONT_FAMILY = ("MS", "Sans", "Serif")
MONOSPACE_FONT_FAMILY    = ("Courier")

PROPORTIONAL_FONT_SIZE  = 10
MONOSPACE_FONT_SIZE     =  9  #a little smaller, because it it more legible at a smaller size
TEXT_ENTRY_FONT_SIZE    = 12  # a little larger makes it easier to see

#STANDARD_SELECTION_EVENTS = ["Return", "Button-1"]
STANDARD_SELECTION_EVENTS = ["Return", "Button-1", "space"]

# Initialize some global variables that will be reset later
__choiceboxMultipleSelect = None
__widgetTexts = None
__replyButtonText = None
__choiceboxResults = None
__firstWidget = None
__enterboxText = None
__enterboxDefaultText=""
__multenterboxText = ""
choiceboxChoices = None
choiceboxWidget = None
entryWidget = None
boxRoot = None
ImageErrorMsg = (
    "\n\n---------------------------------------------\n"
    "Error: %s\n%s")
#-------------------------------------------------------------------
# various boxes built on top of the basic buttonbox
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# ynbox
#-----------------------------------------------------------------------
def ynbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes", "No")
    , image=None
    ):
    """
    Display a msgbox with choices of Yes and No.

    The default is "Yes".

    The returned value is calculated this way::
        if the first choice ("Yes") is chosen, or if the dialog is cancelled:
            return 1
        else:
            return 0

    If invoked without a msg argument, displays a generic request for a confirmation
    that the user wishes to continue.  So it can be used this way::
        if ynbox(): pass # continue
        else: sys.exit(0)  # exit the program

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    return boolbox(msg, title, choices, image=image)


#-----------------------------------------------------------------------
# ccbox
#-----------------------------------------------------------------------
def ccbox(msg="Shall I continue?"
    , title=" "
    , choices=("Continue", "Cancel")
    , image=None
    ):
    """
    Display a msgbox with choices of Continue and Cancel.

    The default is "Continue".

    The returned value is calculated this way::
        if the first choice ("Continue") is chosen, or if the dialog is cancelled:
            return 1
        else:
            return 0

    If invoked without a msg argument, displays a generic request for a confirmation
    that the user wishes to continue.  So it can be used this way::

        if ccbox():
            pass # continue
        else:
            sys.exit(0)  # exit the program

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    return boolbox(msg, title, choices, image=image)


#-----------------------------------------------------------------------
# boolbox
#-----------------------------------------------------------------------
def boolbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes","No")
    , image=None
    ):
    """
    Display a boolean msgbox.

    The default is the first choice.

    The returned value is calculated this way::
        if the first choice is chosen, or if the dialog is cancelled:
            returns 1
        else:
            returns 0
    """
    reply = buttonbox(msg=msg, choices=choices, title=title, image=image)
    if reply == choices[0]: return 1
    else: return 0


#-----------------------------------------------------------------------
# indexbox
#-----------------------------------------------------------------------
def indexbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes","No")
    , image=None
    ):
    """
    Display a buttonbox with the specified choices.
    Return the index of the choice selected.
    """
    reply = buttonbox(msg=msg, choices=choices, title=title, image=image)
    index = -1
    for choice in choices:
        index = index + 1
        if reply == choice: return index
    raise AssertionError(
        "There is a program logic error in the EasyGui code for indexbox.")


#-----------------------------------------------------------------------
# msgbox
#-----------------------------------------------------------------------
def msgbox(msg="(Your message goes here)", title=" ", ok_button="OK",image=None,root=None):
    """
    Display a messagebox
    """
    if type(ok_button) != type("OK"):
        raise AssertionError("The 'ok_button' argument to msgbox must be a string.")

    return buttonbox(msg=msg, title=title, choices=[ok_button], image=image,root=root)


#-------------------------------------------------------------------
# buttonbox
#-------------------------------------------------------------------
def buttonbox(msg="",title=" "
    ,choices=("Button1", "Button2", "Button3")
    , image=None
    , root=None
    ):
    """
    Display a msg, a title, and a set of buttons.
    The buttons are defined by the members of the choices list.
    Return the text of the button that the user selected.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    global boxRoot, __replyButtonText, __widgetTexts, buttonsFrame


    # Initialize __replyButtonText to the first choice.
    # This is what will be used if the window is closed by the close button.
    __replyButtonText = choices[0]

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.minsize(400, 100)

    # ------------- define the messageFrame ---------------------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the imageFrame ---------------------------------


    tk_Image = None
    if image:
        imageFilename = os.path.normpath(image)
        junk,ext = os.path.splitext(imageFilename)

        if os.path.exists(imageFilename):
            if ext.lower() in [".gif", ".pgm", ".ppm"]:
                tk_Image = PhotoImage(file=imageFilename)
            else:
                try:
                    from PIL import Image   as PILImage
                    from PIL import ImageTk as PILImageTk
                    PILisLoaded = True
                except:
                    PILisLoaded = False

                if PILisLoaded:
                    try:
                        pil_Image = PILImage.open(imageFilename)
                        tk_Image = PILImageTk.PhotoImage(pil_Image)
                    except:
                        msg += ImageErrorMsg % (imageFilename,
                            "\nThe Python Imaging Library (PIL) could not convert this file to a displayable image."
                            "\n\nPIL reports:\n" + exception_format())

                else:  # PIL is not loaded
                    msg += ImageErrorMsg % (imageFilename,
                    "\nI could not import the Python Imaging Library (PIL) to display the image.\n\n"
                    "You may need to install PIL\n"
                    "(http://www.pythonware.com/products/pil/)\n"
                    "to display " + ext + " image files.")

        else:
            msg += ImageErrorMsg % (imageFilename, "\nImage file not found.")

    if tk_Image:
        imageFrame = Frame(master=boxRoot)
        imageFrame.pack(side=TOP, fill=BOTH)
        label = Label(imageFrame,image=tk_Image)
        label.image = tk_Image # keep a reference!
        label.pack(side=TOP, expand=YES, fill=X, padx='1m', pady='1m')

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    # -------------------- place the widgets in the frames -----------------------
    messageWidget = Message(messageFrame, text=msg, width=400)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')

    __put_buttons_in_buttonframe(choices)

    # -------------- the action begins -----------
    # put the focus on the first button
    __firstWidget.focus_force()

    boxRoot.deiconify()
    boxRoot.mainloop()
    boxRoot.destroy()
    if root: root.deiconify()
    return __replyButtonText


#-------------------------------------------------------------------
# integerbox
#-------------------------------------------------------------------
def integerbox(msg=""
    , title=" "
    , default=""
    , lowerbound=0
    , upperbound=99
    , image = None
    , root  = None
    , **invalidKeywordArguments
    ):
    """
    Show a box in which a user can enter an integer.

    In addition to arguments for msg and title, this function accepts
    integer arguments for "default", "lowerbound", and "upperbound".

    The default argument may be None.

    When the user enters some text, the text is checked to verify that it
    can be converted to an integer between the lowerbound and upperbound.

    If it can be, the integer (not the text) is returned.

    If it cannot, then an error msg is displayed, and the integerbox is
    redisplayed.

    If the user cancels the operation, None is returned.

    NOTE that the "argLowerBound" and "argUpperBound" arguments are no longer
    supported.  They have been replaced by "upperbound" and "lowerbound".
    """
    if "argLowerBound" in invalidKeywordArguments:
        raise AssertionError(
            "\nintegerbox no longer supports the 'argLowerBound' argument.\n"
            + "Use 'lowerbound' instead.\n\n")
    if "argUpperBound" in invalidKeywordArguments:
        raise AssertionError(
            "\nintegerbox no longer supports the 'argUpperBound' argument.\n"
            + "Use 'upperbound' instead.\n\n")

    if default != "":
        if type(default) != type(1):
            raise AssertionError(
                "integerbox received a non-integer value for "
                + "default of " + dq(str(default)) , "Error")

    if type(lowerbound) != type(1):
        raise AssertionError(
            "integerbox received a non-integer value for "
            + "lowerbound of " + dq(str(lowerbound)) , "Error")

    if type(upperbound) != type(1):
        raise AssertionError(
            "integerbox received a non-integer value for "
            + "upperbound of " + dq(str(upperbound)) , "Error")

    if msg == "":
        msg = ("Enter an integer between " + str(lowerbound)
            + " and "
            + str(upperbound)
            )

    while 1:
        reply = enterbox(msg, title, str(default), image=image, root=root)
        if reply == None: return None

        try:
            reply = int(reply)
        except:
            msgbox ("The value that you entered:\n\t%s\nis not an integer." % dq(str(reply))
                    , "Error")
            continue

        if reply < lowerbound:
            msgbox ("The value that you entered is less than the lower bound of "
                + str(lowerbound) + ".", "Error")
            continue

        if reply > upperbound:
            msgbox ("The value that you entered is greater than the upper bound of "
                + str(upperbound) + ".", "Error")
            continue

        # reply has passed all validation checks.
        # It is an integer between the specified bounds.
        return reply

#-------------------------------------------------------------------
# multenterbox
#-------------------------------------------------------------------
def multenterbox(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    ):
    r"""
    Show screen with multiple data entry fields.

    If there are fewer values than names, the list of values is padded with
    empty strings until the number of values is the same as the number of names.

    If there are more values than names, the list of values
    is truncated so that there are as many values as names.

    Returns a list of the values of the fields,
    or None if the user cancels the operation.

    Here is some example code, that shows how values returned from
    multenterbox can be checked for validity before they are accepted::
        ----------------------------------------------------------------------
        msg = "Enter your personal information"
        title = "Credit Card Application"
        fieldNames = ["Name","Street Address","City","State","ZipCode"]
        fieldValues = []  # we start with blanks for the values
        fieldValues = multenterbox(msg,title, fieldNames)

        # make sure that none of the fields was left blank
        while 1:
            if fieldValues == None: break
            errmsg = ""
            for i in range(len(fieldNames)):
                if fieldValues[i].strip() == "":
                    errmsg += ('"%s" is a required field.\n\n' % fieldNames[i])
            if errmsg == "":
                break # no problems found
            fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)

        writeln("Reply was: %s" % str(fieldValues))
        ----------------------------------------------------------------------

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg fields: a list of fieldnames.
    @arg values:  a list of field values
    """
    return __multfillablebox(msg,title,fields,values,None)


#-----------------------------------------------------------------------
# multpasswordbox
#-----------------------------------------------------------------------
def multpasswordbox(msg="Fill in values for the fields."
    , title=" "
    , fields=tuple()
    ,values=tuple()
    ):
    r"""
    Same interface as multenterbox.  But in multpassword box,
    the last of the fields is assumed to be a password, and
    is masked with asterisks.

    Example
    =======

    Here is some example code, that shows how values returned from
    multpasswordbox can be checked for validity before they are accepted::
        msg = "Enter logon information"
        title = "Demo of multpasswordbox"
        fieldNames = ["Server ID", "User ID", "Password"]
        fieldValues = []  # we start with blanks for the values
        fieldValues = multpasswordbox(msg,title, fieldNames)

        # make sure that none of the fields was left blank
        while 1:
            if fieldValues == None: break
            errmsg = ""
            for i in range(len(fieldNames)):
                if fieldValues[i].strip() == "":
                    errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
            fieldValues = multpasswordbox(errmsg, title, fieldNames, fieldValues)

        writeln("Reply was: %s" % str(fieldValues))
    """
    return __multfillablebox(msg,title,fields,values,"*")

def bindArrows(widget):
    widget.bind("<Down>", tabRight)
    widget.bind("<Up>"  , tabLeft)

    widget.bind("<Right>",tabRight)
    widget.bind("<Left>" , tabLeft)

def tabRight(event):
    boxRoot.event_generate("<Tab>")

def tabLeft(event):
    boxRoot.event_generate("<Shift-Tab>")

#-----------------------------------------------------------------------
# __multfillablebox
#-----------------------------------------------------------------------
def __multfillablebox(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    , mask = None
    ):
    global boxRoot, __multenterboxText, __multenterboxDefaultText, cancelButton, entryWidget, okButton

    choices = ["OK", "Cancel"]
    if len(fields) == 0: return None

    fields = list(fields[:])  # convert possible tuples to a list
    values = list(values[:])  # convert possible tuples to a list

    if   len(values) == len(fields): pass
    elif len(values) >  len(fields):
        fields = fields[0:len(values)]
    else:
        while len(values) < len(fields):
            values.append("")

    boxRoot = Tk()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.bind("<Escape>", __multenterboxCancel)

    # -------------------- put subframes in the boxRoot --------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    #-------------------- the msg widget ----------------------------
    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    global entryWidgets
    entryWidgets = []

    lastWidgetIndex = len(fields) - 1

    for widgetIndex in range(len(fields)):
        argFieldName  = fields[widgetIndex]
        argFieldValue = values[widgetIndex]
        entryFrame = Frame(master=boxRoot)
        entryFrame.pack(side=TOP, fill=BOTH)

        # --------- entryWidget ----------------------------------------------
        labelWidget = Label(entryFrame, text=argFieldName)
        labelWidget.pack(side=LEFT)

        entryWidget = Entry(entryFrame, width=40,highlightthickness=2)
        entryWidgets.append(entryWidget)
        entryWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,TEXT_ENTRY_FONT_SIZE))
        entryWidget.pack(side=RIGHT, padx="3m")

        bindArrows(entryWidget)

        entryWidget.bind("<Return>", __multenterboxGetText)
        entryWidget.bind("<Escape>", __multenterboxCancel)

        # for the last entryWidget, if this is a multpasswordbox,
        # show the contents as just asterisks
        if widgetIndex == lastWidgetIndex:
            if mask:
                entryWidgets[widgetIndex].configure(show=mask)

        # put text into the entryWidget
        entryWidgets[widgetIndex].insert(0,argFieldValue)
        widgetIndex += 1

    # ------------------ ok button -------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=BOTTOM, fill=BOTH)

    okButton = Button(buttonsFrame, takefocus=1, text="OK")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __multenterboxGetText
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __multenterboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------- time for action! -----------------
    entryWidgets[0].focus_force()    # put the focus on the entryWidget
    boxRoot.mainloop()  # run it!

    # -------- after the run has completed ----------------------------------
    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    return __multenterboxText


#-----------------------------------------------------------------------
# __multenterboxGetText
#-----------------------------------------------------------------------
def __multenterboxGetText(event):
    global __multenterboxText

    __multenterboxText = []
    for entryWidget in entryWidgets:
        __multenterboxText.append(entryWidget.get())
    boxRoot.quit()


def __multenterboxCancel(event):
    global __multenterboxText
    __multenterboxText = None
    boxRoot.quit()


#-------------------------------------------------------------------
# enterbox
#-------------------------------------------------------------------
def enterbox(msg="Enter something."
    , title=" "
    , default=""
    , strip=True
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter some text.

    You may optionally specify some default text, which will appear in the
    enterbox when it is displayed.

    Returns the text that the user entered, or None if he cancels the operation.

    By default, enterbox strips its result (i.e. removes leading and trailing
    whitespace).  (If you want it not to strip, use keyword argument: strip=False.)
    This makes it easier to test the results of the call::

        reply = enterbox(....)
        if reply:
            ...
        else:
            ...
    """
    result = __fillablebox(msg, title, default=default, mask=None,image=image,root=root)
    if result and strip:
        result = result.strip()
    return result


def passwordbox(msg="Enter your password."
    , title=" "
    , default=""
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter a password.
    The text is masked with asterisks, so the password is not displayed.
    Returns the text that the user entered, or None if he cancels the operation.
    """
    return __fillablebox(msg, title, default, mask="*",image=image,root=root)


def __fillablebox(msg
    , title=""
    , default=""
    , mask=None
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter some text.
    You may optionally specify some default text, which will appear in the
    enterbox when it is displayed.
    Returns the text that the user entered, or None if he cancels the operation.
    """

    global boxRoot, __enterboxText, __enterboxDefaultText
    global cancelButton, entryWidget, okButton

    if title == None: title == ""
    if default == None: default = ""
    __enterboxDefaultText = default
    __enterboxText        = __enterboxDefaultText

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.bind("<Escape>", __enterboxCancel)

    if image:
        image = os.path.normpath(image)
        junk,ext = os.path.splitext(image)
        if ext.lower() == ".gif":
            if os.path.exists(image):
                pass
            else:
                msg += ImageErrorMsg % (image, "Image file not found.")
                image = None
        else:
            msg += ImageErrorMsg % (image, "Image file is not a .gif file.")
            image = None
    # ------------- define the messageFrame ---------------------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the imageFrame ---------------------------------
    if image:
        imageFrame = Frame(master=boxRoot)
        imageFrame.pack(side=TOP, fill=BOTH)
        image = PhotoImage(file=image)
        label = Label(imageFrame,image=image)
        label.image = image # keep a reference!
        label.pack(side=TOP, expand=YES, fill=X, padx='1m', pady='1m')

    # ------------- define the entryFrame ---------------------------------
    entryFrame = Frame(master=boxRoot)
    entryFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    #-------------------- the msg widget ----------------------------
    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    # --------- entryWidget ----------------------------------------------
    entryWidget = Entry(entryFrame, width=40)
    bindArrows(entryWidget)
    entryWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,TEXT_ENTRY_FONT_SIZE))
    if mask:
        entryWidget.configure(show=mask)
    entryWidget.pack(side=LEFT, padx="3m")
    entryWidget.bind("<Return>", __enterboxGetText)
    entryWidget.bind("<Escape>", __enterboxCancel)
    # put text into the entryWidget
    entryWidget.insert(0,__enterboxDefaultText)

    # ------------------ ok button -------------------------------
    okButton = Button(buttonsFrame, takefocus=1, text="OK")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __enterboxGetText
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __enterboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)

    # ------------------- time for action! -----------------
    entryWidget.focus_force()    # put the focus on the entryWidget
    boxRoot.deiconify()
    boxRoot.mainloop()  # run it!

    # -------- after the run has completed ----------------------------------
    if root: root.deiconify()
    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    return __enterboxText


def __enterboxGetText(event):
    global __enterboxText
    __enterboxText = entryWidget.get()
    boxRoot.quit()


def __enterboxRestore(event):
    global entryWidget
    entryWidget.delete(0,len(entryWidget.get()))
    entryWidget.insert(0, __enterboxDefaultText)


def __enterboxCancel(event):
    global __enterboxText
    __enterboxText = None
    boxRoot.quit()

def denyWindowManagerClose():
    """ don't allow WindowManager close
    """
    x = Tk()
    x.withdraw()
    x.bell()
    x.destroy()



#-------------------------------------------------------------------
# multchoicebox
#-------------------------------------------------------------------
def multchoicebox(msg="Pick as many items as you like."
    , title=" "
    , choices=()
    , **kwargs
    ):
    """
    Present the user with a list of choices.
    allow him to select multiple items and return them in a list.
    if the user doesn't choose anything from the list, return the empty list.
    return None if he cancelled selection.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    if len(choices) == 0: choices = ["Program logic error - no choices were specified."]

    global __choiceboxMultipleSelect
    __choiceboxMultipleSelect = 1
    return __choicebox(msg, title, choices)


#-----------------------------------------------------------------------
# choicebox
#-----------------------------------------------------------------------
def choicebox(msg="Pick something."
    , title=" "
    , choices=()
    ):
    """
    Present the user with a list of choices.
    return the choice that he selects.
    return None if he cancels the selection selection.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    if len(choices) == 0: choices = ["Program logic error - no choices were specified."]

    global __choiceboxMultipleSelect
    __choiceboxMultipleSelect = 0
    return __choicebox(msg,title,choices)


#-----------------------------------------------------------------------
# __choicebox
#-----------------------------------------------------------------------
def __choicebox(msg
    , title
    , choices
    ):
    """
    internal routine to support choicebox() and multchoicebox()
    """
    global boxRoot, __choiceboxResults, choiceboxWidget, defaultText
    global choiceboxWidget, choiceboxChoices
    #-------------------------------------------------------------------
    # If choices is a tuple, we make it a list so we can sort it.
    # If choices is already a list, we make a new list, so that when
    # we sort the choices, we don't affect the list object that we
    # were given.
    #-------------------------------------------------------------------
    choices = list(choices[:])
    if len(choices) == 0:
        choices = ["Program logic error - no choices were specified."]
    defaultButtons = ["OK", "Cancel"]

    # make sure all choices are strings
    for index in range(len(choices)):
        choices[index] = str(choices[index])

    lines_to_show = min(len(choices), 20)
    lines_to_show = 20

    if title == None: title = ""

    # Initialize __choiceboxResults
    # This is the value that will be returned if the user clicks the close icon
    __choiceboxResults = None

    boxRoot = Tk()
    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    screen_width  = boxRoot.winfo_screenwidth()
    screen_height = boxRoot.winfo_screenheight()
    root_width    = int((screen_width * 0.8))
    root_height   = int((screen_height * 0.5))
    root_xpos     = int((screen_width * 0.1))
    root_ypos     = int((screen_height * 0.05))

    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    rootWindowPosition = "+0+0"
    boxRoot.geometry(rootWindowPosition)
    boxRoot.expand=NO
    boxRoot.minsize(root_width, root_height)
    rootWindowPosition = "+" + str(root_xpos) + "+" + str(root_ypos)
    boxRoot.geometry(rootWindowPosition)

    # ---------------- put the frames in the window -----------------------------------------
    message_and_buttonsFrame = Frame(master=boxRoot)
    message_and_buttonsFrame.pack(side=TOP, fill=X, expand=NO)

    messageFrame = Frame(message_and_buttonsFrame)
    messageFrame.pack(side=LEFT, fill=X, expand=YES)
    #messageFrame.pack(side=TOP, fill=X, expand=YES)

    buttonsFrame = Frame(message_and_buttonsFrame)
    buttonsFrame.pack(side=RIGHT, expand=NO, pady=0)
    #buttonsFrame.pack(side=TOP, expand=YES, pady=0)

    choiceboxFrame = Frame(master=boxRoot)
    choiceboxFrame.pack(side=BOTTOM, fill=BOTH, expand=YES)

    # -------------------------- put the widgets in the frames ------------------------------

    # ---------- put a msg widget in the msg frame-------------------
    messageWidget = Message(messageFrame, anchor=NW, text=msg, width=int(root_width * 0.9))
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=LEFT, expand=YES, fill=BOTH, padx='1m', pady='1m')

    # --------  put the choiceboxWidget in the choiceboxFrame ---------------------------
    choiceboxWidget = Listbox(choiceboxFrame
        , height=lines_to_show
        , borderwidth="1m"
        , relief="flat"
        , bg="white"
        )

    if __choiceboxMultipleSelect:
        choiceboxWidget.configure(selectmode=MULTIPLE)

    choiceboxWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))

    # add a vertical scrollbar to the frame
    rightScrollbar = Scrollbar(choiceboxFrame, orient=VERTICAL, command=choiceboxWidget.yview)
    choiceboxWidget.configure(yscrollcommand = rightScrollbar.set)

    # add a horizontal scrollbar to the frame
    bottomScrollbar = Scrollbar(choiceboxFrame, orient=HORIZONTAL, command=choiceboxWidget.xview)
    choiceboxWidget.configure(xscrollcommand = bottomScrollbar.set)

    # pack the Listbox and the scrollbars.  Note that although we must define
    # the textArea first, we must pack it last, so that the bottomScrollbar will
    # be located properly.

    bottomScrollbar.pack(side=BOTTOM, fill = X)
    rightScrollbar.pack(side=RIGHT, fill = Y)

    choiceboxWidget.pack(side=LEFT, padx="1m", pady="1m", expand=YES, fill=BOTH)

    #---------------------------------------------------
    # sort the choices
    # eliminate duplicates
    # put the choices into the choiceboxWidget
    #---------------------------------------------------
    for index in range(len(choices)):
        choices[index] == str(choices[index])

    if runningPython3:
        choices.sort(key=str.lower)
    else:
        choices.sort( lambda x,y: cmp(x.lower(),    y.lower())) # case-insensitive sort

    lastInserted = None
    choiceboxChoices = []
    for choice in choices:
        if choice == lastInserted: pass
        else:
            choiceboxWidget.insert(END, choice)
            choiceboxChoices.append(choice)
            lastInserted = choice

    boxRoot.bind('<Any-Key>', KeyboardListener)

    # put the buttons in the buttonsFrame
    if len(choices) > 0:
        okButton = Button(buttonsFrame, takefocus=YES, text="OK", height=1, width=6)
        bindArrows(okButton)
        okButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

        # for the commandButton, bind activation events to the activation event handler
        commandButton  = okButton
        handler = __choiceboxGetChoice
        for selectionEvent in STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

        # now bind the keyboard events
        choiceboxWidget.bind("<Return>", __choiceboxGetChoice)
        choiceboxWidget.bind("<Double-Button-1>", __choiceboxGetChoice)
    else:
        # now bind the keyboard events
        choiceboxWidget.bind("<Return>", __choiceboxCancel)
        choiceboxWidget.bind("<Double-Button-1>", __choiceboxCancel)

    cancelButton = Button(buttonsFrame, takefocus=YES, text="Cancel", height=1, width=6)
    bindArrows(cancelButton)
    cancelButton.pack(expand=NO, side=BOTTOM, padx='2m', pady='1m', ipady="1m", ipadx="2m")

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __choiceboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # add special buttons for multiple select features
    if len(choices) > 0 and __choiceboxMultipleSelect:
        selectionButtonsFrame = Frame(messageFrame)
        selectionButtonsFrame.pack(side=RIGHT, fill=Y, expand=NO)

        selectAllButton = Button(selectionButtonsFrame, text="Select All", height=1, width=6)
        bindArrows(selectAllButton)

        selectAllButton.bind("<Button-1>",__choiceboxSelectAll)
        selectAllButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

        clearAllButton = Button(selectionButtonsFrame, text="Clear All", height=1, width=6)
        bindArrows(clearAllButton)
        clearAllButton.bind("<Button-1>",__choiceboxClearAll)
        clearAllButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")


    # -------------------- bind some keyboard events ----------------------------
    boxRoot.bind("<Escape>", __choiceboxCancel)

    # --------------------- the action begins -----------------------------------
    # put the focus on the choiceboxWidget, and the select highlight on the first item
    choiceboxWidget.select_set(0)
    choiceboxWidget.focus_force()

    # --- run it! -----
    boxRoot.mainloop()

    boxRoot.destroy()
    return __choiceboxResults


def __choiceboxGetChoice(event):
    global boxRoot, __choiceboxResults, choiceboxWidget

    if __choiceboxMultipleSelect:
        __choiceboxResults = [choiceboxWidget.get(index) for index in choiceboxWidget.curselection()]

    else:
        choice_index = choiceboxWidget.curselection()
        __choiceboxResults = choiceboxWidget.get(choice_index)

    # writeln("Debugging> mouse-event=", event, " event.type=", event.type)
    # writeln("Debugging> choice=", choice_index, __choiceboxResults)
    boxRoot.quit()


def __choiceboxSelectAll(event):
    global choiceboxWidget, choiceboxChoices
    choiceboxWidget.selection_set(0, len(choiceboxChoices)-1)

def __choiceboxClearAll(event):
    global choiceboxWidget, choiceboxChoices
    choiceboxWidget.selection_clear(0, len(choiceboxChoices)-1)



def __choiceboxCancel(event):
    global boxRoot, __choiceboxResults

    __choiceboxResults = None
    boxRoot.quit()


def KeyboardListener(event):
    global choiceboxChoices, choiceboxWidget
    key = event.keysym
    if len(key) <= 1:
        if key in string.printable:
            # Find the key in the list.
            # before we clear the list, remember the selected member
            try:
                start_n = int(choiceboxWidget.curselection()[0])
            except IndexError:
                start_n = -1

            ## clear the selection.
            choiceboxWidget.selection_clear(0, 'end')

            ## start from previous selection +1
            for n in range(start_n+1, len(choiceboxChoices)):
                item = choiceboxChoices[n]
                if item[0].lower() == key.lower():
                    choiceboxWidget.selection_set(first=n)
                    choiceboxWidget.see(n)
                    return
            else:
                # has not found it so loop from top
                for n in range(len(choiceboxChoices)):
                    item = choiceboxChoices[n]
                    if item[0].lower() == key.lower():
                        choiceboxWidget.selection_set(first = n)
                        choiceboxWidget.see(n)
                        return

                # nothing matched -- we'll look for the next logical choice
                for n in range(len(choiceboxChoices)):
                    item = choiceboxChoices[n]
                    if item[0].lower() > key.lower():
                        if n > 0:
                            choiceboxWidget.selection_set(first = (n-1))
                        else:
                            choiceboxWidget.selection_set(first = 0)
                        choiceboxWidget.see(n)
                        return

                # still no match (nothing was greater than the key)
                # we set the selection to the first item in the list
                lastIndex = len(choiceboxChoices)-1
                choiceboxWidget.selection_set(first = lastIndex)
                choiceboxWidget.see(lastIndex)
                return

#-----------------------------------------------------------------------
# exception_format
#-----------------------------------------------------------------------
def exception_format():
    """
    Convert exception info into a string suitable for display.
    """
    return "".join(traceback.format_exception(
           sys.exc_info()[0]
        ,  sys.exc_info()[1]
        ,  sys.exc_info()[2]
        ))

#-----------------------------------------------------------------------
# exceptionbox
#-----------------------------------------------------------------------
def exceptionbox(msg=None, title=None):
    """
    Display a box that gives information about
    an exception that has just been raised.

    The caller may optionally pass in a title for the window, or a
    msg to accompany the error information.

    Note that you do not need to (and cannot) pass an exception object
    as an argument.  The latest exception will automatically be used.
    """
    if title == None: title = "Error Report"
    if msg == None:
        msg = "An error (exception) has occurred in the program."

    codebox(msg, title, exception_format())

#-------------------------------------------------------------------
# codebox
#-------------------------------------------------------------------

def codebox(msg=""
    , title=" "
    , text=""
    ):
    """
    Display some text in a monospaced font, with no line wrapping.
    This function is suitable for displaying code and text that is
    formatted using spaces.

    The text parameter should be a string, or a list or tuple of lines to be
    displayed in the textbox.
    """
    return textbox(msg, title, text, codebox=1 )

#-------------------------------------------------------------------
# textbox
#-------------------------------------------------------------------
def textbox(msg=""
    , title=" "
    , text=""
    , codebox=0
    ):
    """
    Display some text in a proportional font with line wrapping at word breaks.
    This function is suitable for displaying general written text.

    The text parameter should be a string, or a list or tuple of lines to be
    displayed in the textbox.
    """

    if msg == None: msg = ""
    if title == None: title = ""

    global boxRoot, __replyButtonText, __widgetTexts, buttonsFrame
    global rootWindowPosition
    choices = ["OK"]
    __replyButtonText = choices[0]


    boxRoot = Tk()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )

    screen_width = boxRoot.winfo_screenwidth()
    screen_height = boxRoot.winfo_screenheight()
    root_width = int((screen_width * 0.8))
    root_height = int((screen_height * 0.5))
    root_xpos = int((screen_width * 0.1))
    root_ypos = int((screen_height * 0.05))

    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    rootWindowPosition = "+0+0"
    boxRoot.geometry(rootWindowPosition)
    boxRoot.expand=NO
    boxRoot.minsize(root_width, root_height)
    rootWindowPosition = "+" + str(root_xpos) + "+" + str(root_ypos)
    boxRoot.geometry(rootWindowPosition)

    mainframe = Frame(master=boxRoot)
    mainframe.pack(side=TOP, fill=BOTH, expand=YES)

    # ----  put frames in the window -----------------------------------
    # we pack the textboxFrame first, so it will expand first
    textboxFrame = Frame(mainframe, borderwidth=3)
    textboxFrame.pack(side=BOTTOM , fill=BOTH, expand=YES)

    message_and_buttonsFrame = Frame(mainframe)
    message_and_buttonsFrame.pack(side=TOP, fill=X, expand=NO)

    messageFrame = Frame(message_and_buttonsFrame)
    messageFrame.pack(side=LEFT, fill=X, expand=YES)

    buttonsFrame = Frame(message_and_buttonsFrame)
    buttonsFrame.pack(side=RIGHT, expand=NO)

    # -------------------- put widgets in the frames --------------------

    # put a textArea in the top frame
    if codebox:
        character_width = int((root_width * 0.6) / MONOSPACE_FONT_SIZE)
        textArea = Text(textboxFrame,height=25,width=character_width, padx="2m", pady="1m")
        textArea.configure(wrap=NONE)
        textArea.configure(font=(MONOSPACE_FONT_FAMILY, MONOSPACE_FONT_SIZE))

    else:
        character_width = int((root_width * 0.6) / MONOSPACE_FONT_SIZE)
        textArea = Text(
            textboxFrame
            , height=25
            , width=character_width
            , padx="2m"
            , pady="1m"
            )
        textArea.configure(wrap=WORD)
        textArea.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))


    # some simple keybindings for scrolling
    mainframe.bind("<Next>" , textArea.yview_scroll( 1,PAGES))
    mainframe.bind("<Prior>", textArea.yview_scroll(-1,PAGES))

    mainframe.bind("<Right>", textArea.xview_scroll( 1,PAGES))
    mainframe.bind("<Left>" , textArea.xview_scroll(-1,PAGES))

    mainframe.bind("<Down>", textArea.yview_scroll( 1,UNITS))
    mainframe.bind("<Up>"  , textArea.yview_scroll(-1,UNITS))


    # add a vertical scrollbar to the frame
    rightScrollbar = Scrollbar(textboxFrame, orient=VERTICAL, command=textArea.yview)
    textArea.configure(yscrollcommand = rightScrollbar.set)

    # add a horizontal scrollbar to the frame
    bottomScrollbar = Scrollbar(textboxFrame, orient=HORIZONTAL, command=textArea.xview)
    textArea.configure(xscrollcommand = bottomScrollbar.set)

    # pack the textArea and the scrollbars.  Note that although we must define
    # the textArea first, we must pack it last, so that the bottomScrollbar will
    # be located properly.

    # Note that we need a bottom scrollbar only for code.
    # Text will be displayed with wordwrap, so we don't need to have a horizontal
    # scroll for it.
    if codebox:
        bottomScrollbar.pack(side=BOTTOM, fill=X)
    rightScrollbar.pack(side=RIGHT, fill=Y)

    textArea.pack(side=LEFT, fill=BOTH, expand=YES)


    # ---------- put a msg widget in the msg frame-------------------
    messageWidget = Message(messageFrame, anchor=NW, text=msg, width=int(root_width * 0.9))
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=LEFT, expand=YES, fill=BOTH, padx='1m', pady='1m')

    # put the buttons in the buttonsFrame
    okButton = Button(buttonsFrame, takefocus=YES, text="OK", height=1, width=6)
    okButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __textboxOK
    for selectionEvent in ["Return","Button-1","Escape"]:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ----------------- the action begins ----------------------------------------
    try:
        # load the text into the textArea
        if type(text) == type("abc"): pass
        else:
            try:
                text = "".join(text)  # convert a list or a tuple to a string
            except:
                msgbox("Exception when trying to convert "+ str(type(text)) + " to text in textArea")
                sys.exit(16)
        textArea.insert(END,text, "normal")

    except:
        msgbox("Exception when trying to load the textArea.")
        sys.exit(16)

    try:
        okButton.focus_force()
    except:
        msgbox("Exception when trying to put focus on okButton.")
        sys.exit(16)

    boxRoot.mainloop()

    # this line MUST go before the line that destroys boxRoot
    areaText = textArea.get(0.0,END)
    boxRoot.destroy()
    return areaText # return __replyButtonText

#-------------------------------------------------------------------
# __textboxOK
#-------------------------------------------------------------------
def __textboxOK(event):
    global boxRoot
    boxRoot.quit()



#-------------------------------------------------------------------
# diropenbox
#-------------------------------------------------------------------
def diropenbox(msg=None
    , title=None
    , default=None
    ):
    """
    A dialog to get a directory name.
    Note that the msg argument, if specified, is ignored.

    Returns the name of a directory, or None if user chose to cancel.

    If the "default" argument specifies a directory name, and that
    directory exists, then the dialog box will start with that directory.
    """
    title=getFileDialogTitle(msg,title)
    boxRoot = Tk()
    boxRoot.withdraw()
    if not default: default = None
    f = tk_FileDialog.askdirectory(
          parent=boxRoot
        , title=title
        , initialdir=default
        , initialfile=None
        )
    boxRoot.destroy()
    if not f: return None
    return os.path.normpath(f)



#-------------------------------------------------------------------
# getFileDialogTitle
#-------------------------------------------------------------------
def getFileDialogTitle(msg
    , title
    ):
    if msg and title: return "%s - %s" % (title,msg)
    if msg and not title: return str(msg)
    if title and not msg: return str(title)
    return None # no message and no title

#-------------------------------------------------------------------
# class FileTypeObject for use with fileopenbox
#-------------------------------------------------------------------
class FileTypeObject:
    def __init__(self,filemask):
        if len(filemask) == 0:
            raise AssertionError('Filetype argument is empty.')

        self.masks = []

        if type(filemask) == type("abc"):  # a string
            self.initializeFromString(filemask)

        elif type(filemask) == type([]): # a list
            if len(filemask) < 2:
                raise AssertionError('Invalid filemask.\n'
                +'List contains less than 2 members: "%s"' % filemask)
            else:
                self.name  = filemask[-1]
                self.masks = list(filemask[:-1] )
        else:
            raise AssertionError('Invalid filemask: "%s"' % filemask)

    def __eq__(self,other):
        if self.name == other.name: return True
        return False

    def add(self,other):
        for mask in other.masks:
            if mask in self.masks: pass
            else: self.masks.append(mask)

    def toTuple(self):
        return (self.name,tuple(self.masks))

    def isAll(self):
        if self.name == "All files": return True
        return False

    def initializeFromString(self, filemask):
        # remove everything except the extension from the filemask
        self.ext = os.path.splitext(filemask)[1]
        if self.ext == "" : self.ext = ".*"
        if self.ext == ".": self.ext = ".*"
        self.name = self.getName()
        self.masks = ["*" + self.ext]

    def getName(self):
        e = self.ext
        if e == ".*"  : return "All files"
        if e == ".txt": return "Text files"
        if e == ".py" : return "Python files"
        if e == ".pyc" : return "Python files"
        if e == ".xls": return "Excel files"
        if e.startswith("."):
            return e[1:].upper() + " files"
        return e.upper() + " files"


#-------------------------------------------------------------------
# fileopenbox
#-------------------------------------------------------------------
def fileopenbox(msg=None
    , title=None
    , default="*"
    , filetypes=None
    ):
    """
    A dialog to get a file name.

    About the "default" argument
    ============================
        The "default" argument specifies a filepath that (normally)
        contains one or more wildcards.
        fileopenbox will display only files that match the default filepath.
        If omitted, defaults to "*" (all files in the current directory).

        WINDOWS EXAMPLE::
            ...default="c:/myjunk/*.py"
        will open in directory c:\myjunk\ and show all Python files.

        WINDOWS EXAMPLE::
            ...default="c:/myjunk/test*.py"
        will open in directory c:\myjunk\ and show all Python files
        whose names begin with "test".


        Note that on Windows, fileopenbox automatically changes the path
        separator to the Windows path separator (backslash).

    About the "filetypes" argument
    ==============================
        If specified, it should contain a list of items,
        where each item is either::
            - a string containing a filemask          # e.g. "*.txt"
            - a list of strings, where all of the strings except the last one
                are filemasks (each beginning with "*.",
                such as "*.txt" for text files, "*.py" for Python files, etc.).
                and the last string contains a filetype description

        EXAMPLE::
            filetypes = ["*.css", ["*.htm", "*.html", "HTML files"]  ]

    NOTE THAT
    =========

        If the filetypes list does not contain ("All files","*"),
        it will be added.

        If the filetypes list does not contain a filemask that includes
        the extension of the "default" argument, it will be added.
        For example, if     default="*abc.py"
        and no filetypes argument was specified, then
        "*.py" will automatically be added to the filetypes argument.

    @rtype: string or None
    @return: the name of a file, or None if user chose to cancel

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg default: filepath with wildcards
    @arg filetypes: filemasks that a user can choose, e.g. "*.txt"
    """
    boxRoot = Tk()
    boxRoot.withdraw()

    initialbase, initialfile, initialdir, filetypes = fileboxSetup(default,filetypes)

    #------------------------------------------------------------
    # if initialfile contains no wildcards; we don't want an
    # initial file. It won't be used anyway.
    # Also: if initialbase is simply "*", we don't want an
    # initialfile; it is not doing any useful work.
    #------------------------------------------------------------
    if (initialfile.find("*") < 0) and (initialfile.find("?") < 0):
        initialfile = None
    elif initialbase == "*":
        initialfile = None

    f = tk_FileDialog.askopenfilename(parent=boxRoot
        , title=getFileDialogTitle(msg,title)
        , initialdir=initialdir
        , initialfile=initialfile
        , filetypes=filetypes
        )

    boxRoot.destroy()

    if not f: return None
    return os.path.normpath(f)


#-------------------------------------------------------------------
# filesavebox
#-------------------------------------------------------------------
def filesavebox(msg=None
    , title=None
    , default=""
    , filetypes=None
    ):
    """
    A file to get the name of a file to save.
    Returns the name of a file, or None if user chose to cancel.

    The "default" argument should contain a filename (i.e. the
    current name of the file to be saved).  It may also be empty,
    or contain a filemask that includes wildcards.

    The "filetypes" argument works like the "filetypes" argument to
    fileopenbox.
    """

    boxRoot = Tk()
    boxRoot.withdraw()

    initialbase, initialfile, initialdir, filetypes = fileboxSetup(default,filetypes)

    f = tk_FileDialog.asksaveasfilename(parent=boxRoot
        , title=getFileDialogTitle(msg,title)
        , initialfile=initialfile
        , initialdir=initialdir
        , filetypes=filetypes
        )
    boxRoot.destroy()
    if not f: return None
    return os.path.normpath(f)


#-------------------------------------------------------------------
#
# fileboxSetup
#
#-------------------------------------------------------------------
def fileboxSetup(default,filetypes):
    if not default: default = os.path.join(".","*")
    initialdir, initialfile = os.path.split(default)
    if not initialdir : initialdir  = "."
    if not initialfile: initialfile = "*"
    initialbase, initialext = os.path.splitext(initialfile)
    initialFileTypeObject = FileTypeObject(initialfile)

    allFileTypeObject = FileTypeObject("*")
    ALL_filetypes_was_specified = False

    if not filetypes: filetypes= []
    filetypeObjects = []

    for filemask in filetypes:
        fto = FileTypeObject(filemask)

        if fto.isAll():
            ALL_filetypes_was_specified = True # remember this

        if fto == initialFileTypeObject:
            initialFileTypeObject.add(fto) # add fto to initialFileTypeObject
        else:
            filetypeObjects.append(fto)

    #------------------------------------------------------------------
    # make sure that the list of filetypes includes the ALL FILES type.
    #------------------------------------------------------------------
    if ALL_filetypes_was_specified:
        pass
    elif allFileTypeObject == initialFileTypeObject:
        pass
    else:
        filetypeObjects.insert(0,allFileTypeObject)
    #------------------------------------------------------------------
    # Make sure that the list includes the initialFileTypeObject
    # in the position in the list that will make it the default.
    # This changed between Python version 2.5 and 2.6
    #------------------------------------------------------------------
    if len(filetypeObjects) == 0:
        filetypeObjects.append(initialFileTypeObject)

    if initialFileTypeObject in (filetypeObjects[0], filetypeObjects[-1]):
        pass
    else:
        if runningPython26:
            filetypeObjects.append(initialFileTypeObject)
        else:
            filetypeObjects.insert(0,initialFileTypeObject)

    filetypes = [fto.toTuple() for fto in filetypeObjects]

    return initialbase, initialfile, initialdir, filetypes

#-------------------------------------------------------------------
# utility routines
#-------------------------------------------------------------------
# These routines are used by several other functions in the EasyGui module.

def __buttonEvent(event):
    """
    Handle an event that is generated by a person clicking a button.
    """
    global  boxRoot, __widgetTexts, __replyButtonText
    __replyButtonText = __widgetTexts[event.widget]
    boxRoot.quit() # quit the main loop


def __put_buttons_in_buttonframe(choices):
    """Put the buttons in the buttons frame
    """
    global __widgetTexts, __firstWidget, buttonsFrame

    __firstWidget = None
    __widgetTexts = {}

    i = 0

    for buttonText in choices:
        tempButton = Button(buttonsFrame, takefocus=1, text=buttonText)
        bindArrows(tempButton)
        tempButton.pack(expand=YES, side=LEFT, padx='1m', pady='1m', ipadx='2m', ipady='1m')

        # remember the text associated with this widget
        __widgetTexts[tempButton] = buttonText

        # remember the first widget, so we can put the focus there
        if i == 0:
            __firstWidget = tempButton
            i = 1

        # for the commandButton, bind activation events to the activation event handler
        commandButton  = tempButton
        handler = __buttonEvent
        for selectionEvent in STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

#-----------------------------------------------------------------------
#
#     class EgStore
#
#-----------------------------------------------------------------------
class EgStore:
    r"""
A class to support persistent storage.

You can use EgStore to support the storage and retrieval
of user settings for an EasyGui application.


# Example A
#-----------------------------------------------------------------------
# define a class named Settings as a subclass of EgStore
#-----------------------------------------------------------------------
class Settings(EgStore):

    def __init__(self, filename):  # filename is required
        #-------------------------------------------------
        # Specify default/initial values for variables that
        # this particular application wants to remember.
        #-------------------------------------------------
        self.userId = ""
        self.targetServer = ""

        #-------------------------------------------------
        # For subclasses of EgStore, these must be
        # the last two statements in  __init__
        #-------------------------------------------------
        self.filename = filename  # this is required
        self.restore()            # restore values from the storage file if possible



# Example B
#-----------------------------------------------------------------------
# create settings, a persistent Settings object
#-----------------------------------------------------------------------
settingsFile = "myApp_settings.txt"
settings = Settings(settingsFile)

user    = "obama_barak"
server  = "whitehouse1"
settings.userId = user
settings.targetServer = server
settings.store()    # persist the settings

# run code that gets a new value for userId, and persist the settings
user    = "biden_joe"
settings.userId = user
settings.store()


# Example C
#-----------------------------------------------------------------------
# recover the Settings instance, change an attribute, and store it again.
#-----------------------------------------------------------------------
settings = Settings(settingsFile)
settings.userId = "vanrossum_g"
settings.store()

"""
    def __init__(self, filename):  # obtaining filename is required
        raise NotImplementedError()

    def restore(self):
        """
        Set the values of whatever attributes are recoverable
        from the pickle file.

        Populate the attributes (the __dict__) of the EgStore object
        from     the attributes (the __dict__) of the pickled object.

        If the pickled object has attributes that have been initialized
        in the EgStore object, then those attributes of the EgStore object
        will be replaced by the values of the corresponding attributes
        in the pickled object.

        If the pickled object is missing some attributes that have
        been initialized in the EgStore object, then those attributes
        of the EgStore object will retain the values that they were
        initialized with.

        If the pickled object has some attributes that were not
        initialized in the EgStore object, then those attributes
        will be ignored.

        IN SUMMARY:

        After the recover() operation, the EgStore object will have all,
        and only, the attributes that it had when it was initialized.

        Where possible, those attributes will have values recovered
        from the pickled object.
        """
        if not os.path.exists(self.filename): return self
        if not os.path.isfile(self.filename): return self

        try:
            f = open(self.filename,"rb")
            unpickledObject = pickle.load(f)
            f.close()

            for key in list(self.__dict__.keys()):
                default = self.__dict__[key]
                self.__dict__[key] = unpickledObject.__dict__.get(key,default)
        except:
            pass

        return self

    def store(self):
        """
        Save the attributes of the EgStore object to a pickle file.
        Note that if the directory for the pickle file does not already exist,
        the store operation will fail.
        """
        f = open(self.filename, "wb")
        pickle.dump(self, f)
        f.close()


    def kill(self):
        """
        Delete my persistent file (i.e. pickle file), if it exists.
        """
        if os.path.isfile(self.filename):
            os.remove(self.filename)
        return

    def __str__(self):
        """
        return my contents as a string in an easy-to-read format.
        """
        # find the length of the longest attribute name
        longest_key_length = 0
        keys = []
        for key in self.__dict__.keys():
            keys.append(key)
            longest_key_length = max(longest_key_length, len(key))

        keys.sort()  # sort the attribute names
        lines = []
        for key in keys:
            value = self.__dict__[key]
            key = key.ljust(longest_key_length)
            lines.append("%s : %s\n" % (key,repr(value))  )
        return "".join(lines)  # return a string showing the attributes




#-----------------------------------------------------------------------
#
# test/demo easygui
#
#-----------------------------------------------------------------------
def egdemo():
    """
    Run the EasyGui demo.
    """
    # clear the console
    writeln("\n" * 100)

    intro_message = ("Pick the kind of box that you wish to demo.\n"
    + "\n * Python version " + sys.version
    + "\n * EasyGui version " + egversion
    + "\n * Tk version " + str(TkVersion)
    )

    #========================================== END DEMONSTRATION DATA


    while 1: # do forever
        choices = [
            "msgbox",
            "buttonbox",
            "buttonbox(image) -- a buttonbox that displays an image",
            "choicebox",
            "multchoicebox",
            "textbox",
            "ynbox",
            "ccbox",
            "enterbox",
            "enterbox(image) -- an enterbox that displays an image",
            "exceptionbox",
            "codebox",
            "integerbox",
            "boolbox",
            "indexbox",
            "filesavebox",
            "fileopenbox",
            "passwordbox",
            "multenterbox",
            "multpasswordbox",
            "diropenbox",
            "About EasyGui",
            " Help"
            ]
        choice = choicebox(msg=intro_message
            , title="EasyGui " + egversion
            , choices=choices)

        if not choice: return

        reply = choice.split()

        if   reply[0] == "msgbox":
            reply = msgbox("short msg", "This is a long title")
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "About":
            reply = abouteasygui()

        elif reply[0] == "Help":
            _demo_help()

        elif reply[0] == "buttonbox":
            reply = buttonbox()
            writeln("Reply was: %s" % repr(reply))

            title = "Demo of Buttonbox with many, many buttons!"
            msg = "This buttonbox shows what happens when you specify too many buttons."
            reply = buttonbox(msg=msg, title=title, choices=choices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "buttonbox(image)":
            _demo_buttonbox_with_image()

        elif reply[0] == "boolbox":
            reply = boolbox()
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "enterbox":
            image = "python_and_check_logo.gif"
            message = "Enter the name of your best friend."\
                      "\n(Result will be stripped.)"
            reply = enterbox(message, "Love!", "     Suzy Smith     ")
            writeln("Reply was: %s" % repr(reply))

            message = "Enter the name of your best friend."\
                      "\n(Result will NOT be stripped.)"
            reply = enterbox(message, "Love!", "     Suzy Smith     ",strip=False)
            writeln("Reply was: %s" % repr(reply))

            reply = enterbox("Enter the name of your worst enemy:", "Hate!")
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "enterbox(image)":
            image = "python_and_check_logo.gif"
            message = "What kind of snake is this?"
            reply = enterbox(message, "Quiz",image=image)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "exceptionbox":
            try:
                thisWillCauseADivideByZeroException = 1/0
            except:
                exceptionbox()

        elif reply[0] == "integerbox":
            reply = integerbox(
                "Enter a number between 3 and 333",
                "Demo: integerbox WITH a default value",
                222, 3, 333)
            writeln("Reply was: %s" % repr(reply))

            reply = integerbox(
                "Enter a number between 0 and 99",
                "Demo: integerbox WITHOUT a default value"
                )
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "diropenbox" : _demo_diropenbox()
        elif reply[0] == "fileopenbox": _demo_fileopenbox()
        elif reply[0] == "filesavebox": _demo_filesavebox()

        elif reply[0] == "indexbox":
            title = reply[0]
            msg   =  "Demo of " + reply[0]
            choices = ["Choice1", "Choice2", "Choice3", "Choice4"]
            reply = indexbox(msg, title, choices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "passwordbox":
            reply = passwordbox("Demo of password box WITHOUT default"
                + "\n\nEnter your secret password", "Member Logon")
            writeln("Reply was: %s" % str(reply))

            reply = passwordbox("Demo of password box WITH default"
                + "\n\nEnter your secret password", "Member Logon", "alfie")
            writeln("Reply was: %s" % str(reply))

        elif reply[0] == "multenterbox":
            msg = "Enter your personal information"
            title = "Credit Card Application"
            fieldNames = ["Name","Street Address","City","State","ZipCode"]
            fieldValues = []  # we start with blanks for the values
            fieldValues = multenterbox(msg,title, fieldNames)

            # make sure that none of the fields was left blank
            while 1:
                if fieldValues == None: break
                errmsg = ""
                for i in range(len(fieldNames)):
                    if fieldValues[i].strip() == "":
                        errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
                fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)

            writeln("Reply was: %s" % str(fieldValues))

        elif reply[0] == "multpasswordbox":
            msg = "Enter logon information"
            title = "Demo of multpasswordbox"
            fieldNames = ["Server ID", "User ID", "Password"]
            fieldValues = []  # we start with blanks for the values
            fieldValues = multpasswordbox(msg,title, fieldNames)

            # make sure that none of the fields was left blank
            while 1:
                if fieldValues == None: break
                errmsg = ""
                for i in range(len(fieldNames)):
                    if fieldValues[i].strip() == "":
                        errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
                fieldValues = multpasswordbox(errmsg, title, fieldNames, fieldValues)

            writeln("Reply was: %s" % str(fieldValues))

        elif reply[0] == "ynbox":
            title = "Demo of ynbox"
            msg = "Were you expecting the Spanish Inquisition?"
            reply = ynbox(msg, title)
            writeln("Reply was: %s" % repr(reply))
            if reply:
                msgbox("NOBODY expects the Spanish Inquisition!", "Wrong!")

        elif reply[0] == "ccbox":
            title = "Demo of ccbox"
            reply = ccbox(msg,title)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "choicebox":
            title = "Demo of choicebox"
            longchoice = "This is an example of a very long option which you may or may not wish to choose."*2
            listChoices = ["nnn", "ddd", "eee", "fff", "aaa", longchoice
                    , "aaa", "bbb", "ccc", "ggg", "hhh", "iii", "jjj", "kkk", "LLL", "mmm" , "nnn", "ooo", "ppp", "qqq", "rrr", "sss", "ttt", "uuu", "vvv"]

            msg = "Pick something. " + ("A wrapable sentence of text ?! "*30) + "\nA separate line of text."*6
            reply = choicebox(msg=msg, choices=listChoices)
            writeln("Reply was: %s" % repr(reply))

            msg = "Pick something. "
            reply = choicebox(msg=msg, title=title, choices=listChoices)
            writeln("Reply was: %s" % repr(reply))

            msg = "Pick something. "
            reply = choicebox(msg="The list of choices is empty!", choices=[])
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "multchoicebox":
            listChoices = ["aaa", "bbb", "ccc", "ggg", "hhh", "iii", "jjj", "kkk"
                , "LLL", "mmm" , "nnn", "ooo", "ppp", "qqq"
                , "rrr", "sss", "ttt", "uuu", "vvv"]

            msg = "Pick as many choices as you wish."
            reply = multchoicebox(msg,"Demo of multchoicebox", listChoices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "textbox": _demo_textbox(reply[0])
        elif reply[0] == "codebox": _demo_codebox(reply[0])

        else:
            msgbox("Choice\n\n" + choice + "\n\nis not recognized", "Program Logic Error")
            return


def _demo_textbox(reply):
    text_snippet = ((\
"""It was the best of times, and it was the worst of times.  The rich ate cake, and the poor had cake recommended to them, but wished only for enough cash to buy bread.  The time was ripe for revolution! """ \
*5)+"\n\n")*10
    title = "Demo of textbox"
    msg = "Here is some sample text. " * 16
    reply = textbox(msg, "Text Sample", text_snippet)
    writeln("Reply was: %s" % str(reply))

def _demo_codebox(reply):
    code_snippet = ("dafsdfa dasflkj pp[oadsij asdfp;ij asdfpjkop asdfpok asdfpok asdfpok"*3) +"\n"+\
"""# here is some dummy Python code
for someItem in myListOfStuff:
    do something(someItem)
    do something()
    do something()
    if somethingElse(someItem):
        doSomethingEvenMoreInteresting()

"""*16
    msg = "Here is some sample code. " * 16
    reply = codebox(msg, "Code Sample", code_snippet)
    writeln("Reply was: %s" % repr(reply))


def _demo_buttonbox_with_image():
    image = "python_and_check_logo.gif"

    msg   = "Pretty nice, huh!"
    reply=msgbox(msg,image=image, ok_button="Wow!")
    writeln("Reply was: %s" % repr(reply))

    msg   = "Do you like this picture?"
    choices = ["Yes","No","No opinion"]

    reply=buttonbox(msg,image=image,choices=choices)
    writeln("Reply was: %s" % repr(reply))

    image = os.path.normpath("python_and_check_logo.png")
    reply=buttonbox(msg,image=image, choices=choices)
    writeln("Reply was: %s" % repr(reply))

    image = os.path.normpath("zzzzz.gif")
    reply=buttonbox(msg,image=image, choices=choices)
    writeln("Reply was: %s" % repr(reply))


def _demo_help():
    savedStdout = sys.stdout    # save the sys.stdout file object
    sys.stdout = capturedOutput = StringIO()
    help("easygui")
    sys.stdout = savedStdout   # restore the sys.stdout file object
    codebox("EasyGui Help",text=capturedOutput.getvalue())

def _demo_filesavebox():
    filename = "myNewFile.txt"
    title = "File SaveAs"
    msg ="Save file as:"

    f = filesavebox(msg,title,default=filename)
    writeln("You chose to save file: %s" % f)

def _demo_diropenbox():
    title = "Demo of diropenbox"
    msg = "Pick the directory that you wish to open."
    d = diropenbox(msg, title)
    writeln("You chose directory...: %s" % d)

    d = diropenbox(msg, title,default="./")
    writeln("You chose directory...: %s" % d)

    d = diropenbox(msg, title,default="c:/")
    writeln("You chose directory...: %s" % d)


def _demo_fileopenbox():
    msg  = "Python files"
    title = "Open files"
    default="*.py"
    f = fileopenbox(msg,title,default=default)
    writeln("You chose to open file: %s" % f)

    default="./*.gif"
    filetypes = ["*.jpg",["*.zip","*.tgs","*.gz", "Archive files"],["*.htm", "*.html","HTML files"]]
    f = fileopenbox(msg,title,default=default,filetypes=filetypes)
    writeln("You chose to open file: %s" % f)

    """#deadcode -- testing ----------------------------------------
    f = fileopenbox(None,None,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(None,title,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(msg,None,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(default=None)
    writeln("You chose to open file: %s" % f)
    #----------------------------------------------------deadcode """


def _dummy():
    pass

EASYGUI_ABOUT_INFORMATION = '''
========================================================================
0.96(2010-06-25)
========================================================================
This version fixes some problems with version independence.

BUG FIXES
------------------------------------------------------
 * A statement with Python 2.x-style exception-handling syntax raised
   a syntax error when running under Python 3.x.
   Thanks to David Williams for reporting this problem.

 * Under some circumstances, PIL was unable to display non-gif images
   that it should have been able to display.
   The cause appears to be non-version-independent import syntax.
   PIL modules are now imported with a version-independent syntax.
   Thanks to Horst Jens for reporting this problem.


========================================================================
0.95(2010-06-12)
========================================================================

ENHANCEMENTS
------------------------------------------------------
 * Previous versions of EasyGui could display only .gif image files using the
   msgbox "image" argument. This version can now display all image-file formats
   supported by PIL the Python Imaging Library) if PIL is installed.
   If msgbox is asked to open a non-gif image file, it attempts to import
   PIL and to use PIL to convert the image file to a displayable format.
   If PIL cannot be imported (probably because PIL is not installed)
   EasyGui displays an error message saying that PIL must be installed in order
   to display the image file.

   Note that
   http://www.pythonware.com/products/pil/
   says that PIL doesn't yet support Python 3.x.


========================================================================
0.94(2010-06-06)
========================================================================

ENHANCEMENTS
------------------------------------------------------
 * The codebox and textbox functions now return the contents of the box, rather
   than simply the name of the button ("Yes").  This makes it possible to use
   codebox and textbox as data-entry widgets.  A big "thank you!" to Dominic
   Comtois for requesting this feature, patiently explaining his requirement,
   and helping to discover the tkinter techniques to implement it.

   NOTE THAT in theory this change breaks backward compatibility.  But because
   (in previous versions of EasyGui) the value returned by codebox and textbox
   was meaningless, no application should have been checking it.  So in actual
   practice, this change should not break backward compatibility.

 * Added support for SPACEBAR to command buttons.  Now, when keyboard
   focus is on a command button, a press of the SPACEBAR will act like
   a press of the ENTER key; it will activate the command button.

 * Added support for keyboard navigation with the arrow keys (up,down,left,right)
   to the fields and buttons in enterbox, multenterbox and multpasswordbox,
   and to the buttons in choicebox and all buttonboxes.

 * added highlightthickness=2 to entry fields in multenterbox and
   multpasswordbox.  Now it is easier to tell which entry field has
   keyboard focus.


BUG FIXES
------------------------------------------------------
 * In EgStore, the pickle file is now opened with "rb" and "wb" rather than
   with "r" and "w".  This change is necessary for compatibility with Python 3+.
   Thanks to Marshall Mattingly for reporting this problem and providing the fix.

 * In integerbox, the actual argument names did not match the names described
   in the docstring. Thanks to Daniel Zingaro of at University of Toronto for
   reporting this problem.

 * In integerbox, the "argLowerBound" and "argUpperBound" arguments have been
   renamed to "lowerbound" and "upperbound" and the docstring has been corrected.

   NOTE THAT THIS CHANGE TO THE ARGUMENT-NAMES BREAKS BACKWARD COMPATIBILITY.
   If argLowerBound or argUpperBound are used, an AssertionError with an
   explanatory error message is raised.

 * In choicebox, the signature to choicebox incorrectly showed choicebox as
   accepting a "buttons" argument.  The signature has been fixed.


========================================================================
0.93(2009-07-07)
========================================================================

ENHANCEMENTS
------------------------------------------------------

 * Added exceptionbox to display stack trace of exceptions

 * modified names of some font-related constants to make it
   easier to customize them


========================================================================
0.92(2009-06-22)
========================================================================

ENHANCEMENTS
------------------------------------------------------

 * Added EgStore class to to provide basic easy-to-use persistence.

BUG FIXES
------------------------------------------------------

 * Fixed a bug that was preventing Linux users from copying text out of
   a textbox and a codebox.  This was not a problem for Windows users.

'''

def abouteasygui():
    """
    shows the easygui revision history
    """
    codebox("About EasyGui\n"+egversion,"EasyGui",EASYGUI_ABOUT_INFORMATION)
    return None



if __name__ == '__main__':
    if True:
        egdemo()
    else:
        # test the new root feature
        root = Tk()
        msg = """This is a test of a main Tk() window in which we will place an easygui msgbox.
                It will be an interesting experiment.\n\n"""
        messageWidget = Message(root, text=msg, width=1000)
        messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')
        messageWidget = Message(root, text=msg, width=1000)
        messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')


        msgbox("this is a test of passing in boxRoot", root=root)
        msgbox("this is a second test of passing in boxRoot", root=root)

        reply = enterbox("Enter something", root=root)
        writeln("You wrote:", reply)

        reply = enterbox("Enter something else", root=root)
        writeln("You wrote:", reply)
        root.destroy()

########NEW FILE########
__FILENAME__ = ezmenu
#! /usr/bin/env python

############################################################
#EzMeNu - A simple module to quickly make menus with PyGame#
############################################################
#Licensed under the GNU Lesser General Public License      #
#Created by PyMike <pymike93@gmail.com>                    #
############################################################

import pygame

class EzMenu:

    def __init__(self, *options):
        """Initialise the EzMenu! options should be a sequence of lists in the
        format of [option_name, option_function]"""

        self.options = options
        self.x = 0
        self.y = 0
        self.font = pygame.font.Font(None, 32)
        self.option = 0
        self.width = 1
        self.color = [0, 0, 0]
        self.hcolor = [255, 0, 0]
        self.height = len(self.options)*self.font.get_height()
        for o in self.options:
            text = o[0]
            ren = self.font.render(text, 1, (0, 0, 0))
            if ren.get_width() > self.width:
                self.width = ren.get_width()

    def draw(self, surface):
        """Draw the menu to the surface."""
        i=0
        for o in self.options:
            if i==self.option:
                clr = self.hcolor
            else:
                clr = self.color
            text = o[0]
            ren = self.font.render(text, 1, clr)
            if ren.get_width() > self.width:
                self.width = ren.get_width()
            surface.blit(ren, (self.x, self.y + i*self.font.get_height()))
            i+=1
            
    def update(self, events):
        """Update the menu and get input for the menu."""
        for e in events:
            if e.type == pygame.KEYDOWN:
                if e.key == pygame.K_DOWN:
                    self.option += 1
                if e.key == pygame.K_UP:
                    self.option -= 1
                if e.key == pygame.K_RETURN:
                    self.options[self.option][1]()
        if self.option > len(self.options)-1:
            self.option = 0
        if self.option < 0:
            self.option = len(self.options)-1

    def set_pos(self, x, y):
        """Set the topleft of the menu at x,y"""
        self.x = x
        self.y = y
        
    def set_font(self, font):
        """Set the font used for the menu."""
        self.font = font
        
    def set_highlight_color(self, color):
        """Set the highlight color"""
        self.hcolor = color
        
    def set_normal_color(self, color):
        """Set the normal color"""
        self.color = color
        
    def center_at(self, x, y):
        """Center the center of the menu at x,y"""
        self.x = x-(self.width/2)
        self.y = y-(self.height/2)

########NEW FILE########
__FILENAME__ = screensaver
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       screensaver.py
import pygame
import random

def screensaver(screenresolution = (640,480), fullscreen = False, pygamequit = True):
    # -*- coding: utf-8 -*-
    """very simple test "game" or screensaver.
       all the user have to do is press ESC or SPACE.
       the "game" paint random circles.
       the "game" accept a screen resolution tuple as argument.
       the "game" returns the time passed until the user pressed space"""
    pygame.init()                      #initialize pygame
    if fullscreen:
        screen=pygame.display.set_mode((screenresolution[0],screenresolution[1]), pygame.FULLSCREEN) # set screensize of pygame window
    else:
        screen=pygame.display.set_mode((screenresolution[0],screenresolution[1])) # set screensize of pygame window
    background = pygame.Surface(screen.get_size())  #create empty pygame surface
    background.fill((255,255,255))     #fill the background white color (red,green,blue)
    background = background.convert()  #convert Surface object to make blitting faster
    screen.blit(background, (0,0))     #draw the background on screen
    clock = pygame.time.Clock()        #create a pygame clock object
    mainloop = True                    
    FPS = 30 # desired framerate in frames per second. try out other values !
    playtime = 0.0 # how many seconds the "game" is played
    while mainloop:
        milliseconds = clock.tick(FPS) # do not go faster than this framerate
        playtime += milliseconds / 1000.0 # add seconds to playtime
        # paint random circles
        color = (random.randint(0,255), random.randint(0,255), random.randint(0,255))
        pygame.draw.circle(screen, color, (random.randint(0,screenresolution[0]),
                                           random.randint(0,screenresolution[1])),
                                           random.randint(1, min(screenresolution[0], screenresolution[1])),
                                           random.randint(0,1))        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                mainloop = False # pygame window closed by user
            elif event.type == pygame.KEYDOWN:
                print "event key:", event.key
                if event.key == pygame.K_ESCAPE:
                    mainloop = False # user pressed ESC
                if event.key == pygame.K_SPACE:
                    mainloop = False # user pressed ESC
        pygame.display.set_caption("press ESC to quit. FPS: %.2f (%ix%i), time: %.2f seonds" % (clock.get_fps(), screenresolution[0], screenresolution[1], playtime))
        pygame.display.flip()          # flip the screen like in a flip book
    print "This 'game' was played for %.2f seconds" % playtime
    if pygamequit:
       pygame.quit()
    return playtime # in seconds

if __name__ == '__main__':
    screensaver()

########NEW FILE########
__FILENAME__ = pygamecheatsheet
# Pygame Cheat Sheet
# This program should show you the basics of using the Pygame library.
# by Al Sweigart http://inventwithpython.com
# modification by Horst JENS http://ThePythonGameBook

# Download files from:
#     http://inventwithpython.com/cat.png
#     http://inventwithpython.com/bounce.wav

import pygame, sys, os
#from pygame.locals import *

pygame.init()
fpsClock = pygame.time.Clock()

screen = pygame.display.set_mode((640, 480))
pygame.display.set_caption('Pygame Cheat Sheet')

redColor = pygame.Color(255, 0, 0)
greenColor = pygame.Color(0, 255, 0)
blueColor = pygame.Color(0, 0, 255)
whiteColor = pygame.Color(255, 255, 255)
mousex, mousey = 0, 0
msg = 'Hello world!'
try:
    cat = os.path.join("data",'babytux.png')
    font = os.path.join("data", 'freesansbold.ttf')
    sound = os.path.join("data",'beep.ogg')
except:
    # does not raise alert if file does not exist ! TODO: fix
    raise UserWarning, "could not found files inside subfolder data"
catSurfaceObj = pygame.image.load(cat)
fontObj = pygame.font.Font(font, 32)
soundObj = pygame.mixer.Sound(sound)

while True:
    screen.fill(whiteColor)

    pygame.draw.polygon(screen, greenColor, ((146, 0), (291, 106), (236, 277), (56, 277), (0, 106)))
    pygame.draw.circle(screen, blueColor, (300, 50), 20, 0)
    pygame.draw.ellipse(screen, redColor, (300, 250, 40, 80), 1)
    pygame.draw.rect(screen, redColor, (10, 10, 50, 100))
    pygame.draw.line(screen, blueColor, (60, 160), (120, 60), 4)

    pixArr = pygame.PixelArray(screen)
    for x in range(100, 200, 4):
        for y in range(100, 200, 4):
            pixArr[x][y] = blueColor
    del pixArr


    screen.blit(catSurfaceObj, (mousex, mousey))

    msgSurfaceObj = fontObj.render(msg, False, blueColor)
    msgRectobj = msgSurfaceObj.get_rect()
    msgRectobj.topleft = (10, 20)
    screen.blit(msgSurfaceObj, msgRectobj)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.MOUSEMOTION:
            mousex, mousey = event.pos
        elif event.type == pygame.MOUSEBUTTONUP:
            mousex, mousey = event.pos
            soundObj.play()
            if event.button in (1, 2, 3):
                msg = 'left, middle, or right mouse click'
            elif event.button in (4, 5):
                msg = 'mouse scrolled up or down'

        elif event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_LEFT, pygame.K_RIGHT, 
                             pygame.K_UP, pygame.K_DOWN):
                msg = 'Arrow key pressed.'
            if event.key == pygame.K_a:
                msg = '"A" key pressed'
            if event.key == pygame.K_ESCAPE:
                pygame.event.post(pygame.event.Event(pygame.QUIT))

    pygame.display.update()
    fpsClock.tick(30) # pause to run the loop at 30 frames per second

########NEW FILE########
__FILENAME__ = pygame_template
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Name:    pygmin.py
Purpose: Minimal code skeleton for pygame experiments 
URL:     
Author:  yipyip
Licence: gpl, see http://www.gnu.org/licenses/gpl.html
"""

####

import pygame

####

class PygView(object):

  
    def __init__(self, width=640, height=400):
        
        pygame.init()
        self.width = width
        self.height = height
        self.screen = pygame.display.set_mode((self.width, self.height), pygame.DOUBLEBUF)
        self.fps = 30 # frames per second
        pygame.display.set_caption("Press ESC to quit")
       

    def run(self):
        """The mainloop
        """
        self.clock = pygame.time.Clock() 
        running = True
        while running:
            self.seconds = self.clock.tick(self.fps)/1000.0 # seconds since last frame
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False 
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        running = False

            pygame.display.set_caption("press Esc to quit. Fps: %.2f (%i x %i)"%(self.clock.get_fps(), self.width, self.height))
            pygame.display.flip()          
        pygame.quit()

####

if __name__ == '__main__':

    PygView().run()

########NEW FILE########
__FILENAME__ = combatgame
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       combatgame.py
#       
#       Copyright 2012 Horst JENS <horst.jens@spielend-programmieren.at>
#       part of http://ThePythonGameBook.com
#
#       a simple role-playing game, inspired by rogue-like games
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.

import random 

# some classes

class BaseObject(object):
    """the common grandfather of all classes in this game"""
    def parameter2attribute(self, **kwargs):
        """setting the attributes of the class instance to existing
           keywords (**kwargs) / parameters"""
        for attr in kwargs.keys():
            if attr in self.__dict__:
                self.__dict__[attr] = kwargs[attr]


class Monster(BaseObject):
    number = 0 # a counter for all monsters
    _book = {}  # a dictionary to hold all monsters
    def __init__(self, **kwargs):
        """to create a new monster:
           mymonster = Monster(str = 7, race="orc")"""
        #print "---- a new monster is born ---"
        Monster.number += 1
        self.number = Monster.number
        Monster._book[self.number] = self
        self.strength = 10 # default value, influence damage afflicted to others
        self.dexterity = 10 # default value, influence chance to attack first
        self.intelligence = 10 
        self.gold = 0
        #self.score = 0 # only relevant for player
        self.hitpoints = 10 # default value, how much damage can be taken
        self.race = "unknow"
        self.name = "x"
        self.activeWeapon = 0
        self.activeShield = 0
        self.activeArmor = 0 # body armor
        self.activeHelm = 0
        self.activeShoe = 0
        self.activeGlove = 0
        self.activeMisc1 = 0
        self.activeMisc2 = 0
        self.activeMisc3 = 0
        self.activeMisc4 = 0
        self.attack = 10 # default value, chance to sucessful hit opponent
        self.defense = 10 # default value, chance to evade attack
        self.protection = 0 # default value, how much damage can be negated
        self.parameter2attribute(**kwargs) # a method of parent class BaseObject
        

class Item(BaseObject):
    number = 0
    book = {}
    def __init__(self, **kwargs):
        """to create an item in the game, code:
           mybox = Item(shortdescr="box",
                       longdescr="a wooden, locked box", weight=50)"""
        Item.number += 1
        self.number = Item.number
        Item.book[self.number] = self
        self.value = 0
        self.weight = 0
        self.category = ""
        self.shortdescr = ""
        self.longdescr = ""
        self.MeleeWeapon = False
        self.shield = False
        self.armor = False
        self.parameter2attribute(**kwargs) # a method of parent class BaseObject
    
    
class MeleeWeapon(Item):
    def __init__(self, **kwargs):
        """to create a MeleeWeapon, code (like an item):
            mysword = MeleeWeapon(shortdescr="sword", attack = 7)"""
        Item.__init__(self, **kwargs)
        self.MeleeWeapon = True
        self.attack = 0
        self.defense = 0
        self.damage = 0
        self.length = 0 # melee attacking with a shorter weapon faces a repel action (max. 1 damage)
        self.parameter2attribute(**kwargs)
        
    
# some functions
def showStats(object):
    """display all stats of an class instance"""
    for key in object.__dict__:
        print key, ":", object.__dict__[key]
        
def domDice(sides = 6, minValue = 1):
    """an open-ended dice, inspired from the game Dominions3 by Illwinter.
       Basically, if the highest side of the dice is thrown, the score 
       of (sides-1) is kept and the dice is throwed again, adding the new score.
       This means there is a very low probaility of a very high throw"""
    if not minValue < sides:
        raise UserWarning, "minValue (%i) must be smaller than sides (%i)" % (minValue, sides)
    #score = 0
    eyes = random.randint(minValue, sides) # number of eyes facing us on the dice after throwing
    if eyes == sides:
        eyes = sides - 1 + domDice(sides, minValue) # recursion
    return eyes 
    
def dice(sides=6, minValue = 1):
    """a conventional dice"""
    if not minValue < sides:
        raise UserWarning, "minValue (%i) must be smaller than sides (%i)" % (minValue, sides)
    return  random.randint(minValue, sides)

def multiDice(dices=2, dicetype="domDice", sides=6, minValue=1):
    """throw several dices and return the sum of the eyes
       accept several dicetypes:
       dice
       domDice"""
    eyes = 0
    for _ in range(dices): 
        if dicetype == "dice":
            eyes += dice(sides, minValue)
        elif dicetype == "domDice":
            eyes += domDice(sides, minValue)
    return eyes
        
def meleeAction(attacker, defender, repeldamage=False):
    """the attacker slashes at the defender
       if this is a repel action (for attacking with a shorter MeleeWeapon)
       then the damage is limited to 1 hitpoint"""
    attDice = multiDice()
    defDice = multiDice()
    attWeapon = MeleeWeapon.book[attacker.activeMeleeWeapon].attack
    defWeapon = MeleeWeapon.book[defender.activeMeleeWeapon].defense
    attackValue =  attacker.attack +  attWeapon + attDice 
    defendValue =  defender.defense + defWeapon + defDice
    #---
    damDice = multiDice(1) # fewer influence of random than at attack vs. defense (1 dice vs. 2 dice)
    protDice = multiDice(1)   
    #protDice = 0  # no random bonus for armor !!
    damWeapon = MeleeWeapon.book[attacker.activeMeleeWeapon].damage
    damageValue =     attacker.strength + damWeapon + damDice
    protectionValue = defender.protection + protDice # Shield ????????
    damage = damageValue - protectionValue
    # hit or miss ?
    if attackValue > defendValue:
        if repeldamage:
            w1 = "..Ouch!!"
            w2 = "'s repel action"
        else:
            w1 = "Whamm!"
            w2 = ""
        print "%s %s%s (%i+%i+%i)  hits %s (%i+%i+%i) with %i:%i!"  % (
                                                w1,
                                                attacker.name, 
                                                w2,
                                                attacker.attack, 
                                                attWeapon,
                                                attDice,
                                                defender.name, 
                                                defender.defense,
                                                defWeapon,
                                                defDice,
                                                attackValue,
                                                defendValue)
            
        # damage calculation
        if repeldamage:
            w1 = "..repel damage"
            w2 = ""
            if damage > 0:
                w3 = "1 max. repel"
            else:
                w3 = "no repel"
        else:
            w1 = ".damage"
            w2 = ""
            if damage >0:
                w3 = str(damage) 
            else:
                w3 = "no"
        print "%s (%i+%i+%i)%s minus protection (%i+%i) is %i-%i=%s damage" % (w1, 
                                                                        attacker.strength,
                                                                        damWeapon,
                                                                        damDice,
                                                                        w2 ,
                                                                        defender.protection,
                                                                        protDice,
                                                                        damageValue,
                                                                        protectionValue,
                                                                        w3)         
            
      
        if damage > 0:
            if repeldamage:
                defender.hitpoints -=1 # repel can cause at max 1 hitpoint damage
                print "..Repel action sucess ! %s looses one hitpoint  (%i left)" % (defender.name, defender.hitpoints)
                
            else: # non-repel damage
                print "..%s is hit for %i damage " \
                      "(%i hitpoints remaining)" % (defender.name, damage,
                                                defender.hitpoints-damage)
                defender.hitpoints -= damage  # alter hitpoints
            if defender.hitpoints <= 0:
                print "...%s dies !" % defender.name
        else:
            if repeldamage:
                print "..the repel action fails to penetrate the attackers armor"
            else:
                print "..but can not penetrate his armor"
    else:
        # def > att
        if repeldamage:
            w1 = "dodge"
            w2 = "repel action"
        else:
            w1 = "evade"
            w2 = "attack"
        print "... but %s can %s (%i+%i+%i) the %s (%i+%i+%i) with %i:%i" % (defender.name,
                                                                        w1,
                                                                        defender.defense,
                                                                        defWeapon,
                                                                        defDice,
                                                                        w2,
                                                                        attacker.attack,
                                                                        attWeapon,
                                                                        attDice,
                                                                        defendValue, 
                                                                        attackValue)
        
        
def meleeRound(opponent1, opponent2):
    """the more agile (dex) opponent stabs first, if the defender survive 
       he stabs back"""
    dex1 = opponent1.dexterity + multiDice()
    dex2 = opponent2.dexterity + multiDice()
    #print "who is attacking first ? %s (%i) vs. %s (%i)" % (opponent1.name, dex1, opponent2.name,dex2)
    if dex1 == dex2:
        #print "both opponents are equal skilled"
        # randomly choose first attacker
        dex1 = dex2 + random.choice((-1,1))
    if opponent1.hitpoints > 0 and opponent2.hitpoints >0:
        print "+++Attack! " + dexmsg(opponent1, opponent2, dex1, dex2)
        if dex1 > dex2:
            meleeAttack(opponent1, opponent2) # attack
            if opponent2.hitpoints > 0 and opponent1.hitpoints >0:
                print "+++Counter-Attack!"
                meleeAttack(opponent2, opponent1) # riposte
        else:
            meleeAttack(opponent2, opponent1) # attack
            if opponent1.hitpoints > 0 and opponent2.hitpoints >0:
                print "+++Counter-Attack!"
                meleeAttack(opponent1, opponent2) # riposte

def dexmsg(opponent1, opponent2, dex1, dex2):
    """ returns a message of who is attacking who first. uses cmp to compare stats.
        cmp(a,b) returns -1 if a<b, 0 if a == b and 1 if a>b"""
    mydic1 = {-1:"slower", 0:"equal fast", 1: "faster"}
    mydic2 = {-1:"is attacked first by", 0:"???", 1:"attacks first"}
    msg = "The %s %s (%i) %s %s (%i) with %i:%i" % (mydic1[cmp(opponent1.dexterity, opponent2.dexterity)],
                                    opponent1.name, opponent1.dexterity, 
                                    mydic2[cmp(dex1, dex2)], opponent2.name, opponent2.dexterity , dex1, dex2)
    return msg

def meleeAttack(opponent1, opponent2):
    """
    The melee attack checks if the defender has a longer weapon. if yes,
    the attacker can loose max. 1 hitpoint due to repel action before 
    continuing his attac.
    Note: a meleeround consist of two meleAttacks (attack and counter-attack). Both check for repel damage.
    """
    if (MeleeWeapon.book[opponent1.activeMeleeWeapon].length <
        MeleeWeapon.book[opponent2.activeMeleeWeapon].length):
        print "Repel action: %s attacks with %s (%i) against  %s (%i)" % (opponent1.name,
                                                                           MeleeWeapon.book[opponent1.activeMeleeWeapon].shortdescr, 
                                                                           MeleeWeapon.book[opponent1.activeMeleeWeapon].length, 
                                                                           MeleeWeapon.book[opponent2.activeMeleeWeapon].shortdescr,
                                                                           MeleeWeapon.book[opponent2.activeMeleeWeapon].length )
         
        
        meleeAction(opponent2, opponent1, True) # repel action, max. 1 damage 
    if opponent1.hitpoints >0 and opponent2.hitpoints > 0:
        meleeAction(opponent1, opponent2) # normal attack

        
    
def melee(opponent1, opponent2):
    """melee combat inspired by the dominions3 rules.
       basic formular:
       if attacking with a shorter melee weapon (weapon length),
       the attacker must defend against a repel action, whose damage is
       limited to 1 hitponts. after that, he continues his attack.
       the attacker throws 2 x a 6-sided dice (and re-rolls at a 6), see
       MultiDice) and adds his attack value vs. the defenders defense
       value and his Multidice.
       if the attacker is sucessfull, damage is calculated at damage value
       + strength + multidice vs. protection + multidice.
       **not yet coded: the attack vs. defense value must be higher
       than the defenders shield parry value
       **not yet coded: sum all items for attack + defense + protection boni/mali
       **not yet coded: each part of body has its own protection value,
       depending on armor (shoe, helm, shield...) of defender
       **not yet coded: critical hit, affliction damage 
       """
       
    #print "==== opponents ===="
    #compareStats(opponent1, opponent2)
    #print "==== MeleeWeapons ===="
    #compareStats(MeleeWeapon.book[opponent1.activeMeleeWeapon], 
    #             MeleeWeapon.book[opponent2.activeMeleeWeapon])
    rounds = 0
    while (opponent1.hitpoints > 0) and (opponent2.hitpoints > 0):
        rounds += 1
        print "----melee round %i----" % rounds
        meleeRound(opponent1, opponent2)
    if opponent1.hitpoints > 0:
        victor = opponent1
    else:
        victor = opponent2
    print "*** Victory for %s ***" % victor.name
    return (rounds, victor)

def compareStats(opponent1, opponent2):
    """ compare the attributes (stats) of two monsters"""
    o = {-2:"-",-1:"<",0:"=",1:">"} # compare results
    ignorelist = ( "activeMeleeWeapon", "MeleeWeapon")
    for key in opponent1.__dict__:
        if key in ignorelist:
            continue
        if not (key in opponent2.__dict__):
            continue 
        if "int" in str(type(opponent1.__dict__[key])):
            r = cmp(opponent1.__dict__[key], opponent2.__dict__[key])
        else:
            r=-2 # text can not be compared directly
        print key, ":", opponent1.__dict__[key], o[r], opponent2.__dict__[key]

def testFight(opponent1, opponent2, trials=10000):
    v1 = 0
    v2 = 0
    vrounds = {}
    for x in range(trials):
        savehp1 = opponent1.hitpoints
        savehp2 = opponent2.hitpoints
        print "========================= new battle ====================="
        print "trial number %i" %x
        trialresult = melee(opponent1, opponent2)
        rounds = trialresult[0]
        victor = trialresult[1]
        if rounds in vrounds.keys():
            vrounds[rounds] +=1
        else:
            vrounds[rounds] = 1
        if victor == opponent1:
            v1 +=1
        else:
            v2 +=1
        # restore hitpoints
        opponent1.hitpoints = savehp1
        opponent2.hitpoints = savehp2
    print "========================="
    print "trial result statistic"
    print "========================="
    print "victorys for", opponent1.name, v1
    print "victorys for", opponent2.name, v2
    print "number of combat rounds and battles fought with this number of rounds:", vrounds
    
    
def domDiceTest():
    """print a table of stat differences 
       and the chance that:
       2domDice + stat differecne > 2domDice
       see page 5 of the domionons3 manual"""
    r = {}
    for zahl in range(-14,15,1):
        r[zahl] = 0
        for x in range(1000):
            a = multiDice()
            b = multiDice()
            print zahl, a, b
            if a + zahl > b:
                r[zahl] += 1
    print "---------"
    for key in sorted(r.keys()):
        print key, ":", r[key]

def game():
    """simple role-playing-game"""
    # edit those values !
    player = Monster(strength=10, dexterity=11, hitpoints=10, intelligence=8, protection=10, race="human", name="lordling")
    player.score = 0 # additional attribute only for player
    bozo  = Monster(strength=11, dexterity=10, hitpoints=11, intelligence=8, protection = 10, race="orc", name="bozo")
    axe =        MeleeWeapon(attack=5, defense = 1, damage=3,  length= 1, shortdescr="axe", )
    shortsword = MeleeWeapon(attack=5, defense = 2, damage=2,  length= 2, shortdescr="army sword")
    player.activeMeleeWeapon =  shortsword.number
    bozo.activeMeleeWeapon = axe.number
    print "--------battle---------"
    #melee(player, bozo)
    testFight(player, bozo, 100)

    
            

    
if __name__ == '__main__':
    game()


########NEW FILE########
__FILENAME__ = combatgui1
import Tkinter
import simplerpg





   
class MyGui():
   def __init__(self, master):
      self.label1 = Tkinter.Label(master, text=player.name).grid(row=0, column=0)
      self.label2 = Tkinter.Label(master, text=" vs. ").grid(row=0, column=1)
      self.label3 = Tkinter.Label(master, text=bozo.name).grid(row=0, column=2)
      self.v1 = Tkinter.StringVar()
      self.v2 = Tkinter.StringVar()
      self.v1.set("1")
      self.v2.set("4")
      self.label4=Tkinter.Label(master, textvariable=self.v1).grid(row=1, column=0)
      self.label5=Tkinter.Label(master, text="battles won").grid(row=1,column=1)
      self.label6=Tkinter.Label(master, textvariable=self.v2).grid(row=1,column=2)
      self.buttonquit = Tkinter.Button(master, text='Quit', command=master.quit).grid(row=3, column=3, sticky=Tkinter.W, pady=4)
      self.buttonfight = Tkinter.Button(master, text='Fight', command=self.fight).grid(row=3, column=0, sticky=Tkinter.W, pady=4)

   def fight(self):
      v={}
      vi1, vi2, v = simplerpg.testFight(player, bozo, 100)
      print "result: ", vi1, vi2
      self.v1.set(str(vi1))
      self.v2.set(str(vi2))
      #print app.label4.text
      #self.label4=Tkinter.Label(master, text=self.victorys1.get()).grid(row=1, column=0)
      # self.label4.configure(text=self.victorys1.get()) #geht net, none type object has no configure
      print self.v1.get() # get and set work fine, but how can i force an update of the label field?
   


# initialize fighters and weapons
#from simplerpg
# edit those values !
player = simplerpg.Monster(strength=10, dexterity=11, hitpoints=10, intelligence=8, protection=10, race="human", name="lordling")
player.score = 0 # additional attribute only for player
bozo  = simplerpg.Monster(strength=11, dexterity=10, hitpoints=11, intelligence=8, protection = 10, race="orc", name="bozo")
axe =        simplerpg.MeleeWeapon(attack=5, defense = 1, damage=3,  length= 1, shortdescr="axe", )
shortsword = simplerpg.MeleeWeapon(attack=5, defense = 2, damage=2,  length= 2, shortdescr="army sword")
player.activeMeleeWeapon =  shortsword.number
bozo.activeMeleeWeapon = axe.number
print "--------battle---------"
#melee(player, bozo)
#simplerpg.testFight(player, bozo, 100)



root = Tkinter.Tk()
app = MyGui(root)
root.mainloop()
########NEW FILE########
__FILENAME__ = combatgui_tk
#/usr/bin/env/python
#       combatgui_tk.py
#       needs simplerpg.py in the same folder
#       and makes an Tkinter gui for it
#
#       2012 by Horst JENS <horst.jens@spielend-programmieren.at>
#       part of http://ThePythonGameBook.com
#
#       a simple role-playing game, inspired by rogue-like games
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 3 of the License, or
#       (at your option) any later version.
#       see http://www.gnu.org/licenses/gpl.html for GNU General Public License



import Tkinter
import simplerpg


class MyGui():
   def __init__(self, master):
      """creates the Tkinter Gui with all Labels and Buttons etc."""
      self.label1 = Tkinter.Button(master, text=player.name).grid(row=0, column=1) # was once a label, is no w a button
      self.label2 = Tkinter.Label(master, text=" Fighters: ").grid(row=0, column=0)
      self.label3 = Tkinter.Button(master, text=bozo.name).grid(row=0, column=2)   # was once a label, is no w a button
      self.v1 = Tkinter.StringVar()
      self.v2 = Tkinter.StringVar()
      self.vrounds = Tkinter.StringVar()    # result table
      self.vleftwins = Tkinter.StringVar()  # result table
      self.vrightwins = Tkinter.StringVar() # result table
      self.vtotal = Tkinter.StringVar()     # result table
      self.v4 = Tkinter.StringVar() # rounds to fight
      self.v4.set(100)
      self.v1.set(0)
      self.v2.set(0)
      self.label4=Tkinter.Label(master, textvariable=self.v1).grid(row=1, column=1)
      self.label5=Tkinter.Label(master, text="battles won;").grid(row=1,column=0)
      self.label6=Tkinter.Label(master, textvariable=self.v2).grid(row=1,column=2)
      self.label7=Tkinter.Label(master, text="# of rounds").grid(row=2,column=0)
      self.label8=Tkinter.Label(master, text="victorys").grid(row=2,column=1)
      self.label9=Tkinter.Label(master, text="victorys").grid(row=2,column=2)
      self.label10=Tkinter.Label(master, text="# of battles").grid(row=2,column=3)
      # courier font for non-proportional chars (each char has the same width, good for tables)
      self.message7=Tkinter.Message(master, font="courier", textvariable=self.vrounds).grid(row=3,column=0)
      self.message8=Tkinter.Message(master, font="courier", textvariable=self.vleftwins).grid(row=3,column=1)
      self.message9=Tkinter.Message(master, font="courier", textvariable=self.vrightwins).grid(row=3,column=2)
      self.message10=Tkinter.Message(master, font="courier", textvariable=self.vtotal).grid(row=3,column=3)
      self.label11 = Tkinter.Label(master, text="# of battles to fight:").grid(row=0, column=3)
      self.entry11 = Tkinter.Entry(master, textvariable=self.v4 ).grid(row=1, column=3)
      self.buttonquit = Tkinter.Button(master, text='Quit', command=master.quit).grid(row=5, column=3, sticky=Tkinter.W, pady=4)
      self.buttonfight = Tkinter.Button(master, text='Fight', command=self.fight).grid(row=5, column=0, sticky=Tkinter.W, pady=4)

   def fight(self):
      """calculates a number of fights and print the results"""
      vi1, vi2, v = simplerpg.testFight(player, bozo, int(self.v4.get())) # self.v4 is number of battles
      self.v1.set(str(vi1))
      self.v2.set(str(vi2))
      textrounds = ""
      textleftwins = ""
      textrightwins = ""
      texttotal = ""
      for x in v.keys():  # create result table
         # right align number with 8 whitespaces and a line ending
         textrounds    += "{:>8}".format("%i :\n" % x) 
         textleftwins  += "{:>8}".format("%i \n" % v[x][0]) 
         textrightwins += "{:>8}".format("%i \n" % v[x][1]) 
         texttotal     += "{:>8}".format("%i \n" % v[x][2]) 
      self.vrounds.set(textrounds)
      self.vleftwins.set(textleftwins)
      self.vrightwins.set(textrightwins)
      self.vtotal.set(texttotal)

# initialize fighters and weapons
#from simplerpg
# edit those values !
player = simplerpg.Monster(strength=10, dexterity=11, hitpoints=10, intelligence=8, protection=10, race="human", name="lordling")
player.score = 0 # additional attribute only for player
bozo  = simplerpg.Monster(strength=11, dexterity=10, hitpoints=11, intelligence=8, protection = 10, race="orc", name="bozo")
axe =        simplerpg.MeleeWeapon(attack=5, defense = 1, damage=3,  length= 1, shortdescr="axe", )
shortsword = simplerpg.MeleeWeapon(attack=5, defense = 2, damage=2,  length= 2, shortdescr="army sword")
player.activeMeleeWeapon =  shortsword.number
bozo.activeMeleeWeapon = axe.number
#print "--------battle---------"
#melee(player, bozo)
#simplerpg.testFight(player, bozo, 100)



root = Tkinter.Tk()
app = MyGui(root)
root.mainloop()
########NEW FILE########
__FILENAME__ = danielcrawl001
#!/usr/bin/python
# -*- coding: utf-8 -*-

import random
import curses
#start
stdscr = curses.initscr()
# Keine Anzeige gedrückter Tasten
curses.noecho()
# Kein line-buffer
curses.cbreak()
# Escape-Sequenzen aktivieren
stdscr.keypad(1)
 
# Farben
curses.start_color()
curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLUE)
curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
 
# Fenster und Hintergrundfarben
stdscr.bkgd(curses.color_pair(1))
stdscr.refresh()

windowheight = 10
windowwidth = 20
windowx = 5
windowy = 5

win = curses.newwin(windowheight, windowwidth, windowy, windowx) # (höhe, breite, y, x)
win.bkgd(curses.color_pair(2))
win.box()

 
# Warten auf Tastendruck
c = stdscr.getch()
 
line_start = 1
col_start = 1

monsterx = 7
monstery = 7
monsterdx = 1
monsterdy = 0

def crash():
    for x in range (10):
        curses.init_pair(1, curses.COLOR_RED, curses.COLOR_CYAN)
        curses.init_pair(2, curses.COLOR_MAGENTA, curses.COLOR_WHITE)
        win.refresh()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLUE)
        curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        win.refresh()
        
while True:
  # Teile des Pads aufs Display bringen
  win.clear()
  win.addstr(line_start, col_start, "x")
  win.addstr(monstery, monsterx, "M")
  win.refresh()
  c = stdscr.getch()
  if c == ord('x'):
    break
  elif c == curses.KEY_DOWN:
      if line_start < windowheight-2:
          line_start += 1
      else:
          crash()
  elif c == curses.KEY_UP:
    if line_start > 1:
        line_start -= 1
    else:
        crash()
  elif c == curses.KEY_LEFT:
    if col_start > 1:
        col_start -= 1
    else:
        crash()
  elif c == curses.KEY_RIGHT:
    if col_start < windowwidth-3:
        col_start += 1
    else:
        crash()
  elif c == " ":
	  pass
  #move monster
  
  if monsterx >= windowwidth -3:
      monsterdx = -1
  if monsterx <=  1:
      monsterdx = 1
  monsterx += monsterdx
# Ende
curses.nocbreak()
stdscr.keypad(0)
curses.echo()
curses.endwin()

########NEW FILE########
__FILENAME__ = danielcrawl002
#!/usr/bin/python
# -*- coding: utf-8 -*-

import random
import curses

class Level(object):
    def __init__(self,txt):
        self.lines=len(txt.splitlines())
        self.colls=len(txt.splitlines()[1])
        self.txt=txt
    def check(self, x, y):
        #check if  position x/y is a valid space
        char=self.txt.splitlines()[y][x]
        return char


levels = []

#level0
levels.append(Level("""
#########nnnnnnnnnnnn#########################################
##########            ################  8    MMM             #
###########            ###############  7     MMM            #
############             ############# MMMMMMMMM             #
#############                 ############################   #
##############                ############################   #
###############       O       #######################        #
################              #######################        #
#################                                            #
##################                                           #
##################                                           #
##################                                           #
##################                  B             s          #
||||||||||||||||||                                           #
##################                                           #
##################          l                                #
#                                              D             #
#         T                                                  #
#                            G                               #
#                                                            #
##############################################################
"""))
#T=Troll / G=Goblin / D=DarkElv / B=Bat / O=Ork / M=Mice
#|=breakable wall / #=unbreakable wall
#8=full health potion / 7=super big backpack / s=sword / l=leather helmet


#level1
levels.append(Level("""
#########pppppppppppp#########################################
#                                                            #
#   ###################                    ######            #
#   #                 #                    #    #            #
#   #                 #                    #    #            #
#   #                 #                    #    #            #
#   #                 #                    #    #            #
#   #                 #                    #    #            #
#   #                 #                    #    #            #
#   #                 #                    #    #            #
#   #                 #                    #    #            #
#   #                 #                    #   ##            #
#   #                 #                    #   ##            #
#   #                 #                    #   ##            #
#   #                 #                    #   ##            #
#   #                 #                    #                 #
#   #    #####        #                    #                 #
#   #        #        #                    #                 #
#   ##########        #                    #                 #
#                     #                    #                 #
##########################nnnnnnnnnnnnn#######################
"""))

#level 2
levels.append(Level("""
##############################################################
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
#                                                            #
##########################ppppppppppppp#######################
"""))

#start
stdscr = curses.initscr()
# Keine Anzeige gedrückter Tasten
curses.noecho()
# Kein line-buffer
curses.cbreak()
# Escape-Sequenzen aktivieren
stdscr.keypad(1)
 
# Farben
curses.start_color()
curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLUE)
curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
 
# Fenster und Hintergrundfarben
stdscr.bkgd(curses.color_pair(1))
stdscr.refresh()

windowheight = 10
windowwidth = 20
windowx = 5
windowy = 5

win = curses.newwin(windowheight, windowwidth, windowy, windowx) # (höhe, breite, y, x)
win.bkgd(curses.color_pair(2))
win.box()

 
# Warten auf Tastendruck
c = stdscr.getch()
 
line_start = 1
col_start = 1

monsterx = 7
monstery = 7
monsterdx = 1
monsterdy = 0

def crash():
    for x in range (10):
        curses.init_pair(1, curses.COLOR_RED, curses.COLOR_CYAN)
        curses.init_pair(2, curses.COLOR_MAGENTA, curses.COLOR_WHITE)
        win.refresh()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLUE)
        curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        win.refresh()
        
while True:
  # Teile des Pads aufs Display bringen
  win.clear()
  win.addstr(line_start, col_start, "x")
  win.addstr(monstery, monsterx, "M")
  win.refresh()
  c = stdscr.getch()
  #if c == ord('x'):
  #  break
  if c == curses.KEY_DOWN:
      if line_start < windowheight-2:
          line_start += 1
      else:
          crash()
  elif c == curses.KEY_UP:
    if line_start > 1:
        line_start -= 1
    else:
        crash()
  elif c == curses.KEY_LEFT:
    if col_start > 1:
        col_start -= 1
    else:
        crash()
  elif c == curses.KEY_RIGHT:
    if col_start < windowwidth-3:
        col_start += 1
    else:
        crash()
  elif c == ord(' '):
      pass
  elif c == ord('q'):
      break
  
  #move monster
  
  if monsterx >= windowwidth -3:
      monsterdx = -1
  if monsterx <=  1:
      monsterdx = 1
  monsterx += monsterdx
# Ende
curses.nocbreak()
stdscr.keypad(0)
curses.echo()
curses.endwin()

########NEW FILE########
__FILENAME__ = dragoncave
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       dragoncave.py
#       
#       Copyright 2011 Horst JENS <horst.jens@spielend-programmieren.at>
#       
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.



#def main():
#   
#   return 0
#
#if __name__ == '__main__':
#   main()

# --- some functions, to be replaced by easygui-functions

def msgbox(msg="hi there", title = "window title", button = "ok", root= None, image=None):
    print title
    print msg
    
def inputbox(msg="huh?", title="window title", default="dunno nothing", root=None, image=None):
    print title
    return raw_input("msg", default)
    
def buttonbox(msg="choose a button", title="window title", choices=("one", "two", "three"), root=None, image=None):
    answer = "-1"
    while not answer.isdigit() or (answer <0) or (answer > len(choices)):
        print title
        print msg
        print "type the number and hit ENTER:"
        for button in choices:
            print choices.index(button), button 
            # each button has an index number, starting with 0
        answer = int(raw_input("Your choice:>"))
        print answer
    return choices[answer] # return the text of the selected button
    
        
# -----

gameOver = False

msg = """
You stand in the entry of the famous dragoncave. Your task is to steal
three dragon eggs and return alive. The dragoncave is haunted by the
mighty dragon and other dangers"""
title = "cave entry"
choices = ("leave the cave", "go deeper into the cave")
answer1 = buttonbox(msg, title, choices)
        
    
    


########NEW FILE########
__FILENAME__ = easygui
"""
@version: 0.96(2010-08-29)

@note:
ABOUT EASYGUI

EasyGui provides an easy-to-use interface for simple GUI interaction
with a user.  It does not require the programmer to know anything about
tkinter, frames, widgets, callbacks or lambda.  All GUI interactions are
invoked by simple function calls that return results.

@note:
WARNING about using EasyGui with IDLE

You may encounter problems using IDLE to run programs that use EasyGui. Try it
and find out.  EasyGui is a collection of Tkinter routines that run their own
event loops.  IDLE is also a Tkinter application, with its own event loop.  The
two may conflict, with unpredictable results. If you find that you have
problems, try running your EasyGui program outside of IDLE.

Note that EasyGui requires Tk release 8.0 or greater.

@note:
LICENSE INFORMATION

EasyGui version 0.96

Copyright (c) 2010, Stephen Raymond Ferg

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer. 
    
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation and/or
       other materials provided with the distribution. 
    
    3. The name of the author may not be used to endorse or promote products derived
       from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@note:
ABOUT THE EASYGUI LICENSE

This license is what is generally known as the "modified BSD license",
aka "revised BSD", "new BSD", "3-clause BSD".
See http://www.opensource.org/licenses/bsd-license.php

This license is GPL-compatible.
See http://en.wikipedia.org/wiki/License_compatibility
See http://www.gnu.org/licenses/license-list.html#GPLCompatibleLicenses

The BSD License is less restrictive than GPL.
It allows software released under the license to be incorporated into proprietary products. 
Works based on the software may be released under a proprietary license or as closed source software.
http://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_.28.22New_BSD_License.22.29

"""
egversion = __doc__.split()[1]

__all__ = ['ynbox'
    , 'ccbox'
    , 'boolbox'
    , 'indexbox'
    , 'msgbox'
    , 'buttonbox'
    , 'integerbox'
    , 'multenterbox'
    , 'enterbox'
    , 'exceptionbox'
    , 'choicebox'
    , 'codebox'
    , 'textbox'
    , 'diropenbox'
    , 'fileopenbox'
    , 'filesavebox'
    , 'passwordbox'
    , 'multpasswordbox'
    , 'multchoicebox'
    , 'abouteasygui'
    , 'egversion'
    , 'egdemo'
    , 'EgStore'
    ]

import sys, os
import string
import pickle
import traceback


#--------------------------------------------------
# check python version and take appropriate action
#--------------------------------------------------
"""
From the python documentation:

sys.hexversion contains the version number encoded as a single integer. This is
guaranteed to increase with each version, including proper support for non-
production releases. For example, to test that the Python interpreter is at
least version 1.5.2, use:

if sys.hexversion >= 0x010502F0:
    # use some advanced feature
    ...
else:
    # use an alternative implementation or warn the user
    ...
"""


if sys.hexversion >= 0x020600F0:
    runningPython26 = True
else:
    runningPython26 = False

if sys.hexversion >= 0x030000F0:
    runningPython3 = True
else:
    runningPython3 = False

try:
    from PIL import Image   as PILImage
    from PIL import ImageTk as PILImageTk
    PILisLoaded = True
except:
    PILisLoaded = False


if runningPython3:
    from tkinter import *
    import tkinter.filedialog as tk_FileDialog
    from io import StringIO
else:
    from Tkinter import *
    import tkFileDialog as tk_FileDialog
    from StringIO import StringIO

def write(*args):
    args = [str(arg) for arg in args]
    args = " ".join(args)
    sys.stdout.write(args)

def writeln(*args):
    write(*args)
    sys.stdout.write("\n")

say = writeln


if TkVersion < 8.0 :
    stars = "*"*75
    writeln("""\n\n\n""" + stars + """
You are running Tk version: """ + str(TkVersion) + """
You must be using Tk version 8.0 or greater to use EasyGui.
Terminating.
""" + stars + """\n\n\n""")
    sys.exit(0)

def dq(s):
    return '"%s"' % s

rootWindowPosition = "+300+200"

PROPORTIONAL_FONT_FAMILY = ("MS", "Sans", "Serif")
MONOSPACE_FONT_FAMILY    = ("Courier")

PROPORTIONAL_FONT_SIZE  = 10
MONOSPACE_FONT_SIZE     =  9  #a little smaller, because it it more legible at a smaller size
TEXT_ENTRY_FONT_SIZE    = 12  # a little larger makes it easier to see

#STANDARD_SELECTION_EVENTS = ["Return", "Button-1"]
STANDARD_SELECTION_EVENTS = ["Return", "Button-1", "space"]

# Initialize some global variables that will be reset later
__choiceboxMultipleSelect = None
__widgetTexts = None
__replyButtonText = None
__choiceboxResults = None
__firstWidget = None
__enterboxText = None
__enterboxDefaultText=""
__multenterboxText = ""
choiceboxChoices = None
choiceboxWidget = None
entryWidget = None
boxRoot = None
ImageErrorMsg = (
    "\n\n---------------------------------------------\n"
    "Error: %s\n%s")
#-------------------------------------------------------------------
# various boxes built on top of the basic buttonbox
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# ynbox
#-----------------------------------------------------------------------
def ynbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes", "No")
    , image=None
    ):
    """
    Display a msgbox with choices of Yes and No.

    The default is "Yes".

    The returned value is calculated this way::
        if the first choice ("Yes") is chosen, or if the dialog is cancelled:
            return 1
        else:
            return 0

    If invoked without a msg argument, displays a generic request for a confirmation
    that the user wishes to continue.  So it can be used this way::
        if ynbox(): pass # continue
        else: sys.exit(0)  # exit the program

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    return boolbox(msg, title, choices, image=image)


#-----------------------------------------------------------------------
# ccbox
#-----------------------------------------------------------------------
def ccbox(msg="Shall I continue?"
    , title=" "
    , choices=("Continue", "Cancel")
    , image=None
    ):
    """
    Display a msgbox with choices of Continue and Cancel.

    The default is "Continue".

    The returned value is calculated this way::
        if the first choice ("Continue") is chosen, or if the dialog is cancelled:
            return 1
        else:
            return 0

    If invoked without a msg argument, displays a generic request for a confirmation
    that the user wishes to continue.  So it can be used this way::

        if ccbox():
            pass # continue
        else:
            sys.exit(0)  # exit the program

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    return boolbox(msg, title, choices, image=image)


#-----------------------------------------------------------------------
# boolbox
#-----------------------------------------------------------------------
def boolbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes","No")
    , image=None
    ):
    """
    Display a boolean msgbox.

    The default is the first choice.

    The returned value is calculated this way::
        if the first choice is chosen, or if the dialog is cancelled:
            returns 1
        else:
            returns 0
    """
    reply = buttonbox(msg=msg, choices=choices, title=title, image=image)
    if reply == choices[0]: return 1
    else: return 0


#-----------------------------------------------------------------------
# indexbox
#-----------------------------------------------------------------------
def indexbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes","No")
    , image=None
    ):
    """
    Display a buttonbox with the specified choices.
    Return the index of the choice selected.
    """
    reply = buttonbox(msg=msg, choices=choices, title=title, image=image)
    index = -1
    for choice in choices:
        index = index + 1
        if reply == choice: return index
    raise AssertionError(
        "There is a program logic error in the EasyGui code for indexbox.")


#-----------------------------------------------------------------------
# msgbox
#-----------------------------------------------------------------------
def msgbox(msg="(Your message goes here)", title=" ", ok_button="OK",image=None,root=None):
    """
    Display a messagebox
    """
    if type(ok_button) != type("OK"):
        raise AssertionError("The 'ok_button' argument to msgbox must be a string.")

    return buttonbox(msg=msg, title=title, choices=[ok_button], image=image,root=root)


#-------------------------------------------------------------------
# buttonbox
#-------------------------------------------------------------------
def buttonbox(msg="",title=" "
    ,choices=("Button1", "Button2", "Button3")
    , image=None
    , root=None
    ):
    """
    Display a msg, a title, and a set of buttons.
    The buttons are defined by the members of the choices list.
    Return the text of the button that the user selected.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    global boxRoot, __replyButtonText, __widgetTexts, buttonsFrame


    # Initialize __replyButtonText to the first choice.
    # This is what will be used if the window is closed by the close button.
    __replyButtonText = choices[0]

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.minsize(400, 100)

    # ------------- define the messageFrame ---------------------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the imageFrame ---------------------------------
    tk_Image = None
    if image:
        imageFilename = os.path.normpath(image)
        junk,ext = os.path.splitext(imageFilename)

        if os.path.exists(imageFilename):
            if ext.lower() in [".gif", ".pgm", ".ppm"]:
                tk_Image = PhotoImage(master=boxRoot, file=imageFilename)
            else:
                if PILisLoaded:
                    try:
                        pil_Image = PILImage.open(imageFilename)
                        tk_Image = PILImageTk.PhotoImage(pil_Image, master=boxRoot)
                    except:
                        msg += ImageErrorMsg % (imageFilename,
                            "\nThe Python Imaging Library (PIL) could not convert this file to a displayable image."
                            "\n\nPIL reports:\n" + exception_format())

                else:  # PIL is not loaded
                    msg += ImageErrorMsg % (imageFilename,
                    "\nI could not import the Python Imaging Library (PIL) to display the image.\n\n"
                    "You may need to install PIL\n"
                    "(http://www.pythonware.com/products/pil/)\n"
                    "to display " + ext + " image files.")

        else:
            msg += ImageErrorMsg % (imageFilename, "\nImage file not found.")

    if tk_Image:
        imageFrame = Frame(master=boxRoot)
        imageFrame.pack(side=TOP, fill=BOTH)
        label = Label(imageFrame,image=tk_Image)
        label.image = tk_Image # keep a reference!
        label.pack(side=TOP, expand=YES, fill=X, padx='1m', pady='1m')

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    # -------------------- place the widgets in the frames -----------------------
    messageWidget = Message(messageFrame, text=msg, width=400)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')

    __put_buttons_in_buttonframe(choices)

    # -------------- the action begins -----------
    # put the focus on the first button
    __firstWidget.focus_force()

    boxRoot.deiconify()
    boxRoot.mainloop()
    boxRoot.destroy()
    if root: root.deiconify()
    return __replyButtonText


#-------------------------------------------------------------------
# integerbox
#-------------------------------------------------------------------
def integerbox(msg=""
    , title=" "
    , default=""
    , lowerbound=0
    , upperbound=99
    , image = None
    , root  = None
    , **invalidKeywordArguments
    ):
    """
    Show a box in which a user can enter an integer.

    In addition to arguments for msg and title, this function accepts
    integer arguments for "default", "lowerbound", and "upperbound".

    The default argument may be None.

    When the user enters some text, the text is checked to verify that it
    can be converted to an integer between the lowerbound and upperbound.

    If it can be, the integer (not the text) is returned.

    If it cannot, then an error msg is displayed, and the integerbox is
    redisplayed.

    If the user cancels the operation, None is returned.

    NOTE that the "argLowerBound" and "argUpperBound" arguments are no longer
    supported.  They have been replaced by "upperbound" and "lowerbound".
    """
    if "argLowerBound" in invalidKeywordArguments:
        raise AssertionError(
            "\nintegerbox no longer supports the 'argLowerBound' argument.\n"
            + "Use 'lowerbound' instead.\n\n")
    if "argUpperBound" in invalidKeywordArguments:
        raise AssertionError(
            "\nintegerbox no longer supports the 'argUpperBound' argument.\n"
            + "Use 'upperbound' instead.\n\n")

    if default != "":
        if type(default) != type(1):
            raise AssertionError(
                "integerbox received a non-integer value for "
                + "default of " + dq(str(default)) , "Error")

    if type(lowerbound) != type(1):
        raise AssertionError(
            "integerbox received a non-integer value for "
            + "lowerbound of " + dq(str(lowerbound)) , "Error")

    if type(upperbound) != type(1):
        raise AssertionError(
            "integerbox received a non-integer value for "
            + "upperbound of " + dq(str(upperbound)) , "Error")

    if msg == "":
        msg = ("Enter an integer between " + str(lowerbound)
            + " and "
            + str(upperbound)
            )

    while 1:
        reply = enterbox(msg, title, str(default), image=image, root=root)
        if reply == None: return None

        try:
            reply = int(reply)
        except:
            msgbox ("The value that you entered:\n\t%s\nis not an integer." % dq(str(reply))
                    , "Error")
            continue

        if reply < lowerbound:
            msgbox ("The value that you entered is less than the lower bound of "
                + str(lowerbound) + ".", "Error")
            continue

        if reply > upperbound:
            msgbox ("The value that you entered is greater than the upper bound of "
                + str(upperbound) + ".", "Error")
            continue

        # reply has passed all validation checks.
        # It is an integer between the specified bounds.
        return reply

#-------------------------------------------------------------------
# multenterbox
#-------------------------------------------------------------------
def multenterbox(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    ):
    r"""
    Show screen with multiple data entry fields.

    If there are fewer values than names, the list of values is padded with
    empty strings until the number of values is the same as the number of names.

    If there are more values than names, the list of values
    is truncated so that there are as many values as names.

    Returns a list of the values of the fields,
    or None if the user cancels the operation.

    Here is some example code, that shows how values returned from
    multenterbox can be checked for validity before they are accepted::
        ----------------------------------------------------------------------
        msg = "Enter your personal information"
        title = "Credit Card Application"
        fieldNames = ["Name","Street Address","City","State","ZipCode"]
        fieldValues = []  # we start with blanks for the values
        fieldValues = multenterbox(msg,title, fieldNames)

        # make sure that none of the fields was left blank
        while 1:
            if fieldValues == None: break
            errmsg = ""
            for i in range(len(fieldNames)):
                if fieldValues[i].strip() == "":
                    errmsg += ('"%s" is a required field.\n\n' % fieldNames[i])
            if errmsg == "":
                break # no problems found
            fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)

        writeln("Reply was: %s" % str(fieldValues))
        ----------------------------------------------------------------------

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg fields: a list of fieldnames.
    @arg values:  a list of field values
    """
    return __multfillablebox(msg,title,fields,values,None)


#-----------------------------------------------------------------------
# multpasswordbox
#-----------------------------------------------------------------------
def multpasswordbox(msg="Fill in values for the fields."
    , title=" "
    , fields=tuple()
    ,values=tuple()
    ):
    r"""
    Same interface as multenterbox.  But in multpassword box,
    the last of the fields is assumed to be a password, and
    is masked with asterisks.

    Example
    =======

    Here is some example code, that shows how values returned from
    multpasswordbox can be checked for validity before they are accepted::
        msg = "Enter logon information"
        title = "Demo of multpasswordbox"
        fieldNames = ["Server ID", "User ID", "Password"]
        fieldValues = []  # we start with blanks for the values
        fieldValues = multpasswordbox(msg,title, fieldNames)

        # make sure that none of the fields was left blank
        while 1:
            if fieldValues == None: break
            errmsg = ""
            for i in range(len(fieldNames)):
                if fieldValues[i].strip() == "":
                    errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
            fieldValues = multpasswordbox(errmsg, title, fieldNames, fieldValues)

        writeln("Reply was: %s" % str(fieldValues))
    """
    return __multfillablebox(msg,title,fields,values,"*")

def bindArrows(widget):
    widget.bind("<Down>", tabRight)
    widget.bind("<Up>"  , tabLeft)

    widget.bind("<Right>",tabRight)
    widget.bind("<Left>" , tabLeft)

def tabRight(event):
    boxRoot.event_generate("<Tab>")

def tabLeft(event):
    boxRoot.event_generate("<Shift-Tab>")

#-----------------------------------------------------------------------
# __multfillablebox
#-----------------------------------------------------------------------
def __multfillablebox(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    , mask = None
    ):
    global boxRoot, __multenterboxText, __multenterboxDefaultText, cancelButton, entryWidget, okButton

    choices = ["OK", "Cancel"]
    if len(fields) == 0: return None

    fields = list(fields[:])  # convert possible tuples to a list
    values = list(values[:])  # convert possible tuples to a list

    if   len(values) == len(fields): pass
    elif len(values) >  len(fields):
        fields = fields[0:len(values)]
    else:
        while len(values) < len(fields):
            values.append("")

    boxRoot = Tk()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.bind("<Escape>", __multenterboxCancel)

    # -------------------- put subframes in the boxRoot --------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    #-------------------- the msg widget ----------------------------
    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    global entryWidgets
    entryWidgets = []

    lastWidgetIndex = len(fields) - 1

    for widgetIndex in range(len(fields)):
        argFieldName  = fields[widgetIndex]
        argFieldValue = values[widgetIndex]
        entryFrame = Frame(master=boxRoot)
        entryFrame.pack(side=TOP, fill=BOTH)

        # --------- entryWidget ----------------------------------------------
        labelWidget = Label(entryFrame, text=argFieldName)
        labelWidget.pack(side=LEFT)

        entryWidget = Entry(entryFrame, width=40,highlightthickness=2)
        entryWidgets.append(entryWidget)
        entryWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,TEXT_ENTRY_FONT_SIZE))
        entryWidget.pack(side=RIGHT, padx="3m")

        bindArrows(entryWidget)

        entryWidget.bind("<Return>", __multenterboxGetText)
        entryWidget.bind("<Escape>", __multenterboxCancel)

        # for the last entryWidget, if this is a multpasswordbox,
        # show the contents as just asterisks
        if widgetIndex == lastWidgetIndex:
            if mask:
                entryWidgets[widgetIndex].configure(show=mask)

        # put text into the entryWidget
        entryWidgets[widgetIndex].insert(0,argFieldValue)
        widgetIndex += 1

    # ------------------ ok button -------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=BOTTOM, fill=BOTH)

    okButton = Button(buttonsFrame, takefocus=1, text="OK")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __multenterboxGetText
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __multenterboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------- time for action! -----------------
    entryWidgets[0].focus_force()    # put the focus on the entryWidget
    boxRoot.mainloop()  # run it!

    # -------- after the run has completed ----------------------------------
    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    return __multenterboxText


#-----------------------------------------------------------------------
# __multenterboxGetText
#-----------------------------------------------------------------------
def __multenterboxGetText(event):
    global __multenterboxText

    __multenterboxText = []
    for entryWidget in entryWidgets:
        __multenterboxText.append(entryWidget.get())
    boxRoot.quit()


def __multenterboxCancel(event):
    global __multenterboxText
    __multenterboxText = None
    boxRoot.quit()


#-------------------------------------------------------------------
# enterbox
#-------------------------------------------------------------------
def enterbox(msg="Enter something."
    , title=" "
    , default=""
    , strip=True
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter some text.

    You may optionally specify some default text, which will appear in the
    enterbox when it is displayed.

    Returns the text that the user entered, or None if he cancels the operation.

    By default, enterbox strips its result (i.e. removes leading and trailing
    whitespace).  (If you want it not to strip, use keyword argument: strip=False.)
    This makes it easier to test the results of the call::

        reply = enterbox(....)
        if reply:
            ...
        else:
            ...
    """
    result = __fillablebox(msg, title, default=default, mask=None,image=image,root=root)
    if result and strip:
        result = result.strip()
    return result


def passwordbox(msg="Enter your password."
    , title=" "
    , default=""
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter a password.
    The text is masked with asterisks, so the password is not displayed.
    Returns the text that the user entered, or None if he cancels the operation.
    """
    return __fillablebox(msg, title, default, mask="*",image=image,root=root)


def __fillablebox(msg
    , title=""
    , default=""
    , mask=None
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter some text.
    You may optionally specify some default text, which will appear in the
    enterbox when it is displayed.
    Returns the text that the user entered, or None if he cancels the operation.
    """

    global boxRoot, __enterboxText, __enterboxDefaultText
    global cancelButton, entryWidget, okButton

    if title == None: title == ""
    if default == None: default = ""
    __enterboxDefaultText = default
    __enterboxText        = __enterboxDefaultText

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.bind("<Escape>", __enterboxCancel)

    # ------------- define the messageFrame ---------------------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the imageFrame ---------------------------------
    tk_Image = None
    if image:
        imageFilename = os.path.normpath(image)
        junk,ext = os.path.splitext(imageFilename)

        if os.path.exists(imageFilename):
            if ext.lower() in [".gif", ".pgm", ".ppm"]:
                tk_Image = PhotoImage(master=boxRoot, file=imageFilename)
            else:
                if PILisLoaded:
                    try:
                        pil_Image = PILImage.open(imageFilename)
                        tk_Image = PILImageTk.PhotoImage(pil_Image, master=boxRoot)
                    except:
                        msg += ImageErrorMsg % (imageFilename,
                            "\nThe Python Imaging Library (PIL) could not convert this file to a displayable image."
                            "\n\nPIL reports:\n" + exception_format())

                else:  # PIL is not loaded
                    msg += ImageErrorMsg % (imageFilename,
                    "\nI could not import the Python Imaging Library (PIL) to display the image.\n\n"
                    "You may need to install PIL\n"
                    "(http://www.pythonware.com/products/pil/)\n"
                    "to display " + ext + " image files.")

        else:
            msg += ImageErrorMsg % (imageFilename, "\nImage file not found.")

    if tk_Image:
        imageFrame = Frame(master=boxRoot)
        imageFrame.pack(side=TOP, fill=BOTH)
        label = Label(imageFrame,image=tk_Image)
        label.image = tk_Image # keep a reference!
        label.pack(side=TOP, expand=YES, fill=X, padx='1m', pady='1m')

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)


    # ------------- define the entryFrame ---------------------------------
    entryFrame = Frame(master=boxRoot)
    entryFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    #-------------------- the msg widget ----------------------------
    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    # --------- entryWidget ----------------------------------------------
    entryWidget = Entry(entryFrame, width=40)
    bindArrows(entryWidget)
    entryWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,TEXT_ENTRY_FONT_SIZE))
    if mask:
        entryWidget.configure(show=mask)
    entryWidget.pack(side=LEFT, padx="3m")
    entryWidget.bind("<Return>", __enterboxGetText)
    entryWidget.bind("<Escape>", __enterboxCancel)
    # put text into the entryWidget
    entryWidget.insert(0,__enterboxDefaultText)

    # ------------------ ok button -------------------------------
    okButton = Button(buttonsFrame, takefocus=1, text="OK")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __enterboxGetText
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __enterboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)

    # ------------------- time for action! -----------------
    entryWidget.focus_force()    # put the focus on the entryWidget
    boxRoot.deiconify()
    boxRoot.mainloop()  # run it!

    # -------- after the run has completed ----------------------------------
    if root: root.deiconify()
    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    return __enterboxText


def __enterboxGetText(event):
    global __enterboxText
    
    __enterboxText = entryWidget.get()
    boxRoot.quit()


def __enterboxRestore(event):
    global entryWidget
    
    entryWidget.delete(0,len(entryWidget.get()))
    entryWidget.insert(0, __enterboxDefaultText)


def __enterboxCancel(event):
    global __enterboxText
    
    __enterboxText = None
    boxRoot.quit()

def denyWindowManagerClose():
    """ don't allow WindowManager close
    """
    x = Tk()
    x.withdraw()
    x.bell()
    x.destroy()



#-------------------------------------------------------------------
# multchoicebox
#-------------------------------------------------------------------
def multchoicebox(msg="Pick as many items as you like."
    , title=" "
    , choices=()
    , **kwargs
    ):
    """
    Present the user with a list of choices.
    allow him to select multiple items and return them in a list.
    if the user doesn't choose anything from the list, return the empty list.
    return None if he cancelled selection.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    if len(choices) == 0: choices = ["Program logic error - no choices were specified."]

    global __choiceboxMultipleSelect
    __choiceboxMultipleSelect = 1
    return __choicebox(msg, title, choices)


#-----------------------------------------------------------------------
# choicebox
#-----------------------------------------------------------------------
def choicebox(msg="Pick something."
    , title=" "
    , choices=()
    ):
    """
    Present the user with a list of choices.
    return the choice that he selects.
    return None if he cancels the selection selection.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    if len(choices) == 0: choices = ["Program logic error - no choices were specified."]

    global __choiceboxMultipleSelect
    __choiceboxMultipleSelect = 0
    return __choicebox(msg,title,choices)


#-----------------------------------------------------------------------
# __choicebox
#-----------------------------------------------------------------------
def __choicebox(msg
    , title
    , choices
    ):
    """
    internal routine to support choicebox() and multchoicebox()
    """
    global boxRoot, __choiceboxResults, choiceboxWidget, defaultText
    global choiceboxWidget, choiceboxChoices
    #-------------------------------------------------------------------
    # If choices is a tuple, we make it a list so we can sort it.
    # If choices is already a list, we make a new list, so that when
    # we sort the choices, we don't affect the list object that we
    # were given.
    #-------------------------------------------------------------------
    choices = list(choices[:])
    if len(choices) == 0:
        choices = ["Program logic error - no choices were specified."]
    defaultButtons = ["OK", "Cancel"]

    # make sure all choices are strings
    for index in range(len(choices)):
        choices[index] = str(choices[index])

    lines_to_show = min(len(choices), 20)
    lines_to_show = 20

    if title == None: title = ""

    # Initialize __choiceboxResults
    # This is the value that will be returned if the user clicks the close icon
    __choiceboxResults = None

    boxRoot = Tk()
    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    screen_width  = boxRoot.winfo_screenwidth()
    screen_height = boxRoot.winfo_screenheight()
    root_width    = int((screen_width * 0.8))
    root_height   = int((screen_height * 0.5))
    root_xpos     = int((screen_width * 0.1))
    root_ypos     = int((screen_height * 0.05))

    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    rootWindowPosition = "+0+0"
    boxRoot.geometry(rootWindowPosition)
    boxRoot.expand=NO
    boxRoot.minsize(root_width, root_height)
    rootWindowPosition = "+" + str(root_xpos) + "+" + str(root_ypos)
    boxRoot.geometry(rootWindowPosition)

    # ---------------- put the frames in the window -----------------------------------------
    message_and_buttonsFrame = Frame(master=boxRoot)
    message_and_buttonsFrame.pack(side=TOP, fill=X, expand=NO)

    messageFrame = Frame(message_and_buttonsFrame)
    messageFrame.pack(side=LEFT, fill=X, expand=YES)
    #messageFrame.pack(side=TOP, fill=X, expand=YES)

    buttonsFrame = Frame(message_and_buttonsFrame)
    buttonsFrame.pack(side=RIGHT, expand=NO, pady=0)
    #buttonsFrame.pack(side=TOP, expand=YES, pady=0)

    choiceboxFrame = Frame(master=boxRoot)
    choiceboxFrame.pack(side=BOTTOM, fill=BOTH, expand=YES)

    # -------------------------- put the widgets in the frames ------------------------------

    # ---------- put a msg widget in the msg frame-------------------
    messageWidget = Message(messageFrame, anchor=NW, text=msg, width=int(root_width * 0.9))
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=LEFT, expand=YES, fill=BOTH, padx='1m', pady='1m')

    # --------  put the choiceboxWidget in the choiceboxFrame ---------------------------
    choiceboxWidget = Listbox(choiceboxFrame
        , height=lines_to_show
        , borderwidth="1m"
        , relief="flat"
        , bg="white"
        )

    if __choiceboxMultipleSelect:
        choiceboxWidget.configure(selectmode=MULTIPLE)

    choiceboxWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))

    # add a vertical scrollbar to the frame
    rightScrollbar = Scrollbar(choiceboxFrame, orient=VERTICAL, command=choiceboxWidget.yview)
    choiceboxWidget.configure(yscrollcommand = rightScrollbar.set)

    # add a horizontal scrollbar to the frame
    bottomScrollbar = Scrollbar(choiceboxFrame, orient=HORIZONTAL, command=choiceboxWidget.xview)
    choiceboxWidget.configure(xscrollcommand = bottomScrollbar.set)

    # pack the Listbox and the scrollbars.  Note that although we must define
    # the textArea first, we must pack it last, so that the bottomScrollbar will
    # be located properly.

    bottomScrollbar.pack(side=BOTTOM, fill = X)
    rightScrollbar.pack(side=RIGHT, fill = Y)

    choiceboxWidget.pack(side=LEFT, padx="1m", pady="1m", expand=YES, fill=BOTH)

    #---------------------------------------------------
    # sort the choices
    # eliminate duplicates
    # put the choices into the choiceboxWidget
    #---------------------------------------------------
    for index in range(len(choices)):
        choices[index] = str(choices[index])

    if runningPython3:
        choices.sort(key=str.lower)
    else:
        choices.sort( lambda x,y: cmp(x.lower(),    y.lower())) # case-insensitive sort

    lastInserted = None
    choiceboxChoices = []
    for choice in choices:
        if choice == lastInserted: pass
        else:
            choiceboxWidget.insert(END, choice)
            choiceboxChoices.append(choice)
            lastInserted = choice

    boxRoot.bind('<Any-Key>', KeyboardListener)

    # put the buttons in the buttonsFrame
    if len(choices) > 0:
        okButton = Button(buttonsFrame, takefocus=YES, text="OK", height=1, width=6)
        bindArrows(okButton)
        okButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

        # for the commandButton, bind activation events to the activation event handler
        commandButton  = okButton
        handler = __choiceboxGetChoice
        for selectionEvent in STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

        # now bind the keyboard events
        choiceboxWidget.bind("<Return>", __choiceboxGetChoice)
        choiceboxWidget.bind("<Double-Button-1>", __choiceboxGetChoice)
    else:
        # now bind the keyboard events
        choiceboxWidget.bind("<Return>", __choiceboxCancel)
        choiceboxWidget.bind("<Double-Button-1>", __choiceboxCancel)

    cancelButton = Button(buttonsFrame, takefocus=YES, text="Cancel", height=1, width=6)
    bindArrows(cancelButton)
    cancelButton.pack(expand=NO, side=BOTTOM, padx='2m', pady='1m', ipady="1m", ipadx="2m")

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __choiceboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # add special buttons for multiple select features
    if len(choices) > 0 and __choiceboxMultipleSelect:
        selectionButtonsFrame = Frame(messageFrame)
        selectionButtonsFrame.pack(side=RIGHT, fill=Y, expand=NO)

        selectAllButton = Button(selectionButtonsFrame, text="Select All", height=1, width=6)
        bindArrows(selectAllButton)

        selectAllButton.bind("<Button-1>",__choiceboxSelectAll)
        selectAllButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

        clearAllButton = Button(selectionButtonsFrame, text="Clear All", height=1, width=6)
        bindArrows(clearAllButton)
        clearAllButton.bind("<Button-1>",__choiceboxClearAll)
        clearAllButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")


    # -------------------- bind some keyboard events ----------------------------
    boxRoot.bind("<Escape>", __choiceboxCancel)

    # --------------------- the action begins -----------------------------------
    # put the focus on the choiceboxWidget, and the select highlight on the first item
    choiceboxWidget.select_set(0)
    choiceboxWidget.focus_force()

    # --- run it! -----
    boxRoot.mainloop()

    boxRoot.destroy()
    return __choiceboxResults


def __choiceboxGetChoice(event):
    global boxRoot, __choiceboxResults, choiceboxWidget
    
    if __choiceboxMultipleSelect:
        __choiceboxResults = [choiceboxWidget.get(index) for index in choiceboxWidget.curselection()]

    else:
        choice_index = choiceboxWidget.curselection()
        __choiceboxResults = choiceboxWidget.get(choice_index)

    # writeln("Debugging> mouse-event=", event, " event.type=", event.type)
    # writeln("Debugging> choice=", choice_index, __choiceboxResults)
    boxRoot.quit()


def __choiceboxSelectAll(event):
    global choiceboxWidget, choiceboxChoices
    
    choiceboxWidget.selection_set(0, len(choiceboxChoices)-1)

def __choiceboxClearAll(event):
    global choiceboxWidget, choiceboxChoices
    
    choiceboxWidget.selection_clear(0, len(choiceboxChoices)-1)



def __choiceboxCancel(event):
    global boxRoot, __choiceboxResults
    
    __choiceboxResults = None
    boxRoot.quit()


def KeyboardListener(event):
    global choiceboxChoices, choiceboxWidget
    key = event.keysym
    if len(key) <= 1:
        if key in string.printable:
            # Find the key in the list.
            # before we clear the list, remember the selected member
            try:
                start_n = int(choiceboxWidget.curselection()[0])
            except IndexError:
                start_n = -1

            ## clear the selection.
            choiceboxWidget.selection_clear(0, 'end')

            ## start from previous selection +1
            for n in range(start_n+1, len(choiceboxChoices)):
                item = choiceboxChoices[n]
                if item[0].lower() == key.lower():
                    choiceboxWidget.selection_set(first=n)
                    choiceboxWidget.see(n)
                    return
            else:
                # has not found it so loop from top
                for n in range(len(choiceboxChoices)):
                    item = choiceboxChoices[n]
                    if item[0].lower() == key.lower():
                        choiceboxWidget.selection_set(first = n)
                        choiceboxWidget.see(n)
                        return

                # nothing matched -- we'll look for the next logical choice
                for n in range(len(choiceboxChoices)):
                    item = choiceboxChoices[n]
                    if item[0].lower() > key.lower():
                        if n > 0:
                            choiceboxWidget.selection_set(first = (n-1))
                        else:
                            choiceboxWidget.selection_set(first = 0)
                        choiceboxWidget.see(n)
                        return

                # still no match (nothing was greater than the key)
                # we set the selection to the first item in the list
                lastIndex = len(choiceboxChoices)-1
                choiceboxWidget.selection_set(first = lastIndex)
                choiceboxWidget.see(lastIndex)
                return

#-----------------------------------------------------------------------
# exception_format
#-----------------------------------------------------------------------
def exception_format():
    """
    Convert exception info into a string suitable for display.
    """
    return "".join(traceback.format_exception(
           sys.exc_info()[0]
        ,  sys.exc_info()[1]
        ,  sys.exc_info()[2]
        ))

#-----------------------------------------------------------------------
# exceptionbox
#-----------------------------------------------------------------------
def exceptionbox(msg=None, title=None):
    """
    Display a box that gives information about
    an exception that has just been raised.

    The caller may optionally pass in a title for the window, or a
    msg to accompany the error information.

    Note that you do not need to (and cannot) pass an exception object
    as an argument.  The latest exception will automatically be used.
    """
    if title == None: title = "Error Report"
    if msg == None:
        msg = "An error (exception) has occurred in the program."

    codebox(msg, title, exception_format())

#-------------------------------------------------------------------
# codebox
#-------------------------------------------------------------------

def codebox(msg=""
    , title=" "
    , text=""
    ):
    """
    Display some text in a monospaced font, with no line wrapping.
    This function is suitable for displaying code and text that is
    formatted using spaces.

    The text parameter should be a string, or a list or tuple of lines to be
    displayed in the textbox.
    """
    return textbox(msg, title, text, codebox=1 )

#-------------------------------------------------------------------
# textbox
#-------------------------------------------------------------------
def textbox(msg=""
    , title=" "
    , text=""
    , codebox=0
    ):
    """
    Display some text in a proportional font with line wrapping at word breaks.
    This function is suitable for displaying general written text.

    The text parameter should be a string, or a list or tuple of lines to be
    displayed in the textbox.
    """

    if msg == None: msg = ""
    if title == None: title = ""

    global boxRoot, __replyButtonText, __widgetTexts, buttonsFrame
    global rootWindowPosition
    choices = ["OK"]
    __replyButtonText = choices[0]


    boxRoot = Tk()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )

    screen_width = boxRoot.winfo_screenwidth()
    screen_height = boxRoot.winfo_screenheight()
    root_width = int((screen_width * 0.8))
    root_height = int((screen_height * 0.5))
    root_xpos = int((screen_width * 0.1))
    root_ypos = int((screen_height * 0.05))

    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    rootWindowPosition = "+0+0"
    boxRoot.geometry(rootWindowPosition)
    boxRoot.expand=NO
    boxRoot.minsize(root_width, root_height)
    rootWindowPosition = "+" + str(root_xpos) + "+" + str(root_ypos)
    boxRoot.geometry(rootWindowPosition)

    mainframe = Frame(master=boxRoot)
    mainframe.pack(side=TOP, fill=BOTH, expand=YES)

    # ----  put frames in the window -----------------------------------
    # we pack the textboxFrame first, so it will expand first
    textboxFrame = Frame(mainframe, borderwidth=3)
    textboxFrame.pack(side=BOTTOM , fill=BOTH, expand=YES)

    message_and_buttonsFrame = Frame(mainframe)
    message_and_buttonsFrame.pack(side=TOP, fill=X, expand=NO)

    messageFrame = Frame(message_and_buttonsFrame)
    messageFrame.pack(side=LEFT, fill=X, expand=YES)

    buttonsFrame = Frame(message_and_buttonsFrame)
    buttonsFrame.pack(side=RIGHT, expand=NO)

    # -------------------- put widgets in the frames --------------------

    # put a textArea in the top frame
    if codebox:
        character_width = int((root_width * 0.6) / MONOSPACE_FONT_SIZE)
        textArea = Text(textboxFrame,height=25,width=character_width, padx="2m", pady="1m")
        textArea.configure(wrap=NONE)
        textArea.configure(font=(MONOSPACE_FONT_FAMILY, MONOSPACE_FONT_SIZE))

    else:
        character_width = int((root_width * 0.6) / MONOSPACE_FONT_SIZE)
        textArea = Text(
            textboxFrame
            , height=25
            , width=character_width
            , padx="2m"
            , pady="1m"
            )
        textArea.configure(wrap=WORD)
        textArea.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))


    # some simple keybindings for scrolling
    mainframe.bind("<Next>" , textArea.yview_scroll( 1,PAGES))
    mainframe.bind("<Prior>", textArea.yview_scroll(-1,PAGES))

    mainframe.bind("<Right>", textArea.xview_scroll( 1,PAGES))
    mainframe.bind("<Left>" , textArea.xview_scroll(-1,PAGES))

    mainframe.bind("<Down>", textArea.yview_scroll( 1,UNITS))
    mainframe.bind("<Up>"  , textArea.yview_scroll(-1,UNITS))


    # add a vertical scrollbar to the frame
    rightScrollbar = Scrollbar(textboxFrame, orient=VERTICAL, command=textArea.yview)
    textArea.configure(yscrollcommand = rightScrollbar.set)

    # add a horizontal scrollbar to the frame
    bottomScrollbar = Scrollbar(textboxFrame, orient=HORIZONTAL, command=textArea.xview)
    textArea.configure(xscrollcommand = bottomScrollbar.set)

    # pack the textArea and the scrollbars.  Note that although we must define
    # the textArea first, we must pack it last, so that the bottomScrollbar will
    # be located properly.

    # Note that we need a bottom scrollbar only for code.
    # Text will be displayed with wordwrap, so we don't need to have a horizontal
    # scroll for it.
    if codebox:
        bottomScrollbar.pack(side=BOTTOM, fill=X)
    rightScrollbar.pack(side=RIGHT, fill=Y)

    textArea.pack(side=LEFT, fill=BOTH, expand=YES)


    # ---------- put a msg widget in the msg frame-------------------
    messageWidget = Message(messageFrame, anchor=NW, text=msg, width=int(root_width * 0.9))
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=LEFT, expand=YES, fill=BOTH, padx='1m', pady='1m')

    # put the buttons in the buttonsFrame
    okButton = Button(buttonsFrame, takefocus=YES, text="OK", height=1, width=6)
    okButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __textboxOK
    for selectionEvent in ["Return","Button-1","Escape"]:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ----------------- the action begins ----------------------------------------
    try:
        # load the text into the textArea
        if type(text) == type("abc"): pass
        else:
            try:
                text = "".join(text)  # convert a list or a tuple to a string
            except:
                msgbox("Exception when trying to convert "+ str(type(text)) + " to text in textArea")
                sys.exit(16)
        textArea.insert(END,text, "normal")

    except:
        msgbox("Exception when trying to load the textArea.")
        sys.exit(16)

    try:
        okButton.focus_force()
    except:
        msgbox("Exception when trying to put focus on okButton.")
        sys.exit(16)

    boxRoot.mainloop()

    # this line MUST go before the line that destroys boxRoot
    areaText = textArea.get(0.0,END)
    boxRoot.destroy()
    return areaText # return __replyButtonText

#-------------------------------------------------------------------
# __textboxOK
#-------------------------------------------------------------------
def __textboxOK(event):
    global boxRoot
    boxRoot.quit()



#-------------------------------------------------------------------
# diropenbox
#-------------------------------------------------------------------
def diropenbox(msg=None
    , title=None
    , default=None
    ):
    """
    A dialog to get a directory name.
    Note that the msg argument, if specified, is ignored.

    Returns the name of a directory, or None if user chose to cancel.

    If the "default" argument specifies a directory name, and that
    directory exists, then the dialog box will start with that directory.
    """
    title=getFileDialogTitle(msg,title)
    localRoot = Tk()
    localRoot.withdraw()
    if not default: default = None
    f = tk_FileDialog.askdirectory(
          parent=localRoot
        , title=title
        , initialdir=default
        , initialfile=None
        )
    localRoot.destroy()
    if not f: return None
    return os.path.normpath(f)



#-------------------------------------------------------------------
# getFileDialogTitle
#-------------------------------------------------------------------
def getFileDialogTitle(msg
    , title
    ):
    if msg and title: return "%s - %s" % (title,msg)
    if msg and not title: return str(msg)
    if title and not msg: return str(title)
    return None # no message and no title

#-------------------------------------------------------------------
# class FileTypeObject for use with fileopenbox
#-------------------------------------------------------------------
class FileTypeObject:
    def __init__(self,filemask):
        if len(filemask) == 0:
            raise AssertionError('Filetype argument is empty.')

        self.masks = []

        if type(filemask) == type("abc"):  # a string
            self.initializeFromString(filemask)

        elif type(filemask) == type([]): # a list
            if len(filemask) < 2:
                raise AssertionError('Invalid filemask.\n'
                +'List contains less than 2 members: "%s"' % filemask)
            else:
                self.name  = filemask[-1]
                self.masks = list(filemask[:-1] )
        else:
            raise AssertionError('Invalid filemask: "%s"' % filemask)

    def __eq__(self,other):
        if self.name == other.name: return True
        return False

    def add(self,other):
        for mask in other.masks:
            if mask in self.masks: pass
            else: self.masks.append(mask)

    def toTuple(self):
        return (self.name,tuple(self.masks))

    def isAll(self):
        if self.name == "All files": return True
        return False

    def initializeFromString(self, filemask):
        # remove everything except the extension from the filemask
        self.ext = os.path.splitext(filemask)[1]
        if self.ext == "" : self.ext = ".*"
        if self.ext == ".": self.ext = ".*"
        self.name = self.getName()
        self.masks = ["*" + self.ext]

    def getName(self):
        e = self.ext
        if e == ".*"  : return "All files"
        if e == ".txt": return "Text files"
        if e == ".py" : return "Python files"
        if e == ".pyc" : return "Python files"
        if e == ".xls": return "Excel files"
        if e.startswith("."):
            return e[1:].upper() + " files"
        return e.upper() + " files"


#-------------------------------------------------------------------
# fileopenbox
#-------------------------------------------------------------------
def fileopenbox(msg=None
    , title=None
    , default="*"
    , filetypes=None
    ):
    """
    A dialog to get a file name.

    About the "default" argument
    ============================
        The "default" argument specifies a filepath that (normally)
        contains one or more wildcards.
        fileopenbox will display only files that match the default filepath.
        If omitted, defaults to "*" (all files in the current directory).

        WINDOWS EXAMPLE::
            ...default="c:/myjunk/*.py"
        will open in directory c:\myjunk\ and show all Python files.

        WINDOWS EXAMPLE::
            ...default="c:/myjunk/test*.py"
        will open in directory c:\myjunk\ and show all Python files
        whose names begin with "test".


        Note that on Windows, fileopenbox automatically changes the path
        separator to the Windows path separator (backslash).

    About the "filetypes" argument
    ==============================
        If specified, it should contain a list of items,
        where each item is either::
            - a string containing a filemask          # e.g. "*.txt"
            - a list of strings, where all of the strings except the last one
                are filemasks (each beginning with "*.",
                such as "*.txt" for text files, "*.py" for Python files, etc.).
                and the last string contains a filetype description

        EXAMPLE::
            filetypes = ["*.css", ["*.htm", "*.html", "HTML files"]  ]

    NOTE THAT
    =========

        If the filetypes list does not contain ("All files","*"),
        it will be added.

        If the filetypes list does not contain a filemask that includes
        the extension of the "default" argument, it will be added.
        For example, if     default="*abc.py"
        and no filetypes argument was specified, then
        "*.py" will automatically be added to the filetypes argument.

    @rtype: string or None
    @return: the name of a file, or None if user chose to cancel

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg default: filepath with wildcards
    @arg filetypes: filemasks that a user can choose, e.g. "*.txt"
    """
    localRoot = Tk()
    localRoot.withdraw()

    initialbase, initialfile, initialdir, filetypes = fileboxSetup(default,filetypes)

    #------------------------------------------------------------
    # if initialfile contains no wildcards; we don't want an
    # initial file. It won't be used anyway.
    # Also: if initialbase is simply "*", we don't want an
    # initialfile; it is not doing any useful work.
    #------------------------------------------------------------
    if (initialfile.find("*") < 0) and (initialfile.find("?") < 0):
        initialfile = None
    elif initialbase == "*":
        initialfile = None

    f = tk_FileDialog.askopenfilename(parent=localRoot
        , title=getFileDialogTitle(msg,title)
        , initialdir=initialdir
        , initialfile=initialfile
        , filetypes=filetypes
        )

    localRoot.destroy()

    if not f: return None
    return os.path.normpath(f)


#-------------------------------------------------------------------
# filesavebox
#-------------------------------------------------------------------
def filesavebox(msg=None
    , title=None
    , default=""
    , filetypes=None
    ):
    """
    A file to get the name of a file to save.
    Returns the name of a file, or None if user chose to cancel.

    The "default" argument should contain a filename (i.e. the
    current name of the file to be saved).  It may also be empty,
    or contain a filemask that includes wildcards.

    The "filetypes" argument works like the "filetypes" argument to
    fileopenbox.
    """

    localRoot = Tk()
    localRoot.withdraw()

    initialbase, initialfile, initialdir, filetypes = fileboxSetup(default,filetypes)

    f = tk_FileDialog.asksaveasfilename(parent=localRoot
        , title=getFileDialogTitle(msg,title)
        , initialfile=initialfile
        , initialdir=initialdir
        , filetypes=filetypes
        )
    localRoot.destroy()
    if not f: return None
    return os.path.normpath(f)


#-------------------------------------------------------------------
#
# fileboxSetup
#
#-------------------------------------------------------------------
def fileboxSetup(default,filetypes):
    if not default: default = os.path.join(".","*")
    initialdir, initialfile = os.path.split(default)
    if not initialdir : initialdir  = "."
    if not initialfile: initialfile = "*"
    initialbase, initialext = os.path.splitext(initialfile)
    initialFileTypeObject = FileTypeObject(initialfile)

    allFileTypeObject = FileTypeObject("*")
    ALL_filetypes_was_specified = False

    if not filetypes: filetypes= []
    filetypeObjects = []

    for filemask in filetypes:
        fto = FileTypeObject(filemask)

        if fto.isAll():
            ALL_filetypes_was_specified = True # remember this

        if fto == initialFileTypeObject:
            initialFileTypeObject.add(fto) # add fto to initialFileTypeObject
        else:
            filetypeObjects.append(fto)

    #------------------------------------------------------------------
    # make sure that the list of filetypes includes the ALL FILES type.
    #------------------------------------------------------------------
    if ALL_filetypes_was_specified:
        pass
    elif allFileTypeObject == initialFileTypeObject:
        pass
    else:
        filetypeObjects.insert(0,allFileTypeObject)
    #------------------------------------------------------------------
    # Make sure that the list includes the initialFileTypeObject
    # in the position in the list that will make it the default.
    # This changed between Python version 2.5 and 2.6
    #------------------------------------------------------------------
    if len(filetypeObjects) == 0:
        filetypeObjects.append(initialFileTypeObject)

    if initialFileTypeObject in (filetypeObjects[0], filetypeObjects[-1]):
        pass
    else:
        if runningPython26:
            filetypeObjects.append(initialFileTypeObject)
        else:
            filetypeObjects.insert(0,initialFileTypeObject)

    filetypes = [fto.toTuple() for fto in filetypeObjects]

    return initialbase, initialfile, initialdir, filetypes

#-------------------------------------------------------------------
# utility routines
#-------------------------------------------------------------------
# These routines are used by several other functions in the EasyGui module.

def __buttonEvent(event):
    """
    Handle an event that is generated by a person clicking a button.
    """
    global  boxRoot, __widgetTexts, __replyButtonText
    __replyButtonText = __widgetTexts[event.widget]
    boxRoot.quit() # quit the main loop


def __put_buttons_in_buttonframe(choices):
    """Put the buttons in the buttons frame
    """
    global __widgetTexts, __firstWidget, buttonsFrame

    __firstWidget = None
    __widgetTexts = {}

    i = 0

    for buttonText in choices:
        tempButton = Button(buttonsFrame, takefocus=1, text=buttonText)
        bindArrows(tempButton)
        tempButton.pack(expand=YES, side=LEFT, padx='1m', pady='1m', ipadx='2m', ipady='1m')

        # remember the text associated with this widget
        __widgetTexts[tempButton] = buttonText

        # remember the first widget, so we can put the focus there
        if i == 0:
            __firstWidget = tempButton
            i = 1

        # for the commandButton, bind activation events to the activation event handler
        commandButton  = tempButton
        handler = __buttonEvent
        for selectionEvent in STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

#-----------------------------------------------------------------------
#
#     class EgStore
#
#-----------------------------------------------------------------------
class EgStore:
    r"""
A class to support persistent storage.

You can use EgStore to support the storage and retrieval
of user settings for an EasyGui application.


# Example A
#-----------------------------------------------------------------------
# define a class named Settings as a subclass of EgStore
#-----------------------------------------------------------------------
class Settings(EgStore):
::
    def __init__(self, filename):  # filename is required
        #-------------------------------------------------
        # Specify default/initial values for variables that
        # this particular application wants to remember.
        #-------------------------------------------------
        self.userId = ""
        self.targetServer = ""

        #-------------------------------------------------
        # For subclasses of EgStore, these must be
        # the last two statements in  __init__
        #-------------------------------------------------
        self.filename = filename  # this is required
        self.restore()            # restore values from the storage file if possible



# Example B
#-----------------------------------------------------------------------
# create settings, a persistent Settings object
#-----------------------------------------------------------------------
settingsFile = "myApp_settings.txt"
settings = Settings(settingsFile)

user    = "obama_barak"
server  = "whitehouse1"
settings.userId = user
settings.targetServer = server
settings.store()    # persist the settings

# run code that gets a new value for userId, and persist the settings
user    = "biden_joe"
settings.userId = user
settings.store()


# Example C
#-----------------------------------------------------------------------
# recover the Settings instance, change an attribute, and store it again.
#-----------------------------------------------------------------------
settings = Settings(settingsFile)
settings.userId = "vanrossum_g"
settings.store()

"""
    def __init__(self, filename):  # obtaining filename is required
        self.filename = None
        raise NotImplementedError()

    def restore(self):
        """
        Set the values of whatever attributes are recoverable
        from the pickle file.

        Populate the attributes (the __dict__) of the EgStore object
        from     the attributes (the __dict__) of the pickled object.

        If the pickled object has attributes that have been initialized
        in the EgStore object, then those attributes of the EgStore object
        will be replaced by the values of the corresponding attributes
        in the pickled object.

        If the pickled object is missing some attributes that have
        been initialized in the EgStore object, then those attributes
        of the EgStore object will retain the values that they were
        initialized with.

        If the pickled object has some attributes that were not
        initialized in the EgStore object, then those attributes
        will be ignored.

        IN SUMMARY:

        After the recover() operation, the EgStore object will have all,
        and only, the attributes that it had when it was initialized.

        Where possible, those attributes will have values recovered
        from the pickled object.
        """
        if not os.path.exists(self.filename): return self
        if not os.path.isfile(self.filename): return self

        try:
            f = open(self.filename,"rb")
            unpickledObject = pickle.load(f)
            f.close()

            for key in list(self.__dict__.keys()):
                default = self.__dict__[key]
                self.__dict__[key] = unpickledObject.__dict__.get(key,default)
        except:
            pass

        return self

    def store(self):
        """
        Save the attributes of the EgStore object to a pickle file.
        Note that if the directory for the pickle file does not already exist,
        the store operation will fail.
        """
        f = open(self.filename, "wb")
        pickle.dump(self, f)
        f.close()


    def kill(self):
        """
        Delete my persistent file (i.e. pickle file), if it exists.
        """
        if os.path.isfile(self.filename):
            os.remove(self.filename)
        return

    def __str__(self):
        """
        return my contents as a string in an easy-to-read format.
        """
        # find the length of the longest attribute name
        longest_key_length = 0
        keys = []
        for key in self.__dict__.keys():
            keys.append(key)
            longest_key_length = max(longest_key_length, len(key))

        keys.sort()  # sort the attribute names
        lines = []
        for key in keys:
            value = self.__dict__[key]
            key = key.ljust(longest_key_length)
            lines.append("%s : %s\n" % (key,repr(value))  )
        return "".join(lines)  # return a string showing the attributes




#-----------------------------------------------------------------------
#
# test/demo easygui
#
#-----------------------------------------------------------------------
def egdemo():
    """
    Run the EasyGui demo.
    """
    # clear the console
    writeln("\n" * 100)

    intro_message = ("Pick the kind of box that you wish to demo.\n"
    + "\n * Python version " + sys.version
    + "\n * EasyGui version " + egversion
    + "\n * Tk version " + str(TkVersion)
    )

    #========================================== END DEMONSTRATION DATA


    while 1: # do forever
        choices = [
            "msgbox",
            "buttonbox",
            "buttonbox(image) -- a buttonbox that displays an image",
            "choicebox",
            "multchoicebox",
            "textbox",
            "ynbox",
            "ccbox",
            "enterbox",
            "enterbox(image) -- an enterbox that displays an image",
            "exceptionbox",
            "codebox",
            "integerbox",
            "boolbox",
            "indexbox",
            "filesavebox",
            "fileopenbox",
            "passwordbox",
            "multenterbox",
            "multpasswordbox",
            "diropenbox",
            "About EasyGui",
            " Help"
            ]
        choice = choicebox(msg=intro_message
            , title="EasyGui " + egversion
            , choices=choices)

        if not choice: return

        reply = choice.split()

        if   reply[0] == "msgbox":
            reply = msgbox("short msg", "This is a long title")
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "About":
            reply = abouteasygui()

        elif reply[0] == "Help":
            _demo_help()

        elif reply[0] == "buttonbox":
            reply = buttonbox()
            writeln("Reply was: %s" % repr(reply))

            title = "Demo of Buttonbox with many, many buttons!"
            msg = "This buttonbox shows what happens when you specify too many buttons."
            reply = buttonbox(msg=msg, title=title, choices=choices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "buttonbox(image)":
            _demo_buttonbox_with_image()

        elif reply[0] == "boolbox":
            reply = boolbox()
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "enterbox":
            image = "python_and_check_logo.gif"
            message = "Enter the name of your best friend."\
                      "\n(Result will be stripped.)"
            reply = enterbox(message, "Love!", "     Suzy Smith     ")
            writeln("Reply was: %s" % repr(reply))

            message = "Enter the name of your best friend."\
                      "\n(Result will NOT be stripped.)"
            reply = enterbox(message, "Love!", "     Suzy Smith     ",strip=False)
            writeln("Reply was: %s" % repr(reply))

            reply = enterbox("Enter the name of your worst enemy:", "Hate!")
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "enterbox(image)":
            image = "python_and_check_logo.gif"
            message = "What kind of snake is this?"
            reply = enterbox(message, "Quiz",image=image)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "exceptionbox":
            try:
                thisWillCauseADivideByZeroException = 1/0
            except:
                exceptionbox()

        elif reply[0] == "integerbox":
            reply = integerbox(
                "Enter a number between 3 and 333",
                "Demo: integerbox WITH a default value",
                222, 3, 333)
            writeln("Reply was: %s" % repr(reply))

            reply = integerbox(
                "Enter a number between 0 and 99",
                "Demo: integerbox WITHOUT a default value"
                )
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "diropenbox" : _demo_diropenbox()
        elif reply[0] == "fileopenbox": _demo_fileopenbox()
        elif reply[0] == "filesavebox": _demo_filesavebox()

        elif reply[0] == "indexbox":
            title = reply[0]
            msg   =  "Demo of " + reply[0]
            choices = ["Choice1", "Choice2", "Choice3", "Choice4"]
            reply = indexbox(msg, title, choices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "passwordbox":
            reply = passwordbox("Demo of password box WITHOUT default"
                + "\n\nEnter your secret password", "Member Logon")
            writeln("Reply was: %s" % str(reply))

            reply = passwordbox("Demo of password box WITH default"
                + "\n\nEnter your secret password", "Member Logon", "alfie")
            writeln("Reply was: %s" % str(reply))

        elif reply[0] == "multenterbox":
            msg = "Enter your personal information"
            title = "Credit Card Application"
            fieldNames = ["Name","Street Address","City","State","ZipCode"]
            fieldValues = []  # we start with blanks for the values
            fieldValues = multenterbox(msg,title, fieldNames)

            # make sure that none of the fields was left blank
            while 1:
                if fieldValues == None: break
                errmsg = ""
                for i in range(len(fieldNames)):
                    if fieldValues[i].strip() == "":
                        errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
                fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)

            writeln("Reply was: %s" % str(fieldValues))

        elif reply[0] == "multpasswordbox":
            msg = "Enter logon information"
            title = "Demo of multpasswordbox"
            fieldNames = ["Server ID", "User ID", "Password"]
            fieldValues = []  # we start with blanks for the values
            fieldValues = multpasswordbox(msg,title, fieldNames)

            # make sure that none of the fields was left blank
            while 1:
                if fieldValues == None: break
                errmsg = ""
                for i in range(len(fieldNames)):
                    if fieldValues[i].strip() == "":
                        errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
                fieldValues = multpasswordbox(errmsg, title, fieldNames, fieldValues)

            writeln("Reply was: %s" % str(fieldValues))

        elif reply[0] == "ynbox":
            title = "Demo of ynbox"
            msg = "Were you expecting the Spanish Inquisition?"
            reply = ynbox(msg, title)
            writeln("Reply was: %s" % repr(reply))
            if reply:
                msgbox("NOBODY expects the Spanish Inquisition!", "Wrong!")

        elif reply[0] == "ccbox":
            title = "Demo of ccbox"
            reply = ccbox(msg,title)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "choicebox":
            title = "Demo of choicebox"
            longchoice = "This is an example of a very long option which you may or may not wish to choose."*2
            listChoices = ["nnn", "ddd", "eee", "fff", "aaa", longchoice
                    , "aaa", "bbb", "ccc", "ggg", "hhh", "iii", "jjj", "kkk", "LLL", "mmm" , "nnn", "ooo", "ppp", "qqq", "rrr", "sss", "ttt", "uuu", "vvv"]

            msg = "Pick something. " + ("A wrapable sentence of text ?! "*30) + "\nA separate line of text."*6
            reply = choicebox(msg=msg, choices=listChoices)
            writeln("Reply was: %s" % repr(reply))

            msg = "Pick something. "
            reply = choicebox(msg=msg, title=title, choices=listChoices)
            writeln("Reply was: %s" % repr(reply))

            msg = "Pick something. "
            reply = choicebox(msg="The list of choices is empty!", choices=[])
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "multchoicebox":
            listChoices = ["aaa", "bbb", "ccc", "ggg", "hhh", "iii", "jjj", "kkk"
                , "LLL", "mmm" , "nnn", "ooo", "ppp", "qqq"
                , "rrr", "sss", "ttt", "uuu", "vvv"]

            msg = "Pick as many choices as you wish."
            reply = multchoicebox(msg,"Demo of multchoicebox", listChoices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "textbox": _demo_textbox(reply[0])
        elif reply[0] == "codebox": _demo_codebox(reply[0])

        else:
            msgbox("Choice\n\n" + choice + "\n\nis not recognized", "Program Logic Error")
            return


def _demo_textbox(reply):
    text_snippet = ((\
"""It was the best of times, and it was the worst of times.  The rich ate cake, and the poor had cake recommended to them, but wished only for enough cash to buy bread.  The time was ripe for revolution! """ \
*5)+"\n\n")*10
    title = "Demo of textbox"
    msg = "Here is some sample text. " * 16
    reply = textbox(msg, title, text_snippet)
    writeln("Reply was: %s" % str(reply))

def _demo_codebox(reply):
    code_snippet = ("dafsdfa dasflkj pp[oadsij asdfp;ij asdfpjkop asdfpok asdfpok asdfpok"*3) +"\n"+\
"""# here is some dummy Python code
for someItem in myListOfStuff:
    do something(someItem)
    do something()
    do something()
    if somethingElse(someItem):
        doSomethingEvenMoreInteresting()

"""*16
    msg = "Here is some sample code. " * 16
    reply = codebox(msg, "Code Sample", code_snippet)
    writeln("Reply was: %s" % repr(reply))


def _demo_buttonbox_with_image():

    msg   = "Do you like this picture?\nIt is "  
    choices = ["Yes","No","No opinion"]

    for image in [
        "python_and_check_logo.gif"
        ,"python_and_check_logo.jpg"
        ,"python_and_check_logo.png"
        ,"zzzzz.gif"]:

        reply=buttonbox(msg + image,image=image,choices=choices)
        writeln("Reply was: %s" % repr(reply))


def _demo_help():
    savedStdout = sys.stdout    # save the sys.stdout file object
    sys.stdout = capturedOutput = StringIO()
    help("easygui")
    sys.stdout = savedStdout   # restore the sys.stdout file object
    codebox("EasyGui Help",text=capturedOutput.getvalue())

def _demo_filesavebox():
    filename = "myNewFile.txt"
    title = "File SaveAs"
    msg ="Save file as:"

    f = filesavebox(msg,title,default=filename)
    writeln("You chose to save file: %s" % f)

def _demo_diropenbox():
    title = "Demo of diropenbox"
    msg = "Pick the directory that you wish to open."
    d = diropenbox(msg, title)
    writeln("You chose directory...: %s" % d)

    d = diropenbox(msg, title,default="./")
    writeln("You chose directory...: %s" % d)

    d = diropenbox(msg, title,default="c:/")
    writeln("You chose directory...: %s" % d)


def _demo_fileopenbox():
    msg  = "Python files"
    title = "Open files"
    default="*.py"
    f = fileopenbox(msg,title,default=default)
    writeln("You chose to open file: %s" % f)

    default="./*.gif"
    filetypes = ["*.jpg",["*.zip","*.tgs","*.gz", "Archive files"],["*.htm", "*.html","HTML files"]]
    f = fileopenbox(msg,title,default=default,filetypes=filetypes)
    writeln("You chose to open file: %s" % f)

    """#deadcode -- testing ----------------------------------------
    f = fileopenbox(None,None,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(None,title,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(msg,None,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(default=None)
    writeln("You chose to open file: %s" % f)
    #----------------------------------------------------deadcode """


def _dummy():
    pass

EASYGUI_ABOUT_INFORMATION = '''
========================================================================
0.96(2010-08-29)
========================================================================
This version fixes some problems with version independence.

BUG FIXES
------------------------------------------------------
 * A statement with Python 2.x-style exception-handling syntax raised
   a syntax error when running under Python 3.x.
   Thanks to David Williams for reporting this problem.

 * Under some circumstances, PIL was unable to display non-gif images
   that it should have been able to display.
   The cause appears to be non-version-independent import syntax.
   PIL modules are now imported with a version-independent syntax.
   Thanks to Horst Jens for reporting this problem.

LICENSE CHANGE
------------------------------------------------------
Starting with this version, EasyGui is licensed under what is generally known as
the "modified BSD license" (aka "revised BSD", "new BSD", "3-clause BSD").
This license is GPL-compatible but less restrictive than GPL.
Earlier versions were licensed under the Creative Commons Attribution License 2.0.


========================================================================
0.95(2010-06-12)
========================================================================

ENHANCEMENTS
------------------------------------------------------
 * Previous versions of EasyGui could display only .gif image files using the
   msgbox "image" argument. This version can now display all image-file formats
   supported by PIL the Python Imaging Library) if PIL is installed.
   If msgbox is asked to open a non-gif image file, it attempts to import
   PIL and to use PIL to convert the image file to a displayable format.
   If PIL cannot be imported (probably because PIL is not installed)
   EasyGui displays an error message saying that PIL must be installed in order
   to display the image file.

   Note that
   http://www.pythonware.com/products/pil/
   says that PIL doesn't yet support Python 3.x.


========================================================================
0.94(2010-06-06)
========================================================================

ENHANCEMENTS
------------------------------------------------------
 * The codebox and textbox functions now return the contents of the box, rather
   than simply the name of the button ("Yes").  This makes it possible to use
   codebox and textbox as data-entry widgets.  A big "thank you!" to Dominic
   Comtois for requesting this feature, patiently explaining his requirement,
   and helping to discover the tkinter techniques to implement it.

   NOTE THAT in theory this change breaks backward compatibility.  But because
   (in previous versions of EasyGui) the value returned by codebox and textbox
   was meaningless, no application should have been checking it.  So in actual
   practice, this change should not break backward compatibility.

 * Added support for SPACEBAR to command buttons.  Now, when keyboard
   focus is on a command button, a press of the SPACEBAR will act like
   a press of the ENTER key; it will activate the command button.

 * Added support for keyboard navigation with the arrow keys (up,down,left,right)
   to the fields and buttons in enterbox, multenterbox and multpasswordbox,
   and to the buttons in choicebox and all buttonboxes.

 * added highlightthickness=2 to entry fields in multenterbox and
   multpasswordbox.  Now it is easier to tell which entry field has
   keyboard focus.


BUG FIXES
------------------------------------------------------
 * In EgStore, the pickle file is now opened with "rb" and "wb" rather than
   with "r" and "w".  This change is necessary for compatibility with Python 3+.
   Thanks to Marshall Mattingly for reporting this problem and providing the fix.

 * In integerbox, the actual argument names did not match the names described
   in the docstring. Thanks to Daniel Zingaro of at University of Toronto for
   reporting this problem.

 * In integerbox, the "argLowerBound" and "argUpperBound" arguments have been
   renamed to "lowerbound" and "upperbound" and the docstring has been corrected.

   NOTE THAT THIS CHANGE TO THE ARGUMENT-NAMES BREAKS BACKWARD COMPATIBILITY.
   If argLowerBound or argUpperBound are used, an AssertionError with an
   explanatory error message is raised.

 * In choicebox, the signature to choicebox incorrectly showed choicebox as
   accepting a "buttons" argument.  The signature has been fixed.


========================================================================
0.93(2009-07-07)
========================================================================

ENHANCEMENTS
------------------------------------------------------

 * Added exceptionbox to display stack trace of exceptions

 * modified names of some font-related constants to make it
   easier to customize them


========================================================================
0.92(2009-06-22)
========================================================================

ENHANCEMENTS
------------------------------------------------------

 * Added EgStore class to to provide basic easy-to-use persistence.

BUG FIXES
------------------------------------------------------

 * Fixed a bug that was preventing Linux users from copying text out of
   a textbox and a codebox.  This was not a problem for Windows users.

'''

def abouteasygui():
    """
    shows the easygui revision history
    """
    codebox("About EasyGui\n"+egversion,"EasyGui",EASYGUI_ABOUT_INFORMATION)
    return None



if __name__ == '__main__':
    if True:
        egdemo()
    else:
        # test the new root feature
        root = Tk()
        msg = """This is a test of a main Tk() window in which we will place an easygui msgbox.
                It will be an interesting experiment.\n\n"""
        messageWidget = Message(root, text=msg, width=1000)
        messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')
        messageWidget = Message(root, text=msg, width=1000)
        messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')


        msgbox("this is a test of passing in boxRoot", root=root)
        msgbox("this is a second test of passing in boxRoot", root=root)

        reply = enterbox("Enter something", root=root)
        writeln("You wrote:", reply)

        reply = enterbox("Enter something else", root=root)
        writeln("You wrote:", reply)
        root.destroy()

########NEW FILE########
__FILENAME__ = combatsimviewer
"""display text output of goblindice004.py inside a tkinter text gui"""
import sys
import os.path 

try:
    import goblindice004 as goblin
    import easygui
except:
    print("Failure: sadly, the import of the easygui.py and/or"
          "goblindice004. py failed. Please make both files are "
          "inside a python path or copy both files into the same"
          "folder as this program.")
    sys.exit()


def check_files(*filenames):
    """"check if files exist in the same folder as this program.
    filenames must be passed as comma seperated parameters"""
    txt = ""
    for filename in filenames:
        ok = True
        if os.path.isfile(filename):
            txt += "\n{} exist".format(filename)
        else:
            txt += "\n{} not found"
            ok = False
    return ok, txt

def clean():
    """return fresh values for playtester_gui"""
    return 0,0,0,[],[],[],"\n\n no battles yet",""
    
def make_txt(m1,m2,m1_wins,m2_wins,m1_hp,m2_hp,battles, battlerounds):
    text = "\n{}\n{}\n".format(m1,m2)
    if battles > 0 and len(m1_hp) >0:
        text += "\nVictorys for {}: {} ({:.2f}%)".format(
           m1.name, m1_wins, m1_wins/battles * 100) 
        text+=" ~hp: {:.1f}".format(sum(m1_hp)/len(m1_hp))
        #text+="\nwins: " + int(100 * m1_wins/battles)*"V"
    if battles > 0 and len(m2_hp) >0:
        text += "\nVictorys for {}: {} ({:.2f}%)".format(
           m2.name, m2_wins, m2_wins/battles * 100)
        text+=" ~hp: {:.1f}".format(sum(m2_hp)/len(m2_hp))
        #text+="\nwins: " + int(100 * m1_wins/battles)*"V"
    if battles >0:
        text+="\n\nbattles: {} ~duration: {:.1f}".format(battles, 
              sum(battlerounds)/len(battlerounds))
    return text
    
def show_log(battles, vtext, log):
    if  battles == 0:
        easygui.msgbox("no battles yet !") 
        return  # do nothing and return
    easygui.textbox(vtext, "combat log", log) # show box and return 

def edit_monsters(m1,m2):
       while True:
           values = easygui.multenterbox("Please edit carefully",
           "edit monster stats", ("Monster1: name (text)", 
           "Monster1: attack (float)", "Monster1: defense (float)",
           "Monster1: hitpoints (integer)", "Monster2: name (text)",
           "Monster2: attack (float)","Monster2: defense (float)",
           "Monster2: hitpoints (integer)"),(
           m1.name, m1.attack, m1.defense, m1.hitpoints,
           m2.name, m2.attack, m2.defense, m2.hitpoints))
           if values == None or None in values:
               easygui.msgbox("nothing changed: empty value or Cancel")
               break # break out of the  edit loop
           else:
               try:
                   m1 = goblin.Monster(values[0], float(values[1]), 
                          float(values[2]),int(values[3]))
                   m2 = goblin.Monster(values[4], float(values[5]), 
                          float(values[6]),int(values[7]))
               except:
                   easygui.msgbox("Invalid value. Please try again")
                   continue # repeat editing
               break # no problems detected
       return m1, m2 # return the changed monster instances 

def savefile(oldtext, text):
    filename = easygui.filesavebox()
    if filename == None:
        return # user selected Cancel
    output = open(filename,"a") # a: append 
    output.write("\n- - - - -\n{}\n{}".format(oldtext, text))
    output.close()

def fight(action, calc_buttons, m1, m2, battles, battlerounds, m1_wins, 
          m1_hp, m2_wins, m2_hp, picdict):
    potency = calc_buttons.index(action) # rank of button
    for x in range(10**potency):         # fight 1,10,100 times
        m1.hitpoints = m1.fullhealth # restore original hp BEFORE fight!
        m2.hitpoints = m2.fullhealth 
        winner, hp, rounds, log =  goblin.combat_sim(m1,m2)
        battles += 1
        battlerounds.append(rounds)
        if winner == m1.name:
            m1_wins+=1
            m1_hp.append(hp)
        else:
            m2_wins+=1
            m2_hp.append(hp)
    vtext = "\n\n\n"        
    vtext += "{} wins after {} rounds having {} hp left".format(
       winner, rounds, hp)
    if winner in picdict:
        victorimage= picdict[winner]
    else:
        victorimage = None
    return battles, battlerounds, m1_wins, m1_hp, m2_wins, m2_hp, \
           vtext, victorimage, log
    
def playtester_gui():
    """gui to help fine-tune stats of monsters"""

    status, text = check_files("stinky200.gif", "grunty200.gif")
    if not status:              # the same as if status == False:
        sys.exit()
    
    m1 = goblin.Monster("Grunty",0.4, 0.7, 95) # name, att, def, hp
    m2 = goblin.Monster("Stinky",0.8, 0.3, 109)
    #winnername, hp, rounds, log = goblin.combat_sim(m1,m2)
    
    victorimage = None
    picdict = {"Grunty": "grunty200.gif",
               "Stinky": "stinky200.gif"}
    
    # \ at the end of a line indicate python to continue in next line
    m1_wins, m2_wins, battles, battlerounds, m1_hp, m2_hp, \
        vtext, log = clean()
    oldtext = ""
    
    calc_buttons = ["+1 battle", "+10 battles", "+100 battles"]
    buttonlist = ["log", "clear","edit", "save"]
    buttonlist.extend(calc_buttons) # append each calcbutton to the list
    buttonlist.append("quit") # append one single elemet
    
    while True: 
        text = make_txt(m1,m2,m1_wins,m2_wins,m1_hp,m2_hp,battles,
                    battlerounds)              
        action = easygui.buttonbox(oldtext + text + vtext, 
           "combat sim viewer", buttonlist, image=victorimage)
        if action == "quit":   # --------menu handler-----------
            break
        elif action == "log":
            show_log(battles, vtext, log)
        elif action == "clear":
            m1wins, m2wins, battles, battlerounds, m1_hp, m2_hp, \
                vtext, log = clean()
            text, oldtext, victorimage = "", "", None
        elif action == "edit":
            m1,m2 = edit_monsters(m1,m2)
            oldtext = text + "\n" + "- - - " * 10 + "\n"
            m1_wins, m2_wins, battles, battlerounds, m1_hp, \
               m2_hp, vtext, log = clean()
        elif action == "save":
            savefile(oldtext,text)
        elif action in calc_buttons: # fight !
           battles, battlerounds, m1_wins, m1_hp, m2_wins, m2_hp, \
               vtext, victorimage, log=fight(action,calc_buttons,m1,m2,
               battles, battlerounds, m1_wins, m1_hp, m2_wins, m2_hp,
               picdict)
        
if __name__=="__main__":
    playtester_gui()

########NEW FILE########
__FILENAME__ = csvmaker
import random
# attack with random.random()
output = {}
for x in range(1000):
    attack = random.random()
    if round(attack,2) in output:
        output[round(attack,2)]+=1
    else:
        output[round(attack,2)] = 1
mycsv = open("attack-values.csv", "w")
for v in output:
    mycsv.write(str(v)+","+ str(output[v]) +"\n")
mycsv.close()
# defense with random.gauss()

output = {}
for x in range(1000):
    defense = random.gauss(0.5,.2)
    if round(defense,2) in output:
        output[round(defense,2)]+=1
    else:
        output[round(defense,2)] = 1
mycsv = open("defense-values.csv", "w")
for v in output:
    mycsv.write(str(v)+","+ str(output[v]) +"\n")
mycsv.close()

# damage (integer) with re_roll function
def re_roll(faces=6, start=0):
    """open ended die throw, can re-roll at highest face)"""
    while True: 
        roll = random.randint(1, faces)
        if roll != faces:
            return roll + start 
        return re_roll(faces, roll-1+start )
output = {}
for x in range(1000):
    damage = re_roll()
    if  damage in output:
        output[damage]+=1
    else:
        output[damage] = 1
mycsv = open("damage-values.csv", "w")
for v in output:
    mycsv.write(str(v)+","+ str(output[v]) +"\n")
mycsv.close()

print("csv files ready")

########NEW FILE########
__FILENAME__ = easygui
"""
@version: 0.96(2010-08-29)

@note:
ABOUT EASYGUI

EasyGui provides an easy-to-use interface for simple GUI interaction
with a user.  It does not require the programmer to know anything about
tkinter, frames, widgets, callbacks or lambda.  All GUI interactions are
invoked by simple function calls that return results.

@note:
WARNING about using EasyGui with IDLE

You may encounter problems using IDLE to run programs that use EasyGui. Try it
and find out.  EasyGui is a collection of Tkinter routines that run their own
event loops.  IDLE is also a Tkinter application, with its own event loop.  The
two may conflict, with unpredictable results. If you find that you have
problems, try running your EasyGui program outside of IDLE.

Note that EasyGui requires Tk release 8.0 or greater.

@note:
LICENSE INFORMATION

EasyGui version 0.96

Copyright (c) 2010, Stephen Raymond Ferg

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer. 
    
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation and/or
       other materials provided with the distribution. 
    
    3. The name of the author may not be used to endorse or promote products derived
       from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@note:
ABOUT THE EASYGUI LICENSE

This license is what is generally known as the "modified BSD license",
aka "revised BSD", "new BSD", "3-clause BSD".
See http://www.opensource.org/licenses/bsd-license.php

This license is GPL-compatible.
See http://en.wikipedia.org/wiki/License_compatibility
See http://www.gnu.org/licenses/license-list.html#GPLCompatibleLicenses

The BSD License is less restrictive than GPL.
It allows software released under the license to be incorporated into proprietary products. 
Works based on the software may be released under a proprietary license or as closed source software.
http://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_.28.22New_BSD_License.22.29

"""
egversion = __doc__.split()[1]

__all__ = ['ynbox'
    , 'ccbox'
    , 'boolbox'
    , 'indexbox'
    , 'msgbox'
    , 'buttonbox'
    , 'integerbox'
    , 'multenterbox'
    , 'enterbox'
    , 'exceptionbox'
    , 'choicebox'
    , 'codebox'
    , 'textbox'
    , 'diropenbox'
    , 'fileopenbox'
    , 'filesavebox'
    , 'passwordbox'
    , 'multpasswordbox'
    , 'multchoicebox'
    , 'abouteasygui'
    , 'egversion'
    , 'egdemo'
    , 'EgStore'
    ]

import sys, os
import string
import pickle
import traceback


#--------------------------------------------------
# check python version and take appropriate action
#--------------------------------------------------
"""
From the python documentation:

sys.hexversion contains the version number encoded as a single integer. This is
guaranteed to increase with each version, including proper support for non-
production releases. For example, to test that the Python interpreter is at
least version 1.5.2, use:

if sys.hexversion >= 0x010502F0:
    # use some advanced feature
    ...
else:
    # use an alternative implementation or warn the user
    ...
"""


if sys.hexversion >= 0x020600F0:
    runningPython26 = True
else:
    runningPython26 = False

if sys.hexversion >= 0x030000F0:
    runningPython3 = True
else:
    runningPython3 = False

try:
    from PIL import Image   as PILImage
    from PIL import ImageTk as PILImageTk
    PILisLoaded = True
except:
    PILisLoaded = False


if runningPython3:
    from tkinter import *
    import tkinter.filedialog as tk_FileDialog
    from io import StringIO
else:
    from Tkinter import *
    import tkFileDialog as tk_FileDialog
    from StringIO import StringIO

def write(*args):
    args = [str(arg) for arg in args]
    args = " ".join(args)
    sys.stdout.write(args)

def writeln(*args):
    write(*args)
    sys.stdout.write("\n")

say = writeln


if TkVersion < 8.0 :
    stars = "*"*75
    writeln("""\n\n\n""" + stars + """
You are running Tk version: """ + str(TkVersion) + """
You must be using Tk version 8.0 or greater to use EasyGui.
Terminating.
""" + stars + """\n\n\n""")
    sys.exit(0)

def dq(s):
    return '"%s"' % s

rootWindowPosition = "+300+200"

PROPORTIONAL_FONT_FAMILY = ("MS", "Sans", "Serif")
MONOSPACE_FONT_FAMILY    = ("Courier")

PROPORTIONAL_FONT_SIZE  = 10
MONOSPACE_FONT_SIZE     =  9  #a little smaller, because it it more legible at a smaller size
TEXT_ENTRY_FONT_SIZE    = 12  # a little larger makes it easier to see

#STANDARD_SELECTION_EVENTS = ["Return", "Button-1"]
STANDARD_SELECTION_EVENTS = ["Return", "Button-1", "space"]

# Initialize some global variables that will be reset later
__choiceboxMultipleSelect = None
__widgetTexts = None
__replyButtonText = None
__choiceboxResults = None
__firstWidget = None
__enterboxText = None
__enterboxDefaultText=""
__multenterboxText = ""
choiceboxChoices = None
choiceboxWidget = None
entryWidget = None
boxRoot = None
ImageErrorMsg = (
    "\n\n---------------------------------------------\n"
    "Error: %s\n%s")
#-------------------------------------------------------------------
# various boxes built on top of the basic buttonbox
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# ynbox
#-----------------------------------------------------------------------
def ynbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes", "No")
    , image=None
    ):
    """
    Display a msgbox with choices of Yes and No.

    The default is "Yes".

    The returned value is calculated this way::
        if the first choice ("Yes") is chosen, or if the dialog is cancelled:
            return 1
        else:
            return 0

    If invoked without a msg argument, displays a generic request for a confirmation
    that the user wishes to continue.  So it can be used this way::
        if ynbox(): pass # continue
        else: sys.exit(0)  # exit the program

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    return boolbox(msg, title, choices, image=image)


#-----------------------------------------------------------------------
# ccbox
#-----------------------------------------------------------------------
def ccbox(msg="Shall I continue?"
    , title=" "
    , choices=("Continue", "Cancel")
    , image=None
    ):
    """
    Display a msgbox with choices of Continue and Cancel.

    The default is "Continue".

    The returned value is calculated this way::
        if the first choice ("Continue") is chosen, or if the dialog is cancelled:
            return 1
        else:
            return 0

    If invoked without a msg argument, displays a generic request for a confirmation
    that the user wishes to continue.  So it can be used this way::

        if ccbox():
            pass # continue
        else:
            sys.exit(0)  # exit the program

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    return boolbox(msg, title, choices, image=image)


#-----------------------------------------------------------------------
# boolbox
#-----------------------------------------------------------------------
def boolbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes","No")
    , image=None
    ):
    """
    Display a boolean msgbox.

    The default is the first choice.

    The returned value is calculated this way::
        if the first choice is chosen, or if the dialog is cancelled:
            returns 1
        else:
            returns 0
    """
    reply = buttonbox(msg=msg, choices=choices, title=title, image=image)
    if reply == choices[0]: return 1
    else: return 0


#-----------------------------------------------------------------------
# indexbox
#-----------------------------------------------------------------------
def indexbox(msg="Shall I continue?"
    , title=" "
    , choices=("Yes","No")
    , image=None
    ):
    """
    Display a buttonbox with the specified choices.
    Return the index of the choice selected.
    """
    reply = buttonbox(msg=msg, choices=choices, title=title, image=image)
    index = -1
    for choice in choices:
        index = index + 1
        if reply == choice: return index
    raise AssertionError(
        "There is a program logic error in the EasyGui code for indexbox.")


#-----------------------------------------------------------------------
# msgbox
#-----------------------------------------------------------------------
def msgbox(msg="(Your message goes here)", title=" ", ok_button="OK",image=None,root=None):
    """
    Display a messagebox
    """
    if type(ok_button) != type("OK"):
        raise AssertionError("The 'ok_button' argument to msgbox must be a string.")

    return buttonbox(msg=msg, title=title, choices=[ok_button], image=image,root=root)


#-------------------------------------------------------------------
# buttonbox
#-------------------------------------------------------------------
def buttonbox(msg="",title=" "
    ,choices=("Button1", "Button2", "Button3")
    , image=None
    , root=None
    ):
    """
    Display a msg, a title, and a set of buttons.
    The buttons are defined by the members of the choices list.
    Return the text of the button that the user selected.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    global boxRoot, __replyButtonText, __widgetTexts, buttonsFrame


    # Initialize __replyButtonText to the first choice.
    # This is what will be used if the window is closed by the close button.
    __replyButtonText = choices[0]

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.minsize(400, 100)

    # ------------- define the messageFrame ---------------------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the imageFrame ---------------------------------
    tk_Image = None
    if image:
        imageFilename = os.path.normpath(image)
        junk,ext = os.path.splitext(imageFilename)

        if os.path.exists(imageFilename):
            if ext.lower() in [".gif", ".pgm", ".ppm"]:
                tk_Image = PhotoImage(master=boxRoot, file=imageFilename)
            else:
                if PILisLoaded:
                    try:
                        pil_Image = PILImage.open(imageFilename)
                        tk_Image = PILImageTk.PhotoImage(pil_Image, master=boxRoot)
                    except:
                        msg += ImageErrorMsg % (imageFilename,
                            "\nThe Python Imaging Library (PIL) could not convert this file to a displayable image."
                            "\n\nPIL reports:\n" + exception_format())

                else:  # PIL is not loaded
                    msg += ImageErrorMsg % (imageFilename,
                    "\nI could not import the Python Imaging Library (PIL) to display the image.\n\n"
                    "You may need to install PIL\n"
                    "(http://www.pythonware.com/products/pil/)\n"
                    "to display " + ext + " image files.")

        else:
            msg += ImageErrorMsg % (imageFilename, "\nImage file not found.")

    if tk_Image:
        imageFrame = Frame(master=boxRoot)
        imageFrame.pack(side=TOP, fill=BOTH)
        label = Label(imageFrame,image=tk_Image)
        label.image = tk_Image # keep a reference!
        label.pack(side=TOP, expand=YES, fill=X, padx='1m', pady='1m')

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    # -------------------- place the widgets in the frames -----------------------
    messageWidget = Message(messageFrame, text=msg, width=400)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')

    __put_buttons_in_buttonframe(choices)

    # -------------- the action begins -----------
    # put the focus on the first button
    __firstWidget.focus_force()

    boxRoot.deiconify()
    boxRoot.mainloop()
    boxRoot.destroy()
    if root: root.deiconify()
    return __replyButtonText


#-------------------------------------------------------------------
# integerbox
#-------------------------------------------------------------------
def integerbox(msg=""
    , title=" "
    , default=""
    , lowerbound=0
    , upperbound=99
    , image = None
    , root  = None
    , **invalidKeywordArguments
    ):
    """
    Show a box in which a user can enter an integer.

    In addition to arguments for msg and title, this function accepts
    integer arguments for "default", "lowerbound", and "upperbound".

    The default argument may be None.

    When the user enters some text, the text is checked to verify that it
    can be converted to an integer between the lowerbound and upperbound.

    If it can be, the integer (not the text) is returned.

    If it cannot, then an error msg is displayed, and the integerbox is
    redisplayed.

    If the user cancels the operation, None is returned.

    NOTE that the "argLowerBound" and "argUpperBound" arguments are no longer
    supported.  They have been replaced by "upperbound" and "lowerbound".
    """
    if "argLowerBound" in invalidKeywordArguments:
        raise AssertionError(
            "\nintegerbox no longer supports the 'argLowerBound' argument.\n"
            + "Use 'lowerbound' instead.\n\n")
    if "argUpperBound" in invalidKeywordArguments:
        raise AssertionError(
            "\nintegerbox no longer supports the 'argUpperBound' argument.\n"
            + "Use 'upperbound' instead.\n\n")

    if default != "":
        if type(default) != type(1):
            raise AssertionError(
                "integerbox received a non-integer value for "
                + "default of " + dq(str(default)) , "Error")

    if type(lowerbound) != type(1):
        raise AssertionError(
            "integerbox received a non-integer value for "
            + "lowerbound of " + dq(str(lowerbound)) , "Error")

    if type(upperbound) != type(1):
        raise AssertionError(
            "integerbox received a non-integer value for "
            + "upperbound of " + dq(str(upperbound)) , "Error")

    if msg == "":
        msg = ("Enter an integer between " + str(lowerbound)
            + " and "
            + str(upperbound)
            )

    while 1:
        reply = enterbox(msg, title, str(default), image=image, root=root)
        if reply == None: return None

        try:
            reply = int(reply)
        except:
            msgbox ("The value that you entered:\n\t%s\nis not an integer." % dq(str(reply))
                    , "Error")
            continue

        if reply < lowerbound:
            msgbox ("The value that you entered is less than the lower bound of "
                + str(lowerbound) + ".", "Error")
            continue

        if reply > upperbound:
            msgbox ("The value that you entered is greater than the upper bound of "
                + str(upperbound) + ".", "Error")
            continue

        # reply has passed all validation checks.
        # It is an integer between the specified bounds.
        return reply

#-------------------------------------------------------------------
# multenterbox
#-------------------------------------------------------------------
def multenterbox(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    ):
    r"""
    Show screen with multiple data entry fields.

    If there are fewer values than names, the list of values is padded with
    empty strings until the number of values is the same as the number of names.

    If there are more values than names, the list of values
    is truncated so that there are as many values as names.

    Returns a list of the values of the fields,
    or None if the user cancels the operation.

    Here is some example code, that shows how values returned from
    multenterbox can be checked for validity before they are accepted::
        ----------------------------------------------------------------------
        msg = "Enter your personal information"
        title = "Credit Card Application"
        fieldNames = ["Name","Street Address","City","State","ZipCode"]
        fieldValues = []  # we start with blanks for the values
        fieldValues = multenterbox(msg,title, fieldNames)

        # make sure that none of the fields was left blank
        while 1:
            if fieldValues == None: break
            errmsg = ""
            for i in range(len(fieldNames)):
                if fieldValues[i].strip() == "":
                    errmsg += ('"%s" is a required field.\n\n' % fieldNames[i])
            if errmsg == "":
                break # no problems found
            fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)

        writeln("Reply was: %s" % str(fieldValues))
        ----------------------------------------------------------------------

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg fields: a list of fieldnames.
    @arg values:  a list of field values
    """
    return __multfillablebox(msg,title,fields,values,None)


#-----------------------------------------------------------------------
# multpasswordbox
#-----------------------------------------------------------------------
def multpasswordbox(msg="Fill in values for the fields."
    , title=" "
    , fields=tuple()
    ,values=tuple()
    ):
    r"""
    Same interface as multenterbox.  But in multpassword box,
    the last of the fields is assumed to be a password, and
    is masked with asterisks.

    Example
    =======

    Here is some example code, that shows how values returned from
    multpasswordbox can be checked for validity before they are accepted::
        msg = "Enter logon information"
        title = "Demo of multpasswordbox"
        fieldNames = ["Server ID", "User ID", "Password"]
        fieldValues = []  # we start with blanks for the values
        fieldValues = multpasswordbox(msg,title, fieldNames)

        # make sure that none of the fields was left blank
        while 1:
            if fieldValues == None: break
            errmsg = ""
            for i in range(len(fieldNames)):
                if fieldValues[i].strip() == "":
                    errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
            fieldValues = multpasswordbox(errmsg, title, fieldNames, fieldValues)

        writeln("Reply was: %s" % str(fieldValues))
    """
    return __multfillablebox(msg,title,fields,values,"*")

def bindArrows(widget):
    widget.bind("<Down>", tabRight)
    widget.bind("<Up>"  , tabLeft)

    widget.bind("<Right>",tabRight)
    widget.bind("<Left>" , tabLeft)

def tabRight(event):
    boxRoot.event_generate("<Tab>")

def tabLeft(event):
    boxRoot.event_generate("<Shift-Tab>")

#-----------------------------------------------------------------------
# __multfillablebox
#-----------------------------------------------------------------------
def __multfillablebox(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    , mask = None
    ):
    global boxRoot, __multenterboxText, __multenterboxDefaultText, cancelButton, entryWidget, okButton

    choices = ["OK", "Cancel"]
    if len(fields) == 0: return None

    fields = list(fields[:])  # convert possible tuples to a list
    values = list(values[:])  # convert possible tuples to a list

    if   len(values) == len(fields): pass
    elif len(values) >  len(fields):
        fields = fields[0:len(values)]
    else:
        while len(values) < len(fields):
            values.append("")

    boxRoot = Tk()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.bind("<Escape>", __multenterboxCancel)

    # -------------------- put subframes in the boxRoot --------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    #-------------------- the msg widget ----------------------------
    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    global entryWidgets
    entryWidgets = []

    lastWidgetIndex = len(fields) - 1

    for widgetIndex in range(len(fields)):
        argFieldName  = fields[widgetIndex]
        argFieldValue = values[widgetIndex]
        entryFrame = Frame(master=boxRoot)
        entryFrame.pack(side=TOP, fill=BOTH)

        # --------- entryWidget ----------------------------------------------
        labelWidget = Label(entryFrame, text=argFieldName)
        labelWidget.pack(side=LEFT)

        entryWidget = Entry(entryFrame, width=40,highlightthickness=2)
        entryWidgets.append(entryWidget)
        entryWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,TEXT_ENTRY_FONT_SIZE))
        entryWidget.pack(side=RIGHT, padx="3m")

        bindArrows(entryWidget)

        entryWidget.bind("<Return>", __multenterboxGetText)
        entryWidget.bind("<Escape>", __multenterboxCancel)

        # for the last entryWidget, if this is a multpasswordbox,
        # show the contents as just asterisks
        if widgetIndex == lastWidgetIndex:
            if mask:
                entryWidgets[widgetIndex].configure(show=mask)

        # put text into the entryWidget
        entryWidgets[widgetIndex].insert(0,argFieldValue)
        widgetIndex += 1

    # ------------------ ok button -------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=BOTTOM, fill=BOTH)

    okButton = Button(buttonsFrame, takefocus=1, text="OK")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __multenterboxGetText
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __multenterboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------- time for action! -----------------
    entryWidgets[0].focus_force()    # put the focus on the entryWidget
    boxRoot.mainloop()  # run it!

    # -------- after the run has completed ----------------------------------
    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    return __multenterboxText


#-----------------------------------------------------------------------
# __multenterboxGetText
#-----------------------------------------------------------------------
def __multenterboxGetText(event):
    global __multenterboxText

    __multenterboxText = []
    for entryWidget in entryWidgets:
        __multenterboxText.append(entryWidget.get())
    boxRoot.quit()


def __multenterboxCancel(event):
    global __multenterboxText
    __multenterboxText = None
    boxRoot.quit()


#-------------------------------------------------------------------
# enterbox
#-------------------------------------------------------------------
def enterbox(msg="Enter something."
    , title=" "
    , default=""
    , strip=True
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter some text.

    You may optionally specify some default text, which will appear in the
    enterbox when it is displayed.

    Returns the text that the user entered, or None if he cancels the operation.

    By default, enterbox strips its result (i.e. removes leading and trailing
    whitespace).  (If you want it not to strip, use keyword argument: strip=False.)
    This makes it easier to test the results of the call::

        reply = enterbox(....)
        if reply:
            ...
        else:
            ...
    """
    result = __fillablebox(msg, title, default=default, mask=None,image=image,root=root)
    if result and strip:
        result = result.strip()
    return result


def passwordbox(msg="Enter your password."
    , title=" "
    , default=""
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter a password.
    The text is masked with asterisks, so the password is not displayed.
    Returns the text that the user entered, or None if he cancels the operation.
    """
    return __fillablebox(msg, title, default, mask="*",image=image,root=root)


def __fillablebox(msg
    , title=""
    , default=""
    , mask=None
    , image=None
    , root=None
    ):
    """
    Show a box in which a user can enter some text.
    You may optionally specify some default text, which will appear in the
    enterbox when it is displayed.
    Returns the text that the user entered, or None if he cancels the operation.
    """

    global boxRoot, __enterboxText, __enterboxDefaultText
    global cancelButton, entryWidget, okButton

    if title == None: title == ""
    if default == None: default = ""
    __enterboxDefaultText = default
    __enterboxText        = __enterboxDefaultText

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.bind("<Escape>", __enterboxCancel)

    # ------------- define the messageFrame ---------------------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the imageFrame ---------------------------------
    tk_Image = None
    if image:
        imageFilename = os.path.normpath(image)
        junk,ext = os.path.splitext(imageFilename)

        if os.path.exists(imageFilename):
            if ext.lower() in [".gif", ".pgm", ".ppm"]:
                tk_Image = PhotoImage(master=boxRoot, file=imageFilename)
            else:
                if PILisLoaded:
                    try:
                        pil_Image = PILImage.open(imageFilename)
                        tk_Image = PILImageTk.PhotoImage(pil_Image, master=boxRoot)
                    except:
                        msg += ImageErrorMsg % (imageFilename,
                            "\nThe Python Imaging Library (PIL) could not convert this file to a displayable image."
                            "\n\nPIL reports:\n" + exception_format())

                else:  # PIL is not loaded
                    msg += ImageErrorMsg % (imageFilename,
                    "\nI could not import the Python Imaging Library (PIL) to display the image.\n\n"
                    "You may need to install PIL\n"
                    "(http://www.pythonware.com/products/pil/)\n"
                    "to display " + ext + " image files.")

        else:
            msg += ImageErrorMsg % (imageFilename, "\nImage file not found.")

    if tk_Image:
        imageFrame = Frame(master=boxRoot)
        imageFrame.pack(side=TOP, fill=BOTH)
        label = Label(imageFrame,image=tk_Image)
        label.image = tk_Image # keep a reference!
        label.pack(side=TOP, expand=YES, fill=X, padx='1m', pady='1m')

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)


    # ------------- define the entryFrame ---------------------------------
    entryFrame = Frame(master=boxRoot)
    entryFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    #-------------------- the msg widget ----------------------------
    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    # --------- entryWidget ----------------------------------------------
    entryWidget = Entry(entryFrame, width=40)
    bindArrows(entryWidget)
    entryWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,TEXT_ENTRY_FONT_SIZE))
    if mask:
        entryWidget.configure(show=mask)
    entryWidget.pack(side=LEFT, padx="3m")
    entryWidget.bind("<Return>", __enterboxGetText)
    entryWidget.bind("<Escape>", __enterboxCancel)
    # put text into the entryWidget
    entryWidget.insert(0,__enterboxDefaultText)

    # ------------------ ok button -------------------------------
    okButton = Button(buttonsFrame, takefocus=1, text="OK")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __enterboxGetText
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __enterboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)

    # ------------------- time for action! -----------------
    entryWidget.focus_force()    # put the focus on the entryWidget
    boxRoot.deiconify()
    boxRoot.mainloop()  # run it!

    # -------- after the run has completed ----------------------------------
    if root: root.deiconify()
    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    return __enterboxText


def __enterboxGetText(event):
    global __enterboxText
    
    __enterboxText = entryWidget.get()
    boxRoot.quit()


def __enterboxRestore(event):
    global entryWidget
    
    entryWidget.delete(0,len(entryWidget.get()))
    entryWidget.insert(0, __enterboxDefaultText)


def __enterboxCancel(event):
    global __enterboxText
    
    __enterboxText = None
    boxRoot.quit()

def denyWindowManagerClose():
    """ don't allow WindowManager close
    """
    x = Tk()
    x.withdraw()
    x.bell()
    x.destroy()



#-------------------------------------------------------------------
# multchoicebox
#-------------------------------------------------------------------
def multchoicebox(msg="Pick as many items as you like."
    , title=" "
    , choices=()
    , **kwargs
    ):
    """
    Present the user with a list of choices.
    allow him to select multiple items and return them in a list.
    if the user doesn't choose anything from the list, return the empty list.
    return None if he cancelled selection.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    if len(choices) == 0: choices = ["Program logic error - no choices were specified."]

    global __choiceboxMultipleSelect
    __choiceboxMultipleSelect = 1
    return __choicebox(msg, title, choices)


#-----------------------------------------------------------------------
# choicebox
#-----------------------------------------------------------------------
def choicebox(msg="Pick something."
    , title=" "
    , choices=()
    ):
    """
    Present the user with a list of choices.
    return the choice that he selects.
    return None if he cancels the selection selection.

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg choices: a list or tuple of the choices to be displayed
    """
    if len(choices) == 0: choices = ["Program logic error - no choices were specified."]

    global __choiceboxMultipleSelect
    __choiceboxMultipleSelect = 0
    return __choicebox(msg,title,choices)


#-----------------------------------------------------------------------
# __choicebox
#-----------------------------------------------------------------------
def __choicebox(msg
    , title
    , choices
    ):
    """
    internal routine to support choicebox() and multchoicebox()
    """
    global boxRoot, __choiceboxResults, choiceboxWidget, defaultText
    global choiceboxWidget, choiceboxChoices
    #-------------------------------------------------------------------
    # If choices is a tuple, we make it a list so we can sort it.
    # If choices is already a list, we make a new list, so that when
    # we sort the choices, we don't affect the list object that we
    # were given.
    #-------------------------------------------------------------------
    choices = list(choices[:])
    if len(choices) == 0:
        choices = ["Program logic error - no choices were specified."]
    defaultButtons = ["OK", "Cancel"]

    # make sure all choices are strings
    for index in range(len(choices)):
        choices[index] = str(choices[index])

    lines_to_show = min(len(choices), 20)
    lines_to_show = 20

    if title == None: title = ""

    # Initialize __choiceboxResults
    # This is the value that will be returned if the user clicks the close icon
    __choiceboxResults = None

    boxRoot = Tk()
    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    screen_width  = boxRoot.winfo_screenwidth()
    screen_height = boxRoot.winfo_screenheight()
    root_width    = int((screen_width * 0.8))
    root_height   = int((screen_height * 0.5))
    root_xpos     = int((screen_width * 0.1))
    root_ypos     = int((screen_height * 0.05))

    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    rootWindowPosition = "+0+0"
    boxRoot.geometry(rootWindowPosition)
    boxRoot.expand=NO
    boxRoot.minsize(root_width, root_height)
    rootWindowPosition = "+" + str(root_xpos) + "+" + str(root_ypos)
    boxRoot.geometry(rootWindowPosition)

    # ---------------- put the frames in the window -----------------------------------------
    message_and_buttonsFrame = Frame(master=boxRoot)
    message_and_buttonsFrame.pack(side=TOP, fill=X, expand=NO)

    messageFrame = Frame(message_and_buttonsFrame)
    messageFrame.pack(side=LEFT, fill=X, expand=YES)
    #messageFrame.pack(side=TOP, fill=X, expand=YES)

    buttonsFrame = Frame(message_and_buttonsFrame)
    buttonsFrame.pack(side=RIGHT, expand=NO, pady=0)
    #buttonsFrame.pack(side=TOP, expand=YES, pady=0)

    choiceboxFrame = Frame(master=boxRoot)
    choiceboxFrame.pack(side=BOTTOM, fill=BOTH, expand=YES)

    # -------------------------- put the widgets in the frames ------------------------------

    # ---------- put a msg widget in the msg frame-------------------
    messageWidget = Message(messageFrame, anchor=NW, text=msg, width=int(root_width * 0.9))
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=LEFT, expand=YES, fill=BOTH, padx='1m', pady='1m')

    # --------  put the choiceboxWidget in the choiceboxFrame ---------------------------
    choiceboxWidget = Listbox(choiceboxFrame
        , height=lines_to_show
        , borderwidth="1m"
        , relief="flat"
        , bg="white"
        )

    if __choiceboxMultipleSelect:
        choiceboxWidget.configure(selectmode=MULTIPLE)

    choiceboxWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))

    # add a vertical scrollbar to the frame
    rightScrollbar = Scrollbar(choiceboxFrame, orient=VERTICAL, command=choiceboxWidget.yview)
    choiceboxWidget.configure(yscrollcommand = rightScrollbar.set)

    # add a horizontal scrollbar to the frame
    bottomScrollbar = Scrollbar(choiceboxFrame, orient=HORIZONTAL, command=choiceboxWidget.xview)
    choiceboxWidget.configure(xscrollcommand = bottomScrollbar.set)

    # pack the Listbox and the scrollbars.  Note that although we must define
    # the textArea first, we must pack it last, so that the bottomScrollbar will
    # be located properly.

    bottomScrollbar.pack(side=BOTTOM, fill = X)
    rightScrollbar.pack(side=RIGHT, fill = Y)

    choiceboxWidget.pack(side=LEFT, padx="1m", pady="1m", expand=YES, fill=BOTH)

    #---------------------------------------------------
    # sort the choices
    # eliminate duplicates
    # put the choices into the choiceboxWidget
    #---------------------------------------------------
    for index in range(len(choices)):
        choices[index] = str(choices[index])

    if runningPython3:
        choices.sort(key=str.lower)
    else:
        choices.sort( lambda x,y: cmp(x.lower(),    y.lower())) # case-insensitive sort

    lastInserted = None
    choiceboxChoices = []
    for choice in choices:
        if choice == lastInserted: pass
        else:
            choiceboxWidget.insert(END, choice)
            choiceboxChoices.append(choice)
            lastInserted = choice

    boxRoot.bind('<Any-Key>', KeyboardListener)

    # put the buttons in the buttonsFrame
    if len(choices) > 0:
        okButton = Button(buttonsFrame, takefocus=YES, text="OK", height=1, width=6)
        bindArrows(okButton)
        okButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

        # for the commandButton, bind activation events to the activation event handler
        commandButton  = okButton
        handler = __choiceboxGetChoice
        for selectionEvent in STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

        # now bind the keyboard events
        choiceboxWidget.bind("<Return>", __choiceboxGetChoice)
        choiceboxWidget.bind("<Double-Button-1>", __choiceboxGetChoice)
    else:
        # now bind the keyboard events
        choiceboxWidget.bind("<Return>", __choiceboxCancel)
        choiceboxWidget.bind("<Double-Button-1>", __choiceboxCancel)

    cancelButton = Button(buttonsFrame, takefocus=YES, text="Cancel", height=1, width=6)
    bindArrows(cancelButton)
    cancelButton.pack(expand=NO, side=BOTTOM, padx='2m', pady='1m', ipady="1m", ipadx="2m")

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = __choiceboxCancel
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # add special buttons for multiple select features
    if len(choices) > 0 and __choiceboxMultipleSelect:
        selectionButtonsFrame = Frame(messageFrame)
        selectionButtonsFrame.pack(side=RIGHT, fill=Y, expand=NO)

        selectAllButton = Button(selectionButtonsFrame, text="Select All", height=1, width=6)
        bindArrows(selectAllButton)

        selectAllButton.bind("<Button-1>",__choiceboxSelectAll)
        selectAllButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

        clearAllButton = Button(selectionButtonsFrame, text="Clear All", height=1, width=6)
        bindArrows(clearAllButton)
        clearAllButton.bind("<Button-1>",__choiceboxClearAll)
        clearAllButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")


    # -------------------- bind some keyboard events ----------------------------
    boxRoot.bind("<Escape>", __choiceboxCancel)

    # --------------------- the action begins -----------------------------------
    # put the focus on the choiceboxWidget, and the select highlight on the first item
    choiceboxWidget.select_set(0)
    choiceboxWidget.focus_force()

    # --- run it! -----
    boxRoot.mainloop()

    boxRoot.destroy()
    return __choiceboxResults


def __choiceboxGetChoice(event):
    global boxRoot, __choiceboxResults, choiceboxWidget
    
    if __choiceboxMultipleSelect:
        __choiceboxResults = [choiceboxWidget.get(index) for index in choiceboxWidget.curselection()]

    else:
        choice_index = choiceboxWidget.curselection()
        __choiceboxResults = choiceboxWidget.get(choice_index)

    # writeln("Debugging> mouse-event=", event, " event.type=", event.type)
    # writeln("Debugging> choice=", choice_index, __choiceboxResults)
    boxRoot.quit()


def __choiceboxSelectAll(event):
    global choiceboxWidget, choiceboxChoices
    
    choiceboxWidget.selection_set(0, len(choiceboxChoices)-1)

def __choiceboxClearAll(event):
    global choiceboxWidget, choiceboxChoices
    
    choiceboxWidget.selection_clear(0, len(choiceboxChoices)-1)



def __choiceboxCancel(event):
    global boxRoot, __choiceboxResults
    
    __choiceboxResults = None
    boxRoot.quit()


def KeyboardListener(event):
    global choiceboxChoices, choiceboxWidget
    key = event.keysym
    if len(key) <= 1:
        if key in string.printable:
            # Find the key in the list.
            # before we clear the list, remember the selected member
            try:
                start_n = int(choiceboxWidget.curselection()[0])
            except IndexError:
                start_n = -1

            ## clear the selection.
            choiceboxWidget.selection_clear(0, 'end')

            ## start from previous selection +1
            for n in range(start_n+1, len(choiceboxChoices)):
                item = choiceboxChoices[n]
                if item[0].lower() == key.lower():
                    choiceboxWidget.selection_set(first=n)
                    choiceboxWidget.see(n)
                    return
            else:
                # has not found it so loop from top
                for n in range(len(choiceboxChoices)):
                    item = choiceboxChoices[n]
                    if item[0].lower() == key.lower():
                        choiceboxWidget.selection_set(first = n)
                        choiceboxWidget.see(n)
                        return

                # nothing matched -- we'll look for the next logical choice
                for n in range(len(choiceboxChoices)):
                    item = choiceboxChoices[n]
                    if item[0].lower() > key.lower():
                        if n > 0:
                            choiceboxWidget.selection_set(first = (n-1))
                        else:
                            choiceboxWidget.selection_set(first = 0)
                        choiceboxWidget.see(n)
                        return

                # still no match (nothing was greater than the key)
                # we set the selection to the first item in the list
                lastIndex = len(choiceboxChoices)-1
                choiceboxWidget.selection_set(first = lastIndex)
                choiceboxWidget.see(lastIndex)
                return

#-----------------------------------------------------------------------
# exception_format
#-----------------------------------------------------------------------
def exception_format():
    """
    Convert exception info into a string suitable for display.
    """
    return "".join(traceback.format_exception(
           sys.exc_info()[0]
        ,  sys.exc_info()[1]
        ,  sys.exc_info()[2]
        ))

#-----------------------------------------------------------------------
# exceptionbox
#-----------------------------------------------------------------------
def exceptionbox(msg=None, title=None):
    """
    Display a box that gives information about
    an exception that has just been raised.

    The caller may optionally pass in a title for the window, or a
    msg to accompany the error information.

    Note that you do not need to (and cannot) pass an exception object
    as an argument.  The latest exception will automatically be used.
    """
    if title == None: title = "Error Report"
    if msg == None:
        msg = "An error (exception) has occurred in the program."

    codebox(msg, title, exception_format())

#-------------------------------------------------------------------
# codebox
#-------------------------------------------------------------------

def codebox(msg=""
    , title=" "
    , text=""
    ):
    """
    Display some text in a monospaced font, with no line wrapping.
    This function is suitable for displaying code and text that is
    formatted using spaces.

    The text parameter should be a string, or a list or tuple of lines to be
    displayed in the textbox.
    """
    return textbox(msg, title, text, codebox=1 )

#-------------------------------------------------------------------
# textbox
#-------------------------------------------------------------------
def textbox(msg=""
    , title=" "
    , text=""
    , codebox=0
    ):
    """
    Display some text in a proportional font with line wrapping at word breaks.
    This function is suitable for displaying general written text.

    The text parameter should be a string, or a list or tuple of lines to be
    displayed in the textbox.
    """

    if msg == None: msg = ""
    if title == None: title = ""

    global boxRoot, __replyButtonText, __widgetTexts, buttonsFrame
    global rootWindowPosition
    choices = ["OK"]
    __replyButtonText = choices[0]


    boxRoot = Tk()

    boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )

    screen_width = boxRoot.winfo_screenwidth()
    screen_height = boxRoot.winfo_screenheight()
    root_width = int((screen_width * 0.8))
    root_height = int((screen_height * 0.5))
    root_xpos = int((screen_width * 0.1))
    root_ypos = int((screen_height * 0.05))

    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    rootWindowPosition = "+0+0"
    boxRoot.geometry(rootWindowPosition)
    boxRoot.expand=NO
    boxRoot.minsize(root_width, root_height)
    rootWindowPosition = "+" + str(root_xpos) + "+" + str(root_ypos)
    boxRoot.geometry(rootWindowPosition)

    mainframe = Frame(master=boxRoot)
    mainframe.pack(side=TOP, fill=BOTH, expand=YES)

    # ----  put frames in the window -----------------------------------
    # we pack the textboxFrame first, so it will expand first
    textboxFrame = Frame(mainframe, borderwidth=3)
    textboxFrame.pack(side=BOTTOM , fill=BOTH, expand=YES)

    message_and_buttonsFrame = Frame(mainframe)
    message_and_buttonsFrame.pack(side=TOP, fill=X, expand=NO)

    messageFrame = Frame(message_and_buttonsFrame)
    messageFrame.pack(side=LEFT, fill=X, expand=YES)

    buttonsFrame = Frame(message_and_buttonsFrame)
    buttonsFrame.pack(side=RIGHT, expand=NO)

    # -------------------- put widgets in the frames --------------------

    # put a textArea in the top frame
    if codebox:
        character_width = int((root_width * 0.6) / MONOSPACE_FONT_SIZE)
        textArea = Text(textboxFrame,height=25,width=character_width, padx="2m", pady="1m")
        textArea.configure(wrap=NONE)
        textArea.configure(font=(MONOSPACE_FONT_FAMILY, MONOSPACE_FONT_SIZE))

    else:
        character_width = int((root_width * 0.6) / MONOSPACE_FONT_SIZE)
        textArea = Text(
            textboxFrame
            , height=25
            , width=character_width
            , padx="2m"
            , pady="1m"
            )
        textArea.configure(wrap=WORD)
        textArea.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))


    # some simple keybindings for scrolling
    mainframe.bind("<Next>" , textArea.yview_scroll( 1,PAGES))
    mainframe.bind("<Prior>", textArea.yview_scroll(-1,PAGES))

    mainframe.bind("<Right>", textArea.xview_scroll( 1,PAGES))
    mainframe.bind("<Left>" , textArea.xview_scroll(-1,PAGES))

    mainframe.bind("<Down>", textArea.yview_scroll( 1,UNITS))
    mainframe.bind("<Up>"  , textArea.yview_scroll(-1,UNITS))


    # add a vertical scrollbar to the frame
    rightScrollbar = Scrollbar(textboxFrame, orient=VERTICAL, command=textArea.yview)
    textArea.configure(yscrollcommand = rightScrollbar.set)

    # add a horizontal scrollbar to the frame
    bottomScrollbar = Scrollbar(textboxFrame, orient=HORIZONTAL, command=textArea.xview)
    textArea.configure(xscrollcommand = bottomScrollbar.set)

    # pack the textArea and the scrollbars.  Note that although we must define
    # the textArea first, we must pack it last, so that the bottomScrollbar will
    # be located properly.

    # Note that we need a bottom scrollbar only for code.
    # Text will be displayed with wordwrap, so we don't need to have a horizontal
    # scroll for it.
    if codebox:
        bottomScrollbar.pack(side=BOTTOM, fill=X)
    rightScrollbar.pack(side=RIGHT, fill=Y)

    textArea.pack(side=LEFT, fill=BOTH, expand=YES)


    # ---------- put a msg widget in the msg frame-------------------
    messageWidget = Message(messageFrame, anchor=NW, text=msg, width=int(root_width * 0.9))
    messageWidget.configure(font=(PROPORTIONAL_FONT_FAMILY,PROPORTIONAL_FONT_SIZE))
    messageWidget.pack(side=LEFT, expand=YES, fill=BOTH, padx='1m', pady='1m')

    # put the buttons in the buttonsFrame
    okButton = Button(buttonsFrame, takefocus=YES, text="OK", height=1, width=6)
    okButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = __textboxOK
    for selectionEvent in ["Return","Button-1","Escape"]:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ----------------- the action begins ----------------------------------------
    try:
        # load the text into the textArea
        if type(text) == type("abc"): pass
        else:
            try:
                text = "".join(text)  # convert a list or a tuple to a string
            except:
                msgbox("Exception when trying to convert "+ str(type(text)) + " to text in textArea")
                sys.exit(16)
        textArea.insert(END,text, "normal")

    except:
        msgbox("Exception when trying to load the textArea.")
        sys.exit(16)

    try:
        okButton.focus_force()
    except:
        msgbox("Exception when trying to put focus on okButton.")
        sys.exit(16)

    boxRoot.mainloop()

    # this line MUST go before the line that destroys boxRoot
    areaText = textArea.get(0.0,END)
    boxRoot.destroy()
    return areaText # return __replyButtonText

#-------------------------------------------------------------------
# __textboxOK
#-------------------------------------------------------------------
def __textboxOK(event):
    global boxRoot
    boxRoot.quit()



#-------------------------------------------------------------------
# diropenbox
#-------------------------------------------------------------------
def diropenbox(msg=None
    , title=None
    , default=None
    ):
    """
    A dialog to get a directory name.
    Note that the msg argument, if specified, is ignored.

    Returns the name of a directory, or None if user chose to cancel.

    If the "default" argument specifies a directory name, and that
    directory exists, then the dialog box will start with that directory.
    """
    title=getFileDialogTitle(msg,title)
    localRoot = Tk()
    localRoot.withdraw()
    if not default: default = None
    f = tk_FileDialog.askdirectory(
          parent=localRoot
        , title=title
        , initialdir=default
        , initialfile=None
        )
    localRoot.destroy()
    if not f: return None
    return os.path.normpath(f)



#-------------------------------------------------------------------
# getFileDialogTitle
#-------------------------------------------------------------------
def getFileDialogTitle(msg
    , title
    ):
    if msg and title: return "%s - %s" % (title,msg)
    if msg and not title: return str(msg)
    if title and not msg: return str(title)
    return None # no message and no title

#-------------------------------------------------------------------
# class FileTypeObject for use with fileopenbox
#-------------------------------------------------------------------
class FileTypeObject:
    def __init__(self,filemask):
        if len(filemask) == 0:
            raise AssertionError('Filetype argument is empty.')

        self.masks = []

        if type(filemask) == type("abc"):  # a string
            self.initializeFromString(filemask)

        elif type(filemask) == type([]): # a list
            if len(filemask) < 2:
                raise AssertionError('Invalid filemask.\n'
                +'List contains less than 2 members: "%s"' % filemask)
            else:
                self.name  = filemask[-1]
                self.masks = list(filemask[:-1] )
        else:
            raise AssertionError('Invalid filemask: "%s"' % filemask)

    def __eq__(self,other):
        if self.name == other.name: return True
        return False

    def add(self,other):
        for mask in other.masks:
            if mask in self.masks: pass
            else: self.masks.append(mask)

    def toTuple(self):
        return (self.name,tuple(self.masks))

    def isAll(self):
        if self.name == "All files": return True
        return False

    def initializeFromString(self, filemask):
        # remove everything except the extension from the filemask
        self.ext = os.path.splitext(filemask)[1]
        if self.ext == "" : self.ext = ".*"
        if self.ext == ".": self.ext = ".*"
        self.name = self.getName()
        self.masks = ["*" + self.ext]

    def getName(self):
        e = self.ext
        if e == ".*"  : return "All files"
        if e == ".txt": return "Text files"
        if e == ".py" : return "Python files"
        if e == ".pyc" : return "Python files"
        if e == ".xls": return "Excel files"
        if e.startswith("."):
            return e[1:].upper() + " files"
        return e.upper() + " files"


#-------------------------------------------------------------------
# fileopenbox
#-------------------------------------------------------------------
def fileopenbox(msg=None
    , title=None
    , default="*"
    , filetypes=None
    ):
    """
    A dialog to get a file name.

    About the "default" argument
    ============================
        The "default" argument specifies a filepath that (normally)
        contains one or more wildcards.
        fileopenbox will display only files that match the default filepath.
        If omitted, defaults to "*" (all files in the current directory).

        WINDOWS EXAMPLE::
            ...default="c:/myjunk/*.py"
        will open in directory c:\myjunk\ and show all Python files.

        WINDOWS EXAMPLE::
            ...default="c:/myjunk/test*.py"
        will open in directory c:\myjunk\ and show all Python files
        whose names begin with "test".


        Note that on Windows, fileopenbox automatically changes the path
        separator to the Windows path separator (backslash).

    About the "filetypes" argument
    ==============================
        If specified, it should contain a list of items,
        where each item is either::
            - a string containing a filemask          # e.g. "*.txt"
            - a list of strings, where all of the strings except the last one
                are filemasks (each beginning with "*.",
                such as "*.txt" for text files, "*.py" for Python files, etc.).
                and the last string contains a filetype description

        EXAMPLE::
            filetypes = ["*.css", ["*.htm", "*.html", "HTML files"]  ]

    NOTE THAT
    =========

        If the filetypes list does not contain ("All files","*"),
        it will be added.

        If the filetypes list does not contain a filemask that includes
        the extension of the "default" argument, it will be added.
        For example, if     default="*abc.py"
        and no filetypes argument was specified, then
        "*.py" will automatically be added to the filetypes argument.

    @rtype: string or None
    @return: the name of a file, or None if user chose to cancel

    @arg msg: the msg to be displayed.
    @arg title: the window title
    @arg default: filepath with wildcards
    @arg filetypes: filemasks that a user can choose, e.g. "*.txt"
    """
    localRoot = Tk()
    localRoot.withdraw()

    initialbase, initialfile, initialdir, filetypes = fileboxSetup(default,filetypes)

    #------------------------------------------------------------
    # if initialfile contains no wildcards; we don't want an
    # initial file. It won't be used anyway.
    # Also: if initialbase is simply "*", we don't want an
    # initialfile; it is not doing any useful work.
    #------------------------------------------------------------
    if (initialfile.find("*") < 0) and (initialfile.find("?") < 0):
        initialfile = None
    elif initialbase == "*":
        initialfile = None

    f = tk_FileDialog.askopenfilename(parent=localRoot
        , title=getFileDialogTitle(msg,title)
        , initialdir=initialdir
        , initialfile=initialfile
        , filetypes=filetypes
        )

    localRoot.destroy()

    if not f: return None
    return os.path.normpath(f)


#-------------------------------------------------------------------
# filesavebox
#-------------------------------------------------------------------
def filesavebox(msg=None
    , title=None
    , default=""
    , filetypes=None
    ):
    """
    A file to get the name of a file to save.
    Returns the name of a file, or None if user chose to cancel.

    The "default" argument should contain a filename (i.e. the
    current name of the file to be saved).  It may also be empty,
    or contain a filemask that includes wildcards.

    The "filetypes" argument works like the "filetypes" argument to
    fileopenbox.
    """

    localRoot = Tk()
    localRoot.withdraw()

    initialbase, initialfile, initialdir, filetypes = fileboxSetup(default,filetypes)

    f = tk_FileDialog.asksaveasfilename(parent=localRoot
        , title=getFileDialogTitle(msg,title)
        , initialfile=initialfile
        , initialdir=initialdir
        , filetypes=filetypes
        )
    localRoot.destroy()
    if not f: return None
    return os.path.normpath(f)


#-------------------------------------------------------------------
#
# fileboxSetup
#
#-------------------------------------------------------------------
def fileboxSetup(default,filetypes):
    if not default: default = os.path.join(".","*")
    initialdir, initialfile = os.path.split(default)
    if not initialdir : initialdir  = "."
    if not initialfile: initialfile = "*"
    initialbase, initialext = os.path.splitext(initialfile)
    initialFileTypeObject = FileTypeObject(initialfile)

    allFileTypeObject = FileTypeObject("*")
    ALL_filetypes_was_specified = False

    if not filetypes: filetypes= []
    filetypeObjects = []

    for filemask in filetypes:
        fto = FileTypeObject(filemask)

        if fto.isAll():
            ALL_filetypes_was_specified = True # remember this

        if fto == initialFileTypeObject:
            initialFileTypeObject.add(fto) # add fto to initialFileTypeObject
        else:
            filetypeObjects.append(fto)

    #------------------------------------------------------------------
    # make sure that the list of filetypes includes the ALL FILES type.
    #------------------------------------------------------------------
    if ALL_filetypes_was_specified:
        pass
    elif allFileTypeObject == initialFileTypeObject:
        pass
    else:
        filetypeObjects.insert(0,allFileTypeObject)
    #------------------------------------------------------------------
    # Make sure that the list includes the initialFileTypeObject
    # in the position in the list that will make it the default.
    # This changed between Python version 2.5 and 2.6
    #------------------------------------------------------------------
    if len(filetypeObjects) == 0:
        filetypeObjects.append(initialFileTypeObject)

    if initialFileTypeObject in (filetypeObjects[0], filetypeObjects[-1]):
        pass
    else:
        if runningPython26:
            filetypeObjects.append(initialFileTypeObject)
        else:
            filetypeObjects.insert(0,initialFileTypeObject)

    filetypes = [fto.toTuple() for fto in filetypeObjects]

    return initialbase, initialfile, initialdir, filetypes

#-------------------------------------------------------------------
# utility routines
#-------------------------------------------------------------------
# These routines are used by several other functions in the EasyGui module.

def __buttonEvent(event):
    """
    Handle an event that is generated by a person clicking a button.
    """
    global  boxRoot, __widgetTexts, __replyButtonText
    __replyButtonText = __widgetTexts[event.widget]
    boxRoot.quit() # quit the main loop


def __put_buttons_in_buttonframe(choices):
    """Put the buttons in the buttons frame
    """
    global __widgetTexts, __firstWidget, buttonsFrame

    __firstWidget = None
    __widgetTexts = {}

    i = 0

    for buttonText in choices:
        tempButton = Button(buttonsFrame, takefocus=1, text=buttonText)
        bindArrows(tempButton)
        tempButton.pack(expand=YES, side=LEFT, padx='1m', pady='1m', ipadx='2m', ipady='1m')

        # remember the text associated with this widget
        __widgetTexts[tempButton] = buttonText

        # remember the first widget, so we can put the focus there
        if i == 0:
            __firstWidget = tempButton
            i = 1

        # for the commandButton, bind activation events to the activation event handler
        commandButton  = tempButton
        handler = __buttonEvent
        for selectionEvent in STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

#-----------------------------------------------------------------------
#
#     class EgStore
#
#-----------------------------------------------------------------------
class EgStore:
    r"""
A class to support persistent storage.

You can use EgStore to support the storage and retrieval
of user settings for an EasyGui application.


# Example A
#-----------------------------------------------------------------------
# define a class named Settings as a subclass of EgStore
#-----------------------------------------------------------------------
class Settings(EgStore):
::
    def __init__(self, filename):  # filename is required
        #-------------------------------------------------
        # Specify default/initial values for variables that
        # this particular application wants to remember.
        #-------------------------------------------------
        self.userId = ""
        self.targetServer = ""

        #-------------------------------------------------
        # For subclasses of EgStore, these must be
        # the last two statements in  __init__
        #-------------------------------------------------
        self.filename = filename  # this is required
        self.restore()            # restore values from the storage file if possible



# Example B
#-----------------------------------------------------------------------
# create settings, a persistent Settings object
#-----------------------------------------------------------------------
settingsFile = "myApp_settings.txt"
settings = Settings(settingsFile)

user    = "obama_barak"
server  = "whitehouse1"
settings.userId = user
settings.targetServer = server
settings.store()    # persist the settings

# run code that gets a new value for userId, and persist the settings
user    = "biden_joe"
settings.userId = user
settings.store()


# Example C
#-----------------------------------------------------------------------
# recover the Settings instance, change an attribute, and store it again.
#-----------------------------------------------------------------------
settings = Settings(settingsFile)
settings.userId = "vanrossum_g"
settings.store()

"""
    def __init__(self, filename):  # obtaining filename is required
        self.filename = None
        raise NotImplementedError()

    def restore(self):
        """
        Set the values of whatever attributes are recoverable
        from the pickle file.

        Populate the attributes (the __dict__) of the EgStore object
        from     the attributes (the __dict__) of the pickled object.

        If the pickled object has attributes that have been initialized
        in the EgStore object, then those attributes of the EgStore object
        will be replaced by the values of the corresponding attributes
        in the pickled object.

        If the pickled object is missing some attributes that have
        been initialized in the EgStore object, then those attributes
        of the EgStore object will retain the values that they were
        initialized with.

        If the pickled object has some attributes that were not
        initialized in the EgStore object, then those attributes
        will be ignored.

        IN SUMMARY:

        After the recover() operation, the EgStore object will have all,
        and only, the attributes that it had when it was initialized.

        Where possible, those attributes will have values recovered
        from the pickled object.
        """
        if not os.path.exists(self.filename): return self
        if not os.path.isfile(self.filename): return self

        try:
            f = open(self.filename,"rb")
            unpickledObject = pickle.load(f)
            f.close()

            for key in list(self.__dict__.keys()):
                default = self.__dict__[key]
                self.__dict__[key] = unpickledObject.__dict__.get(key,default)
        except:
            pass

        return self

    def store(self):
        """
        Save the attributes of the EgStore object to a pickle file.
        Note that if the directory for the pickle file does not already exist,
        the store operation will fail.
        """
        f = open(self.filename, "wb")
        pickle.dump(self, f)
        f.close()


    def kill(self):
        """
        Delete my persistent file (i.e. pickle file), if it exists.
        """
        if os.path.isfile(self.filename):
            os.remove(self.filename)
        return

    def __str__(self):
        """
        return my contents as a string in an easy-to-read format.
        """
        # find the length of the longest attribute name
        longest_key_length = 0
        keys = []
        for key in self.__dict__.keys():
            keys.append(key)
            longest_key_length = max(longest_key_length, len(key))

        keys.sort()  # sort the attribute names
        lines = []
        for key in keys:
            value = self.__dict__[key]
            key = key.ljust(longest_key_length)
            lines.append("%s : %s\n" % (key,repr(value))  )
        return "".join(lines)  # return a string showing the attributes




#-----------------------------------------------------------------------
#
# test/demo easygui
#
#-----------------------------------------------------------------------
def egdemo():
    """
    Run the EasyGui demo.
    """
    # clear the console
    writeln("\n" * 100)

    intro_message = ("Pick the kind of box that you wish to demo.\n"
    + "\n * Python version " + sys.version
    + "\n * EasyGui version " + egversion
    + "\n * Tk version " + str(TkVersion)
    )

    #========================================== END DEMONSTRATION DATA


    while 1: # do forever
        choices = [
            "msgbox",
            "buttonbox",
            "buttonbox(image) -- a buttonbox that displays an image",
            "choicebox",
            "multchoicebox",
            "textbox",
            "ynbox",
            "ccbox",
            "enterbox",
            "enterbox(image) -- an enterbox that displays an image",
            "exceptionbox",
            "codebox",
            "integerbox",
            "boolbox",
            "indexbox",
            "filesavebox",
            "fileopenbox",
            "passwordbox",
            "multenterbox",
            "multpasswordbox",
            "diropenbox",
            "About EasyGui",
            " Help"
            ]
        choice = choicebox(msg=intro_message
            , title="EasyGui " + egversion
            , choices=choices)

        if not choice: return

        reply = choice.split()

        if   reply[0] == "msgbox":
            reply = msgbox("short msg", "This is a long title")
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "About":
            reply = abouteasygui()

        elif reply[0] == "Help":
            _demo_help()

        elif reply[0] == "buttonbox":
            reply = buttonbox()
            writeln("Reply was: %s" % repr(reply))

            title = "Demo of Buttonbox with many, many buttons!"
            msg = "This buttonbox shows what happens when you specify too many buttons."
            reply = buttonbox(msg=msg, title=title, choices=choices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "buttonbox(image)":
            _demo_buttonbox_with_image()

        elif reply[0] == "boolbox":
            reply = boolbox()
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "enterbox":
            image = "python_and_check_logo.gif"
            message = "Enter the name of your best friend."\
                      "\n(Result will be stripped.)"
            reply = enterbox(message, "Love!", "     Suzy Smith     ")
            writeln("Reply was: %s" % repr(reply))

            message = "Enter the name of your best friend."\
                      "\n(Result will NOT be stripped.)"
            reply = enterbox(message, "Love!", "     Suzy Smith     ",strip=False)
            writeln("Reply was: %s" % repr(reply))

            reply = enterbox("Enter the name of your worst enemy:", "Hate!")
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "enterbox(image)":
            image = "python_and_check_logo.gif"
            message = "What kind of snake is this?"
            reply = enterbox(message, "Quiz",image=image)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "exceptionbox":
            try:
                thisWillCauseADivideByZeroException = 1/0
            except:
                exceptionbox()

        elif reply[0] == "integerbox":
            reply = integerbox(
                "Enter a number between 3 and 333",
                "Demo: integerbox WITH a default value",
                222, 3, 333)
            writeln("Reply was: %s" % repr(reply))

            reply = integerbox(
                "Enter a number between 0 and 99",
                "Demo: integerbox WITHOUT a default value"
                )
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "diropenbox" : _demo_diropenbox()
        elif reply[0] == "fileopenbox": _demo_fileopenbox()
        elif reply[0] == "filesavebox": _demo_filesavebox()

        elif reply[0] == "indexbox":
            title = reply[0]
            msg   =  "Demo of " + reply[0]
            choices = ["Choice1", "Choice2", "Choice3", "Choice4"]
            reply = indexbox(msg, title, choices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "passwordbox":
            reply = passwordbox("Demo of password box WITHOUT default"
                + "\n\nEnter your secret password", "Member Logon")
            writeln("Reply was: %s" % str(reply))

            reply = passwordbox("Demo of password box WITH default"
                + "\n\nEnter your secret password", "Member Logon", "alfie")
            writeln("Reply was: %s" % str(reply))

        elif reply[0] == "multenterbox":
            msg = "Enter your personal information"
            title = "Credit Card Application"
            fieldNames = ["Name","Street Address","City","State","ZipCode"]
            fieldValues = []  # we start with blanks for the values
            fieldValues = multenterbox(msg,title, fieldNames)

            # make sure that none of the fields was left blank
            while 1:
                if fieldValues == None: break
                errmsg = ""
                for i in range(len(fieldNames)):
                    if fieldValues[i].strip() == "":
                        errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
                fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)

            writeln("Reply was: %s" % str(fieldValues))

        elif reply[0] == "multpasswordbox":
            msg = "Enter logon information"
            title = "Demo of multpasswordbox"
            fieldNames = ["Server ID", "User ID", "Password"]
            fieldValues = []  # we start with blanks for the values
            fieldValues = multpasswordbox(msg,title, fieldNames)

            # make sure that none of the fields was left blank
            while 1:
                if fieldValues == None: break
                errmsg = ""
                for i in range(len(fieldNames)):
                    if fieldValues[i].strip() == "":
                        errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i])
                if errmsg == "": break # no problems found
                fieldValues = multpasswordbox(errmsg, title, fieldNames, fieldValues)

            writeln("Reply was: %s" % str(fieldValues))

        elif reply[0] == "ynbox":
            title = "Demo of ynbox"
            msg = "Were you expecting the Spanish Inquisition?"
            reply = ynbox(msg, title)
            writeln("Reply was: %s" % repr(reply))
            if reply:
                msgbox("NOBODY expects the Spanish Inquisition!", "Wrong!")

        elif reply[0] == "ccbox":
            title = "Demo of ccbox"
            reply = ccbox(msg,title)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "choicebox":
            title = "Demo of choicebox"
            longchoice = "This is an example of a very long option which you may or may not wish to choose."*2
            listChoices = ["nnn", "ddd", "eee", "fff", "aaa", longchoice
                    , "aaa", "bbb", "ccc", "ggg", "hhh", "iii", "jjj", "kkk", "LLL", "mmm" , "nnn", "ooo", "ppp", "qqq", "rrr", "sss", "ttt", "uuu", "vvv"]

            msg = "Pick something. " + ("A wrapable sentence of text ?! "*30) + "\nA separate line of text."*6
            reply = choicebox(msg=msg, choices=listChoices)
            writeln("Reply was: %s" % repr(reply))

            msg = "Pick something. "
            reply = choicebox(msg=msg, title=title, choices=listChoices)
            writeln("Reply was: %s" % repr(reply))

            msg = "Pick something. "
            reply = choicebox(msg="The list of choices is empty!", choices=[])
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "multchoicebox":
            listChoices = ["aaa", "bbb", "ccc", "ggg", "hhh", "iii", "jjj", "kkk"
                , "LLL", "mmm" , "nnn", "ooo", "ppp", "qqq"
                , "rrr", "sss", "ttt", "uuu", "vvv"]

            msg = "Pick as many choices as you wish."
            reply = multchoicebox(msg,"Demo of multchoicebox", listChoices)
            writeln("Reply was: %s" % repr(reply))

        elif reply[0] == "textbox": _demo_textbox(reply[0])
        elif reply[0] == "codebox": _demo_codebox(reply[0])

        else:
            msgbox("Choice\n\n" + choice + "\n\nis not recognized", "Program Logic Error")
            return


def _demo_textbox(reply):
    text_snippet = ((\
"""It was the best of times, and it was the worst of times.  The rich ate cake, and the poor had cake recommended to them, but wished only for enough cash to buy bread.  The time was ripe for revolution! """ \
*5)+"\n\n")*10
    title = "Demo of textbox"
    msg = "Here is some sample text. " * 16
    reply = textbox(msg, title, text_snippet)
    writeln("Reply was: %s" % str(reply))

def _demo_codebox(reply):
    code_snippet = ("dafsdfa dasflkj pp[oadsij asdfp;ij asdfpjkop asdfpok asdfpok asdfpok"*3) +"\n"+\
"""# here is some dummy Python code
for someItem in myListOfStuff:
    do something(someItem)
    do something()
    do something()
    if somethingElse(someItem):
        doSomethingEvenMoreInteresting()

"""*16
    msg = "Here is some sample code. " * 16
    reply = codebox(msg, "Code Sample", code_snippet)
    writeln("Reply was: %s" % repr(reply))


def _demo_buttonbox_with_image():

    msg   = "Do you like this picture?\nIt is "  
    choices = ["Yes","No","No opinion"]

    for image in [
        "python_and_check_logo.gif"
        ,"python_and_check_logo.jpg"
        ,"python_and_check_logo.png"
        ,"zzzzz.gif"]:

        reply=buttonbox(msg + image,image=image,choices=choices)
        writeln("Reply was: %s" % repr(reply))


def _demo_help():
    savedStdout = sys.stdout    # save the sys.stdout file object
    sys.stdout = capturedOutput = StringIO()
    help("easygui")
    sys.stdout = savedStdout   # restore the sys.stdout file object
    codebox("EasyGui Help",text=capturedOutput.getvalue())

def _demo_filesavebox():
    filename = "myNewFile.txt"
    title = "File SaveAs"
    msg ="Save file as:"

    f = filesavebox(msg,title,default=filename)
    writeln("You chose to save file: %s" % f)

def _demo_diropenbox():
    title = "Demo of diropenbox"
    msg = "Pick the directory that you wish to open."
    d = diropenbox(msg, title)
    writeln("You chose directory...: %s" % d)

    d = diropenbox(msg, title,default="./")
    writeln("You chose directory...: %s" % d)

    d = diropenbox(msg, title,default="c:/")
    writeln("You chose directory...: %s" % d)


def _demo_fileopenbox():
    msg  = "Python files"
    title = "Open files"
    default="*.py"
    f = fileopenbox(msg,title,default=default)
    writeln("You chose to open file: %s" % f)

    default="./*.gif"
    filetypes = ["*.jpg",["*.zip","*.tgs","*.gz", "Archive files"],["*.htm", "*.html","HTML files"]]
    f = fileopenbox(msg,title,default=default,filetypes=filetypes)
    writeln("You chose to open file: %s" % f)

    """#deadcode -- testing ----------------------------------------
    f = fileopenbox(None,None,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(None,title,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(msg,None,default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(default=default)
    writeln("You chose to open file: %s" % f)

    f = fileopenbox(default=None)
    writeln("You chose to open file: %s" % f)
    #----------------------------------------------------deadcode """


def _dummy():
    pass

EASYGUI_ABOUT_INFORMATION = '''
========================================================================
0.96(2010-08-29)
========================================================================
This version fixes some problems with version independence.

BUG FIXES
------------------------------------------------------
 * A statement with Python 2.x-style exception-handling syntax raised
   a syntax error when running under Python 3.x.
   Thanks to David Williams for reporting this problem.

 * Under some circumstances, PIL was unable to display non-gif images
   that it should have been able to display.
   The cause appears to be non-version-independent import syntax.
   PIL modules are now imported with a version-independent syntax.
   Thanks to Horst Jens for reporting this problem.

LICENSE CHANGE
------------------------------------------------------
Starting with this version, EasyGui is licensed under what is generally known as
the "modified BSD license" (aka "revised BSD", "new BSD", "3-clause BSD").
This license is GPL-compatible but less restrictive than GPL.
Earlier versions were licensed under the Creative Commons Attribution License 2.0.


========================================================================
0.95(2010-06-12)
========================================================================

ENHANCEMENTS
------------------------------------------------------
 * Previous versions of EasyGui could display only .gif image files using the
   msgbox "image" argument. This version can now display all image-file formats
   supported by PIL the Python Imaging Library) if PIL is installed.
   If msgbox is asked to open a non-gif image file, it attempts to import
   PIL and to use PIL to convert the image file to a displayable format.
   If PIL cannot be imported (probably because PIL is not installed)
   EasyGui displays an error message saying that PIL must be installed in order
   to display the image file.

   Note that
   http://www.pythonware.com/products/pil/
   says that PIL doesn't yet support Python 3.x.


========================================================================
0.94(2010-06-06)
========================================================================

ENHANCEMENTS
------------------------------------------------------
 * The codebox and textbox functions now return the contents of the box, rather
   than simply the name of the button ("Yes").  This makes it possible to use
   codebox and textbox as data-entry widgets.  A big "thank you!" to Dominic
   Comtois for requesting this feature, patiently explaining his requirement,
   and helping to discover the tkinter techniques to implement it.

   NOTE THAT in theory this change breaks backward compatibility.  But because
   (in previous versions of EasyGui) the value returned by codebox and textbox
   was meaningless, no application should have been checking it.  So in actual
   practice, this change should not break backward compatibility.

 * Added support for SPACEBAR to command buttons.  Now, when keyboard
   focus is on a command button, a press of the SPACEBAR will act like
   a press of the ENTER key; it will activate the command button.

 * Added support for keyboard navigation with the arrow keys (up,down,left,right)
   to the fields and buttons in enterbox, multenterbox and multpasswordbox,
   and to the buttons in choicebox and all buttonboxes.

 * added highlightthickness=2 to entry fields in multenterbox and
   multpasswordbox.  Now it is easier to tell which entry field has
   keyboard focus.


BUG FIXES
------------------------------------------------------
 * In EgStore, the pickle file is now opened with "rb" and "wb" rather than
   with "r" and "w".  This change is necessary for compatibility with Python 3+.
   Thanks to Marshall Mattingly for reporting this problem and providing the fix.

 * In integerbox, the actual argument names did not match the names described
   in the docstring. Thanks to Daniel Zingaro of at University of Toronto for
   reporting this problem.

 * In integerbox, the "argLowerBound" and "argUpperBound" arguments have been
   renamed to "lowerbound" and "upperbound" and the docstring has been corrected.

   NOTE THAT THIS CHANGE TO THE ARGUMENT-NAMES BREAKS BACKWARD COMPATIBILITY.
   If argLowerBound or argUpperBound are used, an AssertionError with an
   explanatory error message is raised.

 * In choicebox, the signature to choicebox incorrectly showed choicebox as
   accepting a "buttons" argument.  The signature has been fixed.


========================================================================
0.93(2009-07-07)
========================================================================

ENHANCEMENTS
------------------------------------------------------

 * Added exceptionbox to display stack trace of exceptions

 * modified names of some font-related constants to make it
   easier to customize them


========================================================================
0.92(2009-06-22)
========================================================================

ENHANCEMENTS
------------------------------------------------------

 * Added EgStore class to to provide basic easy-to-use persistence.

BUG FIXES
------------------------------------------------------

 * Fixed a bug that was preventing Linux users from copying text out of
   a textbox and a codebox.  This was not a problem for Windows users.

'''

def abouteasygui():
    """
    shows the easygui revision history
    """
    codebox("About EasyGui\n"+egversion,"EasyGui",EASYGUI_ABOUT_INFORMATION)
    return None



if __name__ == '__main__':
    if True:
        egdemo()
    else:
        # test the new root feature
        root = Tk()
        msg = """This is a test of a main Tk() window in which we will place an easygui msgbox.
                It will be an interesting experiment.\n\n"""
        messageWidget = Message(root, text=msg, width=1000)
        messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')
        messageWidget = Message(root, text=msg, width=1000)
        messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')


        msgbox("this is a test of passing in boxRoot", root=root)
        msgbox("this is a second test of passing in boxRoot", root=root)

        reply = enterbox("Enter something", root=root)
        writeln("You wrote:", reply)

        reply = enterbox("Enter something else", root=root)
        writeln("You wrote:", reply)
        root.destroy()

########NEW FILE########
__FILENAME__ = goblindice001
"""
Simple python program using combat rules from role-playing games.

Name:             goblindice001.py 
Purpose:          teaching basic python: while, if, elif, else, +=
edit this code:   https://github.com/horstjens/ThePythonGameBook/
                  blob/master/python/goblindice/goblindice001.py
edit tutorial:    https://github.com/horstjens/ThePythonGameBook/
                  blob/master/goblindice001.rst                  
main project:     http://ThePythonGameBook.com
Author:           Horst JENS, horst.jens@spielend-programmieren.at
Licence:          gpl, see http://www.gnu.org/licenses/gpl.html
"""
import random 
 
# Grunty, the untrained goblin, has some attack skill
grunty_attack = 3   # integer value 
 
# his opponent is a punchbag or wooden testdummy with poor defense
testdummy_hitpoints = 200 # integer value
testdummy_defense = 1
 
logfile = " Grunty vs. punchbag"   # string
combatround = 0 
 
while testdummy_hitpoints > 0:
    combatround += 1        # the same as: combatround = combatround +1
    logfile += "\n*** Round: " + str(combatround) + " ***" # \n new line
    logfile += ", target has {} hitpoints".format(testdummy_hitpoints)
    attack= grunty_attack + random.randint(1,6)+random.randint(1,6)
    defense = testdummy_defense + random.randint(1,6) # roll one die
    if attack > defense: # did Grunty hit the testdummy ?
        logfile += "\nSmack! Grunty hits his target with a most "
        logfile += "skilled attack: {} > {}".format(attack, defense)
        damage = random.randint(1,6)+random.randint(1,6)-2 # 0-10 damage
        testdummy_hitpoints -= damage   # subtract damage from hitpoints
        logfile += "\n...and inflicts {} damage!".format(damage)
    elif attack == defense:
        logfile += "\nGrunty manages to nearly hit the target, but "
        logfile += "he makes no damage {0} = {0}".format(attack)
    else:
        logfile += "\n Oh no! Grunty does not even hit his target "
        logfile +=  "{} < {}".format(attack, defense)
logfile += "\n" + "- " * 20 # make a dashed line by multiplying a string
logfile += "\nVictory for Grunty after {} rounds".format(combatround)

print(logfile)


########NEW FILE########
__FILENAME__ = goblindice002
"""
Simple two player combat sim example using a function.

Name:             goblindice002.py 
Purpose:          introducing a function, parameters and return values
idea:             simple combat simulating 2 players
edit this code:   https://github.com/horstjens/ThePythonGameBook/
                  blob/master/python/goblindice/goblindice002.py
edit tutorial:    https://github.com/horstjens/ThePythonGameBook/
                  blob/master/goblindice002.rst                  
main project:     http://ThePythonGameBook.com
Author:           Horst JENS, horst.jens@spielend-programmieren.at
Licence:          gpl, see http://www.gnu.org/licenses/gpl.html
"""
import random 
 
# Grunty, is better at defending than at attacking
grunty_attack = 4   # integer value 
grunty_defense = 7
grunty_hitpoints = 100

# Stinky is better and faster at attacking and can take more damage
stinky_attack = 8
stinky_defense = 2
stinky_hitpoints = 130
 
logfile = " Grunty vs. Stinky"   # string
combatround = 0 

# strike function to avoid writing nearly identical code twice

def strike(attacker_attack, defender_defense, attacker, defender):
    """Return damage value and text output for logfile"""
    attack = attacker_attack + random.randint(1,6)+random.randint(1,6)
    defense = defender_defense + random.randint(1,6)+random.randint(1,6)
    output = ""  # local variable, only valid inside this function
    dmg = 0      # default damage, also a local variable
    if attack > defense: # did the attacker hit his opponent ?
        output += "\n Smack! {} hits {} with a most ".format(
                    attacker, defender)
        output += "skilled attack: {} > {}".format(attack, defense)
        dmg = random.randint(1,6)+random.randint(1,6)-2 # 0-10 damage
        output += "\n ...and inflicts {} damage!".format(dmg)
    elif attack == defense:
        output += "\n{} manages to nearly to hit {}".format(
                   attacker, defender)
        output += ", but he makes no damage {0} = {0}".format(attack)
    else:
        output += "\n Oh no! {} does not even hit {} ".format(
                    attacker, defender)
        output += "{} < {}".format(attack, defense)
    return dmg, output  

while stinky_hitpoints > 0 and grunty_hitpoints >0:
    combatround += 1        # the same as: combatround = combatround +1
    logfile += "\n*** Round: " + str(combatround) + " ***" # \n new line
    logfile += " Grunty has {} hitpoints,".format(grunty_hitpoints)
    logfile += " Stinky has {} hitpoints".format(stinky_hitpoints)
    # Stinky always strikes first
    damage, text = strike(stinky_attack, grunty_defense, "Stinky",
                           "Grunty")
    grunty_hitpoints -= damage
    logfile += text
    if grunty_hitpoints < 1:            # can Grunty still strike back ?
        break                           # exit this while loop
    # Grunty strikes back at Stinky
    damage, text = strike(grunty_attack, stinky_defense, "Grunty",
                          "Stinky")
    stinky_hitpoints -= damage
    logfile += text
logfile += "\n" + "- " * 20 # make a dashed line by multiplying a string
if grunty_hitpoints > stinky_hitpoints:
    winner = "Grunty"
else:
    winner = "Stinky"
logfile += "\nVictory for {} after {} rounds".format(winner,combatround)

print(logfile)


########NEW FILE########
__FILENAME__ = goblindice003
"""
RPG game combat sim using a recursion and functions from module random.

Name:             goblindice003.py 
Purpose:          introducing a recursion and default parameters.
                  introducing  __name__ and __main__ 
idea:             simulate open-ended dice using a recursion, make
                  use of random.random() and random.gauss() functions
                  for a more detailed combat model.
edit this code:   https://github.com/horstjens/ThePythonGameBook/
                  blob/master/python/goblindice/goblindice003.py
edit tutorial:    https://github.com/horstjens/ThePythonGameBook/
                  blob/master/goblindice003.rst                  
main project:     http://ThePythonGameBook.com
Author:           Horst JENS, horst.jens@spielend-programmieren.at
Licence:          gpl, see http://www.gnu.org/licenses/gpl.html
"""
import random 
 
def re_roll(faces=6, start=0):
    """open ended die throw, can re-roll at highest face)"""
    while True: 
        roll = random.randint(1, faces)
        if roll != faces:
            return roll + start 
        return re_roll(faces, roll-1+start )
            
def strike(attacker_attack, defender_defense, attacker, defender):
    """Return damage value and text output for logfile"""
    # add a random float from 0.0 to 1.0 to the attack value
    attack = attacker_attack + random.random() 
    # add a random float ( 0.5 +- something) to the defense value
    defense = defender_defense + random.gauss(0.5,0.2) 
    output = ""   
    dmg = 0       
    if attack > defense: # did the attacker hit his opponent ?
        output += "\n Smack! {} hits {} with a most skilled ".format(
                    attacker, defender)
        output += "attack: {:.2f}>{:.2f}".format(attack, defense)
        # use 2 dice with re-rolling (re-roll at 6, return sum)
        dmg = re_roll()  # no parameters, using default values
        output += "\n ...and inflicts {} damage!".format(dmg)
    else:
        output += "\n Oh no! {} does not even hit {} ".format(
                    attacker, defender)
        output += "{:.2f} < {:.2f}".format(attack, defense)
    return dmg, output  

def combat_sim():
    """2 player combat sim.
    
    Returns a text string with the combat log to either a print function
    (if __name__== "__main__") or to another calling program with a more
    complex display method."""
    
    # Grunty, is better at defending than at attacking
    grunty_attack = 0.4     # float (decimal)  instead of integer 
    grunty_defense = 0.7    # defense is also a float now 
    grunty_hitpoints = 100  # hitpoints are still integer, as is damage

    # Stinky is better and faster at attacking and can take more damage
    stinky_attack = 0.8     # can be interpreted as 80% success chance
    stinky_defense = 0.3     
    stinky_hitpoints = 130
     
    logfile = " Grunty vs. Stinky"   # string
    combatround = 0 

    while stinky_hitpoints > 0 and grunty_hitpoints >0:
        combatround += 1 
        logfile += "\n*** Round: {} ***".format(combatround) 
        logfile += " Grunty has {} hitpoints,".format(grunty_hitpoints)
        logfile += " Stinky has {} hitpoints".format(stinky_hitpoints)
        # Stinky always strikes first
        damage, text = strike(stinky_attack, grunty_defense, "Stinky",
                               "Grunty")
        grunty_hitpoints -= damage
        logfile += text
        if grunty_hitpoints < 1:        # can Grunty still strike back ?
            break                       # exit this while loop
        damage, text = strike(grunty_attack, stinky_defense, "Grunty",
                              "Stinky")
        stinky_hitpoints -= damage
        logfile += text
    logfile += "\n" + "- " * 20 
    if grunty_hitpoints > stinky_hitpoints:
        winner = "Grunty"
    else:
        winner = "Stinky"
    logfile += "\nVictory for {} after {} rounds".format(winner,combatround)
    return logfile

if __name__=="__main__":
   print(combat_sim())


########NEW FILE########
__FILENAME__ = goblindice004
"""
RPG combat sim with monster class and variable first strike order

Name:             goblindice004.py 
idea:             decide at each combat round who strikes first
edit this code:   https://github.com/horstjens/ThePythonGameBook/
                  blob/master/python/goblindice/goblindice004.py
edit tutorial:    https://github.com/horstjens/ThePythonGameBook/
                  blob/master/goblindice004.rst                  
main project:     http://ThePythonGameBook.com
Author:           Horst JENS, horst.jens@spielend-programmieren.at
Licence:          gpl, see http://www.gnu.org/licenses/gpl.html
"""
import random 

class Monster(object):
    """general-purpose monster class for combats"""
    
    def __init__(self, name, attack, defense, hitpoints):
        self.name = name
        self.attack = attack
        self.defense = defense
        self.hitpoints = hitpoints
        self.fullhealth = hitpoints
    
    def __repr__(self):
        """a string describing myself, used in print and others"""
        return "{} att: {:.2f} def: {:.2f} hp: {}/{}".format(self.name,
            self.attack, self.defense, self.hitpoints, self.fullhealth)
        
    def relative_health(self):
        """return percentage of full health"""
        return self.hitpoints / self.fullhealth
        
def re_roll(faces=6, start=0):
    """open ended die throw, can re-roll at highest face)"""
    while True: 
        roll = random.randint(1, faces)
        if roll != faces:
            return roll + start 
        return re_roll(faces, roll-1+start )
            
def strike(attacker, defender):
    """Calculate effect of strike and returns combat log text string"""
    attack = attacker.attack + random.gauss(0.5,0.2)  
    defense = defender.defense + random.gauss(0.5,0.1) 
    output = ""   
    dmg = 0       
    if attack > defense: # did the attacker hit his opponent ?
        output += "\n Smack! {} hits {} with a most skilled ".format(
                    attacker.name, defender.name)
        output += "attack: {:.2f}>{:.2f}".format(attack, defense)
        # use 2 dice with re-rolling (re-roll at 6, return sum)
        dmg = re_roll()  # no parameters, using default values
        output += "\n ...and inflicts {} damage!".format(dmg)
        # changing hitpoints inside the class instance
        defender.hitpoints -= dmg
    else:
        output += "\n Oh no! {} does not even hit {} ".format(
                    attacker.name, defender.name)
        output += "{:.2f} < {:.2f}".format(attack, defense)
    return output  

def combat_sim(monster1, monster2):
    """simulating combat between 2 monsters with random first strike
    
    requires 2 Monster instances as arguments
    returns victor name, victor hitpoints, number of rounds, logtext"""
    
    monsterlist = [monster1,monster2] # a list of all participants
    log = "{} vs. {}".format(monster1.name, monster2.name)
    combatround = 0 

    while monster1.hitpoints > 0 and monster2.hitpoints >0:
        combatround += 1 
        log += "\n*** Round: {} ***".format(combatround) 
        log += " {} has {} hp ({:.0f}%),".format(monster1.name,
                    monster1.hitpoints, monster1.relative_health()*100)
        log += " Stinky has {} hp ({:.0f}%)".format(monster2.name,
                    monster2.hitpoints, monster2.relative_health()*100)
        random.shuffle(monsterlist)     # sort the combatants by random
        first, second = monsterlist[0], monsterlist[1] #first strike?
        log += "\n{} strikes first:".format(first.name)
        log += strike(first, second) # this may change the hitpoints
        if second.hitpoints < 1:         # first striker already victor?
            break                        # exit this while loop
        log += strike(second, first) # revenge
    log += "\n" + "- " * 20 
    if first.hitpoints > second.hitpoints:
        winner = first
    else:
        winner = second
    log += "\nVictory for {} after {} rounds".format(winner.name 
                                                  ,combatround)
    return winner.name, winner.hitpoints, combatround, log

if __name__=="__main__":
   m1 = Monster("Grunty",0.4, 0.7, 95) # name, attack, defense, hp
   m2 = Monster("Stinky",0.8, 0.3, 109) # 
   print(combat_sim(m1,m2)[3]) # only print the 4th returned value 


########NEW FILE########
__FILENAME__ = localscope
# define variable
hitpoints = 55
# define function
def drink_magic_potion():
   """manipulate hitpoints directly"""
   localhitpoints = hitpoints * 2
   return localhitpoints
# call the function
print("hitpionts before drinking",hitpoints)
hitpoints = drink_magic_potion()
print("hitpoints after drinking", hitpoints)

########NEW FILE########
__FILENAME__ = localscope2
# define variable
hitpoints = 55
# define function
def drink_magic_potion():
   """try to direct manipulating hitpoints"""
   hitpoints = hitpoints * 2
   return hitpoints
# call the function
print("hitpionts before drinking",hitpoints)
hitpoints = drink_magic_potion()
print("hitpoints after drinking", hitpoints)

########NEW FILE########
__FILENAME__ = localscope3
# define variable
hitpoints = 55
# define function
def drink_magic_potion():
   """manipulating hitpoints by making hitpoints global"""
   global hitpoints
   hitpoints = hitpoints * 2

# call the function
print("hitpionts before drinking",hitpoints)
drink_magic_potion() 
print("hitpoints after drinking", hitpoints)

########NEW FILE########
__FILENAME__ = scrollbox
"""scrollbox to display text in a vertical scrollable window

source: http://stackoverflow.com/questions/17657212/
        how-to-code-the-tkinter-scrolledtext-module
note:   easygui.textbox does the same, but is not included in python
"""

import tkinter as tk
import tkinter.scrolledtext as tkst
# make sure goblindice003.py is is in the same folder as this program
import goblindice003 as goblin

window = tk.Tk()
frame1 = tk.Frame(
    master = window,
    bg = '#808000')
frame1.pack(fill='both', expand='yes')
editArea = tkst.ScrolledText(
    master = frame1,
    wrap   = tk.WORD,
    width  = 80,
    height = 40)
editArea.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
# Adding some text, to see if scroll is working as we expect it
editArea.insert(tk.INSERT,goblin.combat_sim())
window.mainloop()

########NEW FILE########
__FILENAME__ = classmenu
#!/usr/bin/env python

#
#  Copyright (C) 2012  Christian Hausknecht
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""
    ~~~~~~~~~~~~~
    classymenu.py
    ~~~~~~~~~~~~~
    
    The most advanced module to create and handle menus with basic Python
    kwnoledges.
    
    This time we use a class to represent and handle our menu tasks.
    
    It might be understandable even for newbies, but you should have been
    familiar to classes in Python.
    
    Of course the core ideas do not differ from the other, structure and
    function based approaches within this folder. As you can see a class is
    often the more comfortable way to handle deeply nested data structures.
    
    Our latest approach in `metamenu.py` handles tuples in a dictionary 
    in a dictionary... that ist not very comfortable to deal with. You can
    get confused by indexes and perhaps keys. It feels less clumsy to deal
    with attributes of a class.
    
    .. moduleauthor:: Christian Hausknecht <christian.hausknecht@gmx.de>
"""

import sys
from itertools import chain

#
# Create some little demo functions that does not have any sensefull 
# functionality but printing some stuff.
#

def make_some_foo_func(s):
    def func():
        print(s)
    return func
    
hello, python, nothing, special  = list(make_some_foo_func(s) for s in 
        ("Hello World!", "Python rocks!", "Nothing to do yet...",
         "Wow! So special we must put it into a subsubmenu...")
    )


class Menu:
    """
    Class that represents and handles a complete menu system all in once.
    
    Each menu class can...
    
        ... print out the (current) menu
        ... handle the user input
        ... run in an event-loop, that handles the complete menu based
            workflow.
    
    It provides the `finish`-method, which adds automatically all needed
    'Exit'-entries to each (sub)menu, so building up a menu is not so much
    typing.
    
    To avoid recursion, we use the `context`-attribute of the Menu-class. The
    current menu-object is always bound to this attribute. As we can combine
    arbitrary menu objects (via the `append_submenu`-method) we must keep
    the current working menu accessible to operate only in one object, the
    'root'-object.
    """
    
    def __init__(self, title):
        self.title = title
        self.items = []
        self.context = self
    
    def __repr__(self):
        return "Menu({})".format(self.title)
    
    def __str__(self):
        head = ("", "-"*len(self.title), "{}".format(self.title),
                "-"*len(self.title))
        entries = ("{} {} {}".format(
                        index, "+" if isinstance(entry[1], Menu) else " ", 
                        entry[0]
                    )
                    for index, entry in enumerate(self, 1)
        )
        return "\n".join(chain(head, entries))

    def __getitem__(self, key):
        """
        Nice to have method for providing the iterable "interface". So you can
        access any menu item via an index or loop over all entries using
        `for` :-)
        """
        return self.items[key]
    
    def append(self, text, func):
        """
        Appends a menu entry to `self.items`.
        
        :param text: string with entry description
        :param func: callable that will be called if chosen
        """
        self.items.append((text, func))
    
    def append_submenu(self, other):
        """
        Appends a submenu entry to the menu. That can be a complex branch
        of menu-objects.
        
        :param other: Menu object, that represents a complete submenu-branch.
        """
        self.items.append((other.title, other))
        
    def finish(self, text="Exit"):
        """
        Nice helper method that computes all needed 'Exit'-items for each
        submenu and the 'final' 'Exit'-item at the main-menu, which is simply
        any string.
        
        All other exit-items are menu objects of the corresponding parent-menu.
        
        The algorithm implements a breadth-first search for handling this task.
        
        :param text: string with the text of the 'Exit'-item.
        """
        self.items.append((text, "#exit"))
        stack = [(self, None)]
        while stack:
            menu, parent = stack.pop()
            for _, command in menu:
                if isinstance(command, Menu):
                    stack.append((command, menu))
            if menu is not self:
                menu.append("{} -> {}".format(text, parent.title), parent)

    def get_user_input(self):
        while True:
            try:
                choice = int(input("Ihre Wahl?: ")) - 1
                if 0 <= choice < len(self.context.items):
                    return choice
                else:
                    raise IndexError
            except (ValueError, IndexError):
                print("Bitte nur Zahlen aus dem Bereich 1..{} eingeben".format(
                                                    len(self.context.items)))

    def run(self):
        """
        Core method to handle a menu. This invokes a loop that handles all
        menu tasks as long as the main menu is exited by the user.
        """
        while True:
            print(self.context)
            choice = self.get_user_input()
            _, command = self.context[choice]
            if isinstance(command, Menu):
                self.context = command
            elif isinstance(command, str):
                return
            else:
                command()

    
def main():
    # We build up some demonstration menu as in the other menu systems.
    # Now we can use classes to create menu objects...
    menu = Menu("Hauptmenü")
    menu.append("Hallo", hello)
    menu.append("Python", python)
    
    sub = Menu("Submenü")
    sub.append("Action", nothing)

    # ... or to create menu objects that we can later on
    subsub = Menu("Subsubmenü")
    subsub.append("Special", special)
    # ... easily add to another menu as submenu
    sub.append_submenu(subsub)

    another_sub = Menu("Another Submenü")
    another_sub.append("Noch mehr Action", nothing)
    # wait a second, we do not need that... we have `menu.finish()`!
    #another_sub.append("Back", menu)

    menu.append_submenu(sub)
    menu.append_submenu(another_sub)
    
    # create 'Exit'-entries automatically - nice to have this :-)
    # saves a lot of typing... :-)))
    menu.finish()
    
    # shake it!
    menu.run()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = classmenu_demo
#!/usr/bin/env python

#
#  Copyright (C) 2012  Christian Hausknecht
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""
    ~~~~~~~~~~~~~
    classymenu.py
    ~~~~~~~~~~~~~
    
    The most advanced module to create and handle menus with basic Python
    kwnoledges.
    
    This time we use a class to represent and handle our menu tasks.
    
    It might be understandable even for newbies, but you should have been
    familiar to classes in Python.
    
    Of course the core ideas do not differ from the other, structure and
    function based approaches within this folder. As you can see a class is
    often the more comfortable way to handle deeply nested data structures.
    
    Our latest approach in `metamenu.py` handles tuples in a dictionary 
    in a dictionary... that ist not very comfortable to deal with. You can
    get confused by indexes and perhaps keys. It feels less clumsy to deal
    with attributes of a class.
    
    .. moduleauthor:: Christian Hausknecht <christian.hausknecht@gmx.de>
"""

import sys
from itertools import chain

#
# Create some little demo functions that does not have any sensefull 
# functionality but printing some stuff.
#

def make_some_foo_func(s):
    def func():
        print(s)
    return func
    
hello, python, nothing, special  = list(make_some_foo_func(s) for s in 
        ("Hello World!", "Python rocks!", "Nothing to do yet...",
         "Wow! So special we must put it into a subsubmenu...")
    )

def blubb():
    print("blubb!")
    
def addblubb(instance):
    instance.append(blubb)

class Menu:
    """
    Class that represents and handles a complete menu system all in once.
    
    Each menu class can...
    
        ... print out the (current) menu
        ... handle the user input
        ... run in an event-loop, that handles the complete menu based
            workflow.
    
    It provides the `finish`-method, which adds automatically all needed
    'Exit'-entries to each (sub)menu, so building up a menu is not so much
    typing.
    
    To avoid recursion, we use the `context`-attribute of the Menu-class. The
    current menu-object is always bound to this attribute. As we can combine
    arbitrary menu objects (via the `append_submenu`-method) we must keep
    the current working menu accessible to operate only in one object, the
    'root'-object.
    """
    
    def __init__(self, title):
        self.title = title
        self.items = []
        self.context = self
    
    def __repr__(self):
        return "Menu({})".format(self.title)
    
    def __str__(self):
        head = ("", "-"*len(self.title), "{}".format(self.title),
                "-"*len(self.title))
        entries = ("{} {} {}".format(
                        index, "+" if isinstance(entry[1], Menu) else " ", 
                        entry[0]
                    )
                    for index, entry in enumerate(self, 1)
        )
        return "\n".join(chain(head, entries))

    def __getitem__(self, key):
        """
        Nice to have method for providing the iterable "interface". So you can
        access any menu item via an index or loop over all entries using
        `for` :-)
        """
        return self.items[key]
    
    def append(self, text, func):
        """
        Appends a menu entry to `self.items`.
        
        :param text: string with entry description
        :param func: callable that will be called if chosen
        """
        self.items.append((text, func))
    
    def append_submenu(self, other):
        """
        Appends a submenu entry to the menu. That can be a complex branch
        of menu-objects.
        
        :param other: Menu object, that represents a complete submenu-branch.
        """
        self.items.append((other.title, other))
        
    def finish(self, text="Exit"):
        """
        Nice helper method that computes all needed 'Exit'-items for each
        submenu and the 'final' 'Exit'-item at the main-menu, which is simply
        any string.
        
        All other exit-items are menu objects of the corresponding parent-menu.
        
        The algorithm implements a breadth-first search for handling this task.
        
        :param text: string with the text of the 'Exit'-item.
        """
        self.items.append((text, "#exit"))
        stack = [(self, None)]
        while stack:
            menu, parent = stack.pop()
            for _, command in menu:
                if isinstance(command, Menu):
                    stack.append((command, menu))
            if menu is not self:
                menu.append("{} -> {}".format(text, parent.title), parent)

    def get_user_input(self):
        while True:
            try:
                choice = int(input("Ihre Wahl?: ")) - 1
                if 0 <= choice < len(self.context.items):
                    return choice
                else:
                    raise IndexError
            except (ValueError, IndexError):
                print("Bitte nur Zahlen aus dem Bereich 1..{} eingeben".format(
                                                    len(self.context.items)))

    def run(self):
        """
        Core method to handle a menu. This invokes a loop that handles all
        menu tasks as long as the main menu is exited by the user.
        """
        while True:
            print(self.context)
            choice = self.get_user_input()
            _, command = self.context[choice]
            if isinstance(command, Menu):
                self.context = command
            elif isinstance(command, str):
                return
            else:
                command()

    
def main():
    # We build up some demonstration menu as in the other menu systems.
    # Now we can use classes to create menu objects...
    menu = Menu("Hauptmenü")
    menu.append("Hallo", hello)
    menu.append("Python", python)
    menu.append("Addblubb", lambda: addblubb(menu) )
    
    sub = Menu("Submenü")
    sub.append("Action", nothing)

    # ... or to create menu objects that we can later on
    subsub = Menu("Subsubmenü")
    subsub.append("Special", special)
    # ... easily add to another menu as submenu
    sub.append_submenu(subsub)

    another_sub = Menu("Another Submenü")
    another_sub.append("Noch mehr Action", nothing)
    # wait a second, we do not need that... we have `menu.finish()`!
    #another_sub.append("Back", menu)

    menu.append_submenu(sub)
    menu.append_submenu(another_sub)
    
    # create 'Exit'-entries automatically - nice to have this :-)
    # saves a lot of typing... :-)))
    menu.finish()
    
    # shake it!
    menu.run()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = classmenu_demo2
#!/usr/bin/env python

#
#  Copyright (C) 2012  Christian Hausknecht
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""
    ~~~~~~~~~~~~~
    classymenu.py
    ~~~~~~~~~~~~~
    
    The most advanced module to create and handle menus with basic Python
    kwnoledges.
    
    This time we use a class to represent and handle our menu tasks.
    
    It might be understandable even for newbies, but you should have been
    familiar to classes in Python.
    
    Of course the core ideas do not differ from the other, structure and
    function based approaches within this folder. As you can see a class is
    often the more comfortable way to handle deeply nested data structures.
    
    Our latest approach in `metamenu.py` handles tuples in a dictionary 
    in a dictionary... that ist not very comfortable to deal with. You can
    get confused by indexes and perhaps keys. It feels less clumsy to deal
    with attributes of a class.
    
    .. moduleauthor:: Christian Hausknecht <christian.hausknecht@gmx.de>
"""

import sys
from itertools import chain

#
# Create some little demo functions that does not have any sensefull 
# functionality but printing some stuff.
#

def make_some_foo_func(s):
    def func():
        print(s)
    return func
    
hello, python, nothing, special  = list(make_some_foo_func(s) for s in 
        ("Hello World!", "Python rocks!", "Nothing to do yet...",
         "Wow! So special we must put it into a subsubmenu...")
    )

def blubb():
    print("blubb!")
    
def addblubb(instance):
    instance.append(blubb)

class Menu:
    """
    Class that represents and handles a complete menu system all in once.
    
    Each menu class can...
    
        ... print out the (current) menu
        ... handle the user input
        ... run in an event-loop, that handles the complete menu based
            workflow.
    
    It provides the `finish`-method, which adds automatically all needed
    'Exit'-entries to each (sub)menu, so building up a menu is not so much
    typing.
    
    To avoid recursion, we use the `context`-attribute of the Menu-class. The
    current menu-object is always bound to this attribute. As we can combine
    arbitrary menu objects (via the `append_submenu`-method) we must keep
    the current working menu accessible to operate only in one object, the
    'root'-object.
    """
    
    def __init__(self, title):
        self.title = title
        self.items = []
        self.context = self
    
    def __repr__(self):
        return "Menu({})".format(self.title)
    
    def __str__(self):
        head = ("", "-"*len(self.title), "{}".format(self.title),
                "-"*len(self.title))
        entries = ("{} {} {}".format(
                        index, "+" if isinstance(entry[1], Menu) else " ", 
                        entry[0]
                    )
                    for index, entry in enumerate(self, 0)
        )
        return "\n".join(chain(head, entries))

    def __getitem__(self, key):
        """
        Nice to have method for providing the iterable "interface". So you can
        access any menu item via an index or loop over all entries using
        `for` :-)
        """
        return self.items[key]
    
    def append(self, text, func):
        """
        Appends a menu entry to `self.items`.
        
        :param text: string with entry description
        :param func: callable that will be called if chosen
        """
        self.items.append((text, func))
    
    def insert(self, text, func):
        """
        insert a menu entry at position 0 to `self.items`.
        
        :param text: string with entry description
        :param func: callable that will be called if chosen
        """
        self.items.insert(0,(text,func))
        
    def remove(self, text):
        """
        remove a menu entry
        
        :param text: string with entry description
        """
        #print(self.items)
        #print("wanna remove:", text, func)
        for (t, f) in self.items:
            if t == text:
                break
        else:
            print("did not found text")
            return
        self.items.remove((t, f))
    
    def append_submenu(self, other):
        """
        Appends a submenu entry to the menu. That can be a complex branch
        of menu-objects.
        
        :param other: Menu object, that represents a complete submenu-branch.
        """
        self.items.append((other.title, other))
        
    def remove_submenu(self, title):
        """removes complete submenu entry and tree"""
        print(self.items)
        
    def finish(self, text="Exit"):
        """
        Nice helper method that computes all needed 'Exit'-items for each
        submenu and the 'final' 'Exit'-item at the main-menu, which is simply
        any string.
        
        All other exit-items are menu objects of the corresponding parent-menu.
        
        The algorithm implements a breadth-first search for handling this task.
        
        :param text: string with the text of the 'Exit'-item.
        """
        #self.items.append((text, "#exit"))
        self.items.insert(0,(text, "#exit"))
        stack = [(self, None)]
        while stack:
            menu, parent = stack.pop()
            for _, command in menu:
                if isinstance(command, Menu):
                    stack.append((command, menu))
            if menu is not self:
                #menu.append("{} -> {}".format(text, parent.title), parent)
                menu.insert("{} -> go back to {}".format(text, parent.title), parent)

    def get_user_input(self):
        while True:
            try:
                choice = int(input("Ihre Wahl?: ")) #- 1
                if -1 <= choice < len(self.context.items):
                    return choice
                else:
                    raise IndexError
            except (ValueError, IndexError):
                print("Bitte nur Zahlen aus dem Bereich 0..{} eingeben".format(
                                                    len(self.context.items)-1))

    def run(self):
        """
        Core method to handle a menu. This invokes a loop that handles all
        menu tasks as long as the main menu is exited by the user.
        """
        while True:
            print(self.context)
            choice = self.get_user_input()
            _, command = self.context[choice]
            if isinstance(command, Menu):
                self.context = command
            elif isinstance(command, str):
                return
            else:
                command()

    


class Game(object):
    def __init__(self):
        
        self.teams = []
        
        self.menu = Menu("Hauptmenü")
        self.menu.append("Hallo", hello)
        self.menu.append("Python", python)
        self.menu.append("greetings", self.greetings)
        self.menu.append("new team", self.newteam)
        self.menu.append("kill team", self.killteam)
        #menu.append("Addblubb", lambda: addblubb(menu) )

        sub = Menu("Submenü")
        sub.append("Action", nothing)

        # ... or to create menu objects that we can later on
        subsub = Menu("Subsubmenü")
        subsub.append("Special", special)
            # ... easily add to another menu as submenu
        sub.append_submenu(subsub)

        another_sub = Menu("Another Submenü")
        another_sub.append("Noch mehr Action", nothing)
        # wait a second, we do not need that... we have `menu.finish()`!
        #another_sub.append("Back", menu)

        self.menu.append_submenu(sub)
        self.menu.append_submenu(another_sub)

        # create 'Exit'-entries automatically - nice to have this :-)
        # saves a lot of typing... :-)))
        self.menu.finish()

        # shake it!
        self.menu.run()
        
    def greetings(self):
        print("i send you greetings from within the game class")
        
    def newteam(self):
        nt = input("please enter name for new team \n:>")
        self.teams.append(nt)
        self.menu.append("manage team {}".format(nt), lambda: self.manage(nt))
        sub = Menu("submenu for team {}".format(nt))
        sub.append("Exit --> back to main menu", self.menu)
        sub.append("Special", special)
        
        self.menu.append_submenu(sub)
        
     
    def killteam(self):
        kt = input("please enter name for team to delete \n:>")
        self.teams.remove(kt)
        self.menu.remove("manage team {}".format(kt))
        self.menu.remove("submenu for team {}".format(kt))
        #self.menu.remove_submenu("aaaa")
        
    def manage(self,teamname):
        print("You are such a manager of team {}! what a boss..".format(teamname))

if __name__ == "__main__":
    #main()
    g = Game()

########NEW FILE########
__FILENAME__ = metamenutest
#!/usr/bin/env python

#
#  Copyright (C) 2012  Christian Hausknecht
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""
    ~~~~~~~~~~~
    metamenu.py
    ~~~~~~~~~~~

    Even more sophisticated approach compared to `submenu.py` as this module
    adds some meta data to each menu, so there is more information about each
    menu printed and therefore a better usability is provided.

    Still it is realized only with basic Python data types.

    There are only decent changes compared to `submenu.py`, to be more precise
    we enhance the menu structure at the 'value' part of the menu keys.
    
    Each menu consists of this dictionary structure:
    
        {
            "root": {
                "title": <string>
                "items": (
                    (<string>, <function object>),
                
                        or
                
                    (<string>, <string of key to submenu>)
                )
            },
            "submenu1": {
                "title": <string>
                "items": (
                    ...
                )
            }
        }

    We added a dictionary as value of the outer keys. In this dictionary there
    have to be the two keys 'title', followed by the name of the menu as
    string, and 'items'
        
    Every menu must habe a 'root' key. That is the entrypoint for the
    `handle_menu` function. To make an entry that leads to a submenu, just
    put the key of that submenu as second parameter of one menu item. This
    way you can also 'go back' from a submenu to the 'root'-menu.
        
    To be more generic, each 'callable' can be used as second argument.
    
    The user can choose via an computed index, which action should be
    triggered by the core function `handle_menu`.
    
    Hint: `print_menu` has changed as the new parameter `title` is now needed,
    which is basically the main issue of this menu version ;-)

    This is esspecially written for beginners, so there is no magic like
    `functools.partial` or some closures to create demo functions.

    .. moduleauthor:: Christian Hausknecht <christian.hausknecht@gmx.de>
"""

import sys

#
# Some little demo functions that does not have any sensfull functionality
#

def hello():
    print("Hallo Welt!")

    
def python():
    print("Python rocks!")


def special():
    print("Wow! So special we must put it into a submenu...")


#
# Functions for our simple menu system
#
    
def print_menu(entries, title):
    """
    Function that prints our menu items. It adds an numeric index to each
    item in order to make that the choosebale index for the user.
    
    :param entries: tuple with entries of a (sub)menu
    :param title: string
    """
    print("", "-"*len(title), "{}".format(title), "-"*len(title), sep="\n")
    for index, entry in enumerate(entries, 1):
        print("{}  {}".format(index, entry[0]))

        
def get_user_input(entries):
    """
    This function implements a simple user input with validation. As the
    input data should match with existing menu items, we check, if the value
    is valid.

    :param entries: tuple with entries of a (sub)menu
    
    :returns: int
    """
    while True:
        try:
            choice = int(input("Ihre Wahl?: ")) - 1
            if 0 <= choice < len(entries):
                return choice
            else:
                raise IndexError
        except (ValueError, IndexError):
            print("Bitte nur Zahlen aus dem Bereich 1 - {} eingeben".format(
                                                                len(entries)))


def handle_menu(menudef):
    """
    Core function of our menu system. It handles the complete process of
    printing the menu, getting the user input and calling the corresponding
    function.
    
    We recognize if a 'submenu' is called by comparing the type of the second
    parameter of our entry item. If that is a string, we interpret that as the
    key of a corresponding 'menu' and make that the current menu to operate on.
    
    The name of the entries to one menu-key now changed to the name `entries`.
    
    We also extract the `title` of one (sub)menu in order to show more
    information in the `print_menu`-function.
    
    :param menudef: dict with menu definition
    """
    category = "root"
    while True:
        title = menudef[category]["title"]
        entries = menudef[category]["items"]
        print_menu(entries, title)
        choice = get_user_input(entries)
        _, command = entries[choice]
        # here is the 'submenu'-magic. Just change the dictionary key and go
        # on in the loop, so the chosen submenu will be handled.
        if isinstance(command, str):
            category = command
        else:
            command()            


def main():
    # just some demonstration menu structure. We have two menus, the 'root'
    # menu and one submenu called 'submenu'. As second option in the 'submenu'
    # we can leave the menu back to the 'root'-menu.
    menu = {
        "root": {
            "title": "Hauptmenü",
            "items": (
                ("Hallo", hello),
                ("Python", python),
                ("Submenu", "submenu"),
                ("Exit", lambda: sys.exit(0))
            )
        },
        "submenu": {
            "title": "Submenü",
            "items": (
                ("Spezial", special),
                ("Zurück", "root"),
            )
        }
    }
    
    # make it so! :-)
    handle_menu(menu)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = slowgoblins001
# part of http://ThePythonGameBook.com
# source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins001.py

hitpoints_stinky = 22
hitpoints_grunty = 43
########NEW FILE########
__FILENAME__ = slowgoblins002
# part of http://ThePythonGameBook.com
# source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins002.py


hitpoints_stinky = 22
hitpoints_grunty = 43
hitpoints_grunty -= 1

########NEW FILE########
__FILENAME__ = slowgoblins003
# part of http://ThePythonGameBook.com
# source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins003.py


hitpoints_stinky = 22
hitpoints_grunty = 43
for game_round in range(22):
     hitpoints_stinky -=1
     hitpoints_grunty -=1
########NEW FILE########
__FILENAME__ = slowgoblins004
# part of http://ThePythonGameBook.com
# source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins004.py


hitpoints_stinky = 22
hitpoints_grunty = 43
print(" --- The Goblin Dice Duel ---")
print("game_round, Stinky, Grunty")
for game_round in range(22):
     print(game_round, hitpoints_stinky, hitpoints_grunty)
     hitpoints_stinky -=1
     hitpoints_grunty -=1
print() # print an empty line
print("Game Over")
########NEW FILE########
__FILENAME__ = slowgoblins005
# part of http://ThePythonGameBook.com
# source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins005.py


import random
hitpoints_stinky = 22
hitpoints_grunty = 43
print(" --- Goblin Dice Duel ---")
print("round    hitpoints")
for combat_round in range(22):
    print("{0:2d} Stinky: {1:3d} Grunty: {2:3d}".format(combat_round, hitpoints_stinky, hitpoints_grunty))
    hitpoints_grunty -= random.randint(1,6)
    hitpoints_stinky -= random.randint(1,6)
print("Game Over")

########NEW FILE########
__FILENAME__ = slowgoblins006
"""part of http://ThePythonGameBook.com
source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins006.py"""


import random

hitpoints_stinky = 22
hitpoints_grunty = 43
combat_round = 0
print(" --- Goblin Dice Duel ---")
print("round    hitpoints")

while hitpoints_stinky >0:
    print("{0:2d} Stinky: {1:2d} Grunty: {2:2d}".format(combat_round, hitpoints_stinky, hitpoints_grunty))
    combat_round += 1
    hitpoints_grunty -= random.randint(0,6)
    if hitpoints_grunty <= 0:
        break
    hitpoints_stinky -= random.randint(0,6)
print("Game Over")

if hitpoints_stinky > hitpoints_grunty:
    print("Stinky wins")
elif hitpoints_grunty > hitpoints_stinky:
    print("Grunty wins")
else:
    print("Nobody wins ?")

print("thank you for playing Goblin Dice Duel. bye-bye!")
########NEW FILE########
__FILENAME__ = slowgoblins007
"""part of http://ThePythonGameBook.com
source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins007.py"""

import random


#later use output instead of print
def output(c_round,hp_stinky,hp_grunty):
    """printing out three values c_round, hp_stinky and hp_grunty"""
    print("{0:2d} Stinky: {1:2d} Grunty: {2:2d}".format(c_round, hp_stinky, hp_grunty))
    # no return necessary because this functions returns nothing (yet)


hitpoints_stinky = 22
hitpoints_grunty = 43
combat_round = 0
print(" --- Goblin Dice Duel ---")
print("round    hitpoints")

while hitpoints_stinky >0:
    output(combat_round, hitpoints_stinky, hitpoints_grunty)
    combat_round += 1
    hitpoints_grunty -= random.randint(0,6)
    if hitpoints_grunty <= 0:
        break
    hitpoints_stinky -= random.randint(0,6)

output(combat_round, hitpoints_stinky, hitpoints_grunty) # output of final strike
print("Game Over")

if hitpoints_stinky > hitpoints_grunty:
    print("Stinky wins")
elif hitpoints_grunty > hitpoints_stinky:
    print("Grunty wins")
else:
    print("Nobody wins ?")
print("thank you for playing Goblin Dice Duel. bye-bye!")

########NEW FILE########
__FILENAME__ = slowgoblins007demo
"""part of http://ThePythonGameBook.com
source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins007demo.py"""

def output(a,b=20,c=30):
    """printing out a, b and c"""
    print("inside the function. The parameters a,b,c:")
    print("a: {} b: {} c: {}".format(a,b,c))
    print("i set now d locally to -100")
    d = -100 # a local d
    print("the local variable d: {}".format(d))
    print("i manipulate locally a and double it")
    a *= 2 # the same as a = a * 2
    print("local a is now: {}".format(a))
    print("returning a,b and c")
    return a,b,c

# calling the function
a = 5
b = 22
c = 100
d = 5000

print("a,b,c,d:",a,b,c,d)
a,b,c = output(a)
print("a,b,c,d:",a,b,c,d)
print(output.__doc__)
print(__doc__)
########NEW FILE########
__FILENAME__ = slowgoblins008compareDemo
"""part of http://ThePythonGameBook.com
source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins008comareDemo.py"""


def sign(a,b):
    """Compares a with b and returns  '<' or '=' or '>' depending on compare result between a and b."""
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="

def compareValues(hpA, attA, defA, hpB, attB, defB):
    """returns a string with a table comparing the values of A and B"""
    text = "\n          Stiny | vs. | Grunty "
    text+= "\n ---------------+-----+-----------"
    text+= "\n hitpoints: {0:3d} |  {1}  | {2:3d}".format(hpA, sign(hpA, hpB), hpB )
    text+= "\n attack:    {0:3d} |  {1}  | {2:3d}".format(attA, sign(attA, attB), attB)
    text+= "\n defense:   {0:3d} |  {1}  | {2:3d}".format(defA, sign(defA,defB), defB)
    text+= "\n"
    return text

hitpoints_stinky = 22
attack_stinky = 6
defense_stinky = 9
hitpoints_grunty = 43
attack_grunty = 5
defense_grunty = 3

# python lines can be several physical lines long if inside brackets
print(compareValues(hitpoints_stinky, attack_stinky, defense_stinky,
                    hitpoints_grunty, attack_grunty, defense_grunty))

########NEW FILE########
__FILENAME__ = slowgoblins009
"""part of http://ThePythonGameBook.com
source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins009.py"""

import random

def sign(a,b):
    """compares a with b and returns a "<","=" or ">" sign"""
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="

def compareValues(hpA, attA, defA, hpB, attB, defB):
    """returns a string with a table comparing the values of A and B"""
    text = "\n         Stinky | vs. | Grunty "
    text+= "\n ---------------+-----+-----------"
    text+= "\n hitpoints: {0:3d} |  {1}  | {2:3d}".format(hpA, sign(hpA, hpB), hpB )
    text+= "\n attack:    {0:3d} |  {1}  | {2:3d}".format(attA, sign(attA, attB), attB)
    text+= "\n defense:   {0:3d} |  {1}  | {2:3d}".format(defA, sign(defA,defB), defB)
    text+= "\n"
    return text

def output(combat_round,hitpoints_stinky,hitpoints_grunty):
    """returns a string with combat_round and both hitpoints"""
    return "\n{0:2d} Stinky: {1:2d} Grunty: {2:2d}".format(combat_round, hitpoints_stinky, hitpoints_grunty)


def game():
    """the Goblin Dice Duel game main function"""
    hitpoints_stinky = 22
    attack_stinky = 6
    defense_stinky = 9
    hitpoints_grunty = 43
    attack_grunty = 5
    defense_grunty = 3
    combat_round = 0
    text = ""


    text+=("\n --- Goblin Dice Duel ---\n\n")
    text+=compareValues(hitpoints_stinky, attack_stinky, defense_stinky,
                        hitpoints_grunty, attack_grunty, defense_grunty)
    text+=("\n\nround    hitpoints\n")
    while hitpoints_stinky >0:
        text+=output(combat_round, hitpoints_stinky, hitpoints_grunty)
        combat_round += 1
        hitpoints_grunty -= random.randint(0,6)
        if hitpoints_grunty <= 0:
            break
        hitpoints_stinky -= random.randint(0,6)
    text+=output(combat_round, hitpoints_stinky, hitpoints_grunty) # output of final strike
    text+=("\nGame Over")
    if hitpoints_stinky > hitpoints_grunty:
        text+=("\nStinky wins")
    elif hitpoints_grunty > hitpoints_stinky:
        text+=("\nGrunty wins")
    else:
        text+=("Nobody wins ?")
    text+=("\nthank you for playing Goblin Dice Duel. bye-bye!")
    # printing everything
    print(text)

if __name__ == "__main__":
    game() # call the game function in this code is not imported but directly called


########NEW FILE########
__FILENAME__ = slowgoblins010
"""part of http://ThePythonGameBook.com
# source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins010.py"""

import random

def sign(a,b):
    """compares a with b and returns a "<","=" or ">" sign"""
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="

def compareValues(hpA, attA, defA, hpB, attB, defB):
    """returns a string with a table comparing the values of A and B"""
    text = "\n         Stinky | vs. | Grunty "
    text+= "\n ---------------+-----+-----------"
    text+= "\n hitpoints: {0:3d} |  {1}  | {2:3d}".format(hpA, sign(hpA, hpB), hpB )
    text+= "\n attack:    {0:3d} |  {1}  | {2:3d}".format(attA, sign(attA, attB), attB)
    text+= "\n defense:   {0:3d} |  {1}  | {2:3d}".format(defA, sign(defA,defB), defB)
    text+= "\n"
    return text

def output(c_round,hp_stinky,hp_grunty):
    """returns a string with combat_round and both hitpoints"""
    return "\n---combat round {0:2d}--- Stinky: {1:2d} Grunty: {2:2d}".format(c_round, hp_stinky, hp_grunty)

def strike(attA, defB, hpB, counterstrike=False):
    """A strikes B. The function returns the new hpB and a text String with the combat report"""
    if counterstrike:
        t = "counterattack"
    else:
        t = "attack"
    rollAtt = random.randint(1,6)
    rollDef = random.randint(1,6)
    scoreA = attA + rollAtt
    scoreD = defB + rollDef
    if scoreA > scoreD:
        striketext = "Sucessfull {} !  ({} > {})".format(t, scoreA,scoreD)
        damage = scoreA - scoreD
        hpB -= damage
        striketext += "\n...doing {} damage.".format(damage)
    else:
        striketext = "The {} failed... ({} <= {})".format(t, scoreA, scoreD)
    return hpB, striketext

def game():
    """the Goblin Dice Duel game main function"""
    hitpoints_stinky = 10
    attack_stinky = 6
    defense_stinky = 9
    hitpoints_grunty = 15
    attack_grunty = 10
    defense_grunty = 3
    combat_round = 0
    text = ""

    text+="\n --- Goblin Dice Duel ---\n\n"
    text+=compareValues(hitpoints_stinky, attack_stinky, defense_stinky,
                        hitpoints_grunty, attack_grunty, defense_grunty)
    text+="\n ==== combat start ===="

    while hitpoints_stinky >0 and hitpoints_grunty > 0:
        text+=output(combat_round, hitpoints_stinky, hitpoints_grunty)
        combat_round += 1
        if random.randint(0,1) == 0:
            text+="\nStinky strikes first: "
            hitpoints_grunty, line = strike(attack_stinky, defense_grunty, hitpoints_grunty, False)
            text+=line
            if hitpoints_grunty > 0:
                text+="\nCounterstrike of Grunty: "
                hitpoints_stinky,line = strike(attack_grunty, defense_stinky, hitpoints_stinky, True)
                text+=line
        else:
            text+="\nGrunty strikes first: "
            hitpoints_stinky,line = strike(attack_grunty, defense_stinky, hitpoints_stinky, False)
            text+=line
            if hitpoints_stinky>0:
                text+="\nCounterstrike of Stinky: "
                hitpoints_grunty,line = strike(attack_stinky, defense_grunty, hitpoints_grunty, True)
                text+=line

    text+=output(combat_round, hitpoints_stinky, hitpoints_grunty) # output of final strike
    text+= "\nGame Over"
    if hitpoints_stinky > hitpoints_grunty:
        text+= "\nStinky wins"
    elif hitpoints_grunty > hitpoints_stinky:
        text+= "\nGrunty wins"
    else:
        text+= "Nobody wins ?"
    print(text)

if __name__ == "__main__":
    game() # call the game function if this code is not imported but directly called


########NEW FILE########
__FILENAME__ = slowgoblins011classdemo
"""part of http://ThePythonGameBook.com
source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins011classdemo.py"""


class Goblin(object):
	counter = 0
	def __init__(self):
		self.attack = 5
		self.defense = 7
		self.hitpoints = 10

	def report(self):
		if self.hitpoints > 0:
			return "i am fine"
		else:
			return "i am in a bad shape"


stinky = Goblin()
grunty = Goblin()
print("Stinky.attack:", stinky.attack)
print("Grunty.defense:", grunty.defense)
print("Grunty.hitpoints:",grunty.hitpoints)
grunty.hitpoints -= 4
print("Grunty take 4 damage:",grunty.hitpoints)
print("Grunty says:", grunty.report())
grunty.hitpoints -= 7
print("Grunty take 7 damage:", grunty.hitpoints)
print("Grunty says:", grunty.report())

########NEW FILE########
__FILENAME__ = slowgoblins012
"""part of http://ThePythonGameBook.com
source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins012.py

use gauss random function instead of randint
"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'

import random

class Goblin(object):
    """generic goblin with randomized stat values"""

    def __init__(self):
        """creates a new goblin instance"""
        self.attack = random.gauss(10, 2)    # float value
        self.defense = random.gauss(10, 2)   # float value
        self.hitpoints = random.gauss(20, 3) # float value
        self.fullhealth = self.hitpoints # copy

    def report(self):
        """returns a string with the actual stats"""
        text = "\natt: {} def: {}hp: {}".format(self.attack, self.defense, self.hitpoints)
        text += "\ni have {0:3f}% of my hitpoints".format(self.hitpoints / self.fullhealth)
        return text

def sign(a, b):
    """compares a with b and returns a "<","=" or ">" sign """
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="

def compareValues(a, b):
    """returns a string with a table comparing the values of goblins a and b"""
    text =  "\n          Stinky | vs. | Grunty "
    text += "\n ----------------+-----+-----------"
    text += "\n hitpoints: {:>4.1f} |  {}  | {:>4.1f}".format(a.hitpoints, sign(a.hitpoints, b.hitpoints), b.hitpoints)
    text += "\n attack:    {:>4.1f} |  {}  | {:>4.1f}".format(a.attack, sign(a.attack, b.attack), b.attack)
    text += "\n defense:   {:>4.1f} |  {}  | {:>4.1f}".format(a.defense, sign(a.defense, b.defense), b.defense)
    text += "\n"
    return text

def output(combatround, a, b):
    """returns a string with combatround and both hitpoints form a and b"""
    return "\n---combat round {0:3d}--- Stinky: {1:.0f} Grunty: {2:.0f}".format(combatround, a.hitpoints, b.hitpoints)

def strike(attacker, defender, counterstrike=False):
    """attacker strikes at defender. The function changes the new
    hitpoints of the defender and returns a text String with the combat report.
    counterstrike (boolean) indicates that this is a counterattack or not."""
    if counterstrike:
        t = "counterattack"
    else:
        t = "attack"
    rollAtt = random.randint(1, 6)
    rollDef = random.randint(1, 6)
    scoreA = attacker.attack + rollAtt
    scoreD = defender.defense + rollDef
    if scoreA > scoreD:
        striketext = "Sucessfull {0} !  ({1:.2f} > {2:.2f})".format(t, scoreA, scoreD)
        damage = scoreA - scoreD
        defender.hitpoints -= damage
        striketext += "\n...doing {0:.2f} damage.".format(damage)
    else:
        striketext = "The {0} failed... ({1:.2f} <= {2:.2f})".format(t, scoreA, scoreD)
    return striketext

def game():
    """the Goblin Dice Duel game main function"""
    stinky = Goblin()
    grunty = Goblin()

    combatround = 0
    text = ""

    text += "\n --- Goblin Dice Duel ---\n\n"
    text += compareValues(stinky, grunty)
    text += "\n ==== combat start ===="

    while stinky.hitpoints > 0 and grunty.hitpoints > 0:
        text += output(combatround, stinky, grunty)
        combatround += 1
        if random.randint(0, 1) == 0:
            text += "\nStinky strikes first: "
            text += strike(stinky, grunty, False)
            if grunty.hitpoints > 0:
                text += "\nCounterstrike of Grunty: "
                text += strike(grunty, stinky, True)
        else:
            text += "\nGrunty strikes first: "
            text += strike(grunty, stinky, False)
            if stinky.hitpoints > 0:
                text += "\nCounterstrike of Stinky: "
                text += strike(stinky, grunty, True)
    text += output(combatround, stinky, grunty) # output of final strike
    text += "\nGame Over"
    if stinky.hitpoints > grunty.hitpoints:
        text += "\nStinky wins"
    elif grunty.hitpoints > stinky.hitpoints:
        text += "\nGrunty wins"
    else:
        text += "Nobody wins ?"
    print(text)

if __name__ == "__main__":
    game()


########NEW FILE########
__FILENAME__ = slowgoblins012classless
#! /usr/bin/env python
# -*- coding: utf-8 -*-
 
"""
part of http://ThePythonGameBook.com
source code: https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins012classless.py

Stinky and Grunty reloaded, without classes by Github user yipyip.

This does the same as slowgoblins013.py but:
  + works with python2 AND python3
  + does NOT use classes
 
See this video:

http://pyvideo.org/video/880/stop-writing-classes

for more information about working without classes in python
"""
 
####
 
from __future__ import absolute_import
from __future__ import unicode_literals
from __future__ import print_function
import random as rand
import sys
 
if sys.version_info[0] < 3:
    text_t = unicode
    binary_t = str
else:
    xrange = range
    text_t = str
    binary_t = bytes
 
####
 
def roll_die(min_val=1, max_val=6):
    """Roll a die"""  
    assert 0 < min_val < max_val, "No valid die!"
    return rand.randint(min_val, max_val)
 
####
 
def make_goblin(name, attack_points=6, defend_points=6, health=10):
    """Spawn a goblin."""
    return dict(name=name,  attack_points=6, defend_points=6, health=health)
 
####
 
def is_dead(goblin):
    """Check goblin health."""
    return goblin['health'] <= 0
 
####
 
def report(goblin):
    """Verbose goblin."""
    items = ("{0}:".format(goblin['name']),
            "Attack={0}".format(goblin['attack_points']),
            "Defend={0}".format(goblin['defend_points']),
            "Health={0}".format(goblin['health']))
    return ' '.join(items)
 
####
 
def combat(goblin_a, goblin_b, max_rounds=100, dice=roll_die):
    """Multiple strikes, selected per random.
    """
    comments = []
    a = goblin_a
    b = goblin_b
    for i in xrange(1, max_rounds+1):
        a, b = rand.choice(((a, b), (b, a)))
        result = strike(a, b, dice)
        comments.append(report_strike_stats(i, a, b, *result))
        if any((is_dead(a), is_dead(b))):
            break
 
    return comments
 
####
        
def strike(attacker, defender, dice):
    """One strike."""
    attack = attacker['attack_points'] + dice()
    defend = defender['defend_points'] + dice()
    damage = 0
    
    if attack > defend:
        damage = attack - defend
        defender['health'] -= damage
 
    return attack, defend, damage
 
####
 
def report_strike_stats(round, a, b, attack, defend, damage):
    """Strike results."""
    succ = "{name_a}(H={ha}) wins against {name_b}(H={hb}) with damage {damage}."
    fail = "{name_a}(H={ha}) defends sucessfully against {name_b}(H={hb})."
    args = dict(name_a=a['name'], name_b=b['name'], damage=damage,
                ha=a['health'], hb=b['health'])
    result_form = (fail, succ)[attack > defend].format(**args)
    
    return "{0:3d}-< {1}".format(round, result_form)
 
####
 
def output(strings):
    """Message interface.
    """
    print("\n".join(strings))
 
####
    
def main(conf):
    """Main procedure.
    """
    if conf['seed']:
        rand.seed(conf['seed'])
    available_dice = {'standard': roll_die}
    
    stinky = make_goblin("Stinky")
    grunty = make_goblin("Grunty")
 
    output((report(stinky), report(grunty)))
    results = combat(stinky, grunty, dice=available_dice[conf['dice']])
    output(results)
 
    for goblin in (stinky, grunty):
        if is_dead(goblin):
            output(("{0} is dead!".format(goblin['name']),))
    
####
 
CONFIG =\
{'seed': None,
 'dice': 'standard'
}
 
if __name__ == '__main__':
    """Module entry point.
    """
    main(CONFIG)

########NEW FILE########
__FILENAME__ = slowgoblins013
"""part of http://ThePythonGameBook.com
source code: 
https://github.com/horstjens/ThePythonGameBook/blob/master/python/goblins/slowgoblins013.py

many battles and better statistics

"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'


import random



###

class Goblin(object):
    """generic goblin with randomized stat values"""

    def __init__(self):
        """creates a new goblin instance"""
        self.attack = random.gauss(10, 2)    # float value
        self.defense = random.gauss(10, 2)   # float value
        self.hitpoints = random.gauss(20, 3) # float value
        self.fullhealth = self.hitpoints # copy
        
        #statistics
        self.damage_dealt = 0
        self.damage_received = 0

    def report(self):
        """returns a string with the actual stats"""
        text = "\natt: {} def: {}hp: {}".format(self.attack, self.defense, self.hitpoints)
        text += "\ni have {0:3f}% of my hitpoints".format(self.hitpoints / self.fullhealth)
        return text

def sign(a, b):
    """compares a with b and returns a "<","=" or ">" sign """
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="

def compareValues(a, b):
    """returns a string with a table comparing the values of a and b"""
    text =  "\n          Stinky | vs. | Grunty "
    text += "\n ----------------+-----+-----------"
    text += "\n hitpoints: {:>4.1f} |  {}  | {:>4.1f}".format(a.hitpoints, sign(a.hitpoints, b.hitpoints), b.hitpoints)
    text += "\n attack:    {:>4.1f} |  {}  | {:>4.1f}".format(a.attack, sign(a.attack, b.attack), b.attack)
    text += "\n defense:   {:>4.1f} |  {}  | {:>4.1f}".format(a.defense, sign(a.defense, b.defense), b.defense)
    text += "\n"
    return text

def output(combatround, a, b):
    """returns a string with combatround and both hitpoints form a and b"""
    return "\n---combat round {0:3d}--- Stinky: {1:.0f} Grunty: {2:.0f}".format(combatround, a.hitpoints, b.hitpoints)

def strike(attacker, defender, counterstrike=False):
    """attacker strikes at defender. The function changes the new
    hitpoints of the defender and returns a text String with the combat report.
    counterstrike (boolean) indicates that this is a counterattack or not."""
    if counterstrike:
        t = "counterattack"
    else:
        t = "attack"
    rollAtt = random.randint(1, 6)
    rollDef = random.randint(1, 6)
    scoreA = attacker.attack + rollAtt
    scoreD = defender.defense + rollDef
    if scoreA > scoreD:
        striketext = "Sucessfull {0} !  ({1:.2f} > {2:.2f})".format(t, scoreA, scoreD)
        damage = scoreA - scoreD
        defender.hitpoints -= damage
        #statistics
        attacker.damage_dealt+= damage
        defender.damage_received+= damage
        striketext += "\n...doing {0:.2f} damage.".format(damage)
    else:
        striketext = "The {0} failed... ({1:.2f} <= {2:.2f})".format(t, scoreA, scoreD)
    return striketext

def game():
    """the Goblin Dice Duel game main function"""
    stinky = Goblin()
    grunty = Goblin()
    
    stinky_wins=0
    grunty_wins=0
    
    #save original hitpoints for next round
    grunty_orig_hp= grunty.hitpoints
    stinky_orig_hp= stinky.hitpoints
    combatround = 0
    text = ""

    text += "\n --- Goblin Dice Duel ---\n\n"
    text += compareValues(stinky, grunty)
    text += "\n *** TURNAMENT START ***"

    for x in range(1,4):
        #text += "\n\n\n ==== combat {} start ====\n\n\n".format(x)
        text += "\n\n\n-BATTLE {} STARTS NOW\n\n-GET READY\n\n-FIGHT!!\n\n".format(x)
        #restore original hitpoints
        grunty.hitpoints= grunty_orig_hp
        stinky.hitpoints= stinky_orig_hp
        while stinky.hitpoints > 0 and grunty.hitpoints > 0:
            text += output(combatround, stinky, grunty)
            #------------BATTLE------------
            combatround += 1
            if random.randint(0, 1) == 0:
                text += "\nStinky strikes first: "
                text += strike(stinky, grunty, False)
                if grunty.hitpoints > 0:
                    text += "\nCounterstrike of Grunty: "
                    text += strike(grunty, stinky, True)
            else:
                text += "\nGrunty strikes first: "
                text += strike(grunty, stinky, False)
                if stinky.hitpoints > 0:
                    text += "\nCounterstrike of Stinky: "
                    text += strike(stinky, grunty, True)
        text += output(combatround, stinky, grunty) # output of final strike
        text += "\nGame Over"
        if stinky.hitpoints > grunty.hitpoints:
            stinky_wins+=1
            text += "\nStinky wins battle {}".format(x)
        elif grunty.hitpoints > stinky.hitpoints:
            grunty_wins+=1
            text += "\nGrunty wins battle {}".format(x)
        else:
            text += "Nobody wins ?"
    #text+="\n\n*** statistics: ***\n\n--VICTORIES    %   |Wins | Ø DD  | Ø DR -- \n    -stinky"
    text+="\n\n*** statistics: ***\n\n                          ø DMG | ø DMG   \n--Victories in % | Wins | dealt | received"
    text+="\n-----------------+------+-------+--------"
    text+="\n -Stinky  {:5.1f}% | {:3.0f}  | {:5.1f} | {:5.1f} \n -Grunty  {:5.1f}% | {:3.0f}  | {:5.1f} | {:5.1f} ".format(
             stinky_wins/(x/100),stinky_wins, stinky.damage_dealt/x,
              stinky.damage_received/x, grunty_wins/(x/100), grunty_wins,
              grunty.damage_dealt/x, grunty.damage_received/x)
    text+="\n\n"+compareValues(stinky, grunty)
    print(text)

if __name__ == "__main__":
    game()

########NEW FILE########
__FILENAME__ = slowgoblins014
"""part of http://ThePythonGameBook.com
source code: https://github.com/horstjens/ThePythonGameBook/blob/master/
python/goblins/slowgoblins014.py

edit stats, text menu, logfile

"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'

import random

class Goblin(object):
    """generic goblin with randomized stat values"""
    #counter = 0 # this is a class attribute

    def __init__(self, name="anonymous goblin"):
        """creates a new goblin instance"""
        self.name = name
        self.attack = random.gauss(10, 2)    # float value
        self.defense = random.gauss(10, 2)   # float value
        self.hitpoints = random.gauss(20, 3) # float value
        self.fullhealth = self.hitpoints # copy
        #statistics
        self.damage_dealt = 0
        self.damage_received = 0
        self.wins = 0
        
    def restore_health(self):
        """restore original hitpoints"""
        self.hitpoints = self.fullhealth 
        
    def report(self):
        """returns a string with the actual stats"""
        text=""
        for stat in filter(lambda x: "__" not in x, dir(self)):
            if "bound method" in str(self.__getattribute__(stat)):
                continue # ignore methods, only take attributes
            #print(stat)
            attr = self.__getattribute__(stat)
            #testing if attribute is string or int or float
            if isinstance(attr, int) or isinstance(attr, float):
                text+= "\n{:>20}: {:5.1f}".format (stat, attr)
            else:
                text+= "\n{:>20}: {}".format(stat, attr)
            
        return text

def sign(a, b):
    """compares a with b and returns a "<","=" or ">" sign """
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="

def compareValues(a, b):
    """returns a string with a table comparing the values of 
       hp, attack, defense of a and b"""
    text =  "\n          Stinky | vs. | Grunty "
    text += "\n ----------------+-----+-----------"
    text += "\n hitpoints: {:>4.1f} |  {}  | {:>4.1f}".format(
         a.hitpoints, sign(a.hitpoints, b.hitpoints), b.hitpoints)
    text += "\n attack:    {:>4.1f} |  {}  | {:>4.1f}".format(
         a.attack, sign(a.attack, b.attack), b.attack)
    text += "\n defense:   {:>4.1f} |  {}  | {:>4.1f}".format(
         a.defense, sign(a.defense, b.defense), b.defense)
    text += "\n"
    return text

def output(battle, combatround, a, b):
    """returns a string with battle, round and hitpoints"""
    text = "\n---battle {:3d} round {:3d}".format(battle, combatround)
    text += "--- Stinky: {:.0f} Grunty: {:.0f}".format(a.hitpoints,
             b.hitpoints)
    return text

def strike(attacker, defender, counterstrike=False):
    """attacker strikes at defender. The function changes the new
    hitpoints of the defender and returns a text String with the 
    combat report.
    counterstrike (boolean) indicates that this is a counterattack 
    or not."""
    if counterstrike:
        t = "counterattack"
    else:
        t = "attack"
    rollAtt = random.randint(1, 6)
    rollDef = random.randint(1, 6)
    scoreA = attacker.attack + rollAtt
    scoreD = defender.defense + rollDef
    if scoreA > scoreD:
        striketext = "Sucessfull {0} !  ({1:.2f} > {2:.2f})".format(t,
                      scoreA, scoreD)
        damage = scoreA - scoreD
        defender.hitpoints -= damage
        #statistics
        attacker.damage_dealt+= damage
        defender.damage_received+= damage
        striketext += "\n...doing {0:.2f} damage.".format(damage)
    else:
        striketext = "The {0} failed... ({1:.2f} <= {2:.2f})".format(t,
                      scoreA, scoreD)
    return striketext

def game(stinky, grunty):
    """the Goblin Dice Duel game main function"""
    # ask how many battles
    battles = integer_input(1,1000000, 
         "fight how many battles ? (ENTER = 100)",100)
    text = ""
    text += "\n --- Goblin Dice Duel ---\n\n"
    text += compareValues(stinky, grunty)
    text += "\n *** TOURNAMENT START ***"
    # reset wins
    stinky.wins = 0
    grunty.wins = 0
    # fight !
    for x in range(1,battles+1):
        combatround = 0 # reset combatround for this battle
        text += "\n\n\n-BATTLE {} STARTS NOW".format(x)
        text += "\n\n-GET READY\n\n-FIGHT!!\n\n"
        while stinky.hitpoints > 0 and grunty.hitpoints > 0:
            combatround += 1
            text += output(x, combatround, stinky, grunty)
            #------------BATTLE------------
            if random.randint(0, 1) == 0:
                text += "\nStinky strikes first: "
                text += strike(stinky, grunty, False)
                if grunty.hitpoints > 0:
                    text += "\nCounterstrike of Grunty: "
                    text += strike(grunty, stinky, True)
            else:
                text += "\nGrunty strikes first: "
                text += strike(grunty, stinky, False)
                if stinky.hitpoints > 0:
                    text += "\nCounterstrike of Stinky: "
                    text += strike(stinky, grunty, True)
        text += output(x, combatround, stinky, grunty) # output of final strike
        text += "\nThis battle is over"
        if stinky.hitpoints > grunty.hitpoints:
            stinky.wins+=1
            text += "\nStinky wins battle {}".format(x)
        elif grunty.hitpoints > stinky.hitpoints:
            grunty.wins+=1
            text += "\nGrunty wins battle {}".format(x)
        else:
            text += "Nobody wins ?"
        # heal to full health after one battle
        #restore original hitpoints
        stinky.restore_health()
        grunty.restore_health()
    # statistic after end of all fights 
    text += "\n\n*** statistics: ***\n\n"
    text += "                          ø DMG | ø DMG   "
    text += "\n--Victories in % | Wins | dealt | received"
    text += "\n-----------------+------+-------+--------"
    text += "\n  "
    text += "Stinky  {:5.1f}% | {:4.0f} | {:5.1f} | {:5.1f}".format(
             stinky.wins/(x/100),stinky.wins, stinky.damage_dealt/x,
             stinky.damage_received/x)    
    text += "\n  "
    text += "Grunty  {:5.1f}% | {:4.0f} | {:5.1f} | {:5.1f} ".format(
            grunty.wins/(x/100), grunty.wins, grunty.damage_dealt/x,
            grunty.damage_received/x)
    text += "\n\n"+compareValues(stinky, grunty)
    text += "===============================================\n"
    
    print(text)
    
    # output into logfile
    try:
        with open('combatlog.txt', 'a') as logfile:
            logfile.write(text)
        print("combat results appended into file 'combatlog.txt'")
    except:
        print("problem with file combatlog.txt")
     
            
def integer_input(min_value,max_value, prompt=">", default=-1):
    """ask and returns an integer between min_value and max_value"""
    choice= -1
    while choice < min_value or choice > max_value:
        char= input(prompt)
        if char == "":
            char = str(default)
        if char.isdigit():
            if not (min_value <= int(char) <= max_value):
                print("valid between (incl.) {} and {}".format(min_value,
                       max_value))  
            choice= int(char)
        else:
            print("please enter numbers only")        
    return choice
    
def float_input(prompt=">", default = 0):
    """ask and returns an float value from the user"""
    answer_ok = False
    while not answer_ok:
        answer = input(prompt)
        if answer == "":
            return default
        try:
            newvalue = float(answer)
            answer_ok = True
        except ValueError:
            print("integer or float with decimal point please")
    return newvalue

    
def mainmenu(maxnumber=4):
    print ("welcome")
    print ("1... compare Goblins")
    print ("2... modify Stinky")
    print ("3... modify Grunty")
    print ("4... fight many battles")
    print ("0... quit")
    return integer_input(0,4, "your choice?>")


def edit(goblin, modlist):
    """let the user change att, def and hp of a goblin"""
    print("all stats of {}:".format(goblin.name))
    print(goblin.report())
    print("\n edit some stats for {}:".format(goblin.name))
    
    for mystat in modlist:
        print("The current value of {} is {}".format(mystat, 
               goblin.__getattribute__(mystat)))
        newvalue = float_input("new value ? [Enter=accept]>", 
                                goblin.__getattribute__(mystat))
        goblin.__setattr__(mystat, newvalue) # set new value
        if mystat == "hitpoints":
            goblin.__setattr__("fullhealth", newvalue) # copy hp
    print("thank you for editing this goblin") 
        

if __name__ == "__main__":
    stinky = Goblin("Stinky")
    grunty = Goblin("Grunty")
    editlist = ["attack", "defense", "hitpoints"] # moddable stats 
    battles = 100
    while True:
        c= mainmenu(battles)
        if c == 0:
            break
        elif c == 1:
            print(compareValues(stinky, grunty))
        elif c == 2:
            edit(stinky, editlist)
        elif c == 3:
            edit(grunty, editlist)
        elif c == 4:
            game(stinky, grunty)
    print("bye-bye")


########NEW FILE########
__FILENAME__ = slowgoblins015
"""part of http://ThePythonGameBook.com
source code: 

https://github.com/horstjens/ThePythonGameBook/blob/master/
python/goblins/slowgoblins015.py

draw, draw-statistic, re-rolls (recursion), better strike

"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'

import random



class Goblin(object):
    """generic goblin with randomized stat values"""
    #counter = 0 # this is a class attribute

    def __init__(self, name="anonymous goblin"):
        """creates a new goblin instance"""
        self.name = name
        self.attack = random.gauss(10, 2)    # float value
        self.defense = random.gauss(10, 2)   # float value
        self.hitpoints = random.gauss(20, 3) # float value
        self.fullhealth = self.hitpoints # copy
        self.defense_penalty = 0
        #statistics
        self.damage_dealt = 0
        self.damage_received = 0
        self.wins = 0
        
        
    def restore_health(self):
        """restore original hitpoints"""
        self.hitpoints = self.fullhealth 
        
    def report(self):
        """returns a string with the actual stats"""
        text=""
        for stat in filter(lambda x: "__" not in x, dir(self)):
            if "bound method" in str(self.__getattribute__(stat)):
                continue # ignore methods, only take attributes
            #print(stat)
            attr = self.__getattribute__(stat)
            #testing if attribute is string or int or float
            if isinstance(attr, int) or isinstance(attr, float):
                text+= "\n{:>20}: {:5.1f}".format (stat, attr)
            else:
                text+= "\n{:>20}: {}".format(stat, attr)
            
        return text

def reroll(min_eyes, max_eyes, depth=1, max_depth=9999):
    """a die that is allowed to re-roll when the max_eyes is thrown.
       return the sum of all throws minus 1 per max_eyes thrown.
       This allows very high results with a very small propability
       
       
    examples: 
    standard (1-6) die throws a 5: 
       result: 5
    standard (1-6) die throws a 6:
       allowed to re-roll: throws a 1:
       result: (6-1)+1=6
    standard (1-6) die throws a 6:
       allowed to re-roll: throws a 2:
       result: (6-1)+2 ) 7
    standard (1-6) die throws a 6:
       allowed to re-roll: throws another 6:
       allowed to re-roll again: throws a 4:
       result: (6-1) + (6-1) + 4 = 5+5+4 =14
    """
    if depth >= max_depth:
        return max_eyes # avoid endless loop
    result = random.randint(min_eyes, max_eyes)
    if result == max_eyes:
       result = result-1 + reroll(min_eyes, max_eyes, depth+1) # recursion !
    return result
    

def sign(a, b):
    """compares a with b and returns a "<","=" or ">" sign """
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="
        
def integer_input(min_value,max_value, prompt=">", default=-1):
    """ask and returns an integer between min_value and max_value"""
    choice= -1
    while choice < min_value or choice > max_value:
        char= input(prompt)
        if char == "":
            char = str(default)
        if char.isdigit():
            if not (min_value <= int(char) <= max_value):
                print("valid between (incl.) {} and {}".format(min_value,
                       max_value))  
            choice= int(char)
        else:
            print("please enter numbers only")        
    return choice
    
def float_input(prompt=">", default = 0):
    """ask and returns an float value from the user"""
    answer_ok = False
    while not answer_ok:
        answer = input(prompt)
        if answer == "":
            return default
        try:
            newvalue = float(answer)
            answer_ok = True
        except ValueError:
            print("integer or float with decimal point please")
    return newvalue

    
def mainmenu(maxnumber=4):
    print ("welcome")
    print ("1... compare Goblins")
    print ("2... modify Stinky")
    print ("3... modify Grunty")
    print ("4... fight many battles")
    print ("0... quit")
    return integer_input(0,4, "your choice?>")


def compareValues(a, b):
    """returns a string with a table comparing the values of 
       hp, attack, defense of a and b"""
    text =  "\n          Stinky | vs. | Grunty "
    text += "\n ----------------+-----+-----------"
    text += "\n hitpoints: {:>4.1f} |  {}  | {:>4.1f}".format(
         a.hitpoints, sign(a.hitpoints, b.hitpoints), b.hitpoints)
    text += "\n attack:    {:>4.1f} |  {}  | {:>4.1f}".format(
         a.attack, sign(a.attack, b.attack), b.attack)
    text += "\n defense:   {:>4.1f} |  {}  | {:>4.1f}".format(
         a.defense, sign(a.defense, b.defense), b.defense)
    text += "\n"
    return text

def output(battle, combatround, a, b):
    """returns a string with battle, round and hitpoints"""
    text = "\n---battle {:3d} round {:3d}".format(battle, combatround)
    text += "--- Stinky: {:.0f} Grunty: {:.0f}".format(a.hitpoints,
             b.hitpoints)
    return text

def strike(attacker, defender, counterstrike=False):
    """attacker strikes at defender. The function changes the new
    hitpoints of the defender and returns a text String with the 
    combat report.
    counterstrike (boolean) indicates that this is a counterattack 
    or not."""
    if counterstrike:
        t = "counterattack"
    else:
        t = "attack"
    rollAtt = reroll(1, 6) # allowed to re-roll if a 6 is thrown
    rollDef = reroll(1, 6)
    scoreA = attacker.attack + rollAtt
    scoreD = defender.defense + rollDef
    striketext = "{} rolls {}, {} rolls {}".format(attacker.name,
                     rollAtt, defender.name, rollDef)
    if scoreA > scoreD:   
        striketext += "\nSucessfull {0} !  ({1:.2f} > {2:.2f})".format(
                      t, scoreA, scoreD)
        damage = scoreA - scoreD
        defender.hitpoints -= damage
        #statistics
        attacker.damage_dealt+= damage
        defender.damage_received+= damage
        striketext += "...doing {0:.2f} damage.".format(damage)
    else:
        striketext = "The {0} failed... ({1:.2f} <= {2:.2f})".format(
                      t, scoreA, scoreD)
    return striketext

def game(stinky, grunty):
    """the Goblin Dice Duel game main function"""
    # ask how many battles
    battles = integer_input(1,1000000, 
        "fight how many battles ? (ENTER = 100)",100)
    maxrounds = integer_input(1,1000,
        "max rounds per battle ? (ENTER = 30)", 30)
    text = ""
    text += "\n --- Goblin Dice Duel ---\n\n"
    text += compareValues(stinky, grunty)
    text += "\n *** TOURNAMENT START ***"
    # reset wins
    stinky.wins = 0
    grunty.wins = 0
    # fight !
    for x in range(1,battles+1):
        combatround = 0 # reset combatround for this battle
        text += "\n\n\n-BATTLE {} STARTS NOW".format(x)
        text += "\n\n-GET READY\n\n-FIGHT!!\n\n"
        #------------BATTLE------------
        while (stinky.hitpoints > 0 and grunty.hitpoints > 0 and
               combatround < maxrounds):
            combatround += 1
            text += output(x, combatround, stinky, grunty)
            # find out who strikes first
            (attacker, defender) = random.choice([(stinky, grunty),
                (grunty, stinky)])
            text += "\n{} strikes first: ".format(attacker.name)
            text += strike(attacker, defender, False)
            if defender.hitpoints > 0:
                text += "\nCounterstrike of {}: ".format(defender.name)
                text += strike(defender, attacker, True)    
        # output of final strike
        text += output(x, combatround, stinky, grunty) 
        text += "\nThis battle is over"
        if (combatround >= maxrounds and stinky.hitpoints>0 and 
            grunty.hitpoints>0):
            text+= " because exceeding {} rounds".format(maxrounds)
            text+= "\nNobody wins"
        elif stinky.hitpoints > grunty.hitpoints:
            stinky.wins+=1
            text+= "\nStinky wins battle {}".format(x)
        elif grunty.hitpoints > stinky.hitpoints:
            grunty.wins+=1
            text+= "\nGrunty wins battle {}".format(x)    
        # heal to full health after one battle
        #restore original hitpoints
        stinky.restore_health()
        grunty.restore_health()
    # statistic after end of all fights 
    text+= "\n\n*** statistics: ***\n\n"
    text+= "                          ø DMG | ø DMG   "
    text+= "\nVictories in %   | Wins | dealt | received"
    text+= "\n-----------------+------+-------+--------"
    text+= "\n  "
    text+= "Stinky  {:5.1f}% | {:4.0f} | {:5.1f} | {:5.1f}".format(
             stinky.wins/(x/100),stinky.wins, stinky.damage_dealt/x,
             stinky.damage_received/x)    
    text+= "\n  "
    text+= "Grunty  {:5.1f}% | {:4.0f} | {:5.1f} | {:5.1f} ".format(
            grunty.wins/(x/100), grunty.wins, grunty.damage_dealt/x,
            grunty.damage_received/x)
    text+= "\n-----------------+------+-------+--------"
    text+= "\nDraws:    {:5.1f}% | {:4.0f} |       |".format(  
        100*(battles - stinky.wins - grunty.wins)/battles,
        battles - stinky.wins - grunty.wins) 
    #text += "\n-----------------+------+-------+--------"
    text+= "\n"+compareValues(stinky, grunty)
    text+= "==============================================="
    
    print(text)
    
    # output into logfile
    try:
        with open('combatlog.txt', 'a') as logfile:
            logfile.write(text)
        print("combat results appended into file 'combatlog.txt'")
    except:
        print("problem with file combatlog.txt")
     
            


def edit(goblin, modlist):
    """let the user change att, def and hp of a goblin"""
    print("all stats of {}:".format(goblin.name))
    print(goblin.report())
    print("\n edit some stats for {}:".format(goblin.name))
    
    for mystat in modlist:
        print("The current value of {} is {}".format(mystat, 
               goblin.__getattribute__(mystat)))
        newvalue = float_input("new value ? [Enter=accept]>", 
                                goblin.__getattribute__(mystat))
        goblin.__setattr__(mystat, newvalue) # set new value
        if mystat == "hitpoints":
            goblin.__setattr__("fullhealth", newvalue) # copy hp
    print("thank you for editing this goblin") 
        


    
    

if __name__ == "__main__":
    stinky = Goblin("Stinky")
    grunty = Goblin("Grunty")
    editlist = ["attack", "defense", "hitpoints"] # moddable stats 
    battles = 100
    while True:
        c= mainmenu(battles)
        if c == 0:
            break
        elif c == 1:
            print(compareValues(stinky, grunty))
        elif c == 2:
            edit(stinky, editlist)
        elif c == 3:
            edit(grunty, editlist)
        elif c == 4:
            game(stinky, grunty)
    print("bye-bye")


########NEW FILE########
__FILENAME__ = slowgoblins016menudemo
"""part of http://ThePythonGameBook.com
source code: 

https://github.com/horstjens/ThePythonGameBook/blob/master/
python/goblins/slowgoblins016menudemo.py

menu demo 

This demo is a nearly identical copy of the simplemenu tutorial
of  Christian Hausknecht, located at
https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus

and licensed under the gpl license. 

see https://github.com/Lysander/snippets/blob/master/Python/python-misc/simplemenus/submenu.py
for the original file 

"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'

import sys

class Goblin(object):
    """demo class, goblins only have a name attribute"""
    def __init__(self, name="anonymous goblin"):
        self.name = name
    

def integer_input(min_value,max_value, prompt=">", default=-1):
    """ask and returns an integer between min_value and max_value"""
    while True:
        try:
            choice = int(input(prompt))
            if choice == "":
                choice = default
            if min_value <= choice < max_value:
                return choice 
            else:
                raise IndexError
        except (ValueError, IndexError):
            print("please enter numbers between {} and {} only".format(
                min_value, max_value-1))
    
    
def info():
    """demo method"""
    print("this is some information")



def rename_team(team_number):
    """rename teamnames in the teamnamces dict and in the menu dict"""
    # hier kommt nicht der neue name
    new_name = input("please enter new name for team number {}: ".format(
        team_number))
    if new_name == "":
        print("nothing renamed")
        return
    team_names[team_number] = new_name
    # change the submenu
    key = "team{0}".format(team_number)
    menu[key][0][0] = "exit menu of team {} (team {})".format(new_name,
        team_number)
    # root menu entry for team 0 is 1, entry for team 1 is 2 ....
    menu["root"][team_number+1][0] = "manage team {} (team {})".format(
        new_name, team_number)
    

def buy_goblin(team_number):
    """create goblin instance and add it to team"""
    new_name = input("please give the new goblin a nickname:")
    if new_name == "":
        new_name = "not yet nicknamed goblin"
    teams[team_number].append(Goblin(new_name))
    print("You purchased {} for the team!".format(new_name))

def show_goblins(team_number):
    """print a list of all goblins in this team"""
    print("------- all goblins of team {} ------".format(
        team_names[team_number]))
    for goblin in teams[team_number]:
        print(goblin.name)
    print("--------------------------")

# -------------------------- Christan's Code ----------------
    
def print_menu(menu):
    """
    Function that prints our menu items. It adds an numeric index to each
    item in order to make that the choosebale index for the user.
    
    :param menu: tuple with menu definition
    """
    # start numbering the items with number 0 
    for index, item in enumerate(menu, 0): 
        print("{}  {}".format(index, item[0]))    
    

def handle_menu(menudef):
    """
    Core function of our menu system. It handles the complete process of
    printing the menu, getting the user input and calling the corresponding
    function.
    
    We recognize if a 'submenu' is called by comparing the type of the second
    parameter of our entry item. If that is a string, we interpret that as the
    key of a corresponding 'menu' and make that the current menu to operate on.
    
    :param menudef: dict with menu definition
    """
    category = "root"
    while True:
        # Hint: 'menu' does not name the complete menu-structure (the dict)
        # but instead it just refenrences the entries for one dictionary-key.
        # And those we can call just 'menu'. Perhaps 'entries' would have been 
        # a better name, but that would have broken the parameter naming of
        # the tow other functions.
        menu = menudef[category]
        print_menu(menu)
        choice = integer_input(0,len(menu))
        _, command = menu[choice]       # the _ is a name vor a variable
        # here is the 'submenu'-magic. Just change the dictionary key and go
        # on in the loop, so the chosen submenu will be handled.
        if isinstance(command, str):
            category = command
        else:
            command()


if __name__ == "__main__":
    teams = {0: [], 1:[]}
    team_names = {0: "team 0", 1:"team 1"}
    teams[0].append(Goblin("Stinky"))
    teams[1].append(Goblin("Grunty"))
    menu = {"root": [
                # to handle a function with parameters, use lambda:
                ["Exit the main menu", lambda: sys.exit(0)],
                # go to another submenu by writing the submenu name
                ["Manage team 0", "team0"],
                ["Manage team 1", "team1"],
                # call a function by writing the funciton name
                ["Show info", info]  ],
            "team0": [
                ["Exit menu of team 0", "root"],
                ["show goblins", lambda: show_goblins(0)],
                ["buy goblin", lambda: buy_goblin(0)],
                ["rename team", lambda: rename_team(0)], 
                ["Show info... ", info] ],
            "team1": [
                ["Exit menu of team 1", "root"],
                ["showgoblins", lambda: show_goblins(1)],
                ["buy goblin", lambda: buy_goblin(1)],
                ["rename team", lambda: rename_team(1)], 
                ["Show info... ", info] ] }

    handle_menu(menu)

########NEW FILE########
__FILENAME__ = slowgoblins017menudemo
"""part of http://ThePythonGameBook.com
source code: 

https://github.com/horstjens/ThePythonGameBook/blob/master/
python/goblins/slowgoblins016.py

dynamic menus, goblins have unique numbers to handle them

This demo is based on the submenu example
of  Christian Hausknecht, located at
https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus

and licensed under the gpl license. 

see https://github.com/Lysander/snippets/blob/master/Python/python-misc/simplemenus/submenu.py
for the original file 

"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'

import sys

class Goblin(object):
    """demo class, goblins only have a name attribute
    and a unique number (managed by a class attribute)"""
    number = 0 # class attribute
    
    def __init__(self, name="anonymous goblin"):
        self.name = name
        self.number = Goblin.number
        Goblin.number += 1 # prepare class attribute for next goblin
    

    
def integer_input(min_value,max_value, prompt=">", default=-1):
    """ask and returns an integer between min_value and max_value"""
    while True:
        try:
            choice = int(input(prompt))
            if choice == "":
                choice = default
            if min_value <= choice < max_value:
                return choice 
            else:
                raise IndexError
        except (ValueError, IndexError):
            print("please enter numbers between {} and {} only".format(
                min_value, max_value-1))
    
    
def info():
    """demo method"""
    print("this is some information")


def buy_goblin(team_number):
    """create goblin instance and add it to team"""
    new_name = input("please give the new goblin a nickname:")
    if new_name == "":
        new_name = "not yet nicknamed goblin"
    g = Goblin(new_name)
    gnr = g.number
    Config.teams[team_number][gnr] = g                # add new goblin to team
    key = "editgoblins{}".format(team_number)
    # add edit goblin menu entry
    Config.menu[key].append(["edit goblin {} ({})".format(new_name, gnr),
        lambda: edit_goblin(gnr, team_number)])
    print("You purchased {} for the team!".format(new_name))

def show_goblins(team_number):
    """print a list of all goblins in this team"""
    print("------- all goblins of team {} ------".format(
        Config.team_names[team_number]))
    for (gnr, goblin) in Config.teams[team_number].items():
        print("{} ({})".format(goblin.name, gnr))
    print("--------------------------")


def rename_team(team_number):
    """rename teamnames in the teamnamces dict and in the menu dict"""
    new_name = input("please enter new name for team number {}: ".format(
        team_number))
    if new_name == "":
        print("nothing renamed")
        return
    Config.team_names[team_number] = new_name
    # change the submenu
    key = "team{0}".format(team_number)
    Config.menu[key][0][0] = "exit menu of team {} (team {})".format(new_name,
        team_number)
    # root menu entry for team 0 is 1, entry for team 1 is 2 ....
    Config.menu["root"][team_number+1][0] = "manage team {} (team {})".format(
        new_name, team_number)

def edit_goblin(number, team_number):
    """let the user change the name attribute of an individual goblin
    need goblins unique number and team number"""  
    #get goblin
    if not number in Config.teams[team_number]:
        print("no goblin with this number is in your team")
        return
    goblin = Config.teams[team_number][number]
    old_name = goblin.name
    new_name = input("please enter the new name for goblin {}: ".format(
        goblin.name)) 
    if new_name == "":
        print("nothing changed")
        return
    goblin.name = new_name
    # change menu entry, search for old entry
    key = "editgoblins{}".format(team_number)
    subkey = "edit goblin {} ({})".format(old_name, number)
    newkey = "edit goblin {} ({})".format(new_name, number)
    for entry in Config.menu[key]:
        if entry[0] == subkey:
            entry[0] = newkey
            break
    else:
        print("error.. i did not found the correct menu entry")
            
           
def sell_goblin(team_number):
    """ask user for goblins unique number and delete this goblin
       from team and delete corresponding edit goblin menu entry"""
    # create prompt
    p = "\n".join(("Each goblins has a unique goblin number. You can",
        "see this number using the 'show all goblins' menu",
        "it is the number in round parentheses",
        "unique number of goblin you want to sell ?"))
    print(p)
    # Goblin.number (class attribute) - 1 is the hightest possible 
    # number of a goblin. It does not mean that this goblin still exist
    delnumber = integer_input(-1, Goblin.number,"(-1 is cancel) >")
    if delnumber == -1:
        print("sell action canceled")
        return
    # check if this goblin exist in the selected team
    if not  delnumber in Config.teams[team_number]:
        print("No goblin with this number exist in your team")
        return
    d = Config.teams[team_number].pop(delnumber) # d is the deleted goblin
    print("Goblin {} sold".format(d.name))
    #remove editmenu entrys
    key = "editgoblins{}".format(team_number)
    subkey = "edit goblin {} ({})".format(d.name, delnumber)
    for entry in Config.menu[key]:
        if entry[0] == subkey:
            Config.menu[key].remove([entry[0], entry[1]])
            break
    else:
        print("error.. i did not found the correct menu entry")
    
    
def print_menu(menu):
    """
    Function that prints our menu items. It adds an numeric index to each
    item in order to make that the choosebale index for the user.
    
    :param menu: tuple with menu definition
    """
    # start numbering the items with number 0 
    for index, item in enumerate(menu, 0): 
        print("{}  {}".format(index, item[0]))  
        

def handle_menu(menudef):
    """
    Core function of our menu system. It handles the complete process of
    printing the menu, getting the user input and calling the corresponding
    function.
    
    We recognize if a 'submenu' is called by comparing the type of the second
    parameter of our entry item. If that is a string, we interpret that as the
    key of a corresponding 'menu' and make that the current menu to operate on.
    
    :param menudef: dict with menu definition
    """
    category = "root"
    while True:
        # Hint: 'menu' does not name the complete menu-structure (the dict)
        # but instead it just refenrences the entries for one dictionary-key.
        # And those we can call just 'menu'. Perhaps 'entries' would have been 
        # a better name, but that would have broken the parameter naming of
        # the tow other functions.
        menu = menudef[category]
        print_menu(menu)
        choice = integer_input(0,len(menu))
        _, command = menu[choice]       # the _ is a name vor a variable
        # here is the 'submenu'-magic. Just change the dictionary key and go
        # on in the loop, so the chosen submenu will be handled.
        if isinstance(command, str):
            category = command
        else:
            command()

class Config(object):
    """class to hold 'global' variables
    (all done as class instances)"""
    teams = {0: {}, 1:{}} # a dict of dicts
    team_names = {0: "team 0", 1:"team 1"}
    menu = {"root": [
                # to handle a function with parameters, use lambda:
                ["Exit the main menu", lambda: sys.exit(0)],
                # go to another submenu by writing the submenu name
                ["Manage team 0", "team0"],
                ["Manage team 1", "team1"],
                # call a function by writing the funciton name
                ["Show info", info]  ],
            "team0": [
                ["Exit menu of team 0", "root"],
                ["show all goblins", lambda: show_goblins(0)],
                ["buy goblin", lambda: buy_goblin(0)],
                ["rename team", lambda: rename_team(0)], 
                ["edit goblins", "editgoblins0"],
                ["sell goblin (number)", lambda: sell_goblin(0)],
                ["Show info... ", info] ],
            "team1": [
                ["Exit menu of team 1", "root"],
                ["show all goblins", lambda: show_goblins(1)],
                ["buy goblin", lambda: buy_goblin(1)],
                ["rename team", lambda: rename_team(1)], 
                ["edit goblins", "editgoblins1"],
                ["sell goblin (number)", lambda: sell_goblin(1)],
                ["Show info... ", info] ], 
            "editgoblins0": [
                ["Exit the edit goblins menu", "team0"],
                ["edit goblin Stinky (0)", lambda: edit_goblin(0,0)] ],
            "editgoblins1": [
                ["Exit the edit goblins menu", "team1"],
                ["edit goblin Grunty (1)", lambda: edit_goblin(1,1)] ]
            }

def main():
    """the main function of the game"""
    #teams = {0: {}, 1:{}} # a dict of dicts
    #team_names = {0: "team 0", 1:"team 1"}
    gob0 = Goblin("Stinky")
    gob0nr = gob0.number               # first goblin, his number is 0
    gob1 = Goblin("Grunty")
    gob1nr = gob1.number               # second goblin, his number is 1
    # inside each team dict, the goblin number is key, 
    # the goblin instance (the goblin himself) is the value
    Config.teams[0][gob0nr] = gob0 # Stinky joins team0
    Config.teams[1][gob1nr] = gob1 # Grunty joins team1
    
    
    handle_menu(Config.menu)

if __name__ == "__main__":
    main()
    

########NEW FILE########
__FILENAME__ = slowgoblins018
"""part of http://ThePythonGameBook.com
source code: 

https://github.com/horstjens/ThePythonGameBook/blob/master/
python/goblins/slowgoblins018.py

DONE: #overwrite all goblin stats with arguments
      #ask isinstance (str, float) for each attribute before editing
      #calculate stat sum
      #show stat sum
      #get money for buying and selling goblins
      #edit stats (att, def, hp) cost money
      
some code is based on the menudemo of  Christian Hausknecht, located at
https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus

and licensed under the gpl license. 

see https://github.com/Lysander/snippets/blob/master/Python/python-misc/simplemenus/submenu.py
for the original file 

"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'

import sys
import random

class Goblin(object):
    """demo class, goblins only have a name attribute
    and a unique number (managed by a class attribute)"""
    number = 0 # class attribute
    
    def __init__(self, name="anonymous goblin", **kwargs):
        """creates a new goblin instance
        every attribute can be overwritten with an argument like      
        g = Goblin(attack = 33.2)
        this will overwrite the random self.attack attribute with 33.2
        """
        self.name = name
        # float values
        self.attack = random.gauss(Config.attack, 2)
        self.defense = random.gauss(Config.defense, 2)
        # always create an goblin with twice the "normal" hitpoints
        # to make him cost real money
        self.hitpoints = random.gauss(Config.hitpoints*2, 3) 
        self.fullhealth = self.hitpoints 
        # integer values 
        self.defense_penalty = 0
        #statistics
        self.damage_dealt = 0
        self.damage_received = 0
        self.wins = 0
        self.fights = 0
        # overwrite attributes if keywords were passed as arguments
        for key in kwargs:
            self.__setattr__(key, kwargs[key])
        # but do not mess around with number
        self.number = Goblin.number # access class attribute
        Goblin.number += 1 # prepare class attribute for next goblin
        # calculate value based on averages described in class Config
        self.value = self.calculate_value()
        
    def calculate_value(self):
        """calculates a 'value' of the goblin based on att, def and hp.
        Formula:
        1.) compare attack, defense and hitpoints with the average 
        values found in class Config.
        2.) take the difference between actual attribute and average
        3.) square the difference but keep the sign 
        4.) build a sum of those squared differences
        Effect should be that a few big differences from the "norm" cost 
        a lot more gold than many small differences"""
        value = 0.0
        for attr in ["attack", "defense", "hitpoints"]:
            actual_value = self.__getattribute__(attr)
            average_value = Config.__getattribute__(Config,attr)
            diff = actual_value - average_value
            if diff < 0:
                sign = -1
            else:
                sign = 1
            value += sign * diff**2  # square the diff but keep the sign
        return value
        
    def restore_health(self):
        """restore original hitpoints"""
        self.hitpoints = self.fullhealth 
        
    def report(self):
        """returns a string with the actual stats"""
        text=""
        for stat in filter(lambda x: "__" not in x, dir(self)):
            if "bound method" in str(self.__getattribute__(stat)):
                continue # ignore methods, only take attributes
            #print(stat)
            attr = self.__getattribute__(stat)
            #testing if attribute is string or int or float
            if isinstance(attr, int) or isinstance(attr, float):
                text+= "\n{:>20}: {:5.1f}".format (stat, attr)
            else:
                text+= "\n{:>20}: {}".format(stat, attr)
        return text

def integer_input(prompt=">", default=-1, minv=-9999999, maxv=9999999):
    """ask and returns an integer between min_value and max_value"""
    while True:
        try:
            choice = int(input(prompt))
            if choice == "":
                choice = default
            if minv <= choice <= maxv:
                return choice 
            else:
                raise IndexError
        except (ValueError, IndexError):
            print("please enter numbers between {} and {} only".format(
                minv, maxv))
    
def float_input(prompt=">", default=0, minv=-9999999, maxv=9999999):
    """ask and returns an float value from the user"""
    answer_ok = False
    while not answer_ok:
        answer = input(prompt)
        if answer == "":
            return default
        try:
            newvalue = float(answer)
            if minv <= newvalue <= maxv:
                answer_ok = True
            else:
                raise IndexError
        except (ValueError, IndexError):
            print("integer or float with decimal point please")
            print("enter value between {} and {}".format(
                    minv, maxv))
    return newvalue

def text_input(prompt=">", default=""):
    """text input function that always returns a text an can handle
    default values if the user only type the ENTER key"""
    new_value = input(prompt)
    if new_value == "":
        return default
    else:
        return new_value
    
def info():
    """demo method"""
    print("this is some information")

def buy_goblin(team_number):
    """create goblin instance and add it to team"""
    new_name = input("please give the new goblin a nickname:")
    if new_name == "":
        new_name = "unnamed goblin"
    g = Goblin(new_name)
    gnr = g.number
    Config.teams[team_number][gnr] = g          # add new goblin to team
    Config.gold[team_number]-=g.value           # deduct gold for buying
    key = "editgoblins{}".format(team_number)
    # add edit goblin menu entry
    Config.menu[key].append(["edit goblin {} ({})".format(new_name, gnr),
        lambda: edit_goblin(gnr, team_number)])
    print("You purchased {} for the team!".format(new_name))

def show_goblins(team_number):
    """print a list of all goblins in this team and the team gold
    also sum all stats (att, def, hitpoints, value) for the team"""
    print("{} team {} gold: {:6.2f} {}".format(16*"-",
        Config.team_names[team_number],Config.gold[team_number],16*"-"))
    print("{:>20}:   attack   defense hitpoints     value".format(
        "attribute"))
    print("{:>20}: {:8.2f} {:8.2f} {:8.2f}".format("normal", 
          Config.attack,Config.defense,Config.hitpoints))
    print("{:>20}{}".format("--goblin (unique nr)",40*"-"))
    sumatt, sumdef, sumhp, sumval = 0,0,0,0
    for (gnr, goblin) in Config.teams[team_number].items():
        print("{:>15} ({:>2}): {:8.2f} {:8.2f} {:8.2f}   {:8.2f}".format(
            goblin.name, gnr, goblin.attack, goblin.defense,
            goblin.hitpoints, goblin.value))
        sumatt += goblin.attack
        sumdef += goblin.defense
        sumhp  += goblin.hitpoints
        sumval += goblin.value
    print(60*"-")
    print("{:>20}: {:8.2f} {:8.2f} {:8.2f}   {:8.2f}".format("sum",
        sumatt, sumdef, sumhp, sumval))

def rename_team(team_number):
    """rename teamnames in the teamnamces dict and in the menu dict"""
    new_name = input("please enter new name for team number {}: ".format(
        team_number))
    if new_name == "":
        print("nothing renamed")
        return
    Config.team_names[team_number] = new_name
    # change the submenu
    key = "team{0}".format(team_number)
    Config.menu[key][0][0] = "exit menu of team {} (team {})".format(new_name,
        team_number)
    # root menu entry for team 0 is 1, entry for team 1 is 2 ....
    Config.menu["root"][team_number+1][0] = "manage team {} (team {})".format(
        new_name, team_number)

def edit_goblin(number, team_number):
    """let the user change attributes of an individual goblin
    need goblins unique number and team number"""  
    #get goblin
    if not number in Config.teams[team_number]:
        print("no goblin with this number is in your team")
        return
    goblin = Config.teams[team_number][number]
    print("current values for this goblin:", goblin.report())
    print("please enter the new (>0) values for name, att, def and hp:")
    namechange = False
    old_name = goblin.name
    for stat in ["name", "attack", "defense", "hitpoints"]:
       attr = goblin.__getattribute__(stat)
       old_value = attr
       print("old value (Enter to accept) for {} is: {}".format(
               stat , old_value))
       if isinstance(attr, float):
           new_value = float_input("new value ?", old_value, old_value)
       elif isinstance(attr, int):
           new_value = integer_input("new value ?", old_value, old_value)
       elif isinstance(attr, str):
           new_value = text_input("new value ?", old_value)
       else:
           print("unknown attribute error") # boolean ?
           raise ValueError
       if new_value == old_value:
           print("nothing changed")
           continue
       if stat == "name":
           namechange = True
       else:
           # display gold cost before and let user confirm
           # new value is always bigger than old value
           norm = Config.__getattribute__(Config, stat)
           # signed(delta_new_norm_)squared - signed(delta_old_norm)squared 
           dnn = new_value - norm # delta new norm
           don = old_value - norm # delta old norm
           if dnn >= 0:           
               sdnns = dnn**2     # signed delta new norm squared
           else:
               sdnns = -1 * dnn**2
           if don >= 0:
               sdons = don**2    # signed delta old norm squared
           else:
               sdons = -1 * don**2 
           price = sdnns - sdons
           print("This change would cost: {} gold".format(price))
           print("Your team has {} gold".format(Config.gold[team_number]))
           if price > Config.gold[team_number]:
               print("nothing changed, due to lack of gold")
               continue
           if integer_input("accept? 0=cancel, 1=yes",0,0,1) == 1:
               goblin.__setattr__(stat, new_value)
               print("changed {} from {} to {}".format(stat, old_value, 
                  new_value)) 
               Config.gold[team_number] -= price
           else:
               print("nothing changed because user canceled")
    # ---- end of for loop ----
    # if new name, change menu entry, search for old entry
    if namechange:
        new_name = goblin.name
        key = "editgoblins{}".format(team_number)
        subkey = "edit goblin {} ({})".format(old_name, number)
        newkey = "edit goblin {} ({})".format(new_name, number)
        for entry in Config.menu[key]:
            if entry[0] == subkey:
                entry[0] = newkey
                break
        else:
            print("error.. i did not found the correct menu entry")
            
def sell_goblin(team_number):
    """ask user for goblins unique number and delete this goblin
       from team and delete corresponding edit goblin menu entry"""
    # create prompt
    p = "\n".join(("Each goblins has a unique goblin number. You can",
        "see this number using the 'show all goblins' menu",
        "it is the number in round parentheses",
        "unique number of goblin you want to sell ?"))
    print(p)
    # Goblin.number (class attribute) - 1 is the hightest possible 
    # number of a goblin. It does not mean that this goblin still exist
    delnumber = integer_input("(-1 is cancel) >", -1, -1, Goblin.number)
    if delnumber == -1:
        print("sell action canceled")
        return
    # check if this goblin exist in the selected team
    if not  delnumber in Config.teams[team_number]:
        print("No goblin with this number exist in your team")
        return
    d = Config.teams[team_number].pop(delnumber) # d is the deleted goblin
    Config.gold[team_number]+= d.value # add gold for selling goblin
    print("Goblin {} sold".format(d.name))
    #remove editmenu entrys
    key = "editgoblins{}".format(team_number)
    subkey = "edit goblin {} ({})".format(d.name, delnumber)
    for entry in Config.menu[key]:
        if entry[0] == subkey:
            Config.menu[key].remove([entry[0], entry[1]])
            break
    else:
        print("error.. i did not found the correct menu entry")
    
def print_menu(menu):
    """print visible menu points. menu is the key in the giant menu
    dict so that the corresponding (sub) menu is printed-
    see original code and tutorial of Christian Hausknecht
    https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus
    """
    # start numbering the items with number 0 
    for index, item in enumerate(menu, 0): 
        print("{}  {}".format(index, item[0]))  
        
def handle_menu(menudef):
    """ print menu, ask for action, userinput, does action, print menu
    menudef is the menu structure ( giant dict )
    see original code and tutorial of Christian Hausknecht
    https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus
    """
    category = "root"
    while True:
        # Hint: 'menu' does not name the complete menu-structure (the dict)
        # but instead it just refenrences the entries for one dictionary-key.
        # And those we can call just 'menu'. Perhaps 'entries' would have been 
        # a better name, but that would have broken the parameter naming of
        # the tow other functions.
        menu = menudef[category]
        print_menu(menu)
        choice = integer_input(default=0, minv=0, maxv=len(menu)-1)
        _, command = menu[choice]       # the _ is a name vor a variable
        # here is the 'submenu'-magic. Just change the dictionary key and go
        # on in the loop, so the chosen submenu will be handled.
        if isinstance(command, str):
            category = command
        else:
            command()

class Config(object):
    """class to hold various 'global' variables until a clean place to
    store those variables is found. (all done as class instances)"""
    teams = {0: {}, 1:{}} # a dict of dicts
    gold = {0:500, 1:500}   # inital design points for each team
    team_names = {0: "team 0", 1:"team 1"}
    #  average values to create goblins and calculate their money value
    hitpoints = 10 # it's twice that number in reality to make goblins expensive
    attack = 10
    defense = 10
    menu = {"root": [
                # to handle a function with parameters, use lambda:
                ["Exit the main menu", lambda: sys.exit(0)],
                # go to another submenu by writing the submenu name
                ["Manage team 0", "team0"],
                ["Manage team 1", "team1"],
                # call a function by writing the funciton name
                ["Show info", info]  ],
            "team0": [
                ["Exit menu of team 0", "root"],
                ["show all goblins", lambda: show_goblins(0)],
                ["buy goblin", lambda: buy_goblin(0)],
                ["rename team", lambda: rename_team(0)], 
                ["edit goblins", "editgoblins0"],
                ["sell goblin (number)", lambda: sell_goblin(0)],
                ["Show info... ", info] ],
            "team1": [
                ["Exit menu of team 1", "root"],
                ["show all goblins", lambda: show_goblins(1)],
                ["buy goblin", lambda: buy_goblin(1)],
                ["rename team", lambda: rename_team(1)], 
                ["edit goblins", "editgoblins1"],
                ["sell goblin (number)", lambda: sell_goblin(1)],
                ["Show info... ", info] ], 
            "editgoblins0": [
                ["Exit the edit goblins menu", "team0"],
                ["edit goblin Stinky (0)", lambda: edit_goblin(0,0)] ],
            "editgoblins1": [
                ["Exit the edit goblins menu", "team1"],
                ["edit goblin Grunty (1)", lambda: edit_goblin(1,1)] ]
            }

def main():
    """the main function of the game"""
    gob0 = Goblin("Stinky")
    gob0nr = gob0.number               # first goblin, his number is 0
    gob1 = Goblin("Grunty")
    gob1nr = gob1.number               # second goblin, his number is 1
    # inside each team dict, the goblin number is key, 
    # the goblin instance (the goblin himself) is the value
    Config.teams[0][gob0nr] = gob0 # Stinky joins team0
    Config.teams[1][gob1nr] = gob1 # Grunty joins team1
    # adjust the gold for each team to reflect buying the first goblin
    Config.gold[0] -= gob0.value
    Config.gold[1] -= gob1.value
    # start the menu, start the game
    handle_menu(Config.menu)

if __name__ == "__main__":
    main()
    

########NEW FILE########
__FILENAME__ = slowgoblins019
"""part of http://ThePythonGameBook.com
source code: 

https://github.com/horstjens/ThePythonGameBook/blob/master/
python/goblins/slowgoblins019.py

TODO:    #compare teams of goblins
         #change sort order
         #sort compare tables by column (attribute)
         #toggle sleep for each goblin
         #check money when buying new goblins 
      
some code is based on the menudemo of  Christian Hausknecht, located at
https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus

and licensed under the gpl license. 

see https://github.com/Lysander/snippets/blob/master/Python/python-misc/simplemenus/submenu.py
for the original file 

for usage of operator.attrgetter, see:
http://wiki.python.org/moin/HowTo/Sorting/
"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'

import sys
import random
import operator 

class Goblin(object):
    """demo class, goblins only have a name attribute
    and a unique number (managed by a class attribute)"""
    number = 0 # class attribute
    
    def __init__(self, name="anonymous goblin", **kwargs):
        """creates a new goblin instance
        every attribute can be overwritten with an argument like      
        g = Goblin(attack = 33.2)
        this will overwrite the random self.attack attribute with 33.2
        """
        self.name = name
        self.attack = random.gauss(Config.attack, 2) # float values
        self.defense = random.gauss(Config.defense, 2)
        # always create an goblin with twice the "normal" hitpoints
        # to make him cost real money
        self.hitpoints = random.gauss(Config.hitpoints*2, 3) 
        self.fullhealth = self.hitpoints 
        self.defense_penalty = 0 # integer value
        self.sleep = False # boolean 
        #statistics
        self.damage_dealt = 0
        self.damage_received = 0
        self.wins = 0
        self.fights = 0
        # overwrite attributes if keywords were passed as arguments
        for key in kwargs:
            self.__setattr__(key, kwargs[key])
        # but do not mess around with number
        self.number = Goblin.number # access class attribute
        Goblin.number += 1 # prepare class attribute for next goblin
        # calculate value based on averages described in class Config
        self.value = self.calculate_value()
        
    def calculate_value(self):
        """calculates a 'value' of the goblin based on att, def and hp.
        Formula:
        1.) compare attack, defense and hitpoints with the average 
        values found in class Config.
        2.) take the difference between actual attribute and average
        3.) square the difference but keep the sign 
        4.) build a sum of those squared differences
        Effect should be that a few big differences from the "norm" cost 
        a lot more gold than many small differences"""
        value = 0.0
        for attr in ["attack", "defense", "hitpoints"]:
            actual_value = self.__getattribute__(attr)
            average_value = Config.__getattribute__(Config,attr)
            diff = actual_value - average_value
            if diff < 0:
                sign = -1
            else:
                sign = 1
            value += sign * diff**2  # square the diff but keep the sign
        return value
        
    def restore_health(self):
        """restore original hitpoints"""
        self.hitpoints = self.fullhealth 
        
    def report(self):
        """returns a string with all the actual stats"""
        text=""
        for stat in filter(lambda x: "__" not in x, dir(self)):
            if "bound method" in str(self.__getattribute__(stat)):
                continue # ignore methods, only take attributes
            #print(stat)
            attr = self.__getattribute__(stat)
            #testing if attribute is string or int or float
            if stat == "sleep":  # sleep is boolean
                text+= "\n{:>20}: {}".format(stat, attr)
            elif isinstance(attr, int) or isinstance(attr, float):
                text+= "\n{:>20}: {:5.1f}".format(stat, attr)
            else:
                text+= "\n{:>20}: {}".format(stat, attr)
        return text
    
    def __repr__(self):
        """overwriting the representation method of a goblin object"""
        return "{:>15} ({:>2}): {:8.2f} {:8.2f} {:8.2f}   {:8.2f}  {}".format(
            self.name, self.number, self.attack, self.defense, 
            self.hitpoints, self.value, self.sleep)

def integer_input(prompt=">", default=-1, minv=-9999999, maxv=9999999):
    """ask and returns an integer between min_value and max_value"""
    while True:
        try:
            choice = int(input(prompt))
            if choice == "":
                choice = default
            if minv <= choice <= maxv:
                return choice 
            else:
                raise IndexError
        except (ValueError, IndexError):
            print("please enter numbers between {} and {} only".format(
                minv, maxv))
    
def float_input(prompt=">", default=0, minv=-9999999, maxv=9999999):
    """ask and returns an float value from the user"""
    answer_ok = False
    while not answer_ok:
        answer = input(prompt)
        if answer == "":
            return default
        try:
            newvalue = float(answer)
            if minv <= newvalue <= maxv:
                answer_ok = True
            else:
                raise IndexError
        except (ValueError, IndexError):
            print("integer or float with decimal point please")
            print("enter value between {} and {}".format(
                    minv, maxv))
    return newvalue

def text_input(prompt=">", default=""):
    """text input function that always returns a text an can handle
    default values if the user only type the ENTER key"""
    new_value = input(prompt)
    if new_value == "":
        return default
    else:
        return new_value
    
def info():
    """demo method"""
    print("this is some information")

def buy_goblin(team_number):
    """create goblin instance and add it to team"""
    #check money
    if Config.gold[team_number] <= 0:
        print("Your team has no gold! Sell some goblins first")
        return
    new_name = input("please give the new goblin a nickname:")
    if new_name == "":
        new_name = "unnamed goblin"
    g = Goblin(new_name)
    gnr = g.number
    Config.teams[team_number][gnr] = g          # add new goblin to team
    Config.gold[team_number]-=g.value           # deduct gold for buying
    key = "editgoblins{}".format(team_number)
    # add edit goblin menu entry
    Config.menu[key].append(["edit goblin {} ({})".format(new_name, gnr),
        lambda: edit_goblin(gnr, team_number)])
    print("You purchased {} for the team!".format(new_name))

def show_goblins(team_number):
    """print a list of all goblins in this team and the team gold
    also sum all stats (att, def, hitpoints, value) for the team"""
    print("{} team {} gold: {:6.2f} {}".format(20*"-",
        Config.team_names[team_number],Config.gold[team_number],20*"-"))
    print("{:>20}: attack   defense hitpoints     value  sleep".format(
        "attribute"))
    print("{:>20}: {:8.2f} {:8.2f} {:8.2f}".format("normal", 
          Config.attack,Config.defense,Config.hitpoints))
    print("{:>20}{}".format("--goblin (unique nr)",46*"-"))
    sumatt, sumdef, sumhp, sumval, sumsleep = 0,0,0,0,0
    sortlist = []
    for (gnr, goblin) in Config.teams[team_number].items():
        sortlist.append(goblin)
    for goblin in sorted(sortlist, key=operator.attrgetter(
        Config.sortorder[0], Config.sortorder[1], Config.sortorder[2]),
        reverse = Config.reverse):
           print(goblin) # this calls self.__repr__ of Goblin instance
           sumatt += goblin.attack
           sumdef += goblin.defense
           sumhp  += goblin.hitpoints
           sumval += goblin.value
           sumsleep+=goblin.sleep # True count as 1, False as 0
    print(66*"=")
    print("{:>20}: {:8.2f} {:8.2f} {:8.2f}   {:8.2f} {:>2}".format("sum",
        sumatt, sumdef, sumhp, sumval, sumsleep))
    print(66*"-")

def rename_team(team_number):
    """rename teamnames in the teamnamces dict and in the menu dict"""
    new_name = input("please enter new name for team number {}: ".format(
        team_number))
    if new_name == "":
        print("nothing renamed")
        return
    Config.team_names[team_number] = new_name
    # change the submenu
    key = "team{0}".format(team_number)
    Config.menu[key][0][0] = "exit menu of team {} (team {})".format(new_name,
        team_number)
    # root menu entry for team 0 is 1, entry for team 1 is 2 ....
    Config.menu["root"][team_number+1][0] = "manage team {} (team {})".format(
        new_name, team_number)

def edit_goblin(number, team_number):
    """let the user change attributes of an individual goblin
    need goblins unique number and team number"""  
    #get goblin
    if not number in Config.teams[team_number]:
        print("no goblin with this number is in your team")
        return
    goblin = Config.teams[team_number][number]
    print("current values for this goblin:", goblin.report())
    print("please enter the new (>0) values for name, att, def and hp:")
    namechange = False
    old_name = goblin.name
    for stat in ["name", "attack", "defense", "hitpoints"]:
       attr = goblin.__getattribute__(stat)
       old_value = attr
       print("old value (Enter to accept) for {} is: {}".format(
               stat , old_value))
       if isinstance(attr, float):
           new_value = float_input("new value ?", old_value, old_value)
       elif isinstance(attr, int):
           new_value = integer_input("new value ?", old_value, old_value)
       elif isinstance(attr, str):
           new_value = text_input("new value ?", old_value)
       else:
           print("unknown attribute error") # boolean ?
           raise ValueError
       if new_value == old_value:
           print("nothing changed")
           continue
       if stat == "name":
           goblin.name = new_value
           namechange = True
       else:
           # display gold cost before and let user confirm
           # new value is always bigger than old value
           norm = Config.__getattribute__(Config, stat)
           # signed(delta_new_norm_)squared - signed(delta_old_norm)squared 
           dnn = new_value - norm # delta new norm
           don = old_value - norm # delta old norm
           if dnn >= 0:           
               sdnns = dnn**2     # signed delta new norm squared
           else:
               sdnns = -1 * dnn**2
           if don >= 0:
               sdons = don**2    # signed delta old norm squared
           else:
               sdons = -1 * don**2 
           price = sdnns - sdons
           print("This change would cost: {} gold".format(price))
           print("Your team has {} gold".format(Config.gold[team_number]))
           if price > Config.gold[team_number]:
               print("nothing changed, due to lack of gold")
               continue
           if integer_input("accept? 0=cancel, 1=yes",0,0,1) == 1:
               goblin.__setattr__(stat, new_value)
               print("changed {} from {} to {}".format(stat, old_value, 
                  new_value)) 
               Config.gold[team_number] -= price
           else:
               print("nothing changed because user canceled")
    # ---- end of for loop ----
    # if new name, change menu entry, search for old entry
    if namechange:
        new_name = goblin.name 
        key = "editgoblins{}".format(team_number)
        subkey = "edit goblin {} ({})".format(old_name, number)
        newkey = "edit goblin {} ({})".format(new_name, number)
        for entry in Config.menu[key]:
            if entry[0] == subkey:
                entry[0] = newkey
                break
        else:
            print("error.. i did not found the correct menu entry")
            
def sell_goblin(team_number):
    """ask user for goblins unique number and delete this goblin
       from team and delete corresponding edit goblin menu entry"""
    # create prompt
    p = "\n".join(("Each goblins has a unique goblin number. You can",
        "see this number using the 'show all goblins' menu",
        "it is the number in round parentheses",
        "unique number of goblin you want to sell ?"))
    print(p)
    # Goblin.number (class attribute) - 1 is the hightest possible 
    # number of a goblin. It does not mean that this goblin still exist
    delnumber = integer_input("(-1 is cancel) >", -1, -1, Goblin.number)
    if delnumber == -1:
        print("sell action canceled")
        return
    # check if this goblin exist in the selected team
    if not  delnumber in Config.teams[team_number]:
        print("No goblin with this number exist in your team")
        return
    d = Config.teams[team_number].pop(delnumber) # d is the deleted goblin
    Config.gold[team_number]+= d.value # add gold for selling goblin
    print("Goblin {} sold".format(d.name))
    #remove editmenu entrys
    key = "editgoblins{}".format(team_number)
    subkey = "edit goblin {} ({})".format(d.name, delnumber)
    for entry in Config.menu[key]:
        if entry[0] == subkey:
            Config.menu[key].remove([entry[0], entry[1]])
            break
    else:
        print("error.. i did not found the correct menu entry")

def toggle_sleep(team_number):
    """ask user for goblin number and toggle sleep status"""
     # create prompt
    p = "\n".join(("Each goblins has a unique goblin number. You can",
        "see this number using the 'show all goblins' menu",
        "it is the number in round parentheses",
        "unique number of goblin you want sleep/wake up ?"))
    print(p)
    sleepnumber = integer_input("(-1 is cancel) >", -1, -1, Goblin.number)
    if sleepnumber == -1:
        print("toggle sleep action canceled")
        return
    # check if this goblin exist in the selected team
    if not  sleepnumber in Config.teams[team_number]:
        print("No goblin with this number exist in your team")
        return
    g = Config.teams[team_number][sleepnumber]
    g.sleep = not g.sleep # toggle sleep
    print("Sleep status of Goblin {}({}) changed to {}".format(g.name,
        g.number, g.sleep))

def print_menu(menu):
    """print visible menu points. menu is the key in the giant menu
    dict so that the corresponding (sub) menu is printed-
    see original code and tutorial of Christian Hausknecht
    https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus
    """
    # start numbering the items with number 0 
    for index, item in enumerate(menu, 0): 
        print("{}  {}".format(index, item[0]))  
        
def handle_menu(menudef):
    """ print menu, ask for action, userinput, does action, print menu
    menudef is the menu structure ( giant dict )
    see original code and tutorial of Christian Hausknecht
    https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus
    """
    category = "root"
    while True:
        # Hint: 'menu' does not name the complete menu-structure (the dict)
        # but instead it just refenrences the entries for one dictionary-key.
        # And those we can call just 'menu'. Perhaps 'entries' would have been 
        # a better name, but that would have broken the parameter naming of
        # the tow other functions.
        menu = menudef[category]
        print_menu(menu)
        choice = integer_input(default=0, minv=0, maxv=len(menu)-1)
        _, command = menu[choice]       # the _ is a name vor a variable
        # here is the 'submenu'-magic. Just change the dictionary key and go
        # on in the loop, so the chosen submenu will be handled.
        if isinstance(command, str):
            category = command
        else:
            command()

def sign(a, b):
    """compares a with b and returns a "<","=" or ">" sign """
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="
            
def compare_teams(a,b):
    """printing comparasion table for two teams"""
    print("-----------------------------")
    print("comparing team {} ({}) with team {} ({})".format(
        Config.team_names[a],a,Config.team_names[b],b))
    print("{:>20}: {:6.1f}   {} {:6.1f}".format("gold", Config.gold[a], 
        sign(Config.gold[a],Config.gold[b]), Config.gold[b]))
    print("{:>20}: {:6.1f}   {} {:6.1f}".format("goblins", 
        len(Config.teams[a]), sign(len(Config.teams[a]),
        len(Config.teams[b])), len(Config.teams[b])))
    
    for stat in ["attack", "defense", "hitpoints", "value", "sleep"]:
        statsum={a:0, b:0}
        for x in [a,b]:
            for (gbnr, goblin) in Config.teams[x].items():
                statsum[x] += goblin.__getattribute__(stat)
        print("{:>20}: {:6.1f}   {} {:6.1f}".format(stat, statsum[a], sign(statsum[a],
            statsum[b]), statsum[b]))
            
# funcitons for sorting
def display_sortorder():
    print("the current sortorder is:")
    print(Config.sortorder)
    print("reverse: ", Config.reverse)

def toggle_reverse():
    Config.reverse = not Config.reverse
    print("changed reverse to ", Config.reverse)
    
def sort(rank):
    """ask the user for a keyword and manipulates Config.sortorder"""
    valid = ["attack", "defense", "hitpoints", "value", "name", "sleep"]
    print("The keyword for sorting must be one of those words:")
    print(valid)
    print("(without the brackets, quotes and commas)")
    answer = text_input("please enter the attribute for sorting:>")
    if not answer in valid:
        print("sorry this was not a valid answer. nothing changed")
        return
    old = Config.sortorder[rank]
    Config.sortorder[rank] = answer
    print("changed sortorder for rank {} from {} to {}".format(rank,
        old, answer))

class Config(object):
    """class to hold various 'global' variables until a clean place to
    store those variables is found. (all done as class instances)"""
    teams = {0: {}, 1:{}} # a dict of dicts
    gold = {0:500, 1:500}   # inital design points for each team
    team_names = {0: "team 0", 1:"team 1"}
    #  average values to create goblins and calculate their money value
    hitpoints = 10 # it's twice that number in reality to make goblins expensive
    attack = 10
    defense = 10
    sortorder = ["attack","defense","hitpoints","value"]
    reverse = False
    menu = {"root": [
                # to handle a function with parameters, use lambda:
                ["Exit the main menu", lambda: sys.exit(0)],
                # go to another submenu by writing the submenu name
                ["Manage team 0", "team0"],
                ["Manage team 1", "team1"],
                # call a function by writing the funciton name
                ["Compare teams", lambda: compare_teams(0,1) ],
                ["Show info", info]  ],
            "team0": [
                ["Exit menu of team 0", "root"],
                ["show all goblins", lambda: show_goblins(0)],
                ["buy goblin", lambda: buy_goblin(0)],
                ["rename team", lambda: rename_team(0)], 
                ["edit goblins", "editgoblins0"],
                ["sell goblin (number)", lambda: sell_goblin(0)],
                ["toggle sleep for goblin (number)", 
                    lambda: toggle_sleep(0)],
                ["Change sort order", "sortorder"],
                ["Show info... ", info] ],
            "team1": [
                ["Exit menu of team 1", "root"],
                ["show all goblins", lambda: show_goblins(1)],
                ["buy goblin", lambda: buy_goblin(1)],
                ["rename team", lambda: rename_team(1)], 
                ["edit goblins", "editgoblins1"],
                ["sell goblin (number)", lambda: sell_goblin(1)],
                ["toggle sleep for goblin (number)", 
                    lambda: toggle_sleep(1)],
                ["Change sort order", "sortorder"],
                ["Show info... ", info] ], 
            "editgoblins0": [
                ["Exit the edit goblins menu", "team0"],
                ["edit goblin Stinky (0)", lambda: edit_goblin(0,0)] ],
            "editgoblins1": [
                ["Exit the edit goblins menu", "team1"],
                ["edit goblin Grunty (1)", lambda: edit_goblin(1,1)] ],
            "sortorder": [
                ["Exit the sortorder menu", "root"],
                ["display sort order", display_sortorder],  
                ["toogle reverse sorting", toggle_reverse],
                ["edit first sort key", lambda: sort(0)],
                ["edit second sort key", lambda: sort(1)],
                ["edit third sort key", lambda: sort(2)],
                ["edit fourth sort key", lambda: sort(3)]  ]
            }

def main():
    """the main function of the game"""
    gob0 = Goblin("Stinky")
    gob0nr = gob0.number               # first goblin, his number is 0
    gob1 = Goblin("Grunty")
    gob1nr = gob1.number               # second goblin, his number is 1
    # inside each team dict, the goblin number is key, 
    # the goblin instance (the goblin himself) is the value
    Config.teams[0][gob0nr] = gob0 # Stinky joins team0
    Config.teams[1][gob1nr] = gob1 # Grunty joins team1
    # adjust the gold for each team to reflect buying the first goblin
    Config.gold[0] -= gob0.value
    Config.gold[1] -= gob1.value
    # start the menu, start the game
    handle_menu(Config.menu)

if __name__ == "__main__":
    main()
    

########NEW FILE########
__FILENAME__ = slowgoblins020
"""part of http://ThePythonGameBook.com
source code: 

https://github.com/horstjens/ThePythonGameBook/blob/master/
python/goblins/slowgoblins020.py

TODO:    #decrease defense for each counterstrike
         #team battles
         #gold for won battles / damage dealt
         #stats after combat
         #tail-recursion in re-roll (thanks to yipyip)
         #calculate_value (and editstats) improved (thanks to yipyip)
         #generic input function
         #fileoperation IOError
         
         
some code is based on the menudemo of  Christian Hausknecht, located at
https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus

and licensed under the gpl license. 

see https://github.com/Lysander/snippets/blob/master/Python/python-misc/simplemenus/submenu.py
for the original file 

for usage of operator.attrgetter, see:
http://wiki.python.org/moin/HowTo/Sorting/
"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'

import sys
import random
import operator 

class Goblin(object):
    """demo class, goblins only have a name attribute
    and a unique number (managed by a class attribute)"""
    number = 0 # class attribute
    
    def __init__(self, name="anonymous goblin", **kwargs):
        """creates a new goblin instance
        every attribute can be overwritten with an argument like      
        g = Goblin(attack = 33.2)
        this will overwrite the random self.attack attribute with 33.2
        """
        self.name = name
        self.attack = random.gauss(Config.attack, 2) # float values
        self.defense = random.gauss(Config.defense, 2)
        # always create an goblin with twice the "normal" hitpoints
        # to make him cost real money
        self.hitpoints = random.gauss(Config.hitpoints*2, 3) 
        self.fullhealth = self.hitpoints 
        self.defense_penalty = 0 # integer value
        self.sleep = False # boolean 
        #statistics
        self.damage_dealt = 0
        self.damage_received = 0
        self.victory = 0  # over all rounds
        self.streak = 0  # victories in this combat
        self.lastround = 0 # number of combatround whre goblin lost
        self.lost = 0
        self.fights = 0
        # overwrite attributes if keywords were passed as arguments
        for key in kwargs:
            self.__setattr__(key, kwargs[key])
        # but do not mess around with number
        self.number = Goblin.number # access class attribute
        Goblin.number += 1 # prepare class attribute for next goblin
        # calculate value based on averages described in class Config
        self.value = self.calculate_value()

    def prepare_for_fight(self):
        """reset attributes like hitpoints, loot etc for each battle"""
        self.restore_health() # restore full hitpoints
        self.fights += 1     
        self.damage_received = 0 # clear for this battle
        self.damage_dealt = 0
        self.streak = 0      # enemys knocked out in one battle
        self.lastround = 0   # fighting until this round (if >0)
        self.loot = 0        # gold plundered from fallen enemys
        
    def calculate_value(self):
        """calculates a 'value' of the goblin based on att, def and hp.
        Formula:
        1.) compare attack, defense and hitpoints with the average 
        values found in class Config.
        2.) take the difference between actual attribute and average
        3.) square the difference but keep the sign 
        4.) build a sum of those squared differences
        Effect should be that a few big differences from the "norm" cost 
        a lot more gold than many small differences"""
        #value = 0.0
        #for attr in ["attack", "defense", "hitpoints"]:
        #    actual_value = self.__getattribute__(attr)
        #    average_value = Config.__getattribute__(Config,attr)
        #    diff = actual_value - average_value
        #    if diff < 0:
        #        sign = -1
        #    else:
        #        sign = 1
        #    value += sign * diff**2  # square the diff but keep the sign
        #return value
        ## code from yipyip
        ## (1,-1)[True] is the same as (1,-1)[1] = -1
        ## (1,-1)[False] is the same as (1,-1)[0] = 1
        diffs = (pts-cfg for pts, cfg in zip((self.attack, self.defense,
             self.hitpoints), (Config.attack, Config.defense, 
             Config.hitpoints)))
        return sum((1, -1)[diff < 0] * diff ** 2 for diff in diffs)
        
        
        
    def restore_health(self):
        """restore original hitpoints"""
        self.hitpoints = self.fullhealth 
        
    def report(self):
        """returns a string with all the actual stats"""
        text=""
        for stat in filter(lambda x: "__" not in x, dir(self)):
            if "bound method" in str(self.__getattribute__(stat)):
                continue # ignore methods, only take attributes
            #print(stat)
            attr = self.__getattribute__(stat)
            #testing if attribute is string or int or float
            if stat == "sleep":  # sleep is boolean
                text+= "\n{:>20}: {}".format(stat, attr)
            elif isinstance(attr, int) or isinstance(attr, float):
                text+= "\n{:>20}: {:5.1f}".format(stat, attr)
            else:
                text+= "\n{:>20}: {}".format(stat, attr)
        return text
    
    def __repr__(self):
        """overwriting the representation method of a goblin object"""
        return "{:>15} ({:>2}): {:6.2f} {:6.2f} {:6.2f} {:6.2f} {}".format(
            self.name, self.number, self.attack, self.defense, 
            self.hitpoints, self.value, self.sleep)

def generic_input(typ="int", prompt=">", default=0, minv=-9999999, maxv=9999999):
    """ask user and returns answer (of typ "int", "float", "text")"""
    while True:
        raw = input(prompt)
        if raw == "":
            return default
        if typ == "text":
            return raw
        try:
            if typ == "int":
                answer = int(raw)
                if minv <= answer <= maxv:
                    return answer
                else:
                    raise IndexError
            
            elif typ == "float":
                answer = float(raw)
                if minv <= answer <= maxv:
                    return answer
                else:
                    raise IndexError
        except (ValueError, IndexError):
            print("please enter numbers between {} and {}".format(
                   minv, maxv))
            if typ=="float" and not "." in raw:
                print("use decimal point")
                
def info():
    """demo method"""
    print("this is some information")

def buy_goblin(team_number):
    """create goblin instance and add it to team"""
    #check money
    if Config.gold[team_number] <= 0:
        print("Your team has no gold! Sell some goblins first")
        return
    new_name = generic_input(typ="text",prompt="nickname for new goblin?",
         default="unnamed goblin")
    g = Goblin(new_name)
    gnr = g.number
    Config.teams[team_number][gnr] = g          # add new goblin to team
    Config.gold[team_number]-=g.value           # deduct gold for buying
    key = "editgoblins{}".format(team_number)
    # add edit goblin menu entry
    Config.menu[key].append(["edit goblin {} ({})".format(new_name, gnr),
        lambda: edit_goblin(gnr, team_number)])
    print("You purchased {} for the team!".format(new_name))

def show_goblins(team_number):
    """print a list of all goblins in this team and the team gold
    also sum all stats (att, def, hitpoints, value) for the team"""
    print("{} team {} gold: {:6.2f} {}".format(20*"-",
        Config.team_names[team_number],Config.gold[team_number],20*"-"))
    print("{:>20}:   att   def     hp   value  sleep".format(
        "attribute"))
    print("{:>20}: {:6.2f} {:6.2f} {:6.2f}".format("normal", 
          Config.attack,Config.defense,Config.hitpoints))
    print("{:>20}{}".format("--goblin (unique nr)",46*"-"))
    sumatt, sumdef, sumhp, sumval, sumsleep = 0,0,0,0,0
    sortlist = []
    for (gnr, goblin) in Config.teams[team_number].items():
        sortlist.append(goblin)
    for goblin in sorted(sortlist, key=operator.attrgetter(
        Config.sortorder[0], Config.sortorder[1], Config.sortorder[2]),
        reverse = Config.reverse):
           print(goblin) # this calls self.__repr__ of Goblin instance
           sumatt += goblin.attack
           sumdef += goblin.defense
           sumhp  += goblin.hitpoints
           sumval += goblin.value
           sumsleep+=goblin.sleep # True count as 1, False as 0
    print(66*"=")
    print("{:>20}: {:6.2f} {:6.2f} {:6.2f} {:6.2f} {:>2}".format("sum",
        sumatt, sumdef, sumhp, sumval, sumsleep))
    print(66*"-")

def rename_team(team_number):
    """rename teamnames in the teamnamces dict and in the menu dict"""
    new_name = input("please enter new name for team number {}: ".format(
        team_number))
    if new_name == "":
        print("nothing renamed")
        return
    Config.team_names[team_number] = new_name
    # change the submenu
    key = "team{0}".format(team_number)
    Config.menu[key][0][0] = "exit menu of team {} (team {})".format(new_name,
        team_number)
    # root menu entry for team 0 is 1, entry for team 1 is 2 ....
    Config.menu["root"][team_number+1][0] = "manage team {} (team {})".format(
        new_name, team_number)

def edit_goblin(number, team_number):
    """let the user change attributes of an individual goblin
    need goblins unique number and team number"""  
    #get goblin
    if not number in Config.teams[team_number]:
        print("no goblin with this number is in your team")
        return
    goblin = Config.teams[team_number][number]
    print("current values for this goblin:", goblin.report())
    print("please enter the new (>0) values for name, att, def and hp:")
    namechange = False
    old_name = goblin.name
    for stat in ["name", "attack", "defense", "hitpoints"]:
       attr = goblin.__getattribute__(stat)
       old_value = attr
       print("old value (Enter to accept) for {} is: {}".format(
               stat , old_value))
       if isinstance(attr, float):
           new_value = generic_input("float","new value ?", old_value, old_value)
       elif isinstance(attr, int):
           new_value = generic_input("int","new value ?", old_value, old_value)
       elif isinstance(attr, str):
           new_value = generic_input("text","new value ?", old_value)
       else:
           print("unknown attribute error") # boolean ?
           raise ValueError
       if new_value == old_value:
           print("nothing changed")
           continue
       if stat == "name":
           goblin.name = new_value
           namechange = True
       else:
           
           # display gold cost before attribute change and let user confirm
           # new value is always bigger than old value
           norm = Config.__getattribute__(Config, stat)
           # signed(delta_new_norm_)squared - signed(delta_old_norm)squared 
           diffnew = new_value - norm # delta new norm
           diffold = old_value - norm # delta old norm
           pricenew = (1,-1)[diffnew<0] * diffnew ** 2
           priceold = (1,-1)[diffold<0] * diffold ** 2
           #if dnn >= 0:           
           #    sdnns = dnn**2     # signed delta new norm squared
           #else:
           #    sdnns = -1 * dnn**2
           #if don >= 0:
           #    sdons = don**2    # signed delta old norm squared
           #else:
           #    sdons = -1 * don**2 
           #price = sdnns - sdons
           price = pricenew - priceold
           print("This change would cost: {} gold".format(price))
           print("Your team has {} gold".format(Config.gold[team_number]))
           if price > Config.gold[team_number]:
               print("nothing changed, due to lack of gold")
               continue
           if generic_input("int","accept? 0=cancel, 1=yes",0,0,1) == 1:
               goblin.__setattr__(stat, new_value)
               print("changed {} from {} to {}".format(stat, old_value, 
                  new_value)) 
               Config.gold[team_number] -= price
           else:
               print("nothing changed because user canceled")
    # ---- end of for loop ----
    # if new name, change menu entry, search for old entry
    if namechange:
        new_name = goblin.name 
        key = "editgoblins{}".format(team_number)
        subkey = "edit goblin {} ({})".format(old_name, number)
        newkey = "edit goblin {} ({})".format(new_name, number)
        for entry in Config.menu[key]:
            if entry[0] == subkey:
                entry[0] = newkey
                break
        else:
            print("error.. i did not found the correct menu entry")
            
def sell_goblin(team_number):
    """ask user for goblins unique number and delete this goblin
       from team and delete corresponding edit goblin menu entry"""
    # create prompt
    p = "\n".join(("Each goblins has a unique goblin number. You can",
        "see this number using the 'show all goblins' menu",
        "it is the number in round parentheses",
        "unique number of goblin you want to sell ?"))
    print(p)
    # Goblin.number (class attribute) - 1 is the hightest possible 
    # number of a goblin. It does not mean that this goblin still exist
    delnumber = generic_input("int","(-1 is cancel) >", -1, -1, Goblin.number)
    if delnumber == -1:
        print("sell action canceled")
        return
    # check if this goblin exist in the selected team
    if not  delnumber in Config.teams[team_number]:
        print("No goblin with this number exist in your team")
        return
    d = Config.teams[team_number].pop(delnumber) # d is the deleted goblin
    Config.gold[team_number]+= d.value # add gold for selling goblin
    print("Goblin {} sold".format(d.name))
    #remove editmenu entrys
    key = "editgoblins{}".format(team_number)
    subkey = "edit goblin {} ({})".format(d.name, delnumber)
    for entry in Config.menu[key]:
        if entry[0] == subkey:
            Config.menu[key].remove([entry[0], entry[1]])
            break
    else:
        print("error.. i did not found the correct menu entry")

def toggle_sleep(team_number):
    """ask user for goblin number and toggle sleep status"""
     # create prompt
    p = "\n".join(("Each goblins has a unique goblin number. You can",
        "see this number using the 'show all goblins' menu",
        "it is the number in round parentheses",
        "unique number of goblin you want sleep/wake up ?"))
    print(p)
    sleepnumber = generic_input("int","(-1 is cancel) >", -1, -1, Goblin.number)
    if sleepnumber == -1:
        print("toggle sleep action canceled")
        return
    # check if this goblin exist in the selected team
    if not  sleepnumber in Config.teams[team_number]:
        print("No goblin with this number exist in your team")
        return
    g = Config.teams[team_number][sleepnumber]
    g.sleep = not g.sleep # toggle sleep
    print("Sleep status of Goblin {}({}) changed to {}".format(g.name,
        g.number, g.sleep))

def print_menu(menu):
    """print visible menu points. menu is the key in the giant menu
    dict so that the corresponding (sub) menu is printed-
    see original code and tutorial of Christian Hausknecht
    https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus
    """
    # start numbering the items with number 0 
    for index, item in enumerate(menu, 0): 
        print("{}  {}".format(index, item[0]))  
        
def handle_menu(menudef):
    """ print menu, ask for action, userinput, does action, print menu
    menudef is the menu structure ( giant dict )
    see original code and tutorial of Christian Hausknecht
    https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus
    """
    category = "root"
    while True:
        # Hint: 'menu' does not name the complete menu-structure (the dict)
        # but instead it just refenrences the entries for one dictionary-key.
        # And those we can call just 'menu'. Perhaps 'entries' would have been 
        # a better name, but that would have broken the parameter naming of
        # the tow other functions.
        menu = menudef[category]
        print_menu(menu)
        choice = generic_input("int",prompt="Your menu choice?", 
            default=0, minv=0, maxv=len(menu)-1)
        _, command = menu[choice]       # the _ is a name vor a variable
        # here is the 'submenu'-magic. Just change the dictionary key and go
        # on in the loop, so the chosen submenu will be handled.
        if isinstance(command, str):
            category = command
        else:
            command()

def sign(a, b):
    """compares a with b and returns a "<","=" or ">" sign """
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="
            
def compare_teams(a,b):
    """printing comparasion table for two teams"""
    print("-----------------------------")
    print("comparing team {} ({}) with team {} ({})".format(
        Config.team_names[a],a,Config.team_names[b],b))
    print("{:>20}: {:6.1f}   {} {:6.1f}".format("gold", Config.gold[a], 
        sign(Config.gold[a],Config.gold[b]), Config.gold[b]))
    print("{:>20}: {:6.1f}   {} {:6.1f}".format("goblins", 
        len(Config.teams[a]), sign(len(Config.teams[a]),
        len(Config.teams[b])), len(Config.teams[b])))
    
    for stat in ["attack", "defense", "hitpoints", "value", "sleep",
        "victory", "lost", "fights", "damage_received", "damage_dealt"]:
        statsum={a:0, b:0}
        for x in [a,b]:
            for (gbnr, goblin) in Config.teams[x].items():
                statsum[x] += goblin.__getattribute__(stat)
        print("{:>20}: {:6.1f}   {} {:6.1f}".format(stat, statsum[a], sign(statsum[a],
            statsum[b]), statsum[b]))
# combat

def clear_logfile(filename = "combatlog.txt"):
    """overwrites the old combatlogfile with empty text"""
    try:
        with open('combatlog.txt', 'w') as logfile:
            logfile.write("---")
        print("combatlogfile cleared")
    except IOError:
        print("problems writing combatlog.txt")

def reroll(min_eyes, max_eyes, accu=0, depth=99):
    """a die that is allowed to re-roll when the max_eyes is thrown.
       return the sum of all throws minus 1 per max_eyes thrown.
       This allows very high results with a very small propability
       example:  6(=max eyes) + (reroll) 6 + 2 = (6-1)+(6-1)+2 =12
       see https://gist.github.com/yipyip/6205271 and
       tail-recursion for more information"""
       
    assert depth >= 0 # make sure that depth is not negative 
    
    result = random.randint(min_eyes, max_eyes)
    if result < max_eyes or depth == 0:
        return accu + result
    return reroll(min_eyes, max_eyes, accu + result - 1, depth - 1)
 

    
def strike(attacker, defender, combatround, counterstrike=False):
    """attacker strikes at defender. The function changes the new
    hitpoints of the defender and returns a text String with the 
    combat report.
    counterstrike (boolean) indicates that this is a counterattack 
    or not.
    Each counterstrike (=being attacked) increases the defense penalty
    by one
    """
    striketext = [] # a list of textlines !
    if counterstrike:
        t = "counterattack"
    else:
        t = "attack"
        
    rollAtt = reroll(1, 6) # allowed to re-roll if a 6 is thrown
    rollDef = reroll(1, 6)
    scoreA = attacker.attack + rollAtt
    scoreD = defender.defense + rollDef - defender.defense_penalty
    striketext.append("{} rolls {}, {} rolls {}".format(attacker.name,
        rollAtt, defender.name, rollDef))
    if scoreA > scoreD:   
        striketext.append("Sucessfull {0} !  ({1:.2f} > {2:.2f})".format(
            t, scoreA, scoreD))
        damage = scoreA - scoreD
        defender.hitpoints -= damage
        #statistics
        attacker.damage_dealt+= damage
        defender.damage_received+= damage 
        striketext.append("...doing {0:.2f} damage.".format(damage))
        if defender.hitpoints <= 0:
            attacker.victory += 1
            attacker.streak += 1
            defender.lost += 1
            defender.lastround  = combatround
            striketext.append("Victory for {}! {} goes down".format(
               attacker.name, defender.name))
            striketext.append("This is victory {} for {}".format(
                attacker.victory, attacker.name)+" ( {} had {} ".format(
                defender.name, defender.victory)+" before he got down)")
            striketext.append("{} wins {:.2f} gold for his team".format(
                attacker.name, defender.fullhealth * Config.loot))
            attacker.loot = defender.fullhealth * Config.loot
    else:
        striketext.append("The {0} failed... ({1:.2f} <= {2:.2f})".format(
            t, scoreA, scoreD))
    if counterstrike:
        attacker.defense_penalty += 1 # each counterstrike lowers defense
    return striketext

def combatround(a,b, number):
    """a round of combat between team a and team b. 
    Each non-sleeping, alive (hp>0) goblin can make one stike against
    another goblin of the enemy team.
    Each attacked goblin (if he survive the attack) makes an counterstrike
    against his attacker, and get his defensepenalty increased by 1
    The effect is that many attack against a single victim are more
    likely to suceed, but remain dangerous for the attacker"""
    # reset all defense_penaltys to 0
    text = [] # a list of lines !
    for team in [a,b]:
        for goblin in Config.teams[team].values():
            goblin.defense_penalty = 0
    # randomize goblin.number to process combat order
    # TODO: give each goblin speed and initiative attributes
    order = list(range(Goblin.number)) # list of all goblin numbers
    random.shuffle(order) # random ordering of those numbers
    for gnr in order:
        if gnr in Config.teams[a]:
            myteam = a
            enemyteam = b
        elif gnr in Config.teams[b]:
            myteam = b
            enemyteam = a
        else:
            continue # non-existing goblin ( sold? )
        attacker = Config.teams[myteam][gnr]
        if attacker.sleep or attacker.hitpoints <= 0:
            continue
        # search random victim
        victimlist = [x for x in Config.teams[enemyteam].values() if ((
           x.sleep == False ) and (x.hitpoints > 0))]
        if len(victimlist) == 0:
            continue 
        defender = random.choice(victimlist)
        text.append("--")
        text.append("{} (nr {}) of team {} strikes".format(
            attacker.name, attacker.number, Config.team_names[a]) +
            " {} (nr {})  of team {}".format(defender.name, 
            defender.number, Config.team_names[b]))
        text.append("{:<20}:  att    def      hp".format("  Strike!")+
            "    $  sleep def-penalty")
        text.append(str(attacker)+" {}".format(attacker.defense_penalty))
        text.append(str(defender)+" {}".format(defender.defense_penalty))
        text.extend(strike(attacker, defender, number, False))
        if defender.hitpoints > 0:
            text.append("  Counterstrike of {}!".format(defender.name))
            text.extend(strike(defender, attacker, number, True))
    return text
            
def fight(a=0,b=1):
    """let fight all non-sleeping, alive goblins in 2 teams versus
       each other until one team has no goblins left"""  
    text = ["The big battle between team {} and team {} starts:".format(
        Config.team_names[a], Config.team_names[b])]
    for team in [a,b]:
        for goblin in Config.teams[team].values():
            if not goblin.sleep:
               goblin.prepare_for_fight() # restore hitpoints to full etc
    battleround = 0
    while True:
        battleround += 1
        ateam = [x for x in Config.teams[a].values() if ((
           x.sleep == False ) and (x.hitpoints > 0))]
        bteam = [x for x in Config.teams[b].values() if ((
           x.sleep == False ) and (x.hitpoints > 0))]
        if len(ateam) > 0 and len(bteam) > 0:
            text.append("=======================")
            text.append("---Battle round {:>4} ---".format(battleround))
            text.append("alive: {} vs. {}".format(len(ateam), len(bteam)))
            text.append("--------------------------")
            text.extend(combatround(a,b, battleround))
        elif len(ateam)>0:
            text.append("========================")
            text.append("team {} is victorious".format(Config.team_names[a]))
            text.append("========================")
            break
        elif len(bteam)>0:
            text.append("========================")
            text.append("team {} is victorious".format(Config.team_names[b]))
            text.append("========================")
            break
        else:
            text.append("no victorous team ?")
            break
    # ---- battle over, print textlines
    text.append("=====--------- battle statistics -----------=====")
    lootsum = [0.0,0.0]
    for t in [a,b]:
        text.append("------ team {} ----".format(Config.team_names[t]))
        tl = [ x for x in Config.teams[t].values() if not x.sleep]
        text.append("{:>20}{:>7}{:>7}{:>7}{:>7}{:>7}".format(
          "Name:","dmg d", "dmg r", "lst r", "streak", "loot"))
        for goblin in tl:
            #text.append(str(goblin))
            text.append("{:>20}{:7.2f}{:7.2f}{:7.2f}{:7.2f}{:7.2f}".format(
                goblin.name, goblin.damage_dealt, goblin.damage_received, 
                goblin.lastround, goblin.streak, goblin.loot))
            lootsum[t] += goblin.loot
        text.append("===================================")
        text.append("team {} made a sum of {:.2f} gold in this battle".format(
            Config.team_names[t], lootsum[t]))
        Config.gold[t] += lootsum[t]
            
    for line in text:
        print(line)    
    try:
        with open('combatlog.txt', 'a') as logfile:
            for line in text:
                logfile.write(line + "\n")
        print("combat log appended into file 'combatlog.txt'")
    except IOError:
        print("problem writing into file combatlog.txt")
            
# funcitons for sorting
def display_sortorder():
    print("the current sortorder is:")
    print(Config.sortorder)
    print("reverse: ", Config.reverse)

def toggle_reverse():
    Config.reverse = not Config.reverse
    print("changed reverse to ", Config.reverse)
    
def sort(rank):
    """ask the user for a keyword and manipulates Config.sortorder"""
    valid = ["attack", "defense", "hitpoints", "value", "name", "sleep"]
    print("The keyword for sorting must be one of those words:")
    print(valid)
    print("(without the brackets, quotes and commas)")
    answer = input("please enter the attribute for sorting:>")
    if not answer in valid:
        print("sorry this was not a valid answer. nothing changed")
        return
    old = Config.sortorder[rank]
    Config.sortorder[rank] = answer
    print("changed sortorder for rank {} from {} to {}".format(rank,
        old, answer))

class Config(object):
    """class to hold various 'global' variables until a clean place to
    store those variables is found. (all done as class instances)"""
    teams = {0: {}, 1:{}} # a dict of dicts
    gold = {0:500, 1:500}   # inital design points for each team
    team_names = {0: "team 0", 1:"team 1"}
    #  average values to create goblins and calculate their money value
    hitpoints = 10 # it's twice that number in reality to make goblins expensive
    attack = 10
    defense = 10
    loot = 1 # 1 gold per hitpoint of  knocked out enemy
    
    sortorder = ["attack","defense","hitpoints","value"]
    reverse = False
    menu = {"root": [
                # to handle a function with parameters, use lambda:
                ["Exit the main menu", lambda: sys.exit(0)],
                # go to another submenu by writing the submenu name
                ["Manage team 0", "team0"],
                ["Manage team 1", "team1"],
                # call a function by writing the funciton name
                ["Compare teams", lambda: compare_teams(0,1) ],
                ["Fight team vs team", fight],
                ["Clear combatlog.txt", clear_logfile],
                ["Show info", info]  ],
            "team0": [
                ["Exit menu of team 0", "root"],
                ["show all goblins", lambda: show_goblins(0)],
                ["buy goblin", lambda: buy_goblin(0)],
                ["rename team", lambda: rename_team(0)], 
                ["edit goblins", "editgoblins0"],
                ["sell goblin (number)", lambda: sell_goblin(0)],
                ["toggle sleep for goblin (number)", 
                    lambda: toggle_sleep(0)],
                ["Change sort order", "sortorder"],
                ["Show info... ", info] ],
            "team1": [
                ["Exit menu of team 1", "root"],
                ["show all goblins", lambda: show_goblins(1)],
                ["buy goblin", lambda: buy_goblin(1)],
                ["rename team", lambda: rename_team(1)], 
                ["edit goblins", "editgoblins1"],
                ["sell goblin (number)", lambda: sell_goblin(1)],
                ["toggle sleep for goblin (number)", 
                    lambda: toggle_sleep(1)],
                ["Change sort order", "sortorder"],
                ["Show info... ", info] ], 
            "editgoblins0": [
                ["Exit the edit goblins menu", "team0"],
                ["edit goblin Stinky (0)", lambda: edit_goblin(0,0)] ],
            "editgoblins1": [
                ["Exit the edit goblins menu", "team1"],
                ["edit goblin Grunty (1)", lambda: edit_goblin(1,1)] ],
            "sortorder": [
                ["Exit the sortorder menu", "root"],
                ["display sort order", display_sortorder],  
                ["toogle reverse sorting", toggle_reverse],
                ["edit first sort key", lambda: sort(0)],
                ["edit second sort key", lambda: sort(1)],
                ["edit third sort key", lambda: sort(2)],
                ["edit fourth sort key", lambda: sort(3)]  ]
            }

def main():
    """the main function of the game"""
    gob0 = Goblin("Stinky")
    gob0nr = gob0.number               # first goblin, his number is 0
    gob1 = Goblin("Grunty")
    gob1nr = gob1.number               # second goblin, his number is 1
    # inside each team dict, the goblin number is key, 
    # the goblin instance (the goblin himself) is the value
    Config.teams[0][gob0nr] = gob0 # Stinky joins team0
    Config.teams[1][gob1nr] = gob1 # Grunty joins team1
    # adjust the gold for each team to reflect buying the first goblin
    Config.gold[0] -= gob0.value
    Config.gold[1] -= gob1.value
    # start the menu, start the game
    handle_menu(Config.menu)

if __name__ == "__main__":
    main()
    

########NEW FILE########
__FILENAME__ = slowgoblins021classmenu_demo
"""part of http://ThePythonGameBook.com
source code: 

https://github.com/horstjens/ThePythonGameBook/blob/master/
python/goblins/slowgoblins021classmenu_demo.py

TODO:     +better remove submenu
          +dynamic finsh method     
         
some code is based on the menudemo of  Christian Hausknecht, located at
https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus

and licensed under the gpl license. 

see https://github.com/Lysander/snippets/blob/master/Python/python-misc/simplemenus/classmenu.py
for the original file 

"""
    

import sys
import itertools # from itertools import chain

#
# Create some little demo functions that does not have any sensefull 
# functionality but printing some stuff.
#

def make_some_foo_func(s):
    """just some demonstration functions"""
    def func():
        print(s)
    return func
    
hello, python, nothing, special  = list(make_some_foo_func(s) for s in 
        ("Hello World!", "Python rocks!", "Nothing to do yet...",
         "Wow! So special we must put it into a subsubmenu...")
    )

class Menu:
    """
    Class that represents and handles a complete menu system all in once.
    
    Each menu class can...
    
        ... print out the (current) menu
        ... handle the user input
        ... run in an event-loop, that handles the complete menu based
            workflow.
    
    It provides the `finish`-method, which adds automatically all needed
    'Exit'-entries to each (sub)menu, so building up a menu is not so much
    typing.
    
    To avoid recursion, we use the `context`-attribute of the Menu-class. The
    current menu-object is always bound to this attribute. As we can combine
    arbitrary menu objects (via the `append_submenu`-method) we must keep
    the current working menu accessible to operate only in one object, the
    'root'-object.
    """
    
    def __init__(self, title):
        self.title = title
        self.items = []
        self.context = self
    
    def __repr__(self):
        return "Menu({})".format(self.title)
    
    def __str__(self):
        head = ("", "-"*len(self.title), "{}".format(self.title),
                "-"*len(self.title))
        entries = ("{} {} {}".format(
                        index, "+" if isinstance(entry[1], Menu) else " ", 
                        entry[0]
                    )
                    for index, entry in enumerate(self, 0)
        )
        return "\n".join(itertools.chain(head, entries))

    def __getitem__(self, key):
        """
        Nice to have method for providing the iterable "interface". So you can
        access any menu item via an index or loop over all entries using
        `for` :-)
        """
        return self.items[key]
    
    def append(self, text, func):
        """
        Appends a menu entry to `self.items`.
        
        :param text: string with entry description
        :param func: callable that will be called if chosen
        """
        self.items.append((text, func))
    
    def insert(self, text, func):
        """
        insert a menu entry at position 0 to `self.items`.
        
        :param text: string with entry description
        :param func: callable that will be called if chosen
        """
        self.items.insert(0,(text,func))
        
    def remove(self, text):
        """
        remove a menu entry
        
        :param text: string with entry description
        """
        for (t, f) in self.items:
            if t == text:
                break
        else:
            print("did not found text")
            return
        self.items.remove((t, f))
    
    def append_submenu(self, other):
        """
        Appends a submenu entry to the menu. That can be a complex branch
        of menu-objects.
        
        :param other: Menu object, that represents a complete submenu-branch.
        """
        self.items.append((other.title, other))
        
    def remove_submenu(self, title):
        """removes complete submenu entry and tree"""
        pass # not necessary ?
        
    def finish(self, text="Exit"):
        """
        Nice helper method that computes all needed 'Exit'-items for each
        submenu and the 'final' 'Exit'-item at the main-menu, which is simply
        any string.
        
        All other exit-items are menu objects of the corresponding parent-menu.
        
        The algorithm implements a breadth-first search for handling this task.
        
        only useable once for a new menu, not later for a dynamic menu
        
        :param text: string with the text of the 'Exit'-item.
        """
        #self.items.append((text, "#exit"))
        self.items.insert(0,(text, "#exit"))
        stack = [(self, None)]
        while stack:
            menu, parent = stack.pop()
            for _, command in menu:
                if isinstance(command, Menu):
                    stack.append((command, menu))
            if menu is not self:
                #menu.append("{} -> {}".format(text, parent.title), parent)
                menu.insert("{} -> go back to {}".format(text, parent.title), parent)

    def get_user_input(self):
        while True:
            try:
                choice = int(input("Your choice?: ")) #- 1
                if -1 <= choice < len(self.context.items):
                    return choice
                else:
                    raise IndexError
            except (ValueError, IndexError):
                print("please enter numbers from 0 to {} only".format(
                                                    len(self.context.items)-1))

    def run(self):
        """
        Core method to handle a menu. This invokes a loop that handles all
        menu tasks as long as the main menu is exited by the user.
        """
        while True:
            print(self.context)
            choice = self.get_user_input()
            _, command = self.context[choice]
            if isinstance(command, Menu):
                self.context = command
            elif isinstance(command, str):
                return
            else:
                command()

    


class Game(object):
    def __init__(self):
        
        self.teams = []
        
        self.menu = Menu("main menu")
        self.menu.append("hello", hello)    # call function outside class
        self.menu.append("python", python)
        self.menu.append("greetings", self.greetings) # call method
        self.menu.append("new team", self.newteam)
        self.menu.append("kill team", self.killteam)
        
        sub = Menu("Sub menu")
        sub.append("action", nothing)

        # ... or to create menu objects that we can later on
        subsub = Menu("Subsub menu")
        subsub.append("Special", special)
            # ... easily add to another menu as submenu
        sub.append_submenu(subsub)

        another_sub = Menu("Another sub menu")
        another_sub.append("more action", nothing)
        # wait a second, we do not need that... we have `menu.finish()`!
        #another_sub.append("Back", menu)

        self.menu.append_submenu(sub)
        self.menu.append_submenu(another_sub)

        # create 'Exit'-entries automatically - nice to have this :-)
        # saves a lot of typing... :-)))
        self.menu.finish()

        # shake it!
        self.menu.run()
        
    def greetings(self):
        print("i send you greetings from within the game class")
        
    def newteam(self):
        nt = input("please enter name for new team \n:>")
        self.teams.append(nt)
        self.menu.append("manage team {}".format(nt), lambda: self.manage(nt))
        sub = Menu("submenu for team {}".format(nt))
        # sadly i can NOT use finish here, because finish was already used
        sub.append("Exit --> go back to main menu", self.menu)
        sub.append("Special", special)
        
        self.menu.append_submenu(sub)
        
     
    def killteam(self):
        kt = input("please enter name for team to delete \n:>")
        self.teams.remove(kt)
        self.menu.remove("manage team {}".format(kt))
        self.menu.remove("submenu for team {}".format(kt))
        
        
    def manage(self,teamname):
        print("You are such a manager of team {}! what a boss..".format(teamname))

if __name__ == "__main__":
    #main()
    g = Game()

########NEW FILE########
__FILENAME__ = slowgoblins022
"""part of http://ThePythonGameBook.com
source code: 

https://github.com/horstjens/ThePythonGameBook/blob/master/
python/goblins/slowgoblins020.py

TODO:    #class for teams
         
         
some code is based on the menudemo of  Christian Hausknecht, located at
https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus

and licensed under the gpl license. 

see https://github.com/Lysander/snippets/blob/master/Python/python-misc/simplemenus/submenu.py
for the original file 

for usage of operator.attrgetter, see:
http://wiki.python.org/moin/HowTo/Sorting/
"""
__license__ = 'gpl3' # see http://www.gnu.org/licenses/gpl.html'

import sys
import random
import operator 

class Goblin(object):
    """demo class, goblins only have a name attribute
    and a unique number (managed by a class attribute)"""
    number = 0 # class attribute
    
    def __init__(self, name="anonymous goblin", **kwargs):
        """creates a new goblin instance
        every attribute can be overwritten with an argument like      
        g = Goblin(attack = 33.2)
        this will overwrite the random self.attack attribute with 33.2
        """
        self.name = name
        self.attack = random.gauss(Game.attack, 2) # float values
        self.defense = random.gauss(Game.defense, 2)
        # always create an goblin with twice the "normal" hitpoints
        # to make him cost real money
        self.hitpoints = random.gauss(Game.hitpoints*2, 3) 
        self.fullhealth = self.hitpoints 
        self.defense_penalty = 0 # integer value
        self.sleep = False # boolean 
        #statistics
        self.damage_dealt = 0
        self.damage_received = 0
        self.victory = 0  # over all rounds
        self.streak = 0  # victories in this combat
        self.lastround = 0 # number of combatround whre goblin lost
        self.lost = 0
        self.fights = 0
        # overwrite attributes if keywords were passed as arguments
        for key in kwargs:
            self.__setattr__(key, kwargs[key])
        # but do not mess around with number
        self.number = Goblin.number # access class attribute
        Goblin.number += 1 # prepare class attribute for next goblin
        # calculate value based on averages described in class Config
        self.value = self.calculate_value()

    def prepare_for_fight(self):
        """reset attributes like hitpoints, loot etc for each battle"""
        self.restore_health() # restore full hitpoints
        self.fights += 1     
        self.damage_received = 0 # clear for this battle
        self.damage_dealt = 0
        self.streak = 0      # enemys knocked out in one battle
        self.lastround = 0   # fighting until this round (if >0)
        self.loot = 0        # gold plundered from fallen enemys
        
    def calculate_value(self):
        """calculates a 'value' of the goblin based on att, def and hp.
        Formula:
        1.) compare attack, defense and hitpoints with the average 
        values found in class Config.
        2.) take the difference between actual attribute and average
        3.) square the difference but keep the sign 
        4.) build a sum of those squared differences
        Effect should be that a few big differences from the "norm" cost 
        a lot more gold than many small differences"""
        diffs = (pts-cfg for pts, cfg in zip((self.attack, self.defense,
             self.hitpoints), (Game.attack, Game.defense, 
             Game.hitpoints)))
        return sum((1, -1)[diff < 0] * diff ** 2 for diff in diffs)
        
        
    def restore_health(self):
        """restore original hitpoints"""
        self.hitpoints = self.fullhealth 
        
    def report(self):
        """returns a string with all the actual stats"""
        text=""
        for stat in filter(lambda x: "__" not in x, dir(self)):
            if "bound method" in str(self.__getattribute__(stat)):
                continue # ignore methods, only take attributes
            #print(stat)
            attr = self.__getattribute__(stat)
            #testing if attribute is string or int or float
            if stat == "sleep":  # sleep is boolean
                text+= "\n{:>20}: {}".format(stat, attr)
            elif isinstance(attr, int) or isinstance(attr, float):
                text+= "\n{:>20}: {:5.1f}".format(stat, attr)
            else:
                text+= "\n{:>20}: {}".format(stat, attr)
        return text
    
    def __repr__(self):
        """overwriting the representation method of a goblin object"""
        return "{:>15} ({:>2}): {:6.2f} {:6.2f} {:6.2f} {:6.2f} {}".format(
            self.name, self.number, self.attack, self.defense, 
            self.hitpoints, self.value, self.sleep)

def generic_input(typ="int", prompt=">", default=0, minv=-9999999, maxv=9999999):
    """ask user and returns answer (of typ "int", "float", "text")"""
    while True:
        raw = input(prompt)
        if raw == "":
            return default
        if typ == "text":
            return raw
        try:
            if typ == "int":
                answer = int(raw)
                if minv <= answer <= maxv:
                    return answer
                else:
                    raise IndexError
            
            elif typ == "float":
                answer = float(raw)
                if minv <= answer <= maxv:
                    return answer
                else:
                    raise IndexError
        except (ValueError, IndexError):
            print("please enter numbers between {} and {}".format(
                   minv, maxv))
            if typ=="float" and not "." in raw:
                print("use decimal point")
                
def info():
    """demo method"""
    print("this is some information")

def buy_goblin(team_number):
    """create goblin instance and add it to team"""
    #check money
    if Config.gold[team_number] <= 0:
        print("Your team has no gold! Sell some goblins first")
        return
    new_name = generic_input(typ="text",prompt="nickname for new goblin?",
         default="unnamed goblin")
    g = Goblin(new_name)
    gnr = g.number
    Config.teams[team_number][gnr] = g          # add new goblin to team
    Config.gold[team_number]-=g.value           # deduct gold for buying
    key = "editgoblins{}".format(team_number)
    # add edit goblin menu entry
    Config.menu[key].append(["edit goblin {} ({})".format(new_name, gnr),
        lambda: edit_goblin(gnr, team_number)])
    print("You purchased {} for the team!".format(new_name))

def show_goblins(team_number):
    """print a list of all goblins in this team and the team gold
    also sum all stats (att, def, hitpoints, value) for the team"""
    print("{} team {} gold: {:6.2f} {}".format(20*"-",
        Config.team_names[team_number],Config.gold[team_number],20*"-"))
    print("{:>20}:   att   def     hp   value  sleep".format(
        "attribute"))
    print("{:>20}: {:6.2f} {:6.2f} {:6.2f}".format("normal", 
          Config.attack,Config.defense,Config.hitpoints))
    print("{:>20}{}".format("--goblin (unique nr)",46*"-"))
    sumatt, sumdef, sumhp, sumval, sumsleep = 0,0,0,0,0
    sortlist = []
    for (gnr, goblin) in Config.teams[team_number].items():
        sortlist.append(goblin)
    for goblin in sorted(sortlist, key=operator.attrgetter(
        Config.sortorder[0], Config.sortorder[1], Config.sortorder[2]),
        reverse = Config.reverse):
           print(goblin) # this calls self.__repr__ of Goblin instance
           sumatt += goblin.attack
           sumdef += goblin.defense
           sumhp  += goblin.hitpoints
           sumval += goblin.value
           sumsleep+=goblin.sleep # True count as 1, False as 0
    print(66*"=")
    print("{:>20}: {:6.2f} {:6.2f} {:6.2f} {:6.2f} {:>2}".format("sum",
        sumatt, sumdef, sumhp, sumval, sumsleep))
    print(66*"-")

def rename_team(team_number):
    """rename teamnames in the teamnamces dict and in the menu dict"""
    new_name = input("please enter new name for team number {}: ".format(
        team_number))
    if new_name == "":
        print("nothing renamed")
        return
    Config.team_names[team_number] = new_name
    # change the submenu
    key = "team{0}".format(team_number)
    Config.menu[key][0][0] = "exit menu of team {} (team {})".format(new_name,
        team_number)
    # root menu entry for team 0 is 1, entry for team 1 is 2 ....
    Config.menu["root"][team_number+1][0] = "manage team {} (team {})".format(
        new_name, team_number)

def edit_goblin(number, team_number):
    """let the user change attributes of an individual goblin
    need goblins unique number and team number"""  
    #get goblin
    if not number in Config.teams[team_number]:
        print("no goblin with this number is in your team")
        return
    goblin = Config.teams[team_number][number]
    print("current values for this goblin:", goblin.report())
    print("please enter the new (>0) values for name, att, def and hp:")
    namechange = False
    old_name = goblin.name
    for stat in ["name", "attack", "defense", "hitpoints"]:
       attr = goblin.__getattribute__(stat)
       old_value = attr
       print("old value (Enter to accept) for {} is: {}".format(
               stat , old_value))
       if isinstance(attr, float):
           new_value = generic_input("float","new value ?", old_value, old_value)
       elif isinstance(attr, int):
           new_value = generic_input("int","new value ?", old_value, old_value)
       elif isinstance(attr, str):
           new_value = generic_input("text","new value ?", old_value)
       else:
           print("unknown attribute error") # boolean ?
           raise ValueError
       if new_value == old_value:
           print("nothing changed")
           continue
       if stat == "name":
           goblin.name = new_value
           namechange = True
       else:
           
           # display gold cost before attribute change and let user confirm
           # new value is always bigger than old value
           norm = Config.__getattribute__(Config, stat)
           # signed(delta_new_norm_)squared - signed(delta_old_norm)squared 
           diffnew = new_value - norm # delta new norm
           diffold = old_value - norm # delta old norm
           pricenew = (1,-1)[diffnew<0] * diffnew ** 2
           priceold = (1,-1)[diffold<0] * diffold ** 2
           #if dnn >= 0:           
           #    sdnns = dnn**2     # signed delta new norm squared
           #else:
           #    sdnns = -1 * dnn**2
           #if don >= 0:
           #    sdons = don**2    # signed delta old norm squared
           #else:
           #    sdons = -1 * don**2 
           #price = sdnns - sdons
           price = pricenew - priceold
           print("This change would cost: {} gold".format(price))
           print("Your team has {} gold".format(Config.gold[team_number]))
           if price > Config.gold[team_number]:
               print("nothing changed, due to lack of gold")
               continue
           if generic_input("int","accept? 0=cancel, 1=yes",0,0,1) == 1:
               goblin.__setattr__(stat, new_value)
               print("changed {} from {} to {}".format(stat, old_value, 
                  new_value)) 
               Config.gold[team_number] -= price
           else:
               print("nothing changed because user canceled")
    # ---- end of for loop ----
    # if new name, change menu entry, search for old entry
    if namechange:
        new_name = goblin.name 
        key = "editgoblins{}".format(team_number)
        subkey = "edit goblin {} ({})".format(old_name, number)
        newkey = "edit goblin {} ({})".format(new_name, number)
        for entry in Config.menu[key]:
            if entry[0] == subkey:
                entry[0] = newkey
                break
        else:
            print("error.. i did not found the correct menu entry")
            
def sell_goblin(team_number):
    """ask user for goblins unique number and delete this goblin
       from team and delete corresponding edit goblin menu entry"""
    # create prompt
    p = "\n".join(("Each goblins has a unique goblin number. You can",
        "see this number using the 'show all goblins' menu",
        "it is the number in round parentheses",
        "unique number of goblin you want to sell ?"))
    print(p)
    # Goblin.number (class attribute) - 1 is the hightest possible 
    # number of a goblin. It does not mean that this goblin still exist
    delnumber = generic_input("int","(-1 is cancel) >", -1, -1, Goblin.number)
    if delnumber == -1:
        print("sell action canceled")
        return
    # check if this goblin exist in the selected team
    if not  delnumber in Config.teams[team_number]:
        print("No goblin with this number exist in your team")
        return
    d = Config.teams[team_number].pop(delnumber) # d is the deleted goblin
    Config.gold[team_number]+= d.value # add gold for selling goblin
    print("Goblin {} sold".format(d.name))
    #remove editmenu entrys
    key = "editgoblins{}".format(team_number)
    subkey = "edit goblin {} ({})".format(d.name, delnumber)
    for entry in Config.menu[key]:
        if entry[0] == subkey:
            Config.menu[key].remove([entry[0], entry[1]])
            break
    else:
        print("error.. i did not found the correct menu entry")

def toggle_sleep(team_number):
    """ask user for goblin number and toggle sleep status"""
     # create prompt
    p = "\n".join(("Each goblins has a unique goblin number. You can",
        "see this number using the 'show all goblins' menu",
        "it is the number in round parentheses",
        "unique number of goblin you want sleep/wake up ?"))
    print(p)
    sleepnumber = generic_input("int","(-1 is cancel) >", -1, -1, Goblin.number)
    if sleepnumber == -1:
        print("toggle sleep action canceled")
        return
    # check if this goblin exist in the selected team
    if not  sleepnumber in Config.teams[team_number]:
        print("No goblin with this number exist in your team")
        return
    g = Config.teams[team_number][sleepnumber]
    g.sleep = not g.sleep # toggle sleep
    print("Sleep status of Goblin {}({}) changed to {}".format(g.name,
        g.number, g.sleep))

def print_menu(menu):
    """print visible menu points. menu is the key in the giant menu
    dict so that the corresponding (sub) menu is printed-
    see original code and tutorial of Christian Hausknecht
    https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus
    """
    # start numbering the items with number 0 
    for index, item in enumerate(menu, 0): 
        print("{}  {}".format(index, item[0]))  
        
def handle_menu(menudef):
    """ print menu, ask for action, userinput, does action, print menu
    menudef is the menu structure ( giant dict )
    see original code and tutorial of Christian Hausknecht
    https://github.com/Lysander/snippets/tree/master/Python/python-misc/simplemenus
    """
    category = "root"
    while True:
        # Hint: 'menu' does not name the complete menu-structure (the dict)
        # but instead it just refenrences the entries for one dictionary-key.
        # And those we can call just 'menu'. Perhaps 'entries' would have been 
        # a better name, but that would have broken the parameter naming of
        # the tow other functions.
        menu = menudef[category]
        print_menu(menu)
        choice = generic_input("int",prompt="Your menu choice?", 
            default=0, minv=0, maxv=len(menu)-1)
        _, command = menu[choice]       # the _ is a name vor a variable
        # here is the 'submenu'-magic. Just change the dictionary key and go
        # on in the loop, so the chosen submenu will be handled.
        if isinstance(command, str):
            category = command
        else:
            command()

def sign(a, b):
    """compares a with b and returns a "<","=" or ">" sign """
    if a < b:
        return "<"
    elif a > b:
        return ">"
    else:
        return "="
            

def clear_logfile(filename = "combatlog.txt"):
    """overwrites the old combatlogfile with empty text"""
    try:
        with open('combatlog.txt', 'w') as logfile:
            logfile.write("---")
        print("combatlogfile cleared")
    except IOError:
        print("problems writing combatlog.txt")

def reroll(min_eyes, max_eyes, accu=0, depth=99):
    """a die that is allowed to re-roll when the max_eyes is thrown.
       return the sum of all throws minus 1 per max_eyes thrown.
       This allows very high results with a very small propability
       example:  6(=max eyes) + (reroll) 6 + 2 = (6-1)+(6-1)+2 =12
       see https://gist.github.com/yipyip/6205271 and
       tail-recursion for more information"""
       
    assert depth >= 0 # make sure that depth is not negative 
    
    result = random.randint(min_eyes, max_eyes)
    if result < max_eyes or depth == 0:
        return accu + result
    return reroll(min_eyes, max_eyes, accu + result - 1, depth - 1)
 

    
def strike(attacker, defender, combatround, counterstrike=False):
    """attacker strikes at defender. The function changes the new
    hitpoints of the defender and returns a text String with the 
    combat report.
    counterstrike (boolean) indicates that this is a counterattack 
    or not.
    Each counterstrike (=being attacked) increases the defense penalty
    by one
    """
    striketext = [] # a list of textlines !
    if counterstrike:
        t = "counterattack"
    else:
        t = "attack"
        
    rollAtt = reroll(1, 6) # allowed to re-roll if a 6 is thrown
    rollDef = reroll(1, 6)
    scoreA = attacker.attack + rollAtt
    scoreD = defender.defense + rollDef - defender.defense_penalty
    striketext.append("{} rolls {}, {} rolls {}".format(attacker.name,
        rollAtt, defender.name, rollDef))
    if scoreA > scoreD:   
        striketext.append("Sucessfull {0} !  ({1:.2f} > {2:.2f})".format(
            t, scoreA, scoreD))
        damage = scoreA - scoreD
        defender.hitpoints -= damage
        #statistics
        attacker.damage_dealt+= damage
        defender.damage_received+= damage 
        striketext.append("...doing {0:.2f} damage.".format(damage))
        if defender.hitpoints <= 0:
            attacker.victory += 1
            attacker.streak += 1
            defender.lost += 1
            defender.lastround  = combatround
            striketext.append("Victory for {}! {} goes down".format(
               attacker.name, defender.name))
            striketext.append("This is victory {} for {}".format(
                attacker.victory, attacker.name)+" ( {} had {} ".format(
                defender.name, defender.victory)+" before he got down)")
            striketext.append("{} wins {:.2f} gold for his team".format(
                attacker.name, defender.fullhealth * Config.loot))
            attacker.loot = defender.fullhealth * Config.loot
    else:
        striketext.append("The {0} failed... ({1:.2f} <= {2:.2f})".format(
            t, scoreA, scoreD))
    if counterstrike:
        attacker.defense_penalty += 1 # each counterstrike lowers defense
    return striketext

def combatround(a,b, number):
    """a round of combat between team a and team b. 
    Each non-sleeping, alive (hp>0) goblin can make one stike against
    another goblin of the enemy team.
    Each attacked goblin (if he survive the attack) makes an counterstrike
    against his attacker, and get his defensepenalty increased by 1
    The effect is that many attack against a single victim are more
    likely to suceed, but remain dangerous for the attacker"""
    # reset all defense_penaltys to 0
    text = [] # a list of lines !
    for team in [a,b]:
        for goblin in Config.teams[team].values():
            goblin.defense_penalty = 0
    # randomize goblin.number to process combat order
    # TODO: give each goblin speed and initiative attributes
    order = list(range(Goblin.number)) # list of all goblin numbers
    random.shuffle(order) # random ordering of those numbers
    for gnr in order:
        if gnr in Config.teams[a]:
            myteam = a
            enemyteam = b
        elif gnr in Config.teams[b]:
            myteam = b
            enemyteam = a
        else:
            continue # non-existing goblin ( sold? )
        attacker = Config.teams[myteam][gnr]
        if attacker.sleep or attacker.hitpoints <= 0:
            continue
        # search random victim
        victimlist = [x for x in Config.teams[enemyteam].values() if ((
           x.sleep == False ) and (x.hitpoints > 0))]
        if len(victimlist) == 0:
            continue 
        defender = random.choice(victimlist)
        text.append("--")
        text.append("{} (nr {}) of team {} strikes".format(
            attacker.name, attacker.number, Config.team_names[a]) +
            " {} (nr {})  of team {}".format(defender.name, 
            defender.number, Config.team_names[b]))
        text.append("{:<20}:  att    def      hp".format("  Strike!")+
            "    $  sleep def-penalty")
        text.append(str(attacker)+" {}".format(attacker.defense_penalty))
        text.append(str(defender)+" {}".format(defender.defense_penalty))
        text.extend(strike(attacker, defender, number, False))
        if defender.hitpoints > 0:
            text.append("  Counterstrike of {}!".format(defender.name))
            text.extend(strike(defender, attacker, number, True))
    return text
            
def fight(a=0,b=1):
    """let fight all non-sleeping, alive goblins in 2 teams versus
       each other until one team has no goblins left"""  
    text = ["The big battle between team {} and team {} starts:".format(
        Config.team_names[a], Config.team_names[b])]
    for team in [a,b]:
        for goblin in Config.teams[team].values():
            if not goblin.sleep:
               goblin.prepare_for_fight() # restore hitpoints to full etc
    battleround = 0
    while True:
        battleround += 1
        ateam = [x for x in Config.teams[a].values() if ((
           x.sleep == False ) and (x.hitpoints > 0))]
        bteam = [x for x in Config.teams[b].values() if ((
           x.sleep == False ) and (x.hitpoints > 0))]
        if len(ateam) > 0 and len(bteam) > 0:
            text.append("=======================")
            text.append("---Battle round {:>4} ---".format(battleround))
            text.append("alive: {} vs. {}".format(len(ateam), len(bteam)))
            text.append("--------------------------")
            text.extend(combatround(a,b, battleround))
        elif len(ateam)>0:
            text.append("========================")
            text.append("team {} is victorious".format(Config.team_names[a]))
            text.append("========================")
            break
        elif len(bteam)>0:
            text.append("========================")
            text.append("team {} is victorious".format(Config.team_names[b]))
            text.append("========================")
            break
        else:
            text.append("no victorous team ?")
            break
    # ---- battle over, print textlines
    text.append("=====--------- battle statistics -----------=====")
    lootsum = [0.0,0.0]
    for t in [a,b]:
        text.append("------ team {} ----".format(Config.team_names[t]))
        tl = [ x for x in Config.teams[t].values() if not x.sleep]
        text.append("{:>20}{:>7}{:>7}{:>7}{:>7}{:>7}".format(
          "Name:","dmg d", "dmg r", "lst r", "streak", "loot"))
        for goblin in tl:
            #text.append(str(goblin))
            text.append("{:>20}{:7.2f}{:7.2f}{:7.2f}{:7.2f}{:7.2f}".format(
                goblin.name, goblin.damage_dealt, goblin.damage_received, 
                goblin.lastround, goblin.streak, goblin.loot))
            lootsum[t] += goblin.loot
        text.append("===================================")
        text.append("team {} made a sum of {:.2f} gold in this battle".format(
            Config.team_names[t], lootsum[t]))
        Config.gold[t] += lootsum[t]
            
    for line in text:
        print(line)    
    try:
        with open('combatlog.txt', 'a') as logfile:
            for line in text:
                logfile.write(line + "\n")
        print("combat log appended into file 'combatlog.txt'")
    except IOError:
        print("problem writing into file combatlog.txt")
            
# funcitons for sorting
def display_sortorder():
    print("the current sortorder is:")
    print(Config.sortorder)
    print("reverse: ", Config.reverse)

def toggle_reverse():
    Config.reverse = not Config.reverse
    print("changed reverse to ", Config.reverse)
    
def sort(rank):
    """ask the user for a keyword and manipulates Config.sortorder"""
    valid = ["attack", "defense", "hitpoints", "value", "name", "sleep"]
    print("The keyword for sorting must be one of those words:")
    print(valid)
    print("(without the brackets, quotes and commas)")
    answer = input("please enter the attribute for sorting:>")
    if not answer in valid:
        print("sorry this was not a valid answer. nothing changed")
        return
    old = Config.sortorder[rank]
    Config.sortorder[rank] = answer
    print("changed sortorder for rank {} from {} to {}".format(rank,
        old, answer))

class Team(object):
    """class that hold all team-related attributes"""
    number = 0 # team counter (class variable)
    
    def __init__(self, name="?"):
        """create new team"""
        self.number = Team.number
        Team.number += 1
        if name == "?" or name == "":
            self.name = "team"
        else:
            self.name = name 
        self.menukey = "team{}".format(self.number) # team1, team2...
        self.name = "{} ({})".format(self.name, self.number)
        self.gold = 500 # start gold to buy goblins
        self.won = 0    # number of battles won for this team
        self.lost = 0   # number of battles lost for this team
        self.members = {} # { number : goblin instance, ... }
    
    def addmenu(self):
        """return new menuppoints for this team"""
        return  {self.menukey: [
                    ["Exit menu of {}".format(self.name), "root"],
                    ["show all goblins", lambda: show_goblins(self.number)],
                    ["buy goblin", lambda: buy_goblin(self.number)],
                    ["rename team", lambda: rename_team(self.number)], 
                    ["edit goblins", "editgoblins1"],
                    ["sell goblin (number)", lambda: sell_goblin(self.number)],
                    ["toggle sleep for goblin (number)", 
                        lambda: toggle_sleep(self.number)],
                    ["Change sort order", "sortorder"] ], 
                "editgoblins{}".format(self.number): [
                    ["Exit the edit goblins menu", self.menukey] ] }
        
    
    def __repr__(self):
        return "team: {} has {} gold, has won {} and lost {} battles.".format(
            self.name, self.gold, self.won, self.lost)
            


class Game(object):
    """an instance of this class is one playable Game"""
    #some class attributes, formerly in Config
    hitpoints = 10 # it's twice that number in reality to make goblins expensive
    attack = 10
    defense = 10
    loot = 1 # 1 gold per hitpoint of  knocked out enemy
    sortorder = ["attack","defense","hitpoints","value"]
    reverse = False
    
    def __init__(self):
        self.teams = {} # {team number:team instance, ...} a dict of team objects   
        self.menu = {"root": [
                        ["exit the main menu", lambda: sys.exit(0)],
                        ["create new team", "createteam"],
                        ["delete team", "deleteteam"],
                        ["compare teams", lambda: compare_teams(0,1) ],
                        ["fight team vs team", fight],
                        ["clear combatlog.txt", clear_logfile],
                        ["show info", info]  ], 
                     "sortorder": [
                        ["Exit the sortorder menu", "root"],
                        ["display sort order", display_sortorder],  
                        ["toogle reverse sorting", toggle_reverse],
                        ["edit first sort key", lambda: sort(0)],
                        ["edit second sort key", lambda: sort(1)],
                        ["edit third sort key", lambda: sort(2)],
                        ["edit fourth sort key", lambda: sort(3)]  ],
                    "deleteteam": [
                        ["Exit the deleteteam menu", "root"] ],
                    "createteam": [
                        ["Exit the createteam menu", "root"] ] }
        # initialise the game
        t0 =Team("Alpha")
        t1 =Team("Bravo")
        gob0 = Goblin("Stinky")
        gob1 = Goblin("Grunty")
        t0.members[gob0.number] = gob0 # Stinky joins team0
        t1.members[gob1.number] = gob1 # Grunty joins team1
        # adjust the gold for each team to reflect buying the first goblin
        t0.gold -= gob0.value
        t1.gold -= gob1.value
        # start the menu, start the game
        #g = Game()
        self.teams[t0.number] = t0  # add teams into game instance
        self.teams[t1.number] = t1
        self.menu.update(t0.addmenu())
        self.menu.update(t1.addmenu())
        
    
        handle_menu(self.menu)    
    
    def ask_team_numbers(self):
        """ask for two existing team numbers ( for compare teams, battle ...)"""
        if len(self.teams)==0:
            print("Please create two teams using the main menu first")
            return -1,-1
        txt1 = "Please enter first team number (-1 = Cancel)"
        txt2 = "Please enter second team number (-1 = Cancel)"
        first = generic_input("int", txt1, -1, -1, max(self.teams))
        if not first in self.teams:
            print("This team number does not exist")
            return -1,-1 
        if first != -1:
            second = generic_input("int", txt2, -1, -1, max(self.teams))
        if not second in self.teams:
            print("This team number does not exit")
            return -1,-1
        if first == second:
            print("You entered twice the same team number")
            return -1,-1
        return first, second

    def compare_teams(self):
        a, b = self.ask_team_numbers()
        if a ==-1 or b ==-1:
            print("no valid team numbers entered")
            return   
        """printing comparasion table for two teams"""
        print("-----------------------------")
        print("comparing team {} ({}) with team {} ({})".format(
            Config.team_names[a],a,Config.team_names[b],b))
        print("{:>20}: {:6.1f}   {} {:6.1f}".format("gold", Config.gold[a], 
            sign(Config.gold[a],Config.gold[b]), Config.gold[b]))
        print("{:>20}: {:6.1f}   {} {:6.1f}".format("goblins", 
            len(Config.teams[a]), sign(len(Config.teams[a]),
            len(Config.teams[b])), len(Config.teams[b])))

        for stat in ["attack", "defense", "hitpoints", "value", "sleep",
            "victory", "lost", "fights", "damage_received", "damage_dealt"]:
            statsum={a:0, b:0}
            for x in [a,b]:
                for (gbnr, goblin) in Config.teams[x].items():
                    statsum[x] += goblin.__getattribute__(stat)
            print("{:>20}: {:6.1f}   {} {:6.1f}".format(stat, statsum[a], sign(statsum[a],
                statsum[b]), statsum[b]))
# combat


if __name__ == "__main__":
    #main()
    g=Game()

########NEW FILE########
__FILENAME__ = submenutest
#!/usr/bin/env python

#
#  Copyright (C) 2012  Christian Hausknecht
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""
    ~~~~~~~~~~
    submenu.py
    ~~~~~~~~~~

    More advanced approach compared to `simplemenu.py` as this module provides
    an approach to implement a generic, but easy to use menu system that
    supports submenus!
    
    Still it is realized only with basic Python data types.
    
    Each menu consists of this dictionary structure:
    
        {
            "root": (
                ("text to be shown", <function object>),
                ("another item text", <another function object>),
                (..., ...),
                
                or
                
                ("text", "submenu1"),
                (<string>, <string of key to submenu>)
            ),
            "submenu1": (
                (<string>, <function object>),
                ...
            ),
            ...
        }
        
    Every menu must habe a 'root' key. That is the entrypoint for the
    `handle_menu` function. To make an entry that leads to a submenu, just
    put the key of that submenu as second parameter of one menu item. This
    way you can also 'go back' from a submenu to the 'root'-menu.
        
    To be more generic, each 'callable' can be used as second argument.
    
    The user can choose via an computed index, which action should be
    triggered by the core function `handle_menu`.
    
    Hint: Both functions `print_menu` ans `get_user_input` are exactly the
    same as in the `simplemenu`-module. We could have easily imported them,
    but I wanted to make this work out of the box.

    This is esspecially written for beginners, so there is no magic like
    `functools.partial` or some closures to create demo functions.

    .. moduleauthor:: Christian Hausknecht <christian.hausknecht@gmx.de>
"""

import sys

#
# Some little demo functions that does not have any sensfull functionality
#

def hello():
    print("Hallo Welt!")

    
def python():
    print("Python rocks!")


def special():
    print("Wow! So special we must put it into a submenu...")


#
# Functions for our simple menu system
#
    
def print_menu(menu):
    """
    Function that prints our menu items. It adds an numeric index to each
    item in order to make that the choosebale index for the user.
    
    :param menu: tuple with menu definition
    """
    for index, item in enumerate(menu, 1):
        print("{}  {}".format(index, item[0]))

        
def get_user_input(menu):
    """
    This function implements a simple user input with validation. As the
    input data should match with existing menu items, we check, if the value
    is valid.

    :param menu: tuple with menu definition
    
    :returns: int
    """
    while True:
        try:
            choice = int(input("Ihre Wahl?: ")) - 1
            if 0 <= choice < len(menu):
                return choice
            else:
                raise IndexError
        except (ValueError, IndexError):
            print("Bitte nur Zahlen aus dem Bereich 1 - {} eingeben".format(
                                                                    len(menu)))

   
def handle_menu(menudef):
    """
    Core function of our menu system. It handles the complete process of
    printing the menu, getting the user input and calling the corresponding
    function.
    
    We recognize if a 'submenu' is called by comparing the type of the second
    parameter of our entry item. If that is a string, we interpret that as the
    key of a corresponding 'menu' and make that the current menu to operate on.
    
    :param menudef: dict with menu definition
    """
    category = "root"
    while True:
        # Hint: 'menu' does not name the complete menu-structure (the dict)
        # but instead it just refenrences the entries for one dictionary-key.
        # And those we can call just 'menu'. Perhaps 'entries' would have been 
        # a better name, but that would have broken the parameter naming of
        # the tow other functions.
        menu = menudef[category]
        print_menu(menu)
        choice = get_user_input(menu)
        _, command = menu[choice]
        # here is the 'submenu'-magic. Just change the dictionary key and go
        # on in the loop, so the chosen submenu will be handled.
        if isinstance(command, str):
            category = command
        else:
            command()


def main():
    # just some demonstration menu structure. We have two menus, the 'root'
    # menu and one submenu called 'submenu'. As second option in the 'submenu'
    # we can leave the menu back to the 'root'-menu.
    menu = {
        "root": (
            ("Hallo", hello),
            ("Python", python),
            ("Submenu", "submenu"),
            ("Exit", lambda: sys.exit(0))
        ),
        "submenu": (
            ("Spezial", special),
            ("Zurück", "root"),
        )
    }
    
    # make it so! :-)
    handle_menu(menu)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = items
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       items.py
#       
#       Copyright 2011 Horst JENS <horst.jens@spielend-programmieren.at>
#       
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.


class Item(object):
    book = {} # a dictionary to store all items and with its numbers
    number = 0
    def __init__(self, name=""):
        if name == "":
            name = "the not yet named thing"
        self.name = name
        self.number = Item.number # unique number
        Item.number += 1          # prepare next unique number
        Item.book[self.number] = self # store yourself in the book
        self.percent = 100.0      # float 100.0 means perfect, 0.0 means useless
        self.weight = 0.0         # weight in kg
        self.goldvalue = 0        # how much would this item cost in a shop
        self.category = "misc"    # 
        print "item number %i with the name %s is created" % (self.number, self.name)
        
    def inspect(self):
        print "--------------"
        print "inspecting item %i , named %s" % (self.number, self.name)
        print "this is a: %s " % self.__class__.__name__ 
        for key in self.__dict__:
            print key, " : ", self.__dict__[key]
        print "--------------"
        
class Sword(Item):
    def __init__(self, name=""):
        Item.__init__(self, name) # call the parent __init__ function
        self.category = "weapon"
        self.attackBonus = 2
        self.defenseBonus = 2
        self.damageBonus = 4
        #self.armorBonus = 0
        self.length = 1.0   # weapon length in meter
        self.weight = 3     # kg
        
class Shield(Item):
    def __init__(self, name=""):
        Item.__init__(self, name)  # call the parent __init__ function
        self.category = "shield"
        self.attackBonus = -1
        self.defenseBonus = 3
        self.damageBonus = 0
        self.armorBonus = 7
        self.weight = 5   # kg
        self.coverpercent = 40.0
        
        

        
        
        


def main():
    # hier gehts los    
    Item("lucky charm")
    temp = Sword("Ice")
    temp.attackBonus = 15
    temp = Shield("old oak shield")
    temp.coverpercent = 70.7
    for x in Item.book.keys():
        Item.book[x].inspect()
    return 0

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = littleAdventure
#This game is part of The Python-Game-Book
# TODO: equipped weapon for monster does not affect combat stat ?
# TODO: seperate IO from other code 
# TODO: detect empty list_items for use, drop, equip etc
# TODO: give monster armor and weapons
# TODO: encumberance or cancel fight after 100 rounds
# TODO: cancel for every menu
# TODO: create random armors and weapons
# TODO: monsters corpses spawn loot
# TODO: history of slain enemys ( room 0?)
# TODO: game won condition
# TODO: monsters can pick up/drop weapons
# TODO: armor and weapons can shatter

import random
import sys
#import logging

if sys.version_info[0] < 3:
    print("this script need python3. You are using python 2 or lower.")
    sys.exit()

#logging.basicConfig(filename='horst.log',level=logging.DEBUG)
    
class Game(object):
    """
    holds all information for a game. Later it may be
    possible to load / save different games
    """
    number = 0

    def __init__(self):
        self.number = Game.number
        Game.number += 1
        self.rooms = {} # dictionary of rooms, key is room number
        self.items = {} # dictionary of items, key is item number
        self.monsters = {} # dictionary of monsters, key is monster number
        self.players = [] # dictionary of players, key is player number, value = monsternumber
        self.effects = {} # dictionary of effects (for items), key is effect name



class Monster(object):
    number = 1 # number 1 should be reserved for player

    def __init__(self, game, where= 0, adjective="", description="",
         boss=False, carrier=False):
        self.number = Monster.number
        Monster.number += 1
        game.monsters[self.number] = self # add monster into game dict
        self.adjective = adjective
        self.location = where # room number
        self.description = description
        self.hitpoints = random.randint(5,15)
        self.player = False
        self.carrier = carrier # can carry items ?
        self.attack = 10 + random.randint(-2,2)
        self.defense = 10 + random.randint(-2,2)
        self.speed = 10 + random.randint(-2,2)
        self.damage = 3 + random.randint(-2,2)
        self.armor = 3 + random.randint(-2,2)
        self.agressive = False
        self.slots = {"head":1, "body":1, "hand":2, "finger":2,
                      "neck":1, "feet":2} # only one magic ring per ring-finger
        if description == "":
            if boss:
                self.adjective = random.choice(("deadly","fantastic",
                        "creepy","ugly","epic"))
                self.description = random.choice(("dragon","cave drake",
                        "sea serpent","gorgon","giant beetle","arch druid"))
                self.hitpoints *= 5
                self.attack += random.randint(2,7)
                self.defense += random.randint(2,7)
                self.speed += random.randint(2,7)
            else:
                self.adjective = random.choice(("weak","boring",
                        "tired","cheap","old"))
                self.description = random.choice(("goblin","ork","troll",
                    "mice","rat","dwarf","spider"))

    def info(self):
        txt = "Monster number {}: {} {} with {} hitpoints\n".format(
            self.number, self.adjective, self.description, self.hitpoints)
        if self.carrier:
            txt += "This monster can carry items\n"
        return txt
        
    def inspect(self, game):
        return "{}\n{:2}\n{:2}\n{:2}\n{:2}\n{:2}".format(self.description,
            self.hitpoints, self.attack, self.defense, self.speed, 
            self.damage, self.armor)

    def list_items(self, game, active_only=False, wearable_only=False,
                   passive_only = False, magic_only = False):
        return []  #TODO: give monsters armor and weapons

    def leftcol(self):
        #return "name      \nhitpoints \nattack    \ndefense   \nspeed     \ndamage    \narmor     \n"
        return "\n\n\n\n\n\n\n"

    def calculate_values(self, game):
        """calculate all bonus and malus from equipped weapons and armors toward combat stats.
        returns dict with combat values"""
        values = {"attack":self.attack, "defense":self.defense,
                  "speed":self.speed, "damage":self.damage,
                  "armor":self.armor }
        items = self.list_items(game, True, True, False, False)
        for i in items:
                values["attack"] += game.items[i].attackbonus
                values["defense"]+= game.items[i].defensebonus
                values["speed"]+= game.items[i].speedbonus
                values["damage"]+= game.items[i].damagebonus
                values["armor"]+= game.items[i].armorbonus
        return values
              

class Player(Monster):
    #playernumber = 1
    def __init__(self, game, where=0, name="hero"):
        """need game instance. 
        """
        Monster.__init__(self, game, where, carrier = True)
        game.players.append(self.number) # add my monsternumber to game.players
        self.playerindex = len(game.players) - 1 
        self.name = name
        self.player = True
        self.description = "player" # overwrite monster
        self.adjective = "human"                     # overwrite monster
        #self.inventory = [] # list of itemnumbers (player carry items)
        self.maxcarry = 35 # kg
        self.carry = 0 # current mass of all carried items in kg
        self.damage += random.randint(1,5)
        self.armor += random.randint(1,5)
        self.speed += random.randint(1,5)
        self.weapon = None
        #self.armor = None
        #self.loaction = where # start room number

    def show_inventory(self, game, itemnumberlist):
        
        txt = ""
        txt += "\n==== Your inventory ====\n"        
        for itemnumber in itemnumberlist:
            i = game.items[itemnumber]
        
            if not game.items[itemnumber].active:
                e = "rucksack"
            else:
                e = "(equipped)"
            txt+="{}...{}...{} kg {}\n".format(itemnumber,
                 game.items[itemnumber].description,
                 game.items[itemnumber].mass, e)
        
        txt += "You're currently carrying {:.2f} kg, that is {:.2f}% of your capacity".format(
            self.carry, (self.carry / self.maxcarry)*100)
        return txt  

    def list_items(self, game, active_only, wearable_only,
                   passive_only, magic_only):
        """returns list of itemnumber
        of the items in the inventory of the player"""
        txt = ""
        items = []
        for itemnumber in game.items:
            i = game.items[itemnumber]
            if i.location == - self.number :
                if active_only and not i.active:
                    continue 
                if passive_only and i.active:
                    continue
                if magic_only and not i.is_magic:
                    continue
                if wearable_only and not i.is_weapon and not i.is_armor:
                    continue
                items.append(itemnumber)
                #txt += game.items[itemnumber].description
        return items
        
  

    def pickup_item(self, game):
        txt, items = game.rooms[self.location].list_items(game)
        if len(items) >0:
            output("please select item number to pick up\n")
            output(txt)
            i = select_number(items)
            m = game.items[i].mass 
            if m > self.maxcarry:
                return "You fail to pick up this item. Reason: You can only carry {} kg. \n and try to pick up {} kg. Become stronger and try again!".format(self.maxcarry,m)
            elif m + self.carry > self.maxcarry:
                return "You fail to pick up this item. Reason: You already carry {} kg. Picking up {} would exceed your max. carry capacity of {} kg. Drop some items first or become stronger!".format(self.carry, m, self.maxcarry)
            else:
                game.items[i].location = - self.number # negative monster number
                self.carry += m
                return "You now carry items for a total weight of {} kg".format(self.carry)
            
        else: 
            return "this room has no items so there is nothing to pick up\n"

    def drop_item(self, game):
        items = self.list_items(game, False, False, False, False) # do not drop equipped items
        if len(items)>0:
            output(self.show_inventory(game, self.list_items(game, False, False, False, False)))
            output("select itemnumber to drop\n")
            i = select_number(items)
            if game.items[i].never_drop:
                return "you can not drop this item, sorry! Try another item"
            game.items[i].location = self.location # drop item in my room
            self.carry -= game.items[i].mass  # update player
            return "you drop the {} to the floor\n".format(game.items[i].description)
        else:
            return "you carry no items so you can drop nothing\n"           
            
   
    def use_item(self, game):
        """launch effect of magic item (must be in inventory)"""
        items = self.list_items(game, False, False, False, True)
        if len(items)>0:
            output(self.show_inventory(game, self.list_items(game, False, False, False, True)))
            output("select itemnumber to use/equip\n")
            i = select_number(items)
            if game.items[i].effect == None:
                return "this item has no effect/is not equippable"
            txt = ""
            game.items[i].charges -= 1
            if game.items[i].charges == 0:
                # destroy item (move to room 0)
                game.items[i].location = 0
                txt += "while using the effect, the item has destroyed itself\n"
            txt += game.effects[game.items[i].effect].action(game, victim=self.number)
            return txt
        else:
            return "you carry no magic items so you can use nothing"

    def inspect(self, game):
        """all you ever wanted to know about yourself, but was too afraid to ask"""
        txt = ""
        weapontext = ""
        armortext = ""
        items = self.list_items(game, True, False, False, False)
        for i in items:
            if game.items[i].is_weapon:
                weapontext+=game.items[i].description + " and "
            elif game.items[i].is_armor:
                armortext+=game.items[i].description + ", "
        if weapontext == "":
            weapontext = "no weapon"
        else:
           weapontext = weapontext[:-5] # remove last 5 chars
        if armortext == "":
            armortext = "no armor"
        else:
            armortext = armortext[:-2] # remove last 2 chars
        txt+="you are a {} with {} hitpoints wielding ".format(
              self.description, self.hitpoints)
        txt +="{} and wearing: {}\n".format(weapontext, armortext)
        attr = self.calculate_values(game).keys()
        #left = self.leftcol().splitlines()
        #right = self.inspect().splitlines()
        v = self.calculate_values(game)
        total = v.values()
        base = []
        for k in attr:
            base.append(self.__getattribute__(k))
        both = zip(attr, base, total)
        txt+="  attribute base  eqip   tmp.effect    total\n"
        for pair in both:
            txt+="{:>10}: {:>2}   {:>2}                    {:>2}\n".format(pair[0],pair[1], pair[2]-pair[1],pair[2])
        return txt
        
    def equip(self, game):
        """ask user of itemnumber to wear/wield/remove"""
        items = self.list_items(game, False, True, False, False)
        txt = "Please select number of item to wield/wear/equip.\n If item is already equipped, it will be put back in the inventory\n"
        for itemnumber in items:
            i = game.items[itemnumber]
            if i.active: 
                d = "currently equipped"
            else:
                d = "in inventory"
            txt += "{}.....{}....({})\n".format(i.number, i.description,d)
        output(txt)
        select = select_number(items)
        i = game.items[select]
        i.active = not i.active # toggle active status
        if i.active:
            output("You wield/wear {}".format(i.description))
        else:
            output("You moved {} into your inventory".format(i.description))
        
        
        
  
    def nextAction(self, game):
        """ask the user to select only one of many options"""
        output("please select your next action:")
        cd = game.rooms[self.location].connectiondict(game) #cd = connectiondict
        txt = ""
        for roomnumber in cd:
            txt+= "{:2}........goto {}\n".format(roomnumber, cd[roomnumber])
        txt += "i,s,m,r...inspect (i)nventory/(s)elf/(m)onsters/(r)oom\nd,p.......(d)rop/(p)ick up item\n"
        txt += "e.........(e)quip/remove armor or weapon\n"
        txt += "u.........(u)se magic item\n"
        txt += "f.........(f)ight monsters\n"
        txt += "please type number/char and press ENTER or q and ENTER to (q)uit\n"
        # generate valid answerlist:
        chars = ("i","d","p","u","f","s","q","m","r","e")
        answers = []
        for roomnumber in cd:
            answers.append(str(roomnumber))
        answers.extend(chars)
        output(txt)
        answer = select_answer(answers)
        if not answer in chars:
            # room change
            # automatic damage if there is still a monster
            txt = ""
            for monster in game.rooms[self.location].local_monsters(game, self.number):
                txt += "While you {} like a coward, {} attacks you from behind for double damage !\n".format("flee" if self.hitpoints > 0 else "die", monster.description)
                damage = monster.damage * 2
                txt += "You loose {} hitpoints! ({} hitpoints left) \n".format(damage, self.hitpoints - damage)
                self.hitpoints -= damage
                if self.hitpoints < 1:
                    txt += "You are dead!! \n"
            if txt != "":
                output(txt)
            self.location = int(answer)
        elif answer =="q":
            #sys.exit()
            self.location = 0 # teleport player out of game
        elif answer =="i":
            output(self.show_inventory(game, self.list_items(game, False, False, False, False)))
        elif answer == "e":
            self.equip(game) # output inside equip function
        elif answer == "r":
            output(game.rooms[self.location].info(game,short=False))
        elif answer == "d":
            output(self.drop_item(game))
        elif answer == "p":
            output(self.pickup_item(game))
        elif answer == "u":
            output(self.use_item(game))
        elif answer == "s":
            output(self.inspect(game))
        elif answer == "m":
            for monster in game.monsters.values(): # iterate directly over all monsters
                if monster.location == self.location and monster.number != self.number:
                     left = self.leftcol().splitlines()
                     middle = self.inspect(game).splitlines()
                     right = monster.inspect(game).splitlines()
                     total = zip(left, middle, right)
                     for t in total:
                         output(t[0]+": "+t[1]+"  vs.  "+t[2])
        elif answer == "f":
            output("you fight one of the monsters in this room !")
            #for monsternumber in [monsternumber for monsternumber in game.monsters if game.monsters[monsternumber].location == self.location]:
            txt = ""
            for monster in game.monsters.values():
                if monster.location == self.location:
                    if self.hitpoints > 0 and monster.number != self.number:
                        txt += "---- combat versus {} ----\n".format(monster.description)
                        txt += combat(game, self, monster)
                        if self.hitpoints > 0:
                            txt += "====== Victory !!! ========"
                            monster.location = 0 # move deat monster in the void
                            # todo: loot
                            # create item: corpse
                            Item(g,self.location, "corpse of killed monster", 70 )
                            break
                        else:
                            txt += "----==== you loose ====----"
                            break
            else:
                txt += "there are no (more) monsters to fight in this room"
            output(txt)
        
class Item(object):
    number = 1

    def __init__(self, game, where=0, description="", mass=-1,
                 effect=None, charges =1 ):
        """need game instance. primary key of all items is the unique
        item number, so that you can have several items with the same
        name"""
        self.number = Item.number
        Item.number += 1
        game.items[self.number] = self # add item into game dict
        self.effect = effect
        if self.effect:
            self.is_magic = True
        else:
            self.is_magic = False
        self.charges = charges # how many times you can use this effect before item is destroyed
        self.location = where # positive values are room number,
                              # negative values refer to monster(!) number possesing this item
        self.description=description
        self.active = False  # is item currently worn or equipped by someone ?
        self.is_weapon = False  
        self.is_armor = False
        self.never_drop = False # forbid to drop this item
        if mass == -1:
            self.mass = round(random.randint(1,30))
        else:
            self.mass = mass
        if self.description == "":
            self.description = random.choice(("small healing potion","medium healing potion",
                    "gold","paper","towel","restaurant bill", "teleport pill", "piece of junk"))
            if self.description == "medium healing potion":
                self.effect = "heal5"
                self.is_magic = True
            elif self.description == "medium healing potion":
                self.effect = "heal10"
                self.is_magic = True
            elif self.description == "teleport pill":
                self.effect = "randomteleport"
                self.is_magic = True

 
    def info(self, game):
        txt =  "Item Number {}: ".format(self.number)
        txt += self.description + "\n"
        #if self.location >= 0:
        #   #txt +="\n current location: room {}, {}".format(self.location, game.rooms[self.location].description) 
        #else:
        #    txt += "\n currently carried by {}".format(game.monsters[self.location*-1].description)
        #return txt

class Weapon(Item):
    def __init__(self, game, where=0, description="", mass=-1,
                 effect=None, charges =1, oneHand=True,
                 twoHand=False, length = 0.1, attackbonus = 0,
                 defensebonus = 0, damagebonus = 0, speedbonus = 0,
                 armorbonus = 0, quality = .5):
        Item.__init__(self, game, where, description, mass,
                 effect, charges)
        self.is_weapon = True  # overwrite value False from Item.__init__
        self.one_hand = oneHand
        self.two_hand = twoHand
        self.length = length # lenght of melee weapon in meter
        self.attackbonus = attackbonus
        self.defensebonus = defensebonus
        self.damagebonus = damagebonus
        self.speedbonus = speedbonus
        self.armorbonus = armorbonus
        self.quality = quality
        
    def unequip(self, game, who):
        """un-wield a weapon and put it back in the inventory"""
        pass
        
    def equip(self, game, who):
        """wield a weapon. un-wield previous selected weapon"""
        pass
        
class Armor(Item): 
    def __init__(self, game, where=0, description="", mass=-1,
                 effect=None, charges =1,  
                 encumberance=0, attackbonus = 0, defensebonus = 0,
                 damagebonus = 0, speedbonus = 0, armorbonus = 0,
                 slot="body", quality = 0.5):
        Item.__init__(self, game, where, description, mass,
                 effect, charges)        
        self.slot = slot
        self.is_armor = True
        self.encumberance = encumberance
        self.attackbonus = attackbonus
        self.defensebonus = defensebonus
        self.damagebonus = damagebonus
        self.speedbonus = speedbonus
        self.armorbonus = armorbonus
        self.quality = quality
        
        
    def unequip(self, game, who):
        """remove armor and put it back in inventory"""
        pass
        
    def equip(self, game, who):
        """wear armor. remove any previous armor in this armor slot and 
        put it back in inventory"""
        pass
        



class Effect(object):
    """generic instant " magic" effect for items like key (connection between rooms, 
       teleport effect, gain healt effect etc."""
    def __init__(self, game, name, function, description="",  
                 arg1=0, arg2=0, success=.5):
        #victim 0 means the effect is targeted at the player (monsternumber 0)
        self.name = name
        self.function = function
        self.description = description
        self.success = success # probability .5 means it has a chance of 50% to work correct
        #self.victim = victim # if the effect is aimed at somebody
        # -1 means the effect is targeted at the first player
        #self.roomnumber=roomnunmber # if the effect is in a certain room only
        self.arg1 = arg1  # reserve
        self.arg2 = arg2  # reserve
        self
        game.effects[self.name] = self
        
    def action(self, game, victim=-1):
        """gives effect to monster with monsternumber == victim"""
        # successchance 
        luck = random.random() # TODO: add players evocation ability here
        if luck > self.success:
            return "Item FAIL ! bad luck, the item/effect refuses to work. try again ?" 
        if self.function == "teleport":
            if self.arg1 != 0:
                # teleport into specific room number
                target = self.arg1
            else:
                # random teleport
                while True:
                    target = random.choice(list(game.rooms.keys()))
                    if target != 0:  # anywhere but the void room
                        break
            game.monsters[victim].location = target
            return "the teleport effect works ! Victim is transported by magic into room number {}".format(target)
        elif self.function == "heal":
            game.monsters[victim].hitpoints += self.arg1
            return "healing effect works! gained {} hitpoints".format(self.arg1)
        elif self.function == "key":
            # right key, wrong room ? 
            if game.monsters[victim].location != self.arg1:
                return "you can not find a lock to use with this key here. maybe in another room ?"
            game.rooms[self.arg1].connections.append(self.arg2)
            return "you open a formerly closed door!"
        elif self.function == "carry":
            game.monsters[victim].maxcarry += self.arg1
            return "you can now carry {} kg. more!".format(self.arg1)
        else:
            return "unknow effect worked correctly"
           


class Room(object):
    number = 0

    def __init__(self, game, name="", description="", connections=[],
                 explored=False, itemchances=[0.5,0.25,0.1],
                 monsterchances=[0.3,0.2,0.1,0.05],
                 bosschances=[0.0], hint="" ):
        """need game instance"""
        self.number = Room.number # void room has number 0
        game.rooms[self.number] = self # add room into game dict
        Room.number += 1
        self.explored = explored # True or False
        self.name = name
        self.hint = hint # description of room if still unexplored
        self.description = description
        self.connections = connections
        self.itemchances = itemchances
        self.monsterchances = monsterchances
        self.bosschances = bosschances
     
        # create items
        for chance in self.itemchances:  
            if random.random()< chance:
                newItem = Item(game, self.number) # create item in this room

        # create monsters
        for chance in self.monsterchances:
            if random.random() < chance:
                newMonster = Monster(game, self.number) # create monster in this room
        # create boss(es)
        for chance in self.bosschances:
            if random.random() < chance:
                newMonster = Monster(game, self.number, boss=True)

                
    def inspect_monsters(self, game, playermonsternumber):
        monstercounter = 0
        txt = ""
        player = game.monsters[playermonsternumber]
        for monster in game.monsters.values(): # iterate directly over all monsters
            if monster.location == self.number and monster.number != playermonsternumber: # each monster in this room but not the player himself
                 monstercounter += 1
                 left = player.leftcol().splitlines()
                 middle = player.inspect(game).splitlines()
                 right = monster.inspect(game).splitlines()
                 total = zip(left, middle, right)
                 for t in total:
                     txt+=t[0]+": "+t[1]+"  vs.  "+t[2]+"\n"
        if monstercounter == 0:
            return "There are no monsters in this room"
        else:
            return txt
    
    def local_monsters(self, game, playermonsternumber):
        monsters = []
        for monster in game.monsters.values(): # iterate directly over all monsters
            if monster.location == self.number and monster.number != playermonsternumber:
                monsters.append(monster)
        return monsters 



    def list_items(self, game):
        """return string with itemnumbers and item description 
        as well as list of itemnumbers"""
        txt = "items in this room:\n"
        items = []
        for itemnumber in game.items:
            if game.items[itemnumber].location == self.number:
                txt +=  "{}....{}\n".format(itemnumber, 
                     game.items[itemnumber].description)
                items.append(itemnumber)
        return txt, items
        
    def connectiondict(self, game):
        """returns a dict with connections from this room.
        key is room number, value is room description (or "unknown",
        depending if the room is yet bo be explored"""
        namesdict = {} # temp list of room names
        for c in self.connections:
            if game.rooms[c].explored:
                namesdict[c] = game.rooms[c].name
            else:
                namesdict[c] = "unknown room " + game.rooms[c].hint
        return namesdict

    def info(self, game, short=True):
        """return string with all information about this room"""
        txt = "Room number {}: {}\n".format(self.number, self.name)
        txt += self.description + "\n"
        # items ?
        txt2 = ""
        itemcounter = 0
        for itemnumber in game.items:
            if game.items[itemnumber].location == self.number:
                itemcounter += 1
                if itemcounter > 1:
                    txt2 += ", "
                txt2 +=  game.items[itemnumber].description 
        if itemcounter > 0:
            txt += "You see {} item(s) here: \n".format(itemcounter) + txt2
        else:
            txt += "This room has no items."
        # doors
        txt += "\nYou see {} door(s) and ".format(len(self.connections))
        # monsters ?
        monstercounter = 0
        txt2 = ""
        for monsternumber in game.monsters:
            if game.monsters[monsternumber].location == self.number:
                if not game.monsters[monsternumber].player:
                    monstercounter +=1
                    txt2 += game.monsters[monsternumber].info() 
        if monstercounter > 0:
            txt +="{} monster(s) here:\n".format(monstercounter)
            txt += txt2
        else:
            txt += "no monsters in this room, fortunately.\n"
        if short:
            return "You are in Room {}: {}. You see {} doors, {} items and {} monsters".format(
                    self.number, self.name, len(self.connections), itemcounter, monstercounter)
        return txt

#--------- battle math -----------

def swing(game, attacker, defender):
    """single combat action and damage calculation"""
    av = attacker.calculate_values(game) # av...AtackerValues
    dv = defender.calculate_values(game) # dv...DefenderValues
    attack_dice = opendice() # default=2
    defend_dice = opendice()
    damage_dice = opendice(1) # only one dice
    armor_dice = opendice(1)  # only one dice
    attack_value = av["attack"] + attack_dice
    defend_value = dv["defense"] + defend_dice
    damage_value = av["damage"] + damage_dice
    armor_value = dv["armor"] + armor_dice
    #armor_value = armor_dice
    damage = damage_value - armor_value
    txt = ""
    # hit at all ?
    if attack_value > defend_value:
        txt += "{} hit {} ({}+{}>{}+{})".format(attacker.description, 
            defender.description, av["attack"], attack_dice,
            dv["defense"], defend_dice)
        # armor penetration ? 
        if damage_value > armor_value:
            txt += " for {} damage ({}+{}-{}-{})\n".format(damage,
            av["damage"],damage_dice, dv["armor"], armor_dice)
            defender.hitpoints -= damage
        else:
            txt += " but makes no damage ({}+{}<{}+{})\n".format(
                av["damage"],damage_dice, dv["armor"], armor_dice)
    else:
        txt += "{} misses ({}+{}<{}+{})\n".format(attacker.description,
            av["attack"], attack_dice, dv["defense"], defend_dice)
    return txt

def combat(game, a,b):
    """combat between two monsters, 
    one of them is usually the player"""
    # first strike ?
    txt = ""
    combatround = 1
    while a.hitpoints > 0 and b.hitpoints > 0:
        txt += "--- round {} ---:\n".format(combatround)
        combatround += 1
        speed_a = a.calculate_values(game)["speed"] + opendice()
        speed_b = b.calculate_values(game)["speed"] + opendice()
        if speed_a > speed_b:
            txt += "first strike! " + swing(game, a, b) 
            if b.hitpoints > 0:
                txt += "risposte: " + swing(game, b, a) 
        else:
            txt += "first strike! " + swing(game, b, a)
            if a.hitpoints > 0:
                txt += "risposte: " + swing(game, a, b) 
    return txt
    
#------------- generic functions ------
# this function use print, replace later with gui commands
def output(txt):
    """can be later replaced by gui or graphical output"""
    print(txt)

def select_number(list_of_numbers):
        """The player select *one* number of a list of numbers"""
        answer = ""
        while ((not answer.isdecimal()) or int(answer) not in list_of_numbers):
                answer=input("Please type selected number and press ENTER: ")
        return int(answer)

def select_answer(list_of_answers):
    """The player select *one* char out of a list"""
    answer = ""
    while not answer in list_of_answers:
        answer = input(">>>")
    return answer
      
def opendice(number_of_dices=2, number_of_sides=6):
    """a dice that re-rolls if the highest number is rolled."""
    if number_of_dices < 1 or number_of_sides < 2:
        return 1 # stupid arguments
    sum = 0
    for dice in range(number_of_dices):
        while True:
            roll = random.randint(1,number_of_sides)
            if roll == number_of_sides:
                sum += (number_of_sides -1)
            else:
                sum += roll
                break
    return sum
    


# create a game instance
g = Game()

# ---------- rooms ---------
# add rooms with  description and connections.
# Each room will have a unique number and add himself to game
# syntax: Room(game, roomname, description, connections...)
# room 0 ....... is the "exit from the game" room
Room(g,"end of the world (game over)", [], explored=True)
# room number 1 .... starting lobby
descr = """The room where your adventure starts. If you 
go to the room number 0, the game is over"""
Room(g,"starting lobby",descr, [0, 2], explored = True) 
# this is a one-way connection from room1 to room0 !
# room number 2 .... first room 
Room(g,"first room", "a boring room with many doors", [1,3,4,5])
# room number 3 ..... storage room
Room(g,"storage room", "you see shelfs, empty boxes and a lot of dust and debris", [2,4], 
   itemchances = [0.6,0.4,0.33])
# room number 4 ..... gear room
Room(g,"gear room", "a room full of stuff", [2,3], itemchances=[1.0,1.0,0.7,0.7])
# room number 5 
Room(g,"npc room", "a ladder leads from here to the roof (7)", [2,7,8], monsterchances=[1.0])
# room number 6 ..... secret room
Room(g, "secret room", "this is where the monsters dump loot and treasures", [9], 
   itemchances = [1.0,1.0,0.8,0.5,0.4])
# room number 7 .... roof
Room(g, "roof", "you can jump from here directly into the boss room (9)", [5,9], hint="(roof)")
# room number 8 .... barrier (blocks path to boss room)
descr = """a mighty magical one-way barrier blocks your path into the
nearby boss room. Maybe there is another way into the boss room?"""
Room(g, "barrier room", descr, [5], hint="(magic light)")
# room number 9 .... boss room
# the boss room has 1 to 6 minions and 1 to 3 bosses
descr = "you smell blood. You can go from here throug the barrier (8). There is also a closed secret door. if you use a key, it may open."
Room(g,"boss chamber",descr , [8], monsterchances=[1.0,0.9,0.8,0.5,0.5,0.5],
     bosschances = [1.0,0.15,0.05], hint="(boss chamber)")

# ----------- effects ----------
Effect(g,"randomteleport","teleport")
Effect(g,"hometeleport", "teleport", arg1 = 1)
Effect(g,"heal5", "heal", arg1=5)
Effect(g,"heal10", "heal", arg1=10)
Effect(g,"heal15", "heal", arg1=15)
Effect(g,"heal50", "heal", arg1=50)
Effect(g,"open secret door", "key", arg1 = 9, arg2 = 6, success=1.0) # connect room 9 to room 6
Effect(g,"poison10", "heal", arg1=-10)
Effect(g,"fullheal", "heal", arg1=50)
Effect(g,"curse", "heal", arg1=-50, success = 0.75)
Effect(g,"carry5", "carry", arg1=5)
Effect(g,"carry10", "carry", arg1=10, success = 1.0)
Effect(g,"carry15", "carry", arg1=15, success = 1.0)
Effect(g,"carry50", "carry", arg1=50, success = 1.0)

# ---------- items ------------
# syntax: Item(game, where, description, mass, effect, workshowmanytimes)
Item(g,1, "blue fearsome chicken feather",0.1,"hometeleport")
Item(g,1, "red fearsome chicken feather",0.2, "hometeleport")
Item(g,5, "yellow mockingbird feather", 0.1, "randomteleport")
Item(g,2, "black mockingbird feather", 0.1, "randomteleport")
Item(g,3, "pink mockingbird feather", 0.1, "randomteleport")
Item(g,4, "potion of instant healing",0.25, "heal15")
Item(g,1, "small healing potion", 0.25, "heal5")
Item(g,3, "big wheel of cheese", 0.50, "heal5", 5) # works 5 times
Item(g,1, "key to secret door", 0.5, "open secret door", -1) # works always
Item(g,6, "bottle of holy water", 0.5, "heal50")
Item(g,7, "Full health potion", 0.50, "fullheal")
Item(g,2, "Cursed pill", 0.10, "curse")
Item(g,3, "small backpack", 0.0, "carry5")
Item(g,5, "medium backpack", 0.0, "carry10")
Item(g,7, "big backpack", 0.0, "carry15")
Item(g,6, "super big backpack of doom", 0.0, "carry50")

# -------- weapons ------
w=Weapon(g, 1, "wooden training sword", 3, length = 1.0, attackbonus=3, defensebonus = 2, damagebonus=1)
Weapon(g, 1, "wooden shield",6,defensebonus=5,armorbonus=2) # shield is a weapon !

Armor(g,1,"leather cap", 2, slot="head", armorbonus = 1)

#Daniels code monster

m=Monster(g, 1, "ugly", "troll")
m.hitpoints=50
w=Weapon(g, -m.number, "epic bow")
w.attackbonus=50
w.active=True
 
# --------- Player ------------
p = Player(g, where=1) # create player in room 1
# ---- default gear for player ---------
shirt=Armor(g,-p.number, "peasant robes",1,slot="boy",armorbonus=1)
shirt.active = True
p.carry = 1
#fist = Weapon(g,-p.number,"fists (unarmed combat)",0, length=0.0, attackbonus=-1)
#fist.never_drop = True
#fist.active = True

# main loop
turns = 1
while p.location != 0 and p.hitpoints > 0:
    output("----- turn: {} -----".format(turns))
    if not g.rooms[p.location].explored:
        output("You explore a new room!")
        g.rooms[p.location].explored = True # explore this room
    output("You have {} hitpoints left:\n{}".format(p.hitpoints, g.rooms[p.location].info(g)))
    p.nextAction(g)
    turns += 1
output("\n==================\n")
output("Thank you for playing. Have a nice real life")

########NEW FILE########
__FILENAME__ = littleAdventure_00_room_numbers
# part of http://ThePythonGameBook.com
# (c) 2013 by Horst JENS ( horst.jens@spielend-programmieren.at )
# license: gpl3, see http://www.gnu.org/copyleft/gpl.html

# little adventure game with different rooms
# you can walk between the rooms
# written for python3

import random

class Game(object):
    """
    holds all information for a game. Later it may be 
    possible to run several game instances at once
    """
    number = 0
    
    def __init__(self):
        self.number = Game.number
        Game.number += 1
        self.rooms = {} # dictionary of rooms
        self.items = {} # dictionary of items
        self.monsters = {} # dictionary of monsters
        
class Item(object):
    number = 0
   
    def __init__(self, game, description=""):
        self.number = Item.number
        Item.number += 1
        if description == "":
            description = random.choice(("ring","beer","flowerpot",
              "stone","bottle"))
        self.description = description
        game.items[self.number] = self # add item into game dict
    
    def info(self):
        txt =  "Item Number {}: ".format(self.number)
        txt += self.description + "\n"
        return txt
    
class Monster(object):
    number = 0
   
    def __init__(self, game, description=""):
        self.number = Monster.number
        Monster.number += 1
        game.monsters[self.number] = self # add monster into game dict
        self.description = description
        if description == "":
            self.description = random.choice(("goblin","ork","troll",
                 "mice","rat","dwarf","dragon"))    
        self.hitpoints = random.randint(5,15)
        
    def info(self):
        txt = "Monster number {}: {} with {} hitpoints\n".format(
            self.number, self.description, self.hitpoints)
        return txt 
        

class Effect(object):
    pass

class Room(object):
    number = 0
   
    def __init__(self, game, description="", connections=[],
                 itemchances=[0.5,0.25,0.1],
                 monsterchances=[0.3,0.2,0.1,0.05]):
        """need game instance"""
        self.number = Room.number
        game.rooms[self.number] = self # add room into game dict
        Room.number += 1
        self.description = description
        self.connections = connections
        self.itemchances = itemchances
        self.monsterchances = monsterchances
        self.effect = random.randint(1,100)
        # create items
        self.itemnumbers = []  # list of indexes of items in this room
        #self.game = game
        for chance in self.itemchances:
            if random.random()< chance:
                newItem = Item(game)
                self.itemnumbers.append(newItem.number) # add reference
        self.monsternumbers = [] # list of indexes of monsters in this room
        for chance in self.monsterchances:
            if random.random() < chance:
                newMonster = Monster(game)
                self.monsternumbers.append(newMonster.number) # add reference       
        
    def info(self, game):
        """return string with all information about this room"""
        txt = "Room number {}: ".format(self.number)
        txt += self.description + "\n"
        # itmes ? 
        if len(self.itemnumbers) > 0:
            txt += "You see {} itmes here: \n".format(len(self.itemnumbers))
            for i in self.itemnumbers:
                txt += game.items[i].info()
        else:
            txt += "This room has no items\n"
        # monsters ?
        if len(self.monsternumbers) > 0:         
            txt +="You see {} monster(s) here:\n".format(len(self.monsternumbers))
            for m in self.monsternumbers:
                txt += game.monsters[m].info()
        else:
            txt += "No monsters in this room, fortunately.\n"
        # doors
        txt += "You see {} door(s).\n".format(len(self.connections))
        txt += "\n"
        return txt

# this function use print, replace later with gui commands
def output(txt):
        """can be later replaced by gui or graphical output"""
        print(txt)

# this funciton use input, replace later with gui command
def nextMove(game, where):
    """ask the user to select only one of many options"""
    output("Where do you want to go today ?")
    connections = game.rooms[where].connections
    for c in connections:
        output("{}.........{}".format(c, game.rooms[c].description))
    answer = ""
    while (not answer.isdecimal()) or (int(answer) not in connections):
        answer = input("please type in valid room number:>")
    return int(answer)
    
# create a game instance        
g = Game()

# add rooms with  description and connections. 
# Each room will have a unique number and add himself to game
Room(g,"starting lobby", [1, 4]) # 0
Room(g,"fist room", [0,2,3]) # 1
Room(g,"storage room", [1]) # 2
Room(g,"boss chamber", [1,2]) # 3
Room(g,"end of the world (game over)", []) # 4

# start player in lobby (room 0)
where = 0 # the actual room number

# main loop
while len(g.rooms[where].connections) > 0:
    output("You are now here:\n{}".format(g.rooms[where].info(g)))
    where = nextMove(g, where)
    output("\n"*15)
output("\n"*5)
output("Thank you for playing. Have a nice real life")


########NEW FILE########
__FILENAME__ = littleAdventure_01_nameindex
# part of http://ThePythonGameBook.com
# (c) 2013 by Horst JENS ( horst.jens@spielend-programmieren.at )
# license: gpl3, see http://www.gnu.org/copyleft/gpl.html
# written for python3
# little adventure game with different rooms
# you can walk between the rooms. 
#
# changes:
# using roomnames as index instead of room numbers
# introducing enumerate to create a menu


import random

class Game(object):
    """
    holds all information for a game. Later it may be 
    possible to run several game instances at once
    """
    number = 0
    
    def __init__(self):
        self.number = Game.number
        Game.number += 1
        #self.rooms = {} # dictionary of rooms, index is room number
        self.roomnames = {} # key is roomname, value is room instance
        self.items = {} # dictionary of items
        self.monsters = {} # dictionary of monsters
        
class Item(object):
    number = 0
   
    def __init__(self, game, description=""):
        self.number = Item.number
        Item.number += 1
        if description == "":
            description = random.choice(("ring","beer","flowerpot",
              "stone","bottle"))
        self.description = description
        game.items[self.number] = self # add item into game dict
    
    def info(self):
        txt =  "Item Number {}: ".format(self.number)
        txt += self.description + "\n"
        return txt
    
class Monster(object):
    number = 0
   
    def __init__(self, game, description=""):
        self.number = Monster.number
        Monster.number += 1
        game.monsters[self.number] = self # add monster into game dict
        self.description = description
        if description == "":
            self.description = random.choice(("goblin","ork","troll",
                 "mice","rat","dwarf","dragon"))    
        self.hitpoints = random.randint(5,15)
        
    def info(self):
        txt = "Monster number {}: {} with {} hitpoints\n".format(
            self.number, self.description, self.hitpoints)
        return txt 
        

class Effect(object):
    pass

class Room(object):
    number = 0
   
    def __init__(self, game, description="", connections=[],
                 itemchances=[0.5,0.25,0.1],
                 monsterchances=[0.3,0.2,0.1,0.05]):
        """need game instance"""
        self.number = Room.number
        #game.rooms[self.number] = self # add room into game dict
        Room.number += 1
        # testing if room description is unique
        while description in game.roomnames : 
            description += str(self.number)
        self.description = description
        game.roomnames[self.description] = self
        self.connections = connections
        self.itemchances = itemchances
        self.monsterchances = monsterchances
        self.effect = random.randint(1,100)
        # create items
        self.itemnumbers = []  # list of indexes of items in this room
        for chance in self.itemchances:
            if random.random()< chance:
                newItem = Item(game)
                self.itemnumbers.append(newItem.number) # add reference
        self.monsternumbers = [] # list of indexes of monsters in this room
        for chance in self.monsterchances:
            if random.random() < chance:
                newMonster = Monster(game)
                self.monsternumbers.append(newMonster.number) # add reference       
        
    def info(self, game):
        """return string with all information about this room"""
        txt = "Room number {}: ".format(self.number)
        txt += self.description + "\n"
        if len(self.itemnumbers) > 0:
            txt += "You see {} itmes here: \n".format(len(self.itemnumbers))
            for i in self.itemnumbers:
                txt += game.items[i].info()
        else:
            txt += "This room has no items\n"
        if len(self.monsternumbers) > 0:                       
            txt +="You see {} monster(s) here:\n".format(len(self.monsternumbers))
            for m in self.monsternumbers:
                txt += game.monsters[m].info()
        else:
            txt += "No monsters in this room, fortunately.\n"
        txt += "You see {} door(s).\n".format(len(self.connections))
        txt += "\n"
        return txt

# this function use print, replace later with gui commands
def output(txt):
    """can be later replaced by gui or graphical output"""
    print(txt)

# this funciton use input, replace later with gui command
def nextMove(game, where):
    """ask the user to select only one of many options"""
    output("Where do you want to go today ?")
    connections = game.roomnames[where].connections
    # create list of tuples with (number, roomname), starting with 1:
    for c in enumerate(connections, 1) :
        output("{}.........{}".format(c[0],c[1]))
    answer = ""
    while ((not answer.isdecimal()) or (int(answer) < 1) or
           (int(answer)>len(connections))):
        answer = input("please type in valid room number:>")
    return connections[int(answer)-1] # return room name
    
# create a game instance        
g = Game()

# add rooms with  description and connections. 
# Each room will have a unique number and add himself to game
# make sure each room name is unique and spelled correctly !
Room(g,"starting lobby", ["first room", "end of the world"]) # 0
Room(g,"first room", ["starting lobby","storage room","boss chamber"]) # 1
Room(g,"storage room", ["first room"]) # 2
Room(g,"boss chamber", ["first room","storage room"]) # 3
Room(g,"end of the world", []) # 4

# start player in lobby (room 0)
where = "starting lobby" # the actual room number

print(g.roomnames[where])
print(g.roomnames[where].connections)

# main loop
while len(g.roomnames[where].connections) > 0:
    output("You are now here:\n{}".format(g.roomnames[where].info(g)))
    where = nextMove(g, where)
    output("\n"*15)
output("\n"*5)
output("Thank you for playing. Have a nice real life")







########NEW FILE########
__FILENAME__ = littleAdventure_02_explored_rooms
# part of http://ThePythonGameBook.com
# (c) 2013 by Horst JENS ( horst.jens@spielend-programmieren.at )
# license: gpl3, see http://www.gnu.org/copyleft/gpl.html
# written for python3
# little adventure game with different rooms
# you can walk between the rooms
# changes:
# menu with room descriptions and enumerate,
# each room get an "explored" flag, reflected in the menu as
# "unknown room" 
# room index changed back to numbers
# added boss monsters into boss chamber


import random

class Game(object):
    """
    holds all information for a game. Later it may be 
    possible to run several game instances at once
    """
    number = 0
    
    def __init__(self):
        self.number = Game.number
        Game.number += 1
        self.rooms = {} # dictionary of rooms, key is room number
        self.items = {} # dictionary of items, key is item number
        self.monsters = {} # dictionary of monsters, key is m. number
        
class Item(object):
    number = 0
   
    def __init__(self, game, description=""):
        self.number = Item.number
        Item.number += 1
        if description == "":
            description = random.choice(("ring","beer","flowerpot",
              "stone","bottle"))
        self.description = description
        game.items[self.number] = self # add item into game dict
    
    def info(self):
        txt =  "Item Number {}: ".format(self.number)
        txt += self.description + "\n"
        return txt
    
class Monster(object):
    number = 0
   
    def __init__(self, game, description="", boss=False):
        self.number = Monster.number
        Monster.number += 1
        game.monsters[self.number] = self # add monster into game dict
        self.description = description
        self.hitpoints = random.randint(5,15)
        if description == "":
            if boss:
                self.description = random.choice(("dragon", "giant",
                    "arch wizard", "ghost king", "vampire lord"))
                self.hitpoints *= 5
            else:
                self.description = random.choice(("goblin","ork","troll",
                    "mice","rat","dwarf","cave drake"))    
        
        
    def info(self):
        txt = "Monster number {}: {} with {} hitpoints\n".format(
            self.number, self.description, self.hitpoints)
        return txt 
        

class Effect(object):
    pass

class Room(object):
    number = 0
   
    def __init__(self, game, description="", connections=[],
                 itemchances=[0.5,0.25,0.1],
                 monsterchances=[0.3,0.2,0.1,0.05], 
                 bosschances=[0.0], explored=False):
        """need game instance"""
        self.number = Room.number
        game.rooms[self.number] = self # add room into game dict
        Room.number += 1
        self.explored = explored # True or False
        self.description = description
        self.connections = connections
        self.itemchances = itemchances
        self.monsterchances = monsterchances
        self.bosschances = bosschances
        self.effect = random.randint(1,100)
        # create items
        self.itemnumbers = []  # list of indexes of items in this room
        #self.game = game
        for chance in self.itemchances:
            if random.random()< chance:
                newItem = Item(game)
                self.itemnumbers.append(newItem.number) # add reference
        self.monsternumbers = [] # list of indexes of monsters in this room
        for chance in self.monsterchances:
            if random.random() < chance:
                newMonster = Monster(game)
                self.monsternumbers.append(newMonster.number) # add reference 
        for chance in self.bosschances:
            if random.random() < chance:
                newMonster = Monster(game,boss=True)
                self.monsternumbers.append(newMonster.number) # add reference 
              
        
    def info(self, game):
        """return string with all information about this room"""
        txt = "Room number {}: ".format(self.number)
        txt += self.description + "\n"
        # itmes ? 
        if len(self.itemnumbers) > 0:
            txt += "You see {} itmes here: \n".format(len(self.itemnumbers))
            for i in self.itemnumbers:
                txt += game.items[i].info()
        else:
            txt += "This room has no items\n"
        # monsters ?
        if len(self.monsternumbers) > 0:         
            txt +="You see {} monster(s) here:\n".format(len(self.monsternumbers))
            for m in self.monsternumbers:
                txt += game.monsters[m].info()
        else:
            txt += "No monsters in this room, fortunately.\n"
        # doors
        txt += "You see {} door(s).\n".format(len(self.connections))
        txt += "\n"
        return txt

# this function use print, replace later with gui commands
def output(txt):
    """can be later replaced by gui or graphical output"""
    print(txt)

# this funciton use input, replace later with gui command
def nextMove(game, where):
    """ask the user to select only one of many options"""
    output("Where do you want to go today ?")
    connections = game.rooms[where].connections
    names = [] # temp list of room names
    for c in connections:
        if game.rooms[c].explored:
            names.append(game.rooms[c].description)
        else:
            names.append("unknown room")
    for d in enumerate(names, 1): # make list of tuples, start with 1
        output("{}.........{}".format(d[0], d[1]))
    answer = ""
    while ((not answer.isdecimal()) or (int(answer) < 1) or 
           (int(answer) > len(connections))):
        answer = input("please type in valid room number:>")
    return connections[int(answer)-1] # return correct room number
    
# create a game instance        
g = Game()

# add rooms with  description and connections. 
# Each room will have a unique number and add himself to game
# room number 0
Room(g,"starting lobby", [1, 4], explored = True) 
# room number 1
Room(g,"fist room", [0,2,3]) 
# room number 2
Room(g,"storage room", [1]) 
# room number 3
# the boss room has 1 to 6 minions and 1 to 3 bosses
Room(g,"boss chamber", [1,2], monsterchances=[1.0,0.9,0.8,0.5,0.5,0.5],
     bosschances = [1.0,0.15,0.05])  
# room number 4
Room(g,"end of the world (game over)", [], explored=True) 
# start player in lobby (room 0)
where = 0 # the actual room number

# main loop
while len(g.rooms[where].connections) > 0:
    if not g.rooms[where].explored:
        output("You explore a new room!")
        g.rooms[where].explored = True # explore this room
    output("You are now here:\n{}".format(g.rooms[where].info(g)))
    where = nextMove(g, where)
    output("\n"*15)
output("\n"*5)
output("Thank you for playing. Have a nice real life")







########NEW FILE########
__FILENAME__ = littleAdventure_03_inventory
# part of http://ThePythonGameBook.com
# (c) 2013 by Horst JENS ( horst.jens@spielend-programmieren.at )
# license: gpl3, see http://www.gnu.org/copyleft/gpl.html
# written for python3
# little adventure game with different rooms
# you can walk between the rooms
# changes:
# pick up and drop items, inspect inventory

import random

class Game(object):
    """
    holds all information for a game. Later it may be 
    possible to run several game instances at once
    """
    number = 0
    
    def __init__(self):
        self.number = Game.number
        Game.number += 1
        self.rooms = {} # dictionary of rooms, key is room number
        self.items = {} # dictionary of items, key is item number
        self.monsters = {} # dictionary of monsters, key is m. number
       

class Player(object):
    number = 0
    def __init__(self, game, where=0, name="hero"):
        """need game object, like the room class"""
        self.number = Player.number
        Player.number += 1
        self.name = name
        self.inventory = [] # list of itemnumbers (player carry items)
        self.maxcarry = 30 # kg
        self.carry = 0 # kg
        self.where = where # start room number
        
        
       
class Item(object):
    number = 0
   
    def __init__(self, game, description="", mass=0):
        self.number = Item.number
        Item.number += 1
        if mass == 0.0:
            mass = round(random.random()*5,1)
        self.mass = mass
        if description == "":
            description = random.choice(("ring","beer","flowerpot",
              "stone","bottle"))
        self.description = description
        game.items[self.number] = self # add item into game dict
    
    def info(self):
        txt =  "Item Number {}: ".format(self.number)
        txt += self.description + "\n"
        return txt
    
class Monster(object):
    number = 0
   
    def __init__(self, game, description="", boss=False):
        self.number = Monster.number
        Monster.number += 1
        game.monsters[self.number] = self # add monster into game dict
        self.description = description
        self.hitpoints = random.randint(5,15)
        if description == "":
            if boss:
                self.description = random.choice(("dragon", "giant",
                    "arch wizard", "ghost king", "vampire lord"))
                self.hitpoints *= 5
            else:
                self.description = random.choice(("goblin","ork","troll",
                    "mice","rat","dwarf","cave drake"))    
        
        
    def info(self):
        txt = "Monster number {}: {} with {} hitpoints\n".format(
            self.number, self.description, self.hitpoints)
        return txt 
        

class Effect(object):
    pass

class Room(object):
    number = 0
   
    def __init__(self, game, description="", connections=[],
                 itemchances=[0.5,0.25,0.1],
                 monsterchances=[0.3,0.2,0.1,0.05], 
                 bosschances=[0.0], explored=False):
        """need game instance"""
        self.number = Room.number
        game.rooms[self.number] = self # add room into game dict
        Room.number += 1
        self.explored = explored # True or False
        self.description = description
        self.connections = connections
        self.itemchances = itemchances
        self.monsterchances = monsterchances
        self.bosschances = bosschances
        self.effect = random.randint(1,100)
        # create items
        self.itemnumbers = []  # list of indexes of items in this room
        #self.game = game
        for chance in self.itemchances:
            if random.random()< chance:
                newItem = Item(game)
                self.itemnumbers.append(newItem.number) # add reference
        self.monsternumbers = [] # list of indexes of monsters in this room
        for chance in self.monsterchances:
            if random.random() < chance:
                newMonster = Monster(game)
                self.monsternumbers.append(newMonster.number) # add reference 
        for chance in self.bosschances:
            if random.random() < chance:
                newMonster = Monster(game,boss=True)
                self.monsternumbers.append(newMonster.number) # add reference 
              
        
    def info(self, game):
        """return string with all information about this room"""
        txt = "Room number {}: ".format(self.number)
        txt += self.description + "\n"
        # itmes ? 
        if len(self.itemnumbers) > 0:
            txt += "You see {} itmes here: \n".format(len(self.itemnumbers))
            for i in self.itemnumbers:
                txt += game.items[i].info()
        else:
            txt += "This room has no items\n"
        # monsters ?
        if len(self.monsternumbers) > 0:         
            txt +="You see {} monster(s) here:\n".format(len(self.monsternumbers))
            for m in self.monsternumbers:
                txt += game.monsters[m].info()
        else:
            txt += "No monsters in this room, fortunately.\n"
        # doors
        txt += "You see {} door(s).\n".format(len(self.connections))
        txt += "\n"
        return txt

# this function use print, replace later with gui commands
def output(txt):
    """can be later replaced by gui or graphical output"""
    print(txt)
    
def select_number(list_of_numbers):
	"""The player select *one* number of a list of numbers"""
	answer = ""
	while ((not answer.isdecimal()) or int(answer) not in list_of_numbers):
		answer=input("Please type selected number and press ENTER")
	return int(answer)

def show_inventory(game, player):
    output("==== your inventory ====")
    output("number, description, mass (kg)")
    output("-------------------------")
    tmpmass = 0.0
    for i in player.inventory:
        output("{}...{}...{}".format(i, game.items[i].description,
                                             game.items[i].mass))
        tmpmass += game.items[i].mass
    output("you currently carry {} kg, that is {:.2f}% of your capacity".format(
        tmpmass, (tmpmass / player.maxcarry)*100))
       
    
def drop_item(game, player):
    pass
    
def pickup_item(game, player):
    pass

# this funciton use input, replace later with gui command
def nextAction(game, player):
    """ask the user to select only one of many options"""
    output("What do you want to do today ?")
    connections = game.rooms[player.where].connections
    names = [] # temp list of room names
    for c in connections:
        if game.rooms[c].explored:
            names.append(game.rooms[c].description)
        else:
            names.append("unknown room")
    output("0.........other actions")
    for d in enumerate(names, 1): # make list of tuples, start with 1
        output("{}.........{}".format(d[0], d[1]))
    #answer = ""
    #while ((not answer.isdecimal()) or (int(answer) < 0) or 
    #       (int(answer) > len(connections))):
    #    answer = input("please type number and press ENTER:>")
    answer = select_number(range(len(names)+1))
    if answer != 0:
       return connections[int(answer)-1] # return new room number
    # other menu options, player remain in same room
    output("What do you want to do today?")
    actions = {"d":"drop item", 
               "i":"inspect inventory",
               "p":"pick up item",
               "c":"cancel"}
    for a in actions:
        output("{}....{}".format(a, actions[a]))
    answer = ""
    while answer not in actions:
        answer = input("please type char and press ENTER:>")
    if answer == "i":
        show_inventory(game, player)
    elif answer == "d":
        drop_item(game, player)
    elif answer == "p":
        pickup_item(game, player)
    return player.where # return the same room number

       
    
# create a game instance        
g = Game()

# add rooms with  description and connections. 
# Each room will have a unique number and add himself to game
# room number 0
Room(g,"starting lobby", [1, 4], explored = True) 
# room number 1
Room(g,"fist room", [0,2,3]) 
# room number 2
Room(g,"storage room", [1]) 
# room number 3
# the boss room has 1 to 6 minions and 1 to 3 bosses
Room(g,"boss chamber", [1,2], monsterchances=[1.0,0.9,0.8,0.5,0.5,0.5],
     bosschances = [1.0,0.15,0.05])  
# room number 4
Room(g,"end of the world (game over)", [], explored=True) 
# start player in lobby (room 0)
# where = 0 # the actual room number
p = Player(g, where=0) # create player in room 0 

# main loop
while len(g.rooms[p.where].connections) > 0:
    if not g.rooms[p.where].explored:
        output("You explore a new room!")
        g.rooms[p.where].explored = True # explore this room
    output("You are now here:\n{}".format(g.rooms[p.where].info(g)))
    p.where = nextAction(g, p)
    output("\n"*1)
output("\n"*1)
output("Thank you for playing. Have a nice real life")







########NEW FILE########
__FILENAME__ = littleAdventure_04_effects
# part of http://ThePythonGameBook.com
# (c) 2013 by Horst JENS ( horst.jens@spielend-programmieren.at )
# license: gpl3, see http://www.gnu.org/copyleft/gpl.html
# written for python3
# little adventure game with different rooms
# you can walk between the rooms
# changes:
# each item "knows" it's own location. no more inventorys for rooms and player
# item can be carried by monster: location ist then a negative monster number
# player is a child class of monster
# STATUS: does not work
# TODO: 
# * ab sucesschance bei Effect weitermachen
# * game unnötig machen?
# * user-interface von player klasse sauberer trennen

import random
import sys

if sys.version_info[0] < 3:
    print("this script need python3. You are using python 2 or lower.")
    sys.exit()
    
class Game(object):
    """
    holds all information for a game. Later it may be
    possible to load / save different games
    """
    number = 0

    def __init__(self):
        self.number = Game.number
        Game.number += 1
        self.rooms = {} # dictionary of rooms, key is room number
        self.items = {} # dictionary of items, key is item number
        self.monsters = {} # dictionary of monsters, key is monster number
        self.players = [] # dictionary of players, key is player number, value = monsternumber
        self.effects = {} # dictionary of effects (for items), key is effect name



class Monster(object):
    number = 1 # number 1 should be reserved for player

    def __init__(self, game, where= 0, adjective="", description="",
         boss=False, carrier=False):
        self.number = Monster.number
        Monster.number += 1
        game.monsters[self.number] = self # add monster into game dict
        self.adjective = adjective
        self.location = where # room number
        self.description = description
        self.hitpoints = random.randint(5,15)
        self.player = False
        self.carrier = carrier # can carry items ?
        self.attack = 10 + random.randint(-2,2)
        self.defense = 10 + random.randint(-2,2)
        self.speed = 10 + random.randint(-2,2)
        self.damage = 3 + random.randint(-2,2)
        self.armor = 3 + random.randint(-2,2)
        self.agressive = False
        if description == "":
            if boss:
                self.adjective = random.choice(("deadly","fantastic",
                        "creepy","ugly","epic"))
                self.description = random.choice(("dragon","cave drake",
                        "sea serpent","gorgon","giant beetle","arch druid"))
                self.hitpoints *= 5
                self.attack += random.randint(2,7)
                self.defense += random.randint(2,7)
                self.speed += random.randint(2,7)
            else:
                self.adjective = random.choice(("weak","boring",
                        "tired","cheap","old"))
                self.description = random.choice(("goblin","ork","troll",
                    "mice","rat","dwarf","spider"))

    def info(self):
        txt = "Monster number {}: {} {} with {} hitpoints\n".format(
            self.number, self.adjective, self.description, self.hitpoints)
        if self.carrier:
            txt += "This monster can carry items\n"
        return txt


class Player(Monster):
    #playernumber = 1
    def __init__(self, game, where=0, name="hero"):
        """need game instance. 
        """
        Monster.__init__(self, game, where, carrier = True)
        game.players.append(self.number) # add my monsternumber to game.players
        self.playerindex = len(game.players) - 1 
        self.name = name
        self.player = True
        self.description = "player" # overwrite monster
        self.adjective = "human"                     # overwrite monster
        #self.inventory = [] # list of itemnumbers (player carry items)
        self.maxcarry = 100 # kg
        self.carry = 0 # current mass of all carried items in kg
        self.damage += random.randint(1,5)
        self.armor += random.randint(1,5)
        self.speed += random.randint(1,5)
        #self.loaction = where # start room number

    def show_inventory(self, game):
        txt = ""
        txt += "\n==== Your inventory ====\n"        
        for itemnumber in game.items:
            #print("debug item:",itemnumber, "location:", game.items[itemnumber].location)
            if game.items[itemnumber].location == self.number * -1: # my negative monster number
                txt+="{}...{}...{} kg\n".format(itemnumber,
                      game.items[itemnumber].description, game.items[itemnumber].mass)
        
        txt += "You're currently carrying {:.2f} kg, that is {:.2f}% of your capacity".format(
            self.carry, (self.carry / self.maxcarry)*100)
        return txt  

    def list_items(self, game):
        """returns list of itemnumber
        of the items in the inventory of the player"""
        txt = ""
        items = []
        for itemnumber in game.items:
            if game.items[itemnumber].location == self.number * -1: # negative monster number
               items.append(itemnumber)
               #txt += game.items[itemnumber].description
        return items

    def pickup_item(self, game):
        txt, items = game.rooms[self.location].list_items(game)
        if len(items) >0:
            output("please select item number to pick up\n")
            output(txt)
            i = select_number(items)
            m = game.items[i].mass 
            if m > self.maxcarry:
                return "You fail to pick up this item. Reason: You can only carry {} kg. \n and try to pick up {} kg. Become stronger and try again!".format(m, self.maxcarry)
            elif m + self.carry > self.maxcarry:
                return "You fail to pick up this item. Reason: You already carry {} kg. Picking up {} would exceed your max. carry capacity of {} kg. Drop some items first or become stronger!".format(self.carry, m, self.maxcarry)
            else:
                game.items[i].location = -1 * self.number # negative monster number
                self.carry += m
            
        else: 
            return "this room has no items so there is nothing to pick up\n"

    def drop_item(self, game):
        items = self.list_items(game)
        if len(items)>0:
            output(self.show_inventory(game))
            output("select itemnumber to drop\n")
            i = select_number(items)
            game.items[i].location = self.location # drop item in my room
            self.carry -= game.items[i].mass  # update player
            return "you drop the {} to the floor\n".format(game.items[i].description)
        else:
            return "you carry no items so you can drop nothing\n"           
            
   
    def use_item(self, game):
        items = self.list_items(game)
        if len(items)>0:
            output(self.show_inventory(game))
            output("select itemnumber to use\n")
            i = select_number(items)
            if game.items[i].effect == None:
                return "this item has no effect"
            txt = ""
            game.items[i].charges -= 1
            if game.items[i].charges == 0:
                # destroy item (move to room 0)
                game.items[i].location = 0
                txt += "while using the effect, the item has destroyed itself\n"
            txt += game.effects[game.items[i].effect].action(game, victim=self.number)
            return txt
        else:
            return "you carry no items so you can use nothing"

    def nextAction(self, game):
        """ask the user to select only one of many options"""
        output("please select your next action:")
        cd = game.rooms[self.location].connectiondict(game) #cd = connectiondict
        #print("debug cd:",cd)
        txt = ""
        #txt = "goto room(s):\n"
        for roomnumber in cd:
            txt+= "{}....goto {}\n".format(roomnumber, cd[roomnumber])
        #txt += "other actions:\n"
        txt += "i....inspect inventory\nd....drop item\np....pick up item\n"
        txt += "u....use item\n"
        txt += "f....fight monsters\n"
        txt += "please type number/char and press ENTER or q and ENTER to quit\n"
        # generate valid answerlist:
        chars = ("i","d","p","u","f", "q")
        answers = []
        for roomnumber in cd:
            answers.append(str(roomnumber))
        answers.extend(chars)
        output(txt)
        answer = select_answer(answers)
        if not answer in chars:
            # room change
            self.location = int(answer)
        elif answer =="q":
            sys.exit()
        elif answer =="i":
            output(self.show_inventory(game))
        elif answer == "d":
            output(self.drop_item(game))
        elif answer == "p":
            output(self.pickup_item(game))
        elif answer == "u":
            output(self.use_item(game))
        elif answer == "f":
            output("you fight one of the monsters in this room !")
            #for monsternumber in [monsternumber for monsternumber in game.monsters if game.monsters[monsternumber].location == self.location]:
            txt = ""
            for monster in game.monsters.values():
                if monster.location == self.location:
                    if self.hitpoints > 0 and monster.number != self.number:
                        txt += "---- combat versus {} ----\n".format(monster.description)
                        txt += combat(self, monster)
                        if self.hitpoints > 0:
                            txt += "====== Victory !!! ========"
                            monster.location = 0 # move deat monster in the void
                            # todo: loot
                            # create item: corpse
                            Item(g,self.location, "corpse of killed monster", 70 )
                            break
                        else:
                            txt += "----==== you loose ====----"
                            break
            else:
                txt += "there are no (more) monsters to fight in this room"
            output(txt)
        
class Item(object):
    number = 0

    def __init__(self, game, where=0, description="", mass=-1, effect=None, charges =1):
        """need game instance. primary key of all items is the unique
        item number, so that you can have several items with the same
        name"""
        self.number = Item.number
        Item.number += 1
        game.items[self.number] = self # add item into game dict
        self.effect = effect
        self.charges = charges # how many times you can use this effect before item is destroyed
        self.location = where # positive values are room number,
                              # negative values refer to monster(!) number
        self.description=description
        if mass == -1:
            self.mass = round(random.randint(1,50))
        else:
            self.mass = mass
        if self.description == "":
            self.description = random.choice(("helmet","chestplate","pants",
                    "shoes","small healing potion","medium healing potion",
                    "gold","sword","bow and arrows","shield", "teleport pill"))
            if self.description == "small healing potion":
                self.effect = "heal5"
            elif self.description == "medium healing potion":
                self.effect = "heal10"
            elif self.description == "teleport pill":
                self.effect = "randomteleport"


    def info(self, game):
        txt =  "Item Number {}: ".format(self.number)
        txt += self.description + "\n"
        #if self.location >= 0:
        #   #txt +="\n current location: room {}, {}".format(self.location, game.rooms[self.location].description) 
        #else:
        #    txt += "\n currently carried by {}".format(game.monsters[self.location*-1].description)
        #return txt



class Effect(object):
    def __init__(self, game, name, function, description="",  
                 arg1=0, arg2=0, success=.5):
        #victim 0 means the effect is targeted at the player (monsternumber 0)
        self.name = name
        self.function = function
        self.description = description
        self.success = success # probability .5 means it has a chance of 50% to work correct
        #self.victim = victim # if the effect is aimed at somebody
        # -1 means the effect is targeted at the first player
        #self.roomnumber=roomnunmber # if the effect is in a certain room only
        self.arg1 = arg1  # reserve
        self.arg2 = arg2  # reserve
        self
        game.effects[self.name] = self
        
    def action(self, game, victim=-1):
        """gives effect to monster with monsternumber == victim"""
        # successchance 
        luck = random.random() # TODO: add players evocation ability here
        if luck > self.success:
            return "Item FAIL ! bad luck, the item/effect refuses to work. try again ?" 
        if self.function == "teleport":
            if self.arg1 != 0:
                # teleport into specific room number
                target = self.arg1
            else:
                # random teleport
                while True:
                    target = random.choice(game.rooms)
                    if target != 0:  # anywhere but the void room
                        break
            game.monsters[victim].location = target
            return "the teleport effect works ! Victim is transported by magic into room number {}".format(target)
        elif self.function == "heal":
            game.monsters[victim].hitpoints += self.arg1
            return "healing effect works! gained {} hitpoints".format(self.arg1)
        elif self.function == "key":
            # right key, wrong room ? 
            if game.monsters[victim].location != self.arg1:
                return "you can not find a lock to use with this key here. maybe in another room ?"
            game.rooms[self.arg1].connections.append(self.arg2)
            return "you open a formerly closed door!"
        else:
            return "unknow effect worked correctly"
           


class Room(object):
    number = 0

    def __init__(self, game, name="", description="", connections=[],
                 explored=False, itemchances=[0.5,0.25,0.1],
                 monsterchances=[0.3,0.2,0.1,0.05],
                 bosschances=[0.0] ):
        """need game instance"""
        self.number = Room.number # void room has number 0
        game.rooms[self.number] = self # add room into game dict
        Room.number += 1
        self.explored = explored # True or False
        self.name = name
        self.description = description
        self.connections = connections
        self.itemchances = itemchances
        self.monsterchances = monsterchances
        self.bosschances = bosschances
     
        # create items
        for chance in self.itemchances:  
            if random.random()< chance:
                newItem = Item(game, self.number) # create item in this room

        # create monsters
        for chance in self.monsterchances:
            if random.random() < chance:
                newMonster = Monster(game, self.number) # create monster in this room
        # create boss(es)
        for chance in self.bosschances:
            if random.random() < chance:
                newMonster = Monster(game, self.number, boss=True)


    def list_items(self, game):
        """return string with itemnumbers and item description 
        as well as list of itemnumbers"""
        txt = "items in this room:\n"
        items = []
        for itemnumber in game.items:
            if game.items[itemnumber].location == self.number:
                txt +=  "{}....{}\n".format(itemnumber, 
                     game.items[itemnumber].description)
                items.append(itemnumber)
        return txt, items
        
    def connectiondict(self, game):
        """returns a dict with connections from this room.
        key is room number, value is room description (or "unknown",
        depending if the room is yet bo be explored"""
        namesdict = {} # temp list of room names
        #print("debug: self.connections", self.connections)
        for c in self.connections:
            if game.rooms[c].explored:
                namesdict[c] = game.rooms[c].name
            else:
                namesdict[c] = "unknown room"
        return namesdict

    def info(self, game):
        """return string with all information about this room"""
        txt = "Room number {}: {}\n".format(self.number, self.name)
        txt += self.description + "\n"
        # itmes ?
        txt2 = ""
        itemcounter = 0
        for itemnumber in game.items:
            if game.items[itemnumber].location == self.number:
                itemcounter += 1
                if itemcounter > 1:
                    txt2 += ", "
                txt2 +=  game.items[itemnumber].description 
        if itemcounter > 0:
            txt += "You see {} item(s) here: \n".format(itemcounter) + txt2
        else:
            txt += "This room has no items."
        # doors
        txt += "\nYou see {} door(s) and ".format(len(self.connections))
        # monsters ?
        monstercounter = 0
        txt2 = ""
        for monsternumber in game.monsters:
            if game.monsters[monsternumber].location == self.number:
                if not game.monsters[monsternumber].player:
                    monstercounter +=1
                    txt2 += game.monsters[monsternumber].info() 
        if monstercounter > 0:
            txt +="{} monster(s) here:\n".format(monstercounter)
            txt += txt2
        else:
            txt += "no monsters in this room, fortunately.\n"
       
        #txt += "\n"
        return txt

#--------- battle math -----------

def swing(attacker, defender):
    """single combat action and damage calculation"""
    attack_value = attacker.attack + opendice()
    defend_value = defender.defense + opendice()
    damage_value = attacker.damage + opendice(1)
    armor_value = defender.armor + opendice(1)
    damage = damage_value - armor_value
    txt = ""
    # hit at all ?
    if attack_value > defend_value:
        txt += "{} hit {}".format(attacker.description, defender.description)
        # armor penetration ? 
        if damage_value > armor_value:
            txt += " for {} damage\n".format(damage_value)
            defender.hitpoints -= damage_value
        else:
            txt += " but makes no damage\n"
    else:
        txt += "{} misses\n".format(attacker.description)
    return txt

def combat(a,b):
    """combat between two monsters, 
    one of them is usually the player"""
    # first strike ?
    txt = ""
    combatround = 1
    while a.hitpoints > 0 and b.hitpoints > 0:
        txt += "--- round {} ---: ".format(combatround)
        combatround += 1
        speed_a = a.speed + opendice()
        speed_b = b.speed + opendice()
        if speed_a > speed_b:
            txt += swing(a, b) # strike
            if b.hitpoints > 0:
                txt += swing(b, a) # riposte
        else:
            txt += swing(b, a) # strike
            if a.hitpoints > 0:
                txt += swing(a, b) # riposte
    return txt
    
#------------- generic functions ------
# this function use print, replace later with gui commands
def output(txt):
    """can be later replaced by gui or graphical output"""
    print(txt)

def select_number(list_of_numbers):
        """The player select *one* number of a list of numbers"""
        answer = ""
        while ((not answer.isdecimal()) or int(answer) not in list_of_numbers):
                answer=input("Please type selected number and press ENTER: ")
        return int(answer)

def select_answer(list_of_answers):
    """The player select *one* char out of a list"""
    answer = ""
    while not answer in list_of_answers:
        answer = input(">>>")
    return answer
      
def opendice(number_of_dices=2, number_of_sides=6):
    """a dice that re-rolls if the highest number is rolled."""
    if number_of_dices < 1 or number_of_sides < 2:
        return 1 # stupid arguments
    sum = 0
    for dice in range(number_of_dices):
        while True:
            roll = random.randint(1,number_of_sides)
            if roll == number_of_sides:
                sum += (number_of_sides -1)
            else:
                sum += roll
                break
    return sum
    


# create a game instance
g = Game()

# ---------- rooms ---------
# add rooms with  description and connections.
# Each room will have a unique number and add himself to game
# room 0 is the "exit from the game" room
# room 1 is the starting room for the player
# syntax: Room(game, roomname, description, connections...)
Room(g,"end of the world (game over)", [], explored=True)
# room number 1 .... starting lobby
descr = """The room where your adventure starts. If you 
go to the room number 0, the game is over"""
Room(g,"starting lobby",descr, [0, 2], explored = True)
# room number 2 .... first room 
Room(g,"first room", "a boring room with many doors", [1,3,4,5])
# room number 3 ..... storage room
Room(g,"storage room", "you see shelfs, empty boxes and a lot of dust and debris", [2,4], 
   itemchances = [0.6,0.4,0.33])
# room number 4 ..... gear room
Room(g,"gear room", "a room full of stuff", [2,3], itemchances=[1.0,1.0,0.7,0.7])
# room number 5 
Room(g,"npc room", "a ladder leads from here to the roof (7)", [2,7,8], monsterchances=[1.0])
# room number 6 ..... secret room
Room(g, "secret room", "this is where the monsters dump loot and treasures", [9], 
   itemchances = [1.0,1.0,0.8,0.5,0.4])
# room number 7 .... roof
Room(g, "roof", "you can jump from here directly into the boss room (9)", [5,9])
# room number 8 .... barrier (blocks path to boss room)
descr = """a mighty magical one-way barrier blocks your path into the
nearby boss room. Maybe there is another way into the boss room?"""
Room(g, "barrier room", descr, [5])
# room number 9 .... boss room
# the boss room has 1 to 6 minions and 1 to 3 bosses
Room(g,"boss chamber", "you smell blood. You can go from here throug the barrier (8). There is also a closed secret door. if you use a key, it may open.", [8], monsterchances=[1.0,0.9,0.8,0.5,0.5,0.5],
     bosschances = [1.0,0.15,0.05])

# ----------- effects ----------
Effect(g,"randomteleport","teleport")
Effect(g,"hometeleport", "teleport", arg1 = 1)
Effect(g,"heal5", "heal", arg1=5)
Effect(g,"heal10", "heal", arg1=10)
Effect(g,"heal15", "heal", arg1=15)
Effect(g,"open secret door", "key", arg1 = 9, arg2 = 6, success=1.0) # connect room 9 to room 6

# ---------- items ------------
# syntax: Item(game, where, description, mass, effect)
Item(g,1, "blue fearsome chicken feather",0.1,"hometeleport")
Item(g,1, "red fearsome chicken feather",0.2, "hometeleport")
Item(g,4, "yellow mockingbird feather", 0.1, "randomteleport")
Item(g,3, "pink mockingbird feather", 0.1, "randomteleport")
Item(g,4, "potion of instant healing",0.25, "heal15")
Item(g,1, "small healing potion", 0.25, "heal5")
Item(g,3, "big wheel of cheese", 0.50, "heal5", 5) # works 5 times
Item(g,1, "key to secret door", 0.5, "open secret door", -1) # works always


# start player in lobby (room 0)
# where = 0 # the actual room number
p = Player(g, where=1) # create player in room 1

# main loop
turns = 1
while p.location != 0 and p.hitpoints > 0:
    output("----- turn: {} -----".format(turns))
    if not g.rooms[p.location].explored:
        output("You explore a new room!")
        g.rooms[p.location].explored = True # explore this room
    #print("debug rooms:", g.rooms)
    output("You are now here with {} hitpoints left:\n{}".format(p.hitpoints, g.rooms[p.location].info(g)))
    p.nextAction(g)
    turns += 1
output("\n==================\n")
output("Thank you for playing. Have a nice real life")

########NEW FILE########
__FILENAME__ = lizardpaper
#       lizardpaper.py 
#       Copyright 2012 Horst JENS <horst.jens@spielend-programmieren.at>
#       This program is part of ThePythonGameBook , 
#       see http://ThePythonGameBook.com for more information.
#       Check the newest version of this file at Github.com:
#       https://github.com/horstjens/ThePythonGameBook/blob/master/python/lizardpaper.py
#
#       tested with python3
#
#       This source code is licensed under the 
#       GNU General Public License, Free Software Foundation
#       http://www.gnu.org/licenses/gpl
#


## irgendein fehler mit keys 

import random

# general purpose functions, to be replaced later by a graphical user interface
def output(msg):
    print(msg)
    
def ask(msg="Your answer please:", choices=["yes","no"]):
    """gives the user a list of choices to answer. Choices must have different first chars"""
    while True:
        print(msg)
        print("Please type one of those answers (without the quotes) and press ENTER:")
        print(choices)
        print("or")
        firstchars = []
        # see if there are choices larger than one char
        maxlength = 1
        for item in choices:
            if len(item) > maxlength:
                maxlength = len(item)
        if maxlength > 1:
            for item in choices:
                firstchars.append(item[0])
            print( tuple(firstchars))
        answer = input(">")
        if answer in choices or answer in firstchars:
            break
    return answer[0]

def askname(msg="please enter your name"):
    return input(msg)

def startmenu():
    msg = "\n"
    msg += "\n*** Welcome !***"
    msg += "\nplease choose between a classic game of 'rock, paper, scissors'"
    msg += "\nor a game of the newer variant 'rock, paper, scissors, lizard, Spock' "
    msg += "\n"
    msg += "\nsee Wikipedia for game rules and more information:"
    msg += "\nhttp://en.wikipedia.org/wiki/Rock_paper_scissors"
    msg += "\nhttp://en.wikipedia.org/wiki/Rock-paper-scissors-lizard-spock"
    msg += "\n"
    #output(msg)
    mode = ask(msg + "press c for classic variant (rock, paper, scissors) \n"  \
               "press n for new variant (rock, paper, scissors, lizard, Spock \n", ["classic","new"])
    if mode == "c":
        game("classic")
    elif mode == "n":
        game("new")
    
def game(mode="classic"):
    """rock paper scissor lizard spock
    mode can be new or classic"""
    # { key: human-readable key description }
    things = {"r":"rock", 
              "s":"scissors",
              "p":"paper"}
    if mode == "new": # expand only for new version
        things["l"] = "lizard"
        things["m"] = "mister Spock"
        
    # { victor : { victim : (victorytext loosertext) }}
    wintext = {
              "r": { "s": ("rock crushes scissors", "scissors is crushed by rock"),
                     "l": ("rock crushes lizard", "lizard is crushed by rock")},
              "s": { "p": ("scissors cut paper", "paper is cut by scissors"),
                     "l": ("scissors decapitate lizard", "lizard is decapitated by scissors")},
              "p": { "o": ("paper disproves mister Spock", "mister Spock is disproved by paper"),
                     "r": ("paper covers rock", "rock is enveloped by paper") },
              "m": { "s": ("mister Spock smashes scissors", "scissors are smashed by mister Spock"),
                     "r": ("mister Spock vaporizes rock", "rock is vaporized by mister Spock") },
              "l": { "p": ("lizard eats paper", "paper is eaten by lizard"),
                     "o": ("lizard poisons Spock", "Spock is poisoned by lizard") } 
              }
    
    #question = "What do you play ? \n"
    #for thingy in things.keys():
    #    question += thingy + ": " + things[thingy] + "\n"
    #question += "\n please press one of the keys listed above and ENTER \n" 
    mainloop = True
    rounds = 0
    # ------ generating players --------
    players = {} # name, nature, thing, points # a dict cointaining dicts ...
    while True:
        msg =  "At the moment, this game has %i players. Minimum to start a game is 2 players. \n" % len(players) 
        if len(players.keys()) > 0:
            msg += "-- list of players in the game --\n"
            for player in players.keys():
                msg += "name: %s  type: %s \n" % (player, players[player]["nature"])
        msg += "----\n"
        playername = askname(msg + "please type in the name of a new player and press ENTER \n"
                               "press only ENTER to start the game \n")
        if playername == "":
            break # exit
        natureOfPlayer = ask("is this player %s a human or a computer ?" % playername, ["human","computer"])
        players[playername] = {"nature": natureOfPlayer , "thing": "xxx", "points":0 } # add player to dictionary
    if len(players) < 2:
        output( "you need at least 2 players to start a game. Bye !")
        return "too few players"
        
    while mainloop: # ----------- the game loop ------------    
        output( " ---- rounds played: %i ----- \n" % rounds )
        for player in players.keys():
            if players[player]["nature"] == "h": # human                
                playerthing = ""
                msg = "******** player %s, it is your turn ! ******* \n" % player 
                playerthing = ask(msg + "What do you play ? \n", tuple(things.values())) # asking the player for rock, paper etc..
                players[player]["thing"] = playerthing # adding answer to dict (inside a dict)
            else: # computer player
                players[player]["thing"] = random.choice(tuple(things.keys())) # computerthing
        rounds += 1
        
        msg = ""
        for player in players.keys(): # --- output ----
            playerthing = players[player]["thing"]
            msg += "The coice of player %s is: %s \n" % (player, playerthing)
        for player in players.keys():         # ---- calculate winner
            msg +=  "...calculating points for player %s...\n" % player
            playerthing = players[player]["thing"]
            for enemy in players.keys():
                if player != enemy:
                    enemything = players[enemy]["thing"]
                    msg +=  "%s of %s versus %s of %s \n" % (things[playerthing], player, things[enemything], enemy)                       
                    if playerthing == enemything:
                        msg += "this is a draw (0 points) \n"
                    elif enemything in wintext[playerthing].keys():
                        players[player]["points"] += 1
                        msg += "%s (+1 point) \n" % wintext[playerthing][enemything][0]  # victory
                    else:
                        msg +=  "%s (no point) \n" % wintext[enemything][playerthing][1] # loose
        msg += "====== result (round %i) =======\n" % rounds     #------ summary -------
        for player in players.keys():
            msg+= "points: %i for %s \n" %( players[player]["points"], player) 
        msg += "------ next round -------\n\n" 
        playMore = ask(msg+"continue or quit ?", ["continue","quit"])
        if playMore == "q":
            mainloop = False
        #print "\n\n\n" # three empty lines
    output("bye-bye")
    return 0 # (computerpoints, playerpoints)

if __name__ == '__main__':
    startmenu()


########NEW FILE########
__FILENAME__ = lizardpaper_easygui
#       lizardpaper.py 
#       Copyright 2012 Horst JENS <horst.jens@spielend-programmieren.at>
#       This program is part of ThePythonGameBook , 
#       see http://ThePythonGameBook.com for more information.
#       Check the newest version of this file at Github.com:
#       https://github.com/horstjens/ThePythonGameBook/blob/master/python/lizardpaper.py
#
#       tested with python3
#
#       This source code is licensed under the 
#       GNU General Public License, Free Software Foundation
#       http://www.gnu.org/licenses/gpl
#



#### warum kann ich nicht from lizardpaper import game, startmenu machen und die funktionien output, ask und askname überschreiben ???
#### wenn ich es mache werde trotzdem die funkoinen ask etc. von lizardpaper ausgeführt, nicht die neuen easygui-funktionnen

import random
try:
    import easygui
except:
    raise UserWarning("Please make sure easygui.py is in the same folder")
    

# general purpose functions from lizardpaper, replaced with easygui functions
def output(msg):
    easygui.msgbox(msg) # python 2.x: use "print msg" instead "print(msg)"
    
def ask(msg="Your answer please:", choices=["yes","no"]):
    return easygui.buttonbox(msg, "your answer:", choices)
    

def askname(msg="please enter your name"):
    return easygui.enterbox(msg) # python2.x: use "raw_input" instead "input"


def startmenu():
    msg = "\n"
    msg += "\n*** Welcome !***"
    msg += "\nplease choose between a classic game of 'rock, paper, scissors'"
    msg += "\nor a game of the newer variant 'rock, paper, scissors, lizard, Spock' "
    msg += "\n"
    msg += "\nsee Wikipedia for game rules and more information:"
    msg += "\nhttp://en.wikipedia.org/wiki/Rock_paper_scissors"
    msg += "\nhttp://en.wikipedia.org/wiki/Rock-paper-scissors-lizard-spock"
    msg += "\n"
    output(msg)
    mode = "x"
    mode = ask("press c for classic variant (rock, paper, scissors) \n"  \
               "press n for new variant (rock, paper, scissors, lizard, Spock \n", ["c","n"])
    if mode == "c":
        game("classic")
    elif mode == "n":
        game("new")
    
def game(mode="classic"):
    """rock paper scissor lizard spock
    mode can be new or classic"""
    # { key: human-readable key description }
    things = {"r":"rock", 
              "s":"scissors",
              "p":"paper"}
    if mode == "new": # expand only for new version
        things["l"] = "lizard"
        things["o"] = "Spock"
        
    # { victor : { victim : (victorytext loosertext) }}
    wintext = {
              "r": { "s": ("rock crushes scissors", "scissors is crushed by rock"),
                     "l": ("rock crushes lizard", "lizard is crushed by rock")},
              "s": { "p": ("scissors cut paper", "paper is cut by scissors"),
                     "l": ("scissors decapitate lizard", "lizard is decapitated by scissors")},
              "p": { "o": ("paper disproves Spock", "Spock is disproved by paper"),
                     "r": ("paper covers rock", "rock is enveloped by paper") },
              "o": { "s": ("Spock smashes scissors", "scissors are smashed by Spock"),
                     "r": ("Spock vaporizes rock", "rock is vaporized by Spock") },
              "l": { "p": ("lizard eats paper", "paper is eaten by lizard"),
                     "o": ("lizard poisons Spock", "Spock is poisoned by lizard") } 
              }
    
    question = "What do you play ? \n"
    for thingy in things.keys():
        question += thingy + ": " + things[thingy] + "\n"
    #question += "\n please press one of the keys listed above and ENTER \n" 
    mainloop = True
    rounds = 0
    # ------ generating players --------
    players = {} # name, nature, thing, points # a dict cointaining dicts ...
    while True:
        output( "At the moment, this game has %i players. Minimum to start a game is 2 players." % len(players))
        if len(players.keys()) > 0:
            output( "-- list of players in the game --")
            for player in players.keys():
                output("name: %s  type: %s" % (player, players[player]["nature"]))
        output("----")
        playername = askname("please type in the name of a new player and press ENTER \n"
                               "press only ENTER to start the game \n")
        if playername == "":
            break # exit
        natureOfPlayer = ask("is this player a (h)uman or a (c)omputer ?", ["h","c"])
        players[playername] = {"nature": natureOfPlayer , "thing": "xxx", "points":0 } # add player to dictionary
    if len(players) < 2:
        output( "you need at least 2 players to start a game. Bye !")
        return "too few players"
        
    while mainloop: # ----------- the game loop ------------    
        output( " ---- rounds played: %i ----- " % rounds )
        for player in players.keys():
            if players[player]["nature"] == "h": # human                
                playerthing = ""
                output("******** player %s, it is your turn ! *******" % player )
                playerthing = ask(question, tuple(things.keys())) # asking the player for rock, paper etc..
                players[player]["thing"] = playerthing # adding answer to dict (inside a dict)
            else: # computer player
                players[player]["thing"] = random.choice(tuple(things.keys())) # computerthing
        rounds += 1
        
        for player in players.keys(): # --- output ----
            playerthing = players[player]["thing"]
            output( "The coice of player %s is: %s " % (player, playerthing))
        for player in players.keys():         # ---- calculate winner
            output( "...calculating points for player %s..." % player)
            playerthing = players[player]["thing"]
            for enemy in players.keys():
                if player != enemy:
                    enemything = players[enemy]["thing"]
                    output( "%s of %s versus %s of %s" % (things[playerthing], player, things[enemything], enemy)  )                      
                    if playerthing == enemything:
                        output( "this is a draw (0 points)")
                    elif enemything in wintext[playerthing].keys():
                        players[player]["points"] += 1
                        output( "%s (+1 point)" % wintext[playerthing][enemything][0] ) # victory
                    else:
                        output( "%s (no point)" % wintext[enemything][playerthing][1] ) # loose
        output( "====== result (round %i) =======" % rounds   )  #------ summary -------
        for player in players.keys():
            output( "points: %i for %s" %( players[player]["points"], player) )
        output ( "------ next round -------" )
        playMore = ask("press c to continue, q to quit", ["c","q"])
        if playMore == "q":
            mainloop = False
        #print "\n\n\n" # three empty lines
    output("bye-bye")
    return 0 # (computerpoints, playerpoints)

if __name__ == '__main__':
    startmenu()



########NEW FILE########
__FILENAME__ = pycrawl
# pycrawl
# my very own rogulike game
# because i play far too much dungeon crawl stone soup
# 2012 by Horst JENS   horstjens@gmail.com
# license: gpl3 see http://www.gnu.org/copyleft/gpl.html
# this game is a part of http://ThePythonGameBook.com


# short description:
# like dungeon crawl stone soup ( see http://crawl.develz.org/wordpress/ )
# this game shall create random levels. Each level has several rooms.
# Each room is made out of tiles (blocks).
# the player start in level one and has to find the ultimate quest item
# in the deepest level (and maybe return to level one)
# each level has 3 stairs down and 3 stairs up

import random

#class Config(object):
#    """all user-changable constants for the game. ideal for modding"""


# a level consist of 8 x 8 rooms, so ROOMROOT = 8
ROOMROOT = 3 # warning, you can get an maximum recursion error if this number is too large
# a room consist of 8 x 8 blocks, so BLOCKROOT = 8
BLOCKROOT = 6
# all propabilities are roughly how much monsters , traps etc. you want per room
# values must be a bit higher because the edge of a room is made out of walls
# i want on average 4 monsters per room
P_MONSTER = 4 /  BLOCKROOT **2 # chance that an (non-wall) block is a monster
# i want on average 3 traps per room
P_TRAP = 3 /  BLOCKROOT **2 #  it is a trap
P_BOX = 0.5 / BLOCKROOT ** 2 # it is a box
P_LOOT = 0.3 / BLOCKROOT ** 2 # it is a loot
P_SHOP = 0.015 / BLOCKROOT ** 2 # it is a shop
# create a lookup table to see what an individual block should become
# the idea is to create a random number bewteen 0 and 1 and use the table
# to look up what the block is
BLOCKDICT = { P_MONSTER:"m",
              P_MONSTER+P_TRAP:"t",
              P_MONSTER+P_TRAP+P_BOX:"b",
              P_MONSTER+P_TRAP+P_BOX+P_LOOT:"l",
              P_MONSTER+P_TRAP+P_BOX+P_LOOT+P_SHOP:"s"
              }
# be careful when using floats as keys for a dict, see http://floating-point-gui.de/

BLOCKSORT = sorted(BLOCKDICT.keys()) # sorted() generates a new sorted list 

P_DOOR = 0.5 # probaility that a wall has a door
P_NOWALL = 0.05 # probability that a wall is removed to create a big hall
STAIRS = 3 # number of stairs up as well as number of stairs down per level
DEEPEST_LEVEL = 10 # the number of the deepest level, where the ultimate questitem is hidden
DOORCHARS = [".","d"] # chars for empty space and door. both allow connection between rooms
CARDINALS = ["north","south","east","west"] # the 4 possible directions for connecting rooms
# a dict for each cardinal direction: (counter-direction, dy, dx)
CARDINALSDICT = {"north":("south",-1,0),"south":("north",1,0),"east":("west",0,1),"west":("east",0,-1)}
LEGEND = {
    "X": "granite wall",
    "#": "wall",
    "d": "door",
    "t": "trap",
    "m": "monster",
    "b": "box",
    "l": "loot",
    "s": "shop",
    "w": "water",
    "f": "fire",
    ".": "emtpy",
    "<": "stair up",
    ">": "stair down",
    "p": "player",
    "q": "questitem"  }

class Room(object):
    """room, made out of BLOCKROOT x BLOCKROOT blocks (or fields).
    startpoint (1,1) is always topleft, going each line from left to right and from top to down
    cols and row start with 1, not with zero. (very un-pythonic!) 
    to avoid headache when hand-editing levels.
    And it's always row first, column second.
    """
    # some classvariables:
    roomnumber = 0  # total amount of rooms. unique number for each room
    book = {}       # dict to store all rooms. will maybe transferred into Level class in the future
    def __init__(self, level, row, col):
        """ a room in a level. row and col start with 1, not with 0 """
        self.level = level
        self.row = row
        self.col = col
        Room.roomnumber +=1
        self.roomnumber = Room.roomnumber
        #self.totalnumber = Room.totalnumber # unique number
        Room.book[(self.level, self.row, self.col)] = self  # store class instance into class dict
        self.edge = False    # possibly unnecessary..
        self.edgewest = False
        self.edgeeast = False
        self.edgenorth = False
        self.edgesouth = False
        # is this a edge room ?
        if self.row ==1:
            self.edgenorth = True
        elif self.row == ROOMROOT:
            self.edgesouth = True
        if self.roomnumber % ROOMROOT == 0:
            self.edgeeast = True
        elif self.roomnumber % ROOMROOT == 1:
            self.edgewest = True
        if self.edgewest or self.edgeeast or self.edgesouth or self.edgenorth:
            self.edge = True
        # possible directions for path. If there is a connection (door) to the next room, change to True
        self.north = False # may be also unnecessary, see Level.doors[]
        self.south = False
        self.west = False
        self.east = False
        # create outer wall
        ##self.blocks = ""
        self.blocks = {}
        for row in list(range(1,BLOCKROOT+1)):
            if row == 1 or row == BLOCKROOT :
                #upper or lower edge
                for col in list(range(1,BLOCKROOT+1)):
                    if (row == 1  and self.edgenorth) or (row == BLOCKROOT and self.edgesouth) :
                        self.blocks[row,col]="X"  # granit
                    else:
                        self.blocks[row,col]="#"  # mortar
            else:
                # middle rows
                for col in list(range(1,BLOCKROOT+1)):
                    if col == 1 or col == BLOCKROOT:
                        # generate wall left and right
                        if (col == 1 and self.edgewest) or (col == BLOCKROOT and self.edgeeast):
                            self.blocks[row,col] = "X" # granit
                        else:
                            self.blocks[row,col] = "#"  # mortar
                    else:
                        # generate  empty space or loot, traps and monsters in the middle
                        block = "." # default is the empty space
                        blockroll = random.random() # number between 0.0 and 1.0
                        for fate in BLOCKSORT:
                            # fate is sorted from 0.0 upwards. if blockroll < fate than we know the type of the block
                            if blockroll < fate:
                                block = BLOCKDICT[fate]
                                break # we found our block, do not compare fate again
                        self.blocks[row, col] = block
                                
        
        
    def make_door(self, direction):
        """create a door from one room into another room,
        the door facing direction north, south, west or east.
        also makes a corresponding door in the other room.
        return True if door was made, otherwise False
        a door can be made only vertical to a wall"""
        #check if direction is meaningful or forbidden because edge
        if self.edge:
            if direction == "west" and self.edgewest:
                return False
            elif direction == "east" and self.edgeeast:
                return False
            elif direction =="north" and self.edgenorth:
                return False
            elif direction == "south" and self.edgesouth:
                return False
        # ok, let us make the door !
        if direction == "west":
            row = random.randint(2, BLOCKROOT-1)
            #only make a door if there is a wall
            if self.blocks[row,1] != ".":
                self.blocks[row,1] = "d"
                self.west = True
                # corresponding door in other room
                Room.book[(self.level, self.row, self.col -1)].blocks[row, BLOCKROOT] = "d"
                Room.book[(self.level, self.row, self.col -1)].east = True
        elif direction == "east":
            row = random.randint(2, BLOCKROOT-1)
            if self.blocks[row, BLOCKROOT] != ".":
                self.blocks[row, BLOCKROOT] = "d"
                self.east = True
                Room.book[(self.level, self.row, self.col +1)].blocks[row, 1] = "d"
                Room.book[(self.level, self.row, self.col +1)].west = True
        elif direction == "north":
            col = random.randint(2, BLOCKROOT-1)
            if self.blocks[1,col] != ".":
                self.blocks[1,col] = "d"
                self.north = True
                Room.book[(self.level, self.row-1, self.col)].blocks[BLOCKROOT, col] = "d"
                Room.book[(self.level, self.row-1, self.col)].south = True
        elif direction == "south":
            col = random.randint(2, BLOCKROOT-1)
            if self.blocks[BLOCKROOT,col] != ".":
                self.blocks[BLOCKROOT,col] = "d"
                self.south = True
                Room.book[(self.level, self.row+1,self.col)].blocks[1,col] = "d"
                Room.book[(self.level, self.row+1,self.col)].north = True
        return True
    
    
    def destroy_wall(self, direction):
        """destroys a whole wall of a room (the corner stones are excluded)
        and the corresponding wall of the other room to create giant halls
        return True if wall was destroyed and False otherwise"""
        if self.edge:
            if direction == "west" and self.edgewest:
                return False
            elif direction == "east" and self.edgeeast:
                return False
            elif direction =="north" and self.edgenorth:
                return False
            elif direction == "south" and self.edgesouth:
                return False
         # ok, let us destroy some walls !
        if direction == "west":
            for row in list(range(2, BLOCKROOT)):
                self.blocks[row,1] = "."
                self.west = True
                # corresponding wall in other room
                Room.book[(self.level, self.row, self.col -1)].blocks[row, BLOCKROOT] = "."
                Room.book[(self.level, self.row, self.col -1)].east = True
        elif direction == "east":
            for row in list(range(2, BLOCKROOT)):
                self.blocks[row, BLOCKROOT] = "."
                self.east = True
                # corresponding wall in other room
                Room.book[(self.level, self.row, self.col +1)].blocks[row, 1] = "."
                Room.book[(self.level, self.row, self.col +1)].west = True
        elif direction == "north":
            for col in list(range(2, BLOCKROOT)):
                self.blocks[1,col] = "."
                self.north = True
                # corresponding wall in other room
                Room.book[(self.level, self.row-1, self.col)].blocks[BLOCKROOT, col] = "."
                Room.book[(self.level, self.row-1, self.col)].south = True
        elif direction == "south":
            for col in list(range(2, BLOCKROOT)):
                self.blocks[BLOCKROOT,col] = "."
                self.south = True
                # corresponding door in other room
                Room.book[(self.level, self.row+1,self.col)].blocks[1,col] = "."
                Room.book[(self.level, self.row+1,self.col)].north = True
        return True
    
    def printroom(self, verbose=True):
        """print and return a single room as string"""
        lines = ""
        for blockrow in list(range(1,BLOCKROOT+1)):
            line = ""
            for blockcol in list(range(1,BLOCKROOT+1)):
                line += self.blocks[blockrow, blockcol]
                #screen[(row, col, blockrow, blockcol)] = actualroom.blocks[blockrow, blockcol]
            lines += line + "\n"
        if verbose:
            print(lines)
        return lines
        
class Level(object):        
    book = {}
    #levelnumber = 0
    def __init__(self, number=1):
        """create level with random rooms.
        set player_position if levelnumber is 1
        set questitem if levelnumber is DEEPEST_LEVEL"""
        self.level = number
        Level.book[number] = self # store the whole class instance into a class dict
        for row in list(range(1,ROOMROOT+1)):
            for col in list(range(1,ROOMROOT+1)):
                # create rooms
                actualroom = Room(self.level, row, col)
        self.stairsup = [] # this level: row, col, blockrow, blockcol, connect to: row, col, blockrow, blockcol
        self.stairsdown = []
        #self.dirtyrooms = set() # used for pathfinding. A set has only unique items, no doublets
        #self.used_doors = 0 # check how long pathfinding is running, break if necessary
        self.doors = {}
        self.unused_doors = {}
        # create stairs
        while len(self.stairsup) < STAIRS:
            row, col, blockrow, blockcol = self.placeme()
            Room.book[(self.level, row, col)].blocks[(blockrow, blockcol)] = "<"
            #self.stairsup += 1
            self.stairsup.append((row,col, blockrow, blockcol))
        if self.level < DEEPEST_LEVEL: # the deepest level has no stairs down
            while len(self.stairsdown) < STAIRS:
                row, col, blockrow, blockcol = self.placeme()
                Room.book[(self.level, row, col)].blocks[(blockrow, blockcol)] = ">"
                #self.stairsdown += 1
                self.stairsdown.append((row,col,blockrow,blockcol))
            # some function to test that there is a valid path from stairup to stairdown
            # TODO FIXME    
            
        # remove walls and create doors between rooms
        for row in list(range(1,ROOMROOT+1)):
            for col in list(range(1,ROOMROOT+1)):
                self.doors[(row,col)] = []
                for wall in ["north","south","west","east"]:
                    if random.random() < P_NOWALL:
                        Room.book[(self.level, row, col)].destroy_wall(wall)
                    elif random.random() < P_DOOR: # if there is a wall, make door at a random position in this wall
                        #print("making door:", wall, "row",row, "col",col)
                        Room.book[(self.level, row, col)].make_door(wall)
        
        # recalculate directions now, because we have doors !
        self.recalculate_directions()
        # set player in level 1
        if self.level == 1:
            row, col, blockrow, blockcol = self.placeme()
            Room.book[(self.level, row, col)].blocks[(blockrow, blockcol)] = "p"
        # --------------- level validation -----------------
        # test if player can reach a stairdown
        #self.dirtyrooms.clear() # clear the set
        self.unused_doors = self.doors.copy() # have a fresh dict of unused doors
        
        print("initiating pathfinding...")
        if self.findpath(row, col, ">"):
            print("player can reach stair down")
            #pass
        else:
            print("player has no path to stair down")
            #raise Exception("this level is invalid. please create another one").with_traceback(tracebackobj)
            # fix this level !
            target = random.choice(self.stairsdown) # select one of the stairdowns in this level and create a path to it
            targetrow = target[0]
            targetcol = target[1]
            print("creating tunnel....")
            self.create_tunnel(row,col, targetrow, targetcol ) # create a tunnel to the target room, by making doors
        
        # set questitem in DEEPEST_LEVEL
        if self.level == DEEPEST_LEVEL:
            row, col, blockrow, blockcol = self.placeme()
            Room.book[(self.level, row, col)].blocks[(blockrow, blockcol)] = "q"
    
    def create_tunnel(self,startrow, startcol, targetrow, targetcol):
        """to make walking from startroom to targetroom possible,
        this method will create some necessary doors"""
        deltax = targetcol - startcol
        deltay = targetrow - startrow
        dx = 0
        dy = 0
        if deltax != 0:
            dx = deltax / abs(deltax) # if negative, makes -1, else, makes 1
        if deltay != 0:
            dy = deltay / abs(deltay)
        #print("I start tunneling in rwo %i col %i"%(startrow, startcol))
        for x in list(range(abs(deltax))):
            if dx == -1:
                Room.book[(self.level, startrow , startcol + x * dx)].make_door("west")
                #print('tunneling west')
            elif dx == 1:
                Room.book[(self.level, startrow , startcol + x * dx)].make_door("east")
                #print('tunneling east')
        for y in list(range(abs(deltay))):
            print("y::::row: %i col %i ynow: %i xnow: %i"%(startrow, startcol, startrow+y*dy, startcol + x * dx ))
            if dy == -1:
                # i am not sure but i feel the (x+1) is because i want to be in this room, not just
                # make a door into this room. 
                Room.book[(self.level, startrow + y * dy , startcol + (x+1) * dx)].make_door("north")
                #print('tunneling north')
            elif dy == 1:
                Room.book[(self.level, startrow + y * dy , startcol + (x+1) * dx)].make_door("south")
                #print('tunneling south')
        self.recalculate_directions() # update level map
    
    def recalculate_directions(self):
        """after importing a level from textfile,
        after generating a level, or after creating doors,
        this method is necessary to find out
        for each room if this room is connected (doors, no wall)
        to other rooms. Also find out if a room is an edge room"""
        # stuff that normally Level.__init__() does
        #self.dirtyrooms = set() # used for pathfinding. A set has only unique items, no doublets
        self.doors = {}
        # recalculate all rooms of this level
        for row in list(range(1, ROOMROOT+1)):
            for col in list(range(1, ROOMROOT+1)):
                self.doors[(row, col)] = []
                if row == 1: # north edge
                    Room.book[(self.level, row, col)].edge = True
                    Room.book[(self.level, row, col)].edgenorth = True
                elif row == ROOMROOT: # south edge
                    Room.book[(self.level, row, col)].edge = True
                    Room.book[(self.level, row, col)].edgesouth = True
                if col == 1: # west edge
                    Room.book[(self.level, row, col)].edge = True
                    Room.book[(self.level, row, col)].edgewest = True
                elif col == ROOMROOT: # east edge
                    Room.book[(self.level, row, col)].edge = True
                    Room.book[(self.level, row, col)].edgeeast = True
                for wall in ["north","south","west","east"]:
                    if Room.book[(self.level, row, col)].edge:
                        if wall == "north" and Room.book[(self.level, row, col)].edgenorth:
                            continue
                        if wall == "south" and Room.book[(self.level, row, col)].edgesouth:
                            continue
                        if wall == "west" and Room.book[(self.level, row, col)].edgewest:
                            continue
                        if wall == "east" and Room.book[(self.level, row, col)].edgeeast:
                            continue
                    # check wall for doors or empty space
                    #DOORCHARS = [".","d"]
                    if wall == "north":
                        for blockcol in list(range(1, BLOCKROOT+1)):
                            if Room.book[(self.level, row, col)].blocks[(1,blockcol)] in DOORCHARS:
                                Room.book[(self.level, row, col)].north = True
                                self.doors[(row,col)].append("north")
                                break
                    elif wall == "south":
                        for blockcol in list(range(1, BLOCKROOT+1)):
                                if Room.book[(self.level, row, col)].blocks[(BLOCKROOT,blockcol)] in DOORCHARS:
                                    Room.book[(self.level, row, col)].south = True
                                    self.doors[(row,col)].append("south")
                                    break
                    elif wall == "west":
                        for blockrow in list(range(1, BLOCKROOT+1)):
                                if Room.book[(self.level, row, col)].blocks[(blockrow, 1)] in DOORCHARS:
                                    Room.book[(self.level, row, col)].west = True
                                    self.doors[(row,col)].append("west")
                                    break
                    elif wall == "east":
                        for blockrow in list(range(1, BLOCKROOT+1)):
                                if Room.book[(self.level, row, col)].blocks[(blockrow, BLOCKROOT)] in DOORCHARS:
                                    Room.book[(self.level, row, col)].east = True
                                    self.doors[(row,col)].append("east")
                                    break
                    
                    
    def findpath(self, row, col, target=">" ):
        """returns True if there exist a path from row/col toward a target block"""
        print("finding path from %s %s to %s" %(row, col, target)) 
        if self.testroom(row, col, target):
            return True
        else:
            if len(self.unused_doors[(row,col)]) > 0:
                for direction in CARDINALS:
                    if direction in self.unused_doors[(row,col)]:
                        self.unused_doors[(row,col)].remove(direction)
                        # cardinalsdict is {dir:(counterdir, dy, dx)}
                        dx = CARDINALSDICT[direction][2]
                        dy = CARDINALSDICT[direction][1]
                        if self.findpath(row+dy, col+dx, target):
                            return True
            else:
                #self.dirtyrooms.add((row, col)) # this room is searched
                return False
            
    
                
    def testroom(self, row, col, target=">"):
        """returns True if the target ist in the room"""
        teststring = Room.book[(self.level, row, col)].printroom(False)
        if target in teststring:
            return True # valid path in same room
        else:
            return False
            
    def placeme(self):
        """returns an empty random position to place stuff"""
        target = "x" # set invalid target
        while target != ".": # as long as target is not empty space
            row = random.randint(1, ROOMROOT)
            col = random.randint(1, ROOMROOT)
            blockrow = random.randint(1, BLOCKROOT)
            blockcol = random.randint(1, BLOCKROOT)
            target = Room.book[(self.level, row, col)].blocks[(blockrow, blockcol)] 
        return row, col, blockrow, blockcol
    
    def printlevel(self, verbose=True):
        """print and return the whole level as string"""
        lines = ""
        for row in list(range(1,ROOMROOT+1)):
            for blockrow in list(range(1,BLOCKROOT+1)):
                line = ""
                for col in list(range(1,ROOMROOT+1)):
                    for blockcol in list(range(1,BLOCKROOT+1)):
                        line += Room.book[(self.level,row,col)].blocks[blockrow, blockcol]
                lines += line + "\n"
        if verbose:
            print(lines)
        return lines
    
    def exportlevel(self, filename="level.txt"):
        """dump level into an txt file"""
        f = open(filename,"w") # create file object f for writing
        f.write(self.printlevel(False))
        f.close()
    
    def importlevel(self, filename="level.txt"):
        """import a single level from file"""
        self.stairsdown = [] # stuff that __init__ does normally
        self.stairsup = []
        f = open(filename,"r") # create file object f for reading
        row = 1
        blockrow =1
        for textline in f.readlines():
            #for row in list(range(1,ROOMROOT+1)):
            #for blockrow in list(range(1,BLOCKROOT+1)):
            start = 0
            for col in list(range(1,ROOMROOT+1)):
                for blockcol in list(range(1,BLOCKROOT+1)):
                    end = start + 1
                    mychar = textline[start:end]
                    #print("mychar:",mychar)
                    Room.book[(self.level,row,col)].blocks[blockrow, blockcol] = mychar
                    start += 1 # next char
                    if mychar == ">":
                        #self.stairsdown += 1
                        self.stairsdown.append((row, col, blockrow, blockcol))
                    elif mychar == "<":
                        #self.stairsup += 1
                        self.stairsup.append((row,col,blockrow,blockcol))
            blockrow += 1
            if blockrow > BLOCKROOT:
                blockrow = 1
                row +=1
        f.close()
    
if __name__ == '__main__':
    Level(1) # create first level
    Level.book[1].printlevel()
    
    Level.book[1].exportlevel()
    #Level.book[1].importlevel()
    #Level.book[1].recalculate_directions()
    #Level.book[1].printlevel()
    #Room.book[(1,3,3)].printroom()
    
    #print(Level.book[1].doors)

########NEW FILE########
__FILENAME__ = pycrawl_actiondemo
# pycrawl_actiondemo
# my very own rogulike game
# because i play far too much dungeon crawl stone soup
# 2012 by Horst JENS   horstjens@gmail.com
# license: gpl3 see http://www.gnu.org/copyleft/gpl.html
# this game is a part of http://ThePythonGameBook.com

# this is a demo where the player (@) can interact with monsters ( battle ), traps, doors etc.
# the player can pick up and drop items. he also has an inventory
# later on, certain monsters should also be able to pick up at last one item
#




import random



class Game(object):
    """super class, contaier for all other stuff"""
    player = None # the player will instance will be stored here
    level = {} # dict with level instances key = levelnumber
    #levelnumber = 1
    score = 0
    turns = 0
    actionObjectNumber = 0 # GameObject number of those Object where an action will be performed with
    history = ""
    deadmonsters = []
    gameloop = True # if False, the game is over
    screen = None # output = None # output instance
    #            key, x, y # y from top to down, x from left to right
    dirs ={"7":(-1,-1),
                 "4":(-1, 0),
                 "1":(-1, 1),
                 "8":( 0,-1),
                 "5":( 0, 0),
                 "2":( 0, 1),
                 "9":( 1,-1),
                 "6":( 1, 0),
                 "3":( 1, 1)}  # this is a constant
    #  creating a lot of classes with methods instead ? Box(GameObject)...
    #            char : [z, short text, long text , actionlist], ...
    tiledict = { "X": ["an outer wall", "an outer wall of the level. You can not go there" ,["scribble on"]] , 
                 "#": ["an inner wall", "an inner wall. You may destroy this wall with the right tools or spells",
                       ["destroy", "scribble on"]] , 
                 ".": ["a floor tile", "an empty floor tile. Not dangerous, but boring.", ["scribble on"] ], 
                 "d": ["a door", "an open door" , ["close"]],
                 "D": ["a door", "a closed door" ,["open", "destroy"]],   
                 "<": ["a stair up", "a stair up to the previous level" , ["climb up"]],
                 ">": ["a stair down", "a stair down to the next deeper level", ["climb down"]],
                 "s": ["a shop", "a shop of a friendly merchant", ["trade with"]] ,
                 "t": ["a trap", "a dangerous trap !", ["disarm/untrap"]],
                 "m": ["a dead monster", "a dead monster. Did you kill it?", ["eat", "bury"]],
                 "?": ["a heap of loot", "a heap of loot. Feel yourself enriched" , ["kick"]],
                 "b": ["a box", "a box. You wonder what is inside. And if it is trapped", ["open", "destroy", "search/untrap"]], 
                 ":": ["a single item", "a single item. add one more item and you have a heap of loot", ["kick","pull","inspect"]],
                 "@": ["You", "the player. that is you.", ["attack"]],
                 "M": ["a living monster", "a living monster. You can kill it. It can kill you !", ["attack", "seduce", "offer item to"]],
                 "Z": ["a sleeping monster","a sleeping monster. You can kill it while it sleeps !", ["attack","push"]]
                }
    

class Level(object):
    """a representation of the current level (lots of GameObjects)
    The level instances live inside Game.level{} """

    def __init__(self, rawlevel, levelnumber):
        self.levelnumber = levelnumber 
        Game.level[self.levelnumber] = self  # store level instance into game class
        #rawmap is a list of lists of chars
        self.rawmap = list(map(list, rawlevel.split())) # at them moment all stuff
        #print(self.rawmap)
        self.rows = len(self.rawmap)  # width of the level in chars
        self.cols = len(self.rawmap[0]) # height of the level in chars
        # make real level from rawmap
        self.pos = {}
        self.stairsup = []  
        self.stairsdown = []
        for r in range(self.rows):
            for c in range(self.cols):
                self.pos[c,r] = -1 # not defined game object number # 
        self.monsterkeys = []
        self.itemkeys = []
        self.interpret_rawlevel()
        self.do_output()
        
    def do_output(self):
        #create screen for output
        Game.screen = Output(self.rows, self.cols) # create Output instance
        Game.screen.drawlevel(self.levelnumber)
        
    
    def interpret_rawlevel(self):
        """generating a 'real'  level info from the rawmap, The rawmap includes traps, walls, monster, player etc. No more random placement needed except for
        generating loot items and single items as indicated in rawmap"""
        for y in range(self.rows):
            for x in range(self.cols):
                rawchar = self.rawmap[y][x]
                if not rawchar in Game.tiledict:
                    raise UserWarning("Bad rawmap char found in rawmap but not in Games.tiledict: %s" % rawchar)
                if rawchar in "dDs#X<>": # not a floor tile but a wall 
                    # create not-floor tile
                    self.pos[(x,y)] = GameObject(x,y,self.levelnumber, rawchar).number
                    if rawchar == ">": # stair down
                        self.stairsdown.append(self.pos[(x,y)])
                    elif rawchar == "<": # stair up
                        self.stairsup.append(self.pos[(x,y)])
                else:
                    # create floor tile
                    self.pos[(x,y)] = GameObject(x,y,self.levelnumber, ".").number
                if rawchar == "@":
                    if not Game.player:
                        Game.player = Player(x, y, self.levelnumber, "@")
                    else:
                        Game.player.x = x
                        Game.player.y = y
                        Game.player.levelnumber = self.levelnumber
 
                elif rawchar in "MZ": # monster  
                    self.monsterkeys.append(Monster(x,y,self.levelnumber, rawchar).number)  
                elif rawchar in "tbm:": #item        
                    # create Item
                    self.itemkeys.append(Item(x,y,self.levelnumber, rawchar).number)
                elif rawchar == "?": # heap of random items    
                    for a in range(random.randint(2,6)):
                        self.itemkeys.append(Item(x,y,self.levelnumber,":").number)
                
    def pickup(self,x,y):
        """a list of items on this positoin, but not traps"""
        ilist = []
        for i in self.itemkeys:
            if GameObject.book[i].char != "t": # you can not pick up traps
                if GameObject.book[i].x == x and GameObject.book[i].y == y:
                    ilist.append(i)
        return ilist
    
    def inspect(self, x,y):
        """gives back a multi-line string describing the actual floor tile, neigboring tiles and all items on this floor tile"""
        t = "At x:%i y:%i l:%i you see %s.\n" % (x,y, self.levelnumber, GameObject.book[self.pos[(x,y)]].longtext )
        items = self.pickup(x,y)
        if len(items) == 0:
            t+= "There are no items laying around"
        else:
            t+= "You see there laying on the floor:\n"
            for i in items:
                t+= GameObject.book[i].longtext + "\n"
        return t
                    
    def __getitem__(self, xy):
        x,y = xy
        return self.pos[(x,y)] # stuff like [ground, itemlist, monster] ?
    
    def __setitem__(self, xy, stuff):
        x,y = xy
        self.pos[(x,y)] = stuff
     

class Output(object):
    """the ascii-map from where the actual output is generated"""
    def __init__(self, rows, cols):
        #print("rows, cols:",rows, cols)
        self.rows = rows
        self.cols = cols
        self.map = [] # self.ground_map = list(map(list, rawlevel.split()))
        # create dummy string of empty tiles
        self.map = [["." for x in range(cols)] for y in range(rows)]

        #print("map:", self.map)
    
    def drawlevel(self, levelnumber):
        level = Game.level[levelnumber]
        for y in range(level.rows):
            for x in range(level.cols):
                # ground
                char = GameObject.book[level.pos[(x,y)]].char
                # items
                itemcount = 0
                for i in level.itemkeys:
                    if GameObject.book[i].x == x and GameObject.book[i].y == y:
                        char = GameObject.book[i].char  #overwrite floor with item
                        itemcount += 1
                if itemcount > 1:
                    char = "?"
                # monsters
                for m in level.monsterkeys:
                    if GameObject.book[m].x == x and GameObject.book[m].y == y:
                        char = GameObject.book[m].char  #overwrite floor with item
                # player
                if Game.player.x == x and Game.player.y == y:
                    char = "@"
                #print("y,x",y,x)
                self.map[y][x] = char # set char    
    
    def make_screenstring(self):
        return "\n".join(self)
    
    def __iter__(self):
        return ("".join(row) for row in self.map)

    def __getitem__(self, xy):
        x, y = xy
        return self.map[y][x] # row, col

    def __setitem__(self, xy, char):
        x, y = xy
        self.map[y][x] = char # row, col


class GameObject(object):
    number = 0
    book = {}
    """each obect in the game Monster, Item, Player, Wall has some shared attributes"""
    def __init__(self, x, y, levelnumber, char, **kwargs):
        self.x = x
        self.y = y
        self.levelnumber = levelnumber
        self.number = GameObject.number
        GameObject.number += 1
        GameObject.book[self.number] = self
        self.char = char
        self.shorttext = Game.tiledict[self.char][0]
        self.longtext = Game.tiledict[self.char][1]
        self.actionlist = Game.tiledict[self.char][2]

class Item(GameObject):
    """individual Item with all attributes"""
    def __init__(self, x, y, levelnumber, char, **kwargs):
        GameObject.__init__(self,x,y,levelnumber, char, **kwargs)
        if self.char == ":": # single item
            self.longtext = self.generate_text()
        else:
            self.longtext = Game.tiledict[self.char][1]
        self.hitpoints = 0
        self.power = 0
        if self.char =="t": # trap
            self.hitpoints = 5
            self.power = random.randint(1,10)
        
            

    def generate_text(self):
        """generate a random description for this item for the very lazy coder"""
        word1 = random.choice(("a big", "a small", "a medium", "an epic", "a handsome","a rotting", "an expensive", "a cheap"))
        word2 = random.choice(("yellow", "green", "blue", "red", "white", "black","rusty", "shiny", "blood-smeared"))
        word3 = random.choice(("ring", "drink", "flower", "wand", "fruit"))
        return " ".join((word1, word2, word3)) # put space between words


class Mover(GameObject):
    """player or monster"""
    def __init__(self,x,y,levelnumber, char, **kwargs):
        GameObject.__init__(self, x,y,levelnumber, char, **kwargs)

    def trapcheck(self):
        #check if on trap and subtract hitpoints
        mylevel = Game.level[self.levelnumber]
        for ik in mylevel.itemkeys:
            mi = GameObject.book[ik]
            if mi.char == "t" and mi.x == self.x and mi.y == self.y:
                return mi.power # the damage of the trap
        return 0   # no trap, no damage
    
class Monster(Mover):
    """individual Monster"""
    def __init__(self,x,y,levelnumber, char, **kwargs):
        #GameObject.__init__(self, x,y,levelnumber, char, **kwargs)
        Mover.__init__(self, x,y,levelnumber, char, **kwargs)
        self.itemkeys = [] # list of of itemkeys that the monster carry
        self.hitpoints = 10
        self.power = 3
        self.mood = "roam"
        self.energy = random.randint(15,25)
        self.lowenergy = 10
        self.highenergy = 30
        self.hostile = False # hostile to player ?
        
    def kill(self):
        """do all the stuff necessary, like transforming yourself into a corpse etc."""
        mylevel = Game.level[self.levelnumber]
        Game.deadmonsters.append(self.number) # add my number to the graveyard
        myindex = mylevel.monsterkeys.index(self.number)
        del(mylevel.monsterkeys[myindex])
        #create dead corpse item
        mylevel.itemkeys.append(Item(self.x, self.y, self.levelnumber, "m").number)
        
        
    def update(self):
        # staying on a trap cost hitpoints
        if self.trapcheck() > 0:
            #self.msg += "Ouch! You stand on a trap and loose one hitpoint!"
            self.hitpoints -= self.trapcheck
            if self.hitpoints < 0:
                self.kill()
                  
        if self.mood == "roam":
            # move around
            self.energy -= 1 # roaming cost energy
            if self.energy < self.lowenergy:
                self.mood = "sleep"
                self.char = "Z" # sleeping Monster
             
        elif self.mood == "sleep":
            self.energy += 1 # sleeping regains energy
            if self.energy > self.highenergy:
                self.mood = "roam"
                self.char = "M" # Monster
        


    
class Player(Mover):
    """the player"""
    def __init__(self,x,y,levelnumber, char, **kwargs):
        #GameObject.__init__(self, x,y,levelnumber, char, **kwargs)
        Mover.__init__(self, x,y,levelnumber, char, **kwargs)
        self.itemkeys = [] # list of itemkeys that the player carrys
        self.hitpoints = 50
        self.power = 5
        self.msg = ""
        self.trapskill = 0.75 # between 0.0 and 1.0 It's a sucess chance for disarming traps

        
    def checkmove(self,dx, dy):
        newx = self.x + dx
        newy = self.y + dy
        newgroundcharnumber = Game.level[self.levelnumber].pos[(newx, newy)]
        newgroundchar = GameObject.book[newgroundcharnumber].char
        if newgroundchar in "#X":
            self.msg = "Moving not possible. You can not walk into %s" % Game.tiledict[newgroundchar][0]
            return False
        else:
            # check if moving into a monster
            mokeys = Game.level[self.levelnumber].monsterkeys
            for mk in mokeys:
                if GameObject.book[mk].x == newx and GameObject.book[mk].y == newy:
                    self.msg = "Moving not possible, You can not walk into a monster. Try action instead."
                    return False
            return True
    
    def statstring(self):
        """a short string with x, y, levelnumber and hitpoints"""
        return "x:%i y:%i level:%i HP:%i" % (self.x, self.y, self.levelnumber, self.hitpoints)
    
    def kill(self):
        """game over etc."""
        Game.gameloop = False
        self.msg += "You are dead and the game is over."
    
    def update(self):
        if self.trapcheck() > 0:
            self.msg += "Ouch! You stand on a trap and loose one hitpoint!"
            self.hitpoints -= self.trapcheck()
            if self.hitpoints < 0:
                self.kill()

        
    def move(self, dx, dy):
        self.x = self.x + dx
        self.y = self.y + dy
        self.msg = "Moving (dx: %i dy: %i) sucessfull" % (dx, dy)
    
    def inventory(self):
        """returns a big string listing the players inventory"""
        if len(self.itemkeys) == 0:
            return "Your inventory is empty."
        else:
            t = "You carry those items in your inventory:\n"
            for i in self.itemkeys:
                t+= GameObject.book[i].longtext + "\n"
            return t
    
    def playeractionlist(self, adx=0, ady=0): # actionlist was already used in GameObject.actionlist
        """generates a list of actions in the format: [("text describing the action", actor, victim, function), ("text,...)]"""
        x = self.x + adx
        y = self.y + ady
        li = []
        # ground tile actions
        gl = GameObject.book[Game.level[self.levelnumber].pos[(x,y)]].actionlist
        for groundaction in gl:
            li.append(( groundaction + " " + GameObject.book[Game.level[self.levelnumber].pos[(x,y)]].shorttext,self, GameObject.book[Game.level[self.levelnumber].pos[(x,y)]], groundaction))
        actionitemkeys = []
        for k in Game.level[self.levelnumber].itemkeys:
            if GameObject.book[k].x == x and GameObject.book[k].y == y:
                actionitemkeys.append(k)
        for ak in actionitemkeys:
            aklist = GameObject.book[ak].actionlist
            for aka in aklist:
                li.append(( aka + " " + GameObject.book[ak].longtext ,self, GameObject.book[ak],aka))
        monsterkeys = Game.level[self.levelnumber].monsterkeys
        actionmonsterkeys = []
        for mk in monsterkeys:
            if GameObject.book[mk].x == x and GameObject.book[mk].y == y:
                actionmonsterkeys.append(mk)
        for monsterkey in actionmonsterkeys:
            ml = GameObject.book[monsterkey].actionlist
            for action in ml:
                li.append(( action + " " + GameObject.book[monsterkey].shorttext,self,GameObject.book[monsterkey],action))
        return li # the actionlist is returned
        
    
    def pickup(self):
        foundlist = Game.level[self.levelnumber].pickup(self.x, self.y)
        if len(foundlist) == 0:
            self.msg = "i found no items here to pick up"
        else:
            for f in foundlist:
                self.itemkeys.append(f)
                i = Game.level[self.levelnumber].itemkeys.index(f)
                del Game.level[self.levelnumber].itemkeys[i]
            self.msg = "%i item(s) picked up and added to inventory" % len(foundlist)
    
    def show_inventory(self):
        """returns a big string with each itemnumber and itemdescription of the player's inventory"""
        if len(self.itemkeys) == 0:
           return "The inventory is empty!"
        t = ""
        for k in self.itemkeys:
            t += "\n" + str(k)+ " : " + GameObject.book[k].longtext 
        return t
    
    def drop(self, itemnumber):
        """drop item with itemnumber on the floor, removing it from inventory and adding it to level"""
        if itemnumber in self.itemkeys:
            # update Item x,y with player x,y
            GameObject.book[itemnumber].x = self.x
            GameObject.book[itemnumber].y = self.y
            Game.level[self.levelnumber].itemkeys.append(itemnumber)
            i = self.itemkeys.index(itemnumber)
            del self.itemkeys[i]
            self.msg = "item dropped"
        else:
            self.msg = "illegal itemnumber. dropping canceled"
    
def action(actor, victim, functionstring):
    """the actor trys to perform function on the victim
    This function is not a class method (yet) but stand-alone
    This function MUST return a msg string"""
    
    msg = "performing action now: %s \n" % functionstring
    #        -------- attack & counterattack ------- 
    if functionstring == "attack":
        damage = random.randint(0,actor.power)
        msg += "%s attack and inflict %i damage on %s (%i hitpoints left)\n" % (actor.shorttext, damage, victim.shorttext, victim.hitpoints-damage)
        if actor.shorttext == "You":
            victim.hostile = True # victim becomes hostile at player
        victim.hitpoints -= damage
        if victim.hitpoints > 0:
            damage = random.randint(0,victim.power)
            msg += "%s strike back inflicting %i damage. (%s has %i hitpoints left) \n" % (victim.shorttext, damage, actor.shorttext, actor.hitpoints-damage)
            actor.hitpoints-= damage
            if actor.hitpoints < 0:
                msg+= "% dies!" % actor.shorttext
                actor.kill()
        else:
            msg+= "%s dies!" % victim.shorttext
            victim.kill()
        return msg
    
    elif functionstring == "climb up":
        if Game.player.levelnumber == 1: # game over
            Game.gameloop = False
            msg += "You leave the dungeon crawl back into the daylight. Game Over "
            return msg
        Game.player.levelnumber -= 1    
        spawn = random.choice(Game.level[Game.player.levelnumber].stairsdown)
        Game.player.x = GameObject.book[spawn].x
        Game.player.y = GameObject.book[spawn].y
        # set new active level
        Game.level[Game.player.levelnumber].do_output()
        msg+= "You climbed down and you are now on level %i.\n" % Game.player.levelnumber
        return msg
    
    elif functionstring == "climb down":
        Game.player.levelnumber += 1
        spawn = random.choice(Game.level[Game.player.levelnumber].stairsup)
        Game.player.x = GameObject.book[spawn].x
        Game.player.y = GameObject.book[spawn].y
        # set new active level
        Game.level[Game.player.levelnumber].do_output()
        msg += "You climbed down and you are now on level %i.\n" % Game.player.levelnumber
        return msg
    
    elif functionstring == "disarm/untrap":
        # test for player trap skill 
        difficulty = random.random() # between 0.0 and 1.0 # improve! TODO
        msg += "Your trapskill: %.2f This trap: %.2f\n" % ( actor.trapskill, difficulty )
        mylevel = Game.level[Game.player.levelnumber]
        trapkey = victim.number
        i = mylevel.itemkeys.index(trapkey)
        if actor.trapskill > difficulty * 2:
            msg +="Your excellent trap skill allows you tu disarm and re-use the trap ! The trap is now in your inventory.\n"
            # remove trap from level    
            del(mylevel.itemkeys[i])
            # add trap to player inventory
            actor.itemkeys.append(victim.number)
        elif actor.trapskill > difficulty:
            msg +="You manage to disarm the trap. The trap is destroyed"
            del(mylevel.itemkeys[i])
        else:
            actor.hitpoints -= victim.power
            msg +="Ouch ! You fail at disarming and loose %i hitpoints. The trap is still dangerous.\n" % victim.power
        return msg # very important for mainloop
    
def main():
    """ the main function of the game contains the game loop and is creating / calling all the class methods"""
    
    # (later, levels will be auto-generated)
    # the first level contains a @, indicating the start position of the player
    rawlevel1 ="""\
XXXXXXXXXXXXXXXXXX
X??....?...##.?..X
X....?..:...d....X
Xtb....t..?##...>X
X.<........##..t.X
X..........##t.<.X
X....tt....dd....X
X..........##....X
X#######..####.##X
X#######..####d##X
X..........#....:X
X..b...:...##M@:?X
X.s....?...###.##X
X.t........##tt.tX
XXXXXXXXXXXXXXXXXX"""

    # the second level contains no @ ! the player is already spawned at level 1 
    rawlevel2 ="""\
XXXXXXXXXXXXXXXXXXXXXXXXX
X...<t..<t..<t..........X
X.......................X
X...ttt.................X
X...t>t...>.....>.......X
X...ttt.................X
X................b......X
X....M..................X
X..............####d####X
X......MMM.....#b.......X
X..............#..?..?..X
X..............#..s.....X
XXXXXXXXXXXXXXXXXXXXXXXXX
"""
     
     
    # init level 1
    
    mylevel = Level(rawlevel1,1) # create level number 1
    p = Game.player # the player instance is already in the game class ( made by Level) p is only to save much typing
    Level(rawlevel2, 2) # also create level 2 now
    mylevel.do_output() # # set active screen to level1 (necessary because level2 changed screen at creation time)
    print(Game.screen.make_screenstring()) # print out the active screen ( level1 )
    while Game.gameloop:
        oldlevelnumber = Game.player.levelnumber
        print("press: \nnumpad keys: move (5): wait (q)uit (p)ickup (d)rop (i)nspect (a)ction ")
        i = input("Your (%s) input?>" % p.statstring())
        i = i.lower()
        if i == "q":
           Game.gameloop = False
        elif i in Game.dirs.keys():
            dx, dy = Game.dirs[i]
            if p.checkmove(dx, dy):
                p.move(dx,dy)
                Game.screen.drawlevel(Game.player.levelnumber)
                print(Game.screen.make_screenstring())
        elif i == "p": #pickup
            p.pickup()
        elif i == "d": # drop
            print(p.show_inventory())
            i = input("enter number to drop or (c) to cancel")
            p.drop(int(i))
        elif i == "i": # inspect tile where i stand and inventory
            print("press numpad key for inspecting neighboring tile, 5 for inspecting this tile")
            i2 = input("inspect in direction? >")
            if i2 in Game.dirs:
                idx, idy = Game.dirs[i2]
                print("You are on tile x:%i y;%i and inspect x:%i y:%i" % (p.x, p.y, p.x+idx, p.y+idy))
                print(mylevel.inspect(p.x+idx, p.y+idy))
                print("----Your inventory:----")
                print(p.inventory())
                #print("----Your stats:--------")
                #print("You have %i hitpoints."% p.hitpoints)
                p.msg = "" # clear player status message
            else:
                p.msg = "unknown direction for inspecting. inspecting canceled"
            
        elif i == "a":
            print("press numpad key for action at neighboring tile, 5 for action on this tile")
            i2 = input("action direction? >")
            if i2 in Game.dirs:
                adx, ady = Game.dirs[i2]
                print("You are on tile x:%i y;%i. Choose an action to perform at x:%i y:%i" % (p.x, p.y, p.x+adx, p.y+ady))
                alist = p.playeractionlist(adx, ady) # (actionstring, actor, victim, function)
                for myaction in alist:
                    print( "%i: %s" % ( alist.index(myaction) , myaction[0]))
                print("please enter desired action number or q to cancel")
                i3 = input("action number? >")
                if not i3.lower().isnumeric():
                    p.msg = "action canceled"
                elif int(i3.lower()) not in range(len(alist)):
                    p.msg = "wrong number. action canceled"
                else:
                    selected = alist[int(i3)] # ( actiontext, actor, victim, function)
                    p.msg = "You try to perform this action: %s" % selected[0]
                    p.msg += "\n" + action(selected[1], selected[2], selected[3])
                #p.msg = "" # clear player status message
            else:
                p.msg = "unknown direction for action. action canceled"
        # ------------- update ----------
        p.update() # player is on a trap ?
        for mok in Game.level[p.levelnumber].monsterkeys:
            GameObject.book[mok].update() # update each monster
        # ------------ output -----------
        if p.msg: # if p.msg != ""
            print(p.msg)
        # force redraw when changing levels
        if oldlevelnumber != Game.player.levelnumber:
            Game.screen.drawlevel(Game.player.levelnumber)
            print(Game.screen.make_screenstring())
        
    print("game over. bye !")

if __name__ == '__main__':
    main()



## old code , use , move, and delete:

#    def __init__(self, char, **kwargs):
#        for attr in kwargs.keys(): 
#            if attr in self.__dict__:
#                self.__dict__[attr] = kwargs[attr]
#    def showStats(object):
#        """display all stats of an class instance"""
#        for key in object.__dict__:
#            print( key, ":", object.__dict__[key])




########NEW FILE########
__FILENAME__ = pycrawl_itemdemo
# pycrawl_itemdemo
# my very own rogulike game
# because i play far too much dungeon crawl stone soup
# 2012 by Horst JENS   horstjens@gmail.com
# license: gpl3 see http://www.gnu.org/copyleft/gpl.html
# this game is a part of http://ThePythonGameBook.com

# this is a demo where the player (@) runs around in some small rooms.
# the player can pick up and drop items. he also has an inventory
# later on, certain monsters should also be able to pick up at last one item
#
# there can be several Items (trap, loot etc. ) on the same x y position
# there can only be one single monster or player at the same x y position ( but several items !)
# there can only be one single floor tile ( wall, empty, shop, ladder, door) at the same x y position
#
#
# some ideas were the items are placed vertically:
# each "GameObject" belongs to one of three panes (z-axis):
# z 0 is the floor, here are empty floor tiles, walls, doors, shops 
# z 1 are the items. Items are removable, like trap, box, heap of loot, single items
# z 2 are the monsters. 
# ( i have to stop myself now and not invent pycraft, made out of blocks in 3 dimensions )
# redndering ( Output class ) is done by drawing z0, then if necessary overwriting with z1,
# then if a monster is present overwriting with z2



import random



class Game(object):
    """super class, contaier for all other stuff"""
    player = None # the player will instance will be stored here
    level = {} # dict with level instances key = levelnumber
    score = 0
    turns = 0
    history = ""
    #            key, x, y # y from top to down, x from left to right
    dirs ={"7":(-1,-1),
                 "4":(-1, 0),
                 "1":(-1, 1),
                 "8":( 0,-1),
                 "5":( 0, 0),
                 "2":( 0, 1),
                 "9":( 1,-1),
                 "6":( 1, 0),
                 "3":( 1, 1)}  # this is a constant
    #            char : [z, short text, long text ], ...
    tiledict = { "X": ["an outer wall", "an outer wall of the level. You can not go there" ] , 
                 "#": ["an inner wall", "an inner wall. You may destroy this wall with the right tools or spells"] , 
                 ".": ["a floor tile", "an empty floor tile. Not dangerous, but boring." ], 
                 "d": ["a door", "an open door" ],
                 "D": ["a door", "a closed door" ],   
                 "<": ["a stair up", "a stair up to the previous level"],
                 ">": ["a stair down", "a stair down to the next deeper level"],
                 "s": ["a shop", "a shop of a friendly merchant"] ,
                 "t": ["a trap", "a dangerous trap !"],
                 "m": ["a dead monster", "a dead monster. Did you kill it?"],
                 "?": ["a heap of loot", "a heap of loot. Feel yourself enriched" ],
                 "b": ["a box", "a box. You wonder what is inside. And if it is trapped"], 
                 ":": ["a single item", "a single item. add one more item and you have a heap of loot"],
                 "@": ["the player", "the player. that is you."],
                 "M": ["a living monster", "a living monster. You can kill it. It can kill you !"],
                 "Z": ["a sleeping monster","a sleeping monster. You can kill it while it sleeps !"]
                }
    output = None # output instance

class Level(object):
    """a representation of the current level (lots of GameObjects)
    The level instances live inside Game.level{} """

    def __init__(self, rawlevel, levelnumber):
        self.levelnumber = levelnumber 
        Game.level[self.levelnumber] = self  # store level instance into game class
        #rawmap is a list of lists of chars
        self.rawmap = list(map(list, rawlevel.split())) # at them moment all stuff
        #print(self.rawmap)
        self.rows = len(self.rawmap)  # width of the level in chars
        self.cols = len(self.rawmap[0]) # height of the level in chars
        # make real level from rawmap
        self.pos = {}
        for r in range(self.rows):
            for c in range(self.cols):
                self.pos[c,r] = -1 # not defined game object number # 
        self.monsterkeys = []
        self.itemkeys = []
        self.interpret_rawlevel()
        Game.output = Output(self.rows, self.cols)
        Game.output.drawlevel(self.levelnumber)
        
    
    def interpret_rawlevel(self):
        """generating a 'real'  level info from the rawmap, The rawmap includes traps, walls, monster, player etc. No more random placement needed except for
        generating loot items and single items as indicated in rawmap"""
        for y in range(self.rows):
            for x in range(self.cols):
                rawchar = self.rawmap[y][x]
                if not rawchar in Game.tiledict:
                    raise UserWarning("Bad rawmap char found in rawmap but not in Games.tiledict: %s" % rawchar)
                if rawchar in "dDs#X<>": # not a floor tile but a wall 
                    # create not-floor tile
                    self.pos[(x,y)] = GameObject(x,y,self.levelnumber, rawchar).number
                else:
                    # create floor tile
                    self.pos[(x,y)] = GameObject(x,y,self.levelnumber, ".").number
                if rawchar == "@":
                    if not Game.player:
                        Game.player = Player(x, y, self.levelnumber, "@")
                    else:
                        Game.player.x = x
                        Game.player.y = y
                        Game.player.levelnumber = self.levelnumber
 
                elif rawchar in "MZ": # monster  
                    self.monsterkeys.append(Monster(x,y,self.levelnumber, rawchar).number)  
                elif rawchar in "tbm:": #item        
                    # create Item
                    self.itemkeys.append(Item(x,y,self.levelnumber, rawchar).number)
                elif rawchar == "?": # heap of random items    
                    for a in range(random.randint(2,6)):
                        self.itemkeys.append(Item(x,y,self.levelnumber,":").number)
                
    def pickup(self,x,y):
        ilist = []
        for i in self.itemkeys:
            if GameObject.book[i].x == x and GameObject.book[i].y == y:
                ilist.append(i)
        return ilist
    
    def inspect(self, x,y):
        """gives back a multi-line string describing the actual floor tile, neigboring tiles and all items on this floor tile"""
        t = "You are at x: %i y:% on a %s.\n" % (x,y, GameObject.book[self.pos[(x,y)]].longtext )
        items = self.pickup(x,y)
        if len(items) == 0:
            t+= "There are no items laying around"
        else:
            t+= "You see laying on the floor:\n"
            for i in items:
                t+= GameObject.book[i].longtext + "\n"
        return t
                    
    def __getitem__(self, xy):
        x,y = xy
        return self.pos[(x,y)] # stuff like [ground, itemlist, monster] ?
    
    def __setitem__(self, xy, stuff):
        x,y = xy
        self.pos[(x,y)] = stuff
     

class Output(object):
    """the ascii-map from where the actual output is generated"""
    def __init__(self, rows, cols):
        #print("rows, cols:",rows, cols)
        self.rows = rows
        self.cols = cols
        self.map = [] # self.ground_map = list(map(list, rawlevel.split()))
        # create dummy string of empty tiles
        self.map = [["." for x in range(cols)] for y in range(rows)]

        #print("map:", self.map)
    
    def drawlevel(self, levelnumber):
        level = Game.level[levelnumber]
        for y in range(level.rows):
            for x in range(level.cols):
                # ground
                char = GameObject.book[level.pos[(x,y)]].char
                # items
                itemcount = 0
                for i in level.itemkeys:
                    if GameObject.book[i].x == x and GameObject.book[i].y == y:
                        char = GameObject.book[i].char  #overwrite floor with item
                        itemcount += 1
                if itemcount > 1:
                    char = "?"
                # monsters
                for m in level.monsterkeys:
                    if GameObject.book[m].x == x and GameObject.book[m].y == y:
                        char = GameObject.book[m].char  #overwrite floor with item
                # player
                if Game.player.x == x and Game.player.y == y:
                    char = "@"
                #print("y,x",y,x)
                self.map[y][x] = char # set char    
    
    def make_screenstring(self):
        return "\n".join(self)
    
    def __iter__(self):
        return ("".join(row) for row in self.map)

    def __getitem__(self, xy):
        x, y = xy
        return self.map[y][x] # row, col

    def __setitem__(self, xy, char):
        x, y = xy
        self.map[y][x] = char # row, col


class GameObject(object):
    number = 0
    book = {}
    """each obect in the game Monster, Item, Player, Wall has some shared attributes"""
    def __init__(self, x, y, levelnumber, char, **kwargs):
        self.x = x
        self.y = y
        self.levelnumber = levelnumber
        self.number = GameObject.number
        GameObject.number += 1
        GameObject.book[self.number] = self
        self.char = char
        self.shorttext = Game.tiledict[self.char][0]
        self.longtext = Game.tiledict[self.char][1]

class Item(GameObject):
    """individual Item with all attributes"""
    def __init__(self, x, y, levelnumber, char, **kwargs):
        GameObject.__init__(self,x,y,levelnumber, char, **kwargs)
        if self.char == ":": # single item
            self.longtext = self.generate_text()
        else:
            self.longtext = Game.tiledict[self.char][1]

    def generate_text(self):
        """generate a random description for this item for the very lazy coder"""
        word1 = random.choice(("a big", "a small", "a medium", "an epic", "a handsome","a rotting", "an expensive", "a cheap"))
        word2 = random.choice(("yellow", "green", "blue", "red", "white", "black","rusty", "shiny", "blood-smeared"))
        word3 = random.choice(("ring", "drink", "flower", "wand", "fruit"))
        return " ".join((word1, word2, word3)) # put space between words

class Monster(GameObject):
    """individual Monster"""
    def __init__(self,x,y,levelnumber, char, **kwargs):
        GameObject.__init__(self, x,y,levelnumber, char, **kwargs)
        self.itemkeys = [] # list of of itemkeys that the monster carry
        self.hitpoints = 5
        self.mood = "roam"
        self.energy = random.randint(15,25)
        self.lowenergy = 10
        self.highenergy = 30
        
    def update(self):
        if self.mood == "roam":
            # move around
            self.energy -= 1 # roaming cost energy
            if self.energy < self.lowenergy:
                self.mood = "sleep"
        elif self.mood == "sleep":
            self.energy += 1 # sleeping regains energy
            if self.energy > self.highenergy:
                self.mood = "roam"
        
    
class Player(GameObject):
    """the player"""
    def __init__(self,x,y,levelnumber, char, **kwargs):
        GameObject.__init__(self, x,y,levelnumber, char, **kwargs)
        self.itemkeys = [] # list of itemkeys that the player carrys
        self.hitpoints = 50
        self.msg = ""
        
    def checkmove(self,dx, dy):
        newx = self.x + dx
        newy = self.y + dy
        newgroundcharnumber = Game.level[self.levelnumber].pos[(newx, newy)]
        newgroundchar = GameObject.book[newgroundcharnumber].char
        if newgroundchar in "#X":
            self.msg = "Moving not possible. You can not walk into %s" % Game.tiledict[newgroundchar][0]
            return False
        else:
            return True
        
    def move(self, dx, dy):
        self.x = self.x + dx
        self.y = self.y + dy
        self.msg = "Moving (dx: %i dy: %i) sucessfull" % (dx, dy)
    
    def inventory(self):
        """returns a big string listing the players inventory"""
        if len(self.itemkeys) == 0:
            return "Your inventory is empty."
        else:
            t = "You carry those items in your inventory:\n"
            for i in self.itemkeys:
                t+= GameObject.book[i].longtext + "\n"
            return t
    
    
    def pickup(self):
        foundlist = Game.level[self.levelnumber].pickup(self.x, self.y)
        if len(foundlist) == 0:
            self.msg = "i found no items here to pick up"
        else:
            for f in foundlist:
                self.itemkeys.append(f)
                i = Game.level[self.levelnumber].itemkeys.index(f)
                del Game.level[self.levelnumber].itemkeys[i]
            self.msg = "%i item(s) picked up and added to inventory" % len(foundlist)
    
    def show_inventory(self):
        """returns a big sting with each itemnumber and itemdescription of the player's inventory"""
        if len(self.itemkeys) == 0:
           return "The inventory is empty!"
        t = ""
        for k in self.itemkeys:
            t += "\n" + str(k)+ " : " + GameObject.book[k].longtext 
        return t
    
    def drop(self, itemnumber):
        """drop item with itemnumber on the floor, removing it from inventory and adding it to level"""
        if itemnumber in self.itemkeys:
            # update Item x,y with player x,y
            GameObject.book[itemnumber].x = self.x
            GameObject.book[itemnumber].y = self.y
            Game.level[self.levelnumber].itemkeys.append(itemnumber)
            i = self.itemkeys.index(itemnumber)
            del self.itemkeys[i]
            self.msg = "item dropped"
        else:
            self.msg = "illegal itemnumber. dropping canceled"
    


def main():
    """ the main function of the game contains the game loop and is creating / calling all the class methods"""
    
    rawlevel ="""\
XXXXXXXXXXXXXXXXXX
X??....?...##.?..X
X....?..:...d....X
Xtb....t..?##...>X
X.<........##..t.X
X..........##t.<.X
X....tt....dd....X
X..........##....X
X#######..####.##X
X#######..####d##X
X..........#....:X
X..b...:...##M@:?X
X.s....?...######X
X.t........##tt.tX
XXXXXXXXXXXXXXXXXX"""
     
     
     
    # init level 1
    ln = 1 # LevelNumber
    mylevel = Level(rawlevel, ln)
    p = Game.player
    print("output:")
    print(Game.output.make_screenstring())
    gameloop = True
    while gameloop:
        print("press: \n(numpad keys): move (q): quit (p): pickup (d): drop (i): inspect")
        i = input(">")
        i = i.lower()
        if i == "q":
           gameloop = False
        elif i in Game.dirs.keys():
            dx, dy = Game.dirs[i]
            if p.checkmove(dx, dy):
                p.move(dx,dy)
                Game.output.drawlevel(ln)
                print(Game.output.make_screenstring())
        elif i == "p": #pickup
            p.pickup()
        elif i == "d": # drop
            print(p.show_inventory())
            i = input("enter number to drop or (c) to cancel")
            p.drop(int(i))
        elif i == "i": # inspect tile where i stand and inventory
            print(mylevel.inspect(p.x, p.y))
            print(p.inventory())
        if p.msg: # if p.msg != ""
            print(p.msg)
    print("game over. bye !")

if __name__ == '__main__':
    main()



## old code , use , move, and delete:

#    def __init__(self, char, **kwargs):
#        for attr in kwargs.keys(): 
#            if attr in self.__dict__:
#                self.__dict__[attr] = kwargs[attr]
#    def showStats(object):
#        """display all stats of an class instance"""
#        for key in object.__dict__:
#            print( key, ":", object.__dict__[key])




########NEW FILE########
__FILENAME__ = pycrawl_monsterdemo
# pycrawl_monsterdemo
# my very own rogulike game
# because i play far too much dungeon crawl stone soup
# 2012 by Horst JENS   horstjens@gmail.com
# license: gpl3 see http://www.gnu.org/copyleft/gpl.html
# this game is a part of http://ThePythonGameBook.com

# this is a demo where the player (@) runs around in some small rooms.
# monsters are placed in the level and are also running around
# monsters have a primitive state machine (moods): if they run around some time, they get tired and sleep for a while

import random


mylevel ="""\
XXXXXXXXXXXXXXXXXX
XMl....M...##.M..X
X....M......d....X
Xtb....t..l##...>X
X.<........##..t.X
X..........##t.<.X
X....tt....dd....X
X..........##....X
X#######..####.##X
X#######..####d##X
X..........##.M.lX
X..b...M...##..@.X
X.s....M...##...tX
X.t........##.t..X
XXXXXXXXXXXXXXXXXX\
"""



class Tile(object):
    """the level or map is made out of ascii tiles. the properties of the tiles are defined here"""
    tiledict = {} # a dict for all the different tiles
    def __init__(self, char, **kwargs):
        self.char = char
        self.text = ""
        #Tile.tileset.add(char) # put this new Tile into the tileset
        Tile.tiledict[char] = self # put this new Tile into the tiledict
        self.stepin = True # can the player step into this tile ? walls, fire etc: False
        #self.interact = False
        self.action = [] # possible actions on this tile
        self.description = "" # text to be displayed
        self.moveable = False
        self.monster = False
        self.blocksight = False # if the line of sight is blocked by this tile (like a wall) or not (like a trap or floor)
        self.attackable = False
        
        for attr in kwargs.keys(): 
            if attr in self.__dict__:
                self.__dict__[attr] = kwargs[attr]
                
    def showStats(object):
        """display all stats of an class instance"""
        for key in object.__dict__:
            print( key, ":", object.__dict__[key])

Tile("@", text="the player", description = "the player. that is you.", attackable = True, stepin = False, action = ["write grafitti"], blocksight=True)
Tile("X", text="an outer wall",  description = "an outer wall of the level. You can not go there", stepin = False, action = ["write grafitti"], blocksight=True)
Tile(".", text="an empty space", description = "an empty boring space. There is really nothing here.")
Tile("d", text="a door", description = "an (open) door", action=["open","close"])
Tile("m", text="a dead monster", description = "a dead monster. Did you kill it?", action=["eat","gather trophy"])
Tile("M", text="a living monster", attackable = True, stepin = False, monster=True, description = "a living monster. You can kill it. It can kill you !", action=["attack","feed","talk"])
Tile("Z", text="a sleeping monster", monster=True, attackable = True, stepin = False, description = "a sleeping monster. You can kill it while it sleeps !", action=["attack","feed","talk"])
Tile("<", text="a stair up", description = "a stair up to the previous level", action = ["climb up"])
Tile(">", text="a stair down", description = "a stair down to the next deeper level", action = ["climb down"])
Tile("#", text="an inner wall", description = "an inner wall. You may destroy this wall with the right tools or spells", stepin = False, blocksight = True)
Tile("t", text="a trap", description = "a dangerous trap !", action = ["disarm", "destroy", "flag"])
Tile("l", text="a heap of loot", description = "a heap of loot. Sadly, not yet programmed. But feel yourself enriched", action=["pick up"])
Tile("b", text="a box", description = "a box. You wonder what is inside. And if it is trapped", action=["force open", "check for traps"])
Tile("s", text="a shop", descriptoin = "a shop of a friendly merchant", action=["go shopping"])



class Level(object):
    """the Level object is created with a map string and has elegant methods
    to get an specific tile (at position x,y) or set an specific tile or
    to return the whole level"""
    number = 0
    book = {}
    def __init__(self, rawlevel):
        Level.number += 1
        self.number = Level.number
        Level.book[self.number] = self # store itself into Level.book
        self.level_map = list(map(list, rawlevel.split()))
        self.rows = len(self.level_map)  # width of the level in chars
        self.cols = len(self.level_map[0]) # height of the level in chars
        print(self.level_map, self.rows, self.cols)
        
    def __getitem__(self, xy):
        """get the char at position x,y (x,y start with 0)"""
        x, y = xy
        return self.level_map[y][x] # row, col 

    def __setitem__(self, xy, item):
        """ x (col) and y (row) position of char to set. (x and y start with 0)"""
        x, y = xy
        self.level_map[y][x] = item # row, col

    def __iter__(self):
        """iterating over the lines of the level"""
        return ("".join(row) for row in self.level_map)

    def __str__(self):
        """calling __iter__ (row for row) to produce one big output string"""
        return "\n".join(row for row in self)
    


class MovingObject(object):
    """anything that moves, like a player, a monster or an arrow"""
    number = 0 # unique number for each  moving object
    book = {} # the big book of moving objects where each monster/player instance will be stored
    
    def __init__(self, char, x, y, levelnumber):
        """create moveable object"""
        MovingObject.number += 1                # get unique number from class variable
        self.number = MovingObject.number
        MovingObject.book[self.number] = self   # store yourself into class dict ( book )
        self.char = char
        self.x = x # position
        self.y = y
        self.dx = 0  # speed
        self.dy = 0
        self.levelnumber = levelnumber
        self.original = Level.book[self.levelnumber][self.x,self.y] # the char of the tile where i was standing on
        self.paint()
     
    def update(self):
        #pass # this method is only here to be overwritten by child objects.
        self.clear()   # correct movement with restoring original floor tiles
        self.x += self.dx
        self.y += self.dy
        self.original = Level.book[self.levelnumber][self.x, self.y]
        self.paint()
        
    def clear(self):
        """clear myself and restore the original char of the level map on my position"""
        Level.book[self.levelnumber][self.x,self.y] = self.original
        
    def paint(self):
        Level.book[self.levelnumber][self.x,self.y] = self.char
        
    def checkmove(self, dx, dy):
        """test if moving into direction dx and dy is possible (not a wall). if yes, return True, else, return False"""
        if dx == 0 and dy == 0:
            #no move, that is always allowed:
            return True
        else:
            targetchar = Level.book[self.levelnumber][self.x + dx, self.y + dy] # the char where i want to go into (hopefully not a wall)
            if Tile.tiledict[targetchar].stepin: # allowed move
                #print("i want to go dx %i dy %i to %i, %i (%s)"% (dx, dy, self.x+dx, self.y+dy, targetchar))
                return True
            else:
                return False
  
    
    
class Monster(MovingObject):
    """Monster class. monster have hitpoints and a state ( attack, roam, sleep, flee)"""
    #number = 0 # unique number for each monster
    #book = {} # the big book of monsters where each monster instance will be stored
    def __init__(self, char, x, y, levelnumber, **kwwargs):
        MovingObject.__init__(self, char, x, y, levelnumber) # calling parent object method)
        #self.char = char # char is already stored in MovingObject !
        self.shortname = "a monster"
        self.hitpoints = 10
        self.moods = ["sleep", "roam", "attack", "flee", "dead"]
        self.mood = random.choice(self.moods[0:2])
        self.sensorradius = 4 # aggro. how close the player must come to get the monster's attention
        self.energy = random.randint(1,100) # below 30, monster want to sleep, above 50, monster is awake
    
    def update(self):
        # loose hitpoints if on a trap
        if self.hitpoints <= 0:
            # monster is dead
            self.mood = "dead"
            self.char = "m"
            self.dx = 0
            self.dy = 0
            
        else:
            # alive monster
            #print("my energy:", self.energy, "my char:", self.char)
            if self.original == "t":
                # i'm on a trap !
                self.hitpoints -= 1
                #self.mood = "roam" # force roaming so that monster does not sleep on traps
                
            if self.mood == "sleep": # monster is sleeping
                self.char = "Z"
                self.dx = 0
                self.dy = 0
                self.energy += 1 # sleeping regains energy
                if self.energy > 50:
                    self.mood = "roam"
            else:                     # monster is awake
                self.char = "M"
                while True:
                    self.dx = random.choice((-1,0,1)) 
                    self.dy = random.choice((-1,0,1))
                    if self.checkmove(self.dx, self.dy):
                        break
                #self.move(self.dy, self.dy) # ???
                self.energy -= 1 # to be active makes the monster tired
                if self.energy < 30:
                    self.mood = "sleep"
        MovingObject.update(self)

class Player(MovingObject):
    """The player is much like a monster also a moving object"""
    def __init__(self, char, x, y, levelnumber):
        MovingObject.__init__(self, char, x, y, levelnumber)
        # i'm sexy and i know it - all my core values like x, y are already stored in MovingObjects
        self.hitpoints = 100
            
    def update(self):    
        # change stats like hungry, healing etc here
        #pass # as none of that is coded i need at least a pass statement or the update method would not work
        if self.original == "t":
            # i'm on a trap !
            self.hitpoints -= 1
        MovingObject.update(self)    
    
    def postext(self):
        return  "You (@) are at position %i, %i on %s with %i hitpoints. press:" % ( self.x, self.y, Tile.tiledict[self.original].text, self.hitpoints)
    
    def badmove(self, dx, dy):
        return "Bad idea! you can not walk into %s" % Tile.tiledict[Level.book[self.levelnumber][self.x + dx, self.y + dy]].text
    
    
def main():
    """ a demo to move the player in an ascii level map"""
    
    firstlevel = Level(mylevel) # creating the level from raw file
    
    for y in range(firstlevel.rows): # rows is the real number of rows (from len()). range start with 0 and stop with y. it's o.k.
        for x in range(firstlevel.cols):
            print("xy:",x,y)
            block = firstlevel[x,y]
            if block == "M": # monster in raw map
                firstlevel[x,y] = "."  # replace with floor
                Monster("M", x, y, firstlevel.number) # create monster
            elif block == "@":
                firstlevel[x,y] = "." # replace with floor
                player = Player("@",x,y,firstlevel.number)
                    
    
    print(firstlevel) # first time printing
    showtext = True # for inside the while loop
    
    while True: # game loop
        # output situation text
        #postext = player.postext()
        actions = Tile.tiledict[player.original].action # get the actionlist for this tile
        if len(actions) == 0:
            actiontext = "(no action possible)\n"
        else:
            actiontext = "for action: a and ENTER\n"
        # input
        inputtext = "to move (wait): numpad 84269713 (5) and ENTER\n" \
                  "%sto get more a more detailed description: d and ENTER\nto quit: q and ENTER] :" % actiontext
        if showtext: # avoid printing the whole text again for certain answers (action, description etc.)
            print(player.postext())
            print(inputtext)
        i = input(">")
        i = i.lower()
        if "q" in i:
            break
        elif i == "4" : # west
            dx = -1
            dy = 0
        elif i  =="6": # east
            dx = 1
            dy = 0
        elif i == "8": # north
            dx = 0
            dy = -1
        elif i == "2": #south
            dx = 0
            dy = 1
        elif i == "1": # south-west
            dx = -1
            dy = 1
        elif i == "7": # north-west
            dx = -1
            dy = -1
        elif i == "9": # north-east
            dx = 1
            dy = -1
        elif i =="3": # south-east
            dx = 1
            dy = 1
        elif i == "5": # wait
            dx = 0
            dy = 0

        # ------- non-moving actions ---------
        elif i == "d":
            showtext = False
            print("--------- more detailed description -------")
            print("This is",Tile.tiledict[original].description)
            print("------ ----- -------- --------- -----------")
            continue # go to the top of the while loop
        elif len(actions) > 0 and i =="a":
            showtext = False
            print("Those are the possible actions (not yet coded, you can only look at it:)")
            print("------ list of possible actions -------")
            for action in actions:
                print(actions.index(action), action)
            print("------ ----- -------- --------- -------")
            continue # go to the top of the while loop
        else:
            print("unknown input. please enter q for quit or numpad 84261379 for moving")
            continue
        # --------- move the player --------------
        if player.checkmove(dx,dy):
            player.dx = dx
            player.dy = dy
            #player.update() not needed because the player isupdated with all movingobjects some lines below
            #player.move(dx,dy)
        else:
            print( player.badmove(dx,dy))
            showtext = False
            continue
        showtext = True
        # update (move) all moveableobjects (monsters)
        for mo in MovingObject.book.keys():
            Monster.book[mo].update()
        # output level
        print(firstlevel)
        if player.hitpoints <= 0:
            print("you are dead. try to avoid traps in the future")
            break
if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = pycrawl_walkdemo
# pycrawl_walkdemo
# my very own rogulike game
# because i play far too much dungeon crawl stone soup
# 2012 by Horst JENS   horstjens@gmail.com
# license: gpl3 see http://www.gnu.org/copyleft/gpl.html
# this game is a part of http://ThePythonGameBook.com

# this is a demo where the player (@) runs around in some small rooms.
# each tile (block) where the player stands should be saved and drawn again as soon as the player moves away

# 3 x 3 roooms with 8 x 8 tiles



#ROOMROOT = 3
#BLOCKROOT = 6
rawlevel ="""\
XXXXXXXXXXXXXXXXXX
X.l..##....dd.m..X
X...m##>...##..m.X
Xtb.m##t..l##...>X
X.<..dd....ddm.t.X
########d#d#######
########d#d#######
X...>##....##....X
X....dd....ddt.<.X
X...mdd...m##....X
X....##.m..##....X
####d#########d###
####d#########d###
X....##..m.##...lX
Xmmb.dd<m..dd...mX
X.s..##..m.##....X
X.t..##m...##...mX
XXXXXXXXXXXXXXXXXX\
"""



class Tile(object):
    """the level or map is made out of ascii tiles. the properties of the tiles are defined here"""
    tiledict = {} # a dict for all the different tiles
    def __init__(self, char, **kwargs):
        self.char = char
        self.text = ""
        #Tile.tileset.add(char) # put this new Tile into the tileset
        Tile.tiledict[char] = self # put this new Tile into the tiledict
        self.stepin = True # can the player step into this tile ? walls, fire etc: False
        #self.interact = False
        self.action = [] # possible actions on this tile
        self.description = "" # text to be displayed
        self.moveable = False
        
        for attr in kwargs.keys(): 
            if attr in self.__dict__:
                self.__dict__[attr] = kwargs[attr]
                
    def showStats(object):
        """display all stats of an class instance"""
        for key in object.__dict__:
            print( key, ":", object.__dict__[key])

Tile("X", text="an outer wall", description = "an outer wall of the level. You can not go there", stepin = False, action = ["write grafitti"])
Tile(".", text="an empty space", description = "an empty boring space. There is really nothing here.")
Tile("d", text="a door", description = "an (open) door", action=["open","close"])
Tile("m", text="an suspicious space", description = "monster placeholder. You have the feeling this place belongs to a monster, but you can not see it yet")
Tile("<", text="a stair up", description = "a stair up to the previous level", action = ["climb up"])
Tile(">", text="a stair down", description = "a stair down to the next deeper level", action = ["climb down"])
Tile("#", text="an inner wall", description = "an inner wall. You may destroy this wall with the right tools or spells", stepin = False)
Tile("t", text="a trap", description = "a dangerous trap !", action = ["disarm", "destroy", "flag"])
Tile("l", text="a heap of loot", description = "a heap of loot. Sadly, not yet programmed. But feel yourself enriched", action=["pick up"])
Tile("b", text="a box", description = "a box. You wonder what is inside. And if it is trapped", action=["force open", "check for traps"])
Tile("s", text="a shop", descriptoin = "a shop of a friendly merchant", action=["go shopping"])

#print(" - - - -  tiles - - - - ")
#for tile in Tile.tiledict.keys():
#    Tile.tiledict[tile].showStats()


class Level(object):
    """the Level object is created with a map string and has elegant methods
    to get an specific tile (at position x,y) or set an specific tile or
    to return the whole level"""
    def __init__(self, level):
        self.level_map = list(map(list, level.split()))

    def __getitem__(self, xy):
        """get the char at position x,y (x,y start with 0)"""
        x, y = xy
        return self.level_map[y][x] # row, col 

    def __setitem__(self, xy, item):
        """ x (col) and y (row) position of char to set. (x and y start with 0)"""
        x, y = xy
        self.level_map[y][x] = item # row, col

    def __iter__(self):
        """iterating over the lines of the level"""
        return ("".join(row) for row in self.level_map)

    def __str__(self):
        """calling __iter__ (row for row) to produce one big output string"""
        return "\n".join(row for row in self)


def main():
    """ a demo to move the player in an ascii level map"""
    #print(' the "raw" level without player and monsters')
    #print(rawlevel)
    #print( " now the player comes into the level at pos row 9 col 9")
    firstlevel = Level(rawlevel) # creating the level from raw file
    # coordinates of player (x,y)
    pcol = 8
    prow = 8
    # saving the original tile so that we can draw it again later or the player will become a snake and pollute the level
    original = firstlevel[pcol,prow] # saving the tile where the player will soon be
    firstlevel[pcol,prow] = "@" # set the player to this coordinate
    print(firstlevel) # first time printing
    firstlevel[pcol,prow] = original # clean up after printing, restore the original tile at player position
    showtext = True # for inside the while loop
    while True: # game loop
        # output situation text
        postext = "You (@) are at position %i, %i on %s. press:" % ( pcol, prow, Tile.tiledict[original].text)
        actions = Tile.tiledict[original].action # get the actionlist for this tile
        if len(actions) == 0:
            actiontext = ""
        else:
            actiontext = "for action: a and ENTER\n"
        # input
        inputtext = "to move: numpad 8426 or nwso and ENTER\n" \
                  "%sto get more a more detailed description: d and ENTER\nto quit: q and ENTER] :" % actiontext
        if showtext: # avoid printing the whole text again for certain answers (action, description etc.)
            print(postext)
            print(inputtext)
        i = input(">")
        i = i.lower()
        if "q" in i:
            break
        elif i == "4" or i =="w":
            if Tile.tiledict[firstlevel[pcol-1, prow]].stepin:
                pcol -= 1
            else:
                print("Bad idea! you can not walk into %s" % Tile.tiledict[firstlevel[pcol-1, prow]].text)
                showtext = False
                continue
        elif i  =="6" or i =="e":
            if Tile.tiledict[firstlevel[pcol+1, prow]].stepin:
                pcol += 1
            else:
                print("Bad idea! you can not walk into %s" % Tile.tiledict[firstlevel[pcol+1, prow]].text)
                showtext = False
                continue                
        elif i == "8" or i =="n":
            if Tile.tiledict[firstlevel[pcol, prow-1]].stepin:
                prow -= 1 # y goes from top to down
            else:
                print("Bad idea! you can not walk into %s" % Tile.tiledict[firstlevel[pcol, prow-1]].text)
                showtext = False
                continue                
        elif i == "2" or i =="s":
            if Tile.tiledict[firstlevel[pcol, prow+1]].stepin:            
                prow += 1
            else:
                print("Bad idea! you can not walk into %s" % Tile.tiledict[firstlevel[pcol-1, prow+1]].text)
                showtext = False
                continue
        elif i == "d":
            showtext = False
            print("--------- more detailed description -------")
            print("This is",Tile.tiledict[original].description)
            print("------ ----- -------- --------- -----------")
            continue # go to the top of the while loop
        elif len(actions) > 0 and i =="a":
            showtext = False
            print("Those are the possible actions (not yet coded, you can only look at it:)")
            print("------ list of possible actions -------")
            for action in actions:
                print(actions.index(action), action)
            print("------ ----- -------- --------- -------")
            continue # go to the top of the while loop
        else:
            print("please enter q for quit or 8426 or nwso for directions")
            continue
        showtext = True 
        original = firstlevel[pcol,prow] # saving the original tile ( __getitem__ )
        #print("original:", original)
        firstlevel[pcol, prow] = "@" # set new player positionxy ( __setitem__ )
        # output level
        print(firstlevel)
        # replace player position with the original tile 
        firstlevel[pcol,prow] = original
if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = schimpfen
# -*- coding: utf-8 -*-
import random as r

e=["ungewaschen", "verseucht", "fett", "ausgekotzt", "zickig", "großmäulig", "hirnverbrannt",
   "breiförmig", "dauerrülpsend","nervig","ekelerregend","kopflos","blöd","vertrottelt"]
m=["Bock","Wurm","Esel","Nasenbär","Rotzlöffel","Volltrottel","Pfosten","Koffer"]
w=["Sau","Motte","Schlange","Blindschleiche","Wanze","Laus","Ratte",
   "Zimtzicke","Nacktschnecke","Giftspinne","Schreckschraube"]
s=["Trampeltier","Stinktier","Faultier"]
q=["sehr","titanisch","unerträglich","unglaublich","alptraumhaft",
   "außerirdisch","äußerst","absolut","voll","gigantisch"]

# männlich, weiblich oder sächlich ?
for x in range(10):
	geschlecht = r.choice("mmmmmwwwwwwwwws")
	if  geschlecht == "m":
		endung = "er"
		hauptwort = r.choice(m)
	elif  geschlecht == "w":
		endung = "e"
		hauptwort = r.choice(w)
	else:
		endung = "es"
		hauptwort = r.choice(s)

	eigenschaft = r.choice(e) + endung
	qa = r.choice(q)
	satz = "Du {} {} {}!".format(qa,eigenschaft, hauptwort)

	print satz

########NEW FILE########
__FILENAME__ = simplerpg
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       simplerpg.py
#       
#       2012 by Horst JENS <horst.jens@spielend-programmieren.at>
#       part of http://ThePythonGameBook.com
#
#       a simple role-playing game, inspired by rogue-like games
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 3 of the License, or
#       (at your option) any later version.
#       see http://www.gnu.org/licenses/gpl.html for GNU General Public License


import random 

# some classes

class BaseObject(object):
    """the common grandfather of all classes in this game"""
    def parameter2attribute(self, **kwargs):
        """setting the attributes of the class instance to existing
           keywords (**kwargs) / parameters"""
        for attr in kwargs.keys():
            if attr in self.__dict__:
                self.__dict__[attr] = kwargs[attr]


class Monster(BaseObject):
    number = 0 # a counter for all monsters
    _book = {}  # a dictionary to hold all monsters
    def __init__(self, **kwargs):
        """to create a new monster:
           mymonster = Monster(str = 7, race="orc")"""
        #print "---- a new monster is born ---"
        Monster.number += 1
        self.number = Monster.number
        Monster._book[self.number] = self
        self.strength = 10 # default value, influence damage afflicted to others
        self.dexterity = 10 # default value, influence chance to attack first
        self.intelligence = 10 
        self.gold = 0
        #self.score = 0 # only relevant for player
        self.hitpoints = 10 # default value, how much damage can be taken
        self.race = "unknow"
        self.name = "x"
        self.activeWeapon = 0
        self.activeShield = 0
        self.activeArmor = 0 # body armor
        self.activeHelm = 0
        self.activeShoe = 0
        self.activeGlove = 0
        self.activeMisc1 = 0
        self.activeMisc2 = 0
        self.activeMisc3 = 0
        self.activeMisc4 = 0
        self.attack = 0 # default value, chance to sucessful hit opponent
        self.defense = 0 # default value, chance to evade attack
        self.protection = 0 # default value, how much damage can be negated
        self.parameter2attribute(**kwargs) # a method of parent class BaseObject
        

class Item(BaseObject):
    number = 0 # unique number for each item
    book = {}  # book to hold all Items
    def __init__(self, **kwargs):
        """to create an item in the game, code:
           mybox = Item(shortdescr="box",
                       longdescr="a wooden, locked box", weight=50)"""
        Item.number += 1
        self.number = Item.number
        Item.book[self.number] = self
        self.value = 0
        self.weight = 0
        self.category = ""
        self.shortdescr = ""
        self.longdescr = ""
        self.MeleeWeapon = False
        self.shield = False
        self.armor = False
        self.parameter2attribute(**kwargs) # a method of parent class BaseObject
    
    
class MeleeWeapon(Item):
    def __init__(self, **kwargs):
        """to create a MeleeWeapon, code (like an item):
            mysword = MeleeWeapon(shortdescr="sword", attack = 7)"""
        Item.__init__(self, **kwargs)
        self.MeleeWeapon = True
        self.attack = 0
        self.defense = 0
        self.damage = 0
        self.length = 0 # melee attacking with a shorter weapon faces a repel action (max. 1 damage)
        self.parameter2attribute(**kwargs)
        
    
# some functions
def showStats(object):   # this should maybe a method of baseobject ?
    """display all stats of an class instance"""
    for key in object.__dict__:
        print key, ":", object.__dict__[key]
        
def domDice(sides = 6, minValue = 1):
    """an open-ended dice, inspired from the game Dominions3 by Illwinter.
       Basically, if the highest side of the dice is thrown, the score 
       of (sides-1) is kept and the dice is throwed again, adding the new score.
       This means there is a very low probaility of a very high throw"""
    if not minValue < sides:
        raise UserWarning, "minValue (%i) must be smaller than sides (%i)" % (minValue, sides)
    #score = 0
    eyes = random.randint(minValue, sides) # number of eyes facing us on the dice after throwing
    if eyes == sides:
        eyes = sides - 1 + domDice(sides, minValue) # recursion
    return eyes 
    
def dice(sides=6, minValue = 1):
    """a conventional dice"""
    if not minValue < sides:
        raise UserWarning, "minValue (%i) must be smaller than sides (%i)" % (minValue, sides)
    return  random.randint(minValue, sides)

def multiDice(dices=2, dicetype="domDice", sides=6, minValue=1):
    """throw several dices and return the sum of the eyes
       accept several dicetypes:
       dice
       domDice"""
    eyes = 0
    for _ in range(dices): 
        if dicetype == "dice":
            eyes += dice(sides, minValue)
        elif dicetype == "domDice":
            eyes += domDice(sides, minValue)
    return eyes
        
def meleeAction(attacker, defender, repeldamage=False):
    """the attacker slashes at the defender
       if this is a repel action (for attacking with a shorter MeleeWeapon)
       then the damage is limited to 1 hitpoint"""
    attDice = multiDice()
    defDice = multiDice()
    attWeapon = MeleeWeapon.book[attacker.activeMeleeWeapon].attack
    defWeapon = MeleeWeapon.book[defender.activeMeleeWeapon].defense
    attackValue =  attacker.attack +  attWeapon + attDice 
    defendValue =  defender.defense + defWeapon + defDice
    #---
    damDice = multiDice(1) # fewer influence of random than at attack vs. defense (1 dice vs. 2 dice)
    protDice = multiDice(1)   
    #protDice = 0  # no random bonus for armor !!
    damWeapon = MeleeWeapon.book[attacker.activeMeleeWeapon].damage
    damageValue =     attacker.strength + damWeapon + damDice
    protectionValue = defender.protection + protDice # Shield ????????
    damage = damageValue - protectionValue
    #---
    textlines = []
    # hit or miss ?
    if attackValue > defendValue:
        if repeldamage:
            w1 = "..Ouch!!"
            w2 = "'s repel action"
        else:
            w1 = "Whamm!"
            w2 = ""
        textlines.append("%s %s%s (%i+%i+%i)  hits %s (%i+%i+%i) with %i:%i!"  % (
            w1, attacker.name, w2, attacker.attack, attWeapon, attDice,
            defender.name, defender.defense, defWeapon, defDice, attackValue,
            defendValue))
            
        # damage calculation
        if repeldamage:
            w1 = "..repel damage"
            w2 = ""
            if damage > 0:
                w3 = "1 max. repel"
            else:
                w3 = "no repel"
        else:
            w1 = ".damage"
            w2 = ""
            if damage >0:
                w3 = str(damage) 
            else:
                w3 = "no"
        textlines.append( "%s (%i+%i+%i)%s minus protection (%i+%i) is %i-%i=%s damage" % (w1, 
            attacker.strength, damWeapon, damDice, w2, defender.protection, protDice,
            damageValue, protectionValue, w3))   
      
        if damage > 0:
            if repeldamage:
                damage = 1  # repel can cause at max 1 hitpoint damage
                defender.hitpoints -= damage 
                textlines.append( "..Repel action sucess ! %s looses one hitpoint  (%i left)" % (defender.name, defender.hitpoints))
                
            else: # non-repel damage
                textlines.append(  "..%s is hit for %i damage (%i hitpoints remaining)" % (defender.name, damage,
                    defender.hitpoints-damage) )
                defender.hitpoints -= damage  # alter hitpoints
            if defender.hitpoints <= 0:
                textlines.append( "...%s dies !" % defender.name)
        else:
            if repeldamage:
                textlines.append( "..the repel action fails to penetrate the attackers armor")
            else:
                textlines.append( "..but can not penetrate his armor")
    else:
        # def > att
        damage = 0 # 
        if repeldamage:
            w1 = "dodge"
            w2 = "repel action"
        else:
            w1 = "evade"
            w2 = "attack"
        textlines.append( "... but %s can %s (%i+%i+%i) the %s (%i+%i+%i) with %i:%i" % (defender.name,
            w1, defender.defense, defWeapon, defDice, w2, attacker.attack, attWeapon, attDice,
            defendValue, attackValue))
    # ---- end of function --
    for line in textlines:
        print line
    return damage, textlines   # not useful yet but maybe later
        
def meleeRound(opponent1, opponent2):
    """the more agile (dex) opponent stabs first, if the defender survive 
       he stabs back"""
    dex1 = opponent1.dexterity + multiDice()
    dex2 = opponent2.dexterity + multiDice()
    if dex1 == dex2:
        # randomly choose first attacker
        dex1 = dex2 + random.choice((-1,1))
    if opponent1.hitpoints > 0 and opponent2.hitpoints >0:
        print "+++Attack! " + dexmsg(opponent1, opponent2, dex1, dex2)
        if dex1 > dex2:
            meleeAttack(opponent1, opponent2) # attack
            if opponent2.hitpoints > 0 and opponent1.hitpoints >0:
                print "+++Counter-Attack!"
                meleeAttack(opponent2, opponent1) # riposte
        else:
            meleeAttack(opponent2, opponent1) # attack
            if opponent1.hitpoints > 0 and opponent2.hitpoints >0:
                print "+++Counter-Attack!"
                meleeAttack(opponent1, opponent2) # riposte

def dexmsg(opponent1, opponent2, dex1, dex2):
    """ returns a message of who is attacking who first. uses cmp to compare stats.
        cmp(a,b) returns -1 if a<b, 0 if a == b and 1 if a>b"""
    mydic1 = {-1:"slower", 0:"equal fast", 1: "faster"}
    mydic2 = {-1:"is attacked first by", 0:"???", 1:"attacks first"}
    msg = "The %s %s (%i) %s %s (%i) with %i:%i" % (mydic1[cmp(opponent1.dexterity, opponent2.dexterity)],
        opponent1.name, opponent1.dexterity, mydic2[cmp(dex1, dex2)], opponent2.name, opponent2.dexterity , dex1, dex2)
    return msg

def meleeAttack(opponent1, opponent2):
    """
    The melee attack checks if the defender has a longer weapon. if yes,
    the attacker can loose max. 1 hitpoint due to repel action before 
    continuing his attac.
    Note: a meleeround consist of two meleAttacks (attack and counter-attack). Both check for repel damage.
    """
    if (MeleeWeapon.book[opponent1.activeMeleeWeapon].length <
        MeleeWeapon.book[opponent2.activeMeleeWeapon].length):
        print "Repel action: %s attacks with shorter %s (%i) against  %s (%i)" % (opponent1.name,
            MeleeWeapon.book[opponent1.activeMeleeWeapon].shortdescr, MeleeWeapon.book[opponent1.activeMeleeWeapon].length, 
            MeleeWeapon.book[opponent2.activeMeleeWeapon].shortdescr, MeleeWeapon.book[opponent2.activeMeleeWeapon].length )
        meleeAction(opponent2, opponent1, True) # repel action, max. 1 damage 
    if opponent1.hitpoints >0 and opponent2.hitpoints > 0:
        meleeAction(opponent1, opponent2) # normal attack

    
def melee(opponent1, opponent2):
    """melee combat inspired by the dominions3 rules.
       basic formular:
       if attacking with a shorter melee weapon (weapon length),
       the attacker must defend against a repel action, whose damage is
       limited to 1 hitponts. after that, he continues his attack.
       the attacker throws 2 x a 6-sided dice (and re-rolls at a 6), see
       MultiDice) and adds his attack value vs. the defenders defense
       value and his Multidice.
       if the attacker is sucessfull, damage is calculated at damage value
       + strength + multidice vs. protection + multidice.
       **not yet coded: the attack vs. defense value must be higher
       than the defenders shield parry value
       **not yet coded: sum all items for attack + defense + protection boni/mali
       **not yet coded: each part of body has its own protection value,
       depending on armor (shoe, helm, shield...) of defender
       **not yet coded: critical hit, affliction damage 
       """
      
    rounds = 0
    while (opponent1.hitpoints > 0) and (opponent2.hitpoints > 0):
        rounds += 1
        print "----melee round %i----" % rounds
        meleeRound(opponent1, opponent2)
    if opponent1.hitpoints > 0:
        victor = opponent1
    else:
        victor = opponent2
    print "*** Victory for %s ***" % victor.name
    return (rounds, victor)

def compareStats(opponent1, opponent2):
    """ compare the attributes (stats) of two monsters"""
    o = {-2:"-",-1:"<",0:"=",1:">"} # compare results
    ignorelist = ( "activeMeleeWeapon", "MeleeWeapon")
    for key in opponent1.__dict__:
        if key in ignorelist:
            continue
        if not (key in opponent2.__dict__):
            continue 
        if "int" in str(type(opponent1.__dict__[key])):
            r = cmp(opponent1.__dict__[key], opponent2.__dict__[key])
        else:
            r=-2 # text can not be compared directly
        print key, ":", opponent1.__dict__[key], o[r], opponent2.__dict__[key]

def testFight(opponent1, opponent2, trials=10000):
    v1 = 0
    v2 = 0
    vrounds = {}
    for x in range(trials):
        savehp1 = opponent1.hitpoints
        savehp2 = opponent2.hitpoints
        print "========================= new battle ====================="
        print "trial number %i" %x
        trialresult = melee(opponent1, opponent2)
        rounds = trialresult[0]
        victor = trialresult[1]
        if not rounds in vrounds.keys():
            vrounds[rounds] = [0,0,0]
        if victor == opponent1:
            v1 +=1
            vrounds[rounds][0] += 1
            vrounds[rounds][2] += 1 
        else:
            v2 +=1
            vrounds[rounds][1] += 1
            vrounds[rounds][2] += 1 
        # restore hitpoints
        opponent1.hitpoints = savehp1
        opponent2.hitpoints = savehp2
    print "========================="
    print "trial result statistic"
    print "========================="
    print "victorys for", opponent1.name, v1
    print "victorys for", opponent2.name, v2
    print "number of combat rounds, victorys1, victorys2, number of battles:", vrounds
    return v1, v2, vrounds 
    
    
def domDiceTest():
    """print a table of stat differences 
       and the chance that:
       2domDice + stat difference > 2domDice
       see page 5 of the domionons3 manual"""
    r = {}
    for zahl in range(-14,15,1):
        r[zahl] = 0
        for x in range(1000):
            a = multiDice()
            b = multiDice()
            print zahl, a, b
            if a + zahl > b:
                r[zahl] += 1
    print "---------"
    for key in sorted(r.keys()):
        print key, ":", r[key]

def game():
    """simple role-playing-game"""
    # edit those values !
    player = Monster(strength=10, dexterity=11, hitpoints=10, intelligence=8, protection=10, race="human", name="lordling")
    player.score = 0 # additional attribute only for player
    bozo  = Monster(strength=11, dexterity=10, hitpoints=11, intelligence=8, protection = 10, race="orc", name="bozo")
    axe =        MeleeWeapon(attack=5, defense = 1, damage=3,  length= 1, shortdescr="axe", )
    shortsword = MeleeWeapon(attack=5, defense = 2, damage=2,  length= 2, shortdescr="army sword")
    player.activeMeleeWeapon =  shortsword.number
    bozo.activeMeleeWeapon = axe.number
    print "--------battle---------"
    #melee(player, bozo)
    v1,v2,rounds = testFight(player, bozo, 100)


    
if __name__ == '__main__':
    game()


########NEW FILE########
__FILENAME__ = turtleforest1
import turtle as t
import random

t.speed (0)

def tree (age= 100):
    """paint a tree"""
    t. pd ()
    t. fd (age * 0.3)
    t. lt (90)
    t. fd (age * 1.3)
    t. lt (90)
    t. fd (age * 0.15)
    t. circle (age * -0.6)
    t. fd (age * 0.15)
    t. lt (90)
    t. fd (age * 1.3)
    t. lt (90)
    t. pu ()

def forest (amount= 100):
    """paint a forest"""
    t. clear ()
    t. pu ()
    for x in range (amount):
        t. setpos (random. randint (-400,400),random. randint (-300,300))
        tree (random. randint (10,200))

if __name__ =="__main__":
    forest ()

########NEW FILE########
__FILENAME__ = zahlen
import random
summe = 0

for x in range(10):
    w = random.randint(1,6)
    print x, ".Wurf: ", w
    
    summe +=w
    
print "______________________" 
print "summe: ", summe

########NEW FILE########
