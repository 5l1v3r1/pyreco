__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# HyperKitty documentation build configuration file, created by
# sphinx-quickstart on Fri Aug 10 19:46:05 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'HyperKitty'
copyright = u'2012, HyperKitty Developers'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0.0'
# The full version, including alpha/beta/rc tags.
release = '1.0.0b1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build', 'database.rst']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'HyperKittydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'HyperKitty.tex', u'HyperKitty Documentation',
   u'Mailman Coders', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'hyperkitty', u'HyperKitty Documentation',
     [u'Mailman Coders'], 1)
]

########NEW FILE########
__FILENAME__ = api
#-*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import serializers

from hyperkitty.models import Tag
from hyperkitty.lib import get_store


class ListSerializer(serializers.Serializer):
    name = serializers.CharField()
    display_name = serializers.CharField()
    subject_prefix = serializers.CharField()

class EmailSerializer(serializers.Serializer):
    list_name = serializers.EmailField()
    message_id = serializers.CharField()
    thread_id = serializers.CharField()
    sender_name = serializers.CharField()
    sender_email = serializers.EmailField()
    subject = serializers.CharField()
    in_reply_to = serializers.CharField()
    date = serializers.DateTimeField()
    likes = serializers.IntegerField()
    dislikes = serializers.IntegerField()

class EmailLinkSerializer(serializers.Serializer):
    list_name = serializers.EmailField()
    message_id = serializers.CharField()
    sender_name = serializers.CharField()
    sender_email = serializers.EmailField()
    date = serializers.DateTimeField()

class ThreadSerializer(serializers.Serializer):
    thread_id = serializers.CharField()
    list_name = serializers.EmailField()
    date_active = serializers.DateTimeField()
    subject = serializers.CharField()
    starting_email = EmailLinkSerializer()
    email_ids = serializers.CharField()
    participants = serializers.CharField()

class TagSerializer(serializers.ModelSerializer):
    class Meta:
        model = Tag
        fields = ("list_address", "threadid", "tag")


class ListResource(APIView):
    """ Resource used to retrieve lists from the archives using the
    REST API.
    """

    def get(self, request):
        store = get_store(request)
        lists = store.get_lists()
        if not lists:
            return Response(status=404)
        else:
            return Response(ListSerializer(lists, many=True).data)

class EmailResource(APIView):
    """ Resource used to retrieve emails from the archives using the
    REST API.
    """

    def get(self, request, mlist_fqdn, messageid):
        store = get_store(request)
        email = store.get_message_by_hash_from_list(mlist_fqdn, messageid)
        if not email:
            return Response(status=404)
        else:
            return Response(EmailSerializer(email).data)


class ThreadResource(APIView):
    """ Resource used to retrieve threads from the archives using the
    REST API.
    """

    def get(self, request, mlist_fqdn, threadid):
        store = get_store(request)
        thread = store.get_thread(mlist_fqdn, threadid)
        if not thread:
            return Response(status=404)
        else:
            return Response(ThreadSerializer(thread).data)


class TagResource(APIView):
    """
    Resource used to retrieve tags from the database using the REST API.
    """

    def get(self, request):
        tags = Tag.objects.all()
        serializer = TagSerializer(tags, many=True)
        return Response(serializer.data)

########NEW FILE########
__FILENAME__ = archiver
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

"""
Class implementation of Mailman's IArchiver interface
"""
from __future__ import absolute_import, unicode_literals

import os
import sys
from urlparse import urljoin

from zope.interface import implements
from mailman.interfaces.archiver import IArchiver
from mailman.config import config
from mailman.config.config import external_configuration
from django.core.urlresolvers import reverse
from kittystore import get_store
from kittystore.utils import get_message_id_hash


class Archiver(object):

    implements(IArchiver)

    name = "hyperkitty"

    def __init__(self):
        self.store = None
        self.base_url = None
        self.settings = None # will be filled by _load_conf()
        self._load_conf()

    def _load_conf(self):
        """
        Find the location of the Django settings module from Mailman's
        configuration file, and load it to get the store's URL.
        """
        # Read our specific configuration file
        archiver_config = external_configuration(
                config.archiver.hyperkitty.configuration)
        self.base_url = archiver_config.get("general", "base_url")
        settings_path = archiver_config.get("general", "django_settings")
        if settings_path.endswith("/settings.py"):
            # we want the directory
            settings_path = os.path.dirname(settings_path)
        #path_added = False
        if settings_path not in sys.path:
            #path_added = True
            sys.path.append(settings_path)
        os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings")
        try:
            from django.conf import settings
        except ImportError:
            raise ImportError("Could not import Django's settings from %s"
                              % settings_path)
        self.settings = settings
        #if path_added:
        #    sys.path.remove(settings_path)

    def list_url(self, mlist):
        """Return the url to the top of the list's archive.

        :param mlist: The IMailingList object.
        :returns: The url string.
        """
        return urljoin(self.base_url,
                       reverse('list_overview', args=[mlist.fqdn_listname]))

    def permalink(self, mlist, msg):
        """Return the url to the message in the archive.

        This url points directly to the message in the archive.  This method
        only calculates the url, it does not actually archive the message.

        :param mlist: The IMailingList object.
        :param msg: The message object.
        :returns: The url string or None if the message's archive url cannot
            be calculated.
        """
        msg_id = msg['Message-Id'].strip().strip("<>")
        msg_hash = get_message_id_hash(msg_id)
        return urljoin(self.base_url, reverse('message_index',
                    kwargs={"mlist_fqdn": mlist.fqdn_listname,
                            "message_id_hash": msg_hash}))

    def archive_message(self, mlist, msg):
        """Send the message to the archiver.

        :param mlist: The IMailingList object.
        :param msg: The message object.
        :returns: The url string or None if the message's archive url cannot
            be calculated.
        """
        if self.store is None:
            self.store = get_store(self.settings)
        msg.message_id_hash = self.store.add_to_list(mlist, msg)
        self.store.commit()
        # TODO: Update karma
        return msg.message_id_hash

########NEW FILE########
__FILENAME__ = context_processors
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
#

from django.conf import settings

def export_settings(context):
    exports = ["APP_NAME", "USE_MOCKUPS", "USE_INTERNAL_AUTH"]
    return dict( (name.lower(), getattr(settings, name))
                 for name in exports)

########NEW FILE########
__FILENAME__ = compat
#-*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

import re
import datetime

PORT_IN_URL = re.compile(':\d+$')


def get_list_by_name(list_name, store, request):
    arch_list_names = store.get_list_names()
    matching = []
    for name in arch_list_names:
        if name[:name.index("@")] == list_name:
            matching.append(name)

    if len(matching) == 0: # no candidate found
        return None
    if len(matching) == 1: # only one candidate
        return store.get_list(matching[0])

    # more than one result, try using the hostname
    domain = request.get_host()
    domain = PORT_IN_URL.sub('', domain)
    list_fqdn = "%s@%s" % (list_name, domain)
    if list_fqdn in matching:
        return store.get_list(list_fqdn)

    # return the first match, arbitrarily
    return store.get_list(matching[0])

def month_name_to_num(month_name):
    """map month names to months numbers"""
    today = datetime.date.today()
    months = dict( (today.replace(month=num).strftime('%B'), num)
                   for num in range(1, 12) )
    return months[month_name]

########NEW FILE########
__FILENAME__ = fedora
"""
Fedora OpenID support

No extra configurations are needed to make this work.
"""
from social_auth.backends import OpenIDBackend, OpenIdAuth


FEDORA_OPENID_URL = 'https://id.fedoraproject.org'


class FedoraBackend(OpenIDBackend):
    """Fedora OpenID authentication backend"""
    name = 'fedora'


class FedoraAuth(OpenIdAuth):
    """Fedora OpenID authentication"""
    AUTH_BACKEND = FedoraBackend

    def openid_url(self):
        """Return Fedora OpenID service url"""
        return FEDORA_OPENID_URL


# Backend definition
BACKENDS = {
    'fedora': FedoraAuth,
}

########NEW FILE########
__FILENAME__ = mailman
#-*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

from __future__ import absolute_import

from functools import wraps

from django.conf import settings
from django.core.urlresolvers import reverse
from django.utils.decorators import available_attrs
from django.shortcuts import render
from django.http import Http404
from mailman.interfaces.archiver import ArchivePolicy
from mailmanclient import Client

from hyperkitty.lib import get_store


def subscribe(list_address, user):
    client = Client('%s/3.0' % settings.MAILMAN_REST_SERVER,
                    settings.MAILMAN_API_USER, settings.MAILMAN_API_PASS)
    rest_list = client.get_list(list_address)
    try:
        member = rest_list.get_member(user.email)
    except ValueError:
        # not subscribed yet, subscribe the user without email delivery
        member = rest_list.subscribe(user.email,
                "%s %s" % (user.first_name, user.last_name))
        member.preferences["delivery_status"] = "by_user"
        member.preferences.save()


def get_subscriptions(store, client, mm_user):
    if not mm_user:
        return []
    ks_user = store.get_user(mm_user.user_id)
    subscriptions = []
    for mlist_id in mm_user.subscription_list_ids:
        mlist = client.get_list(mlist_id).fqdn_listname
        # de-duplicate subscriptions
        if mlist in [ s["list_name"] for s in subscriptions ]:
            continue
        posts_count = store.get_message_count_by_user_id(
                mm_user.user_id, mlist)
        if ks_user is None:
            # no email sent and no vote cast yet
            likes = dislikes = 0
        else:
            likes, dislikes = ks_user.get_votes_in_list(mlist)
        all_posts_url = "%s?list=%s" % \
                (reverse("user_posts", args=[mm_user.user_id]), mlist)
        likestatus = "neutral"
        if likes - dislikes >= 10:
            likestatus = "likealot"
        elif likes - dislikes > 0:
            likestatus = "like"
        subscriptions.append({
            "list_name": mlist,
            "first_post": store.get_first_post(mlist, mm_user.user_id),
            "likes": likes,
            "dislikes": dislikes,
            "likestatus": likestatus,
            "all_posts_url": all_posts_url,
            "posts_count": posts_count,
        })
    return subscriptions


# View decorator: check that the list is authorized
def check_mlist_private(func):
    @wraps(func, assigned=available_attrs(func))
    def inner(request, *args, **kwargs):
        if "mlist_fqdn" in kwargs:
            mlist_fqdn = kwargs["mlist_fqdn"]
        else:
            mlist_fqdn = args[0]
        try:
            store = get_store(request)
        except KeyError:
            return func(request, *args, **kwargs) # Unittesting?
        mlist = store.get_list(mlist_fqdn)
        if mlist is None:
            raise Http404("No archived mailing-list by that name.")
        #return HttpResponse(request.session.get("subscribed", "NO KEY"), content_type="text/plain")
        if not is_mlist_authorized(request, mlist):
            return render(request, "errors/private.html", {
                            "mlist": mlist,
                          }, status=403)
        return func(request, *args, **kwargs)
    return inner

def is_mlist_authorized(request, mlist):
    if mlist.archive_policy == ArchivePolicy.private and \
            not (request.user.is_authenticated() and
                 hasattr(request, "session") and
                 mlist.name in request.session.get("subscribed", [])):
        return False
    return True

########NEW FILE########
__FILENAME__ = mockup
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
#

class Email(object):
    """ Email class containing the information needed to store and
    display email threads.
    """

    def __init__(self):
        """ Constructor.
        Instanciate the default attributes of the object.
        """
        self.email_id = ''
        self.title = ''
        self.body = ''
        self.tags = []
        self.category = 'question'
        self.category_tag = None
        self.participants = set(['Pierre-Yves Chibon'])
        self.answers = []
        self.liked = 0
        self.author = ''
        self.avatar = None

class Author(object):
    """ Author class containing the information needed to get the top
    author of the month!
    """

    def __init__(self):
        """ Constructor.
        Instanciate the default attributes of the object.
        """
        self.name = None
        self.kudos = 0
        self.avatar = None


def get_email_tag(tag):
    threads = generate_random_thread()
    output = []
    for email in threads:
        if tag in email.tags or tag in email.category:
            output.append(email)
        elif email.category_tag and tag in email.category_tag:
            output.append(email)
    return output


def generate_thread_per_category():
    threads = generate_random_thread()
    categories = {}
    for thread in threads:
        category = thread.category
        if thread.category_tag:
            category = thread.category_tag
        if category in categories.keys():
            categories[category].append(thread)
        else:
            categories[category] = [thread]
    return categories

def generate_top_author():
    authors = []

    author = Author()
    author.name = 'Pierre-Yves Chibon'
    author.avatar = 'https://secure.gravatar.com/avatar/072b4416fbfad867a44bc7a5be5eddb9'
    author.kudos = 3
    authors.append(author)

    author = Author()
    author.name = 'Stanislav Ochotnický'
    author.avatar = 'http://sochotni.fedorapeople.org/sochotni.jpg'
    author.kudos = 4
    authors.append(author)

    author = Author()
    author.name = 'Toshio Kuratomi'
    author.avatar = 'https://secure.gravatar.com/avatar/7a9c1d88f484c9806bceca0d6d91e948'
    author.kudos = 5
    authors.append(author)

    return authors

def generate_random_thread():
    threads = []

    ## 1
    email = Email()
    email.email_id = 1
    email.title = 'Headsup! krb5 ccache defaults are changing in Rawhide'
    email.age = '6 days'
    email.body = '''Dear fellow developers,
with the upcoming Fedora 18 release (currently Rawhide) we are going to change the place where krb5 credential cache files are saved by default.

The new default for credential caches will be the /run/user/username directory.
'''
    email.tags.extend(['rawhide', 'krb5'])
    email.participants = set(['Stephen Gallagher', 'Toshio Kuratomi', 'Kevin Fenzi', 'Seth Vidal'])
    email.answers.extend([1,2,3,4,5,6,7,8,9,10,11,12])
    email.liked = 1
    email.author = 'Stephen Gallagher'
    email.avatar = 'http://fedorapeople.org/~sgallagh/karrde712.png'
    threads.append(email)

    ## 2
    email = Email()
    email.email_id = 2
    email.title = 'Problem in packaging kicad'
    email.age = '6 days'
    email.body = '''Paragraph 1: Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. '''
    email.tags.extend(['packaging', 'kicad'])
    email.participants = set(['Pierre-Yves Chibon', 'Tom "spot" Callaway', 'Toshio Kuratomi', 'Kevin Fenzi'])
    email.answers.extend([1,2,3,4,5,6,7,8,9,10,11,12])
    email.liked = 0
    email.author = 'Pierre-Yves Chibon'
    email.avatar = 'https://secure.gravatar.com/avatar/072b4416fbfad867a44bc7a5be5eddb9'
    threads.append(email)

    ## 3
    email = Email()
    email.email_id = 3
    email.title = 'Update Java Guideline'
    email.age = '6 days'
    email.body = '''Paragraph 1: Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. '''
    email.tags.extend(['rawhide', 'krb5'])
    email.participants = set(['Stanislav Ochotnický', 'Tom "spot" Callaway', 'Stephen Gallagher', 'Jason Tibbitts', 'Rex Dieter', 'Toshio Kuratomi'])
    email.answers.extend([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19])
    email.liked = 5
    email.category = 'todo'
    email.author = 'Stanislav Ochotnický'
    email.avatar = 'http://sochotni.fedorapeople.org/sochotni.jpg'
    threads.append(email)

    ## 4
    email = Email()
    email.email_id = 4
    email.title = 'Agenda for the next Board Meeting'
    email.age = '6 days'
    email.body = '''Paragraph 1: Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. '''
    email.tags.extend(['agenda', 'board'])
    email.participants = set(['Toshio Kuratomi', 'Tom "spot" Callaway', 'Robyn Bergeron', 'Max Spevack'])
    email.answers.extend([1,2,3,4,5,6,7,8,9,10,11,12])
    email.liked = 20
    email.category = 'agenda'
    email.author = 'Toshio Kuratomi'
    email.avatar = 'https://secure.gravatar.com/avatar/7a9c1d88f484c9806bceca0d6d91e948'
    threads.append(email)

    ## 5
    email = Email()
    email.email_id = 5
    email.title = 'I told you so! '
    email.age = '6 days'
    email.body = '''Paragraph 1: Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. '''
    email.tags.extend(['systemd', 'mp3', 'pulseaudio'])
    email.participants = set(['Pierre-Yves Chibon'])
    email.answers.extend([1,2,3,4,5,6,7,8,9,10,11,12])
    email.liked = 0
    email.author = 'Pierre-Yves Chibon'
    email.avatar = 'https://secure.gravatar.com/avatar/072b4416fbfad867a44bc7a5be5eddb9'
    email.category = 'shut down'
    email.category_tag = 'dead'
    threads.append(email)

    return threads

########NEW FILE########
__FILENAME__ = paginator
#-*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#


from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger, Page
from django.utils import six
from storm.store import ResultSet


class StormPaginator(Paginator):

    def page(self, number):
        "Returns a Page object for the given 1-based page number."
        number = self.validate_number(number)
        bottom = (number - 1) * self.per_page
        top = bottom + self.per_page
        if top + self.orphans >= self.count:
            top = self.count
        #return StormPage(self.object_list[bottom:top], number, self)
        return Page(list(self.object_list[bottom:top]), number, self)

class StormPage(Page):

    def __len__(self):
        return self.paginator.per_page

    def __getitem__(self, index):
        if not isinstance(index, (slice,) + six.integer_types):
            raise TypeError
        # The object_list is converted to a list so that if it was a QuerySet
        # it won't be a database hit per __getitem__.
        return list(self.object_list)[index]
        #return self.object_list[index]

    def __iter__(self):
        for obj in self.object_list:
            yield obj

    def __contains__(self, item):
        return self.object_list.__contains__(item)


def paginate(objects, page_num, max_page_range=10, paginator=None):
    try:
        page_num = int(page_num)
    except (TypeError, ValueError):
        page_num = 1
    if paginator is None:
        # else use the provided instance
        if isinstance(objects, ResultSet):
            paginator = StormPaginator(objects, 10)
        else:
            paginator = Paginator(objects, 10)
    try:
        objects = paginator.page(page_num)
    except PageNotAnInteger:
        # If page is not an integer, deliver first page.
        objects = paginator.page(1)
    except EmptyPage:
        # If page is out of range (e.g. 9999), deliver last page of results.
        objects = paginator.page(paginator.num_pages)
    # Calculate the displayed page range
    if paginator.num_pages > max_page_range:
        objects.page_range = [ 1 ]
        subrange_lower = page_num - (max_page_range / 2 - 2)
        if subrange_lower > 3:
            objects.page_range.append("...")
        else:
            subrange_lower = 2
        objects.page_range.extend(range(subrange_lower, page_num))
        if page_num != 1 and page_num != 100:
            objects.page_range.append(page_num)
        subrange_upper = page_num + (max_page_range / 2 - 2)
        if subrange_upper >= paginator.num_pages - 2:
            subrange_upper = paginator.num_pages - 1
        objects.page_range.extend(range(page_num+1, subrange_upper+1))
        if subrange_upper < paginator.num_pages - 2:
            objects.page_range.append("...")
        objects.page_range.append(paginator.num_pages)
    else:
        objects.page_range = [ p+1 for p in range(paginator.num_pages) ]
    return objects


########NEW FILE########
__FILENAME__ = posting
#-*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#


from django.core.exceptions import SuspiciousOperation
from django.core.mail import EmailMessage
from mailmanclient import MailmanConnectionError

from hyperkitty.lib import mailman


class PostingFailed(Exception):
    pass


def post_to_list(request, mlist, subject, message, headers={},
                 attachments=None):
    if not mlist:
        # Make sure the list exists to avoid posting to any email addess
        raise SuspiciousOperation("I don't know this mailing-list")
    # Check that the user is subscribed
    try:
        mailman.subscribe(mlist.name, request.user)
    except MailmanConnectionError:
        raise PostingFailed("Can't connect to Mailman's REST server, "
                            "your message has not been sent.")
    # send the message
    headers["User-Agent"] = "HyperKitty on %s" % request.build_absolute_uri("/")
    if not request.user.first_name and not request.user.last_name:
        from_email = request.user.email
    else:
        from_email = '"%s %s" <%s>' % (request.user.first_name,
                                       request.user.last_name,
                                       request.user.email)
    msg = EmailMessage(
               subject=subject,
               body=message,
               from_email=from_email,
               to=[mlist.name],
               headers=headers,
               )
    # Attachments
    if attachments:
        if not isinstance(attachments, list):
            attachments = [attachments]
        for attach in attachments:
            msg.attach(attach.name, attach.read())
    msg.send()

########NEW FILE########
__FILENAME__ = view_helpers
#-*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#


import datetime

from django.utils.timezone import utc

from hyperkitty.models import ThreadCategory, LastView
from hyperkitty.views.forms import CategoryForm


FLASH_MESSAGES = {
    "updated-ok": ("success", "The profile was successfully updated."),
    "sent-ok": ("success", "The message has been sent successfully."),
    "attached-ok": ("success", "Thread successfully re-attached."),
}


def get_months(store, list_name):
    """ Return a dictionnary of years, months for which there are
    potentially archives available for a given list (based on the
    oldest post on the list).

    :arg list_name, name of the mailing list in which this email
    should be searched.
    """
    date_first = store.get_start_date(list_name)
    if not date_first:
        return {}
    archives = {}
    now = datetime.datetime.now()
    year = date_first.year
    month = date_first.month
    while year < now.year:
        archives[year] = range(1, 13)[(month -1):]
        year = year + 1
        month = 1
    archives[now.year] = range(1, 13)[:now.month]
    return archives


def get_display_dates(year, month, day):
    if day is None:
        start_day = 1
    else:
        start_day = int(day)
    begin_date = datetime.datetime(int(year), int(month), start_day)

    if day is None:
        end_date = begin_date + datetime.timedelta(days=32)
        end_date = end_date.replace(day=1)
    else:
        end_date = begin_date + datetime.timedelta(days=1)

    return begin_date, end_date


def daterange(start_date, end_date):
    for n in range(int((end_date - start_date).days)):
        yield start_date + datetime.timedelta(n)


def get_category_widget(request=None, current_category=None):
    """
    Returns the category form and the applicable category object (or None if no
    category is set for this thread).

    If current_category is not provided or None, try to deduce it from the POST
    request.
    if request is not provided or None, don't return the category form, return
    None instead.
    """
    categories = [ (c.name, c.name.upper())
                   for c in ThreadCategory.objects.all() ] \
                 + [("", "no category")]

    if request:
        if request.method == "POST":
            category_form = CategoryForm(request.POST)
        else:
            category_form = CategoryForm(initial={"category": current_category or ""})
        category_form["category"].field.choices = categories
    else:
        category_form = None
    if request and request.method == "POST" and category_form.is_valid():
        # is_valid() must be called after the choices have been set
        current_category = category_form.cleaned_data["category"]

    if not current_category:
        category = None
    else:
        try:
            category = ThreadCategory.objects.get(name=current_category)
        except ThreadCategory.DoesNotExist:
            category = None
    return category, category_form


def is_thread_unread(request, mlist_name, thread):
    """Returns True or False if the thread is unread or not."""
    unread = False
    if request.user.is_authenticated():
        try:
            last_view_obj = LastView.objects.get(
                    list_address=mlist_name,
                    threadid=thread.thread_id,
                    user=request.user)
        except LastView.DoesNotExist:
            unread = True
        else:
            if thread.date_active.replace(tzinfo=utc) \
                    > last_view_obj.view_date:
                unread = True
    return unread


def get_recent_list_activity(store, mlist):
    """Return the number of emails posted in the last 30 days"""
    begin_date, end_date = mlist.get_recent_dates()
    days = daterange(begin_date, end_date)

    # Use get_messages and not get_threads to count the emails, because
    # recently active threads include messages from before the start date
    emails_in_month = store.get_message_dates(
            list_name=mlist.name, start=begin_date, end=end_date)
    # graph
    emails_per_date = {}
    # populate with all days before adding data.
    for day in days:
        emails_per_date[day.strftime("%Y-%m-%d")] = 0
    # now count the emails
    for email_date in emails_in_month:
        date_str = email_date.strftime("%Y-%m-%d")
        if date_str not in emails_per_date:
            continue # outside the range
        emails_per_date[date_str] += 1
    # return the proper format for the javascript chart function
    return [ {"date": d, "count": emails_per_date[d]}
             for d in sorted(emails_per_date) ]


def show_mlist(mlist, request):
    def get_domain(host):
        return ".".join(host.split(".")[-2:])
    return (get_domain(mlist.name.partition("@")[2])
            == get_domain(request.get_host()))

########NEW FILE########
__FILENAME__ = middleware
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#


from django.conf import settings


class PaginationMiddleware(object):
    """
    Inserts a variable representing the current page onto the request object if
    it exists in either **GET** or **POST** portions of the request.
    """
    def process_request(self, request):
        try:
            request.page = int(request.REQUEST['page'])
        except (KeyError, ValueError, TypeError):
            request.page = 1



# KittyStore

from threading import local
from django.shortcuts import redirect
from django.core.urlresolvers import reverse
import kittystore

class KittyStoreDjangoMiddleware(object):
    """Django middleware.
    Add KittyStore object in environ['kittystore.store']. Each thread contains
    own store.
    Inspired by http://pypi.python.org/pypi/middlestorm
    """

    def __init__(self):
        """Create Django middleware."""
        self._local = local()

    def process_request(self, request):
        if request.path == reverse("error_schemaupgrade"):
            return # Display the error page
        if "kittystore.store" in request.environ:
            return # Already set, for example by unit tests
        try:
            request.environ['kittystore.store'] = self._local.store
        except AttributeError:
            try:
                store = kittystore.get_store(settings)
            except kittystore.SchemaUpgradeNeeded:
                return redirect("error_schemaupgrade")
            else:
                request.environ['kittystore.store'] = \
                        self._local.__dict__.setdefault('store', store)

    def process_response(self, request, response):
        if "kittystore.store" in request.environ:
            # kittystore.store could be absent on automatic redirects for ex.
            request.environ['kittystore.store'].commit()
            #request.environ['kittystore.store'].close()
        return response

    def process_exception(self, request, exception):
        request.environ['kittystore.store'].rollback()



# http://stackoverflow.com/questions/2799450/django-https-for-just-login-page

from django.http import HttpResponsePermanentRedirect

SSL = 'SSL'

class SSLRedirect(object):

    def process_view(self, request, view_func, view_args, view_kwargs):
        want_secure = view_kwargs.pop(SSL, False)
        if not settings.USE_SSL: # User-disabled (e.g: development server)
            return # but after having removed the 'SSL' kwarg

        if request.user.is_authenticated():
            want_secure = True

        if not want_secure == self._is_secure(request):
            return self._redirect(request, want_secure)

    def _is_secure(self, request):
        if request.is_secure():
            return True

        #Handle the Webfaction case until this gets resolved in the request.is_secure()
        if 'HTTP_X_FORWARDED_SSL' in request.META:
            return request.META['HTTP_X_FORWARDED_SSL'] == 'on'

        return False

    def _redirect(self, request, secure):
        protocol = secure and "https" or "http"
        newurl = "%s://%s%s" % (protocol, request.get_host(), request.get_full_path())
        if settings.DEBUG and request.method == 'POST':
            raise RuntimeError, \
        """Django can't perform a SSL redirect while maintaining POST data.
           Please structure your views so that redirects only occur during GETs."""
        return HttpResponsePermanentRedirect(newurl)



# https://docs.djangoproject.com/en/dev/topics/i18n/timezones/

from django.utils import timezone
from django.core.exceptions import ObjectDoesNotExist

class TimezoneMiddleware(object):

    def process_request(self, request):
        if not request.user.is_authenticated():
            return
        try:
            user_profile = request.user.userprofile
        except ObjectDoesNotExist:
            return
        if user_profile.timezone:
            timezone.activate(user_profile.timezone)



# Cache some metadata from Mailman about the logged in user

from urllib2 import HTTPError
from mailmanclient import Client as MailmanClient
from mailmanclient import MailmanConnectionError

class MailmanUserMetadata(object):

    session_key = "subscribed"

    def process_view(self, request, view_func, view_args, view_kwargs):
        if not request.user.is_authenticated():
            return
        if not request.user.email:
            return # Can this really happen?
        if "subscribed" in request.session and "user_id" in request.session:
            return # Already set
        client = MailmanClient('%s/3.0' %
                    settings.MAILMAN_REST_SERVER,
                    settings.MAILMAN_API_USER,
                    settings.MAILMAN_API_PASS)
        try:
            user = client.get_user(request.user.email)
        except MailmanConnectionError:
            return
        except HTTPError, err:
            if err.code == 404:
                user = client.create_user(request.user.email, "")
            else:
                return
        if user.user_id is None:
            request.session["user_id"] = None
        else:
            request.session["user_id"] = unicode(user.user_id)
        request.session["subscribed"] = \
                [ s.address for s in user.subscriptions ]

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Rating'
        db.create_table('hyperkitty_rating', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('list_address', self.gf('django.db.models.fields.CharField')(max_length=50)),
            ('messageid', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('vote', self.gf('django.db.models.fields.SmallIntegerField')()),
        ))
        db.send_create_signal('hyperkitty', ['Rating'])

        # Adding model 'UserProfile'
        db.create_table('hyperkitty_userprofile', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['auth.User'], unique=True)),
            ('karma', self.gf('django.db.models.fields.IntegerField')(default=1)),
        ))
        db.send_create_signal('hyperkitty', ['UserProfile'])

        # Adding model 'Tag'
        db.create_table('hyperkitty_tag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('list_address', self.gf('django.db.models.fields.CharField')(max_length=50)),
            ('threadid', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('tag', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('hyperkitty', ['Tag'])


    def backwards(self, orm):
        # Deleting model 'Rating'
        db.delete_table('hyperkitty_rating')

        # Deleting model 'UserProfile'
        db.delete_table('hyperkitty_userprofile')

        # Deleting model 'Tag'
        db.delete_table('hyperkitty_tag')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'hyperkitty.rating': {
            'Meta': {'object_name': 'Rating'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'messageid': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'vote': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        'hyperkitty.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'tag': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'hyperkitty.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'karma': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['hyperkitty']
########NEW FILE########
__FILENAME__ = 0002_auto__add_favorite
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Favorite'
        db.create_table('hyperkitty_favorite', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('list_address', self.gf('django.db.models.fields.CharField')(max_length=50)),
            ('threadid', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
        ))
        db.send_create_signal('hyperkitty', ['Favorite'])


    def backwards(self, orm):
        # Deleting model 'Favorite'
        db.delete_table('hyperkitty_favorite')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'hyperkitty.favorite': {
            'Meta': {'object_name': 'Favorite'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'hyperkitty.rating': {
            'Meta': {'object_name': 'Rating'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'messageid': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'vote': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        'hyperkitty.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'tag': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'hyperkitty.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'karma': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['hyperkitty']
########NEW FILE########
__FILENAME__ = 0003_auto__chg_field_favorite_list_address__chg_field_tag_list_address__chg
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Favorite.list_address'
        db.alter_column(u'hyperkitty_favorite', 'list_address', self.gf('django.db.models.fields.CharField')(max_length=255))

        # Changing field 'Tag.list_address'
        db.alter_column(u'hyperkitty_tag', 'list_address', self.gf('django.db.models.fields.CharField')(max_length=255))

        # Changing field 'Rating.list_address'
        db.alter_column(u'hyperkitty_rating', 'list_address', self.gf('django.db.models.fields.CharField')(max_length=255))

    def backwards(self, orm):

        # Changing field 'Favorite.list_address'
        db.alter_column(u'hyperkitty_favorite', 'list_address', self.gf('django.db.models.fields.CharField')(max_length=50))

        # Changing field 'Tag.list_address'
        db.alter_column(u'hyperkitty_tag', 'list_address', self.gf('django.db.models.fields.CharField')(max_length=50))

        # Changing field 'Rating.list_address'
        db.alter_column(u'hyperkitty_rating', 'list_address', self.gf('django.db.models.fields.CharField')(max_length=50))

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'hyperkitty.favorite': {
            'Meta': {'object_name': 'Favorite'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.rating': {
            'Meta': {'object_name': 'Rating'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'messageid': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'vote': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        u'hyperkitty.tag': {
            'Meta': {'object_name': 'Tag'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tag': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'hyperkitty.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'karma': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['hyperkitty']
########NEW FILE########
__FILENAME__ = 0004_auto__add_lastview
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'LastView'
        db.create_table(u'hyperkitty_lastview', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('list_address', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('threadid', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('view_date', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
        ))
        db.send_create_signal(u'hyperkitty', ['LastView'])


    def backwards(self, orm):
        # Deleting model 'LastView'
        db.delete_table(u'hyperkitty_lastview')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'hyperkitty.favorite': {
            'Meta': {'object_name': 'Favorite'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.lastview': {
            'Meta': {'object_name': 'LastView'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'view_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'hyperkitty.rating': {
            'Meta': {'object_name': 'Rating'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'messageid': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'vote': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        u'hyperkitty.tag': {
            'Meta': {'object_name': 'Tag'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'tag': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'hyperkitty.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'karma': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['hyperkitty']
########NEW FILE########
__FILENAME__ = 0005_add_indices
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding index on 'Favorite', fields ['list_address']
        db.create_index(u'hyperkitty_favorite', ['list_address'])

        # Adding index on 'Favorite', fields ['threadid']
        db.create_index(u'hyperkitty_favorite', ['threadid'])

        # Adding index on 'Tag', fields ['list_address']
        db.create_index(u'hyperkitty_tag', ['list_address'])

        # Adding index on 'Tag', fields ['threadid']
        db.create_index(u'hyperkitty_tag', ['threadid'])

        # Adding index on 'Rating', fields ['list_address']
        db.create_index(u'hyperkitty_rating', ['list_address'])

        # Adding index on 'Rating', fields ['messageid']
        db.create_index(u'hyperkitty_rating', ['messageid'])

        # Adding index on 'LastView', fields ['list_address']
        db.create_index(u'hyperkitty_lastview', ['list_address'])

        # Adding index on 'LastView', fields ['threadid']
        db.create_index(u'hyperkitty_lastview', ['threadid'])


    def backwards(self, orm):
        # Removing index on 'LastView', fields ['threadid']
        db.delete_index(u'hyperkitty_lastview', ['threadid'])

        # Removing index on 'LastView', fields ['list_address']
        db.delete_index(u'hyperkitty_lastview', ['list_address'])

        # Removing index on 'Rating', fields ['messageid']
        db.delete_index(u'hyperkitty_rating', ['messageid'])

        # Removing index on 'Rating', fields ['list_address']
        db.delete_index(u'hyperkitty_rating', ['list_address'])

        # Removing index on 'Tag', fields ['threadid']
        db.delete_index(u'hyperkitty_tag', ['threadid'])

        # Removing index on 'Tag', fields ['list_address']
        db.delete_index(u'hyperkitty_tag', ['list_address'])

        # Removing index on 'Favorite', fields ['threadid']
        db.delete_index(u'hyperkitty_favorite', ['threadid'])

        # Removing index on 'Favorite', fields ['list_address']
        db.delete_index(u'hyperkitty_favorite', ['list_address'])


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'hyperkitty.favorite': {
            'Meta': {'object_name': 'Favorite'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.lastview': {
            'Meta': {'object_name': 'LastView'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'view_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'hyperkitty.rating': {
            'Meta': {'object_name': 'Rating'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'messageid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'vote': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        u'hyperkitty.tag': {
            'Meta': {'object_name': 'Tag'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'tag': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'})
        },
        u'hyperkitty.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'karma': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['hyperkitty']
########NEW FILE########
__FILENAME__ = 0006_auto__add_field_userprofile_timezone
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'UserProfile.timezone'
        db.add_column(u'hyperkitty_userprofile', 'timezone',
                      self.gf('django.db.models.fields.CharField')(default=u'', max_length=100),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'UserProfile.timezone'
        db.delete_column(u'hyperkitty_userprofile', 'timezone')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'hyperkitty.favorite': {
            'Meta': {'object_name': 'Favorite'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.lastview': {
            'Meta': {'object_name': 'LastView'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'view_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'hyperkitty.rating': {
            'Meta': {'object_name': 'Rating'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'messageid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'vote': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        u'hyperkitty.tag': {
            'Meta': {'object_name': 'Tag'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'tag': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'})
        },
        u'hyperkitty.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'karma': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'timezone': ('django.db.models.fields.CharField', [], {'default': "u''", 'max_length': '100'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['hyperkitty']
########NEW FILE########
__FILENAME__ = 0007_auto__add_field_tag_user
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Tag.user'
        db.add_column(u'hyperkitty_tag', 'user',
                      self.gf('django.db.models.fields.related.ForeignKey')(default=1, to=orm['auth.User']),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Tag.user'
        db.delete_column(u'hyperkitty_tag', 'user_id')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'hyperkitty.favorite': {
            'Meta': {'object_name': 'Favorite'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.lastview': {
            'Meta': {'object_name': 'LastView'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'view_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'hyperkitty.rating': {
            'Meta': {'object_name': 'Rating'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'messageid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'vote': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        u'hyperkitty.tag': {
            'Meta': {'object_name': 'Tag'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'tag': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'karma': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'timezone': ('django.db.models.fields.CharField', [], {'default': "u''", 'max_length': '100'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['hyperkitty']

########NEW FILE########
__FILENAME__ = 0008_auto__add_threadcategory
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'ThreadCategory'
        db.create_table(u'hyperkitty_threadcategory', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255, db_index=True)),
            ('color', self.gf('paintstore.fields.ColorPickerField')(max_length=7)),
        ))
        db.send_create_signal(u'hyperkitty', ['ThreadCategory'])


    def backwards(self, orm):
        # Deleting model 'ThreadCategory'
        db.delete_table(u'hyperkitty_threadcategory')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'hyperkitty.favorite': {
            'Meta': {'object_name': 'Favorite'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.lastview': {
            'Meta': {'object_name': 'LastView'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'view_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'hyperkitty.rating': {
            'Meta': {'object_name': 'Rating'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'messageid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'vote': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        u'hyperkitty.tag': {
            'Meta': {'object_name': 'Tag'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'tag': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.threadcategory': {
            'Meta': {'object_name': 'ThreadCategory'},
            'color': ('paintstore.fields.ColorPickerField', [], {'max_length': '7'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        u'hyperkitty.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'karma': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'timezone': ('django.db.models.fields.CharField', [], {'default': "u''", 'max_length': '100'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['hyperkitty']
########NEW FILE########
__FILENAME__ = 0009_auto__del_rating
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting model 'Rating'
        db.delete_table(u'hyperkitty_rating')


    def backwards(self, orm):
        # Adding model 'Rating'
        db.create_table(u'hyperkitty_rating', (
            ('list_address', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('messageid', self.gf('django.db.models.fields.CharField')(max_length=100, db_index=True)),
            ('vote', self.gf('django.db.models.fields.SmallIntegerField')()),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal(u'hyperkitty', ['Rating'])


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'hyperkitty.favorite': {
            'Meta': {'object_name': 'Favorite'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.lastview': {
            'Meta': {'object_name': 'LastView'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"}),
            'view_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'hyperkitty.tag': {
            'Meta': {'object_name': 'Tag'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'list_address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'tag': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'threadid': ('django.db.models.fields.CharField', [], {'max_length': '100', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']"})
        },
        u'hyperkitty.threadcategory': {
            'Meta': {'object_name': 'ThreadCategory'},
            'color': ('paintstore.fields.ColorPickerField', [], {'max_length': '7'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        u'hyperkitty.userprofile': {
            'Meta': {'object_name': 'UserProfile'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'karma': ('django.db.models.fields.IntegerField', [], {'default': '1'}),
            'timezone': ('django.db.models.fields.CharField', [], {'default': "u''", 'max_length': '100'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['hyperkitty']
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
#

from django.conf import settings
from django.db import models
from django.contrib.auth.models import User
from django.contrib import admin

import pytz
from paintstore.fields import ColorPickerField



class UserProfile(models.Model):
    # User Object
    user = models.OneToOneField(settings.AUTH_USER_MODEL)

    karma = models.IntegerField(default=1)
    TIMEZONES = [ (tz, tz) for tz in pytz.common_timezones ]
    timezone = models.CharField(max_length=100, choices=TIMEZONES, default=u"")

    def __unicode__(self):
        """Unicode representation"""
        return u'%s' % (unicode(self.user))


class Tag(models.Model):
    list_address = models.CharField(max_length=255, db_index=True)
    threadid = models.CharField(max_length=100, db_index=True)
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    tag = models.CharField(max_length=255)

    def __unicode__(self):
        """Unicode representation"""
        return u'Tag %s on thread %s in list %s' % (unicode(self.tag),
                unicode(self.threadid), unicode(self.list_address))

admin.site.register(Tag)


class Favorite(models.Model):
    list_address = models.CharField(max_length=255, db_index=True)
    threadid = models.CharField(max_length=100, db_index=True)
    user = models.ForeignKey(settings.AUTH_USER_MODEL)

    def __unicode__(self):
        """Unicode representation"""
        return u"Thread %s is a favorite of %s" % (unicode(self.threadid),
                unicode(self.user))

admin.site.register(Favorite)


class LastView(models.Model):
    list_address = models.CharField(max_length=255, db_index=True)
    threadid = models.CharField(max_length=100, db_index=True)
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    view_date = models.DateTimeField(auto_now=True)

    def __unicode__(self):
        """Unicode representation"""
        return u"Last view of %s by user %s was %s" % (unicode(self.threadid),
                unicode(self.user), self.view_date.isoformat())

admin.site.register(LastView)


class ThreadCategory(models.Model):
    name = models.CharField(max_length=255, db_index=True, unique=True)
    color = ColorPickerField()

    class Meta:
        verbose_name_plural = "Thread categories"

    def __unicode__(self):
        """Unicode representation"""
        return u'Category "%s"' % (unicode(self.name))

class ThreadCategoryAdmin(admin.ModelAdmin):
    def save_model(self, request, obj, form, change):
        obj.name = obj.name.lower()
        return super(ThreadCategoryAdmin, self).save_model(
                     request, obj, form, change)

admin.site.register(ThreadCategory, ThreadCategoryAdmin)

########NEW FILE########
__FILENAME__ = hk_generic
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

import datetime
import re

import json
from dateutil.tz import tzoffset
from django import template
from django.utils.datastructures import SortedDict
from django.utils.html import conditional_escape
from django.utils.safestring import mark_safe
from django.utils.timezone import utc

register = template.Library()


@register.filter
def trimString(str):
    return re.sub('\s+', ' ', str)


@register.filter(name='sort')
def listsort(value):
    if isinstance(value, dict):
        new_dict = SortedDict()
        key_list = value.keys()
        key_list.sort()
        key_list.reverse()
        for key in key_list:
            values = value[key]
            values.sort()
            values.reverse()
            new_dict[key] = values
        return new_dict.items()
    elif isinstance(value, list):
        new_list = list(value)
        new_list.sort()
        return new_list
    else:
        return value
    listsort.is_safe = True


@register.filter(name="monthtodate")
def to_date(month, year):
    return datetime.date(year, month, 1)


@register.filter
def strip_page(value):
    if not value:
        return value
    if value.endswith('/') and value[-3] == '/':
        end_with_number = False
        try:
            if int(value[-2]) in range(0,10):
                end_with_number = True
            if end_with_number:
                output = value.rsplit('/', 2)
        except ValueError:
            output = value.rsplit('/', 1)
    else:
        output = value.rsplit('/', 1)
    return output[0]


# From http://djangosnippets.org/snippets/1259/
@register.filter
def truncatesmart(value, limit=80):
    """
    Truncates a string after a given number of chars keeping whole words.

    Usage:
        {{ string|truncatesmart }}
        {{ string|truncatesmart:50 }}
    """
    try:
        limit = int(limit)
    # invalid literal for int()
    except ValueError:
        # Fail silently.
        return value

    # Make sure it's unicode
    value = unicode(value)

    # Return the string itself if length is smaller or equal to the limit
    if len(value) <= limit:
        return value

    # Cut the string
    value = value[:limit]

    # Break into words and remove the last
    words = value.split(' ')[:-1]

    # Join the words and return
    return ' '.join(words) + '...'


MAILTO_RE = re.compile("<a href=['\"]mailto:([^'\"]+)@([^'\"]+)['\"]>[^<]+</a>")
@register.filter(is_safe=True)
def escapeemail(text):
    """To escape email addresses"""
    # reverse the effect of urlize() on email addresses
    text = MAILTO_RE.sub(r"\1(a)\2", text)
    return text.replace("@", u"\uff20")


@register.filter()
def get_date(email_or_thread):
    """
    Rebuild the date of an email or a thread taking the timezone into account.
    """
    if hasattr(email_or_thread, 'date'):
        tz = tzoffset(None, email_or_thread.timezone * 60)
        date_obj = email_or_thread.date.replace(tzinfo=tz)
    elif hasattr(email_or_thread, 'date_active'):
        date_obj = email_or_thread.date_active.replace(tzinfo=utc)
    else:
        raise ValueError(email_or_thread)
    return date_obj


SNIPPED_RE = re.compile("^(\s*&gt;).*$", re.M)
@register.filter(needs_autoescape=True)
def snip_quoted(content, quotemsg="...", autoescape=None):
    """Snip quoted text in messages"""
    if autoescape:
        content = conditional_escape(content)
    quoted = []
    current_quote = []
    current_quote_orig = []
    #lastline = None
    for line in content.split("\n"):
        match = SNIPPED_RE.match(line)
        if match is not None:
            #if lastline == "":
            #    current_quote_orig.append(lastline)
            current_quote_orig.append(line)
            content_start = len(match.group(1))
            current_quote.append(line[content_start:])
        else:
            if current_quote_orig:
                current_quote_orig.append("")
                quoted.append( (current_quote_orig[:], current_quote[:]) )
                current_quote = []
                current_quote_orig = []
        #lastline = line
    for quote_orig, quote in quoted:
        replaced = ('<div class="quoted-switch"><a style="font-weight:normal" href="#">%s</a></div>' % quotemsg
                   +'<div class="quoted-text">'
                   +"\n".join(quote)
                   +' </div>')
        content = content.replace("\n".join(quote_orig), replaced)
    return mark_safe(content)

SNIPPED_BEGIN_PGP = re.compile("^.*(BEGIN PGP SIGNATURE).*$", re.M)
SNIPPED_END_PGP = re.compile("^.*(END PGP SIGNATURE).*$", re.M)
@register.filter(needs_autoescape=True)
def snip_pgp(content, quotemsg="...PGP SIGNATURE...", autoescape=None):
    """Snip pgp signature in messages"""
    if autoescape:
        content = conditional_escape(content)
    quoted = []
    current_quote = []
    current_quote_orig = []
    pgp_signature = False
    for line in content.split("\n"):
        match_start = SNIPPED_BEGIN_PGP.match(line)
        match_end = SNIPPED_END_PGP.match(line)
        if match_end is not None or match_start is not None or pgp_signature:
            current_quote_orig.append(line)
            current_quote.append(line)
        # start of pgp signature
        if match_start is not None:
            pgp_signature = True
        # end of pgp signature
        elif match_end is not None:
            pgp_signature = False
            if current_quote_orig:
                current_quote_orig.append("")
                quoted.append( (current_quote_orig[:], current_quote[:]) )
                current_quote = []
                current_quote_orig = []
    for quote_orig, quote in quoted:
        replaced = ('<div class="quoted-switch"><a href="#" class="pgp">%s</a></div>' % quotemsg
                   +'<div class="quoted-text">'
                   +"\n".join(quote)
                   +' </div>')
        content = content.replace("\n".join(quote_orig), replaced)
    return mark_safe(content)

@register.filter()
def multiply(num1, num2):
    if int(num2) == float(num2):
        num2 = int(num2)
    else:
        num2 = float(num2)
    return num1 * num2


@register.assignment_tag(takes_context=True)
def is_message_new(context, refdate):
    user = context["user"]
    last_view = context.get("last_view")
    refdate = refdate.replace(tzinfo=utc)
    return (user.is_authenticated() and
            (not last_view or refdate > last_view)
           )


@register.simple_tag(takes_context=True)
def add_to_query_string(context, *args, **kwargs):
    qs = context["request"].GET.copy()
    # create a dict from every args couple
    new_qs_elements = dict(zip(args[::2], args[1::2]))
    new_qs_elements.update(kwargs)
    # don't use the .update() method, it appends instead of overwriting
    for key, value in new_qs_elements.iteritems():
        qs[key] = value
    return qs.urlencode()


@register.filter
def until(value, limit):
    return value.partition(limit)[0]


@register.filter
def to_json(value):
    return json.dumps(value)

@register.filter
def get_item(dictionary, key):
    return dictionary.get(key)

@register.filter(is_safe=True)
def num_comments(value):
    """Returns the number of comments in a thread"""
    try:
        return len(value) - 1
    except (ValueError, TypeError):
        return ''

########NEW FILE########
__FILENAME__ = storm
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#


from django import template

from hyperkitty.lib import stripped_subject

register = template.Library()

@register.filter(name="count")
def count(expr):
    return expr.count()

@register.filter(name="strip_subject")
def strip_subject(subject, mlist):
    return stripped_subject(mlist, subject)

########NEW FILE########
__FILENAME__ = test_lib
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
#

import datetime
from traceback import print_exc, format_exc

from mock import Mock
from django.http import HttpRequest
from django.core.urlresolvers import reverse
import kittystore
from kittystore.test import SettingsModule

from hyperkitty.lib.view_helpers import get_display_dates, show_mlist
from hyperkitty.lib.paginator import paginate
from hyperkitty.lib.mailman import get_subscriptions

from hyperkitty.tests.utils import TestCase


class GetDisplayDatesTestCase(TestCase):

    def test_month(self):
        begin_date, end_date = get_display_dates('2012', '6', None)
        self.assertEqual(begin_date, datetime.datetime(2012, 6, 1))
        self.assertEqual(end_date, datetime.datetime(2012, 7, 1))

    def test_month_december(self):
        try:
            begin_date, end_date = get_display_dates('2012', '12', None)
        except ValueError, e:
            self.fail(e)
        self.assertEqual(begin_date, datetime.datetime(2012, 12, 1))
        self.assertEqual(end_date, datetime.datetime(2013, 1, 1))

    def test_day(self):
        begin_date, end_date = get_display_dates('2012', '4', '2')
        self.assertEqual(begin_date, datetime.datetime(2012, 4, 2))
        self.assertEqual(end_date, datetime.datetime(2012, 4, 3))


class PaginateTestCase(TestCase):

    def test_page_range(self):
        objects = range(1000)
        self.assertEqual(paginate(objects, 1).page_range,
                         [1, 2, 3, 4, '...', 100])
        self.assertEqual(paginate(objects, 2).page_range,
                         [1, 2, 3, 4, 5, '...', 100])
        self.assertEqual(paginate(objects, 3).page_range,
                         [1, 2, 3, 4, 5, 6, '...', 100])
        self.assertEqual(paginate(objects, 4).page_range,
                         [1, 2, 3, 4, 5, 6, 7, '...', 100])
        self.assertEqual(paginate(objects, 5).page_range,
                         [1, 2, 3, 4, 5, 6, 7, 8, '...', 100])
        self.assertEqual(paginate(objects, 6).page_range,
                         [1, 2, 3, 4, 5, 6, 7, 8, 9, '...', 100])
        self.assertEqual(paginate(objects, 7).page_range,
                         [1, '...', 4, 5, 6, 7, 8, 9, 10, '...', 100])
        self.assertEqual(paginate(objects, 8).page_range,
                         [1, '...', 5, 6, 7, 8, 9, 10, 11, '...', 100])
        self.assertEqual(paginate(objects, 9).page_range,
                         [1, '...', 6, 7, 8, 9, 10, 11, 12, '...', 100])
        self.assertEqual(paginate(objects, 10).page_range,
                         [1, '...', 7, 8, 9, 10, 11, 12, 13, '...', 100])
        self.assertEqual(paginate(objects, 40).page_range,
                         [1, '...', 37, 38, 39, 40, 41, 42, 43, '...', 100])
        self.assertEqual(paginate(objects, 90).page_range,
                         [1, '...', 87, 88, 89, 90, 91, 92, 93, '...', 100])
        self.assertEqual(paginate(objects, 91).page_range,
                         [1, '...', 88, 89, 90, 91, 92, 93, 94, '...', 100])
        self.assertEqual(paginate(objects, 92).page_range,
                         [1, '...', 89, 90, 91, 92, 93, 94, 95, '...', 100])
        self.assertEqual(paginate(objects, 93).page_range,
                         [1, '...', 90, 91, 92, 93, 94, 95, 96, '...', 100])
        self.assertEqual(paginate(objects, 94).page_range,
                         [1, '...', 91, 92, 93, 94, 95, 96, 97, '...', 100])
        self.assertEqual(paginate(objects, 95).page_range,
                         [1, '...', 92, 93, 94, 95, 96, 97, 98, 99, 100])
        self.assertEqual(paginate(objects, 96).page_range,
                         [1, '...', 93, 94, 95, 96, 97, 98, 99, 100])
        self.assertEqual(paginate(objects, 97).page_range,
                         [1, '...', 94, 95, 96, 97, 98, 99, 100])
        self.assertEqual(paginate(objects, 98).page_range,
                         [1, '...', 95, 96, 97, 98, 99, 100])
        self.assertEqual(paginate(objects, 99).page_range,
                         [1, '...', 96, 97, 98, 99, 100])
        self.assertEqual(paginate(objects, 100).page_range,
                         [1, '...', 97, 98, 99, 100])


#
# view_helpers.show_mlist()
#

class FakeKSList(object):
    def __init__(self, name):
        self.name = name

class ShowMlistTestCase(TestCase):

    def _do_test(self, listdomain, vhost, expected):
        mlist = FakeKSList("test@%s" % listdomain)
        req = HttpRequest()
        req.META["HTTP_HOST"] = vhost
        self.assertEqual(show_mlist(mlist, req), expected)

    def test_same_domain(self):
        self._do_test("example.com", "example.com", True)
        self._do_test("lists.example.com", "lists.example.com", True)

    def test_web_subdomain(self):
        self._do_test("example.com", "www.example.com", True)
        self._do_test("example.com", "lists.example.com", True)

    def test_mail_subdomain(self):
        self._do_test("lists.example.com", "example.com", True)

    def test_different_subdomains(self):
        self._do_test("lists.example.com", "archives.example.com", True)

    def test_different_domains(self):
        self._do_test("example.com", "another-example.com", False)
        self._do_test("lists.example.com", "archives.another-example.com", False)

    def test_single_component_domain(self):
        self._do_test("intranet", "intranet", True)

    def test_different_single_component_domain(self):
        self._do_test("intranet", "extranet", False)


#
# mailman.get_subscriptions()
#

class FakeMMList:
    def __init__(self, name):
        self.fqdn_listname = name

class MMGetSubTestCase(TestCase):

    def setUp(self):
        self.store = kittystore.get_store(
                SettingsModule(), debug=False, auto_create=True)
        self.client = Mock()
        self.client.get_list.side_effect = lambda name: FakeMMList(name)
        self.mm_user = Mock()
        self.mm_user.user_id = "123456"

    def test_user_not_in_ks(self):
        # The user is not in KittyStore yet, this should not prevent the
        # listing of the subscriptions in Mailman
        self.mm_user.subscription_list_ids = ["test@example.com",]
        try:
            subs = get_subscriptions(self.store, self.client, self.mm_user)
        except AttributeError, e:
            #print_exc()
            self.fail("Subscriptions should be available even if "
                      "the user has never voted yet\n%s" % format_exc())
        expected = [{
            'first_post': None, 'posts_count': 0,
            'likes': 0, 'dislikes': 0, 'likestatus': 'neutral',
            'list_name': "test@example.com",
            'all_posts_url': "%s?list=test@example.com"
                             % reverse("user_posts", args=["123456"]),
            }]
        self.assertEqual(subs, expected)

########NEW FILE########
__FILENAME__ = test_models
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
#

from hyperkitty.tests.utils import TestCase
from hyperkitty.models import Tag

class TagTestCase(TestCase):
    fixtures = ['tag_testdata.json']

    def setUp(self):
        super(TagTestCase, self).setUp()
        self.tag_1 = Tag.objects.get(pk=1)

########NEW FILE########
__FILENAME__ = test_templatetags
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

from hyperkitty.tests.utils import TestCase

from hyperkitty.templatetags.hk_generic import snip_quoted

class SnipQuotedTestCase(TestCase):

    quotemsg = "[SNIP]"

    def test_quote_1(self):
        contents = """
On Fri, 09.11.12 11:27, Someone wrote:
&gt; This is the first quoted line
&gt; This is the second quoted line
This is the response.
"""
        expected = """
On Fri, 09.11.12 11:27, Someone wrote:
<div class="quoted-switch"><a style="font-weight:normal" href="#">%s</a></div><div class="quoted-text"> This is the first quoted line
 This is the second quoted line </div>This is the response.
""" % self.quotemsg
        result = snip_quoted(contents, self.quotemsg)
        self.assertEqual(result, expected)

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#


from django.test import TestCase as DjangoTestCase
from django.conf import settings

import kittystore
from kittystore.test import SettingsModule


OVERRIDE_SETTINGS = {
    "TEMPLATE_DEBUG": True,
    "ASSETS_DEBUG": True,
    "USE_SSL": False,
    "KITTYSTORE_URL": 'sqlite:',
    "KITTYSTORE_SEARCH_INDEX": None,
    "KITTYSTORE_DEBUG": False,
    "USE_MOCKUPS": False,
    "ROOT_URLCONF": "hyperkitty.urls",
    "CACHES": {
        'default': {
            'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
        },
    },
}


class TestCase(DjangoTestCase):

    def _pre_setup(self):
        super(TestCase, self)._pre_setup()
        self._old_settings = {}
        for key, value in OVERRIDE_SETTINGS.iteritems():
            self._old_settings[key] = getattr(settings, key)
            setattr(settings, key, value)

    def _post_teardown(self):
        super(TestCase, self)._post_teardown()
        for key, value in self._old_settings.iteritems():
            setattr(settings, key, value)


class ViewTestCase(TestCase):
    """A testcase class that sets up kittystore to make the web client work"""

    def _pre_setup(self):
        super(ViewTestCase, self)._pre_setup()
        self.store = kittystore.get_store(SettingsModule(),
                                     debug=False, auto_create=True)
        self.client.defaults = {"kittystore.store": self.store,
                                "HTTP_USER_AGENT": "testbot",
                                }

    def _post_teardown(self):
        super(ViewTestCase, self)._post_teardown()

########NEW FILE########
__FILENAME__ = test_accounts
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

import datetime
from traceback import format_exc

from hyperkitty.tests.utils import ViewTestCase
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from mailman.email.message import Message

from kittystore.utils import get_message_id_hash
from kittystore.test import FakeList

from hyperkitty.models import LastView



class AccountViewsTestCase(ViewTestCase):

    def setUp(self):
        self.user = User.objects.create_user('testuser', 'test@example.com', 'testPass')

    def test_login(self):
        # Try to access user profile (private data) without logging in
        response = self.client.get(reverse("user_profile"))
        self.assertRedirects(response,
                "%s?next=%s" % (reverse('user_login'), reverse("user_profile")))

    def test_profile(self):
        self.client.login(username='testuser', password='testPass')
        response = self.client.get(reverse("user_profile"))
        self.assertEqual(response.status_code, 200)

    def test_registration(self):
        self.client.login(username='testuser', password='testPass')
        # If the user if already logged in, redirect to index page...
        # Don't let him register again
        response = self.client.get(reverse('user_registration'))
        self.assertRedirects(response, reverse('root'))

        # Access the user registration page after logging out and try to register now
        self.client.logout()
        response = self.client.get(reverse('user_registration'))
        self.assertEqual(response.status_code, 200)

        # @TODO: Try to register a user and verify its working

    def test_votes_no_mailman_user(self):
        self.client.login(username='testuser', password='testPass')
        response = self.client.get(reverse("user_votes"))
        self.assertEqual(response.status_code, 500)

    def test_votes_no_ks_user(self):
        self.client.login(username='testuser', password='testPass')
        # use a temp variable below because self.client.session is actually a
        # property which returns a new instance en each call :-/
        session = self.client.session
        session["user_id"] = u"testuser"
        session.save()

        try:
            response = self.client.get(reverse("user_votes"))
        except AttributeError:
            self.fail("Getting the votes should not fail if "
                      "the user has never voted yet\n%s" % format_exc())
        self.assertEqual(response.status_code, 200)
        self.assertNotContains(response, "<table>")
        self.assertNotContains(response, "<tbody>")



class LastViewsTestCase(ViewTestCase):

    def setUp(self):
        self.user = User.objects.create_user('testuser', 'test@example.com', 'testPass')
        self.client.login(username='testuser', password='testPass')
        # Create test data
        ml = FakeList("list@example.com")
        ml.subject_prefix = u"[example] "
        # Create 3 threads
        messages = []
        for msgnum in range(3):
            msg = Message()
            msg["From"] = "dummy@example.com"
            msg["Message-ID"] = "<id%d>" % (msgnum+1)
            msg["Subject"] = "Dummy message"
            msg.set_payload("Dummy message")
            self.store.add_to_list(ml, msg)
            messages.append(msg)
        # 1st is unread, 2nd is read, 3rd is updated
        LastView.objects.create(list_address="list@example.com", user=self.user,
                                threadid=get_message_id_hash("<id2>"))
        LastView.objects.create(list_address="list@example.com", user=self.user,
                                threadid=get_message_id_hash("<id3>"))
        msg4 = Message()
        msg4["From"] = "dummy@example.com"
        msg4["Message-ID"] = "<id4>"
        msg4["Subject"] = "Dummy message"
        msg4["In-Reply-To"] = "<id3>"
        msg4.set_payload("Dummy message")
        self.store.add_to_list(ml, msg4)

    def test_profile(self):
        response = self.client.get(reverse('user_last_views'))
        self.assertContains(response, "<td>dummy@example.com</td>",
                            count=2, status_code=200, html=True)

    def test_thread(self):
        responses = []
        for msgnum in range(3):
            threadid = get_message_id_hash("<id%d>" % (msgnum+1))
            response = self.client.get(reverse('thread', args=(
                        "list@example.com", threadid)))
            responses.append(response)
        # There's always one icon in the right column, so all counts are +1
        self.assertContains(responses[0], "fa-envelope", count=2, status_code=200)
        self.assertContains(responses[1], "fa-envelope", count=1, status_code=200)
        self.assertContains(responses[2], "fa-envelope", count=2, status_code=200)

    def test_thread_list(self):
        now = datetime.datetime.now()
        response = self.client.get(reverse('archives_with_month', args=(
                    "list@example.com", now.year, now.month)))
        self.assertContains(response, "fa-envelope",
                            count=2, status_code=200)

    def test_overview(self):
        response = self.client.get(reverse('list_overview', args=["list@example.com"]))
        self.assertContains(response, "fa-envelope",
                            count=4, status_code=200)

########NEW FILE########
__FILENAME__ = test_archives
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

import datetime
from tempfile import mkdtemp
from shutil import rmtree

from hyperkitty.tests.utils import TestCase, ViewTestCase
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from mailman.email.message import Message
from mailman.interfaces.archiver import ArchivePolicy

import kittystore
from kittystore.test import FakeList, SettingsModule



class ListArchivesTestCase(ViewTestCase):

    def setUp(self):
        # Create the list by adding a dummy message
        ml = FakeList("list@example.com")
        msg = Message()
        msg["From"] = "dummy@example.com"
        msg["Message-ID"] = "<msg>"
        msg.set_payload("Dummy message")
        self.store.add_to_list(ml, msg)

    def test_no_date(self):
        today = datetime.date.today()
        response = self.client.get(reverse(
                'archives_latest', args=['list@example.com']))
        final_url = reverse('archives_with_month',
                kwargs={'mlist_fqdn': 'list@example.com',
                        'year': today.year,
                        'month': today.month,
                })
        self.assertRedirects(response, final_url)



class PrivateArchivesTestCase(TestCase):

    def setUp(self):
        self.tmpdir = mkdtemp(prefix="hyperkitty-testing-")
        self.user = User.objects.create_user('testuser', 'test@example.com', 'testPass')
        # Setup KittyStore with a working search index
        settings = SettingsModule()
        settings.KITTYSTORE_SEARCH_INDEX = self.tmpdir
        self.store = kittystore.get_store(settings, debug=False, auto_create=True)
        self.client.defaults = {"kittystore.store": self.store,
                                "HTTP_USER_AGENT": "testbot",
                                }
        ml = FakeList("list@example.com")
        ml.subject_prefix = u"[example] "
        ml.archive_policy = ArchivePolicy.private
        msg = Message()
        msg["From"] = "dummy@example.com"
        msg["Message-ID"] = "<msgid>"
        msg["Subject"] = "Dummy message"
        msg.set_payload("Dummy message")
        msg["Message-ID-Hash"] = self.msgid = self.store.add_to_list(ml, msg)

    def tearDown(self):
        rmtree(self.tmpdir)


    def _do_test(self, url, query={}):
        response = self.client.get(url, query)
        self.assertEquals(response.status_code, 403)
        self.client.login(username='testuser', password='testPass')
        # use a temp variable below because self.client.session is actually a
        # property which returns a new instance en each call :-/
        session = self.client.session
        session["subscribed"] = ["list@example.com"]
        session.save()
        response = self.client.get(url, query)
        self.assertContains(response, "Dummy message", status_code=200)


    def test_month_view(self):
        now = datetime.datetime.now()
        self._do_test(reverse('archives_with_month', args=["list@example.com", now.year, now.month]))

    def test_overview(self):
        self._do_test(reverse('list_overview', args=["list@example.com"]))

    def test_thread_view(self):
        self._do_test(reverse('thread', args=["list@example.com", self.msgid]))

    def test_message_view(self):
        self._do_test(reverse('message_index', args=["list@example.com", self.msgid]))

    def test_search_list(self):
        self._do_test(reverse('search'), {"list": "list@example.com", "query": "dummy"})

    def test_search_all_lists(self):
        # When searching all lists, we only search public lists regardless of
        # the user's subscriptions
        response = self.client.get(reverse('search'), {"query": "dummy"})
        self.assertNotContains(response, "Dummy message", status_code=200)

########NEW FILE########
__FILENAME__ = test_message
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

import json

from hyperkitty.tests.utils import ViewTestCase
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from mailman.email.message import Message

from kittystore.utils import get_message_id_hash
from kittystore.test import FakeList



class MessageViewsTestCase(ViewTestCase):

    def setUp(self):
        self.user = User.objects.create_user(
                'testuser', 'test@example.com', 'testPass')
        self.client.login(username='testuser', password='testPass')
        # use a temp variable below because self.client.session is actually a
        # property which returns a new instance en each call :-/
        session = self.client.session
        session["user_id"] = u"testuser"
        session.save()
        # Create a dummy message to test on
        ml = FakeList("list@example.com")
        msg = Message()
        msg["From"] = "dummy@example.com"
        msg["Message-ID"] = "<msg>"
        msg.set_payload("Dummy message")
        self.store.add_to_list(ml, msg)


    def test_vote_up(self):
        url = reverse('message_vote', args=("list@example.com",
                      get_message_id_hash("msg")))
        resp = self.client.post(url, {"vote": "1"})
        self.assertEqual(resp.status_code, 200)
        result = json.loads(resp.content)
        self.assertEqual(result["like"], 1)
        self.assertEqual(result["dislike"], 0)


    def test_vote_down(self):
        url = reverse('message_vote', args=("list@example.com",
                      get_message_id_hash("msg")))
        resp = self.client.post(url, {"vote": "-1"})
        self.assertEqual(resp.status_code, 200)
        result = json.loads(resp.content)
        self.assertEqual(result["like"], 0)
        self.assertEqual(result["dislike"], 1)


    def test_vote_cancel(self):
        ml = FakeList("list@example.com")
        msg = Message()
        msg["From"] = "dummy@example.com"
        msg["Message-ID"] = "<msg1>"
        msg.set_payload("Dummy message")
        self.store.add_to_list(ml, msg)
        msg.replace_header("Message-ID", "<msg2>")
        self.store.add_to_list(ml, msg)
        msg1 = self.store.get_message_by_id_from_list("list@example.com", "msg1")
        msg1.vote(1, u"testuser")
        msg2 = self.store.get_message_by_id_from_list("list@example.com", "msg2")
        msg2.vote(-1, u"testuser")
        self.assertEqual(msg1.likes, 1)
        self.assertEqual(msg2.dislikes, 1)
        for msg in (msg1, msg2):
            url = reverse('message_vote', args=("list@example.com",
                          msg.message_id_hash))
            resp = self.client.post(url, {"vote": "0"})
            self.assertEqual(resp.status_code, 200)
            self.assertEqual(msg.likes, 0)
            self.assertEqual(msg.dislikes, 0)
            result = json.loads(resp.content)
            self.assertEqual(result["like"], 0)
            self.assertEqual(result["dislike"], 0)


    def test_unauth_vote(self):
        self.client.logout()
        url = reverse('message_vote', args=("list@example.com",
                      get_message_id_hash("msg")))
        resp = self.client.post(url, {"vote": "1"})
        self.assertEqual(resp.status_code, 403)

########NEW FILE########
__FILENAME__ = test_thread
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

import datetime
import json

from mock import Mock

from hyperkitty.tests.utils import ViewTestCase
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from mailman.email.message import Message

import kittystore
from kittystore.test import FakeList, SettingsModule

from hyperkitty.models import Tag



class ReattachTestCase(ViewTestCase):

    def setUp(self):
        self.user = User.objects.create_user('testuser', 'test@example.com', 'testPass')
        self.user.is_staff = True
        self.user.save()
        self.client.login(username='testuser', password='testPass')
        ml = FakeList("list@example.com")
        ml.subject_prefix = u"[example] "
        # Create 2 threads
        self.messages = []
        for msgnum in range(2):
            msg = Message()
            msg["From"] = "dummy@example.com"
            msg["Message-ID"] = "<id%d>" % (msgnum+1)
            msg["Subject"] = "Dummy message"
            msg.set_payload("Dummy message")
            msg["Message-ID-Hash"] = self.store.add_to_list(ml, msg)
            self.messages.append(msg)

    def test_suggestions(self):
        threadid = self.messages[0]["Message-ID-Hash"]
        msg2 = self.store.get_message_by_id_from_list("list@example.com", "id2")
        self.store.search = Mock(return_value={"results": [msg2]})
        self.store.search_index = True
        response = self.client.get(reverse('thread_reattach_suggest',
                                   args=["list@example.com", threadid]))
        self.store.search.assert_called_with(
            u'dummy message', 'list@example.com', 1, 50)
        other_threadid = self.messages[1]["Message-ID-Hash"]
        expected = '<input type="radio" name="parent" value="%s" />' % other_threadid
        self.assertContains(response, expected, count=1, status_code=200)

    def test_reattach(self):
        threadid1 = self.messages[0]["Message-ID-Hash"]
        threadid2 = self.messages[1]["Message-ID-Hash"]
        response = self.client.post(reverse('thread_reattach',
                                   args=["list@example.com", threadid2]),
                                   data={"parent": threadid1})
        now = datetime.datetime.now()
        threads = list(self.store.get_threads("list@example.com",
                now - datetime.timedelta(days=1),
                now + datetime.timedelta(days=1)))
        self.assertEqual(len(threads), 1)
        self.assertEqual(threads[0].thread_id, threadid1)
        expected_url = reverse('thread', args=["list@example.com", threadid1]) + "?msg=attached-ok"
        self.assertRedirects(response, expected_url)

    def test_reattach_manual(self):
        threadid1 = self.messages[0]["Message-ID-Hash"]
        threadid2 = self.messages[1]["Message-ID-Hash"]
        response = self.client.post(reverse('thread_reattach',
                                    args=["list@example.com", threadid2]),
                                    data={"parent": "",
                                          "parent-manual": threadid1})
        now = datetime.datetime.now()
        threads = list(self.store.get_threads("list@example.com",
                now - datetime.timedelta(days=1),
                now + datetime.timedelta(days=1)))
        self.assertEqual(len(threads), 1)
        self.assertEqual(threads[0].thread_id, threadid1)
        expected_url = reverse('thread', args=["list@example.com", threadid1]) + "?msg=attached-ok"
        self.assertRedirects(response, expected_url)

    def test_reattach_invalid(self):
        threadid = self.messages[0]["Message-ID-Hash"]
        self.store.attach_to_thread = Mock()
        response = self.client.post(reverse('thread_reattach',
                                    args=["list@example.com", threadid]),
                                    data={"parent": "invalid-data"})
        self.assertFalse(self.store.attach_to_thread.called)
        now = datetime.datetime.now()
        threads = list(self.store.get_threads("list@example.com",
                now - datetime.timedelta(days=1),
                now + datetime.timedelta(days=1)))
        self.assertEqual(len(threads), 2)
        self.assertContains(response, '<div class="alert alert-warning">',
                count=1, status_code=200)
        self.assertContains(response, "Invalid thread id, it should look")

    def test_reattach_on_itself(self):
        threadid = self.messages[0]["Message-ID-Hash"]
        self.store.attach_to_thread = Mock()
        response = self.client.post(reverse('thread_reattach',
                                    args=["list@example.com", threadid]),
                                    data={"parent": threadid})
        self.assertFalse(self.store.attach_to_thread.called)
        now = datetime.datetime.now()
        threads = list(self.store.get_threads("list@example.com",
                now - datetime.timedelta(days=1),
                now + datetime.timedelta(days=1)))
        self.assertEqual(len(threads), 2)
        self.assertContains(response, '<div class="alert alert-warning">',
                count=1, status_code=200)
        self.assertContains(response, "Can&#39;t re-attach a thread to itself")

    def test_reattach_on_unknown(self):
        threadid = self.messages[0]["Message-ID-Hash"]
        threadid_unknown = "L36TVP2EFFDSXGVNQJCY44W5AB2YMJ65"
        self.store.attach_to_thread = Mock()
        response = self.client.post(reverse('thread_reattach',
                                    args=["list@example.com", threadid]),
                                    data={"parent": threadid_unknown})
        self.assertFalse(self.store.attach_to_thread.called)
        self.assertContains(response, '<div class="alert alert-warning">',
                count=1, status_code=200)
        self.assertContains(response, "Unknown thread")

    def test_reattach_old_to_new(self):
        threadid1 = self.messages[0]["Message-ID-Hash"]
        threadid2 = self.messages[1]["Message-ID-Hash"]
        self.store.attach_to_thread = Mock()
        response = self.client.post(reverse('thread_reattach',
                                    args=["list@example.com", threadid1]),
                                    data={"parent": threadid2})
        self.assertFalse(self.store.attach_to_thread.called)
        now = datetime.datetime.now()
        threads = list(self.store.get_threads("list@example.com",
                now - datetime.timedelta(days=1),
                now + datetime.timedelta(days=1)))
        self.assertEqual(len(threads), 2)
        self.assertContains(response, '<div class="alert alert-error">',
                count=1, status_code=200)
        self.assertContains(response, "Can&#39;t attach an older thread to a newer thread.",
                count=1, status_code=200)



class ThreadTestCase(ViewTestCase):

    def setUp(self):
        self.user = User.objects.create_user('testuser', 'test@example.com', 'testPass')
        self.user.is_staff = True
        self.user.save()
        self.client.login(username='testuser', password='testPass')
        self.ml = FakeList("list@example.com")
        self.ml.subject_prefix = u"[example] "
        msg = self._make_msg("msgid")
        self.threadid = msg["Message-ID-Hash"]

    def _make_msg(self, msgid, reply_to=None):
        msg = Message()
        msg["From"] = "dummy@example.com"
        msg["Message-ID"] = "<%s>" % msgid
        msg["Subject"] = "Dummy message"
        msg.set_payload("Dummy message")
        if reply_to is not None:
            msg["In-Reply-To"] = "<%s>" % reply_to
        msg["Message-ID-Hash"] = self.store.add_to_list(self.ml, msg)
        return msg

    def _do_post(self, data):
        url = reverse('tags', args=["list@example.com", self.threadid])
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 200)
        return json.loads(response.content)

    def test_add_tag(self):
        result = self._do_post({ "tag": "testtag", "action": "add" })
        self.assertEqual(result["tags"], [u"testtag"])

    def test_add_tag_stripped(self):
        result = self._do_post({ "tag": " testtag ", "action": "add" })
        self.assertEqual(result["tags"], [u"testtag"])
        self.assertEqual(Tag.objects.count(), 1)
        self.assertEqual(Tag.objects.all()[0].tag, u"testtag")

    def test_add_tag_twice(self):
        # A second adding of the same tag should just be ignored
        Tag(list_address="list@example.com", threadid=self.threadid,
            tag="testtag", user=self.user).save()
        result = self._do_post({ "tag": "testtag", "action": "add" })
        self.assertEqual(result["tags"], [u"testtag"])
        self.assertEqual(Tag.objects.count(), 1)

    def test_add_multiple_tags(self):
        result = self._do_post({ "tag": "testtag 1, testtag 2 ; testtag 3", "action": "add" })
        expected = [u"testtag 1", u"testtag 2", u"testtag 3"]
        self.assertEqual(result["tags"], expected)
        self.assertEqual(Tag.objects.count(), 3)
        self.assertEqual(sorted(t.tag for t in Tag.objects.all()), expected)

    def test_num_comments(self):
        self._make_msg("msgid2", "msgid")
        self._make_msg("msgid3", "msgid2")
        self._make_msg("msgid4", "msgid3")
        url = reverse('thread', args=["list@example.com", self.threadid])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertTrue("num_comments" in response.context)
        self.assertEqual(response.context["num_comments"], 3)

########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

from django.conf.urls import patterns, include, url
from django.views.generic.base import TemplateView
from hyperkitty.api import ListResource, EmailResource, ThreadResource
from hyperkitty.api import TagResource

from django.contrib.staticfiles.urls import staticfiles_urlpatterns
from django.contrib.auth.views import logout as logout_view

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

from hyperkitty.views import TextTemplateView


urlpatterns = patterns('hyperkitty.views',
    # Index
    url(r'^/?$', 'index.index', name='root'),

    # Account
    url(r'^accounts/login/$', 'accounts.login_view', {'template_name': 'login.html', 'SSL': True}, name='user_login'),
    url(r'^accounts/logout/$', logout_view, {'next_page': '/'}, name='user_logout'),
    url(r'^accounts/profile/$', 'accounts.user_profile', name='user_profile'),
    url(r'^accounts/profile/last_views$', 'accounts.last_views', name='user_last_views'),
    url(r'^accounts/profile/votes$', 'accounts.votes', name='user_votes'),
    url(r'^accounts/profile/subscriptions$', 'accounts.subscriptions', name='user_subscriptions'),
    url(r'^accounts/register/$', 'accounts.user_registration', {'SSL': True}, name='user_registration'),

    # User (logged in user)
    url(r'^user/(?P<user_id>[^/]+)/$', 'accounts.public_profile', name='public_user_profile'),
    url(r'^user/(?P<user_id>[^/]+)/posts$', 'accounts.posts', name='user_posts'),
    # Users (other users)
    url(r'^users/$', 'users.users', name='users_overview'),
    url(r'^users/(?P<user_id>[^/]+)/$', 'users.public_profile', name='users_profile'),

    # List archives and overview
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/(?P<year>\d{4})/(?P<month>\d\d?)/(?P<day>\d\d?)/$',
        'list.archives', name='archives_with_day'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/(?P<year>\d{4})/(?P<month>\d\d?)/$',
        'list.archives', name='archives_with_month'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/latest$',
        'list.archives', name='archives_latest'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/$',
        'list.overview', name='list_overview'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/recent-activity$',
        'list.recent_activity', name='list_recent_activity'),

    # Message
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/message/(?P<message_id_hash>\w+)/$',
        'message.index', name='message_index'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/message/(?P<message_id_hash>\w+)/attachment/(?P<counter>\d+)/(?P<filename>.+)$',
        'message.attachment', name='message_attachment'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/message/(?P<message_id_hash>\w+)/vote$',
        'message.vote', name='message_vote'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/message/(?P<message_id_hash>\w+)/reply$',
        'message.reply', name='message_reply'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/message/new$',
        'message.new_message', name='message_new'),

    # Thread
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/thread/(?P<threadid>\w+)/$',
        'thread.thread_index', name='thread'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/thread/(?P<threadid>\w+)/replies$',
        'thread.replies', name='thread_replies'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/thread/(?P<threadid>\w+)/tags$',
        'thread.tags', name='tags'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/thread/(?P<threadid>\w+)/suggest-tags$',
        'thread.suggest_tags', name='suggest_tags'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/thread/(?P<threadid>\w+)/favorite$',
        'thread.favorite', name='favorite'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/thread/(?P<threadid>\w+)/category$',
        'thread.set_category', name='thread_set_category'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/thread/(?P<threadid>\w+)/reattach$',
        'thread.reattach', name='thread_reattach'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/thread/(?P<threadid>\w+)/reattach-suggest$',
        'thread.reattach_suggest', name='thread_reattach_suggest'),


    # Search
    url(r'^search$', 'search.search', name='search'),
    url(r'^list/(?P<mlist_fqdn>[^/@]+@[^/@]+)/tag/(?P<tag>.*)/$',
        'search.search_tag', name='search_tag'),


    # Categories and Tags
    url(r'^categories/$', 'categories.categories', name='categories_overview'),
    url(r'^tags/$', 'tags.tags', name='tags_overview'),

    # REST API
    url(r'^api/$', TemplateView.as_view(template_name="api.html")),
    url(r'^api/list\/',
        ListResource.as_view(), name="api_list"),
    url(r'^api/email\/(?P<mlist_fqdn>[^/@]+@[^/@]+)\/(?P<messageid>.*)/',
        EmailResource.as_view(), name="api_email"),
    url(r'^api/thread\/(?P<mlist_fqdn>[^/@]+@[^/@]+)\/(?P<threadid>.*)/',
        ThreadResource.as_view(), name="api_thread"),
    url(r'^api/tag\/', TagResource.as_view(), name="api_tag"),

    # Errors
    url(r'^error/schemaupgrade$',
        TemplateView.as_view(template_name="errors/schemaupgrade.html"),
        name="error_schemaupgrade"),

    # Admin
    url(r'^admin/', include(admin.site.urls), {"SSL": True}),
    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Robots.txt
    url(r'^robots\.txt$', TextTemplateView.as_view(template_name="robots.txt")),

    # Social Auth
    url(r'', include('social_auth.urls'), {"SSL": True}),
    # BrowserID
    url(r'', include('django_browserid.urls'), {"SSL": True}),

    # Mailman 2.X compatibility
    url(r'^listinfo/?$', 'compat.summary'),
    url(r'^listinfo/(?P<list_name>[^/]+)/?$', 'compat.summary'),
    url(r'^pipermail/(?P<list_name>[^/]+)/?$', 'compat.summary'),
    url(r'^pipermail/(?P<list_name>[^/]+)/(?P<year>\d\d\d\d)-(?P<month_name>\w+)/?$', 'compat.arch_month'),
    url(r'^pipermail/(?P<list_name>[^/]+)/(?P<year>\d\d\d\d)-(?P<month_name>\w+)/(?P<summary_type>[a-z]+)\.html$', 'compat.arch_month'),
    url(r'^pipermail/(?P<list_name>[^/]+)/(?P<year>\d\d\d\d)-(?P<month_name>\w+)\.txt.gz', 'compat.arch_month_mbox'),
    url(r'^pipermail/(?P<list_name>[^/]+)/(?P<year>\d\d\d\d)-(?P<month_name>\w+)/(?P<msg_num>\d+)\.html$', 'compat.message'),

)
#) + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
urlpatterns += staticfiles_urlpatterns()

########NEW FILE########
__FILENAME__ = accounts
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
#

import logging
from urllib2 import HTTPError

from django.conf import settings
from django.core.urlresolvers import reverse
from django.core.exceptions import SuspiciousOperation, ObjectDoesNotExist
from django.contrib.auth import authenticate, login, get_backends
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib.auth.views import login as django_login_view
from django.shortcuts import render, redirect
from django.utils.http import is_safe_url
from django.utils.timezone import utc, get_current_timezone
from django.http import Http404, HttpResponse
#from django.utils.translation import gettext as _
from social_auth.backends import SocialAuthBackend
import dateutil.parser
import mailmanclient

from hyperkitty.models import UserProfile, Favorite, LastView
from hyperkitty.views.forms import RegistrationForm, UserProfileForm
from hyperkitty.lib import get_store
from hyperkitty.lib.view_helpers import FLASH_MESSAGES
from hyperkitty.lib.paginator import paginate
from hyperkitty.lib.mailman import get_subscriptions, is_mlist_authorized


logger = logging.getLogger(__name__)


def login_view(request, *args, **kwargs):
    if "extra_context" not in kwargs:
        kwargs["extra_context"] = {}
    if "backends" not in kwargs["extra_context"]:
        kwargs["extra_context"]["backends"] = []
    # Note: sorry but I really find the .setdefault() method non-obvious and
    # harder to re-read that the lines above.
    for backend in get_backends():
        if not isinstance(backend, SocialAuthBackend):
            continue # It should be checked using duck-typing instead
        kwargs["extra_context"]["backends"].append(backend.name)
    return django_login_view(request, *args, **kwargs)


@login_required
def user_profile(request):
    if not request.user.is_authenticated():
        return redirect('user_login')

    store = get_store(request)

    # try to render the user profile.
    try:
        user_profile = request.user.userprofile
    except ObjectDoesNotExist:
        user_profile = UserProfile.objects.create(user=request.user)

    # get the Mailman user
    try:
        mm_client = mailmanclient.Client('%s/3.0' %
                    settings.MAILMAN_REST_SERVER,
                    settings.MAILMAN_API_USER,
                    settings.MAILMAN_API_PASS)
        mm_user = mm_client.get_user(request.user.email)
    except (HTTPError, mailmanclient.MailmanConnectionError):
        mm_client = mm_user = None

    if request.method == 'POST':
        form = UserProfileForm(request.POST)
        if form.is_valid():
            request.user.first_name = form.cleaned_data["first_name"]
            request.user.last_name = form.cleaned_data["last_name"]
            user_profile.timezone = form.cleaned_data["timezone"]
            request.user.save()
            user_profile.save()
            # Now update the display name in Mailman
            if mm_user is not None:
                mm_user.display_name = "%s %s" % (
                        request.user.first_name, request.user.last_name)
                mm_user.save()
            redirect_url = reverse('user_profile')
            redirect_url += "?msg=updated-ok"
            return redirect(redirect_url)
    else:
        form = UserProfileForm(initial={
                "first_name": request.user.first_name,
                "last_name": request.user.last_name,
                "timezone": get_current_timezone(),
                })

    # Favorites
    try:
        favorites = Favorite.objects.filter(user=request.user)
    except Favorite.DoesNotExist:
        favorites = []
    for fav in favorites:
        thread = store.get_thread(fav.list_address, fav.threadid)
        fav.thread = thread
        if thread is None:
            fav.delete() # thread has gone away?
    favorites = [ f for f in favorites if f.thread is not None ]

    # Emails
    emails = []
    if mm_user is not None:
        for addr in mm_user.addresses:
            addr = unicode(addr)
            if addr != request.user.email:
                emails.append(addr)

    # Flash messages
    flash_messages = []
    flash_msg = request.GET.get("msg")
    if flash_msg:
        flash_msg = { "type": FLASH_MESSAGES[flash_msg][0],
                      "msg": FLASH_MESSAGES[flash_msg][1] }
        flash_messages.append(flash_msg)

    # Extract the gravatar_url used by django_gravatar2.  The site
    # administrator could alternatively set this to http://cdn.libravatar.org/
    gravatar_url = getattr(settings, 'GRAVATAR_URL', 'http://www.gravatar.com')
    gravatar_shortname = '.'.join(gravatar_url.split('.')[-2:]).strip('/')

    context = {
        'user_profile' : user_profile,
        'form': form,
        'emails': emails,
        'favorites': favorites,
        'flash_messages': flash_messages,
        'gravatar_url': gravatar_url,
        'gravatar_shortname': gravatar_shortname,
    }
    return render(request, "user_profile.html", context)


def user_registration(request):
    if not settings.USE_INTERNAL_AUTH and \
            request.META["SERVER_NAME"] != "testserver": # work with unit tests
        raise SuspiciousOperation
    redirect_to = request.REQUEST.get("next", reverse("root"))
    if not is_safe_url(url=redirect_to, host=request.get_host()):
        redirect_to = settings.LOGIN_REDIRECT_URL


    if request.user.is_authenticated():
        # Already registered, redirect back to index page
        return redirect(redirect_to)

    if request.POST:
        form = RegistrationForm(request.POST)
        if form.is_valid():
            u = User.objects.create_user(form.cleaned_data['username'],
                                         form.cleaned_data['email'],
                                         form.cleaned_data['password1'])
            u.is_active = True
            u.save()
            user = authenticate(username=form.cleaned_data['username'],
                                password=form.cleaned_data['password1'])

            if user is not None:
                logger.debug(user)
                if user.is_active:
                    login(request, user)
                    return redirect(redirect_to)
    else:
        form = RegistrationForm()

    context = {
        'form': form,
        'next': redirect_to,
    }
    return render(request, 'register.html', context)


@login_required
def last_views(request):
    store = get_store(request)
    # Last viewed threads
    try:
        last_views = LastView.objects.filter(user=request.user
                                            ).order_by("-view_date")
    except Favorite.DoesNotExist:
        last_views = []
    last_views = paginate(last_views, request.GET.get('lvpage'))
    for last_view in last_views:
        thread = store.get_thread(last_view.list_address, last_view.threadid)
        last_view.thread = thread
        if thread is None:
            last_view.delete()
            continue
        if thread.date_active.replace(tzinfo=utc) > last_view.view_date:
            # small optimization: only query the replies if necessary
            # XXX: Storm-specific (count method)
            thread.unread = thread.replies_after(last_view.view_date).count()
        else:
            thread.unread = 0
    last_views = [ lv for lv in last_views if lv.thread is not None ]

    return render(request, 'ajax/last_views.html', {
                "last_views": last_views,
            })


@login_required
def votes(request):
    store = get_store(request)
    if "user_id" not in request.session:
        return HttpResponse("Could not find or create your user ID in Mailman",
                            content_type="text/plain", status=500)
    user = store.get_user(request.session["user_id"])
    if user is None:
        votes = [] # User not found in KittyStore: no emails sent yet
    else:
        votes = paginate(user.votes, request.GET.get('vpage'))
    return render(request, 'ajax/votes.html', {
                "votes": votes,
            })


@login_required
def subscriptions(request):
    store = get_store(request)
    # get the Mailman user
    try:
        mm_client = mailmanclient.Client('%s/3.0' %
                    settings.MAILMAN_REST_SERVER,
                    settings.MAILMAN_API_USER,
                    settings.MAILMAN_API_PASS)
        mm_user = mm_client.get_user(request.user.email)
    except (HTTPError, mailmanclient.MailmanConnectionError):
        mm_client = mm_user = None
    # Subscriptions
    subscriptions = get_subscriptions(store, mm_client, mm_user)
    return render(request, 'fragments/user_subscriptions.html', {
                "subscriptions": subscriptions,
            })


def public_profile(request, user_id):
    class FakeMailmanUser(object):
        display_name = None
        created_on = None
        addresses = []
        subscription_list_ids = []
    store = get_store(request)
    try:
        client = mailmanclient.Client('%s/3.0' %
                    settings.MAILMAN_REST_SERVER,
                    settings.MAILMAN_API_USER,
                    settings.MAILMAN_API_PASS)
        mm_user = client.get_user(user_id)
    except HTTPError:
        raise Http404("No user with this ID: %s" % user_id)
    except mailmanclient.MailmanConnectionError:
        db_user = store.get_user(user_id)
        if db_user is None:
            return HttpResponse("Can't connect to Mailman",
                                content_type="text/plain", status=500)
        mm_user = FakeMailmanUser()
        mm_user.display_name = list(db_user.senders)[0].name
        mm_user.addresses = db_user.addresses
    fullname = mm_user.display_name
    if not fullname:
        fullname = store.get_sender_name(user_id)
    # Subscriptions
    subscriptions = get_subscriptions(store, client, mm_user)
    likes = sum([s["likes"] for s in subscriptions])
    dislikes = sum([s["dislikes"] for s in subscriptions])
    likestatus = "neutral"
    if likes - dislikes >= 10:
        likestatus = "likealot"
    elif likes - dislikes > 0:
        likestatus = "like"
    try:
        email = unicode(mm_user.addresses[0])
    except KeyError:
        email = None
    if mm_user.created_on is not None:
        creation = dateutil.parser.parse(mm_user.created_on)
    else:
        creation = None
    context = {
        "fullname": fullname,
        "mm_user": mm_user,
        "email": email,
        "creation": creation,
        "subscriptions": subscriptions,
        "posts_count": sum([s["posts_count"] for s in subscriptions]),
        "likes": likes,
        "dislikes": dislikes,
        "likestatus": likestatus,
    }
    return render(request, "user_public_profile.html", context)


def posts(request, user_id):
    store = get_store(request)
    mlist_fqdn = request.GET.get("list")
    if mlist_fqdn is None:
        mlist = None
        return HttpResponse("Not implemented yet", status=500)
    else:
        mlist = store.get_list(mlist_fqdn)
        if mlist is None:
            raise Http404("No archived mailing-list by that name.")
        if not is_mlist_authorized(request, mlist):
            return render(request, "errors/private.html", {
                            "mlist": mlist,
                          }, status=403)

    # Get the user's full name
    try:
        client = mailmanclient.Client('%s/3.0' %
                    settings.MAILMAN_REST_SERVER,
                    settings.MAILMAN_API_USER,
                    settings.MAILMAN_API_PASS)
        mm_user = client.get_user(user_id)
    except HTTPError:
        raise Http404("No user with this ID: %s" % user_id)
    except mailmanclient.MailmanConnectionError:
        fullname = None
    else:
        fullname = mm_user.display_name
    if not fullname:
        fullname = store.get_sender_name(user_id)

    # Get the messages and paginate them
    messages = store.get_messages_by_user_id(user_id, mlist_fqdn)
    try:
        page_num = int(request.GET.get('page', "1"))
    except ValueError:
        page_num = 1
    messages = paginate(messages, page_num)

    for message in messages:
        message.myvote = message.get_vote_by_user_id(
                request.session.get("user_id"))

    context = {
        'user_id': user_id,
        'mlist' : mlist,
        'messages': messages,
        'fullname': fullname,
    }
    return render(request, "user_posts.html", context)

########NEW FILE########
__FILENAME__ = categories
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
#

from django.http import Http404

def categories(request):
    raise Http404("This feature has not been implemented yet.")

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

from __future__ import with_statement

import os
import mailbox
import datetime
import tempfile
import gzip
from cStringIO import StringIO

from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect, Http404

from hyperkitty.lib import get_store
from hyperkitty.lib.compat import get_list_by_name, month_name_to_num


def summary(request, list_name=None):
    if list_name is None:
        return HttpResponseRedirect(reverse('root'))
    store = get_store(request)
    mlist = get_list_by_name(list_name, store, request)
    if mlist is None:
        raise Http404("No archived mailing-list by that name.")
    url = reverse('list_overview', kwargs={'mlist_fqdn': mlist.name})
    #return HttpResponse(request.build_absolute_uri(url))
    return HttpResponseRedirect(url)


def arch_month(request, list_name, year, month_name, summary_type="thread"):
    store = get_store(request)
    mlist = get_list_by_name(list_name, store, request)
    if mlist is None:
        raise Http404("No archived mailing-list by that name.")
    url = reverse('archives_with_month', kwargs={
            'mlist_fqdn': mlist.name,
            'year': year,
            'month': str(month_name_to_num(month_name)).rjust(2, "0"),
            })
    #return HttpResponse(request.build_absolute_uri(url))
    return HttpResponseRedirect(url)


def arch_month_mbox(request, list_name, year, month_name):
    """
    The messages must be rebuilt before being added to the mbox file, including
    headers and the textual content, making sure to escape email addresses.
    """
    return HttpResponse("Not implemented yet.",
                        content_type="text/plain", status=500)
    store = get_store(request)
    mlist = get_list_by_name(list_name, store, request)
    if mlist is None:
        raise Http404("No archived mailing-list by that name.")
    month = month_name_to_num(month_name)
    year = int(year)
    begin_date = datetime.datetime(year, month, 1)
    if month != 12:
        end_month = month + 1
    else:
        end_month = 1
    end_date = datetime.datetime(year, end_month, 1)
    messages = store.get_messages(mlist.name, start=begin_date, end=end_date)
    messages.reverse() # they are sorted recent first by default
    mboxfile, mboxfilepath = tempfile.mkstemp(prefix="hyperkitty-",
                                              suffix=".mbox.gz")
    os.close(mboxfile)
    mbox = mailbox.mbox(mboxfilepath)
    for message in messages:
        mbox.add(message.full)
    mbox.close()
    content = StringIO()
    zipped_content = gzip.GzipFile(fileobj=content)
    with gzip.GzipFile(fileobj=content, mode="wb") as zipped_content:
        with open(mboxfilepath, "rb") as mboxfile:
            zipped_content.write(mboxfile.read())
    response = HttpResponse(content.getvalue())
    content.close()
    response['Content-Type'] = "application/mbox+gz"
    response['Content-Disposition'] = 'attachment; filename=%d-%s.txt.gz' \
            % (year, month_name)
    response['Content-Length'] = len(response.content)
    os.remove(mboxfilepath)
    return response


def message(request, list_name, year, month_name, msg_num):
    store = get_store(request)
    mlist = get_list_by_name(list_name, store, request)
    if mlist is None:
        raise Http404("No archived mailing-list by that name.")
    message = store.get_message_by_number(mlist.name, int(msg_num))
    if message is None:
        raise Http404("No such message in this mailing-list.")
    url = reverse('message_index', kwargs={
            'mlist_fqdn': mlist.name,
            'message_id': message.message_id_hash,
            })
    #return HttpResponse(request.build_absolute_uri(url))
    return HttpResponseRedirect(url)

########NEW FILE########
__FILENAME__ = forms
#-*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurélien Bompard <abompard@fedoraproject.org>
#

from django import forms
from django.core import validators
from django.contrib.auth.models import User
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy

from hyperkitty.models import UserProfile


def isValidUsername(username):
        try:
            User.objects.get(username=username)
        except User.DoesNotExist:
            return
        raise validators.ValidationError('The username "%s" is already taken.' % username)



class RegistrationForm(forms.Form):

    username =  forms.CharField(widget=forms.TextInput, required=True,
                                validators=[isValidUsername])

    email     = forms.EmailField(required=True)

    password1 = forms.CharField(widget=forms.PasswordInput,
                                required=True, label="Password")

    password2 = forms.CharField(widget=forms.PasswordInput,
                                required=True, label="Confirm password")

    def clean(self):
        cleaned_data = super(RegistrationForm, self).clean()
        if cleaned_data.get("password1") != cleaned_data.get("password2"):
            self._errors["password2"] = self.error_class(["Passwords do not match."])
            del cleaned_data["password1"]
            del cleaned_data["password2"]
        return cleaned_data



class UserProfileForm(forms.Form):
    first_name = forms.CharField()
    last_name = forms.CharField()
    timezone = forms.ChoiceField(label="Time zone",
                                 choices=UserProfile.TIMEZONES)



class TextInputWithButton(forms.TextInput):
    """
    Render a text field and a button following the Twitter Bootstrap
    directives: http://getbootstrap.com/components/#input-groups-buttons

    Use the 'button_text' class attribute to set the button's text.
    """

    def render(self, name, value, attrs=None):
        button_text = self.attrs.pop("button_text", u"")
        initial_rendering = forms.TextInput.render(
                self, name, value, attrs)
        button = mark_safe(u'<span class="input-group-btn"><button type="submit" class="btn btn-default">%s</button></span>'
                           % button_text)
        return "".join([u'<span class="input-append"><div class="input-group">',
                        initial_rendering, button, u'</div></span>'])



class AddTagForm(forms.Form):
    tag =  forms.CharField(label='', help_text=None,
                widget=TextInputWithButton(
                    attrs={'placeholder': 'Add a tag...',
                           'class': 'input-medium form-control',
                           'button_text': 'Add',
                           'title': 'use commas to add multiple tags',
                           }
                    )
                )
    action = forms.CharField(widget=forms.HiddenInput, initial="add")



class AttachmentFileInput(forms.FileInput):
    attach_first_text = ugettext_lazy('Attach a file')
    attach_another_text = ugettext_lazy('Attach another file')
    rm_text = ugettext_lazy('Remove this file')
    template = """
<span class="attach-files-template">
    %(input)s <a href="#" title="%(rm_text)s">(-)</a>
</span>
<span class="attach-files"></span>
<a href="#" class="attach-files-first">%(attach_first_text)s</a>
<a href="#" class="attach-files-add">%(attach_another_text)s</a>
"""

    def render(self, name, value, attrs=None):
        substitutions = {
            'attach_first_text': self.attach_first_text,
            'attach_another_text': self.attach_another_text,
            'rm_text': self.rm_text,
        }
        substitutions['input'] = super(AttachmentFileInput, self).render(name, value, attrs)
        return mark_safe(self.template % substitutions)


class ReplyForm(forms.Form):
    newthread = forms.BooleanField(label="", required=False)
    subject = forms.CharField(label="", required=False,
            widget=forms.TextInput(attrs={ 'placeholder': 'New subject','class': 'form-control'}))
    message = forms.CharField(label="", widget=forms.Textarea(attrs={ 'class': 'form-control' }))
    attachment = forms.FileField(required=False, widget=AttachmentFileInput)

class PostForm(forms.Form):
    subject = forms.CharField()
    message = forms.CharField(widget=forms.Textarea)
    attachment = forms.FileField(required=False, label="",
                                 widget=AttachmentFileInput)

class CategoryForm(forms.Form):
    category = forms.ChoiceField(label="", required=False)

########NEW FILE########
__FILENAME__ = index
#-*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#


import datetime

from django.shortcuts import render
from django.conf import settings
from mailman.interfaces.archiver import ArchivePolicy

from hyperkitty.lib import get_store
from hyperkitty.lib.view_helpers import show_mlist
from hyperkitty.lib.mailman import is_mlist_authorized


def index(request):
    now = datetime.datetime.now()
    store = get_store(request)
    lists = [ l for l in store.get_lists()
              if not settings.FILTER_VHOST or show_mlist(l, request) ]
    initials = set()
    for mlist in lists:
        if mlist.archive_policy != ArchivePolicy.private:
            mlist.is_private = False
            mlist.can_view = True
        else:
            mlist.is_private = True
            if is_mlist_authorized(request, mlist):
                mlist.can_view = True
            else:
                mlist.can_view = False
        if mlist.created_at and \
                now - mlist.created_at <= datetime.timedelta(days=30):
            mlist.is_new = True
        else:
            mlist.is_new = False
        initials.add(mlist.name[0])

    # sorting
    sort_mode = request.GET.get('sort')
    if sort_mode == "active":
        lists.sort(key=lambda l: l.recent_threads_count, reverse=True)
    elif sort_mode == "popular":
        lists.sort(key=lambda l: l.recent_participants_count, reverse=True)
    elif sort_mode == "creation":
        lists.sort(key=lambda l: l.created_at, reverse=True)
    else:
        sort_mode = None

    context = {
        'view_name': 'all_lists',
        'all_lists': lists,
        'initials': sorted(list(initials)),
        'sort_mode': sort_mode,
        }
    return render(request, "index.html", context)

########NEW FILE########
__FILENAME__ = list
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

import datetime

import json
from django.shortcuts import redirect, render
from django.conf import settings
from django.core.urlresolvers import reverse
from django.utils import formats
from django.utils.dateformat import format as date_format
from django.http import Http404, HttpResponse

from hyperkitty.models import Tag, Favorite
from hyperkitty.lib import get_store
from hyperkitty.lib.view_helpers import FLASH_MESSAGES, \
        get_category_widget, get_months, get_display_dates, \
        is_thread_unread, get_recent_list_activity
from hyperkitty.lib.paginator import paginate
from hyperkitty.lib.mailman import check_mlist_private


if settings.USE_MOCKUPS:
    from hyperkitty.lib.mockup import generate_top_author



@check_mlist_private
def archives(request, mlist_fqdn, year=None, month=None, day=None):
    if year is None and month is None:
        today = datetime.date.today()
        return redirect(reverse(
                'archives_with_month', kwargs={
                    "mlist_fqdn": mlist_fqdn,
                    'year': today.year,
                    'month': today.month}))

    begin_date, end_date = get_display_dates(year, month, day)
    store = get_store(request)
    mlist = store.get_list(mlist_fqdn)
    threads = store.get_threads(mlist_fqdn, start=begin_date, end=end_date)
    if day is None:
        list_title = date_format(begin_date, "F Y")
        no_results_text = "for this month"
    else:
        #list_title = date_format(begin_date, settings.DATE_FORMAT)
        list_title = formats.date_format(begin_date) # works with i18n
        no_results_text = "for this day"
    extra_context = {
        'month': begin_date,
        'month_num': begin_date.month,
        "list_title": list_title.capitalize(),
        "no_results_text": no_results_text,
    }
    if day is None:
        month_activity = mlist.get_month_activity(int(year), int(month))
        extra_context["participants"] = month_activity.participants_count
    return _thread_list(request, mlist, threads, extra_context=extra_context)


def _thread_list(request, mlist, threads, template_name='thread_list.html', extra_context={}):
    if mlist is None:
        raise Http404("No archived mailing-list by that name.")
    store = get_store(request)

    threads = paginate(threads, request.GET.get('page'))

    participants = set()
    for thread in threads:
        if "participants" not in extra_context:
            participants.update(thread.participants)

        # Favorites
        thread.favorite = False
        if request.user.is_authenticated():
            try:
                Favorite.objects.get(list_address=mlist.name,
                                     threadid=thread.thread_id,
                                     user=request.user)
            except Favorite.DoesNotExist:
                pass
            else:
                thread.favorite = True

        # Tags
        try:
            thread.tags = Tag.objects.filter(threadid=thread.thread_id,
                                             list_address=mlist.name)
        except Tag.DoesNotExist:
            thread.tags = []

        # Category
        thread.category_hk, thread.category_form = \
                get_category_widget(request, thread.category)

        # Unread status
        thread.unread = is_thread_unread(request, mlist.name, thread)

    flash_messages = []
    flash_msg = request.GET.get("msg")
    if flash_msg:
        flash_msg = { "type": FLASH_MESSAGES[flash_msg][0],
                      "msg": FLASH_MESSAGES[flash_msg][1] }
        flash_messages.append(flash_msg)

    context = {
        'mlist' : mlist,
        'threads': threads,
        'participants': len(participants),
        'months_list': get_months(store, mlist.name),
        'flash_messages': flash_messages,
    }
    context.update(extra_context)
    return render(request, template_name, context)


@check_mlist_private
def overview(request, mlist_fqdn=None):
    if not mlist_fqdn:
        return redirect('/')

    store = get_store(request)
    mlist = store.get_list(mlist_fqdn)
    if mlist is None:
        raise Http404("No archived mailing-list by that name.")
    begin_date, end_date = mlist.get_recent_dates()
    threads_result = store.get_threads(
            list_name=mlist.name, start=begin_date, end=end_date)

    threads = []
    for thread_obj in threads_result:
        thread_obj.category_widget = get_category_widget(
                None, thread_obj.category)[0]
        thread_obj.unread = is_thread_unread(request, mlist.name, thread_obj)
        threads.append(thread_obj)

    # top threads are the one with the most answers
    top_threads = sorted(threads, key=lambda t: len(t), reverse=True)

    # active threads are the ones that have the most recent posting
    active_threads = sorted(threads, key=lambda t: t.date_active, reverse=True)

    # top authors are the ones that have the most kudos.  How do we determine
    # that?  Most likes for their post?
    if settings.USE_MOCKUPS:
        authors = generate_top_author()
        authors = sorted(authors, key=lambda author: author.kudos)
        authors.reverse()
    else:
        authors = []

    # Top posters
    top_posters = []
    for poster in store.get_top_participants(list_name=mlist.name,
                start=begin_date, end=end_date, limit=5):
        top_posters.append({"name": poster[0], "email": poster[1],
                            "count": poster[2]})

    # Popular threads
    pop_threads = sorted([ t for t in threads if t.likes - t.dislikes > 0 ],
                         key=lambda t: t.likes - t.dislikes,
                         reverse=True)

    # Threads by category
    threads_by_category = {}
    for thread in active_threads:
        if not thread.category:
            continue
        # don't use defaultdict, use .setdefault():
        # http://stackoverflow.com/questions/4764110/django-template-cant-loop-defaultdict
        if len(threads_by_category.setdefault(thread.category, [])) >= 5:
            continue
        threads_by_category[thread.category].append(thread)

    # Personalized discussion groups: flagged/favorited threads and threads by user
    if request.user.is_authenticated():
        try:
            favorites = Favorite.objects.filter(list_address=mlist.name, user=request.user)
        except Favorite.DoesNotExist:
            favorites = []
        # threads_posted_to = store.get_messages_by_user_id(request.session.get("user_id"), mlist_fqdn)
        threads_posted_to = []
    else:
        favorites = []
        threads_posted_to = []

    context = {
        'view_name': 'overview',
        'mlist' : mlist,
        'top_threads': top_threads[:6],
        'most_active_threads': active_threads[:6],
        'top_author': authors,
        'top_posters': top_posters,
        'pop_threads': pop_threads[:6],
        'threads_by_category': threads_by_category,
        'months_list': get_months(store, mlist.name),
        'flagged_threads': favorites[:6],
        'threads_posted_to': threads_posted_to[:6],
    }
    return render(request, "overview.html", context)


@check_mlist_private
def recent_activity(request, mlist_fqdn):
    store = get_store(request)
    mlist = store.get_list(mlist_fqdn)
    evolution = get_recent_list_activity(store, mlist)
    return HttpResponse(json.dumps({"evolution": evolution}),
                        content_type='application/javascript')

########NEW FILE########
__FILENAME__ = message
#-*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

import urllib
import datetime
import json

from django.http import HttpResponse, Http404
from django.shortcuts import redirect, render
from django.core.urlresolvers import reverse
from django.core.exceptions import SuspiciousOperation
from django.template import RequestContext, loader
from django.contrib.auth.decorators import login_required

from hyperkitty.lib import get_store
from hyperkitty.lib.view_helpers import get_months
from hyperkitty.lib.posting import post_to_list, PostingFailed
from hyperkitty.lib.mailman import check_mlist_private
from forms import ReplyForm, PostForm


@check_mlist_private
def index(request, mlist_fqdn, message_id_hash):
    '''
    Displays a single message identified by its message_id_hash (derived from
    message_id)
    '''
    store = get_store(request)
    message = store.get_message_by_hash_from_list(mlist_fqdn, message_id_hash)
    if message is None:
        raise Http404
    message.sender_email = message.sender_email.strip()
    message.myvote = message.get_vote_by_user_id(request.session.get("user_id"))
    mlist = store.get_list(mlist_fqdn)

    context = {
        'mlist' : mlist,
        'message': message,
        'message_id_hash' : message_id_hash,
        'months_list': get_months(store, mlist.name),
        'reply_form': ReplyForm(),
    }
    return render(request, "message.html", context)


@check_mlist_private
def attachment(request, mlist_fqdn, message_id_hash, counter, filename):
    """
    Sends the numbered attachment for download. The filename is not used for
    lookup, but validated nonetheless for security reasons.
    """
    store = get_store(request)
    message = store.get_message_by_hash_from_list(mlist_fqdn, message_id_hash)
    if message is None:
        raise Http404
    attachment = store.get_attachment_by_counter(
            mlist_fqdn, message.message_id, int(counter))
    if attachment is None or attachment.name != filename:
        raise Http404
    # http://djangosnippets.org/snippets/1710/
    response = HttpResponse(attachment.content)
    response['Content-Type'] = attachment.content_type
    response['Content-Length'] = attachment.size
    if attachment.encoding is not None:
        response['Content-Encoding'] = attachment.encoding
    # Follow RFC2231, browser support is sufficient nowadays (2012-09)
    response['Content-Disposition'] = 'attachment; filename*=UTF-8\'\'%s' \
            % urllib.quote(attachment.name.encode('utf-8'))
    return response


@check_mlist_private
def vote(request, mlist_fqdn, message_id_hash):
    """ Vote for or against a given message identified by messageid. """
    if request.method != 'POST':
        raise SuspiciousOperation

    if not request.user.is_authenticated():
        return HttpResponse('You must be logged in to vote',
                            content_type="text/plain", status=403)
    if "user_id" not in request.session:
        return HttpResponse("Could not find or create your user ID in Mailman",
                            content_type="text/plain", status=500)

    store = get_store(request)
    message = store.get_message_by_hash_from_list(mlist_fqdn, message_id_hash)
    if message is None:
        raise Http404

    value = int(request.POST['vote'])
    message.vote(value, request.session["user_id"])

    # Extract all the votes for this message to refresh it
    message.myvote = message.get_vote_by_user_id(request.session["user_id"])
    t = loader.get_template('messages/like_form.html')
    html = t.render(RequestContext(request, {
            "object": message,
            "message_id_hash": message_id_hash,
            }))

    result = { "like": message.likes, "dislike": message.dislikes,
               "html": html, }
    return HttpResponse(json.dumps(result),
                        content_type='application/javascript')


@login_required
@check_mlist_private
def reply(request, mlist_fqdn, message_id_hash):
    """ Sends a reply to the list.
    TODO: unit tests
    """
    if request.method != 'POST':
        raise SuspiciousOperation
    form = ReplyForm(request.POST)
    if not form.is_valid():
        return HttpResponse(form.errors.as_text(),
                            content_type="text/plain", status=400)
    store = get_store(request)
    mlist = store.get_list(mlist_fqdn)
    if form.cleaned_data["newthread"]:
        subject = form.cleaned_data["subject"]
        headers = {}
    else:
        message = store.get_message_by_hash_from_list(mlist.name, message_id_hash)
        subject = message.subject
        if not message.subject.lower().startswith("re:"):
            subject = "Re: %s" % subject
        headers = {"In-Reply-To": "<%s>" % message.message_id,
                   "References": "<%s>" % message.message_id, }
    try:
        post_to_list(request, mlist, subject, form.cleaned_data["message"],
                     headers, attachments=request.FILES.getlist('attachment'))
    except PostingFailed, e:
        return HttpResponse(str(e), content_type="text/plain", status=500)

    reply = {
        "sender_name": "%s %s" % (request.user.first_name,
                                  request.user.last_name),
        "sender_email": request.user.email,
        "content": form.cleaned_data["message"],
        "level": message.thread_depth, # no need to increment, level = thread_depth - 1
    }
    t = loader.get_template('ajax/temp_message.html')
    html = t.render(RequestContext(request, { 'email': reply }))
    result = {"result": "The reply has been sent successfully.",
              "message_html": html}
    return HttpResponse(json.dumps(result),
                        content_type="application/javascript")


@login_required
@check_mlist_private
def new_message(request, mlist_fqdn):
    """ Sends a new thread-starting message to the list.
    TODO: unit tests
    """
    store = get_store(request)
    mlist = store.get_list(mlist_fqdn)
    failure = None
    if request.method == 'POST':
        form = PostForm(request.POST)
        if form.is_valid():
            today = datetime.date.today()
            redirect_url = reverse(
                    'archives_with_month', kwargs={
                        "mlist_fqdn": mlist_fqdn,
                        'year': today.year,
                        'month': today.month})
            redirect_url += "?msg=sent-ok"
            try:
                post_to_list(request, mlist, form.cleaned_data['subject'],
                             form.cleaned_data["message"],
                             attachments=request.FILES.getlist("attachment"))
            except PostingFailed, e:
                failure = str(e)
            else:
                return redirect(redirect_url)
    else:
        form = PostForm()
    context = {
        "mlist": mlist,
        "post_form": form,
        "failure": failure,
        'months_list': get_months(store, mlist.name),
    }
    return render(request, "message_new.html", context)

########NEW FILE########
__FILENAME__ = search
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#


from django.shortcuts import render
from django.core.paginator import Paginator, Page
from django.http import Http404

from hyperkitty.models import Tag
from hyperkitty.lib import get_store
from hyperkitty.lib.paginator import paginate

from hyperkitty.views.list import _thread_list
from hyperkitty.lib.mailman import check_mlist_private, is_mlist_authorized


class SearchPaginator(Paginator):
    """
    A paginator which does not split the object_list into pages, because Whoosh
    already handles that
    """
    def __init__(self, object_list, per_page, total):
        super(SearchPaginator, self).__init__(object_list, per_page)
        self._count = total

    def page(self, number):
        "Returns the object list without paginating"""
        return Page(self.object_list, number, self)


@check_mlist_private
def search_tag(request, mlist_fqdn, tag):
    '''Returns threads having a particular tag'''
    store = get_store(request)
    mlist = store.get_list(mlist_fqdn)

    try:
        tags = Tag.objects.filter(tag=tag)
    except Tag.DoesNotExist:
        tags = {}

    threads = []
    for t in tags:
        thread = store.get_thread(mlist_fqdn, t.threadid)
        if thread is not None:
            threads.append(thread)

    extra_context = {
        "tag": tag,
        "list_title": "Search results for tag \"%s\"" % tag,
        "no_results_text": "for this tag",
    }
    return _thread_list(request, mlist, threads, extra_context=extra_context)


def search(request, page=1):
    """ Returns messages corresponding to a query """
    results_per_page = 10
    store = get_store(request)
    query = request.GET.get("query")
    mlist_fqdn = request.GET.get("list")
    sort_mode = request.GET.get('sort')

    if mlist_fqdn is None:
        mlist = None
    else:
        mlist = store.get_list(mlist_fqdn)
        if mlist is None:
            raise Http404("No archived mailing-list by that name.")
        if not is_mlist_authorized(request, mlist):
            return render(request, "errors/private.html", {
                            "mlist": mlist,
                          }, status=403)

    if not store.search_index:
        return render(request, "errors/nosearch.html", {"mlist": mlist})

    if not query:
        return render(request, "search_results.html", {
            'mlist' : mlist,
            "query": query or "",
            'messages': [],
            'total': 0,
            'sort_mode': sort_mode,
        })

    try:
        page_num = int(request.GET.get('page', "1"))
    except ValueError:
        page_num = 1

    sortedby = None
    reverse = False
    if sort_mode == "date-asc":
        sortedby = "date"
    elif sort_mode == "date-desc":
        sortedby = "date"
        reverse = True

    query_result = store.search(query, mlist_fqdn, page_num, results_per_page,
                                sortedby=sortedby, reverse=reverse)
    total = query_result["total"]
    messages = query_result["results"]
    for message in messages:
        message.myvote = message.get_vote_by_user_id(
                request.session.get("user_id"))

    paginator = SearchPaginator(messages, 10, total)
    messages = paginate(messages, page_num, paginator=paginator)

    context = {
        'mlist' : mlist,
        "query": query,
        'messages': messages,
        'total': total,
        'sort_mode': sort_mode,
    }
    return render(request, "search_results.html", context)

########NEW FILE########
__FILENAME__ = tags
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
#

from django.http import Http404

def tags(request):
    raise Http404("This feature has not been implemented yet.")

########NEW FILE########
__FILENAME__ = thread
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Aamir Khan <syst3m.w0rm@gmail.com>
# Author: Aurelien Bompard <abompard@fedoraproject.org>
#

import datetime
import re
import json
from collections import namedtuple

from django.http import HttpResponse, Http404
from django.template import RequestContext, loader
from django.shortcuts import render, redirect
from django.core.urlresolvers import reverse
from django.core.exceptions import SuspiciousOperation
from django.utils.timezone import utc
import robot_detection

from hyperkitty.models import Tag, Favorite, LastView
from hyperkitty.views.forms import AddTagForm, ReplyForm
from hyperkitty.lib import get_store, stripped_subject
from hyperkitty.lib.view_helpers import (get_months, get_category_widget,
        FLASH_MESSAGES)
from hyperkitty.lib.mailman import check_mlist_private


def _get_thread_replies(request, thread, offset=1, limit=None):
    '''
    Get and sort the replies for a thread.
    By default, offset = 1 to skip the original message.
    '''
    if not thread:
        raise Http404

    if "sort" in request.GET and request.GET["sort"] == "date":
        sort_mode = "date"
        emails = thread.emails
    else:
        sort_mode = "thread"
        emails = thread.emails_by_reply

    # XXX: Storm-specific
    emails = emails.find()
    emails.config(offset=offset, limit=limit)

    emails = list(emails)
    for email in emails:
        # Extract all the votes for this message
        email.myvote = email.get_vote_by_user_id(request.session.get("user_id"))
        if sort_mode == "thread":
            email.level = email.thread_depth - 1 # replies start ragged left
            if email.level > 5:
                email.level = 5

    return emails


@check_mlist_private
def thread_index(request, mlist_fqdn, threadid, month=None, year=None):
    ''' Displays all the email for a given thread identifier '''
    store = get_store(request)
    thread = store.get_thread(mlist_fqdn, threadid)
    if not thread:
        raise Http404
    prev_thread, next_thread = store.get_thread_neighbors(mlist_fqdn, threadid)

    sort_mode = request.GET.get("sort", "thread")
    thread.starting_email.myvote = thread.starting_email.get_vote_by_user_id(
            request.session.get("user_id"))

    # Tags
    tag_form = AddTagForm()
    try:
        tags = Tag.objects.filter(threadid=threadid, list_address=mlist_fqdn)
    except Tag.DoesNotExist:
        tags = []

    # Favorites
    fav_action = "add"
    if request.user.is_authenticated():
        try:
            Favorite.objects.get(list_address=mlist_fqdn, threadid=threadid,
                                 user=request.user)
        except Favorite.DoesNotExist:
            pass
        else:
            fav_action = "rm"

    # Category
    category, category_form = get_category_widget(request, thread.category)

    # Extract relative dates
    today = datetime.date.today()
    days_old = today - thread.starting_email.date.date()
    days_inactive = today - thread.last_email.date.date()

    mlist = store.get_list(mlist_fqdn)
    subject = stripped_subject(mlist, thread.starting_email.subject)

    # Last view
    last_view = None
    if request.user.is_authenticated():
        last_view_obj, created = LastView.objects.get_or_create(
                list_address=mlist_fqdn, threadid=threadid, user=request.user)
        if not created:
            last_view = last_view_obj.view_date
            last_view_obj.save() # update timestamp
    # get the number of unread messages
    if last_view is None:
        if request.user.is_authenticated():
            unread_count = len(thread)
        else:
            unread_count = 0
    else:
        # XXX: Storm-specific
        unread_count = thread.replies_after(last_view).count()

    # Flash messages
    flash_messages = []
    flash_msg = request.GET.get("msg")
    if flash_msg:
        flash_msg = { "type": FLASH_MESSAGES[flash_msg][0],
                      "msg": FLASH_MESSAGES[flash_msg][1] }
        flash_messages.append(flash_msg)

    # TODO: eventually move to a middleware ?
    # http://djangosnippets.org/snippets/1865/
    is_bot = True
    user_agent = request.META.get('HTTP_USER_AGENT', None)
    if user_agent:
        is_bot = robot_detection.is_robot(user_agent)

    context = {
        'mlist': mlist,
        'threadid': threadid,
        'subject': subject,
        'tags': tags,
        'addtag_form': tag_form,
        'month': thread.date_active,
        'first_mail': thread.starting_email,
        'prev_thread': prev_thread,
        'next_thread': next_thread,
        'months_list': get_months(store, mlist.name),
        'days_inactive': days_inactive.days,
        'days_old': days_old.days,
        'sort_mode': sort_mode,
        'fav_action': fav_action,
        'reply_form': ReplyForm(),
        'is_bot': is_bot,
        'num_comments': len(thread) - 1,
        'participants': thread.participants,
        'last_view': last_view,
        'unread_count': unread_count,
        'category_form': category_form,
        'category': category,
        'flash_messages': flash_messages,
    }
    context["participants"].sort(key=lambda p: p.name.lower())

    if is_bot:
        # Don't rely on AJAX to load the replies
        # The limit is a safety measure, don't let a bot kill the DB
        context["replies"] = _get_thread_replies(request, thread, limit=1000)

    return render(request, "thread.html", context)


@check_mlist_private
def replies(request, mlist_fqdn, threadid):
    """Get JSON encoded lists with the replies and the participants"""
    chunk_size = 5
    offset = int(request.GET.get("offset", "1"))
    store = get_store(request)
    thread = store.get_thread(mlist_fqdn, threadid)
    mlist = store.get_list(mlist_fqdn)
    # Last view
    last_view = request.GET.get("last_view")
    if last_view:
        try:
            last_view = datetime.datetime.fromtimestamp(int(last_view), utc)
        except ValueError:
            last_view = None
    context = {
        'mlist': mlist,
        'threadid': threadid,
        'reply_form': ReplyForm(),
        'last_view': last_view,
    }
    context["replies"] = _get_thread_replies(request, thread, offset=offset,
                                             limit=chunk_size)

    replies_tpl = loader.get_template('ajax/replies.html')
    replies_html = replies_tpl.render(RequestContext(request, context))
    response = {"replies_html": replies_html,
                "more_pending": False,
                "next_offset": None,
               }
    if len(context["replies"]) == chunk_size:
        response["more_pending"] = True
        response["next_offset"] = offset + chunk_size
    return HttpResponse(json.dumps(response),
                        content_type='application/javascript')


@check_mlist_private
def tags(request, mlist_fqdn, threadid):
    """ Add or remove one or more tags on a given thread. """
    if not request.user.is_authenticated():
        return HttpResponse('You must be logged in to add a tag',
                            content_type="text/plain", status=403)

    if request.method != 'POST':
        raise SuspiciousOperation
    action = request.POST.get("action")

    if action == "add":
        form = AddTagForm(request.POST)
        if not form.is_valid():
            return HttpResponse("Error adding tag: invalid data",
                                content_type="text/plain", status=500)
        tagname = form.data['tag']
    elif action == "rm":
        tagname = request.POST.get('tag')
    else:
        raise SuspiciousOperation
    tagnames = [ t.strip() for t in re.findall(r"[\w'_ -]+", tagname) ]
    for tagname in tagnames:
        try:
            tag = Tag.objects.get(threadid=threadid, list_address=mlist_fqdn,
                                  tag=tagname)
        except Tag.DoesNotExist:
            if action == "add":
                tag = Tag(list_address=mlist_fqdn, threadid=threadid,
                          tag=tagname, user=request.user)
                tag.save()
            elif action == "rm":
                raise Http404("No such tag: %s" % tagname)
        else:
            if action == "rm":
                tag.delete()

    # Now refresh the tag list
    tags = Tag.objects.filter(threadid=threadid, list_address=mlist_fqdn)
    FakeMList = namedtuple("MailingList", ["name"])
    tpl = loader.get_template('threads/tags.html')
    html = tpl.render(RequestContext(request, {
            "tags": tags,
            "mlist": FakeMList(name=mlist_fqdn),
            "threadid": threadid,
            }))

    response = {"tags": [ t.tag for t in tags ], "html": html}
    return HttpResponse(json.dumps(response),
                        content_type='application/javascript')

@check_mlist_private
def suggest_tags(request, mlist_fqdn, threadid):
    term = request.GET.get("term")
    current_tags = Tag.objects.filter(
            list_address=mlist_fqdn, threadid=threadid
            ).values_list("tag", flat=True)
    if term:
        tags = Tag.objects.filter(list_address=mlist_fqdn, tag__istartswith=term)
    else:
        tags = Tag.objects.all()
    tags = tags.exclude(tag__in=current_tags).values_list("tag", flat=True)
    tags = [ t.encode("utf8") for t in tags ]
    return HttpResponse(json.dumps(tags), content_type='application/javascript')


@check_mlist_private
def favorite(request, mlist_fqdn, threadid):
    """ Add or remove from favorites"""
    if not request.user.is_authenticated():
        return HttpResponse('You must be logged in to have favorites',
                            content_type="text/plain", status=403)

    if request.method != 'POST':
        raise SuspiciousOperation

    props = dict(list_address=mlist_fqdn, threadid=threadid, user=request.user)
    if request.POST["action"] == "add":
        try:
            fav = Favorite.objects.get(**props)
        except Favorite.DoesNotExist:
            fav = Favorite(**props)
        fav.save()
    elif request.POST["action"] == "rm":
        try:
            fav = Favorite.objects.get(**props)
        except Favorite.DoesNotExist:
            pass
        else:
            fav.delete()
    else:
        raise SuspiciousOperation
    return HttpResponse("success", content_type='text/plain')


@check_mlist_private
def set_category(request, mlist_fqdn, threadid):
    """ Set the category for a given thread. """
    if not request.user.is_authenticated():
        return HttpResponse('You must be logged in to add a tag',
                            content_type="text/plain", status=403)
    if request.method != 'POST':
        raise SuspiciousOperation

    store = get_store(request)
    category, category_form = get_category_widget(request)
    thread = store.get_thread(mlist_fqdn, threadid)
    if not category and thread.category:
        thread.category = None
        store.commit()
    elif category and category.name != thread.category:
        thread.category = category.name
        store.commit()

    # Now refresh the category widget
    FakeMList = namedtuple("MailingList", ["name"])
    context = {
            "category_form": category_form,
            "mlist": FakeMList(name=mlist_fqdn),
            "threadid": threadid,
            "category": category,
            }
    return render(request, "threads/category.html", context)


@check_mlist_private
def reattach(request, mlist_fqdn, threadid):
    if not request.user.is_staff:
        return HttpResponse('You must be a staff member to reattach a thread',
                            content_type="text/plain", status=403)
    flash_messages = []
    store = get_store(request)
    mlist = store.get_list(mlist_fqdn)
    thread = store.get_thread(mlist_fqdn, threadid)

    if request.method == 'POST':
        parent_tid = request.POST.get("parent")
        if not parent_tid:
            parent_tid = request.POST.get("parent-manual")
        if not parent_tid or not re.match("\w{32}", parent_tid):
            flash_messages.append({"type": "warning",
                                   "msg": "Invalid thread id, it should look "
                                          "like OUAASTM6GS4E5TEATD6R2VWMULG44NKJ."})
        elif parent_tid == threadid:
            flash_messages.append({"type": "warning",
                                   "msg": "Can't re-attach a thread to "
                                          "itself, check your thread ID."})
        else:
            new_thread = store.get_thread(mlist_fqdn, parent_tid)
            if new_thread is None:
                flash_messages.append({"type": "warning",
                                       "msg": "Unknown thread, check your "
                                              "thread ID."})
            elif thread.starting_email.date <= new_thread.starting_email.date:
                flash_messages.append({"type": "error",
                                       "msg": "Can't attach an older thread "
                                              "to a newer thread."})
            else:
                for msg in thread.emails:
                    store.attach_to_thread(msg, new_thread)
                store.delete_thread(mlist_fqdn, threadid)
                return redirect(reverse(
                        'thread', kwargs={
                            "mlist_fqdn": mlist_fqdn,
                            'threadid': parent_tid,
                        })+"?msg=attached-ok")


    context = {
        'mlist' : mlist,
        'thread': thread,
        'months_list': get_months(store, mlist.name),
        'flash_messages': flash_messages,
    }
    return render(request, "reattach.html", context)


@check_mlist_private
def reattach_suggest(request, mlist_fqdn, threadid):
    store = get_store(request)
    mlist = store.get_list(mlist_fqdn)
    thread = store.get_thread(mlist_fqdn, threadid)

    default_search_query = stripped_subject(
        mlist, thread.subject).lower().replace("re:", "")
    search_query = request.GET.get("q")
    if not search_query:
        search_query = default_search_query
    search_query = search_query.strip()
    if store.search_index:
        search_result = store.search(search_query, mlist_fqdn, 1, 50)
        messages = search_result["results"]
    else:
        messages = []
    suggested_threads = []
    for msg in messages:
        if msg.thread not in suggested_threads and msg.thread_id != threadid:
            suggested_threads.append(msg.thread)

    context = {
        'mlist' : mlist,
        'suggested_threads': suggested_threads[:10],
    }
    return render(request, "ajax/reattach_suggest.html", context)

########NEW FILE########
__FILENAME__ = users
# -*- coding: utf-8 -*-
# Copyright (C) 1998-2012 by the Free Software Foundation, Inc.
#
# This file is part of HyperKitty.
#
# HyperKitty is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# HyperKitty is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# HyperKitty.  If not, see <http://www.gnu.org/licenses/>.
#
#

from django.http import Http404

def users(request):
    raise Http404("This feature has not been implemented yet.")

def public_profile(request, user_id):
    raise Http404("This feature has not been implemented yet.")

########NEW FILE########
