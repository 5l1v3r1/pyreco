__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-ecstatic documentation build configuration file, created by
# sphinx-quickstart on Fri Jan 25 21:54:20 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import re, sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('.'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'docs_settings'

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-ecstatic'
copyright = u'2013, Matthew Tretter'

pkgmeta = {}
execfile(os.path.join(os.path.dirname(__file__), '..', '..', 'ecstatic',
                      'pkgmeta.py'), pkgmeta)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = re.match('\d+\.\d+', pkgmeta['__version__']).group()
# The full version, including alpha/beta/rc tags.
release = pkgmeta['__version__']

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-ecstaticdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-ecstatic.tex', u'django-ecstatic Documentation',
   u'Matthew Tretter', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-ecstatic', u'django-ecstatic Documentation',
     [u'Matthew Tretter'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-ecstatic', u'django-ecstatic Documentation',
   u'Matthew Tretter', 'django-ecstatic', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = docs_settings

########NEW FILE########
__FILENAME__ = conf
from appconf import AppConf
from django.conf import settings


class EcstaticConf(AppConf):
    MANIFEST = 'ecstatic.manifests.JsonManifest'
    MANIFEST_FILE = None
    MANIFEST_EXCLUDES = ['CVS', '.*', '*~']
    MANIFEST_EXTRAS = ['admin/']
    USE_MANIFEST = not settings.DEBUG
    MANIFEST_CACHE = 'ecstatic_manifest' if 'ecstatic_manifest' in settings.CACHES else 'default'
    STRICT = False

########NEW FILE########
__FILENAME__ = createstaticmanifest
from django.conf import settings
from django.contrib.staticfiles import finders
from django.core.management.base import NoArgsCommand
from django.utils.datastructures import SortedDict
import os
from ..utils import StorageOverrideMixin
from ...manifests import ConfiguredStaticFilesManifest


class Command(StorageOverrideMixin, NoArgsCommand):
    """
    Creates a staticfiles manifest. The exact format of the manifest is defined
    by ``ECSTATIC_MANIFEST``. By default, it's a JSON file.

    """
    help = 'Creates a file that maps static file names to their URLs.'

    def handle_noargs(self, **options):
        self.set_options(**options)

        found_files = SortedDict()
        manifest = ConfiguredStaticFilesManifest()
        manifest.clear()

        ignore_patterns = getattr(settings, 'ECSTATIC_MANIFEST_EXCLUDES', [])

        for finder in finders.get_finders():
            for path, storage in finder.list(ignore_patterns):
                # Prefix the relative path if the source storage contains it
                if getattr(storage, 'prefix', None):
                    prefixed_path = os.path.join(storage.prefix, path)
                else:
                    prefixed_path = path

                if prefixed_path not in found_files:
                    found_files[prefixed_path] = path

        for path in found_files.values() + settings.ECSTATIC_MANIFEST_EXTRAS:
            try:
                generate_url = self.storage.generate_url
            except AttributeError:
                raise AttributeError('%s doesn\'t define a generate_url method.'
                        ' Did you remember to extend StaticManifestMixin?' %
                        self.storage)
            hashed_name = generate_url(path)
            manifest.add(path, hashed_name)

        manifest.flush()

########NEW FILE########
__FILENAME__ = eccollect
import os
import sys

from django.contrib.staticfiles.management.commands.collectstatic import Command as CollectStatic
from django.core.management.base import CommandError
from django.contrib.staticfiles import finders
from django.utils.datastructures import SortedDict
from hashlib import md5
from optparse import make_option
from ..utils import StorageOverrideMixin


class CollectNewMixin(object):

    comparison_method_aliases = {
        'md5': 'file_hash',
        'mtime': 'modified_time',
    }

    def __init__(self, *args, **kwargs):
        self.option_list = list(self.option_list) + [
            make_option('--compare', default='modified_time',
                dest='comparison_method',
                help='The comparison method to use in order to determine which'
                    ' file is newer. Options are modified_time/mtime and'
                    ' file_hash/md5. Note that, with file_hash, the file will'
                    ' be opened if the storage does not define a file_hash'
                    ' method, so you should define a file_hash method for'
                    ' remote storage backends (or avoid the file_hash'
                    ' comparison method). The modified_time method must return'
                    ' a local datetime; file_hash must return an md5'
                    ' hexdigest.'),
            make_option('--pp', default='default',
                action="store", dest='pp', type="string",
                help='The default behavior of collectstatic is to collect'
                    ' the files first then batch post-process them.'
                    ' Ommiting the --pp option or passing it default produces'
                    ' this default behavior. Passing in progressive will'
                    ' post-process each individual file after it\'s collected')
        ]
        super(CollectNewMixin, self).__init__(*args, **kwargs)

    def collect(self):
        """
        Perform the bulk of the work of collectstatic.

        Split off from handle_noargs() to facilitate testing.
        """
        if self.symlink:
            if sys.platform == 'win32':
                raise CommandError("Symlinking is not supported by this "
                                   "platform (%s)." % sys.platform)
            if not self.local:
                raise CommandError("Can't symlink to a remote destination.")

        if self.clear:
            self.clear_dir('')

        handler = self._get_handler()

        do_post_process = self.post_process and hasattr(self.storage, 'post_process')

        found_files = SortedDict()
        for finder in finders.get_finders():
            for path, storage in finder.list(self.ignore_patterns):
                # Prefix the relative path if the source storage contains it
                if getattr(storage, 'prefix', None):
                    prefixed_path = os.path.join(storage.prefix, path)
                else:
                    prefixed_path = path

                if prefixed_path not in found_files:
                    found_files[prefixed_path] = (storage, path)
                    handler(path, prefixed_path, storage)
                    if self.progressive_post_process and do_post_process:
                        try:
                            self._post_process(
                                    {prefixed_path: (storage, path)},
                                    self.dry_run)
                        except ValueError as e:
                            message = ('%s current storage requires all files'
                                ' to have been collected first. Try '
                                ' ecstatic.storage.CachedStaticFilesStorage' \
                                % e)
                            raise ValueError(message)

        if not self.progressive_post_process and do_post_process:
            self._post_process(found_files, self.dry_run)

        return {
            'modified': self.copied_files + self.symlinked_files,
            'unmodified': self.unmodified_files,
            'post_processed': self.post_processed_files,
        }

    def set_options(self, **options):
        super(CollectNewMixin, self).set_options(**options)
        comparison_method = options.get('comparison_method')
        self.comparison_method = self.comparison_method_aliases.get(comparison_method, comparison_method)
        pp = options.get('pp')
        if pp == 'default':
            self.progressive_post_process = False
        elif pp == 'progressive':
            self.progressive_post_process = True
        else:
            raise CommandError("--pp must be 'default' or 'progressive'.")

    def delete_file(self, path, prefixed_path, source_storage):
        if self.comparison_method == 'modified_time':
            return CollectStatic.delete_file(self, path, prefixed_path, source_storage)
        elif self.storage.exists(prefixed_path):
            should_delete = self.compare(path, prefixed_path, source_storage)
            if should_delete:
                if self.dry_run:
                    self.log(u"Pretending to delete '%s'" % path)
                else:
                    self.log(u"Deleting '%s'" % path)
                    self.storage.delete(prefixed_path)
            else:
                self.log(u"Skipping '%s' (not modified)" % path)
                return False
        return True

    def compare(self, path, prefixed_path, source_storage):
        """
        Returns True if the file should be copied.
        """
        # First try a method on the command named compare_<comparison_method>
        # If that doesn't exist, create a comparitor that calls methods on the
        # storage with the name <comparison_method>, passing them the name.
        comparitor = getattr(self, 'compare_%s' % self.comparison_method, None)
        if not comparitor:
            comparitor = self._create_comparitor(self.comparison_method)
        return comparitor(path, prefixed_path, source_storage)

    def _create_comparitor(self, comparison_method):
        def comparitor(path, prefixed_path, source_storage):
            # If both storage objects don't implement a method with a name that
            # matches the comparison method, this will raise an exception.
            source_fn = getattr(source_storage, comparison_method)
            dest_fn = getattr(self.storage, comparison_method)
            source_value = source_fn(path)
            dest_value = dest_fn(path)
            return source_value == dest_value
        return comparitor

    def compare_file_hash(self, path, prefixed_path, source_storage):
        old_md5 = self._get_md5(self.storage, path)
        new_md5 = self._get_md5(source_storage, prefixed_path)
        return old_md5 != new_md5

    def _get_md5(self, storage, name):
        fn = getattr(storage, 'file_hash', None)
        if fn:
            return fn(name)
        else:
            file = storage.open(name)
            contents = file.read()
            return md5(contents).hexdigest()

    def _post_process(self, found_files, dry_run):
        processor = self.storage.post_process(found_files, dry_run=dry_run)
        for original_path, processed_path, processed in processor:
            if processed:
                self.log(u"Post-processed '%s' as '%s" %
                         (original_path, processed_path), level=1)
                self.post_processed_files.append(original_path)
            else:
                self.log(u"Skipped post-processing '%s'" % original_path)

    def _get_handler(self):
        return self.link_file if self.symlink else self.copy_file


class Command(StorageOverrideMixin, CollectNewMixin, CollectStatic):
    """
    A version of Django's ``collectstatic`` with some useful extra options. For
    example, you can choose to only collect new files (which is great for
    collecting to a CDN).

    """
    pass

########NEW FILE########
__FILENAME__ = hashmedianames
from django.core.management.base import BaseCommand
from django.db.models import get_models
from django.db.models.fields.files import ImageField, FileField
import os
from ...utils import get_hashed_filename


class Command(BaseCommand):
    help = 'Renames existing media files to include a hash of their contents.'

    def handle(self, *args, **options):
        for model in get_models():
            # See if the model has any ImageFields or FileFields
            # TODO: Add setting for field types
            field_names = [f.name for f in model._meta.fields if type(f) in
                    (ImageField, FileField)]

            if field_names:
                print('Hashing filenames for %s.%s...' % (model._meta.app_label,
                                          model._meta.object_name))

                for m in model.objects.all():
                    updated = False
                    for field_name in field_names:
                        updated = updated or self.rename_file(m, field_name)
                    if updated:
                        m.save()

    def rename_file(self, instance, field_name):
        """
        Renames a file and updates the model field to point to the new file.
        Returns True if a change has been made; otherwise False

        """
        file = getattr(instance, field_name)

        if file:
            new_name = get_hashed_filename(file.name, file)
            if new_name != file.name:
                print('    Renaming "%s" to "%s"' % (file.name, new_name))
                file.save(os.path.basename(new_name), file, save=False)
                return True

        return False

########NEW FILE########
__FILENAME__ = utils
from django.contrib.staticfiles.storage import staticfiles_storage
from django.core.files.storage import get_storage_class
from optparse import make_option


class StorageOverrideMixin(object):
    def __init__(self, *args, **kwargs):
        self.option_list = self.option_list + (
            make_option('-s', '--storage', action='store',
                dest='storage_override', type="string",
                help='override default storage backend'),
        )
        super(StorageOverrideMixin, self).__init__(*args, **kwargs)

    def set_options(self, **options):
        try:
            super_set_options = super(StorageOverrideMixin, self).set_options
        except AttributeError:
            pass
        else:
            super_set_options(**options)

        storage_override = options.get('storage_override')
        if storage_override:
            cls = get_storage_class(storage_override)
            self.storage = cls()
        else:
            self.storage = staticfiles_storage

        try:
            self.storage.path('')
        except NotImplementedError:
            self.local = False
        else:
            self.local = True

########NEW FILE########
__FILENAME__ = manifests
from django.conf import settings
from django.core.cache import get_cache
from django.core.exceptions import ImproperlyConfigured
from django.utils import simplejson as json
from django.utils.functional import LazyObject
from django.utils.importlib import import_module
import os


class NotInManifest(Exception):
    pass


class JsonManifest(object):
    _cleared = False
    _data = {}

    def clear(self):
        self._cleared = True
        self._data = {}

    def add(self, key, value):
        self._data[key] = value

    def flush(self):
        file = open(settings.ECSTATIC_MANIFEST_FILE, mode='w+')
        data = {}

        if not self._cleared:
            # Load the existing data from the file
            is_empty = file.read(1) is None
            file.seek(0)
            if not is_empty:
                data = json.load(file)

        self._data.update(data)
        json.dump(self._data, file, indent=4)
        file.truncate()
        file.close()
        self._data = {}
        self._cleared = False

    def _get_cache_key(self, name, manifest_mtime):
        return 'ecstatic:staticmanifest:%s:%s' % (manifest_mtime, name)

    def get(self, key):
        manifest_mtime = os.path.getmtime(settings.ECSTATIC_MANIFEST_FILE)
        cache_key = self._get_cache_key(key, manifest_mtime)
        cache = get_cache(settings.ECSTATIC_MANIFEST_CACHE)
        value = cache.get(cache_key)
        if value is None:
            # Populate the cache with the entire contents of the manifest.
            # The manifest should fit in the cache, so this will reduce the
            # number of times we need to read the file.
            file = open(settings.ECSTATIC_MANIFEST_FILE)
            data = json.load(file)
            for name, url in data.items():
                cache.set(self._get_cache_key(name, manifest_mtime), url)
                if name == key:
                    value = url
        if value is None:
            raise NotInManifest('The file "%s" was not found in the'
                                ' manifest.' % key)
        return value


class ConfiguredStaticFilesManifest(LazyObject):
    def _setup(self):
        self._wrapped = get_manifest_class(settings.ECSTATIC_MANIFEST)()


def get_manifest_class(import_path=None):
    try:
        dot = import_path.rindex('.')
    except ValueError:
        raise ImproperlyConfigured("%s isn't a manifest module." % import_path)
    module, classname = import_path[:dot], import_path[dot + 1:]
    try:
        mod = import_module(module)
    except ImportError as e:
        raise ImproperlyConfigured('Error importing manifest module %s: "%s"' % (module, e))
    try:
        return getattr(mod, classname)
    except AttributeError:
        raise ImproperlyConfigured('Manifest module "%s" does not define a "%s" class.' % (module, classname))


staticfiles_manifest = ConfiguredStaticFilesManifest()

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = pkgmeta
__title__ = 'django-ecstatic'
__author__ = 'Matthew Tretter'
__version__ = '0.2.0'
__all__ = ['__title__', '__author__', '__version__']

########NEW FILE########
__FILENAME__ = storage
from contextlib import contextmanager
from django.conf import settings
from django.contrib.staticfiles import finders
from django.contrib.staticfiles.storage import (StaticFilesStorage,
        CachedFilesMixin as _CachedFilesMixin)
from django.core.files import File
from django.core.files.storage import FileSystemStorage
from fnmatch import fnmatch
import itertools
import os
import types
from .manifests import staticfiles_manifest
from .utils import get_hashed_filename, split_filename


@contextmanager
def patched_name_fn(storage, fn_name, desc):
    original_fn = getattr(storage, fn_name)

    def patched(self, name, *args, **kwargs):
        try:
            return original_fn(name, *args, **kwargs)
        except Exception as exc:
            if self.strict:
                raise

            # TODO: Real warning?
            print('WARNING: Could not get %s for "%s". Using "%s" instead.'
                  ' To change this behavior, set your storage\'s `strict`'
                  ' attribute to `False`. Error was: %s'
                  % (desc, name, name, exc))
            # Increment error count.
            setattr(self, '_post_process_error_count',
                    getattr(self, '_post_process_error_count', 0))
            self._post_process_error_count += 1
            return name

    method = types.MethodType(patched, storage)
    setattr(storage, fn_name, method)

    yield

    setattr(storage, fn_name, original_fn)


@contextmanager
def post_process_error_counter(storage):
    storage._post_process_error_count = 0
    yield
    storage._post_process_error_count = 0


class LaxPostProcessorMixin(object):
    strict = settings.ECSTATIC_STRICT

    def post_process(self, paths, dry_run=False, **options):
        """
        Overridden to work around https://code.djangoproject.com/ticket/19111
        """
        with post_process_error_counter(self):
            with patched_name_fn(self, 'hashed_name', 'hashed name'):
                with patched_name_fn(self, 'url', 'url'):
                    for result in super(LaxPostProcessorMixin,
                                        self).post_process(paths, dry_run, **options):
                        yield result
            error_count = self._post_process_error_count
            if error_count:
                print('%s post-processing error%s.' % (error_count,
                        '' if error_count == 1 else 's'))


class CachedFilesMixin(LaxPostProcessorMixin, _CachedFilesMixin):
    """
    A subclass of ``django.contrib.staticfiles.storage.CachedFilesMixin`` that
    allows you to exclude files from postprocessing.

    """
    postprocess_exclusions = []

    def exclude_file(self, name):
        return any(fnmatch(name, pattern) for pattern in
                self.postprocess_exclusions)

    def hashed_name(self, name, content=None):
        if not self.exclude_file(name):
            name = super(CachedFilesMixin, self).hashed_name(name, content)
        return name

    def post_process(self, paths, dry_run=False, **options):
        """
        Overridden to allow some files to be excluded (using
        ``postprocess_exclusions``)

        """
        if self.postprocess_exclusions:
            paths = dict((k, v) for k, v in paths.items() if not
                    self.exclude_file(k))
        return super(CachedFilesMixin, self).post_process(paths,
                dry_run, **options)


class UncollectedFileHashMixin(object):
    """
    A mixin that uses the local version of the static file to compute the hash.
    This removes at least one network connection when using a remote storage
    (``CachedFilesMixin.hashed_name``'s checks for existence and opening of the
    file) but adds the requirement that the static files be locally accessible
    (which they should be already).

    """
    def hashed_name(self, name, content=None):
        if content is None:
            path = finders.find(name)

            if path:
                # Really, we should be using the associated storage object to open
                # the file, but Django doesn't seem to expose that, so we just
                # assume it's a file on the local filesystem.
                content = File(open(path))
            else:
                raise ValueError('No static file name "%s" exists.' % name)

        return super(UncollectedFileHashMixin, self).hashed_name(name, content)


class CachedStaticFilesMixin(UncollectedFileHashMixin, CachedFilesMixin):
    pass


class CachedStaticFilesStorage(CachedFilesMixin, StaticFilesStorage):
    """
    A static file system storage backend which also saves
    hashed copies of the files it saves.
    """
    pass


# FIXME: extract a mixin
class HashedNameFileSystemStorage(FileSystemStorage):
    def get_available_name(self, name):
        dir_name, filename = os.path.split(name)
        basename, hash, ext = split_filename(filename)

        count = itertools.count(1)
        while self.exists(name):
            name = os.path.join(dir_name, '%s_%s%s%s' % (basename, count.next(),
                                                         hash, ext))

        return name

    def save(self, name, content):
        name = get_hashed_filename(name, content)
        return super(HashedNameFileSystemStorage, self).save(name, content)


class StaticManifestMixin(object):
    """
    A mixin that uses a manifest file to get URLs.

    """
    def generate_url(self, name):
        return super(StaticManifestMixin, self).url(name, force=True)

    def url(self, name, force=False):
        if not settings.ECSTATIC_USE_MANIFEST and not force:
            return super(StaticManifestMixin, self).url(name, force)

        return staticfiles_manifest.get(name)

########NEW FILE########
__FILENAME__ = utils
from contextlib import contextmanager
from django.conf import settings
from hashlib import md5
import re


@contextmanager
def patched_settings(**kwargs):
    old = {}
    for k, v in kwargs.items():
        try:
            old[k] = getattr(settings, k)
        except AttributeError:
            pass
        setattr(settings, k, v)
    yield
    for k, v in old.items():
        setattr(settings, k, v)


hashed_filename_pattern = r"""
    (?P<name>.+?)                  # A basename that's at least 1 char long
    (
        (?P<hash>\.[a-f0-9]{12})?  # A 12-character hexidecimal hash, only matched if an extension is also found
        (?P<ext>\.[^\.]+)          # An extension
    )?                             # The hash and extension are optional
    $                              # The end of the string
    """

hashed_filename_re = re.compile(hashed_filename_pattern, re.VERBOSE)


def get_hashed_filename(name, file, suffix=None):
    """
    Gets a new filename for the provided file of the form
    "oldfilename.hash.ext". If the old filename looks like it already contains a
    hash, it will be replaced (so you don't end up with names like
    "pic.hash.hash.ext")

    """
    basename, hash, ext = split_filename(name)
    file.seek(0)
    new_hash = '.%s' % md5(file.read()).hexdigest()[:12]
    if suffix is not None:
        basename = '%s_%s' % (basename, suffix)
    return '%s%s%s' % (basename, new_hash, ext)


def split_filename(name):
    """
    Splits the filename into three parts: the name part, the hash part, and the
    extension. Like with the extension, the hash part starts with a dot.

    """
    parts = hashed_filename_re.match(name).groupdict()
    return (parts['name'] or '', parts['hash'] or '', parts['ext'] or '')

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = settings
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'testdb'
    }
}

########NEW FILE########
