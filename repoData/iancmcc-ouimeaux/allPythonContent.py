__FILENAME__ = conf
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# complexity documentation build configuration file, created by
# sphinx-quickstart on Tue Jul  9 22:26:36 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# Get the project root dir, which is the parent dir of this
cwd = os.getcwd()
project_root = os.path.dirname(cwd)

# Insert the project root dir as the first element in the PYTHONPATH.
# This lets us ensure that the source package is imported, and that its
# version is used.
sys.path.insert(0, project_root)

import ouimeaux

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'ouimeaux'
copyright = u'2014, Ian McCracken'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = ouimeaux.__version__
# The full version, including alpha/beta/rc tags.
release = ouimeaux.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'ouimeauxdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'ouimeaux.tex', u'ouimeaux Documentation',
   u'Ian McCracken', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'ouimeaux', u'ouimeaux Documentation',
     [u'Ian McCracken'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'ouimeaux', u'ouimeaux Documentation',
   u'Ian McCracken', 'ouimeaux', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False
########NEW FILE########
__FILENAME__ = cli
import os
import sys
import logging
import argparse

from .discovery import UPnPLoopbackException
from .environment import Environment
from .config import get_cache, in_home, WemoConfiguration
from .utils import matcher

reqlog = logging.getLogger("requests.packages.urllib3.connectionpool")
reqlog.disabled = True

NOOP = lambda *x: None


def _state(device, readable=False):
    state = device.get_state(force_update=True)
    if readable:
        return "on" if state else "off"
    else:
        return state


def scan(args, on_switch=NOOP, on_motion=NOOP):
    try:
        env = Environment(on_switch, on_motion, with_subscribers=False,
                          bind=args.bind, with_cache=args.use_cache)
        env.start()
        with get_cache() as c:
            if c.empty:
                args.use_cache = False
        if (args.use_cache is not None and not args.use_cache) or (
                    env._config.cache is not None and not env._config.cache):
            env.discover(args.timeout)
    except KeyboardInterrupt:
        sys.exit(0)
    except UPnPLoopbackException:
        print """
Loopback interface is being used! You will probably not receive any responses 
from devices.  Use ifconfig to find your IP address, then either pass the 
--bind argument or edit ~/.wemo/config.yml to specify the IP to which devices 
should call back during discovery.""".strip()
        sys.exit(1)


def switch(args):
    if args.state.lower() in ("on", "1", "true"):
        state = "on"
    elif args.state.lower() in ("off", "0", "false"):
        state = "off"
    elif args.state.lower() == "toggle":
        state = "toggle"
    elif args.state.lower() == "status":
        state = "status"
    else:
        print """No valid action specified. 
Usage: wemo switch NAME (on|off|toggle|status)"""
        sys.exit(1)

    device_name = args.device
    alias = WemoConfiguration().aliases.get(device_name)
    if alias:
        matches = lambda x:x == alias
    elif device_name:
        matches = matcher(device_name)
    else:
        matches = NOOP

    def on_switch(switch):
        if matches(switch.name):
            if state == "toggle":
                found_state = switch.get_state(force_update=True)
                switch.set_state(not found_state)
            elif state == "status":
                print _state(switch, args.human_readable)
            else:
                getattr(switch, state)()
            sys.exit(0)

    scan(args, on_switch)
    # If we got here, we didn't find anything
    print "No device found with that name."
    sys.exit(1)


def list_(args):

    def on_switch(switch):
        print "Switch:", switch.name

    def on_motion(motion):
        print "Motion:", motion.name

    scan(args, on_switch, on_motion)


def status(args):

    def on_switch(switch):
        print "Switch:", switch.name, '\t', _state(switch, args.human_readable)

    def on_motion(motion):
        print "Motion:", motion.name, '\t', _state(motion, args.human_readable)

    scan(args, on_switch, on_motion)


def clear(args):
    for fname in 'cache', 'cache.db':
        filename = in_home('.wemo', fname)
        try:
            os.remove(filename)
        except OSError:
            # File didn't exist; cache must be clear
            pass
    print "Device cache cleared."


def server(args):
    from socketio.server import SocketIOServer
    from ouimeaux.server import app, initialize
    initialize()
    level = logging.INFO
    if getattr(args, 'debug', False):
        level = logging.DEBUG
    logging.basicConfig(level=level)
    try:
        # TODO: Move this to configuration
        listen = WemoConfiguration().listen or '0.0.0.0:5000'
        try:
            host, port = listen.split(':')
        except Exception:
            print "Invalid bind address configuration:", listen
            sys.exit(1)
        SocketIOServer((host, int(port)), app,
                       policy_server=False,
                       namespace="socket.io").serve_forever()
    except (KeyboardInterrupt, SystemExit):
        sys.exit(0)


def wemo():
    parser = argparse.ArgumentParser()

    parser.add_argument("-b", "--bind", default=None,
                        help="ip:port to which to bind the response server."
                             " Default is localhost:54321")
    parser.add_argument("-d", "--debug", action="store_true", default=False,
                        help="Enable debug logging")
    parser.add_argument("-e", "--exact-match", action="store_true", 
                        default=False,
                        help="Disable fuzzy matching for device names")
    parser.add_argument("-f", "--no-cache", dest="use_cache", default=None,
                        action="store_false",
                        help="Disable the device cache")
    parser.add_argument("-v", "--human-readable", dest="human_readable", 
                        action="store_true", default=False,
                        help="Print statuses as human-readable words")
    parser.add_argument("-t", "--timeout", type=int, default=5,
                        help="Time in seconds to allow for discovery")
    subparsers = parser.add_subparsers()

    clearparser = subparsers.add_parser("clear", 
                                        help="Clear the device cache")
    clearparser.set_defaults(func=clear)

    statusparser = subparsers.add_parser("status", 
                                         help="Print status of WeMo devices")
    statusparser.set_defaults(func=status)

    stateparser = subparsers.add_parser("switch",
                                        help="Turn a WeMo Switch on or off")
    stateparser.add_argument("device", help="Name or alias of the device")
    stateparser.add_argument("state", help="'on' or 'off")
    stateparser.set_defaults(func=switch)

    listparser = subparsers.add_parser("list",
                          help="List all devices found in the environment")
    listparser.set_defaults(func=list_)

    serverparser = subparsers.add_parser("server",
                          help="Run the API server and web app")
    serverparser.set_defaults(func=server)

    args = parser.parse_args()

    if getattr(args, 'debug', False):
        logging.basicConfig(level=logging.DEBUG)

    args.func(args)

########NEW FILE########
__FILENAME__ = config
from contextlib import contextmanager, closing
import os
import shelve
import gevent
from gevent.lock import RLock

import yaml
from ouimeaux.device import Device


def in_home(*path):
    try:
        from win32com.shell import shellcon, shell
    except ImportError:
        home = os.path.expanduser("~")
    else:
        home = shell.SHGetFolderPath(0, shellcon.CSIDL_APPDATA, 0, 0)
    return os.path.join(home, *path)


def ensure_directory(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)
    return directory


class WemoConfiguration(object):
    def __init__(self, filename=None):
        if filename is None:
            ensure_directory(in_home('.wemo'))
            filename = in_home('.wemo', 'config.yml')
        if not os.path.isfile(filename):
            with open(filename, 'w') as f:
                f.write("""
aliases:
# Shortcuts to longer device names. Uncommenting the following
# line will allow you to execute 'wemo switch lr on' instead of
# 'wemo switch "Living Room Lights" on'
#
#    lr: Living Room Lights

# ip:port to bind to when receiving responses from discovery.
# The default is first DNS resolution of local host, port 54321
#
# bind: 10.1.2.3:9090

# Whether to use a device cache (stored at ~/.wemo/cache)
#
# cache: true

# Web app bind address
#
# listen: 0.0.0.0:5000
""")
        with open(filename, 'r') as cfg:
            self._parsed = yaml.load(cfg)

    @property
    def aliases(self):
        return self._parsed.get('aliases') or {}

    @property
    def bind(self):
        return self._parsed.get('bind', None)

    @property
    def cache(self):
        return self._parsed.get('cache', None)

    @property
    def listen(self):
        return self._parsed.get('listen', None)


class Cache(object):
    def __init__(self, shelf):
        self._shelf = shelf

    @property
    def empty(self):
        return not self._shelf.get('devices')

    def add_device(self, device):
        assert isinstance(device, Device)
        d = self._shelf.setdefault('devices', {})
        d[device.name] = device

    @property
    def devices(self):
        try:
            return self._shelf.setdefault('devices', {}).itervalues()
        except ImportError:
            self._shelf.clear()
            return self.devices


_CACHE_LOCK = RLock()

@contextmanager
def get_cache():
    ensure_directory(in_home('.wemo'))
    filename = in_home('.wemo', 'cache')
    _CACHE_LOCK.acquire(blocking=True)
    try:
        with closing(shelve.open(filename, writeback=True)) as cache:
            yield Cache(cache)
    finally:
        _CACHE_LOCK.release()


########NEW FILE########
__FILENAME__ = service
import logging
from xml.etree import cElementTree as et

import requests

from .xsd import service as serviceParser


log = logging.getLogger(__name__)

REQUEST_TEMPLATE = """
<?xml version="1.0" encoding="utf-8"?>
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
 <s:Body>
  <u:{action} xmlns:u="{service}">
   {args}
  </u:{action}>
 </s:Body>
</s:Envelope>
"""


class Action(object):
    def __init__(self, service, action_config):
        self._action_config = action_config
        self.name = action_config.get_name()
        self.serviceType = service.serviceType
        self.controlURL = service.controlURL
        self.args = {}
        self.headers = {
            'Content-Type': 'text/xml',
            'SOAPACTION': '"%s#%s"' % (self.serviceType, self.name)
        }
        arglist = action_config.get_argumentList()
        if arglist is not None:
            for arg in arglist.get_argument():
                # TODO: Get type instead of setting 0
                self.args[arg.get_name()] = 0

    def __call__(self, **kwargs):
        arglist = '\n'.join('<{0}>{1}</{0}>'.format(arg, value)
                            for arg, value in kwargs.iteritems())
        body = REQUEST_TEMPLATE.format(
            action=self.name,
            service=self.serviceType,
            args=arglist
        )
        response = requests.post(self.controlURL, body.strip(), headers=self.headers)
        d = {}
        for r in et.fromstring(response.content).getchildren()[0].getchildren()[0].getchildren():
            d[r.tag] = r.text
        return d

    def __repr__(self):
        return "<Action %s(%s)>" % (self.name, ", ".join(self.args))


class Service(object):
    """
    Represents an instance of a service on a device.
    """

    def __init__(self, service, base_url):
        self._base_url = base_url.rstrip('/')
        self._config = service
        url = '%s/%s' % (base_url, service.get_SCPDURL().strip('/'))
        xml = requests.get(url)
        self.actions = {}
        self._svc_config = serviceParser.parseString(xml.content).actionList
        for action in self._svc_config.get_action():
            act = Action(self, action)
            name = action.get_name()
            self.actions[name] = act
            setattr(self, name, act)

    @property
    def hostname(self):
        return self._base_url.split('/')[-1]

    @property
    def controlURL(self):
        return '%s/%s' % (self._base_url,
                          self._config.get_controlURL().strip('/'))

    @property
    def serviceType(self):
        return self._config.get_serviceType()


########NEW FILE########
__FILENAME__ = device
#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Jan 31 15:50:44 2013 by generateDS.py version 2.8b.
#

import sys
import getopt
import re as re_
import base64
from datetime import datetime, tzinfo, timedelta

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(tzinfo):
            def __init__(self, offset, name):
                self.__offset = timedelta(minutes = offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S')
            else:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S.%f')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_datetime(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S')
            return dt.replace(tzinfo = tz)

        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%d')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_date(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%d').replace(tzinfo = tz)
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' %
                (self.name, base64.b64encode(self.value), self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class root(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, specVersion=None, URLBase=None, device=None):
        self.specVersion = specVersion
        self.URLBase = URLBase
        self.device = device
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if root.subclass:
            return root.subclass(*args_, **kwargs_)
        else:
            return root(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specVersion(self): return self.specVersion
    def set_specVersion(self, specVersion): self.specVersion = specVersion
    def get_URLBase(self): return self.URLBase
    def set_URLBase(self, URLBase): self.URLBase = URLBase
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='tns:', name_='root', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='root')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='root'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='root', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.specVersion is not None:
            self.specVersion.export(outfile, level, namespace_, name_='specVersion', pretty_print=pretty_print)
        if self.URLBase is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURLBase>%s</%sURLBase>%s' % (namespace_, self.gds_format_string(quote_xml(self.URLBase).encode(ExternalEncoding), input_name='URLBase'), namespace_, eol_))
        if self.device is not None:
            self.device.export(outfile, level, namespace_, name_='device', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.specVersion is not None or
            self.URLBase is not None or
            self.device is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='root'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.specVersion is not None:
            showIndent(outfile, level)
            outfile.write('specVersion=model_.SpecVersionType(\n')
            self.specVersion.exportLiteral(outfile, level, name_='specVersion')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.URLBase is not None:
            showIndent(outfile, level)
            outfile.write('URLBase=%s,\n' % quote_python(self.URLBase).encode(ExternalEncoding))
        if self.device is not None:
            showIndent(outfile, level)
            outfile.write('device=model_.DeviceType(\n')
            self.device.exportLiteral(outfile, level, name_='device')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'specVersion':
            obj_ = SpecVersionType.factory()
            obj_.build(child_)
            self.set_specVersion(obj_)
        elif nodeName_ == 'URLBase':
            URLBase_ = child_.text
            URLBase_ = self.gds_validate_string(URLBase_, node, 'URLBase')
            self.URLBase = URLBase_
        elif nodeName_ == 'device':
            obj_ = DeviceType.factory()
            obj_.build(child_)
            self.set_device(obj_)
# end class root


class SpecVersionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, major=None, minor=None):
        self.major = major
        self.minor = minor
    def factory(*args_, **kwargs_):
        if SpecVersionType.subclass:
            return SpecVersionType.subclass(*args_, **kwargs_)
        else:
            return SpecVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_major(self): return self.major
    def set_major(self, major): self.major = major
    def get_minor(self): return self.minor
    def set_minor(self, minor): self.minor = minor
    def export(self, outfile, level, namespace_='tns:', name_='SpecVersionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecVersionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='SpecVersionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='SpecVersionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.major is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smajor>%s</%smajor>%s' % (namespace_, self.gds_format_integer(self.major, input_name='major'), namespace_, eol_))
        if self.minor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminor>%s</%sminor>%s' % (namespace_, self.gds_format_integer(self.minor, input_name='minor'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.major is not None or
            self.minor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpecVersionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.major is not None:
            showIndent(outfile, level)
            outfile.write('major=%d,\n' % self.major)
        if self.minor is not None:
            showIndent(outfile, level)
            outfile.write('minor=%d,\n' % self.minor)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'major':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'major')
            self.major = ival_
        elif nodeName_ == 'minor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'minor')
            self.minor = ival_
# end class SpecVersionType


class DeviceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, deviceType=None, friendlyName=None, manufacturer=None, manufacturerURL=None, modelDescription=None, modelName=None, modelNumber=None, modelURL=None, serialNumber=None, UDN=None, UPC=None, iconList=None, serviceList=None, deviceList=None, presentationURL=None, anytypeobjs_=None):
        self.deviceType = deviceType
        self.friendlyName = friendlyName
        self.manufacturer = manufacturer
        self.manufacturerURL = manufacturerURL
        self.modelDescription = modelDescription
        self.modelName = modelName
        self.modelNumber = modelNumber
        self.modelURL = modelURL
        self.serialNumber = serialNumber
        self.UDN = UDN
        self.UPC = UPC
        self.iconList = iconList
        self.serviceList = serviceList
        self.deviceList = deviceList
        self.presentationURL = presentationURL
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if DeviceType.subclass:
            return DeviceType.subclass(*args_, **kwargs_)
        else:
            return DeviceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deviceType(self): return self.deviceType
    def set_deviceType(self, deviceType): self.deviceType = deviceType
    def get_friendlyName(self): return self.friendlyName
    def set_friendlyName(self, friendlyName): self.friendlyName = friendlyName
    def get_manufacturer(self): return self.manufacturer
    def set_manufacturer(self, manufacturer): self.manufacturer = manufacturer
    def get_manufacturerURL(self): return self.manufacturerURL
    def set_manufacturerURL(self, manufacturerURL): self.manufacturerURL = manufacturerURL
    def get_modelDescription(self): return self.modelDescription
    def set_modelDescription(self, modelDescription): self.modelDescription = modelDescription
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_modelNumber(self): return self.modelNumber
    def set_modelNumber(self, modelNumber): self.modelNumber = modelNumber
    def get_modelURL(self): return self.modelURL
    def set_modelURL(self, modelURL): self.modelURL = modelURL
    def get_serialNumber(self): return self.serialNumber
    def set_serialNumber(self, serialNumber): self.serialNumber = serialNumber
    def get_UDN(self): return self.UDN
    def set_UDN(self, UDN): self.UDN = UDN
    def get_UPC(self): return self.UPC
    def set_UPC(self, UPC): self.UPC = UPC
    def get_iconList(self): return self.iconList
    def set_iconList(self, iconList): self.iconList = iconList
    def get_serviceList(self): return self.serviceList
    def set_serviceList(self, serviceList): self.serviceList = serviceList
    def get_deviceList(self): return self.deviceList
    def set_deviceList(self, deviceList): self.deviceList = deviceList
    def get_presentationURL(self): return self.presentationURL
    def set_presentationURL(self, presentationURL): self.presentationURL = presentationURL
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='DeviceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='DeviceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='DeviceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deviceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeviceType>%s</%sdeviceType>%s' % (namespace_, self.gds_format_string(quote_xml(self.deviceType).encode(ExternalEncoding), input_name='deviceType'), namespace_, eol_))
        if self.friendlyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfriendlyName>%s</%sfriendlyName>%s' % (namespace_, self.gds_format_string(quote_xml(self.friendlyName).encode(ExternalEncoding), input_name='friendlyName'), namespace_, eol_))
        if self.manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanufacturer>%s</%smanufacturer>%s' % (namespace_, self.gds_format_string(quote_xml(self.manufacturer).encode(ExternalEncoding), input_name='manufacturer'), namespace_, eol_))
        if self.manufacturerURL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanufacturerURL>%s</%smanufacturerURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.manufacturerURL).encode(ExternalEncoding), input_name='manufacturerURL'), namespace_, eol_))
        if self.modelDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodelDescription>%s</%smodelDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.modelDescription).encode(ExternalEncoding), input_name='modelDescription'), namespace_, eol_))
        if self.modelName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodelName>%s</%smodelName>%s' % (namespace_, self.gds_format_string(quote_xml(self.modelName).encode(ExternalEncoding), input_name='modelName'), namespace_, eol_))
        if self.modelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodelNumber>%s</%smodelNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.modelNumber).encode(ExternalEncoding), input_name='modelNumber'), namespace_, eol_))
        if self.modelURL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodelURL>%s</%smodelURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.modelURL).encode(ExternalEncoding), input_name='modelURL'), namespace_, eol_))
        if self.serialNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserialNumber>%s</%sserialNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.serialNumber).encode(ExternalEncoding), input_name='serialNumber'), namespace_, eol_))
        if self.UDN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUDN>%s</%sUDN>%s' % (namespace_, self.gds_format_string(quote_xml(self.UDN).encode(ExternalEncoding), input_name='UDN'), namespace_, eol_))
        if self.UPC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUPC>%s</%sUPC>%s' % (namespace_, self.gds_format_string(quote_xml(self.UPC).encode(ExternalEncoding), input_name='UPC'), namespace_, eol_))
        if self.iconList is not None:
            self.iconList.export(outfile, level, namespace_, name_='iconList', pretty_print=pretty_print)
        if self.serviceList is not None:
            self.serviceList.export(outfile, level, namespace_, name_='serviceList', pretty_print=pretty_print)
        if self.deviceList is not None:
            self.deviceList.export(outfile, level, namespace_, name_='deviceList', pretty_print=pretty_print)
        if self.presentationURL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spresentationURL>%s</%spresentationURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.presentationURL).encode(ExternalEncoding), input_name='presentationURL'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.deviceType is not None or
            self.friendlyName is not None or
            self.manufacturer is not None or
            self.manufacturerURL is not None or
            self.modelDescription is not None or
            self.modelName is not None or
            self.modelNumber is not None or
            self.modelURL is not None or
            self.serialNumber is not None or
            self.UDN is not None or
            self.UPC is not None or
            self.iconList is not None or
            self.serviceList is not None or
            self.deviceList is not None or
            self.presentationURL is not None or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DeviceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.deviceType is not None:
            showIndent(outfile, level)
            outfile.write('deviceType=%s,\n' % quote_python(self.deviceType).encode(ExternalEncoding))
        if self.friendlyName is not None:
            showIndent(outfile, level)
            outfile.write('friendlyName=%s,\n' % quote_python(self.friendlyName).encode(ExternalEncoding))
        if self.manufacturer is not None:
            showIndent(outfile, level)
            outfile.write('manufacturer=%s,\n' % quote_python(self.manufacturer).encode(ExternalEncoding))
        if self.manufacturerURL is not None:
            showIndent(outfile, level)
            outfile.write('manufacturerURL=%s,\n' % quote_python(self.manufacturerURL).encode(ExternalEncoding))
        if self.modelDescription is not None:
            showIndent(outfile, level)
            outfile.write('modelDescription=%s,\n' % quote_python(self.modelDescription).encode(ExternalEncoding))
        if self.modelName is not None:
            showIndent(outfile, level)
            outfile.write('modelName=%s,\n' % quote_python(self.modelName).encode(ExternalEncoding))
        if self.modelNumber is not None:
            showIndent(outfile, level)
            outfile.write('modelNumber=%s,\n' % quote_python(self.modelNumber).encode(ExternalEncoding))
        if self.modelURL is not None:
            showIndent(outfile, level)
            outfile.write('modelURL=%s,\n' % quote_python(self.modelURL).encode(ExternalEncoding))
        if self.serialNumber is not None:
            showIndent(outfile, level)
            outfile.write('serialNumber=%s,\n' % quote_python(self.serialNumber).encode(ExternalEncoding))
        if self.UDN is not None:
            showIndent(outfile, level)
            outfile.write('UDN=%s,\n' % quote_python(self.UDN).encode(ExternalEncoding))
        if self.UPC is not None:
            showIndent(outfile, level)
            outfile.write('UPC=%s,\n' % quote_python(self.UPC).encode(ExternalEncoding))
        if self.iconList is not None:
            showIndent(outfile, level)
            outfile.write('iconList=model_.IconListType(\n')
            self.iconList.exportLiteral(outfile, level, name_='iconList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serviceList is not None:
            showIndent(outfile, level)
            outfile.write('serviceList=model_.ServiceListType(\n')
            self.serviceList.exportLiteral(outfile, level, name_='serviceList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceList is not None:
            showIndent(outfile, level)
            outfile.write('deviceList=model_.DeviceListType(\n')
            self.deviceList.exportLiteral(outfile, level, name_='deviceList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.presentationURL is not None:
            showIndent(outfile, level)
            outfile.write('presentationURL=%s,\n' % quote_python(self.presentationURL).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deviceType':
            deviceType_ = child_.text
            deviceType_ = self.gds_validate_string(deviceType_, node, 'deviceType')
            self.deviceType = deviceType_
        elif nodeName_ == 'friendlyName':
            friendlyName_ = child_.text
            friendlyName_ = self.gds_validate_string(friendlyName_, node, 'friendlyName')
            self.friendlyName = friendlyName_
        elif nodeName_ == 'manufacturer':
            manufacturer_ = child_.text
            manufacturer_ = self.gds_validate_string(manufacturer_, node, 'manufacturer')
            self.manufacturer = manufacturer_
        elif nodeName_ == 'manufacturerURL':
            manufacturerURL_ = child_.text
            manufacturerURL_ = self.gds_validate_string(manufacturerURL_, node, 'manufacturerURL')
            self.manufacturerURL = manufacturerURL_
        elif nodeName_ == 'modelDescription':
            modelDescription_ = child_.text
            modelDescription_ = self.gds_validate_string(modelDescription_, node, 'modelDescription')
            self.modelDescription = modelDescription_
        elif nodeName_ == 'modelName':
            modelName_ = child_.text
            modelName_ = self.gds_validate_string(modelName_, node, 'modelName')
            self.modelName = modelName_
        elif nodeName_ == 'modelNumber':
            modelNumber_ = child_.text
            modelNumber_ = self.gds_validate_string(modelNumber_, node, 'modelNumber')
            self.modelNumber = modelNumber_
        elif nodeName_ == 'modelURL':
            modelURL_ = child_.text
            modelURL_ = self.gds_validate_string(modelURL_, node, 'modelURL')
            self.modelURL = modelURL_
        elif nodeName_ == 'serialNumber':
            serialNumber_ = child_.text
            serialNumber_ = self.gds_validate_string(serialNumber_, node, 'serialNumber')
            self.serialNumber = serialNumber_
        elif nodeName_ == 'UDN':
            UDN_ = child_.text
            UDN_ = self.gds_validate_string(UDN_, node, 'UDN')
            self.UDN = UDN_
        elif nodeName_ == 'UPC':
            UPC_ = child_.text
            UPC_ = self.gds_validate_string(UPC_, node, 'UPC')
            self.UPC = UPC_
        elif nodeName_ == 'iconList':
            obj_ = IconListType.factory()
            obj_.build(child_)
            self.set_iconList(obj_)
        elif nodeName_ == 'serviceList':
            obj_ = ServiceListType.factory()
            obj_.build(child_)
            self.set_serviceList(obj_)
        elif nodeName_ == 'deviceList':
            obj_ = DeviceListType.factory()
            obj_.build(child_)
            self.set_deviceList(obj_)
        elif nodeName_ == 'presentationURL':
            presentationURL_ = child_.text
            presentationURL_ = self.gds_validate_string(presentationURL_, node, 'presentationURL')
            self.presentationURL = presentationURL_
        else:
            obj_ = self.gds_build_any(child_, 'DeviceType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class DeviceType


class IconListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, icon=None):
        if icon is None:
            self.icon = []
        else:
            self.icon = icon
    def factory(*args_, **kwargs_):
        if IconListType.subclass:
            return IconListType.subclass(*args_, **kwargs_)
        else:
            return IconListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_icon(self): return self.icon
    def set_icon(self, icon): self.icon = icon
    def add_icon(self, value): self.icon.append(value)
    def insert_icon(self, index, value): self.icon[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='IconListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IconListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='IconListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='IconListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for icon_ in self.icon:
            icon_.export(outfile, level, namespace_, name_='icon', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.icon
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IconListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('icon=[\n')
        level += 1
        for icon_ in self.icon:
            showIndent(outfile, level)
            outfile.write('model_.iconType(\n')
            icon_.exportLiteral(outfile, level, name_='iconType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'icon':
            obj_ = iconType.factory()
            obj_.build(child_)
            self.icon.append(obj_)
# end class IconListType


class ServiceListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, service=None):
        if service is None:
            self.service = []
        else:
            self.service = service
    def factory(*args_, **kwargs_):
        if ServiceListType.subclass:
            return ServiceListType.subclass(*args_, **kwargs_)
        else:
            return ServiceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def add_service(self, value): self.service.append(value)
    def insert_service(self, index, value): self.service[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='ServiceListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='ServiceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='ServiceListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for service_ in self.service:
            service_.export(outfile, level, namespace_, name_='service', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.service
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('service=[\n')
        level += 1
        for service_ in self.service:
            showIndent(outfile, level)
            outfile.write('model_.serviceType(\n')
            service_.exportLiteral(outfile, level, name_='serviceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'service':
            obj_ = serviceType.factory()
            obj_.build(child_)
            self.service.append(obj_)
# end class ServiceListType


class DeviceListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, device=None):
        if device is None:
            self.device = []
        else:
            self.device = device
    def factory(*args_, **kwargs_):
        if DeviceListType.subclass:
            return DeviceListType.subclass(*args_, **kwargs_)
        else:
            return DeviceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def add_device(self, value): self.device.append(value)
    def insert_device(self, index, value): self.device[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='DeviceListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='DeviceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='DeviceListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for device_ in self.device:
            device_.export(outfile, level, namespace_, name_='device', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.device
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DeviceListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('device=[\n')
        level += 1
        for device_ in self.device:
            showIndent(outfile, level)
            outfile.write('model_.DeviceType(\n')
            device_.exportLiteral(outfile, level, name_='DeviceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'device':
            obj_ = DeviceType.factory()
            obj_.build(child_)
            self.device.append(obj_)
# end class DeviceListType


class iconType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mimetype=None, width=None, height=None, depth=None, url=None):
        self.mimetype = mimetype
        self.width = width
        self.height = height
        self.depth = depth
        self.url = url
    def factory(*args_, **kwargs_):
        if iconType.subclass:
            return iconType.subclass(*args_, **kwargs_)
        else:
            return iconType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mimetype(self): return self.mimetype
    def set_mimetype(self, mimetype): self.mimetype = mimetype
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def get_depth(self): return self.depth
    def set_depth(self, depth): self.depth = depth
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def export(self, outfile, level, namespace_='tns:', name_='iconType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iconType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='iconType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='iconType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mimetype is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smimetype>%s</%smimetype>%s' % (namespace_, self.gds_format_string(quote_xml(self.mimetype).encode(ExternalEncoding), input_name='mimetype'), namespace_, eol_))
        if self.width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swidth>%s</%swidth>%s' % (namespace_, self.gds_format_integer(self.width, input_name='width'), namespace_, eol_))
        if self.height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheight>%s</%sheight>%s' % (namespace_, self.gds_format_integer(self.height, input_name='height'), namespace_, eol_))
        if self.depth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepth>%s</%sdepth>%s' % (namespace_, self.gds_format_integer(self.depth, input_name='depth'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.mimetype is not None or
            self.width is not None or
            self.height is not None or
            self.depth is not None or
            self.url is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='iconType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mimetype is not None:
            showIndent(outfile, level)
            outfile.write('mimetype=%s,\n' % quote_python(self.mimetype).encode(ExternalEncoding))
        if self.width is not None:
            showIndent(outfile, level)
            outfile.write('width=%d,\n' % self.width)
        if self.height is not None:
            showIndent(outfile, level)
            outfile.write('height=%d,\n' % self.height)
        if self.depth is not None:
            showIndent(outfile, level)
            outfile.write('depth=%d,\n' % self.depth)
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('url=%s,\n' % quote_python(self.url).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mimetype':
            mimetype_ = child_.text
            mimetype_ = self.gds_validate_string(mimetype_, node, 'mimetype')
            self.mimetype = mimetype_
        elif nodeName_ == 'width':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'width')
            self.width = ival_
        elif nodeName_ == 'height':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'height')
            self.height = ival_
        elif nodeName_ == 'depth':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'depth')
            self.depth = ival_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
# end class iconType


class serviceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, serviceType=None, serviceId=None, SCPDURL=None, controlURL=None, eventSubURL=None):
        self.serviceType = serviceType
        self.serviceId = serviceId
        self.SCPDURL = SCPDURL
        self.controlURL = controlURL
        self.eventSubURL = eventSubURL
    def factory(*args_, **kwargs_):
        if serviceType.subclass:
            return serviceType.subclass(*args_, **kwargs_)
        else:
            return serviceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serviceType(self): return self.serviceType
    def set_serviceType(self, serviceType): self.serviceType = serviceType
    def get_serviceId(self): return self.serviceId
    def set_serviceId(self, serviceId): self.serviceId = serviceId
    def get_SCPDURL(self): return self.SCPDURL
    def set_SCPDURL(self, SCPDURL): self.SCPDURL = SCPDURL
    def get_controlURL(self): return self.controlURL
    def set_controlURL(self, controlURL): self.controlURL = controlURL
    def get_eventSubURL(self): return self.eventSubURL
    def set_eventSubURL(self, eventSubURL): self.eventSubURL = eventSubURL
    def export(self, outfile, level, namespace_='tns:', name_='serviceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='serviceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='serviceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='serviceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.serviceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserviceType>%s</%sserviceType>%s' % (namespace_, self.gds_format_string(quote_xml(self.serviceType).encode(ExternalEncoding), input_name='serviceType'), namespace_, eol_))
        if self.serviceId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserviceId>%s</%sserviceId>%s' % (namespace_, self.gds_format_string(quote_xml(self.serviceId).encode(ExternalEncoding), input_name='serviceId'), namespace_, eol_))
        if self.SCPDURL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCPDURL>%s</%sSCPDURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.SCPDURL).encode(ExternalEncoding), input_name='SCPDURL'), namespace_, eol_))
        if self.controlURL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontrolURL>%s</%scontrolURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.controlURL).encode(ExternalEncoding), input_name='controlURL'), namespace_, eol_))
        if self.eventSubURL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seventSubURL>%s</%seventSubURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.eventSubURL).encode(ExternalEncoding), input_name='eventSubURL'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.serviceType is not None or
            self.serviceId is not None or
            self.SCPDURL is not None or
            self.controlURL is not None or
            self.eventSubURL is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='serviceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.serviceType is not None:
            showIndent(outfile, level)
            outfile.write('serviceType=%s,\n' % quote_python(self.serviceType).encode(ExternalEncoding))
        if self.serviceId is not None:
            showIndent(outfile, level)
            outfile.write('serviceId=%s,\n' % quote_python(self.serviceId).encode(ExternalEncoding))
        if self.SCPDURL is not None:
            showIndent(outfile, level)
            outfile.write('SCPDURL=%s,\n' % quote_python(self.SCPDURL).encode(ExternalEncoding))
        if self.controlURL is not None:
            showIndent(outfile, level)
            outfile.write('controlURL=%s,\n' % quote_python(self.controlURL).encode(ExternalEncoding))
        if self.eventSubURL is not None:
            showIndent(outfile, level)
            outfile.write('eventSubURL=%s,\n' % quote_python(self.eventSubURL).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'serviceType':
            serviceType_ = child_.text
            serviceType_ = self.gds_validate_string(serviceType_, node, 'serviceType')
            self.serviceType = serviceType_
        elif nodeName_ == 'serviceId':
            serviceId_ = child_.text
            serviceId_ = self.gds_validate_string(serviceId_, node, 'serviceId')
            self.serviceId = serviceId_
        elif nodeName_ == 'SCPDURL':
            SCPDURL_ = child_.text
            SCPDURL_ = self.gds_validate_string(SCPDURL_, node, 'SCPDURL')
            self.SCPDURL = SCPDURL_
        elif nodeName_ == 'controlURL':
            controlURL_ = child_.text
            controlURL_ = self.gds_validate_string(controlURL_, node, 'controlURL')
            self.controlURL = controlURL_
        elif nodeName_ == 'eventSubURL':
            eventSubURL_ = child_.text
            eventSubURL_ = self.gds_validate_string(eventSubURL_, node, 'eventSubURL')
            self.eventSubURL = eventSubURL_
# end class serviceType


GDSClassesMapping = {
    'serviceList': ServiceListType,
    'service': serviceType,
    'iconList': IconListType,
    'deviceList': DeviceListType,
    'device': DeviceType,
    'specVersion': SpecVersionType,
    'icon': iconType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'root'
        rootClass = root
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'root'
        rootClass = root
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'root'
        rootClass = root
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from device import *\n\n')
    sys.stdout.write('from datetime import datetime as datetime_\n\n')
    sys.stdout.write('import device as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "DeviceListType",
    "DeviceType",
    "IconListType",
    "ServiceListType",
    "SpecVersionType",
    "iconType",
    "root",
    "serviceType"
    ]

########NEW FILE########
__FILENAME__ = service
#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Jan 31 15:52:45 2013 by generateDS.py version 2.8b.
#

import sys
import getopt
import re as re_
import base64
from datetime import datetime, tzinfo, timedelta

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(tzinfo):
            def __init__(self, offset, name):
                self.__offset = timedelta(minutes = offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S')
            else:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S.%f')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_datetime(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S')
            return dt.replace(tzinfo = tz)

        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%d')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_date(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%d').replace(tzinfo = tz)
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' %
                (self.name, base64.b64encode(self.value), self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class scpd(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, specVersion=None, actionList=None, serviceStateTable=None):
        self.specVersion = specVersion
        self.actionList = actionList
        self.serviceStateTable = serviceStateTable
    def factory(*args_, **kwargs_):
        if scpd.subclass:
            return scpd.subclass(*args_, **kwargs_)
        else:
            return scpd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specVersion(self): return self.specVersion
    def set_specVersion(self, specVersion): self.specVersion = specVersion
    def get_actionList(self): return self.actionList
    def set_actionList(self, actionList): self.actionList = actionList
    def get_serviceStateTable(self): return self.serviceStateTable
    def set_serviceStateTable(self, serviceStateTable): self.serviceStateTable = serviceStateTable
    def export(self, outfile, level, namespace_='', name_='scpd', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scpd')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='scpd'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='scpd', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.specVersion is not None:
            self.specVersion.export(outfile, level, namespace_, name_='specVersion', pretty_print=pretty_print)
        if self.actionList is not None:
            self.actionList.export(outfile, level, namespace_, name_='actionList', pretty_print=pretty_print)
        if self.serviceStateTable is not None:
            self.serviceStateTable.export(outfile, level, namespace_, name_='serviceStateTable', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.specVersion is not None or
            self.actionList is not None or
            self.serviceStateTable is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='scpd'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.specVersion is not None:
            showIndent(outfile, level)
            outfile.write('specVersion=model_.SpecVersionType(\n')
            self.specVersion.exportLiteral(outfile, level, name_='specVersion')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.actionList is not None:
            showIndent(outfile, level)
            outfile.write('actionList=model_.ActionListType(\n')
            self.actionList.exportLiteral(outfile, level, name_='actionList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serviceStateTable is not None:
            showIndent(outfile, level)
            outfile.write('serviceStateTable=model_.ServiceStateTableType(\n')
            self.serviceStateTable.exportLiteral(outfile, level, name_='serviceStateTable')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'specVersion':
            obj_ = SpecVersionType.factory()
            obj_.build(child_)
            self.set_specVersion(obj_)
        elif nodeName_ == 'actionList':
            obj_ = ActionListType.factory()
            obj_.build(child_)
            self.set_actionList(obj_)
        elif nodeName_ == 'serviceStateTable':
            obj_ = ServiceStateTableType.factory()
            obj_.build(child_)
            self.set_serviceStateTable(obj_)
# end class scpd


class SpecVersionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, major=None, minor=None):
        self.major = major
        self.minor = minor
    def factory(*args_, **kwargs_):
        if SpecVersionType.subclass:
            return SpecVersionType.subclass(*args_, **kwargs_)
        else:
            return SpecVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_major(self): return self.major
    def set_major(self, major): self.major = major
    def get_minor(self): return self.minor
    def set_minor(self, minor): self.minor = minor
    def export(self, outfile, level, namespace_='', name_='SpecVersionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecVersionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpecVersionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpecVersionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.major is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smajor>%s</%smajor>%s' % (namespace_, self.gds_format_integer(self.major, input_name='major'), namespace_, eol_))
        if self.minor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminor>%s</%sminor>%s' % (namespace_, self.gds_format_integer(self.minor, input_name='minor'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.major is not None or
            self.minor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpecVersionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.major is not None:
            showIndent(outfile, level)
            outfile.write('major=%d,\n' % self.major)
        if self.minor is not None:
            showIndent(outfile, level)
            outfile.write('minor=%d,\n' % self.minor)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'major':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'major')
            self.major = ival_
        elif nodeName_ == 'minor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'minor')
            self.minor = ival_
# end class SpecVersionType


class ActionListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action=None):
        if action is None:
            self.action = []
        else:
            self.action = action
    def factory(*args_, **kwargs_):
        if ActionListType.subclass:
            return ActionListType.subclass(*args_, **kwargs_)
        else:
            return ActionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def add_action(self, value): self.action.append(value)
    def insert_action(self, index, value): self.action[index] = value
    def export(self, outfile, level, namespace_='', name_='ActionListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for action_ in self.action:
            action_.export(outfile, level, namespace_, name_='action', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.action
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('action=[\n')
        level += 1
        for action_ in self.action:
            showIndent(outfile, level)
            outfile.write('model_.ActionType(\n')
            action_.exportLiteral(outfile, level, name_='ActionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'action':
            obj_ = ActionType.factory()
            obj_.build(child_)
            self.action.append(obj_)
# end class ActionListType


class ActionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, argumentList=None):
        self.name = name
        self.argumentList = argumentList
    def factory(*args_, **kwargs_):
        if ActionType.subclass:
            return ActionType.subclass(*args_, **kwargs_)
        else:
            return ActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_argumentList(self): return self.argumentList
    def set_argumentList(self, argumentList): self.argumentList = argumentList
    def export(self, outfile, level, namespace_='', name_='ActionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.argumentList is not None:
            self.argumentList.export(outfile, level, namespace_, name_='argumentList', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.name is not None or
            self.argumentList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.argumentList is not None:
            showIndent(outfile, level)
            outfile.write('argumentList=model_.ArgumentListType(\n')
            self.argumentList.exportLiteral(outfile, level, name_='argumentList')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'argumentList':
            obj_ = ArgumentListType.factory()
            obj_.build(child_)
            self.set_argumentList(obj_)
# end class ActionType


class ArgumentListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, argument=None):
        if argument is None:
            self.argument = []
        else:
            self.argument = argument
    def factory(*args_, **kwargs_):
        if ArgumentListType.subclass:
            return ArgumentListType.subclass(*args_, **kwargs_)
        else:
            return ArgumentListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_argument(self): return self.argument
    def set_argument(self, argument): self.argument = argument
    def add_argument(self, value): self.argument.append(value)
    def insert_argument(self, index, value): self.argument[index] = value
    def export(self, outfile, level, namespace_='', name_='ArgumentListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArgumentListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArgumentListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ArgumentListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for argument_ in self.argument:
            argument_.export(outfile, level, namespace_, name_='argument', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.argument
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArgumentListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('argument=[\n')
        level += 1
        for argument_ in self.argument:
            showIndent(outfile, level)
            outfile.write('model_.ArgumentType(\n')
            argument_.exportLiteral(outfile, level, name_='ArgumentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'argument':
            obj_ = ArgumentType.factory()
            obj_.build(child_)
            self.argument.append(obj_)
# end class ArgumentListType


class ArgumentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, direction=None, relatedStateVariable=None, retval=None):
        self.name = name
        self.direction = direction
        self.relatedStateVariable = relatedStateVariable
        self.retval = retval
    def factory(*args_, **kwargs_):
        if ArgumentType.subclass:
            return ArgumentType.subclass(*args_, **kwargs_)
        else:
            return ArgumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_relatedStateVariable(self): return self.relatedStateVariable
    def set_relatedStateVariable(self, relatedStateVariable): self.relatedStateVariable = relatedStateVariable
    def get_retval(self): return self.retval
    def set_retval(self, retval): self.retval = retval
    def export(self, outfile, level, namespace_='', name_='ArgumentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArgumentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ArgumentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespace_, self.gds_format_string(quote_xml(self.direction).encode(ExternalEncoding), input_name='direction'), namespace_, eol_))
        if self.relatedStateVariable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srelatedStateVariable>%s</%srelatedStateVariable>%s' % (namespace_, self.gds_format_string(quote_xml(self.relatedStateVariable).encode(ExternalEncoding), input_name='relatedStateVariable'), namespace_, eol_))
        if self.retval is not None:
            self.retval.export(outfile, level, namespace_, name_='retval', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.name is not None or
            self.direction is not None or
            self.relatedStateVariable is not None or
            self.retval is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArgumentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction=%s,\n' % quote_python(self.direction).encode(ExternalEncoding))
        if self.relatedStateVariable is not None:
            showIndent(outfile, level)
            outfile.write('relatedStateVariable=%s,\n' % quote_python(self.relatedStateVariable).encode(ExternalEncoding))
        if self.retval is not None:
            showIndent(outfile, level)
            outfile.write('retval=model_.retvalType(\n')
            self.retval.exportLiteral(outfile, level, name_='retval')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'direction':
            direction_ = child_.text
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
        elif nodeName_ == 'relatedStateVariable':
            relatedStateVariable_ = child_.text
            relatedStateVariable_ = self.gds_validate_string(relatedStateVariable_, node, 'relatedStateVariable')
            self.relatedStateVariable = relatedStateVariable_
        elif nodeName_ == 'retval':
            obj_ = retvalType.factory()
            obj_.build(child_)
            self.set_retval(obj_)
# end class ArgumentType


class ServiceStateTableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, stateVariable=None):
        if stateVariable is None:
            self.stateVariable = []
        else:
            self.stateVariable = stateVariable
    def factory(*args_, **kwargs_):
        if ServiceStateTableType.subclass:
            return ServiceStateTableType.subclass(*args_, **kwargs_)
        else:
            return ServiceStateTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stateVariable(self): return self.stateVariable
    def set_stateVariable(self, stateVariable): self.stateVariable = stateVariable
    def add_stateVariable(self, value): self.stateVariable.append(value)
    def insert_stateVariable(self, index, value): self.stateVariable[index] = value
    def export(self, outfile, level, namespace_='', name_='ServiceStateTableType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceStateTableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceStateTableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceStateTableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for stateVariable_ in self.stateVariable:
            stateVariable_.export(outfile, level, namespace_, name_='stateVariable', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.stateVariable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceStateTableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('stateVariable=[\n')
        level += 1
        for stateVariable_ in self.stateVariable:
            showIndent(outfile, level)
            outfile.write('model_.StateVariableType(\n')
            stateVariable_.exportLiteral(outfile, level, name_='StateVariableType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stateVariable':
            obj_ = StateVariableType.factory()
            obj_.build(child_)
            self.stateVariable.append(obj_)
# end class ServiceStateTableType


class StateVariableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sendEvents='yes', name=None, dataType=None, defaultValue=None, allowedValueList=None, allowedValueRange=None):
        self.sendEvents = _cast(None, sendEvents)
        self.name = name
        self.dataType = dataType
        self.defaultValue = defaultValue
        self.allowedValueList = allowedValueList
        self.allowedValueRange = allowedValueRange
    def factory(*args_, **kwargs_):
        if StateVariableType.subclass:
            return StateVariableType.subclass(*args_, **kwargs_)
        else:
            return StateVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def get_allowedValueList(self): return self.allowedValueList
    def set_allowedValueList(self, allowedValueList): self.allowedValueList = allowedValueList
    def get_allowedValueRange(self): return self.allowedValueRange
    def set_allowedValueRange(self, allowedValueRange): self.allowedValueRange = allowedValueRange
    def get_sendEvents(self): return self.sendEvents
    def set_sendEvents(self, sendEvents): self.sendEvents = sendEvents
    def export(self, outfile, level, namespace_='', name_='StateVariableType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateVariableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateVariableType'):
        if self.sendEvents is not None and 'sendEvents' not in already_processed:
            already_processed.append('sendEvents')
            outfile.write(' sendEvents=%s' % (self.gds_format_string(quote_attrib(self.sendEvents).encode(ExternalEncoding), input_name='sendEvents'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StateVariableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.dataType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdataType>%s</%sdataType>%s' % (namespace_, self.gds_format_string(quote_xml(self.dataType).encode(ExternalEncoding), input_name='dataType'), namespace_, eol_))
        if self.defaultValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefaultValue>%s</%sdefaultValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.defaultValue).encode(ExternalEncoding), input_name='defaultValue'), namespace_, eol_))
        if self.allowedValueList is not None:
            self.allowedValueList.export(outfile, level, namespace_, name_='allowedValueList', pretty_print=pretty_print)
        if self.allowedValueRange is not None:
            self.allowedValueRange.export(outfile, level, namespace_, name_='allowedValueRange', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.name is not None or
            self.dataType is not None or
            self.defaultValue is not None or
            self.allowedValueList is not None or
            self.allowedValueRange is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateVariableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sendEvents is not None and 'sendEvents' not in already_processed:
            already_processed.append('sendEvents')
            showIndent(outfile, level)
            outfile.write('sendEvents = "%s",\n' % (self.sendEvents,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.dataType is not None:
            showIndent(outfile, level)
            outfile.write('dataType=%s,\n' % quote_python(self.dataType).encode(ExternalEncoding))
        if self.defaultValue is not None:
            showIndent(outfile, level)
            outfile.write('defaultValue=%s,\n' % quote_python(self.defaultValue).encode(ExternalEncoding))
        if self.allowedValueList is not None:
            showIndent(outfile, level)
            outfile.write('allowedValueList=model_.AllowedValueListType(\n')
            self.allowedValueList.exportLiteral(outfile, level, name_='allowedValueList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.allowedValueRange is not None:
            showIndent(outfile, level)
            outfile.write('allowedValueRange=model_.AllowedValueRangeType(\n')
            self.allowedValueRange.exportLiteral(outfile, level, name_='allowedValueRange')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sendEvents', node)
        if value is not None and 'sendEvents' not in already_processed:
            already_processed.append('sendEvents')
            self.sendEvents = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'dataType':
            dataType_ = child_.text
            dataType_ = self.gds_validate_string(dataType_, node, 'dataType')
            self.dataType = dataType_
        elif nodeName_ == 'defaultValue':
            defaultValue_ = child_.text
            defaultValue_ = self.gds_validate_string(defaultValue_, node, 'defaultValue')
            self.defaultValue = defaultValue_
        elif nodeName_ == 'allowedValueList':
            obj_ = AllowedValueListType.factory()
            obj_.build(child_)
            self.set_allowedValueList(obj_)
        elif nodeName_ == 'allowedValueRange':
            obj_ = AllowedValueRangeType.factory()
            obj_.build(child_)
            self.set_allowedValueRange(obj_)
# end class StateVariableType


class AllowedValueListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, allowedValue=None):
        if allowedValue is None:
            self.allowedValue = []
        else:
            self.allowedValue = allowedValue
    def factory(*args_, **kwargs_):
        if AllowedValueListType.subclass:
            return AllowedValueListType.subclass(*args_, **kwargs_)
        else:
            return AllowedValueListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allowedValue(self): return self.allowedValue
    def set_allowedValue(self, allowedValue): self.allowedValue = allowedValue
    def add_allowedValue(self, value): self.allowedValue.append(value)
    def insert_allowedValue(self, index, value): self.allowedValue[index] = value
    def export(self, outfile, level, namespace_='', name_='AllowedValueListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllowedValueListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllowedValueListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AllowedValueListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for allowedValue_ in self.allowedValue:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallowedValue>%s</%sallowedValue>%s' % (namespace_, self.gds_format_string(quote_xml(allowedValue_).encode(ExternalEncoding), input_name='allowedValue'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.allowedValue
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AllowedValueListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('allowedValue=[\n')
        level += 1
        for allowedValue_ in self.allowedValue:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(allowedValue_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allowedValue':
            allowedValue_ = child_.text
            allowedValue_ = self.gds_validate_string(allowedValue_, node, 'allowedValue')
            self.allowedValue.append(allowedValue_)
# end class AllowedValueListType


class AllowedValueRangeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, minimum=None, maximum=None, step=None):
        self.minimum = minimum
        self.maximum = maximum
        self.step = step
    def factory(*args_, **kwargs_):
        if AllowedValueRangeType.subclass:
            return AllowedValueRangeType.subclass(*args_, **kwargs_)
        else:
            return AllowedValueRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def export(self, outfile, level, namespace_='', name_='AllowedValueRangeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllowedValueRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllowedValueRangeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AllowedValueRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.minimum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimum>%s</%sminimum>%s' % (namespace_, self.gds_format_float(self.minimum, input_name='minimum'), namespace_, eol_))
        if self.maximum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximum>%s</%smaximum>%s' % (namespace_, self.gds_format_float(self.maximum, input_name='maximum'), namespace_, eol_))
        if self.step is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstep>%s</%sstep>%s' % (namespace_, self.gds_format_float(self.step, input_name='step'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.minimum is not None or
            self.maximum is not None or
            self.step is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AllowedValueRangeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.minimum is not None:
            showIndent(outfile, level)
            outfile.write('minimum=%f,\n' % self.minimum)
        if self.maximum is not None:
            showIndent(outfile, level)
            outfile.write('maximum=%f,\n' % self.maximum)
        if self.step is not None:
            showIndent(outfile, level)
            outfile.write('step=%f,\n' % self.step)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'minimum':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'minimum')
            self.minimum = fval_
        elif nodeName_ == 'maximum':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximum')
            self.maximum = fval_
        elif nodeName_ == 'step':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'step')
            self.step = fval_
# end class AllowedValueRangeType


class retvalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if retvalType.subclass:
            return retvalType.subclass(*args_, **kwargs_)
        else:
            return retvalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='retvalType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='retvalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='retvalType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='retvalType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='retvalType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class retvalType


GDSClassesMapping = {
    'argumentList': ArgumentListType,
    'actionList': ActionListType,
    'retval': retvalType,
    'stateVariable': StateVariableType,
    'argument': ArgumentType,
    'action': ActionType,
    'serviceStateTable': ServiceStateTableType,
    'allowedValueRange': AllowedValueRangeType,
    'specVersion': SpecVersionType,
    'allowedValueList': AllowedValueListType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'scpd'
        rootClass = scpd
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'scpd'
        rootClass = scpd
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'scpd'
        rootClass = scpd
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from service import *\n\n')
    sys.stdout.write('from datetime import datetime as datetime_\n\n')
    sys.stdout.write('import service as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ActionListType",
    "ActionType",
    "AllowedValueListType",
    "AllowedValueRangeType",
    "ArgumentListType",
    "ArgumentType",
    "ServiceStateTableType",
    "SpecVersionType",
    "StateVariableType",
    "retvalType",
    "scpd"
    ]

########NEW FILE########
__FILENAME__ = insight
from .switch import Switch

class Insight(Switch):

    def __repr__(self):
        return '<WeMo Insight "{name}">'.format(name=self.name)

    @property
    def today_kwh(self):
        return self.insight.GetTodayKWH()

    @property
    def current_power(self):
        """
        Returns the current power usage in mW.
        """
        return self.insight.GetPower()

    @property
    def today_on_time(self):
        return self.insight.GetTodayONTime()

    @property
    def on_for(self):
        return self.insight.GetONFor()

    @property
    def in_standby_since(self):
        return self.insight.GetInSBYSince()

    @property
    def today_standby_time(self):
        return self.insight.GetTodaySBYTime()


########NEW FILE########
__FILENAME__ = lightswitch
from .switch import Switch

class LightSwitch(Switch):

    def __repr__(self):
        return '<WeMo LightSwitch "{name}">'.format(name=self.name)

########NEW FILE########
__FILENAME__ = motion
from ouimeaux.device import Device

class Motion(Device):

    def __repr__(self):
        return '<WeMo Motion "{name}">'.format(name=self.name)

########NEW FILE########
__FILENAME__ = switch
from ouimeaux.device import Device


class Switch(Device):

    def set_state(self, state):
        """
        Set the state of this device to on or off.
        """
        self.basicevent.SetBinaryState(BinaryState=int(state))
        self._state = int(state)

    def off(self):
        """
        Turn this device off. If already off, will return "Error".
        """
        return self.set_state(0)

    def on(self):
        """
        Turn this device on. If already on, will return "Error".
        """
        return self.set_state(1)

    def toggle(self):
        """
        Toggle the switch's state.
        """
        return self.set_state(not self.get_state())

    def __repr__(self):
        return '<WeMo Switch "{name}">'.format(name=self.name)


########NEW FILE########
__FILENAME__ = discovery
import logging

import gevent
from gevent import socket
from gevent.server import DatagramServer

from ouimeaux.utils import get_ip_address
from pysignals import receiver
from ouimeaux.signals import discovered


log = logging.getLogger(__name__)


class UPnPLoopbackException(Exception):
    """
    Using loopback interface as callback IP.
    """


class UPnP(object):
    """
    Makes M-SEARCH requests, filters out non-WeMo responses, and dispatches
    signals with the results.
    """
    def __init__(self, mcast_ip='239.255.255.250', mcast_port=1900, bind=None):
        if bind is None:
            host = get_ip_address()
            if host.startswith('127.'):
                raise UPnPLoopbackException("Using %s as a callback IP for "
                                            "discovery will not be successful.")
            port = 54321
            bind = '{0}:{1}'.format(host, port)
        self.bind = bind
        self.mcast_ip = mcast_ip
        self.mcast_port = mcast_port
        self.clients = {}

    def _response_received(self, message, address):
        log.debug("Received a response from {0}:{1}".format(*address))
        if address[0] not in self.clients:
            lines = message.splitlines()
            lines.pop(0) # HTTP status
            headers = {}
            for line in lines:
                try:
                    header, value = line.split(":", 1)
                    headers[header.lower()] = value.strip()
                except ValueError:
                    continue
            if (headers.get('x-user-agent', None) == 'redsonic'):
                log.debug("Found WeMo at {0}:{1}".format(*address))
                self.clients[address[0]] = headers
                gevent.spawn(discovered.send, self, address=address,
                        headers=headers)

    @property
    def server(self):
        """
        UDP server to listen for responses.
        """
        server = getattr(self, "_server", None)
        if server is None:
            log.debug("Binding datagram server to %s", self.bind)
            server = DatagramServer(self.bind, self._response_received)
            self._server = server
        return server

    def broadcast(self):
        """
        Send a multicast M-SEARCH request asking for devices to report in.
        """
        log.debug("Broadcasting M-SEARCH to %s:%s", self.mcast_ip, self.mcast_port)
        request = '\r\n'.join(("M-SEARCH * HTTP/1.1",
                               "HOST:{mcast_ip}:{mcast_port}",
                               "ST:upnp:rootdevice",
                               "MX:2",
                               'MAN:"ssdp:discover"',
                               "", "")).format(**self.__dict__)
        self.server.sendto(request, (self.mcast_ip, self.mcast_port))


def test():
    logging.basicConfig(level=logging.DEBUG)

    @receiver(discovered)
    def handler(sender, **kwargs):
        print "I GOT ONE"
        print kwargs['address'], kwargs['headers']

    upnp = UPnP()
    upnp.server.set_spawn(1)
    upnp.server.start()
    log.debug("Started server, listening for responses")
    with gevent.Timeout(2, KeyboardInterrupt):
        while True:
            try:
                upnp.broadcast()
                gevent.sleep(2)
            except KeyboardInterrupt:
                break


if __name__ == "__main__":
    test()

########NEW FILE########
__FILENAME__ = environment
import logging

import gevent

from ouimeaux.config import get_cache, WemoConfiguration
from ouimeaux.device.switch import Switch
from ouimeaux.device.insight import Insight
from ouimeaux.device.lightswitch import LightSwitch
from ouimeaux.device.motion import Motion
from ouimeaux.discovery import UPnP
from ouimeaux.signals import discovered, devicefound
from ouimeaux.subscribe import SubscriptionRegistry
from ouimeaux.utils import matcher


_NOOP = lambda *x: None
log = logging.getLogger(__name__)

reqlog = logging.getLogger("requests")
reqlog.disabled = True


class StopBroadcasting(Exception):
    pass


class UnknownDevice(Exception):
    pass



class Environment(object):
    def __init__(self, switch_callback=_NOOP, motion_callback=_NOOP,
                 with_discovery=True, with_subscribers=True, with_cache=None,
                 bind=None, config_filename=None):
        """
        Create a WeMo environment.

        @param switch_callback: A function to be called when a new switch is
                                discovered.
        @type switch_callback:  function
        @param motion_callback: A function to be called when a new motion is
                                discovered.
        @type motion_callback:  function
        @param with_subscribers: Whether to register for events with discovered
                                devices.
        @type with_subscribers: bool
        @param bind: ip:port to which to bind the response server.
        @type bind: str
        """
        self._config = WemoConfiguration(filename=config_filename)
        self.upnp = UPnP(bind=bind or self._config.bind)
        discovered.connect(self._found_device, self.upnp)
        self.registry = SubscriptionRegistry()
        if with_cache is None:
            with_cache = (self._config.cache if self._config.cache is not None else True)
        self._with_cache = with_cache
        self._with_discovery = with_discovery
        self._with_subscribers = with_subscribers
        self._switch_callback = switch_callback
        self._motion_callback = motion_callback
        self._switches = {}
        self._motions = {}
        self.devices = {}

    def __iter__(self):
        return self.devices.itervalues()

    def start(self):
        """
        Start the server(s) necessary to receive information from devices.
        """
        if self._with_cache:
            with get_cache() as c:
                for dev in c.devices:
                    self._process_device(dev, cache=False)

        if self._with_discovery:
            # Start the server to listen to new devices
            self.upnp.server.set_spawn(2)
            self.upnp.server.start()

        if self._with_subscribers:
            # Start the server to listen to events
            self.registry.server.set_spawn(2)
            self.registry.server.start()

    def wait(self, timeout=None):
        """
        Wait for events.
        """
        try:
            if timeout:
                gevent.sleep(timeout)
            else:
                while True:
                    gevent.sleep(1000)
        except (KeyboardInterrupt, SystemExit, Exception):
            pass

    def discover(self, seconds=2):
        """
        Discover devices in the environment.

        @param seconds: Number of seconds to broadcast requests.
        @type seconds: int
        """
        log.info("Discovering devices")
        with gevent.Timeout(seconds, StopBroadcasting) as timeout:
            try:
                try:
                    while True:
                        self.upnp.broadcast()
                        gevent.sleep(1)
                except Exception as e:
                    raise StopBroadcasting(e)
            except StopBroadcasting:
                return


    def _found_device(self, sender, **kwargs):
        address = kwargs['address']
        headers = kwargs['headers']
        log.info("Found device at %s" % (address,))
        usn = headers['usn']
        if usn.startswith('uuid:Socket'):
            klass = Switch
        elif usn.startswith('uuid:Lightswitch'):
            klass = LightSwitch
        elif usn.startswith('uuid:Insight'):
            klass = Insight
        elif usn.startswith('uuid:Sensor'):
            klass = Motion
        else:
            log.info("Unrecognized device type. USN={0}".format(usn))
            return
        device = klass(headers['location'])
        self._process_device(device)

    def _process_device(self, device, cache=None):
        if isinstance(device, Switch):
            callback = self._switch_callback
            registry = self._switches
        elif isinstance(device, Motion):
            callback = self._motion_callback
            registry = self._motions
        else:
            return
        self.devices[device.name] = device
        registry[device.name] = device
        if self._with_subscribers:
            self.registry.register(device)
            self.registry.on(device, 'BinaryState',
                             device._update_state)
        if cache if cache is not None else self._with_cache:
            with get_cache() as c:
                c.add_device(device)
        devicefound.send(device)
        callback(device)

    def list_switches(self):
        """
        List switches discovered in the environment.
        """
        return self._switches.keys()

    def list_motions(self):
        """
        List motions discovered in the environment.
        """
        return self._motions.keys()

    def get(self, name):
        alias = self._config.aliases.get(name)
        if alias:
            matches = lambda x: x == alias
        elif name:
            matches = matcher(name)
        else:
            matches = _NOOP
        for k in self.devices:
            if matches(k):
                return self.devices[k]
        else:
            raise UnknownDevice(name)

    def get_switch(self, name):
        """
        Get a switch by name.
        """
        try:
            return self._switches[name]
        except KeyError:
            raise UnknownDevice(name)

    def get_motion(self, name):
        """
        Get a motion by name.
        """
        try:
            return self._motions[name]
        except KeyError:
            raise UnknownDevice(name)


if __name__ == "__main__":
    # Use with python -i
    environment = Environment()

########NEW FILE########
__FILENAME__ = settings
DEBUG = True
SECRET_KEY = 'temporary_secret_key'  # make sure to change this

########NEW FILE########
__FILENAME__ = signals
from pysignals import Signal, receiver

# Work around a bug in pysignals when in the interactive interpreter
import sys
_main = sys.modules.get('__main__')
if _main:
    _main.__file__ = "__main__.py"


# Fires when a device responds to a broadcast 
discovered = Signal(providing_args=["address", "headers"])

# Fires when a device is found and added to the environment
devicefound = Signal()

# Fires when a subscriber receives an event
subscription = Signal(providing_args=["type", "value"])

# Fires when a device changes state
statechange = Signal(providing_args=["state"])


@receiver(subscription)
def _got_subscription(sender, **kwargs):
    if kwargs['type'] == 'BinaryState':
        statechange.send(sender, state=int(kwargs['value']))

########NEW FILE########
__FILENAME__ = subscribe
from collections import defaultdict
import logging
from xml.etree import cElementTree
from functools import partial

import requests
import gevent
from gevent import socket
from gevent.wsgi import WSGIServer

from ouimeaux.utils import get_ip_address
from ouimeaux.device.insight import Insight
from ouimeaux.signals import subscription


log = logging.getLogger(__name__)

NS = "{urn:schemas-upnp-org:event-1-0}"
SUCCESS = '<html><body><h1>200 OK</h1></body></html>'


class SubscriptionRegistry(object):
    def __init__(self):
        self._devices = {}
        self._callbacks = defaultdict(list)

    def register(self, device):
        log.info("Subscribing to basic events from %r", (device,))
        # Provide a function to register a callback when the device changes state
        device.register_listener = partial(self.on, device, 'BinaryState')
        self._devices[device.host] = device
        self._resubscribe(device.basicevent.eventSubURL)

    def _resubscribe(self, url, sid=None):
        headers = {'TIMEOUT': 300}
        if sid is not None:
            headers['SID'] = sid
        else:
            host = get_ip_address()
            headers.update({
                "CALLBACK": '<http://%s:8989>' % host,
                "NT": "upnp:event"
            })

        response = requests.request(method="SUBSCRIBE", url=url,
                                    headers=headers)
        if response.status_code == 412 and sid:
            # Invalid subscription ID. Send an UNSUBSCRIBE for safety and
            # start over.
            requests.request(method='UNSUBSCRIBE', url=url,
                    headers={'SID':sid})
            return self._resubscribe(url)
        timeout = int(response.headers.get('timeout', '1801').replace(
            'Second-', ''))
        sid = response.headers.get('sid', sid) 
        gevent.spawn_later(timeout-1, self._resubscribe, url, sid)

    def _handle(self, environ, start_response):
        device = self._devices[environ['REMOTE_ADDR']]
        doc = cElementTree.parse(environ['wsgi.input'])
        for propnode in doc.findall('./{0}property'.format(NS)):
            for property_ in propnode.getchildren():
                text = property_.text
                if isinstance(device, Insight) and property_.tag=='BinaryState':
                    text = text.split('|')[0]
                subscription.send(device, type=property_.tag, value=text)
                self._event(device, property_.tag, text)
        start_response('200 OK', [
            ('Content-Type', 'text/html'), 
            ('Content-Length', len(SUCCESS)),
            ('Connection', 'close')
        ])
        yield SUCCESS

    def _event(self, device, type_, value):
        for t, callback in self._callbacks.get(device, ()):
            if t == type_:
                callback(value)

    def on(self, device, type, callback):
        self._callbacks[device].append((type, callback))

    @property
    def server(self):
        """
        UDP server to listen for responses.
        """
        server = getattr(self, "_server", None)
        if server is None:
            server = WSGIServer(('', 8989), self._handle, log=None)
            self._server = server
        return server


########NEW FILE########
__FILENAME__ = utils
import time
import socket
import struct
import re


def tz_hours():
    delta = time.localtime().tm_hour - time.gmtime().tm_hour
    sign = '-' if delta < 0 else ''
    return "%s%02d.00" % (sign, abs(delta))


def is_dst():
    return 1 if time.localtime().tm_isdst else 0


def get_timesync():
    timesync = """
<?xml version="1.0" encoding="utf-8"?>
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
 <s:Body>
  <u:TimeSync xmlns:u="urn:Belkin:service:timesync:1">
   <UTC>{utc}</UTC>
   <TimeZone>{tz}</TimeZone>
   <dst>{dst}</dst>
   <DstSupported>{dstsupported}</DstSupported>
  </u:TimeSync>
 </s:Body>
</s:Envelope>""".format(
        utc=int(time.time()),
        tz=tz_hours(),
        dst=is_dst(),
        dstsupported=is_dst()).strip()
    return timesync


def get_ip_address():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(('1.2.3.4', 9))
        return s.getsockname()[0]
    except socket.error:
        return None
    finally:
        del s


def matcher(match_string):
    pattern = re.compile('.*?'.join(re.escape(c) for c in match_string.lower()))
    def matches(s):
        return pattern.search(s.lower()) is not None
    return matches


########NEW FILE########
__FILENAME__ = test_ouimeaux
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
test_ouimeaux
----------------------------------

Tests for `ouimeaux` module.
"""

import unittest


import ouimeaux

class TestOuimeaux(unittest.TestCase):

    def setUp(self):
        pass

    def test_something(self):
        pass

    def tearDown(self):
        pass

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
