__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# trombi documentation build configuration file, created by
# sphinx-quickstart on Mon Aug 30 20:00:26 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'trombi'
copyright = u'2011, Jyrki Pulliainen; 2010, Inoi Oy'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.9'
# The full version, including alpha/beta/rc tags.
release = '0.9.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'trombidoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'trombi.tex', u'trombi Documentation',
   u'Inoi Oy', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = couch_util
# Copyright (c) 2011 Jyrki Pulliainen <jyrki@dywypi.org>
# Copyright (c) 2010 Inoi Oy
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import errno
import json
import os
import shutil
import subprocess
import time
import sys

try:
    # Python 3
    from urllib import request
    from urllib.error import URLError
except ImportError:
    # Python 3
    import urllib2 as request
    from urllib2 import URLError

import nose.tools
from tornado.httpclient import HTTPClient, HTTPError

baseurl = ''

_proc = None


def setup_with_admin():
    global _proc, baseurl
    try:
        shutil.rmtree('tmp')
    except OSError:
        # Python 3
        err = sys.exc_info()[1]
        if err.errno != errno.ENOENT:
            raise

    os.mkdir('tmp')
    os.mkdir('tmp/couch')

    port = 8922
    baseurl = 'http://localhost:%d/' % (port)

    dir = os.path.dirname(__file__)

    cmdline = 'couchdb -n -a %s -a %s' % (
        os.path.join(dir, 'conf/local.ini'),
        os.path.join(dir, 'conf/local_session.ini'),
    )

    null = open('/dev/null', 'w')
    _proc = subprocess.Popen(
        cmdline, shell=True, stdout=null, stderr=null
    )

    # Wait for couchdb to start
    time.sleep(1)
    # Wait for couchdb to start

    while True:
        try:
            f = request.urlopen('http://localhost:%s' % port)
        except URLError:
            continue
        try:
            json.loads(f.read().decode('utf-8'))
        except ValueError:
            continue
        # Got a sensible response
        break


def setup():
    global _proc, baseurl
    try:
        shutil.rmtree('tmp')
    except OSError:
        # Python 3
        err = sys.exc_info()[1]
        if err.errno != errno.ENOENT:
            raise

    os.mkdir('tmp')
    os.mkdir('tmp/couch')

    port = 8921
    baseurl = 'http://localhost:%d/' % (port)

    dir = os.path.dirname(__file__)
    cmdline = 'couchdb -n -a %s' % os.path.join(dir, 'conf/local.ini')
    null = open('/dev/null', 'w')
    _proc = subprocess.Popen(cmdline, shell=True, stdout=null, stderr=null)

    # Wait for couchdb to start
    time.sleep(1)
    # Wait for couchdb to start

    while True:
        try:
            f = request.urlopen('http://localhost:%s' % port)
        except URLError:
            continue
        try:
            json.loads(f.read().decode('utf-8'))
        except ValueError:
            continue
        # Got a sensible response
        break


def teardown():
    global _proc
    _proc.terminate()
    _proc.wait()


_couch_1_1_user_view = """
(
    function(newDoc, oldDoc, userCtx) {
        if (newDoc._deleted === true) {
            // allow deletes by admins and matching users
            // without checking the other fields
            if ((userCtx.roles.indexOf('_admin') !== -1) ||
                (userCtx.name == oldDoc.name)) {
                return;
            } else {
                throw({forbidden: 'Only admins may delete other user docs.'});
            }
        }

        if ((oldDoc && oldDoc.type !== 'user') || newDoc.type !== 'user') {
            throw({forbidden : 'doc.type must be user'});
        } // we only allow user docs for now

        if (!newDoc.name) {
            throw({forbidden: 'doc.name is required'});
        }

        if (newDoc.roles && !isArray(newDoc.roles)) {
            throw({forbidden: 'doc.roles must be an array'});
        }

        if (newDoc._id !== ('org.couchdb.user:' + newDoc.name)) {
            throw({
                forbidden: 'Doc ID must be of the form org.couchdb.user:name'
            });
        }

        if (oldDoc) { // validate all updates
            if (oldDoc.name !== newDoc.name) {
                throw({forbidden: 'Usernames can not be changed.'});
            }
        }

        if (newDoc.password_sha && !newDoc.salt) {
            throw({
                forbidden: 'Users with password_sha must have a salt.' +
                    'See /_utils/script/couch.js for example code.'
            });
        }

        if (userCtx.roles.indexOf('_admin') === -1) {
            if (oldDoc) { // validate non-admin updates
                if (userCtx.name !== newDoc.name) {
                    throw({
                        forbidden: 'You may only update your own user document.'
                    });
                }
                // validate role updates
                var oldRoles = oldDoc.roles.sort();
                var newRoles = newDoc.roles.sort();

                if (oldRoles.length !== newRoles.length) {
                    throw({forbidden: 'Only _admin may edit roles'});
                }

                for (var i = 0; i < oldRoles.length; i++) {
                    if (oldRoles[i] !== newRoles[i]) {
                        throw({forbidden: 'Only _admin may edit roles'});
                    }
                }
            } else if (newDoc.roles.length > 0) {
                throw({forbidden: 'Only _admin may set roles'});
            }
        }

        // no system roles in users db
        for (var i = 0; i < newDoc.roles.length; i++) {
            if (newDoc.roles[i][0] === '_') {
                throw({
                    forbidden:
                    'No system roles (starting with underscore) in users db.'
                });
            }
        }

        // no system names as names
        if (newDoc.name[0] === '_') {
            throw({forbidden: 'Username may not start with underscore.'});
        }
    }
)
"""


def with_couchdb(func):
    @nose.tools.make_decorator(func)
    def inner(*args, **kwargs):
        global baseurl

        cli = HTTPClient()
        # Delete all old databases
        response = cli.fetch('%s_all_dbs' % baseurl)
        try:
            dbs = json.loads(response.body.decode('utf-8'))
        except ValueError:
            print >> sys.stderr, \
                "CouchDB's response was invalid JSON: %s" % response.body
            sys.exit(2)

        for database in dbs:
            if database.startswith('_'):
                # Skip special databases like _users
                continue
            cli.fetch(
                '%s%s' % (baseurl, database),
                method='DELETE',
                )

        # Update _auth with parenthesis, in case we are running too
        # new spidermonkey, which fails in evaluation

        user_auth_doc = json.loads(
            cli.fetch('%s/_users/_design/_auth' % baseurl).body
        )

        user_auth_doc['validate_doc_update'] = _couch_1_1_user_view

        try:
            response = cli.fetch('%s_session' % baseurl,
                  headers={
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  method='POST',
                  body='name=admin&password=admin',
            )
            cookie = response.headers['Set-Cookie']
        except HTTPError:
            cookie = ''

        cli.fetch(
            '%s/_users/_design/_auth/' % baseurl,
            body=json.dumps(user_auth_doc),
            method='PUT',
            headers={'Cookie': cookie},
        )

        return func(baseurl, *args, **kwargs)

    return inner

########NEW FILE########
__FILENAME__ = test_client
# Copyright (c) 2011 Jyrki Pulliainen <jyrki@dywypi.org>
# Copyright (c) 2010 Inoi Oy
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import with_statement

from datetime import datetime
import sys

from nose.tools import eq_ as eq
from .couch_util import setup, teardown, with_couchdb
from .util import with_ioloop, DatetimeEncoder

try:
    import json
except ImportError:
    import simplejson as json

try:
    # Python 3
    from urllib.request import urlopen
    from urllib.error import HTTPError
except ImportError:
    # Python 2
    from urllib2 import urlopen
    from urllib2 import HTTPError

import trombi
import trombi.errors


def test_from_uri():
    db = trombi.from_uri('http://1.2.3.4/foobar')
    assert isinstance(db.server, trombi.Server)
    eq(db.baseurl, 'http://1.2.3.4/foobar')
    eq(db.name, 'foobar')

    db = trombi.from_uri('http://1.2.3.4:1122/foobar/')
    assert isinstance(db.server, trombi.Server)
    eq(db.baseurl, 'http://1.2.3.4:1122/foobar')
    eq(db.name, 'foobar')


@with_ioloop
def test_cannot_connect(ioloop):
    def create_callback(db):
        eq(db.error, True)
        eq(db.errno, 599)
        eq(db.msg, 'Unable to connect to CouchDB')
        ioloop.stop()

    s = trombi.Server('http://localhost:39998', io_loop=ioloop)
    s.create('couchdb-database', callback=create_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_create_db(baseurl, ioloop):
    def create_callback(db):
        eq(db.error, False)
        assert isinstance(db, trombi.Database)
        f = urlopen('%s_all_dbs' % baseurl)
        assert 'couchdb-database' in json.loads(f.read().decode('utf-8'))
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('couchdb-database', callback=create_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_db_exists(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)

    def first_callback(db):
        s.create(
            'couchdb-database',
            callback=callback,
            )

    def callback(result):
        eq(result.error, True)
        eq(result.errno, trombi.errors.PRECONDITION_FAILED)
        eq(result.msg, "Database already exists: 'couchdb-database'")
        f = urlopen('%s_all_dbs' % baseurl)
        assert 'couchdb-database' in json.loads(f.read().decode('utf-8'))
        ioloop.stop()

    s.create('couchdb-database', callback=first_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_invalid_db_name(baseurl, ioloop):
    def callback(result):
        eq(result.error, True)
        eq(result.errno, trombi.errors.INVALID_DATABASE_NAME)
        eq(result.msg, "Invalid database name: 'this name is invalid'")
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('this name is invalid', callback=callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_get_create_doesnt_yet_exist(baseurl, ioloop):
    def callback(db):
        eq(db.error, False)
        eq(db.name, 'nonexistent')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.get('nonexistent', create=True, callback=callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_get_create_already_exists(baseurl, ioloop):
    def create_callback(db):
        eq(db.name, 'new')
        s.get('new', create=True, callback=get_callback)

    def get_callback(db):
        eq(db.error, False)
        eq(db.name, 'new')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('new', callback=create_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_delete_db(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)

    def create_callback(db):
        s.delete('testdatabase', callback=delete_callback)

    def delete_callback(result):
        eq(result.error, False)
        f = urlopen('%s_all_dbs' % baseurl)
        data = f.read().decode('utf-8')
        eq([x for x in json.loads(data) if not x.startswith('_')], [])
        ioloop.stop()

    s.create('testdatabase', callback=create_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_delete_db_not_exists(baseurl, ioloop):
    def callback(result):
        eq(result.error, True)
        eq(result.errno, trombi.errors.NOT_FOUND)
        eq(result.msg, "Database does not exist: 'testdatabase'")
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.delete('testdatabase', callback=callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_list_databases(baseurl, ioloop):
    def create_first(db):
        s.create('testdb2', callback=create_second)

    def create_second(db):
        s.list(callback=list_callback)

    def list_callback(databases):
        databases = list(databases)
        assert all(isinstance(x, trombi.Database) for x in databases)
        eq(
            set(['testdb2', 'testdb1']),
            set([x.name for x in databases if not x.name.startswith('_')]),
            )
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb1', callback=create_first)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_open_database(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)

    def create_callback(db):
        s.get('testdb1', callback=get_callback)

    def get_callback(db):
        eq(db.error, False)
        eq(db.name, 'testdb1')
        eq(db.server, s)
        ioloop.stop()

    s.create('testdb1', callback=create_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_open_nonexisting_database(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)

    def callback(result):
        eq(result.error, True)
        eq(result.errno, trombi.errors.NOT_FOUND)
        eq(result.msg, "Database not found: testdb1")
        ioloop.stop()

    s.get('testdb1', callback=callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_open_database_bad_name(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)

    def callback(result):
        eq(result.error, True)
        eq(result.errno, trombi.errors.INVALID_DATABASE_NAME)
        eq(result.msg, "Invalid database name: 'not a valid name'")
        ioloop.stop()

    s.get('not a valid name', callback=callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_db_info(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)

    def get_info(db):
        db.info(check_info)

    def check_info(info):
        eq(info.error, False)
        eq(info['db_name'], 'testdb')
        eq(info['doc_count'], 0)
        assert 'update_seq' in info
        assert 'disk_size' in info
        ioloop.stop()

    s.create('testdb', callback=get_info)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_create_document(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            {'testvalue': 'something'},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        eq(doc.error, False)
        assert isinstance(doc, trombi.Document)
        assert doc.id
        assert doc.rev

        eq(doc['testvalue'], 'something')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_create_document_with_slash(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'something/with/slash',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        eq(doc.error, False)
        assert isinstance(doc, trombi.Document)
        assert doc.id
        assert doc.rev

        eq(doc.id, 'something/with/slash')
        eq(doc['testvalue'], 'something')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_get_document(baseurl, ioloop):
    def do_test(db):
        def create_doc_callback(doc):
            db.get(doc.id, callback=get_doc_callback)

        def get_doc_callback(doc):
            eq(doc.error, False)
            assert isinstance(doc, trombi.Document)
            assert doc.id
            assert doc.rev

            eq(doc['testvalue'], 'something')
            ioloop.stop()

        db.set(
            {'testvalue': 'something'},
            create_doc_callback,
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_get_document_with_attachments(baseurl, ioloop):
    def do_test(db):
        def create_doc_callback(doc):
            db.get(doc.id, callback=get_doc_callback, attachments=True)

        def get_doc_callback(doc):
            assert isinstance(doc, trombi.Document)
            assert doc.id
            assert doc.rev

            eq(doc['testvalue'], 'something')

            def _assert_on_fetch(*a, **kw):
                assert False, 'Fetch detected, failing test!'

            doc.db._fetch = _assert_on_fetch

            doc.load_attachment('foo', got_attachment)

        def got_attachment(data):
            eq(data, b'bar')
            ioloop.stop()

        db.set(
            {'testvalue': 'something'},
            create_doc_callback,
            attachments={'foo': (None, b'bar')}
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_get_attachment(baseurl, ioloop):
    def do_test(db):
        def start():
            db.set(
                {'testvalue': 'something'},
                doc_created,
                attachments={'foo': (None, b'bar')},
                )

        def doc_created(doc):
            db.get_attachment(doc.id, 'foo', check_attachment)

        def check_attachment(data):
            eq(data, b'bar')
            ioloop.stop()

        start()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_get_attachment_doc_doesnt_exist(baseurl, ioloop):
    def do_test(db):
        def start():
            db.get_attachment('bar', 'foo', check_attachment)

        def check_attachment(data):
            eq(data, None)
            ioloop.stop()

        start()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_get_attachment_doc_exists_attachment_doesnt(baseurl, ioloop):
    def do_test(db):
        def start():
            db.set(
                {'testvalue': 'something'},
                doc_created,
                )

        def doc_created(doc):
            db.get_attachment(doc.id, 'foo', check_attachment)

        def check_attachment(data):
            eq(data, None)
            ioloop.stop()

        start()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_create_document_custom_id(baseurl, ioloop):
    def do_test(db):
        def create_doc_callback(doc):
            eq(doc.error, False)
            assert isinstance(doc, trombi.Document)
            eq(doc.id, 'testid')
            assert '_id' not in doc
            assert '_rev' not in doc
            assert doc.rev

            eq(doc['testvalue'], 'something')

            f = urlopen('%stestdb/testid' % baseurl)
            data = f.read().decode('utf-8')
            eq(json.loads(data),
               {'_id': 'testid',
                '_rev': doc.rev,
                'testvalue': 'something',
                })
            ioloop.stop()

        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_delete_document(baseurl, ioloop):
    def do_test(db):
        def create_doc_callback(doc):
            eq(db.error, False)
            db.delete(doc, callback=delete_doc_callback)

        def delete_doc_callback(db):
            eq(db.error, False)
            assert isinstance(db, trombi.Database)

            try:
                urlopen('%stestdb/testid' % baseurl)
            except HTTPError:
                # Python 3
                e = sys.exc_info()[1]
                eq(e.code, 404)
            else:
                assert 0

            ioloop.stop()

        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_delete_document_not_existing(baseurl, ioloop):
    def do_test(db):
        def create_doc_callback(doc):
            doc.id = 'wrongid'
            db.delete(doc, callback=delete_doc_errback)

        def delete_doc_errback(response):
            eq(response.error, True)
            eq(response.errno, trombi.errors.NOT_FOUND)
            eq(response.msg, 'missing')
            ioloop.stop()

        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_delete_document_wrong_rev(baseurl, ioloop):
    def do_test(db):
        def create_doc_callback(doc):
            doc.rev = '1-eabf'
            db.delete(doc, callback=delete_doc_callback)

        def delete_doc_callback(result):
            eq(result.error, True)
            eq(result.errno, trombi.errors.CONFLICT)
            eq(result.msg, 'Document update conflict.')
            ioloop.stop()

        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_delete_document_invalid_rev(baseurl, ioloop):
    def do_test(db):
        def create_doc_callback(doc):
            doc.rev = 'invalid'
            db.delete(doc, callback=delete_doc_callback)

        def delete_doc_callback(result):
            eq(result.error, True)
            eq(result.errno, trombi.errors.BAD_REQUEST)
            eq(result.msg, 'Invalid rev format')
            ioloop.stop()

        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_create_document_custom_id_exists(baseurl, ioloop):
    def do_test(db):
        def create_doc_callback(doc):
            db.set(
                'testid',
                {'testvalue': 'something'},
                update_doc_error,
                )

        def update_doc_error(result):
            eq(result.error, True)
            eq(result.errno, trombi.errors.CONFLICT)
            eq(result.msg, 'Document update conflict.')
            ioloop.stop()

        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_update_document(baseurl, ioloop):
    def do_test(db):
        def update_doc(doc):
            doc['newvalue'] = 'somethingelse'
            db.set(doc, doc_updated)

        def doc_updated(doc):
            eq(doc, {
                'testvalue': 'something',
                'newvalue': 'somethingelse',
            })
            ioloop.stop()

        db.set(
            'testid',
            {'testvalue': 'something'},
            update_doc,
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_set_document_change_id(baseurl, ioloop):
    def do_test(db):
        def update_doc(doc):
            doc['newvalue'] = 'somethingelse'
            db.set('otherid', doc, doc_updated)

        def doc_updated(doc):
            eq(doc, {
                'testvalue': 'something',
                'newvalue': 'somethingelse',
            })
            eq(doc.id, 'otherid')

            # Check that the original didn't change
            db.get('testid', check_original)

        def check_original(doc):
            eq(doc, {'testvalue': 'something'})
            eq(doc.id, 'testid')
            ioloop.stop()

        db.set('testid', {'testvalue': 'something'}, update_doc)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_set_document_with_kw_callback(baseurl, ioloop):
    def do_test(db):
        def update_doc(doc):
            ioloop.stop()

        db.set('testid', {'testvalue': 'something'}, callback=update_doc)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_get_document_does_not_exist(baseurl, ioloop):
    def create_db_callback(db):
        db.get('foo', callback=get_callback)

    def get_callback(doc):
        eq(doc, None)
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_save_attachment_inline(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'testid',
            {'testvalue': 'something'},
            data_callback,
            attachments={'foobar': (None, b'some textual data')},
            )

    def data_callback(doc):
        f = urlopen('%stestdb/testid/foobar' % baseurl)
        eq(f.read(), b'some textual data')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_save_attachment_inline_custom_content_type(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'testid',
            {'testvalue': 'something'},
            data_callback,
            attachments={'foobar':
                             ('application/x-custom', b'some textual data')
                         },
            )

    def data_callback(doc):
        f = urlopen('%stestdb/testid/foobar' % baseurl)
        eq(f.info()['Content-Type'], 'application/x-custom')
        eq(f.read(), b'some textual data')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_save_attachment(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        data = b'some textual data'
        doc.attach('foobar', data, callback=data_callback)

    def data_callback(doc):
        f = urlopen('%stestdb/testid/foobar' % baseurl)
        eq(f.read(), b'some textual data')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_save_attachment_wrong_rev(baseurl, ioloop):
    def do_test(db):
        def create_doc_callback(doc):
            doc.rev = '1-deadbeef'
            data = 'some textual data'
            doc.attach('foobar', data, callback=data_callback)

        def data_callback(doc):
            eq(doc.error, True)
            ioloop.stop()

        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_attachment(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        data = b'some textual data'
        doc.attach('foobar', data, callback=attach_callback)

    def attach_callback(doc):
        doc.load_attachment('foobar', callback=data_callback)

    def data_callback(data):
        eq(data, b'some textual data')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_unkonwn_attachment(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        doc.load_attachment('foobar', callback=data_callback)

    def data_callback(result):
        eq(result.error, True)
        eq(result.errno, trombi.errors.NOT_FOUND)
        eq(result.msg, 'Document is missing attachment')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_inline_attachment(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'testid',
            {'testvalue': 'something'},
            attach_callback,
            attachments={'foobar': (None, b'some textual data')},
            )

    def attach_callback(doc):
        doc.load_attachment('foobar', callback=data_callback)

    def data_callback(data):
        eq(data, b'some textual data')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_inline_attachment_no_fetch(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'testid',
            {'testvalue': 'something'},
            attach_callback,
            attachments={'foobar': (None, b'some textual data')},
            )

    def attach_callback(doc):
        def _broken_fetch(*a, **kw):
            assert False, 'Fetch called when not needed!'

        doc.db._fetch = _broken_fetch
        doc.load_attachment('foobar', callback=data_callback)

    def data_callback(data):
        eq(data, b'some textual data')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_delete_attachment(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        data = b'some textual data'
        doc.attach('foobar', data, callback=attach_callback)

    def attach_callback(doc):
        doc.delete_attachment('foobar', callback=delete_callback)

    def delete_callback(doc):
        try:
            urlopen('%stestdb/testid/foobar' % baseurl)
        except HTTPError:
            # Python 3
            e = sys.exc_info()[1]
            eq(e.code, 404)
        else:
            assert 0

        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_delete_attachment_wrong_rev(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            'testid',
            {'testvalue': 'something'},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        doc.rev = '1-deadwrong'
        data = 'some textual data'
        doc.attach('foobar', data, callback=attach_callback)

    def attach_callback(doc):
        eq(doc.error, True)
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_view_empty_results(baseurl, ioloop):
    def do_test(db):
        def create_view_callback(response):
            eq(response.code, 201)
            db.view('testview', 'all', load_view_cb)

        def load_view_cb(result):
            assert isinstance(result, trombi.ViewResult)
            eq(result.error, False)
            eq(len(result), 0)
            ioloop.stop()

        db.server._fetch(
            '%stestdb/_design/testview' % baseurl,
            create_view_callback,
            method='PUT',
            body=json.dumps(
                {
                    'language': 'javascript',
                    'views': {
                        'all': {
                            'map': 'function (doc) { emit(null, doc) }',
                            }
                        }
                    }
                )
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_view_with_results(baseurl, ioloop):
    def do_test(db):
        def create_view_callback(response):
            eq(response.code, 201)
            db.set({'data': 'data'}, create_doc_cb)

        def create_doc_cb(doc):
            db.view('testview', 'all', load_view_cb)

        def load_view_cb(result):
            eq(result.error, False)
            eq(len(result), 1)
            del result[0]['value']['_rev']
            del result[0]['value']['_id']
            del result[0]['id']
            eq(list(result), [{'value': {'data': 'data'}, 'key': None}])
            ioloop.stop()

        db.server._fetch(
            '%stestdb/_design/testview' % baseurl,
            create_view_callback,
            method='PUT',
            body=json.dumps(
                {
                    'language': 'javascript',
                    'views': {
                        'all': {
                            'map': '(function (doc) { emit(null, doc) })',
                            }
                        }
                    }
                )
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_view_with_grouping_reduce(baseurl, ioloop):
    def do_test(db):
        def create_view_callback(response):
            eq(response.code, 201)
            db.set({'data': 'data'}, create_1st_doc_cb)

        def create_1st_doc_cb(doc):
            db.set({'data': 'other'}, create_2nd_doc_cb)

        def create_2nd_doc_cb(doc):
            db.view('testview', 'all', load_view_cb, group=True)

        def load_view_cb(result):
            eq(result.error, False)
            eq(list(result), [{'value': 1, 'key': 'data'},
                              {'value': 1, 'key': 'other'}])
            ioloop.stop()

        db.server._fetch(
            '%stestdb/_design/testview' % baseurl,
            create_view_callback,
            method='PUT',
            body=json.dumps(
                {
                    'language': 'javascript',
                    'views': {
                        'all': {
                            'map': '(function (doc) { emit(doc.data, doc) })',
                            'reduce': '(function (key, value) { return \
                                       value.length })',
                            }
                        }
                    }
                )
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_view_with_keys(baseurl, ioloop):
    def do_test(db):
        def create_view_callback(response):
            eq(response.code, 201)
            db.set({'data': 'data'}, create_1st_doc_cb)

        def create_1st_doc_cb(doc):
            db.set({'data': 'other'}, create_2nd_doc_cb)

        def create_2nd_doc_cb(doc):
            db.view('testview', 'all', load_view_cb, keys=['data'])

        def load_view_cb(result):
            eq(result.error, False)
            eq(len(result), 1)
            eq(result[0]['key'], 'data')
            ioloop.stop()

        db.server._fetch(
            '%stestdb/_design/testview' % baseurl,
            create_view_callback,
            method='PUT',
            body=json.dumps(
                {
                    'language': 'javascript',
                    'views': {
                        'all': {
                            'map': '(function (doc) { emit(doc.data, doc) })',
                            }
                        }
                    }
                )
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_view_no_design_doc(baseurl, ioloop):
    def create_db_callback(db):
        def load_view_cb(result):
            eq(result.error, True)
            eq(result.errno, trombi.errors.NOT_FOUND)
            eq(result.msg, 'missing')
            ioloop.stop()
        db.view('testview', 'all', load_view_cb, group='true')

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_load_view_no_such_view(baseurl, ioloop):
    def do_test(db):
        def create_view_callback(useless):
            db.view('testview', 'all', load_view_cb)

        def load_view_cb(result):
            eq(result.error, True)
            eq(result.errno, trombi.errors.NOT_FOUND)
            eq(result.msg, 'missing_named_view')
            ioloop.stop()

        db.server._fetch(
            '%stestdb/_design/testview' % baseurl,
            create_view_callback,
            method='PUT',
            body=json.dumps(
                {
                    'language': 'javascript',
                    'views': {
                        'foobar': {
                            'map': '(function (doc) { emit(doc.data, doc) })',
                            'reduce': '(function (key, value) { return \
                                       value.length })',
                            }
                        }
                    }
                )
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_temporary_view_empty_results(baseurl, ioloop):
    def create_db_callback(db):
        db.temporary_view(view_results, 'function(doc) { emit(null, doc); }')

    def view_results(result):
        assert isinstance(result, trombi.ViewResult)
        eq(result.error, False)
        eq(list(result), [])
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_temporary_view_no_such_db(baseurl, ioloop):
    def view_results(result):
        eq(result.error, True)
        eq(result.errno, trombi.errors.NOT_FOUND)
        eq(result.msg, 'no_db_file')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    db = trombi.Database(s, 'doesnotexist')
    db.temporary_view(view_results, '(function() { emit(null);})')
    ioloop.start()


@with_ioloop
@with_couchdb
def test_temporary_view_nonempty_results(baseurl, ioloop):
    def do_test(db):
        def doc_ready(doc):
            db.temporary_view(view_results,
                              '(function(doc) { emit(null, doc); })')

        def view_results(results):
            eq(len(results), 1)
            result = results[0]

            # Remove keys starting with _
            eq(
                dict((k, v) for k, v in result['value'].items()
                     if k[0] != '_'),
                {'foo': 'bar'}
            )
            eq(result['key'], None)

            ioloop.stop()

        db.set('testid', {'foo': 'bar'}, doc_ready)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_temporary_view_with_reduce_fun(baseurl, ioloop):
    def do_test(db):
        def doc_ready(doc):
            db.set({'value': 2}, doc2_ready)

        def doc2_ready(doc):
            db.temporary_view(
                view_results,
                map_fun='(function(doc) { emit(null, doc.value); })',
                reduce_fun='(function(key, values) { return sum(values); })'
            )

        def view_results(result):
            eq(result.error, False)
            eq(list(result), [{'key': None, 'value': 3}])
            ioloop.stop()

        db.set({'value': 1}, doc_ready)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_copy_document(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            {'testvalue': 'something'},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        doc.copy('newname', copy_done)

    def copy_done(doc):
        eq(doc.id, 'newname')
        eq(dict(doc), {'testvalue': 'something'})
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_copy_document_exists(baseurl, ioloop):
    def do_test(db):
        def create_doc(doc):
            db.set(
                {'testvalue': 'something'},
                copy_doc,
                )

        def copy_doc(doc):
            doc.copy('newname', copy_done)

        def copy_done(result):
            eq(result.error, True)
            eq(result.errno, trombi.errors.CONFLICT)
            eq(result.msg, 'Document update conflict.')
            ioloop.stop()

        db.set('newname', {'something': 'else'}, create_doc)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_copy_document_with_attachments(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            {'testvalue': 'something'},
            create_doc_callback,
            attachments={'foo': (None, b'bar')}
            )

    def create_doc_callback(doc):
        doc.copy('newname', copy_done)

    def copy_done(doc):
        eq(doc.id, 'newname')
        eq(dict(doc), {'testvalue': 'something'})
        eq(list(doc.attachments.keys()), ['foo'])
        eq(doc.attachments['foo']['content_type'], 'text/plain')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_copy_loaded_document_with_attachments_false(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            {'testvalue': 'something'},
            create_doc_callback,
            attachments={'foo': (None, b'bar')}
            )

    def create_doc_callback(doc):
        doc.db.get(doc.id, got_doc)

    def got_doc(doc):
        doc.copy('newname', copy_done)

    def copy_done(doc):
        eq(doc.id, 'newname')
        eq(dict(doc), {'testvalue': 'something'})
        doc.load_attachment('foo', loaded_attachment)

    def loaded_attachment(attach):
        eq(attach, b'bar')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_copy_loaded_document_with_attachments_true(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            {'testvalue': 'something'},
            create_doc_callback,
            attachments={'foo': (None, b'bar')}
            )

    def create_doc_callback(doc):
        doc.db.get(doc.id, got_doc, attachments=True)

    def got_doc(doc):
        doc.copy('newname', copy_done)

    def copy_done(doc):
        eq(doc.id, 'newname')
        eq(dict(doc), {'testvalue': 'something'})
        eq(list(doc.attachments.keys()), ['foo'])
        eq(doc.attachments['foo']['content_type'], 'text/plain')
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_create_document_raw(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            {'testvalue': 'something'},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        eq(doc.error, False)
        assert isinstance(doc, trombi.Document)
        assert doc.id
        assert doc.rev

        eq(doc.raw(),
           {
                '_id': doc.id,
                '_rev': doc.rev,
                'testvalue': 'something',
                })
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_view_results_with_offset(baseurl, ioloop):
    def do_test(db):
        def create_view_callback(response):
            eq(response.code, 201)
            db.set({'data': 'data'}, create_first_doc_cb)

        def create_first_doc_cb(response):
            db.set({'another': 'data'}, create_docs_cb)

        def create_docs_cb(doc):
            db.view('testview', 'all', load_view_cb, skip=1)

        def load_view_cb(result):
            eq(result.error, False)
            eq(len(result), 1)
            eq(result.total_rows, 2)
            eq(result.offset, 1)
            ioloop.stop()

        db.server._fetch(
            '%stestdb/_design/testview' % baseurl,
            create_view_callback,
            method='PUT',
            body=json.dumps(
                {
                    'language': 'javascript',
                    'views': {
                        'all': {
                            'map': '(function (doc) { emit(null, doc) })',
                            }
                        }
                    }
                )
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_view_results_include_docs(baseurl, ioloop):
    def do_test(db):
        def create_view_callback(response):
            eq(response.code, 201)
            db.set({'data': 'data'}, create_first_doc_cb)

        def create_first_doc_cb(response):
            db.set({'another': 'data'}, create_docs_cb)

        def create_docs_cb(doc):
            db.view('testview', 'all', load_view_cb, include_docs=True)

        def load_view_cb(result):
            eq(result.error, False)
            eq(len(result), 2)
            eq(result.total_rows, 2)
            assert all(isinstance(x['doc'], trombi.Document) for x in result)
            ioloop.stop()

        db.server._fetch(
            '%stestdb/_design/testview' % baseurl,
            create_view_callback,
            method='PUT',
            body=json.dumps(
                {
                    'language': 'javascript',
                    'views': {
                        'all': {
                            'map': '(function (doc) { emit(null, doc) })',
                            }
                        }
                    }
                )
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_view_results_include_docs_with_bogus_docs(baseurl, ioloop):
    def do_test(db):
        def create_view_callback(response):
            eq(response.code, 201)
            db.set({'data': 'data'}, create_first_doc_cb)

        def create_first_doc_cb(response):
            db.set({'another': 'data'}, create_docs_cb)

        def create_docs_cb(doc):
            db.view('testview', 'all', load_view_cb, include_docs=True)

        def load_view_cb(result):
            eq(result.error, False)
            eq(len(result), 2)
            eq(result.total_rows, 2)
            assert all(x['doc'] == None for x in result)
            ioloop.stop()

        db.server._fetch(
            '%stestdb/_design/testview' % baseurl,
            create_view_callback,
            method='PUT',
            body=json.dumps(
                {
                    'language': 'javascript',
                    'views': {
                        'all': {
                            'map': '(function (doc) { emit(null, \
                            {"_id": "bogus"}) })',
                            }
                        }
                    }
                )
            )

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_bulk_insert(baseurl, ioloop):
    def do_test(db):
        datas = [
            {'key1': 'data1'},
            {'key2': 'data2'},
            ]
        db.bulk_docs(datas, bulks_cb)

    def bulks_cb(response):
        assert not response.error
        eq(len(response), 2)
        assert all(isinstance(x, trombi.BulkObject) for x in response)
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_bulk_delete(baseurl, ioloop):
    def do_test(db):
        def bulks_cb(response):
            datas = []
            for doc in response:
                datas.append(dict(doc))
                datas[-1]['_deleted'] = True
            db.bulk_docs(datas, bulks_delete_cb)

        def bulks_delete_cb(response):
            eq(response.error, False)
            eq(len(response), 2)
            assert all(isinstance(x, trombi.BulkObject) for x in response)
            ioloop.stop()

        datas = [
            {'key1': 'data1'},
            {'key2': 'data2'},
            ]
        db.bulk_docs(datas, bulks_cb)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_bulk_mixed(baseurl, ioloop):
    def do_test(db):
        def bulks_cb(response):
            datas = [dict(response[0])]
            datas[0]['_deleted'] = True
            db.bulk_docs(datas, bulks_delete_cb)

        def bulks_delete_cb(response):
            eq(response.error, False)
            eq(len(response), 1)
            assert all(isinstance(x, trombi.BulkObject) for x in response)
            ioloop.stop()

        datas = [
            {'key1': 'data1'},
            {'key2': 'data2'},
            ]
        db.bulk_docs(datas, bulks_cb)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_bulk_conflict(baseurl, ioloop):
    def do_test(db):
        def bulks_cb(response):
            db.bulk_docs([{
                        '_id': 'foobar', 'key1': 'data2'
                        }], bulks_update_cb)

        def bulks_update_cb(response):
            eq(response.error, False)
            eq(len(response), 1)
            assert all(isinstance(x, trombi.BulkError) for x in response)
            eq(response[0].reason, 'Document update conflict.')
            ioloop.stop()

        datas = [
            {'_id': 'foobar', 'key1': 'data1'},
            ]
        db.bulk_docs(datas, bulks_cb)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_bulk_insert_with_doc(baseurl, ioloop):
    def do_test(db):
        def doc_created_cb(response):
            response['some'] = 'other'
            db.bulk_docs([response], bulks_cb)

        def bulks_cb(response):
            assert not response.error
            eq(len(response), 1)
            assert all(isinstance(x, trombi.BulkObject) for x in response)
            ioloop.stop()

        db.set('mydoc', {'some': 'data'}, doc_created_cb)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_bulk_insert_mixed(baseurl, ioloop):
    def do_test(db):
        def doc_created_cb(response):
            response['some'] = 'other'
            db.bulk_docs([response, {'other': 'doc'}], bulks_cb)

        def bulks_cb(response):
            assert not response.error
            eq(len(response), 2)
            assert all(isinstance(x, trombi.BulkObject) for x in response)
            ioloop.stop()

        db.set('mydoc', {'some': 'data'}, doc_created_cb)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_continuous_changes_feed(baseurl, ioloop):
    def do_test(db):
        runs = []

        def _got_change(change):
            runs.append(True)
            change['changes'][0].pop('rev')

            if len(runs) == 1:
                # First change
                eq(change, {'seq': 1, 'id': 'mydoc', 'changes': [{}]})

            elif len(runs) == 2:
                # Second change
                eq(change, {'seq': 2, 'id': 'second_doc', 'changes': [{}]})

                # Create another document
                db.set('third_doc', {'still': 'more'}, lambda x: None)

            elif len(runs) == 3:
                eq(change, {'seq': 3, 'id': 'third_doc', 'changes': [{}]})
                ioloop.stop()

        def doc_created(response):
            assert not response.error
            db.changes(_got_change, feed='continuous')

            # Create another document
            db.set('second_doc', {'more': 'data'}, lambda x: None)

        db.set('mydoc', {'some': 'data'}, doc_created)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_long_polling_changes_feed(baseurl, ioloop):
    changes = []

    def do_test(db):
        def _got_change(change):
            changes.append(change.content)
            ioloop.stop()

        def doc_created(response):
            assert not response.error
            db.changes(_got_change, feed='longpoll')

        db.set('mydoc', {'some': 'data'}, doc_created)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()
    changes[0]['results'][0]['changes'][0].pop('rev')
    eq(changes[0], {'last_seq': 1, 'results': [{
                    'changes': [{}], 'id': 'mydoc', 'seq': 1}]})


@with_ioloop
@with_couchdb
def test_long_polling_before_doc_created(baseurl, ioloop):
    changes = []

    def do_test(db):
        def _got_change(change):
            changes.append(change.content)
            ioloop.stop()

        def doc_created(response):
            assert not response.error

        db.changes(_got_change, feed='longpoll', timeout=2)
        db.set('mydoc', {'some': 'data'}, doc_created)

    s = trombi.Server(baseurl, io_loop=ioloop)
    s.create('testdb', callback=do_test)
    ioloop.start()
    changes[0]['results'][0]['changes'][0].pop('rev')
    eq(changes[0], {'last_seq': 1, 'results': [{
                    'changes': [{}], 'id': 'mydoc', 'seq': 1}]})


def test_custom_encoder():
    s = trombi.Server('http://localhost:5984', json_encoder=DatetimeEncoder)
    json.dumps({'foo': datetime.now()}, cls=s._json_encoder)


def test_custom_encoder_from_uri():
    db = trombi.from_uri('http://localhost:5984/testdb/',
                         json_encoder=DatetimeEncoder)
    json.dumps({'foo': datetime.now()}, cls=db._json_encoder)


@with_ioloop
@with_couchdb
def test_create_document_with_custom_encoder(baseurl, ioloop):
    def create_db_callback(db):
        db.set(
            {'testvalue': datetime(1900, 1, 1)},
            create_doc_callback,
            )

    def create_doc_callback(doc):
        eq(doc.error, False)
        assert isinstance(doc, trombi.Document)
        assert doc.id
        assert doc.rev

        eq(doc['testvalue'], datetime(1900, 1, 1))
        ioloop.stop()

    s = trombi.Server(baseurl, io_loop=ioloop, json_encoder=DatetimeEncoder)
    s.create('testdb', callback=create_db_callback)
    ioloop.start()

########NEW FILE########
__FILENAME__ = test_session
#
# Copyright (c) 2011 Daniel Truemper truemped@googlemail.com
#
# test_session.py 13-Oct-2011
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import with_statement

from nose.tools import eq_ as eq

from ..couch_util import setup_with_admin as setup, teardown, with_couchdb
from ..util import with_ioloop

try:
    import json
except ImportError:
    import simplejson as json

try:
    # Python 3
    from urllib.request import urlopen
    from urllib.error import HTTPError
except ImportError:
    # Python 2
    from urllib2 import urlopen
    from urllib2 import HTTPError

import trombi
import trombi.errors


@with_ioloop
@with_couchdb
def test_session_api_with_wrong_credentials(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)

    def session_callback(response):
        assert response.error
        eq(response.msg, 'Name or password is incorrect.')
        ioloop.stop()

    s.login(username="daniel", password="daniel", callback=session_callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_session_with_user(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)
    result = {}

    def session_callback(session_info):
        result['session_info'] = session_info
        ioloop.stop()

    def add_user_callback(response):
        assert not response.error
        ioloop.stop()

    # add a user
    s.add_user('testuser', 'testpassword', add_user_callback)
    ioloop.start()

    # login
    s.login(username="testuser", password="testpassword",
            callback=session_callback)
    ioloop.start()

    # check for the cookie and user info
    eq(result['session_info'].content, {u'ok': True, u'name': u'testuser',
        u'roles': []})
    assert s.session_cookie.startswith('AuthSession')

    # get the session info
    s.session(session_callback)
    ioloop.start()

    # check that no cookie has been sent and the session info is correct
    eq(result['session_info'].content,
       {u'info': {u'authentication_handlers':
            [u'oauth', u'cookie', u'default'], u'authentication_db':
            u'_users'}, u'userCtx': {u'name': None, u'roles': []},
                                u'ok':
            True})

    # check that logout is working
    s.logout(session_callback)
    ioloop.start()

    assert not s.session_cookie
    eq(result['session_info'].content, {u'ok': True})

########NEW FILE########
__FILENAME__ = test_usermgmt
#
# Copyright (c) 2011 Daniel Truemper truemped@googlemail.com
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#

from __future__ import with_statement

from datetime import datetime
import hashlib
import sys

from nose.tools import eq_ as eq
from .couch_util import setup, teardown, with_couchdb
from .util import with_ioloop, DatetimeEncoder

try:
    import json
except ImportError:
    import simplejson as json

try:
    # Python 3
    from urllib.request import urlopen
    from urllib.error import HTTPError
except ImportError:
    # Python 2
    from urllib2 import urlopen
    from urllib2 import HTTPError

import trombi
import trombi.errors


@with_ioloop
@with_couchdb
def test_add_user(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)

    def callback(doc):
        assert not doc.error
        ioloop.stop()

    s.add_user('test', 'test', callback)
    ioloop.start()


@with_ioloop
@with_couchdb
def test_get_user(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)

    def callback(doc):
        assert not doc.error
        ioloop.stop()

    s.add_user('get_test', 'test', callback)
    ioloop.start()

    user = []
    def callback(doc):
        assert not doc.error
        user.append(doc)
        ioloop.stop()

    s.get_user('get_test', callback)
    ioloop.start()

    eq(True, isinstance(user[0], trombi.Document))

@with_ioloop
@with_couchdb
def test_update_user(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)
    userdoc = []

    def add_callback(doc):
        assert not doc.error
        userdoc.append(doc)
        ioloop.stop()

    s.add_user('updatetest', 'test', add_callback)
    ioloop.start()

    def update_callback(doc):
        assert not doc.error
        userdoc.append(doc)
        ioloop.stop()

    userdoc[0]['roles'].append('test')
    s.update_user(userdoc[0], update_callback)
    ioloop.start()

    eq(userdoc[1]['roles'], ['test'])

    def update_passwd_callback(doc):
        assert not doc.error
        userdoc.append(doc)
        ioloop.stop()

    s.update_user_password('updatetest', 'test2', update_passwd_callback)
    ioloop.start()

    eq(userdoc[1]['salt'], userdoc[2]['salt'])
    eq(userdoc[1]['password_sha'] != userdoc[2]['password_sha'], True)


@with_ioloop
@with_couchdb
def test_delete_user(baseurl, ioloop):
    s = trombi.Server(baseurl, io_loop=ioloop)
    user = []

    def add_callback(doc):
        assert not doc.error
        user.append(doc)
        ioloop.stop()

    s.add_user('deletetest', 'test', add_callback)
    ioloop.start()

    def delete_callback(db):
        assert not db.error
        assert isinstance(db, trombi.Database)
        ioloop.stop()

    s.delete_user(user[0], delete_callback)
    ioloop.start()

########NEW FILE########
__FILENAME__ = util
# Copyright (c) 2010 Inoi Oy
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json
import os
import sys
import errno
import shutil
import types
import nose.tools

from datetime import datetime
from tornado.ioloop import IOLoop

def unrandom(random=None):
    # Make os.urandom not so random. If user wants, a custom random
    # function can be used providing keyword argument `random`
    if random is None:
        random = lambda x: '1' * x

    def outer(func):
        @nose.tools.make_decorator(func)
        def wrap_urandom(*a, **kw):
            _old_urandom = os.urandom
            try:
                os.urandom = random
                func(*a, **kw)
            finally:
                os.urandom = _old_urandom
        return wrap_urandom
    return outer

def with_ioloop(func):
    @nose.tools.make_decorator(func)
    def wrapper(*args, **kwargs):
        ioloop = IOLoop()

        # Override ioloop's _run_callback to let all exceptions through
        def run_callback(self, callback):
            callback()
        ioloop._run_callback = types.MethodType(run_callback, ioloop)

        return func(ioloop, *args, **kwargs)

    return wrapper

def mkdir(*a, **kw):
    try:
        os.mkdir(*a, **kw)
    except OSError:
        # Python 3
        e = sys.exc_info()[1]
        if e.errno == errno.EEXIST:
            pass
        else:
            raise

def find_test_name():
    try:
        from nose.case import Test
        from nose.suite import ContextSuite
        import types
        def get_nose_name(its_self):
            if isinstance(its_self, Test):
                file_, module, class_ = its_self.address()
                name = '%s:%s' % (module, class_)
                return name
            elif isinstance(its_self, ContextSuite):
                if isinstance(its_self.context, types.ModuleType):
                    return its_self.context.__name__
    except ImportError:
        # older nose
        from nose.case import FunctionTestCase, MethodTestCase
        from nose.suite import TestModule
        from nose.util import test_address
        def get_nose_name(its_self):
            if isinstance(its_self, (FunctionTestCase, MethodTestCase)):
                file_, module, class_ = test_address(its_self)
                name = '%s:%s' % (module, class_)
                return name
            elif isinstance(its_self, TestModule):
                return its_self.moduleName

    i = 0
    while True:
        i += 1
        frame = sys._getframe(i)
        # kludge, hunt callers upwards until we find our nose
        if (frame.f_code.co_varnames
            and frame.f_code.co_varnames[0] == 'self'):
            its_self = frame.f_locals['self']
            name = get_nose_name(its_self)
            if name is not None:
                return name

def maketemp():
    tmp = os.path.join(os.path.dirname(__file__), 'tmp')
    mkdir(tmp)

    name = find_test_name()
    tmp = os.path.join(tmp, name)
    try:
        shutil.rmtree(tmp)
    except OSError:
        # Python 3
        e = sys.exc_info()[1]
        if e.errno == errno.ENOENT:
            pass
        else:
            raise
    os.mkdir(tmp)
    return tmp


def assert_raises(excClass, callableObj, *args, **kwargs):
    """
    Like unittest.TestCase.assertRaises, but returns the exception.
    """
    try:
        callableObj(*args, **kwargs)
    except excClass:
        # Python 3
        return sys.exc_info()[1]
    except:
        if hasattr(excClass,'__name__'): excName = excClass.__name__
        else: excName = str(excClass)
        raise AssertionError("%s not raised" % excName)

class DatetimeEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, datetime):
            return o.isoformat()
        else:
            return super(DatetimeEncoder, self).default(o)

########NEW FILE########
__FILENAME__ = client
# Copyright (c) 2011 Jyrki Pulliainen <jyrki@dywypi.org>
# Copyright (c) 2010 Inoi Oy
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Asynchronous CouchDB client"""

import functools
from hashlib import sha1
import uuid
import logging
import re
import collections
import tornado.ioloop
import urllib

try:
    # Python 3
    from urllib.parse import quote as urlquote
    from urllib.parse import urlencode
except ImportError:
    # Python 2
    from urllib import quote as urlquote
    from urllib import urlencode

from base64 import b64encode, b64decode
from tornado.httpclient import AsyncHTTPClient
from tornado.httputil import HTTPHeaders

log = logging.getLogger('trombi')

try:
    import json
except ImportError:
    import simplejson as json

import trombi.errors


def from_uri(uri, fetch_args=None, io_loop=None, **kwargs):
    try:
        # Python 3
        from urllib.parse import urlparse, urlunsplit
    except ImportError:
        # Python 2
        from urlparse import urlparse, urlunsplit

    p = urlparse(uri)
    if p.params or p.query or p.fragment:
        raise ValueError(
            'Invalid database address: %s (extra query params)' % uri)
    if not p.scheme in ('http', 'https'):
        raise ValueError(
            'Invalid database address: %s (only http:// and https:// are supported)' % uri)

    baseurl = urlunsplit((p.scheme, p.netloc, '', '', ''))
    server = Server(baseurl, fetch_args, io_loop=io_loop, **kwargs)

    db_name = p.path.lstrip('/').rstrip('/')
    return Database(server, db_name)


class TrombiError(object):
    """
    A common error class denoting an error that has happened
    """
    error = True


class TrombiErrorResponse(TrombiError):
    def __init__(self, errno, msg):
        self.error = True
        self.errno = errno
        self.msg = msg

    def __str__(self):
        return 'CouchDB reported an error: %s (%d)' % (self.msg, self.errno)


class TrombiObject(object):
    """
    Dummy result for queries that really don't have anything sane to
    return, like succesful database deletion.

    """
    error = False


class TrombiResult(TrombiObject):
    """
    A generic result objects for Trombi queries that do not have any
    formal representation.
    """

    def __init__(self, data):
        self.content = data
        super(TrombiResult, self).__init__()


class TrombiDict(TrombiObject, dict):
    def to_basetype(self):
        return dict(self)


def _jsonize_params(params):
    result = dict()
    for key, value in params.items():
        result[key] = json.dumps(value)
    return urlencode(result)


def _error_response(response):
    if response.code == 599:
        return TrombiErrorResponse(599, 'Unable to connect to CouchDB')

    try:
        content = json.loads(response.body.decode('utf-8'))
    except ValueError:
        return TrombiErrorResponse(response.code, response.body)
    try:
        return TrombiErrorResponse(response.code, content['reason'])
    except (KeyError, TypeError):
        # TypeError is risen if the result is a list
        return TrombiErrorResponse(response.code, content)


class Server(TrombiObject):
    def __init__(self, baseurl, fetch_args=None, io_loop=None,
                 json_encoder=None, **client_args):
        self.error = False
        self.session_cookie = None
        self.baseurl = baseurl
        if self.baseurl[-1] == '/':
            self.baseurl = self.baseurl[:-1]
        if fetch_args is None:
            self._fetch_args = dict()
        else:
            self._fetch_args = fetch_args

        if io_loop is None:
            self.io_loop = tornado.ioloop.IOLoop.instance()
        else:
            self.io_loop = io_loop
        # We can assign None to _json_encoder as the json (or
        # simplejson) then defaults to json.JSONEncoder
        self._json_encoder = json_encoder
        self._client = AsyncHTTPClient(self.io_loop, **client_args)

    def _invalid_db_name(self, name):
        return TrombiErrorResponse(
            trombi.errors.INVALID_DATABASE_NAME,
            'Invalid database name: %r' % name,
            )

    def _fetch(self, *args, **kwargs):
        # This is just a convenince wrapper for _client.fetch

        # Set default arguments for a fetch
        fetch_args = {
            'headers': HTTPHeaders({'Content-Type': 'application/json'})
        }
        fetch_args.update(self._fetch_args)
        fetch_args.update(kwargs)

        if self.session_cookie:
            fetch_args['X-CouchDB-WWW-Authenticate': 'Cookie']
            if 'Cookie' in fetch_args:
                fetch_args['Cookie'] += '; %s' % self.session_cookie
            else:
                fetch_args['Cookie'] = self.sesison_cookie

        self._client.fetch(*args, **fetch_args)

    def create(self, name, callback):
        if not VALID_DB_NAME.match(name):
            # Avoid additional HTTP Query by doing the check here
            callback(self._invalid_db_name(name))

        def _create_callback(response):
            if response.code == 201:
                callback(Database(self, name))
            elif response.code == 412:
                callback(
                    TrombiErrorResponse(
                        trombi.errors.PRECONDITION_FAILED,
                        'Database already exists: %r' % name
                        ))
            else:
                callback(_error_response(response))

        self._fetch(
            '%s/%s' % (self.baseurl, name),
            _create_callback,
            method='PUT',
            body='',
            )

    def get(self, name, callback, create=False):
        if not VALID_DB_NAME.match(name):
            callback(self._invalid_db_name(name))

        def _really_callback(response):
            if response.code == 200:
                callback(Database(self, name))
            elif response.code == 404:
                # Database doesn't exist
                if create:
                    self.create(name, callback)
                else:
                    callback(TrombiErrorResponse(
                            trombi.errors.NOT_FOUND,
                            'Database not found: %s' % name
                            ))
            else:
                callback(_error_response(response))

        self._fetch(
            '%s/%s' % (self.baseurl, name),
            _really_callback,
            )

    def delete(self, name, callback):
        def _really_callback(response):
            if response.code == 200:
                callback(TrombiObject())
            elif response.code == 404:
                callback(
                    TrombiErrorResponse(
                        trombi.errors.NOT_FOUND,
                        'Database does not exist: %r' % name
                        ))
            else:
                callback(_error_response(response))

        self._fetch(
            '%s/%s' % (self.baseurl, name),
            _really_callback,
            method='DELETE',
            )

    def list(self, callback):
        def _really_callback(response):
            if response.code == 200:
                body = response.body.decode('utf-8')
                callback(Database(self, x) for x in json.loads(body))
            else:
                callback(_error_response(response))

        self._fetch(
            '%s/%s' % (self.baseurl, '_all_dbs'),
            _really_callback,
            )

    def add_user(self, name, password, callback, doc=None):
        userdb = Database(self, '_users')

        if not doc:
            doc = {}

        doc['type'] = 'user'
        if 'roles' not in doc:
            doc['roles'] = []

        doc['name'] = name
        doc['salt'] = str(uuid.uuid4())
        doc['password_sha'] = sha1(password + doc['salt']).hexdigest()

        if '_id' not in doc:
            doc['_id'] = 'org.couchdb.user:%s' % name

        userdb.set(doc, callback)

    def get_user(self, name, callback, attachments=False):
        userdb = Database(self, '_users')

        doc_id = name
        if not name.startswith('org.couchdb.user:'):
            doc_id = 'org.couchdb.user:%s' % name

        userdb.get(doc_id, callback, attachments=attachments)

    def update_user(self, user_doc, callback):
        userdb = Database(self, '_users')
        userdb.set(user_doc, callback)

    def update_user_password(self, username, password, callback):
        def _really_callback(user_doc):
            if user_doc.error:
                callback(user_doc)
            user_doc['password_sha'] = sha1(password + user_doc['salt']).hexdigest()
            self.update_user(user_doc, callback)

        self.get_user(username, _really_callback)

    def delete_user(self, user_doc, callback):
        userdb = Database(self, '_users')
        userdb.delete(user_doc, callback)

    def logout(self, callback):
        def _really_callback(response):
            if response.code == 200:
                self.session_cookie = None
                callback(TrombiResult(json.loads(response.body)))
            else:
                callback(_error_response(response))

        url = '%s/%s' % (self.baseurl, '_session')
        self._client.fetch(url, _really_callback, method='DELETE')

    def login(self, username, password, callback):
        def _really_callback(response):
            if response.code in (200, 302):
                self.session_cookie = response.headers['Set-Cookie']
                response_body = json.loads(response.body)
                callback(TrombiResult(response_body))
            else:
                callback(_error_response(response))

        body = urllib.urlencode({'name': username, 'password': password})
        url = '%s/%s' % (self.baseurl, '_session')

        self._client.fetch(url, _really_callback, method='POST', body=body)

    def session(self, callback):
        def _really_callback(response):
            if response.code == 200:
                body = json.loads(response.body)
                callback(TrombiResult(body))
            else:
                callback(_error_response(response))

        url = '%s/%s' % (self.baseurl, '_session')
        self._client.fetch(url, _really_callback)


class Database(TrombiObject):
    def __init__(self, server, name):
        self.server = server
        self._json_encoder = self.server._json_encoder
        self.name = name
        self.baseurl = '%s/%s' % (self.server.baseurl, self.name)

    def _fetch(self, url, *args, **kwargs):
        # Just a convenience wrapper
        if 'baseurl' in kwargs:
            url = '%s/%s' % (kwargs.pop('baseurl'), url)
        else:
            url = '%s/%s' % (self.baseurl, url)
        return self.server._fetch(url, *args, **kwargs)

    def info(self, callback):
        def _really_callback(response):
            if response.code == 200:
                body = response.body.decode('utf-8')
                callback(TrombiDict(json.loads(body)))
            else:
                callback(_error_response(response))

        self._fetch('', _really_callback)

    def set(self, *args, **kwargs):
        cb = kwargs.pop('callback', None)
        if cb:
            args += (cb,)
        if len(args) == 2:
            data, callback = args
            doc_id = None
        elif len(args) == 3:
            doc_id, data, callback = args
        else:
            raise TypeError(
                'Database.set takes at most 2 non-keyword arguments.')

        if kwargs:
            if list(kwargs.keys()) != ['attachments']:
                if len(kwargs) > 1:
                    raise TypeError(
                        '%s are invalid keyword arguments for this function') %(
                        (', '.join(kwargs.keys())))
                else:
                    raise TypeError(
                        '%s is invalid keyword argument for this function' % (
                            list(kwargs.keys())[0]))

            attachments = kwargs['attachments']
        else:
            attachments = {}

        if isinstance(data, Document):
            doc = data
        else:
            doc = Document(self, data)

        if doc_id is None and doc.id is not None and doc.rev is not None:
            # Update the existing document
            doc_id = doc.id

        if doc_id is not None:
            url = urlquote(doc_id, safe='')
            method = 'PUT'
        else:
            url = ''
            method = 'POST'

        for name, attachment in attachments.items():
            content_type, attachment_data = attachment
            if content_type is None:
                content_type = 'text/plain'
            doc.attachments[name] = {
                'content_type': content_type,
                'data': b64encode(attachment_data).decode('utf-8'),
                }

        def _really_callback(response):
            try:
                # If the connection to the server is malfunctioning,
                # ie. the simplehttpclient returns 599 and no body,
                # don't set the content as the response.code will not
                # be 201 at that point either
                if response.body is not None:
                    content = json.loads(response.body.decode('utf-8'))
            except ValueError:
                content = response.body

            if response.code == 201:
                doc.id = content['id']
                doc.rev = content['rev']
                callback(doc)
            else:
                callback(_error_response(response))

        self._fetch(
            url,
            _really_callback,
            method=method,
            body=json.dumps(doc.raw(), cls=self._json_encoder),
        )

    def get(self, doc_id, callback, attachments=False):
        def _really_callback(response):
            if response.code == 200:
                data = json.loads(response.body.decode('utf-8'))
                doc = Document(self, data)
                callback(doc)
            elif response.code == 404:
                # Document doesn't exist
                callback(None)
            else:
                callback(_error_response(response))

        doc_id = urlquote(doc_id, safe='')

        kwargs = {}

        if attachments is True:
            doc_id += '?attachments=true'
            kwargs['headers'] = HTTPHeaders(
                {'Content-Type': 'application/json',
                 'Accept': 'application/json',
             })

        self._fetch(
            doc_id,
            _really_callback,
            **kwargs
            )

    def get_attachment(self, doc_id, attachment_name, callback):
        def _really_callback(response):
            if response.code == 200:
                callback(response.body)
            elif response.code == 404:
                # Document or attachment doesn't exist
                callback(None)
            else:
                callback(_error_response(response))

        doc_id = urlquote(doc_id, safe='')
        attachment_name = urlquote(attachment_name, safe='')

        self._fetch(
            '%s/%s' % (doc_id, attachment_name),
            _really_callback,
            )

    def view(self, design_doc, viewname, callback, **kwargs):
        def _really_callback(response):
            if response.code == 200:
                body = response.body.decode('utf-8')
                callback(
                    ViewResult(json.loads(body), db=self)
                    )
            else:
                callback(_error_response(response))

        if not design_doc and viewname == '_all_docs':
            url = '_all_docs'
        else:
            url = '_design/%s/_view/%s' % (design_doc, viewname)

        # We need to pop keys before constructing the url to avoid it
        # ending up twice in the request, both in the body and as a
        # query parameter.
        keys = kwargs.pop('keys', None)

        if kwargs:
            url = '%s?%s' % (url, _jsonize_params(kwargs))

        if keys is not None:
            self._fetch(url, _really_callback,
                        method='POST',
                        body=json.dumps({'keys': keys})
                        )
        else:
            self._fetch(url, _really_callback)

    def list(self, design_doc, listname, viewname, callback, **kwargs):
        def _really_callback(response):
            if response.code == 200:
                callback(TrombiResult(response.body))
            else:
                callback(_error_response(response))

        url = '_design/%s/_list/%s/%s/' % (design_doc, listname, viewname)
        if kwargs:
            url = '%s?%s' % (url, _jsonize_params(kwargs))

        self._fetch(url, _really_callback)

    def temporary_view(self, callback, map_fun, reduce_fun=None,
                       language='javascript', **kwargs):
        def _really_callback(response):
            if response.code == 200:
                body = response.body.decode('utf-8')
                callback(
                    ViewResult(json.loads(body), db=self)
                    )
            else:
                callback(_error_response(response))

        url = '_temp_view'
        if kwargs:
            url = '%s?%s' % (url, _jsonize_params(kwargs))

        body = {'map': map_fun, 'language': language}
        if reduce_fun:
            body['reduce'] = reduce_fun

        self._fetch(url, _really_callback, method='POST',
                    body=json.dumps(body),
                    headers={'Content-Type': 'application/json'})

    def delete(self, data, callback):
        def _really_callback(response):
            try:
                json.loads(response.body.decode('utf-8'))
            except ValueError:
                callback(_error_response(response))
                return
            if response.code == 200:
                callback(self)
            else:
                callback(_error_response(response))

        if isinstance(data, Document):
            doc = data
        else:
            doc = Document(self, data)

        doc_id = urlquote(doc.id, safe='')
        self._fetch(
            '%s?rev=%s' % (doc_id, doc.rev),
            _really_callback,
            method='DELETE',
            )

    def bulk_docs(self, data, callback, all_or_nothing=False):
        def _really_callback(response):
            if response.code == 200 or response.code == 201:
                try:
                    content = json.loads(response.body.decode('utf-8'))
                except ValueError:
                    callback(TrombiErrorResponse(response.code, response.body))
                else:
                    callback(BulkResult(content))
            else:
                callback(_error_response(response))

        docs = []
        for element in data:
            if isinstance(element, Document):
                docs.append(element.raw())
            else:
                docs.append(element)

        payload = {'docs': docs}
        if all_or_nothing is True:
            payload['all_or_nothing'] = True

        self._fetch(
            '_bulk_docs',
            _really_callback,
            method='POST',
            body=json.dumps(payload),
            )

    def changes(self, callback, timeout=None, feed='normal', **kw):
        def _really_callback(response):
            log.debug('Changes feed response: %s', response)
            if response.code != 200:
                callback(_error_response(response))
                return
            if feed == 'continuous':
                # Feed terminated, call callback with None to indicate
                # this, if the mode is continous
                callback(None)
            else:
                body = response.body.decode('utf-8')
                callback(TrombiResult(json.loads(body)))

        stream_buffer = []

        def _stream(text):
            stream_buffer.append(text.decode('utf-8'))
            chunks = ''.join(stream_buffer).split('\n')

            # The last chunk is either an empty string or an
            # incomplete line. Save it for the next round. The [:]
            # syntax is used because of variable scoping.
            stream_buffer[:] = [chunks.pop()]

            for chunk in chunks:
                if not chunk.strip():
                    continue

                try:
                    obj = json.loads(chunk)
                except ValueError:
                    # JSON parsing failed. Apparently we have some
                    # gibberish on our hands, just discard it.
                    log.warning('Invalid changes feed line: %s' % chunk)
                    continue

                # "Escape" the streaming_callback context by invoking
                # the handler as an ioloop callback. This makes it
                # possible to start new HTTP requests in the handler
                # (it is impossible in the streaming_callback
                # context). Tornado runs these callbacks in the order
                # they were added, so this works correctly.
                #
                # This also relieves us from handling exceptions in
                # the handler.
                cb = functools.partial(callback, TrombiDict(obj))
                self.server.io_loop.add_callback(cb)

        couchdb_params = kw
        couchdb_params['feed'] = feed
        params = dict()
        if timeout is not None:
            # CouchDB takes timeouts in milliseconds
            couchdb_params['timeout'] = timeout * 1000
            params['request_timeout'] = timeout + 1
        url = '_changes?%s' % urlencode(couchdb_params)
        if feed == 'continuous':
            params['streaming_callback'] = _stream

        log.debug('Fetching changes from %s with params %s', url, params)
        self._fetch(url, _really_callback, **params)


class Document(collections.MutableMapping, TrombiObject):
    def __init__(self, db, data):
        self.db = db
        self.data = {}
        self.id = None
        self.rev = None
        self._postponed_attachments = False
        self.attachments = {}

        for key, value in data.items():
            if key.startswith('_'):
                setattr(self, key[1:], value)
            else:
                self[key] = value

    def __len__(self):
        return len(self.data)

    def __iter__(self):
        return iter(self.data)

    def __contains__(self, key):
        return key in self.data

    def __getitem__(self, key):
        return self.data[key]

    def __setitem__(self, key, value):
        if key.startswith('_'):
            raise KeyError("Keys starting with '_' are reserved for CouchDB")
        self.data[key] = value

    def __delitem__(self, key):
        del self.data[key]

    def raw(self):
        result = {}
        if self.id:
            result['_id'] = self.id
        if self.rev:
            result['_rev'] = self.rev
        if self.attachments:
            result['_attachments'] = self.attachments

        result.update(self.data)
        return result

    def copy(self, new_id, callback):
        assert self.rev and self.id

        def _copy_done(response):
            if response.code != 201:
                callback(_error_response(response))
                return

            content = json.loads(response.body.decode('utf-8'))
            doc = Document(self.db, self.data)
            doc.attachments = self.attachments.copy()
            doc.id = content['id']
            doc.rev = content['rev']
            callback(doc)

        self.db._fetch(
            '%s' % urlquote(self.id, safe=''),
            _copy_done,
            allow_nonstandard_methods=True,
            method='COPY',
            headers={'Destination': str(new_id)}
            )

    def attach(self, name, data, callback, type='text/plain'):
        def _really_callback(response):
            if  response.code != 201:
                callback(_error_response(response))
                return
            data = json.loads(response.body.decode('utf-8'))
            assert data['id'] == self.id
            self.rev = data['rev']
            self.attachments[name] = {
                'content_type': type,
                'length': len(data),
                'stub': True,
            }
            callback(self)

        headers = {'Content-Type': type, 'Expect': ''}

        self.db._fetch(
            '%s/%s?rev=%s' % (
                urlquote(self.id, safe=''),
                urlquote(name, safe=''),
                self.rev),
            _really_callback,
            method='PUT',
            body=data,
            headers=headers,
            )

    def load_attachment(self, name, callback):
        def _really_callback(response):
            if response.code == 200:
                callback(response.body)
            else:
                callback(_error_response(response))

        if (hasattr(self, 'attachments') and
            name in self.attachments and
            not self.attachments[name].get('stub', False)):
            data = self.attachments[name]['data'].encode('utf-8')
            callback(b64decode(data))
        else:
            self.db._fetch(
                '%s/%s' % (
                    urlquote(self.id, safe=''),
                    urlquote(name, safe='')
                    ),
                _really_callback,
                )

    def delete_attachment(self, name, callback):
        def _really_callback(response):
            if response.code != 200:
                callback(_error_response(response))
                return
            callback(self)

        self.db._fetch(
            '%s/%s?rev=%s' % (self.id, name, self.rev),
            _really_callback,
            method='DELETE',
            )


class BulkError(TrombiError):
    def __init__(self, data):
        self.error_type = data['error']
        self.reason = data.get('reason', None)
        self.raw = data


class BulkObject(TrombiObject, collections.Mapping):
    def __init__(self, data):
        self._data = data

    def __len__(self):
        return len(self._data)

    def __iter__(self):
        return iter(self._data)

    def __contains__(self, key):
        return key in self._data

    def __getitem__(self, key):
        return self._data[key]


class BulkResult(TrombiResult, collections.Sequence):
    def __init__(self, result):
        self.content = []
        for line in result:
            if 'error' in line:
                self.content.append(BulkError(line))
            else:
                self.content.append(BulkObject(line))

    def __len__(self):
        return len(self.content)

    def __iter__(self):
        return iter(self.content)

    def __getitem__(self, key):
        return self.content[key]


class ViewResult(TrombiObject, collections.Sequence):
    def __init__(self, result, db=None):
        self.db = db
        self.total_rows = result.get('total_rows', len(result['rows']))
        self._rows = result['rows']
        self.offset = result.get('offset', 0)

    def _format_row(self, row):
        if 'doc' in row and row['doc']:
            row['doc'] = Document(self.db, row['doc'])
        return row

    def __len__(self):
        return len(self._rows)

    def __iter__(self):
        return (self._format_row(x) for x in self._rows)

    def __getitem__(self, key):
        return self._format_row(self._rows[key])


class Paginator(TrombiObject):
    """
    Provides pseudo pagination of CouchDB documents calculated from
    the total_rows and offset of a CouchDB view as well as a user-
    defined page limit.
    """
    def __init__(self, db, limit=10):
        self._db = db
        self._limit = limit
        self.response = None
        self.count = 0
        self.start_index = 0
        self.end_index = 0
        self.num_pages = 0
        self.current_page = 0
        self.previous_page = 0
        self.next_page = 0
        self.rows = None
        self.has_next = False
        self.has_previous = False
        self.page_range = None
        self.start_doc_id = None
        self.end_doc_id = None

    def get_page(self, design_doc, viewname, callback,
            key=None, doc_id=None, forward=True, **kw):
        """
        On success, callback is called with this Paginator object as an
        argument that is fully populated with the page data requested.

        Use forward = True for paging forward, and forward = False for
        paging backwargs

        The combination of key/doc_id and forward is crucial.  When
        requesting to paginate forward the key/doc_id must be the built
        from the _last_ document on the current page you are moving forward
        from.  When paginating backwards, the key/doc_id must be built
        from the _first_ document on the current page.

        """
        def _really_callback(response):
            if response.error:
                # Send the received Database.view error to the callback
                callback(response)
                return

            if forward:
                offset = response.offset
            else:
                offset = response.total_rows - response.offset - self._limit

            self.response = response
            self.count = response.total_rows
            self.start_index = offset
            self.end_index = response.offset + self._limit - 1
            self.num_pages = (self.count / self._limit) + 1
            self.current_page = (offset / self._limit) + 1
            self.previous_page = self.current_page - 1
            self.next_page = self.current_page + 1
            self.rows = [row['value'] for row in response]
            if not forward:
                self.rows.reverse()
            self.has_next = (offset + self._limit) < self.count
            self.has_previous = (offset - self._limit) >= 0
            self.page_range = [p for p in xrange(1, self.num_pages+1)]
            try:
                self.start_doc_id = self.rows[0]['_id']
                self.end_doc_id = self.rows[-1]['_id']
            except (IndexError, KeyError):
                # empty set
                self.start_doc_id = None
                self.end_doc_id = None
            callback(self)

        kwargs = {'limit': self._limit,
                  'descending': True}
        kwargs.update(kw)

        if 'startkey' not in kwargs:
            kwargs['startkey'] = key

        if kwargs['startkey'] and forward and doc_id:
            kwargs['start_doc_id'] = doc_id
        elif kwargs['startkey'] and not forward:
            kwargs['start_doc_id'] = doc_id if doc_id else ''
            kwargs['descending'] = False if kwargs['descending'] else True
            kwargs['skip'] = 1

        self._db.view(design_doc, viewname, _really_callback, **kwargs)


VALID_DB_NAME = re.compile(r'^[a-z][a-z0-9_$()+-/]*$')

########NEW FILE########
__FILENAME__ = errors
# Copyright (c) 2011 Jyrki Pulliainen <jyrki@dywypi.org>
# Copyright (c) 2010 Inoi Oy
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Collection of possible couchdb errors
BAD_REQUEST = 400
CONFLICT = 409
PRECONDITION_FAILED = 412
NOT_FOUND = 404
SERVER_ERROR = 500

# Non-http errors (or overloaded http 500 errors)
INVALID_DATABASE_NAME = 51

errormap = {
    409: CONFLICT,
    412: PRECONDITION_FAILED,
    404: NOT_FOUND,
    500: SERVER_ERROR
    }

########NEW FILE########
