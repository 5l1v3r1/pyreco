__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# inspyred documentation build configuration file, created by
# sphinx-quickstart on Tue Jul 07 00:35:34 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.mathjax']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'inspyred'
copyright = u'2012, Inspired Intelligence Initiative'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'inspyreddoc'

#jsmath_path = 'jsMath/easy/load.js'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'inspyred.tex', u'inspyred Documentation',
   u'Aaron Garrett', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = moonshot
# Title:  Moon probe evolution example
# Author: Mike Vella

#start_imports
import os
import math
import pylab
import itertools
from matplotlib import pyplot as plt
from matplotlib.patches import Circle
from random import Random
from time import time
import inspyred
#end_imports

# All units are in SI unless stated otherwise.

# Global constants
#start_globals
G = 6.67300e-11 # Universal gravitational constant
earth_mass = 5.9742e24
earth_radius = 6.378e6
moon_mass = 7.36e22
moon_radius = 1.737e6
moon_position = (384403e3, 0)
earth_position = (0, 0)
#end_globals

def pairwise(iterable):
    """s -> (s0,s1), (s1,s2), (s2, s3), ..."""
    a, b = itertools.tee(iterable)
    next(b, None)
    return itertools.izip(a, b)
    
def distance_between(position_a, position_b):
    return math.sqrt((position_a[0] - position_b[0])**2 + (position_a[1] - position_b[1])**2)
    
def gravitational_force(position_a, mass_a, position_b, mass_b):
    """Returns the gravitational force between the two bodies a and b."""
    distance = distance_between(position_a, position_b)

    # Calculate the direction and magnitude of the force.
    angle = math.atan2(position_a[1] - position_b[1], position_a[0] - position_b[0])
    magnitude = G * mass_a * mass_b / (distance**2)

    # Find the x and y components of the force.
    # Determine sign based on which one is the larger body.
    sign = -1 if mass_b > mass_a else 1
    x_force = sign * magnitude * math.cos(angle)
    y_force = sign * magnitude * math.sin(angle)
    return x_force, y_force

def force_on_satellite(position, mass):
    """Returns the total gravitational force acting on the body from the Earth and Moon."""
    earth_grav_force = gravitational_force(position, mass, earth_position, earth_mass)
    moon_grav_force = gravitational_force(position, mass, moon_position, moon_mass)
    F_x = earth_grav_force[0] + moon_grav_force[0]
    F_y = earth_grav_force[1] + moon_grav_force[1]
    return F_x, F_y

def acceleration_of_satellite(position, mass):
    """Returns the acceleration based on all forces acting upon the body."""
    F_x, F_y = force_on_satellite(position, mass)
    return F_x / mass, F_y / mass

def moonshot(orbital_height, satellite_mass, boost_velocity, initial_y_velocity, 
             time_step=60, max_iterations=5e4, plot_trajectory=False):
    fitness = 0.0
    distance_from_earth_center = orbital_height + earth_radius
    eqb_velocity = math.sqrt(G * earth_mass / distance_from_earth_center)
    
    # Start the simulation.
    # Keep up with the positions of the satellite as it moves.
    position = [(earth_radius + orbital_height, 0.0)] # The initial position of the satellite.
    velocity = [0.0, initial_y_velocity]
    time = 0
    min_distance_from_moon = distance_between(position[-1], moon_position) - moon_radius

    i = 0 
    keep_simulating = True
    rockets_boosted = False

    while keep_simulating:
        # Calculate the acceleration and corresponding change in velocity.
        # (This is effectively the Forward Euler Algorithm.)
        acceleration = acceleration_of_satellite(position[-1], satellite_mass)
        velocity[0] += acceleration[0] * time_step
        velocity[1] += acceleration[1] * time_step 

        # Start the rocket burn:
        # add a boost in the +x direction of 1m/s
        # closest point to the moon
        if position[-1][1] < -100 and position[-1][0] > distance_from_earth_center-100 and not rockets_boosted: 
            launch_point = position[-1]
            velocity[0] += boost_velocity[0]
            velocity[1] += boost_velocity[1]
            rockets_boosted = True

        # Calculate the new position based on the velocity.
        position.append((position[-1][0] + velocity[0] * time_step, 
                         position[-1][1] + velocity[1] * time_step))
        time += time_step

        if i >= max_iterations:
            keep_simulating = False

        distance_from_moon_surface = distance_between(position[-1], moon_position) - moon_radius
        distance_from_earth_surface = distance_between(position[-1], earth_position) - earth_radius
        if distance_from_moon_surface < min_distance_from_moon:
            min_distance_from_moon = distance_from_moon_surface
            
        # See if the satellite crashes into the Moon or the Earth, or
        # if the satellite gets too far away (radio contact is lost).
        if distance_from_moon_surface <= 0:
            fitness += 100000 # penalty of 100,000 km if crash on moon
            keep_simulating = False
        elif distance_from_earth_surface <= 0:
            keep_simulating = False
            fitness -= 100000 # reward of 100,000 km if land on earth
        elif distance_from_earth_surface > 2 * distance_between(earth_position, moon_position): 
            keep_simulating = False #radio contact lost
        i += 1

    # Augment the fitness to include the minimum distance (in km) 
    # that the satellite made it to the Moon (lower without crashing is better).
    fitness += min_distance_from_moon / 1000.0 
    
    # Augment the fitness to include 1% of the total distance
    # traveled by the probe (in km). This means the probe
    # should prefer shorter paths.
    total_distance = 0
    for p, q in pairwise(position):
        total_distance += distance_between(p, q)
    fitness += total_distance / 1000.0 * 0.01

    if plot_trajectory:
        axes = plt.gca()
        earth = Circle(earth_position, earth_radius, facecolor='b', alpha=1)
        moon = Circle(moon_position, moon_radius, facecolor='0.5', alpha=1)
        axes.add_artist(earth)
        axes.add_artist(moon)
        axes.annotate('Earth', xy=earth_position,  xycoords='data',
                      xytext=(0, 1e2), textcoords='offset points',
                      arrowprops=dict(arrowstyle="->"))
        axes.annotate('Moon', xy=moon_position,  xycoords='data',
                      xytext=(0, 1e2), textcoords='offset points',
                      arrowprops=dict(arrowstyle="->"))
        x = [p[0] for p in position] 
        y = [p[1] for p in position]
        cm = pylab.get_cmap('gist_rainbow')
        lines = plt.scatter(x, y, c=range(len(x)), cmap=cm, marker='o', s=2)
        plt.setp(lines, edgecolors='None')  
        plt.axis("equal")
        plt.grid("on")
        projdir = os.path.dirname(os.getcwd())
        name = '{0}/{1}.pdf'.format(projdir, str(fitness))
        plt.savefig(name, format="pdf")
        plt.clf()
        
    return fitness


def satellite_generator(random, args):
    chromosome = []
    bounder = args["_ec"].bounder
    # The constraints are as follows:
    #             orbital   satellite   boost velocity      initial y
    #             height    mass        (x,       y)        velocity
    for lo, hi in zip(bounder.lower_bound, bounder.upper_bound):
        chromosome.append(random.uniform(lo, hi))
    return chromosome

def moonshot_evaluator(candidates, args):
    fitness=[]
    for chromosome in candidates:
        orbital_height = chromosome[0]
        satellite_mass = chromosome[1]
        boost_velocity = (chromosome[2], chromosome[3])
        initial_y_velocity = chromosome[4]
        fitness.append(moonshot(orbital_height, satellite_mass, boost_velocity, initial_y_velocity))
    return fitness
    
def custom_observer(population, num_generations, num_evaluations, args):
    best = max(population)
    print('Generations: {0}  Evaluations: {1}  Best: {2}'.format(num_generations, num_evaluations, str(best)))

   
#start_main   
rand = Random()
rand.seed(int(time()))
# The constraints are as follows:
#             orbital   satellite   boost velocity      initial y
#             height    mass        (x,       y)        velocity
constraints=((6e6,      10.0,       3e3,    -10000.0,   4000), 
             (8e6,      40.0,       9e3,     10000.0,   6000))

algorithm = inspyred.ec.EvolutionaryComputation(rand)
algorithm.terminator = inspyred.ec.terminators.evaluation_termination
algorithm.observer = inspyred.ec.observers.file_observer
algorithm.selector = inspyred.ec.selectors.tournament_selection
algorithm.replacer = inspyred.ec.replacers.generational_replacement
algorithm.variator = [inspyred.ec.variators.blend_crossover, inspyred.ec.variators.gaussian_mutation]
projdir = os.path.dirname(os.getcwd())

stat_file_name = '{0}/moonshot_ec_statistics.csv'.format(projdir)
ind_file_name = '{0}/moonshot_ec_individuals.csv'.format(projdir)
stat_file = open(stat_file_name, 'w')
ind_file = open(ind_file_name, 'w')
final_pop = algorithm.evolve(generator=satellite_generator,
                             evaluator=moonshot_evaluator,
                             pop_size=100,
                             maximize=False,
                             bounder=inspyred.ec.Bounder(constraints[0], constraints[1]),
                             num_selected=100,
                             tournament_size=2,
                             num_elites=1,
                             mutation_rate=0.3,
                             max_evaluations=600,
                             statistics_file=stat_file,
                             individuals_file=ind_file)

stat_file.close()
ind_file.close()

# Sort and print the fittest individual, who will be at index 0.
final_pop.sort(reverse=True)
best = final_pop[0]
components = best.candidate
print('\nFittest individual:')
print(best)
moonshot(components[0], components[1], (components[2], components[3]), components[4], plot_trajectory=True)
#end_main

########NEW FILE########
__FILENAME__ = polyarea
#start_imports
from random import Random
from time import time
from time import sleep
import inspyred
from Tkinter import *
import itertools
#end_imports


def area(p):
    return 0.5 * abs(sum([x0*y1 - x1*y0 for ((x0, y0), (x1, y1)) in segments(p)]))

def segments(p):
    return zip(p, p[1:] + [p[0]])

def generate_polygon(random, args):
    size = args.get('num_vertices', 6)
    return [(random.uniform(-1, 1), random.uniform(-1, 1)) for i in range(size)]

def evaluate_polygon(candidates, args):
    fitness = []
    for cs in candidates:
        fit = area(cs)
        fitness.append(fit)
    return fitness

#start_bounder    
def bound_polygon(candidate, args):
    for i, c in enumerate(candidate):
        x = max(min(c[0], 1), -1)
        y = max(min(c[1], 1), -1)
        candidate[i] = (x, y)
    return candidate
bound_polygon.lower_bound = itertools.repeat(-1)
bound_polygon.upper_bound = itertools.repeat(1)
#end_bounder
    
def mutate_polygon(random, candidates, args):
    mut_rate = args.setdefault('mutation_rate', 0.1)
    bounder = args['_ec'].bounder
    for i, cs in enumerate(candidates):
        for j, (c, lo, hi) in enumerate(zip(cs, bounder.lower_bound, bounder.upper_bound)):
            if random.random() < mut_rate:
                x = c[0] + random.gauss(0, 1) * (hi - lo)
                y = c[1] + random.gauss(0, 1) * (hi - lo)
                candidates[i][j] = (x, y)
        candidates[i] = bounder(candidates[i], args)
    return candidates
        
def polygon_observer(population, num_generations, num_evaluations, args):
    try:
        canvas = args['canvas']
    except KeyError:
        canvas = Canvas(Tk(), bg='white', height=400, width=400)
        args['canvas'] = canvas
        
    # Get the best polygon in the population.
    poly = population[0].candidate
    coords = [(100*x + 200, -100*y + 200) for (x, y) in poly]
    old_polys = canvas.find_withtag('poly')
    for p in old_polys:
        canvas.delete(p)
    old_rects = canvas.find_withtag('rect')
    for r in old_rects:
        canvas.delete(r)
    old_verts = canvas.find_withtag('vert')
    for v in old_verts:
        canvas.delete(v)
        
    canvas.create_rectangle(100, 100, 300, 300, fill='', outline='yellow', width=6, tags='rect')
    canvas.create_polygon(coords, fill='', outline='black', width=2, tags='poly')
    vert_radius = 3
    for (x, y) in coords:
        canvas.create_oval(x-vert_radius, y-vert_radius, x+vert_radius, y+vert_radius, fill='blue', tags='vert')
    canvas.pack()
    canvas.update()
    print('{0} evaluations'.format(num_evaluations))
    sleep(0.05)

#start_main
rand = Random()
rand.seed(int(time()))
my_ec = inspyred.ec.EvolutionaryComputation(rand)
my_ec.selector = inspyred.ec.selectors.tournament_selection
my_ec.variator = [inspyred.ec.variators.uniform_crossover, mutate_polygon]
my_ec.replacer = inspyred.ec.replacers.steady_state_replacement
my_ec.observer = polygon_observer
my_ec.terminator = [inspyred.ec.terminators.evaluation_termination, inspyred.ec.terminators.average_fitness_termination]
window = Tk()
window.title('Evolving Polygons')
can = Canvas(window, bg='white', height=400, width=400)
can.pack()

final_pop = my_ec.evolve(generator=generate_polygon,
                         evaluator=evaluate_polygon,
                         pop_size=100,
                         bounder=bound_polygon,
                         max_evaluations=5000,
                         num_selected=2,
                         mutation_rate=0.25,
                         num_vertices=3,
                         canvas=can)
# Sort and print the best individual, who will be at index 0.
final_pop.sort(reverse=True)
print('Terminated due to {0}.'.format(my_ec.termination_cause))
print(final_pop[0])
sleep(5)
#end_main

########NEW FILE########
__FILENAME__ = rastrigin
#start_imports
from random import Random
from time import time
from math import cos
from math import pi
from inspyred import ec
from inspyred.ec import terminators
#end_imports


def generate_rastrigin(random, args):
    size = args.get('num_inputs', 10)
    return [random.uniform(-5.12, 5.12) for i in range(size)]

def evaluate_rastrigin(candidates, args):
    fitness = []
    for cs in candidates:
        fit = 10 * len(cs) + sum([((x - 1)**2 - 10 * cos(2 * pi * (x - 1))) for x in cs])
        fitness.append(fit)
    return fitness

#start_main
rand = Random()
rand.seed(int(time()))
es = ec.ES(rand)
es.terminator = terminators.evaluation_termination
final_pop = es.evolve(generator=generate_rastrigin,
                      evaluator=evaluate_rastrigin,
                      pop_size=100,
                      maximize=False,
                      bounder=ec.Bounder(-5.12, 5.12),
                      max_evaluations=20000,
                      mutation_rate=0.25,
                      num_inputs=3)
# Sort and print the best individual, who will be at index 0.
final_pop.sort(reverse=True)
print(final_pop[0])
#end_main

########NEW FILE########
__FILENAME__ = knapsack_acs_example
from random import Random
from time import time
import math
import inspyred


def main(prng=None, display=False):    
    if prng is None:
        prng = Random()
        prng.seed(time()) 

    items = [(7,369), (10,346), (11,322), (10,347), (12,348), (13,383), 
             (8,347), (11,364), (8,340), (8,324), (13,365), (12,314), 
             (13,306), (13,394), (7,326), (11,310), (9,400), (13,339), 
             (5,381), (14,353), (6,383), (9,317), (6,349), (11,396), 
             (14,353), (9,322), (5,329), (5,386), (5,382), (4,369), 
             (6,304), (10,392), (8,390), (8,307), (10,318), (13,359), 
             (9,378), (8,376), (11,330), (9,331)]

    problem = inspyred.benchmarks.Knapsack(15, items, duplicates=False)
    ac = inspyred.swarm.ACS(prng, problem.components)
    ac.terminator = inspyred.ec.terminators.generation_termination
    final_pop = ac.evolve(problem.constructor, problem.evaluator, 
                          maximize=problem.maximize, pop_size=50, 
                          max_generations=50)

    if display:
        best = max(ac.archive)
        print('Best Solution: {0}: {1}'.format(str(best.candidate), 
                                               best.fitness))
    return ac
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = knapsack_ec_example
from random import Random
from time import time
import inspyred


def main(prng=None, display=False):    
    if prng is None:
        prng = Random()
        prng.seed(time()) 
        
    items = [(7,369), (10,346), (11,322), (10,347), (12,348), (13,383), 
             (8,347), (11,364), (8,340), (8,324), (13,365), (12,314), 
             (13,306), (13,394), (7,326), (11,310), (9,400), (13,339), 
             (5,381), (14,353), (6,383), (9,317), (6,349), (11,396), 
             (14,353), (9,322), (5,329), (5,386), (5,382), (4,369), 
             (6,304), (10,392), (8,390), (8,307), (10,318), (13,359), 
             (9,378), (8,376), (11,330), (9,331)]

    problem = inspyred.benchmarks.Knapsack(15, items, duplicates=True)
    ea = inspyred.ec.EvolutionaryComputation(prng)
    ea.selector = inspyred.ec.selectors.tournament_selection
    ea.variator = [inspyred.ec.variators.uniform_crossover, 
                   inspyred.ec.variators.gaussian_mutation]
    ea.replacer = inspyred.ec.replacers.steady_state_replacement
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          bounder=problem.bounder,
                          maximize=problem.maximize, 
                          pop_size=100, 
                          max_evaluations=2500,
                          tournament_size=5,
                          num_selected=2)
    
    if display:
        best = max(ea.population)
        print('Best Solution: {0}: {1}'.format(str(best.candidate), 
                                               best.fitness))
    return ea
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = logging_example
from random import Random
from time import time
import inspyred
import math

# Define an additional "necessary" function for the evaluator
# to see how it must be handled when using pp.
def my_squaring_function(x):
    return x**2

def generate_rastrigin(random, args):
    size = args.get('num_inputs', 10)
    return [random.uniform(-5.12, 5.12) for i in xrange(size)]

def evaluate_rastrigin(candidates, args):
    fitness = []
    for cs in candidates:
        fit = 10 * len(cs) + sum([(my_squaring_function(x - 1) - 
                                   10 * math.cos(2 * math.pi * (x - 1))) 
                                   for x in cs])
        fitness.append(fit)
    if any([f < 9.5 for f in fitness]):
        raise TypeError
    return fitness
    
def main(prng=None, display=False):    
    if prng is None:
        prng = Random()
        prng.seed(time()) 
        
    import logging
    logger = logging.getLogger('inspyred.ec')
    logger.setLevel(logging.DEBUG)
    file_handler = logging.FileHandler('inspyred.log', mode='w')
    file_handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    
    ea = inspyred.ec.DEA(prng)
    if display:
        ea.observer = inspyred.ec.observers.stats_observer 
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=generate_rastrigin, 
                          evaluator=inspyred.ec.evaluators.parallel_evaluation_pp,
                          pp_evaluator=evaluate_rastrigin, 
                          pp_dependencies=(my_squaring_function,),
                          pp_modules=("math",),
                          pop_size=8, 
                          bounder=inspyred.ec.Bounder(-5.12, 5.12),
                          maximize=False,
                          max_evaluations=256,
                          num_inputs=3)
    
    if display:
        best = max(final_pop) 
        print('Best Solution: \n{0}'.format(str(best)))
    return ea
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = niche_example
import random
import time
import math
import itertools
import inspyred

def my_distance(x, y):
    return sum([abs(a - b) for a, b in zip(x, y)])

def generate(random, args):
    return [random.uniform(0, 26)]
    
def evaluate(candidates, args):
    fitness = []
    for cand in candidates:
        fit = sum([math.sin(c) for c in cand])
        fitness.append(fit)
    return fitness

def main(prng=None, display=False):
    if prng is None:
        prng = random.Random()
        prng.seed(time.time()) 
    
    ea = inspyred.ec.EvolutionaryComputation(prng)
    ea.selector = inspyred.ec.selectors.tournament_selection
    ea.replacer = inspyred.ec.replacers.crowding_replacement
    ea.variator = inspyred.ec.variators.gaussian_mutation
    ea.terminator = inspyred.ec.terminators.evaluation_termination

    final_pop = ea.evolve(generate, evaluate, pop_size=30, 
                          bounder=inspyred.ec.Bounder(0, 26),
                          max_evaluations=10000,
                          num_selected=30,
                          mutation_rate=1.0,
                          crowding_distance=10,
                          distance_function=my_distance)
                          
    if display:
        import pylab
        x = []
        y = []
        for p in final_pop:
            x.append(p.candidate[0])
            y.append(math.sin(p.candidate[0]))
        t = [(i / 1000.0) * 26.0 for i in range(1000)]
        s = [math.sin(a) for a in t]
        pylab.plot(t, s, color='b')
        pylab.scatter(x, y, color='r')
        pylab.axis([0, 26, 0, 1.1])
        pylab.savefig('niche_example.pdf', format='pdf')
        pylab.show()
    return ea

if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = parallel_evaluation_mp_example
from random import Random
from time import time
import inspyred
import math

def generate_rastrigin(random, args):
    size = args.get('num_inputs', 10)
    return [random.uniform(-5.12, 5.12) for i in xrange(size)]

def evaluate_rastrigin(candidates, args):
    fitness = []
    for cs in candidates:
        fit = 10 * len(cs) + sum([((x - 1)**2 - 10 * 
                                   math.cos(2 * math.pi * (x - 1))) 
                                   for x in cs])
        fitness.append(fit)
    return fitness
    
def main(prng=None, display=False):    
    if prng is None:
        prng = Random()
        prng.seed(time()) 

    ea = inspyred.ec.DEA(prng)
    if display:
        ea.observer = inspyred.ec.observers.stats_observer 
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=generate_rastrigin, 
                          evaluator=inspyred.ec.evaluators.parallel_evaluation_mp,
                          mp_evaluator=evaluate_rastrigin, 
                          mp_nprocs=8,
                          pop_size=8, 
                          bounder=inspyred.ec.Bounder(-5.12, 5.12),
                          maximize=False,
                          max_evaluations=256,
                          num_inputs=3)
                          
    if display:
        best = max(final_pop) 
        print('Best Solution: \n{0}'.format(str(best)))
    return ea
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = parallel_evaluation_pp_example
from random import Random
from time import time
import inspyred
import math

# Define an additional "necessary" function for the evaluator
# to see how it must be handled when using pp.
def my_squaring_function(x):
    return x**2

def generate_rastrigin(random, args):
    size = args.get('num_inputs', 10)
    return [random.uniform(-5.12, 5.12) for i in xrange(size)]

def evaluate_rastrigin(candidates, args):
    fitness = []
    for cs in candidates:
        fit = 10 * len(cs) + sum([(my_squaring_function(x - 1) - 
                                   10 * math.cos(2 * math.pi * (x - 1))) 
                                   for x in cs])
        fitness.append(fit)
    return fitness
    
def main(prng=None, display=False):    
    if prng is None:
        prng = Random()
        prng.seed(time()) 
        
    ea = inspyred.ec.DEA(prng)
    if display:
        ea.observer = inspyred.ec.observers.stats_observer 
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=generate_rastrigin, 
                          evaluator=inspyred.ec.evaluators.parallel_evaluation_pp,
                          pp_evaluator=evaluate_rastrigin, 
                          pp_dependencies=(my_squaring_function,),
                          pp_modules=("math",),
                          pop_size=8, 
                          bounder=inspyred.ec.Bounder(-5.12, 5.12),
                          maximize=False,
                          max_evaluations=256,
                          num_inputs=3)
    
    if display:
        best = max(final_pop) 
        print('Best Solution: \n{0}'.format(str(best)))
    return ea
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = tsp_ec_example
from random import Random
from time import time
import math
import inspyred


def main(prng=None, display=False):    
    if prng is None:
        prng = Random()
        prng.seed(time()) 
        
    points = [(110.0, 225.0), (161.0, 280.0), (325.0, 554.0), (490.0, 285.0), 
              (157.0, 443.0), (283.0, 379.0), (397.0, 566.0), (306.0, 360.0), 
              (343.0, 110.0), (552.0, 199.0)]
    weights = [[0 for _ in range(len(points))] for _ in range(len(points))]
    for i, p in enumerate(points):
        for j, q in enumerate(points):
            weights[i][j] = math.sqrt((p[0] - q[0])**2 + (p[1] - q[1])**2)
              
    problem = inspyred.benchmarks.TSP(weights)
    ea = inspyred.ec.EvolutionaryComputation(prng)
    ea.selector = inspyred.ec.selectors.tournament_selection
    ea.variator = [inspyred.ec.variators.partially_matched_crossover, 
                   inspyred.ec.variators.inversion_mutation]
    ea.replacer = inspyred.ec.replacers.generational_replacement
    ea.terminator = inspyred.ec.terminators.generation_termination
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          bounder=problem.bounder,
                          maximize=problem.maximize, 
                          pop_size=100, 
                          max_generations=50,
                          tournament_size=5,
                          num_selected=100,
                          num_elites=1)
    
    if display:
        best = max(ea.population)
        print('Best Solution: {0}: {1}'.format(str(best.candidate), 1/best.fitness))
    return ea
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = custom_archiver_example
from random import Random
from time import time
import inspyred

def my_archiver(random, population, archive, args):
    worst_in_pop = min(population)
    if len(archive) > 0:
        worst_in_arc = min(archive)
        if worst_in_pop < worst_in_arc:
            return [worst_in_pop]
        else:
            return archive
    else:
        return [worst_in_pop]

if __name__ == '__main__':
    prng = Random()
    prng.seed(time()) 
    
    problem = inspyred.benchmarks.Rosenbrock(2)
    ea = inspyred.ec.ES(prng)
    ea.observer = [inspyred.ec.observers.stats_observer, 
                   inspyred.ec.observers.archive_observer]
    ea.archiver = my_archiver
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          pop_size=100, 
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          max_evaluations=30000)
    best = max(final_pop)
    print('Best Solution: \n{0}'.format(str(best)))
    print(ea.archive)

########NEW FILE########
__FILENAME__ = custom_ec_example
from random import Random
from time import time
import inspyred

def main(prng=None, display=False):
    if prng is None:
        prng = Random()
        prng.seed(time()) 
    
    problem = inspyred.benchmarks.Ackley(2)
    ea = inspyred.ec.EvolutionaryComputation(prng)
    ea.selector = inspyred.ec.selectors.tournament_selection
    ea.variator = [inspyred.ec.variators.uniform_crossover, 
                   inspyred.ec.variators.gaussian_mutation]
    ea.replacer = inspyred.ec.replacers.steady_state_replacement
    ea.terminator = inspyred.ec.terminators.generation_termination
    final_pop = ea.evolve(generator=problem.generator,
                          evaluator=problem.evaluator,
                          pop_size=100, 
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          tournament_size=7,
                          num_selected=2, 
                          max_generations=300,
                          mutation_rate=0.2)

    if display:
        best = max(final_pop) 
        print('Best Solution: \n{0}'.format(str(best)))
    return ea

if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = custom_observer_example
from random import Random
from time import time
import inspyred

def my_observer(population, num_generations, num_evaluations, args):
    best = max(population)
    print('{0:6} -- {1} : {2}'.format(num_generations, 
                                      best.fitness, 
                                      str(best.candidate)))

if __name__ == '__main__':
    prng = Random()
    prng.seed(time()) 
    
    problem = inspyred.benchmarks.Rastrigin(2)
    ea = inspyred.ec.ES(prng)
    ea.observer = my_observer
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          pop_size=100, 
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          max_evaluations=30000)
    best = max(final_pop)
    print('Best Solution: \n{0}'.format(str(best)))

########NEW FILE########
__FILENAME__ = custom_replacer_example
from random import Random
from time import time
import inspyred

def my_replacer(random, population, parents, offspring, args):
    psize = len(population)
    population.sort(reverse=True)
    survivors = population[:psize // 2]
    num_remaining = psize - len(survivors)
    for i in range(num_remaining):
        survivors.append(random.choice(offspring))
    return survivors

if __name__ == '__main__':
    prng = Random()
    prng.seed(time()) 
    
    problem = inspyred.benchmarks.Ackley(2)
    ea = inspyred.ec.ES(prng)
    ea.replacer = my_replacer
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          pop_size=100, 
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          max_evaluations=30000)
    best = max(final_pop)
    print('Best Solution: \n{0}'.format(str(best)))

########NEW FILE########
__FILENAME__ = custom_selector_example
from random import Random
from time import time
import inspyred

def my_selector(random, population, args):
    n = args.get('num_selected', 2)
    best = max(population)
    selected = []
    for i in range(n):
        if random.random() <= 0.5:
            selected.append(best)
        else:
            selected.append(random.choice(population))
    return selected

if __name__ == '__main__':
    prng = Random()
    prng.seed(time()) 
    
    problem = inspyred.benchmarks.Griewank(2)
    ea = inspyred.ec.DEA(prng)
    ea.selector = my_selector
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          pop_size=100, 
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          max_evaluations=30000)
                          
    best = max(final_pop)
    print('Best Solution: \n{0}'.format(str(best)))

########NEW FILE########
__FILENAME__ = custom_terminator_example
from random import Random
from time import time
import itertools
import inspyred

def my_terminator(population, num_generations, num_evaluations, args):
    min_ham_dist = args.get('minimum_hamming_distance', 30)
    ham_dist = []
    for x, y in itertools.combinations(population, 2):
        ham_dist.append(sum(a != b for a, b in zip(x.candidate, y.candidate)))
    avg_ham_dist = sum(ham_dist) / float(len(ham_dist))
    return avg_ham_dist <= min_ham_dist
        

if __name__ == '__main__':
    prng = Random()
    prng.seed(time()) 
    
    problem = inspyred.benchmarks.Binary(inspyred.benchmarks.Schwefel(2), 
                                         dimension_bits=30)
    ea = inspyred.ec.GA(prng)
    ea.terminator = my_terminator
    final_pop = ea.evolve(generator=problem.generator,
                          evaluator=problem.evaluator,
                          pop_size=10,
                          maximize=problem.maximize,
                          bounder=problem.bounder,
                          num_elites=1,
                          minimum_hamming_distance=12)
                          
    best = max(final_pop)
    print('Best Solution: \n{0}'.format(str(best)))

########NEW FILE########
__FILENAME__ = custom_variator_example
from random import Random
from time import time
import inspyred

# Note that we could have used the @inspyred.ec.variators.mutator
# decorator here and simplified our custom variator to 
#
#     def my_variator(random, candidate, args)
#
# where candidate is a single candidate. Such a function would
# just return the single mutant.
def my_variator(random, candidates, args):
    mutants = []
    for c in candidates:
        points = random.sample(range(len(c)), 2)
        x, y = min(points), max(points)
        if x == 0:
            mutants.append(c[y::-1] + c[y+1:])
        else:
            mutants.append(c[:x] + c[y:x-1:-1] + c[y+1:])
    return mutants

if __name__ == '__main__':
    prng = Random()
    prng.seed(time()) 
    
    problem = inspyred.benchmarks.Binary(inspyred.benchmarks.Schwefel(2), 
                                         dimension_bits=30)
    ea = inspyred.ec.GA(prng)
    ea.variator = my_variator
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=problem.generator,
                          evaluator=problem.evaluator,
                          pop_size=10,
                          maximize=problem.maximize,
                          bounder=problem.bounder,
                          num_elites=1,
                          max_evaluations=20000)
                          
    best = max(final_pop)
    print('Best Solution: \n{0}'.format(str(best)))

########NEW FILE########
__FILENAME__ = acs_example
from random import Random
from time import time
import math
import inspyred

def main(prng=None, display=False):    
    if prng is None:
        prng = Random()
        prng.seed(time()) 
        
    points = [(110.0, 225.0), (161.0, 280.0), (325.0, 554.0), (490.0, 285.0), 
              (157.0, 443.0), (283.0, 379.0), (397.0, 566.0), (306.0, 360.0), 
              (343.0, 110.0), (552.0, 199.0)]
    weights = [[0 for _ in range(len(points))] for _ in range(len(points))]
    for i, p in enumerate(points):
        for j, q in enumerate(points):
            weights[i][j] = math.sqrt((p[0] - q[0])**2 + (p[1] - q[1])**2)
              
    problem = inspyred.benchmarks.TSP(weights)
    ac = inspyred.swarm.ACS(prng, problem.components)
    ac.terminator = inspyred.ec.terminators.generation_termination
    final_pop = ac.evolve(generator=problem.constructor, 
                          evaluator=problem.evaluator, 
                          bounder=problem.bounder,
                          maximize=problem.maximize, 
                          pop_size=10, 
                          max_generations=50)
    
    if display:
        best = max(ac.archive)
        print('Best Solution:')
        for b in best.candidate:
            print(points[b.element[0]])
        print(points[best.candidate[-1].element[1]])
        print('Distance: {0}'.format(1/best.fitness))
    return ac
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = dea_example
from random import Random
from time import time
import inspyred

def main(prng=None, display=False):
    if prng is None:
        prng = Random()
        prng.seed(time()) 
    
    problem = inspyred.benchmarks.Griewank(2)
    ea = inspyred.ec.DEA(prng)
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          pop_size=100, 
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          max_evaluations=30000)
                          
    if display:
        best = max(final_pop)
        print('Best Solution: \n{0}'.format(str(best)))
    return ea

if __name__ == '__main__':
    main(display=True)        

########NEW FILE########
__FILENAME__ = eda_example
from random import Random
from time import time
import inspyred

def main(prng=None, display=False):
    if prng is None:
        prng = Random()
        prng.seed(time()) 
    
    problem = inspyred.benchmarks.Rastrigin(2)
    ea = inspyred.ec.EDA(prng)
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(evaluator=problem.evaluator, 
                          generator=problem.generator, 
                          pop_size=1000, 
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          max_evaluations=30000,
                          num_selected=500,
                          num_offspring=1000,
                          num_elites=1)
    
    if display:
        best = max(final_pop) 
        print('Best Solution: \n{0}'.format(str(best)))
    return ea
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = es_example
from random import Random
from time import time
import inspyred

def main(prng=None, display=False):    
    if prng is None:
        prng = Random()
        prng.seed(time()) 
        
    problem = inspyred.benchmarks.Rosenbrock(2)
    ea = inspyred.ec.ES(prng)
    ea.terminator = [inspyred.ec.terminators.evaluation_termination, 
                     inspyred.ec.terminators.diversity_termination]
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          pop_size=100, 
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          max_evaluations=30000)

    if display:
        best = max(final_pop)
        print('Best Solution: \n{0}'.format(str(best)))
    return ea
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = ga_example
from random import Random
from time import time
import inspyred

def main(prng=None, display=False): 
    if prng is None:
        prng = Random()
        prng.seed(time()) 
    
    problem = inspyred.benchmarks.Binary(inspyred.benchmarks.Schwefel(2), 
                                         dimension_bits=30)
    ea = inspyred.ec.GA(prng)
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=problem.generator,
                          evaluator=problem.evaluator,
                          pop_size=100,
                          maximize=problem.maximize,
                          bounder=problem.bounder,
                          max_evaluations=30000, 
                          num_elites=1)
                          
    if display:
        best = max(final_pop)
        print('Best Solution: \n{0}'.format(str(best)))
    return ea
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = nsga_example
from random import Random
from time import time
import inspyred
   
def main(prng=None, display=False):
    if prng is None:
        prng = Random()
        prng.seed(time()) 

    problem = inspyred.benchmarks.Kursawe(3)
    ea = inspyred.ec.emo.NSGA2(prng)
    ea.variator = [inspyred.ec.variators.blend_crossover, 
                   inspyred.ec.variators.gaussian_mutation]
    ea.terminator = inspyred.ec.terminators.generation_termination
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          pop_size=100,
                          maximize=problem.maximize,
                          bounder=problem.bounder,
                          max_generations=80)
    
    if display:
        final_arc = ea.archive
        print('Best Solutions: \n')
        for f in final_arc:
            print(f)
        import pylab
        x = []
        y = []
        for f in final_arc:
            x.append(f.fitness[0])
            y.append(f.fitness[1])
        pylab.scatter(x, y, color='b')
        pylab.savefig('{0} Example ({1}).pdf'.format(ea.__class__.__name__, 
                                                     problem.__class__.__name__), 
                      format='pdf')
        pylab.show()
    return ea
        
if __name__ == '__main__':
    main(display=True)    

########NEW FILE########
__FILENAME__ = paes_example
from random import Random
from time import time
import inspyred

def main(prng=None, display=False):
    if prng is None:
        prng = Random()
        prng.seed(time()) 
        
    problem = inspyred.benchmarks.Kursawe(3)
    ea = inspyred.ec.emo.PAES(prng)
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(generator=problem.generator, 
                          evaluator=problem.evaluator, 
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          max_evaluations=10000,
                          max_archive_size=100,
                          num_grid_divisions=4)
    
    if display:
        final_arc = ea.archive
        print('Best Solutions: \n')
        for f in final_arc:
            print(f)
        import pylab
        x = []
        y = []
        for f in final_arc:
            x.append(f.fitness[0])
            y.append(f.fitness[1])
        pylab.scatter(x, y, color='b')
        pylab.savefig('{0} Example ({1}).pdf'.format(ea.__class__.__name__, 
                                                     problem.__class__.__name__), 
                      format='pdf')
        pylab.show()
    return ea

if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = pso_example
from time import time
from random import Random
import inspyred

def main(prng=None, display=False):
    if prng is None:
        prng = Random()
        prng.seed(time()) 
    
    problem = inspyred.benchmarks.Ackley(2)
    ea = inspyred.swarm.PSO(prng)
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    ea.topology = inspyred.swarm.topologies.ring_topology
    final_pop = ea.evolve(generator=problem.generator,
                          evaluator=problem.evaluator, 
                          pop_size=100,
                          bounder=problem.bounder,
                          maximize=problem.maximize,
                          max_evaluations=30000, 
                          neighborhood_size=5)

    if display:
        best = max(final_pop) 
        print('Best Solution: \n{0}'.format(str(best)))
    return ea

if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = sa_example
from random import Random
from time import time
import inspyred

def main(prng=None, display=False):    
    if prng is None:
        prng = Random()
        prng.seed(time()) 
        
    problem = inspyred.benchmarks.Sphere(2)
    ea = inspyred.ec.SA(prng)
    ea.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = ea.evolve(evaluator=problem.evaluator, 
                          generator=problem.generator, 
                          maximize=problem.maximize,
                          bounder=problem.bounder,
                          max_evaluations=30000)
                          
    if display:
        best = max(final_pop)
        print('Best Solution: \n{0}'.format(str(best)))
    return ea
            
if __name__ == '__main__':
    main(display=True)

########NEW FILE########
__FILENAME__ = benchmarks
"""
    =====================================================
    :mod:`benchmarks` -- Benchmark optimization functions
    =====================================================
    
    This module provides a set of benchmark problems for global optimization.

    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: benchmarks
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import copy
from inspyred import ec
from inspyred.ec import emo
from inspyred.ec import selectors
from inspyred import swarm
import itertools
import math
import random


class Benchmark(object):
    """Defines a global optimization benchmark problem.
    
    This abstract class defines the basic structure of a global
    optimization problem. Subclasses should implement the ``generator`` 
    and ``evaluator`` methods for a particular optimization problem, 
    which can be used with inspyred's evolutionary computations. 
    
    In addition to being used with evolutionary computations, subclasses
    of this class are also callable. The arguments passed to such a call 
    are combined into a list and passed as the single candidate to the 
    evaluator method. The single calculated fitness is returned. What
    this means is that a given benchmark can act as a mathematical function
    that takes arguments and returns the value of the function, like the
    following example.::
    
        my_function = benchmarks.Ackley(2)
        output = my_function(-1.5, 4.2)
    
    Public Attributes:
    
    - *dimensions* -- the number of inputs to the problem
    - *objectives* -- the number of outputs of the problem (default 1)
    - *bounder* -- the bounding function for the problem (default None)
    - *maximize* -- whether the problem is one of maximization (default 
      True)
    
    """
    def __init__(self, dimensions, objectives=1):
        self.dimensions = dimensions
        self.objectives = objectives
        self.bounder = None
        self.maximize = True
        
    def __str__(self):
        if self.objectives > 1:
            return '{0} ({1} dimensions, {2} objectives)'.format(self.__class__.__name__, self.dimensions, self.objectives)
        else:
            return '{0} ({1} dimensions)'.format(self.__class__.__name__, self.dimensions)
        
    def __repr__(self):
        return self.__class__.__name__
    
    def generator(self, random, args):
        """The generator function for the benchmark problem."""
        raise NotImplementedError
        
    def evaluator(self, candidates, args):
        """The evaluator function for the benchmark problem."""
        raise NotImplementedError
        
    def __call__(self, *args, **kwargs):
        candidate = [a for a in args]
        fit = self.evaluator([candidate], kwargs)
        return fit[0]

class Binary(Benchmark):
    """Defines a binary problem based on an existing benchmark problem.
    
    This class can be used to modify an existing benchmark problem to
    allow it to use a binary representation. The generator creates
    a list of binary values of size `dimensions`-by-`dimension_bits`.
    The evaluator accepts a candidate represented by such a binary list
    and transforms that candidate into a real-valued list as follows:
    
    1. Each set of `dimension_bits` bits is converted to its positive
       integer representation. 
    2. Next, that integer value is divided by the maximum integer that 
       can be represented by `dimension_bits` bits to produce a real 
       number in the range [0, 1]. 
    3. That real number is then scaled to the range [lower_bound, 
       upper_bound] for that dimension (which should be defined by 
       the bounder).
    
    Public Attributes:
    
    - *benchmark* -- the original benchmark problem
    - *dimension_bits* -- the number of bits to use to represent each dimension
    - *bounder* -- a bounder that restricts elements of candidate solutions to 
      the range [0, 1]
    - *maximize* -- whether the underlying benchmark problem is one of maximization
    
    """
    def __init__(self, benchmark, dimension_bits):
        Benchmark.__init__(self, benchmark.dimensions, benchmark.objectives)
        self.benchmark = benchmark
        self.dimension_bits = dimension_bits
        self.bounder = ec.DiscreteBounder([0, 1])
        self.maximize = self.benchmark.maximize
        self.__class__.__name__ = self.__class__.__name__ + ' ' + self.benchmark.__class__.__name__
        
    def _binary_to_real(self, binary):
        real = []
        for d, lo, hi in zip(range(self.dimensions), self.benchmark.bounder.lower_bound, self.benchmark.bounder.upper_bound):
            b = binary[d*self.dimension_bits:(d+1)*self.dimension_bits]
            real_val = float(int(''.join([str(i) for i in b]), 2))
            value = real_val / (2**(self.dimension_bits)-1) * (hi - lo) + lo
            real.append(value)
        return real
    
    def generator(self, random, args):
        return [random.choice([0, 1]) for _ in range(self.dimensions * self.dimension_bits)]
        
    def evaluator(self, candidates, args):
        real_candidates = []
        for c in candidates:
            real_candidates.append(self._binary_to_real(c))
        return self.benchmark.evaluator(real_candidates, args)

        
        
#-----------------------------------------------------------------------
#                     SINGLE-OBJECTIVE PROBLEMS
#-----------------------------------------------------------------------

class Ackley(Benchmark):
    """Defines the Ackley benchmark problem.
    
    This class defines the Ackley global optimization problem. This 
    is a multimodal minimization problem defined as follows:
    
    .. math::
    
        f(x) = -20e^{-0.2\sqrt{\\frac{1}{n} \sum_{i=1}^n x_i^2}} - e^{\\frac{1}{n} \sum_{i=1}^n \cos(2 \pi x_i)} + 20 + e
    
    Here, :math:`n` represents the number of dimensions and :math:`x_i \in [-32, 32]` for :math:`i=1,...,n`.
    
    .. figure:: _static/image6011.jpg
        :alt: Ackley function
        :align: center
        
        Two-dimensional Ackley function 
        (`image source <http://www-optima.amp.i.kyoto-u.ac.jp/member/student/hedar/Hedar_files/TestGO_files/Page295.htm>`__)
    
    Public Attributes:
    
    - *global_optimum* -- the problem input that produces the optimum output.
      Here, this corresponds to [0, 0, ..., 0].
    
    """
    def __init__(self, dimensions=2):
        Benchmark.__init__(self, dimensions)
        self.bounder = ec.Bounder([-32.0] * self.dimensions, [32.0] * self.dimensions)
        self.maximize = False
        self.global_optimum = [0 for _ in range(self.dimensions)]
    
    def generator(self, random, args):
        return [random.uniform(-32.0, 32.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        for c in candidates:
            fitness.append(-20 * math.exp(-0.2 * math.sqrt(1.0 / self.dimensions * sum([x**2 for x in c]))) - 
                           math.exp(1.0 / self.dimensions * sum([math.cos(2 * math.pi * x) for x in c])) + 20 + math.e)
        return fitness

class Griewank(Benchmark):
    """Defines the Griewank benchmark problem.
    
    This class defines the Griewank global optimization problem. This 
    is a highly multimodal minimization problem with numerous, wide-spread, 
    regularly distributed local minima. It is defined as follows:
    
    .. math::
    
        f(x) = \\frac{1}{4000} \sum_{i=1}^n x_i^2 - \prod_{i=1}^n \cos(\\frac{x_i}{\sqrt{i}}) + 1
    
    Here, :math:`n` represents the number of dimensions and :math:`x_i \in [-600, 600]` for :math:`i=1,...,n`.
    
    .. figure:: _static/image8891.jpg
        :alt: Griewank function
        :align: center
        
        Two-dimensional Griewank function 
        (`image source <http://www-optima.amp.i.kyoto-u.ac.jp/member/student/hedar/Hedar_files/TestGO_files/Page1905.htm>`__)
    
    Public Attributes:
    
    - *global_optimum* -- the problem input that produces the optimum output.
      Here, this corresponds to [0, 0, ..., 0].
    
    """
    def __init__(self, dimensions=2):
        Benchmark.__init__(self, dimensions)
        self.bounder = ec.Bounder([-600.0] * self.dimensions, [600.0] * self.dimensions)
        self.maximize = False
        self.global_optimum = [0 for _ in range(self.dimensions)]
        
    def generator(self, random, args):
        return [random.uniform(-600.0, 600.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        for c in candidates:
            prod = 1
            for i, x in enumerate(c):
                prod *= math.cos(x / math.sqrt(i+1))
            fitness.append(1.0 / 4000.0 * sum([x**2 for x in c]) - prod + 1)
        return fitness

class Rastrigin(Benchmark):
    """Defines the Rastrigin benchmark problem.
    
    This class defines the Rastrigin global optimization problem. This 
    is a highly multimodal minimization problem where the local minima
    are regularly distributed. It is defined as follows:
    
    .. math::
    
        f(x) = \sum_{i=1}^n (x_i^2 - 10\cos(2\pi x_i) + 10)
    
    Here, :math:`n` represents the number of dimensions and :math:`x_i \in [-5.12, 5.12]` for :math:`i=1,...,n`.
    
    .. figure:: _static/image12271.jpg
        :alt: Rastrigin function
        :align: center
        
        Two-dimensional Rastrigin function 
        (`image source <http://www-optima.amp.i.kyoto-u.ac.jp/member/student/hedar/Hedar_files/TestGO_files/Page2607.htm>`__)
    
    Public Attributes:
    
    - *global_optimum* -- the problem input that produces the optimum output.
      Here, this corresponds to [0, 0, ..., 0].
    
    """
    def __init__(self, dimensions=2):
        Benchmark.__init__(self, dimensions)
        self.bounder = ec.Bounder([-5.12] * self.dimensions, [5.12] * self.dimensions)
        self.maximize = False
        self.global_optimum = [0 for _ in range(self.dimensions)]
        
    def generator(self, random, args):
        return [random.uniform(-5.12, 5.12) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        for c in candidates:
            fitness.append(sum([x**2 - 10 * math.cos(2 * math.pi * x) + 10 for x in c]))
        return fitness

class Rosenbrock(Benchmark):
    """Defines the Rosenbrock benchmark problem.
    
    This class defines the Rosenbrock global optimization problem, 
    also known as the "banana function." The global optimum sits 
    within a narrow, parabolic-shaped flattened valley. It is 
    defined as follows:
    
    .. math::
    
        f(x) = \sum_{i=1}^{n-1} [100(x_i^2 - x_{i+1})^2 + (x_i - 1)^2]
    
    Here, :math:`n` represents the number of dimensions and :math:`x_i \in [-5, 10]` for :math:`i=1,...,n`.
    
    .. figure:: _static/image12371.jpg
        :alt: Rosenbrock function
        :align: center
        
        Two-dimensional Rosenbrock function 
        (`image source <http://www-optima.amp.i.kyoto-u.ac.jp/member/student/hedar/Hedar_files/TestGO_files/Page2537.htm>`__)
    
    Public Attributes:
    
    - *global_optimum* -- the problem input that produces the optimum output.
      Here, this corresponds to [1, 1, ..., 1].
    
    """
    def __init__(self, dimensions=2):
        Benchmark.__init__(self, dimensions)
        self.bounder = ec.Bounder([-5.0] * self.dimensions, [10.0] * self.dimensions)
        self.maximize = False
        self.global_optimum = [1 for _ in range(self.dimensions)]
    
    def generator(self, random, args):
        return [random.uniform(-5.0, 10.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        for c in candidates:
            total = 0
            for i in range(len(c) - 1):
                total += 100 * (c[i]**2 - c[i+1])**2 + (c[i] - 1)**2
            fitness.append(total)
        return fitness
    
class Schwefel(Benchmark):
    """Defines the Schwefel benchmark problem.
    
    This class defines the Schwefel global optimization problem. 
    It is defined as follows:
    
    .. math::
    
        f(x) = 418.9829n - \sum_{i=1}^n \\left[-x_i \sin(\sqrt{|x_i|})\\right]
    
    Here, :math:`n` represents the number of dimensions and :math:`x_i \in [-500, 500]` for :math:`i=1,...,n`.
    
    .. figure:: _static/image12721.jpg
        :alt: Schwefel function
        :align: center
        
        Two-dimensional Schwefel function 
        (`image source <http://www-optima.amp.i.kyoto-u.ac.jp/member/student/hedar/Hedar_files/TestGO_files/Page2530.htm>`__)
    
    Public Attributes:
    
    - *global_optimum* -- the problem input that produces the optimum output.
      Here, this corresponds to [420.9687, 420.9687, ..., 420.9687].
    
    """
    def __init__(self, dimensions=2):
        Benchmark.__init__(self, dimensions)
        self.bounder = ec.Bounder([-500.0] * self.dimensions, [500.0] * self.dimensions)
        self.maximize = False
        self.global_optimum = [420.9687 for _ in range(self.dimensions)]
    
    def generator(self, random, args):
        return [random.uniform(-500.0, 500.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        for c in candidates:
            fitness.append(418.9829 * self.dimensions - sum([x * math.sin(math.sqrt(abs(x))) for x in c]))
        return fitness
    
class Sphere(Benchmark):
    """Defines the Sphere benchmark problem.
    
    This class defines the Sphere global optimization problem, also called
    the "first function of De Jong's" or "De Jong's F1." It is continuous,
    convex, and unimodal, and it is defined as follows:
    
    .. math::
    
        f(x) = \sum_{i=1}^n x_i^2
    
    Here, :math:`n` represents the number of dimensions and :math:`x_i \in [-5.12, 5.12]` for :math:`i=1,...,n`.
    
    .. figure:: _static/image11981.jpg
        :alt: Sphere function
        :align: center
        
        Two-dimensional Sphere function 
        (`image source <http://www-optima.amp.i.kyoto-u.ac.jp/member/student/hedar/Hedar_files/TestGO_files/Page1113.htm>`__)
    
    Public Attributes:
    
    - *global_optimum* -- the problem input that produces the optimum output.
      Here, this corresponds to [0, 0, ..., 0].
    
    """
    def __init__(self, dimensions=2):
        Benchmark.__init__(self, dimensions)
        self.bounder = ec.Bounder([-5.12] * self.dimensions, [5.12] * self.dimensions)
        self.maximize = False
        self.global_optimum = [0 for _ in range(self.dimensions)]
    
    def generator(self, random, args):
        return [random.uniform(-5.12, 5.12) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        for c in candidates:
            fitness.append(sum([x**2 for x in c]))
        return fitness
    
        
#-----------------------------------------------------------------------
#                      MULTI-OBJECTIVE PROBLEMS
#-----------------------------------------------------------------------

class Kursawe(Benchmark):
    """Defines the Kursawe multiobjective benchmark problem.
    
    This class defines the Kursawe multiobjective minimization problem. 
    This function accepts an n-dimensional input and produces a 
    two-dimensional output. It is defined as follows:
    
    .. math::
    
        f_1(x) &= \sum_{i=1}^{n-1} \\left[-10e^{-0.2\sqrt{x_i^2 + x_{i+1}^2}}\\right] \\\\
        f_2(x) &= \sum_{i=1}^n \\left[|x_i|^{0.8} + 5\sin(x_i)^3\\right] \\\\
    
    Here, :math:`n` represents the number of dimensions and :math:`x_i \in [-5, 5]` for :math:`i=1,...,n`.
    
    .. figure:: _static/kursawefun.jpg
        :alt: Kursawe Pareto front
        :width: 700 px
        :align: center
        
        Three-dimensional Kursawe Pareto front 
        (`image source <http://delta.cs.cinvestav.mx/~ccoello/EMOO/testfuncs/>`__)
    
    """
    def __init__(self, dimensions=2):
        Benchmark.__init__(self, dimensions, 2)
        self.bounder = ec.Bounder([-5.0] * self.dimensions, [5.0] * self.dimensions)
        self.maximize = False

    def generator(self, random, args):
        return [random.uniform(-5.0, 5.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        for c in candidates:
            f1 = sum([-10 * math.exp(-0.2 * math.sqrt(c[i]**2 + c[i+1]**2)) for i in range(len(c) - 1)])
            f2 = sum([math.pow(abs(x), 0.8) + 5 * math.sin(x)**3 for x in c])
            fitness.append(emo.Pareto([f1, f2]))
        return fitness

class DTLZ1(Benchmark):
    """Defines the DTLZ1 multiobjective benchmark problem.
    
    This class defines the DTLZ1 multiobjective minimization problem
    taken from `(Deb et al., "Scalable Multi-Objective Optimization Test Problems."
    CEC 2002, pp. 825--830) <http://www.tik.ee.ethz.ch/sop/download/supplementary/testproblems/dtlz1/index.php>`__.
    This function accepts an n-dimensional input and produces an m-dimensional output.
    It is defined as follows:
    
    .. math::
    
        f_1(\\vec{x}) &= \\frac{1}{2} x_1 \\dots x_{m-1}(1 + g(\\vec{x_m})) \\\\
        f_i(\\vec{x}) &= \\frac{1}{2} x_1 \\dots x_{m-i}(1 + g(\\vec{x_m})) \\\\
        f_m(\\vec{x}) &= \\frac{1}{2} (1 - x_1)(1 + g(\\vec{x_m})) \\\\
        g(\\vec{x_m}) &= 100\\left[|\\vec{x_m}| + \sum_{x_i \in \\vec{x_m}}\\left((x_i - 0.5)^2 - \cos(20\pi(x_i - 0.5))\\right)\\right] \\\\
    
    Here, :math:`n` represents the number of dimensions, :math:`m` represents the
    number of objectives, :math:`x_i \in [0, 1]` for :math:`i=1,...,n`, and 
    :math:`\\vec{x_m} = x_m x_{m+1} \\dots x_{n}.`
    
    The recommendation given in the paper mentioned above is to provide 4 more
    dimensions than objectives. For instance, if we want to use 2 objectives, we
    should use 6 dimensions.
    
    .. figure:: _static/dtlz1funb.jpg
        :alt: DTLZ1 Pareto front
        :width: 700 px
        :align: center
        
        Three-dimensional DTLZ1 Pareto front 
        (`image source <http://delta.cs.cinvestav.mx/~ccoello/EMOO/testfuncs/>`__)
        
    """
    def __init__(self, dimensions=2, objectives=2):
        Benchmark.__init__(self, dimensions, objectives)
        if dimensions < objectives:
            raise ValueError('dimensions ({0}) must be greater than or equal to objectives ({1})'.format(dimensions, objectives))
        self.bounder = ec.Bounder([0.0] * self.dimensions, [1.0] * self.dimensions)
        self.maximize = False
        
    def global_optimum(self):
        """Return a globally optimal solution to this problem.
        
        This function returns a globally optimal solution (i.e., a 
        solution that lives on the Pareto front). Since there are many
        solutions that are Pareto-optimal, this function randomly 
        chooses one to return.
        
        """
        x = [random.uniform(0, 1) for _ in range(self.objectives - 1)]
        x.extend([0 for _ in range(self.dimensions - self.objectives + 1)])
        return x
    
    def generator(self, random, args):
        return [random.uniform(0.0, 1.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        g = lambda x: 100 * (len(x) + sum([(a - 0.5)**2 - math.cos(20 * math.pi * (a - 0.5)) for a in x]))
        for c in candidates:
            gval = g(c[self.objectives-1:])
            fit = [0.5 * reduce(lambda x,y: x*y, c[:self.objectives-1]) * (1 + gval)]
            for m in reversed(range(1, self.objectives)):
                fit.append(0.5 * reduce(lambda x,y: x*y, c[:m-1], 1) * (1 - c[m-1]) * (1 + gval))
            fitness.append(emo.Pareto(fit))
        return fitness

class DTLZ2(Benchmark):
    """Defines the DTLZ2 multiobjective benchmark problem.
    
    This class defines the DTLZ2 multiobjective minimization problem
    taken from `(Deb et al., "Scalable Multi-Objective Optimization Test Problems."
    CEC 2002, pp. 825--830) <http://www.tik.ee.ethz.ch/sop/download/supplementary/testproblems/dtlz1/index.php>`__.
    This function accepts an n-dimensional input and produces an m-dimensional output.
    It is defined as follows:
    
    .. math::
    
        f_1(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(x_1 \pi/2)\cos(x_2 \pi/2)\\dots\cos(x_{m-2} \pi/2)\cos(x_{m-1} \pi/2) \\\\
        f_i(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(x_1 \pi/2)\cos(x_2 \pi/2)\\dots\cos(x_{m-i} \pi/2)\sin(x_{m-i+1} \pi/2) \\\\
        f_m(\\vec{x}) &= (1 + g(\\vec{x_m}))\sin(x_1 \pi/2) \\\\
        g(\\vec{x_m}) &= \sum_{x_i \in \\vec{x_m}}(x_i - 0.5)^2 \\\\
    
    Here, :math:`n` represents the number of dimensions, :math:`m` represents the
    number of objectives, :math:`x_i \in [0, 1]` for :math:`i=1,...,n`, and 
    :math:`\\vec{x_m} = x_m x_{m+1} \\dots x_{n}.`
    
    The recommendation given in the paper mentioned above is to provide 9 more
    dimensions than objectives. For instance, if we want to use 2 objectives, we
    should use 11 dimensions.
    
    """
    def __init__(self, dimensions=2, objectives=2):
        Benchmark.__init__(self, dimensions, objectives)
        if dimensions < objectives:
            raise ValueError('dimensions ({0}) must be greater than or equal to objectives ({1})'.format(dimensions, objectives))
        self.bounder = ec.Bounder([0.0] * self.dimensions, [1.0] * self.dimensions)
        self.maximize = False
    
    def global_optimum(self):
        """Return a globally optimal solution to this problem.
        
        This function returns a globally optimal solution (i.e., a 
        solution that lives on the Pareto front). Since there are many
        solutions that are Pareto-optimal, this function randomly 
        chooses one to return.
        
        """
        x = [random.uniform(0, 1) for _ in range(self.objectives - 1)]
        x.extend([0.5 for _ in range(self.dimensions - self.objectives + 1)])
        return x
    
    def generator(self, random, args):
        return [random.uniform(0.0, 1.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        g = lambda x: sum([(a - 0.5)**2 for a in x])
        for c in candidates:
            gval = g(c[self.objectives-1:])
            fit = [(1 + gval) * 
                   reduce(lambda x,y: x*y, [math.cos(a * math.pi / 2.0) for a in c[:self.objectives-1]])]
            for m in reversed(range(1, self.objectives)):
                fit.append((1 + gval) * 
                           reduce(lambda x,y: x*y, [math.cos(a * math.pi / 2.0) for a in c[:m-1]], 1) *
                           math.sin(c[m-1] * math.pi / 2.0))
            fitness.append(emo.Pareto(fit))
        return fitness

class DTLZ3(Benchmark):
    """Defines the DTLZ3 multiobjective benchmark problem.
    
    This class defines the DTLZ3 multiobjective minimization problem
    taken from `(Deb et al., "Scalable Multi-Objective Optimization Test Problems."
    CEC 2002, pp. 825--830) <http://www.tik.ee.ethz.ch/sop/download/supplementary/testproblems/dtlz1/index.php>`__.
    This function accepts an n-dimensional input and produces an m-dimensional output.
    It is defined as follows:
    
    .. math::
    
        f_1(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(x_1 \pi/2)\cos(x_2 \pi/2)\\dots\cos(x_{m-2} \pi/2)\cos(x_{m-1} \pi/2) \\\\
        f_i(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(x_1 \pi/2)\cos(x_2 \pi/2)\\dots\cos(x_{m-i} \pi/2)\sin(x_{m-i+1} \pi/2) \\\\
        f_m(\\vec{x}) &= (1 + g(\\vec{x_m}))\sin(x_1 \pi/2) \\\\
        g(\\vec{x_m}) &= 100\\left[|\\vec{x_m}| + \sum_{x_i \in \\vec{x_m}}\\left((x_i - 0.5)^2 - \cos(20\pi(x_i - 0.5))\\right)\\right] \\\\
    
    Here, :math:`n` represents the number of dimensions, :math:`m` represents the
    number of objectives, :math:`x_i \in [0, 1]` for :math:`i=1,...,n`, and 
    :math:`\\vec{x_m} = x_m x_{m+1} \\dots x_{n}.`
    
    The recommendation given in the paper mentioned above is to provide 9 more
    dimensions than objectives. For instance, if we want to use 2 objectives, we
    should use 11 dimensions.
    
    """
    def __init__(self, dimensions=2, objectives=2):
        Benchmark.__init__(self, dimensions, objectives)
        if dimensions < objectives:
            raise ValueError('dimensions ({0}) must be greater than or equal to objectives ({1})'.format(dimensions, objectives))
        self.bounder = ec.Bounder([0.0] * self.dimensions, [1.0] * self.dimensions)
        self.maximize = False
    
    def global_optimum(self):
        """Return a globally optimal solution to this problem.
        
        This function returns a globally optimal solution (i.e., a 
        solution that lives on the Pareto front). Since there are many
        solutions that are Pareto-optimal, this function randomly 
        chooses one to return.
        
        """
        x = [random.uniform(0, 1) for _ in range(self.objectives - 1)]
        x.extend([0.5 for _ in range(self.dimensions - self.objectives + 1)])
        return x
        
    def generator(self, random, args):
        return [random.uniform(0.0, 1.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        g = lambda x: 100 * (len(x) + sum([(a - 0.5)**2 - math.cos(20 * math.pi * (a - 0.5)) for a in x]))
        for c in candidates:
            gval = g(c[self.objectives-1:])
            fit = [(1 + gval) * reduce(lambda x,y: x*y, [math.cos(a * math.pi / 2.0) for a in c[:self.objectives-1]])]
            for m in reversed(range(1, self.objectives)):
                fit.append((1 + gval) * 
                           reduce(lambda x,y: x*y, [math.cos(a * math.pi / 2.0) for a in c[:m-1]], 1) *
                           math.sin(c[m-1] * math.pi / 2.0))
            fitness.append(emo.Pareto(fit))
        return fitness

class DTLZ4(Benchmark):
    """Defines the DTLZ4 multiobjective benchmark problem.
    
    This class defines the DTLZ4 multiobjective minimization problem
    taken from `(Deb et al., "Scalable Multi-Objective Optimization Test Problems."
    CEC 2002, pp. 825--830) <http://www.tik.ee.ethz.ch/sop/download/supplementary/testproblems/dtlz1/index.php>`__.
    This function accepts an n-dimensional input and produces an m-dimensional output.
    It is defined as follows:
    
    .. math::
    
        f_1(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(x_1^\\alpha \pi/2)\cos(x_2^\\alpha \pi/2)\\dots\cos(x_{m-2}^\\alpha \pi/2)\cos(x_{m-1}^\\alpha \pi/2) \\\\
        f_i(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(x_1^\\alpha \pi/2)\cos(x_2^\\alpha \pi/2)\\dots\cos(x_{m-i}^\\alpha \pi/2)\sin(x_{m-i+1}^\\alpha \pi/2) \\\\
        f_m(\\vec{x}) &= (1 + g(\\vec{x_m}))\sin(x_1^\\alpha \pi/2) \\\\
        g(\\vec{x_m}) &= \sum_{x_i \in \\vec{x_m}}(x_i - 0.5)^2 \\\\
    
    Here, :math:`n` represents the number of dimensions, :math:`m` represents the
    number of objectives, :math:`x_i \in [0, 1]` for :math:`i=1,...,n`,  
    :math:`\\vec{x_m} = x_m x_{m+1} \\dots x_{n},` and :math:`\\alpha=100.`
    
    The recommendation given in the paper mentioned above is to provide 9 more
    dimensions than objectives. For instance, if we want to use 2 objectives, we
    should use 11 dimensions.
    
    """
    def __init__(self, dimensions=2, objectives=2, alpha=100):
        Benchmark.__init__(self, dimensions, objectives)
        if dimensions < objectives:
            raise ValueError('dimensions ({0}) must be greater than or equal to objectives ({1})'.format(dimensions, objectives))
        self.bounder = ec.Bounder([0.0] * self.dimensions, [1.0] * self.dimensions)
        self.maximize = False
        self.alpha = alpha
    
    def global_optimum(self):
        """Return a globally optimal solution to this problem.
        
        This function returns a globally optimal solution (i.e., a 
        solution that lives on the Pareto front). Since there are many
        solutions that are Pareto-optimal, this function randomly 
        chooses one to return.
        
        """
        x = [random.uniform(0, 1) for _ in range(self.objectives - 1)]
        x.extend([0.5 for _ in range(self.dimensions - self.objectives + 1)])
        return x
        
    def generator(self, random, args):
        return [random.uniform(0.0, 1.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        g = lambda x: sum([(a - 0.5)**2 for a in x])
        for c in candidates:
            gval = g(c[self.objectives-1:])
            fit = [(1 + gval) * 
                   reduce(lambda x,y: x*y, [math.cos(a**self.alpha * math.pi / 2.0) for a in c[:self.objectives-1]])]
            for m in reversed(range(1, self.objectives)):
                fit.append((1 + gval) * 
                           reduce(lambda x,y: x*y, [math.cos(a**self.alpha * math.pi / 2.0) for a in c[:m-1]], 1) *
                           math.sin(c[m-1]**self.alpha * math.pi / 2.0))
            fitness.append(emo.Pareto(fit))
        return fitness

class DTLZ5(Benchmark):
    """Defines the DTLZ5 multiobjective benchmark problem.
    
    This class defines the DTLZ5 multiobjective minimization problem
    taken from `(Deb et al., "Scalable Multi-Objective Optimization Test Problems."
    CEC 2002, pp. 825--830) <http://www.tik.ee.ethz.ch/sop/download/supplementary/testproblems/dtlz1/index.php>`__.
    This function accepts an n-dimensional input and produces an m-dimensional output.
    It is defined as follows:
    
    .. math::
    
        f_1(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(\\theta_1 \pi/2)\cos(\\theta_2 \pi/2)\\dots\cos(\\theta_{m-2} \pi/2)\cos(\\theta_{m-1} \pi/2) \\\\
        f_i(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(\\theta_1 \pi/2)\cos(\\theta_2 \pi/2)\\dots\cos(\\theta_{m-i} \pi/2)\sin(\\theta_{m-i+1} \pi/2) \\\\
        f_m(\\vec{x}) &= (1 + g(\\vec{x_m}))\sin(\\theta_1 \pi/2) \\\\
        \\theta_i     &= \\frac{\pi}{4(1+g(\\vec{x_m}))}(1 + 2g(\\vec{x_m}) x_i) \\\\
        g(\\vec{x_m}) &= \sum_{x_i \in \\vec{x_m}}(x_i - 0.5)^2 \\\\
    
    Here, :math:`n` represents the number of dimensions, :math:`m` represents the
    number of objectives, :math:`x_i \in [0, 1]` for :math:`i=1,...,n`, and 
    :math:`\\vec{x_m} = x_m x_{m+1} \\dots x_{n}.`
    
    The recommendation given in the paper mentioned above is to provide 9 more
    dimensions than objectives. For instance, if we want to use 2 objectives, we
    should use 11 dimensions.
    
    """
    def __init__(self, dimensions=2, objectives=2):
        Benchmark.__init__(self, dimensions, objectives)
        if dimensions < objectives:
            raise ValueError('dimensions ({0}) must be greater than or equal to objectives ({1})'.format(dimensions, objectives))
        self.bounder = ec.Bounder([0.0] * self.dimensions, [1.0] * self.dimensions)
        self.maximize = False
    
    def global_optimum(self):
        """Return a globally optimal solution to this problem.
        
        This function returns a globally optimal solution (i.e., a 
        solution that lives on the Pareto front). Since there are many
        solutions that are Pareto-optimal, this function randomly 
        chooses one to return.
        
        """
        x = [random.uniform(0, 1) for _ in range(self.objectives - 1)]
        x.extend([0.5 for _ in range(self.dimensions - self.objectives + 1)])
        return x
        
    def generator(self, random, args):
        return [random.uniform(0.0, 1.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        g = lambda x: sum([(a - 0.5)**2 for a in x])
        for c in candidates:
            gval = g(c[self.objectives-1:])
            theta = lambda x: math.pi / (4.0 * (1 + gval)) * (1 + 2 * gval * x)
            fit = [(1 + gval) * math.cos(math.pi / 2.0 * c[0]) *
                   reduce(lambda x,y: x*y, [math.cos(theta(a)) for a in c[1:self.objectives-1]])]
            for m in reversed(range(1, self.objectives)):
                if m == 1:
                    fit.append((1 + gval) * math.sin(math.pi / 2.0 * c[0]))
                else:
                    fit.append((1 + gval) * math.cos(math.pi / 2.0 * c[0]) *
                               reduce(lambda x,y: x*y, [math.cos(theta(a)) for a in c[1:m-1]], 1) *
                               math.sin(theta(c[m-1])))
            fitness.append(emo.Pareto(fit))
        return fitness

class DTLZ6(Benchmark):
    """Defines the DTLZ6 multiobjective benchmark problem.
    
    This class defines the DTLZ6 multiobjective minimization problem
    taken from `(Deb et al., "Scalable Multi-Objective Optimization Test Problems."
    CEC 2002, pp. 825--830) <http://www.tik.ee.ethz.ch/sop/download/supplementary/testproblems/dtlz1/index.php>`__.
    This function accepts an n-dimensional input and produces an m-dimensional output.
    It is defined as follows:
    
    .. math::
    
        f_1(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(\\theta_1 \pi/2)\cos(\\theta_2 \pi/2)\\dots\cos(\\theta_{m-2} \pi/2)\cos(\\theta_{m-1} \pi/2) \\\\
        f_i(\\vec{x}) &= (1 + g(\\vec{x_m}))\cos(\\theta_1 \pi/2)\cos(\\theta_2 \pi/2)\\dots\cos(\\theta_{m-i} \pi/2)\sin(\\theta_{m-i+1} \pi/2) \\\\
        f_m(\\vec{x}) &= (1 + g(\\vec{x_m}))\sin(\\theta_1 \pi/2) \\\\
        \\theta_i     &= \\frac{\pi}{4(1+g(\\vec{x_m}))}(1 + 2g(\\vec{x_m}) x_i) \\\\
        g(\\vec{x_m}) &= \sum_{x_i \in \\vec{x_m}}x_i^{0.1} \\\\
    
    Here, :math:`n` represents the number of dimensions, :math:`m` represents the
    number of objectives, :math:`x_i \in [0, 1]` for :math:`i=1,...,n`, and 
    :math:`\\vec{x_m} = x_m x_{m+1} \\dots x_{n}.`
    
    The recommendation given in the paper mentioned above is to provide 9 more
    dimensions than objectives. For instance, if we want to use 2 objectives, we
    should use 11 dimensions.
    
    """
    def __init__(self, dimensions=2, objectives=2):
        Benchmark.__init__(self, dimensions, objectives)
        if dimensions < objectives:
            raise ValueError('dimensions ({0}) must be greater than or equal to objectives ({1})'.format(dimensions, objectives))
        self.bounder = ec.Bounder([0.0] * self.dimensions, [1.0] * self.dimensions)
        self.maximize = False
    
    def global_optimum(self):
        """Return a globally optimal solution to this problem.
        
        This function returns a globally optimal solution (i.e., a 
        solution that lives on the Pareto front). Since there are many
        solutions that are Pareto-optimal, this function randomly 
        chooses one to return.
        
        """
        x = [random.uniform(0, 1) for _ in range(self.objectives - 1)]
        x.extend([0 for _ in range(self.dimensions - self.objectives + 1)])
        return x
        
    def generator(self, random, args):
        return [random.uniform(0.0, 1.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        g = lambda x: sum([a**0.1 for a in x])
        for c in candidates:
            gval = g(c[self.objectives-1:])
            theta = lambda x: math.pi / (4.0 * (1 + gval)) * (1 + 2 * gval * x)
            fit = [(1 + gval) * math.cos(math.pi / 2.0 * c[0]) *
                   reduce(lambda x,y: x*y, [math.cos(theta(a)) for a in c[1:self.objectives-1]])]
            for m in reversed(range(1, self.objectives)):
                if m == 1:
                    fit.append((1 + gval) * math.sin(math.pi / 2.0 * c[0]))
                else:
                    fit.append((1 + gval) * math.cos(math.pi / 2.0 * c[0]) *
                               reduce(lambda x,y: x*y, [math.cos(theta(a)) for a in c[1:m-1]], 1) *
                               math.sin(theta(c[m-1])))
            fitness.append(emo.Pareto(fit))
        return fitness

class DTLZ7(Benchmark):
    """Defines the DTLZ7 multiobjective benchmark problem.
    
    This class defines the DTLZ7 multiobjective minimization problem
    taken from `(Deb et al., "Scalable Multi-Objective Optimization Test Problems."
    CEC 2002, pp. 825--830) <http://www.tik.ee.ethz.ch/sop/download/supplementary/testproblems/dtlz1/index.php>`__.
    This function accepts an n-dimensional input and produces an m-dimensional output.
    It is defined as follows:
    
    .. math::
    
        f_1(\\vec{x}) &= x_1 \\\\
        f_i(\\vec{x}) &= x_i \\\\
        f_m(\\vec{x}) &= (1 + g(\\vec{x_m}))h(f_1, f_2, \\dots, f_{m-1}, g) \\\\
        g(\\vec{x_m}) &= 1 + \\frac{9}{|\\vec{x_m}|}\sum_{x_i \in \\vec{x_m}}x_i \\\\
        h(f_1, f_2, \\dots, f_{m-1}, g) &= m - \sum_{i=1}^{m-1}\\left[\\frac{f_1}{1+g}(1 + \sin(3\pi f_i))\\right] \\\\
    
    Here, :math:`n` represents the number of dimensions, :math:`m` represents the
    number of objectives, :math:`x_i \in [0, 1]` for :math:`i=1,...,n`, and 
    :math:`\\vec{x_m} = x_m x_{m+1} \\dots x_{n}.`
    
    The recommendation given in the paper mentioned above is to provide 19 more
    dimensions than objectives. For instance, if we want to use 2 objectives, we
    should use 21 dimensions.
    
    .. figure:: _static/dtlz7funb.jpg
        :alt: DTLZ7 Pareto front
        :width: 700 px
        :align: center
        
        Three-dimensional DTLZ7 Pareto front 
        (`image source <http://delta.cs.cinvestav.mx/~ccoello/EMOO/testfuncs/>`__)
        
    """
    def __init__(self, dimensions=2, objectives=2):
        Benchmark.__init__(self, dimensions, objectives)
        if dimensions < objectives:
            raise ValueError('dimensions ({0}) must be greater than or equal to objectives ({1})'.format(dimensions, objectives))
        self.bounder = ec.Bounder([0.0] * self.dimensions, [1.0] * self.dimensions)
        self.maximize = False
    
    def global_optimum(self):
        """Return a globally optimal solution to this problem.
        
        This function returns a globally optimal solution (i.e., a 
        solution that lives on the Pareto front). Since there are many
        solutions that are Pareto-optimal, this function randomly 
        chooses one to return.
        
        """
        x = [random.uniform(0, 1) for _ in range(self.objectives - 1)]
        x.extend([0 for _ in range(self.dimensions - self.objectives + 1)])
        return x
        
    def generator(self, random, args):
        return [random.uniform(0.0, 1.0) for _ in range(self.dimensions)]
        
    def evaluator(self, candidates, args):
        fitness = []
        g = lambda x: 1 + 9.0 / len(x) * sum([a for a in x])
        for c in candidates:
            gval = g(c[self.objectives-1:])
            fit = []
            for m in range(self.objectives-1):
                fit.append(c[m])
            fit.append((1 + gval) * (self.objectives - sum([a / (1.0 + gval) * (1 + math.sin(3 * math.pi * a)) for a in c[:self.objectives-1]])))
            fitness.append(emo.Pareto(fit))
        return fitness


#-----------------------------------------------------------------------
#                  DISCRETE OPTIMIZATION PROBLEMS
#-----------------------------------------------------------------------

class TSP(Benchmark):
    """Defines the Traveling Salesman benchmark problem.
    
    This class defines the Traveling Salesman problem: given a set of
    locations and their pairwise distances, find the shortest route that
    visits each location once and only once. This problem assumes that 
    the ``weights`` parameter is an *n*-by-*n* list of pairwise 
    distances among *n* locations. This problem is treated as a 
    maximization problem, so fitness values are determined to be the 
    reciprocal of the total path length.
    
    In the case of typical evolutionary computation, a candidate solution
    is represented as a permutation of the *n*-element list of the integers 
    from 0 to *n*-1. In the case of ant colony optimization, a candidate
    solution is represented by a list of ``TrailComponent`` objects which
    have (source, destination) tuples as their elements and the reciprocal
    of the weight from source to destination as their values. 
    
    If evolutionary computation is to be used, then the ``generator`` 
    function should be used to create candidates. If ant colony 
    optimization is used, then the ``constructor`` function creates 
    candidates. The ``evaluator`` function performs the evaluation for 
    both types of candidates.
    
    Public Attributes:
    
    - *weights* -- the two-dimensional list of pairwise distances 
    - *components* -- the set of ``TrailComponent`` objects constructed
      from the ``weights`` attribute, where the element is the (source,
      destination) tuple and the value is the reciprocal of its 
      ``weights`` entry
    - *bias* -- the bias in selecting the component of maximum desirability
      when constructing a candidate solution for ant colony optimization 
      (default 0.5)
    
    """
    def __init__(self, weights):
        Benchmark.__init__(self, len(weights))
        self.weights = weights
        self.components = [swarm.TrailComponent((i, j), value=(1 / weights[i][j])) for i, j in itertools.permutations(range(len(weights)), 2)]
        self.bias = 0.5
        self.bounder = ec.DiscreteBounder([i for i in range(len(weights))])
        self.maximize = True
        self._use_ants = False

    def generator(self, random, args):
        """Return a candidate solution for an evolutionary computation."""
        locations = [i for i in range(len(self.weights))]
        random.shuffle(locations)
        return locations
    
    def constructor(self, random, args):
        """Return a candidate solution for an ant colony optimization."""
        self._use_ants = True
        candidate = []
        while len(candidate) < len(self.weights) - 1:
            # Find feasible components
            feasible_components = []
            if len(candidate) == 0:
                feasible_components = self.components
            elif len(candidate) == len(self.weights) - 1:
                first = candidate[0]
                last = candidate[-1]
                feasible_components = [c for c in self.components if c.element[0] == last.element[1] and c.element[1] == first.element[0]]
            else:
                last = candidate[-1]
                already_visited = [c.element[0] for c in candidate]
                already_visited.extend([c.element[1] for c in candidate])
                already_visited = set(already_visited)
                feasible_components = [c for c in self.components if c.element[0] == last.element[1] and c.element[1] not in already_visited]
            if len(feasible_components) == 0:
                candidate = []
            else:
                # Choose a feasible component
                if random.random() <= self.bias:
                    next_component = max(feasible_components)
                else:
                    next_component = selectors.fitness_proportionate_selection(random, feasible_components, {'num_selected': 1})[0]
                candidate.append(next_component)
        return candidate
    
    def evaluator(self, candidates, args):
        """Return the fitness values for the given candidates."""
        fitness = []
        if self._use_ants:
            for candidate in candidates:
                total = 0
                for c in candidate:
                    total += self.weights[c.element[0]][c.element[1]]
                last = (candidate[-1].element[1], candidate[0].element[0])
                total += self.weights[last[0]][last[1]]
                fitness.append(1 / total)
        else:
            for candidate in candidates:
                total = 0
                for src, dst in zip(candidate, candidate[1:] + [candidate[0]]):
                    total += self.weights[src][dst]
                fitness.append(1 / total)
        return fitness

class Knapsack(Benchmark):
    """Defines the Knapsack benchmark problem.
    
    This class defines the Knapsack problem: given a set of items, each
    with a weight and a value, find the set of items of maximal value
    that fit within a knapsack of fixed weight capacity. This problem 
    assumes that the ``items`` parameter is a list of (weight, value) 
    tuples. This problem is most easily defined as a maximization problem,
    where the total value contained in the knapsack is to be maximized.
    However, for the evolutionary computation (which may create infeasible
    solutions that exceed the knapsack capacity), the fitness is either
    the total value in the knapsack (for feasible solutions) or the
    negative difference between the actual contents and the maximum 
    capacity of the knapsack.

    If evolutionary computation is to be used, then the ``generator`` 
    function should be used to create candidates. If ant colony 
    optimization is used, then the ``constructor`` function creates 
    candidates. The ``evaluator`` function performs the evaluation for 
    both types of candidates.
    
    Public Attributes:
    
    - *capacity* -- the weight capacity of the knapsack
    - *items* -- a list of (weight, value) tuples corresponding to the
      possible items to be placed into the knapsack
    - *components* -- the set of ``TrailComponent`` objects constructed
      from the ``items`` parameter
    - *duplicates* -- Boolean value specifying whether items may be 
      duplicated in the knapsack (i.e., False corresponds to 0/1 Knapsack)
    - *bias* -- the bias in selecting the component of maximum desirability
      when constructing a candidate solution for ant colony optimization 
      (default 0.5)
    
    """
    def __init__(self, capacity, items, duplicates=False):
        Benchmark.__init__(self, len(items))
        self.capacity = capacity
        self.items = items
        self.components = [swarm.TrailComponent((item[0]), value=item[1]) for item in items]
        self.duplicates = duplicates
        self.bias = 0.5
        if self.duplicates:
            max_count = [self.capacity // item[0] for item in self.items]
            self.bounder = ec.DiscreteBounder([i for i in range(max(max_count)+1)])
        else:
            self.bounder = ec.DiscreteBounder([0, 1])
        self.maximize = True
        self._use_ants = False
    
    def generator(self, random, args):
        """Return a candidate solution for an evolutionary computation."""
        if self.duplicates:
            max_count = [self.capacity // item[0] for item in self.items]
            return [random.randint(0, m) for m in max_count]
        else:
            return [random.choice([0, 1]) for _ in range(len(self.items))]
    
    def constructor(self, random, args):
        """Return a candidate solution for an ant colony optimization."""
        self._use_ants = True
        candidate = []
        while len(candidate) < len(self.components):
            # Find feasible components
            feasible_components = []
            if len(candidate) == 0:
                feasible_components = self.components
            else:
                remaining_capacity = self.capacity - sum([c.element for c in candidate])
                if self.duplicates:
                    feasible_components = [c for c in self.components if c.element <= remaining_capacity]
                else:
                    feasible_components = [c for c in self.components if c not in candidate and c.element <= remaining_capacity]
            if len(feasible_components) == 0:
                break
            else:
                # Choose a feasible component
                if random.random() <= self.bias:
                    next_component = max(feasible_components)
                else:
                    next_component = selectors.fitness_proportionate_selection(random, feasible_components, {'num_selected': 1})[0]
                candidate.append(next_component)
        return candidate
    
    def evaluator(self, candidates, args):
        """Return the fitness values for the given candidates."""
        fitness = []
        if self._use_ants:
            for candidate in candidates:
                total = 0
                for c in candidate:
                    total += c.value
                fitness.append(total)
        else:
            for candidate in candidates:
                total_value = 0
                total_weight = 0
                for c, i in zip(candidate, self.items):
                    total_weight += c * i[0]
                    total_value += c * i[1]
                if total_weight > self.capacity:
                    fitness.append(self.capacity - total_weight)
                else:
                    fitness.append(total_value)
        return fitness



########NEW FILE########
__FILENAME__ = analysis
"""
    ===============================================
    :mod:`analysis` -- Optimization result analysis
    ===============================================
    
    This module provides analysis methods for the results of evolutionary computations.

    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: analysis
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import csv
import math

def fitness_statistics(population):
    """Return the basic statistics of the population's fitness values.
    
    This function returns a dictionary containing the "best", "worst",
    "mean", "median", and "std" fitness values in the population.
    ("std" is the standard deviation.) A typical usage would be similar
    to the following::
    
       stats = fitness_statistics(population)
       print(stats['best'])
       print(stats['worst'])
       print(stats['mean'])
       print(stats['median'])
       print(stats['std'])
    
    .. note::
    
       This function makes use of the numpy library for calculations. If that
       library is not found, it attempts to complete the calculations 
       internally. However, this second attempt will fail for multiobjective
       fitness values and will return ``nan`` for the mean, median, and 
       standard deviation.
    
    Arguments:
    
    - *population* -- the population of individuals 

    """
    population.sort(reverse=True)
    worst_fit = population[-1].fitness
    best_fit = population[0].fitness
    try:
        import numpy
        f = [p.fitness for p in population]
        med_fit = numpy.median(f)
        avg_fit = numpy.mean(f)
        std_fit = numpy.std(f)
    except ImportError:
        try:
            plen = len(population)
            if plen % 2 == 1:
                med_fit = population[(plen - 1) // 2].fitness
            else:
                med_fit = float(population[plen // 2 - 1].fitness + population[plen // 2].fitness) / 2
            avg_fit = sum([p.fitness for p in population]) / float(plen)
            if plen > 1:
                std_fit = math.sqrt(sum([(p.fitness - avg_fit)**2 for p in population]) / float(plen - 1))
            else:
                std_fit = 0
        except TypeError:
            med_fit = float('nan')
            avg_fit = float('nan')
            std_fit = float('nan')
    return {'best': best_fit, 'worst': worst_fit, 'mean': avg_fit, 
            'median': med_fit, 'std': std_fit}
            

def generation_plot(file, errorbars=True):
    """Plot the results of the algorithm using generation statistics.
    
    This function creates a plot of the generation fitness statistics 
    (best, worst, median, and average). This function requires the 
    pylab and matplotlib libraries.
    
    .. note::
    
       This function only works for single-objective problems.

    .. figure:: _static/generation_plot.png
        :alt: Example generation plot
        :align: center
        
        An example image saved from the ``generation_plot`` function (without error bars).
    
    Arguments:
    
    - *file* -- a file-like object representing the statistics file 
      produced by the file_observer 
    - *errorbars* -- Boolean value stating whether standard error bars should 
      be drawn (default True)

    """
    import pylab
    import matplotlib.font_manager 
    
    generation = []
    psize = []
    worst = []
    best = []
    median = []
    average = []
    stdev = []
    reader = csv.reader(file)
    for row in reader:
        generation.append(int(row[0]))
        psize.append(int(row[1]))
        worst.append(float(row[2]))
        best.append(float(row[3]))
        median.append(float(row[4]))
        average.append(float(row[5]))
        stdev.append(float(row[6]))
    stderr = [s / math.sqrt(p) for s, p in zip(stdev, psize)]
    
    data = [average, median, best, worst]
    colors = ['black', 'blue', 'green', 'red']
    labels = ['average', 'median', 'best', 'worst']
    figure = pylab.figure()
    if errorbars:
        pylab.errorbar(generation, average, stderr, color=colors[0], label=labels[0])
    else:
        pylab.plot(generation, average, color=colors[0], label=labels[0])
    for d, col, lab in zip(data[1:], colors[1:], labels[1:]):
        pylab.plot(generation, d, color=col, label=lab)
    pylab.fill_between(generation, data[2], data[3], color='#e6f2e6')
    pylab.grid(True)
    ymin = min([min(d) for d in data])
    ymax = max([max(d) for d in data])
    yrange = ymax - ymin
    pylab.ylim((ymin - 0.1*yrange, ymax + 0.1*yrange))  
    prop = matplotlib.font_manager.FontProperties(size=8) 
    pylab.legend(loc='upper left', prop=prop)    
    pylab.xlabel('Generation')
    pylab.ylabel('Fitness')
    pylab.show()    

    
def allele_plot(file, normalize=False, alleles=None, generations=None):
    """Plot the alleles from each generation from the individuals file.
    
    This function creates a plot of the individual allele values as they
    change through the generations. It creates three subplots, one for each
    of the best, median, and average individual. The best and median 
    individuals are chosen using the fitness data for each generation. The 
    average individual, on the other hand, is actually an individual created
    by averaging the alleles within a generation. This function requires the 
    pylab library.

    .. note::
    
       This function only works for single-objective problems.

    .. figure:: _static/allele_plot.png
        :alt: Example allele plot
        :align: center
        
        An example image saved from the ``allele_plot`` function.
    
    Arguments:
    
    - *file* -- a file-like object representing the individuals file 
      produced by the file_observer 
    - *normalize* -- Boolean value stating whether allele values should be
      normalized before plotting (default False)
    - *alleles* -- a list of allele index values that should be plotted
      (default None)
    - *generations* -- a list of generation numbers that should be plotted
      (default None)

    If *alleles* is ``None``, then all alleles are plotted. Similarly, if 
    *generations* is ``None``, then all generations are plotted.

    """    
    import pylab
    
    generation_data = []
    reader = csv.reader(open(file))
    for row in reader:
        g = int(row[0])
        row[3] = row[3].replace('[', '')
        row[-1] = row[-1].replace(']', '')
        individual = [float(r) for r in row[3:]]
        individual.append(float(row[2]))
        try:
            generation_data[g]
        except IndexError:
            generation_data.append([])
        generation_data[g].append(individual)
    for gen in generation_data:
        gen.sort(key=lambda x: x[-1])
        for j, g in enumerate(gen):
            gen[j] = g[:-1]
        
    best = []
    median = []
    average = []
    for gen in generation_data:
        best.append(gen[0])
        plen = len(gen)
        if plen % 2 == 1:
            med = gen[(plen - 1) // 2]
        else:
            med = []
            for a, b in zip(gen[plen // 2 - 1], gen[plen // 2]):
                med.append(float(a + b) / 2)
        median.append(med)
        avg = [0] * len(gen[0])
        for individual in gen:
            for i, allele in enumerate(individual):
                avg[i] += allele
        for i, a in enumerate(avg):
            avg[i] /= float(len(gen))
        average.append(avg)        
    
    for plot_num, (data, title) in enumerate(zip([best, median, average], 
                                                 ["Best", "Median", "Average"])):
        if alleles is None:
            alleles = list(range(len(data[0])))
        if generations is None:
            generations = list(range(len(data)))    
        if normalize:
            columns = list(zip(*data))
            max_col = [max(c) for c in columns]
            min_col = [min(c) for c in columns]
            for dat in data:
                for i, d in enumerate(dat):
                    dat[i] = (d - min_col[i]) / float(max_col[i] - min_col[i])
        plot_data = []
        for g in generations:
            plot_data.append([data[g][a] for a in alleles])
        sub = pylab.subplot(3, 1, plot_num + 1)
        pylab.pcolor(pylab.array(plot_data))
        pylab.colorbar()
        step_size = max(len(generations) // 7, 1)
        ytick_locs = list(range(step_size, len(generations), step_size))
        ytick_labs = generations[step_size::step_size]
        pylab.yticks(ytick_locs, ytick_labs)
        pylab.ylabel('Generation')
        if plot_num == 2:
            xtick_locs = list(range(len(alleles)))
            xtick_labs = alleles
            pylab.xticks(xtick_locs, xtick_labs)
            pylab.xlabel('Allele')
        else:
            pylab.setp(sub.get_xticklabels(), visible=False)
        pylab.title(title)
    pylab.show()

    
def hypervolume(pareto_set, reference_point=None):
    """Calculates the hypervolume by slicing objectives (HSO).
    
    This function calculates the hypervolume (or S-measure) of a nondominated
    set using the Hypervolume by Slicing Objectives (HSO) procedure of `While, et al. 
    (IEEE CEC 2005) <http://www.lania.mx/~ccoello/EMOO/while05a.pdf.gz>`_.
    The *pareto_set* should be a list of lists of objective values.
    The *reference_point* may be specified or it may be left as the default 
    value of None. In that case, the reference point is calculated to be the
    maximum value in the set for all objectives (the ideal point). This function 
    assumes that objectives are to be maximized.
    
    Arguments:
    
    - *pareto_set* -- the list or lists of objective values comprising the Pareto front
    - *reference_point* -- the reference point to be used (default None)
    
    """
    def dominates(p, q, k=None):
        if k is None:
            k = len(p)
        d = True
        while d and k < len(p):
            d = not (q[k] > p[k])
            k += 1
        return d
        
    def insert(p, k, pl):
        ql = []
        while pl and pl[0][k] > p[k]:
            ql.append(pl[0])
            pl = pl[1:]
        ql.append(p)
        while pl:
            if not dominates(p, pl[0], k):
                ql.append(pl[0])
            pl = pl[1:]
        return ql

    def slice(pl, k, ref):
        p = pl[0]
        pl = pl[1:]
        ql = []
        s = []
        while pl:
            ql = insert(p, k + 1, ql)
            p_prime = pl[0]
            s.append((math.fabs(p[k] - p_prime[k]), ql))
            p = p_prime
            pl = pl[1:]
        ql = insert(p, k + 1, ql)
        s.append((math.fabs(p[k] - ref[k]), ql))
        return s

    ps = pareto_set
    ref = reference_point
    n = min([len(p) for p in ps])
    if ref is None:
        ref = [max(ps, key=lambda x: x[o])[o] for o in range(n)]
    pl = ps[:]
    pl.sort(key=lambda x: x[0], reverse=True)
    s = [(1, pl)]
    for k in range(n - 1):
        s_prime = []
        for x, ql in s:
            for x_prime, ql_prime in slice(ql, k, ref):
                s_prime.append((x * x_prime, ql_prime))
        s = s_prime
    vol = 0
    for x, ql in s:
        vol = vol + x * math.fabs(ql[0][n - 1] - ref[n - 1])
    return vol



    
    

########NEW FILE########
__FILENAME__ = archivers
"""
    =============================================
    :mod:`archivers` -- Solution archival methods
    =============================================
    
    This module provides pre-defined archivers for evoluationary computations.
    
    All archiver functions have the following arguments:
    
    - *random* -- the random number generator object
    - *population* -- the population of individuals
    - *archive* -- the current archive of individuals
    - *args* -- a dictionary of keyword arguments
    
    Each archiver function returns the updated archive. 
    
    .. note::
    
       The *population* is really a shallow copy of the actual population of
       the evolutionary computation. This means that any activities like
       sorting will not affect the actual population.    
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: archivers
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import math


def default_archiver(random, population, archive, args):
    """Do nothing.
    
    This function just returns the existing archive (which is
    probably empty) with no changes.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       archive -- the current archive of individuals
       args -- a dictionary of keyword arguments
    
    """
    return archive
    
    
def population_archiver(random, population, archive, args):
    """Archive the current population.
    
    This function replaces the archive with the individuals 
    of the current population.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       archive -- the current archive of individuals
       args -- a dictionary of keyword arguments
    
    """
    new_archive = []
    for ind in population:
        new_archive.append(ind)
    return new_archive
    

def best_archiver(random, population, archive, args):
    """Archive only the best individual(s).
    
    This function archives the best solutions and removes inferior ones.
    If the comparison operators have been overloaded to define Pareto
    preference (as in the ``Pareto`` class), then this archiver will form 
    a Pareto archive.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       archive -- the current archive of individuals
       args -- a dictionary of keyword arguments
    
    """
    new_archive = archive
    for ind in population:
        if len(new_archive) == 0:
            new_archive.append(ind)
        else:
            should_remove = []
            should_add = True
            for a in new_archive:
                if ind.candidate == a.candidate:
                    should_add = False
                    break
                elif ind < a:
                    should_add = False
                elif ind > a:
                    should_remove.append(a)
            for r in should_remove:
                new_archive.remove(r)
            if should_add:
                new_archive.append(ind)
    return new_archive

    
def adaptive_grid_archiver(random, population, archive, args):
    """Archive only the best individual(s) using a fixed size grid.
    
    This function archives the best solutions by using a fixed-size grid
    to determine which existing solutions should be removed in order to
    make room for new ones. This archiver is designed specifically for
    use with the Pareto Archived Evolution Strategy (PAES).

    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       archive -- the current archive of individuals
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *max_archive_size* -- the maximum number of individuals in the archive
      (default len(population))
    - *num_grid_divisions* -- the number of grid divisions (default 1)
    
    """
    def get_grid_location(fitness, num_grid_divisions, global_smallest, global_largest):
        loc = 0
        n = 1
        num_objectives = len(fitness)
        inc = [0 for _ in range(num_objectives)]
        width = [0 for _ in range(num_objectives)]
        local_smallest = global_smallest[:]
        for i, f in enumerate(fitness):
            if f < local_smallest[i] or f > local_smallest[i] + global_largest[i] - global_smallest[i]:
                return -1
        for i in range(num_objectives):
            inc[i] = n
            n *= 2
            width[i] = global_largest[i] - global_smallest[i]
        for d in range(num_grid_divisions):
            for i, f in enumerate(fitness):
                if f < width[i] / 2.0 + local_smallest[i]:
                    loc += inc[i]
                else:
                    local_smallest[i] += width[i] / 2.0
            for i in range(num_objectives):
                inc[i] *= num_objectives * 2
                width[i] /= 2.0
        return loc
 
    def update_grid(individual, archive, num_grid_divisions, global_smallest, global_largest, grid_population):
        if len(archive) == 0:
            num_objectives = len(individual.fitness)
            smallest = [individual.fitness[o] for o in range(num_objectives)]
            largest = [individual.fitness[o] for o in range(num_objectives)]
        else:
            num_objectives = min(min([len(a.fitness) for a in archive]), len(individual.fitness))
            smallest = [min(min([a.fitness[o] for a in archive]), individual.fitness[o]) for o in range(num_objectives)] 
            largest = [max(max([a.fitness[o] for a in archive]), individual.fitness[o]) for o in range(num_objectives)]
        for i in range(num_objectives):
            global_smallest[i] = smallest[i] - abs(0.2 * smallest[i])
            global_largest[i] = largest[i] + abs(0.2 * largest[i])
        for i in range(len(grid_population)):
            grid_population[i] = 0
        for a in archive:
            loc = get_grid_location(a.fitness, num_grid_divisions, global_smallest, global_largest)
            a.grid_location = loc
            grid_population[loc] += 1
        loc = get_grid_location(individual.fitness, num_grid_divisions, global_smallest, global_largest)
        individual.grid_location = loc
        grid_population[loc] += 1

    max_archive_size = args.setdefault('max_archive_size', len(population))
    num_grid_divisions = args.setdefault('num_grid_divisions', 1)
        
    if not 'grid_population' in dir(adaptive_grid_archiver):
        adaptive_grid_archiver.grid_population = [0 for _ in range(2**(min([len(p.fitness) for p in population]) * num_grid_divisions))]
    if not 'global_smallest' in dir(adaptive_grid_archiver):
        adaptive_grid_archiver.global_smallest = [0 for _ in range(min([len(p.fitness) for p in population]))]
    if not 'global_largest' in dir(adaptive_grid_archiver):
        adaptive_grid_archiver.global_largest = [0 for _ in range(min([len(p.fitness) for p in population]))]
     
    new_archive = archive
    for ind in population:
        update_grid(ind, new_archive, num_grid_divisions, adaptive_grid_archiver.global_smallest, 
                    adaptive_grid_archiver.global_largest, adaptive_grid_archiver.grid_population)
        should_be_added = True
        for a in new_archive:
            if ind == a or a > ind:
                should_be_added = False
                
        if should_be_added:
            if len(new_archive) == 0:
                new_archive.append(ind)
            else:
                join = False
                nondominated = True
                removal_set = []
                for i, a in enumerate(new_archive):
                    if ind > a and not join:
                        new_archive[i] = ind
                        join = True
                    elif ind > a:
                        if not a in removal_set: 
                            removal_set.append(a)
                    # Otherwise, the individual is nondominated against this archive member.
                    
                # We can't use set difference because Individual objects are not hashable.
                # We'd like to say...
                #     new_archive = list(set(new_archive) - set(removal_set))
                # So this code gets that same result without using sets.
                temp_archive = []
                for ind in new_archive:
                    if ind not in removal_set:
                        temp_archive.append(ind)
                new_archive = temp_archive
                
                if not join and nondominated:
                    if len(new_archive) == max_archive_size:
                        replaced_index = 0
                        found_replacement = False
                        loc = get_grid_location(ind.fitness, num_grid_divisions, 
                                                adaptive_grid_archiver.global_smallest, 
                                                adaptive_grid_archiver.global_largest)
                        ind.grid_location = loc
                        if ind.grid_location >= 0:
                            most = adaptive_grid_archiver.grid_population[ind.grid_location]
                        else:
                            most = -1
                        for i, a in enumerate(new_archive):
                            pop_at_a = adaptive_grid_archiver.grid_population[a.grid_location]
                            if pop_at_a > most:
                                most = pop_at_a
                                replaced_index = i
                                found_replacement = True
                        if found_replacement:
                            new_archive[replaced_index] = ind
                    else:
                        new_archive.append(ind)
    return new_archive

########NEW FILE########
__FILENAME__ = ec
"""
    ===============================================
    :mod:`ec` -- Evolutionary computation framework
    ===============================================
    
    This module provides the framework for creating evolutionary computations.
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: ec
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import collections
import copy
import functools
from inspyred.ec import archivers
from inspyred.ec import generators
from inspyred.ec import migrators
from inspyred.ec import observers
from inspyred.ec import replacers
from inspyred.ec import selectors
from inspyred.ec import terminators
from inspyred.ec import variators
import itertools
import logging
import math
import time


class Error(Exception):
    """An empty base exception."""
    pass


class EvolutionExit(Error):
    """An exception that may be raised and caught to end the evolution.
    
    This is an empty exception class that can be raised by the user
    at any point in the code and caught outside of the ``evolve``
    method. 
    
    .. note::
    
       Be aware that ending the evolution in such a way will almost 
       certainly produce an erroneous population (e.g., not all 
       individuals will have been reevaluated, etc.). However, this 
       approach can be viable if solutions have been archived such 
       that the current population is not of critical importance.
    
    """
    pass


class Bounder(object):
    """Defines a basic bounding function for numeric lists.
    
    This callable class acts as a function that bounds a 
    numeric list between the lower and upper bounds specified.
    These bounds can be single values or lists of values. For
    instance, if the candidate is composed of five values, each
    of which should be bounded between 0 and 1, you can say
    ``Bounder([0, 0, 0, 0, 0], [1, 1, 1, 1, 1])`` or just
    ``Bounder(0, 1)``. If either the ``lower_bound`` or 
    ``upper_bound`` argument is ``None``, the Bounder leaves 
    the candidate unchanged (which is the default behavior).
    
    As an example, if the bounder above were used on the candidate 
    ``[0.2, -0.1, 0.76, 1.3, 0.4]``, the resulting bounded
    candidate would be ``[0.2, 0, 0.76, 1, 0.4]``.
    
    A bounding function is necessary to ensure that all 
    evolutionary operators respect the legal bounds for 
    candidates. If the user is using only custom operators
    (which would be aware of the problem constraints), then 
    those can obviously be tailored to enforce the bounds
    on the candidates themselves. But the built-in operators
    make only minimal assumptions about the candidate solutions.
    Therefore, they must rely on an external bounding function
    that can be user-specified (so as to contain problem-specific
    information). 
    
    In general, a user-specified bounding function must accept
    two arguments: the candidate to be bounded and the keyword
    argument dictionary. Typically, the signature of such a 
    function would be the following::
    
        bounded_candidate = bounding_function(candidate, args)
        
    This function should return the resulting candidate after 
    bounding has been performed.
    
    Public Attributes:
    
    - *lower_bound* -- the lower bound for a candidate
    - *upper_bound* -- the upper bound for a candidate
    
    """
    def __init__(self, lower_bound=None, upper_bound=None):
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound
        if self.lower_bound is not None and self.upper_bound is not None:
            if not isinstance(self.lower_bound, collections.Iterable):
                self.lower_bound = itertools.repeat(self.lower_bound)
            if not isinstance(self.upper_bound, collections.Iterable):
                self.upper_bound = itertools.repeat(self.upper_bound)

    def __call__(self, candidate, args):
        # The default would be to leave the candidate alone
        # unless both bounds are specified.
        if self.lower_bound is None or self.upper_bound is None:
            return candidate
        else:
            if not isinstance(self.lower_bound, collections.Iterable):
                self.lower_bound = [self.lower_bound] * len(candidate)
            if not isinstance(self.upper_bound, collections.Iterable):
                self.upper_bound = [self.upper_bound] * len(candidate)
            bounded_candidate = candidate
            for i, (c, lo, hi) in enumerate(zip(candidate, self.lower_bound, 
                                                self.upper_bound)):
                bounded_candidate[i] = max(min(c, hi), lo)
            return bounded_candidate


class DiscreteBounder(object):
    """Defines a basic bounding function for numeric lists of discrete values.
    
    This callable class acts as a function that bounds a 
    numeric list to a set of legitimate values. It does this by 
    resolving a given candidate value to the nearest legitimate 
    value that can be attained. In the event that a candidate value
    is the same distance to multiple legitimate values, the legitimate
    value appearing earliest in the list will be used.
    
    For instance, if ``[1, 4, 8, 16]`` was used as the *values* parameter,
    then the candidate ``[6, 10, 13, 3, 4, 0, 1, 12, 2]`` would be 
    bounded to ``[4, 8, 16, 4, 4, 1, 1, 8, 1]``.
    
    Public Attributes:
    
    - *values* -- the set of attainable values
    - *lower_bound* -- the smallest attainable value
    - *upper_bound* -- the largest attainable value
    
    """
    def __init__(self, values):
        self.values = values
        self.lower_bound = itertools.repeat(min(self.values))
        self.upper_bound = itertools.repeat(max(self.values))

    def __call__(self, candidate, args):
        if not isinstance(self.lower_bound, collections.Iterable):
            self.lower_bound = [min(self.values)] * len(candidate)
        if not isinstance(self.upper_bound, collections.Iterable):
            self.upper_bound = [max(self.values)] * len(candidate)
        closest = lambda target: min(self.values, key=lambda x: abs(x-target))
        bounded_candidate = candidate
        for i, c in enumerate(bounded_candidate):
            bounded_candidate[i] = closest(c)
        return bounded_candidate


class Individual(object):
    """Represents an individual in an evolutionary computation.
    
    An individual is defined by its candidate solution and the
    fitness (or value) of that candidate solution. Individuals
    can be compared with one another by using <, <=, >, and >=.
    In all cases, such comparisons are made using the individuals'
    fitness values. The ``maximize`` attribute is respected in all
    cases, so it is better to think of, for example, < (less-than)
    to really mean "worse than" and > (greater-than) to mean
    "better than". For instance, if individuals a and b have fitness
    values 2 and 4, respectively, and if ``maximize`` were ``True``,
    then a < b would be true. If ``maximize`` were ``False``, then 
    a < b would be false (because a is "better than" b in terms of
    the fitness evaluation, since we're minimizing).
    
    .. note::
    
       ``Individual`` objects are almost always created by the EC, 
       rather than the user. The ``evolve`` method of the EC also 
       has a ``maximize`` argument, whose value is passed directly 
       to all created individuals.
    
    Public Attributes:
    
    - *candidate* -- the candidate solution
    - *fitness* -- the value of the candidate solution
    - *birthdate* -- the system time at which the individual was created
    - *maximize* -- Boolean value stating use of maximization
    
    """
    def __init__(self, candidate=None, maximize=True):
        self._candidate = candidate
        self.fitness = None
        self.birthdate = time.time()
        self.maximize = maximize
    
    @property
    def candidate(self):
        return self._candidate
        
    @candidate.setter
    def candidate(self, value):
        self._candidate = value
        self.fitness = None
        
    def __str__(self):
        return '{0} : {1}'.format(str(self.candidate), str(self.fitness))
        
    def __repr__(self):
        return '<Individual: candidate = {0}, fitness = {1}, birthdate = {2}>'.format(str(self.candidate), str(self.fitness), self.birthdate)
        
    def __lt__(self, other):
        if self.fitness is not None and other.fitness is not None:
            if self.maximize: 
                return self.fitness < other.fitness
            else:
                return self.fitness > other.fitness
        else:
            raise Error('fitness cannot be None when comparing Individuals')

    def __le__(self, other):
        return self < other or not other < self
            
    def __gt__(self, other):
        if self.fitness is not None and other.fitness is not None:
            return other < self
        else:
            raise Error('fitness cannot be None when comparing Individuals')

    def __ge__(self, other):
        return other < self or not self < other
        
    def __eq__(self, other):
        return ((self._candidate, self.fitness, self.maximize) == 
                (other._candidate, other.fitness, other.maximize))
                
    def __ne__(self, other):
        return not (self == other)
        


class EvolutionaryComputation(object):
    """Represents a basic evolutionary computation.
    
    This class encapsulates the components of a generic evolutionary
    computation. These components are the selection mechanism, the
    variation operators, the replacement mechanism, the migration
    scheme, the archival mechanism, the terminators, and the observers.
    
    The ``observer``, ``terminator``, and ``variator`` attributes may be
    specified as lists of such operators. In the case of the ``observer``,
    all elements of the list will be called in sequence during the 
    observation phase. In the case of the ``terminator``, all elements of
    the list will be combined via logical ``or`` and, thus, the evolution will 
    terminate if any of the terminators return True. Finally, in the case
    of the ``variator``, the elements of the list will be applied one
    after another in pipeline fashion, where the output of one variator
    is used as the input to the next.
    
    Public Attributes:
    
    - *selector* -- the selection operator (defaults to ``default_selection``)
    - *variator* -- the (possibly list of) variation operator(s) (defaults to 
      ``default_variation``)
    - *replacer* -- the replacement operator (defaults to 
      ``default_replacement``)
    - *migrator* -- the migration operator (defaults to ``default_migration``)
    - *archiver* -- the archival operator (defaults to ``default_archiver``)
    - *observer* -- the (possibly list of) observer(s) (defaults to 
      ``default_observer``)
    - *terminator* -- the (possibly list of) terminator(s) (defaults to 
      ``default_termination``)
    - *logger* -- the logger to use (defaults to the logger 'inspyred.ec')
    
    The following attributes do not have legitimate values until after 
    the ``evolve`` method executes:
    
    - *termination_cause* -- the name of the function causing 
      ``evolve`` to terminate, in the event that multiple terminators are used
    - *generator* -- the generator function passed to ``evolve``
    - *evaluator* -- the evaluator function passed to ``evolve``
    - *bounder* -- the bounding function passed to ``evolve``
    - *maximize* -- Boolean stating use of maximization passed to ``evolve``
    - *archive* -- the archive of individuals
    - *population* -- the population of individuals
    - *num_evaluations* -- the number of fitness evaluations used
    - *num_generations* -- the number of generations processed
    
    Note that the attributes above are, in general, not intended to 
    be modified by the user. (They are intended for the user to query
    during or after the ``evolve`` method's execution.) However, 
    there may be instances where it is necessary to modify them 
    within other functions. This is possible to do, but it should be the 
    exception, rather than the rule.
    
    If logging is desired, the following basic code segment can be 
    used in the ``main`` or calling scope to accomplish that::
    
        import logging
        logger = logging.getLogger('inspyred.ec')
        logger.setLevel(logging.DEBUG)
        file_handler = logging.FileHandler('inspyred.log', mode='w')
        file_handler.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
    
    Protected Attributes:
    
    - *_random* -- the random number generator object
    - *_kwargs* -- the dictionary of keyword arguments initialized
      from the *args* parameter in the *evolve* method
    
    """
    def __init__(self, random):
        self.selector = selectors.default_selection
        self.variator = variators.default_variation
        self.replacer = replacers.default_replacement
        self.migrator = migrators.default_migration
        self.observer = observers.default_observer
        self.archiver = archivers.default_archiver
        self.terminator = terminators.default_termination
        self.termination_cause = None
        self.generator = None
        self.evaluator = None
        self.bounder = None
        self.maximize = True
        self.archive = None
        self.population = None
        self.num_evaluations = 0
        self.num_generations = 0
        self.logger = logging.getLogger('inspyred.ec')
        try:
            self.logger.addHandler(logging.NullHandler())
        except AttributeError:
            # If Python < 2.7, then NullHandler doesn't exist.
            pass
        self._random = random
        self._kwargs = dict()
        
    def _should_terminate(self, pop, ng, ne):
        terminate = False
        fname = ''
        if isinstance(self.terminator, collections.Iterable):
            for clause in self.terminator:
                self.logger.debug('termination test using {0} at generation {1} and evaluation {2}'.format(clause.__name__, ng, ne))
                terminate = terminate or clause(population=pop, num_generations=ng, num_evaluations=ne, args=self._kwargs)
                if terminate:
                    fname = clause.__name__
                    break
        else:
            self.logger.debug('termination test using {0} at generation {1} and evaluation {2}'.format(self.terminator.__name__, ng, ne))
            terminate = self.terminator(population=pop, num_generations=ng, num_evaluations=ne, args=self._kwargs)
            fname = self.terminator.__name__
        if terminate:
            self.termination_cause = fname
            self.logger.debug('termination from {0} at generation {1} and evaluation {2}'.format(self.termination_cause, ng, ne))
        return terminate
        
    
    def evolve(self, generator, evaluator, pop_size=100, seeds=None, maximize=True, bounder=None, **args):
        """Perform the evolution.
        
        This function creates a population and then runs it through a series
        of evolutionary epochs until the terminator is satisfied. The general
        outline of an epoch is selection, variation, evaluation, replacement,
        migration, archival, and observation. The function returns a list of
        elements of type ``Individual`` representing the individuals contained
        in the final population.
        
        Arguments:
        
        - *generator* -- the function to be used to generate candidate solutions 
        - *evaluator* -- the function to be used to evaluate candidate solutions
        - *pop_size* -- the number of Individuals in the population (default 100)
        - *seeds* -- an iterable collection of candidate solutions to include
          in the initial population (default None)
        - *maximize* -- Boolean value stating use of maximization (default True)
        - *bounder* -- a function used to bound candidate solutions (default None)
        - *args* -- a dictionary of keyword arguments

        The *bounder* parameter, if left as ``None``, will be initialized to a
        default ``Bounder`` object that performs no bounding on candidates.
        Note that the *_kwargs* class variable will be initialized to the *args* 
        parameter here. It will also be modified to include the following 'built-in' 
        keyword argument:
        
        - *_ec* -- the evolutionary computation (this object)
        
        """
        self._kwargs = args
        self._kwargs['_ec'] = self
        
        if seeds is None:
            seeds = []
        if bounder is None:
            bounder = Bounder()
        
        self.termination_cause = None
        self.generator = generator
        self.evaluator = evaluator
        self.bounder = bounder
        self.maximize = maximize
        self.population = []
        self.archive = []
        
        # Create the initial population.
        if not isinstance(seeds, collections.Sequence):
            seeds = [seeds]
        initial_cs = copy.copy(seeds)
        num_generated = max(pop_size - len(seeds), 0)
        i = 0
        self.logger.debug('generating initial population')
        while i < num_generated:
            cs = generator(random=self._random, args=self._kwargs)
            initial_cs.append(cs)
            i += 1
        self.logger.debug('evaluating initial population')
        initial_fit = evaluator(candidates=initial_cs, args=self._kwargs)
        
        for cs, fit in zip(initial_cs, initial_fit):
            if fit is not None:
                ind = Individual(cs, maximize=maximize)
                ind.fitness = fit
                self.population.append(ind)
            else:
                self.logger.warning('excluding candidate {0} because fitness received as None'.format(cs))
        self.logger.debug('population size is now {0}'.format(len(self.population)))
        
        self.num_evaluations = len(initial_fit)
        self.num_generations = 0
        
        self.logger.debug('archiving initial population')
        self.archive = self.archiver(random=self._random, population=list(self.population), archive=list(self.archive), args=self._kwargs)
        self.logger.debug('archive size is now {0}'.format(len(self.archive)))
        self.logger.debug('population size is now {0}'.format(len(self.population)))
                
        if isinstance(self.observer, collections.Iterable):
            for obs in self.observer:
                self.logger.debug('observation using {0} at generation {1} and evaluation {2}'.format(obs.__name__, self.num_generations, self.num_evaluations))
                obs(population=list(self.population), num_generations=self.num_generations, num_evaluations=self.num_evaluations, args=self._kwargs)
        else:
            self.logger.debug('observation using {0} at generation {1} and evaluation {2}'.format(self.observer.__name__, self.num_generations, self.num_evaluations))
            self.observer(population=list(self.population), num_generations=self.num_generations, num_evaluations=self.num_evaluations, args=self._kwargs)
        
        while not self._should_terminate(list(self.population), self.num_generations, self.num_evaluations):
            # Select individuals.
            self.logger.debug('selection using {0} at generation {1} and evaluation {2}'.format(self.selector.__name__, self.num_generations, self.num_evaluations))
            parents = self.selector(random=self._random, population=list(self.population), args=self._kwargs)
            self.logger.debug('selected {0} candidates'.format(len(parents)))
            parent_cs = [copy.deepcopy(i.candidate) for i in parents]
            offspring_cs = parent_cs
            
            if isinstance(self.variator, collections.Iterable):
                for op in self.variator:
                    self.logger.debug('variation using {0} at generation {1} and evaluation {2}'.format(op.__name__, self.num_generations, self.num_evaluations))
                    offspring_cs = op(random=self._random, candidates=offspring_cs, args=self._kwargs)
            else:
                self.logger.debug('variation using {0} at generation {1} and evaluation {2}'.format(self.variator.__name__, self.num_generations, self.num_evaluations))
                offspring_cs = self.variator(random=self._random, candidates=offspring_cs, args=self._kwargs)
            self.logger.debug('created {0} offspring'.format(len(offspring_cs)))
            
            # Evaluate offspring.
            self.logger.debug('evaluation using {0} at generation {1} and evaluation {2}'.format(evaluator.__name__, self.num_generations, self.num_evaluations))
            offspring_fit = evaluator(candidates=offspring_cs, args=self._kwargs)
            offspring = []
            for cs, fit in zip(offspring_cs, offspring_fit):
                if fit is not None:
                    off = Individual(cs, maximize=maximize)
                    off.fitness = fit
                    offspring.append(off)
                else:
                    self.logger.warning('excluding candidate {0} because fitness received as None'.format(cs))
            self.num_evaluations += len(offspring_fit)        

            # Replace individuals.
            self.logger.debug('replacement using {0} at generation {1} and evaluation {2}'.format(self.replacer.__name__, self.num_generations, self.num_evaluations))
            self.population = self.replacer(random=self._random, population=self.population, parents=parents, offspring=offspring, args=self._kwargs)
            self.logger.debug('population size is now {0}'.format(len(self.population)))
            
            # Migrate individuals.
            self.logger.debug('migration using {0} at generation {1} and evaluation {2}'.format(self.migrator.__name__, self.num_generations, self.num_evaluations))
            self.population = self.migrator(random=self._random, population=self.population, args=self._kwargs)
            self.logger.debug('population size is now {0}'.format(len(self.population)))
            
            # Archive individuals.
            self.logger.debug('archival using {0} at generation {1} and evaluation {2}'.format(self.archiver.__name__, self.num_generations, self.num_evaluations))
            self.archive = self.archiver(random=self._random, archive=self.archive, population=list(self.population), args=self._kwargs)
            self.logger.debug('archive size is now {0}'.format(len(self.archive)))
            self.logger.debug('population size is now {0}'.format(len(self.population)))
            
            self.num_generations += 1
            if isinstance(self.observer, collections.Iterable):
                for obs in self.observer:
                    self.logger.debug('observation using {0} at generation {1} and evaluation {2}'.format(obs.__name__, self.num_generations, self.num_evaluations))
                    obs(population=list(self.population), num_generations=self.num_generations, num_evaluations=self.num_evaluations, args=self._kwargs)
            else:
                self.logger.debug('observation using {0} at generation {1} and evaluation {2}'.format(self.observer.__name__, self.num_generations, self.num_evaluations))
                self.observer(population=list(self.population), num_generations=self.num_generations, num_evaluations=self.num_evaluations, args=self._kwargs)
        return self.population
        

class GA(EvolutionaryComputation):
    """Evolutionary computation representing a canonical genetic algorithm.
    
    This class represents a genetic algorithm which uses, by 
    default, rank selection, `n`-point crossover, bit-flip mutation, 
    and generational replacement. In the case of bit-flip mutation, 
    it is expected that each candidate solution is a ``Sequence`` 
    of binary values. 
    
    Optional keyword arguments in ``evolve`` args parameter:
    
    - *num_selected* -- the number of individuals to be selected 
      (default len(population))
    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)
    - *num_crossover_points* -- the `n` crossover points used (default 1)
    - *mutation_rate* -- the rate at which mutation is performed (default 0.1)
    - *num_elites* -- number of elites to consider (default 0)
    
    """
    def __init__(self, random):
        EvolutionaryComputation.__init__(self, random)
        self.selector = selectors.rank_selection 
        self.variator = [variators.n_point_crossover, variators.bit_flip_mutation]
        self.replacer = replacers.generational_replacement
        
    def evolve(self, generator, evaluator, pop_size=100, seeds=None, maximize=True, bounder=None, **args):
        args.setdefault('num_selected', pop_size)
        return EvolutionaryComputation.evolve(self, generator, evaluator, pop_size, seeds, maximize, bounder, **args)


class ES(EvolutionaryComputation):
    """Evolutionary computation representing a canonical evolution strategy.
    
    This class represents an evolution strategy which uses, by 
    default, the default selection (i.e., all individuals are selected), 
    an internal adaptive mutation using strategy parameters, and 'plus' 
    replacement. It is expected that each candidate solution is a ``Sequence``
    of real values. 
    
    The candidate solutions to an ES are augmented by strategy parameters of
    the same length (using ``inspyred.ec.generators.strategize``). These 
    strategy parameters are evolved along with the candidates and are used as
    the mutation rates for each element of the candidates. The evaluator is
    modified internally to use only the actual candidate elements (rather than
    also the strategy parameters), so normal evaluator functions may be used
    seamlessly.

    Optional keyword arguments in ``evolve`` args parameter:
    
    - *tau* -- a proportionality constant (default None)
    - *tau_prime* -- a proportionality constant (default None)
    - *epsilon* -- the minimum allowed strategy parameter (default 0.00001)
    
    If *tau* is ``None``, it will be set to ``1 / sqrt(2 * sqrt(n))``, where
    ``n`` is the length of a candidate. If *tau_prime* is ``None``, it will be
    set to ``1 / sqrt(2 * n)``. The strategy parameters are updated as follows:
    
    .. math::
    
        \\sigma_i^\\prime = \\sigma_i + e^{\\tau \\cdot N(0, 1) + \\tau^\prime \\cdot N(0, 1)}
        
        \\sigma_i^\\prime = max(\\sigma_i^\\prime, \\epsilon)
    
    """
    def __init__(self, random):
        EvolutionaryComputation.__init__(self, random)
        self.selector = selectors.default_selection
        self.variator = self._internal_variation
        self.replacer = replacers.plus_replacement
        
    def _internal_variation(self, random, candidates, args):
        tau = args.setdefault('tau', None)
        tau_prime = args.setdefault('tau_prime', None)
        epsilon = args.setdefault('epsilon', 0.00001)
        mutants = []
        n = len(candidates[0]) // 2
        if tau is None:
            tau = 1 / math.sqrt(2 * math.sqrt(n))
        if tau_prime is None:
            tau_prime = 1 / math.sqrt(2 * n) 
        for candidate in candidates:
            cand = candidate[:n]
            strat = candidate[n:]
            for i, s in enumerate(strat):
                strat[i] = s * math.exp(tau_prime * random.gauss(0, 1) + tau * random.gauss(0, 1))
                strat[i] = max(strat[i], epsilon)
            for i, (c, s) in enumerate(zip(cand, strat)):
                cand[i] = c + random.gauss(0, s)
            cand = self.bounder(cand, args)
            cand.extend(strat)
            mutants.append(cand)
        return mutants
        
    def _internal_evaluator(self, func):
        @functools.wraps(func)
        def evaluator(candidates, args):
            cands = []
            for candidate in candidates:
                n = len(candidate) // 2
                cands.append(candidate[:n])
            return func(cands, args)
        return evaluator
    
    def evolve(self, generator, evaluator, pop_size=100, seeds=None, maximize=True, bounder=None, **args):
        generator = generators.strategize(generator)
        evaluator = self._internal_evaluator(evaluator)
        # Strategize any seeds that are passed.
        strategy_seeds = None
        if seeds is not None:
            strategy_seeds = []
            for candidate in seeds:
                n = len(candidate)
                c = copy.copy(candidate)
                c.extend([self._random.random() for _ in range(n)])
                strategy_seeds.append(c)
        return EvolutionaryComputation.evolve(self, generator, evaluator, pop_size, strategy_seeds, maximize, bounder, **args)
    

class EDA(EvolutionaryComputation):
    """Evolutionary computation representing a canonical estimation of distribution algorithm.
    
    This class represents an estimation of distribution algorithm which
    uses, by default, truncation selection, an internal estimation of 
    distribution variation, and generational replacement. It is expected 
    that each candidate solution is a ``Sequence`` of real values. 
    
    The variation used here creates a statistical model based on the set 
    of candidates. The offspring are then generated from this model. This 
    function also makes use of the bounder function as specified in the EC's 
    ``evolve`` method.

    Optional keyword arguments in ``evolve`` args parameter:
    
    - *num_selected* -- the number of individuals to be selected 
      (default len(population)/2)
    - *num_offspring* -- the number of offspring to create (default len(population))
    - *num_elites* -- number of elites to consider (default 0)
    
    """
    def __init__(self, random):
        EvolutionaryComputation.__init__(self, random)
        self.selector = selectors.truncation_selection
        self.variator = self._internal_variation
        self.replacer = replacers.generational_replacement
        
    def _internal_variation(self, random, candidates, args):
        num_offspring = args.setdefault('num_offspring', 1)
        bounder = args['_ec'].bounder        
        num_genes = max([len(x) for x in candidates])
        genes = [[x[i] for x in candidates] for i in range(num_genes)] 
        mean = [float(sum(x)) / float(len(x)) for x in genes]
        stdev = [sum([(x - m)**2 for x in g]) / float(len(g) - 1) for g, m in zip(genes, mean)]
        offspring = []
        for _ in range(num_offspring):
            child = copy.copy(candidates[0])
            for i, (m, s) in enumerate(zip(mean, stdev)):
                child[i] = m + random.gauss(0, s)
            child = bounder(child, args)
            offspring.append(child)
        return offspring
        
    def evolve(self, generator, evaluator, pop_size=100, seeds=None, maximize=True, bounder=None, **args):
        args.setdefault('num_selected', pop_size // 2)
        args.setdefault('num_offspring', pop_size)
        return EvolutionaryComputation.evolve(self, generator, evaluator, pop_size, seeds, maximize, bounder, **args)


class DEA(EvolutionaryComputation):
    """Evolutionary computation representing a differential evolutionary algorithm.
    
    This class represents a differential evolutionary algorithm which uses, by 
    default, tournament selection, heuristic crossover, Gaussian mutation,
    and steady-state replacement. It is expected that each candidate solution 
    is a ``Sequence`` of real values. 
    
    Optional keyword arguments in ``evolve`` args parameter:
    
    - *num_selected* -- the number of individuals to be selected (default 2)
    - *tournament_size* -- the tournament size (default 2)
    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)
    - *mutation_rate* -- the rate at which mutation is performed (default 0.1)
    - *gaussian_mean* -- the mean used in the Gaussian function (default 0)
    - *gaussian_stdev* -- the standard deviation used in the Gaussian function
      (default 1)

    """
    def __init__(self, random):
        EvolutionaryComputation.__init__(self, random)
        self.selector = selectors.tournament_selection
        self.variator = [variators.heuristic_crossover, variators.gaussian_mutation]
        self.replacer = replacers.steady_state_replacement
        
    def evolve(self, generator, evaluator, pop_size=100, seeds=None, maximize=True, bounder=None, **args):
        args.setdefault('num_selected', 2)
        return EvolutionaryComputation.evolve(self, generator, evaluator, pop_size, seeds, maximize, bounder, **args)


class SA(EvolutionaryComputation):
    """Evolutionary computation representing simulated annealing.
    
    This class represents a simulated annealing algorithm. It accomplishes this
    by using default selection (i.e., all individuals are parents), Gaussian
    mutation, and simulated annealing replacement. It is expected that each
    candidate solution is a ``Sequence`` of real values. Consult the
    documentation for the ``simulated_annealing_replacement`` for more
    details on the keyword arguments listed below. 
    
    .. note::
    
       The ``pop_size`` parameter to ``evolve`` will always be set to 1, 
       even if a different value is passed.
    
    Optional keyword arguments in ``evolve`` args parameter:
    
    - *temperature* -- the initial temperature
    - *cooling_rate* -- a real-valued coefficient in the range (0, 1) 
      by which the temperature should be reduced     
    - *mutation_rate* -- the rate at which mutation is performed (default 0.1)
    - *gaussian_mean* -- the mean used in the Gaussian function (default 0)
    - *gaussian_stdev* -- the standard deviation used in the Gaussian function
      (default 1)
      
    """
    def __init__(self, random):
        EvolutionaryComputation.__init__(self, random)
        self.selector = selectors.default_selection
        self.variator = variators.gaussian_mutation
        self.replacer = replacers.simulated_annealing_replacement
    
    def evolve(self, generator, evaluator, pop_size=1, seeds=None, maximize=True, bounder=None, **args):
        pop_size = 1
        return EvolutionaryComputation.evolve(self, generator, evaluator, pop_size, seeds, maximize, bounder, **args)

########NEW FILE########
__FILENAME__ = emo
"""
    ======================================================
    :mod:`emo` -- Evolutionary multiobjective optimization
    ======================================================
    
    This module provides the framework for making multiobjective evolutionary 
    computations.
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: emo
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
from inspyred.ec import ec
import math


class Pareto(object):
    """Represents a Pareto multiobjective solution.
    
    A Pareto solution is a set of multiobjective values that can be 
    compared to other Pareto values using Pareto preference. This means 
    that a solution dominates, or is better than, another solution if it 
    is better than or equal to the other solution in all objectives and
    strictly better in at least one objective.
    
    Since some problems may mix maximization and minimization among
    different objectives, an optional `maximize` parameter may be
    passed upon construction of the Pareto object. This parameter
    may be a list of Booleans of the same length as the set of 
    objective values. If this parameter is used, then the `maximize`
    parameter of the evolutionary computation's ``evolve`` method 
    should be left as the default True value in order to avoid
    confusion. (Setting the `evolve`'s parameter to False would
    essentially invert all of the Booleans in the Pareto `maximize`
    list.) So, if all objectives are of the same type (either
    maximization or minimization), then it is best simply to use
    the `maximize` parameter of the `evolve` method and to leave
    the `maximize` parameter of the Pareto initialization set to
    its default True value. However, if the objectives are mixed
    maximization and minimization, it is best to leave the ``evolve``'s
    `maximize` parameter set to its default True value and specify
    the Pareto's `maximize` list to the appropriate Booleans.
    
    The typical usage is as follows::
    
        @inspyred.ec.evaluators.evaluator
        def my_evaluator(candidate, args):
            obj1 = 1 # Calculate objective 1
            obj2 = 2 # Calculate objective 2
            obj3 = 3 # Calculate objective 3
            return emo.Pareto([obj1, obj2, obj3])
    
    """
    def __init__(self, values=None, maximize=True):
        if values is None:
            values = []
        self.values = values
        try:
            iter(maximize)
        except TypeError:
            maximize = [maximize for v in values]
        self.maximize = maximize
        
    def __len__(self):
        return len(self.values)
    
    def __getitem__(self, key):
        return self.values[key]
        
    def __iter__(self):
        return iter(self.values)
    
    def __lt__(self, other):
        if len(self.values) != len(other.values):
            raise NotImplementedError
        else:
            not_worse = True
            strictly_better = False
            for x, y, m in zip(self.values, other.values, self.maximize):
                if m:
                    if x > y:
                        not_worse = False
                    elif y > x:
                        strictly_better = True
                else:
                    if x < y:
                        not_worse = False
                    elif y < x:
                        strictly_better = True
            return not_worse and strictly_better
            
    def __le__(self, other):
        return self < other or not other < self
        
    def __gt__(self, other):
        return other < self
        
    def __ge__(self, other):
        return other < self or not self < other
        
    def __eq__(self, other):
        return self.values == other.values
        
    def __ne__(self, other):
        return not (self == other)
    
    def __str__(self):
        return str(self.values)
        
    def __repr__(self):
        return str(self.values)


class NSGA2(ec.EvolutionaryComputation):
    """Evolutionary computation representing the nondominated sorting genetic algorithm.
    
    This class represents the nondominated sorting genetic algorithm (NSGA-II)
    of Kalyanmoy Deb et al. It uses nondominated sorting with crowding for 
    replacement, binary tournament selection to produce *population size*
    children, and a Pareto archival strategy. The remaining operators take 
    on the typical default values but they may be specified by the designer.
    
    """
    def __init__(self, random):
        ec.EvolutionaryComputation.__init__(self, random)
        self.archiver = ec.archivers.best_archiver
        self.replacer = ec.replacers.nsga_replacement
        self.selector = ec.selectors.tournament_selection
    
    def evolve(self, generator, evaluator, pop_size=100, seeds=None, maximize=True, bounder=None, **args):
        args.setdefault('num_selected', pop_size)
        args.setdefault('tournament_size', 2)
        return ec.EvolutionaryComputation.evolve(self, generator, evaluator, pop_size, seeds, maximize, bounder, **args)

    
class PAES(ec.EvolutionaryComputation):
    """Evolutionary computation representing the Pareto Archived Evolution Strategy.
    
    This class represents the Pareto Archived Evolution Strategy of Joshua
    Knowles and David Corne. It is essentially a (1+1)-ES with an adaptive
    grid archive that is used as a part of the replacement process. 
    
    """
    def __init__(self, random):
        ec.EvolutionaryComputation.__init__(self, random)
        self.archiver = ec.archivers.adaptive_grid_archiver
        self.selector = ec.selectors.default_selection
        self.variator = ec.variators.gaussian_mutation
        self.replacer = ec.replacers.paes_replacement  

    def evolve(self, generator, evaluator, pop_size=1, seeds=None, maximize=True, bounder=None, **args):
        final_pop = ec.EvolutionaryComputation.evolve(self, generator, evaluator, pop_size, seeds, maximize, bounder, **args)
        try:
            del self.archiver.grid_population
        except AttributeError:
            pass
        try:
            del self.archiver.global_smallest
        except AttributeError:
            pass
        try:
            del self.archiver.global_largest
        except AttributeError:
            pass
        return final_pop
    


########NEW FILE########
__FILENAME__ = evaluators
"""
    ===============================================
    :mod:`evaluators` -- Fitness evaluation methods
    ===============================================
    
    Evaluator functions are problem-specific. This module provides pre-defined 
    evaluators for evolutionary computations.

    All evaluator functions have the following arguments:
    
    - *candidates* -- the candidate solutions
    - *args* -- a dictionary of keyword arguments
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: evaluators
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
    .. moduleauthor:: Jelle Feringa <jelleferinga@gmail.com>
"""
import functools
try:
    import cPickle as pickle
except ImportError:
    import pickle


def evaluator(evaluate):
    """Return an inspyred evaluator function based on the given function.
    
    This function generator takes a function that evaluates only one
    candidate. The generator handles the iteration over each candidate 
    to be evaluated.

    The given function ``evaluate`` must have the following signature::
    
        fitness = evaluate(candidate, args)
        
    This function is most commonly used as a function decorator with
    the following usage::
    
        @evaluator
        def evaluate(candidate, args):
            # Implementation of evaluation
            pass
            
    The generated function also contains an attribute named
    ``single_evaluation`` which holds the original evaluation function.
    In this way, the original single-candidate function can be
    retrieved if necessary.
    
    """
    @functools.wraps(evaluate)
    def ecspy_evaluator(candidates, args):
        fitness = []
        for candidate in candidates:
            fitness.append(evaluate(candidate, args))
        return fitness
    ecspy_evaluator.single_evaluation = evaluate
    return ecspy_evaluator
    

def parallel_evaluation_pp(candidates, args):
    """Evaluate the candidates in parallel using Parallel Python.

    This function allows parallel evaluation of candidate solutions.
    It uses the `Parallel Python <http://www.parallelpython.com>`_  (pp)
    library to accomplish the parallelization. This library must already 
    be installed in order to use this function. The function assigns the 
    evaluation of each candidate to its own job, all of which are then 
    distributed to the available processing units.
    
    .. note::
    
       All arguments to the evaluation function must be pickleable.
       Those that are not will not be sent through the ``args`` variable
       and will be unavailable to your function.
       
    .. Arguments:
       candidates -- the candidate solutions
       args -- a dictionary of keyword arguments

    Required keyword arguments in args:
    
    - *pp_evaluator* -- actual evaluation function to be used (This function
      should have the same signature as any other inspyred evaluation function.)

    Optional keyword arguments in args:
    
    - *pp_dependencies* -- tuple of functional dependencies of the serial 
      evaluator (default ())
    - *pp_modules* -- tuple of modules that must be imported for the 
      functional dependencies (default ())
    - *pp_servers* -- tuple of servers (on a cluster) that will be used 
      for parallel processing (default ("*",))
    - *pp_secret* -- string representing the secret key needed to authenticate
      on a worker node (default "inspyred")
    - *pp_nprocs* -- integer representing the number of worker processes to
      start on the local machine (default "autodetect", which sets it to the
      number of processors in the system)
      
    For more information about these arguments, please consult the
    documentation for `Parallel Python <http://www.parallelpython.com>`_.
    
    """
    import pp
    logger = args['_ec'].logger
    
    try:
        evaluator = args['pp_evaluator']
    except KeyError:
        logger.error('parallel_evaluation_pp requires \'pp_evaluator\' be defined in the keyword arguments list')
        raise 
    secret_key = args.setdefault('pp_secret', 'inspyred')
    try:
        job_server = args['_pp_job_server']
    except KeyError:
        pp_servers = args.get('pp_servers', ("*",))
        pp_nprocs = args.get('pp_nprocs', 'autodetect')
        job_server = pp.Server(ncpus=pp_nprocs, ppservers=pp_servers, secret=secret_key)
        args['_pp_job_server'] = job_server
    pp_depends = args.setdefault('pp_dependencies', ())
    pp_modules = args.setdefault('pp_modules', ())
        
    pickled_args = {}
    for key in args:
        try:
            pickle.dumps(args[key])
            pickled_args[key] = args[key]
        except (TypeError, pickle.PickleError, pickle.PicklingError):
            logger.debug('unable to pickle args parameter {0} in parallel_evaluation_pp'.format(key))
            pass
            
    func_template = pp.Template(job_server, evaluator, pp_depends, pp_modules)
    jobs = [func_template.submit([c], pickled_args) for c in candidates]
    
    fitness = []
    for i, job in enumerate(jobs):
        r = job()
        try:
            fitness.append(r[0])
        except TypeError:
            logger.warning('parallel_evaluation_pp generated an invalid fitness for candidate {0}'.format(candidates[i]))
            fitness.append(None)
    return fitness


def parallel_evaluation_mp(candidates, args):
    """Evaluate the candidates in parallel using ``multiprocessing``.

    This function allows parallel evaluation of candidate solutions.
    It uses the standard multiprocessing library to accomplish the 
    parallelization. The function assigns the evaluation of each
    candidate to its own job, all of which are then distributed to the
    available processing units.
    
    .. note::
    
       All arguments to the evaluation function must be pickleable.
       Those that are not will not be sent through the ``args`` variable
       and will be unavailable to your function.
    
    .. Arguments:
       candidates -- the candidate solutions
       args -- a dictionary of keyword arguments

    Required keyword arguments in args:
    
    - *mp_evaluator* -- actual evaluation function to be used (This function
      should have the same signature as any other inspyred evaluation function.)

    Optional keyword arguments in args:
    
    - *mp_nprocs* -- number of processors that will be used (default machine 
      cpu count)
    
    """
    import time
    import multiprocessing
    logger = args['_ec'].logger
    
    try:
        evaluator = args['mp_evaluator']
    except KeyError:
        logger.error('parallel_evaluation_mp requires \'mp_evaluator\' be defined in the keyword arguments list')
        raise 
    try:
        nprocs = args['mp_nprocs']
    except KeyError:
        nprocs = multiprocessing.cpu_count()
        
    pickled_args = {}
    for key in args:
        try:
            pickle.dumps(args[key])
            pickled_args[key] = args[key]
        except (TypeError, pickle.PickleError, pickle.PicklingError):
            logger.debug('unable to pickle args parameter {0} in parallel_evaluation_mp'.format(key))
            pass

    start = time.time()
    try:
        pool = multiprocessing.Pool(processes=nprocs)
        results = [pool.apply_async(evaluator, ([c], pickled_args)) for c in candidates]
        pool.close()
        pool.join()
        return [r.get()[0] for r in results]
    except (OSError, RuntimeError) as e:
        logger.error('failed parallel_evaluation_mp: {0}'.format(str(e)))
        raise
    else:
        end = time.time()
        logger.debug('completed parallel_evaluation_mp in {0} seconds'.format(end - start))
        

########NEW FILE########
__FILENAME__ = generators
"""
    ================================================
    :mod:`generators` -- Solution generation methods
    ================================================
    
    Generator functions are problem-specific. They are used to create the 
    initial set of candidate solutions needed by the evolutionary computation. 

    All generator functions have the following arguments:
    
    - *random* -- the random number generator object
    - *args* -- a dictionary of keyword arguments
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: generators
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import functools


def strategize(generator):
    """Add strategy parameters to candidates created by a generator.
    
    This function decorator is used to provide a means of adding strategy 
    parameters to candidates created by a generator. The generator function 
    is modifed to extend the candidate with ``len(candidate)`` strategy 
    parameters (one per candidate element). Each strategy parameter is 
    initialized to a random value in the range [0, 1]. The typical usage is 
    as follows::
    
        @strategize
        def generator_function(random, args):
            # Normal generator function
            pass
            
    """
    @functools.wraps(generator)
    def strategy_generator(random, args):
        candidate = generator(random, args)
        n = len(candidate)
        candidate.extend([random.random() for _ in range(n)])
        return candidate
    return strategy_generator


class diversify(object):
    """Ensure uniqueness of candidates created by a generator.
    
    This function decorator is used to enforce uniqueness of candidates 
    created by a generator. The decorator maintains a list of previously
    created candidates, and it ensures that new candidates are unique by
    checking a generated candidate against that list, regenerating if a
    duplicate is found. The typical usage is as follows::
    
        @diversify
        def generator_function(random, args):
            # Normal generator function
            pass
            
    If a list of seeds is used, then these can be specified prior to the
    generator's use by saying the following::
    
        @diversify
        def generator_function(random, args):
            # Normal generator function
            pass
        generator_function.candidates = seeds
            
    """
    def __init__ (self, generator):
        self.candidates = []
        self.generator = generator
        try:
            functools.update_wrapper(self, generator)
        except:
            pass

    def __call__ (self, random, args):
        c = self.generator(random, args)
        while c in self.candidates:
            c = self.generator(random, args)
        self.candidates.append(c)
        return c

########NEW FILE########
__FILENAME__ = migrators
"""
    ==============================================
    :mod:`migrators` -- Solution migration methods
    ==============================================
    
    This module provides pre-defined migrators for evolutionary computations.

    All migrator functions have the following arguments:
    
    - *random* -- the random number generator object
    - *population* -- the population of Individuals
    - *args* -- a dictionary of keyword arguments
    
    Each migrator function returns the updated population.
    
    Migrator functions would typically be used for multi-population approaches,
    such as island-model evolutionary computations. They provide a means for
    individuals to be transferred from one population to another during the
    evolutionary process.
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: migrators
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import multiprocessing
try:
    import Queue
except ImportError:
    import queue as Queue


def default_migration(random, population, args):
    """Do nothing.
    
    This function just returns the existing population with no changes.
    
    """
    return population


class MultiprocessingMigrator(object):
    """Migrate among processes on the same machine.
    
    This callable class allows individuals to migrate from one process 
    to another on the same machine. It maintains a queue of migrants
    whose maximum length can be fixed via the ``max_migrants``
    parameter in the constructor. If the number of migrants in the queue
    reaches this value, new migrants are not added until earlier ones
    are consumed. The unreliability of a multiprocessing environment
    makes it difficult to provide guarantees. However, migrants are 
    theoretically added and consumed at the same rate, so this value
    should determine the "freshness" of individuals, where smaller
    queue sizes provide more recency.
    
    An optional keyword argument in ``args`` requires the migrant to be
    evaluated by the current evolutionary computation before being inserted 
    into the population. This can be important when different populations 
    use different evaluation functions and you need to be able to compare 
    "apples with apples," so to speak.
    
    The migration takes the current individual *I* out of the queue, if
    one exists. It then randomly chooses an individual *E* from the population
    to insert into the queue. Finally, if *I* exists, it replaces *E* in the
    population (re-evaluating fitness if necessary). Otherwise, *E* remains in 
    the population and also exists in the queue as a migrant.
    
    Optional keyword arguments in args:
    
    - *evaluate_migrant* -- should new migrants be evaluated before 
      adding them to the population (default False)
    
    """
    def __init__(self, max_migrants=1):
        self.max_migrants = max_migrants
        self.migrants = multiprocessing.Queue(self.max_migrants)
        self._lock = multiprocessing.Lock()
        self.__name__ = self.__class__.__name__

    def __call__(self, random, population, args):
        with self._lock:
            evaluate_migrant = args.setdefault('evaluate_migrant', False)
            migrant_index = random.randint(0, len(population) - 1)
            old_migrant = population[migrant_index]
            try:
                migrant = self.migrants.get(block=False)
                if evaluate_migrant:
                    fit = args["_ec"].evaluator([migrant.candidate], args)
                    migrant.fitness = fit[0]
                    args["_ec"].num_evaluations += 1                    
                population[migrant_index] = migrant
            except Queue.Empty:
                pass
            try:
                self.migrants.put(old_migrant, block=False)
            except Queue.Full:
                pass
            return population





########NEW FILE########
__FILENAME__ = observers
"""
    ================================================
    :mod:`observers` -- Algorithm monitoring methods
    ================================================
    
    This module provides pre-defined observers for evolutionary computations.
    
    All observer functions have the following arguments:
    
    - *population* -- the population of Individuals
    - *num_generations* -- the number of elapsed generations
    - *num_evaluations* -- the number of candidate solution evaluations
    - *args* -- a dictionary of keyword arguments    
    
    .. note::
    
       The *population* is really a shallow copy of the actual population of
       the evolutionary computation. This means that any activities like
       sorting will not affect the actual population.
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: observers
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import email
import inspyred
import math
import os
import smtplib
import time


    

def default_observer(population, num_generations, num_evaluations, args):
    """Do nothing."""    
    pass
    

def best_observer(population, num_generations, num_evaluations, args):
    """Print the best individual in the population to the screen.
    
    This function displays the best individual in the population to 
    the screen. 
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    """
    print("Best Individual: {0}\n".format(str(max(population))))
    
    
def stats_observer(population, num_generations, num_evaluations, args):
    """Print the statistics of the evolutionary computation to the screen.
    
    This function displays the statistics of the evolutionary computation
    to the screen. The output includes the generation number, the current
    number of evaluations, the maximum fitness, the minimum fitness, 
    the average fitness, and the standard deviation.
    
    .. note::
    
       This function makes use of the ``inspyred.ec.analysis.fitness_statistics`` 
       function, so it is subject to the same requirements.
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    """
    stats = inspyred.ec.analysis.fitness_statistics(population)
    worst_fit = '{0:>10}'.format(stats['worst'])[:10]
    best_fit = '{0:>10}'.format(stats['best'])[:10]
    avg_fit = '{0:>10}'.format(stats['mean'])[:10]
    med_fit = '{0:>10}'.format(stats['median'])[:10]
    std_fit = '{0:>10}'.format(stats['std'])[:10]
            
    print('Generation Evaluation      Worst       Best     Median    Average    Std Dev')
    print('---------- ---------- ---------- ---------- ---------- ---------- ----------')
    print('{0:>10} {1:>10} {2:>10} {3:>10} {4:>10} {5:>10} {6:>10}\n'.format(num_generations, 
                                                                             num_evaluations, 
                                                                             worst_fit, 
                                                                             best_fit, 
                                                                             med_fit, 
                                                                             avg_fit, 
                                                                             std_fit))


def population_observer(population, num_generations, num_evaluations, args):
    """Print the current population of the evolutionary computation to the screen.
    
    This function displays the current population of the evolutionary 
    computation to the screen in fitness-sorted order. 
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    """
    population.sort(reverse=True)
    print('----------------------------------------------------------------------------')
    print('                            Current Population')
    print('----------------------------------------------------------------------------')
    for ind in population:
        print(str(ind))
    print('----------------------------------------------------------------------------')
    
    
def file_observer(population, num_generations, num_evaluations, args):
    """Print the output of the evolutionary computation to a file.
    
    This function saves the results of the evolutionary computation
    to two files. The first file, which by default is named 
    'inspyred-statistics-file-<timestamp>.csv', contains the basic
    generational statistics of the population throughout the run
    (worst, best, median, and average fitness and standard deviation
    of the fitness values). The second file, which by default is named
    'inspyred-individuals-file-<timestamp>.csv', contains every individual
    during each generation of the run. Both files may be passed to the
    function as keyword arguments (see below).
    
    The format of each line of the statistics file is as follows::
    
       generation number, population size, worst, best, median, average, standard deviation

    The format of each line of the individuals file is as follows::
    
       generation number, individual number, fitness, string representation of candidate
    
    .. note::
    
       This function makes use of the ``inspyred.ec.analysis.fitness_statistics`` 
       function, so it is subject to the same requirements.
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *statistics_file* -- a file object (default: see text)
    - *individuals_file* -- a file object (default: see text) 
    
    """
    try:
        statistics_file = args['statistics_file']
    except KeyError:
        statistics_file = open('inspyred-statistics-file-{0}.csv'.format(time.strftime('%m%d%Y-%H%M%S')), 'w')
        args['statistics_file'] = statistics_file
    try:
        individuals_file = args['individuals_file']
    except KeyError:
        individuals_file = open('inspyred-individuals-file-{0}.csv'.format(time.strftime('%m%d%Y-%H%M%S')), 'w')
        args['individuals_file'] = individuals_file

    stats = inspyred.ec.analysis.fitness_statistics(population)
    worst_fit = stats['worst']
    best_fit = stats['best']
    avg_fit = stats['mean']
    med_fit = stats['median']
    std_fit = stats['std']
    
    statistics_file.write('{0}, {1}, {2}, {3}, {4}, {5}, {6}\n'.format(num_generations, len(population), worst_fit, best_fit, med_fit, avg_fit, std_fit))
    for i, p in enumerate(population):
        individuals_file.write('{0}, {1}, {2}, {3}\n'.format(num_generations, i, p.fitness, str(p.candidate)))
    statistics_file.flush()
    individuals_file.flush()
    

def archive_observer(population, num_generations, num_evaluations, args):
    """Print the current archive to the screen.
    
    This function displays the current archive of the evolutionary 
    computation to the screen. 
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
       
    """
    archive = args['_ec'].archive
    print('----------------------------------------------------------------------------')
    print('                         Archive ({0:5} individuals)'.format(len(archive)))
    print('----------------------------------------------------------------------------')
    for a in archive:
        print(a)
    print('----------------------------------------------------------------------------')

    
class EmailObserver(object):
    """Email the population statistics, individuals, and optional file observer data.
    
    This callable class allows information about the current generation
    to be emailed to a user. This is useful when dealing with computationally
    expensive optimization problems where the evolution must progress over
    hours or days. The ``generation_step`` attribute can be set to an integer
    greater than 1 to ensure that emails are only sent on generations that are
    multiples of the step size.
    
    .. note::
    
       This function makes use of the ``inspyred.ec.analysis.fitness_statistics`` 
       function, so it is subject to the same requirements.
    
    A typical instantiation of this class would be the following::
    
        import getpass
        usr = raw_input("Enter your username: ")
        pwd = getpass.getpass("Enter your password: ")
        email_observer = EmailObserver(usr, pwd, "my.mail.server")
        email_observer.from_address = "me@here.com"
        email_observer.to_address = "you@there.com" # or ["you@there.com", "other@somewhere.com"]
        email_observer.subject = "My custom subject"
        email_observer.generation_step = 10 # Send an email every 10th generation
    
    Public Attributes:
    
    - *username* -- the mail server username
    - *password* -- the mail server password
    - *server* -- the mail server URL or IP address string
    - *port* -- the mail server port as an integer
    - *from_address* -- the email address of the sender
    - *to_address* -- the (possibly list of) email address(es) of the receiver(s)
    - *subject* -- the subject of the email (default 'inspyred observer report')
    - *max_attachment* -- the maximum allowable size, in MB, of attachments
      (default 20 MB)
    - *generation_step* -- the step size for when a generation's information 
      should be emailed (default 1)
    
    """
    def __init__(self, username, password, server, port=587):
        self.username = username
        self.password = password
        self.server = server
        self.port = port
        self.generation_step = 1
        self.max_attachment = 20
        self.subject = "inspyred observer report"
        self.__name__ = self.__class__.__name__
        
    def _send_mail(self, fromaddr, toaddr, subject, text, attachments=None):
        if not isinstance(toaddr, (list, tuple)):
            toaddr = [toaddr]
        msg = email.MIMEMultipart.MIMEMultipart('related')
        msg['From'] = fromaddr
        msg['To'] = ','.join(toaddr)
        msg['Subject'] = subject
        body = email.MIMEMultipart.MIMEMultipart('alternative')
        body.attach(email.MIMEText.MIMEText(text, 'plain'))
        html = '<html><body><tt>{0}</tt></body></html>'.format(text.replace(' ', '&nbsp;').replace('\n', '<br/>'))
        body.attach(email.MIMEText.MIMEText(html, 'html'))
        msg.attach(body)
        if attachments is not None:
            if not isinstance(attachments, (list, tuple)):
                attachments = [attachments]
            for file in attachments:
                part = email.MIMEBase.MIMEBase('application', 'octet-stream')
                fp = open(file, 'rb')
                part.set_payload(fp.read())
                fp.close()
                email.Encoders.encode_base64(part)
                part.add_header('Content-Disposition', 'attachment; filename="{0}"'.format(os.path.basename(file)))
                msg.attach(part)
        mail_server = smtplib.SMTP(self.server, self.port)
        mail_server.ehlo()
        mail_server.starttls()
        mail_server.ehlo()
        mail_server.login(self.username, self.password)
        mail_server.sendmail(fromaddr, toaddr, msg.as_string())
        mail_server.quit()
        
    def __call__(self, population, num_generations, num_evaluations, args):
        if num_generations % self.generation_step == 0:
            stats = inspyred.ec.analysis.fitness_statistics(population)
            worst_fit = '{0:>10}'.format(stats['worst'])[:10]
            best_fit = '{0:>10}'.format(stats['best'])[:10]
            avg_fit = '{0:>10}'.format(stats['mean'])[:10]
            med_fit = '{0:>10}'.format(stats['median'])[:10]
            std_fit = '{0:>10}'.format(stats['std'])[:10]
            
            body = 'Generation Evaluation      Worst       Best     Median    Average    Std Dev\n'
            body += '---------- ---------- ---------- ---------- ---------- ---------- ----------\n'
            body += '{0:>10} {1:>10} {2:>10} {3:>10} {4:>10} {5:>10} {6:>10}\n'.format(num_generations, 
                                                                                       num_evaluations, 
                                                                                       worst_fit, 
                                                                                       best_fit, 
                                                                                       med_fit, 
                                                                                       avg_fit, 
                                                                                       std_fit)
            body += '----------------------------------------------------------------------------\n'
            for p in population:
                body += str(p) + '\n'
            body += '----------------------------------------------------------------------------\n'
            total_size = 0
            files = []
            stats = args.get("statistics_file", None) 
            inds = args.get("individuals_file", None)
            for file in [stats, inds]:
                if file is not None:
                    files.append(file.name)
                    total_size += os.path.getsize(file.name)
            if total_size > (self.max_attachment * 1048576):
                files = None
            self._send_mail(self.from_address, self.to_address, self.subject, body, files)    
        
        
def plot_observer(population, num_generations, num_evaluations, args):    
    """Plot the output of the evolutionary computation as a graph.
    
    This function plots the performance of the EC as a line graph 
    using the pylab library (matplotlib) and numpy. The graph consists of a 
    blue line representing the best fitness, a green line representing
    the average fitness, and a red line representing the median fitness.
    It modifies the keyword arguments variable 'args' by including an
    entry called 'plot_data'.
    
    If this observer is used, the calling script should also import
    the pylab library and should end the script with::
    
        pylab.show()
    
    Otherwise, the program may generate a runtime error.
    
    .. note::
    
       This function makes use of the pylab and numpy libraries.
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    """
    import pylab
    import numpy
    
    stats = inspyred.ec.analysis.fitness_statistics(population)
    best_fitness = stats['best']
    worst_fitness = stats['worst']
    median_fitness = stats['median']
    average_fitness = stats['mean']
    colors = ['black', 'blue', 'green', 'red']
    labels = ['average', 'median', 'best', 'worst']
    data = []
    if num_generations == 0:
        pylab.ion()
        data = [[num_evaluations], [average_fitness], [median_fitness], [best_fitness], [worst_fitness]]
        lines = []
        for i in range(4):
            line, = pylab.plot(data[0], data[i+1], color=colors[i], label=labels[i])
            lines.append(line)
        # Add the legend when the first data is added.
        pylab.legend(loc='lower right')
        args['plot_data'] = data
        args['plot_lines'] = lines
        pylab.xlabel('Evaluations')
        pylab.ylabel('Fitness')
    else:
        data = args['plot_data']
        data[0].append(num_evaluations)
        data[1].append(average_fitness)
        data[2].append(median_fitness)
        data[3].append(best_fitness)
        data[4].append(worst_fitness)
        lines = args['plot_lines']
        for i, line in enumerate(lines):
            line.set_xdata(numpy.array(data[0]))
            line.set_ydata(numpy.array(data[i+1]))
        args['plot_data'] = data
        args['plot_lines'] = lines
    ymin = min([min(d) for d in data[1:]])
    ymax = max([max(d) for d in data[1:]])
    yrange = ymax - ymin
    pylab.xlim((0, num_evaluations))
    pylab.ylim((ymin - 0.1*yrange, ymax + 0.1*yrange))
    pylab.draw()

########NEW FILE########
__FILENAME__ = replacers
"""
    ================================================
    :mod:`replacers` -- Survivor replacement methods
    ================================================
    
    This module provides pre-defined replacers for evolutionary computations.
    
    All replacer functions have the following arguments:
    
    - *random* -- the random number generator object
    - *population* -- the population of individuals
    - *parents* -- the list of parent individuals
    - *offspring* -- the list of offspring individuals
    - *args* -- a dictionary of keyword arguments
    
    Each replacer function returns the list of surviving individuals.

    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: replacers
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import math


def default_replacement(random, population, parents, offspring, args):
    """Performs no replacement, returning the original population.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments
    
    """
    return population

    
def truncation_replacement(random, population, parents, offspring, args):
    """Replaces population with the best of the population and offspring.
    
    This function performs truncation replacement, which means that
    the entire existing population is replaced by the best from among
    the current population and offspring, keeping the existing population
    size fixed. This is similar to so-called "plus" replacement in the 
    evolution strategies literature, except that "plus" replacement 
    considers only parents and offspring for survival. However, if the
    entire population are parents (which is often the case in evolution 
    strategies), then truncation replacement and plus-replacement are 
    equivalent approaches.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments
    
    """
    psize = len(population)
    population.extend(list(offspring))
    population.sort(reverse=True)
    return population[:psize]

    
def steady_state_replacement(random, population, parents, offspring, args):
    """Performs steady-state replacement for the offspring.
    
    This function performs steady-state replacement, which means that
    the offspring replace the least fit individuals in the existing
    population, even if those offspring are less fit than the individuals
    that they replace.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments
    
    """
    population.sort()
    num_to_replace = min(len(offspring), len(population))
    population[:num_to_replace] = offspring[:num_to_replace]
    return population


def generational_replacement(random, population, parents, offspring, args):
    """Performs generational replacement with optional weak elitism.
    
    This function performs generational replacement, which means that
    the entire existing population is replaced by the offspring,
    truncating to the population size if the number of offspring is 
    larger. Weak elitism may also be specified through the `num_elites`
    keyword argument in args. If this is used, the best `num_elites`
    individuals in the current population are allowed to survive if
    they are better than the worst `num_elites` offspring.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *num_elites* -- number of elites to consider (default 0)
    
    """
    num_elites = args.setdefault('num_elites', 0)
    population.sort(reverse=True)
    offspring.extend(population[:num_elites])
    offspring.sort(reverse=True)
    survivors = offspring[:len(population)]
    return survivors


def random_replacement(random, population, parents, offspring, args):
    """Performs random replacement with optional weak elitism.
    
    This function performs random replacement, which means that
    the offspring replace random members of the population, keeping
    the population size constant. Weak elitism may also be specified 
    through the `num_elites` keyword argument in args. If this is used, 
    the best `num_elites` individuals in the current population are 
    allowed to survive if they are better than the worst `num_elites`
    offspring.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *num_elites* -- number of elites to consider (default 0)
    
    """
    num_elites = args.setdefault('num_elites', 0)
    population.sort(reverse=True)
    num_to_replace = min(len(offspring), len(population) - num_elites) 
    valid_indices = range(num_elites, len(population))
    rep_index = random.sample(valid_indices, num_to_replace)
    for i, repind in enumerate(rep_index):
        population[repind] = offspring[i]
    return population


def plus_replacement(random, population, parents, offspring, args):
    """Performs "plus" replacement.
    
    This function performs "plus" replacement, which means that
    the entire existing population is replaced by the best
    population-many elements from the combined set of parents and 
    offspring. 
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments

    """
    pool = list(offspring)
    pool.extend(parents)
    pool.sort(reverse=True)
    survivors = pool[:len(population)]
    return survivors


def comma_replacement(random, population, parents, offspring, args):
    """Performs "comma" replacement.
    
    This function performs "comma" replacement, which means that
    the entire existing population is replaced by the best
    population-many elements from the offspring. This function
    makes the assumption that the size of the offspring is at 
    least as large as the original population. Otherwise, the
    population size will not be constant.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments
       
    """
    offspring.sort(reverse=True)
    survivors = offspring[:len(population)]
    return survivors


def crowding_replacement(random, population, parents, offspring, args):
    """Performs crowding replacement as a form of niching.
    
    This function performs crowding replacement, which means that
    the members of the population are replaced one-at-a-time with
    each of the offspring. A random sample of `crowding_distance`
    individuals is pulled from the current population, and the
    closest individual to the current offspring (where "closest"
    is determined by the `distance_function`) is replaced by that
    offspring, if the offspring is better. It is possible for one 
    offspring to replace an earlier offspring in the same generation, 
    given the random sample that is taken of the current survivors 
    for each offspring.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:    
    
    - *distance_function* -- a function that accepts two candidate 
      solutions and returns the distance between them (default 
      Euclidean L2 distance)
    - *crowding_distance* -- a positive integer representing the 
      number of closest solutions to consider as a "crowd" (default 2)
       
    """
    def distance(x, y):
        return math.sqrt(sum([(a - b)**2 for a, b in zip(x, y)]))
    try:
        distance_function = args['distance_function']
    except KeyError:
        distance_function = distance
        args['distance_function'] = distance_function
    crowding_distance = args.setdefault('crowding_distance', 2)
    survivors = population
    for o in offspring:
        pool = random.sample(survivors, crowding_distance)
        closest = min(pool, key=lambda x: distance_function(o.candidate, x.candidate))
        if o > closest:
            survivors.remove(closest)
            survivors.append(o)
    return survivors



    
#-------------------------------------------
# Algorithm-specific Replacement Strategies
#-------------------------------------------
    
def simulated_annealing_replacement(random, population, parents, offspring, args):
    """Replaces population using the simulated annealing schedule.
    
    This function performs simulated annealing replacement based
    on a temperature and a cooling rate. These can be specified
    by the keyword arguments `temperature`, which should be the
    initial temperature, and `cooling_rate`, which should be the
    coefficient by which the temperature is reduced. If these
    keyword arguments are not present, then the function will
    attempt to base the cooling schedule either on the ratio of 
    evaluations to the maximum allowed evaluations or on the 
    ratio of generations to the maximum allowed generations. 
    Each of these ratios is of the form ``(max - current)/max``
    so that the cooling schedule moves smoothly from 1 to 0.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments
    
    Optional keyword arguments in args:    
    
    - *temperature* -- the initial temperature
    - *cooling_rate* -- a real-valued coefficient in the range (0, 1) 
      by which the temperature should be reduced 
    
    """
    try:
        temp = args['temperature']
        cooling_rate = args['cooling_rate']
        temp = temp * cooling_rate
        args['temperature'] = temp
    except KeyError:
        try:
            num_evals = args['_ec'].num_evaluations
            max_evals = args['max_evaluations']
            temp = float(max_evals - num_evals) / float(max_evals)
        except KeyError:
            num_gens = args['_ec'].num_generations
            max_gens = args['max_generations']
            temp = 1 - float(max_gens - num_gens) / float(max_gens)
        
    new_pop = []
    for p, o in zip(parents, offspring):
        if o >= p:
            new_pop.append(o)
        elif temp > 0 and random.random() < math.exp(-abs(p.fitness - o.fitness) / float(temp)):
            new_pop.append(o)
        else:
            new_pop.append(p)
            
    return new_pop

    
def nsga_replacement(random, population, parents, offspring, args):
    """Replaces population using the non-dominated sorting technique from NSGA-II.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments
    
    """
    survivors = []
    combined = list(population)
    combined.extend(offspring)
    
    # Perform the non-dominated sorting to determine the fronts.
    fronts = []
    pop = set(range(len(combined)))
    while len(pop) > 0:
        front = []
        for p in pop:
            dominated = False
            for q in pop:
                if combined[p] < combined[q]:
                    dominated = True
                    break
            if not dominated:
                front.append(p)
        fronts.append([dict(individual=combined[f], index=f) for f in front])
        pop = pop - set(front)
    
    # Go through each front and add all the elements until doing so
    # would put you above the population limit. At that point, fall
    # back to the crowding distance to determine who to put into the
    # next population. Individuals with higher crowding distances
    # (i.e., more distance between neighbors) are preferred.
    for i, front in enumerate(fronts):
        if len(survivors) + len(front) > len(population):
            # Determine the crowding distance.
            distance = [0 for _ in range(len(combined))]
            individuals = list(front)
            num_individuals = len(individuals)
            num_objectives = len(individuals[0]['individual'].fitness)
            for obj in range(num_objectives):
                individuals.sort(key=lambda x: x['individual'].fitness[obj])
                distance[individuals[0]['index']] = float('inf')
                distance[individuals[-1]['index']] = float('inf')
                for i in range(1, num_individuals-1):
                    distance[individuals[i]['index']] = (distance[individuals[i]['index']] + 
                                                         (individuals[i+1]['individual'].fitness[obj] - 
                                                          individuals[i-1]['individual'].fitness[obj]))
                
            crowd = [dict(dist=distance[f['index']], index=f['index']) for f in front]
            crowd.sort(key=lambda x: x['dist'], reverse=True)
            last_rank = [combined[c['index']] for c in crowd]
            r = 0
            num_added = 0
            num_left_to_add = len(population) - len(survivors)
            while r < len(last_rank) and num_added < num_left_to_add:
                if last_rank[r] not in survivors:
                    survivors.append(last_rank[r])
                    num_added += 1
                r += 1
            # If we've filled out our survivor list, then stop.
            # Otherwise, process the next front in the list.
            if len(survivors) == len(population):
                break
        else:
            for f in front:
                if f['individual'] not in survivors:
                    survivors.append(f['individual'])
    return survivors

    
def paes_replacement(random, population, parents, offspring, args):
    """Replaces population using the Pareto Archived Evolution Strategy method.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       parents -- the list of parent individuals
       offspring -- the list of offspring individuals
       args -- a dictionary of keyword arguments
    
    """
    archive = args['_ec'].archive
    archiver = args['_ec'].archiver
        
    survivors = []
    for p, o in zip(parents, offspring):
        if o == p:
            survivors.append(p)
        elif o in archive:
            survivors.append(p)
        elif o > p:
            archive = archiver(random, [o], archive, args)
            survivors.append(o)
        elif o >= p:
            for a in archive:
                if o > a or o < a:
                    break
            if o >= a:
                archive = archiver(random, [o], archive, args)
                if o > a or archiver.grid_population[o.grid_location] <= archiver.grid_population[p.grid_location]:
                    survivors.append(o)
                else:
                    survivors.append(p)
            else:
                survivors.append(p)
        else:
            survivors.append(p)
    return survivors

########NEW FILE########
__FILENAME__ = selectors
"""
    ============================================
    :mod:`selectors` -- Parent selection methods
    ============================================
    
    This module provides pre-defined selectors for evolutionary computations.

    All selector functions have the following arguments:
    
    - *random* -- the random number generator object
    - *population* -- the population of individuals
    - *args* -- a dictionary of keyword arguments
    
    Each selector function returns the list of selected individuals.

    .. note::
    
       The *population* is really a shallow copy of the actual population of
       the evolutionary computation. This means that any activities like
       sorting will not affect the actual population.
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: selectors
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""


def default_selection(random, population, args):
    """Return the population.
    
    This function acts as a default selection scheme for an evolutionary
    computation. It simply returns the entire population as having been 
    selected.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       args -- a dictionary of keyword arguments
    
    """
    return population


def truncation_selection(random, population, args):
    """Selects the best individuals from the population.
    
    This function performs truncation selection, which means that only
    the best individuals from the current population are selected. This
    is a completely deterministic selection mechanism.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *num_selected* -- the number of individuals to be selected 
      (default len(population))
    
    """
    num_selected = args.setdefault('num_selected', len(population))
    population.sort(reverse=True)
    return population[:num_selected]

    
def uniform_selection(random, population, args):
    """Return a uniform sampling of individuals from the population.
    
    This function performs uniform selection by randomly choosing
    members of the population with replacement.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *num_selected* -- the number of individuals to be selected 
      (default 1)
    
    """
    num_selected = args.setdefault('num_selected', 1)
    selected = []
    for _ in range(num_selected):
        selected.append(population[random.randint(0, len(population)-1)])
    return selected


def fitness_proportionate_selection(random, population, args):
    """Return fitness proportionate sampling of individuals from the population.
    
    This function stochastically chooses individuals from the population
    with probability proportional to their fitness. This is often 
    referred to as "roulette wheel" selection. Note that this selection
    is not valid for minimization problems.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *num_selected* -- the number of individuals to be selected (default 1)
    
    """
    num_selected = args.setdefault('num_selected', 1)
    len_pop = len(population)
    psum = [i for i in range(len_pop)]
    pop_max_fit = (max(population)).fitness
    pop_min_fit = (min(population)).fitness
    
    # If we're actually doing minimimization,
    # fitness proportionate selection is not defined.
    if pop_max_fit < pop_min_fit:
        raise ValueError('Fitness proportionate selection is not valid for minimization.')
    
    # Set up the roulette wheel
    if pop_max_fit == pop_min_fit:
        psum = [(index + 1) / float(len_pop) for index in range(len_pop)]
    elif (pop_max_fit > 0 and pop_min_fit >= 0) or (pop_max_fit <= 0 and pop_min_fit < 0):
        population.sort(reverse=True)
        psum[0] = population[0].fitness
        for i in range(1, len_pop):
            psum[i] = population[i].fitness + psum[i-1]
        for i in range(len_pop):
            psum[i] /= float(psum[len_pop-1])
            
    # Select the individuals
    selected = []
    for _ in range(num_selected):
        cutoff = random.random()
        lower = 0
        upper = len_pop - 1
        while(upper >= lower):
            mid = (lower + upper) // 2
            if psum[mid] > cutoff: 
                upper = mid - 1
            else: 
                lower = mid + 1
        lower = max(0, min(len_pop-1, lower))
        selected.append(population[lower])
    return selected


def rank_selection(random, population, args):
    """Return a rank-based sampling of individuals from the population.
    
    This function behaves similarly to fitness proportionate selection,
    except that it uses the individual's rank in the population, rather
    than its raw fitness value, to determine its probability. This
    means that it can be used for both maximization and minimization 
    problems, since higher rank can be defined correctly for both.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *num_selected* -- the number of individuals to be selected (default 1)
    
    """
    num_selected = args.setdefault('num_selected', 1)

    # Set up the roulette wheel
    len_pop = len(population)
    population.sort()
    psum = list(range(len_pop))
    den = (len_pop * (len_pop + 1)) / 2.0
    for i in range(len_pop):
        psum[i] = (i + 1) / den
    for i in range(1, len_pop):
        psum[i] += psum[i-1]
        
    # Select the individuals
    selected = []
    for _ in range(num_selected):
        cutoff = random.random()
        lower = 0
        upper = len_pop - 1
        while(upper >= lower):
            mid = (lower + upper) // 2
            if psum[mid] > cutoff: 
                upper = mid - 1
            else: 
                lower = mid + 1
        lower = max(0, min(len_pop-1, lower))
        selected.append(population[lower])
    return selected


def tournament_selection(random, population, args):
    """Return a tournament sampling of individuals from the population.
    
    This function selects ``num_selected`` individuals from the population. 
    It selects each one by using random sampling without replacement
    to pull ``tournament_size`` individuals and adds the best of the
    tournament as its selection. If ``tournament_size`` is greater than
    the population size, the population size is used instead as the size
    of the tournament.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of individuals
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *num_selected* -- the number of individuals to be selected (default 1)
    - *tournament_size* -- the tournament size (default 2)
    
    """
    num_selected = args.setdefault('num_selected', 1)
    tournament_size = args.setdefault('tournament_size', 2)
    if tournament_size > len(population):
        tournament_size = len(population)
    selected = []
    for _ in range(num_selected):
        tourn = random.sample(population, tournament_size)
        selected.append(max(tourn))
    return selected



########NEW FILE########
__FILENAME__ = terminators
"""
    ===================================================
    :mod:`terminators` -- Algorithm termination methods
    ===================================================
    
    This module provides pre-defined terminators for evolutionary computations.
    
    Terminators specify when the evolutionary process should end. All 
    terminators must return a Boolean value where True implies that 
    the evolution should end. 
    
    All terminator functions have the following arguments:
    
    - *population* -- the population of Individuals
    - *num_generations* -- the number of elapsed generations
    - *num_evaluations* -- the number of candidate solution evaluations
    - *args* -- a dictionary of keyword arguments
    
    .. note::
    
       The *population* is really a shallow copy of the actual population of
       the evolutionary computation. This means that any activities like
       sorting will not affect the actual population.    
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: terminators
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import itertools
import math
import sys
import time


def default_termination(population, num_generations, num_evaluations, args):
    """Return True.
    
    This function acts as a default termination criterion for an evolutionary computation.
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    """
    return True
    

def diversity_termination(population, num_generations, num_evaluations, args):
    """Return True if population diversity is less than a minimum diversity.
    
    This function calculates the Euclidean distance between every pair of
    individuals in the population. It then compares the maximum of those
    distances with a specified minimum required diversity. This terminator 
    is really only well-defined for candidate solutions which are list 
    types of numeric values. 
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    Optional keyword arguments in args:
    
    - *min_diversity* -- the minimum population diversity allowed (default 0.001)
    
    """
    min_diversity = args.setdefault('min_diversity', 0.001)
    cart_prod = itertools.product(population, population)
    distance = []
    for (p, q) in cart_prod:
        d = 0
        for x, y in zip(p.candidate, q.candidate):
            d += (x - y)**2
        distance.append(math.sqrt(d))
    return max(distance) < min_diversity

    
def average_fitness_termination(population, num_generations, num_evaluations, args):
    """Return True if the population's average fitness is near its best fitness.
    
    This function calculates the average fitness of the population, as well
    as the best fitness. If the difference between those values is less 
    than a specified tolerance, the function returns True. 
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    Optional keyword arguments in args:
    
    - *tolerance* -- the minimum allowable difference between average 
      and best fitness (default 0.001)
    
    """
    tolerance = args.setdefault('tolerance', 0.001)
    avg_fit = sum([x.fitness for x in population]) / float(len(population))
    best_fit = max([x.fitness for x in population])
    return (best_fit - avg_fit) < tolerance


def evaluation_termination(population, num_generations, num_evaluations, args):
    """Return True if the number of function evaluations meets or exceeds a maximum.
    
    This function compares the number of function evaluations that have been 
    generated with a specified maximum. It returns True if the maximum is met
    or exceeded.
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    Optional keyword arguments in args:
    
    - *max_evaluations* -- the maximum candidate solution evaluations (default 
      len(population)) 
    
    """
    max_evaluations = args.setdefault('max_evaluations', len(population))
    return num_evaluations >= max_evaluations


def generation_termination(population, num_generations, num_evaluations, args):
    """Return True if the number of generations meets or exceeds a maximum.
    
    This function compares the number of generations with a specified 
    maximum. It returns True if the maximum is met or exceeded.
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    Optional keyword arguments in args:
    
    - *max_generations* -- the maximum generations (default 1) 
    
    """
    max_generations = args.setdefault('max_generations', 1)
    return num_generations >= max_generations

    
def time_termination(population, num_generations, num_evaluations, args):
    """Return True if the elapsed time meets or exceeds a duration of time.
    
    This function compares the elapsed time with a specified maximum. 
    It returns True if the maximum is met or exceeded. If the `start_time`
    keyword argument is omitted, it defaults to `None` and will be set to
    the current system time (in seconds). If the `max_time` keyword argument
    is omitted, it will default to `None` and will immediately terminate.
    The `max_time` argument can be specified in seconds as a floating-point
    number, as minutes/seconds as a two-element tuple of floating-point
    numbers, or as hours/minutes/seconds as a three-element tuple of 
    floating-point numbers.
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    Optional keyword arguments in args:
    
    - *start_time* -- the time from which to start measuring (default None)
    - *max_time* -- the maximum time that should elapse (default None)
    
    """
    start_time = args.setdefault('start_time', None)
    max_time = args.setdefault('max_time', None)
    logging = args.get('_ec').logger

    if start_time is None:
        start_time = time.time()
        args['start_time'] = start_time
        logging.debug('time_termination terminator added without setting the start_time argument; setting start_time to current time')
    if max_time is None:
        logging.debug('time_termination terminator added without setting the max_time argument; terminator will immediately terminate')
    else:
        try:
            max_time = max_time[0] * 3600.0 + max_time[1] * 60.00 + max_time[2]
            args['max_time'] = max_time
        except TypeError:
            pass
        except IndexError:
            max_time = max_time[0] * 60 + max_time[1]
            args['max_time'] = max_time
    time_elapsed = time.time() - start_time
    return max_time is None or time_elapsed >= max_time


def user_termination(population, num_generations, num_evaluations, args):
    """Return True if user presses the ESC key when prompted.
    
    This function prompts the user to press the ESC key to terminate the 
    evolution. The prompt persists for a specified number of seconds before
    evolution continues. Additionally, the function can be customized to 
    allow any press of the ESC key to be stored until the next time this 
    function is called. 
    
    .. note::
    
       This function makes use of the ``msvcrt`` (Windows) and ``curses`` 
       (Unix) libraries. Other systems may not be supported.
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    Optional keyword arguments in args:
    
    - *termination_response_timeout* -- the number of seconds to wait for 
      the user to press the ESC key (default 5)
    - *clear_termination_buffer* -- whether the keyboard buffer should be 
      cleared before allowing the user to press a key (default True)
    
    """
    def getch():
        unix = ('darwin', 'linux2')
        if sys.platform not in unix:
            try:
                import msvcrt
            except ImportError:
                return -1
            if msvcrt.kbhit():
                return msvcrt.getch()
            else:
                return -1
        elif sys.platform in unix:
            def _getch(stdscr):
                stdscr.nodelay(1)
                ch = stdscr.getch()
                stdscr.nodelay(0)
                return ch
            import curses
            return curses.wrapper(_getch)
    
    num_secs = args.get('termination_response_timeout', 5)
    clear_buffer = args.get('clear_termination_buffer', True)
    if clear_buffer:
        while getch() > -1:
            pass
    sys.stdout.write('Press ESC to terminate (%d secs):' % num_secs)
    count = 1
    start = time.time()
    while time.time() - start < num_secs:
        ch = getch()
        if ch > -1 and ord(ch) == 27:
            sys.stdout.write('\n\n')
            return True
        elif time.time() - start == count:
            sys.stdout.write('.')
            count += 1
    sys.stdout.write('\n')
    return False    

    
def no_improvement_termination(population, num_generations, num_evaluations, args):
    """Return True if the best fitness does not change for a number of generations.
    
    This function keeps track of the current best fitness and compares it to
    the best fitness in previous generations. Whenever those values are the 
    same, it begins a generation count. If that count exceeds a specified 
    number, the terminator returns True.
    
    .. Arguments:
       population -- the population of Individuals
       num_generations -- the number of elapsed generations
       num_evaluations -- the number of candidate solution evaluations
       args -- a dictionary of keyword arguments
    
    Optional keyword arguments in args:
    
    - *max_generations* -- the number of generations allowed for no change in fitness (default 10)
    
    """
    max_generations = args.setdefault('max_generations', 10)
    previous_best = args.setdefault('previous_best', None)
    current_best = max(population).fitness
    if previous_best is None or previous_best != current_best:
        args['previous_best'] = current_best
        args['generation_count'] = 0
        return False
    else:
        if args['generation_count'] >= max_generations:
            return True
        else:
            args['generation_count'] += 1
            return False
########NEW FILE########
__FILENAME__ = utilities
"""
    ==================================================
    :mod:`utilities` -- Optimization utility functions
    ==================================================
    
    This module provides utility classes and decorators for evolutionary computations.

    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: utilities
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import collections
import functools
import multiprocessing
try:
    import cPickle as pickle
except ImportError:
    import pickle


try:
    from collections import OrderedDict as OrderedDict
except ImportError:
    # http://code.activestate.com/recipes/576693/ (r9)
    # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
    # Passes Python2.7's test suite and incorporates all the latest updates.

    try:
        from thread import get_ident as _get_ident
    except ImportError:
        from dummy_thread import get_ident as _get_ident
    try:
        from _abcoll import KeysView, ValuesView, ItemsView
    except ImportError:
        pass

    class OrderedDict(dict):
        def __init__(self, *args, **kwds):
            if len(args) > 1:
                raise TypeError('expected at most 1 arguments, got %d' % len(args))
            try:
                self.__root
            except AttributeError:
                self.__root = root = []                     # sentinel node
                root[:] = [root, root, None]
                self.__map = {}
            self.__update(*args, **kwds)

        def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
            if key not in self:
                root = self.__root
                last = root[0]
                last[1] = root[0] = self.__map[key] = [last, root, key]
            dict_setitem(self, key, value)

        def __delitem__(self, key, dict_delitem=dict.__delitem__):
            dict_delitem(self, key)
            link_prev, link_next, key = self.__map.pop(key)
            link_prev[1] = link_next
            link_next[0] = link_prev

        def __iter__(self):
            root = self.__root
            curr = root[1]
            while curr is not root:
                yield curr[2]
                curr = curr[1]

        def __reversed__(self):
            root = self.__root
            curr = root[0]
            while curr is not root:
                yield curr[2]
                curr = curr[0]

        def clear(self):
            try:
                for node in self.__map.itervalues():
                    del node[:]
                root = self.__root
                root[:] = [root, root, None]
                self.__map.clear()
            except AttributeError:
                pass
            dict.clear(self)

        def popitem(self, last=True):
            if not self:
                raise KeyError('dictionary is empty')
            root = self.__root
            if last:
                link = root[0]
                link_prev = link[0]
                link_prev[1] = root
                root[0] = link_prev
            else:
                link = root[1]
                link_next = link[1]
                root[1] = link_next
                link_next[0] = root
            key = link[2]
            del self.__map[key]
            value = dict.pop(self, key)
            return key, value

        def keys(self):
            return list(self)

        def values(self):
            return [self[key] for key in self]

        def items(self):
            return [(key, self[key]) for key in self]

        def iterkeys(self):
            return iter(self)

        def itervalues(self):
            for k in self:
                yield self[k]

        def iteritems(self):
            for k in self:
                yield (k, self[k])

        def update(*args, **kwds):
            if len(args) > 2:
                raise TypeError('update() takes at most 2 positional '
                                'arguments (%d given)' % (len(args),))
            elif not args:
                raise TypeError('update() takes at least 1 argument (0 given)')
            self = args[0]
            other = ()
            if len(args) == 2:
                other = args[1]
            if isinstance(other, dict):
                for key in other:
                    self[key] = other[key]
            elif hasattr(other, 'keys'):
                for key in other.keys():
                    self[key] = other[key]
            else:
                for key, value in other:
                    self[key] = value
            for key, value in kwds.items():
                self[key] = value

        __update = update
        __marker = object()

        def pop(self, key, default=__marker):
            if key in self:
                result = self[key]
                del self[key]
                return result
            if default is self.__marker:
                raise KeyError(key)
            return default

        def setdefault(self, key, default=None):
            if key in self:
                return self[key]
            self[key] = default
            return default

        def __repr__(self, _repr_running={}):
            call_key = id(self), _get_ident()
            if call_key in _repr_running:
                return '...'
            _repr_running[call_key] = 1
            try:
                if not self:
                    return '%s()' % (self.__class__.__name__,)
                return '%s(%r)' % (self.__class__.__name__, self.items())
            finally:
                del _repr_running[call_key]

        def __reduce__(self):
            items = [[k, self[k]] for k in self]
            inst_dict = vars(self).copy()
            for k in vars(OrderedDict()):
                inst_dict.pop(k, None)
            if inst_dict:
                return (self.__class__, (items,), inst_dict)
            return self.__class__, (items,)

        def copy(self):
            return self.__class__(self)

        @classmethod
        def fromkeys(cls, iterable, value=None):
            d = cls()
            for key in iterable:
                d[key] = value
            return d

        def __eq__(self, other):
            if isinstance(other, OrderedDict):
                return len(self)==len(other) and self.items() == other.items()
            return dict.__eq__(self, other)

        def __ne__(self, other):
            return not self == other

        def viewkeys(self):
            return KeysView(self)

        def viewvalues(self):
            return ValuesView(self)

        def viewitems(self):
            return ItemsView(self)

    
class BoundedOrderedDict(OrderedDict):
    def __init__(self, *args, **kwds):
        self._lock = multiprocessing.Lock()
        self.maxlen = kwds.pop("maxlen", None)
        OrderedDict.__init__(self, *args, **kwds)
        self._checklen()

    def __setitem__(self, key, value):
        with self._lock:
            OrderedDict.__setitem__(self, key, value)
            self._checklen()

    def _checklen(self):
        if self.maxlen is not None:
            while len(self) > self.maxlen:
                self.popitem(last=False)


def memoize(func=None, maxlen=None):
    """Cache a function's return value each time it is called.
    
    This function serves as a function decorator to provide a caching of
    evaluated fitness values. If called later with the same arguments, 
    the cached value is returned instead of being re-evaluated.
    
    This decorator assumes that candidates are individually pickleable, 
    and their pickled values are used for hashing into a dictionary. It 
    should be used when evaluating an *expensive* fitness 
    function to avoid costly re-evaluation of those fitnesses. The 
    typical usage is as follows::
    
        @memoize
        def expensive_fitness_function(candidates, args):
            # Implementation of expensive fitness calculation
            pass
            
    It is also possible to provide the named argument *maxlen*, which
    specifies the size of the memoization cache to use. (If *maxlen* is
    ``None``, then an unbounded cache is used.) Once the size of the cache 
    has reached *maxlen*, the oldest element is replaced by the newest
    element in order to keep the size constant. This usage is as follows::
    
        @memoize(maxlen=100)
        def expensive_fitness_function(candidates, args):
            # Implementation of expensive fitness calculation
            pass
            
    .. warning:: The ``maxlen`` parameter must be passed as a named keyword
       argument, or an ``AttributeError`` will be raised (e.g., saying 
       ``@memoize(100)`` will cause an error).
    
    """
    if func is not None:
        cache = BoundedOrderedDict(maxlen=maxlen)
        @functools.wraps(func)
        def memo_target(candidates, args):
            fitness = []
            for candidate in candidates:
                lookup_value = pickle.dumps(candidate, 1)
                if lookup_value not in cache:
                    cache[lookup_value] = func([candidate], args)[0]
                fitness.append(cache[lookup_value])
            return fitness
        return memo_target
    else:
        def memoize_factory(func):
            return memoize(func, maxlen=maxlen)
        return memoize_factory


class Objectify(object):
    """Create an "objectified" version of a function.
    
    This function allows an ordinary function passed to it to 
    become essentially a callable instance of a class. For inspyred, 
    this means that evolutionary operators (selectors, variators,
    replacers, etc.) can be created as normal functions and then
    be given the ability to have attributes *that are specific to
    the object*. Python functions can always have attributes without
    employing any special mechanism, but those attributes exist for the 
    function, and there is no way to create a new "object" except
    by implementing a new function with the same functionality.
    This class provides a way to "objectify" the same function
    multiple times in order to provide each "object" with its own
    set of independent attributes.
    
    The attributes that are created on an objectified function are
    passed into that function via the ubiquitous ``args`` variable
    in inspyred. Any user-specified attributes are added to the 
    ``args`` dictionary and replace any existing entry if necessary.
    If the function modifies those entries in the dictionary (e.g.,
    when dynamically modifying parameters), the corresponding 
    attributes are modified as well.
    
    Essentially, a local copy of the ``args`` dictionary is created
    into which the attributes are inserted. This modified local copy 
    is then passed to the function. After the function returns, the
    values of the attributes from the dictionary are retrieved and 
    are used to update the class attributes.
    
    The typical usage is as follows::
    
        def typical_function(*args, **kwargs):
            # Implementation of typical function
            pass
        
        fun_one = Objectify(typical_function)
        fun_two = Objectify(typical_function)
        fun_one.attribute = value_one
        fun_two.attribute = value_two
    
    """
    def __init__(self, func):
        self.func = func
        try:
            functools.update_wrapper(self, func)
        except:
            pass
        
    def __call__(self, *args, **kwargs):
        params = vars(self)
        try:
            orig_args = dict(kwargs['args'])
            orig_args.update(params)
            newkwargs = dict(kwargs)
            newkwargs['args'] = orig_args
            newargs = args
        except KeyError:
            orig_args = dict(args[-1])
            orig_args.update(params)
            newargs = list(args[:-1])
            newargs.append(orig_args)
            newargs = tuple(newargs)
            newkwargs = kwargs
        return_value = self.func(*newargs, **newkwargs)
        try:
            for key in newkwargs['args']:
                if key in params:
                    setattr(self, key, newkwargs['args'][key])
        except KeyError:
            for key in newargs[-1]:
                if key in params:
                    setattr(self, key, newargs[-1][key])
        return return_value

########NEW FILE########
__FILENAME__ = crossovers
"""
    =================
    :mod:`crossovers`
    =================
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: crossovers
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import copy
import functools
import math
try:
    import cPickle as pickle
except ImportError:
    import pickle


def crossover(cross):
    """Return an inspyred crossover function based on the given function.

    This function generator takes a function that operates on only
    two parent candidates to produce an iterable sequence of offspring
    (typically two). The generator handles the pairing of selected
    parents and collecting of all offspring.

    The generated function chooses every odd candidate as a 'mom' and
    every even as a 'dad' (discounting the last candidate if there is
    an odd number). For each mom-dad pair, offspring are produced via
    the `cross` function.

    The given function ``cross`` must have the following signature::

        offspring = cross(random, mom, dad, args)

    This function is most commonly used as a function decorator with
    the following usage::

        @crossover
        def cross(random, mom, dad, args):
            # Implementation of paired crossing
            pass

    The generated function also contains an attribute named
    ``single_crossover`` which holds the original crossover function.
    In this way, the original single-set-of-parents function can be
    retrieved if necessary.

    """
    @functools.wraps(cross)
    def ecspy_crossover(random, candidates, args):
        if len(candidates) % 2 == 1:
            candidates = candidates[:-1]
        moms = candidates[::2]
        dads = candidates[1::2]
        children = []
        for i, (mom, dad) in enumerate(zip(moms, dads)):
            cross.index = i
            offspring = cross(random, mom, dad, args)
            for o in offspring:
                children.append(o)
        return children
    ecspy_crossover.single_crossover = cross
    return ecspy_crossover


@crossover
def n_point_crossover(random, mom, dad, args):
    """Return the offspring of n-point crossover on the candidates.

    This function performs n-point crossover (NPX). It selects *n* 
    random points without replacement at which to 'cut' the candidate 
    solutions and recombine them.

    .. Arguments:
       random -- the random number generator object
       mom -- the first parent candidate
       dad -- the second parent candidate
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)
    - *num_crossover_points* -- the number of crossover points used (default 1)
    
    """
    crossover_rate = args.setdefault('crossover_rate', 1.0)
    num_crossover_points = args.setdefault('num_crossover_points', 1)
    children = []
    if random.random() < crossover_rate:
        num_cuts = min(len(mom)-1, num_crossover_points)
        cut_points = random.sample(range(1, len(mom)), num_cuts)
        cut_points.sort()
        bro = copy.copy(dad)
        sis = copy.copy(mom)
        normal = True
        for i, (m, d) in enumerate(zip(mom, dad)):
            if i in cut_points:
                normal = not normal
            if not normal:
                bro[i] = m
                sis[i] = d
        children.append(bro)
        children.append(sis)
    else:
        children.append(mom)
        children.append(dad)
    return children


@crossover
def uniform_crossover(random, mom, dad, args):
    """Return the offspring of uniform crossover on the candidates.

    This function performs uniform crossover (UX). For each element 
    of the parents, a biased coin is flipped to determine whether 
    the first offspring gets the 'mom' or the 'dad' element. An 
    optional keyword argument in args, ``ux_bias``, determines the bias.

    .. Arguments:
       random -- the random number generator object
       mom -- the first parent candidate
       dad -- the second parent candidate
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)
    - *ux_bias* -- the bias toward the first candidate in the crossover 
      (default 0.5)
    
    """
    ux_bias = args.setdefault('ux_bias', 0.5)
    crossover_rate = args.setdefault('crossover_rate', 1.0)
    children = []
    if random.random() < crossover_rate:
        bro = copy.copy(dad)
        sis = copy.copy(mom)
        for i, (m, d) in enumerate(zip(mom, dad)):
            if random.random() < ux_bias:
                bro[i] = m
                sis[i] = d
        children.append(bro)
        children.append(sis)
    else:
        children.append(mom)
        children.append(dad)
    return children


@crossover
def partially_matched_crossover(random, mom, dad, args):
    """Return the offspring of partially matched crossover on the candidates.

    This function performs partially matched crossover (PMX). This type of
    crossover assumes that candidates are composed of discrete values that
    are permutations of a given set (typically integers). It produces offspring
    that are themselves permutations of the set.

    .. Arguments:
       random -- the random number generator object
       mom -- the first parent candidate
       dad -- the second parent candidate
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)

    """
    crossover_rate = args.setdefault('crossover_rate', 1.0)
    if random.random() < crossover_rate:
        size = len(mom)
        points = random.sample(range(size), 2)
        x, y = min(points), max(points)
        bro = copy.copy(dad)
        bro[x:y+1] = mom[x:y+1]
        sis = copy.copy(mom)
        sis[x:y+1] = dad[x:y+1]
        for parent, child in zip([dad, mom], [bro, sis]):
            for i in range(x, y+1):
                if parent[i] not in child[x:y+1]:
                    spot = i
                    while x <= spot <= y:
                        spot = parent.index(child[spot])
                    child[spot] = parent[i]
        return [bro, sis]
    else:
        return [mom, dad]


@crossover
def arithmetic_crossover(random, mom, dad, args):
    """Return the offspring of arithmetic crossover on the candidates.

    This function performs arithmetic crossover (AX), which is similar to a 
    generalized weighted averaging of the candidate elements. The allele
    of each parent is weighted by the *ax_alpha* keyword argument, and
    the allele of the complement parent is weighted by 1 - *ax_alpha*.
    This averaging is only done on the alleles listed in the *ax_points*
    keyword argument. If this argument is ``None``, then all alleles
    are used. This means that if this function is used with all default
    values, then offspring are simple averages of their parents.
    This function also makes use of the bounder function as specified 
    in the EC's ``evolve`` method.

    .. Arguments:
       random -- the random number generator object
       mom -- the first parent candidate
       dad -- the second parent candidate
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)
    - *ax_alpha* -- the weight for the averaging (default 0.5)
    - *ax_points* -- a list of points specifying the alleles to
      recombine (default None)
    
    """
    ax_alpha = args.setdefault('ax_alpha', 0.5)
    ax_points = args.setdefault('ax_points', None)
    crossover_rate = args.setdefault('crossover_rate', 1.0)
    bounder = args['_ec'].bounder
    children = []
    if random.random() < crossover_rate:
        bro = copy.copy(dad)
        sis = copy.copy(mom)
        if ax_points is None:
            ax_points = list(range(min(len(bro), len(sis))))
        for i in ax_points:
            bro[i] = ax_alpha * mom[i] + (1 - ax_alpha) * dad[i]
            sis[i] = ax_alpha * dad[i] + (1 - ax_alpha) * mom[i]
        bro = bounder(bro, args)
        sis = bounder(sis, args)
        children.append(bro)
        children.append(sis)
    else:
        children.append(mom)
        children.append(dad)
    return children
    
    
@crossover
def blend_crossover(random, mom, dad, args):
    """Return the offspring of blend crossover on the candidates.

    This function performs blend crossover (BLX), which is similar to 
    arithmetic crossover with a bit of mutation. It creates offspring
    whose values are chosen randomly from a range bounded by the
    parent alleles but that is also extended by some amount proportional
    to the *blx_alpha* keyword argument. It is this extension of the
    range that provides the additional exploration. This averaging is 
    only done on the alleles listed in the *blx_points* keyword argument. 
    If this argument is ``None``, then all alleles are used. This function 
    also makes use of the bounder function as specified in the EC's 
    ``evolve`` method.

    .. Arguments:
       random -- the random number generator object
       mom -- the first parent candidate
       dad -- the second parent candidate
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)
    - *blx_alpha* -- the blending rate (default 0.1)
    - *blx_points* -- a list of points specifying the alleles to
      recombine (default None)
    
    """
    blx_alpha = args.setdefault('blx_alpha', 0.1)
    blx_points = args.setdefault('blx_points', None)
    crossover_rate = args.setdefault('crossover_rate', 1.0)
    bounder = args['_ec'].bounder
    children = []
    if random.random() < crossover_rate:
        bro = copy.copy(dad)
        sis = copy.copy(mom)
        if blx_points is None:
            blx_points = list(range(min(len(bro), len(sis))))
        for i in blx_points:
            smallest, largest = min(mom[i], dad[i]), max(mom[i], dad[i])
            delta = blx_alpha * (largest - smallest)
            bro[i] = smallest - delta + random.random() * (largest - smallest + 2 * delta)
            sis[i] = smallest - delta + random.random() * (largest - smallest + 2 * delta)
        bro = bounder(bro, args)
        sis = bounder(sis, args)
        children.append(bro)
        children.append(sis)
    else:
        children.append(mom)
        children.append(dad)
    return children    
    
    
def heuristic_crossover(random, candidates, args):
    """Return the offspring of heuristic crossover on the candidates.

    It performs heuristic crossover (HX), which is similar to the 
    update rule used in particle swarm optimization. This function 
    also makes use of the bounder function as specified in the EC's 
    ``evolve`` method.

    .. note::
    
       This function assumes that candidates can be pickled (for hashing 
       as keys to a dictionary).

    .. Arguments:
       random -- the random number generator object
       candidates -- the candidate solutions
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)
    
    """
    crossover_rate = args.setdefault('crossover_rate', 1.0)
    bounder = args['_ec'].bounder
        
    if len(candidates) % 2 == 1:
        candidates = candidates[:-1]
        
    # Since we don't have fitness information in the candidates, we need 
    # to make a dictionary containing the candidate and its corresponding 
    # individual in the population.
    population = list(args['_ec'].population)
    lookup = dict(zip([pickle.dumps(p.candidate, 1) for p in population], population))
    
    moms = candidates[::2]
    dads = candidates[1::2]
    children = []
    for mom, dad in zip(moms, dads):
        if random.random() < crossover_rate:
            bro = copy.copy(dad)
            sis = copy.copy(mom)
            mom_is_better = lookup[pickle.dumps(mom, 1)] > lookup[pickle.dumps(dad, 1)]
            for i, (m, d) in enumerate(zip(mom, dad)):
                negpos = 1 if mom_is_better else -1
                val = d if mom_is_better else m
                bro[i] = val + random.random() * negpos * (m - d)
                sis[i] = val + random.random() * negpos * (m - d)
            bro = bounder(bro, args)
            sis = bounder(sis, args)
            children.append(bro)
            children.append(sis)
        else:
            children.append(mom)
            children.append(dad)
    return children
    

@crossover
def simulated_binary_crossover(random, mom, dad, args):
    """Return the offspring of simulated binary crossover on the candidates.
    
    This function performs simulated binary crossover (SBX), following the 
    implementation in NSGA-II 
    `(Deb et al., ICANNGA 1999) <http://vision.ucsd.edu/~sagarwal/icannga.pdf>`_.
 
    .. Arguments:
       random -- the random number generator object
       mom -- the first parent candidate
       dad -- the second parent candidate
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:

    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)
    - *sbx_distribution_index* -- the non-negative distribution index 
      (default 10)
    
    A small value of the `sbx_distribution_index` optional argument allows 
    solutions far away from parents to be created as child solutions, 
    while a large value restricts only near-parent solutions to be created as
    child solutions.
    
    """
    crossover_rate = args.setdefault('crossover_rate', 1.0)
    if random.random() < crossover_rate:
        di = args.setdefault('sbx_distribution_index', 10)
        bounder = args['_ec'].bounder
        bro = copy.copy(dad)
        sis = copy.copy(mom)
        for i, (m, d, lb, ub) in enumerate(zip(mom, dad, bounder.lower_bound, bounder.upper_bound)):
            try:
                if m > d:
                    m, d = d, m
                beta = 1.0 + 2 * min(m - lb, ub - d) / float(d - m)
                alpha = 2.0 - 1.0 / beta**(di + 1.0)
                u = random.random() 
                if u <= (1.0 / alpha):
                    beta_q = (u * alpha)**(1.0 / float(di + 1.0))
                else:
                    beta_q = (1.0 / (2.0 - u * alpha))**(1.0 / float(di + 1.0))
                bro_val = 0.5 * ((m + d) - beta_q * (d - m))
                bro_val = max(min(bro_val, ub), lb)        
                sis_val = 0.5 * ((m + d) + beta_q * (d - m))
                sis_val = max(min(sis_val, ub), lb)
                if random.random() > 0.5:
                    bro_val, sis_val = sis_val, bro_val
                bro[i] = bro_val
                sis[i] = sis_val
            except ZeroDivisionError:
                # The offspring already have legitimate values for every element,
                # so no need to take any special action here.
                pass
        return [bro, sis]
    else:
        return [mom, dad]


@crossover
def laplace_crossover(random, mom, dad, args):
    """Return the offspring of Laplace crossover on the candidates.
    
    This function performs Laplace crosssover (LX), following the 
    implementation specified in (Deep and Thakur, "A new crossover 
    operator for real coded genetic algorithms," Applied Mathematics 
    and Computation, Volume 188, Issue 1, May 2007, pp. 895--911).
    This function also makes use of the bounder function as specified 
    in the EC's ``evolve`` method.    
 
    .. Arguments:
       random -- the random number generator object
       mom -- the first parent candidate
       dad -- the second parent candidate
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *crossover_rate* -- the rate at which crossover is performed 
      (default 1.0)
    - *lx_location* -- the location parameter (default 0)
    - *lx_scale* -- the scale parameter (default 0.5)
    
    In some sense, the *lx_location* and *lx_scale* parameters can be thought 
    of as analogs in a Laplace distribution to the mean and standard 
    deviation of a Gaussian distribution. If *lx_scale* is near zero, offspring 
    will be produced near the parents. If *lx_scale* is farther from zero, 
    offspring will be produced far from the parents.
    
    """
    crossover_rate = args.setdefault('crossover_rate', 1.0)
    if random.random() < crossover_rate:
        bounder = args['_ec'].bounder
        a = args.setdefault('lx_location', 0)
        b = args.setdefault('lx_scale', 0.5)
        bro = copy.copy(dad)
        sis = copy.copy(mom)
        for i, (m, d) in enumerate(zip(mom, dad)):
            u = random.random()
            if random.random() <= 0.5:
                beta = a - b * math.log(u)
            else:
                beta = a + b * math.log(u)
            bro[i] = m + beta * abs(m - d)
            sis[i] = d + beta * abs(m - d)
        bro = bounder(bro, args)
        sis = bounder(sis, args)
        return [bro, sis]
    else:
        return [mom, dad]








########NEW FILE########
__FILENAME__ = mutators
"""
    ===============
    :mod:`mutators`
    ===============
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: mutators
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import copy
import functools
    
    
def mutator(mutate):
    """Return an inspyred mutator function based on the given function.
    
    This function generator takes a function that operates on only
    one candidate to produce a single mutated candidate. The generator 
    handles the iteration over each candidate in the set to be mutated.

    The given function ``mutate`` must have the following signature::
    
        mutant = mutate(random, candidate, args)
        
    This function is most commonly used as a function decorator with
    the following usage::
    
        @mutator
        def mutate(random, candidate, args):
            # Implementation of mutation
            pass
            
    The generated function also contains an attribute named
    ``single_mutation`` which holds the original mutation function.
    In this way, the original single-candidate function can be
    retrieved if necessary.
    
    """
    @functools.wraps(mutate)
    def ecspy_mutator(random, candidates, args):
        mutants = []
        for i, cs in enumerate(candidates):
            mutants.append(mutate(random, cs, args))
        return mutants
    ecspy_mutator.single_mutation = mutate
    return ecspy_mutator
    

@mutator
def bit_flip_mutation(random, candidate, args):
    """Return the mutants produced by bit-flip mutation on the candidates.

    This function performs bit-flip mutation. If a candidate solution contains
    non-binary values, this function leaves it unchanged.

    .. Arguments:
       random -- the random number generator object
       candidate -- the candidate solution
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *mutation_rate* -- the rate at which mutation is performed (default 0.1)
    
    The mutation rate is applied on a bit by bit basis.
    
    """
    rate = args.setdefault('mutation_rate', 0.1)
    mutant = copy.copy(candidate)
    if len(mutant) == len([x for x in mutant if x in [0, 1]]):
        for i, m in enumerate(mutant):
            if random.random() < rate:
                mutant[i] = (m + 1) % 2
    return mutant


@mutator
def random_reset_mutation(random, candidate, args):
    """Return the mutants produced by randomly choosing new values.

    This function performs random-reset mutation. It assumes that 
    candidate solutions are composed of discrete values. This function
    makes use of the bounder function as specified in the EC's 
    ``evolve`` method, and it assumes that the bounder contains
    an attribute called *values* (which is true for instances of
    ``DiscreteBounder``).
    
    The mutation moves through a candidate solution and, with rate
    equal to the *mutation_rate*, randomly chooses a value from the 
    set of allowed values to be used in that location. Note that this
    value may be the same as the original value.

    .. Arguments:
       random -- the random number generator object
       candidate -- the candidate solution
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *mutation_rate* -- the rate at which mutation is performed (default 0.1)
    
    The mutation rate is applied on an element by element basis.
    
    """
    bounder = args['_ec'].bounder
    try:
        values = bounder.values
    except AttributeError:
        values = None
    if values is not None:
        rate = args.setdefault('mutation_rate', 0.1)
        mutant = copy.copy(candidate)
        for i, m in enumerate(mutant):
            if random.random() < rate:
                mutant[i] = random.choice(values)
        return mutant
    else:
        return candidate


@mutator
def scramble_mutation(random, candidate, args):
    """Return the mutants created by scramble mutation on the candidates.

    This function performs scramble mutation. It randomly chooses two
    locations along the candidate and scrambles the values within that
    slice. 

    .. Arguments:
       random -- the random number generator object
       candidate -- the candidate solution
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *mutation_rate* -- the rate at which mutation is performed (default 0.1)
      
    The mutation rate is applied to the candidate as a whole (i.e., it
    either mutates or it does not, based on the rate).
    
    """
    rate = args.setdefault('mutation_rate', 0.1)
    if random.random() < rate:
        size = len(candidate)
        p = random.randint(0, size-1)
        q = random.randint(0, size-1)
        p, q = min(p, q), max(p, q)
        s = candidate[p:q+1]
        random.shuffle(s)
        return candidate[:p] + s[::-1] + candidate[q+1:]
    else:
        return candidate
    

@mutator
def inversion_mutation(random, candidate, args):
    """Return the mutants created by inversion mutation on the candidates.

    This function performs inversion mutation. It randomly chooses two
    locations along the candidate and reverses the values within that
    slice. 

    .. Arguments:
       random -- the random number generator object
       candidate -- the candidate solution
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *mutation_rate* -- the rate at which mutation is performed (default 0.1)
      
    The mutation rate is applied to the candidate as a whole (i.e., it
    either mutates or it does not, based on the rate).
    
    """
    rate = args.setdefault('mutation_rate', 0.1)
    if random.random() < rate:
        size = len(candidate)
        p = random.randint(0, size-1)
        q = random.randint(0, size-1)
        p, q = min(p, q), max(p, q)
        s = candidate[p:q+1]
        return candidate[:p] + s[::-1] + candidate[q+1:]
    else:
        return candidate


@mutator    
def gaussian_mutation(random, candidate, args):
    """Return the mutants created by Gaussian mutation on the candidates.

    This function performs Gaussian mutation. This function  
    makes use of the bounder function as specified in the EC's 
    ``evolve`` method.

    .. Arguments:
       random -- the random number generator object
       candidate -- the candidate solution
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *mutation_rate* -- the rate at which mutation is performed (default 0.1)
    - *gaussian_mean* -- the mean used in the Gaussian function (default 0)
    - *gaussian_stdev* -- the standard deviation used in the Gaussian function
      (default 1)
      
    The mutation rate is applied on an element by element basis.
    
    """
    mut_rate = args.setdefault('mutation_rate', 0.1)
    mean = args.setdefault('gaussian_mean', 0.0)
    stdev = args.setdefault('gaussian_stdev', 1.0)
    bounder = args['_ec'].bounder
    mutant = copy.copy(candidate)
    for i, m in enumerate(mutant):
        if random.random() < mut_rate:
            mutant[i] += random.gauss(mean, stdev)
    mutant = bounder(mutant, args)
    return mutant


@mutator
def nonuniform_mutation(random, candidate, args):
    """Return the mutants produced by nonuniform mutation on the candidates.

    The function performs nonuniform mutation as specified in
    (Michalewicz, "Genetic Algorithms + Data Structures = Evolution
    Programs," Springer, 1996). This function also makes use of the 
    bounder function as specified in the EC's ``evolve`` method.
    
    .. note::
    
       This function **requires** that *max_generations* be specified in 
       the *args* dictionary. Therefore, it is best to use this operator 
       in conjunction with the ``generation_termination`` terminator. 

    .. Arguments:
       random -- the random number generator object
       candidate -- the candidate solution
       args -- a dictionary of keyword arguments

    Required keyword arguments in args:
    
    - *max_generations* -- the maximum number of generations for which
      evolution should take place
    
    Optional keyword arguments in args:
    
    - *mutation_strength* -- the strength of the mutation, where higher
      values correspond to greater variation (default 1)
    
    """
    bounder = args['_ec'].bounder
    num_gens = args['_ec'].num_generations
    max_gens = args['max_generations']
    strength = args.setdefault('mutation_strength', 1)
    exponent = (1.0 - num_gens / float(max_gens)) ** strength
    mutant = copy.copy(candidate)
    for i, (c, lo, hi) in enumerate(zip(candidate, bounder.lower_bound, bounder.upper_bound)):
        if random.random() <= 0.5:
            new_value = c + (hi - c) * (1.0 - random.random() ** exponent)
        else:
            new_value = c - (c - lo) * (1.0 - random.random() ** exponent)
        mutant[i] = new_value
    return mutant

########NEW FILE########
__FILENAME__ = variators
"""
    ================
    :mod:`variators`
    ================
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: variators
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""


def default_variation(random, candidates, args):
    """Return the set of candidates without variation.

    .. Arguments:
       random -- the random number generator object
       candidates -- the candidate solutions
       args -- a dictionary of keyword arguments
    
    """
    return candidates


########NEW FILE########
__FILENAME__ = swarm
"""
    ==================================
    :mod:`swarm` -- Swarm intelligence
    ==================================
    
    This module provides standard swarm intelligence algorithms.
    
    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: swarm
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""
import collections
import copy
import inspyred
import math


#-----------------------------------------------------------------------
#                     PARTICLE SWARM OPTIMIZATION
#-----------------------------------------------------------------------

class PSO(inspyred.ec.EvolutionaryComputation):
    """Represents a basic particle swarm optimization algorithm.
    
    This class is built upon the ``EvolutionaryComputation`` class making
    use of an external archive and maintaining the population at the previous
    timestep, rather than a velocity. This approach was outlined in 
    (Deb and Padhye, "Development of Efficient Particle Swarm Optimizers by
    Using Concepts from Evolutionary Algorithms", GECCO 2010, pp. 55--62).
    This class assumes that each candidate solution is a ``Sequence`` of
    real values.
    
    Public Attributes:
    
    - *topology* -- the neighborhood topology (default topologies.star_topology)
    
    Optional keyword arguments in ``evolve`` args parameter:
    
    - *inertia* -- the inertia constant to be used in the particle 
      updating (default 0.5)
    - *cognitive_rate* -- the rate at which the particle's current 
      position influences its movement (default 2.1)
    - *social_rate* -- the rate at which the particle's neighbors 
      influence its movement (default 2.1)
    
    """
    def __init__(self, random):
        inspyred.ec.EvolutionaryComputation.__init__(self, random)
        self.topology = inspyred.swarm.topologies.star_topology
        self._previous_population = []
        self.selector = self._swarm_selector
        self.replacer = self._swarm_replacer
        self.variator = self._swarm_variator
        self.archiver = self._swarm_archiver
        
    def _swarm_archiver(self, random, population, archive, args):
        if len(archive) == 0:
            return population[:]
        else:
            new_archive = []
            for i, (p, a) in enumerate(zip(population[:], archive[:])):
                if p < a:
                    new_archive.append(a)
                else:
                    new_archive.append(p)
            return new_archive
        
    def _swarm_variator(self, random, candidates, args):
        inertia = args.setdefault('inertia', 0.5)
        cognitive_rate = args.setdefault('cognitive_rate', 2.1)
        social_rate = args.setdefault('social_rate', 2.1)
        if len(self.archive) == 0:
            self.archive = self.population[:]
        if len(self._previous_population) == 0:
            self._previous_population = self.population[:]
        neighbors = self.topology(self._random, self.archive, args)
        offspring = []
        for x, xprev, pbest, hood in zip(self.population, 
                                         self._previous_population, 
                                         self.archive, 
                                         neighbors):
            nbest = max(hood)
            particle = []
            for xi, xpi, pbi, nbi in zip(x.candidate, xprev.candidate, 
                                         pbest.candidate, nbest.candidate):
                value = (xi + inertia * (xi - xpi) + 
                         cognitive_rate * random.random() * (pbi - xi) + 
                         social_rate * random.random() * (nbi - xi))
                particle.append(value)
            particle = self.bounder(particle, args)
            offspring.append(particle)
        return offspring
        
    def _swarm_selector(self, random, population, args):
        return population
        
    def _swarm_replacer(self, random, population, parents, offspring, args):
        self._previous_population = population[:]
        return offspring


#-----------------------------------------------------------------------
#                        ANT COLONY OPTIMIZATION
#-----------------------------------------------------------------------

class TrailComponent(inspyred.ec.Individual):
    """Represents a discrete component of a trail in ant colony optimization.
    
    An trail component has an element, which is its essence (and which
    is equivalent to the candidate in the ``Individual`` parent class); 
    a value, which is its weight or cost; a pheromone level; and a
    desirability, which is a combination of the value and pheromone
    level (and which is equivalent to the fitness in the ``Individual``
    parent class). Note that the desirability (and, thus, the fitness)
    cannot be set manually. It is calculated automatically from the 
    value and pheromone level.

    Public Attributes:
    
    - *element* -- the actual interpretation of this component
    - *value* -- the value or cost of the component
    - *desirability* -- the worth of the component based on value and 
      pheromone level
    - *delta* -- the exponential contribution of the pheromone level on
      the desirability
    - *epsilon* -- the exponential contribution of the value on the 
      desirability
    - *maximize* -- Boolean value stating use of maximization
    
    """
    def __init__(self, element, value, maximize=True, delta=1, epsilon=1):
        inspyred.ec.Individual.__init__(self, element, maximize)
        self._value = value
        self._pheromone = 0
        self.fitness = 0
        self.delta = delta
        self.epsilon = epsilon
    
    @property
    def element(self):
        return self.candidate
    
    @element.setter
    def element(self, val):
        self.candidate = val
    
    @property
    def value(self):
        return self._value
        
    @value.setter
    def value(self, val):
        self._value = val
        self.fitness = (self._pheromone ** self.delta + 
                        self._value ** self.epsilon)
    
    @property
    def pheromone(self):
        return self._pheromone
        
    @pheromone.setter
    def pheromone(self, val):
        self._pheromone = val
        self.fitness = self._pheromone + self._value ** self.epsilon
    
    @property
    def desirability(self):
        return self.fitness
    
    def __eq__(self, other):
        return self.candidate == other.candidate
    
    def __str__(self):
        return '({0}, {1})'.format(self.element, self.value)
        
    def __repr__(self):
        return str(self)
        

class ACS(inspyred.ec.EvolutionaryComputation):
    """Represents an Ant Colony System discrete optimization algorithm.
    
    This class is built upon the ``EvolutionaryComputation`` class making
    use of an external archive. It assumes that candidate solutions are
    composed of instances of ``TrailComponent``.
    
    Public Attributes:
    
    - *components* -- the full set of discrete components for a given problem
    - *initial_pheromone* -- the initial pheromone on a trail (default 0)
    - *evaporation_rate* -- the rate of pheromone evaporation (default 0.1)
    - *learning_rate* -- the learning rate used in pheromone updates 
      (default 0.1)
    
    """
    def __init__(self, random, components):
        inspyred.ec.EvolutionaryComputation.__init__(self, random)
        self.components = components
        self.evaporation_rate = 0.1
        self.initial_pheromone = 0
        self.learning_rate = 0.1
        self._variator = self._internal_variator
        self.archiver = self._internal_archiver
        self.replacer = inspyred.ec.replacers.generational_replacement
        
    @property
    def variator(self):
        return self._variator
        
    @variator.setter
    def variator(self, value):
        self._variator = [self._internal_variator]
        if isinstance(value, collections.Sequence):
            self._variator.extend(value)
        else:
            self._variator.append(value)

    def _internal_variator(self, random, candidates, args):
        offspring = []
        for i in range(len(candidates)):
            offspring.append(self.generator(random, args))
        return offspring
        
    def _internal_archiver(self, random, population, archive, args):
        best = max(population)
        if len(archive) == 0:
            archive.append(best)
        else:
            arc_best = max(archive)
            if best > arc_best:
                archive.remove(arc_best)
                archive.append(best)
            else:
                best = arc_best
        for c in self.components:
            c.pheromone = ((1 - self.evaporation_rate) * c.pheromone + 
                           self.evaporation_rate * self.initial_pheromone)
        for c in self.components:
            if c in best.candidate:
                c.pheromone = ((1 - self.learning_rate) * c.pheromone + 
                               self.learning_rate * best.fitness)
        return archive

########NEW FILE########
__FILENAME__ = topologies
"""
    =====================================
    :mod:`topologies` -- Swarm topologies
    =====================================
    
    This module defines various topologies for swarm intelligence algorithms.
    
    Particle swarms make use of topologies, which determine the logical
    relationships among particles in the swarm (i.e., which ones belong to the same
    "neighborhood"). All topology functions have the following arguments:
        
    - *random* -- the random number generator object
    - *population* -- the population of Particles
    - *args* -- a dictionary of keyword arguments
        
    Each topology function returns a list of lists of neighbors
    for each particle in the population. For example, if a swarm
    contained 10 particles, then this function would return a list
    containing 10 lists, each of which contained the neighbors for 
    its corresponding particle in the population. 
    
    Rather than constructing and returning a list of lists directly, the 
    topology functions could (and probably *should*, for efficiency) be 
    written as generators that yield each neighborhood list one at a 
    time. This is how the existing topology functions operate.

    .. Copyright 2012 Inspired Intelligence Initiative

    .. This program is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

    .. This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

    .. You should have received a copy of the GNU General Public License
       along with this program.  If not, see <http://www.gnu.org/licenses/>.
       
    .. module:: topologies
    .. moduleauthor:: Aaron Garrett <aaron.lee.garrett@gmail.com>
"""


def star_topology(random, population, args):
    """Returns the neighbors using a star topology.
    
    This function sets all particles as neighbors for all other particles.
    This is known as a star topology. The resulting list of lists of 
    neighbors is returned.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of particles
       args -- a dictionary of keyword arguments
    
    """
    for _ in range(len(population)):
        yield population[:]
    
    
def ring_topology(random, population, args):
    """Returns the neighbors using a ring topology.
    
    This function sets all particles in a specified sized neighborhood
    as neighbors for a given particle. This is known as a ring 
    topology. The resulting list of lists of neighbors is returned.
    
    .. Arguments:
       random -- the random number generator object
       population -- the population of particles
       args -- a dictionary of keyword arguments

    Optional keyword arguments in args:
    
    - *neighborhood_size* -- the width of the neighborhood around a 
      particle which determines the size of the neighborhood
      (default 3)
    
    """
    neighborhood_size = args.setdefault('neighborhood_size', 3)
    half_hood = neighborhood_size // 2
    neighbor_index_start = []
    for index in range(len(population)):
        if index < half_hood:
            neighbor_index_start.append(len(population) - half_hood + index)
        else:
            neighbor_index_start.append(index - half_hood)
    neighbors = []
    for start in neighbor_index_start:
        n = []
        for i in range(0, neighborhood_size):
            n.append(population[(start + i) % len(population)])
        yield n
    

########NEW FILE########
__FILENAME__ = pavement
#!/usr/bin/python2.6

# Standard library
import os
import sys

# Set up Paver
import paver
import paver.doctools
import paver.misctasks
from paver.path import path
from paver.easy import *
import paver.setuputils
paver.setuputils.install_distutils_tasks()
try:
    from sphinxcontrib import paverutils
except:
    paverutils = None


PROJECT = 'inspyred'
VERSION = '1.0'

# The sphinx templates expect the VERSION in the shell environment
os.environ['VERSION'] = VERSION

# Read the long description to give to setup
README = path('README.rst').text()

# Scan the input for package information
# to grab any data files (text, images, etc.) 
# associated with sub-packages.
PACKAGE_DATA = paver.setuputils.find_package_data(PROJECT, 
                                                  package=PROJECT,
                                                  only_in_packages=False
                                                  )

options(
    setup=Bunch(
        name = PROJECT,
        version = VERSION,
        description='A framework for creating bio-inspired computational intelligence algorithms in Python.',
        long_description=README,
        author='Aaron Garrett',
        author_email='aaron.lee.garrett@gmail.com',
        url='http://%s.github.com' % PROJECT,
        download_url='https://github.com/{0}/{0}/downloads/{0}-{1}.tar.gz'.format(PROJECT, VERSION),
        license='GPLv3+',
        platforms=('Any'),
        keywords=('python', 'optimization', 'evolutionary computation', 'genetic algorithm', 
                  'particle swarm', 'estimation of distribution', 'differential evolution',
                  'nsga', 'paes', 'island model', 'multiobjective', 'ant colony'),

        classifiers=[
          'Development Status :: 5 - Production/Stable',
          'Environment :: Console',
          'Intended Audience :: Developers',
          'Intended Audience :: Science/Research',
          'License :: OSI Approved :: GNU General Public License (GPL)',
          'Operating System :: OS Independent',
          'Programming Language :: Python :: 2.6',
          'Programming Language :: Python :: 2.7',
          'Programming Language :: Python :: 3',
          'Topic :: Scientific/Engineering :: Artificial Intelligence'
          ],
        
        packages = [PROJECT, '%s.ec' % PROJECT, '%s.ec.variators' % PROJECT, '%s.swarm' % PROJECT],
        package_data=PACKAGE_DATA,
    ),
    
    sdist = Bunch(
    ),
    
    sphinx = Bunch(
        sourcedir='docs',
        docroot = '.',
        builder = 'html',
        doctrees='docs/_build/doctrees',
        confdir = 'docs',
    ),

    html = Bunch(
        builddir='docs',
        outdir='html',
        templates='pkg',
    ),

    # Some of the files include [[[ as part of a nested list data structure,
    # so change the tags cog looks for to something less likely to appear.
    cog=Bunch(
        beginspec='{{{cog',
        endspec='}}}',
        endoutput='{{{end}}}',
    ),
    
    minilib=Bunch(
        extra_files=['doctools']
    ),
)

def run_script(input_file, script_name, interpreter='python'):
    """Run a script in the context of the input_file's directory, 
    return the text output formatted to be included as an rst
    literal text block.
    """
    from paver.easy import sh
    from paver.path import path
    rundir = path(input_file).dirname()
    output_text = sh('cd %(rundir)s && %(interpreter)s %(script_name)s 2>&1' % vars(), capture=True)
    response = '\n::\n\n\t$ %(interpreter)s %(script_name)s\n\t' % vars()
    response += '\n\t'.join(output_text.splitlines())
    while not response.endswith('\n\n'):
        response += '\n'
    return response
    
    
# Stuff run_script() into the builtins so we don't have to
# import it in all of the cog blocks where we want to use it.
__builtins__['run_script'] = run_script


def remake_directories(*dirnames):
    """Remove the directories and recreate them.
    """
    for d in dirnames:
        d = path(d)
        if d.exists():
            d.rmtree()
        d.mkdir()
    return

@task
@needs(['cog'])
def html(options):
    if paverutils is None:
        raise RuntimeError('Could not find sphinxcontrib.paverutils, will not be able to build HTML output.')
    paverutils.html(options)
    return

@task
@needs(['generate_setup', 'minilib', 
        'html_clean', 
        'setuptools.command.sdist'
        ])
def sdist(options):
    """Create a source distribution.
    """
    pass

@task
def html_clean(options):
    """Remove sphinx output directories before building the HTML.
    """
    remake_directories(options.sphinx.doctrees, options.html.outdir)
    html(options)
    return


########NEW FILE########
__FILENAME__ = constraint_selection
import random
from inspyred import ec
from inspyred.ec import variators
from inspyred.ec import replacers
from inspyred.ec import terminators
from inspyred.ec import observers

def my_constraint_function(candidate):
    """Return the number of constraints that candidate violates."""
    # In this case, we'll just say that the point has to lie 
    # within a circle centered at (0, 0) of radius 1.
    if candidate[0]**2 + candidate[1]**2 > 1:
        return 1
    else:
        return 0

def my_generator(random, args):
    # Create pairs in the range [-2, 2].
    return [random.uniform(-2.0, 2.0) for i in range(2)]

def my_evaluator(candidates, args):
    # The fitness will be how far the point is from
    # the origin. (We're maximizing, in this case.)
    # Note that the constraint heavily punishes individuals
    # who go beyond the unit circle. Therefore, these
    # two functions combined focus the evolution toward
    # finding individual who lie ON the circle.
    fitness = []
    for c in candidates:
        if my_constraint_function(c) > 0:
            fitness.append(-1)
        else:
            fitness.append(c[0]**2 + c[1]**2)
    return fitness

def constrained_tournament_selection(random, population, args):
    num_selected = args.setdefault('num_selected', 1)
    constraint_func = args.setdefault('constraint_function', None)
    tournament_size = 2
    pop = list(population)
    selected = []
    for _ in range(num_selected):
        tournament = random.sample(pop, tournament_size)
        # If there is not a constraint function,
        # just do regular tournament selection.
        if constraint_func is None:
            selected.append(max(tournament))
        else:
            cons = [constraint_func(t.candidate) for t in tournament]
            # If no constraints are violated, just do 
            # regular tournament selection.
            if max(cons) == 0:
                selected.append(max(tournament))
            # Otherwise, choose the least violator 
            # (which may be a non-violator).
            else:
                selected.append(tournament[cons.index(min(cons))])
    return selected

r = random.Random()
myec = ec.EvolutionaryComputation(r)
myec.selector = constrained_tournament_selection
myec.variator = variators.gaussian_mutation
myec.replacer = replacers.generational_replacement
myec.terminator = terminators.evaluation_termination
myec.observer = observers.stats_observer
pop = myec.evolve(my_generator, my_evaluator, 
                  pop_size=100, 
                  bounder=ec.Bounder(-2, 2),
                  num_selected=100,
                  constraint_func=my_constraint_function, 
                  mutation_rate=0.5,
                  max_evaluations=2000)
                  
import pylab
x = []
y = []
c = []
pop.sort()
num_feasible = len([p for p in pop if p.fitness >= 0])
feasible_count = 0
for i, p in enumerate(pop):
    x.append(p.candidate[0])
    y.append(p.candidate[1])
    if i == len(pop) - 1:
        c.append('r')
    elif p.fitness < 0:
        c.append('0.98')
    else:
        c.append(str(1 - feasible_count / float(num_feasible)))
        feasible_count += 1
angles = pylab.linspace(0, 2*pylab.pi, 100)
pylab.plot(pylab.cos(angles), pylab.sin(angles), color='b')
pylab.scatter(x, y, color=c)
pylab.savefig('constraint_example.pdf', format='pdf')

########NEW FILE########
__FILENAME__ = lexicographic
import functools

@functools.total_ordering
class Lexicographic(object):
    def __init__(self, values=None, maximize=True):
        if values is None:
            values = []
        self.values = values
        try:
            iter(maximize)
        except TypeError:
            maximize = [maximize for v in values]
        self.maximize = maximize

    def __len__(self):
        return len(self.values)
    
    def __getitem__(self, key):
        return self.values[key]
        
    def __iter__(self):
        return iter(self.values)
        
    def __lt__(self, other):
        for v, o, m in zip(self.values, other.values, self.maximize):
            if m:
                if v < o:
                    return True
                elif v > o:
                    return False
            else:
                if v > o:
                    return True
                elif v < o:
                    return False
        return False

    def __eq__(self, other):
        return (self.values == other.values and self.maximize == other.maximize)

    def __str__(self):
        return str(self.values)
        
    def __repr__(self):
        return str(self.values)


def my_evaluator(candidates, args):
    fitness = []
    for candidate in candidates:
        f = candidate[0] ** 2 + 1
        g = candidate[0] ** 2 - 1
        fitness.append(Lexicographic([f, g], maximize=False))
    return fitness

def my_generator(random, args):
    return [random.random()]
    
if __name__ == '__main__':
    a = Lexicographic([1, 2, 3], maximize=True)
    b = Lexicographic([1, 3, 2], maximize=True)
    c = Lexicographic([2, 1, 3], maximize=True)
    d = Lexicographic([2, 3, 1], maximize=True)
    e = Lexicographic([3, 1, 2], maximize=True)
    f = Lexicographic([3, 2, 1], maximize=True)
    
    u = Lexicographic([1, 2, 3], maximize=False)
    v = Lexicographic([1, 3, 2], maximize=False)
    w = Lexicographic([2, 1, 3], maximize=False)
    x = Lexicographic([2, 3, 1], maximize=False)
    y = Lexicographic([3, 1, 2], maximize=False)
    z = Lexicographic([3, 2, 1], maximize=False)
    
    for p in [a, b, c, d, e, f]:
        for q in [a, b, c, d, e, f]:
            print('%s < %s : %s' % (p, q, p < q))
    print('----------------------------------------')
    for p in [u, v, w, x, y, z]:
        for q in [u, v, w, x, y, z]:
            print('%s < %s : %s' % (p, q, p < q))
    











########NEW FILE########
__FILENAME__ = meta_ec
import csv
import time
import random
from inspyred import ec
from inspyred.ec import selectors
from inspyred.ec import replacers
from inspyred.ec import variators
from inspyred.ec import terminators
from inspyred.ec import observers


class MetaEC(ec.EvolutionaryComputation):
    def __init__(self, random):
        ec.EvolutionaryComputation.__init__(self, random)
        self.selector = selectors.tournament_selection
        self.replacer = replacers.generational_replacement
        self.variator = [variators.uniform_crossover, self._internal_variator]
        self.terminator = self._internal_meta_terminator
        
    def _create_selector_replacer(self, random):
        pop_size = random.randint(1, 100)
        selector = random.choice(range(0, 5))
        replacer = random.choice(range(0, 8))
        sel = [selector]
        if selector > 0:
            if replacer == 0 or replacer == 2 or replacer == 3:
                sel.append(pop_size)
            else:
                sel.append(random.randint(1, pop_size))
        if selector == 2:
            sel.append(random.randint(min(2, pop_size), pop_size))
        rep = [replacer]
        if replacer == 1:
            rep.append(random.randint(min(2, pop_size), pop_size))
        elif replacer == 3 or replacer == 5:
            rep.append(random.randint(0, pop_size))
        return [pop_size, sel, rep]
    
    def _create_variators(self, random):
        crossover = random.choice([0, 1, 2, 3, 4, 6])
        mutator = random.choice([5, 6])
        variators = ([crossover], [mutator])
        if crossover == 0 or crossover == 4:
            variators[0].append(random.random())
            variators[0].append(random.random())
        elif crossover == 1:
            variators[0].append(random.random())
        elif crossover == 2:
            variators[0].append(random.random())
            variators[0].append(random.randint(1, 10))
        elif crossover == 3:
            variators[0].append(random.randint(0, 30))
        if mutator == 5:
            variators[1].append(random.random())
            variators[1].append(random.random())
        return variators
    
    def _internal_generator(self, random, args):
        cross, mut = self._create_variators(random)
        return [self._create_selector_replacer(random), cross, mut]
        
    def _internal_variator(self, random, candidates, args):
        cs_copy = list(candidates)
        for i, cs in enumerate(cs_copy):
            if random.random() < 0.1:
                cs_copy[i][0] = self._create_selector_replacer(random)
            if random.random() < 0.1:
                cross, mut = self._create_variators(random)
                cs_copy[i][1] = cross
                cs_copy[i][2] = mut
        return cs_copy

    def _internal_observer(self, population, num_generations, num_evaluations, args):
        for i, p in enumerate(population):
            self._observer_file.write('{0}, {1}, {2}\n'.format(i, p.fitness, str(p.candidate)))
            self._observer_file.flush()
    
    def _internal_terminator(self, population, num_generations, num_evaluations, args):
        maxevals = args.get('max_evaluations', 0)
        self._meta_evaluations += num_evaluations
        return num_evaluations >= maxevals or self._meta_evaluations >= self._max_meta_evaluations
        
    def _internal_meta_terminator(self, population, num_generations, num_evaluations, args):
        return self._meta_evaluations >= self._max_meta_evaluations
        
    def _internal_evaluator(self, candidates, args):
        the_generator = args.get('the_generator')
        the_evaluator = args.get('the_evaluator')
        do_maximize = args.get('do_maximize', True)
    
        fitness = []
        for candidate in candidates:
            popsize, selector, replacer, crossover, mutator, myargs = self.interpret_candidate(candidate)
            myargs['max_evaluations'] = args.get('num_trial_evaluations', popsize * 10)
            num_trials = args.get('num_trials', 1)
            evo = ec.EvolutionaryComputation(self._random)
            evo.terminator = self._internal_terminator
            evo.observer = self._internal_observer
            evo.selector = selector
            evo.variator = [crossover, mutator]
            evo.replacer = replacer
            best_fit = []
            for i in range(num_trials):
                final_pop = evo.evolve(generator=the_generator,
                                       evaluator=the_evaluator,
                                       pop_size=popsize,
                                       maximize=do_maximize,
                                       args=myargs)
                best_fit.append(final_pop[0].fitness)
            fitness.append(sum(best_fit) / float(len(best_fit)))
        return fitness
    
    def interpret_candidate(self, candidate):
        selector_mapping = (selectors.default_selection,
                            selectors.rank_selection,
                            selectors.tournament_selection,
                            selectors.truncation_selection,
                            selectors.uniform_selection)
        variator_mapping = (variators.blend_crossover, 
                            variators.heuristic_crossover,
                            variators.n_point_crossover,
                            variators.simulated_binary_crossover,
                            variators.uniform_crossover,
                            variators.gaussian_mutation,
                            variators.default_variation)
        replacer_mapping = (replacers.comma_replacement,
                            replacers.crowding_replacement, 
                            replacers.default_replacement,
                            replacers.generational_replacement,
                            replacers.plus_replacement,
                            replacers.random_replacement,
                            replacers.steady_state_replacement,
                            replacers.truncation_replacement)
        
        myargs = dict()
        # Selectors
        if candidate[0][1][0] == 1:
            myargs['num_selected'] = candidate[0][1][1]
        elif candidate[0][1][0] == 2:
            myargs['num_selected'] = candidate[0][1][1]
            myargs['tournament_size'] = candidate[0][1][2]
        elif candidate[0][1][0] == 3:
            myargs['num_selected'] = candidate[0][1][1]
        elif candidate[0][1][0] == 4:
            myargs['num_selected'] = candidate[0][1][1]
            
        # Replacers
        if candidate[0][2][0] == 1:
            myargs['crowding_distance'] = candidate[0][2][1]
        elif candidate[0][2][0] == 3:
            myargs['num_elites'] = candidate[0][2][1]
        elif candidate[0][2][0] == 5:
            myargs['num_elites'] = candidate[0][2][1]
            
        # Crossovers
        if candidate[1][0] == 0:
            myargs['crossover_rate'] = candidate[1][1]
            myargs['blx_alpha'] = candidate[1][2]
        elif candidate[1][0] == 1:
            myargs['crossover_rate'] = candidate[1][1]
        elif candidate[1][0] == 2:
            myargs['crossover_rate'] = candidate[1][1]
            myargs['num_crossover_points'] = candidate[1][2]
        elif candidate[1][0] == 3:
            myargs['sbx_distribution_index'] = candidate[1][1]
        elif candidate[1][0] == 4:
            myargs['crossover_rate'] = candidate[1][1]
            myargs['ux_bias'] = candidate[1][2]
            
        # Mutators
        if candidate[2][0] == 5:
            myargs['mutation_rate'] = candidate[2][1]
            myargs['gaussian_stdev'] = candidate[2][2]
            
        return (candidate[0][0], 
                selector_mapping[candidate[0][1][0]], 
                replacer_mapping[candidate[0][2][0]], 
                variator_mapping[candidate[1][0]],
                variator_mapping[candidate[2][0]],
                myargs)
                
    def evolve(self, generator, evaluator, pop_size=100, seeds=[], maximize=True, **args):
        args.setdefault('the_generator', generator)
        args.setdefault('the_evaluator', evaluator)
        args.setdefault('do_maximize', maximize)
        args.setdefault('num_elites', 1)
        args.setdefault('num_selected', pop_size)
        self._observer_file = open('metaec-individuals-file-' + time.strftime('%m%d%Y-%H%M%S') + '.csv', 'w')
        self._meta_evaluations = 0
        self._max_meta_evaluations = args.get('max_evaluations', 0)
        final_pop = ec.EvolutionaryComputation.evolve(self, self._internal_generator, 
                                                      self._internal_evaluator, pop_size, 
                                                      seeds, maximize, **args)
        self._observer_file.close()
        return final_pop
        
if __name__ == '__main__':  
    import math
    import inspyred

    prng = random.Random()
    prng.seed(time.time())
    problem = inspyred.benchmarks.Rastrigin(3)
    mec = MetaEC(prng)
    mec.observer = observers.stats_observer
    final_pop = mec.evolve(generator=problem.generator, 
                           evaluator=problem.evaluator, 
                           pop_size=10, 
                           maximize=problem.maximize,
                           bounder=problem.bounder,
                           num_trials=1, 
                           num_trial_evaluations=5000, 
                           max_evaluations=100000)
        
    pop_size, selector, replacer, crossover, mutator, args = mec.interpret_candidate(final_pop[0].candidate)
    print('Best Fitness: {0}'.format(final_pop[0].fitness))
    print('Population Size: {0}'.format(pop_size))
    print('Selector: {0}'.format(selector.__name__))
    print('Replacer: {0}'.format(replacer.__name__))
    print('Crossover: {0}'.format(crossover.__name__))
    print('Mutator: {0}'.format(mutator.__name__))
    print('Parameters:')
    for key in args:
        print('    {0}: {1}'.format(key, args[key]))
    print('Actual Evaluations Used: {0}'.format(mec._meta_evaluations))

########NEW FILE########
__FILENAME__ = micro_ec
import collections
import inspyred

class MicroEC(inspyred.ec.EvolutionaryComputation):
    def __init__(self, random):
        inspyred.ec.EvolutionaryComputation.__init__(self, random)
        
    def evolve(self, generator, evaluator, pop_size=10, seeds=None, maximize=True, bounder=None, **args):
        self._kwargs = args
        self._kwargs['_ec'] = self
        
        if seeds is None:
            seeds = []
        if bounder is None:
            bounder = inspyred.ec.Bounder()
        
        self.termination_cause = None
        self.generator = generator
        self.evaluator = evaluator
        self.bounder = bounder
        self.maximize = maximize
        self.population = []
        self.archive = []
        microseeds = seeds
        
        while not self._should_terminate(list(self.population), self.num_generations, self.num_evaluations):
            microec = inspyred.ec.EvolutionaryComputation(self._random)
            microec.selector = self.selector
            microec.variator = self.variator
            microec.replacer = self.replacer
            microec.observer = self.observer
            microec.terminator = inspyred.ec.terminators.evaluation_termination
            maxevals = args['max_evaluations']
            args['max_evaluations'] = args['micro_evaluations']
            result = microec.evolve(generator=generator, evaluator=evaluator, 
                                    pop_size=pop_size, seeds=microseeds, 
                                    maximize=maximize, **args)
            self.population = list(result)
            args['max_evaluations'] = maxevals
            result.sort(reverse=True)
            microseeds = [result[0].candidate]
            self.num_evaluations += microec.num_evaluations

            # Migrate individuals.
            self.population = self.migrator(random=self._random, 
                                            population=self.population, 
                                            args=self._kwargs)
            
            # Archive individuals.
            self.archive = self.archiver(random=self._random, archive=self.archive, 
                                         population=list(self.population), args=self._kwargs)
            
            self.num_generations += microec.num_generations
            if isinstance(self.observer, collections.Iterable):
                for obs in self.observer:
                    obs(population=list(self.population), num_generations=self.num_generations, 
                        num_evaluations=self.num_evaluations, args=self._kwargs)
            else:
                self.observer(population=list(self.population), num_generations=self.num_generations, 
                              num_evaluations=self.num_evaluations, args=self._kwargs)
        return self.population


if __name__ == '__main__':
    import random
    import math
    import time

    def rastrigin_generator(random, args):
        return [random.uniform(-5.12, 5.12) for _ in range(2)]

    def rastrigin_evaluator(candidates, args):
        fitness = []
        for cand in candidates:
            fitness.append(10 * len(cand) + sum([x**2 - 10 * (math.cos(2*math.pi*x)) for x in cand]))
        return fitness
        
    prng = random.Random()
    prng.seed(time.time())
    micro = MicroEC(prng)
    micro.selector = inspyred.ec.selectors.tournament_selection
    micro.replacer = inspyred.ec.replacers.steady_state_replacement
    micro.variator = [inspyred.ec.variators.uniform_crossover, inspyred.ec.variators.gaussian_mutation]
    micro.archiver = inspyred.ec.archivers.best_archiver
    micro.observer = inspyred.ec.observers.stats_observer
    micro.terminator = inspyred.ec.terminators.evaluation_termination
    final_pop = micro.evolve(rastrigin_generator, 
                             rastrigin_evaluator, 
                             pop_size=10, 
                             maximize=False, 
                             bounder=inspyred.ec.Bounder(-5.12, 5.12),
                             max_evaluations=3000,
                             micro_evaluations=300,
                             num_selected=2, 
                             gaussian_stdev=0.1)
                             
    print('Actual evaluations: {0}'.format(micro.num_evaluations))

    for p in micro.archive:
        print p

########NEW FILE########
__FILENAME__ = network_migrator
import sys
import socket
import pickle
import threading
import collections
import SocketServer

class NetworkMigrator(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    """Defines a migration function across a network.
    
    This callable class acts as a migration function that 
    allows candidate solutions to migrate from one population
    to another via TCP/IP connections.
    
    The migrator is constructed by specifying the IP address
    of the server (hosting the population from which individuals
    emigrate) as an IP-port tuple and the addresses of the clients 
    (hosting the populations to which individuals from the server 
    immigrate) as a list of IP-port tuples. The ``max_migrants`` 
    parameter specifies the size of the queue of migrants waiting 
    to immigrate to the server from the clients; the newest migrants 
    replace older ones in the queue.
    
    Note: In order to use this migration operator, individuals
    must be pickle-able.
        
    The following is an example of the use of this operator::
    
        m = NetworkMigrator(('192.168.1.10', 25125),
                            [('192.168.1.11', 12345), ('192.168.1.12', 54321)], 
                            max_migrants=3)
                        
    Since the NetworkMigrator object is a server, it should always
    call the ``shutdown()`` method when it is no longer needed, in
    order to give back its resources.

    Public Attributes:
    
    - *client_addresses* -- the list of IP address tuples
      (IP, port) to which individuals should migrate
    - *migrants* -- the deque of migrants (of maximum size 
      specified by ``max_migrants``) waiting to immigrate 
      to client populations
    
    """
    def __init__(self, server_address, client_addresses, max_migrants=1):
        self._lock = threading.Lock()
        SocketServer.TCPServer.__init__(self, server_address, None)
        self.client_addresses = client_addresses
        self.migrants = collections.deque(maxlen=max_migrants)
        t = threading.Thread(target=self.serve_forever)
        t.setDaemon(True)
        t.start()
        self.__name__ = self.__class__.__name__

    def finish_request(self, request, client_address):
        try:
            rbufsize = -1
            wbufsize = 0
            rfile = request.makefile('rb', rbufsize)
            wfile = request.makefile('wb', wbufsize)

            pickle_data = rfile.readline().strip()
            migrant = pickle.loads(pickle_data)
            with self._lock:
                self.migrants.append(migrant)
            
            if not wfile.closed:
                wfile.flush()
            wfile.close()
            rfile.close()        
        finally:
            sys.exc_traceback = None

    def __call__(self, random, population, args):
        """Perform the migration.
        
        This function serves as the migration operator. Here, a random address
        is chosen from the ``client_addresses`` list, and a random individual
        is chosen from the population to become the migrant. A socket is opened
        to the chosen client address, and the chosen migrant is pickled and
        sent to the NetworkMigrator object running at the client address. Then
        the migrant queue on the current machine is queried for a migrant
        to replace the one sent. If one is found, it replaces the newly
        migrated individual; otherwise, the individual remains in the population.
        
        Any immigrants may also be re-evaluated before insertion into the
        current population by setting the ``evaluate_migrant`` keyword
        argument in ``args`` to True. This is useful if the evaluation
        functions in different populations are different and we want to compare
        "apples to apples," as they say.

        Arguments:
        
        - *random* -- the random number generator object
        - *population* -- the population of Individuals
        - *args* -- a dictionary of keyword arguments
        
        Optional keyword arguments in the ``args`` parameter:
        
        - *evaluate_migrant* -- whether to re-evaluate the immigrant (default False)
        
        """
        evaluate_migrant = args.setdefault('evaluate_migrant', False)
        client_address = random.choice(self.client_addresses)
        migrant_index = random.randint(0, len(population) - 1)
        pickle_data = pickle.dumps(population[migrant_index])
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.connect(client_address)
            sock.send(pickle_data + '\n')
        finally:
            sock.close()
        migrant = None
        with self._lock:
            if len(self.migrants) > 0:
                migrant = self.migrants.popleft()
        if migrant is not None:
            if evaluate_migrant:
                fit = args._ec.evaluator([migrant], args)
                migrant.fitness = fit[0]
                args._ec.num_evaluations += 1
            population[migrant_index] = migrant
        return population
		
    def __str__(self):
        return str(self.migrants)

########NEW FILE########
__FILENAME__ = evaluator_tests
import unittest
import random
import logging
import multiprocessing
import inspyred

class DummyEC(object):
    pass

def test_generator(random, args):
    return [random.random() for _ in range(6)]
    
def test_evaluator(candidates, args):
    fitness = []
    for c in candidates:
        fitness.append(sum(c))
    return fitness

def test_evaluator_mo(candidates, args):
    fitness = []
    for c in candidates:
        fitness.append(inspyred.ec.emo.Pareto([sum(c), sum(c)]))
    return fitness
    
def test_set_up(generator, evaluator):
    pop_size = 12
    prng = random.Random()
    prng.seed(111111)
    candidates = [generator(prng, {}) for _ in range(pop_size)]
    fitnesses = evaluator(candidates, {})
    population = [inspyred.ec.Individual(candidate=c) for c in candidates]
    for i, f in zip(population, fitnesses):
        i.fitness = f
    parents = population[:pop_size//2]
    offspring = population[pop_size//2:]
    return (prng, candidates, fitnesses, population, parents, offspring)


class EvaluatorTests(unittest.TestCase):
    def setUp(self):
        self.prng, self.candidates, self.fitnesses, self.population, self.parents, self.offspring = test_set_up(test_generator, test_evaluator)
        self.evaluator = test_evaluator
        self.ec = inspyred.ec.EvolutionaryComputation(None)
    
    def test_parallel_evaluation_pp(self):
        fitnesses = inspyred.ec.evaluators.parallel_evaluation_pp(self.candidates, {'_ec':self.ec, 'pp_evaluator':self.evaluator})
        assert fitnesses == self.fitnesses
        
    def test_parallel_evaluation_mp(self):
        fitnesses = inspyred.ec.evaluators.parallel_evaluation_mp(self.candidates, {'_ec':self.ec, 'mp_evaluator':self.evaluator})
        assert fitnesses == self.fitnesses
        
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = example_tests
import unittest
import random
import sys, os
pth = os.path.split( os.path.split( os.path.abspath(__file__) )[0] )[0] 
sys.path.append( pth )

import examples

prng = random.Random()
prng.seed(12345) 

class ACS_Test(unittest.TestCase):
    def test(self):
        ac = examples.standard.acs_example.main(prng=prng)
        best = max(ac.archive)
        assert 1550 < (1/best.fitness) < 1553

class Custom_EC_Test(unittest.TestCase):
    def test(self):
        ea = examples.custom.custom_ec_example.main(prng=prng)
        best = max(ea.population)
        assert best.fitness < 0.34

class DEA_Test(unittest.TestCase):
    def test(self):
        dea = examples.standard.dea_example.main(prng=prng)
        best = max(dea.population)
        assert best.fitness < 0.3

class EDA_Test(unittest.TestCase):
    def test(self):
        eda = examples.standard.eda_example.main(prng=prng)
        best = max(eda.population)
        assert best.fitness < 2.5

class ES_Test(unittest.TestCase):
    def test(self):
        es = examples.standard.es_example.main(prng=prng)
        best = max(es.population)
        assert best.fitness < 0.044

class GA_Test(unittest.TestCase):
    def test(self):
        ga = examples.standard.ga_example.main(prng=prng)
        best = max(ga.population)
        assert best.fitness < 0.005

class Knapsack_ACS_Test(unittest.TestCase):
    def test(self):
        ac = examples.advanced.knapsack_acs_example.main(prng=prng)
        best = max(ac.archive)
        assert best.fitness > 1130

class Knapsack_EC_Test(unittest.TestCase):
    def test(self):
        ea = examples.advanced.knapsack_ec_example.main(prng=prng)
        best = max(ea.population)
        assert best.fitness > 1130

class Niche_Test(unittest.TestCase):
    def test(self):
        ea = examples.advanced.niche_example.main(prng=prng)
        candidates = [p.candidate[0] for p in ea.population]
        self.assertTrue(any(map(lambda x: 1 < x < 2, candidates)), 'expected a solution in [1, 2]')
        self.assertTrue(any(map(lambda x: 7 < x < 8, candidates)), 'expected a solution in [7, 8]')
        self.assertTrue(any(map(lambda x: 14 < x < 15, candidates)), 'expected a solution in [14, 15]')
        self.assertTrue(any(map(lambda x: 20 < x < 21, candidates)), 'expected a solution in [20, 21]')

class NSGA_Test(unittest.TestCase):
    def test(self):
        nsga = examples.standard.nsga_example.main(prng=prng)
        fitnesses = [a.fitness for a in nsga.archive]
        assert all([(-21 < f[0] < -12) and (-12 < f[1] < 1) for f in fitnesses])

class PAES_Test(unittest.TestCase):
    def test(self):
        paes = examples.standard.paes_example.main(prng=prng)
        fitnesses = [a.fitness for a in paes.archive]
        assert all([(-21 < f[0] < -12) and (-12 < f[1] < 1) for f in fitnesses])

class PSO_Test(unittest.TestCase):
    def test(self):
        pso = examples.standard.pso_example.main(prng=prng)
        best = max(pso.population)
        assert best.fitness < 2

class TSP_EC_Test(unittest.TestCase):
    def test(self):
        ea = examples.advanced.tsp_ec_example.main(prng=prng)
        best = max(ea.population)
        assert 1550 < (1/best.fitness) < 1553
        
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = observer_tests
import unittest
import random
import inspyred

class DummyEC(object):
    pass

def test_generator(random, args):
    return [random.random() for _ in range(6)]
    
def test_evaluator(candidates, args):
    fitness = []
    for c in candidates:
        fitness.append(sum(c))
    return fitness
    
def test_set_up(generator, evaluator):
    pop_size = 12
    prng = random.Random()
    prng.seed(111111)
    candidates = [generator(prng, {}) for _ in range(pop_size)]
    fitnesses = evaluator(candidates, {})
    population = [inspyred.ec.Individual(candidate=c) for c in candidates]
    for i, f in zip(population, fitnesses):
        i.fitness = f
    parents = population[:pop_size//2]
    offspring = population[pop_size//2:]
    return (prng, candidates, fitnesses, population, parents, offspring)

class ObserverTests(unittest.TestCase):
    def setUp(self):
        self.prng, self.candidates, self.fitnesses, self.population, self.parents, self.offspring = test_set_up(test_generator, test_evaluator)
        self.ec = DummyEC()
        self.ec.bounder = inspyred.ec.Bounder(0, 1)
        self.ec.population = list(self.population)
        self.ec.archive = [["The", "archive", "observer", "works"]]
        
    def test_all_observers(self):
        inspyred.ec.observers.default_observer(self.population, 0, 0, {})
        inspyred.ec.observers.best_observer(self.population, 0, 0, {})
        inspyred.ec.observers.stats_observer(self.population, 0, 0, {})
        inspyred.ec.observers.population_observer(self.population, 0, 0, {})
        inspyred.ec.observers.file_observer(self.population, 0, 0, {})
        inspyred.ec.observers.archive_observer(self.population, 0, 0, {'_ec': self.ec})
        inspyred.ec.observers.plot_observer(self.population, 0, 0, {})
        # Cannot test the email observer without putting in a username and password.
        # We'll leave it out for now.
        assert True
 
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = operator_tests
import unittest
import random
import logging
import itertools
import multiprocessing
import inspyred

class DummyEC(object):
    pass

def test_generator(random, args):
    return [random.random() for _ in range(6)]
    
def test_evaluator(candidates, args):
    fitness = []
    for c in candidates:
        fitness.append(sum(c))
    return fitness

def test_evaluator_mo(candidates, args):
    fitness = []
    for c in candidates:
        fitness.append(inspyred.ec.emo.Pareto([sum(c), sum(c)]))
    return fitness
    
def test_set_up(generator, evaluator):
    pop_size = 12
    prng = random.Random()
    prng.seed(111111)
    candidates = [generator(prng, {}) for _ in range(pop_size)]
    fitnesses = evaluator(candidates, {})
    population = [inspyred.ec.Individual(candidate=c) for c in candidates]
    for i, f in zip(population, fitnesses):
        i.fitness = f
    parents = population[:pop_size//2]
    offspring = population[pop_size//2:]
    return (prng, candidates, fitnesses, population, parents, offspring)

def test_process(random, population, migrator, output_queue):
    for i in range(9999):
        population = migrator(random, population, {})
    output_queue.put(population)
    

class ArchiverTests(unittest.TestCase):
    def setUp(self):
        self.prng, self.candidates, self.fitnesses, self.population, self.parents, self.offspring = test_set_up(test_generator, test_evaluator_mo)
        
    def test_default_archiver(self):
        new_archive = inspyred.ec.archivers.default_archiver(self.prng, list(self.population), [], {})
        assert not new_archive
        
    def test_best_archiver(self):
        new_archive = inspyred.ec.archivers.best_archiver(self.prng, list(self.population), [], {})
        assert new_archive == [max(self.population)]
        
    def test_adaptive_grid_archiver(self):
        new_archive = inspyred.ec.archivers.adaptive_grid_archiver(self.prng, list(self.population), [], {})
        assert len(new_archive) == 1
        
class MigratorTests(unittest.TestCase):
    def setUp(self):
        self.prng, self.candidates, self.fitnesses, self.population, self.parents, self.offspring = test_set_up(test_generator, test_evaluator)

    def test_default_migration(self):
        migrants = inspyred.ec.migrators.default_migration(self.prng, list(self.population), {})
        assert migrants == self.population
    
    # Multiprocessing migration test may fail simply due to randomness of the migration.
    # It is recommended to run the test multiple times to make sure that it consistently
    # fails before spending time looking for errors.
    def test_multiprocessing_migration(self):
        queue = multiprocessing.Queue()
        migrator = inspyred.ec.migrators.MultiprocessingMigrator()
        populations = [["red", "orange", "yellow", "green", "blue", "indigo", "violet"],
                       [1, 2, 3, 4, 5, 6, 7],
                       ["bashful", "doc", "dopey", "grumpy", "happy", "sleepy", "sneezy"]]
        
        jobs = []
        for pop in populations:
            p = multiprocessing.Process(target=test_process, args=(self.prng, list(pop), migrator, queue))
            p.start()
            jobs.append(p)
        for j in jobs:
            j.join()    
            
        final_pops = []
        while queue.qsize() > 0:
            final_pops.append(set(queue.get()))
        for p in final_pops:
            a = p & set(populations[0])
            b = p & set(populations[1])
            c = p & set(populations[2])
            assert len(a) > 0 and len(b) > 0 and len(c) > 0
        
        
class ReplacerTests(unittest.TestCase):
    def setUp(self):
        self.prng, self.candidates, self.fitnesses, self.population, self.parents, self.offspring = test_set_up(test_generator, test_evaluator)
        self.prng_mo, self.candidates_mo, self.fitnesses_mo, self.population_mo, self.parents_mo, self.offspring_mo = test_set_up(test_generator, test_evaluator_mo)
        self.ec = DummyEC()
        self.ec.num_evaluations = 10
        self.ec.archive = []
        self.ec.archiver = inspyred.ec.archivers.adaptive_grid_archiver
        
    def test_default_replacement(self):
        survivors = inspyred.ec.replacers.default_replacement(self.prng, list(self.population), list(self.parents), list(self.offspring), {})
        assert survivors == self.population
        
    def test_truncation_replacement(self):
        survivors = inspyred.ec.replacers.truncation_replacement(self.prng, list(self.population), list(self.parents), list(self.offspring), {})
        assert len(survivors) == len(self.population) and max(max(self.population), max(self.offspring)) == max(survivors)
        
    def test_steady_state_replacement(self):
        survivors = inspyred.ec.replacers.steady_state_replacement(self.prng, list(self.population), list(self.parents), list(self.offspring), {})
        assert len(survivors) == len(self.population) and all([o in survivors for o in self.offspring])
        
    def test_generational_replacement(self):
        survivors = inspyred.ec.replacers.generational_replacement(self.prng, list(self.population), list(self.parents), list(self.offspring), {})
        assert all([s in self.offspring for s in survivors])
        
    def test_random_replacement(self):
        survivors = inspyred.ec.replacers.random_replacement(self.prng, list(self.population), list(self.parents), list(self.offspring), {})
        assert len(survivors) == len(self.population) and all([o in survivors for o in self.offspring])
    
    def test_plus_replacement(self):
        survivors = inspyred.ec.replacers.plus_replacement(self.prng, list(self.population), list(self.parents), list(self.offspring), {})
        assert len(survivors) == len(self.population) and max(max(self.parents), max(self.offspring)) == max(survivors)
    
    def test_comma_replacement(self):
        survivors = inspyred.ec.replacers.comma_replacement(self.prng, list(self.population), list(self.parents), list(self.offspring), {})
        assert len(survivors) == min(len(self.population), len(self.offspring)) and all([s in self.offspring for s in survivors])
    
    def test_crowding_replacement(self):
        survivors = inspyred.ec.replacers.crowding_replacement(self.prng, list(self.population), list(self.parents), list(self.offspring), {})
        assert len(survivors) == len(self.population) and max(max(self.population), max(self.offspring)) == max(survivors)
    
    def test_simulated_annealing_replacement(self):
        survivors = inspyred.ec.replacers.simulated_annealing_replacement(self.prng, list(self.population), list(self.parents), list(self.offspring), 
                                                                    {'_ec':self.ec, 'max_evaluations':100})
        assert len(survivors) == len(self.parents) and max(max(self.parents), max(self.offspring)) == max(survivors)
    
    def test_nsga_replacement(self):
        survivors = inspyred.ec.replacers.nsga_replacement(self.prng_mo, list(self.population_mo), list(self.parents_mo), list(self.offspring_mo), {})
        assert (len(survivors) == len(self.population_mo) and 
                max(max(self.population_mo), max(self.offspring_mo)) == max(survivors))
    
    def test_paes_replacement(self):
        survivors = inspyred.ec.replacers.paes_replacement(self.prng_mo, list(self.population_mo), list(self.parents_mo), list(self.offspring_mo), {'_ec':self.ec})
        assert (len(survivors) == min(len(self.parents_mo), len(self.offspring_mo)) and 
                max(survivors) == max(max(self.parents_mo), max(self.offspring_mo)))
    
class SelectorTests(unittest.TestCase):
    def setUp(self):
        self.prng, self.candidates, self.fitnesses, self.population, self.parents, self.offspring = test_set_up(test_generator, test_evaluator)        

    def test_default_selection(self):
        parents = inspyred.ec.selectors.default_selection(self.prng, list(self.population), {})
        assert parents == self.population

    def test_truncation_selection(self):
        parents = inspyred.ec.selectors.truncation_selection(self.prng, list(self.population), {})
        assert all([p in parents for p in self.population])

    def test_uniform_selection(self):
        parents = inspyred.ec.selectors.uniform_selection(self.prng, list(self.population), {})
        assert len(parents) == 1 and all([p in self.population for p in parents])

    def test_fitness_proportionate_selection(self):
        parents = inspyred.ec.selectors.fitness_proportionate_selection(self.prng, list(self.population), {})
        assert len(parents) == 1 and all([p in self.population for p in parents])

    def test_rank_selection(self):
        parents = inspyred.ec.selectors.rank_selection(self.prng, list(self.population), {})
        assert len(parents) == 1 and all([p in self.population for p in parents])

    def test_tournament_selection(self):
        parents = inspyred.ec.selectors.tournament_selection(self.prng, list(self.population), {'tournament_size':len(self.population)})
        assert len(parents) == 1 and max(parents) == max(self.population)

class TerminatorTests(unittest.TestCase):
    def setUp(self):
        self.prng, self.candidates, self.fitnesses, self.population, self.parents, self.offspring = test_set_up(test_generator, test_evaluator)
        self.ec = DummyEC()
        self.ec.logger = logging.getLogger('inspyred.test')
        
    def test_default_termination(self):
        t = inspyred.ec.terminators.default_termination(list(self.population), 1, 1, {})
        assert t == True

    def test_diversity_termination(self):
        p = [inspyred.ec.Individual(candidate=[1, 1, 1]) for _ in range(10)]
        t = inspyred.ec.terminators.diversity_termination(list(p), 1, 1, {})
        assert t == True

    def test_average_fitness_termination(self):
        p = [inspyred.ec.Individual(candidate=i.candidate) for i in self.population]
        for x in p:
            x.fitness = 1
        t = inspyred.ec.terminators.average_fitness_termination(list(p), 1, 1, {})
        assert t == True

    def test_evaluation_termination(self):
        t = inspyred.ec.terminators.evaluation_termination(list(self.population), 1, len(self.population), {})
        assert t == True

    def test_generation_termination(self):
        t = inspyred.ec.terminators.generation_termination(list(self.population), 1, 1, {})
        assert t == True

    def test_time_termination(self):
        t = inspyred.ec.terminators.time_termination(list(self.population), 1, 1, {'_ec':self.ec, 'max_time':0})
        assert t == True

class VariatorTests(unittest.TestCase):
    def setUp(self):
        self.prng, self.candidates, self.fitnesses, self.population, self.parents, self.offspring = test_set_up(test_generator, test_evaluator)
        self.ec = DummyEC()
        self.ec.bounder = inspyred.ec.Bounder(0, 1)
        self.ec.population = list(self.population)
        
    def test_default_variation(self):
        offspring = inspyred.ec.variators.default_variation(self.prng, list(self.candidates), {})
        assert offspring == self.candidates

    def test_n_point_crossover(self):
        offspring = inspyred.ec.variators.n_point_crossover(self.prng, list(self.candidates), {'num_crossover_points':3})
        moms = self.candidates[::2]
        dads = self.candidates[1::2]
        dmoms = itertools.chain.from_iterable([[t, t] for t in moms])
        ddads = itertools.chain.from_iterable([[t, t] for t in dads])
        offs = [(offspring[i], offspring[i+1]) for i in range(0, len(offspring), 2)]
        assert (all([x in m or x in d for m, d, o in zip(dmoms, ddads, offspring) for x in o]) and 
                all([(x in o[0] or x in o[1]) and (y in o[0] or y in o[1]) for m, d, o in zip(moms, dads, offs) for x in m for y in m]))

    def test_uniform_crossover(self):
        offspring = inspyred.ec.variators.uniform_crossover(self.prng, list(self.candidates), {})
        moms = self.candidates[::2]
        dads = self.candidates[1::2]
        dmoms = itertools.chain.from_iterable([[t, t] for t in moms])
        ddads = itertools.chain.from_iterable([[t, t] for t in dads])
        offs = [(offspring[i], offspring[i+1]) for i in range(0, len(offspring), 2)]
        assert (all([x in m or x in d for m, d, o in zip(dmoms, ddads, offspring) for x in o]) and 
                all([(x in o[0] or x in o[1]) and (y in o[0] or y in o[1]) for m, d, o in zip(moms, dads, offs) for x in m for y in m]))
    
    def test_blend_crossover(self):
        alpha = 0.1
        offspring = inspyred.ec.variators.blend_crossover(self.prng, list(self.candidates), {'_ec':self.ec, 'blx_alpha':alpha})
        moms = itertools.chain.from_iterable([[t, t] for t in self.candidates[::2]])
        dads = itertools.chain.from_iterable([[t, t] for t in self.candidates[1::2]])
        tests = []
        for mom, dad, off in zip(moms, dads, offspring):
            for m, d, x in zip(mom, dad, off):
                tol = alpha * (max(m, d) - min(m, d))
                tests.append(x >= (min(m, d) - tol) and x <= (max(m, d) + tol))
        assert all(tests)
    
    def test_arithmetic_crossover(self):
        alpha = 0.5
        cands = [[0, 0, 0], [1, 1, 1]]
        offspring = inspyred.ec.variators.arithmetic_crossover(self.prng, list(cands), {'_ec':self.ec, 'ax_alpha':alpha})
        for off in offspring:
            for o in off:
                assert o == 0.5
        
    def test_heuristic_crossover(self):
        offspring = inspyred.ec.variators.heuristic_crossover(self.prng, list(self.candidates), {'_ec':self.ec})
        moms = itertools.chain.from_iterable([[t, t] for t in self.candidates[::2]])
        dads = itertools.chain.from_iterable([[t, t] for t in self.candidates[1::2]])
        tests = []
        for mom, dad, off in zip(moms, dads, offspring):
            for m, d, x in zip(mom, dad, off):
                tests.append(x >= min(m, d) and x <= max(m, d))
        assert all(tests)
    
    def test_simulated_binary_crossover(self):
        alpha = 0.2
        offspring = inspyred.ec.variators.simulated_binary_crossover(self.prng, list(self.candidates), {'_ec':self.ec})
        moms = itertools.chain.from_iterable([[t, t] for t in self.candidates[::2]])
        dads = itertools.chain.from_iterable([[t, t] for t in self.candidates[1::2]])
        tests = []
        for mom, dad, off in zip(moms, dads, offspring):
            for m, d, x in zip(mom, dad, off):
                tol = alpha * (max(m, d) - min(m, d))
                tests.append(x >= (min(m, d) - tol) and x <= (max(m, d) + tol))
        assert all(tests)
    
    def test_laplace_crossover(self):
        alpha = 0.1
        offspring = inspyred.ec.variators.laplace_crossover(self.prng, list(self.candidates), {'_ec':self.ec, 'lx_scale': 0.01})
        moms = itertools.chain.from_iterable([[t, t] for t in self.candidates[::2]])
        dads = itertools.chain.from_iterable([[t, t] for t in self.candidates[1::2]])
        tests = []
        for mom, dad, off in zip(moms, dads, offspring):
            for m, d, x in zip(mom, dad, off):
                tol = alpha * (max(m, d) - min(m, d))
                tests.append(x >= (min(m, d) - tol) and x <= (max(m, d) + tol))
        assert all(tests)
    
    def test_gaussian_mutation(self):
        offspring = inspyred.ec.variators.gaussian_mutation(self.prng, list(self.candidates), {'_ec':self.ec})
        assert(all([x >= 0 and x <= 1 for o in offspring for x in o]))
        
    def test_bit_flip_mutation(self):
        class my_random(object):
            def random(self):
                return 0
        r = my_random()
        my_candidate = [1, 0, 1, 0, 1, 1, 0, 0, 0, 1]
        offspring = inspyred.ec.variators.bit_flip_mutation(r, list([my_candidate]), {})
        assert(all([c != o for c, o in zip(my_candidate, offspring[0])]))
    
    def test_random_reset_mutation(self):
        class my_random(object):
            def random(self):
                return 0
            def choice(self, v):
                return v[0]
        r = my_random()
        b = inspyred.ec.DiscreteBounder([1, 2, 3])
        self.ec.bounder = b
        offspring = inspyred.ec.variators.random_reset_mutation(r, list([[1, 3, 2, 2, 1]]), {'_ec': self.ec})
        assert all([o == 1 for o in offspring[0]])
        
    def test_nonuniform_mutation(self):
        self.ec.num_generations = 0
        offspring = inspyred.ec.variators.nonuniform_mutation(self.prng, list(self.candidates), {'_ec':self.ec, 'max_generations': 10})
        assert(all([x >= 0 and x <= 1 for o in offspring for x in o]))
    
if __name__ == '__main__':
    unittest.main()
        

########NEW FILE########
__FILENAME__ = supplemental_tests
import inspyred
import multiprocessing
import random
import unittest


class AnalysisTests(unittest.TestCase):
    def test_hypervolume(self):
        assert True
        

class BounderTests(unittest.TestCase):
    def test_bounder(self):
        a = inspyred.ec.Bounder(0, 1)
        b = inspyred.ec.Bounder(0, [3, 5])
        c = inspyred.ec.Bounder([1, 2], 3)
        d = inspyred.ec.Bounder([1, 2], [3, 5])
        u = a([-1, 2], {})
        v = b([4, 6], {})
        w = b([-1, 2], {})
        x = c([0, 1], {})
        y = c([4, 4], {})
        z = d([0, 6], {})
        assert u == [0, 1]
        assert v == [3, 5]
        assert w == [0, 2]
        assert x == [1, 2]
        assert y == [3, 3]
        assert z == [1, 5]
        
    def test_discrete_bounder(self):
        a = inspyred.ec.DiscreteBounder([1, 3, 7, 15])
        b = inspyred.ec.DiscreteBounder([0, 1])
        w = a([7, 3, 1, 1, 15], {})
        x = a([2, 5, 9, 11, 13], {})
        y = a([-2, 16, 10, 1.5], {})
        z = b([-1, 0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 2], {})
        assert w == [7, 3, 1, 1, 15]
        assert x == [1, 3, 7, 7, 15]
        assert y == [1, 15, 7, 1]
        assert z == [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]


@inspyred.ec.generators.strategize
def strategize_generator(random, args):
    return [random.uniform(-5, 5) for _ in range(3)]
    
@inspyred.ec.generators.diversify
def diversify_generator(random, args):
    return [random.randint(1, 9) for _ in range(2)]
    
class GeneratorTests(unittest.TestCase):
    def setUp(self):
        self.prng = random.Random()
        self.prng.seed(11111)
        
    def test_strategize(self):
        cand = strategize_generator(self.prng, {})
        n = len(cand) // 2
        tests = [-5 <= c <= 5 for c in cand[:n]]
        tests.extend([0 <= c <= 1 for c in cand[n:]])
        assert all(tests)
        
    def test_diversify(self):
        c = []
        for i in range(10):
            c.append(diversify_generator(self.prng, {}))
        assert c == diversify_generator.candidates
        

@inspyred.ec.utilities.memoize
def f(n, a):
    if n[0] <= 1: return [1]
    return [f([n[0]-1], a)[0] + f([n[0]-2], a)[0]]

@inspyred.ec.utilities.memoize(maxlen=2)
def g(c, a):
    if c[0] <= 1: return [1]
    return [g([c[0]-1], a)[0] + g([c[0]-2], a)[0]]

class UtilityTests(unittest.TestCase):
    def test_memoize(self):        
        elements = [60] * 4
        pool = multiprocessing.Pool(processes=4)
        results = [pool.apply_async(f, ([e], 0)) for e in elements]
        pool.close()
        pool.join()
        tests_f = [r.get()[0] == 2504730781961 for r in results]
        elements = [35] * 4
        pool = multiprocessing.Pool(processes=4)
        results = [pool.apply_async(g, ([e], 0)) for e in elements]
        pool.close()
        pool.join()
        tests_g = [r.get()[0] == 14930352 for r in results]
        assert all(tests_f)
        assert all(tests_g)

    def test_objectify(self):
        def my_fun(x, y, args):
            z = x + y + args['key']
            args['key'] = args['key'] * 2
            return z
        d = {'key': 1}
        f = inspyred.ec.utilities.Objectify(my_fun)
        f.key = 7
        g = inspyred.ec.utilities.Objectify(my_fun)
        g.key = 3
        a = f(9, 2, d)
        b = g(2, 5, d)
        c = my_fun(3, 4, d)
        assert a == 18
        assert b == 10
        assert f.key == 14
        assert g.key == 6
        assert c == 8
        assert d['key'] == 2


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
